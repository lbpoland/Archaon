
// --- MUD Extraction File: mud_extraction_part1.c ---
// Generated: 2025-03-07 07:27:40 UTC
// Source Directory: /mnt/home2/grok/lib
// Purpose: Consolidated LPC .c files for analysis and recreation with FluffOS v2019+
//          and Forgotten Realms theming, replicating discworld.starturtle.net:4242
//          with optimizations (UTF-8, JSON, strict typing).
// Note: Each file break is marked with // --- END [file_path] ---
//
// --- BEGIN [/mnt/home2/grok/lib/std/room/bath_house_inside.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/bath_house_inside.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629324   Available: 13576678
Inodes: Total: 5242880    Free: 4960135
361 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/bath_house_inside.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629324   Available: 13576678
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * Indoors bath house inheritable.
 * @author Taffyd
 * @started 3/05/00 9:55
 */

inherit "/std/room/basic_room";
inherit "/std/room/inherit/bath_house";

/** @ignore yes */
void create() {
    basic_room::create();
    bath_house::create();
} /* create() */

/** @ignore yes */
void init() {
    basic_room::init();
    bath_house::init();
} /* init() */
// --- END [/mnt/home2/grok/lib/std/room/bath_house_inside.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/parcel_inherit.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/parcel_inherit.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629324   Available: 13576678
Inodes: Total: 5242880    Free: 4960135
6128 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/parcel_inherit.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629324   Available: 13576678
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 *
 * Post Office Delivery Inheritable
 * @author Terano
 * @started 28 December, 1998
 */

#include <money.h>
#include <mail.h>
#include <player_handler.h>
#include <player.h>

inherit "/std/room/basic_room";

string loc;
string where;
object shelf;
int cost;

varargs int do_deposit( object *obs, string name, int show_sender );
int do_collect();

/**
 * Makes a shelf and moves it to the room, if there is a shelf, items
 * collected will be moved to it, otherwise they just get moved to the floor
 * @param short The short desc of the shelf
 * @param long The long desc of the shelf
 */
void make_shelf( string short, string long ) {

  shelf = clone_object( "/std/surface" );
  shelf->set_name( short );
  shelf->set_long( long );
  shelf->set_max_weight( 10000 );
  shelf->move( this_object() );
  shelf->add_property( "there", "fixed to one wall" );
  shelf->reset_get();

}

/**
 * Sets the location of the parcel office
 * This is a directory in /save/parcels
 * ie /save/parcels/teranotest/
 * @param _loc location of the post office
 */
void set_location( string _loc ) { loc = _loc; }

/**
 * Sets the cost to send a parcel, in default money units
 * 400 = $1AM
 * @param _cost The cost
 */
void set_cost( int _cost ) { cost = _cost; }

/**
 * What currency to use
 * @param temp The type of currency (ie "Ankh-Morpork")
 */
void set_currency( string temp ) { where = temp; }

/**
 * @ignore
 */
string query_location() { return loc; }

/**
 * @ignore
 */
int query_cost() { return cost; }

/**
 * @ignore
 */
string query_currency() { return where; }

/**
 * @ignore
 */
void init() {
    ::init();


  this_player()->add_command( "deposit", this_object(),
                  "<indirect:object> for <string>",
                  (: do_deposit( $1, $4[1] ) :) );
  this_player()->add_command( "collect", this_object(), "",
                  (: do_collect() :) );

}

/**
 * This method is used by outside objects to send parcels (if they should
 * need to do so).
 * @param obs Objects to deposit (required)
 * @param name Name to go to (required)
 * @param show_sender non-zero to show name of sender in automail (optional)
 */
int deposit_parcel( object *obs, string name, int show_sender ) {
  if ( obs == 0 || name == 0 ) {
    return 0;
  }

  if ( !PLAYER_HANDLER->test_user( name ) )  {
    return -2;
  }

  if ( !sizeof( obs ) ) {
    return 0;
  }

  if ( PLAYER_MULTIPLAYER_HANDLER->member_denied_parcel( this_player()->query_name() ) ) {
    return -4;
  }

  if ( PLAYER_MULTIPLAYER_HANDLER->member_denied_parcel( lower_case(name) ) ) {
    return -5;
  }

  MAIL_PARCEL_HANDLER->deposit( name, this_player()->query_name(),
                   loc, obs );

  AUTO_MAILER->auto_mail( name, "the parcel clerk",
       "Parcel Deposit Notification", "",
       "Please come to the " + loc + " Post Office parcel counter to\n"
       "collect " + ( sizeof( obs ) == 1 ? "a parcel which has" :
       query_num( sizeof( obs ) ) +" parcels which have" ) +
       " been deposited for you" +
       ( show_sender ? " by " + this_player()->query_short() : "" ) + ".\n\n"
       "Due to limited space in our warehouse you have two weeks to collect\n"
       "your parcels, if you do not collect them within this time they will\n"
       "will be destroyed.\n\n   The parcel clerk, " +
       loc + " Post Office.", 0, 0 );

  return 1;

}

/**
 * Do deposit function, mask to do interesting things
 * @param *obs Objects to deposit (required)
 * @param name Name to go to (required)
 * @param show_sender non-zero to show name of sender in automail (optional)
 * @return -5 if user is not allowed to recieve parcels, -4 if sender is not
 * allowed to send parcels, -3 if sender and user are the same person,
 * -2 if no such user, -1 if not enough money, 0 if missing arguments or
 * failed for unknown reason and 1 if successful
 */
varargs int do_deposit( object *obs, string name, int show_sender ) {
  int ret;
  int total_cost;
  object* total_obs;
  object ob;

  total_obs = obs;
  foreach (ob in obs) {
     total_obs += deep_inventory(ob);
  }

  if (sizeof(total_obs) > 20) {
     add_failed_mess("You are depositing too many items.  The maximum is "
                     "20.\n");
     return -6;
  }

  total_cost = cost * sizeof(total_obs);

  if ( this_player()->query_value_in( where ) < total_cost )  {
    add_failed_mess("You do not have enough money to deposit these "
                    "items, you need " +
                    MONEY_HAND->money_value_string(total_cost,
                            query_property("place")) + ".\n");
    return -1;
  }

  if ( lower_case(name) == this_player()->query_name() ) {
    add_failed_mess("You cannot deposit things for yourself!\n");
    return -3;
  }

  ret = deposit_parcel(obs, name, show_sender);
  switch (ret) {
  case 0 :
  case -1 :
  case -2 :
     return ret;
  case -3 :
    add_failed_mess("You cannot deposit things for yourself!\n");
    return -3;
  case -4 :
    add_failed_mess("You are not allowed to deposit parcels.\n");
    return -4;
  case -5 :
    add_failed_mess(upper_case(name)+" is not allowed to recieve parcels.\n");
    return -5;
  case 1 :
     this_player()->pay_money( (mixed *)MONEY_HAND->create_money_array(
                                total_cost, where ), where );

     return 1;
  }
  return ret;
} /* do_deposit() */

/**
 * Collects a parcel if any are here
 * Mask to do interesting things
 * @return 1 if there are parcels, and 0 if there arent
 */
int do_collect() {

  string this_player_name;

  this_player_name = lower_case(this_player()->query_name());

  if( PLAYER_MULTIPLAYER_HANDLER->member_denied_parcel(this_player_name) ) {
    add_failed_mess("You are not allowed to collect things.\n");
    return 0;
  }

  if ( !MAIL_PARCEL_HANDLER->collect( this_player()->query_name(), loc,
                        (shelf) ? shelf : this_object(), 0 ) ) {
    return 0;
  }

  return 1;
} /* do_collect() */

// Jesus, I guess this is the only way.
// -- Taffyd.

void set_shelf( object ob ) {
    shelf = ob;
} /* set_shelf() */

object query_shelf() {
    return shelf;
} /* query_shelf() */
// --- END [/mnt/home2/grok/lib/std/room/parcel_inherit.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/player_housing.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/player_housing.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629322   Available: 13576676
Inodes: Total: 5242880    Free: 4960135
4915 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/player_housing.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629322   Available: 13576676
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is the standard inheritable for a player-owned house room.
 *
 * All you need to do is inherit this file  and call a couple of setup
 * functions and off you go.
 *
 * In addition you will need to register the house with the
 * housing command if you wish the house to be available for sale or rent
 * using the normal processes. Make sure you have permission and have
 * read the help on the housing command before you do this.
 *
 * @example
 * inherit "/std/room/player_housing";
 *
 * void setup() {
 *   set_light(100);
 *   set_theft_handler(HOSPITAL);
 *   set_save_file("/save/player_housing/am/short/flat1");
 *
 *   set_short("front room");
 *   set_base_desc("a small and cosy front room" );
 *   add_surface( "floor", "finished pine board" );
 *   add_surface( "ceiling", "plain plaster" );
 *   add_surface( "north wall", "plain plaster" );
 *   add_surface( "south wall", "plain plaster" );
 *   add_surface( "east wall", "plain plaster" );
 *   add_surface( "west wall", "plain plaster" );
 *   add_exit("out", PATH+"courtyard", "door");
 *   add_exit("north", PATH+"flat1bed", "door");
 * }
 *
 * In the room outside the house you also need to add the following line to
 * make sure the doors from the street to the house get setup correctly (ie.
 * know if the user left the door locked or not and what kind of lock/trap
 * is in use in the door):
 * (PATH+"flat1")->setup_doors();
 *
 * @author Belle, Gototh, Ceres
 */
#include <dirs.h>
#include <housing.h>
#include <login_handler.h>
#include <player_handler.h>

inherit "/std/room/basic_room";
inherit "/std/room/inherit/player_housing";

/** @ignore yes */
void create() {
  add_help_file("player_housing");
  do_setup++;
  basic_room::create();
  player_housing::create();
  do_setup--;
  if ( !do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }
  seteuid("Room");
  add_property("no burial", 1);
  add_property("no teleport", 1);
}

/** @ignore yes
 * Internal function to update the dynamic long description of the room.
 */
string query_long() {
  return player_housing::query_long();
}

/** @ignore yes
 * Just makes sure room exits are relative inside houses and that doors
 * are closed.
 */
int add_exit(string direc, mixed dest, string type) {
  int tmp;

  tmp = ::add_exit(direc, dest, type);
  setup_exit(direc, 1);
  return tmp;
}

/**
 * This method returns the address of the player house.
 * @return the address of this house
 */
string query_address() {
   return HOUSING->query_address(file_name(this_object()));
}

/** @ignore yes
 * Stops positioned objects from showing.  If it has a CURRENT_ROOM_VERB
 * property it's obviously a placed object and shouldn't been seen.
 */
string process_non_living(object *int_non_livings, int start) {
  object *not_positioned;

  not_positioned = player_housing::my_process_non_living(int_non_livings);
  return ::process_non_living(not_positioned, start);
}

/** @ignore yes */
void init() {
  player_housing::init();
  basic_room::init();
}

/** @ignore yes */
void event_exit(object ob, string message, object to) {
  //basic_room::event_exit(ob, message, to);
  player_housing::event_exit(ob, message, to);
}

/** @ignore yes
 * Cleanup could screw us up so we stay loaded.
 */
int query_keep_room_loaded() {
  player_housing::query_keep_room_loaded();
}

/** @ignore yes */
void dest_me() {
  player_housing::dest_me();
  basic_room::dest_me();
}

/**
 * @ignore yes
 * Calls appropriate test_remove() functions and does PK checks for removal
 * of items from this house.
 */
int test_remove(object thing, int flag, mixed dest) {
  object thief;
  mixed *stuff;
  
  if(!basic_room::test_remove(thing, flag, dest))
    return 0;

  thief = this_player();
  if(!thief)
    return player_housing::test_remove(thing, flag, dest);

  // Check for controlled NPCs and find their owner/caster
  if(thief->query_caster())
    thief = find_player(thief->query_caster());
  else if(thief->query_owner())
    thief = thief->query_owner();

  stuff = thing->query_property("dropped");
  
  // Do PK checks for taking this rooms inventory away.
  if(thief &&
     test_save(thing) && PLAYER_HANDLER->test_user(query_owner()) &&
     !this_object()->test_occupier(thief->query_name()) &&
     (!stuff || stuff[0] != thief->query_name())) { 
    log_file("HOUSING_THEFT", "%s: %s stole %s from %s in %s\n",
             ctime( time() )[4..18], (string)thief->query_short(),
             thing->query_short(),
             (string)query_owner(), file_name());
    
    event(this_object(), "theft", thief, this_object(), ({ thing }));
  }

  return player_housing::test_remove(thing, flag, dest);
}

/**
 * @ignore yes
 * Makes sure furniture is saved when its put in this room.
 */
int test_add( object ob, int flag) {
  int retval;
  
  retval = basic_room::test_add(ob, flag);
  if(retval)
    retval = player_housing::test_add(ob, flag);
  return retval;
}
// --- END [/mnt/home2/grok/lib/std/room/player_housing.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/room_save.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/room_save.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629321   Available: 13576675
Inodes: Total: 5242880    Free: 4960135
1438 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/room_save.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629321   Available: 13576675
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * A saving room inheritable.  This handles rooms which save their inventory,
 * or more specifically part of their inventory.
 *
 * Which objects should be saved or not saved can be controlled by overriding
 * test_save.
 *
 * Containers in this room that need to cause it to save its inventory should
 * generate a save event.
 *
 * @see test_save
 * @see event_save
 *
 * @author ceres
 */
#include <move_failures.h>
#include <player.h>

inherit "/std/room/basic_room";
inherit "/std/room/inherit/room_save";
inherit "/std/basic/auto_load";

/** @ignore yes */
void create() {
   do_setup++;
   basic_room::create();
   room_save::create();
   do_setup--;

   if ( !do_setup ) {
     this_object()->setup();
     this_object()->reset();
   }
} /* create() */

/**
 * @ignore yes
 * Makes sure furniture is removed from the save file
 * when its removed from this room.
 */
int test_remove(object thing, int flag, mixed dest) {
  int result;

  result = basic_room::test_remove(thing, flag, dest);

  if(result) {
    room_save::test_remove(thing, flag, dest);
  }
  
  return result;
} /* test_remove() */

/**
 * @ignore yes
 * Makes sure furniture is saved when its put in this room.
 */
int test_add( object ob, int flag) {
  room_save::test_add(ob, flag);
  return basic_room::test_add(ob, flag);
} /* test_add() */

#ifdef DONT_USE
/** @ignore yes */
void dest_me() {
  room_save::dest_me();
  basic_room::dest_me();
}
#endif
// --- END [/mnt/home2/grok/lib/std/room/room_save.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/outside.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/outside.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629320   Available: 13576674
Inodes: Total: 5242880    Free: 4960135
9368 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/outside.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629320   Available: 13576674
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <weather.h>

inherit "/std/room/basic_room";

#define FAST_CLEAN_UP 15
//#define SLOW_CLEAN_UP 180
//#define CLEAN_UP_LOG "clean_up"

nosave int current_day;
nosave object sunlight;
nosave int day_light;
nosave string _climate;
nosave int next_weather_update;
nosave string weather_str;
private nosave string _weather_handler;

// this is for the new call_out system, and the function stuff...
// it incorporates a much faster 'handle' to grab call_outs with.
nosave int callout_handle;
nosave int room_stabilize;
private nosave int room_create_time;
private nosave int _fast_clean_up;

int clean_up_room( int flag );
int query_fast_clean_up();
void set_fast_clean_up(int fast_clean_up);

/**
 * This sets the weather handler that the room will use.
 * @param the handler to use.
 */
void set_weather_handler( string handler ) {
    _weather_handler = handler ;
} /* set_weather_handler */

/**
 * This returns the path to the weather handler currently being used.
 */
string query_weather_handler() {
    return _weather_handler ;
} /* query_weather_handler */

/**
 * This method sets the climate for this room from the standard
 * climate types.
 * @param a climate type string
 * @see /obj/handlers/weather
 */
int set_climate(string climate) {
  if(member_array(climate, CLIMATES) == -1)
    return 0;
  
  _climate = climate;
  return 1;
}

/**
 * This method returns the climate type for this room
 * @return climate string
 * @see /obj/handlers/weather
 */
string query_climate() {
  if(!_climate)
    return DEFAULT_CLIMATE;
  
  return _climate;
}

void set_light_change(string s) { 
    add_property("light change", s); 
} /* set_light_change() */

string query_light_change() { 
    return query_property("light change"); 
} /* query_light_change() */

/**
 * Returns the snow look for the snow item.
 */
string snow_look() {
   return _weather_handler->snow_string(this_object()) + ".";
} /* snow_look() */

/**
 * Returns the rain look for the rain item.
 */
string rain_look() {
   return _weather_handler->rain_string(this_object()) + ".";
} /* rain_look() */

/**
 * Returns the sleet look for the sleet item.
 */
string sleet_look() {
   return _weather_handler->sleet_string(this_object()) + ".";
} /* sleet_look() */

/**
 * Returns the cloud look for the cloud item.
 */
string cloud_look() {
   return _weather_handler->cloud_string(this_object()) + ".";
} /* cloud_look() */

void create() {
  set_fast_clean_up(1);
  do_setup++;
  ::create();
  do_setup--;
  set_room_size( 50 );
  add_property( "location", "outside" );
  add_property( "here", "on the ground" );
  _weather_handler = WEATHER ;

  /*
  add_item("snow", ({ this_object(), "snow_look" }));
  add_item("rain", ({ this_object(), "rain_look" }));
  add_item("sleet", ({ this_object(), "sleet_look" }));
  add_item("cloud", ({ this_object(), "cloud_look" }));
  */
  
  if ( !do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }
  
  room_create_time = time();
  room_stabilize = 0;
} /* create() */

/** @ignore yes */
int query_light() {
  int new_light;

  new_light = ( day_light * (int)_weather_handler->query_darkness
    ( this_object() ) ) / 100;
  if ( new_light != query_my_light() ) {
    ::set_light(new_light);
  }
  return ::query_light();
} /* query_light() */

/** @ingore yes */
int query_visibility() {
   return _weather_handler->query_visibility(this_object());
}

/**
 * This method returns the current level of day light in the room.  The
 * day light is the light level the room is set to if there was full sun
 * and no darkness at all.  Mostly a percentage of this is calculated
 * in the query_light() method.
 * @return the current daylight level
 */
int query_day_light() { return day_light; }

/** @ignore yes */
int set_light( int number ) {
  ::set_light(number);
  day_light = number;
} /* set_light() */

/** @ignore yes */
string long( string word, int dark ) {
   int day_time;
   string ret;
   string obscure;
   mixed bit;

/* No point reinventing the wheel... */
   ret = ::long( word, dark );
   day_time = (int)_weather_handler->query_day( this_object() );
   if ( day_time != current_day ) {
      if ( query_light_change() ) {
         call_other( this_object(), query_light_change(), current_day );
      }
   }
   obscure = this_object()->query_weather_obscured(day_time);
   if ( !day_time )
   {
      bit = query_night_long();
      if (functionp(bit)) {
         bit = evaluate(bit, word, dark);
      }
      ret = replace(ret, "$long$", bit);
      if (!obscure) {
         ret = (string)_weather_handler->query_moon_string() + ret;
      }
   } else {
      bit = query_long();
      if (functionp(bit)) {
         bit = evaluate(bit, word, dark);
      }
      ret = replace( ret, "$long$", bit);
   }
   if ( time() > next_weather_update ) {
      weather_str = _weather_handler->weather_string(this_object(), obscure) +".\n";
      next_weather_update = (int)_weather_handler->next_update();
   }
   return replace(ret, "$weather$",
                  this_player()->colour_event("weather", "%^ORANGE%^")+
                  weather_str+ "%^RESET%^");
} /* long() */

/** @ignore yes */
mixed *stats() {
  return ::stats() + ({
    ({ "day light", day_light, }),
  });
} /* stats() */

/* added by Funtime to catch daylight searches */
/* 31/Aug/1995 */
/* the returned objects should be an array, hence sunlight[0] */
/** @ignore yes */
object *find_inv_match( string word, object looker ) {
  int daylight;

  if((word == "sunlight") || (word == "daylight"))
  {
    daylight = this_object()->query_light();
    /* nighttime - kill the light object as well */
    if(daylight == 0)
    {
      if(sunlight)
      {
        remove_hidden_object(sunlight);
        sunlight->dest_me();
        sunlight = 0;
      }
      return ::find_inv_match( word, looker );
    }

    /* any other strength of light we should have an object of some kind */
    /* see if we have a sunlight object already - if not, create */
    if(!sunlight)
    {
      sunlight = clone_object("/std/object");
      sunlight->set_name("sunlight");
      sunlight->set_weight(0);
      sunlight->reset_get();
/*       sunlight->move(this_object()); */
      sunlight->add_alias("daylight");
      add_hidden_object(sunlight);
    }

    /* see if the daylight strength is high enough */
    if(daylight < 25)
    {
      sunlight->set_long("The light here is currently quite dim.\n");
    } else {
      sunlight->set_long("What do you want to look at the light for?  "+
        "It's... well, light really.\n");
    }
  }

  /* object has been added to the inv of the room, so  */
  /* search the room as normal */

  return ::find_inv_match( word, looker );
} /* find_inv_match() */

/** @ignore yes */
void dest_me() {
  if(sunlight) {
    sunlight->dest_me();
  }
  ::dest_me();
} /* dest_me() */


#ifdef FAST_CLEAN_UP
/*
 * The following code simply detects runthroughs and dests the room
 * if that happens. ie. if the room is empty within a few seconds of being
 * created it will dest itself.
 *
 * Ceres July 1997
 */
/** @ignore yes */
void event_exit(object ob, string message, object to) {
  if(!room_stabilize) {
    remove_call_out(callout_handle);
    callout_handle = call_out("clean_up_room", FAST_CLEAN_UP, 0);
  }
}

/** @ignore yes */
string *query_zones() {
  // monsters call this to move, but may not actually come here,
  // so potential clean_up_room {Laggard}
  if(!room_stabilize)
    callout_handle = call_out("clean_up_room", FAST_CLEAN_UP, 0) ;

  return ::query_zones();
} /* query_zones() */

// use call_out to attempt faster clean up {Laggard}
// this is almost but not quite the same as the preceeding function.
// the differences are not subtle.
/** @ignore yes */
int clean_up_room(int flag) {
  object *obs, ob;
  int elapsed_time = time() - room_create_time;
  
  if(room_stabilize || !query_fast_clean_up() ||
     this_object()->query_keep_room_loaded())
    return 0;
   
  callout_handle = 0 ;

  // We don't cleanup if this room contains any: users, non-living objects,
  // npcs that are not transient, or transients unable to move.
  obs = filter(all_inventory(this_object()),
               (: !living($1) || (userp($1)) ||
                !$1->query_property("transient") ||
                sizeof($1->query_attacker_list()) ||
                $1->cannot_walk() :));

  if(sizeof(all_inventory(this_object())) ||
     elapsed_time > (FAST_CLEAN_UP * 3)) {
    room_stabilize = 1;
    return 1;
  }

  // Move transients back to their hospital for recycling.
  obs = filter(all_inventory(this_object()),
               (: $1->query_property("transient") :));
  foreach(ob in obs)
    if(ob->query_property("hospital"))
      ob->move(ob->query_property("hospital"), "$N wander$s in.",
               "$N wander$s out.");
  
  dest_me();
  return 0;
} /* clean_up_room() */

/**
 * This function allows you to disable the fast clean-up of outside
 * rooms.
 *
 * @see clean_up_room
 * @param number 1 to allow fast clean-up, 0 to disable it
 */
void set_fast_clean_up(int number) {
   _fast_clean_up = number;
} /* set_fast_cleanup() */

/**
 * This function allows you to check whether or not fast clean-up
 * is currently allowed.
 *
 * @return 0 if it is disabled, 1 if it is allowed
 */
int query_fast_clean_up() {
   return _fast_clean_up;
} /* query_fast_cleanup() */
#endif
// --- END [/mnt/home2/grok/lib/std/room/outside.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/newspaper_subscription.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/newspaper_subscription.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629318   Available: 13576672
Inodes: Total: 5242880    Free: 4960135
17610 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/newspaper_subscription.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629318   Available: 13576672
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*
 *
 *$Id*
 *
 */

/**
 * Newspaper subscription room
 * This room handles subscriptions for one specific newspaper.
 * @see /obj/handlers/newspaper
 * @see help:subscription_room
 * @author Wirble
 * @started August 2001
 */

#define USE_LOGIN 1

/** The newspaper-include. */
#include <room/newspaper.h>

/** The include file for moving. */
#include <move_failures.h>

/** The mailer include-file. */
#include <mail.h>

/** The money include-file. */
#include <money.h>

/** The player-handler-include. */
#include <player_handler.h>

/** The number of issues newspaper boxes are purchased with. */
#define ISSUES_PER_BOX 12

inherit "/std/room/basic_room";

/* variables */
private mapping _subscribers;
private string _region;
private string _paper;
private string _parcel;
private nosave string _savefile;


/** @ignore */
void create() {
   ::create();

   add_help_file( "newspaper_subscription" );
   if( !_subscribers ) {
      _subscribers = ([ ]);
   }
} /* void create() */

/**
 * This queries the prices for subscriptions and boxes.
 * @return price per issue to parcel subscribers
 */
int query_price_per_issue_subscriber() {
   int deposit_cost = 400;
   return deposit_cost + ( NEWSPAPER_HANDLER->query_paper_cost( _paper ) * 2 );
} /* query_price_per_issue_subscriber() */

/**
 * This method queries the cost per issue for boxes.
 * @return cost per issue for a box
 */
int query_price_per_issue_box() {
   return NEWSPAPER_HANDLER->query_paper_cost( _paper );
} /* query_price_per_issue_box() */

/**
 * This returns the base cost of the newspaper box.
 * @return the base cost of the newspaper box.
 */
int query_price_newspaper_box() {
   return load_object( NEWSPAPER_SUBSCRIPTION_OB )->query_value() +
           ISSUES_PER_BOX * NEWSPAPER_HANDLER->query_paper_cost( _paper );
} /* query_price_newspaper_box() */

/**
 * This returns the base cost of the international newspaper box.
 * @return the base cost of the international newspaper box.
 */
int query_price_international_newspaper_box() {
   return (load_object( NEWSPAPER_SUBSCRIPTION_OB )->query_value() +
           ISSUES_PER_BOX * NEWSPAPER_HANDLER->query_paper_cost( _paper )) * 2;
} /* query_price_international_newspaper_box() */




/** @ignore */
private void load_me() {
   if( !_savefile ||
       ( file_size( _savefile ) <= 0 && file_size( _savefile + ".o" ) <= 0 ) ) {
      return;
   }
   unguarded( (: restore_object( _savefile + ".o", 1 ) :) );
} /* private void load_me() */


/** @ignore */
private void save_me() {
   if( !_savefile ) {
      return;
   }
   unguarded( (: save_object( _savefile, 1 ) :) );
} /* private void save_me() */

/** @ignore */
void dest_me() {
   save_me();
   ::dest_me();
} /* void dest_me() */

/** @ignore */
private void send_termination_mail( string name, string mess ) {
   object player;

   if( ( player = find_living( name ) ) &&
       environment( player ) ) {
      tell_room( environment( player ),
                 "An imp zips past " + player->the_short() + " screaming \"You "
                 "have mail!\" in its high-pitched voice.\n" );
   }

   AUTO_MAILER->auto_mail( name,
                           _paper,
                           "Your subscription for " + _paper,
                           0,
                           "Greetings.\n"
                           "\n"
                           "Your subscription for " + _paper +
                           " has ended.\n"
                           "\n" +
                           mess + "\n" );
} /* private void send_termination_mail() */

/** @ignore */
private int withdraw_from_account( string name, int price ) {
   string bank;
   int amount = 0;
   int amount_in_account;

   foreach( bank in BANK_HANDLER->query_accounts( name ) ) {
      if( BANK_HANDLER->query_account( name, bank ) >= price ) {
         BANK_HANDLER->adjust_account( name, bank, -price );
         return 1;
      } else {
         amount += BANK_HANDLER->query_account( name, bank );
      }
   }
   if( amount >= price ) {
      foreach( bank in BANK_HANDLER->query_accounts( name ) ) {
         amount_in_account = BANK_HANDLER->query_account( name, bank );
         if( amount_in_account < amount ) {
            amount -= amount_in_account;
            BANK_HANDLER->adjust_account( name, bank, -amount_in_account );
         } else {
            BANK_HANDLER->adjust_account( name, bank, -amount );
            return 1;
         }
      }
   }
   send_termination_mail( name, "You failed to pay for an issue of " + _paper +
                                "." );
   return 0;
} /* private int withdraw_from_account() */


/** @ignore */
private void deliver_issue( string name, int issue ) {
   int* editions;
   object player;
   object ob;

   editions = PLAYER_HANDLER->test_property( name, "Paper " + _paper );
   if( !editions ) {
      editions = ({ });
   }
   if( member_array( issue, editions ) == -1 ) {
      editions += ({ issue });
#ifdef USE_LOGIN
      "/secure/login"->special_add_property( name, "Paper " + _paper,
                                             editions );
#endif
#ifdef USE_PLAYER_HANDLER
      PLAYER_HANDLER->special_add_property( name, "Paper " + _paper,
                                             editions );
#endif 
      NEWSPAPER_HANDLER->add_edition_paper_sold( _paper, issue,
                         NEWSPAPER_HANDLER->query_paper_cost( _paper ) );
   } else {
      NEWSPAPER_HANDLER->add_edition_revenue( _paper, issue,
                         NEWSPAPER_HANDLER->query_paper_cost( _paper ) );
   }
   ob = clone_object( NEWSPAPER_OB );
   ob->set_paper( _paper );
   ob->set_edition( issue );
   if( _parcel ) {
      MAIL_PARCEL_HANDLER->deposit( name, _paper, _parcel, ({ ob }) );
   }
   if( ( player = find_living( name ) ) &&
       environment( player ) ) {
      tell_room( environment( player ),
                 "An imp rushes up to " + player->the_short() + " and squeaks "
                 "something that very much sounds like \"You have mail!\" "
                 "before zipping away again.\n" );
   }
   AUTO_MAILER->auto_mail( name,
                           _paper,
                           "A new issue of " + _paper,
                           0,
                           "Greetings.\n"
                           "\n"
                           "Issue " + issue + " of " + _paper + " has been "
                           "deposited for you at the " + _parcel +
                           " post-office.\n"
                           "\n"
                           "Enjoy.\n" );
} /* private void deliver_issue() */


/**
 * This function has to be called whenever a new issue of the paper is
 * released.
 */
void event_publish_paper(string paper) {
   string name;
   int issues;
   int price;
   int last_issue = NEWSPAPER_HANDLER->query_last_edition_num( _paper );

   if (paper != _paper) {
      return ;
   }

   price = query_price_per_issue_subscriber();

   if( _subscribers ) {
      foreach( name in keys( _subscribers ) ) {
         if( !PLAYER_HANDLER->test_user( name ) ) {
            map_delete( _subscribers, name );
         } else {
            issues = _subscribers[ name ];
            if( issues == -1 ) {
               if( withdraw_from_account( name, price ) ) {
                  deliver_issue( name, last_issue );
               } else {
                  map_delete( _subscribers, name );
               }
            } else if( issues >= 1 ) {
               deliver_issue( name, last_issue );
               _subscribers[ name ]--;
               if( _subscribers[ name ] == 0 ) {
                  map_delete( _subscribers, name );
                  send_termination_mail( name,
                                         "All issues of " + _paper + " that "
                                         "you have paid for have been "
                                         "delivered." );
               }
            }
         }
      }
   }
} /* void publish_issue() */


/**
 * This sets the region the newspaper is in. i.e. Ankh-Morpork or Klatch.  This
 * will be used for determining the correct currency.
 * @param new_region The region to use.
 */
void set_money_place( string new_region ) {
   _region = new_region;
} /* void set_money_place() */

/**
 * This method returns the money place for the newsper.
 * @return the money place for the newspaper
 */
string query_money_place() {
   return _region;
} /* query_money_place() */

/**
 * This sets the paper this particular room is for.
 * @param new_paper The paper's official name with correct capitalization.
 */
protected void set_paper( string new_paper ) {
   if (_paper) {
      NEWSPAPER_HANDLER->remove_newspaper_inform(_paper, file_name(this_object()));
   }
   _paper = new_paper;
   NEWSPAPER_HANDLER->add_newspaper_inform(_paper, file_name(this_object()));
} /* protected void set_paper() */


/**
 * This sets the savefile for the room.
 * @param filename The full filename to use
 */
protected void set_savefile( string filename ) {
   _savefile = filename;
   if (_savefile) {
      load_me();
   }
} /* protected void set_savefile() */


/**
 * This sets the parcel region for the room and thereby determines to which post
 * office the newspapers will be delivered, i.e. Ankh-Morpork.
 * @param parcel_region The region to use.
 */
protected void set_parcel( string parcel_region ) {
   _parcel = parcel_region;
} /* protected void set_parcel() */

/** @ignore */
int do_subscribe( int numbers ) {
   string name;
   int price;
   string mess;

   if( !numbers || !this_player() || numbers < -1 ) {
      return 0;
   }
   name = this_player()->query_name();
   price = query_price_per_issue_subscriber();
   if( !_subscribers ) {
      _subscribers = ([ ]);
   }
   if( !undefinedp( _subscribers[ name ] ) && _subscribers[ name ] == -1 ) {
      add_failed_mess( "You already have a subscription for " + _paper +
                       ", so there is no need to re-subscribe.\n" );
      return 0;
   }
   if( numbers == -1 ) {
      _subscribers[ name ] = -1;
      add_succeeded_mess( ({"You subscribe to " + _paper + ".\n"
                            "Your bank-account(s) will be billed whenever a "
                            "new issue is released, until you unsubscribe.\n",
                            "$N fill$s out a subscription form.\n"
                          }) );
      save_me();
      return 1;
   }
   price *= numbers;
   if( this_player()->query_value_in( _region ) < price ) {
      add_failed_mess( "You cannot afford to pay for this many issues of " +
                       _paper + ".  It would cost you " +
                       MONEY_HAND->money_value_string( price, _region ) +
                       ".\n" );
      return 0;
   }
   if( undefinedp( _subscribers[ name ] ) ) {
      _subscribers[ name ] = numbers;
      if( numbers == 1 ) {
         mess = "one issue ";
      } else {
         mess = numbers + " issues ";
      }
   } else {
      _subscribers[ name ] += numbers;
      if( numbers == 1 ) {
         mess = "an additional issue ";
      } else {
         mess = "an additional " + numbers + " issues ";
      }
   }
   this_player()->pay_money( MONEY_HAND->create_money_array( price, _region ),
                            _region );

   add_succeeded_mess( ({"You subscribe to " + mess + "of " + _paper +
                         " and pay " + MONEY_HAND->money_value_string( price,
                         _region ) + ".\n",
                         "$N fill$s out a subscription form.\n"
                       }) );
   save_me();
   return 1;
} /* int do_subscribe() */


/** @ignore */
int do_unsubscribe() {
   if( undefinedp( _subscribers[ this_player()->query_name() ] ) ) {
      add_failed_mess( "You don't have a subscription for " + _paper +
                       ", so you cannot unsubscribe.\n" );
      return 0;
   }
   map_delete( _subscribers, this_player()->query_name() );
   add_succeeded_mess( ({"You successfully unscubscribe from " + _paper + ".\n",
                         "$N fill$s out a subscription form.\n"
                       }) );
   save_me();
   return 1;
} /* int do_unsubscribe() */


/** @ignore */
int do_buy( int international ) {
   object box;
   int price;


   if( international == 1 ) {
      price = query_price_international_newspaper_box();
   } else {
      price = query_price_newspaper_box();
   }
   if( !this_player() ) {
      return 0;
   }

   if( this_player()->query_value_in( _region ) < price ) {
      add_failed_mess( "You are too poor to afford this.\n" );
      return 0;
   } else {
      this_player()->pay_money( MONEY_HAND->create_money_array(
                                  price, _region ), _region );
      add_succeeded_mess( "$N purchase$s a newspaper box.\n" );
      box = clone_object( NEWSPAPER_SUBSCRIPTION_OB );
      box->set_paper( _paper );
      box->set_international( international );
      box->set_issues_left( ISSUES_PER_BOX );
      box->set_last_issue( NEWSPAPER_HANDLER->query_last_edition_num( _paper ));
      if( box->move( this_player() ) != MOVE_OK ) {
         box->move( environment( this_player() ) );
         write( "You cannot carry the box.  It has been put on the "
                      "floor.\n" );
      }
      return 1;
   }

} /* int do_buy() */


/** @ignore */
int do_check() {
   int i;

   if( !this_player() ) {
      return 0;
   }
   if( undefinedp( _subscribers[ this_player()->query_name() ] ) ) {
      add_succeeded_mess( ({"You have no subscription for " + _paper + ".\n",
                            "$N check$s something on a list.\n"
                          }) );
      return 1;
   }
   i = _subscribers[ this_player()->query_name() ];
   if( i == -1 ) {
      add_succeeded_mess( ({"Your subscription for " + _paper +
                            " will continue until you unsubscribe again.\n",
                            "$N check$s something on a list.\n"
                          }) );
      return 1;
   } else if( i == 1 ) {
      add_succeeded_mess( ({"Your subscription for " + _paper +
                            " will expire after the next issue.\n",
                            "$N check$s something on a list.\n"
                          }) );
      return 1;
   } else {
     add_succeeded_mess( ({ "Your subscription for " + _paper + " covers " + i +
                            " more issues.\n",
                            "$N check$s something on a list.\n"
                         }) );
      return 1;
   }
} /* int do_check() */


/** @ignore */
int do_list( string subscription_type ) {
   string* subscriber_list;
   string name;

   subscriber_list = ({ });
   if( !this_player() || !subscription_type ) {
      return 0;
   }
   if( subscription_type == "all" ) {
      foreach( name in keys( _subscribers ) ) {
         subscriber_list += ({ name });
      }
   } else if( subscription_type == "pre-paid" ) {
      foreach( name in keys( _subscribers ) ) {
         if( _subscribers[ name ] > 0 ) {
            subscriber_list += ({ name });
         }
      }
   } else if( subscription_type == "unlimited" ) {
      foreach( name in keys( _subscribers ) ) {
         if( _subscribers[ name ] == -1 ) {
            subscriber_list += ({ name });
         }
      }
   }
   if( sizeof( subscriber_list ) == 0 ) {
      subscriber_list += ({ "none" });
   }
   add_succeeded_mess( ({"The following people have a this kind of "
                         "subscription for " + _paper + ":\n" +
                         query_multiple_short( subscriber_list ) +
                         "\n",
                         "$N check$s some lists.\n"
                       }) );
   return 1;
} /* int do_list() */

/** @ignore */
void init() {
   string _office;
   object office = 0;

   add_command( "subscribe",
                "[to] <number> [issue|issues] of " + _paper,
                (: do_subscribe( $4[0] ) :) );
   add_command( "subscribe",
                "[to] " + _paper,
                (: do_subscribe( -1 ) :) );
   add_command( "unsubscribe",
                "[from] " + _paper,
                (: do_unsubscribe() :) );
   add_command( "buy",
                "[a] newspaper box",
                (: do_buy( 0 ) :) );
   add_command( "buy",
                "[an] international newspaper box",
                (: do_buy( 1 ) :) );
   add_command( "check",
                "subscription",
                (: do_check() :) );
   /* This if for the listing of the subscriptions */
   if( _office = NEWSPAPER_HANDLER->query_paper_office( _paper ) ) {
      office = load_object( _office );
   }
   if( this_player()->query_creator() ||
       ( office && office->is_editor(this_player()->query_name()) ) ) {
      add_command( "list",
                   "{all|unlimited|pre-paid} subscriptions",
                   (: do_list( $4[0] ) :) );
   }
   /* This is for error-handling */
   if( !this_player()->query_creator() ) {
      return;
   }
   if( !_parcel ) {
      write("%^WHITE%^%^BOLD%^Warning: This room's _parcel - variable "
                   "isn't set.%^RESET%^\n" );
   }
   if( !_region ) {
      write("%^WHITE%^%^BOLD%^Warning: This room's _region - variable "
                   "isn't set.%^RESET%^\n" );
   }
   if( !_paper ) {
      write("%^WHITE%^%^BOLD%^Warning: This room's _paper - variable "
                   "isn't set.%^RESET%^\n" );
   }
      if( !_savefile ) {
      tell_object( this_player(),
                   "%^WHITE%^%^BOLD%^Warning: This room's _savefile - variable "
                   "isn't set.%^RESET%^\n" );
   }


   ::init();
} /* void init() */

// --- END [/mnt/home2/grok/lib/std/room/newspaper_subscription.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/graffbase.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/graffbase.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629313   Available: 13576667
Inodes: Total: 5242880    Free: 4960135
5300 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/graffbase.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629313   Available: 13576667
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: graffbase.c,v 1.1 1998/01/15 01:37:46 ceres Exp $
 *
 * $Log: graffbase.c,v $
 * Revision 1.1  1998/01/15 01:37:46  ceres
 * Initial revision
 *
*/
/*
 * $Locker:  $
 * $Id: graffbase.c,v 1.1 1998/01/15 01:37:46 ceres Exp $
 *
 * $Log: graffbase.c,v $
 * Revision 1.1  1998/01/15 01:37:46  ceres
 * Initial revision
 *
*/
/*
 * $Locker:  $
 * $Id: graffbase.c,v 1.1 1998/01/15 01:37:46 ceres Exp $
 *
 * $Log: graffbase.c,v $
 * Revision 1.1  1998/01/15 01:37:46  ceres
 * Initial revision
 *
*/
/*
 * $Locker:  $
 * $Id: graffbase.c,v 1.1 1998/01/15 01:37:46 ceres Exp $
 *
 * $Log: graffbase.c,v $
 * Revision 1.1  1998/01/15 01:37:46  ceres
 * Initial revision
 *
*/
/* This is the temporary and hacked version of Taniwha's graffiti base code.
 * The original files can be found in /w/hobbes/misc/graffiti/
 * Based on /obj/misc/quill
 * Taniwha, 1997
 */

#include <language.h>
// Property to add to an object to allow scrawling

#define GRAFFITI "graffiti"

#define ETP environment(this_player())
#define TO this_object()


object writing_on;
string type;
object old;
string olds;

/* Functions to override in inheriting objects */
string query_drawingwith(); // name of thing doing the drawing
int do_check();  // do we have the "pen and paper"
int done_check(); // Clean uo routine, break chalk etc

string query_drawingwith() { return "something"; }
int do_check() { return 0; } // fail
int done_check() { return 0; }


void init() {
 this_player()->add_command( "scrawl", this_object(), "with charcoal on wall");
 this_player()->add_command( "scrawl", this_object(), "on wall with charcoal");
} /* init() */

int do_scrawl( object *things ) {
    string language;
   /* if(!this_object()->do_check() ) return 0;*/
    if ( !ETP->query_property( GRAFFITI) ) {
        this_player()->add_failed_mess( this_object(), "You can't scrawl on "+
          "this wall.\n");
        return 0;
    }
    language = (string)this_player()->query_current_language();
    if ( !LANGUAGE_HAND->query_language_written( language ) ) {
        this_player()->add_failed_mess( this_object(), "You can't scrawl on "
          "a wall when you're not using a language that can be "+
          "scrawling on a wall with.\n",({writing_on}));
        return 0;
    }

    if(( old = present("graffiti",ETP)) && !interactive(old))
    {
        olds = old->query_property("graffiti");
    }
    if ( writing_on ) {
        this_player()->add_failed_mess( this_object(), "The writing "+
          "spot seems to be busy at the moment.\n",
          ({writing_on}));
        return 0;
    }
    this_player()->add_succeeded_mess( this_object(), ({"You start scrawling "+
      "on a wall with some charcoal.\n", "$N starts scrawling on a wall with "
      "some charcoal.\n"}) );
    writing_on = ETP;
    call_out( "begin_writing", 0, this_player() );
    return 1;
} /* do_write() */

void begin_writing( object writer ) {
    if ( !writer ) {
        writing_on = 0;
        return;
    }
    writer->do_edit( 0, "end_writing" );
} /* begin_writing() */

void end_writing( string words ) {
    string language;
    string extra;
    if ( !words || ( words == "" ) ) {
        write( "You don't scrawl anything on "+
         "the wall.\n");
        say( (string)this_player()->the_short() +" doesn't "+
          "scrawl anything after all.\n" );
        writing_on = 0;
        return;
    }
    language = (string)this_player()->query_current_language();
    if ( !LANGUAGE_HAND->query_language_written( language ) ) {
        write( "You seem to have changed to using a non-written language.\n" );
        say( (string)this_player()->the_short() +" seems "+
          "linguistically-challenged.\n" );
        writing_on = 0;
        return;
    }
    if ( !writing_on ) {
        write( "You seem to have lost what you were scrawling on.\n" );
        say( (string)this_player()->the_short() +" looks around "+
          "in puzzlement.\n" );
        return;
    }
    if (  writing_on != ETP ) {
        write("The wall seems to have run away from you.\n" );
        say( (string)this_player()->the_short() +" looks like "+
          (string)this_player()->query_pronoun() +"'s lost something.\n" );
        writing_on = 0;
        return;
    }
    /*   
       writing_on->add_read_mess( words, type, language, 0 );
    */
    if(!stringp(olds)) olds = "";
    words = olds +"\n"+"%^MAGENTA%^Scrawled with rough charcoal, you "
             "read the words:%^RESET%^\n\n"+
    words;
    if(old) old->move("/room/rubbish");
    extra = TO->extra_stuff();
    if(!strlen(extra))extra = "Some disreputable character has scrawled "
        "graffiti over this wall.  You may be able to \"read\" it.\n";
    ETP->add_sign(
      extra,
      words,	
      "graffiti",
      ({"graffiti","scrawl"}),
      language
    );
    old = present("graffiti",ETP);
    old->add_property("determinate","some ");
    old->add_property("there","on the wall");
    if(old) old->add_property("graffiti",words);

    write( "As you finish scrawling on the wall, the piece of charcoal "
           "breaks.\n" );
    say( (string)this_player()->the_short() +" finishes scrawling "+
      "on the wall.\n" );
    this_object()->done_check();
    writing_on = 0;
} /* end_writing() */
// --- END [/mnt/home2/grok/lib/std/room/graffbase.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/npcroom.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/npcroom.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629312   Available: 13576666
Inodes: Total: 5242880    Free: 4960135
3993 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/npcroom.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629312   Available: 13576666
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: npcroom.c,v 1.1 1998/01/15 01:37:46 ceres Exp $
 *
 * $Log: npcroom.c,v $
 * Revision 1.1  1998/01/15 01:37:46  ceres
 * Initial revision
 *
*/
/*
 * $Locker:  $
 * $Id: npcroom.c,v 1.1 1998/01/15 01:37:46 ceres Exp $
 *
 * $Log: npcroom.c,v $
 * Revision 1.1  1998/01/15 01:37:46  ceres
 * Initial revision
 *
*/
/*
 * $Locker:  $
 * $Id: npcroom.c,v 1.1 1998/01/15 01:37:46 ceres Exp $
 *
 * $Log: npcroom.c,v $
 * Revision 1.1  1998/01/15 01:37:46  ceres
 * Initial revision
 *
*/
/* Inheritable object to make the functions to handles the creation of objects
 * and npc's in a room.
 * reset_objects is an array of the objects 
 * reset_definitions is an array of the definitions of how these objects
 * should be cloned
 * the value of a reset definition is an array containig the following:
 *   ({ flag, delay, clone_info, entry_mess })
 * flag can be REMOVABLE, FIXED or UNIQUE defining whether a new item
 *   should be cloned if this one is removed from the room, only cloned if
 *   this one is destructed, or as fixed, but it's the master objects that's
 *   put here(mainly for unique npc's with their own file).
 * delay is the delay in seconds between reset being called and the cloning  
 * clone_info can be a string, in which case it's considered to be the
 *   filename of the thing to put here, or a function pointer meaning
 *   it's a function returning the thing.
 * entry_mess is the parameter given to move when moving the item to this 
 *   room.
 */

#define FLAG 0
#define DELAY 1
#define CLONE 2
#define MESS 3
#define REMOVABLE 0
#define FIXED 1
#define UNIQUE 2

nosave mixed  *reset_definitions;
nosave object *reset_objects;

void add_cloned_object( int flag, int delay, mixed clone_info, 
                       string entry_mess ) {
   if ( !sizeof( reset_definitions ) )
      reset_definitions = ({ ({ flag, delay, clone_info, entry_mess }) });
   else
      reset_definitions += ({ ({ flag, delay, clone_info, entry_mess }) });
} /* add_cloned_object() */

mixed *query_cloned_objects() {
   return reset_objects + ({ });
} /* query_cloned_objects() */

mixed *query_cloned_definitions() {
   return reset_definitions + ({ });
} /* query_cloned_definitions() */

private object make_clone( mixed func ) {
   if ( stringp( func ) ) {
      return clone_object( func );
   } else if ( functionp( func ) ) {
      return evaluate( func );
   } else
      return 0;
} /* make_clone() */

private void make_object( int i ) {
   switch ( reset_definitions[ i ][ FLAG ] ) {
    case REMOVABLE:
    case FIXED:
      reset_objects[ i ] = make_clone( reset_definitions[ i ][ CLONE ] );
      reset_objects[ i ]->move( this_object(),
            reset_definitions[ i ][ MESS ] );
      break;
    case UNIQUE:
      if ( !stringp( reset_definitions[ i ][ CLONE ] ) )
         return;
      reset_definitions[ i ][ CLONE ]->move( this_object(),
            reset_definitions[ i ][ MESS ] );
      reset_objects[ i ] = find_object( reset_definitions[ i ][ CLONE ] );
   }
} /* make_object() */

void reset() {
   int i;
   
   if ( !sizeof( reset_definitions ) )
      return;
   if ( !sizeof( reset_objects ) )
      reset_objects = allocate( sizeof( reset_definitions ) );
   for ( i = sizeof( reset_definitions ); i--; ) {
      switch ( reset_definitions[ i ][ FLAG ] ) {
       case REMOVABLE:
         if ( !reset_objects[ i ] || 
             ( environment( reset_objects[ i ] ) != this_object() ) ) {
            if ( reset_definitions[ i ][ DELAY ] >= 0 )
               call_out( "make_object", reset_definitions[ i ][ DELAY ], i );
            else
               make_object( i );
         }
         break;
       case FIXED:
       case UNIQUE:
         if ( !reset_objects[ i ] ) {
            if ( reset_definitions[ i ][ DELAY ] >= 0 )
               call_out( "make_object", reset_definitions[ i ][ DELAY ], i );
            else
               make_object( i );
         }
      }
   }
} /* reset() */
// --- END [/mnt/home2/grok/lib/std/room/npcroom.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/controller/topography/area.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/controller/topography/area.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629311   Available: 13576665
Inodes: Total: 5242880    Free: 4960135
15066 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/controller/topography/area.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629311   Available: 13576665
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker: pinkfish $
 * $Id: area.c,v 1.3 2002/02/28 23:26:06 rhinehold Exp pinkfish $
 *
 *
 */

/*
** area.c - base object for a terrain-like set of rooms.
*/

#include <dirs.h>
#include <image.h>

inherit "/std/room";

mapping direction_bits = ([
    "north": 1,
    "northeast": 2,
    "east": 4,
    "southeast": 8,
    "south": 16,
    "southwest": 32,
    "west": 64,
    "northwest": 128,
    "up": 256,
    "down": 512,
]);

class AREA_INFO {
  string base;
  int *origin;    // Origin of area; room centers are 2*size offset from this
  int *size;      // Size of each room
  mixed *bbox;    // Keeps track of bounding box of area (absolute)
  mixed *vertices;  // Outline of area (absolute)
  class IMAGE_INFO height; // Height map of area
  class IMAGE_INFO exits;  // Map of exits (for twisty little passages :)
} /* AREA_INFO */

private int dbg_lvl = 0;
private string debugger = "jeremy";
private string _handler;

private class AREA_INFO *areas = ({ });

private mapping room_cache = ([ ]);
private mapping area_cache = ([ ]);

/**
 * This method sets the handler of the topographic region.
 * @param handler the handler to set
 */
void set_handler(string handler) {
   _handler = handler;
}

/**
 * This method returns the handler of the topographic region.
 * @return the handler of the whole region
 */
string query_handler() {
   return _handler;
} /* query_handler() */

/**
 * This method sets the creator to whom debugging messages are sent.
 * @param d name of creator
 */
void set_debugger(string s) { debugger = s; }

/**
 * This method returns the name of the creator to whom debugging messages
 * are sent.
 * @return name of creator
 */
string query_debugger() { return debugger; }

/**
 * This method sets the level of debugging messages printed.
 * @param l debugging level (0 is off)
 */
void set_debug_level(int l) { dbg_lvl = l; }

/**
 * This method returns the current debugging level.
 * @return current debug level (0 is off)
 */
int query_debug_level() { return dbg_lvl; }

/**
 * @ignore
 * For debugging only
 */
mixed query(string s) { return fetch_variable(s); }

void set_base(int i, string s) { areas[i]->base = s; }
string query_base(int i) { return areas[i]->base; }

void set_origin(int i, int *o) { areas[i]->origin = copy(o); }
int *query_origin(int i) { return copy(areas[i]->origin); }

void create() {

  do_setup++;
  ::create();
  do_setup--;

  // Keeps us from being unloaded (one of the drawbacks of making the
  // handler a room; I wonder if that was a smart move...).
  set_keep_room_loaded(1);

  if ( !do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }
} /* create() */

// Quantize coord to origin in area a
int *quantize_to_origin(int *coord_r, int a) {
  int size2, i, *coord_q;

  coord_q = allocate(3);
  for (i = 0; i < 3; i++) {
    size2 = areas[a]->size[i] * 2;
    if (coord_r[i] < areas[a]->origin[i]) {
      coord_q[i] = coord_r[i] - areas[a]->size[i];
    } else {
      coord_q[i] = coord_r[i] + areas[a]->size[i];
    }
    coord_q[i] = ((coord_q[i] - areas[a]->origin[i]) / size2) * size2
      + areas[a]->origin[i];
  }
  return coord_q;
} /* quantize_to_origin() */

void set_size(int i, mixed s) {
  if (intp(s)) {
    areas[i]->size = ({ s, s, s });
  } else if (arrayp(s) && (sizeof(s) == 3)) {
    areas[i]->size = copy(s);
  } else {
    error("Illegal size; must be int or 3-element array.\n");
  }
} /* set_size() */

//int *query_size(int i) { return copy(areas[i]->size); }

varargs void set_height_map(int i, string map_file, int rle) {
  int *nw;

  areas[i]->height = IMAGE_HANDLER->load_image(map_file, rle);
  if (arrayp(areas[i]->bbox)) {
    // Set up coordinate of NW corner
    nw = copy(areas[i]->bbox[0]);
    nw[0] = areas[i]->bbox[1][0] - 1;
    nw[1] += 1;
    nw[2] += 1;
    areas[i]->height->nw_coord = quantize_to_origin(nw, i);
  }
}

varargs void set_exits_map(int i, string map_file, int rle) {
  int *nw;

  areas[i]->exits = IMAGE_HANDLER->load_image(map_file, rle);
  if (arrayp(areas[i]->bbox)) {
    // Set up coordinate of NW corner
    nw = copy(areas[i]->bbox[0]);
    nw[0] = areas[i]->bbox[1][0] - 1;
    nw[1] += 1;
    nw[2] += 1;
    areas[i]->exits->nw_coord = quantize_to_origin(nw, i);
  }
}

int new_area() {
  areas += ({ new(class AREA_INFO) });
} /* new_area() */

// Note: this must be done after the origin is set
void set_vertices(int a, mixed *vs) {
  int v, i;

  if (!arrayp(areas[a]->origin)) {
    error("Origin unset - setting to (0,0,0).\n");
    areas[a]->origin = ({ 0, 0, 0 });
  }
  areas[a]->vertices = copy(vs);
  // Initialize bounding box
  areas[a]->bbox = ({ copy(vs[0]), copy(vs[0]) });
  for (i = 0; i < 3; i++) {
    areas[a]->bbox[0][i] += areas[a]->origin[i];
    areas[a]->bbox[1][i] += areas[a]->origin[i];
  }
  // Change to absolute coordinates
  for (v = 0; v < sizeof(areas[a]->vertices); v++) {
    for (i = 0; i < 3; i++) {
      areas[a]->vertices[v][i] += areas[a]->origin[i];
      if (areas[a]->vertices[v][i] < areas[a]->bbox[0][i]) {
        areas[a]->bbox[0][i] = areas[a]->vertices[v][i];
      } else if (areas[a]->vertices[v][i] > areas[a]->bbox[1][i]) {
        areas[a]->bbox[1][i] = areas[a]->vertices[v][i];
      }
    }
  }
} /* set_vertices() */

int in_bbox(int *coord, mixed *bbox) {
  if ((coord[0] < bbox[0][0]) || (coord[0] > bbox[1][0])) {
    return 0;
  }
  if ((coord[1] < bbox[0][1]) || (coord[1] > bbox[1][1])) {
    return 0;
  }
  if ((coord[2] < bbox[0][2]) || (coord[2] > bbox[1][2])) {
    return 0;
  }
  return 1;
} /* in_bbox() */

int in_area(int a, int *v) {
  // This counts how many times a line from v straight north crosses
  // the edges.  If it's odd, we're in the area.
  // REF: Foley, J.D. and A. Van Dam, Fundamentals of Interactive Computer
  //      Graphics, Addison-Wesley, 1982, pp 457-458.
  // This may be more complicated than it has to be.  I found a much simpler
  // implementation in C, but I haven't verified it yet.
  int crossings, i, i0, i1, de, int_n, below_vertex;
  mixed *vs;

  if (!in_bbox(v, areas[a]->bbox)) {
    //printf("Outside (bbox)...\n");
    return 0;
  }
  // This looks complicated, but most of the time it shouldn't get past
  // the first four tests.
  vs = allocate(2);
  for (i = 0; i < sizeof(areas[a]->vertices); i++) {
    below_vertex = 0;
    vs[0] = areas[a]->vertices[i];
    if (i < sizeof(areas[a]->vertices)-1) {
      vs[1] = areas[a]->vertices[i+1];
    } else {
      vs[1] = areas[a]->vertices[0];
    }
    if ((v[1] < vs[0][1]) && (v[1] < vs[1][1])) {
      //printf("Outside (west)...\n");
      continue;
    }
    if ((v[1] > vs[0][1]) && (v[1] > vs[1][1])) {
      //printf("Outside (east)...\n");
      continue;
    }
    if ((v[0] > vs[0][0]) && (v[0] > vs[1][0])) {
      //printf("Outside (north)...\n");
      continue;
    }
    if ((v[0] < vs[0][0]) && (v[0] < vs[1][0])) {
      // We're below the line segment.
      if (v[1] != vs[0][1]) {
        // We're not below the first vertex...
        if (v[1] != vs[1][1]) {
          // We're not below the second vertex, so we cross the line.
          crossings++;
        }
        // Don't count hitting the vertex on the second point (see below)
        continue;
      } else {
        // Need to check whether to count the vertex as a crossing.
        below_vertex = 1;
      }
    }
    // Okay, now we get into some fuzzier cases.  We're somewhere in the
    // bounding box of the line segment, or we hit a vertex.
    if (vs[0][1] == vs[1][1]) {
      // Don't count vertical lines unless we're sitting right on it.
      if (!below_vertex) {
        return 1;
      }
      continue;
    }
    if ((v[0] == vs[0][0]) && (v[1] == vs[0][1])) {
      // We're on a vertex - we're "in".
      return 1;
    }
    if ((vs[0][0] == vs[1][0]) && !below_vertex) {
      // We're on a horizontal line - we're "in".
      return 1;
    }
    // Vertices are tough...we need to find if it's concave or convex
    if (v[1] == vs[1][1]) {
      // Don't count vertex hit on second point (or else it'll get
      // counted twice).
      continue;
    }
    if (v[1] == vs[0][1]) {
      if (v[0] > vs[0][0]) {
        // We're above the first vertex.  No intersection.
        continue;
      }
      // Find closest bend on one side...
      i0 = i;
      while (areas[a]->vertices[i0][1] == v[1]) {
        i0--;
        if (i0 < 0) i0 = sizeof(areas[a]->vertices) - 1;
      }
      // Find closest bend on the other side...
      i1 = i;
      while (areas[a]->vertices[i1][1] == v[1]) {
        i1++;
        if (i1 >= sizeof(areas[a]->vertices)) i1 = 0;
      }
      // This counts as at least one hit.
      crossings++;
      if (((areas[a]->vertices[i0][1] > v[1]) &&
           (areas[a]->vertices[i1][1] > v[1])) ||
          ((areas[a]->vertices[i0][1] < v[1]) &&
           (areas[a]->vertices[i1][1] < v[1]))) {
        // Concave/convex count as 2 crossings.
        crossings++;
      }
      continue;
    }
    // Nothing left to do but find the intersection
    de = vs[1][1] - vs[0][1];
    int_n = ceil(to_float(vs[1][0] - vs[0][0])*(v[1] - vs[0][1])/de
                 + vs[0][0] + 0.5);
    if (int_n > v[0]) {
      crossings++;
    }
  }
  // LSB indicates if it's odd.
  return (crossings & 1);
} /* in_area() */

object clone_room(int a, int *coord_q, string coord_s) {
  int i, j, e, bit;
  string dir;
  object room;

  room = clone_object(areas[a]->base);
  room_cache[coord_s] = room;
  area_cache[coord_s] = a;
  room->set_room_size(areas[a]->size);
  // TODO: add height map stuff
  room->set_co_ord(coord_q);
  if (areas[a]->exits) {
    // Add exits to room according to map
    i = (areas[a]->origin[0] - coord_q[0])/(2*areas[a]->size[0]);
    j = (coord_q[1] - areas[a]->origin[1])/(2*areas[a]->size[1]);
    if ((i < areas[a]->exits->size[0]) && (j < areas[a]->exits->size[1])
        && (i >= 0) && (j >= 0)) {
      e = areas[a]->exits->image[i][j];
      foreach (dir, bit in direction_bits) {
        if (e & bit) {
          // TODO: should put a field for the exit type in the class...
          room->add_exit(dir, "", "path");
        }
      }
      // This is a bit of a hack, but it's easy.
      room->add_property("image_cell", ({ i, j }));
    }
  }
  // Other room initialization TBD.
  return room;
}

object find_room_at_coord(int *coord) {
  int a, ac, *coord_q;
  string coord_s;
  object room;

  // Check to see if it's in the cache as-is.
  coord_s = sprintf("%d:%d:%d", coord[0], coord[1], coord[2]);
  if (objectp(room = room_cache[coord_s])) {
    return room;
  }
  if (!undefinedp(ac = area_cache[coord_s])) {
    // There used to be a room here.
    return clone_room(ac, coord, coord_s);
  }
  for (a = 0; a < sizeof(areas); a++) {
    // Quantize coordinates to room centers for this area.
    coord_q = quantize_to_origin(coord, a);
    // Check the cache again.
    coord_s = sprintf("%d:%d:%d", coord_q[0], coord_q[1], coord_q[2]);
    if (objectp(room = room_cache[coord_s])) {
      return room;
    }
    if (!undefinedp(ac = area_cache[coord_s])) {
      // There used to be a room here.
      return clone_room(ac, coord_q, coord_s);
    }
    if (!in_area(a, coord_q)) {
      continue;
    }
    return clone_room(a, coord_q, coord_s);
  }
  return 0;
} /* find_room_at_coord() */

object find_room_at_exit(object r, int *d, string direc) {
  int a, ac, i, *coord, *coord_r, *coord_q;
  string coord_s;
  object room;
  mixed size_r;

  if (dbg_lvl > 0) {
    tell_creator(debugger, "%s::find_room_at_exit()\n"
                 "  r: %O\n"
                 "  d: %O\n"
                 "  direc: %O\n",
                 file_name(this_object()), r, d, direc);
  }
  if (!arrayp(d)) {
    return 0;
  }
  coord = r->query_co_ord();
  // Some rooms (like milestones) have "fake" sizes.
  size_r = r->query_actual_room_size();
  if (!arrayp(size_r)) {
    size_r = r->query_room_size();
    if (!arrayp(size_r)) {
      // Must be a single int for all 3 dimensions.
      size_r = ({ size_r, size_r, size_r });
    }
  }
  coord_r = allocate(3);
  for (a = 0; a < sizeof(areas); a++) {
    for (i = 0; i < 3; i++) {
      coord_r[i] = coord[i] + (size_r[i] + areas[a]->size[i]) * d[i];
    }
    // Use the drivers virtual mapping stuff to do the cacheing for us.
    coord_s = sprintf("%d:%d:%d", coord_r[0], coord_r[1], coord_r[2]);
    return load_object(_handler + ":" + coord_s);
#if 0
    // Check to see if it is (or has been) in the cache as-is.
    if (objectp(room = room_cache[coord_s])) {
      if (dbg_lvl > 0) {
        tell_creator(debugger, "%s::find_room_at_exit()\n"
                 "  found room %O cached at %s...\n",
                 file_name(this_object()), room, coord_s);
      }
      return room;
    }
    if (!undefinedp(ac = area_cache[coord_s])) {
      // There used to be a room here.
      if (dbg_lvl > 0) {
        tell_creator(debugger, "%s::find_room_at_exit()\n"
                 "  found area %O cached at %s...\n",
                 file_name(this_object()), ac, coord_s);
      }
      return clone_room(ac, coord_r, coord_s);
    }
    coord_q = quantize_to_origin(coord_r, a);
    // Check the cache again.
    coord_s = sprintf("%d:%d:%d", coord_q[0], coord_q[1], coord_q[2]);
    if (objectp(room = room_cache[coord_s])) {
      return room;
    }
    if (!undefinedp(ac = area_cache[coord_s])) {
      // There used to be a room here.
      return clone_room(ac, coord_q, coord_s);
    }
    if (!in_area(a, coord_q)) {
      continue;
    }
    return clone_room(a, coord_q, coord_s);
#endif
  }
  return 0;
} /* find_room_at_exit() */

// This is a testing convenience function
int goto_room_at_coord(int *coord) {
  return this_player()->move_with_look(find_room_at_coord(coord));
} /* goto_room_at_coord() */

int goto_room_at_exit(int *d, string direc) {
  return this_player()->move_with_look(find_room_at_exit(
                        environment(this_player()), d, direc));
}

void print_images(int a) {
  if (areas[a]->height) {
    printf("-------- Height:\n");
    IMAGE_HANDLER->print_image(areas[a]->height);
  }
  if (areas[a]->exits) {
    printf("-------- Exits:\n");
    IMAGE_HANDLER->print_image(areas[a]->exits);
  }
}

void print_map(int a) {
  int s, e;
  string l = "";
  class IMAGE_INFO exits;

  if (areas[a]->exits) {
    exits = areas[a]->exits;
    for (s = 0; s < exits->size[1]; s++) {
      for (e = 0; e < exits->size[0]; e++) {
        l += (exits->image[s][e] & 128)?"\\":" ";
        l += (exits->image[s][e] & 1)  ?"|":" ";
        l += (exits->image[s][e] & 2)  ?"/":" ";
      }
      l += "\n";
      for (e = 0; e < exits->size[0]; e++) {
        l += (exits->image[s][e] & 64) ?"-":" ";
        l += "*";
        l += (exits->image[s][e] & 4)  ?"-":" ";
      }
      l += "\n";
      for (e = 0; e < exits->size[0]; e++) {
        l += (exits->image[s][e] & 32) ?"/":" ";
        l += (exits->image[s][e] & 16) ?"|":" ";
        l += (exits->image[s][e] & 8)  ?"\\":" ";
      }
      l += "\n";
    }
    write(l);
  }
}
// --- END [/mnt/home2/grok/lib/std/room/controller/topography/area.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/controller/topography/topography.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/controller/topography/topography.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629307   Available: 13576661
Inodes: Total: 5242880    Free: 4960135
14280 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/controller/topography/topography.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629307   Available: 13576661
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker: pinkfish $
 * $Id: topography.c,v 1.9 2002/02/28 23:13:52 pinkfish Exp pinkfish $
 *
 *
 */

/*
 * $Locker: pinkfish $
 * $Id: topography.c,v 1.9 2002/02/28 23:13:52 pinkfish Exp pinkfish $
 *
 *
 */

/*
** topography.c - the top-level handler that pulls together the areas,
**             irooms, and fixed rooms.
*/
/**
 * This is the top-level handler for the topography system.
 */
#include <dirs.h>
#include "path.h"

//inherit "/std/room";
inherit "/std/basic/setup";

class bounding_box {
   int* topleft;
   int* bottomright;
}

class FIXED_INFO {
  string path;
  object ob;
  int *coord;
  mixed bbox;
}

private mapping opposites = ([
  "north": "south", "south": "north", "west": "east",
  "east": "west", "northeast": "southwest", "southwest": "northeast",
  "northwest": "southeast", "southeast": "northwest", "up": "down",
  "down": "up"
]);

private int _dbg_lvl = 0;
private string _debugger;
private object *_area_handlers = ({ });
private object *_iroom_handlers = ({ });
private class FIXED_INFO *_fixed_rooms = ({ });
private mapping _fixed_room_index = ([ ]);
private class bounding_box _topo_box;

/**
 * This method sets the creator to whom debugging messages are sent.
 * @param d name of creator
 */
void set_debugger(string s) { _debugger = s; }

/**
 * This method returns the name of the creator to whom debugging messages
 * are sent.
 * @return name of creator
 */
string query_debugger() { return _debugger; }

/**
 * This method sets the level of debugging messages printed.
 * @param l debugging level (0 is off)
 */
void set_debug_level(int l) { _dbg_lvl = l; }

/**
 * This method returns the current debugging level.
 * @return current debug level (0 is off)
 */
int query_debug_level() { return _dbg_lvl; }

/**
 * @ignore
 * For debugging only
 */
//mixed query(string s) { return fetch_variable(s); }

void create() {

  //inc_setup();
  //::create();
  //dec_setup();

  do_setup();
} /* create() */

/**
 * This method returns the bounding box for the topography.
 * @return the bounding box
 */
class bounding_box query_bounding_box() {
   return _topo_box;
} /* query_bounding_box() */

/**
 * Checks to see if the co-ordinate is in the bounding box.
 * @param coord the co-ordinate to check
 * @param bbox the bounding box
 * @return 1 if it is, 0 if not
 */
int in_bbox(int *coord, class bounding_box bbox) {
  if ((coord[0] < bbox->topleft[0]) || (coord[0] > bbox->bottomright[0])) {
    return 0;
  }
  if ((coord[1] < bbox->topleft[1]) || (coord[1] > bbox->bottomright[1])) {
    return 0;
  }
  return 1;
} /* in_bbox() */

/**
 * This method makes a bounding box for a specified co ordinate and
 * a polygon.
 * @param coord the co-ordinate to get the box from
 * @param s the size (or integer square size) of the room
 * @return the bounding box
 */
class bounding_box bounding_box(int *coord, mixed s) {
  int *size;
  class bounding_box bbox;

  if (sizeof(coord) != 3) {
    return 0;
  }
  if (arrayp(s)) {
    if (sizeof(s) == 3) {
      size = s;
    } else {
      return 0;
    }
  } else if (intp(s)) {
    size = ({ s, s, s });
  } else {
    return 0;
  }
  bbox = new(class bounding_box);
  bbox->topleft = ({ coord[0]-size[0], coord[1]-size[1], coord[2]-size[2] });
  bbox->bottomright = ({ coord[0]+size[0], coord[1]+size[1], coord[2]+size[2] });
  return bbox;
} /* bounding_box() */

/**
 * This method adds in an area handler.
 * @param h the area handle to add
 */
void add_area_handler(mixed h) {
  object oh;

  if (stringp(h)) {
    oh = load_object(h);
    oh->set_handler(base_name(this_object()));
    if (objectp(oh)) {
      _area_handlers += ({ oh });
    } else {
      error(sprintf("Couldn't find area handler %s.\n", h));
    }
  } else if (objectp(h)) {
    h->set_handler(base_name(this_object()));
    _area_handlers += ({ h });
  } else {
    error(sprintf("Couldn't find area handler %O.\n", h));
  }
} /* add_area_handler() */

/**
 * This method adds in an inter-room handler.  An interroom is something like
 * a path that has a rectangular bounding box allowing multiple rooms to
 * connect to it.
 * @param h the interoom handler
 */
void add_iroom_handler(mixed h) {
  object oh;

  if (stringp(h)) {
    oh = load_object(h);
    oh->set_handler(base_name(this_object()));
    if (objectp(oh)) {
      _iroom_handlers += ({ oh });
    } else {
      error(sprintf("Couldn't find interroom handler %s.\n", h));
    }
  } else if (objectp(h)) {
    h->set_handler(base_name(this_object()));
    _iroom_handlers += ({ h });
  } else {
    error(sprintf("Couldn't find interroom handler %O.\n", h));
  }
} /* add_iroom_handler() */

/**
 * This is the internal function to add a fixed location room.
 * @param path the path to the object
 * @param ob the object itself
 * @param coord the coordinate of the object
 * @param bbox the bounding box of the object
 */
private void add_internal_fixed_room(string path,
                                     object ob,
                                     int* coord,
                                     class bounding_box bbox) {
  class FIXED_INFO cf;

  cf = new(class FIXED_INFO);
  cf->path = path;
  cf->ob = ob;
  cf->coord = coord;
  cf->bbox = bbox;
  _fixed_room_index[cf->path] = sizeof(_fixed_rooms);
  _fixed_rooms += ({ cf });
} /* add_internal_fixed_room() */

/**
 * This method adds a room in a fixed location.  It gets the co-ordinate
 * and size information from the room itself.
 * @param f the room to add
 * @add add_fixed_room_object()
 * @add add_fixed_room_coord()
 */
void add_fixed_room(string f) {
  object of;

  of = load_object(f);
  if (!objectp(of)) {
    error(sprintf("Couldn't load fixed room %s.\n", f));
    return;
  }
  add_internal_fixed_room(f, of, of->query_co_ord(),
                      bounding_box(of->query_co_ord(), of->query_room_size()));
} /* add_fixed_room() */

/**
 * This method adds a fixed room from an object.
 * @param of the object file
 * @add add_fixed_room()
 * @add add_fixed_room_coord()
 */
void add_fixed_room_object(object of) {
  add_internal_fixed_room(file_name(of), of, of->query_co_ord(),
                    bounding_box(of->query_co_ord(), of->query_room_size()));
} /* add_fixed_room() */

/**
 * This method adds a fixed room with a room and a co-ordinate.
 * @param f the file name of the room
 * @param coord the coordinate of the room
 * @param size the size of the room
 * @add add_fixed_room_object()
 * @add add_fixed_room()
 */
void add_fixed_room_coordinate(string f, int* coord, int* size) {
    add_internal_fixed_room(f, 0, coord, bounding_box(coord, size));
} /* add_fixed_room_coordinate() */

/**
 * This method is called from a loaded object to setup the fixed room
 * into the topology.
 */
void setup_fixed_room() {
  object shad, r;
  int i;

  r = previous_object();
  shad = clone_object(FIXED_SHADOW);
  if (!objectp(shad)) {
    error(sprintf("Couldn't create shadow for fixed room %O.\n", r));
    return;
  }
  shad->attach(r);
  shad->set_area_handler(file_name(this_object()));
  if (undefinedp(i = _fixed_room_index[file_name(r)])) {
    error(sprintf("Couldn't find entry for fixed room %O.\n", r));
  }
  r->set_co_ord(_fixed_rooms[i]->coord);
  //tell_creator("jeremy", "%O coords = %O\n", r, r->query_co_ord());
} /* setup_fixed_room() */

/**
 * This method finds the room as the specified co-ordinates.
 * @param coord the coordinate to look up the room at
 * @return the room
 */
object find_room_at_coord(int *coord) {
  int i;
  object ob;

  if (_dbg_lvl > 0) {
    tell_creator(_debugger, "%s::find_room_at_coord()\n"
                 "  coord: %O\n",
                 file_name(this_object()), coord);
  }
  // Check fixed rooms first...
  for (i = 0; i < sizeof(_fixed_rooms); i++) {
    if (in_bbox(coord, _fixed_rooms[i]->bbox)) {
      if (!objectp(_fixed_rooms[i]->ob)) {
        _fixed_rooms[i]->ob = load_object(_fixed_rooms[i]->path);
      }
      return _fixed_rooms[i]->ob;
    }
  }
  // ...then irooms...
  for (i = 0; i < sizeof(_iroom_handlers); i++) {
    if (objectp(ob = _iroom_handlers[i]->find_room_at_coord(coord))) {
      return ob;
    }
  }
  // ...finally, check areas...
  for (i = 0; i < sizeof(_area_handlers); i++) {
    if (objectp(ob = _area_handlers[i]->find_room_at_coord(coord))) {
      return ob;
    }
  }
  return 0;
} /* find_room_at_coord() */

/**
 * This method does a virtual object lookup for the room.
 * @param x the x coord
 * @param y the y coord
 * @param z the z coord
 */
object create_virtual_object(int x, int y, int z) {
   if (undefinedp(x) || undefinedp(y) || undefinedp(z)) {
      return 0;
   }

   return find_room_at_coord(({ x, y, z }));
} /* create_virtual_object() */

/**
 * This method finds the room at the specified exit in the specified room.
 * @param r the room to look up
 * @param d the dimension of the room
 * @param direc the direction we are moving in
 * @return the room at the exit
 */
object find_room_at_exit(object r, int *d, string direc) {
  int i, s, dist, max_dist, max_iroom, *coord, *coord_r, *coord_ob;
  string msg;
  object ob, *irooms = ({ });
  mixed size_r;
  class bounding_box bbox_r;

  if (_dbg_lvl > 0) {
    tell_creator(_debugger, "%s::find_room_at_exit()\n"
                 "  r: %O\n"
                 "  d: %O\n"
                 "  direc: %O\n",
                 file_name(this_object()), r, d, direc);
  }
  if (!arrayp(d)) {
    return 0;
  }
  coord = r->query_co_ord();
  // Some rooms (like milestones) have "fake" sizes.
  size_r = r->query_actual_room_size();
  if (!arrayp(size_r)) {
    size_r = r->query_room_size();
    if (!arrayp(size_r)) {
      // Must be a single int for all 3 dimensions.
      size_r = ({ size_r, size_r, size_r });
    }
  }
  coord_r = allocate(3);
  for (i = 0; i < 3; i++) {
    // This assumes the rooms are adjacent, either on an edge or at
    // a corner (note to self: figure out why this seems to hit areas
    // before irooms).
    //coord_r[i] = coord[i] + (size_r[i] + 1) * d[i];
    coord_r[i] = coord[i] + 2 * size_r[i] * d[i];
  }
  // Check fixed rooms first...
  for (i = 0; i < sizeof(_fixed_rooms); i++) {
    if (in_bbox(coord_r, _fixed_rooms[i]->bbox)) {
      if (!objectp(_fixed_rooms[i]->ob)) {
        _fixed_rooms[i]->ob = load_object(_fixed_rooms[i]->path);
      }
      // Check that the fixed room allows entrances from this direction.
      msg = evaluate(_fixed_rooms[i]->ob->query_topo_barrier(direc));
      if (!undefinedp(msg)) {
        if (!stringp(msg)) {
          msg = "You can't go that way.\n";
        }
        notify_fail(msg);
        return 0;
      }
      return _fixed_rooms[i]->ob;
    }
  }
  // ...then irooms...
  // This is a bit complicated.  I need to check the distance to
  // the rooms returned by all the handlers and pick the closest.
  bbox_r = bounding_box(coord, size_r);
  for (i = 0; i < sizeof(_iroom_handlers); i++) {
    ob = _iroom_handlers[i]->find_room_at_crossing(coord, coord_r);
    tell_creator("rhinehold", "ob = %O\n", ob);
    if (objectp(ob /*(= _iroom_handlers[i]->find_room_at_crossing(coord, coord_r)*/)
        && (ob != r)) {
      if (_dbg_lvl > 1) {
        tell_creator(_debugger, "%s::find_room_at_exit()\n"
                     "  %O->find_room_at_crossing() returned %O\n",
                     file_name(this_object()), _iroom_handlers[i], ob);
      }
      // This is a kludge, but I can't think of a way around it.  Milestones
      // (like all normal rooms), get their coords set in a callout, so
      // I can't calculate the distance here.  I'll have to assume that
      // a room without coordinates is the "correct" one.
      if (!arrayp(ob->query_co_ord())) {
        return ob;
      }
      // Ignore irooms that are in the current room's bounding box, if
      // the current room is a fixed room.
      // *** NOTE: I'm not sure if this is sufficient.  There are cases
      // where I want irooms to take precedence (like the path around
      // the maze), but there are others where the current room should
      // take precedence (like s_cara03b).  Hopefully, the latter case
      // is always a fixed room.
      if (r->query_fixed_room() && in_bbox(ob->query_co_ord(), bbox_r)) {
        continue;
      }
      irooms += ({ ob });
    }
  }
  if ((s = sizeof(irooms)) > 0) {
    if (s == 1) {
      return irooms[0];
    } else {
      // Hopefully this won't happen often...
      max_dist = 0;
      max_iroom = -1;
      for (i = 0; i < s; i++) {
        coord_ob = irooms[i]->query_co_ord();
        dist = (coord[0] - coord_ob[0])*(coord[0] - coord_ob[0]) +
          (coord[1] - coord_ob[1])*(coord[1] - coord_ob[1]);
        if (dist > max_dist) {
          max_dist = dist;
          max_iroom = i;
        }
      }
      if (max_iroom >= 0) {
        return irooms[max_iroom];
      }
    }
  }
  // ...finally, check areas...
  for (i = 0; i < sizeof(_area_handlers); i++) {
    if (objectp(ob = _area_handlers[i]->find_room_at_exit(r, d))) {
      if (_dbg_lvl > 1) {
        tell_creator(_debugger, "%s::find_room_at_exit()\n"
                     "  %O->find_room_at_exit() returned %O\n",
                     file_name(this_object()), _area_handlers[i], ob);
      }
      return ob;
    }
  }
  return 0;
} /* find_room_at_exit() */

// This is a testing convenience function
/**
 * This method allows you to be moved quickly to a room at the specified
 * co-ordinate.
 * @param coord the coordinate to go to
 */
int goto_room_at_coord(int *coord) {
  return this_player()->move_with_look(find_room_at_coord(coord));
} /* goto_room_at_coord() */

/**
 * This method will make a map of the specified width based on the data in
 * the topography area.
 * @param width the width of the map
 * @return the map
 */
string query_text_map(int width) {
   int x;
   int y;
   int maxy;
   string map;
   object room;

   map = "";
   for (y = 0; y < maxy; y++) {
      for (x = 0; x < width; x++) {
         room = find_room_at_coord( ({ x, y, 0 }) );
         if (!room) {
            map += " ";
         } else if (!room->query_room_letter()) {
            map += "?";
         } else {
            map += room->query_room_letter();
         }
      }
      map += "\n";
   }
   return map;
} /* query_text_map() */
// --- END [/mnt/home2/grok/lib/std/room/controller/topography/topography.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/controller/topography/interroom.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/controller/topography/interroom.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629303   Available: 13576657
Inodes: Total: 5242880    Free: 4960135
34644 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/controller/topography/interroom.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629303   Available: 13576657
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: interroom.c,v 1.2 2002/02/28 23:26:13 rhinehold Exp $
 *
 *
 */

/*
** interroom.c - a handler to handle being "in between" the regular rooms
**     on a long road.
**
** The milestones are the "normal" rooms that people travel between when
** moving compass directions.  milestone_coords[] is a cache of the
** milestone coordinates.
**
** irooms[][] is an array of arrays of rooms; one array of rooms for
** each segment of the road (one less than the number of milestone_coords).
**
** bases[] is an array of base rooms to clone for the interrooms (one for
** each gap between the milestones).
*/

/**
 * The interroom handler is a scheme for handling multiple levels of
 * detail along piecewise linear paths (eg, roads).  The vertices of
 * the path (called "milestones") behave like the rooms along a
 * traditional road.  However, between each milestone are a number of
 * "in-between" rooms (called "interrooms" or "irooms").  Irooms are
 * generally cloned as needed, while milestones are generally unique
 * rooms.  The irooms between two milestones are reached via exits
 * with the same names as those connecting the milestones, but
 * prepended with a "motion verb" (eg, "walk", giving iroom exits of
 * "walk east", "walk west", etc.).<p>
 *
 * The interroom handler is a sort of "mini-handler".  It is meant to
 * be used as an inheritable, with each path having its own handler.
 * Although there is no limit to the number of milestones along a
 * given path, a few points should be kept in mind:
 * <ul>
 * <li> Each milestone can be specified only once in a given handler,
 * except the first and last, which may be identical (ie, you can have
 * a loop, but not a figure-eight).
 *
 * <li> The calculations are based on the bounding box of the path.  A
 * long relatively straight road (ie, north/south or east/west is
 * fairly efficient, but a mostly diagonal road is the least
 * efficient.  So a road that's straight on one half and diagonal on
 * the other half might be better broken into two paths.
 * </ul>
 * Each handler specifies the milestones, the rooms to clone for the
 * irooms (the irooms in each segment are clones of the same room),
 * the sizes of the irooms (again, the irooms in each segment are of the
 * same size), and the save file to use for caching information (like
 * room coordinates).
 *
 * In the documentation, directions along the path are sometimes referred
 * to as "to the left" or "to the right".  These mean "toward the lower
 * numberd milestone" or "toward the higher numbered milestone",
 * respectively, regardless of the compass direction of the path.
 *
 * @author Jeremy
 * @see iroom
 * @see milestone
 * @see topography
 */

#include <map.h>

inherit "/std/room";

class IROOM_INFO {
  string base;
  int *size;
  mixed *bbox;  // Keeps track of bounding box of iroom segment
  int sgn_n;  // Keeps track of N/S direction (N = 1)
  int sgn_e;  // Keeps track of E/W direction (E = 1)
  string *exits; // In order of direction to milestone[i], milestone[i+1]
}

int closed;  // this path forms a closed loop
nosave int dbg_lvl = 0;
mixed *irooms;  // an array of arrays of objects
string *milestones;  // milestone room names
mixed *milestone_coords;  // cache of milestone coordinates
mapping milestone_idx = ([ ]);  // mapping of room name to index
class IROOM_INFO *iroom_info;
mixed *overall_bbox;
string save_file;
nosave string debugger = "jeremy";

mixed *bbox(int *coord_a, int *coord_b);
int in_bbox(int *coord_a, mixed bbox);

/**
 * This method sets the creator to whom debugging messages are sent.
 * @param d name of creator
 */
void set_debugger(string s) { debugger = s; }

/**
 * This method returns the name of the creator to whom debugging messages
 * are sent.
 * @return name of creator
 */
string query_debugger() { return debugger; }

/**
 * This method sets the level of debugging messages printed.
 * @param l debugging level (0 is off)
 */
void set_debug_level(int l) { dbg_lvl = l; }

/**
 * This method returns the current debugging level.
 * @return current debug level (0 is off)
 */
int query_debug_level() { return dbg_lvl; }

/**
 * @ignore
 * For debugging only
 */
mixed query(string s) { return fetch_variable(s); }

/**
 * @ignore
 * Integer absolute value function.
 */
int abs(int i) {
  return (i<0)?-i:i;
}

/**
 * @ignore
 * Float absolute value function.
 */
float fabs(float i) {
  return (i<0)?-i:i;
}

/**
 * This method sets the path of the file to use for saving data that
 * shouldn't have to be recalculated very often.
 * @param s pathname of save file
 */
void set_save_file(string s) { save_file = s; }

/**
 * This method returns the path of the file used for saving.
 * return pathname of save file
 */
string query_save_file() { return save_file; }

/**
 * This method is used to set the pathnames of the milestones.  Each
 * milestone should inherit one of the milestone inheritables.
 * @param array of filenames of the milestones for this path.
 * @see milestone
 */
void set_milestones(string *s) {
  int i;

  milestones = copy(s);
  if (milestones[0] == milestones[<1]) {
    // This is a closed loop
    closed = 1;
  }
  for (i = 0; i < sizeof(milestones) - closed; i++) {
    milestone_idx[s[i]] = i;
  }
  milestone_coords = allocate(sizeof(milestones));
  irooms = allocate(sizeof(milestones)-1);
  iroom_info = allocate(sizeof(milestones)-1);
  for (i = 0; i < sizeof(iroom_info); i++) {
    iroom_info[i] = new(class IROOM_INFO);
    iroom_info[i]->exits = allocate(2);
  }
  overall_bbox = 0;
} /* set_milestones() */

/**
 * This method returns the array of milestone filenames.
 * @return an array of milestone filenames
 * @see set_milestones()
 */
string *query_milestones() { return milestones; }

/**
 * This method returns the filename of the given milestone.
 * @param i index number of milestone
 * @returns filename of milestone i
 * @see set_milestones()
 */
string query_milestone(int i) { return milestones[i]; }

/**
 * @ignore
 * This method is used internally to set (or update) the coordinates
 * of a milestone.  It also updates related info, such as the bounding
 * boxes.
 */
void set_milestone_coords(int i, int *c) {

  if (!arrayp(c) || (sizeof(c) != 3)) {
    return;
  }
  if (!arrayp(milestone_coords[i]) || (milestone_coords[i][0] != c[0])
  || (milestone_coords[i][1] != c[1]) || (milestone_coords[i][2] != c[2])) {
    // Update iroom_info on either side of milestone
    milestone_coords[i] = copy(c);
    if ((i > 0) && arrayp(milestone_coords[i-1])) {
      iroom_info[i-1]->bbox = bbox(milestone_coords[i-1], milestone_coords[i]);
      if (milestone_coords[i-1][0] < milestone_coords[i][0]) {
        iroom_info[i-1]->sgn_n = 1;
      } else if (milestone_coords[i-1][0] > milestone_coords[i][0]) {
        iroom_info[i-1]->sgn_n = -1;
      } else {
        iroom_info[i-1]->sgn_n = 0;
      }
      if (milestone_coords[i-1][1] < milestone_coords[i][1]) {
        iroom_info[i-1]->sgn_e = 1;
      } else if (milestone_coords[i-1][1] > milestone_coords[i][1]) {
        iroom_info[i-1]->sgn_e = -1;
      } else {
        iroom_info[i-1]->sgn_e = 0;
      }
      // Update overall bounding box (do I need to add in room size?)
      if (!arrayp(overall_bbox)) {
        overall_bbox = copy(iroom_info[i-1]->bbox);
      } else {
        if (iroom_info[i-1]->bbox[0][0] < overall_bbox[0][0]) {
          overall_bbox[0][0] = iroom_info[i-1]->bbox[0][0];
        }
        if (iroom_info[i-1]->bbox[0][1] < overall_bbox[0][1]) {
          overall_bbox[0][1] = iroom_info[i-1]->bbox[0][1];
        }
        if (iroom_info[i-1]->bbox[1][0] > overall_bbox[1][0]) {
          overall_bbox[1][0] = iroom_info[i-1]->bbox[1][0];
        }
        if (iroom_info[i-1]->bbox[1][1] > overall_bbox[1][1]) {
          overall_bbox[1][1] = iroom_info[i-1]->bbox[1][1];
        }
      }
    }
    if ((i < sizeof(iroom_info)) && arrayp(milestone_coords[i+1])) {
      iroom_info[i]->bbox = bbox(milestone_coords[i], milestone_coords[i+1]);
      if (milestone_coords[i][0] < milestone_coords[i+1][0]) {
        iroom_info[i]->sgn_n = 1;
      } else if (milestone_coords[i][0] > milestone_coords[i+1][0]) {
        iroom_info[i]->sgn_n = -1;
      } else {
        iroom_info[i]->sgn_n = 0;
      }
      if (milestone_coords[i][1] < milestone_coords[i+1][1]) {
        iroom_info[i]->sgn_e = 1;
      } else if (milestone_coords[i][1] > milestone_coords[i+1][1]) {
        iroom_info[i]->sgn_e = -1;
      } else {
        iroom_info[i]->sgn_e = 0;
      }
      // Update overall bounding box (do I need to add in room size?)
      if (!arrayp(overall_bbox)) {
        overall_bbox = copy(iroom_info[i]->bbox);
      } else {
        if (iroom_info[i]->bbox[0][0] < overall_bbox[0][0]) {
          overall_bbox[0][0] = iroom_info[i]->bbox[0][0];
        }
        if (iroom_info[i]->bbox[0][1] < overall_bbox[0][1]) {
          overall_bbox[0][1] = iroom_info[i]->bbox[0][1];
        }
        if (iroom_info[i]->bbox[1][0] > overall_bbox[1][0]) {
          overall_bbox[1][0] = iroom_info[i]->bbox[1][0];
        }
        if (iroom_info[i]->bbox[1][1] > overall_bbox[1][1]) {
          overall_bbox[1][1] = iroom_info[i]->bbox[1][1];
        }
      }
    }
    //printf("Setting room %d to %O\n", i, c);
  }
} /* set_milestone_coords() */

/**
 * @ignore
 * This method returns the array of coordinates for the milestones.
 */
mixed query_milestone_coords() { return milestone_coords; }

/**
 * This method is used to set the filenames of the rooms to clone for
 * the irooms.  Each segment of the path (ie, between two milestones)
 * can use a different base room.  Each base room should inherit one
 * of the iroom inheritables.
 * @param s array of filenames of irooms
 * @see iroom
 */
void set_bases(string *s) {
  int i;

  if (sizeof(s) != sizeof(iroom_info)) {
    error("Wrong number of bases (" + sizeof(s) + ") for given milestones (" +
          sizeof(milestones) + ").\n");
    return;
  }
  for (i = 0; i < sizeof(s); i++) {
    iroom_info[i]->base = s[i];
  }
} /* set_bases() */

/**

 * This method is used to set the sizes of the irooms.  Each segment
 * of the path (ie, between two milestones) can use a different size.
 * However, the distance between milestones must be an integer
 * multiple of the size (in each dimension).  The number of irooms in
 * each segment is calculated automatically.
 * @param s array of sizes of irooms (n x 1 or n x 3)
 * @see iroom
 */
void set_sizes(mixed *s) {
  int i;

  if (sizeof(s) != sizeof(iroom_info)) {
    error("Wrong number of sizes (" + sizeof(s) + ") for given milestones (" +
          sizeof(milestones) + ").\n");
    return;
  }
  for (i = 0; i < sizeof(s); i++) {
    iroom_info[i]->size = allocate(3);
    if (intp(s[i])) {
      iroom_info[i]->size[0] = s[i];
      iroom_info[i]->size[1] = s[i];
      iroom_info[i]->size[2] = s[i];
    } else if (arrayp(s[i])) {
      iroom_info[i]->size[0] = s[i][0];
      iroom_info[i]->size[1] = s[i][1];
      iroom_info[i]->size[2] = s[i][2];
    } else {
      error("Illegal room size given (" + i + ").\n");
      continue;
    }
  }
} /* set_sizes() */

/**
 * @ignore
 */
class IROOM_INFO *query_iroom_info() { return iroom_info; }

/**
 * This method determines if iroom j (between milestones i & i+1) is
 * just before a milestone when going in direction dir.  If dir == 0,
 * the direction is towards milestone i (ie, to the "left"); if
 * dir == 1, the direction is towards milestone i+1 (ie, to the "right").
 * @param i milestone "to the left" of the iroom
 * @param j iroom index
 * @param dir direction
 * @return true if the iroom is just before a milestone in direction dir
 * @see query_irooms_inv()
 */
int query_endpoint(int i, int j, int dir) {
  // See query_irooms_inv() for comments on dir
  if ((dir && (j == sizeof(irooms[i])-1)) || (!dir && (j == 0))) {
    return 1;
  }
  return 0;
}

/**
 * This method returns all of the objects in the rooms between this
 * room and the next milestone (non-inclusive).  This is used when the
 * player uses the exit directly to the next milestone, to inform the
 * player of what [s]he passed along the way.<p>
 * 'dir' is a bit of a kludge.  If it is 1, the movement is to milestone
 * i+1; if it is 0, the movement is to milestone i, <i>unless</i> j == -1,
 * in which case the movement is to milestone i-1 (this latter case is
 * only used when the current room is a milestone).
 * @param i milestone "to the left" of the current iroom
 * @param j iroom index (or -1 if a milestone)
 * @param dir direction
 * @return an array of the objects between this room and the next milestone
 */
object *query_irooms_inv(int i, int j, int dir) {
  // dir==1 -> moving towards milestone i+1
  // dir==0 ->
  //     if j == -1 -> moving towards milestone i-1 (only used by milestones)
  //     else       -> moving towards milestone i
  int k;
  object *invs;

  invs = ({ });
  if (dir) {
    if (!arrayp(irooms[i])) {
      return invs;
    }
    for (k = j+1; k < sizeof(irooms[i]); k++) {
      //tell_creator("jeremy", "Checking irooms[%d][%d]\n", i, k);
      if (objectp(irooms[i][k])) {
        invs += all_inventory(irooms[i][k]);
      }
    }
  } else {
    if (j == -1) {
      if (closed) {
        // Wraparound for closed path
        i = sizeof(milestones) - 2;
      } else {
        i--;
      }
      if (!arrayp(irooms[i])) {
        return invs;
      } else {
        j = sizeof(irooms[i]);
      }
    } else if (!arrayp(irooms[i])) {
      return invs;
    }
    for (k = j-1; k >= 0; k--) {
      //tell_creator("jeremy", "Checking irooms[%d][%d]\n", i, k);
      if (objectp(irooms[i][k])) {
        invs += all_inventory(irooms[i][k]);
      }
    }
  }
  return invs;
} /* query_irooms_inv() */

/**
 * This method returns the coordinates of a rectangle that bounds the
 * given points.  The parameters are each arrays of three integers.  The
 * returned value is a 2-element array, each element being an array of
 * three integers.  The first element is the minimum values (ie, the
 * lower-southwestern corner) and the second is the maximum values (the
 * upper-northeastern corner).
 * @param coord_a the coordinates of one point
 * @param coord_b the coordinates of the other point
 * @return the bounding box
 */
mixed *bbox(int *coord_a, int *coord_b) {
  // Finds rectangle that bounds the given points.  Returns a 2-element
  // array of coordinates (min, max);
  int c;
  mixed *bbox;

  bbox = allocate(2);
  bbox[0] = allocate(3);
  bbox[1] = allocate(3);
  for (c = 0; c < 3; c++) {
    if (coord_a[c] < coord_b[c]) {
      bbox[0][c] = coord_a[c];
      bbox[1][c] = coord_b[c];
    } else {
      bbox[0][c] = coord_b[c];
      bbox[1][c] = coord_a[c];
    }
  }
  return bbox;
} /* bbox() */

/**
 * This method returns 1 if the given coordinates lie within the given
 * bounding box.  coord_a is an array of three integers (north,
 * east, up).  Currently, the "up" value is not checked.  bbox is a
 * two-element array of coordinates.
 * @param coord_a the coordinates of the point to check
 * @param bbox the bounding box to check the point against
 * @return true if the point lies within the bounding box
 */
int in_bbox(int *coord_a, mixed bbox) {
  // Note: this does not check the height (3rd coordinate)
  if ((coord_a[0] < bbox[0][0]) || (coord_a[0] > bbox[1][0])
  || (coord_a[1] < bbox[0][1]) || (coord_a[1] > bbox[1][1]))
    return 0;
  return 1;
} /* in_bbox() */

/**
 * This method calculates the number of irooms between milestone i and
 * milestone i+1.
 * @param i "left-hand" milestone
 * @return the number of irooms between the milestones
 */
int number_of_irooms(int i) {
  int n;
  mixed bbox;
  class IROOM_INFO ir;

  ir = iroom_info[i];
  bbox = ir->bbox;
  if (ir->sgn_n == 0) {
    n = (bbox[1][1] - bbox[0][1])/(ir->size[1]*2);
  } else if (ir->sgn_e == 0) {
    n = (bbox[1][0] - bbox[0][0])/(ir->size[0]*2);
  } else {
    // Diagonal
    n = (bbox[1][1] - bbox[0][1])/(ir->size[1]*2);
    if (n != (bbox[1][0] - bbox[0][0])/(ir->size[0]*2)) {
      error("Interroom sizes don't match diagonal.\n");
      return 0;
    }
  }
  return n-1;
} /* number_of_irooms() */

/**
 * This method clones an iroom at the requested location, and sets up
 * the pertinent details.
 * @param i milestone "to the left" of the iroom
 * @param idx index of this iroom within its segment
 * @param icoord the coordinates of the new iroom
 * @return the cloned iroom
 */
object clone_iroom(int i, int idx, int *icoord) {
  object iroom;

  iroom = clone_object(iroom_info[i]->base);
  // Set up new room
  iroom->set_room_size(iroom_info[i]->size);
  iroom->set_co_ord(icoord);
  iroom->set_milestone_index( ({ i, idx }) );
  iroom->add_exit(iroom_info[i]->exits[0], milestones[i], "road");
  iroom->add_exit(iroom_info[i]->exits[1], milestones[i+1], "road");
  iroom->add_milestone_dir(iroom_info[i]->exits[0]);
  iroom->add_milestone_dir(iroom_info[i]->exits[1]);
  // This adds the topo exits that were set up with add_topo_exits();
  // this way, everything else is all set up.
  iroom->add_topo_exits_int();
  return iroom;
} /* clone_iroom() */

/**
 * This method is called to set up a milestone.  It sets up the coordinates
 * and some of the exit information.
 * @param ms milestone to be set up
 */
void setup_milestone(object ms) {
  int *coord, i, j, idir;
  string *dir;

  if (undefinedp(i = milestone_idx[file_name(ms)])) {
    error("This room (" + file_name(ms) + ") is not a milestone.\n");
    return;
  }
  ms->set_milestone_index(file_name(this_object()), i);
  coord = ms->query_co_ord();
  if (arrayp(coord)) {
    set_milestone_coords(i, coord);
  } else {
    if (arrayp(milestone_coords[i])) {
      coord = milestone_coords[i];
    } else {
      coord = MAP->static_query_co_ord(file_name(ms));
      set_milestone_coords(i, coord);
    }
    ms->set_co_ord(coord);
  }
  if (closed && (i == 0)) {
    milestone_coords[<1] = milestone_coords[0];
  }
  dir = ms->query_dest_dir();
  if ((i > 0) || closed) {
    // Left-hand room exit
    if (closed && i == 0) {
      // Wraparound for closed path
      j = sizeof(milestones) - 2;
    } else {
      j = i - 1;
    }
    if ((idir = member_array(milestones[j], dir)) < 0) {
      // This is no longer an error, but we still need an entry.
      //error("No exit to " + milestones[j] + " from " + milestones[i] +
      //      ".\n");
      ms->add_milestone_dir(file_name(this_object()), 0);
    } else {
      iroom_info[j]->exits[0] = dir[idir-1];
      ms->add_milestone_dir(file_name(this_object()), dir[idir-1]);
    }
  } else {
    // Need a dummy entry
    ms->add_milestone_dir(file_name(this_object()), 0);
  }
  if (i < sizeof(irooms)) {
    // Right-hand room exit
    j = i + 1;
    if ((idir = member_array(milestones[j], dir)) < 0) {
      // This is no longer an error, but we still need an entry.
      //error("No exit to " + milestones[j] + " from " + milestones[i] +
      //      ".\n");
      ms->add_milestone_dir(file_name(this_object()), 0);
    } else {
      iroom_info[i]->exits[1] = dir[idir-1];
      ms->add_milestone_dir(file_name(this_object()), dir[idir-1]);
    }
  }
} /* setup_milestone() */

/**
 * This method finds the room along the path that contains the given point.
 * Obviously, things will go wrong if the rooms somehow overlap.
 * @param coord_a the coordinates of the point
 * @param hint_idx indicates that only this index should be checked
 * (optional)
 * @return the room that contains coord_a, or 0 if no matches
 */
varargs object find_room_at_coord(int *coord_a, int hint_idx) {
  int i, idx, in_bbox;
  int start_i, stop_i;
  int *icoord = ({ 0, 0, 0 });
  mixed bbox;
  float slope;
  class IROOM_INFO ir;

  if (dbg_lvl > 0) {
    tell_creator(debugger, "%s::find_room_at_coord()\n"
                 "  coord_a: %O\n"
                 "  hint_idx: %s\n",
                 file_name(this_object()), coord_a,
                 undefinedp(hint_idx)?"NULL":hint_idx+"");
  }
  // The only way I can think to do this is check every pair of
  // adjacent milestones; I originally planned a binary-search type of
  // check, but I think I'd still need to scan all the milestones to find
  // the bounding boxes.
  // First check that we're in the neighborhood
  if (!in_bbox(coord_a, overall_bbox)) {
    return 0;
  }
  in_bbox = 0;
  // See if the choice has been narrowed down for us
  if (undefinedp(hint_idx)) {
    start_i = 0;
    stop_i = sizeof(iroom_info);
  } else {
    start_i = hint_idx;
    stop_i = hint_idx + 1;
  }
  for (i = start_i; i < stop_i; i++) {
    ir = iroom_info[i];
    bbox = ir->bbox;
    if (dbg_lvl > 1) {
      tell_creator(debugger, "%s::find_room_at_coord()\n"
                   "  Checking bbox(%d,%d): %O\n",
                   file_name(this_object()), i, i+1, bbox);
    }
    if (in_bbox(coord_a, bbox)) {
      if (dbg_lvl > 1) {
        tell_creator(debugger, "%s::find_room_at_coord()\n"
                     "  In bbox(%d,%d)...\n",
                     file_name(this_object()), i, i+1);
      }
      // Check that the coordinates lie on the line
      if (ir->sgn_e == 0) {
        // N/S (vertical) line
        if (abs(coord_a[1]-milestone_coords[i][1]) < ir->size[1]) {
          if (dbg_lvl > 2) {
            tell_creator(debugger, "%s::find_room_at_coord()\n"
                         "  On vline between (%d,%d)...\n",
                         file_name(this_object()), i, i+1);
          }
          break;
        }
      } else {
        slope = to_float(milestone_coords[i][0] - milestone_coords[i+1][0])
          / to_float(milestone_coords[i][1] - milestone_coords[i+1][1]);
        if (abs(slope * (coord_a[1] - milestone_coords[i+1][1]) +
            milestone_coords[i+1][0] - coord_a[0]) < ir->size[0]) {
          if (dbg_lvl > 2) {
            tell_creator(debugger, "%s::find_room_at_coord()\n"
                         "  On line between (%d,%d)...\n",
                         file_name(this_object()), i, i+1);
          }
          break;
        }
      }
    }
  }
  if (i == stop_i) {
    // Couldn't find one
    if (dbg_lvl > 2) {
      tell_creator(debugger, "%s::find_room_at_coord()\n"
                   "  Couldn't find a room...\n",
                   file_name(this_object()));
    }
    return 0;
  }
  // We now know what rooms the iroom is between...
  if (ir->sgn_n == 0) {
    // East/west road
    idx = abs(coord_a[1] - milestone_coords[i][1]
              + ir->size[1]*ir->sgn_e)/(ir->size[1]*2);
    icoord[0] = milestone_coords[i][0];
    icoord[1] = milestone_coords[i][1] + idx*ir->sgn_e*ir->size[1]*2;
  } else {
    idx = abs(coord_a[0] - milestone_coords[i][0]
              + ir->size[0]*ir->sgn_n)/(ir->size[0]*2);
    icoord[0] = milestone_coords[i][0] + idx*ir->sgn_n*ir->size[0]*2;
    if (ir->sgn_e == 0) {
      icoord[1] = milestone_coords[i][1];
    } else {
      icoord[1] = milestone_coords[i][1] + idx*ir->sgn_e*ir->size[1]*2;
    }
  }
  if (dbg_lvl > 2) {
    tell_creator(debugger, "%s::find_room_at_coord()\n"
                 "  idx: %O\n",
                 file_name(this_object()), idx);
  }
  if (idx == 0) {
    // We hit right on a milestone
    return load_object(milestones[i]);
  }
  if (!arrayp(irooms[i])) {
    irooms[i] = allocate(number_of_irooms(i));
  }
  if (idx == sizeof(irooms[i])+1) {
    // We hit on the other end
    return load_object(milestones[i+1]);
  }
  // Decrement idx to index irooms[i] (since idx==0 is the milestone)
  idx--;
  if (!objectp(irooms[i][idx])) {
    icoord[2] = (milestone_coords[i+1][2] - milestone_coords[i][2])
      * idx / sizeof(irooms[i]) + milestone_coords[i][2];
    // Clone new iroom
    irooms[i][idx] = clone_iroom(i, idx, icoord);
  }
  return irooms[i][idx];
} /* find_room_at_coord() */

/**
 * This method returns the room at the given index, or 0 if there is
 * no such room.  Generally, idx is the index of the iroom within its
 * segment; the following are for special cases:<ul>
 * <li> -1 means milestone i
 * <li> sizeof(irooms[i]) means milestone i+1
 * <li> -2 means the last iroom of this segment
 * <ul>
 * @param i milestone "to the left" of the room (but see above)
 * @param idx index of iroom (but see above)
 * @return the room at the given index
 */
object find_room_at_index(int i, int idx) {
  // A couple of kludges:
  //    idx == -1 means milestone i
  //    idx == sizeof(irooms[i]) means milestone i+1
  //    idx == -2 means the last iroom of this segment
  int *icoord = ({ 0, 0, 0 });
  class IROOM_INFO ir;

  if (dbg_lvl > 0) {
    tell_creator(debugger, "%s::find_room_at_index()\n"
                 "  i: %O, idx: %O\n",
                 file_name(this_object()), i, idx);
  }
  if (closed && (i == -1)) {
    // Assume we wrapped around on a closed path
    i = sizeof(milestones) - 2;
  }
  if ((i < 0) || (i >= sizeof(irooms))) {
    return 0;
  }
  if (idx == -1) {
    return load_object(milestones[i]);
  }
  if (!arrayp(irooms[i])) {
    irooms[i] = allocate(number_of_irooms(i));
  }
  if (idx == sizeof(irooms[i])) {
    return load_object(milestones[i+1]);
  }
  if (idx == -2) {
    idx = sizeof(irooms[i]) - 1;
  }
  if ((idx < 0) || (idx >= sizeof(irooms[i]))) {
    return 0;
  }
  if (!objectp(irooms[i][idx])) {
    ir = iroom_info[i];
    if (ir->sgn_n == 0) {
      // East/west road
      icoord[0] = milestone_coords[i][0];
      icoord[1] = milestone_coords[i][1] + (idx+1)*ir->sgn_e*ir->size[1]*2;
    } else {
      icoord[0] = milestone_coords[i][0] + (idx+1)*ir->sgn_n*ir->size[0]*2;
      if (ir->sgn_e == 0) {
        icoord[1] = milestone_coords[i][1];
      } else {
        icoord[1] = milestone_coords[i][1] + (idx+1)*ir->sgn_e*ir->size[1]*2;
      }
    }
    icoord[2] = (milestone_coords[i+1][2] - milestone_coords[i][2])
      * idx / sizeof(irooms[i]) + milestone_coords[i][2];
    // Clone new iroom
    irooms[i][idx] = clone_iroom(i, idx, icoord);
  }
  return irooms[i][idx];
} /* find_room_at_index() */

/**
 * This method determines which side(s) of bbox the given point is on,
 * setting a bit in the return value as follows:<ul>
 * <li> bit 0: south
 * <li> bit 1: north
 * <li> bit 2: west
 * <li> bit 3: east
 * <\ul>
 * This effectively divides the plane into nine regions.  If two points
 * have the same region number, then their line can't cross bbox.  An
 * easy way to check this is to bitwise-and ("&") the query_region()
 * for two points: if the result is non-zero, then the line between
 * the points can't cross bbox (note however that a result of zero doesn't
 * guarantee that they do cross bbox).
 * @param coord the coordinates of the point
 * @param bbox the bounding box
 * @return an int indicating on which side of bbox the point lies
 */
int query_region(int *coord, mixed bbox) {
  // This checks which side(s) of the box the point is on, setting
  // a different bit for each side; the idea is that if two points are
  // on the same side, they don't cross the box.
  int ret;

  if (coord[0] < bbox[0][0]) {
    ret += 1;
  } else if (coord[0] > bbox[1][0]) {
    ret += 2;
  }
  if (coord[1] < bbox[0][1]) {
    ret += 4;
  } else if (coord[1] > bbox[1][1]) {
    ret += 8;
  }
  return ret;
} /* query_region() */

/**
 * This method returns the room on the path that lies along the line
 * between coord_a and coord_b.  Note that if the line crosses more than
 * one room, the one closest to coord_a is returned.
 * @param coord_a the coordinates of the first point
 * @param coord_b the coordinates of the second poing
 * @return the room between the two points, or 0 if no such room exists
 */
object find_room_at_crossing(int *coord_a, int *coord_b) {
  int i, a, b, c, d, dist2, ret_dist2;
  float e, f, det;
  int *isect;
  object ret;
  mixed bbox, road_a, road_b;

  if (dbg_lvl > 0) {
    tell_creator(debugger, "%s::find_room_at_crossing()\n"
                 "  coord_a: %O\n"
                 "  coord_b: %O\n",
                 file_name(this_object()), coord_a, coord_b);
  }
  // First check that we're in the neighborhood
  if (query_region(coord_a, overall_bbox)
      & query_region(coord_b, overall_bbox)) {
    return 0;
  }
  for (i = 0; i < sizeof(iroom_info); i++) {
    // Check if the line crosses the bounding box
    bbox = iroom_info[i]->bbox;
    if (query_region(coord_a, iroom_info[i]->bbox)
        & query_region(coord_b, iroom_info[i]->bbox)) {
      //tell_creator("jeremy", "Boxes don't overlap (%d).\n", i);
      continue;
    }
    // Find intersection of lines.
    // I really wanted to avoid floats, but the sizes of some of the
    // coordinates made it a necessity when multiplying them together.
    road_a = allocate(3);
    road_b = allocate(3);
    if (iroom_info[i]->sgn_n > 0) {
      road_a[0] = bbox[0][0];
      road_b[0] = bbox[1][0];
    } else {
      road_a[0] = bbox[1][0];
      road_b[0] = bbox[0][0];
    }
    if (iroom_info[i]->sgn_e > 0) {
      road_a[1] = bbox[0][1];
      road_b[1] = bbox[1][1];
    } else {
      road_a[1] = bbox[1][1];
      road_b[1] = bbox[0][1];
    }
    a = coord_b[0] - coord_a[0];
    b = coord_a[1] - coord_b[1];
    c = road_b[0] - road_a[0];
    d = road_a[1] - road_b[1];
    e = to_float(a)*coord_a[1] + to_float(b)*coord_a[0];
    f = to_float(c)*road_a[1] + to_float(d)*road_a[0];
    det = a*d - b*c;
    // The compiler apparently doesn't recognize scientific notation
    if (fabs(det) < 0.0000000000001) {
      //tell_creator("jeremy", "Determinant is 0.\n");
      continue;
    }
    isect = allocate(3);
    isect[0] = to_int(floor((a*f - e*c)/det + 0.5));
    isect[1] = to_int(floor((e*d - b*f)/det + 0.5));
    if (!in_bbox(isect, bbox) || !in_bbox(isect, bbox(coord_a, coord_b))) {
      // They intersect, but not between the endpoints
      continue;
    }
    dist2 = (isect[0]-coord_a[0])*(isect[0]-coord_a[0]) +
      (isect[1]-coord_a[1])*(isect[1]-coord_a[1]);
    if (objectp(ret) && (dist2 >= ret_dist2)) {
      // This one is further away
      continue;
    }
    ret = find_room_at_coord(isect, i);
    if (dbg_lvl > 0) {
      tell_creator(debugger, "%s::find_room_at_crossing()\n"
                   "  find_room_at_coord() returned %O\n",
                   file_name(this_object()), ret);
    }
    ret_dist2 = dist2;
    // I don't think there's any way this should happen, but I'll check anyway
    if (!objectp(ret)) {
      error("Couldn't find a room where there should be one!\n");
    }
  }
  return ret;
} /* find_room_at_crossing() */

/**
 * @ignore
 */
void create() {
  string std_euid;

  std_euid = "/secure/master"->creator_file(file_name(this_object()));
  seteuid(std_euid);
  do_setup++;
  ::create();
  do_setup--;

  if ( !do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }
  // Keeps us from being unloaded (one of the drawbacks of making the
  // handler a room; I wonder if that was a smart move...).
  set_keep_room_loaded(1);
} /* create() */

/**
 * @ignore
 */
void dest_me() {

  if (stringp(save_file)) {
    unguarded( (: save_object, save_file :) );
  }
  ::dest_me();
} /* dest_me() */

// These are testing convenience functions
/**
 * @ignore
 */
int goto_room_at_coord(int *coord) {
  return this_player()->move_with_look(find_room_at_coord(coord));
}

/**
 * @ignore
 */
int goto_room_at_index(int i, int j) {
  return this_player()->move_with_look(find_room_at_index(i, j));
}

/**
 * @ignore
 */
int goto_room_at_crossing(int *a, int *b) {
  return this_player()->move_with_look(find_room_at_crossing(a, b));
}

/**
 * @ignore
 * This function isn't quite for public use yet.
 */
void recalc_milestones(int idx, int callouts, object tp) {
  // This should initially be called with both parameters 0 (or unspecified);
  // It callouts itself until it gets through all the milestones.
  int *c;
  string ms;

  if (callouts > 10) {
    error(sprintf("Too many callouts in %s:recalc_iroom_info(%d, %d)\n",
          file_name(this_object()), idx, callouts));
    return;
  }
  if (!idx && !callouts && !tp) {
    // Reinitialize everything
    rm(save_file);
    this_object()->setup();
    idx = 0;
    tp = this_player();
  }
  ms = milestones[idx];
  if (!arrayp(c = ms->query_co_ord())) {
    // The call_out is necessary to give time for the coords to be set
    call_out("recalc_milestones", 0, idx, callouts+1, tp);
    tell_object(tp, sprintf("Waiting on %s (%d, %d)...\n",
                          ms, idx, callouts));
    return;
  }
  ms->setup_milestone(ms);
  tell_object(tp, sprintf("Loaded room %s at (%d, %d, %d)...\n",
                          ms, c[0], c[1], c[2]));
  idx++;
  if (idx < sizeof(milestones)) {
    // This could be a direct call, but hey, this won't be run that
    // often, and it makes the code more uniform.
    call_out("recalc_milestones", 0, idx, 0, tp);
    return;
  }
  tell_object(tp, "IRoom info successfully recalculated.\n");
} /* recalc_milestones() */

/**
 * @ignore
 */
void clear_map_handler() {
  // This is necessary if the rooms move to new coordinates, since
  // the map handler doesn't seem to update itself very often.
  // For right now, this has to be called manually.
  int i;
  string ms, directory, troom;

  for (i = 0; i < sizeof(milestones); i++) {
    ms = milestones[i];
    // These are needed for the map handler
    directory = implode( explode( ms, "/" )[ 0..<2 ], "/" );
    troom = explode( ms, "/" )[ <1 ];
    if ( troom[ <2.. ] == ".c" ) {
      troom = troom[ 0..<3];
    }
    MAP->del(directory, troom);
    printf("Deleting %s in %s from map handler.\n", directory, troom);
  }
} /* clear_map_handler() */

/**
 * @ignore
 */
int sanity_checks() {
  // This does a few sanity checks, like making sure all milestones
  // have coordinates and sizes, the interroom areas have bounding
  // boxes, etc.  It returns 1 on success.
  int i, success = 1;

  for (i = 0; i < sizeof(milestone_coords); i++) {
    if (sizeof(milestone_coords[i]) != 3) {
      printf("Milestone %d (%s) doesn't have proper coordinates: %O\n",
             i, milestones[i], milestone_coords[i]);
      success = 0;
    }
  }
  for (i = 0; i < sizeof(iroom_info); i++) {
    if (sizeof(iroom_info[i]->size) != 3) {
      printf("Interroom segment %d has improper size: %O\n",
             i, iroom_info[i]->size);
      success = 0;
    }
    if ((sizeof(iroom_info[i]->bbox) != 2) ||
        (sizeof(iroom_info[i]->bbox[0]) != 3) ||
        (sizeof(iroom_info[i]->bbox[1]) != 3)) {
      printf("Interroom segment %d has improper bounding box: %O\n",
             i, iroom_info[i]->bbox);
      success = 0;
    }
  }
  return success;
}
// --- END [/mnt/home2/grok/lib/std/room/controller/topography/interroom.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/controller/club_room_controller.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/controller/club_room_controller.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629295   Available: 13576649
Inodes: Total: 5242880    Free: 4960135
21213 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/controller/club_room_controller.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629295   Available: 13576649
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * THis is the controller object to deal with the club rooms.  It
 * keeps track of which club owns the room, if the club room has
 * a board and any ownership issues that are needed.
 * @author Pinkfish
 * @started May 16th
 */
inherit "/std/basic/setup";

#include <clubs.h>
#include <room/club_room.h>

private nosave string _save_directory;
private mapping _options;
private string _club;
private mapping _ownership;
private nosave mapping _default_ownership;
private int _board_contained;

class ownership {
   string name;
   int type;
   int control_type;
}

private void setup_discussions();
void save_me();
void load_me();

void create() {
   _options = ([ ]);
   _ownership = ([ ]);
   _default_ownership = ([ ]);
   do_setup();
   // Make sure the save file is setup correctly.
   call_out((: load_me() :), 0);
} /* create() */

private void add_board_to(string club) {
   int board_count;

   // Next add the board to the new club.
   board_count = CLUB_HANDLER->query_elected_option(club, 
                                                    CLUB_ROOM_BOARD_COUNT);
   board_count++;
   if (board_count == 1) {
      CLUB_HANDLER->create_club_board(club);
   }
   CLUB_HANDLER->set_elected_option(club,
                                    CLUB_ROOM_BOARD_COUNT,
                                    board_count);
} /* add_board_to() */

private void remove_board_from(string club) {
   int board_count;

   board_count = CLUB_HANDLER->query_elected_option(club, 
                                                    CLUB_ROOM_BOARD_COUNT);
   board_count--;
   if (board_count == 0 &&
       CLUB_HANDLER->query_club_board(club)) {
      CLUB_HANDLER->remove_club_board(club);
   }
   if (board_count <= 0) {
      CLUB_HANDLER->remove_elected_option(club,
                                          CLUB_ROOM_BOARD_COUNT);
   } else {
      CLUB_HANDLER->set_elected_option(club,
                                       CLUB_ROOM_BOARD_COUNT,
                                       board_count);
   }
} /* remove_board_from() */

/**
 * This method sets the club that currently owns the set of rooms.
 * @param club the club that owns the rooms
 * @return 1 on success, 0 on failure
 */
int set_club(string club) {
   class ownership bing;
   class ownership fluff;
   string name;

   if (!CLUB_HANDLER->is_elected_club(club)) {
      return 0;
   }

   if (_club &&
       CLUB_HANDLER->query_club_name(club) ==
       CLUB_HANDLER->query_club_name(_club)) {
      return 1;
   }

   // Changing clubs.
   if (_board_contained) {
      // First remove the board from the old club...
      if (_club) {
         remove_board_from(_club);
      }

      add_board_to(club);
   }
   _club = club;

   //
   // Ok, need to set all the owned items as unowned and then
   // setup things for them.
   //
   foreach (name, bing in _ownership) {
      if (bing->control_type != CLUB_ROOM_CONTROLLED_FIXED) {
         if (_default_ownership[name]) {
            fluff = _default_ownership[name];
            bing->type = fluff->type;
            if (functionp(fluff->name)) {
               bing->name = evaluate(fluff->name,
                                     name,
                                     club);
            } else {
               bing->name = fluff->name;
            }
         }
      }
   }
   call_out((: setup_discussions :), 1);
   save_me();
   return 1;
} /* set_club() */

/**
 * This method queries the club that currently owns the set of rooms.
 * @return the club that owns the rooms
 */
string query_club() {
   return _club;
} /* query_club() */

/**
 * This method sets if a board is associated with the club room set or
 * not.
 * @parm board_associated is there a board associated
 */
void set_board_associated(int board_associated) {
   // Make sure it only has a 0 or 1 value.
   board_associated = board_associated != 0;
   if (_club) {
      if (_board_contained != board_associated) {
         if (board_associated) {
            add_board_to(_club);
         } else {
            remove_board_from(_club);
         }
      }
   }
   _board_contained = board_associated;
} /* set_board_associated() */

/**
 * This method queries to see if there is a board associated or not
 * @return 1 if there is aboard associated with this club room set
 */
int query_board_associated() {
   return _board_contained;
} /* query_board_associated() */

/**
 * This method checks to see if there is an option associated with the
 * club room.
 * @param name the name of the optionto check
 * @return 1 if there is, 0 if not
 */
int is_option(string name) {
   return !undefinedp(_options[name]);
} /* is_option() */

/**
 * This method queries and option associated with the club room.
 * @param name the name of the option
 * @return the value of the option
 */
mixed query_option(string name) {
   return _options[name];
} /* query_option() */

/**
 * This remove removes an option associated with the club room.
 * @param name the name of the optoin
 * @return 1 on success, 0 on failure
 */
int remove_option(string name) {
   if (is_option(name)) {
      map_delete(_options, name);
      return 1;
   }
   return 0;
} /* remove_option() */

/**
 * This method sets the value of the option associated with the club room.
 * @param name the name of the option
 * @param value the new value for the option
 * @return 1 on success, 0 on failure
 */
int set_option(string name, mixed value) {
   _options[name] = value;
} /* set_option() */

/**
 * This method adds an item to have ownership.  If a function pointer
 * is set as the default name, then the method will be evaluated each
 * time the club changes.  The first arguement will be the name of the
 * owned item being changed and the second argument will be the new
 * club name.
 * @param name the name of the option that needs ownership control
 * @param type the type of controlled ownership
 * @param default_type the default ownership of the item
 * @param default_name the default name of the owner
 * @return 1 on success, 0 on failure
 */
int add_controlled_ownership(string name,
                             int type,
                             int default_type,
                             mixed default_name) {
   class ownership bing;

   if (!_ownership[name]) {
      bing = new(class ownership);
      bing->name = CLUB_UNKNOWN_MEMBER;
      bing->type = CLUB_ROOM_OWNED_PERSON;
      bing->control_type = type;
      _ownership[name] = bing;
      bing = new(class ownership);
      bing->name = default_name;
      bing->type = default_type;
      bing->control_type = type;
      _default_ownership[name] = bing;
      //save_me();
      return 1;
   }
   return 0;
} /* add_controlled_ownership() */

/**
 * This method sets the owner of the controlled ownership type.
 * @param controlled the item being controlled
 * @param owner the owner of the item
 * @param type the type of the owner
 * @return 1 on success, 0 on failure
 */
int set_controlled_ownership_owner(string controlled,
                                   string owner,
                                   int type) {
   class ownership bing;

   if (!_ownership[controlled]) {
      return 0;
   }
   bing = _ownership[controlled];
   bing->type = type;
   bing->name = owner;
   save_me();
   return 1;
} /* set_controlled_ownership_owner() */

/**
 * This is the function used for nominating someone exciting the the
 * owned position of the club rooms.
 * @param message the message being sent
 * @param club_name the name of the club
 * @param frog the discussion item
 * @param arg1 the first argument
 * @param arg2 the second argument
 */
mixed discuss_nominate_ownership(string message,
                                 string club_name,
                                 class discussion_idea frog,
                                 string arg1,
                                 string arg2) {
   string *nominated;
   string body;
   string *nom;
   string name;
   int ret;

   switch (message) {
   case CLUB_DISCUSS_MESSAGE_VERIFY :
      if (CLUB_HANDLER->query_club_name(club_name) != 
          CLUB_HANDLER->query_club_name(_club)) {
         return 0;
      }

      if (!_ownership[frog->information]) {
         return 0;
      }
      return 1;

   case CLUB_DISCUSS_MESSAGE_COMPLETE :
      body = "Hello!\n\nThe discussion item " 
         "added at " + ctime(frog->time_added) + ", finished at " +
         ctime(time()) + " and added by " + frog->added_by +
         " has finished.";
      body += "  The vote for nominations for the ownership of " +
         frog->information + " in the club " +
         CLUB_HANDLER->query_club_name(club_name) + 
         " has been completed and the "
         "results are:\n";
      nominated = ({ });
      foreach (name, nom in frog->choices) {
         body += name + ": " + query_multiple_short(nom);
         if ((member_array(name, nom) != -1 ||
              name[0..strlen(CLUB_ROOM_POSITION_START)] == CLUB_ROOM_POSITION_START) &&
              sizeof(nom) >= 2) {
            body += " (accepted)\n";
            nominated += ({ name });
         } else {
            body += "\n";
         }
      }
      if (frog->information) {
         body += frog->information;
      }
      if (sizeof(nominated)) {
         if (_ownership[frog->information]) {
            if (sizeof(nominated) != 1) {
               body += "Therefor we had added an election with " + 
                  query_multiple_short(nominated) +
                  " for the ownership of " +
                  frog->information + ".\n";
               CLUB_HANDLER->add_discussion_item(club_name,
                                   CLUB_DISCUSS_FUNCTION,
                                   frog->added_by,
                                   ({ file_name(this_object()),
                                      "discuss_elect_ownership" }),
                                   frog->information,
                                   nominated,
                                   7 * (24 * 60 * 60),
                                   0);
            } else {
               body += "Only " + nominated[0] +
                  " was nominated, so they are given ownership immediately.\n";
               if (name[0..strlen(CLUB_ROOM_POSITION_START)] == CLUB_ROOM_POSITION_START) {
                  
                  set_controlled_ownership_owner(frog->information,
                                                 nominated[0][strlen(CLUB_ROOM_POSITION_START)..],
                                                 CLUB_ROOM_OWNED_POSITION);
               } else {
                  set_controlled_ownership_owner(frog->information,
                                                 nominated[0],
                                                 CLUB_ROOM_OWNED_PERSON);
               }
            }
         } else {
            body += "The ownership item appears to have vanished!\n";
         }
      } else {
         if (_ownership[frog->information]) {
            body += "No one accepted their nomination, so nothing "
               "happened.\n";
            CLUB_HANDLER->add_discussion_item(club_name,
                                CLUB_DISCUSS_FUNCTION,
                                frog->added_by,
                                frog->name,
                                frog->information,
                                ({ }),
                                7 * (24 * 60 * 60),
                                frog->optional_data);
         } else {
            body += "The position in the club appears to have vanished!\n";
         }
      }
      return body;

   case CLUB_DISCUSS_MESSAGE_SHORT_DESCRIPTION :
      return "Nominations for ownership of " + frog->information;

   case CLUB_DISCUSS_MESSAGE_LONG_DESCRIPTION :
      body = "Nominations for the ownership of " + frog->information +
         ", positions or people can be nominated to have ownership.  "
         "Positions are nominated by putting the word 'position' in front "
         "ie: 'position president'.\n"
         "Currently nominated are:\n";
      foreach (name, nom in frog->choices) {
         body += name + ": " + query_multiple_short(nom);
         if ((member_array(name, nom) != -1 ||
              name[0..strlen(CLUB_ROOM_POSITION_START) - 1] == CLUB_ROOM_POSITION_START) &&
              sizeof(nom) >= 2) {
            body += " (accepted)\n";
         } else {
            body += "\n";
         }
      }
      return body;

   case CLUB_DISCUSS_MESSAGE_NOMINATION :
      if (CLUB_HANDLER->is_member_of(_club, arg1)) {
         // Ok, so the person nominating is a member.
         if (CLUB_HANDLER->is_member_of(_club, arg2) ||
             (name[0..strlen(CLUB_ROOM_POSITION_START) - 1] == CLUB_ROOM_POSITION_START &&
              CLUB_HANDLER->is_valid_position(_club, 
                                              name[strlen(CLUB_ROOM_POSITION_START)..]))) {
            if (!frog->choices[arg2]) {
               frog->choices[arg2] = ({ arg1 });
               return 1;
            } else if (member_array(arg1,
                                    frog->choices[arg2]) == -1) {
               frog->choices[arg2] += ({ arg1 });
               return 1;
            }
         }
      }
      return 0;

   case CLUB_DISCUSS_MESSAGE_TYPE :
      return CLUB_DISCUSS_MESSAGE_TYPE_NOMINATE;

   case CLUB_DISCUSS_MESSAGE_REMOVE_MEMBER :
      // Check out to see if they have been nominated or nominated someone.
      if (frog->choices[arg1]) {
         map_delete(frog->choices, arg1);
         ret = 1;
      }
      foreach (name, nom in frog->choices) {
         if (member_array(arg1, nom) != -1) {
            frog->choices[name] = nom - ({ arg1 });
            if (!sizeof(frog->choices[name])) {
               map_delete(frog->choices, name);
            }
            ret = 1;
         }
      }
      return ret;

   case CLUB_DISCUSS_MESSAGE_REMOVE_POSITION :
      if (frog->choices[CLUB_ROOM_POSITION_START + arg1]) {
         map_delete(frog->choices, CLUB_ROOM_POSITION_START + arg1);
         ret = 1;
      }
      return ret;

   case CLUB_DISCUSS_MESSAGE_CHANGE_POSITION :
      if (frog->choices[CLUB_ROOM_POSITION_START + arg1]) {
         frog->choices[CLUB_ROOM_POSITION_START + arg2] = frog->choices[CLUB_ROOM_POSITION_START + arg1];
         map_delete(frog->choices, CLUB_ROOM_POSITION_START + arg1);
         ret = 1;
      }
      return ret;

   case CLUB_DISCUSS_MESSAGE_NOMINATION_QUERY :
      return frog->choices;

   }
} /* discuss_nominate_ownership() */

/**
 * This is the function used for electing whoever gets to have the 
 * nice owned room.
 * @param message the message being sent
 * @param club_name the name of the club
 * @param frog the discussion item
 * @param arg1 the first argument
 * @param arg2 the second argument
 */
mixed discuss_elect_ownership(string message,
                              string club_name,
                              class discussion_idea frog,
                              string arg1,
                              string arg2) {
   string body;
   string name;
   int votes;
   int ret;
   int max_votes;
   string *names;

   switch (message) {
   case CLUB_DISCUSS_MESSAGE_VERIFY :
      if (CLUB_HANDLER->query_club_name(club_name) != 
          CLUB_HANDLER->query_club_name(_club)) {
         return 0;
      }

      if (!_ownership[frog->information]) {
         return 0;
      }
      return 1;

   case CLUB_DISCUSS_MESSAGE_COMPLETE :
      body = "Hello!\n\nThe discussion item " 
         "added at " + ctime(frog->time_added) + ", finished at " +
         ctime(time()) + " and added by " + frog->added_by +
         " has finished.";
      body += "  The vote for elections of the ownership of " +
              frog->information + 
         " in the club " +
         CLUB_HANDLER->query_club_name(club_name) + 
         " has been completed and the "
         "results are:\n";
      names = ({ });
      max_votes = 0;
      foreach (name, votes in frog->choices) {
         body += name + ": " + votes + "\n";
         if (votes > max_votes) {
            max_votes = votes;
            names = ({ name });
         } else if (votes == max_votes) {
            names += ({ name });
         }
      }
      if (_ownership[frog->information]) {
         if (sizeof(names) == 1) {
            body += "Therefor we set " + names[0] +
                  " as owning " + frog->information + ".\n";
            if (names[0][0..strlen(CLUB_ROOM_POSITION_START) - 1] == CLUB_ROOM_POSITION_START) {
               set_controlled_ownership_owner(frog->information,
                                              names[0][strlen(CLUB_ROOM_POSITION_START)..],
                                              CLUB_ROOM_OWNED_POSITION);
             } else {
               set_controlled_ownership_owner(frog->information,
                                              names[0],
                                              CLUB_ROOM_OWNED_PERSON);
             }
         } else {
            body += "There was a tie for the results of the position, readding "
                    "a discussion with the tied members: " +
                    query_multiple_short(names) + ".\n";
            CLUB_HANDLER->add_discussion_item(club_name,
                                   CLUB_DISCUSS_FUNCTION,
                                   frog->added_by,
                                   ({ file_name(this_object()),
                                      "discuss_elect_ownership" }),
                                   frog->information,
                                   names,
                                   7 * (24 * 60 * 60),
                                   frog->optional_data);
         }
      } else {
         body += "The ownership item appears to have vanished!\n";
      }
      return body;

   case CLUB_DISCUSS_MESSAGE_SHORT_DESCRIPTION :
      return "Election for ownership of " + frog->information;

   case CLUB_DISCUSS_MESSAGE_LONG_DESCRIPTION :
      body = "Election for the ownership of " + frog->information +
         ".\n";
      return body;

   case CLUB_DISCUSS_MESSAGE_TYPE :
      return CLUB_DISCUSS_MESSAGE_TYPE_VOTE;

   case CLUB_DISCUSS_MESSAGE_REMOVE_MEMBER :
      // Check out to see if they have been nominated or nominated someone.
      if (frog->choices[arg1]) {
         map_delete(frog->choices, arg1);
         ret = 1;
      }
      return ret;

   case CLUB_DISCUSS_MESSAGE_REMOVE_POSITION :
      if (frog->choices[CLUB_ROOM_POSITION_START + arg1]) {
         map_delete(frog->choices, CLUB_ROOM_POSITION_START + arg1);
         ret = 1;
      }
      return ret;

   case CLUB_DISCUSS_MESSAGE_CHANGE_POSITION :
      if (frog->choices[CLUB_ROOM_POSITION_START + arg1]) {
         frog->choices[CLUB_ROOM_POSITION_START + arg2] = frog->choices[CLUB_ROOM_POSITION_START + arg1];
         map_delete(frog->choices, CLUB_ROOM_POSITION_START + arg1);
         ret = 1;
      }
      return ret;
   }
} /* discuss_elect_ownership() */

private void setup_discussions() {
   string name;
   class ownership bing;

   foreach (name, bing in _ownership) {
      if (bing->control_type != CLUB_ROOM_CONTROLLED_FIXED) {
         CLUB_HANDLER->add_discussion_item(_club,
                                           CLUB_DISCUSS_FUNCTION,
                                           ({ file_name(this_object()),
                                              "discuss_nominate_ownership" }),
                                           name,
                                           ({ }),
                                           7 * 24 * 60 * 60,
                                           0);
      }
   }
} /* setup_discussions() */

/**
 * This method loads all the data from the save file.
 */
void load_me() {
//tell_creator("pinkfish", "Loading " + _save_file + "\n");
   if (_save_directory) {
      unguarded( (: restore_object(_save_directory + CLUB_ROOM_CONTROLLER_SAVE_FILE ) :) );
//tell_creator("pinkfish", "%O, %O, %O\n", _options, _club, _ownership);
   }
} /* load_me() */

/**
 * This method saves all the data to the save file.
 */
void save_me() {
   if (_save_directory) {
      unguarded( (: save_object(_save_directory + CLUB_ROOM_CONTROLLER_SAVE_FILE ) :) );
   }
} /* save_me() */

/**
 * This method sets the save directory for the club room controller.
 * @param save_file the new save file
 */
void set_save_directory(string save_directory) {
   while (save_directory[<1] == '/') {
      save_directory = save_directory[0..<2];
   }
   _save_directory = save_directory;
} /* set_save_directory() */

/**
 * This method returns the save file for the club room controller.
 * @return the save file for the club room controller
 */
string query_save_directory() {
   return _save_directory;
} /* query_save_directory() */

/**
 * This method returns the save file name to use for the room.
 * @param fname the file name to use for the room
 * @return the save file name to use
 */
string query_room_save_file_name(mixed fname) {
   if (objectp(fname)) {
      fname = file_name(fname);
   } 
   fname = fname[strsrch(fname, '/', -1)..];
   return _save_directory + fname;
} /* query_room_save_file_name() */
// --- END [/mnt/home2/grok/lib/std/room/controller/club_room_controller.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/water_outside.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/water_outside.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629289   Available: 13576643
Inodes: Total: 5242880    Free: 4960135
1975 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/water_outside.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629289   Available: 13576643
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * Standard outside water room inheritable.  This is mainly just a mux
 * for the functions that are defined in both /std/outside and
 * /std/room/basic/water.
 * @author Presto, Jeremy, Bakhtosh
 * @see /std/outside.c
 * @see /std/room/basic/water.c
 */

inherit "/std/room/outside";
inherit "/std/room/basic/water";

private int _setting_water_light = 0;

/**
 * @ignore yes
 */
void init() {
  water::init();
  outside::init();
}

/**
 * @ignore yes
 */
int is_allowed_position(string poss) {
  return water::is_allowed_position(poss);
}

/**
 * @ignore yes
 */
mixed *query_default_position(object ob) {
  return water::query_default_position(ob);
}

/**
 * @ignore yes
 */
int add_exit(string direc, mixed dest, string type) {
  int retval = outside::add_exit(direc, dest, type);
  water::add_exit(direc, dest, type);
  return retval;
}

/**
 * @ignore yes
 */
int query_light() {
  update_water_light();
  if (query_surface()) {
    return ::query_light();
  }
  return ::query_light()*query_clarity()/100;
}

/**
 * This function is used to set the light in a water room without overriding
 * the use of set_use_surface_light(1).  There should be no reason to use it
 * outside of the water inheritable.
 * @param number the new light level
 * @return the new light level
 * @see set_light
 * @see set_use_surface_light
 * @see update_water_light
 */
int set_water_light(int number) {
  _setting_water_light = 1;
  set_light(number);
  _setting_water_light = 0;
}

/**
 * @ignore yes
 */
int adjust_light(int number) {
  if (!_setting_water_light) {
    set_use_surface_light(0);
  }
  return ::adjust_light(number);
}

/**
 * @ignore yes
 */
mixed query_property(string tag) {
  if ("location" == tag && !query_surface()) {
    return "underwater";
  }
  return ::query_property(tag);
}

/**
 * This method sets the default attack speed for the room.
 * This defaults to 5 for water rooms.
 * @return the default attack speed
 */
int attack_speed() { return 5; }
// --- END [/mnt/home2/grok/lib/std/room/water_outside.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/guild-outside.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/guild-outside.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629288   Available: 13576642
Inodes: Total: 5242880    Free: 4960135
522 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/guild-outside.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629288   Available: 13576642
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is the standard guild inheritable for outside rooms. 
 * It makes a room the into
 * a place where players can advance and do all those other wonderful
 * guild things you would expect in a guild room.
 * @author No idea
 * @revision ceres July 1999
 * Change over to the new guild costing mechanisms.
 */
inherit "/std/room/outside";
inherit "/std/room/inherit/guild";

void create() {
  guild::create();
  outside::create();
} /* create() */

void init() {
  outside::init();
  guild::init();
} /* init() */
// --- END [/mnt/home2/grok/lib/std/room/guild-outside.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/delivery_room.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/delivery_room.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629288   Available: 13576642
Inodes: Total: 5242880    Free: 4960135
706 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/delivery_room.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629288   Available: 13576642
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: delivery_room.c,v 1.2 2000/06/21 23:54:00 pinkfish Exp $
 *
 *
 */

/**
 * This object provides a simple interface to the delivery inheritable.
 * It combines room and delivery functions.
 *
 * @author Taffyd
 */

inherit "/std/room/basic_room";
inherit "/std/delivery";

/** @ignore yes */
void create() {
    delivery::create();
    basic_room::create();
} /* create() */

/** @ignore yes */
void dest_me() {
    delivery::dest_me();
    basic_room::dest_me();
} /* dest_me() */

mixed *stats() {
    return delivery::stats() + basic_room::stats();
} /* stats() */


/** @ignore yes */
int query_delivery_room() {
    return 1;
} /* query_delivery_room() */
// --- END [/mnt/home2/grok/lib/std/room/delivery_room.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/council_archive.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/council_archive.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629288   Available: 13576642
Inodes: Total: 5242880    Free: 4960135
3752 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/council_archive.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629288   Available: 13576642
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This room is for looking at old closed cases.
 * @author Pinkfish
 * @started Tue Jun  3 10:22:28 PDT 2003
 */
inherit "/std/room/basic_room";
inherit "/std/room/inherit/council_base";
#define NOMIC_SYSTEM_CASE_CLASSES
#include <nomic_system.h>
#include <player_handler.h>
#include <mail.h>

void create() {
   ::create();
   add_help_file("council_archive");
} /* create() */

/**
 * The short description of the case.
 * @param the_case the case to get a short desc
 * @return the short description of the case
 */
string query_case_short(class nomic_case the_case) {
   string ret;

   ret = "Case #" + the_case->id + " \"" +
         the_case->short + "\" opened by " + the_case->opener +
         " against " + query_multiple_short(the_case->people) + " at " +
         ctime(the_case->time_opened);
   return ret;
} /* query_case_short() */

/**
 * This method lists all the currently open cases.
 * @return 1 for success, 0 if failed
 */
int do_list_all_cases() {
   int* cases;
   string ret;
   int id;

   cases = NOMIC_HANDLER->query_closed_cases(query_council_area());
   if (!sizeof(cases)) {
      add_failed_mess("There are no open cases.\n");
      return 0;
   }
   ret = "Currently closed cases:\n";
   foreach (id in cases) {
      //the_case = NOMIC_HANDLER->query_open_case(query_council_area(), id);
      ret += "$I$5=$C$Case #" + id;
      ret += "\n";
   }
   this_player()->more_string(ret, "closed cases");
   return 1;
} /* do_list_closed_cases() */

/**
 * This method lists the specified open case.
 * @param case_id the case to list
 * @return 1 for success, 0 if failed
 */
int do_list_case(int case_id) {
   string ret;
   class nomic_case the_case;
   class nomic_case_note note;
   class nomic_case_event event;
   int id;

   ret = "";
   the_case = NOMIC_HANDLER->query_closed_case(query_council_area(), case_id);
   if (!the_case) {
      add_failed_mess("Unable to find the case.\n");
      return 0;
   }
   ret += "$I$3=" + query_case_short(the_case);
   if (sizeof(the_case->events)) {
      ret += "\n";
      ret += "$I$0=%^YELLOW%^Events%^RESET%^:\n";
      foreach (event in the_case->events) {
         ret += "$I$6=   " +
                capitalize(NOMIC_HANDLER->query_event_name(event->type)) +
                " " +
                "by " + event->person + " at " + ctime(event->event_time) +
                " " +
                event->mess + "\n";
      }
   }
   if (sizeof(the_case->notes)) {
      ret += "\n";
      ret += "$I$0=%^YELLOW%^Notes%^RESET%^:\n";
      foreach (id in the_case->notes) {
         note = NOMIC_HANDLER->query_note(id);
         ret += "$I$6=   Note by " + note->person + " at " +
                ctime(note->time_created) +
                ".\n" + note->text + "\n\n";
      }
   }
   this_player()->more_string(ret, "closed case");
   return 1;
} /* do_list_case() */

/**
 * This method lists the currently online citizens in a nice list.
 */
int do_list_citizens() {
    object* cits;
    string ret;
    string area;
    
    area = this_object()->query_council_area();

    cits = filter( users(), (: NOMIC_HANDLER->is_citizen_of( 
       this_object()->query_council_area(), $1->query_name() ) &&
       $1->query_visible( this_player() ) :) );
    cits = sort_array(cits, (: strcmp($1->query_name(), $2->query_name()) :));

    ret = "The online citizens (and magistrates) of " + area + " are:\n\n";
    ret += query_multiple_short(cits);
    write("$P$Citizens Online$P$" + ret);

    return 1;
} /* int do_list() */

/** @ignore yes */
void init() {
   add_command("list", "", (: do_list_all_cases() :));
   add_command("list", "[case] <number>", (: do_list_case($4[0]) :));
   add_command("list", "citizens", (: do_list_citizens() :));
} /* init() */
// --- END [/mnt/home2/grok/lib/std/room/council_archive.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/room_rental.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/room_rental.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629287   Available: 13576641
Inodes: Total: 5242880    Free: 4960135
401 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/room_rental.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629287   Available: 13576641
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * A Room Rental room inheritable
 * that include the /std/room/basic_room
 * inheritable
 *
 * @author goldenthread
 * @started 14 Jul y2k2
 *
 */

#include <room/room_rental.h>

inherit "/std/room/basic_room";
inherit ROOM_RENTAL_INHERIT_ROOM;

/** @ignore yes */
void create() {
   basic_room::create();
} /* create() */

/** @ignore yes */
void init() {
   basic_room::init();
} /* init() */

// --- END [/mnt/home2/grok/lib/std/room/room_rental.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/player_housing_outside.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/player_housing_outside.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629286   Available: 13576640
Inodes: Total: 5242880    Free: 4960135
4273 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/player_housing_outside.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629286   Available: 13576640
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is the standard inheritable for a player-owned house outside room,
 * like for gardens and things.
 * <p>
 * All you need to do is inherit this file and call a couple of setup
 * functions and off you go.
 * <p>
 * In addition you will need to have a lord register the house with the
 * housing command if you wish the house to be available for sale or rent
 * using the normal processes.
 *
 * @example
 * inherit "/std/room/player_housing_outside";
 *
 * void setup() {
 *   set_light(100);
 *   set_theft_handler(HOSPITAL);
 *   set_save_file("/save/player_housing/am/short/flat1_garden");
 *
 *   set_short("front room");
 *   set_base_desc("a small garden" );
 *   add_surface( "floor", "grass" );
 *   add_surface( "north wall", "red brick" );
 *   add_surface( "south wall", "red brick" );
 *   add_surface( "east wall", "red brick" );
 *   add_surface( "west wall", "red brick" );
 *   add_exit("south", PATH+"flat1", "door");
 * }
 *
 * @author Belle, Gototh, Ceres, Pinkfish
 */
#include <dirs.h>
#include <housing.h>
#include <login_handler.h>
#include <player.h>

inherit "/std/room/outside";
inherit "/std/room/inherit/player_housing";

/** @ignore yes */
void create() {
  add_help_file("player_housing");
  do_setup++;
  outside::create();
  player_housing::create();
  do_setup--;
  if ( !do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }
  seteuid("Room");
  add_property("no burial", 1);
}

/** @ignore yes
 * Internal function to update the dynamic long description of the room.
 */
string query_long() {
  return player_housing::query_long();
}

/**
 * This method returns the current owner of the house.
 */
string query_owner() {
   return HOUSING->query_owner(base_name(this_object()));
} /* query_owner() */

/** @ignore yes
 * Just makes sure room exits are relative inside houses and that doors
 * are closed.
 */
int add_exit(string direc, mixed dest, string type) {
  int tmp;

  tmp = ::add_exit(direc, dest, type);
  setup_exit(direc, 0);
  return tmp;
}

/** @ignore yes
 * Stops positioned objects from showing.  If it has a CURRENT_ROOM_VERB
 * property it's obviously a placed object and shouldn't been seen.
 */
string process_non_living(object *int_non_livings, int start) {
  object *not_positioned;
 
  not_positioned = player_housing::my_process_non_living(int_non_livings);
  return ::process_non_living(not_positioned, start);
} /* process_non_living() */

/** @ignore yes */
void init() {
  player_housing::init();
  outside::init();
}

/** @ignore yes */
void event_exit(object ob, string message, object to) {
  outside::event_exit(ob, message, to);
  player_housing::event_exit(ob, message, to);
}

/** @ignore yes
 * Cleanup could screw us up so we stay loaded.
 */
int query_keep_room_loaded() { return 1; }

/** @ignore yes */
void dest_me() {
  player_housing::dest_me();
  outside::dest_me();
}

/**
 * @ignore yes
 * Calls appropriate test_remove() functions and does PK checks for removal
 * of items from this house.
 */
int test_remove(object thing, int flag, mixed dest) {
  object thief;
  mixed *stuff;
  
  if(!outside::test_remove(thing, flag, dest))
    return 0;

  thief = this_player();
  if(!thief)
    return player_housing::test_remove(thing, flag, dest);
  
  if(thief->query_caster())
    thief = find_player(thief->query_caster());
  else if(thief->query_owner())
    thief = thief->query_owner();

  stuff = thing->query_property("dropped");

  // Do PK checks for taking this rooms inventory away.
  if(thief &&
     test_save(thing) && 
     !test_occupier(thief->query_name()) &&
     (!stuff || stuff[0] != thief->query_name())) { 
    log_file("HOUSING_THEFT", "%s: %s stole %s from %s in %s\n",
             ctime( time() )[4..18], (string)thief->query_short(),
             thing->query_short(),
             (string)query_owner(), file_name());
    
    event(this_object(), "theft", thief, this_object(), ({ thing }));
  }

  return player_housing::test_remove(thing, flag, dest);
}

/**
 * @ignore yes
 * Makes sure furniture is saved when its put in this room.
 */
int test_add( object ob, int flag) {
  int retval;
  
  retval = outside::test_add(ob, flag);
  if(retval)
    retval = player_housing::test_add(ob, flag);
  return retval;
} /* test_add() */
// --- END [/mnt/home2/grok/lib/std/room/player_housing_outside.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/punishments/fine.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/punishments/fine.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629285   Available: 13576639
Inodes: Total: 5242880    Free: 4960135
6487 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/punishments/fine.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629285   Available: 13576639
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is the method for fining someone in am.  This handles keeping
 * track fo the fines and the setup of fines.  This punihshment needs to
 * be inherited to work correctly.
 * @author Pinkfish
 * @started Thu Sep 21 14:35:32 PDT 2000
 */
#include <money.h>
#include <nomic_system.h>
#include <player_handler.h>
inherit "/std/room/inherit/punishment_inherit";

// 4 weeks timeout
#define TIMEOUT (4 * 7 * 24 * 60 * 60)

private mapping _fines;
private nosave string _money_area;
private nosave string _save_file;

class fine_type {
   int paid;
   int fines;
   int last_touched;
}

void load_me();

void setup() {
   _fines = ([ ]);
   set_short("fine");
   set_description_file(NOMIC_PUNISHMENT_DOCS_DIR + "fine");
   seteuid(getuid());
   load_me();
} /* setup() */

/** @ignore yes */
void load_me() {
   if (_save_file) {
      unguarded((: restore_object( _save_file ) :));
      call_out("remove_old_fines", 2);
   }
} /* load_me() */

/** @ignore yes */
void save_me() {
   unguarded((: save_object( _save_file ) :));
} /* save_me() */

/**
 * This method nips through the list of fines and removes any fines that
 * are either for people that do not exist any more, or totals that are
 * old.
 */
void remove_old_fines() {
   class fine_type fine;
   string player;
   int changed;

   foreach (player, fine in _fines) {
      if (!PLAYER_HANDLER->test_user(player)) {
         map_delete(_fines, player);
         changed = 1;
      }
      if (sizeof(fine) == 2) {
         fine = new(class fine_type, paid : fine->paid, fines : fine->fines,
                                last_touched : time());
         _fines[player] = fine;
         changed = 1;
      }
      if (fine->fines <= 0 && fine->last_touched + TIMEOUT < time()) {
         map_delete(_fines, player);
         changed = 1;
      }
   }
   if (changed) {
      save_me();
   }
}

/**
 * This method sets the money area of the fine.
 * @param area the money area
 */
void set_money_area(string area) {
   _money_area = area;
} /* set_money_area() */

/**
 * This method returns the money area of the fine.
 * @return the money area
 */
string query_money_area() {
   return _money_area;
} /* query_money_area() */

/**
 * This method sets the save file of the fines.
 * @param fname the save file name
 */
void set_save_file(string fname) {
   _save_file = fname;
} /* set_save_file() */

/**
 * This method returns the save file of the fines.
 * @return the save file name
 */
string query_save_file() {
   return _save_file;
} /* query_save_file() */

//
// The punishment handle area
//

/**
 * @ignore yes
 */
void start_punishment(string area,
                      class nomic_case the_case,
                      string type,
                      function finish) {
   write("How much do you wish to fine " +
         query_multiple_short(the_case->people) + "? ");
   input_to("fine_amount", 0, area, the_case, type, finish);
} /* start_punishment() */

/** @ignore yes */
string query_short(string area,
                      class nomic_case the_case,
                      string type,
                      mixed data) {
   return "fined " +
          MONEY_HAND->money_value_string(data, _money_area);
} /* query_short() */

/**
 * @ignore yes
 */
void fine_amount(string amt, string area, class nomic_case the_case,
                 string type, function finish) {
   int value;

   amt = lower_case(amt);
   if (!strlen(amt) || amt[0] == 'q') {
      write("Aborting the fine.\n");
      return ;
   }

   //
   // See if it has a value.
   //
   value = MONEY_HAND->value_from_string(amt, _money_area);
   if (value <= 0) {
      write("You did not specify a positive money value.\n");
      write("How much do you wish to fine " +
            query_multiple_short(the_case->people) + "? ");
      input_to("fine_amount", 0, area, the_case, type, finish);
      return ;
   }

   evaluate(finish, the_case, type, value);
} /* fine_amount() */

/**
 * @ignore yes
 */
void complete_punishment(string area,
                      class nomic_case the_case,
                      string type,
                      mixed data) {
   string person;

   foreach (person in the_case->people) {
      if (!_fines[person]) {
         _fines[person] = new(class fine_type);
      }
      _fines[person]->fines += data;
      _fines[person]->last_touched = time();
   }
   save_me();

   return ;
} /* complete_punishment() */

/**
 * @ignore yes
 */
void suspend_punishment(string area,
                      class nomic_case the_case,
                      string type,
                      mixed data) {
   string person;

   foreach (person in the_case->people) {
      if (!_fines[person]) {
         _fines[person] = new(class fine_type);
      }
      _fines[person]->fines -= data;
      _fines[person]->last_touched = time();
   }
   save_me();

   return ;
} /* suspend_punishment() */

//
//  The fine control area.
//

/**
 * This method pays a fine.
 * @param person the person doing the payment
 * @param amount the amount being paid
 * @return 1 on success, 0 on failure
 */
int pay_fine(string person, int amount) {
   if (_fines[person]) {
      _fines[person]->paid += amount;
      _fines[person]->last_touched = time();
      save_me();
      return 1;
   }
   return 0;
} /* pay_fine() */

/**
 * This method figures out the current fine for the person.
 * @param person the person to get the fine for
 * @return the currently outstanding fines
 */
int query_current_fine(string person) {
   if (_fines[person]) {
      return _fines[person]->fines - _fines[person]->paid;
   }
   return 0;
} /* query_current_fine() */

/**
 * This method figures out the current total fine for the person.
 * @param person the person to get the fine for
 * @return the currently outstanding fines
 */
int query_total_fine(string person) {
   if (_fines[person]) {
      return _fines[person]->fines;
   }
   return 0;
} /* query_total_fine() */

/**
 * This method figures out the current total fine for the person.
 * @param person the person to get the fine for
 * @return the currently outstanding fines
 */
int query_total_payments(string person) {
   if (_fines[person]) {
      return _fines[person]->paid;
   }
   return 0;
} /* query_total_payments() */

/**
 * This method returns the list of players that have outstanding fines
 * in the fine handler.
 * @return the list of players
 */
string* query_people_with_fines() {
   return keys(_fines);
} /* query_people_with_fines() */
// --- END [/mnt/home2/grok/lib/std/room/punishments/fine.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/punishments/not_guilty.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/punishments/not_guilty.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629283   Available: 13576637
Inodes: Total: 5242880    Free: 4960135
340 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/punishments/not_guilty.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629283   Available: 13576637
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is the standard punishment file for a verdict of not guilty.
 * @author Pinkfish
 * @started Tue Sep 19 14:37:28 PDT 2000
 */
#include <nomic_system.h>

inherit "/std/room/inherit/punishment_inherit";

void setup() {
   set_short("not guilty");
   set_description_file(NOMIC_PUNISHMENT_DOCS_DIR + "not_guilty");
} /* setup() */
// --- END [/mnt/home2/grok/lib/std/room/punishments/not_guilty.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/punishments/banishment.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/punishments/banishment.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629283   Available: 13576637
Inodes: Total: 5242880    Free: 4960135
3130 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/punishments/banishment.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629283   Available: 13576637
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is the standard punishment file for banishing someone from a
 * city.
 * @author Pinkfish
 * @started Tue Sep 19 14:37:28 PDT 2000
 */
#include <nomic_system.h>

inherit "/std/room/inherit/punishment_inherit";

private nosave string _banish_handler;

void create() {
   set_short("banishment");
   set_description_file(NOMIC_PUNISHMENT_DOCS_DIR + "banishment");
   ::create();
} /* setup() */

/**
 * This method sets the banish handler.  The banish handler will be called
 * with two methods, one is:<br>
 * banish_person(string name, int days)<br>
 * banish_person_suspend(string name)
 * @param handler the banish handler
 */
void set_banish_handler(string hand) {
   _banish_handler = hand;
} /* set_banish_handler() */

/**
 * This method returns the banish handler.
 * @return the banish handler
 */
string query_banish_handler() {
   return _banish_handler;
} /* query_banish_handler() */

/** @ignore yes */
string query_short(string area, class nomic_case the_case, string type, mixed data) {
   return ::query_short() + " for " + data + " days";
} /* query_short() */

/**
 * @ignore yes
 */
void start_punishment(string area,
                      class nomic_case the_case,
                      string type,
                      function finish) {
   if (sizeof(filter(the_case->people,
                    (: NOMIC_HANDLER->is_magistrate_of($2, $1) :), area))) {
      write("You cannot banish a magistrate.\n");
      return ;
   }

   write("How long do you want the person banished from the city for (in "
         "days, 0 means forever)? ");
   input_to("days_of_banishment", 0, area, the_case, type, finish);
} /* start_punishment() */

/** @ignore yes */
void days_of_banishment(string input,
                        string area,
                        class nomic_case the_case,
                        string type,
                        function finish) {
   int num;

   input = lower_case(input);
   if (input == "" || input[0] == 'q') {
      write("Aborting banishment.\n");
      return ;
   }

   if (input[0] >= '0' && input[0] <= '9') {
      if (sscanf(input, "%d", num) == 1) {
         evaluate(finish, the_case, type, num);
         return ;
      }
   }
   write("Invalid input.\n");
   write("How long do you want the person banished from the city for (in "
         "days, 0 means forever)? ");
   input_to("days_of_banishment", 0, area, the_case, type, finish);
} /* days_of_banishment() */

/**
 * @ignore yes
 */
void complete_punishment(string area,
                      class nomic_case the_case,
                      string type,
                      mixed data) {
   string person;

   foreach (person in the_case->people) {
      _banish_handler->banish_person(person, data);
   }
   return ;
} /* complete_punishment() */

/**
 * @ignore yes
 */
void suspend_punishment(string area,
                      class nomic_case the_case,
                      string type,
                      mixed data) {
   string person;

   foreach (person in the_case->people) {
      _banish_handler->banish_person_suspend(person);
   }
   return ;
} /* suspend_punishment() */
// --- END [/mnt/home2/grok/lib/std/room/punishments/banishment.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/punishments/title.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/punishments/title.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629282   Available: 13576636
Inodes: Total: 5242880    Free: 4960135
4611 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/punishments/title.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629282   Available: 13576636
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is the method for forcing someone to have a title of some sort.
 * It allows a range of different titles to be chosen from.
 * This punihshment needs to
 * be inherited to work correctly.
 * @author Pinkfish
 * @started Thu Jun 26 14:46:36 PDT 2003
 */
#include <money.h>
#include <nomic_system.h>
#include <player_handler.h>
#include <player.h>
inherit "/std/room/inherit/punishment_inherit";

private nosave string* _titles;

void create() {
   _titles = ({ });
   set_description_file(NOMIC_PUNISHMENT_DOCS_DIR + "title");
   set_short("title");
   ::create();
} /* create() */

/**
 * This method sets the allowable list of titles used for this area.
 * @param titles the list of titles to use
 */
void set_titles(string* titles) {
   _titles = titles;
}

/**
 * This method returns the list of allowable titles to use for this
 * area.
 * @return the list of allowable titles
 */
string* query_titles() {
   return _titles;
}

//
// The punishment handle area
//

/**
 * @ignore yes
 */
void start_punishment(string area,
                      class nomic_case the_case,
                      string type,
                      function finish) {
   int i;

   for (i = 0; i < sizeof(_titles); i++) {
      write(sprintf("%c) %s\n", i + 'A', _titles[i]));
   }
   write("Which title do you wish " +
         query_multiple_short(the_case->people) + " to have? ");
   input_to("choose_title", 0, area, the_case, type, finish);
} /* start_punishment() */

/** @ignore yes */
string query_short(string area,
                      class nomic_case the_case,
                      string type,
                      mixed data) {
   return "set to a title of " + data[0] + " for " + data[1] + " hours";
} /* query_short() */

/**
 * @ignore yes
 */
void choose_title(string title, string area, class nomic_case the_case,
                 string type, function finish) {
   int i;
   int pos;

   if (!strlen(title) || title[0] == 'q') {
      write("Aborting the title setting.\n");
      return ;
   }

   title = lower_case(title);
   if (strlen(title) == 1) {
      pos = title[0] = 'a';
      if (pos >= 0 && pos < sizeof(_titles)) {
         title = _titles[pos];
      }
   }
   if (member_array(title, _titles) == -1) {
      write("You did not specify a valid title.\n");
      for (i = 0; i < sizeof(_titles); i++) {
         write(sprintf("%c) %s\n", i + 'A', _titles[i]));
      }
      write("What title do you want to give " +
            query_multiple_short(the_case->people) + "? ");
      input_to("choose_title", 0, area, the_case, type, finish);
      return ;
   }

   write("How long do you wish " +
            query_multiple_short(the_case->people) + " to keep the title " +
         title +
         "(this is in hours and is online time, not real time)? ");
   input_to("choose_timeout", 0, area, the_case, type, finish, title);
} /* fine_amount() */

void choose_timeout(string str, string area, class nomic_case the_case,
                 string type, function finish, string title) {
   int timeout;

   if (!strlen(str) || str[0] == 'q') {
      write("Aborting the title setting.\n");
      return ;
   }

   timeout = to_int(str);
   if (timeout <= 0) {
      write("The timeout must be greator than 0 hours.\n");
      write("How long do you wish " +
            query_multiple_short(the_case->people) + " to keep the title " +
            title + "?");
      input_to("choose_timeout", 0, area, the_case, type, finish, title);
      return ;
   }

   if (timeout > 30) {
      write("The timeout must be less than 30 hours.\n");
      write("How long do you wish " +
            query_multiple_short(the_case->people) + " to keep the title " +
            title + "?");
      input_to("choose_timeout", 0, area, the_case, type, finish, title);
      return ;
   }

   evaluate(finish, the_case, type, ({ title, timeout }));
}

/**
 * @ignore yes
 */
void complete_punishment(string area,
                      class nomic_case the_case,
                      string type,
                      mixed data) {
   string person;

   foreach (person in the_case->people) {
      PLAYER_TITLE_HANDLER->set_forced_title_on_player(person, data[0], data[1] * (60 * 60));
   }

   return ;
} /* complete_punishment() */

/**
 * @ignore yes
 */
void suspend_punishment(string area,
                      class nomic_case the_case,
                      string type,
                      mixed data) {
   string person;

   foreach (person in the_case->people) {
      PLAYER_TITLE_HANDLER->remove_forced_title(person, data[0]);
   }

   return ;
} /* suspend_punishment() */
// --- END [/mnt/home2/grok/lib/std/room/punishments/title.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/punishments/lose_citizenship.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/punishments/lose_citizenship.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629281   Available: 13576635
Inodes: Total: 5242880    Free: 4960135
1985 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/punishments/lose_citizenship.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629281   Available: 13576635
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is the standard punishment file for losing someone's
 * citizenship.
 * @author Pinkfish
 * @started Tue Sep 19 14:37:28 PDT 2000
 */
#include <nomic_system.h>

inherit "/std/room/inherit/punishment_inherit";

void setup() {
   set_short("lose citizenship");
   set_description_file(NOMIC_PUNISHMENT_DOCS_DIR + "lose_citizenship");
} /* setup() */


/**
 * @ignore yes
 */
void start_punishment(string area,
                      class nomic_case the_case,
                      string type,
                      function finish) {
   string* not_citizens;
   string* magistrates;

   not_citizens = filter(the_case->people,
                     (: !NOMIC_HANDLER->is_citizen_of($2, $1) :), area);
   if (sizeof(not_citizens)) {
      write(query_multiple_short(not_citizens) + " cannot lose "
            "their citizenship since they are not citizens.\n");
      return ;
   }

   magistrates = filter(the_case->people,
                    (: NOMIC_HANDLER->is_magistrate_of($2, $1) :), area);
   if (sizeof(magistrates)) {
      write(query_multiple_short(magistrates) + " cannot lose "
            "their citizenship since they are magistrates.\n");
      return ;
   }
   evaluate(finish, the_case, type, 0);
} /* start_punishment() */

/**
 * @ignore yes
 */
void complete_punishment(string area,
                      class nomic_case the_case,
                      string type,
                      mixed data) {
   string citizen;

   foreach (citizen in the_case->people) {
      NOMIC_HANDLER->remove_citizen(area, citizen);
   }

   return ;
} /* complete_punishment() */

/**
 * @ignore yes
 */
void suspend_punishment(string area,
                      class nomic_case the_case,
                      string type,
                      mixed data) {
   string citizen;

   //
   // Make them citizens again...
   //
   foreach (citizen in the_case->people) {
      NOMIC_HANDLER->add_citizen(area, citizen);
   }

   return ;
} /* suspend_punishment() */
// --- END [/mnt/home2/grok/lib/std/room/punishments/lose_citizenship.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/punishments/dismissed.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/punishments/dismissed.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629280   Available: 13576634
Inodes: Total: 5242880    Free: 4960135
338 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/punishments/dismissed.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629280   Available: 13576634
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is the standard punishment file for a verdict of not guilty.
 * @author Pinkfish
 * @started Tue Sep 19 14:37:28 PDT 2000
 */
#include <nomic_system.h>

inherit "/std/room/inherit/punishment_inherit";

void setup() {
   set_short("dismissed");
   set_description_file(NOMIC_PUNISHMENT_DOCS_DIR + "dismissed");
} /* setup() */
// --- END [/mnt/home2/grok/lib/std/room/punishments/dismissed.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/auction_room.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/auction_room.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629280   Available: 13576634
Inodes: Total: 5242880    Free: 4960135
52003 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/auction_room.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629280   Available: 13576634
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * Auction Room Inheritable
 * This room will give you everything you need to make an auction
 * room.
 * @author Terano
 * @started 3 October, 1998
 * @changed 24 March, 1999 Many exciting things. Terano.
 * @changed 2 October, 1999 Added stability! Excitement! 
 * An excessively complicated browse function! Terano.
 * @changed 8 January, 2000! Made Y2K compliant! (Just kidding)
 * Added some advertising stuff.
 * Fixed a missing case as well.
 * @changed 11 January, 2000 Fixed some advertising stuff.
 */

#include <money.h>
#include <move_failures.h>
#include <player_handler.h>
#include <mail.h>

#define COLOUR_ID "colour code"

#define AUCTION_PLAYER_NAME 0
#define AUCTION_PLAYER_BID 1

#define ERRNOSPACE -1 //No space
#define ERRBADPARM -2 //Bad parameter
#define ERRBADCBOB -3 //Bad call back object
#define ERROBNOMOVE -4 //Autoload gen failed due to bad move
#define ERRGENFAIL -5 //General failure
#define ERRNORECV -6  //Could not recover autoloading
#define ERRRECVEMP -7 //Case recovered as empty
#define WARNUNDEST -8 //An object being converted was undestable.
#define WARNEXCL -9 //Bidder has been excluded
#define WARNNOLOTS "NULL" //We have no lots!

#define TCTP( x, y ) tell_creator( this_player(), x, y )
#define GECM( x ) "/global/events"->convert_message( x )

#define c_item class item
#define c_store class store
#define c_lot class lot

#define OPEN "open"
#define CLOSED "closed"
#define WAIT_SELLER "waitsell"
#define WAIT_BUYER "waitbuy"
#define WAIT_BUYER_LAPSE "waitbuylapse"
#define WAIT_CRE_INTERVENTION "waitcreint"

#define CHECK_CYCLE 10  //Apparently the control function is efficient enough 

#define COLOURS ({ "red", "orange", "yellow", "blue", "green", "indigo",\
  "violet", "crimson", "puce", "emerald", "ochre", "tangerine", "aquamarine",\
  "silver", "gold", "copper", "lilac" })
#define NO_COLOURS sizeof( COLOURS )

nosave inherit "/std/room";  //Why save all those evil room variables?
inherit "/global/auto_load";

/**
 * In this new version, we aren't keeping the objects loaded,
 * because the auto_load code seems flaky outside of 
 * /global/player.c
 * Instead keep a whole bunch of info about it on file.
 */
 
c_item {
  string name;
  string *alias;
  string *adjectives;
  string long;
  string read_mess;
  string enchant_mess;
}

c_store {
  int case_code;
  string colour;
  string inv_string;
  c_item *inventory;
}

/**
 * A few notes about this class, I didn't like the way the old one
 * worked, when a lot moved to expired_lots, there was no real way to recover it
 * Instead, we will keep one array of all lots, with differing status's depending
 * on whats happening.
 * IE: Open: Accepting bids.
 *     Waiting: Seller: It did not take any acceptable bids and it is waiting collection
 *       by the seller.
 *     Waiting: Buyer: A bid was taken and we are waiting for payment.
 *     Waiting: Buyer (lapsed): A bid was taken, but lapsed. There are no 
 *       other bidders, so in the next cycle the seller will be mailed and
 *       status changed to Waiting: Seller.
 *     Waiting Creator Intervention:  A lot has fallen over in some way,
 *       and needs a creator to fix it.
 *     Closed: The bid has been collected (by either buyer or seller),
 *       lots will stay in this status for 2 hours after collection.
 *       Then payment will be credited to the payment array and the lot will 
 *       be deleted.
 * Case code is used in reference to the store class.
 * The rest are the same as they were in the last version
 */

c_lot {
  int case_code; //The code that matches this bid.
  c_store assoc_store; //Associated store, to save processing! 
  string seller; //Name of the person/object selling
  string status; //Either Open, Waiting: Seller, Waiting: Buyer or Closed.
  int expiration_time; //Time that this status stops
  int reserve_price; //Min price
  mapping bids; //Mapping of bids
  mixed *lot_autoload; //Autoload info for the bid
  mixed *current_bid; //Info on the current bid
  string *auto_bids; //I'm not sure yet, but it will become apparent
  string notes; //Player added notes
  string *excluded; //People player wants excluded from bidding.
}

c_lot *lots = ({ }); //Array of lots
mapping payments = ([ ]); //Stored as ([ "name": amount ]);
int lot_count = 0;
nosave string *used_colours = ({ });
nosave string currency = "default";
nosave string location = "unset";
nosave string shop_name = "REAS Auction Inheritable";
nosave int admin_cost = 2000; //defaults to AM$5
nosave float commission = ( 5.0/100.0 ); //Default to 5%

/**
 * I've decided that a large amount of problems with this code 
 * were from the cases, to add realism, I've left them in, but 
 * I've removed all the functionality from them and moved it in 
 * here.
 */
mapping cases = ([ ]); //Something like: ([ /std/object#123: 0001 ])

void save_file();
void load_file();

void set_location( string loc );
void set_currency( string cur );
void set_admin_cost( int value );
void set_commission( int percent );
void set_case_desc( string *bits );
mixed recover_lot( mixed lot_autoload );

int change_status( int lot_ident, string new_status );
void adjust_money( int amount, object player );
mixed generate_auto_load( object *obs );
c_store generate_store( object *things, int lot_id );
c_lot query_status( int lot_ident );

int do_deposit( object *things, int auction_time, string time_type,
  string res_price );
int do_bid( string offer, object *boxes );
int do_collect( string pattern );
int do_list();
int do_withdraw( object *boxes);
int do_describe( object *boxes, string int_desc );
int do_exclude( object *cases, string excluded );
int do_browse( object *cases, string target, int identifier );
int do_unexclude( object *cases, string excluded );
string generate_advertising_string( c_lot lot );
string generate_random_adv_str();

/**
 * @ignore
*/
void create() {

    do_setup++;
    ::create();
    do_setup--;

    if ( !do_setup ) {
       this_object()->setup();
       this_object()->reset();
    }

    call_out( "load_file", 1 ); //To give time for location data to be restored
    call_out( "load_store", 2 ); //To give time for save data to be restored
    call_out( "lot_check", 5 ); //Lets do some work!
}

/**
 * @ignore
 */
void init() {

    this_player()->add_command( "bid", this_object(),
      "<string'amount'> {on|for} <indirect:object:here'case'>",
      (: do_bid( $4[0], $1 ) :) );

   this_player()->add_command( "collect", this_object(),
      ({ "successful bids", "money", "expired lots",
        "all" }),
      (: do_collect( $5 ) :) );

    this_player()->add_command( "deposit", this_object(),
      "<indirect:object:me'items'> for <number> "
      "{minute|hour|day} auction" ,
      (: do_deposit( $1, $4[1], $4[2], "" ) :) );

   this_player()->add_command( "deposit", this_object(), 
      "<indirect:object:me'items'> for <number> "
      "{minute|hour|day} "
      "auction with [a] reserve price of <string'amount'>",
      (: do_deposit( $1, $4[1], $4[2], $4[3] ) :) );

    this_player()->add_command( "list", this_object(), "" );

   this_player()->add_command( "browse", this_object(), 
       "<string'object'> in <indirect:object'case'>", (: do_browse( $1, $4[0], 0 ) :) );

    this_player()->add_command( "browse", this_object(), 
       "<string'object'> <number> in <indirect:object'case'>",
       (: do_browse( $1, $4[0], $4[1] ) :) );

    this_player()->add_command( "withdraw", this_object(), 
      "<indirect:object'case'> from auction",
      (: do_withdraw( $1 ) :) );

   this_player()->add_command( "write", this_object(), 
      "<string'text'> on <indirect:object'case'>",
      (: do_describe( $1, $4[0] ) :) );

   this_player()->add_command( "exclude", this_object(), 
      "<string'name'> from bidding on <indirect:object'case'>",
      (: do_exclude( $1, $4[0] ) :) );

   this_player()->add_command( "exclude", this_object(), 
      "list for <indirect:object'case'>",
      (: do_exclude( $1, "list" ) :) );

   this_player()->add_command( "exclude", this_object(), 
      "current ignore list from bidding on <indirect:object'case'>",
      (: do_exclude( $1, "ignore list" ) :) );

   this_player()->add_command( "unexclude", this_object(), 
      "<string'name'> from bidding on <indirect:object'case'>",
      (: do_unexclude( $1, $4[0] ) :) );
}


/**
 * This function allows an object to deposit an item for auction,
 * Things are the items to auction, auction length is the length in seconds,
 * function_cb and object_cb are function names and object paths to allow a
 * call back to be scheduled for when the auction is over, res price is
 * the reserve price and int_desc is a description that will be written on
 * the case. If an error code is generated, it is upon the object calling
 * this function to pull those objects back. An object reference isn't
 * kept here.
 */
int automated_deposit( object *things, int auction_length, 
 string function_cb, string object_cb, int res_price,
  string int_desc ) {

  mixed *auto_load_string;
  c_lot temp;
  c_store temp2;

 if ( !sizeof( COLOURS - used_colours ) ) {
#ifdef DEBUG
   log_file( "REAS", "%s: ERRNOSPACE generated by: %s!\n", ctime( time() ), 
             (previous_object()?file_name( previous_object()):"No previous object" ) );
#endif
    return ERRNOSPACE; 
  }

  if ( !sizeof( things ) || auction_length < 0 ) {
#ifdef DEBUG
    log_file( "REAS", "%s: ERRBADPARM generated by: %s!\n", ctime( time() ), 
      (previous_object()?file_name( previous_object()):"No previous object" ) );
#endif
    return ERRBADPARM;
  }
  if ( !objectp( load_object( object_cb ) ) ) {
#ifdef DEBUG
    log_file( "REAS", "%s: ERRBADCBOB generated by: %s!\n", ctime( time() ), 
      (previous_object()?file_name( previous_object()):"No previous object" ) );
#endif
    return ERRBADCBOB; 
  }

  //Work out the new case ID;
 lot_count ++;

  //Generate the case info
  temp2 = generate_store( things, lot_count );

  //Store and destroy objects
  auto_load_string = generate_auto_load( things );

  if ( !arrayp( auto_load_string ) ) {
   if ( (int) auto_load_string == ERROBNOMOVE ) {
#ifdef DEBUG
      log_file( "REAS", "%s: ERROBNOMOVE generated by: %s!\n", ctime( time() ), 
        query_multiple_short( map( things, (: file_name( $1 ) :) ) ) );
#endif
      return ERROBNOMOVE; 
    }
#ifdef DEBUG
    log_file( "REAS", "%s: ERRGENFAIL generated by: %s!\n", ctime( time() ), 
      query_multiple_short( map( things, (: file_name( $1 ) :) ) ) );
#endif
    return ERRGENFAIL; 
    }    

   temp = new( c_lot, assoc_store: temp2, case_code: lot_count, seller: "Auto", status: OPEN, 
      expiration_time: time() + auction_length, reserve_price: res_price, 
      bids: ([ ]), current_bid: allocate( 2 ), lot_autoload: auto_load_string,
      auto_bids: ({ function_cb, object_cb }), notes: int_desc, excluded: ({ }) );

    lots += ({ temp });
    
   return lot_count;
}


/**
 * @ignore
 */
mixed generate_auto_load( object *obs ) {

 object box = clone_object( "/obj/baggage" );
string *temp;

  box->set_name( "box" );
  box->set_long( "This is a box used in the auction room inheritable. "
    "How did you get hold of one?\n" );
  box->set_weight( 500000 ); 
  box->set_max_weight( 500000 );
  box->set_volume( 500000 );

 if ( sizeof( filter( obs->move( box ), (: $1 != 0 :) ) ) )
    //Not all obs moved in properly, scream and die!
   return ERROBNOMOVE;

  //So far so good.
  temp = create_auto_load( ({ box }), 0 );
  
  if ( !arrayp( temp ) )
   //Eek!
  return ERRGENFAIL;

   obs->dest_me();
   obs -= ({ 0 });

   //I might change this to a fatal error later, I'm not sure how autoloading 
   //handles undestable objects.
   if ( sizeof( obs ) ) {
#ifdef DEBUG
     log_file( "REAS", "%s: WARNUNDEST generated by object %s.\n", ctime( time() ), 
     query_multiple_short( map( obs, (: file_name( $1 ) :) ) ) );
#endif
   }

   box->dest_me();
   return temp;
}

/**
 * Return a store class with info on the objects
 */
c_store generate_store( object *things, int lot_id ) {

  c_store temp;
  c_item temp2;
  object temp3;
  string *avail_colours = COLOURS - used_colours;
  string _colour = avail_colours[ random( sizeof( avail_colours ) ) ];

  temp = new( c_store, case_code: lot_id, colour: _colour, 
    inventory: ({ }), inv_string: GECM( query_multiple_short( things ) ) );

    used_colours += ({ _colour });

  foreach( temp3 in things ) {
    temp2 = new( c_item, name: temp3->query_name(), 
    alias: temp3->query_alias(), long: temp3->query_long(),
    read_mess: temp3->query_readable_message(), enchant_mess:
    temp3->enchant_string(), adjectives: temp3->query_adjectives() );
    temp->inventory += ({ temp2 });

    if ( !stringp( temp2->read_mess ) ) 
      temp2->read_mess = "";
  }

 return temp;
}  

/**
 * A major component, this function is called once every few minutes to
 * change the state of our bids. It puts new bids out on display, and 
 * modifies the state of in game lots as required. It also removes old ones.
 */
void lot_check() {

  c_lot temp_lot;
  c_store current_store;
  object new_case;
  object *all_new_cases = ({ });
  object *obs;
  object *exp_cases;
  int *active_lots;
  string name;
  int *bids;

  //Lets put the cases in first, this will avoid problems with lots that later  
  //flip into another status not having cases when the room is loaded.

  //Get rid of null entries.. 
  cases = filter( cases, (: objectp( $1 ) :) );

  active_lots = map( filter( lots, (: ( (c_lot) $1)->status == OPEN :) ), 
   (: ( (c_lot) $1)->case_code :) );

  if ( sizeof( cases ) < sizeof( active_lots ) ) {
    //At least one of our items isn't on display! Find out which one it is
    active_lots = active_lots - values( cases );
   
    foreach( int temp in active_lots ) {
      //Find our current store..
      temp_lot = filter( lots, (: $1->case_code == $(temp) :) )[0];
      current_store = temp_lot->assoc_store;

      new_case = clone_object( "/std/object" );
      new_case->set_name( "case" );
      new_case->set_short( current_store->colour + " case" );
      new_case->set_long( "This is a display case used in this auction shop. "
        "It contains " + current_store->inv_string +".\nYou can \"browse\" these"
        " items.\n" );
      new_case->add_adjective( current_store->colour );
      new_case->move( this_object() );
      new_case->reset_get();
      new_case->add_extra_look( this_object() );
      used_colours += ({ current_store->colour });
      cases += ([ new_case: temp ]);
      all_new_cases += ({ new_case });
    }
    //A hook for later on (if you want to put in a nifty message)
    if ( sizeof( all_new_cases ) )
      this_object()->add_new_case( all_new_cases ); 
  }

  //Lots which require a state change
  foreach( temp_lot in ( filter( lots, (: $1->expiration_time < time() :) ) ) ) {
    TCTP( "Looking at lot %d. ", temp_lot->case_code );
    TCTP( "Status is: %s\n", temp_lot->status );
    switch( temp_lot->status ) {
      case OPEN: //Switching to another state
      TCTP( "In open %s", "\n" );
        //Woo. The bidding on this item is done. Did someone grab it?
        //If so, let the buyer know someone got it.
        //Otherwise let the seller know that they can pick it up
        //Change state appropriately.
        //There are some situations where its neccessary to look up the inv string
        current_store = temp_lot->assoc_store;

        //Before we start, lets get the box in the room out of the way, we'll put a
        //call in here in case someone wants to use a funky message.
        exp_cases = filter( cases, (: $2 == $(temp_lot)->case_code :) );
        map( exp_cases, (: this_object()->remove_lot( $1 ) :) );

        //First lets check if its being automatically handled, if it is
        //we can let the code know, it should look after the result instantly
        //so we can close it. We have to return the objects at the same time.
        //This could be tricky.
        if ( sizeof( temp_lot->auto_bids ) ) {
          //Recover objects first.
          obs = recover_lot( temp_lot->lot_autoload );
  
          //Make the call back
          call_other( temp_lot->auto_bids[1], temp_lot->auto_bids[0], 
          temp_lot->case_code, stringp( temp_lot->current_bid[ AUCTION_PLAYER_NAME ] ), 
          temp_lot->current_bid[ AUCTION_PLAYER_NAME ],          
          temp_lot->current_bid[ AUCTION_PLAYER_BID ], obs );
     
          //Ok, assuming that worked, the objects are recovered and the other
         //object has done what it was supposed to do with them, this means 
          //we can close this lot.
          temp_lot->status = CLOSED;
          temp_lot->expiration_time = time() + ( 2 * 60 * 60 );      

          //Yes, we aren't processing here anymore. The other object is 
          //responsible for letting the players know.
          continue; 
        }

        if ( stringp( name = temp_lot->current_bid[ AUCTION_PLAYER_NAME ] ) ) {
          //Someone got it!
          //Lets find out what they've won.
          if ( PLAYER_HANDLER->test_user( name ) ) {
            AUTO_MAILER->auto_mail( name, shop_name, "Your successful purchase!", 
            "","Congratulations! You have successfully purchased "+
            current_store->inv_string +" with a bid of "
            + MONEY_HAND->money_value_string( temp_lot->current_bid[ AUCTION_PLAYER_BID ],
            currency )+ ".\n\nYou have one week to collect your items before they are "
            "forfeit.\n", 0, 0 );
          }
          temp_lot->status = WAIT_BUYER;
          temp_lot->expiration_time = time() + ( 7 * 24 * 60 * 60 );      
          continue;
        } 

        //We want to drop down through WAIT_BUYER_LAPSE if there was no buyer initially.

        case WAIT_BUYER_LAPSE:
        //No one got it. Mail seller.
        name = temp_lot->seller;
 
        if (PLAYER_HANDLER->test_user( name ) ) {
          AUTO_MAILER->auto_mail( name, shop_name, "Your unsuccessful sale!",
          "", "Dear "+ capitalize( name ) +",\n\nIt is with some regret that I inform you "
          "that we were unable to sell " + current_store->inv_string +
          ".\n\nYou have one week to collect your items before they are forfeit.\n",
          0, 0 );
        } 
        temp_lot->status = WAIT_SELLER;
        temp_lot->expiration_time = time() + ( 7 * 24 * 60 * 60 );      
        
        continue;

      case WAIT_SELLER: //Free object
        name = temp_lot->seller;
        if ( PLAYER_HANDLER->test_user( name ) ) {
          AUTO_MAILER->auto_mail( name, shop_name, "Your unsuccessful sale!",
          "", "Dear "+ name +",\n\nAs you have not collected your items within "
          "7 days, they have been disposed of.\n\nHave a nice day.\n",
         0, 0 );
        } 
        temp_lot->status = CLOSED;
        temp_lot->expiration_time = time() + ( 2 * 60 * 60 );      
        continue;

    case WAIT_BUYER: //Drop to next bidder 

      name = temp_lot->current_bid[ AUCTION_PLAYER_NAME ];
      if ( PLAYER_HANDLER->test_user( name ) ) {
        AUTO_MAILER->auto_mail( name, shop_name, "Your successful purchase!", 
        "","Dear " + name +",\nBecause you have not picked up your items, "+
        "they have been sold to another client.\n\nHave a nice day.", 0, 0 );
      }

      map_delete( temp_lot->bids, name );

      if ( sizeof( temp_lot->bids ) == 0 ) {
        //there are no other bids, lets go to WAIT_BUYER_LAPSE
        temp_lot->status = WAIT_BUYER_LAPSE;
        temp_lot->expiration_time = time() + ( 2 * 60 * 60 ); //2 hrs
        continue;
      }

      //Sort all the remaining bids, pick the best one, mail them and reset the 
      //expiration time. 
      bids = sort_array( values( temp_lot->bids ), -1 );

      TCTP( "bids is %O.\n", bids );
      name = filter( temp_lot->bids, (: $2 == $(bids[0]) :) );

      //Now the name of the next best bidder should be kept in name,
      //and their bid is in bids[0]
      temp_lot->current_bid[ AUCTION_PLAYER_NAME ] = name;
      temp_lot->current_bid[ AUCTION_PLAYER_BID ] = bids[0];

      if ( PLAYER_HANDLER->test_user( name ) ) {
        AUTO_MAILER->auto_mail( name, shop_name, "Your successful purchase!", 
        "","Congratulations! You have successfully purchased "+
        current_store->inv_string +" with a bid of "
        + MONEY_HAND->money_value_string( temp_lot->current_bid[ AUCTION_PLAYER_BID ],
        currency )+ ".\n\nYou have one week to collect your items before they are "
        "forfeit.\n", 0, 0 );
      }
      temp_lot->status = WAIT_BUYER;
      temp_lot->expiration_time = time() + ( 7 * 24 * 60 * 60 );      
      continue;
    
    case WAIT_CRE_INTERVENTION: //Lots waiting cre intervention
#ifdef DEBUG
      log_file("REAS", "%s: Lot %d is still waiting for manual intervention!\n",
        ctime( time() ), temp_lot->case_code );
#endif
      temp_lot->expiration_time = time() + ( 7 * 24 * 60 * 60 );      
      continue;

      case CLOSED: //Discard lot class also discard store class
        TCTP( "In closed %s", "" );
        lots -= ({ temp_lot }); //Remove the lot array.
#ifdef DEBUG
        log_file( "REAS", "%s: Closed lot %d\n", ctime( time() ), temp_lot->case_code );
#endif        
        continue;
    }
  }

  //Finally finished processing.. hopefully we haven't over evalled yet.
  call_out( "lot_check", CHECK_CYCLE );
  return ;
}

int do_deposit( object *things, int auction_time, string time_type, string res_price ) {

  mixed *auto_load_string;
  c_lot temp;
  c_store temp2;
 int value;
  int finishtime;

 if ( auction_time <= 0 || ( time_type == "day" && auction_time > 10 )
    || ( time_type == "minute" && auction_time > 59 ) ||
    ( time_type == "hour" && auction_time > 23 ) ) {
      this_player()->add_failed_mess( this_object(), 
        "That's not a valid length.\n" );
      return 0;
  }

  if ( sizeof( res_price ) ) { 
   value = MONEY_HAND->value_from_string( res_price, currency );

    if ( value == 0 ) {
      this_player()->add_failed_mess( this_object(), 
        res_price +" isn't a valid reserve price.\n" );
      return 0;
    }
  }

 if ( !sizeof( COLOURS - used_colours ) ) {
    this_player()->add_failed_mess( this_object(), "The auction house "
      "doesn't have any display cases left to auction your item.\n" );
    return 0;
  }

  switch( time_type ) {
    case "minute": 
      if ( auction_time < 5 ) {
        this_player()->add_failed_mess( this_object(),
          "Auctions must go for at least 5 minutes.\n" );
        return 0;
      }
      finishtime = time() + ( auction_time * 60 );
      break;
    case "hour":
       finishtime = time() + ( auction_time * 60 * 60 );
       break;
    case "day":
      if ( auction_time > 14 ) {
        this_player()->add_failed_mess( this_object(),
          "Auction can not go for longer then two weeks.\n" );
        return 0;
      }
      finishtime = time() + ( auction_time * 60 * 60 * 24 );
      break;
    default: 
       return 0;
 }

  foreach( object tmp in things ) {
    if ( base_name( tmp ) == "/obj/money.c" ) {
      //Argh! Money! Scream and die.
      this_player()->add_failed_mess( this_player(), "You can't auction money.\n" );
      things->move( this_player(), "" );
      filter( things, (: environment( $1 ) != this_player() :) )->
        move( environment( this_player() ),  "$N falls to the floor!\n" );
      return 0;
    }
  }

  //Work out the new case ID;
  lot_count ++;

  //Generate the case info
  temp2 = generate_store( things, lot_count );

  //Store and destroy objects
  auto_load_string = generate_auto_load( things );

  if ( !arrayp( auto_load_string ) ) {
    //Something went wrong! Scream and die.
    this_player()->add_failed_mess( this_player(), "You can't auction that.\n" );
    things->move( this_player(), "" );
    filter( things, (: environment( $1 ) != this_player() :) )->
      move( environment( this_player() ),  "$N falls to the floor!\n" );
    return 0;
 }

  temp = new( c_lot, assoc_store: temp2, case_code: lot_count, seller: this_player()->query_name(),
    status: OPEN, expiration_time: finishtime, reserve_price: value, 
    bids: ([ ]), current_bid: allocate( 2 ), lot_autoload: auto_load_string,
    auto_bids: ({ }), notes: "", excluded: ({ }) );

  lots += ({ temp });
  
 if ( strlen( res_price ) )
    this_player()->add_succeeded_mess( this_object(), "$N $V "+
    temp2->inv_string + " for "+ add_a( query_num( auction_time, 5000 ) ) +
    " " + time_type + " auction, with a reserve price of "+ 
      MONEY_HAND->money_value_string( value, currency ) +".\n" );
  else
    this_player()->add_succeeded_mess( this_object(), "$N $V "+
    temp2->inv_string +" for a "+ query_num( auction_time, 5000 ) +
    " " + time_type + " auction, with no reserve price.\n" );

    TCTP( "Generated lot %d.\n", lot_count );
    return 1;

}

int do_list() {
  c_lot *_lots;
  c_lot _lot;
  string str;

  if ( !sizeof( cases ) ) {
    write( "There is nothing up for auction in this store.\n" );
    return 1;
  }

  str = "Items currently for auction:\n" ;
  
  foreach( object _case in keys( cases ) ) {
    _lots = filter( lots, (: $1->case_code == $( cases[ _case ] ) :) );
    if ( !sizeof( _lots ) ) continue;
    _lot = _lots[0];

    str +=  "$I$6=   " + 
      capitalize( _lot->assoc_store->colour + " case" ) + ": " +
      _lot->assoc_store->inv_string;
    if (_lot->current_bid[AUCTION_PLAYER_NAME]) {
       str += "; bid: "+ MONEY_HAND->money_value_string( 
        _lot->current_bid[1], currency ) + ", by " +
        capitalize(_lot->current_bid[ AUCTION_PLAYER_NAME ] ) +".\n";
    } else {
       str += ", no bid yet.\n";
    }
  }
  write("$P$Auctions$P$" + str);
  return 1;
} 

/**
 * @ignore
 * This function is meant to be masked, but remember to call it 
 * otherwise your cases will never disappear.
 */
void remove_lot( object ob ) {

  if ( member_array( ob, keys( cases ) ) == -1 )  {
    return;
  }
  map_delete( cases, ob );
  ob->dest_me();
  return;
}

/**
 * Basic add command function.. lets you bid on stuff
 */
int do_bid( string offer, object *boxes ) {

//Step one, work out what they are bidding on.
c_lot temp;
c_lot *temps;
c_store temp2;
object box;
int value;

 if ( sizeof( boxes ) > 1 ) {
    this_player()->add_failed_mess( this_object(), 
      "You can only $V on one case at "
      "a time.\n" );
    return 0;
  }

  box = boxes[0];

  if ( member_array( box, keys( cases ) ) == -1 ) {
    this_player()->add_failed_mess( this_object(), 
      "$I isn't being auctioned here.\n", ({ box }) );
    return 0;
  }  

  temps = filter_array( lots, (: $1->case_code == cases[ $(box) ] :) );
  
  //We will need the bid info now.. the store info isn't needed if the lot
  //has been closed.. so lets return 1; if thats the case.. 

  temp = temps[0];
  temp2 = temp->assoc_store;
  
  if ( temp->status != OPEN ) {
    this_player()->add_failed_mess(this_object(), 
      "The bidding on this item is finished.\n" );
    return 0;
  }

  if ( member_array( this_player()->query_name(),
       temp->excluded ) != -1 ) {
    write( "You have been excluded from bidding on this object.\n" );
    return WARNEXCL;
  }    

  if ( !classp( temp2 ) ) {
#ifdef DEBUG
    log_file( "REAS", "%s: Open lot without store! Lot code: %d.\n",
      ctime( time() ), temp->case_code );
#endif
    write( "Something has gone wrong. Please fetch a liaison post haste!\n" );
    printf( "Your lot code is: %d.\n", temp->case_code );
    temp->status = WAIT_CRE_INTERVENTION;
    temp->expiration_time = time() + ( 7 * 24 * 60 * 60 );
    this_player()->add_succeeded_mess( this_object(), "" );
    return 1;
  }

  value = MONEY_HAND->value_from_string( offer, currency );

  if ( value == 0 ) {
        this_player()->add_failed_mess( this_object(),
          offer +" isn't worth anything here.\n" );
        return 0;
  }

 if ( this_player()->query_value_in( currency ) < value ) {
   this_player()->add_failed_mess( this_object(), "You don't "
     "have that much.\n" );
   return 0;
 }

 if ( temp->reserve_price != 0 && value < temp->reserve_price ) {
   this_player()->add_failed_mess( this_object(), 
     "The reserve price for this lot is "+ 
     MONEY_HAND->money_value_string( temp->reserve_price, currency ) +".\n" );
     return 0;
 }

  if ( value < 400 ) {
   this_player()->add_failed_mess( this_object(), 
     "You must bid at least "+
     MONEY_HAND->money_value_string( 400, currency ) + ".\n" );
     return 0;
 }
 

 if ( sizeof( temp->current_bid ) && 
   temp->current_bid[ AUCTION_PLAYER_BID ] >= value ) {
   this_player()->add_failed_mess(this_object(), 
     "Someone else has already bid more than that.\n");
   return 0;
 }

 if ( sizeof( temp->current_bid ) && 
   ( ( value - temp->current_bid[ AUCTION_PLAYER_BID ] ) <
     ( temp->current_bid[ AUCTION_PLAYER_BID ] / 20 ) ) ) {
     this_player()->add_failed_mess( this_object(), "You must bid 5% "
     "more then the current bid.\n" );
   return 0;
 }

 temp->bids[ this_player()->query_name() ] = value;
 temp->current_bid[0] = this_player()->query_name();
 temp->current_bid[1] = value;

 this_player()->add_succeeded_mess(this_object(),
   "$N $V "+ offer +" for "+ temp2->inv_string +".\n" );
 return 1;

}

/**
 * This function will be a bit horrible, but it is a nicer way of doing it 
 * then keeping the objects around.
 * This function uses Terano's cheap and dirty parser (All rights reserved).
 * To be added - plural support! (using query_plural)
 */
int do_browse( object *boxes, string target, int identifier ) {

object box;
c_store container;
c_item temp;
mapping contents = ([ ]); //A list of all things in the box
string *names = ({ });
mixed *longadj = ({ });
string temp2;
mixed *contenders;
string *contender;
string *adjectives;
string name;
string word;
int keep_flag;

 if ( sizeof( boxes ) > 1 ) {
    this_player()->add_failed_mess( this_object(), 
      "You can only $V one case at a time.\n" );
    return 0;
  }

  box = boxes[0];

 if ( member_array( box, keys( cases ) ) == -1 ) {
    this_player()->add_failed_mess( this_object(), 
      "$I isn't being auctioned here.\n", ({ box }) );
    return 0;
  }  

  container = filter( lots, (: $1->case_code == cases[ $(box) ] :) )[ 0 ]->assoc_store;
//TCTP( "Container: %O", container );
  TCTP( "The case code for this case is: %d.\n", container->case_code );
  //Go through the inventory of the array

  foreach( temp in container->inventory ) { 
    //Compile a list of what it wants to be called.
    names = temp->alias + ({ temp->name });  

    //There are some objects with aliases the same as the name
    //ie: bottle and bottle :P
    names = uniq_array( names );

    //Work out what it looks like.
    longadj = ({ temp->long + temp->read_mess + 
      ( this_player()->query_see_octarine() ? temp->enchant_mess : "" ),
      temp->adjectives });

    //Ok, we have a nice list of all the names of this item
    foreach( temp2 in names ) {
    //TCTP( "Adding: %O\n", temp2 );
      if ( arrayp( contents[ temp2 ] ) )
        contents[ temp2 ] += ({ longadj });
      else
        contents[ temp2 ] = ({ longadj });
    }
  }

  //TCTP( "Object list: %O", contents );

 //Seeing if the string is one word, "bing".. or two words.. "blue bing".
  adjectives = explode( target, " " );

 //The name will be the bit at the end. The rest will be describing words.
    name = adjectives[ sizeof( adjectives ) - 1 ];
    adjectives -= ({ name });

  TCTP( "Search Name: %s ", name );
  TCTP( "Search Adj: %O.\n", adjectives );

  if ( !arrayp( contents[ name ] ) ) {
    this_player()->add_failed_mess( this_object(), 
      "There is nothing like that in the case.\n" );
    return 0;
 }

  //Our matches! Let's strip down a level of complexity here to
  //avoid evilness.
  contenders = contents[ name ];
//TCTP( "Matches: %O\n", contenders );

  if ( sizeof( contenders ) == 1 ) {
    //That was easy. Theres only one of them about.
    contender = contenders[0];
    this_player()->add_succeeded_mess( this_player(),
     "$N $V "+ target +" in $I.\n", ({ box }) );
    call_out( (: tell_object( this_player(), 
      $(GECM( contender[0]) ) ) :) );
    return 1;
  }

  //Ok, we've got more then one. If they gave us a number, we can use that.
  //Otherwise its fuzzy matching time. If they didn't give us any
  //adjectives to try and parse with, scream and die.
  if ( identifier != 0 ) {
    if ( identifier > sizeof( contenders ) ) {
     this_player()->add_failed_mess( this_player(),
        "There are only " + sizeof( contenders ) + 
        " " + pluralize( target ) + " in $I.\n", ({ box }) );
       return 0;
      }
    this_player()->add_succeeded_mess( this_player(),
      "$N $V "+ add_a( target ) +" in $I.\n", ({ box }) );
    call_out( (: tell_object( this_player(),  
      GECM( $(contenders[ identifier - 1 ][0]) ) ) :), 0 );
    return 1;
  }    

  if ( !sizeof( adjectives ) ) {
    this_player()->add_failed_mess( this_object(), 
      "There are "+ sizeof( contenders ) +" objects like that in the case.\n" );
    return 0;
 }
 
  //Ok, this bit is really going to suck.
  //Lets go through our list of contenders, and see how many we can find 
  //with these descriptive words as adjectives.
  foreach ( contender in contenders ) {
    keep_flag = 0;
    foreach( word in contender[ 1 ] ) {
      if ( member_array( word, adjectives ) != -1 ) 
        //Mark it as one to keep.
        keep_flag = 0;
      continue;
    }
    //If keep_flag isn't set, dump it
    if ( !keep_flag )
      contenders -= ({ contender });
    continue;
  }

//TCTP( "Contenders 2: %O\n", contenders );

  if ( !sizeof( contenders ) ) {
    //Argh, after all that, we disqualified everything! Bloody players.
    this_player()->add_failed_mess( this_object(), 
      "There is nothing matching "+ target +" in the case.\n" );
    return 0;
  }


  if ( sizeof( contenders ) > 1 ) {
     //Ok, there are still too many, scream and die.
     this_player()->add_failed_mess( this_object(), 
       "There are " + sizeof( contenders ) + " items like that in the case. "
       "Please specify which one you want to browse.\n" );
     return 0;
  }


  //Woohoo! We found it!
  contender = contenders[0];
  this_player()->add_succeeded_mess( this_player(),
    "$N peruse "+ add_a( target ) +" in $I.\n", ({ box }) );
  call_out( (: tell_object( this_player(), 
    GECM( $(contender[0]) ) ) :), 0 );

  return 1;
}

void adjust_money( int amount, object player ) {
    object money;

    if ( amount < 0 ) { //Taking money
        player->pay_money(MONEY_HAND->create_money_array(-amount, currency ));
        return;
    }
    money = MONEY_HAND->create_money_array( amount, currency );
    player->adjust_money( money, currency );
}

void load_file() {

    if ( !stringp( location ) ) return;
    if ( file_size( location +".o" ) < 0 ) return;
    unguarded( (: restore_object, location :) );
    return;

}

void save_file() {

    if ( location == "unset" ) return;
    unguarded( (: save_object, location :) );
    return;
}

void set_shop_name( string _name ) { shop_name = _name; }
void set_save_path( string path ) { location = path; }
void set_currency( string cur ) { currency = cur; }
void set_admin_cost( int value ) { admin_cost = value; }
void set_commission( int percent ) { commission = percent/100.0; }
mapping query_payments() { return payments; }


void dest_me() {
    save_file();
    if ( sizeof( cases ) ) keys( cases )->dest_me();
    ::dest_me();
}

mixed recover_lot( mixed lot_autoload ) {

  object *boxes;
  object *stuff;
  boxes = load_auto_load_to_array( lot_autoload, this_player() );

  if ( !objectp( boxes[0] ) ) {
#ifdef DEBUG
    log_file( "REAS", "%s: Could not recover: %O.\n", ctime( time() ),
      lot_autoload );
#endif
    return ERRNORECV;
  }
  
  stuff = all_inventory( boxes[ 0 ] ); //All that should be in this array is a box

  if ( !sizeof( stuff ) ) {
#ifdef DEBUG
    log_file( "REAS", "%s: Recovered case as empty: %O.\n", ctime( time() ),
      lot_autoload );
#endif
    return ERRRECVEMP;
  }

  //5 seconds to deal with inventory of boxes. Lets be generous.
  call_out( (: $(boxes)->dest_me() :), 5 ); 
  return stuff;

}
/**
 * Withdraw an item from bidding
 */
int do_withdraw( object *boxes ) {

object box;
c_lot *_lots;
object *obs; 

  if ( sizeof( boxes ) > 1  ) {
    this_player()->add_failed_mess( this_object(), 
      "You can only $V on one case at "
      "a time.\n" );
      return 0;
  }

  box = boxes[0];

  if ( member_array( box, keys( cases ) ) == -1 ) {
    this_player()->add_failed_mess( this_object(), 
      "$I isn't being auctioned here.\n", boxes );
    return 0;
  }  

  _lots = filter( lots, (: $1->case_code == cases[ $(box) ] :) );

  if ( this_player()->query_name() != _lots[0]->seller && 
    !this_player()->query_creator() ) {
     this_player()->add_failed_mess( this_player(), "This isn't your "
       "lot to withdraw!\n" );
     return 0;
  }

  //Close and wrap up in 2 hours
  _lots[0]->status = CLOSED;
  _lots[0]->expiration_time = time() + ( 2 * 60 * 60 );

  obs = recover_lot( _lots[0]->lot_autoload );

  if ( !arrayp( obs ) ) {
    write( "Something has gone wrong. Please fetch a liaison post haste!\n" );
    printf( "Your lot code is: %d.\n", _lots[0]->case_code );
    _lots[0]->status = WAIT_CRE_INTERVENTION;
    _lots[0]->expiration_time = time() + ( 7 * 24 * 60 * 60 );
    this_player()->add_succeeded_mess( this_object(), "" );
    return 1;
  }

  obs->move( this_player(), "You collect $N." );
  filter( obs, (: environment( $1 ) != this_player() :) )->
    move( environment( this_player() ), "$N falls to the floor!\n" );

  //Avoid problems with listing later on.
  this_object()->remove_lot( box );

  this_player()->add_succeeded_mess( this_object(), "" );
  return 1;
}

int do_describe( object *boxes, string int_desc ) {

    object box;
    c_lot *_lots;
    c_lot  _lot;
    int code;

    if ( sizeof( boxes ) > 1 ) {
        this_player()->add_failed_mess( this_object(), 
          "You can only $V on one case at "
          "a time.\n" );
        return 0;
    }

    box = boxes[0];

    if ( member_array( box, keys( cases ) ) == -1 ) {
        this_player()->add_failed_mess( this_object(), 
          "$I isn't being auctioned here.\n",
          ({ box }) );
        return 0;
    }  

    code = cases[ box ];

    _lots = filter( lots, (: $1->case_code == $(code) :) );

    if ( sizeof( _lots ) != 1 ) {
        printf( "Please inform a creator, there are %d records to "
          "match this case.\n", sizeof( _lots ) );
        printf( "Your lot code is: %d.\n", code );
        this_player()->add_succeeded_mess( this_object(), "" );
        return 1;
    }

    _lot = _lots[0];

    if ( this_player()->query_name() != _lot->seller && 
      !this_player()->query_creator() ) {
        this_player()->add_failed_mess( this_player(), "This isn't your "
          "lot to describe!\n" );
        return 0;
    }

    _lot->notes = int_desc;

    printf( "You neatly letter %s on the case.\n", int_desc );
    this_player()->add_succeeded_mess( this_object(), "" );
    return 1;

}

string extra_look( object ob ) {

    c_lot temp, *temp2;
    mixed bid_info;
    string ret;
    int code;

    if ( member_array( ob, keys( cases ) ) == -1 ) return "";

    code = cases[ ob ];
    temp2 = filter( lots, (: $1->case_code == $(code) :) );

    if ( sizeof( temp2 ) != 1 ) return sizeof( temp2 ) +" found in lot array!\n";

    temp = temp2[0];

    bid_info = temp->current_bid;

    ret = "";

    if ( !stringp( bid_info[ AUCTION_PLAYER_NAME ] ) ) {
        if ( temp->reserve_price ) {
          ret += "Reserve price is: ";
          ret += MONEY_HAND->money_value_string( temp->reserve_price, currency );
          ret += ".\n";
        }
        else
            ret += "No bid as of yet.\n";
    }
    else 
      ret += "The current bid is "+ MONEY_HAND->money_value_string( 
        bid_info[1], currency ) + ", made by "+ capitalize( 
        bid_info[ AUCTION_PLAYER_NAME ] ) +".\n";

    ret += "The bidding on this lot stops at "+ amtime( temp->expiration_time )+
      ".\n";

    if ( sizeof( temp->notes ) ) {
      ret += "Neatly lettered on the case is: ";
      ret += temp->notes;
      ret += ".\n";
    }
    return ret;
}

int do_collect( string pattern ) {
    int amount;
    c_lot _lot, *_lots = ({ }), *_exp_lots;
    object *items = ({ });

    //All lots that aren't OPEN, CLOSED or WAITing for a cre.
    _exp_lots = filter( lots, (: ((c_lot)$1)->status != OPEN :) );
    _exp_lots = filter( _exp_lots, (: ((c_lot)$1)->status != CLOSED :) );
    _exp_lots = filter( _exp_lots, (: ((c_lot)$1)->status != WAIT_CRE_INTERVENTION :) );

    if ( pattern == "all" ) {
        do_collect( "money" );
        do_collect( "successful bids" );
        do_collect( "expired lots" );
        return 1;
    }

    if ( pattern == "money" ) {
      _lots = filter( lots, (: ( $1->seller == $2 ) &&
        ( stringp( $1->current_bid[ AUCTION_PLAYER_NAME ] ) ) :),
        this_player()->query_name() );

      if ( undefinedp( payments[ this_player()->query_name() ] ) ) {
        if ( sizeof( _lots ) ) { 
          foreach( c_lot tempy in _lots ) { 
            write( capitalize( tempy->current_bid[ AUCTION_PLAYER_NAME ] ) +
              " must pay for the items they bid on before you can collect "
              "the money for them! They have until "+ amtime( tempy->expiration_time )+".\n" );
            }
       }
      }

      if ( undefinedp( payments[ this_player()->query_name() ] ) ) {
        write( "You aren't owed any money!\n" );
        return 0;
      }

      amount = payments[ this_player()->query_name() ];
      adjust_money( amount - to_int( amount * commission ), this_player() );

      printf( "You recieve %s, minus %s commission.\n", 
        MONEY_HAND->money_value_string( amount, currency ),
        MONEY_HAND->money_value_string( to_int( amount * commission ),
        currency ) );

      map_delete( payments, this_player()->query_name() );
       
      this_player()->add_succeeded_mess( this_object(),
        "$N $V some money from $D.\n" );
      save_file();
      return 1;
    }

    if ( pattern == "successful bids" ) {
        //Items that have expired with the player as the current bid,
        _lots = filter( _exp_lots,
          (: $1->current_bid[ AUCTION_PLAYER_NAME ] == $2 :), 
          this_player()->query_name() );

        if ( !sizeof( _lots ) ) {
            write( "You aren't expecting any bids!\n" );
            return 0;
        }

        foreach( _lot in _lots ) 
          amount += _lot->current_bid[ 1 ];

        if ( this_player()->query_value_in( currency ) < amount ) {
            printf( "You have %d %s waiting, for a total cost of %s.\n"
              "You don't have enough money.\n", 
              sizeof( _lots ),
              sizeof( _lots ) > 1 ? "lots" : "lot", 
              MONEY_HAND->money_value_string( amount, currency ) );
            this_player()->add_failed_mess( this_object(), "" );
            return 0;
        }

        adjust_money( -amount, this_player() );

        foreach( _lot in _lots ) {
          items += recover_lot( _lot->lot_autoload );
  
          if ( undefinedp( payments[ _lot->seller ] ) )
            payments[ _lot->seller ] = _lot->current_bid[ AUCTION_PLAYER_BID ];
          else
            payments[ _lot->seller ] += _lot->current_bid[ AUCTION_PLAYER_BID ];

          _lot->status = CLOSED;
          _lot->expiration_time = time() + ( 2 * 60 * 60 ); //2 hrs
        }

        items->move( this_player(), "You collect $N." );
        filter( items, (: environment( $1 ) != this_player() :) )->
          move( environment( this_player() ), "$N falls to the floor!\n" );

        printf( "You had %d %s waiting, for a total cost of %s.\nYou "
          "hand over the money.\n", sizeof( _lots ),
          sizeof( _lots ) > 1 ? "lots" : "lot", 
          MONEY_HAND->money_value_string( amount, currency ) );

        return 1;
    }

    if ( pattern == "expired lots" ) {
        //Items that didnt sell
        _lots = filter( _exp_lots, 
          (: !stringp( $1->current_bid[ AUCTION_PLAYER_NAME ] ) && 
            $1->seller == $2 :), this_player()->query_name() );

        if ( !sizeof( _lots ) ) {
            this_player()->add_failed_mess( this_object(), "You aren't expecting "
              "any items.\n" );
            return 0;
        }

        amount = admin_cost * sizeof( _lots );

        if ( this_player()->query_value_in( currency ) < amount ) {
            printf( "You have %d %s waiting, for a total administration "
              "cost of %s.\n"
              "You don't have enough money.\n", 
              sizeof( _lots ),
              sizeof( _lots ) > 1 ? "lots" : "lot", 
              MONEY_HAND->money_value_string( amount, currency ) );
            return 0;
        }

        adjust_money( -amount, this_player() );

        foreach( _lot in _lots ) {
          items += recover_lot( _lot->lot_autoload );
  
          if ( undefinedp( payments[ _lot->seller ] ) )
            payments[ _lot->seller ] = _lot->current_bid[ AUCTION_PLAYER_BID ];
          else
            payments[ _lot->seller ] += _lot->current_bid[ AUCTION_PLAYER_BID ];

          _lot->status = CLOSED;
          _lot->expiration_time = time() + ( 2 * 60 * 60 ); //2 hrs
        }

        items->move( this_player(), "You collect $N." );
        filter( items, (: environment( $1 ) != this_player() :) )->
          move( environment( this_player() ), "$N falls to the floor!\n" );

        printf( "You had %d %s waiting, for a total administration "
          "cost of %s.\n"
          "You hand over the money.\n", 
          sizeof( _lots ), sizeof( _lots ) > 1 ?
          "lots" : "lot", 
          MONEY_HAND->money_value_string( amount, currency ) );
        return 1;
    }
}

int do_exclude( object *boxes, string excluded ) {

    object box;
    c_lot *_lots;
    c_lot  _lot;
    int code;
    string *ignored = this_player()->query_property( "ignoring" );    

    if ( sizeof( boxes ) > 1 ) {
        this_player()->add_failed_mess( this_object(), 
          "You can only $V people from one case at "
          "a time.\n" );
        return 0;
    }

    box = boxes[0];

    if ( member_array( box, keys( cases ) ) == -1 ) {
        this_player()->add_failed_mess( this_object(), 
          "$I isn't being auctioned here.\n",
          ({ box }) );
        return 0;
    }  

    code = cases[ box ];

    _lots = filter( lots, (: $1->case_code == $(code) :) );

    if ( sizeof( _lots ) != 1 ) {
        printf( "Please inform a creator, there are %d records to "
          "match this case.\n", sizeof( _lots ) );
        printf( "Your lot code is: %d.\n", code );
        this_player()->add_succeeded_mess( this_object(), "" );
        return 1;
    }

    _lot = _lots[0];

    if ( this_player()->query_name() != _lot->seller && 
      !this_player()->query_creator() ) {
        this_player()->add_failed_mess( this_player(), "This isn't your "
          "lot to exclude people from!\n" );
        return 0;
    }

    if ( excluded == "list" ) {
      if ( !sizeof( _lot->excluded ) ) 
        write( "No one is being excluded from bidding on this lot.\n" );
      else
        write( query_multiple_short( _lot->excluded ) + " is being excluded from "
          "bidding on this lot.\n" );
      return 1;
    }

    if ( excluded != "ignore list" ) {
      if ( member_array( excluded, _lot->excluded ) != -1 ) {
        write( excluded + " is already excluded from this lot.\n" );
        return 1;
      }
      if ( !PLAYER_HANDLER->test_user( excluded ) ) 
        return notify_fail( excluded +" is not a player here!\n" );
      else  {
        _lot->excluded += ({ excluded });
        _lot->excluded = uniq_array( _lot->excluded );
        write( excluded +" will not be allowed to bid on "+
          query_multiple_short( boxes ) +".\n" );
        return 1;
      }   
    }
    if ( !arrayp( ignored ) || !sizeof( ignored ) ) {
      write( "You aren't ignoring anyone!\n" );
      return 1;
    }
    _lot->excluded += ignored;
    _lot->excluded = uniq_array( _lot->excluded );
    write( query_multiple_short( ignored ) + " will not be allowed to bid on "+
      query_multiple_short( boxes ) +".\n"  );
    this_player()->add_succeeded_mess( this_object(), "" );
    return 1;

}

int do_unexclude( object *boxes, string excluded ) {

    object box;
    c_lot *_lots;
    c_lot  _lot;
    int code;

    if ( sizeof( boxes ) > 1 ) {
        this_player()->add_failed_mess( this_object(), 
          "You can only $V people from one case at "
          "a time.\n" );
        return 0;
    }

    box = boxes[0];

    if ( member_array( box, keys( cases ) ) == -1 ) {
        this_player()->add_failed_mess( this_object(), 
          "$I isn't being auctioned here.\n",
          ({ box }) );
        return 0;
    }  

    code = cases[ box ];

    _lots = filter( lots, (: $1->case_code == $(code) :) );

    if ( sizeof( _lots ) != 1 ) {
        printf( "Please inform a creator, there are %d records to "
          "match this case.\n", sizeof( _lots ) );
        printf( "Your lot code is: %d.\n", code );
        this_player()->add_succeeded_mess( this_object(), "" );
        return 1;
    }

    _lot = _lots[0];

    if ( this_player()->query_name() != _lot->seller && 
      !this_player()->query_creator() ) {
        this_player()->add_failed_mess( this_player(), "This isn't your "
          "lot to unexclude people from!\n" );
        return 0;
    }

    if ( member_array( excluded, _lot->excluded ) == -1 ) {
      if ( !sizeof( _lot->excluded ) ) {
        write( "No one is excluded from bidding on this case!\n" );
        return 1;
      }
      write( "Only "+ query_multiple_short( _lot->excluded ) + 
        ( sizeof( excluded ) == 1 ? " is " : " are " ) + 
        " being excluded from bidding on this case!\n" );
      return 1;
    }

    _lot->excluded -= ({ excluded });
    write( capitalize( excluded ) + " is now allowed to bid on this case.\n" );
    this_player()->add_succeeded_mess( this_object(), "" );
    return 1;

}

/**
 * @ignore
 */
c_lot find_spec_lot( int pos ) { return lots[ pos ]; }

/**
 * This function generates a string that can be used in any advertising
 * you might want to do, it returns a human friendly string that passes
 * information about the lot. (Specifically - contents, cost and exp time)
 * It takes a lot as an arg.
 */ 
string generate_advertising_string( c_lot lot ) {
  //Return a string that we can do something with!
  //Something like: "<lot QMS>, currently going for <currency string>, "
  //"but hurry, bidding stops on <time>!"
  string c_string;
 
  if ( intp( lot->current_bid[ 0 ] ) && ( lot->current_bid[ 0 ] ) )
    c_string = MONEY_HAND->money_value_string( lot->current_bid[ 0 ], currency );
  else
    if ( intp( lot->reserve_price ) && lot->reserve_price )
      c_string = MONEY_HAND->money_value_string( lot->reserve_price, currency );
    else
     c_string = "make an offer"; 

  if ( c_string == "make an offer" ) 
    return lot->assoc_store->inv_string + ", " + c_string + 
    " but hurry, bidding stops at " + amtime( lot->expiration_time );

  return lot->assoc_store->inv_string + ", currently going for " + c_string + 
    " but hurry, bidding stops at " + amtime( lot->expiration_time );

}

/**
 * A more usable version of above function, call it and it picks a lot
 * at random and generates a string for it.
 * returns "NULL" if there are no lots.
 * Also returns NULL if the lot chosen isnt open
 */
string generate_random_adv_string() {
c_lot temp;
  if ( sizeof( lots ) ) {
    temp = lots[ random( sizeof( lots ) ) ];
    if ( temp->status != OPEN )
      return WARNNOLOTS;
    else return generate_advertising_string( temp );
  }
  else
    return WARNNOLOTS;
}
// --- END [/mnt/home2/grok/lib/std/room/auction_room.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/meeting.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/meeting.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629267   Available: 13576621
Inodes: Total: 5242880    Free: 4960135
452 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/meeting.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629267   Available: 13576621
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This file is the inheritable for a meeting room.  It handles the floor
 * and a few other things neatly.
 * @author Pinkfish 
 * @started 25th of June
 */
inherit "/std/room/basic_room";
inherit "/std/room/inherit/meeting";

/** @ignore yes */
void create() {
   add_help_file("meeting");
   basic_room::create();
   meeting::create();
} /* create() */

/** @ignore yes */
void init() {
   basic_room::init();
   meeting::init();
} /* init() */
// --- END [/mnt/home2/grok/lib/std/room/meeting.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/newspaper_office.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/newspaper_office.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629267   Available: 13576621
Inodes: Total: 5242880    Free: 4960135
494 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/newspaper_office.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629267   Available: 13576621
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * The newspaper office room.
 * @author Obilic
 * @changed Pinkfish Fri Apr 27 12:08:29 PDT 2001
 * Turned into an inherit and made to use a newspaper handler for
 * distributing the actual text.
 */
inherit "/std/room/inherit/newspaper_office";
inherit "/std/room/basic_room";

void create() {
   newspaper_office::create();
   basic_room::create();
   add_help_file("newspaper_office");
} /* create() */

void init() {
   basic_room::init();
   newspaper_office::init();
} /* init() */

// --- END [/mnt/home2/grok/lib/std/room/newspaper_office.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/complaints_room.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/complaints_room.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629266   Available: 13576620
Inodes: Total: 5242880    Free: 4960135
631 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/complaints_room.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629266   Available: 13576620
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming

/**
 * This inherit allows people to complain in unhappy times.
 *
 * @see /std/room/inherit/complaints_room.c
 * @author Arienne
 * @started Wed Apr  4 14:11:50 BST 2001
**/

inherit "/std/room/inherit/complaints_room";
inherit "/std/room/basic_room";

/**
 * @ignore
**/
void create() {
    add_help_file("complaints_room");
    do_setup++;
    basic_room::create();
    do_setup--;

    set_not_replaceable( 1 );

    if ( !do_setup ) {
        this_object()->setup();
        this_object()->reset();
    }
} /* create() */

/**
 * @ignore
**/
void init() {
    complaints_room::init();
    basic_room::init();
} /* init() */

// --- END [/mnt/home2/grok/lib/std/room/complaints_room.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/room_rental_office.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/room_rental_office.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629266   Available: 13576620
Inodes: Total: 5242880    Free: 4960135
461 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/room_rental_office.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629266   Available: 13576620
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * A Room Rental Office inheritable
 * that includes the /std/room/basic_room
 * inheritable
 * 
 * by goldenthread started 14 Jul y2k2
 *
 */

#include <room/room_rental.h>

inherit "/std/room/basic_room";
inherit ROOM_RENTAL_INHERIT_OFFICE;

/** @ignore yes */
void create() {
   basic_room::create();
   room_rental_office::create();
} /* create() */

/** @ignore yes */
void init() {
   basic_room::init();
   room_rental_office::init();
} /* init() */
// --- END [/mnt/home2/grok/lib/std/room/room_rental_office.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/council_chambers.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/council_chambers.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629266   Available: 13576620
Inodes: Total: 5242880    Free: 4960135
17859 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/council_chambers.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629266   Available: 13576620
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <nomic_system.h>

inherit "/std/room/basic_room";
inherit "/std/room/inherit/council_base";


void create() {
   ::create();
} /* create() */

/**
 * This method lists the current set of rules from the specified area.
 * @return 1 on success, 0 on failure
 */
int do_list_rules() {
   class nomic_rule* rules;
   class nomic_rule rule;
   string ret;
   int cur_type;

   rules = NOMIC_HANDLER->query_all_nomic_rules(query_council_area());
   if (!sizeof(rules)) {
      add_failed_mess("There are no rules, oh no!  Lawlessness!\n");
      return 0;
   }

   rules = sort_array(rules, (: $1->id - $2->id :) );

   ret = "";
   cur_type = -1;
   foreach (rule in rules) {
      if (rule->type != cur_type) {
         switch (rule->type) {
         case NOMIC_TYPE_IMMUTABLE :
            ret += "%^BOLD%^Immutable Rules%^RESET%^\n";
            break;
         case NOMIC_TYPE_CITIZEN :
            ret += "%^BOLD%^Citizen Rules%^RESET%^\n";
            break;
         case NOMIC_TYPE_GENERAL :
            ret += "%^BOLD%^General Rules%^RESET%^\n";
            break;
         }
         cur_type = rule->type;
      }
      ret += NOMIC_HANDLER->rule_as_string(0, rule);
      ret += "\n";
   }
   write("$P$Nomic rules$P$" + ret);
   return 1;
} /* do_list_rules() */


/**
 * This method lists the current set of rules from the specified area.
 * @return 1 on success, 0 on failure
 */
int do_list_one_rule(int num) {
   class nomic_rule rule;
   string ret;

   rule = NOMIC_HANDLER->query_nomic_rule(query_council_area(), num);
   if (!rule) {
      add_failed_mess("There is no rule number " + num + ".\n");
      return 0;
   }

   ret = "";
   switch (rule->type) {
   case NOMIC_TYPE_IMMUTABLE :
      ret += "%^BOLD%^Immutable Rules%^RESET%^\n";
      break;
   case NOMIC_TYPE_CITIZEN :
      ret += "%^BOLD%^Citizen Rules%^RESET%^\n";
      break;
   case NOMIC_TYPE_GENERAL :
      ret += "%^BOLD%^General Rules%^RESET%^\n";
      break;
   }
   ret += NOMIC_HANDLER->rule_as_string(0, rule);
   ret += "\n";
   write("$P$Nomic rules$P$" + ret);
   return 1;
} /* do_list_rules() */

/**
 * This lists all the new rules up for discussion or whatever by the
 * magistrates.
 * @return 1 on success, 0 on failure
 */
int do_list_single_motion(int num) {
   class nomic_motion* rules;
   class nomic_motion rule;
   int is_mag;
   string ret;

   rules = NOMIC_HANDLER->query_all_motions(query_council_area());
   is_mag = NOMIC_HANDLER->is_magistrate_of(query_council_area(),
                      this_player()->query_name());
   if (!is_mag) {
      rules = filter(rules, (: $1->state == NOMIC_STATE_CITIZEN_VOTE :));
   }

   if (!sizeof(rules)) {
      add_failed_mess("No motion to look at or vote on.\n");
      return 0;
   }

   ret = "";
   foreach (rule in rules) {
      if (rule->identifier == num) {
         ret += NOMIC_HANDLER->motion_as_string(0, query_council_area(), rule,
                                             0);
         ret += "\n";
      }
   }

   if (ret == "") {
      add_failed_mess("The motion " + num + " was not found.\n");
      return 0;
   }

   write("$P$New Nomic Rules$P$" + ret);
   return 1;
} /* do_list_single_motion() */

/**
 * This lists all the new rules up for discussion or whatever by the
 * magistrates.
 * @return 1 on success, 0 on failure
 */
int do_list_motions(int brief) {
   class nomic_motion* rules;
   class nomic_motion rule;
   int is_mag;
   string ret;

   rules = NOMIC_HANDLER->query_all_motions(query_council_area());
   is_mag = NOMIC_HANDLER->is_magistrate_of(query_council_area(),
                      this_player()->query_name());
   if (!is_mag) {
      rules = filter(rules, (: $1->state == NOMIC_STATE_CITIZEN_VOTE :));
   }

   if (!sizeof(rules)) {
      add_failed_mess("No motion to look at or vote on.\n");
      return 0;
   }

   ret = "";
   foreach (rule in rules) {
      ret += NOMIC_HANDLER->motion_as_string(0, query_council_area(), rule,
                                             brief);
      ret += "\n";
   }
   write("$P$New Nomic Rules$P$" + ret);
   return 1;
} /* do_list_motions() */

/**
 * This method allows the person to make a comment on a current rule.
 * Comments are only allowed by magistrates and only in the first two
 * phases.
 * @param num the id of the rule to comment on
 * @return 1 on success, 0 on failure
 */
int do_comment_on(int num) {
   class nomic_motion rule;
   int is_mag;

   rule = NOMIC_HANDLER->query_motion(query_council_area(), num);
   is_mag = NOMIC_HANDLER->is_magistrate_of(query_council_area(),
                      this_player()->query_name());
   if (!rule || !is_mag && rule->state != NOMIC_STATE_CITIZEN_VOTE) {
      add_failed_mess("Could not find the motion " + num + ".\n");
      return 0;
   }
   write("You are commenting on:\n" +
         NOMIC_HANDLER->motion_as_string(0, query_council_area(), rule) +
         "\n");
   this_player()->do_edit("", "finish_comment_on", this_object(), 0, rule);
   return 1;
} /* do_comment_on() */

/** @ignore yes */
void finish_comment_on(string comment, class nomic_motion rule) {
   if (!comment) {
      write("Aborting comment.\n");
      return ;
   }
   if (NOMIC_HANDLER->comment_on_motion(query_council_area(), rule->identifier,
                                       comment, this_player()->query_name())) {
      write("Succeeded in making a comment on the rule.\n");
   } else {
      write("Could not make a comment on the rule for some reason.\n");
   }
} /* finish_comment_on() */

/**
 * This method allows the person to amend a new rule.
 * Amendments are only allowed by magistrates and only during the discusion
 * phase.
 * @param num the id of the rule to comment on
 * @return 1 on success, 0 on failure
 */
int do_amend_motion(int num) {
   class nomic_motion rule;
   int is_mag;

   is_mag = NOMIC_HANDLER->is_magistrate_of(query_council_area(),
                      this_player()->query_name());
   if (!is_mag) {
      add_failed_mess("You cannot amend rules.\n");
      return 0;
   }

   rule = NOMIC_HANDLER->query_motion(query_council_area(), num);
   if (!rule) {
      add_failed_mess("Could not find the motion " + num + ".\n");
      return 0;
   }
   if (rule->state != NOMIC_STATE_COUNCIL_REVIEW) {
      add_failed_mess("You cannot amend the motion " + num + ".\n");
      return 0;
   }
   if (rule->motion_type != NOMIC_MOTION_TYPE_RULE_ADD &&
       rule->motion_type != NOMIC_MOTION_TYPE_RULE_AMEND) {
      add_failed_mess("You cannot amend the motion " + num + ".\n");
      return 0;
   }

   write("You are adding an amendment to:\n" +
         NOMIC_HANDLER->motion_as_string(0, query_council_area(), rule) +
         "\n\nWARNING!  Ammending the motion replaces the current text.\n");
   this_player()->do_edit("", "finish_amend_motion", this_object(), 0, rule);
   return 1;
} /* do_amend_motion() */

/** @ignore yes */
void finish_amend_motion(string amendment, class nomic_motion rule) {
   if (!amendment) {
      write("Aborting amendment.\n");
      return ;
   }
   if (NOMIC_HANDLER->amend_motion(query_council_area(), rule->identifier,
                                   amendment, this_player()->query_name())) {
      write("Succeeded in adding an amendment to the motion.\n");
   } else {
      write("Could not add an amendment to the rule for some reason.\n");
   }
} /* finish_amend_motion() */

/**
 * This method will handle voting on the specific new nomic rule.
 * @param num the rule number to vote on
 * @param vote their vote
 * @return 1 on success, 0 on failure
 */
int do_vote_on(int num, string vote) {
   class nomic_motion rule;
   int is_mag;
   int vote_id;

   rule = NOMIC_HANDLER->query_motion(query_council_area(), num);
   is_mag = NOMIC_HANDLER->is_magistrate_of(query_council_area(),
                      this_player()->query_name());
   if (!rule || (!is_mag && rule->state != NOMIC_STATE_CITIZEN_VOTE)) {
      add_failed_mess("Could not find the motion " + num + ".\n");
      return 0;
   }

   if (rule->state != NOMIC_STATE_CITIZEN_VOTE &&
       rule->state != NOMIC_STATE_COUNCIL_VOTE) {
      add_failed_mess("The rule is not in a state that you can vote on.\n");
      return 0;
   }

   switch (vote) {
   case "yes" :
      vote_id = NOMIC_VOTE_YES;
      break;
   case "no" :
      vote_id = NOMIC_VOTE_NO;
      break;
   case "abstain" :
      vote_id = NOMIC_VOTE_ABSTAIN;
      break;
   default :
      add_failed_mess("Unknown type of vote, must be one of yes, no or "
                      "abstain.\n");
      return 0;
   }

   if (NOMIC_HANDLER->has_voted_for_motion(query_council_area(), num,
                     this_player()->query_name())) {
      add_failed_mess("You have already voted for this rule!\n");
      return 0;
   } else if (NOMIC_HANDLER->vote_for_motion(query_council_area(), num, vote_id,
                     this_player()->query_name())) {
      add_succeeded_mess(({ "$N $V for " + vote + " in motion id " + num +
                            ".\n",
                            "$N $V for a motion.\n" }));
      return 1;
   }
   add_failed_mess("Could not vote for the rule for some reason.\n");
   return 0;
} /* do_vote_on() */

/**
 * This method adds an amendment to a current rule.
 * @param num the number of the current rule
 * @return 1 on success, 0 on failure
 */
int do_amend_current_rule(int num) {
   class nomic_rule rule;

   rule = NOMIC_HANDLER->query_nomic_rule(query_council_area(), num);
   if (!rule) {
      add_failed_mess("The rule " + num + " does not exist.\n");
      return 0;
   }

   if (!NOMIC_HANDLER->is_magistrate_of(query_council_area(),
                      this_player()->query_name())) {
      add_failed_mess("You cannot do this until you are a magistrate.\n");
      return 0;
   }

   if (!NOMIC_HANDLER->query_can_change_rule(query_council_area(), rule)) {
      add_failed_mess("You cannot change that rule.\n");
      return 0;
   }

   write("What amendment would you like to make to the rule:\n" +
         NOMIC_HANDLER->rule_as_string(0, rule) + "\n");
   this_player()->do_edit("", "amend_current_rule", this_object(), 0, rule);
   return 1;
} /* do_amend_current_rule() */

/** @ignore yes */
void amend_current_rule(string str, class nomic_rule rule) {
   if (!str) {
      write("Aborting the addition of an amendment.\n");
      return ;
   }
   write("Adding the amendment:\n" +
         str + "\nTo the rule:\n" +
         NOMIC_HANDLER->rule_as_string(0, rule) + "\nAre you sure you wish to do this? ");
   input_to("amend_current_rule_check", 0, rule, str);
} /* amend_current_rule() */

/** @ignore yes */
void amend_current_rule_check(string str,
                               class nomic_rule rule,
                               string amend) {
   str = lower_case(str);
   if (!strlen(str) || str[0] != 'y') {
      write("Aborting the addition of an amendment.\n");
      return 0;
   }

   if (!NOMIC_HANDLER->add_amend_rule_motion(query_council_area(), rule->id, amend,
                                          this_player()->query_name())) {
      write("Cannot add the rule amendment.\n");
   } else {
      write("Added a motion to amend the rule.\n");
   }
} /* amend_current_rule_check() */

/**
 * This method removes a current rule.
 * @param num the number of the current rule
 * @return 1 on success, 0 on failure
 */
int do_remove_current_rule(int num) {
   class nomic_rule rule;

   rule = NOMIC_HANDLER->query_nomic_rule(query_council_area(), num);
   if (!rule) {
      add_failed_mess("The rule " + num + " does not exist.\n");
      return 0;
   }

   if (!NOMIC_HANDLER->is_magistrate_of(query_council_area(),
                      this_player()->query_name())) {
      add_failed_mess("You cannot do this until you are a magistrate.\n");
      return 0;
   }

   if (!NOMIC_HANDLER->query_can_change_rule(query_council_area(), rule)) {
      add_failed_mess("You cannot change that rule.\n");
      return 0;
   }

   write("Would you like to remove the rule:\n" +
         NOMIC_HANDLER->rule_as_string(0, rule) +
         "\nYou must be sure about removing this.   Do you wish to "
         "remove the rule? ");
   input_to("remove_current_rule_check", 0, rule);
   return 1;
} /* do_remove_current_rule() */

/** @ignore yes */
void remove_current_rule_check(string str,
                               class nomic_rule rule) {
   str = lower_case(str);
   if (!strlen(str) || str[0] != 'y') {
      write("Aborting the removal of the rule.\n");
      return 0;
   }

   if (!NOMIC_HANDLER->add_remove_rule_motion(query_council_area(), rule->id,
                                          this_player()->query_name())) {
      write("Cannot remove the rule.\n");
   } else {
      write("Added a motion to remove the rule.\n");
   }
} /* remove_current_rule_check() */

/**
 * This method creates a new rule.
 * @param type the type of the new rule
 * @return 1 on success, 0 on failure
 */
int do_create_motion(string type) {
   int type_no;

   type_no = NOMIC_HANDLER->query_type_number(type);
   if (type_no == NOMIC_ERROR ||
       type_no == NOMIC_TYPE_IMMUTABLE) {
      add_failed_mess("The type " + type + " is invalid.\n");
      return 0;
   }

   if (!NOMIC_HANDLER->is_magistrate_of(query_council_area(),
                      this_player()->query_name())) {
      add_failed_mess("You cannot do this until you are a magistrate.\n");
      return 0;
   }

   write("What rule would you like to create?\n");
   this_player()->do_edit("", "create_motion", this_object(), 0, type_no);
   return 1;
} /* do_create_motion() */

/** @ignore yes */
void create_motion(string str, int type_no) {
   if (!str) {
      write("Aborting the creation of the rule.\n");
      return ;
   }
   write("Adding the motion of type " + 
         NOMIC_HANDLER->query_type_name(type_no) + ":\n" +
         str +
         "\nAre you sure you wish to do this? ");
   input_to("create_motion_check", 0, type_no, str);
} /* create_motion() */

/** @ignore yes */
void create_motion_check(string str,
                         int type_no,
                         string motion) {
   str = lower_case(str);
   if (!strlen(str) || str[0] != 'y') {
      write("Aborting the creation of the rule.\n");
      return 0;
   }

   if (!NOMIC_HANDLER->add_create_rule_motion(query_council_area(), type_no, motion,
                                          this_player()->query_name())) {
      write("Cannot create the rule.\n");
   } else {
      write("Added a motion to create the rule.\n");
   }
} /* create_motion_check() */

/**
 * This method transmogrifies a current rule.
 * @param num the number of the current rule
 * @return 1 on success, 0 on failure
 */
int do_transmogrify_current_rule(int num, string new_type) {
   class nomic_rule rule;
   int new_type_no;

   if (!NOMIC_HANDLER->is_magistrate_of(query_council_area(),
                      this_player()->query_name())) {
      add_failed_mess("You cannot do this until you are a magistrate.\n");
      return 0;
   }

   rule = NOMIC_HANDLER->query_nomic_rule(query_council_area(), num);
   if (!rule) {
      add_failed_mess("The rule " + num + " does not exist.\n");
      return 0;
   }

   if (!NOMIC_HANDLER->query_can_change_rule(query_council_area(), rule)) {
      add_failed_mess("You cannot change that rule.\n");
      return 0;
   }

   new_type_no = NOMIC_HANDLER->query_type_number(new_type);
   if (new_type_no == NOMIC_ERROR ||
       new_type_no == NOMIC_TYPE_IMMUTABLE) {
      add_failed_mess("The type " + new_type + " is not valid.\n");
      return 0;
   }

   write("Would you like to transmogrify the rule:\n" +
         NOMIC_HANDLER->rule_as_string(0, rule) +
         "\nYou must be sure about transmogrifying this.   Do you wish to "
         "transmogrify the rule? ");
   input_to("transmogrify_current_rule_check", 0, rule, new_type_no);
   return 1;
} /* do_transmogrify_current_rule() */

/** @ignore yes */
void transmogrify_current_rule_check(string str,
                               class nomic_rule rule,
                               int new_type_no) {
   str = lower_case(str);
   if (!strlen(str) || str[0] != 'y') {
      write("Aborting the removal of the rule.\n");
      return 0;
   }

   if (!NOMIC_HANDLER->add_move_rule_type_motion(query_council_area(), rule->id,
                                          new_type_no,
                                          this_player()->query_name())) {
      write("Cannot transmogrify the rule.\n");
   } else {
      write("Added a motion to transmogrify the rule.\n");
   }
} /* transmogrify_current_rule_check() */

/** @ignore yes */
void init() {
   ::init();
   add_command("list", "[rules]", (: do_list_rules() :) );
   add_command("list", "rule <number>", (: do_list_one_rule($4[0]) :) );
   add_command("list", "motion <number'motion id'>",
               (: do_list_single_motion($4[0]) :));
   add_command("list", "motions", (: do_list_motions(1) :));
   add_command("list", "motions {verbose|brief}",
               (: do_list_motions($4[0] == "brief") :));
   add_command("comment", "on <number'motion id'>",
                (: do_comment_on($4[0]) :) );
   add_command("amend", "motion <number'motion id'>",
                (: do_amend_motion($4[0]) :) );
   add_command("vote", "{yes|no|abstain} for <number'motion id'>",
               (: do_vote_on($4[1], $4[0]) :));

   add_command("motion", "amend rule <number'rule id'>",
                (: do_amend_current_rule($4[0]) :) );
   add_command("motion", "create new rule <string'type'>",
                (: do_create_motion($4[0]) :) );
   add_command("motion", "remove rule <number'rule id'>",
                (: do_remove_current_rule($4[0]) :) );
   add_command("motion", "move rule <number'rule id'> to <string'type'>",
                (: do_transmogrify_current_rule($4[0], $4[1]) :) );
} /* init() */
// --- END [/mnt/home2/grok/lib/std/room/council_chambers.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/council_vote.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/council_vote.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629261   Available: 13576615
Inodes: Total: 5242880    Free: 4960135
12483 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/council_vote.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629261   Available: 13576615
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is the room you will use to vote for magistrates.
 * @author Pinkfish
 * @started Mon Oct 23 22:26:11 PDT 2000
 */
inherit "/std/room/basic_room";
inherit "/std/room/inherit/council_base";
inherit "/std/room/inherit/voting_room";
#include <nomic_system.h>
#include <player_handler.h>

void post_results(string type, string desc, string* choices,
                  mixed* votes, string* voted);

void create() {
   voting_room::create();

   set_vote_conditions( (: NOMIC_HANDLER->is_citizen_of(query_council_area(),
                            $1->query_name()) :));
   set_completion_action( (: post_results :));
   set_vote_duration( 7 * 24 * 60 * 60);
   //set_open_voting(1);
   basic_room::create();
   add_help_file("voting_booth");
   setup_after_load();
} /* create() */

/**
 * This method prints some useful information about the election status
 * of the current area.
 * @return 1 on success, 0 on failure
 */
int do_status() {
   string person;
   string* nominated;
   string* magistrates;
   string ret;

   if (!NOMIC_HANDLER->is_citizen_of(query_council_area(),
                                     this_player()->query_name())) {
      add_failed_mess("You must be a citizen to see this information.\n");
      return 0;
   }

   magistrates = NOMIC_HANDLER->query_magistrates(query_council_area());
   if (!sizeof(magistrates)) {
      ret = "There are no current magistrates.\n\n";
   } else {
      ret = "The current magistrates of " + query_council_area() +
            " are " +
            query_multiple_short(map(magistrates, (: capitalize($1) :))) +
            ".\n\n";
   }

   if (NOMIC_HANDLER->is_nomination_phase(query_council_area())) {
      ret += "The citizens of " + query_council_area() + " are currently "
            "accepting nominations for the " +
            query_num(NOMIC_HANDLER->query_number_of_magistrates(query_council_area())) +
            " magistrate positions.  The "
            "currently nominated people are:\n";
      nominated = sort_array(NOMIC_HANDLER->query_people_nominated(query_council_area()), 0);
      if (!sizeof(nominated)) {
         ret += "No one is currently nominated.\n";
      } else {
         foreach (person in nominated) {
            ret += "$I$6=   " + capitalize(person) + " nominated by " +
                   query_multiple_short(map(NOMIC_HANDLER->query_nominated_by(
                                          query_council_area(), person),
                                          (: capitalize($1) :)));
            if (NOMIC_HANDLER->is_nomination_accepted(query_council_area(),
                                                      person)) {
               ret += " (accepted)\n";
            } else {
               ret += "\n";
            }
         }
      }
      ret += "\n\n$I$0=The phase ends at " +
         ctime(NOMIC_HANDLER->query_end_of_phase_time(query_council_area())) +
             "\n";
   } else if (NOMIC_HANDLER->is_election_phase(query_council_area())) {
      ret += "The citizens of " + query_council_area() + " are currently "
            "voting for people in the " +
            query_num(NOMIC_HANDLER->query_number_of_magistrates(query_council_area())) +
            " magistrate positions.  The people "
            "you can vote for are:\n";

      nominated = sort_array(NOMIC_HANDLER->query_can_vote_for(query_council_area()), 0);
      foreach (person in nominated) {
         ret += "   * " + capitalize(person) + "\n";
      }
      ret += "\n\n$I$0=The phase ends at " +
         ctime(NOMIC_HANDLER->query_end_of_phase_time(query_council_area())) +
             "\n";
      if (NOMIC_HANDLER->has_voted(query_council_area(),
                                this_player()->query_name())) {
         ret += "You have already voted.\n";
      } else {
         ret += "You have not yet voted.\n";
      }
   } else {
      ret += "\n\nThe next election is at " +
         ctime(NOMIC_HANDLER->query_next_election_time(query_council_area())) +
             "\n";
   }
   this_player()->more_string(ret, "Status");
   return 1;
} /* do_status() */

/**
 * This method allows you to vote for someone.
 */
int do_vote(string person, int force) {
   string* bits;

   if (!NOMIC_HANDLER->is_citizen_of(query_council_area(),
                                     this_player()->query_name())) {
      add_failed_mess("You must be a citizen to vote.\n");
      return 0;
   }

   if (!NOMIC_HANDLER->is_election_phase(query_council_area())) {
      add_failed_mess("There is no election at the moment.\n");
      return 0;
   }

   if (NOMIC_HANDLER->has_voted(query_council_area(),
                                this_player()->query_name())) {
      add_failed_mess("You have already voted.  You cannot vote twice!\n");
      return 0;
   }

   bits = explode(replace_string(lower_case(person), " ", ""), ",");
   bits = uniq_array(bits);
   foreach (person in bits) {
      if (!NOMIC_HANDLER->is_eligible_to_vote_for(query_council_area(),
                                                  person)) {
         add_failed_mess("You cannot vote for " + person + " as they are not "
                         "running or not a citizen.\n");
         return 0;
      }
   }

   if (!force &&
       sizeof(bits) <
            NOMIC_HANDLER->query_number_of_magistrates(query_council_area())) {
      add_failed_mess("You must vote for at least " +
            query_num(NOMIC_HANDLER->query_number_of_magistrates(query_council_area())) +
            " magistrates or use the 'force' option to vote for less.\n");
      return 0;
   }

   if (sizeof(bits) >
            NOMIC_HANDLER->query_number_of_magistrates(query_council_area())) {
      add_failed_mess("You can only vote for " +
            query_num(NOMIC_HANDLER->query_number_of_magistrates(query_council_area())) +
            " magistrates, not more.\n");
      return 0;
   }

   if (NOMIC_HANDLER->vote_for_people(query_council_area(), bits,
                                      this_player()->query_name())) {
      add_succeeded_mess(({ "You successfully vote for " +
                            query_multiple_short(bits) + ".\n",
                            "$N votes for someone.\n" }));
      return 1;
   }

   add_failed_mess("Unable to vote for some reason.\n");
   return 0;
} /* do_vote() */

/**
 * This method allows you to nominate someone for a position.
 */
int do_nominate(string person) {
   person = lower_case(person);
   if (!NOMIC_HANDLER->is_citizen_of(query_council_area(),
                                     this_player()->query_name())) {
      add_failed_mess("You must be a citizen to nominate someonej.\n");
      return 0;
   }

   if (!NOMIC_HANDLER->is_citizen_of(query_council_area(), person)) {
      add_failed_mess("You can only nominate someone who is a citizen.\n");
      return 0;
   }

   if (!NOMIC_HANDLER->is_nomination_phase(query_council_area())) {
      add_failed_mess("There is no election at the moment.\n");
      return 0;
   }

   if (PLAYER_HANDLER->test_creator(person)) {
      add_failed_mess("You cannot nominate a creator.\n");
      return 0;
   }

   if (member_array(this_player()->query_name(),
                    NOMIC_HANDLER->query_nominated_by(query_council_area(),
                                                      person)) != -1) {
      add_failed_mess("You have already nominated " + person + ".\n");
      return 0;
   }

   if (NOMIC_HANDLER->nominate_magistrate(query_council_area(), person,
                                          this_player()->query_name())) {
      add_succeeded_mess(({ "You successfully nominated " +
                            upper_case( person ) + ".\n",
                            "$N nominates " + person + ".\n" }));
      return 1;
   }

   add_failed_mess("Unable to nominate for some reason.\n");
   return 0;
} /* do_nominate() */

/**
 * This lists all the new rules up for discussion or whatever by the
 * magistrates.
 * @return 1 on success, 0 on failure
 */
int do_list_motions() {
   class nomic_motion* rules;
   class nomic_motion rule;
   int is_mag;
   string ret;

   rules = NOMIC_HANDLER->query_all_motions(query_council_area());
   is_mag = NOMIC_HANDLER->is_magistrate_of(query_council_area(),
                      this_player()->query_name());
   if (!is_mag) {
      rules = filter(rules, (: $1->state == NOMIC_STATE_CITIZEN_VOTE :));
   }

   if (!sizeof(rules)) {
      add_failed_mess("No motion to look at or vote on.\n");
      return 0;
   }

   ret = "";
   foreach (rule in rules) {
      ret += NOMIC_HANDLER->motion_as_string(0, query_council_area(), rule);
      ret += "\n";
   }
   write("$P$New Nomic Rules$P$" + ret);
   return 1;
} /* do_list_motions() */

/**
 * This method will handle voting on the specific new nomic rule.
 * @param num the rule number to vote on
 * @param vote their vote
 * @return 1 on success, 0 on failure
 */
int do_vote_on(int num, string vote) {
   class nomic_motion rule;
   int is_mag;
   int vote_id;

   rule = NOMIC_HANDLER->query_motion(query_council_area(), num);
   is_mag = NOMIC_HANDLER->is_magistrate_of(query_council_area(),
                      this_player()->query_name());
   if (!rule || (!is_mag && rule->state != NOMIC_STATE_CITIZEN_VOTE)) {
      add_failed_mess("Could not find the motion " + num + ".\n");
      return 0;
   }

   if (rule->state != NOMIC_STATE_CITIZEN_VOTE &&
       rule->state != NOMIC_STATE_COUNCIL_VOTE) {
      add_failed_mess("The rule is not in a state that you can vote on.\n");
      return 0;
   }

   switch (vote) {
   case "yes" :
      vote_id = NOMIC_VOTE_YES;
      break;
   case "no" :
      vote_id = NOMIC_VOTE_NO;
      break;
   case "abstain" :
      vote_id = NOMIC_VOTE_ABSTAIN;
      break;
   default :
      add_failed_mess("Unknown type of vote, must be one of yes, no or "
                      "abstain.\n");
      return 0;
   }

   if (NOMIC_HANDLER->has_voted_for_motion(query_council_area(), num,
                     this_player()->query_name())) {
      add_failed_mess("You have already voted for this rule!\n");
      return 0;
   } else if (NOMIC_HANDLER->vote_for_motion(query_council_area(), num, vote_id,
                     this_player()->query_name())) {
      add_succeeded_mess(({ "$N $V for " + vote + " in motion id " + num +
                            ".\n",
                            "$N $V for a motion.\n" }));
      return 1;
   }
   add_failed_mess("Could not vote for the rule for some reason.\n");
   return 0;
} /* do_vote_on() */

/** @ignore yes */
void post_results(string type, string desc, string* choices,
                  mixed* votes, string* voted) {
   string mess;
   int i;

   mess = "The results of the poll on:\n" + desc + "\n.\n";
   for (i = 0; i < sizeof(choices); i++) {
      if (arrayp(votes[i])) {
         mess += choices[i] + ":  " + sizeof(votes[i]) + "\n";
      } else {
         mess += choices[i] + ":  " + votes[i] + "\n";
      }
   }

   mess += "\n\nPlease note: This is not a new law, just an opinion poll.\n";

   NOMIC_HANDLER->post_citizen_message(query_council_area(), "Results of Poll",
                                          mess);
} /* post_results() */

/** @ignore yes */
void add_vote(string type, string description, string *choices, int ending) {
   string mess;

   ::add_vote(type, description, choices, ending);

   mess = "New vote on:\n" + description + "\nWith choices of " +
          query_multiple_short(choices) + ".\n",
   NOMIC_HANDLER->post_citizen_message(query_council_area(), "New vote by " +
                    this_player()->query_cap_name(),
                                          mess);
} /* add_vote() */


/** ignore yes */
void init() {
   basic_room::init();
   voting_room::init();
   add_command("list", "elections", (: do_status() :));
   add_command("list", "motions", (: do_list_motions() :));
   add_command("information", "", (: do_status() :));
   add_command("status", "", (: do_status() :));
   add_command("vote", "{yes|no|abstain} in [motion] <number'id'>",
               (: do_vote_on($4[1], $4[0]) :));
   add_command("vote", "for <string'people'>", (: do_vote($4[0], 0) :));
   add_command("vote", "force for <string'people'>", (: do_vote($4[0], 1) :));
   add_command("nominate", "<string'person'>", (: do_nominate($4[0]) :));
   if (NOMIC_HANDLER->is_magistrate_of(query_council_area(),
                                      this_player()->query_name())) {
      init_add_vote();
   }
} /* init() */
// --- END [/mnt/home2/grok/lib/std/room/council_vote.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/council_document.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/council_document.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629258   Available: 13576612
Inodes: Total: 5242880    Free: 4960135
493 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/council_document.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629258   Available: 13576612
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * A stable in which to house your lucky transport.
 * @author Pinkfish
 * @started Tue Nov 30 23:37:12 PST 1999
 */
inherit "/std/room/document_handler";
inherit "/std/room/inherit/council_base";
#include <nomic_system.h>

/** @ignore yes */
int is_open_for(string type, string name) {
   switch (type) {
   case "document_add" :
   case "document_delete" :
      return NOMIC_HANDLER->is_magistrate_of(query_council_area(), name);
   default :
      return 1;
   }
} /* is_open_for() */
// --- END [/mnt/home2/grok/lib/std/room/council_document.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/council_treasury.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/council_treasury.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629257   Available: 13576611
Inodes: Total: 5242880    Free: 4960135
13030 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/council_treasury.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629257   Available: 13576611
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is the council treasury inheritable.  It does fun stuff!  Kudos to
 * Pinkfish for the deposit/withdrawl stuff, which I shamelessy stole 
 * from /std/bank.
 * @author Kili
 * @started Late October 2001
 */

inherit "/std/room";
inherit "/std/room/inherit/council_base";

#define TWO_WEEKS (60 * 60 * 24 * 7 * 2)
#define READ_LOG 1
#define DEPOSIT 2
#define MAGISTRATE 2
#define CITIZEN 1
#define ANYONE 0

#define COUNCIL_LOG_WITHDRAW_INDEX 0
#define COUNCIL_LOG_DEPOSIT_INDEX  1

#include <money.h>
#include <move_failures.h>
#include <nomic_system.h>

private nosave string _save_file;
private nosave string _archive;
// One toon. It just makes things easier, all right? =P
private int _balance = 200;
private int _read;
private int _dep;
private int *_log;

int do_withdraw(int,
                string,
                string);
int do_deposit(int);
int do_check();

class transaction {
   string person;
   int amount;
   string reason;
   int date;
   string action;
}

class transaction *transactions = ({ });

/**
 * Save the variables for this treasury.
 */
void save_me()
{
   if (!_save_file) {
      debug_printf("Error: No save file set.\n");
      return;
   }
   unguarded((: save_object, _save_file :));
   return;
}                               /* save_me() */

/**
 * Load the variables for this treasury.
 */
void load_me()
{
   if (!_save_file)
      return;

   if (file_size(_save_file + ".o") > 0) {
      unguarded((: restore_object, _save_file :));
      return;
   }
   return;
}

/**
 * This will check to see if the player attempting an action is allowed to
 * perform that action.
 * @param player The player attempting the action
 * @param type The type of action (deposting, reading logs, etc.).
 */
int security_check(object player,
                   int type)
{
   int person;
   int tmp;

   if (!type)
      return -1;

   if (!player)
      return -1;

// Just for testing, no longer needed.
//   if (player->query_creator())
//      return 1;
   if (NOMIC_HANDLER->is_magistrate_of(query_council_area(), this_player()->query_name())) {
      person = 2;
   }

   if (NOMIC_HANDLER->is_citizen_of(query_council_area(), this_player()->query_name())) {

      person = 1;
   } else {
      person = 0;
   }
   // What are they trying to do? Find that out and make tmp equal what
   // security level it is.
   if (type == READ_LOG)
      tmp = _read;

   if (type == DEPOSIT)
      tmp = _dep;

   // Do they need to be a magistrate or a citizen? Are they?
   switch (tmp) {
   case MAGISTRATE:
      return (person == 2);
      break;
   case CITIZEN:
      return (person >= 1);
      break;
   case ANYONE:
      return 1;
   }
}

/**
 * This will check the time of the last transactions, and move them into a
 * log file if they are over two weeks old.
 */
void check_time()
{
   string str;

   while (transactions[0]->date + TWO_WEEKS < time()) {
      str =
         capitalize(transactions[0]->person) + " " + transactions[0]->action +
         " " + MONEY_HAND->money_value_string(transactions[0]->amount, query_property("place"));
      str +=
         (transactions[0]->action ==
          "withdrew" ? " for " + transactions[0]->reason : "");
      str += " on " + amtime(transactions[0]->date) + ".\n";
      log_file(_archive, str, 0);
      transactions = transactions[1..];
   }
}                               /* check_time() */

/**
 * @ignore yes
 */
void log_action(object player,
                int amount,
                string action,
                string word)
{
   // This bit is actually superfluous, but why not!
   string reason = (word ? word : "no reason specified");
   class transaction new_trans;

   if (!player)
      return;

   if (!amount)
      return;

   if (!action)
      return;

 new_trans = new (class transaction, person: player->query_name(), amount: amount, reason: reason, date: time(), action:action);
   transactions += ({ new_trans });
   check_time();
   save_me();
}                               /* log_withdrawl */

/**
 * @ignore yes
 */
varargs int view_transactions(string player)
{
   int i;
   int f;
   string ret;
   
   if (!security_check(this_player(), READ_LOG)) {
      return
         add_failed_mess("You aren't allowed to view the transactions.\n");
   }
   ret = "A peek at the log book reveals:\nTransactions\n---\n\n";

   if (!sizeof(transactions)) {
      ret += "None so far.\n";
      write("$P$Transactions$P$" + ret);
      return 1;
   }

   if(player) {
      for(i = 0; i <sizeof(transactions); i++) {
         if (transactions[i]->person != lower_case(player)) {
            continue;
         }
            ret += capitalize(transactions[i]->person) + " " +
                transactions[i]->action + " " +
                MONEY_HAND->money_value_string(transactions[i]->amount,
                query_property("place")) +
                (transactions[i]->action ==
                "withdrew" ? " for " + transactions[i]->reason : "") +
                " on " + amtime(transactions[i]->date)
                + ".\n";
         
      }
   } else {    
      for (i = 0; i < sizeof(transactions); i++) {
         
      ret += capitalize(transactions[i]->person) + " " +
          transactions[i]->action + " " +
          MONEY_HAND->money_value_string(transactions[i]->amount,
          query_property("place")) +
          (transactions[i]->action ==
          "withdrew" ? " for " + transactions[i]->reason : "") +
          " on " + amtime(transactions[i]->date)
          + ".\n";
      }
   }
   write("$P$Transactions$P$" + ret);
   return 1;
}                               /* view_transactions */

/**
 * @ignore yes
 */
void create()
{
   set_short("council treasury");
   set_long("This is the treasury for the council.\n");
   ::create();
   load_me();
   add_help_file( "council_treasury" );
}                               /* create() */

/**
 * @ignore yes
 */
void init()
{
   ::init();

   this_player()->add_command("withdraw", this_object(), "<number'amount'> "
                              "<string'type'> for <string'reason'>",
                              (: do_withdraw($4[0], $4[1], $4[2]) :));
   this_player()->add_command("deposit", this_object(), "<string>",
                              (: do_deposit($4[0]) :));
   this_player()->add_command("check", this_object(), "balance");
   this_player()->add_command("view", this_object(),
                              "transactions",
                              (: view_transactions() :));
   this_player()->add_command("view", this_object(),
                              "transactions [by] <word'player'>",
                              (: view_transactions($4[0]) :));
}                               /* init() */

/**
 * Set the save file for the treasury
 * @param file The file to save to
 */
void set_save_file(string file)
{
   _save_file = file;
}                               /* set_save_file() */

/**
 * Set the location of the treasury, to determine what type of currency to use
 * @param word The location
 */
void set_place(string word)
{
   add_property("place", word);
}                               /* set_place() */

/**
 * @ignore yes
 */
int do_check()
{
   write("The treasury contains " + MONEY_HAND->money_value_string(_balance,
                                                                   query_property("place")) +
         ".\n");
   return 1;
}                               /* do_check() */

/**
 * @ignore yes
 */
int do_withdraw(int number,
                string type,
                string reason)
{
   int amount;
   int best;
   object money;

   if (!NOMIC_HANDLER->is_magistrate_of(query_council_area(), this_player()->query_name())) {
      notify_fail("You must be a magistrate to withdraw funds.\n");
      return 0;
   }

   if (number <= 0) {
      notify_fail("You must withdraw something.\n");
      return 0;
   }

   money = clone_object(MONEY_OBJECT);
   money->set_money_array((mixed *) MONEY_HAND->query_values_in(query_property("place")));
   if ((best = (int) money->find_best_fit(type)) == -1) {
      notify_fail("That currency is not legal tender here.  Sorry.\n");
      money->dest_me();
      return 0;
   }
   type = ((mixed *) money->query_money_array())[best];
   amount = number * ((mixed *) money->query_money_array())[best + 1];
   if ((amount > _balance) || (amount < 0)) {
      notify_fail("There isn't that much in the account.\n");
      money->dest_me();
      return 0;
   }
   money->set_money_array(({ type, number }));
   _balance -= amount;
   save_me();
   this_player()->add_succeeded_mess(this_object(),
                                     ({ "You withdraw " +
                                        (string) money->short() + ".\n" +
                                        "There is " +
                                        (string) MONEY_HAND->
                                        money_value_string(_balance,
                                                           query_property("place")) +
                                        " in your account after the withdrawal.\n",
                                        "$N withdraws some money from the treasury.\n" }),
                                     ({ }));
   if ((int) money->move(this_player()) != MOVE_OK) {
      write
         ("You are too heavily burdened to collect the money, so the teller "
          + "puts it on the counter for you.\n");
      money->move(this_object());
   }

   if (_log[COUNCIL_LOG_WITHDRAW_INDEX]) {
      log_action(this_player(), amount, "withdrew", reason);
   }

   this_player()->save();
   return 1;
}                               /* do_withdraw() */

/**
 * @ignore yes
 */
int do_deposit(string words)
{
   int amount;
//int total;
   mixed money;
   object *tender;
   object legal;
   object illegal;
   string howmuch;

   if (!security_check(this_player(), DEPOSIT)) {
      return add_failed_mess("You are not allowed to deposit.\n");
   }

   money = (mixed) MONEY_HAND->parse_money(words, this_player(), query_property("place"));
   if (intp(money)) {
      switch (money) {
      case NO_MATCH:
         return notify_fail("You do not have \"" + words + "\".\n");
      case NO_MONEY:
         return notify_fail("You can only deposit money.\n");
      default:
         return notify_fail("You can only deposit legal tender.\n");
      }
   }
   // Figure out the legal tender
   tender = MONEY_HAND->filter_legal_tender(money, query_property("place"));
   legal = tender[0];
   illegal = tender[1];
   if (legal) {
      amount = legal->query_value_in(query_property("place"));
      // Minimum amount added to prevent depositing 1c 1000 times to avoid
      // charges.
      if (amount < 200) {
         legal->move(this_player());
         if (illegal) {
            illegal->move(this_player());
         }
         add_failed_mess("That is too small an amount to deposit.\n");
         return 0;
      }

      _balance += amount;
      save_me();
   }
   // Give them back their illegal money and zap the other stuff.
   if (illegal) {
      illegal->move(this_player());
   }

   if (legal) {
      howmuch = legal->the_short();
      legal->move("/room/rubbish");
      this_player()->save();
   } else {
      add_failed_mess("Unable to find any legal money to deposit.\n");
      return 0;
   }

   write("You give the teller " + howmuch + ".\n");

   this_player()->add_succeeded_mess(this_object(),
                                     ({ "$N $V " + words + ".\n"
                                        "This gives a total of " +
                                        MONEY_HAND->
                                        money_value_string(_balance,
                                                           query_property("place")) +
                                        " in the treasury.\n",
                                        "$N deposits some money into the treasury.\n" }),
                                     ({ }));

   if (_log[COUNCIL_LOG_DEPOSIT_INDEX])
      log_action(this_player(), amount, "deposited", "");
   return 1;
}                               /* do_deposit() */

/**
 * This sets what you must be to read the log and deposit cash, and also
 * wether you are logging withdrawls and deposits.
 * @param read_log 2 for magistrate, 1 for citizen, 0 for anyone is able to
 * read the log
 * @param deposits Same as for read_log, to see who can deposit
 * @param logging ({withdrwals, deposits}), are we logging? 0 for no, 1 for yes
 */
void set_security_levels(int read_log,
                         int deposits,
                         int *logging)
{
   _read = read_log;
   _dep = deposits;
   _log = logging;
}                               /* set_security_levels() */

/**
 * This sets the file to which old logs will be transferred after two weeks.  
 * You can then modify the council archives to read the file.
 * @param word The file to write to
 */
void set_archive(string word)
{
   _archive = word;
}                               /* set_archive */
// --- END [/mnt/home2/grok/lib/std/room/council_treasury.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/rooftop.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/rooftop.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629254   Available: 13576608
Inodes: Total: 5242880    Free: 4960135
24161 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/rooftop.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629254   Available: 13576608
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: rooftop.c,v 1.10 2003/03/24 21:16:14 ceres Exp $
 */
#include <tasks.h>

#define TOO_SOON "too soon to proceed from rooftop"

inherit "/std/room/outside";

/**
 * This is a standard rooftop inheritable. It allows you to setup a rooftop
 * location including such things as slope, strength, jumping locations etc.
 *
 * @example
 * inherit "/std/rooftop"
 *
 * void setup() {
 *    set_fall_damage( "all", 500 );
 *    set_slope( 60, "ledge", PATH + "womble01" );
 *    set_weak_messages(
 *      "The ledge crumbles under your weight.",
 *      "$short$ falls from the crumbling ledge.",
 *      "$short$ comes crashing to the ground.",
 *      "The paving stones shift beneath your feet.",
 *    );
 *    set_weak_roof( 2000, PATH + "womble01" );
 *    set_jump( ({ "north", "n" }), PATH + "ledge01", PATH + "womble01", 6 );
 * }
 *
 * @see set_wall
 * @author shrike
 */
#define DEBUG

#define ROCK "other.movement.climbing.rock"
#define ROPE "other.movement.climbing.rope"

/* function prototypes */
void   set_death_reason( string );
void   set_fall_damage( string, int );
mixed  query_fall_damage( string );
int    calc_fall_damage( string );
void   set_weak_roof( int, string );
void   set_slope( int, string, string );
string process_string( string, mapping );
string process_mess( string, object, string );

/* object variables */
mapping  damages;          // damages for all the various types of falling.
string * damage_types;
int      roof_max_weight;  // in units (20 units == 1 kg)
int      gradient;         // percentage grade of the roof.
string   weak_roof_dest;   // where you fall if the roof collapses.
string   slope_dest;       // where you fall if you slip off the roof.
string   place;            // where you fall off of. (ie "edge of the roof
                           //  bordering Filigree Street" )
string   death_reason;     // used when you die.

/*
 * Message arrays. most are of the form
 * ({ player_mess, exit_mess, enter_mess })
 * Where player_mess is what the player who's jumping/falling sees.
 * exit mess is the message sent to the other objects in the starting room,
 * and enter_mess is what the objects in the target room see.
 * weak_messages has an additional 4th parameter, which is the message to
 * the room when the roof is about to collapse, and jump_tm_messages will
 * be randomly selected from if the player gets a TM while jumping.
 */
string * weak_messages;    // for when a roof collapses.
string * slope_messages;   // falling off
string * step_messages;    // stepping off when you should have jumped
string * jump_tm_messages;       // tm messages. it will pick a rnadom one
string * jump_success_messages;  // jumping successfully
string * jump_failure_messages;  // jumping unsuccessfully
string * ghost_fall_messages;    // a ghost drifting to the ground
string * item_slope_messages;    // a non-corpse item sliding off the edge
string * corpse_slope_messages;  // a corpse sliding off the edge

/*
 * Info for jumping from roof to roof. each element is of the form
 * <string:key>: ({             Name of the exit
 *    <string:destination>,     Filename of the destination room
 *    <string:fall_dest>,       filename of the room where you fall on failure
 *    <int:distance>            Distance. (streets in AM are ~5-20 wide
 * })
 */
mapping jump_info;

/*
 * Translates from direction aliases to jump_info keys. Each element looks
 * like <string:name> : <string: jump_info key>
 * In order to pull up the jump info for a particular location, you'd
 * use jump_info[ translations["name"] ].
 */
mapping translations;

/** @ignore yes */
void init() {
   ::init();
   add_command( "jump", "<word'direction'>",
     (: this_object()->do_roofjump( $4[0] ) :) );
} /* init() */

/** @ignore yes */
void create() {
   do_setup++;
   ::create();
   do_setup--;

   weak_messages = ({
     "The roof collapses! This is going to be painful...\n",
     "$short$ crashes down through a weak spot in the roof.",
     "$short$ comes crashing to the ground, landing in a rain of debris.",
     "You hear an ominous creak.\n"
   });

   slope_messages = ({
     "The roof is too steep for you to stand on! It's time to make friends "
       "with the floor...\n",
     "$short$ gets in touch with gravity and slides over the edge of the "
       "roof.",
     "$short$ comes crashing to the ground, landing in a heap."
   });

   step_messages = ({
     "You step off the edge of the roof into midair.\n",
     "$short$ steps off the edge of the roof and plummets earthwards.",
     "$short$ comes crashing to the ground, landing in a heap."
   });

   jump_tm_messages = ({
     "You leap more gracefully through the air.",
     "You feel more able to leap tall buildings in a single bound.",
     "You jump like a mountain goat."
   });

   jump_success_messages = ({
     "You launch yourself off the edge of the roof and land gracefully on "
       "the other side.\n",
     "$short$ jumps gracefully across the gap to the $dir$.",
     "$short$ jumps in from across the gap to the $opp_dir$."
   });

   jump_failure_messages = ({
     "You launch yourself off the edge of the roof!\nUnfortunately you "
       "misjudge the distance and plummet earthwards. This is going to "
       "hurt...\n",
     "$short$ jumps off to the $dir$, but misjudges and plummets "
       "earthwards.",
     "$short$ plummets to the ground, landing in a heap."
   });

   ghost_fall_messages = ({
      "You find your consciousness drifting earthwards.\n",
      "$the_short$ drifts earthwards.",
      "$the_short$ drifts in from above, looking somewhat dazed."
   });

   item_slope_messages = ({
     "$the_short$ tumbles over the edge and plummets to the ground.\n",
     "Hearing a noise, you look up just as $a_short$ falls off the edge "
       "of the roof and hits the ground.\n"
   });

   corpse_slope_messages = ({
     "$the_short$ tumbles over the edge and plummets to the ground with "
       "a sickening thud.\n",
     "Hearing a noise, you look up just as $the_short$ tumbles over the "
       "edge of the roof and hits the ground with a sickening thud.\n"
   });

   damages = ([ ]);
   damage_types = ({ "weak", "slope", "step", "jump" });
   translations = ([ ]);
   jump_info = ([ ]);

   this_object()->setup();
} /* create() */

/* Customize the message sets */

/**
 * Set the messages for when a player falls through a weak roof.
 *
 * @param player the message shown to the player.
 * @param from the message shown in the room the player is leaving.
 * @param to the message shown in the room the player is entering.
 * @param warn the message shown to the room just before the roof collapses.
 *
 * @see set_weak_roof
 */
void set_weak_messages( string player, string from, string to, string warn ) {
   weak_messages = ({ player, from, to, warn });
} /* set_weak_messages() */

/**
 * Set the messages for when a player slips off a sloping roof.
 *
 * @param player the message shown to the player.
 * @param from the message shown in the room the player is leaving.
 * @param to the message shown in the room the player is entering.
 *
 * @see set_slope
 */
void set_slope_messages( string player, string from, string to ) {
   slope_messages = ({ player, from, to });
} /* set_slope_messages() */

/**
 * Set the messages for when a player falls off by moving in the wrong
 * direction.
 *
 * @param player the message shown to the player.
 * @param from the message shown in the room the player is leaving.
 * @param to the message shown in the room the player is entering.
 *
 * @see set_jump
 */
void set_step_messages( string player, string from, string to ) {
   step_messages = ({ player, from, to });
} /* set_step_messages() */

/**
 * Set the messages for when a player gets a TM by jumping. These messages
 * will be selected at random, and then coloured appropriately.
 *
 * @param messages the array of messages from which to choose.
 *
 * @see set_jump
 */
void set_jump_tm_messages( string * messages ) {
   jump_success_messages = messages;
} /* set_jump_tm_messages() */

/**
 * Set the messages for when a player successfully jumps a gap.
 *
 * @param player the message shown to the player.
 * @param from the message shown in the room the player is leaving.
 * @param to the message shown in the room the player is entering.
 *
 * @see set_jump
 */
void set_jump_success_messages( string player, string from, string to ) {
   jump_success_messages = ({ player, from, to });
} /* set_jump_success_messages() */

/**
 * Set the messages for when a player falls off by failing to jump across
 * a gap.
 *
 * @param player the message shown to the player.
 * @param from the message shown in the room the player is leaving.
 * @param to the message shown in the room the player is entering.
 *
 * @see set_jump
 */
void set_jump_failure_messages( string player, string from, string to ) {
   jump_failure_messages = ({ player, from, to });
} /* set_jump_failure_messages() */

/**
 * Set the messages for when a ghost falls off a roof.
 *
 * @param player the message shown to the player.
 * @param from the message shown in the room the player is leaving.
 * @param to the message shown in the room the player is entering.
 *
 * @see set_slope
 */
void set_ghost_fall_messages( string player, string from, string to ) {
   ghost_fall_messages = ({ player, from, to });
} /* set_ghost_fall_messages() */

/**
 * Set the messages for when a corpse slides off a sloping roof.
 *
 * @param from the message shown in the room the corpse is leaving.
 * @param to the message shown in the room the corpse is entering.
 *
 * @see set_slope
 */
void set_corpse_slope_messages( string from, string to ) {
  corpse_slope_messages = ({ from, to });
} /* set_item_slope_messages() */

/**
 * Set the messages for when a non-corpse item slides off a sloping roof.
 *
 * @param from the message shown in the room the object is leaving.
 * @param to the message shown in the room the object is entering.
 *
 * @see set_slope
 */
void set_item_slope_messages( string from, string to ) {
   item_slope_messages = ({ from, to });
} /* set_item_slope_messages() */

/**
 * Set the amount of damage the player will take if they fall off this
 * roof.  This amount is somewhat randomised.
 *
 * @param type The type of fall (weak, slope, step or jump; all to set all damages the same)
 * @param damage The amount of damage.
 *
 * @see set_slope, set_jump, set_weak_roof
 */
void set_fall_damage( string type, int damage ) {
   if( damage < 0 )
      damage = -damage;

   if( type == "all" ) {
      foreach( type in damage_types )
         damages[type] = damage;
   } else if( member_array( type, damage_types ) >= 0 ) {
      damages[type] = damage;
   } else
      return;
} /* set_fall_famage() */

/**
 * Find out the damage for falling from this location.
 *
 * @param type The type ( weak, slope, step, jump, or all )
 * @return An int, or an integer array of the damage(s)
 *
 * @see set_fall_damage
 */
mixed query_fall_damage( string type ) {
   if( type == "all" )
      return damages;
   else
      return damages[type];
} /* query_fall_famage() */

/** @ignore yes */
int calc_fall_damage( string type ) {
   if( type == "all" )
      return 0;
   return query_fall_damage( type ) + random( query_fall_damage( type ) );
} /* calc_fall_famage() */

/**
 * Set the maximum weight this location can support.
 *
 * @param maxweight the maximum weight capacity of the roof.
 * @param dest the room you go to if the roof collapses.
 */
void set_weak_roof( int maxweight, string dest ) {
   roof_max_weight = maxweight;
   weak_roof_dest = dest;
} /* set_weak_roof() */

/**
 * Set the gradient of this location.
 *
 * @param angle the angle (in degrees).
 * @param loc a short description of the area to show to players.
 * @param dest the fall destination.
 */
void set_slope( int angle, string loc, string dest ) {
   gradient = ( angle * 100 ) / 90;
   place = loc;
   slope_dest = dest;
} /* set_slope() */

/**
 * Setup a jumping exit. The player will be able to "jump <dir>" and a skill
 * test will be performed and they'll succeed or fail.
 *
 * Streets in AM are usually 5-20 wide.
 * if you want to do something other than the standard fall function,
 * you'll need to mask do_fall() in the child room.
 *
 * @param dir direction names
 * @param dest the destination
 * @param fall_dest the destination if they fall
 * @param distance the distance of the jump
 * @return -1 if any of the keys in dir already exists, 0 if dir is
 * malformed (string and string * are the only acceptable types), or
 * 1 on success.
 *
 * @example
 * set_jump( ({ "north", "n" }), RUN + "run12", FILIGREE + "filigree10", 6 );
 */
int set_jump( mixed dir, string dest, string fall_dest, int distance ) {
   string * dirs;
   mixed foo;
   string bar;

   if( stringp( dir ) ) {
      dirs = ({ dir });
   } else if( arrayp(dir) ) {
      foreach( foo in dir )
         if( !stringp( foo ) )
            return 0;
      dirs = sort_array( dir, 1 );
   }

   foreach( bar in dir )
      if( !undefinedp( translations[bar] ) )
         return -1;

   // setup the mappings
   jump_info[ dir[0] ] = ({ dest, fall_dest, distance });
   foreach( bar in dir )
      translations[bar] = dir[0];

   if( !query_exit( dir[0] ) )
      add_exit( dir[0], dest, "roof" );
   modify_exit( dir[0], ({
     "closed", 1,
     "function", (: this_object()->silly_move( $1, $2, $3,
       jump_info[ translations[$1] ][1], "step", step_messages ) :),
     "look", "You'll have to jump across to see what's on the other side."
   }) );

   return 1;
} /* set_jump() */

/**
 * @ignore yes
 * Internal function used if a player steps off the edge of a roof.
 */
int silly_move( string verb, object ob, string special, mixed dest,
  string dam_type, string * messages ) {
   this_object()->do_fall( ob, dest, dam_type, messages, 0 );
   return notify_fail( "" );
} /* silly_move() */

/**
 * @ignore yes
 * Internal function to handle falling. You can overload this if you so
 * desire.
 */
void do_fall( object obj, mixed dest, string dam_type, string * messages,
  string dir ) {
   int damage, i;
   object destob;

   // Remove the property that prevents them leaving the room..
   obj->remove_property( TOO_SOON );

   for( i = 0; i < sizeof( messages ); i++ )
      messages[i] = process_mess( messages[i], obj, dir );

   if( stringp( dest ) ) {
      if( !(destob = load_object( dest ) ) ) {
         tell_object( obj, "Cannot find " + dest + ".\n"
           "Moving you to the void - Please contact a creator.\n" );
         obj->move_with_look( "/room/void", "Poof. $N appears.\n",
           "$N plummets earthwards.\n" );
         return;
      }
   } else if( objectp( dest ) ) {
      destob = dest;
   } else {
      return;
   }

   tell_object( obj, messages[0] );
   obj->move_with_look( destob, messages[2], messages[1] );
   if( obj->query_property( "dead" ) )
      return;

   damage = calc_fall_damage( dam_type );
   if( damage >= obj->query_hp() ) {
      set_death_reason( "plummeting from the rooftops" );
      obj->attack_by( this_object() );
      obj->do_death();
   } else
      obj->adjust_hp( -damage );
} /* do_fall() */

/**
 * @ignore yes
 * Deals with falling through or off roofs. also takes care of dropped
 * items/corpses on sloped roofs.
 */
void event_enter( object obj, object from ) {
   int totalweight, objectweight, i;
   float encum, diff;
   int fall;
   object * contents;
   object destination;

   if( !obj ) return;

   if( obj->query_property( "demon" )
     || obj->query_property( "floating" ) ) {
      return;
   }

   // This property will keep them from leaving until the skillchecks
   // have had a chance to process
   obj->add_property( TOO_SOON, 1, 5 );

   // deal with weak roofs.  Calculate the total weight of the objects
   // here, including carried items.
   if( roof_max_weight ) {
      contents = all_inventory( this_object() );

      for( i = 0; i < sizeof(contents); i++ ) {
         objectweight = contents[i]->query_weight();
         objectweight += contents[i]->query_loc_weight();
         totalweight += objectweight;
#ifdef DEBUG
         debug_printf( "event_enter: Total weight of %s is %d units.\n",
           obj->query_name(), objectweight );
#endif
      }
#ifdef DEBUG
      debug_printf( "event_enter: The current weight on this roof is %d "
        "units. Max weight is set to %d.\n", totalweight, roof_max_weight );
#endif

      // Have we exceeded the maxweight?
      if( totalweight > roof_max_weight ) {
         fall = 1;
         tell_room( environment( obj ), weak_messages[3] );
         if( !(destination = load_object( weak_roof_dest ) ) ) {
            tell_room( this_object(), "Error loading room "
              + weak_roof_dest + ", moving you to the void.\n"
              "Please contact a creator.\n" );
            for( i = 0; i < sizeof(contents); i++ )
               contents[i]->move_with_look( "/room/void" );
            return;
         }
         for( i = 0; i < sizeof(contents); i++ ) {
            call_out( "do_fall", 1, contents[i], destination, "weak",
              weak_messages, 0 );
         }
         return;
      }
   }

   if( gradient && !fall ) {
      if( living( obj ) ) {
         if( ( obj->query_property( "dead" ) )
           || !( obj->query_max_weight() ) ) {
            call_out( "do_fall", 1, obj, slope_dest, "step",
              ghost_fall_messages );
            return;
         }
         encum = ( 100 * to_float( obj->query_loc_weight() ) )
           / to_float( obj->query_max_weight() );
         diff = to_int( sin( ( 3.1415926536 / 180.0 ) * gradient )
           * ( encum * 10 ) );
         call_out( "gradient_check", 1, obj, slope_dest,
           to_int( diff + ( gradient * 2 ) ) );
      } else {
         if( member_array( obj->query_name(),
           ({ "death", "binky" }) ) >= 0 )
            return;
         if( gradient > 3 ) {
            if( obj->query_corpse() ) {
               obj->move( slope_dest,
                 process_mess( corpse_slope_messages[1], obj, 0 ),
                 process_mess( corpse_slope_messages[0], obj, 0 ) );
            } else {
               obj->move( slope_dest,
                 process_mess( item_slope_messages[1], obj, 0 ),
                 process_mess( item_slope_messages[0], obj, 0 ) );
            }
         }
      }
      return;
   }

   // Remove the property that prevents them leaving the room,
   // since there's no skill check forthcoming.
   obj->remove_property( TOO_SOON );
} /* event_enter() */

/** @ignore yes
 *  Internal function to perform the skillcheck for sloping roofs.
 */
void gradient_check( object obj, string destination, int diff ) {
   object destob;

#ifdef DEBUG
   debug_printf( "gradient_check( %s, \"%s\", %d )",
     obj->query_name(), destination, diff );
#endif

   // Remove the property that prevents them leaving the room..
   obj->remove_property( TOO_SOON );

   switch( TASKER->perform_task( obj, ROCK, diff + 1, TM_FIXED ) ) {
   case AWARD:
      tell_object( obj, "%^YELLOW%^" + ({
        "You balance more confidently on the " + place + ".",
        "Climbing becomes easier."
      })[ random(2) ] + "%^RESET%^\n" );
   case SUCCEED:
      tell_object( obj, "The " + place + " is steep, but you manage "
        "not to fall.\n" );
      break;
   case FAIL:
      if( !( destob = load_object( destination ) ) ) {
         tell_object( obj, "Error loading room " + destination +
           ", moving you to the void.\nPlease contact a creator.\n" );
         obj->move_with_look( "/room/void" );
      } else
         do_fall( obj, destob, "slope", slope_messages, 0 );
      break;
   default:
      write( "Gnaaaaaaaaaaaah! You should not be getting this message.  "
        "Please contact a creator.\n" );
      break;
   }
} /* gradient_check() */

/** @ignore yes */
int do_roofjump( string dir ){
   mixed * info;
   int distance;
   float weight, max_weight;
   object destination, fall_destination;
   string key;

   if( !( key = translations[dir] ) || !( info = jump_info[key] ) ) {
      add_failed_mess( "You can't jump there!\n" );
      return 0;
   }

   if( !(destination = load_object( info[0] ) ) ) {
      add_failed_mess( "Error! The file " + info[0] + " does not exist "
        "or does not load. Please contact a creator.\n" );
      return 0;
   }
   if( !(fall_destination = load_object( info[1] ) ) ) {
      add_failed_mess( "Error! The file " + info[1] + " does not exist "
        "or does not load. Please contact a creator.\n" );
      return 0;
   }
   distance = info[2];

   if( distance ) {
      weight = to_float( this_player()->query_loc_weight() );
      max_weight = to_float( this_player()->query_max_weight() );
      // at this rate, a 300-bonus, unencumbered
      // player can handle a 20-foot gap.
      distance *= to_float( ( to_float(weight) * 7) /
           to_float(max_weight) ) + 15;

      switch( TASKER->perform_task( this_player(), ROCK, distance, TM_FIXED ) ) {
         case AWARD:
            write( "%^YELLOW%^"
              + jump_tm_messages[ random( sizeof( jump_tm_messages ) ) ]
              + "%^RESET%^\n" );
         case SUCCEED:
            write( process_mess( jump_success_messages[0], this_player(), dir ) );
            this_player()->move_with_look( destination,
              process_mess( jump_success_messages[2], this_player(), dir ),
              process_mess( jump_success_messages[1], this_player(), dir ), );
            break;
         case FAIL:
            write( process_mess( jump_failure_messages[0], this_player(), dir ) );
            do_fall( this_player(), fall_destination, "jump",
              jump_failure_messages, dir );
            break;
         default:
            write( "Oh dear. Something is broken. Please inform a "
              "creator.\n" );
      }
      return 1;
   }
} /* do_roofjump() */

/** @ignore yes */
string query_death_reason() {
   call_out( (: death_reason = 0 :), 2 );
   if( death_reason )
      return "/global/player"->convert_message( death_reason );
   return "a rooftop (" + file_name( this_object() )
     + ") with an incorrectly set death message";
} /* query_death_reason() */

/** @ignore yes */
void set_death_reason( string str ) {
   death_reason = str;
} /* set_death_reason() */

/** @ignore yes */
string process_string( string str, mapping transforms ) {
   string foo, bar;

   foreach( foo, bar in transforms )
      if( bar ) str = replace_string( str, foo, bar );
   return "/global/player"->convert_message( str );
} /* process_string() */

/** @ignore yes */
string process_mess( string str, object ob, string direction ) {
   string opp_dir;
   string * directions = ({ "north", "northeast", "east", "southeast",
     "south", "southwest", "west", "northwest" });

   if( !str || ( str == "" ) )
      return "";

   if( stringp( direction ) ) {
      if( member_array( direction, directions ) < 0 ) {
         opp_dir = 0;
      } else {
         opp_dir =
           directions[ ( member_array( direction, directions ) + 4 ) % 8 ];
      }
   }

   str = process_string( str, ([
     "$dir$"       : direction,
     "$opp_dir$"   : opp_dir,
     "$short$"     : ob->query_short(),
     "$poss$"      : ob->query_possessive(),
     "$pronoun$"   : ob->query_pronoun(),
     "$obj$"       : ob->query_objective(),
     "$a_short$"   : ob->a_short(),
     "$the_short$" : ob->the_short(),
     "$one_short$" : ob->one_short()
   ]) );

   return implode( explode( str, ". " ),
     (: "$C$" + $1 + ". " + "$C$" + $2 :) );
} /* process_mess() */

int test_remove( object ob, int flag, mixed dest ) {
   if( !living(ob) ) {
      return ::test_remove( ob, flag, dest );
   }

   if( objectp(dest) )
      dest = file_name(dest);
   if( !stringp(dest) || dest == "/room/rubbish" )
      return 1;

   if( ob->query_property( TOO_SOON ) ) {
      tell_object( ob, "You haven't quite caught your balance yet.\n" );
      notify_fail( "" );
      return 0;
   }
   return ::test_remove( ob, flag, dest );
} /* test_remove() */
// --- END [/mnt/home2/grok/lib/std/room/rooftop.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/club_control_room.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/club_control_room.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629248   Available: 13576602
Inodes: Total: 5242880    Free: 4960135
560 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/club_control_room.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629248   Available: 13576602
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* -*- LPC -*- */
/**
 * This inherit allows people to create clubs and do fluffy club stuff if
 * they need to.
 * @author Arienne
 * @started Tue Feb 27 01:06:55 GMT 2001
 */
inherit "/std/room/basic_room";
inherit "/std/room/inherit/club_control_room";

void create() {
    do_setup++;
    basic_room::create();
    club_control_room::create();
    do_setup--;

    if ( !do_setup ) {
        this_object()->setup();
        this_object()->reset();
    }
} /* create() */

void init() {
    basic_room::init();
    club_control_room::init();
} /* init() */
// --- END [/mnt/home2/grok/lib/std/room/club_control_room.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/guild.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/guild.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629248   Available: 13576602
Inodes: Total: 5242880    Free: 4960135
512 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/guild.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629248   Available: 13576602
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is the standard guild inheritable.  It makes a room the into
 * a place where players can advance and do all those other wonderful 
 * guild things you would expect in a guild room.
 * @author Pinkfish
 * @revision ceres July 1999
 * Change over to the new guild costing mechanisms.
 */
inherit "/std/room/basic_room";
inherit "/std/room/inherit/guild";

void create() {
  guild::create();
  basic_room::create();
} /* create() */

void init() {
  basic_room::init();
  guild::init();
} /* init() */
// --- END [/mnt/home2/grok/lib/std/room/guild.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/basic_room.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/basic_room.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629247   Available: 13576601
Inodes: Total: 5242880    Free: 4960135
98073 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/basic_room.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629247   Available: 13576601
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  RCS stuff...  -*- LPC -*-
 * $Locker: pinkfish $
 *
 * $Id: basic_room.c,v 1.61 2003/10/26 09:30:02 pinkfish Exp pinkfish $
 *
 */

/**
 * The standard room inheritable.  This contains all the stuff needed to
 * construct a standard room.
 * @author Pinkfish
 * @see /std/room/outside.c
 */

#include <armoury.h>
#include <dirs.h>
#include <door.h>
#include <move_failures.h>
#include <room.h>
#include <position.h>
#include <situations.h>
#include <weather.h>
#include <nroff.h>

inherit "/std/basic/cute_look";
inherit "/std/basic/desc";
inherit "/std/basic/extra_look";
inherit "/std/basic/light";
inherit "/std/basic/property";
inherit "/std/basic/export_inventory";
inherit "/std/basic/help_files";
inherit "/std/basic/effects";

nosave int do_setup;
nosave int *co_ord;
nosave int co_ord_calculated;
nosave string long_exit;
nosave string long_exit_mxp;
nosave string short_exit;
nosave string theft_handler;
nosave string *aliases;
nosave string *_exits;

nosave object item;
private nosave object chatter;
nosave object sitchanger;
nosave object linker;
nosave object terrain;
nosave object wall; 
nosave object *hidden_objects;
private nosave object* _use_internal_objects;
nosave mapping door_control;
nosave mixed *dest_other;
nosave int enchant_time;
nosave int background_enchant;
nosave float dynamic_enchant;
private nosave int last_visited;

// This is the day/night stuff.
private nosave string *variablelongs;
private nosave mixed variablechats;
private nosave mixed variableitems;
private nosave int is_day = -1;

varargs int add_item( mixed shorts, mixed desc, int no_plural );
int remove_item( string word );
private void setup_room_chat( );
void set_not_replaceable(int replace);
int query_not_replaceable();
void set_night_long( string str );

protected void create() {
   object *npcs;
   object virt_room;
   string *inhs;

   desc::create();
   extra_look::create();
   property::create();
   export_inventory::create();
   light::create();
   effects::create();
   set_can_export_inventory();
   set_ignore_livings_in_inventory( 0 );
   aliases = ({ });
   _exits = ({ });
   hidden_objects = ({ });
   _use_internal_objects = ({ });
   door_control = ([ ]);
   dest_other = ({ });
   seteuid( (string)"/secure/master"->creator_file( file_name(
           this_object() ) ) );
   add_property( "location", "inside" );
   add_property( "here", "on the floor" );
   if ( !do_setup ) {
      this_object()->setup();
      this_object()->reset();
   }
   if ( find_object( "/obj/handlers/map" ) ) {
      catch( "/obj/handlers/map"->check_map( file_name( this_object() ) ) );
   }
   if( (virt_room = find_object("/room/virtual") ) ){
     npcs = ({}) + all_inventory(virt_room);
     catch(npcs->real_room(file_name()));
   }

   // Check to see if the room is replaceable...
   inhs = inherit_list(this_object());
   if (sizeof(inhs) == 1) {
      if (replaceable(this_object(), ({ "setup" }))) {
         // Do it after a delay so that setup() has definately finished.
         call_out(function(string fname) {
           if (!query_not_replaceable()) {
               catch(replace_program(fname));
           }
         }, 0, inhs[0]);
      }
   }
} /* create() */

/**
 * Returns 1 to indicate that this object is a room.
 * @return 1 to indicate that this is a room
 */
int query_is_room()
{
  return 1;
}

/**
 * Returns the current enchantment level of the room.  The enchanment
 * level controls things like what happens when you flip coins and
 * some special messages which give wizards some idea about magic
 * levels.
 * @return the current enchantment
 * @see set_enchant()
 */
int query_enchant() {
  int enchant_level =  to_int( floor( 0.5 + dynamic_enchant *
                        exp( -0.693 *
                             ( time() - enchant_time ) /
                             ENCHANT_HALF)) +
                 background_enchant );
  if ( enchant_level > 5000 ) {
    return 5000;
  }

  return enchant_level;
} /* query_enchant() */

/**
 * Sets the current enchantment level of the room.  The enchanment
 * level controls things like what happens when you flip coins and
 * some special messages which give wizards some idea about magic
 * levels.
 * When called from the room itself, it sets a background level of 
 * enchantment that don't decay, when called from another object it
 * sets the current enchantment which then decays towards the background 
 * level.
 * @param number the new enchantment level to set
 * @see query_enchant()
 */
int set_enchant(int number) {
  if (number < 0) {
    number = 0;
  }

  if (previous_object()==this_object()) { 
    /* setting up the background enchantment */
    background_enchant = (float) number;
    dynamic_enchant = 0.0;
    enchant_time = time();
  } else {
    /* by design, this can result in negative dynamic enchantment
     * it is definitely possible to suck out all magic in an area,
     * but it'll seep back in if the background level is higher.
     */
    dynamic_enchant = number - background_enchant;
    enchant_time=time();
  }
  return number;
} /* set_enchant() */

/**
 * Adds number to the current enchantment level of the room.
 * The enchanment level controls things like what happens when you
 * flip coins and some special messages which give wizards some 
 * idea about magic levels.
 * @param number the new enchantment level to set
 * @see query_enchant()
 */
int add_enchant( int number ) {
  dynamic_enchant = dynamic_enchant * exp( -0.693 * 
                                           ( time() - enchant_time ) /
                                           ENCHANT_HALF ) + number;
  enchant_time = time();
  return floor( 0.5 + dynamic_enchant ) + background_enchant;
} /* add_enchant() */
  
/**
 * This method sets the background enchantment of the room.
 * @return the theft handler of the room
 * @see set_enchant()
 */
void set_background_enchant( int number ) { 
  background_enchant = number;
} /* set_background_enchant() */

/**
 * This method sets the current dynamic enchantment of the room.
 * @return the theft handler of the room
 * @see set_enchant()
 */
void set_dynamic_enchant( float number ) { 
  dynamic_enchant = number;
  enchant_time = time();
} /* set_dynamic_enchant() */

/**
 * This method returns the background enchantment of the room.
 * @return the theft handler of the room
 * @see query_enchant()
 */
int query_background_enchant() { 
  return background_enchant;
} /* query_background_enchant() */

/**
 * This method returns the current dynamic enchantment of the room.
 * @return the theft handler of the room
 * @see query_enchant()
 */
float query_dynamic_enchant() { 
  dynamic_enchant = dynamic_enchant * exp( -0.693 * 
                                           ( time() - enchant_time ) /
                                           ENCHANT_HALF );
  enchant_time = time();
  return dynamic_enchant;
} /* set_dynamic_enchant() */

/**
 * Returns the current co-ordinates of the room.  The co-ordinates are
 * 3d, ({ x, y, z }).  So an array with three elements.
 * @return the current co-ordinates
 * @see set_co_ord()
 */
int *query_co_ord() {
  if ( pointerp( co_ord ) ) {
    return copy(co_ord);
  }
  return 0;
} /* query_co_ord() */

/**
 * Sets the current co-ordinates of the room.  The co-ordinates are
 * 3d, ({ x, y, z }).  So an array with three elements.
 * @param new_co_ord the new co-ordinates for the room.
 * @see query_co_ord()
 * @see query_co_ord_calculated()
 */
void set_co_ord( int *new_co_ord ) {
  if ( !pointerp( new_co_ord ) ) {
    write( "Warning: Co-ordinate must be an array.\n" );
    return;
  }
  if ( sizeof( new_co_ord ) != 3 ) {
      write( "Warning: The co-ordinate must have three elements.\n" );
      return;
  }
  co_ord = new_co_ord;
  if ( previous_object() == this_object() ) {
    co_ord_calculated = 0;
  } else {
    co_ord_calculated = 1;
  }
} /* set_co_ord() */

/** 
 * This method resets the co-ordinates for the room to zero, and resets
 * a flag so that calc_co_ord() can be called again to redetermine 
 * the room's co-ordinates.
 * @see set_co_ord()
 * @see calc_co_ord()
 * @see query_co_ord()
 * @see query_co_ord_calculated()
 */
void flush_co_ord() {
    co_ord = 0; 
    co_ord_calculated = 0; 
} /* flush_co_ord() */ 

/**
 * This tells us if the co-ordinates were set or if they were calculated.
 * If they were set with set_co_ord then the value of this will be 0
 * otherwise it will be 1.
 * @return 1 if it is calculated, 0 if it is not
 * @see query_co_ord()
 * @see set_co_ord()
 */
int query_co_ord_calculated() { return co_ord_calculated; }

/**
 * This returns the long exit string.  This is calculated when it is
 * first needed by the calc_long_exit function.
 * @return the long exit string
 * @see calc_long_exit()
 * @see long()
 */
string query_long_exit() { return long_exit; }

/**
 * This returns the long exit string with mxp codeds added. 
 * This is calculated when it is
 * first needed by the calc_long_exit function.
 * @return the long exit string
 * @see calc_long_exit()
 * @see long()
 */
string query_long_exit_mxp() { return long_exit_mxp; }

/**
 * This method creates the long exit description used in the room long
 * descriptions.
 * @see query_long_exit()
 */
void calc_long_exit() {
  int i, add;
  string *words;
  mixed tmp;
  
  words = ({ });
  for ( i = 0; i < sizeof( dest_other ); i += 2 ) {
    tmp = dest_other[ i + 1 ][ ROOM_OBV ];
    if ( !tmp ) {
      continue;
    }
    if ( intp( tmp ) && tmp ) {
      add = 1;
    }
    if ( stringp( tmp ) ) {
      add = (int)call_other( this_object(), tmp, dest_other[ i ] );
    }
    if ( pointerp( tmp ) ) {
      add = (int)call_other( tmp[ 0 ], tmp[ 1 ], dest_other[ i ] );
    }
    if ( add ) {
      if(dest_other[i+1][ROOM_REL]) {
        words += ({ "$R$-"+ dest_other[ i ] +"$R$" });
      } else {
        words += ({ dest_other[i] });
      }
    }
  }
  switch ( sizeof( words ) ) {
  case 0 :
    long_exit = "There are no obvious exits.";
    long_exit_mxp = mxp_expire("Exits") + "There are no obvious exits.";
    break;
  case 1 :
    long_exit = "There is one obvious exit: "+ words[ 0 ] + ".";
    long_exit_mxp = mxp_expire("Exits") +
                    "There is one obvious exit: "+ mxp_tag("Exit", words[ 0 ], 1) + ".";
    break;
  default :
    long_exit = "There are "+ query_num( sizeof( words ), 0 ) +
      " obvious exits: "+ query_multiple_short( words ) +
      ".";
    long_exit_mxp = mxp_expire("Exits") +
      "There are "+ query_num( sizeof( words ), 0 ) +
      " obvious exits: "+ query_multiple_short( map(words, (: mxp_tag("Exit", $1, 1) :) ) ) +
      ".";
  }
} /* calc_long_exit() */

/**
 * This method returns the current theft handler for the room.
 * @return the theft handler of the room
 * @see set_theft_handler()
 */
string query_theft_handler() { return theft_handler; }

/**
 * This method sets the current theft handler for the room.
 * @param word the new theft handler for the room
 * @see query_theft_handler()
 */
void set_theft_handler( string word ) { theft_handler = word; }

/**
 * This method returns the current exit aliases for the room.
 * @return the exit aliases of the room
 * @see add_alias()
 * @see remove_alias()
 */
string *query_aliases() { return copy( aliases ); }

/**
 * This method adds an exit alias to the room.
 * Aliases are convenient extra forms that can be attached to certain
 * exits. In the above functions, the variable names is either a string
 * or an array of strings and is, respectively, the alias or aliases
 * for the direction passed in word. Since, sometimes, the same alias
 * could be used for more than one exit, remove_alias() requires both
 * alias(es) and direction in order to remove the correct alias(es). 
 * @param names the exit names to alias
 * @param word the name to alias them too
 * @see query_aliases()
 * @see remove_alias()
 * @example
 * add_exit( "north", PATH +"dining_hall", "corridor" );
 * add_alias( ({ "enter", "enter hall", "enter dining hall" }), "north" );
 * @example
 * add_exit( "board carriage", PATH +"carriage", "door" );
 * add_alias( "board", "board carriage" );
 */
void add_alias( mixed names, string word ) {
  string name;

  if ( !aliases ) {
    aliases = ({ });
  }
  if ( pointerp( names ) ) {
    foreach ( name in names ) {
      add_alias( name, word );
    }
    return;
  }
  aliases += ({ word, names });
  if ( find_call_out( "calc_exits" ) == -1 ) {
    call_out( "calc_exits", 1 );
  }
} /* add_alias() */

/**
 * This method removes the exit aliases from the room.
 * Aliases are convenient extra forms that can be attached to certain
 * exits. In the above functions, the variable names is either a string
 * or an array of strings and is, respectively, the alias or aliases
 * for the direction passed in word. Since, sometimes, the same alias
 * could be used for more than one exit, remove_alias() requires both
 * alias(es) and direction in order to remove the correct alias(es). 
 * @param names the names to remove
 * @param word what they were aliased to
 * @see add_alias()
 * @see query_aliases()
 * @example
 * remove_exit( "board carriage" );
 * remove_alias( "board", "board carriage" );
 */
void remove_alias( mixed names, string word ) {
  int i;
  string name;

  if ( !aliases ) {
    return;
  }
  if ( pointerp( names ) ) {
    foreach ( name in names ) {
      remove_alias( name, word );
    }
    return;
  }
  for ( i = sizeof( aliases ) - 2; i >= -1; i -= 2 ) {
    if ( ( aliases[ i ] == word ) && ( aliases[ i + 1 ] == names ) ) {
      aliases = delete( aliases, i, 2 );  
    }
  }
} /* remove_alias() */

/**
 * This returns the current array of exits.
 * @return the exits array
 * @see add_exit()
 * @see remove_exit()
 * @see modify_exit()
 */
string *query_exits() { return copy(_exits); }

/**
 * This method removes all the current exits in the room.
 * @see add_exit()
 * @see remove_exit()
 * @see modify_exit()
 */
void reset_exits() { _exits = ({ }); }

/**
 * This method returns the current item object.
 * @return the current item object
 * @see add_item()
 */
object query_item() { return item; }

/**
 * This method returns the current chatter object.
 * @return the chatter object
 * @see add_room_chat()
 */
object query_chatter() { return chatter; }

/**
 * This method returns the current situation changer object.
 * @return the situation changer object
 * @see add_situation()
 * @see automate_situation()
 * @see change_situation
 */
object query_situation_changer() { return sitchanger; }

/**
 * This method returns the current linker object.
 * @return the linker object
 */
object query_linker() { return linker; }

/**
 * This method returns the current terrain object.
 * @return the terrain object
 * @see add_room_chat()
 */
object query_terrain() { return terrain; }

/**
 * This method returns the current wall object.
 * @return the wall object
 * @see add_room_chat()
 */
object query_wall() { return wall; }

/**
 * This returns the current array of hidden objects.  The hidden objects
 * are used to allow things to not actually be in the room description
 * but be able to be manipulated by commands.
 * @see add_hidden_object()
 * @see remove_hidden_object()
 * @return the array of hidden objects
 */
object *query_hidden_objects() { return hidden_objects + ({ }); }

/**
 * This puts a hidden object into a room. A hidden object is an object that
 * exists in the room as far as all the find_match calls go. So, for look at's
 * and so on, but does not actually exist in the room so it does not show up
 * in the inventory when the player does a look. This is the method used for
 * putting signs and doors into rooms, that actually have shorts and you can
 * do things to, but do not show up in the inventory. The function init is also
 * called on these objects when init is called in the room. The only thing you
 * cannot put in your init function is an add_action. You can however define
 * up bunches of add_commands...
 * <p>
 * If this sounds complicated. Think of it as an object that IS in the room, but
 * you cannot see it. 
 * <p>
 * A word of warning here, the init() function will *not* be called on all
 * the players when the object is added as hidden.  This means that the
 * commands on it will not be available until the player re-enters the room.
 * You could get around this by moving everyone out of the room and
 * then back in again.
 * @example
 * #include <room.h>
 * sign = clone_object(PATH + SIGN);
 * add_hidden_object(sign);
 * @example
 * // Add a hidden object that has actions we want players to be able to
 * // use.
 * add_hidden_object(fluffy_container);
 * players = filter(all_inventory(), (: living($1) :));
 * players->move(ROOM_VOID);
 * // This forces init() to be recalled.  (This is realtivatively icky
 * // way of doing it, but the driver does not give us many alternatives).
 * players->move(this_object());
 * @see query_hidden_object()
 * @see remove_hidden_object()
 * @param thing the hidden object to add
 * @return 1 if successful, 0 on a failure
 */
int add_hidden_object( object thing ) {
  if ( !hidden_objects ) {
    hidden_objects = ({ });
  }
  if ( member_array( thing, hidden_objects ) != -1 ) {
    return 0;
  }
  hidden_objects += ({ thing });
  return 1;
} /* add_hidden_object() */

/**
 * This method removes a hidden object.
 * @param thing the hidden object to remove
 * @return 1 on success, 0 on failure
 * @see add_hidden_object()
 * @see query_hidden_objects()
 */
int remove_hidden_object( object thing ) {
  int i;

  i = member_array( thing, hidden_objects );
  if ( i == -1 ) {
    return 0;
  }
  hidden_objects = hidden_objects[0..i - 1] + hidden_objects[i + 1..];
  return 1;
} /* remove_hidden_object() */

/**
 * This method adds an object whose interior bits want to be able to export
 * commands.  You can use this for tables an so on, so that stuff on a table
 * can still be used.
 * @param thing the thing whose inventory bits are to be exported
 */
void add_use_internal_object(object thing) {
   _use_internal_objects |= ({ thing });
} /* add_use_internal_objects() */

/**
 * This method removes an object whose interor bits want to export.
 * @param thing the object to remove
 */
void remove_use_internal_object(object thing) {
   _use_internal_objects -= ({ thing });
} /* remove_use_internal_object() */

/**
 * This method returns all the current use internal objects available.
 * @return the list of use internal objects here
 */
object* query_use_internal_objects() {
   return _use_internal_objects;
} /* query_use_internal_objects() */

/**
 * This returns the information about the door in the specified direction.
 * @param direc the direction to query the door in
 * @param name the name of the exit
 * @return the door control information
 * @see modify_exit()
 */
varargs mixed query_door_control( string direc, string name ) {
   if ( !stringp( direc ) ) {
      return copy( door_control );
   }
   if (name) {
      return door_control[ direc + " " + name ];
   }
   //debug_printf("Doing a door_control empty call %O\n", direc);
   return door_control[ direc ];
} /* query_door_control() */

/**
 * This returns information about the exits in the room.  This is the
 * information set by modify_exit().  The values from this are probably
 * not very useful for normal coding.
 * @see modify_exit()
 * @see query_dest_dir()
 */
varargs mixed *query_dest_other( string direc ) {
  int i;

  if ( !stringp( direc ) ) {
    return copy( dest_other );
  }
  i = member_array( direc, dest_other );
  if ( i == -1 ) {
    return 0;
  }
  return copy( dest_other[ i + 1 ] );
} /* query_dest_other() */

/**
 * Returns an array containing just the destinations and directions used to
 * get there. This is useful for monster or whatever that you want to scan a
 * room for exits to leave out of. The array is of the format. ({ direction1,
 * destination1, direction2, destination2, ... })
 * <p>
 * The thing passed in is used as the basis for the relative directions
 * if it is an object.  If it is not an object then this is ignored
 * altogether.
 * @see query_dest_other()
 * @see add_exit()
 * @param thing used to get the relative directions according to thing
 * @return the array of direction, destination pairs
 */
varargs string *query_dest_dir( object thing ) {
  int i;
  string *ret;
  
  ret = ({ });
  for ( i = sizeof( dest_other ) - 2; i > -1; i -= 2 ) {
    if ( !dest_other[ i + 1 ][ ROOM_REL ] || !objectp( thing ) ) {
      ret += ({ dest_other[ i ], dest_other[ i + 1 ][ ROOM_DEST ] });
    } else {
      ret += ({ (string)thing->find_rel( dest_other[ i ] ),
                  dest_other[ i + 1 ][ ROOM_DEST ] });
    }
  }
  return ret;
} /* query_dest_dir() */

/**
 * This method just returns all the directions available to leave from
 * the room.
 * <p>
 * The thing passed in is used as the basis for the relative directions
 * if it is an object.  If it is not an object then this is ignored
 * altogether.
 * <p>
 * <b>Strawberries</b>
 * <p>
 * Starting from a above,<br>
 * Working slowly down under.<br>
 * Sliding up the sides<br>
 * Eating a meal, fresh cream and syrup.<br>
 * <p>
 * Round and round, and round again<br>
 * Grining micheviously<br>
 * One tongue at play<br>
 * Firm and hard, fresh strawberries today.
 *
 * @see query_dest_other()
 * @see add_exit()
 * @param thing used to get the relative directions according to thing
 * @return the array of directions
 */
varargs string *query_direc( object thing ) {
  int i;
  string *ret;
  
  ret = ({ });
  for ( i = sizeof( dest_other ) - 2; i > -1; i -= 2 ) {
    if ( !dest_other[ i + 1 ][ ROOM_REL ] || !objectp( thing ) ) {
      ret += ({ dest_other[ i ] });
    } else {
      ret += ({ (string)thing->find_rel( dest_other[ i ] ) });
    }
  }
  return ret;
} /* query_direc() */

/**
 * This method returns the destination room for an exit.
 * @param exit the exit name
 * @return the path of the destination room, or ROOM_VOID on error
 * @see query_dest_dir()
 * @example
 * #include <room.h>
 * string dest;
 *
 * dest = room->query_destination("south");
 * if (dest == ROOM_VOID) {
 *    do_error();
 * } else {
 *    do_move("south");
 * }
 */
string query_destination( string exit ) {
   int i;

   i = member_array( exit, dest_other );
   if ( ( i < 0 ) && objectp( this_player() ) )
      i = member_array( (string)this_player()->reorient_rel( exit ),
            dest_other );
   if ( i < 0 )
      return ROOM_VOID;
   return dest_other[ i + 1 ][ ROOM_DEST ];
} /* query_destination() */

/** @ignore yes */
int test_add( object thing, int flag ) { return 1; }

/** @ignore yes */
int test_remove( object thing, int flag, mixed dest ) { return 1; }

/** @ignore yes */
int add_weight( int number ) { return 1; }

/** @ignore yes */
int query_no_writing() { return 1; }

/** @ignore yes */
int query_decay() { return 10; }

/**
 * This method returns whether or not it is daytime.  The value is
 * automatically updated whenever anyone enters the room and so is more
 * efficient than checking with the weather handler.
 *
 * @example
 * void init() {
 *   ::init();
 *   if(is_day()) {
 *     setup_daytime_stuff();
 *   } else {
 *     setup_nighttime_stuff();
 *   }
 * }
 * @return 1 for day, 0 for night.
 */
int query_day() { return is_day; }

/**
 * This method sets the default attack speed for the room.
 * This defaults to 15.
 * @return the default attack speed
 */
int attack_speed() { return 15; }

/**
 * This is the message to print instead of the room description when the
 * room is dark.  It defaults to the message "It's dark in here isn't it?".
 * @return the dark message
 * @see set_dark_mess()
 * @see long()
 * @see query_bright_mess()
 */
string query_dark_mess() {
  mixed dark_mess;

  if ( !stringp( dark_mess = query_property( "dark mess" ) ) ) {
    return "It's dark here, isn't it?";
  }
  return dark_mess;
} /* query_dark_mess() */

/**
 * This method sets the dark message associated with the room.
 * @param word the new dark message
 * @see query_dark_mess()
 * @see long()
 */
void set_dark_mess( string word ) {
    add_property( "dark mess", word );
} /* set_dark_mess() */

/**
 * This method returns the message to use when it is too bright to see in
 * the room.  It defaults to: "It's too bright to see anything!".
 * @return the message to print when it is too bright
 * @see query_dark_mess()
 * @see long()
 * @see set_bright_mess()
 */
string query_bright_mess() {
  mixed bright_mess;
 
  if ( !stringp( bright_mess = query_property( "bright mess" ) ) ) {
    return "It's too bright to see anything!";
  }
  return bright_mess;
} /* query_bright_mess() */

/**
 * This method sets the bright message associated with the room.
 * @param word the new bright message
 * @see query_bright_mess()
 * @see long()
 */
void set_bright_mess( string word ) { add_property( "bright mess", word ); }

/**
 * This method queries the size of the room.  The default size of a room
 * is 10x10x10.  A room can be any rectangular size, this method will return
 * an array of three elements if the room is a non-cube.  If it returns
 * a single number then the room is assumed to be cubic.
 * <p>
 * ({ north-south size, east-west size, up-down size })
 * <p>
 * The sizes are all radii's so they are half the actual width of the room.
 * @return the size of the room
 * @see set_room_size()
 * @see query_room_size_array()
 */
mixed query_room_size() {
   mixed room_size;

   room_size = query_property( "room size" );
   if ( !room_size ) {
      return 10;
   }
   return room_size;
} /* query_room_size() */

/**
 * This method returns the size of the room as a three element array always.
 * <p>
 * ({ north-south size, east-west size, up-down size })
 * <p>
 * The sizes are all radii's so they are half the actual width of the room.
 * @return the size of the room as a three element array
 * @see query_room_size()
 * @see set_room_size()
 */
int *query_room_size_array() {
   mixed room_size;

   room_size = query_room_size();
   if ( pointerp( room_size ) ) {
      return room_size;
   }
   return ({ room_size, room_size, room_size });
} /* query_room_size_array() */

/**
 * This method sets the rooms principle radii.  If the parameter isa single
 * number then the room is assumed to be cubic and dimension applies in
 * all directions.  If the input is a three element array then the elements
 * apply to all the directions.<br>
 * ({ north-south size, east-west size, up-down size })
 * <p>
 * The sizes are all radii's so they are half the actual width of the room.
 * @param number the new size of the room
 * @see query_room_size()
 * @see query_room_size_array()
 */
void set_room_size( mixed number ) {
   if ( intp( number ) ) {
      add_property( "room size", number );
      return;
   }
   if ( pointerp( number ) ) {
      if ( sizeof( number ) == 3 ) {
         add_property( "room size", number );
         return;
      }
   }
   write( "Room size must be an integer or an array of three integers.\n" );
} /* set_room_size() */

/** @ignore yes */
int id( string word ) { return 0; }

string expand_alias( string word ) {
   int i;

   if ( !aliases || !sizeof( aliases ) ) {
      return word;
   }
   i = member_array( word, aliases );
   if ( i == -1 ) {
      return word;
   }
   if ( i % 2 ) {
      return aliases[ i - 1 ];
   }
   return word;
} /* expand_alias() */

/**
 * This method returns the exit string used when in brief mode.
 * @return the brief exit string
 * @see calc_exit_string()
 */
string calc_short_exit_string() {
   int i, add;
   string *words;
   int pos;
   string tmp_dir;
   mixed tmp;

   words = ({ });
   for ( i = 0; i < sizeof( dest_other ); i += 2 ) {
      tmp = dest_other[ i + 1 ][ ROOM_OBV ];
      if ( !tmp ) {
         continue;
      }
      if ( intp( tmp ) && tmp ) {
         add = 1;
      }
      if ( stringp( tmp ) ) {
         add = (int)call_other( this_object(), tmp, dest_other[ i ] );
      }
      if ( pointerp( tmp ) ) {
         add = (int)call_other( tmp[ 0 ], tmp[ 1 ], dest_other[ i ] );
      }
      if ( add ) {
         if ( tmp = SHORTEN[ dest_other[ i ] ] ) { // is there a short form?
            if (dest_other[i+1][ROOM_REL]) {// is the exit relative
               words += ({ "$r$-"+tmp+"$r$" });
            } else {
               words += ({ tmp });
            }
         } else {                // no short form
            if (dest_other[i+1][ROOM_REL]) { // is the exit relative?
               words += ({ "$r$-"+dest_other[ i ]+"$r$" });
            } else {
               // If there is two words, check and see if the second can
               // be shortened
               pos = strsrch(dest_other[i], " ");
               if (pos != -1) {
                  tmp_dir = dest_other[i][pos + 1..];
                  tmp = SHORTEN[tmp_dir];
                  if (tmp) {
                     tmp_dir = tmp;
                  }
                  words += ({ dest_other[i][0..pos] + tmp_dir });
               } else {
                  words += ({ dest_other[i] });
               }
            }
         }
      }
   }
   if(!sizeof(words)) {
     return " [none]";
   }
   return " ["+ implode( words, "," ) +"]";
} /* calc_short_exit_string() */

/**
 * This method returns the short exit string.  The short exit string is the
 * string used in 'brief' mode of a players look.
 * @return the short exit string
 * @see calc_short_exit_string()
 * @see query_exit_string()
 */
string query_short_exit_string() {
   string tmp;
  
   if(short_exit) {
      return this_player()->colour_event("exits", "%^GREEN%^") +
     short_exit + "%^RESET%^";
   }
   
   tmp = calc_short_exit_string();
   if (!query_property("no exit cache")) {
      short_exit = tmp;
   }
   return this_player()->colour_event("exits", "%^GREEN%^") +
     tmp + "%^RESET%^";
} /* query_short_exit_string() */

/**
 * @ignore yes
 */
string enchant_string() {
   string words;
   
   words = (string)this_object()->query_property( "octarine_mess" );
   if ( words ) {
      return words +"\n";
   }
   switch ( query_enchant() ) {
      case 0 .. 49 :
         return "";
      case 50 .. 149 :
         return "There is the residual taste of magic in this place.\n";
      case 150 .. 299 :
         return "This place has seen some use of magic.\n";
      case 300 .. 499 :
         return "A considerable amount of magic has been used here.\n";
      case 500 .. 749 :
         return "A very large quantity of magic has been manipulated here.\n";
      case 750 .. 1000 :
         return "You can feel the Dungeon Dimensions trying to push in.\n";
      case 1001 .. 1500 :
         return "Little sparks flash in from the Dungeon Dimensions.\n";
      case 1501 .. 2000 :
         return "Apparations of things with lots of tentacles seem to be "
                "on the edge of your vision.\n";
      default :
         return "So much magic has been expended here that the area is in "+
               "danger of dumping itself into the Dungeon Dimensions.\n";
   }
} /* enchant_string() */

/** @ignore yes */
string long( string word, int dark ) {
   string ret;

   if ( !long_exit ) {
      calc_long_exit();
   }
   if ( dark ) {
      if ( dark < 0 ) {
         ret = mxp_tag("RoomDesc", this_object()->query_dark_mess(), this_player()) +"\n";
      } else {
         ret = mxp_tag("RoomDesc", this_object()->query_bright_mess(), this_player()) +"\n";
      }
      if ( query_property( "location" ) == "outside" ) {
         ret += "$weather$";
      }
      if ( ( dark == 1 ) || ( dark == -1 ) ) {
         ret = "$C$"+ mxp_tag("RoomName", a_short(), this_player()) +".  "+ ret +
           this_player()->colour_event("exits", "%^GREEN%^") +
           mxp_tag("RoomExits", mxp_choice(long_exit, long_exit_mxp, this_player()), this_player())
           +"%^RESET%^\n";
         if ( query_contents( "" ) != "" ) {
            ret += this_player()->colour_event("inventory", "") + "Some objects you can't make out are here.%^RESET%^\n";
         }
      }
   } else {
      if ( query_property( "location" ) == "outside" ) {
         ret = "$long$";
      } else {
         ret = query_long();
      }

      if(!ret) {
         ret = "Erk, this room seems to be broken.\n";
      }
      
      word = calc_extra_look();
      if ( stringp( word ) && ( word != "" ) ) {
         ret += word;
      }
      if ( this_player()->query_see_octarine() ) {
         ret += enchant_string();
      }
      if ( query_property( "location" ) == "outside" ) {
         ret += "$weather$";
      }
      ret = mxp_tag("RoomDesc", ret, this_player());
      ret += this_player()->colour_event("exits", "%^GREEN%^") +
         mxp_tag("RoomExits", mxp_choice(long_exit, long_exit_mxp, this_player()), this_player())
         +"%^RESET%^\n"+ query_contents( "" );
   }
   if ( query_property( "no exit cache" ) )  {
      long_exit = 0;
   }
   return mxp_secure(this_player()) + ret + mxp_open(this_player());
} /* long() */

/** @ignore yes */
string pretty_short( object thing ) {
   int dark;

   if ( thing ) {
      dark = (int)thing->check_dark( (int)this_object()->query_light() );
   }
   return ::short( dark );
} /* pretty_short() */

/**
 * This method returns the visibility in this room.  The visibility should
 * be a percentage which represents the percentage of the maximum visibility
 * in the room.
 * @return the visbility
 */
int query_visibility() {
   return 100;
}

/**
 * This method is designed to allow a little more flexability in which rooms
 * can be used for co-ordinates.  It should be overridden by higher up
 * rooms to do different checks.
 * @return 1 if it can be used, 0 if not
 */
int can_use_for_co_ords(string other) {
   return 1;
}

/**
 * This method calculates the co-ordinates of this room.  The co-ordinates
 * are based on the surrounding rooms co-ordinates, if one of those rooms
 * are loaded.  The function 'query_do_not_use_coords' is called on the
 * rooms to see if the co-ordinates are allowed to leak out further or
 * not.
 * @see query_co_ord()
 * @see modify_exit()
 */
void calc_co_ord() {
  int i, j, k, shift, *delta, *other_co_ord;
  string other;
  mixed* std_orders = STD_ORDERS;
   
  for ( i = sizeof( dest_other ) - 2; ( i > -1 ) && !co_ord; i -= 2 ) {
    /* if destination isn't loaded, skip it */
    other = dest_other[ i + 1 ][ ROOM_DEST ];
    if ( !find_object( other ) ) {
       continue;
    }
    if ( other->query_do_not_use_coords()) {
       continue;
    }
    // if it is in a /w directory, ignore it.
    if (stringp(other) && other[0..2] == "/w/") {
       continue;
    }
    /* if destination has no coordinates, skip it */
    other_co_ord = (int *)other->query_co_ord();
    if ( !other_co_ord ) {
      continue;
    }

    // A co-ordinate of 0, 0, 0 must be wrong...
    if (!other_co_ord[0] && !other_co_ord[1] && !other_co_ord[2]) {
      continue;
    }

    // Do a special check to see if there any other overrides needed.
    if (!can_use_for_co_ords(other)) {
       continue;
    }

    /* if exit had a delta defined, use that */
    j = -1;
    if ( delta = dest_other[ i + 1 ][ ROOM_DELTA ] ) {
      co_ord = copy( other_co_ord );
      if (pointerp(delta)) {
        k = 3;
        while ( k-- ) {
          /*
           * it's -= to make delta here the offset from this
           * room to the destination 
           */
          co_ord[ k ] -= delta[ k ];
        }
        continue;
      } else {
        j = member_array(delta, std_orders);
      }
    }

    /* if exit isn't a direction, skip it */
    if (j == -1) {
      j = member_array( dest_other[ i ], std_orders );
      if ( j == -1 ) {
        continue;
      }
    }

    co_ord = copy( other_co_ord );
    delta = query_room_size_array() + (int *)other->query_room_size_array();
    for ( k = 0; k < 3; k++ ) {
      co_ord[ k ] += std_orders[ j + 1 ][ k ] *
        ( delta[ k ] + delta[ k + 3 ] );
    }
    if ( ( j < 16 ) && dest_other[ i + 1 ][ ROOM_GRADE ] ) {
      /* one of the lateral directions */
      switch ( j ) {
      case 0 .. 1 :
        shift = delta[ 0 ] + delta[ 3 ];
        break;
      case 2 .. 3 :
        shift = delta[ 1 ] + delta[ 4 ];
        break;
      default :
        shift = delta[ 0 ] + delta[ 1 ] + delta[ 3 ] + delta[ 4 ];
      }
      co_ord[ 2 ] -= ( dest_other[ i + 1 ][ ROOM_GRADE ] * shift ) / 100;
      }
    co_ord_calculated = 1;
  }
} /* calc_co_ord() */

/**
 * This method calculates all the exit strings to be used for this room.
 */
void calc_exits() {
   int i, j;
   string exit, word, *tmp_al;

   _exits = ({ });
   for ( i = sizeof( dest_other ) - 2; i > -1; i -= 2 ) {
      exit = dest_other[ i ];
      if ( member_array( exit, _exits ) == -1 ) {
         _exits += ({ exit });
         word = SHORTEN[ exit ];
         if ( stringp( word ) ) {
            _exits += ({ word });
         }
      }
      tmp_al = aliases;
      j = member_array( exit, tmp_al );
      while ( j != -1 ) {
         if ( j % 2 ) {
            j--;
         } else {
            word = tmp_al[ j + 1 ];
            if ( member_array( word, _exits ) == -1 ) {
               _exits += ({ word });
            }
         }
         tmp_al = delete( tmp_al, j, 2 );
         j = member_array( exit, tmp_al );
      }
   }
} /* calc_exits() */

/** @ignore yes */
void init() {
  object ob;
  int i;
  
  /* This is some experimental XP stuff for exploration.
   * It gives some XP to someone who enters a room under the following
   * conditions:
   * 1. The room is freshly loaded but the mud has been up at least 1/2 
   *    an hour.
   * 2. The room has been loaded but hasn't been visited for at least 15
   *    minutes.
   */
  if(this_player() && interactive(this_player())) {
    if(((!last_visited && uptime() > 1800 + random(3600)) ||
      (last_visited && (time() - last_visited > random(900) + 900)))) {
      if(clonep(this_object()))
        this_player()->adjust_xp(random(random(50)), 0);
      else
        this_player()->adjust_xp(random(random(500)), 0);
    }
    last_visited = time();
  }

  // Has the day/night changed and do we care?
  if(is_day != -1 && ((WEATHER_HANDLER->query_day() > 0) != is_day)) {
    is_day = (1 - is_day);
    
    // Do longs;
    if(variablelongs && strlen(variablelongs[is_day]))
      set_long(variablelongs[is_day]);
    
    // Do items.
    if(variableitems) {
      for(i=0; i<sizeof(variableitems[1-is_day]); i += 2)
        remove_item(variableitems[1-is_day][i]);
      
      for(i=0; i<sizeof(variableitems[is_day]); i += 2)
        add_item(variableitems[is_day][i], variableitems[is_day][i+1]);
    }
    
    // Do chats.
    setup_room_chat();
  }

  if(chatter) {
    chatter->check_chat();
  }

  if(sitchanger) {
    sitchanger->check_situations();
  }

  if(!sizeof(_exits)) {
    calc_exits();
  }

  if(!pointerp(co_ord)) {
    this_object()->calc_co_ord();
  }

  foreach (ob in hidden_objects) {
    if ( ob && objectp( ob ) ) {
      ob->init();
    } else {
      hidden_objects -= ({ 0, ob });
    }
  }

  if (this_player() && userp(this_player())) {
    foreach (ob in _use_internal_objects) {
      if (ob && objectp(ob)) {
        _use_internal_objects->find_inv_match("all", this_player())->init();
      } else {
        _use_internal_objects -= ({ 0, ob });
      }
    }
  }

  if(item) {
    item->init();
  }
}

/**
 * This method returns the set of move zones for this room.  This is used
 * by npcs to see which rooms they are allowed to move into.
 * @see add_zone()
 * @see /obj/monster->add_move_zone()
 */
string *query_zones() {
  string *zones;

  zones = query_property( "room zone" );
  if ( !zones ) {
    return ({ "nowhere" });
  }
  return zones + ({ });
} /* query_zones() */

/**
 * This method adds a move zone into the current list of movement zones
 * for the room.  The move zones are used by npcs to see which rooms they
 * are allowed to move into.
 * @see set_zone()
 * @see query_zones()
 * @see /obj/monster->add_move_zone()
 */
void add_zone(string zone) {
   string *zones;

   zones = query_property( "room zone" );
   if ( !zones ) {
      zones = ({ zone });
   } else {
      zones += ({ zone });
   }
   add_property( "room zone", zones );
} /* add_zone() */

/**
 * This method removes a move zone from the current list of movement zones
 * for the room.  The move zones are used by npcs to see which rooms they
 * are allowed to move into.
 * @see add_zone()
 * @see query_zones()
 * @see /obj/monster->add_move_zone()
 */
void remove_zone(string zone) {
   string *zones;

   zones = query_property( "room zone" );
   if ( !zones ) {
      return;
   } else {
      zones -= ({ zone });
   }
   add_property( "room zone", zones );
} /* add_zone() */


/**
 * This method adds a move zone into the current list of zones.
 * This method is depreciated, add_zone should be used instead.
 * @see add_zone()
 * @see query_zones()
 */
void set_zone( string zone ) {
   add_zone(zone);
} /* set_zone() */

/**
 * This method determines if there is an exit in the specified direction.
 * @param direc the exit to test for
 * @return 1 if it exists, 0 if it does now
 */
int query_exit( string direc ) {
  return ( member_array( direc, dest_other ) != -1 );
} /* query_exit() */

/**
 * This method adds an exit to the room.   The direction is the direction in
 * which the exit should go.  This is something like "north" or "enter
 * gate".  The destination field is where the player will go when they
 * enter the exit.  The type is a set type that sets a whole bunch of
 * defaults for the room.  The destination can be either a strong
 * or an object.
 * <p>
 * The types are controlled by /obj/handlers/room_handler.c and the current
 * types and what this all means are:
 * <dl>
 * <dd>
 * <dl>
 * <dt>road
 * <dd>Wide road.
 * <dt>path
 * <dd>Narrower path
 * <dt>door
 * <dd>And exit with a door.  Defaults to closed but not locked.
 * <dt>secret
 * <dd>A secret door.  Defaults to closed but not locked.
 * <dt>corridor
 * <dd>A corridor (bing).
 * <dt>hidden
 * <dd>A hidden exit without a door
 * </dl>
 * </dl>
 * <p>
 * The room aliases are used to expand things for exits.  However they
 * don't expand the entire exit name.  They expand it in bits.  For
 * instance, if the exit was "enter live eel", you could
 * add_alias("eel", "live eel"); and add_alias("bing", "enter"); to
 * get both of the bits of the exit.  So "bing eel", "enter eel",
 * "bing live eel" etc would work.
 * @example
 * add_exit("north", PATH + "market2", "road");
 * add_alias("eel", "live eel");
 * add_exit("enter live eel", PATH + "live_eel", "secret");
 * @example
 * object fluffy_room;
 *
 * fluffy_room = clone_object(PATH + "fluffy_room");
 * add_exit("north", fluffy_room, "road");
 * @see modify_exit()
 * @see query_dest_dir()
 * @see remove_exit()
 * @see /obj/handlers/room_handler
 */
int add_exit( string direc, mixed dest, string type ) {
   mixed *stuff;

   if ( !dest_other ) dest_other = ({ });
   if ( member_array( direc, dest_other ) != -1 ) return 0;
   if ( objectp( dest ) )
      dest = file_name( dest );
   if ( dest[ 0 .. 0 ] != "/" )
      dest = "/"+ dest;
   stuff = ({ dest }) + (mixed *)ROOM_HANDLER->query_exit_type( type, direc );
   dest_other += ({ direc, stuff });
   stuff = ROOM_HANDLER->query_door_type( type, direc,
                                                         dest );
   if ( stuff ) {
      door_control[ direc ] = clone_object( DOOR_OBJECT );
      door_control[ direc ]->setup_door( direc, this_object(), dest, stuff,
                                         type);
      hidden_objects += ({ door_control[ direc ] });
      if (door_control[ direc ]->query_door_name()) {
         door_control[ dest + " " + door_control[ direc ]->query_door_name()] = direc;
      } else {
         door_control[ dest ] = direc;
      }
   }
   if ( find_call_out( "calc_exits" ) == -1 ) {
      call_out( "calc_exits", 1 );
   }
   long_exit = 0;
   short_exit = 0;
   return 1;
} /* add_exit() */

/**
 * This method modifies the parameters for the exit.  See the docs in
 * /doc/new/room/modify_exit for more complete information.
 */
int modify_exit( mixed direc, mixed *data ) {
   int i, j, k;
   
   if(pointerp(direc)) {
     for(k = 0; k < sizeof(direc); k++) {
       modify_exit(direc[k], data);
     }
     return 0;
   }
   if ( ( i = member_array( direc, dest_other ) ) == -1 ) {
     return 0;
   }
   for ( j = 0; j < sizeof( data ); j+= 2 ) {
     switch ( lower_case( data[ j ] ) ) {
     case "message" :
       dest_other[ i + 1 ][ ROOM_EXIT ] = data[ j + 1 ];
       break;
     case "exit mess" :
     case "exit_mess" :
       dest_other[ i + 1 ][ ROOM_EXIT ] = data[ j + 1 ];
       break;
     case "move mess" :
       dest_other[ i + 1 ][ ROOM_MESS ] = data[ j + 1 ];
       break;
     case "linker mess" :
       dest_other[ i + 1 ][ ROOM_LINK_MESS ] = data[ j + 1 ];
       break;
     case "obvious" :
       dest_other[ i + 1 ][ ROOM_OBV ] = data[ j + 1 ];
       if ( !intp( data[ j + 1 ] ) )
         add_property( "no exit cache", 1 );
       long_exit = 0;
       short_exit = 0;
       break;
     case "function" :
       dest_other[ i + 1 ][ ROOM_FUNC ] = data[ j + 1 ];
       break;
     case "size" :
       dest_other[ i + 1 ][ ROOM_SIZE ] = data[ j + 1 ];
       break;
     case "upgrade" :
       dest_other[ i + 1 ][ ROOM_GRADE ] = data[ j + 1 ];
       break;
     case "downgrade" :
       dest_other[ i + 1 ][ ROOM_GRADE ] = -data[ j + 1 ];
       break;
     case "enter" :
       dest_other[ i + 1 ][ ROOM_ENTER ] = data[ j + 1 ];
       break;
     case "enter mess" :
     case "enter_mess" :
       if ( sizeof( dest_other[ i + 1 ][ ROOM_ENTER ] ) == 2 )
         dest_other[ i + 1 ][ ROOM_ENTER ] = replace( data[ j + 1 ],
           "$F", dest_other[ i + 1 ][ ROOM_ENTER ][ 1 ] );
       else
         dest_other[ i + 1 ][ ROOM_ENTER ] = data[ j + 1 ];
       break;
     case "dest" :
       dest_other[ i + 1 ][ ROOM_DEST ] = data[ j + 1 ];
       if ( objectp( door_control[ direc ] ) ) {
         map_delete(door_control, door_control[ direc ]->query_dest() + " " + door_control[ direc ]->query_door_name());
         door_control[ direc ]->set_dest( data[ j + 1 ] );
         door_control[ data[ j + 1 ] ] = direc;
         if (door_control[ direc ]->query_door_name()) {
            door_control[ data[ j + 1 ] + " " + door_control[ direc ]->query_door_name()] = direc;
         }
       }
       break;
     case "door name" :
       if ( objectp( door_control[ direc ] ) ) {
          map_delete(door_control, door_control[ direc ]->query_dest() + " " + door_control[ direc ]->query_door_name());
          door_control[ direc ]->set_door_name( data[ j + 1 ] );
          door_control[ door_control[ direc ]->query_dest() + " " + data[ j + 1 ]] = direc;
       }
       break;
     case "relative" :
       dest_other[ i + 1 ][ ROOM_REL ] = data[ j + 1 ];
       break;
     case "lock owner" :
       if ( objectp( door_control[ direc ] ) ) {
          door_control[ direc ]->set_lock_owner( data[ j + 1 ] );
       }
       break;
     case "look" :
       dest_other[ i + 1][ ROOM_LOOK ] = data[ j + 1 ];
       break;
     case "look func" :
       dest_other[ i + 1][ ROOM_LOOK_FUNC ] = data[ j + 1 ];
       break;
     case "no map" :
       dest_other[ i + 1][ ROOM_NO_MAP ] = data[ j + 1 ];
       break;
     case "delta" :
       dest_other[ i + 1][ ROOM_DELTA ] = data[ j + 1 ];
       break;
     case "closed" :
       if ( objectp( door_control[ direc ] ) ) {
         if ( data[j+1]) {
            door_control[ direc ]->set_closed();
         } else {
            door_control[ direc ]->set_open();
         }
       }
       break;
     case "open" :
       if ( objectp( door_control[ direc ] ) ) {
         if ( data[j+1]) {
            door_control[ direc ]->set_open();
         } else {
            door_control[ direc ]->set_closed();
         }
       }
       break;
     case "transparent" :
       if ( objectp( door_control[ direc ] ) ) {
         data[j+1] ? door_control[ direc ]->set_transparent() :
           door_control[ direc ]->reset_transparent();
       }
       break;
     case "stuck" :
       if ( objectp( door_control[ direc ] ) ) {
         door_control[ direc ]->set_stuck( data[ j + 1 ] );
       }
       break;
     case "locked" :
       if ( objectp( door_control[ direc ] ) ) {
         if(data[j+1]) {
           door_control[ direc ]->set_closed();
           door_control[ direc ]->set_locked();
         } else
           door_control[ direc ]->set_unlocked();
       }
       break;
     case "unlocked" :
       if ( objectp( door_control[ direc ] ) ) {
         data[j+1] ? door_control[ direc ]->set_unlocked() :
           door_control[ direc ]->set_locked();
       }
       break;
     case "autolock":
       if ( objectp( door_control [direc ] ) ) {
         door_control[ direc ]->set_autolock( data[ j + 1 ] );
       }
       break;
     case "key" :
       if ( objectp( door_control[ direc ] ) ) {
         door_control[ direc ]->set_key( data[ j + 1 ] );
       }
       break;
     case "other" :
       if ( objectp( door_control[ direc ] ) ) {
         door_control[ direc ]->set_other_id( data[ j + 1 ] );
       }
       break;
     case "difficulty" :
       if ( objectp( door_control[ direc ] ) ) {
         door_control[ direc ]->set_difficulty( data[ j + 1 ] );
       }
       break;
     case "door long" :
       if ( objectp( door_control[ direc ] ) ) {
         door_control[ direc ]->set_long( data[ j + 1 ] );
       }
       break;
     case "open/close func" :
       if ( objectp( door_control[ direc ] ) ) {
         door_control[direc]->set_open_trap(data[j+1][0], data[j+1][1]);
       }
       break;
     case "lock/unlock func" :
       if ( objectp( door_control[ direc ] ) ) {
         door_control[direc]->set_lock_trap(data[j+1][0], data[j+1][1]);
       }
       break;
     case "door short" :
       if ( objectp( door_control[ direc ] ) ) {
         door_control[ direc ]->set_short( data[ j + 1 ] );
       }
       break;
     case "double doors" :
       if ( objectp( door_control[ direc ] ) ) {
         door_control[ direc ]->set_how_many( data[ j + 1 ] );
       }
       break;
     case "one way" :
       if ( objectp( door_control[ direc ] ) ) {
         door_control[ direc ]->set_one_way( data[ j + 1 ] );
       }
       break;
     case "secret" :
       if ( objectp( door_control[ direc ] ) ) {
         door_control[ direc ]->remove_hide_invis( "secret" );
         if ( data[ j + 1 ] > 0 ) {
           door_control[ direc ]->add_hide_invis( "secret", 0,
                                                  data[ j + 1 ], 0 );
         }
       }
       break;
     case "undoor" :
       if ( objectp( door_control[ direc ] ) ) {
         map_delete( door_control, dest_other[ i + 1 ][ ROOM_DEST ] + " " +
                                   door_control[ direc ]->query_door_name() );
         door_control[ direc ]->go_away();
         hidden_objects -= ({ door_control[ direc ] });
         map_delete( door_control, direc );
         map_delete( door_control, dest_other[ i + 1 ][ ROOM_DEST ] );
         /* Hope that something takes care of the other side. */
       }
       break;
     case "no follow" :
       if (data[j + 1]) {
         dest_other[ i + 1 ][ROOM_NPC_STOP] = 1;
       } else {
         dest_other[ i + 1 ][ROOM_NPC_STOP] = 0;
       }
       break;
     }
   }
   return 1;
} /* modify_exit() */

/**
 * This method removes the specified exit from the room.
 * @see add_exit()
 * @see modify_exit()
 */
int remove_exit( string direc ) {
  int i;

  if ( !dest_other ) {
    dest_other = ({ });
    return 0;
  }
  i = member_array( direc, dest_other );
  if ( i == -1 )
    return 0;
  if ( door_control[ direc ] ) {
    door_control[ direc ]->dest_me();
    hidden_objects -= ({ door_control[ direc ] });
    door_control = m_delete( door_control, direc );
    door_control = m_delete( door_control, dest_other[ i + 1 ][ ROOM_DEST ] );
  }
  dest_other = delete( dest_other, i, 2 );
  if ( find_call_out( "calc_exits" ) == -1 )
    call_out( "calc_exits", 1 );
   long_exit = 0;
   short_exit = 0;
  return 1;
} /* remove_exit() */

/**
 * This method checks to see if the door is open.
 * @param direc the direction of the door
 * @return -1 on an error, 0 for closed, 1 for open
 * @see modify_exit()
 */
int query_door_open( string direc ) {
  if ( !objectp( door_control[ direc ] ) ) {
    return -1;
  }
  return (int)door_control[ direc ]->query_open();
} /* query_door_open() */

/**
 * This method checks to see if the exit is a relative one.
 * @param direc the direction to check
 * @see modify_exit()
 */
int query_relative( string direc ) {
   int i;

   i = member_array( direc, dest_other );
   if ( i == -1 ) {
      return 0;
   }
   return dest_other[ i + 1 ][ ROOM_REL ];
} /* query_relative() */

string query_look( string direc ) {
   int i;

   i = member_array( direc, dest_other );
   if ( i == -1 )
      return 0;
   if ( !dest_other[ i + 1 ] )
      return 0;
   return (string)evaluate(dest_other[ i + 1 ][ ROOM_LOOK ]);
} /* query_look() */

mixed *query_look_func( string direc ) {
  int i;
  if ( ( i = member_array( direc, dest_other ) ) == -1 ) return 0;
  if( !dest_other[ i + 1 ] ) return 0;
  return dest_other[ i + 1 ][ ROOM_LOOK_FUNC ];
}

/**
 * This method returns the size of the exit.  This is used to check to make
 * sure that people can enter it.
 * @param direc the direction of the exit to check
 * @return the size of the exit
 * @see modify_exit()
 */
int query_size( string direc ) {
  int i;
  if ( ( i = member_array( direc, dest_other ) ) == -1 ) return 0;
  if ( stringp( dest_other[ i + 1 ][ ROOM_SIZE ] ) )
    return (int)call_other( this_object(), dest_other[ i + 1 ][ ROOM_SIZE ] );
  if ( pointerp( dest_other[ i + 1 ][ ROOM_SIZE ] ) )
    return (int)call_other( dest_other[ i + 1 ][ ROOM_SIZE ][ 0 ],
        dest_other[ i + 1 ][ ROOM_SIZE ][ 1 ] );
  return dest_other[ i + 1 ][ ROOM_SIZE ];
} /* query_size() */
 
/** @ignore yes */
void event_magic( object channel, int amount, object caster ) {
   add_enchant( amount / 5 );
} /* event_magic() */

/** @ignore yes */
void event_theft( object command_ob, object thief, object victim,
                  object *stolen ) {

  if(thief->query_caster())
    thief = find_player(thief->query_caster());
  else if(thief->query_owner())
    thief = thief->query_owner();
  
  log_file( "THEFT", "%s: %s stole %s from %s in %s\n",
            ctime( time() )[4..18], (string)thief->query_short(),
            implode( (string *)stolen->query_short(), ", " ),
            (string)victim->query_short(), file_name() );
  
  if ( stringp( theft_handler )) {
    if( theft_handler != "none" )
      theft_handler->handle_theft( this_object(), command_ob, thief,
                                   victim, stolen );
  } else
    "/obj/handlers/theft_handler"->handle_theft( this_object(), command_ob,
                                                 thief, victim, stolen );
} /* event_theft() */

/** @ignore yes */
int query_last_visited() { return last_visited; }

/**
 * This method adds an item description to a room.  This allows you to
 * set up objects which do not as such exist, but can be looked at for
 * instance.  There should be a lot of these in rooms.  The name of
 * the item can be multiple word, and the plural for it is
 * automagicaly added, unless the no_plural flag is set.  If the name
 * is an array all of the elements in the array respond to the
 * description.
 * <p>
 * If the desc is set to an array, you can use this for handling
 * things like read messages and so on too.  Every second element in
 * the array is the description/text to be printed and the other
 * element is the command upon which the text should be printed.  The
 * special command 'long' is used to set the long description.
 * <p>
 * The special type 'position' is used to allow people to use that
 * item to do positions on, like stand, sit, lie etc.
 * <p>
 * This method also allows you to setup add_command patterns.  If the
 * name after the verb is just a string, then the string will be printed
 * when that verb is used.  If it is just a function pointer then the
 * function will be evaluated and the return result printed.  If it
 * is an array, then the first element must be a function pointer and
 * the second optional element is the pattern to use for that method.
 * Multiple patterns and functions may be specified.
 * @param shorts the short description of the item
 * @param desc the description of the item
 * @param no_plural do not automaticaly add a plural for the item
 * @return 1 if successfully added, 0 if not
 * @example
 * add_item("green pot plant", "It is a nasty green pot plant lurking by "
 *                             "the door.\n");
 * @example
 * add_item(({ "telephone", "red phone" }),
 *          "Sitting in the corner is the red phone, it is staring unhappily "
 *          "into space thinking of cupcakes and better times.\n");
 * @example
 * add_item("small book", ({ "long", "A small red book with dots on the
 *                                   "cover.\n",
 *                           "read", "It says 'Rabbit!' in big letters.\n" }) );
 * @example
 * add_item("green leather couch",
 *          ({ "long", "The green leather couch is wonderful , so comfy!  "
 *                     " So... Comfy!\n",
 *             "position", "the green leather couch" }) );
 * @example
 * add_item("rotating hologram", (: query_current_hologram_string() :));
 * @example
 * add_item("glue stick",
 *          ({ "long", "The glue stick looks sticky, like you could slime "
 *                     "something with it.\n",
 *             "slime", ({ (: do_slime :),
 *                         "<indirect:living> with <direct:object>" }) }) );
 * @see query_item()
 * @see remove_item()
 * @see modify_item()
 */
varargs int add_item( mixed shorts, mixed desc, int no_plural ) {
  if (!desc) {
     // A 0 description is a definate no no.
     printf("Error!  In %O add_item(%O, 0), not added.\n", file_name(),
                                                           shorts);
     return 0;
  }

  if ( !item ) {
     item = clone_object( ITEM_OBJECT );
  }
  item->setup_item( shorts, desc, no_plural );
  return 1;
} /* add_item() */

/**
 * This method will attempt to remove the item defined by the given string.
 * This will remove everything associated with that item, verbs, patterns,
 * everything.
 * @param word the name of the item to remove
 * @return 1 if successful, 0 on a failure
 * @example
 * add_item("frog", "Cute, green and sitting on a lilly pad.  Yes!\n");
 * ...
 * remove_item("frog");
 * @example
 * add_item(({ "big bad chicken", "clucker" }),
 *          "The big bad chicken sits and stares at you.\n");
 * ...
 * remove_item("big bad chicken");
 * @see add_item()
 * @see query_item()
 */
int remove_item( string word ) {
  if ( !item ) {
    return 1;
  }
  return (int)item->remove_item( word );
} /* remove_item() */

/**
 * This method will modify certain bits of the specified item.  This will
 * change only the bits of the pattern that are specified.  If you wish to
 * remove elements a better method would be to remove the item and
 * then readd it.  The format of the new_desc array is the same as in the
 * add_item code.
 * @param word the name of the item to change
 * @param new_desc the bits of the item to change
 * @see remove_item()
 * @see add_item()
 */
int modify_item( string word, mixed new_desc ) {
  if ( !item ) {
    return 0;
  }
  return (int)item->modify_item( word, new_desc );
} /* modify_item() */

/**
 * This method sets up a linkage between the current room and othert
 * rooms.  The linkage broadcasts things like says and enter/exit
 * messages between the rooms.
 * <P>
 * The the dynamic preposition is used when someone enters/exits
 * the room, the static preposition is used when someone says something
 * in the room.  The dynamic proposition defaults to "into" and the
 * static preposition defaults to "in".
 * @param rooms the rooms to link together
 * @param d_prep the dynamic preposition
 * @param s_prep the static preposition
 * @param r_name the name of the room/area
 * @example
 * set_linker( ({ PATH + "room1", PATH + "room2", }),
 *             "into", "in", "fluffy square");
 */
varargs int set_linker( string *rooms, string d_prep, string s_prep,
    string r_name ) {
  if ( linker ) {
    return 0;
  }
  linker = clone_object( LINKER_OBJECT );
  linker->setup_shadow( this_object(), rooms, d_prep, s_prep, r_name );
  return 1;
} /* set_linker() */

int set_terrain( string terrain_name ) {
   if ( terrain ) {
      return 0;
   }
   terrain = clone_object( TERRAIN_OBJECT );
   terrain->setup_shadow( this_object(), terrain_name );
   set_not_replaceable(1);
   return 1;
} /* set_terrain() */

void set_wall( mixed *args ) {
   if ( !wall ) {
      wall = clone_object( WALL_OBJECT );
      wall->setup_shadow( this_object() );
   }
   wall->set_wall( args );
} /* set_wall() */

/**
 * This method sets the default position for the room.  Se the set
 * default position in the living code for a more complete
 * example of this.
 * @param pos the default position
 * @see /ostd/living/living->set_default_position()
 */
void set_default_position(mixed stuff) {
  add_property(DEFAULT_POSITION_PROPERTY, stuff);
} /* set_default_position() */

/**
 * This method returns the current default position asigned to this
 * room.
 * @return the current default position
 */
mixed query_default_position() {
   return query_property(DEFAULT_POSITION_PROPERTY);
} /* query_default_position() */

/**
 * This method tells us if the passed i nposition is
 * allowed in this type of room.
 * @param poss the position to check
 */
int is_allowed_position(string poss) {
  switch (poss) {
    case SITTING :
    case STANDING :
    case KNEELING :
    case LYING :
    case MEDITATING :
    case CROUCHING :
      return 1;
    default :
      return 0;
  }
} /* is_allowed_position() */

/** @ignore yes */
void dest_me() {
  object thing;
  
  if ( file_name( this_object() ) != ROOM_VOID ) {
    foreach( thing in all_inventory( this_object() ) ) {
      if ( userp( thing ) ) {
        thing->move_with_look( ROOM_VOID, "$N fall$s into the void." );
        continue;
      }
      thing->dest_me();
    }
  }
  
  if ( chatter )
    chatter->dest_me();
  if ( sitchanger )
    sitchanger->dest_me();
  if ( linker )
    linker->destruct_shadow( linker );
  if ( terrain )
    terrain->destruct_shadow( terrain );
  if(wall)
    wall->destruct_shadow(wall);
  if ( item )
    item->dest_me();
  
  if(door_control)
    foreach(thing in keys(door_control))
      if(objectp(thing))
        catch(thing->dest_me());
  
  if ( sizeof( hidden_objects ) )
    foreach( thing in hidden_objects ) {
      // Don't dest thing if it's hidden in multiple rooms
      if ( objectp( thing ) && ( thing->multiple_hidden() == 0 ) )
        catch( thing->dest_me() );
    }
  destruct( this_object() );
} /* dest_me() */

/**
 * This method sets the flag that enables or disables the room being
 * cleaned up.  If they flag is set to 1, then room is never cleaned up.
 * @param flag the room being cleaned up flag
 * @see query_keep_room_loaded()
 */
void set_keep_room_loaded(int flag) {
   add_property(ROOM_KEEP_PROP, flag);
} /* set_keep_room_loaded() */

/**
 * This method returns the status of the keep room loaded flag.  If they
 * flag is non-0 then the room with not be unloaded.
 * @return the status of the keep room loaded flag
 */
int query_keep_room_loaded() {
   return query_property(ROOM_KEEP_PROP);
} /* query_keep_room_loaded() */
 
/** @ignore yes */
int clean_up( int parent ) {
  if (parent) {
    return 0;
  }
  // Call outside ourselves to catch shadows.
  if (this_object()->query_keep_room_loaded()) {
      return 0;
  }
  call_out("real_clean", 30 + random(120));
  return 1;
} /* clean_up() */

/** @ignore yes */
int real_clean() {
   object thing;

   /*
    * Don't clean up the room if:
    * there's a player in it, there's a unique npc in it and it's been visited
    * by a player in the last hour, it's a slave room or there's a corpse in
    * it.
    */
   foreach ( thing in all_inventory( this_object() ) ) {
     // Destruct wandering monsters.
     if(thing->query_property("transient")) {
       if(thing->query_property("hospital"))
         thing->move(thing->query_property("hospital"), "$N wander$s in.",
                     "$N wander$s out.");
       else
         thing->move("/room/rubbish", "$N wander$s in.", "$N wander$s out.");
     }
     
     if ( thing->query_property( "player" ) ||
          (thing->query_property( "unique" ) &&
           last_visited > time() - 3600) ||
          thing->query_slave() ||
          thing->query_name() == "corpse") {
         return 0;
      }
   }
   dest_me();
   return 1;
} /* real_clean() */

/** @ignore yes */
int filter_inventory(object item, object looker) {
  return item && item->short(0) && (!looker || item->query_visible(looker));
}

/** 
 * This method returns all the matchable objects in the room.  This is used
 * by find_match to determine the group of objects to select from.
 * @param words the words to match on
 * @param looker the person doing the pmacthing
 * @return the array of objects to match on
 */
object *find_inv_match( string words, object looker ) {
   object *things;

   things = all_inventory( this_object() );
   if ( pointerp( hidden_objects ) ) {
      things += hidden_objects;
   }

   //
   // Only do these extra checks for players.
   //
   if (looker && userp(looker)) {
      /* Chekced to this filter thing to speed it up. */
      things = filter(things, "filter_inventory", this_object(), looker);
   }

   if ( item ) {
      things += ({ item });
   }
   return things;
} /* find_inv_match() */

/**
 * This method adds a sign into the room.  Any of these elements can
 * be set to 0, except the long description.
 * @param sign_long the long description of the sign
 * @param sign_read_mess the readable message on the sign
 * @param sign_short the short description of the sign
 * @param sign_name the name of the sign
 * @param sign_language the language the sign is written in
 * @return the object for the sign
 */
varargs object add_sign( string sign_long, mixed sign_read_mess, string
    sign_short, mixed sign_name, string sign_language ) {
  object sign;
  string* bits;

  sign = clone_object( "/std/object" );
  if ( !sign_name ) {
     sign_name = "sign";
  }
  if (pointerp(sign_name)) {
    bits = explode(sign_name[0], " ");
    sign->set_name( bits[<1] );
    sign->add_adjective( bits[0..<2]);
    sign->add_alias(implode(map(sign_name[1..], (: explode($1, " ")[<1] :)),
           (: $1 | ({ $2 }) :), ({ })));
    sign->add_plural(implode(map(sign_name[1..],
           (: pluralize(explode($1, " ")[<1]) :)), (: $1 | ({ $2 }) :), ({ })));
    sign->add_adjective(implode(map(sign_name[1..],
           (: explode($1, " ")[0..<2] :)), (: $1 | ({ $2 }) :), ({ })));
  } else {
    bits = explode(sign_name, " ");
    sign->set_name( bits[<1] );
    sign->add_adjective( bits[0..<2]);
  }
  sign->set_long( sign_long );
  if ( !sign_language ) sign_language = "common";
  sign->set_read_mess( sign_read_mess, sign_language );
  sign->reset_get();
  if ( sign_short && ( sign_short != "" ) ) {
    sign->set_short( sign_short );
    sign->set_main_plural( pluralize( sign_short ) );
    sign->move( this_object() );
    sign->add_property("there", "here");
  } else {
    hidden_objects += ({ sign });
    bits = sign->query_adjectives();
    if (sizeof(bits) > 0)
      sign->set_short(implode(bits, " ") + " " + sign->query_name());
    else
      sign->set_short(sign->query_name());
  }
  return sign;
} /* add_sign() */

/** @ignore yes */
void tell_door( string direc, string message, object thing ) {
   if ( objectp( door_control[ direc ] ) )
      door_control[ direc ]->tell_door( message, thing );
} /* tell_door() */

/** @ignore yes */
varargs mixed call_door( string direc, string func, mixed arg1, mixed arg2,
      mixed arg3 ) {
   if ( objectp( door_control[ direc ] ) )
      return (mixed)call_other( door_control[ direc ], func, arg1, arg2,
            arg3 );
} /* call_door() */

/**
 * This method determines if the specified exit is a door or not.
 * @param dest the destination to check for being a door
 * @param name the name of the door
 * @return 0 if it is not a door, the direction if it is
 * @see query_exit()
 * @see add_exit()
 */
string query_door( mixed dest, string name ) {
   int i;
   string direc;
   mixed bing;

   if ( objectp( dest ) ) {
      dest = file_name( dest );
   }
   if ( !stringp( dest ) ) {
      return 0;
   }
   if (name) {
      bing = door_control[ dest + " " + name];
      if (!bing) {
         bing = door_control[ dest ];
      }
   } else {
      bing = door_control[ dest ];
   }
   if ( bing ) {
      if ( !objectp( bing ) ) {
         direc = bing;
      }
   }
   if ( !direc ) {
      return 0;
   }
   bing = door_control[ direc ];
   if ( objectp( bing ) ) {
      return direc;
   }
   bing = clone_object( DOOR_OBJECT );
   i = member_array( direc, dest_other );
   bing->setup_door( direc, this_object(), dest, dest_other[ i + 1 ] );
   hidden_objects += ({ bing });
   door_control[ direc ] = bing;
   return direc;
} /* query_door() */

/**
 * This method stops all the room chats for the room.  It also removes
 * all the room chats, so if you want to have any more you must
 * add them again.
 * @see room_chat()
 */
void stop_room_chats() {
   if ( chatter ) {
      chatter->dest_me();
   }
} /* stop_room_chats() */

/**
 * Allows the chat interval to be changed.
 * @param min minimum interval between chats (seconds)
 * @param max maximum interval between chats (seconds)
 */
void set_chat_min_max( int min,int  max ) {
  if (chatter) chatter->set_chat_min_max(min,max);
}

/**
 * Adds more chats to the existing set of room chats
 * managed by this chatter object.
 * @param new_chats an array of new chat strings
 * @see remove_room_chats
 * @see query_room_chats
 * @see /std/room/basic/chatter
 */
void add_room_chats( string *new_chats ) {
  if (chatter) {
    chatter->add_room_chats( new_chats );
  }
} /* add_room_chats() */

/**
 * Removes chats from the set of room chats
 * managed by this chatter object.  If there are no chats
 * left the chatter is destructed.
 * @param dead_chats an array of chat strings to remove
 * @see add_room_chats
 * @see query_room_chats
 * @see /std/room/basic/chatter
 */
void remove_room_chats( string *dead_chats ) {
  if (chatter) {
    chatter->remove_room_chats( dead_chats );
  }
} /* remove_room_chats() */

/**
 * Returns the current set of room chats
 * managed by the chatter object.  
 * @return pointer to the mixed array of chat args
 * @example
 *  ({ 120, 240, ({ "A frog gimbles the curtains.",
 *                  "A truly revolting smell drifts insidiously "
 *                  "from the rug." }) })
 * @see add_room_chats
 * @see remove_room_chats
 * @see room_chat
 * @see /std/room/basic/chatter
 */
mixed *query_room_chats() { 
  if (chatter) {
    return chatter->query_room_chats();
  }
  return 0;
} /* query_room_chats() */

/**
 * This figures out the time of day and uses the correct chat messages.
 */
private void setup_room_chat() {
  mixed* chats;

  if (!chatter) {
    chatter = clone_object( CHATTER_OBJECT );
    if(base_name(this_object()) == "/d/sur/Maps/basic_rooms/plains/plains")
      log_file("CHATTER", "%s cloned chatter: %O\n",
               file_name(this_object()), chatter);
  }
  if(is_day == -1) {
    is_day = (WEATHER_HANDLER->query_day() > 0);
  }

  if (!variablechats) {
    variablechats = allocate(3);
  }

  if (is_day) {
    chats = variablechats[ROOM_DAY_INDEX];
  } else {
    chats = variablechats[ROOM_NIGHT_INDEX];
  }
  if (!chats) {
    chats = variablechats[ROOM_DEFAULT_INDEX];
  } else if (variablechats[ROOM_DEFAULT_INDEX]) {
    // Add the defaults onto the array.
    chats[2] += variablechats[ROOM_DEFAULT_INDEX][2];
  }
  chatter->setup_chatter( this_object(), chats );
}

/**
 * This method sets up the room chats.
 * Room chats are strings which are printed at (semi) random intervals
 * in rooms.  They are used to add atmosphere to a room. A chat will
 * be picked at random from the array of chats with a frequency
 * controlled by the times min and max. ie. one will be picked every n
 * seconds where is varies between min and max seconds. Please don't
 * make the values for min and max too small or the messages just
 * become annoying!
 * <p>
 * The argument to the room_chat method is an array of the format:<br>
 * ({ int min, int max, ({ string *chats }) }).  In place of a chat
 * string you may use "#function_name" where function_name is a
 * function that exists on the room object.
 * <p>
 * Repeated calls to this function overwrite the chats for
 * the default chatter.
 * <p>
 * If this function is used in combination with the day/night chats then
 * this sets the default chat items for the chatter.  The frequency
 * of chats will be taken from the day/night chats, but the messages from
 * here will be merged into the day/night chats.
 * @param args the room chat arguments
 * @param chatobj chatter object in case the default offends you.
 *                This argument may be omitted in which case you get 
 *                /std/room/basic/chatter.c
 * @example
 * room_chat(({ 120, 240, ({ "A string frog wanders past.",
 *                           "#make_soggy_bread",
 *                           "A trully revolting smell drifts insidiously "
 *                                "from the bakery." }) }) );
 * @see stop_room_chat()
 * @see add_room_chats()
 * @see remove_room_chats()
 * @see set_chat_min_max()
 */
varargs void room_chat( mixed *args, object chatobj ) {
   if (!args)  {
      /* This can happen if you have day chats w/o night chats, */
      /* and vice-versa */
      return;
   }
   if ( !pointerp( args[ 2 ] ) ) {
      write( "Error: second argument of room_chat args is not an array.\n" );
      return;
   }
   if (!chatter && objectp(chatobj)) {
     chatter = chatobj;
   }
   if (!variablechats) {
      variablechats = allocate(3);
   }
   variablechats[ROOM_DEFAULT_INDEX] = args;
   setup_room_chat();
} /* room_chat() */

/**
 * Set a situation changer (in place of the default).
 * If there is no argument you get the default:
 * /std/room/basic/situation_changer.
 * You call this before any other situation related functions.
 * If you create your own changer it should inherit one of
 * /std/room/basic/situation_changer or
 * /std/room/basic/multiroom_situation_changer or
 * otherwsie provide the functionality of those objects.
 * @param changer optional parameter specifying either a path for
 * the changer object or an existing object to use.
 * @see add_situation
 * @see start_situation
 * @see automate_situation
 * @see change_situation
 * @example
 * If you have a special changer object used for more than one room
 * then in setup for those rooms you should have:
 * set_situation_changer(load_object("/w/me/mychanger"));
 * Where /w/me/mychanger inherits 
 * /std/room/basic/multiroom_situation_changer
 */
varargs object set_situation_changer( mixed changer ) {
  if (stringp(changer)) {
    sitchanger = clone_object( changer );  
  } else if (objectp(changer)) {
    sitchanger = changer; 
  } else {
    sitchanger = clone_object( SITUATION_CHANGER_OBJECT );
  }
  return (sitchanger = sitchanger->set_room( this_object() ));
} /* set_situation_changer() */

/**
 * Adds a situation to the room.  These situations can be
 * invoked manually with start_situation or automatically via
 * automate_situation.
 * @param label string or number labelling the situation
 * @param sit a structure (class) containing all the bits
 * of the situation you want to add.  It should be a
 * variable of class situation.  You should include
 * situations.h where this class is defined.
 * Every part is optional.
 * eg. 
 * start_func  function to be called at start of situation 
 *             that might be used to load NPC's or anything
 *             beyond a message.
 * 
 *             The start function is passed the label, 
 *             a do_start_mess flag and the room object.  
 *             If the flag is 1 the situation is starting 
 *             rather than being reloaded.  Thus if 
 *             do_start_mess is 0 then you should avoid
 *             any obvious start messages and make it look
 *             like the situation is already underway.
 *
 * end_func    function to be called an the end of a situation.  
 *             The end function is only
 *             passed the label and the room object.
 *
 * start_mess  message told to the room at start of situation
 *
 * end_mess    message told to the room at end of situation
 *
 * extra_look  extra look string appended to rooms long 
 *             during the situation
 * chat_rate   an array of 2 numbers giving the minimum and
 *             maximum delay between chats.  If this is set
 *             then the chats are not merged with the
 *             existing chats but added independently with
 *             their own chat rates as given.
 *
 * chats       an array of chat strings to be active 
 *             during the situation 
 *
 * add_items   a mixed array of ({ item, item description }) 
 *             pairs to be active during the situation
 * 
 * random_words  sets of words to insert into text to replace 
 *               the special character #n where n is a number.
 *             The form of the array is ({  #1array, #2array, ... })
 *             where #1array = ({ "#1word1","#1word2",... }) etc.
 *             For the duration of the situation one of the strings
 *             in #1array is used to replace all instances of #1
 *             in the extra_look, start_mess, end_mess, chats
 *             and key and the long description part of the add_items.
 *             In a situation compounded of many situations
 *             the same random seed is used for choosing all #1's
 *             for each individual situation for the duration, 
 *             and a different seed for all #2's etc. 
 *
 * @see start_situation
 * @see end_situation
 * @see automate_situation
 * @see change_situation
 * @see add_item
 * @see room_chat
 * @see add_extra_look
 * @see set_situation_changer
 * @see make_situation_seed
 * @see /include/situation.h
 * @see goto learning  search  situation  for working examples
 * @example
 * #include <situations.h>
 *
 * class situation frogs;
 * frogs = new(class situation, 
 *     start_mess: "Water seeps out of the ground to form puddles.",
 *     extra_look: "There are large puddles on the ground here.",
 *     chat_rate: ({ 120,180 }),
 *     chats: ({"A hidden frog croaks quietly.",
 *              "There is a blooping sound." }),
 *     add_items:({ ({"puddle", "The puddles are dark and murky.  " 
 *                    "They will probably dry up given time." }) }) );
 * add_situation( "frogs", frogs );
 *
 * @example
 * add_situation( "ship", new(class situation, 
 *      start_mess: "A #1 ship hoves into view.",
 *      extra_look: "There is a #1 ship forging up the river.",
 *      chats: ({"The #1 ship's sails flap in the breeze.",
 *               "Shouts of sailors carry over to you from the #1 ship." }),
 *      add_items: ({ ({"ship", "The #1 ship, the \"#2\" is a small "
 *                    "sailing vessel that transports cargo up and "
 *                    "down the river."}) }),
 *      random_words: ({ ({ "old","waterlogged","heavily laden" }),
 *                       ({ "Jemima", "Old Sea Dog", "Randy Mermaid" }) })
 *      ) );
 * When the situation is started a random choice (eg. "old") replaces #1 
 * and a name (eg. "Jemima") replaces #2 in the text strings for
 * the duration.  
 * 
 * @example
 * add_situation( "frogs", new(class situation, 
 *      start_mess: "Water seeps out of the ground to form puddles.",
 *      extra_look: "There are large puddles on the ground here.",
 *      chats: ({"A hidden frog croaks quietly.",
 *               "There is a blooping sound." }),
 *      add_items: ({ ({"puddle", "The puddles are dark and murky.  " 
 *                      "They will probably dry up given time." }) }) ));
 * @example
 * This is an empty situation, useful for making pauses in the action.
 * add_situation( "pause", new(class situation) );
 */
void add_situation( mixed label, class situation sit ) {
  if (!sitchanger) {
    sitchanger = clone_object( SITUATION_CHANGER_OBJECT );
    sitchanger->set_room( this_object() );
  }
  sitchanger->add_situation( label, sit );
} /* add_situation() */

/**
 * Makes a seed value for the random part of when 
 * situations turn on and off.  The two ints should be
 * constant for a given room -- eg. the coordinates.
 * If this function is not called the seed is 
 * generated from the file_name of the object.
 * For this reason, rooms that are clones will produce
 * erratic results unless this function is called.
 * @param xval integer to use to make a seed (eg. x coordinate)
 * @param yval integer to use to make a seed (eg. y coordinate)
 */
void make_situation_seed(int xval, int yval) {
  if (sitchanger) sitchanger->set_seed(xval,yval);
} /* make_situation_seed() */

/**
 * Starts a situation previously added to the room.  These situations can be
 * invoked manually with start_situation or automatically via
 * automate_situation.  The call is passed to the situation
 * changer object.  If there isn't one nothing happens. 
 * @param label label for the situation as passed to add_situation
 * @param do_start_mess 0 to supress the start_mess string
 *        This is to fake it that a situation has been 
 *        going for a while when really you just loaded it.
 * @see add_situation
 * @see end_situation
 * @see automate_situation
 * @see change_situation
 */
void start_situation(int label, int do_start_mess) {
  if (sitchanger) 
    sitchanger->start_situation( label, do_start_mess );
} /* start_situation */

/**
 * Ends a situation previously added and started on the room.  
 * These situations can be invoked manually with start_situation 
 * or automatically via automate_situation. 
 * @param label label for the situation
 * @see add_situation
 * @see start_situation
 * @see automate_situation
 * @see change_situation
 */
void end_situation(mixed label) {
  if (sitchanger) sitchanger->end_situation( label );
} /* end_situation() */

/**
 * Starts one or more situations that will end after a
 * specified duration.  You can use an array and make
 * further situations commence when others end.
 * @param label (mixed) label of the situation to start up.  
 * If you pass an array such as ({ "frog1", "frog2" }) for the 
 * label then that set of situations are started one at
 * a time and the total duration is split evenly between them.
 * Label is usually an integer or a string or an array of
 * integers and/or strings.
 * If the string is a list of labels
 * separated by , then multiple situations
 * are started using those labels.
 * @param duration (int) total time (seconds) the overall situation 
 * should last.  You can put an array of durations -- one for each
 * situation if the label lists more than one situation and then
 * the overall time is the sum of the numbers.
 * -1 is a special duration.  It means that the labelled situation goes on
 * forever (and thus nothing after it in the array will ever go).
 * @param words is a list of replacements for #n in the text OR
 * a random number seed to use to choose words from random_words.
 * eg. ({ "#1", "frog", "#2", "honey" }) or 22
 *
 * @return handle useful for halting the changes later.  It is typically
 * a small positive integer.
 * @see shutdown_situation
 * @see add_situation
 * @see automate_situation
 * @see goto learning  search  situation  for working examples
 * @example
 * handle=change_situation( ({ "sew1","sew2" }), ({ 60,60 }) );
 * 
 * if (over) shutdown_situation( handle, ({ "sew1","sew2" }) );
 * @example
 * change_situation( ({ "background,sew1","background,sew2" }), 120 );
 * @example
 * change_situation( ({ "building_falling","rubble" }), ({ 120, -1 }) );
 * @example
 * add_situation( "boat1", 
 *   new(class situation,
 *     start_mess: "A little fishing boat comes up to the pier.  "
 *        "It has the name \"#1\" painted on the side.\n"
 *        "A fisherman jumps off the boat and ties its painter to a post.",
 *     chats: ({"The little boat bobs up and down next to the pier.",
 *              "A fisherman hops off the little boat." }),
 *     chat_rate: ({ 20, 30 }),
 *     extra_look: "There is a little boat here.",
 *     add_items: ({ ({ ({ "#1","little boat" }), 
 *       "There is little fishing boat tied up at the pier here.  "
 *       "The name \"#1\" is painted on the side."   }) }),
 *     end_mess: "The fishermen get back on board and "
 *        "the little boat moves on.",
 *     random_words: ({ ({ "Honey Toad", "Piker", "Bing" }) })
 *   )
 * );
 * 
 * change_situation( "boat1", 120, ({ "#1","Floating Egg" }) );
 */
varargs mixed change_situation( mixed label, mixed duration, mixed words ) {
  if (sitchanger) 
    return sitchanger->change_situation(label,duration,words,0);

  return 0;
} /* change_situation() */

/**
 * Automate starting and ending of a situation.
 * These situations can be invoked manually with start_situation.
 * The automated starting and ending is unaffected by the room 
 * unloading.  When the room reloads the situation will be 
 * restarted unless its duration is up.
 * You must include the file situations.h for the definitions
 * of the when masks.  The random seed needs to be set
 * consistently for the situations.  This is probably ok
 * unless your rooms are clones (see make_situation_seed). 
 * @param label (mixed) label of the situation to start 
 *  up.  If you pass an array such as ({ "frog1", "frog2" }) for the 
 * label then that set of situations are started one at
 * a time and the total duration is split evenly between them.
 * Label is usually an integer or a string or an array of
 * integers and/or strings.
 * If the string is a list of labels
 * separated by , then multiple situations
 * are started using those labels.
 * @param duration (int) total time (seconds) the overall situation 
 * should last.  You can put an array of durations -- one for each
 * situation if the label lists more than one situation and then
 * the overall time is the sum of the numbers.
 * -1 is a special duration.  It means that the situaton given that
 * duration is not part of the set but a special background or
 * default situation that occurs all the time except when
 * this automated situation is going.
 * @param when (int) a time of the day mask.  This limits when
 * the situation is allowed to occur.  The mask is composed of
 * the allowed hours in AM time ( 24 hours clock, (1<<hour) and 
 * combined with | (OR) ).   You can just use these
 * predefined masks and ignore how it works:
 *  WHEN_WEE_HOURS, WHEN_EARLY_MORNING, WHEN_LATE_MORNING, WHEN_AFTERNOON
 *  WHEN_EVENING, WHEN_LATENIGHT, WHEN_MIDDAY, WHEN_MORNING, 
 *  WHEN_EARLY_MORNING, WHEN_LATE_MORNING, WHEN_NIGHT, WHEN_DAY
 *  WHEN_ANY_TIME    
 * The masks are defined in /include/situations.h.
 * @param chance  (int) chance in 1000 of starting the situation
 *  This is tested every duration seconds.
 * @param category (optional) if you specify a cateory for the situation
 *                 then no situations with the same category will overlap.
 *                 category would usually be a string eg. "boats".
 * @see add_situation
 * @see start_situation
 * @see end_situation
 * @see situations.h
 * @see set_situation_changer
 * @see make_situation_seed
 * @see goto learning  search  situation  for working examples
 * @example
 * #include <situations.h>
 *
 *  automate_situation( "frog", 300, WHEN_ANY_TIME, 200 );
 *
 * This will automatically start the situation labelled "frog" 
 * at a random time that is any time of the day with a 200/1000
 * chance of it starting per 300 seconds.  It will last for
 * 300 seconds (5 minutes).  
 * @example
 *  automate_situation( ({"frog1,pond","frog2,pond"}), 240, 
 *                        WHEN_EVENING|WHEN_NIGHT, 300 );
 *
 * This will automatically start a situation that is a combination 
 * of "frog1" and "pond" followed by "frog2" and "pond".  They start
 * at a random time but only in the evening or at night.  
 * There will be a 300/1000 chance of 
 * it starting per 240 seconds.  Both the "frog1" and "frog2" 
 * situations will get half the total time (as there are two),  
 * 120 seconds each, for a total duration of 240 seconds (4 minutes).
 * @example
 *  automate_situation( ({"frog1,pond","frog2,pond"}), ({ 80,160 }), 
 *                        WHEN_EVENING|WHEN_NIGHT, 300 );
 * Same as previous example except the durations of the individual
 * parts are set: "frog1,pond" for 80 seconds followed by "frog2,pond"
 * for 160 seconds.  The total time is 80+160.
 */
varargs void automate_situation( mixed label, mixed duration, mixed when, 
    mixed chance, mixed category ) {
  if (sitchanger) 
    sitchanger->automate_situation(label,duration,when,chance,category);
} /* automate_situation() */

/**
 * Shuts down all current and pending situations.  It also turns off the
 * automated situation manager so no more are added.  It does not
 * destruct this object so all the add_situations are still loaded
 * and make be recommenced with automate_situation.  dest_me is
 * the appropriate call to permanently remove all situations.  The
 * call is passed to the situation changer object.  If none exists
 * then nothing happens.  The situation changer is created when
 * an add_situation call is performed. 
 * @see add_situation
 * @see automate_situation
 * @see change_situation
 */
void shutdown_all_situations() {
  if (sitchanger) sitchanger->shutdown_all_situations();
} /* shutdown_all_situations() */

/**
 * Shuts down a situation or set of situations initiated with
 * change_situation based on the call_out handle
 * returned by the call to change_situation.
 * @param callout call_out handle.  If 0 then the last
 * known handle is used.
 * @param label label or array of labels of situations to clean 
 * up with end_situation
 * @param the_room the room
 * @see automate_situation
 * @see change_situation
 */
void shutdown_situation(int call, mixed label) {
  if (sitchanger) sitchanger->shutdown_situation(call,label);
} /* shutdown_situation() */

/**
 * This method checks to see if the program is replaceable.
 * @return 1 if the program is not replaceable
 * @see set_not_replaceable()
 */
int query_not_replaceable() {
   return query_property(ROOM_NOT_REPLACE_PROGRAM_PROP);
} /* query_not_replaceable() */

/**
 * This method sets a property to make the program replaceable.  A program
 * will only be replaced if there is only a setup() function in the room.
 * A reset() or a create() will stop the room from being replace and in
 * fact any other function existing in there will stop it from being
 * replaced as well.
 * @pram replace 1 to make the room not replacable
 * @see query_not_replaceable()
 */
void set_not_replaceable(int replace) {
   add_property(ROOM_NOT_REPLACE_PROGRAM_PROP, replace);
} /* set_not_replaceable() */

/** @ignore yes */
mixed stats() {
   int i;
   mixed *stuff;
   stuff = ({ });
   for ( i = sizeof( dest_other ) - 2; i > -1; i -= 2 )
      stuff += ({
         ({ dest_other[ i ], dest_other[ i + 1 ][ ROOM_DEST ] })
      });
   if ( co_ord )
      stuff += ({
         ({ "co-ord x", co_ord[ 0 ] }),
         ({ "co-ord y", co_ord[ 1 ] }),
         ({ "co-ord z", co_ord[ 2 ] })
      });
   return light::stats() + property::stats() + effects::stats() + stuff + ({
      ({ "short", short( 0 ) }),
      ({ "enchantment", query_enchant() }),
      ({ "background enchantment", background_enchant }),
      ({ "dynamic enchantment", dynamic_enchant }),
      ({ "enchantment time", enchant_time }),
      ({ "theft handler", theft_handler }),
   });
} /* stats() */

/**
 * This method sets the long description to display during the day time.
 * @param str the new day long description
 * @see query_day_long()
 * @see set_night_long()
 */
void set_day_long( string str ) {
  if(!variablelongs) {
    variablelongs = allocate(2);
  }

  variablelongs[ROOM_DAY_INDEX] = str;

  if(is_day == -1) {
    is_day = (WEATHER_HANDLER->query_day() > 0);
  }

  if(is_day == ROOM_DAY_INDEX) {
    set_long(str);
  }
}

/**
 * This method returns the long description of the room during the day.  This is
 * used to print out different strings for rooms during the day and during
 * the night.
 * @return the night long for the room.
 */
string query_day_long() {

   if(variablelongs && strlen(variablelongs[ROOM_DAY_INDEX]))
     return variablelongs[ROOM_DAY_INDEX];
   
   return this_object()->query_long();
} /* query_day_long() */

/**
 * This method sets up the night long for the room.  This will be the
 * long description displayed at night in the room.
 * @param str the new night long description
 * @see set_day_long()
 * @see query_night_long()
 */
void set_night_long( string str ) {
  if(!variablelongs)
    variablelongs = allocate(2);

  variablelongs[ROOM_NIGHT_INDEX] = str;

  if(is_day == -1)
    is_day = (WEATHER_HANDLER->query_day() > 0);
  if(is_day == ROOM_NIGHT_INDEX)
    set_long(str);
}

/**
 * This method returns the long description of the room at night.  This is
 * used to print out different strings for rooms during the day and during
 * the night.
 * @return the night long for the room.
 */
string query_night_long() {

   if(variablelongs && strlen(variablelongs[ROOM_NIGHT_INDEX]))
     return variablelongs[ROOM_NIGHT_INDEX];
   
   return this_object()->query_long();
} /* query_night_long() */

/* Returns the long part of the description. */
private string return_long(mixed desc) {
  int ma;

  if(!pointerp(desc))
    return (string)desc;

  ma = member_array("long", desc);
  if(ma < 0)
    return "Error: No long found.";
  
  return (string)desc[ma+1];
}

/**
 * This method sets up an item which will only be displayed during the
 * day.  All of the standard add_item things are available with this
 * method.
 * @see /std/room->add_item()
 * @see add_night_item()
 */
varargs int add_day_item(mixed shorts, mixed desc, mixed no_plural) {
  string the_item;
  
  if(pointerp(shorts))
    the_item = shorts[0];
  else
    the_item = shorts;

  if(!variableitems)
    variableitems = ({ ({ }), ({ }) });
  
  variableitems[ROOM_DAY_INDEX] += ({ the_item, return_long(desc) });

  if(is_day == -1)
    is_day = (WEATHER_HANDLER->query_day() > 0);
  if(is_day == ROOM_DAY_INDEX) 
    return add_item(shorts, desc, no_plural);
  
  return 1;
}

/**
 * This method sets up an item which will only be displayed during the
 * night.  All of the standard add_item things are available with this
 * method.
 * @see /std/room->add_item()
 * @see add_day_item()
 */
varargs int add_night_item(mixed shorts, mixed desc, mixed no_plural) {
  string the_item;
  
  if(pointerp(shorts))
    the_item = shorts[0];
  else
    the_item = shorts;

  if(!variableitems)
    variableitems = ({ ({ }), ({ }) });

  variableitems[ROOM_NIGHT_INDEX] += ({ the_item, return_long( desc ) });
  
  if(is_day == -1) {
    is_day = (WEATHER_HANDLER->query_day() > 0);
  }
  if(is_day == ROOM_NIGHT_INDEX)  {
    return add_item(shorts, desc, no_plural);
  }

  return 1;
}

/**
 * This method sets up chats for when the room is in the day cycle.
 * @param args the chatter arguements
 * @see room_night_chat()
 * @see /std/room->room_chat()
 */
void room_day_chat(mixed *args) {
  if(!variablechats) {
    variablechats = allocate(3);
  }
  
  variablechats[ROOM_DAY_INDEX] = args;
  
  if(is_day == -1) {
    is_day = (WEATHER_HANDLER->query_day() > 0);
  }
  if(is_day == ROOM_DAY_INDEX) {
    setup_room_chat();
  }
}

/**
 * This method sets up chats for when the room is in the night cycle.
 * @param args the chatter arguements
 * @see room_day_chat()
 * @see /std/room->room_chat()
 */
void room_night_chat( mixed *args ) {
  if(!variablechats) {
    variablechats = allocate(3);
  }
  
  variablechats[ROOM_NIGHT_INDEX] = args;
  
  if(is_day == -1) {
    is_day = (WEATHER_HANDLER->query_day() > 0);
  }
  if(is_day == ROOM_NIGHT_INDEX) {
    setup_room_chat();
  }
}

/** @ignore yes */
string query_help_file_directory() {
  return ROOM_HELP_FILE_DIR;
} /* query_help_file_directory() */

/**
 * This returns the set of chats visible only at night.
 * @return the chat array used at night.
 */
mixed* query_room_night_chats() {
  if (sizeof (variablechats)) {
    return variablechats[ROOM_NIGHT_INDEX];
  }
  return ({ });
}

/**
 * This returns the set of chats visible only during the day.
 * @return the chat array used during the day
 */
mixed* query_room_day_chats() {
  if (sizeof (variablechats)) {
    return variablechats[ROOM_DAY_INDEX];
  }
  return ({ });
}

/**
 * This returns the default set of chats, these are mixed with the night
 * and day chats to generate the current set.
 * @return the mixed set of chats
 */
mixed* query_room_default_chats() {
   if (sizeof(variablechats)) {
      return variablechats[ROOM_DEFAULT_INDEX];
   }
   return ({ });
}

/**
 * These are the items only visible during the day.
 */
mixed* query_day_items() {
  if (sizeof (variableitems)) {
    return variableitems[ROOM_DAY_INDEX];
  }
  return ({ });
}

/**
 * These are the items only visible at night.
 */
mixed* query_night_items() {
  if (sizeof (variableitems)) {
    return variableitems[ROOM_NIGHT_INDEX];
  }
  return ({ });
}
// --- END [/mnt/home2/grok/lib/std/room/basic_room.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/furniture/commercial.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/furniture/commercial.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629223   Available: 13576577
Inodes: Total: 5242880    Free: 4960135
13151 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/furniture/commercial.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629223   Available: 13576577
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: commercial.c,v 1.25 2003/06/07 01:37:30 pinkfish Exp $
 *
 *
 */
/**
 * This is a fucniture object for makeing all kinds of commercial
 * furniture.
 * @author Pinkfish
 * @started Sat Jun  2 16:27:27 PDT 2001
 */
#include <move_failures.h>
#include <position.h>
#include <money.h>

inherit "/std/object";
inherit "/std/basic/item_chat";
inherit "/std/room/furniture/inherit/furniture_base";

string query_main_status(int hints);

private nosave int _commercial_size;
private nosave string _commercial_type;
private nosave string _commercial_name;
private nosave string* _use_types;
private nosave string _info;
private int _revenue;
private int _weekly_revenue;
private int _commercial_id;
private int _weekly_upkeep_cost;

#define OBJECT_TAG "commercial inh"

void create() {
   _commercial_size = 100;
   if (!_use_types) {
      _use_types = ({ });
   }
   do_setup++;
   object::create();
   furniture_base::create();
   add_alias( "furniture" );
   add_plural( "furniture" );
   add_property("talisman", "no one");
   set_opaque();
   if ( !query_property( "shop type" ) ) {
      add_property( "shop type", "furniture" );
   }

   do_setup--;
   if ( !do_setup ) {
     this_object()->setup();
   }
   // Don't respond to 'get all'
   set_no_all(1);
   reset_get();
} /* create() */

/**
 * This method sets the weekly upkeep cost for the furniture item.
 */
void set_weekly_upkeep_cost(int cost) {
   _weekly_upkeep_cost = cost;
}

/**
 * This method sets the weekly upkeep cost for the furniture item.
 */
int query_weekly_upkeep_cost() {
   return _weekly_upkeep_cost;
}

/**
 * This method returns the revenue for this item.
 */
int query_revenue() {
   return _revenue;
} /* query_revenue() */

/**
 * This method sets the current revenue of the item.
 * @param revenue the new revenue of the object
 */
void set_revenue(int revenue) {
   _revenue = revenue;
} /* set_revenue() */

/**
 * This method returns the save directory of the outside room.
 * @return the save directory
 */
string query_save_dir() {
   return environment()->query_save_dir();
} /* query_save_dir() */

/**
 * This method returns the owner of the establishment.
 * @return the owener of the establishment
 */
string query_owner() {
  return environment()->query_owner();
} /* query_owner() */

/**
 * This method returns the owner of the establishment.
 * @return the owener of the establishment
 */
string query_language() {
  return environment()->query_language();
} /* query_owner() */

/**
 * This method returns the money place of the object.
 * @return the money place
 */
string query_money_place() {
   if (!environment()) {
      return "default";
   }
   return environment()->query_property("place");
} /* query_money_place() */

/**
 * This method checks to see if the specified person is allowed
 * to use the room or not.
 * @param person the person to check
 */
int is_allowed(string person) {
   return environment()->is_allowed(person);
} /* is_allowed() */

/**
 * This method returns the list of people that are allowed.
 * @return the people that are allowed
 */
string query_allowed() {
   return environment()->query_allowed();
} /* query_allowed() */

/**
 * This method returns the float in the current room.
 * @return the float
 */
int query_float() {
   return environment()->query_royalty(query_owner());
} /* query_float() */

/**
 * This method returns the royalties for the specific person.
 * @param person the person to get the royalty of
 * @return the royalty
 */
int query_royalty(string person) {
   return environment()->query_royalty(person);
} /* query_royalty() */

/**
 * This method adjusts the royalty for the specific person.
 * @param person the person to adjust the royalty of
 * @param amount the amount to adjust it by
 */
int adjust_royalty(string person, int amount) {
   if (person == query_owner()) {
      _revenue += amount;
      _weekly_revenue += amount;
   }
   environment()->adjust_royalty(person, amount);
} /* adjust_royalty() */

/**
 * This method adjusts the float of the current room.
 * @param amt the amount to adjust by
 */
int adjust_float(int amt) {
   adjust_royalty(query_owner(), amt);
} /* adjust_float() */

/**
 * This method checks to see if the place is open for the spefic type of
 * activity.
 * @param type the type of open to check rfor
 * @param person the person to check for
 */
int is_open_for(string type, string person) {
   if (!environment()->query_commercial_property()) {
      return 0;
   }
   return environment()->is_open_for(type, person);
} /* is_open_for() */

/**
 * This method sets the size of the item in terms of commericial
 * property.  100 is very large and takes up all of a large
 * commercial property.  For example, a 100 item shop will be
 * size 100.
 * @param size the new size of the item
 */
void set_commercial_size(int size) {
   _commercial_size = size;
} /* set_commercial_size() */

/**
 * This method returns the type of the commericial property.
 * @return the type of the commercial property
 */
string query_commercial_type() {
   return _commercial_type;
} /* query_commercial_type() */

/**
 * This method sets the type of the item in terms of commericial
 * property.
 * @param type the new type of the item
 */
void set_commercial_type(string type) {
   _commercial_type = type;
} /* set_commercial_type() */

/**
 * THis method sets any extra information about the shop to be told
 * when someone does a browse.
 * @param info the infomation
 */
void set_commercial_information(string info) {
   _info = info;
} /* set_commercial_information() */

/**
 * This method returns the extra information about the shoip to be used
 * in the browse.
 * @return the extra inforation
 */
string query_commercial_information() {
   return _info;
} /* query_commercial_information() */

/**
 * This method sets the name of the item for use in finding this specific
 * type of item in a room.
 * @param name the name
 * @see /std/shops/inherit/commercial->find_commercial_items()
 */
void set_commercial_name(string name) {
   _commercial_name = name;
} /* set_commercial_information() */

/**
 * This method returns the name of the item for use in finding this specic
 * type of item in a room.
 * @return the extra inforation
 * @see /std/shops/inherit/commercial->find_commercial_items()
 */
string query_commercial_name() {
   return _commercial_name;
} /* query_commercial_name() */

/**
 * This method returns the size of the commericial property.
 * @return the size of the commercial property
 */
int query_commercial_size() {
   return _commercial_size;
} /* query_commercial_size() */

/**
 * This returns a unique id for the commercial item.  This id will be
 * unique within the room*
 * @return a unique id
 */
int query_commercial_id() {
   return _commercial_id;
} /* query_commercial_id() */

/**
 * This method sets up a new commercial id for the place.
 */
void setup_new_commercial_id() {
   _commercial_id = environment()->find_next_commercial_id();
} /* setup_new_commercial_id() */

/**
 * This method sets the commercial id for the item.
 * @param id the unique id to use
 */
void set_commercial_id(int id) {
   _commercial_id = id;
} /* set_commercial_id() */

/**
 * This method returns the parcel post room defined for the room.
 * @return the parcel post room defined for the room
 */
string query_parcel_post() {
   return environment()->query_parcel_post();
} /* query_parcel_post() */

/**
 * This method sets the types which this item will use for checking.
 * @param types this sets the types for the shop
 */
void set_shop_use_types(string* types) {
   _use_types = types;
} /* set_shop_use_types() */

/**
 * This method returns the types of thingies for the commercial property.
 * @return the shop types
 */
string* query_shop_use_types() {
   return _use_types;
} /* query_shop_use_types() */

/**
 * This resets the weekly statistics for the object.
 */
void reset_weekly_status() {
   _weekly_revenue = 0;
} /* reset_weekly_status() */

/**
 * This method returns the weekly status for this furniture object.
 * @return the weekly status for the this object
 */
string query_weekly_status_string() {
   string ret;
   string place;

   place = query_money_place();
   if (query_weekly_upkeep_cost()) {
      ret = "Weekly Upkeep : " +
            MONEY_HAND->money_value_string(_weekly_upkeep_cost, place) + "\n" +
            "Weekly Revenue: " +
            MONEY_HAND->money_value_string(_weekly_revenue, place) + "\n" +
            "Profit        : " +
            MONEY_HAND->money_value_string(_weekly_revenue - _weekly_upkeep_cost, place) + "\n";
   } else {
      ret = "Weekly Revenue: " +
            MONEY_HAND->money_value_string(_weekly_revenue, place) + "\n";
   }
   return ret;
} /* query_weekly_status_string() */

/**
 * This method checks to see if the furniture can be trashed or not.  This
 * will check to make sure the item can be trashed or not.  The item should
 * be unable to be trashed if it still contains some player data of
 * some sort.
 * @return 1 if it can be trashed, 0 if not
 */
int can_trash_furniture() {
   return 1;
} /* can_trash_furniture() */

/**
 * This method checks to see if the item is a commercial
 * furniture item.
 * @return 1 if the item is commercial furniture
 */
int query_commercial_furniture() {
   return 1;
} /* query_commercial_furniture() */

/* Furniture is much harder to carry than just its weight, therefore we
 * multiply its weight by 5 to determine if someone can carry it.
 */
/** @ignore yes */
varargs int move( mixed dest, string messin, string messout ) {
   int i;
   int t;
   int f;
   object from;

   if(stringp(dest)) {
      dest = find_object(dest);
   }

   if (!move_check(dest)) {
      write(the_short() + " resists being picked up and shocks you slightly.\n");
      return MOVE_INVALID_DEST;
   }

   if(!dest) {
      return MOVE_INVALID_DEST;
   }

   if(living(dest)) {
      t = (int)this_object()->query_complete_weight() * 5;
      if(!(dest->add_weight(t))) {
         return MOVE_TOO_HEAVY;
      }
      debug_printf("Added %d", t);
   }

   from = environment();
   i = ::move(dest, messin, messout);

   if(i != MOVE_OK) {
      dest->add_weight(-t);
      return i;
   }

   if(from && living(from)) {
      f = (int)this_object()->query_complete_weight() * 5;
      from->add_weight(-f);
   }

   if (from) {
      from->remove_commercial_thing(this_object());
   }
   dest->add_commercial_thing(this_object());
   dest->register_use_types(_use_types);

   return i;
} /* move() */

/** @ignore yes
 * This stops people dragging items away if they aren't allowed to.
 */
int get(mixed dest) {
   if(!move_check(dest)) {
      write("You feel it would be wrong to take " + the_short() + ".\n");
      return 2;
   }
   return ::get(dest);
} /* get() */

/** @ignore yes */
int do_status(int hint) {
   string ret;

   ret = query_main_status(hint);
   write("$P$Status$P$" + ret);
   add_succeeded_mess("$N get$s the status of $D.\n");
   return 1;
} /* do_status() */

/** @ignore yes */
int do_reset() {
   string place;
   int old_revenue;

   place = query_money_place();
   old_revenue = _revenue;
   _revenue = 0;
   add_succeeded_mess("$N clear$s the revenue of " +
                      MONEY_HAND->money_value_string(old_revenue, place) +
                      " on $D.\n");
   return 1;
} /* do_reset() */

void init() {
   ::init();
 
   if (is_allowed(this_player()->query_name())) {
      add_command("status", "<direct:object>", (: do_status, 0 :));
      add_command("status", "hints <direct:object>", (: do_status, 1 :));
      add_command("status", "hint <direct:object>", (: do_status, 1 :));
      add_command("reset", "revenue on <direct:object>", (: do_reset :));
   }
} /* init() */

/** @ignore yes */
mixed query_static_auto_load() {
  if ( base_name(this_object()) + ".c" == __FILE__ ) {
    return int_query_static_auto_load();
  }
  return ([ ]);
} /* query_static_auto_load() */

/** @ignore yes */
mixed query_dynamic_auto_load() {
   mapping junk;

   junk = object::query_dynamic_auto_load();
   if (!junk) {
      junk = ([ ]);
   }
   junk["bonded"] = query_bonded();
   add_auto_load_value(junk, OBJECT_TAG, "revenue", query_revenue());
   add_auto_load_value(junk, OBJECT_TAG, "commercial id", query_commercial_id());
   return junk;
} /* query_dynamic_auto_load() */

/** @ignore yes */
void init_dynamic_arg(mapping map) {
   object::init_dynamic_arg(map);
   if (map) {
      set_bonded(map["bonded"]);
      set_revenue(query_auto_load_value(map, OBJECT_TAG, "revenue"));
      if (query_auto_load_value(map, OBJECT_TAG, "commercial id")) {
         set_commercial_id(query_auto_load_value(map, OBJECT_TAG, "commercial id"));
      }
   }
} /* init_dynamic_arg() */

/** @ingore yes */
string query_help_file_directory() {
   return "/doc/furniture/";
} /* query_help_file_directory() */

/** @ingore yes */
mixed *stats() {
   return ::stats() +
          ({ ({ "revenue", query_revenue() }),
             ({ "bonded", query_bonded() }),
             ({ "commercial id", query_commercial_id() }) });
} /* stats() */
// --- END [/mnt/home2/grok/lib/std/room/furniture/commercial.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/furniture/inherit/furniture_base.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/furniture/inherit/furniture_base.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629220   Available: 13576574
Inodes: Total: 5242880    Free: 4960135
7505 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/furniture/inherit/furniture_base.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629220   Available: 13576574
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: furniture_base.c,v 1.23 2003/06/25 19:51:42 ceres Exp $
 *
 *
 */
/**
 * This is a furniture item for making all kinds of furniture.
 * @author Ceres
 * @changes Pinkfish Tue May 15 13:06:52 PDT 2001
 * Made is so that furniture can be bonded to someone so only that person
 * can move it and touch it.
 */
#include <move_failures.h>
#include <position.h>
#include <housing.h>
#include <room/placement.h>

//
// Predefintions.
//
void add_property(string name, mixed type);
mixed query_property(string name);
string one_short();
int query_light_needs_inform();
void inform_of_light_level_change(object ob);
//void set_max_cond(int);
//void set_cond(int);

private nosave mapping _allowed_room_verbs;
private nosave string *_allowed_positions;
private nosave string _bonded;

void create() {
  _allowed_positions = ({ });
  if (base_name(this_object()) + ".c" != __FILE__) {
    if ( !query_property( "shop type" ) ) {
      add_property( "shop type", "furniture" );
    }
    this_object()->set_max_cond(100000);
    this_object()->set_cond(100000);
  }
  if(clonep(this_object()) &&
     base_name(this_object())[0..14] != "/obj/furnitures" &&
     base_name(this_object())[0..2] != "/w/" && 
     strsrch (base_name(this_object()), "_dev") == -1 && 
     strsrch (base_name(this_object()), "_pt") == -1) {
    call_out("move", 2, "/room/void");
  }
}

/**
 * This method will return true if the item is an item of furniture.
 * @return always returns true
 */
int query_furniture() {
   return 1;
}

/**
 * Used to define what positions (sitting, lying etc.) are allowed for this
 * piece of furniture.
 * @param positions an array of strings.
 *
 * @see position.h
 */
void set_allowed_positions(string *positions) {
   _allowed_positions = positions;
}

/**
 * Removes the positions given to this function as the argument,
 * from the list of allowed positions for this piece of furniture
 */
void remove_allowed_positions( string *positions ){
  _allowed_positions -= positions;
}

/**
 * Returns the set of allowed positions for the furniture object.
 * @return the set of allowed positions
 */
string* query_allowed_positions() {
   return _allowed_positions;
}

/**
 * Set the allowed location verbs for this object.
 * @param allowed the allow mapping
 */
void set_allowed_room_verbs( mapping allowed ) {
  _allowed_room_verbs = allowed;
}

/**
 * This method returns the location verbs for this object.
 * @return the allowed mapping
 */
mapping query_allowed_room_verbs() {
   return _allowed_room_verbs;
}

/** @ignore yes */
string query_position_string(string position_type) {
  if(member_array(position_type, _allowed_positions) != -1) {
    return one_short();
  }
  return 0;
}

/**
 * This method sets the furniture as bonded to a specified person.
 * @param person the person to bond the furniture to
 */
void set_bonded(string person) {
   _bonded = person;
}

/**
 * This method returns the person who the furniture is currently
 * bonded to.
 * @return the person the furniture is bonded to
 */
string query_bonded() {
   return _bonded;
}

/**
 * Returns the person who this item is bonded to.
 * @return the person the furniture is bonded to
 */
string query_owner() {
   return _bonded;
}

/**
 * This method checks to see if the specified person can mess with this
 * furniture.
 * @param person the person to check
 */
int is_allowed_to_mess(object player) {
  mixed *stuff;
  string occupier;
  
  if(environment() && !function_exists("query_owner", environment()))
    return 1;
  if(player->query_creator())
    return 1;
  
  // Do the checks on the controller of a controlled monster
  // (dustdevil, fruitbat, portage cloud etc. etc.)
  if(player->query_caster())
    player = find_player(player->query_caster());
  if(player->query_owner())
    player = player->query_owner();

  // It's bonded to this person so they can move it.
  if (player && player->query_name() == _bonded)
    return 1;

  // If this person dropped it they can move it.
  stuff = this_object()->query_property("dropped");
  if(player && sizeof(stuff) && stuff[0] == player->query_name())
    return 1;

  if(player && environment()) {
    // If they control this room they can move it.
    if(environment()->test_occupier(player->query_name()))
      return 1;
    if(environment()->query_owner() == "For Sale" ||
       environment()->query_owner() == "Under Offer")
      return 1;
    
    occupier = HOUSING->query_owner(base_name(environment()));
    if(pk_check(player, occupier, 1))
      return 0;
  }
  
  // Otherwise succeed if not bonded, fail if bonded.
  return (!_bonded);
}

/**
 * This makes a move check to see if the person is allowed to move
 * the item or not.
 * @param dest where we are going to
 * @return 1 if can be moved, 0 otherwise
 */
int move_check(object dest) {
  if (living(dest)) {
    if (!is_allowed_to_mess(dest)) {
       return 0;
    }
  } else if (this_player() && environment()) {
    // Allow people to drop items that have managed to get that are bonded.
    if (!(living(environment()) && dest == environment(environment()))) {
       // Otherwise check this player, allow the initial setup move though.
       if (!is_allowed_to_mess(this_player())) {
          return 0;
       }
    }
  }
  return 1;
}

/**
 * This method returns the current verb the furniture object is using.  The
 * verb is something like 'sitting' or 'standing'.
 * @return the current verb
 */
string query_placement_verb() {
   return query_property(PLACEMENT_CURRENT_ROOM_VERB);
}

/**
 * This method returns the current other the furniture object is using.  The
 * other is somethign like 'against', 'beside'.
 * @return the current other
 */
string query_placement_other() {
   return query_property(PLACEMENT_CURRENT_ROOM_OTHER);
}

/**
 * This method returns the current position the furniture object is using.
 * The position is something like 'wall', 'ceiling' etc.
 * @return the current position
 */
string query_placement_position() {
   return query_property(PLACEMENT_CURRENT_ROOM_POSITION);
}

/**
 * This method returns if the furniture object can be moved or not.
 * @return 1 if it is immovable
 */
int query_placement_immovable() {
   return query_property(PLACEMENT_IMMOVABLE);
}

/**
 * This method checks to see if the furniture is placed or not.
 * @return 1 if placed, 0 if not
 */
int is_placed() {
   return query_placement_position() &&
     stringp(query_placement_verb()) &&
     stringp(query_placement_other());
}

/**
 * This method sets the current verb the furniture object is using.  The
 * verb is something like 'sitting' or 'standing'.
 * @param verb the new verb
 */
void set_placement_verb(string verb) {
   add_property(PLACEMENT_CURRENT_ROOM_VERB, verb);
}

/**
 * This method sets the current other the furniture object is using.  The
 * other is somethign like 'against', 'beside'.
 * @param other the new other
 */
void set_placement_other(string other) {
   add_property(PLACEMENT_CURRENT_ROOM_OTHER, other);
}

/**
 * This method sets the current position the furniture object is using.
 * The position is something like 'wall', 'ceiling' etc.
 * @param position the new position
 */
void set_placement_position(string position) {
   add_property(PLACEMENT_CURRENT_ROOM_POSITION, position);
}

/**
 * This method returns if the furniture object can be moved or not.
 * @return 1 if it is immovable
 */
int set_placement_immovable() {
   return query_property(PLACEMENT_IMMOVABLE);
}
// --- END [/mnt/home2/grok/lib/std/room/furniture/inherit/furniture_base.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/furniture/inherit/one_armed_bandit_inherit.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/furniture/inherit/one_armed_bandit_inherit.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629218   Available: 13576572
Inodes: Total: 5242880    Free: 4960135
10107 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/furniture/inherit/one_armed_bandit_inherit.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629218   Available: 13576572
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/** Inherit for one-armed bandits.
 * Refined from the original object by Jobe.
 * Wirble, June 4th 2002
 */

#include <money.h>


int do_slot();
int do_pull_lever();
int do_read_dial();

int set_coin_type( string coin );
int set_chances( int c1, int c2, int c3, int c4, int c5 );
int set_prizes( int p1, int p2, int p3, int p4, int p5, int jackpot );

int* query_prizes();
int* query_chances();
string query_coin_type();

void rollem( object player );
string my_short();

private string *animal = ({"albatross", "frog", "hippo", "turtle", "cabbage"});

private string *adject = ({"A crazy", "A dancing", "A sad", "A floopy", "A bemused",
    "A sarcastic", "A quizzical", "A startled", "A friendly", "A mindless"});

private string _coin = "Ankh-Morpork pence", _coin_short = "pence",
    _coin_pl = "Ankh-Morpork pence";
private int _busy = 0;
private int* _chances = ({1,1,1,1,1});
private int* _prizes = ({2,2,2,2,2,3});


/** @ignore */
void init(){
    this_player()->add_command( "slot", this_object(),
        _coin_short + " into <direct:object>", (: do_slot() :) );
    this_player()->add_command( "pull", this_object(),
        "lever on <direct:object>", (: do_pull_lever() :) );
    this_player()->add_command( "read", this_object(),
        "dial on <direct:object>", (: do_read_dial() :) );
} /*void init() */


/** This sets the type of coin the bandit accepts.  It has to be of valid
 * type as registed in the money handler.
 * @param coin the name of the coin
 * @return 1 on success, otherwise 0
 */
int set_coin_type( string coin ) {
    if( member_array( coin, MONEY_HAND->query_valid_types() ) == -1 )
        return 0;
    _coin = coin;
    _coin_short = MONEY_HAND->query_aliases_for( coin )[0];
    _coin_pl = MONEY_HAND->query_main_plural_for( coin );
    return 1;
} /* int set_coin_type() */


/** Sets the chances for winning.  Each value represents the chance for one
 * type of picture to show up.
 *
 * 5, 4, 3, 2, 1 would mean: 33.3% chance for pic 1, 26.6% for pic 2,
 * 20% for pic 3, 13.3% for pic 4 and 6.6% for pic 5.
 * To win, all three images must be the same pic. To win the jackpot, there has
 * to be another match of 10% per image.
 * @param c1 Chance for albatross
 * @param c2 Chance for frog
 * @param c3 Chance for hippo
 * @param c4 Chance for turtle
 * @param c5 Chance for cabbage
 * @return 1 on success, otherwise 0
 */
int set_chances( int c1, int c2, int c3, int c4, int c5 ) {
    if( !( c1 > 0 && c2 > 0 && c3 > 0 && c4 > 0 && c5 > 0 ) )
        return 0;
    _chances = ({ c1, ( c1 + c2 ), ( c1 + c2 + c3 ), ( c1 + c2 + c3 + c4 ),
        ( c1 + c2 + c3 + c4 + c5 ) });
    return 1;
} /* int set_chances() */


/** Number of coins (as per defined type) won by scoring a triple or the
 * jackpot. Minimum 2.
 * @param p1 Number of coins for 3x albatross
 * @param p2 Number of coins for 3x frog
 * @param p3 Number of coins for 3x hippo
 * @param p4 Number of coins for 3x turtle
 * @param p5 Number of coins for 3x cabbage
 * @param jackpot Number of coins for jackpot (higher than any of the others)
 * @return 1 on success, otherwise 0
 */
int set_prizes( int p1, int p2, int p3, int p4, int p5, int jackpot ) {
    if( !( p1 > 1 && p2 > 1 && p3 > 1 && p4 > 1 && p5 > 1 && jackpot > 1 ) ||
        ( jackpot <= p1 || jackpot <= p2 || jackpot <= p3 ||
        jackpot <= p4 || jackpot <= p5 ) )
        return 0;
    _prizes = ({p1, p2, p3, p4, p5, jackpot});
    return 1;
} /* int set_prizes() */


/** @ignore */
int do_slot() {
    if( member_array( _coin, this_player()->query_money_array() ) == -1 ) {
        this_player()->add_failed_mess( this_object(),
            "You need " + add_a( _coin ) + " to play.\n", ({ }) );
        return 0;
    }
    if( _busy == 1 ) {
        this_player()->add_failed_mess( this_object(),
            "There is already a coin inserted.\n", ({ }) );
        return 0;
    }
    if( _busy == 2 ) {
        this_player()->add_failed_mess( this_object(),
            "The wheels of $D are still spinning.\n", ({ }) );
        return 0;
    }
    this_player()->adjust_money( -1, _coin );
    this_object()->adjust_money( 1 );
    _busy = 1;
    this_player()->add_succeeded_mess( this_object(),
        "$N insert$s " + add_a( _coin_short ) + " into $D.\n", ({ }) );
    return 1;
} /* int do_slot() */


/** @ignore */
int do_pull_lever() {
    if( _busy == 0 ) {
        this_player()->add_failed_mess( this_object(),
            "You must put a coin in the slot before you can play.\n", ({ }) );
        return 0;
    }
    if( _busy == 2 ) {
        this_player()->add_failed_mess( this_object(),
            "The wheels of $D are already spinning.\n", ({ }) );
        return 0;
    }
    this_player()->add_succeeded_mess( this_object(),
        ({"You pull the lever.  The pictures behind the windows blur... one by "
             "one they are replaced by a new picture that appears with a sharp "
             "click.\n",
        "$N pull$s the lever on $D and the machine whirs softly.  The sound is "
        "cut short by three sharp clicks.\n"
        }), ({ }) );
    call_out( "rollem", 0, this_player() );
    _busy = 2;
    return 1;
} /* int do_pull_lever() */


/** @ignore */
void rollem( object player ) {
    int a1, a2, a3, c;
    int adj1 = random( 10 ),
        adj2 = random( 10 ),
        adj3 = random( 10 );

    c = random( _chances[4] );
    if( c < _chances[0] )
        a1 = 0;
    else if( c < _chances[1] )
        a1 = 1;
    else if( c < _chances[2] )
        a1 = 2;
    else if( c < _chances[3] )
        a1 = 3;
    else
        a1 = 4;

    c = random( _chances[4] );
    if( c < _chances[0] )
        a2 = 0;
    else if( c < _chances[1] )
        a2 = 1;
    else if( c < _chances[2] )
        a2 = 2;
    else if( c < _chances[3] )
        a2 = 3;
    else
        a2 = 4;

    c = random( _chances[4] );
    if( c < _chances[0] )
        a3 = 0;
    else if( c < _chances[1] )
        a3 = 1;
    else if( c < _chances[2] )
        a3 = 2;
    else if( c < _chances[3] )
        a3 = 3;
    else
        a3 = 4;

    tell_object( player,
        "The windows now show these pictures :\n\n"
         "        " + adject[ adj1 ] + " " + animal[ a1 ] +
         "    " + adject[ adj2 ] + " " + animal[ a2 ] +
         "    " + adject[ adj3 ] + " "+animal[ a3 ] + "\n\n" );
    if( a1 == a2 && a1 == a3 ) {
        if( adj1 == adj2 && adj1 == adj3 ) {
            tell_object( player,
                "WOW!!  A triple " + adject[ adj1 ] + " " + animal[ a1 ] +
                "!!  You really hit the jackpot this time!\n\n"
                "Whistles and bells start sounding like crazy, the whole " +
                this_object()->short() +  " glows with flashing lights.  There "
                "is a loud tingling as " + _prizes[5] + " " +
                MONEY_HAND->query_plural_for( _coin ) + " drop into the tray "
                "of " + my_short() + ".  Slightly stunned you quickly scoop "
                "it up and cackle with delight.\n" );
            tell_room( environment( this_object() ),
                "Whistles and bells start sounding and " + my_short() +
                " starts to flash with coloured lights.  Someone must have "
                "won the jackpot...lucky buggers.  As you watch some coins "
                "drop into the tray at the bottom of " + my_short() + ", " +
                player->one_short() + " snatches it up and cackles with "
                "delight.\n", ({player}) );
            player->adjust_money( _prizes[5] ,_coin );
            this_object()->adjust_money( -(_prizes[ 5 ]) );
            _busy = 0;
            return;
        }

        tell_object( player,
            "Congratulations!  You scored a triple " + animal[ a1 ] + "!\n" );
        player->adjust_money( _prizes[ a1 ], _coin );
        tell_object( player,
            _prizes[ a1 ]+ " " + MONEY_HAND->query_plural_for( _coin ) +
            " fall into the tray at the bottom of " + my_short() + ".  You "
            "quickly scoop them up before anyone else can snaffle them.\n" );
        tell_room( environment( this_object() ),
            player->one_short() + " deftly scoops some coins from the tray at "
            "the bottom of " + my_short() + ".\n", ({player}) );
        this_object()->adjust_money( -(_prizes[ a1 ]) );
        _busy = 0;
        return;
    }
    tell_object( player,
        "You didn't win.  Why not have another go and attempt to recoup your "
        "losses?\n" );
    _busy = 0;
}/*void rollem() */


/** Returns the chances for each image in the order: albatross, frog, hippo,
 * turtle, cabbage.
 * @return an array with the chances
 */
int* query_chances() {
    int* tmp = ({ });
    tmp += ({ _chances[0] });
    tmp += ({ _chances[1] - _chances[0] });
    tmp += ({ _chances[2] - _chances[1] });
    tmp += ({ _chances[3] - _chances[2] });
    tmp += ({ _chances[4] - _chances[3] });
    return tmp;
} /* int* query_chances() */


/** This function returns the number of coins for each image.  The elements are
 * in the order: albatross, frog, hippo, turtle, cabbage, jackpot.
 * @return the array of numbers
 */
int* query_prizes() {
    return _prizes;
} /* int* query_prizes() */


/** Returns the coin-type for use with the bandit.
 * @return the name of the coin
 */
string query_coin_type() {
    return _coin;
} /* string query_coin_type() */


/** @ignore */
string my_short() {
    return this_object()->the_short();
} /* string my_short() */


/** @ignore */
int do_read_dial() {
    string tmp =
        "Stake        : 1 " + _coin_pl + "\n"
        "3x Albatross : " + _prizes[0] + " " + _coin_pl + "\n"
        "3x Frog      : " + _prizes[1] + " " + _coin_pl + "\n"
        "3x Hippo     : " + _prizes[2] + " " + _coin_pl + "\n"
        "3x Turtle    : " + _prizes[3] + " " + _coin_pl + "\n"
        "3x Cabbage   : " + _prizes[4] + " " + _coin_pl + "\n"
        "JACKPOT      : " + _prizes[5] + " " + _coin_pl + "\n";
    this_player()->add_succeeded_mess( this_object(),
        ({tmp, "$N read$s the dial on $D.\n"}), ({ }) );
    return 1;
} /* int do_read_dial() */


// --- END [/mnt/home2/grok/lib/std/room/furniture/inherit/one_armed_bandit_inherit.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/furniture/inherit/document_handler.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/furniture/inherit/document_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629215   Available: 13576569
Inodes: Total: 5242880    Free: 4960135
11323 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/furniture/inherit/document_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629215   Available: 13576569
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is an inheritable for a document manager.  It allows the owner
 * to put a bunch of different documents into the system with a name.
 * They can then be retrieved by others.
 * @author Pinkfish
 * @started Tue Jan 15 13:25:26 PST 2002
 */

#include <move_failures.h>
#include <nroff.h>
#include <room/newspaper.h>
#include <room/document_handler.h>

#define TAG "document__h"

class document {
   string title;
   string fname;
   string added_by;
   int time_added;
   int type;
}

private mapping _documents;
private int _next_doc_id;

string query_save_dir();
void save_me();
int is_open_for(string type, string name);
void add_auto_load_value(mapping map, string tag, string name, mixed value);
mixed query_auto_load_value(mapping map, string tag, string name);

/** @ignore yes */
void create() {
   _documents = ([ ]);
}

/**
 * This method returns the file name of the specified document.
 * @param id the id of the document
 * @return the file name of the document, 0 on failure
 */
string query_document_file_name(string id) {
   if (_documents[id]) {
      return query_save_dir() + "/" + _documents[id]->fname;
   }
   return 0;
} /* query_document_file_name() */

/**
 * This method loads up the specified document from the list of
 * documents.  This returns the data off the disk directly, without any
 * processing.
 * @param id the id of the document
 * @return the document string
 */
string query_document_data(string id) {
   string fname;

   fname = query_document_file_name(id);
   if (fname) {
      return unguarded( (: read_file($(fname)) :) );
   }
   return 0;
} /* query_document_data() */

/**
 * This checks to see if the document exists in the repository.
 * @param id the id to check
 */
int is_document(string id) {
   return _documents[id] != 0;
} /* is_document() */

/**
 * This method will convert the data in the file into a readable format
 * (on the mud).
 * @param id the id of the document
 * @return the document in a readable format
 */
string query_document_readable(string id) {
   string fname;
   string text;

   fname = query_document_file_name(id);
   if (fname) {
      switch (_documents[id]->type) {
      case DOCUMENT_PLAIN :
         text = unguarded( (: read_file($(fname)) :) );
         break;
      case DOCUMENT_HTML :
         text = unguarded( (: NROFF_HAND->cat_file($(fname) + ".nroff", 1) :) );
         if (!text) {
            // Make the html output.
            text = unguarded( (: read_file( $(fname)) :) );
            if (text) {
               text = NEWSPAPER_HANDLER->convert_html(text);
               unguarded( (: write_file($(fname) + ".proc", $(text), 1) :) );
               if (unguarded( (: NROFF_HAND->create_nroff($(fname) + ".proc",
                           $(fname) + ".nroff")
:) )) {
                  text = unguarded( (: NROFF_HAND->cat_file($(fname) +
                                                            ".nroff") :) )
;
               } else {
                  text = "Unable to make nroff file.\n";
               }
            } else {
               text = "Unable to read the file, opps!\n";
            }
         }
         break;
      }
   }
   return text;
} /* query_document_readbale() */

/**
 * This method returns the text of the document in html format.
 * @param id the document id
 * @return the text of the document in html
 */
string query_document_html(string id) {
   string fname;
   string text;

   fname = query_document_file_name(id);
   if (fname) {
      switch (_documents[id]->type) {
      case DOCUMENT_PLAIN :
         text = unguarded( (: read_file($(fname)) :) );
         text = replace(fname, ({ "&", "&amp;", "<", "&lt;", ">", "&gt;",
                                  " ", "&nbsp;", "\n", "<br>" }) );
         break;
      case DOCUMENT_HTML :
         text = unguarded( (: read_file($(fname)) :) );
         if (!text) {
            // Make the html output.
            text = unguarded( (: read_file( $(fname)) :) );
            if (text) {
               text = NEWSPAPER_HANDLER->convert_html(text);
               unguarded( (: write_file($(fname) + ".proc", $(text), 1) :) );
               if (unguarded( (: NROFF_HAND->create_nroff($(fname) + ".proc",
                           $(fname) + ".nroff")
:) )) {
                  text = unguarded( (: NROFF_HAND->cat_file($(fname) +
                                                            ".nroff") :) )
;
               } else {
                  text = "Unable to make nroff file.\n";
               }
            } else {
               text = "Unable to read the file, opps!\n";
            }
         }
         break;
      }
   }
   return text;
} /* query_document_html() */

/**
 * This method updates the text for the specified document.
 * @param id the document id to update
 * @param text the new text for the document
 */
void update_document_text(string id, string text) {
   string fname;

   fname = query_document_file_name(id);
   if (fname) {
      unguarded( (: write_file($(fname), $(text), 1) :));
   }
} /* update_document_text() */

/** 
 * This method deletes a document from the system.
 * @param id the id of the document to delete
 */
void delete_document(string id) {
   string fname;

   fname = query_document_file_name(id);
   if (fname) {
      unguarded( (: rm($(fname) + ".proc") :));
      unguarded( (: rm($(fname) + ".nroff.o") :));
      unguarded( (: rm($(fname)) :));
      map_delete(_documents, id);
      save_me();
   }
} /* delete_document() */

/**
 * This method adds a document into the repository.
 * @param title the title of the document
 * @param text the text of the document
 * @param person the person that added the document
 * @param type the type of the document
 * @return the new id of the document
 */
string add_document(string title, string text, string person, int type) {
   class document bing;
   string id;

   id = _next_doc_id + "";
   bing = new(class document);
   bing->title = title;
   bing->added_by = person;
   bing->type = type;
   bing->time_added = time();
   bing->fname = id + ".txt";
   _next_doc_id++;
   _documents[id] = bing;
   update_document_text(id, text);
   save_me();
   return id;
} /* add_document() */

/**
 * This command lists all the documents in the current set.
 */
int do_list() {
   string ret;
   class document info;
   string id;

   if (!is_open_for("document_view", this_player()->query_name())) {
      add_failed_mess("You cannot list documents on $I.\n",
                      ({ this_object() }));
      return 0;
   }

   if (!sizeof(_documents)) {
      add_failed_mess("Cannot find any documents to list on $I.\n",
                      ({ this_object() }));
      return 0;
   }
   ret = "";
   foreach (id, info in _documents) {
      ret += "$I$3=" + id + ") " + info->title + " [" + info->added_by +
             "] - " + ctime(info->time_added)[4..9] + " " + 
             ctime(info->time_added)[<4..] + "\n";
   }
   write("$P$Documents$P$" + ret);
   add_succeeded_mess(({ "", "$N lists the documents in $I.\n" }),
                      ({ this_object() }));
   return 1;
} /* do_list() */

/**
 * This method displays one document.
 */
int do_display(string id) {
   string ret;
   class document info;

   if (!is_open_for("document_view", this_player()->query_name())) {
      add_failed_mess("You cannot view documents on $I.\n",
                      ({ this_object() }));
      return 0;
   }

   ret = query_document_readable(id);
   if (!ret) {
      add_failed_mess("Cannot find the document " + id + " on $I.\n",
                      ({ this_object() }));
      return 0;
   }

   info = _documents[id];

   ret = "Document #" + id + " " + info->title + " [" + info->added_by +
             "] - " + ctime(info->time_added)[4..9] + " " + 
             ctime(info->time_added)[<4..] + "\n" + ret;

   write("$P$Document " + id + "$P$" + ret);
   add_succeeded_mess(({ "", "$N reads a document from $I.\n" }),
                      ({ this_object() }));
   return 1;
} /* do_display() */

/**
 * This method adds in a document.
 */
int do_add_document(string title, int type) {
   if (!is_open_for("document_add", this_player()->query_name())) {
      add_failed_mess("You cannot add documents to $I.\n",
                      ({ this_object() }));
      return 0;
   }

   this_player()->do_edit("", "finish_edit", this_object(), 0,
                          ({ title, type }));
   return 1;
} /* do_add_document() */

/** @ignore yes */
void finish_edit(string str, mixed* args) {
   string title;
   int type;

   title = args[0];
   type = args[1];
   if (!str || str == "") {
      write("Abandoning adding the document.\n");
      return ;
   }

   add_document(title, str, this_player()->query_cap_name(), type);
   write("Added the document into the collection.\n");
} /* finish_edit() */

/**
 * This method deletes a document from the repository.,
 */
int do_delete_document(string id) {
   if (!is_open_for("document_delete", this_player()->query_name())) {
      add_failed_mess("You cannot delete documents from $I.\n",
                      ({ this_object() }));
      return 0;
   }

   if (!is_document(id)) {
      add_failed_mess("The document " + id + " does not exist in $I.\n",
                      ({ this_object() }));
      return 0;
   }
   delete_document(id);
   add_succeeded_mess("$N delete$s a document from $I.\n", ({ this_object() }));
   return 1;
} /* do_delete_document() */

/** @ignore yes */
mapping query_dynamic_auto_load(mapping map) {
   if (file_name(this_object()) != "/std/room/furniture/inherit/document_handler" && map) {
      add_auto_load_value(map, TAG, "documents", _documents);
      add_auto_load_value(map, TAG, "doc id", _next_doc_id);
      return map;
   }
} /* query_dynamic_auto_load() */

/** @ignore yes */
void init_dynamic_arg(mapping map) {
   if (file_name(this_object()) != "/std/room/furniture/inherit/document_handler" && map) {
      _documents = query_auto_load_value(map, TAG, "documents");
      if (!_documents) {
         _documents = ([ ]);
      }
      _next_doc_id = query_auto_load_value(map, TAG, "doc id");
   }
} /* init_dynamic_arg() */

/**
 * This is the init to call if this is used inside an object.
 */
void init_object() {
   add_command("list", "documents [from] <direct:object>", (: do_list() :));
   add_command("view", "document <string'id'> [from] <direct:object>",
                (: do_display($4[0]) :));
   add_command("add", "documents {html|plain} called <string:quoted'title'> to <direct:object>",
               (: do_add_document($4[1], ($4[0] == "html"?DOCUMENT_HTML:DOCUMENT_PLAIN)) :));

   add_command("delete", "document <string'id'> [from] <direct:object>",
                (: do_delete_document($4[0]) :));
} /* init_object() */

/**
 * This is the init to call if this is used inside a room.
 */
void init_room() {
   add_command("list", "[documents]", (: do_list() :));
   add_command("view", "[document] <string'id'>",
                (: do_display($4[0]) :));
   add_command("add", "[document] {html|plain} called <string:quoted'title'>",
               (: do_add_document($4[1], ($4[0] == "html"?DOCUMENT_HTML:DOCUMENT_PLAIN)) :));
   add_command("delete", "[document] <string'id'>",
                (: do_delete_document($4[0]) :));
} /* init_room() */
// --- END [/mnt/home2/grok/lib/std/room/furniture/inherit/document_handler.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/furniture/fuel_inherit.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/furniture/fuel_inherit.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629212   Available: 13576566
Inodes: Total: 5242880    Free: 4960135
3548 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/furniture/fuel_inherit.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629212   Available: 13576566
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 *  You need a setup() in the inheriting fuel item.
 *  From here set_name for you fuel and whatever else you want.
 *  Also make sure that you have set a weight for the item as this is
 *  what determines how long it burns for.
 *
 * -> NOTE: <-
 *  You set the description for the fuel by using set_shorts and set_longs
 *  (with an s on the end) The argument to these functions must be an ARRAY.
 *  The first element is the normal description of the fuel, when it hasn't 
 *  been burnt. The rest describe the fuel after it has been burnt a little, 
 *  then a bit more...until finally its burnt out. There can be as 
 *  many elements in this description array as you want.
 *  See /obj/furnitures/misc/log.c for an example of some fuel.
 *  @author Aquilo
 */

inherit "/std/object";

private nosave int _amount; // The percentage amount of burnable material left
            // 0 - The log has been burnt to a crisp, no good as fuel anymore
            // 100 - All its weight is available to be burnt

private nosave string *_shorts;
private nosave string *_longs;

string fuel_short();
string fuel_long();

void create(){
   ::create();

   if(!_amount){
     _amount = 100;
   }
   set_short( (: fuel_short :) );
   set_long( (: fuel_long :) );
   add_property("no recycling", 1);
   add_property("fuel", 1);
} /* create() */

/**
 * This method sets the amount of fuel left.
 * @param i the amount of fuel left
 */
void set_amount_left(int i){  _amount = i;  }

/**
 * Thie method changes the amount of fuel left.
 * @param i amount to adjust the fuel by
 */
void adjust_amount_left(int i){  _amount += i;  }

/**
 * This method returns the amount of fuel left.
 * @return the amount of fuel left
 */
int query_amount_left(){  return _amount;  }

/**
 * This method sets the array of shorts to use for the various amounts
 * of the fuel left.  The number of shorts must match the number of
 * descriptions.
 * @param desc the shorts for the fuel left
 */
void set_shorts(string *desc){  _shorts = desc;  }

/**
 * This method sets the array of descriptions to use for the various amounts
 * of the fuel left.  The number of shorts must match the number of
 * descriptions.
 * @param desc the descriptions for the fuel left
 */
void set_longs(string *desc){  _longs = desc;  }

/**
 * This method returns the short description of the fuel.  It looks
 * of the description properly from the array of shorts.
 * @return the current short of the fuel
 */
string fuel_short(){
   int i;
   int x;

   x = sizeof(_shorts);
   for(i = 1; i <= x; i++){
      if( (_amount + 1) > 100 - ( i * 100 / x ) ){
         return _shorts[(i-1)];
      }
   }
   // Should never get here but return something just in case
   return "fuel";
} /* fuel_short() */

/**
 * This method returns the description of the fuel.  It looks
 * of the description properly from the array of longs.
 * @return the current long of the fuel
 */
string fuel_long(){
   int i;
   int x;

   x = sizeof(_longs);

   for(i = 1; i <= x; i++){
      if( ( _amount + 1 ) > ( 100 - ( i * 100 / x )) ){
         return _longs[(i-1)];
      }
   }
   // Should never get here but return something just in case
   return "fuel";
} /* fuel_long() */

/** @ignore yes */
mixed query_dynamic_auto_load() {
   return ([ "::" : ::query_dynamic_auto_load(),
             "amount" : _amount
          ]);
/** @ignore yes */
} /* query_dynamic_auto_load() */

void init_dynamic_arg(mapping arg) {
   _amount = arg[ "amount" ];
   ::init_dynamic_arg(arg["::"]);
} /* init_dynamic_arg() */
// --- END [/mnt/home2/grok/lib/std/room/furniture/fuel_inherit.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/furniture/clock.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/furniture/clock.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629211   Available: 13576565
Inodes: Total: 5242880    Free: 4960135
2470 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/furniture/clock.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629211   Available: 13576565
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: clock.c,v 1.6 2001/06/01 20:54:45 ceres Exp $
 *
 *
 */
/**
 * The base file for clocks in player houses.
 * @author Ceres
 */

#include <move_failures.h>
#include <position.h>

inherit "/obj/clock";
inherit "/std/room/furniture/inherit/furniture_base";

/** @ignore yes */
void chime(string mess) {
  int *co_ords;

  if(environment(this_object())) {
    co_ords = (int *)environment(this_object())->query_co_ord();
    "/obj/handlers/broadcaster"->broadcast_event(users(), co_ords,
                                                 mess, 20, 1, 0 );
    tell_room(environment(this_object()), mess);
  }
} /* chime() */



void create() {
   do_setup++;
   clock::create();
   add_alias( "furniture" );
   add_plural( "furniture" );
   set_opaque();
   furniture_base::create();

   do_setup--;
   if ( !do_setup ) {
     this_object()->setup();
   }
} /* create() */

private int do_real_move(mixed dest, string messin, string messout) {
   return clock::move(dest, messin, messout);
} /* do_real_move() */

/** @ignore yes */
/* Furniture is much harder to carry than just its weight, therefore we
 * multiply its weight by 5 to determine if someone can carry it.
 */
varargs int move( mixed dest, string messin, string messout ) {
  int i, t, f;
  object from;

  if(stringp(dest)) {
    dest = find_object(dest);
  }

  if (!move_check(dest)) {
     write(the_short() + " resists being picked up and shocks you slightly.\n");
     return MOVE_INVALID_DEST;
  }

  if(!dest) {
    return MOVE_INVALID_DEST;
  }

  if(living(dest)) {
    t = (int)this_object()->query_complete_weight() * 2;
    if(!(dest->add_weight(t))) {
      return MOVE_TOO_HEAVY;
    }
    debug_printf("Added %d", t);
  }

  i = ::move(dest, messin, messout);

  if(i != MOVE_OK) {
    dest->add_weight(-t);
    return i;
  }

  from = environment();
  if(from && living(from)) {
    f = (int)this_object()->query_complete_weight() * 2;
    from->add_weight(-f);
  }

  return i;
} /* move() */

/** @ignore yes
 * This stops people dragging items away if they aren't allowed to.
 */
int get(mixed dest) {
  if(!move_check(dest)) {
    write("You feel it would be wrong to take " + the_short() + ".\n");
    return 2;
  }
  return ::get(dest);
}

/** @ignore yes */
mixed query_static_auto_load() {
  if ( base_name(this_object()) + ".c" == __FILE__ ) {
    return int_query_static_auto_load();
  }
  return ([ ]);
} /* query_static_auto_load() */
// --- END [/mnt/home2/grok/lib/std/room/furniture/clock.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/furniture/curtains.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/furniture/curtains.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629210   Available: 13576564
Inodes: Total: 5242880    Free: 4960135
4098 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/furniture/curtains.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629210   Available: 13576564
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: curtains.c,v 1.6 2001/06/01 21:18:40 ceres Exp $
 *
 *
 */
/**
 * This is a furniture item for making all kinds of furniture.
 */
#include <move_failures.h>
#include <position.h>

inherit "/std/room/furniture/basic";

private nosave object _window;
private string _window_id;
private string _window_old_long;

void create() {
  do_setup++;
  ::create();
  add_alias( "furniture" );
  add_plural( "furniture" );
  set_opaque();
  if ( !query_property( "shop type" ) ) {
    add_property( "shop type", "furniture" );
  }
  set_allowed_room_verbs((["hanging" : "hangs" ]));
  do_setup--;
  if ( !do_setup ) {
    this_object()->setup();
  }
}

void init() {
  if(!_window_id) {
    this_player()->add_command("hang", this_object(),
        "<direct:object> [on|at] <indirect:object:here>");
  }
  this_player()->add_command("open", this_object(), "<direct:object>");
  this_player()->add_command("close", this_object(), "<direct:object>");
}

int do_open() {
  if(!_window)
    _window = environment(this_object())->query_door_control(_window_id);

  if(!_window_id || !_window) {
    this_player()->add_failed_mess(this_object(),
        "$D aren't hanging at a window.\n");
    return 0;
  }

  if(_window->query_transparent()) {
    this_player()->add_failed_mess(this_object(),
        "$D are already open.\n");
    return 0;
  }

  _window->set_transparent();
  this_player()->add_succeeded_mess(this_object(), "$N $V $D.\n", ({}));
  return 1;
}

int do_close() {
  if(!_window)
    _window = environment(this_object())->query_door_control(_window_id);

  if(!_window_id || !_window) {
    this_player()->add_failed_mess(this_object(),
        "$D aren't hanging at a window.\n");
    return 0;
  }

  if(!_window->query_transparent()) {
    this_player()->add_failed_mess(this_object(),
        "$D are already closed.\n");
    return 0;
  }

  _window->reset_transparent();
  this_player()->add_succeeded_mess(this_object(), "$N $V $D.\n", ({}));
  
  return 1;
}

int do_hang(mixed *in_dir, string direct, string indirect, mixed *args) {
  if(member_array("window", in_dir[0]->parse_command_id_list()) == -1) {
    this_player()->add_failed_mess(this_object(),
        "You can only $V $D at windows.\n",
        ({ }));
    return 0;
  }

  if(this_object()->move(environment(this_player())) != MOVE_OK) {
    this_player()->add_failed_mess(this_object(),
        "You seem to be unable to $V $D "
        "at $I.\n", ({ in_dir[0] }));
    return 0;
  }
  this_object()->add_property("current room hidden", 1);

  _window_id = in_dir[0]->query_my_id();
  _window_old_long = in_dir[0]->query_long();
  
  in_dir[0]->set_long(in_dir[0]->query_long()+"It has " +
                      this_object()->query_short() +
                      " hanging round it.\n");
  event(environment(), "save", this_object());

  this_player()->add_succeeded_mess(this_object(),
                                   "$N $V $D at $I.\n", ({ in_dir[0] }));
  return 1;
}

/** @ignore yes
 * Reset the windows desc and opacity when the curtains are removed.
 */
void removed() {
  this_object()->remove_property("current room hidden");
  if(!_window)
    _window = environment(this_object())->query_door_control(_window_id);
  _window->set_long(_window_old_long);
  _window->set_transparent();
  _window_id = 0;
}

/**
 * This method will return true if the item is an item of furniture.
 * @return always returns true
 */
int query_furniture() { return 1; }

/** @ignore yes */
mixed query_static_auto_load() {
  if ( base_name(this_object()) + ".c" == __FILE__ )
    return int_query_static_auto_load() +
      ([ "window" : _window_id,
       "window_old_long" : _window_old_long ]);
  return ([ "window" : _window_id,
          "window_old_long" : _window_old_long ]);
}

/** 
 * @ignore yes
 */
void init_static_arg( mapping map ) {
  if ( !mapp( map ) ) {
    return;
  }
  ::init_static_arg(map);

  if ( !undefinedp( map[ "window" ] ) )
    _window_id = map["window"];
  if(!undefinedp(map["window_old_long"]))
    _window_old_long = map["window_old_long"];
}

// --- END [/mnt/home2/grok/lib/std/room/furniture/curtains.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/furniture/fireplace_inherit.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/furniture/fireplace_inherit.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629209   Available: 13576563
Inodes: Total: 5242880    Free: 4960135
42 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/furniture/fireplace_inherit.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629209   Available: 13576563
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/room/furniture/fireplace";

// --- END [/mnt/home2/grok/lib/std/room/furniture/fireplace_inherit.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/furniture/surface.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/furniture/surface.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629209   Available: 13576563
Inodes: Total: 5242880    Free: 4960135
9913 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/furniture/surface.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629209   Available: 13576563
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: surface.c,v 1.17 2002/11/18 01:46:35 ceres Exp $
 *
 *
 */
/**
 * This is a furniture item for making all kinds of furniture.
 */
#include <move_failures.h>
#include <player.h>

inherit "/std/object";
inherit "/std/basic/cute_look";
inherit "/std/basic/item_chat";
inherit "/std/room/furniture/inherit/furniture_base";

private nosave int _loc_weight, _max_weight;
private nosave string *_shadows;
private nosave object _player;
private nosave string *_aliases;
private nosave int _use_internals;

//#define DEBUG

void create() {
  do_setup++;
  furniture_base::create();
  object::create();
  
  add_alias( "furniture" );
  add_plural( "furniture" );
  set_opaque();
  
  do_setup--;
  if ( !do_setup ) {
    this_object()->setup();
  }
  // Don't respond to 'get all'
  set_no_all(1);
} 

/**
 * @ignore yes
 */
void init() {
  string alias;

  if(_aliases)
    foreach(alias in _aliases) {
      add_command(alias, "<indirect:object:me> {in|on|into} <indirect:object>",
                  (: "/cmds/living/put"->cmd($1, $3, $4) :) );
    }
  ::init();
}

/**
 * Set aliases for 'put' for this object.  This allows you to setup an item
 * so that things can be hung from it, or stood on it or somesuch.
 *
 * @param aliases aliases for the verb 'put'.
 */
void set_put_aliases(string *aliases) {
  _aliases = aliases;
}

/**
 * This sets the flag to say if the object will allow things on it to be
 * used.  This is useful for tables and so on.
 * @param allow 1 if they are allowed to be used, 0- if not
 */
void set_allow_use_internals(int allow) {
   _use_internals = allow;
} /* set_allow_use_internals() */

/**
 * This method returns the flag to say if the object will allow things on it
 * to be used.
 * @return 1 if it is allowed, 0 if not
 */
int query_allow_use_internals() {
   return _use_internals;
} /* query_allow_use_internals() */

/** @ignore yes */
/* Furniture is much harder to carry than just its weight, therefore we
 * multiply its weight by 5 to determine if someone can carry it.
 */
varargs int move( mixed dest, string messin, string messout ) {
  int i, w;
  object from;

  if (!move_check(dest)) {
     write(the_short() + " resists being picked up and shocks you slightly.\n");
     return MOVE_INVALID_DEST;
  }

  w = (int)this_object()->query_complete_weight() * 5;
  if ( from = environment() ) {
    from->add_weight( -w );
  }
  if(!dest) {
    return MOVE_INVALID_DEST;
  }

  if (!( dest->add_weight( w ) ) ) {
    if ( from ) {
      from->add_weight( w );
    }
    return MOVE_TOO_HEAVY;
  }
  if ( stringp( dest ) ) {
    dest = find_object( dest );
  }
  i = ::move( dest, messin, messout );
  if ( i != MOVE_OK ) {
    if ( from ) {
      from->add_weight( w );
    }
    dest->add_weight( -w );
  } else {
    if (_use_internals) {
      if (from) {
        from->remove_use_internal_object(this_object());
      }
      dest->add_use_internal_object(this_object());
    }
    if (query_light_needs_inform()) {
      if ( from ) {
        inform_of_light_level_change(from);
      }
      inform_of_light_level_change(dest);
    }
  }
  return i;
} /* move() */

/** @ignore yes
 * This stops people dragging items away if they aren't allowed to.
 */
int get(mixed dest) {
  if(!move_check(dest)) {
    write("You feel it would be wrong to take " + the_short() + ".\n");
    return 2;
  }
  return ::get(dest);
}

/**
 * @ignore yes
 * Makes sure furniture is removed from the save file
 * when its removed from this room.
 */
int test_remove(object thing, int flag, mixed dest) {
  mixed *stuff;
  object thief;
  
  if(environment() && this_player()) {
    thief = this_player();
    if(thief->query_caster())
      thief = find_player(thief->query_caster());
    else if(thief->query_owner())
      thief = thief->query_owner();
    
    stuff = thing->query_property("dropped");
    
    /*
     * It's theft if the item is being removed by someone other than the
     * occupier and someone other than the person who dropped it.
     */
    if(function_exists("test_occupier", environment()) &&
       !environment()->test_occupier(thief->query_name()) &&
       (!sizeof(stuff) || stuff[0] != thief->query_name()) &&
       thief && environment(thief)) {
      event(environment(thief), "theft", thief, this_object(), ({ thing }));
    }
    
#ifdef DEBUG
    if(base_name(environment()) != "/room/rubbish")
      log_file(base_name(environment()) + ".log",
               "%s %s moved from %s to %s.\n", ctime(time())[4..18],
               thing->query_short(), this_object()->query_short(),
               dest->query_short());
#endif
    event(environment(), "save");
  }
  
  return 1;
}

/** @ignore yes */
int test_add( object thing, int flag ) {
  if(environment())
    event(environment(), "save");

#ifdef DEBUG
  if(environment() && base_name(environment()) != "/room/rubbish")
    log_file(base_name(environment()) + ".log",
             "%s %s put on %s by %s.\n", ctime(time())[4..18],
             thing->query_short(), this_object()->query_short(),
             this_player() ? this_player()->query_name() : "Unknown");
#endif

  return 1;
} /* test_add() */

void set_max_weight(int arg) { _max_weight = arg; }
int query_max_weight() { return _max_weight; }
int query_loc_weight() { return _loc_weight; }
int query_has_surface() { return 1; }

/** @ignore yes */
void update_loc_weight() {
  int i;
  object *contents;
  _loc_weight = 0;
  contents = all_inventory( this_object() );
  for ( i = 0; i < sizeof( contents ); i++ )
    _loc_weight += (int)contents[ i ]->query_complete_weight();
} /* update_loc_weight() */

int query_complete_weight() {
  return ::query_complete_weight() + query_loc_weight();
} /* query_complete_weight() */

int add_weight( int n ) {
  if ( !_max_weight ) return 1;
  if ( n + _loc_weight > _max_weight ) return 0;
  if ( !environment() ) {
    _loc_weight += n;
    return 1;
  }
  if ( !( environment()->add_weight( n ) ) ) return 0;
  _loc_weight += n;
  return 1;
} /* add_weight() */

int transfer_all_to(object dest) {
  object *ob;
  int i;

  ob = all_inventory(this_object());
  for (i=0;i<sizeof(ob);i++)
    ob[i]->move(dest);
  if (first_inventory(this_object())) return 0;
  return 1;
} /* transfer_all_to() */

string long( string word, int dark ) {
   object *things;
   things = (object *)this_object()->find_inv_match( "all", this_player() );
   if ( !sizeof( things ) )
      return object::long( word, dark ) +"There is nothing on "+
            the_short() +".\n";
   return object::long( word, dark ) + query_contents( "On " +
            the_short() +" "+ ( sizeof( things ) == 1 ? "is " :
            "are " ), things );
} /* long() */

object *find_inv_match( string words, object looker ) {
   int i;
   object *things;

   things = all_inventory( this_object() );
   for ( i = sizeof( things ) - 1; i > -1; i-- ) {
      if ( !things[ i ]->short( 0 ) ) {
         things = delete( things, i, 1 );
         continue;
      }
      if ( !looker )
         continue;
      if ( !things[ i ]->query_visible( looker ) )
         things = delete( things, i, 1 );
   }
   return things;
} /* find_inv_match() */

void set_player( object thing ) { _player = thing; }
object query_player() { return _player; }

mixed stats() {
  return ::stats() + ({
    ({ "loc_weight", query_loc_weight(), }),
    ({ "max_weight", query_max_weight(), }),
  });
} /* stats() */

mapping int_query_static_auto_load() {
  return ([
    "::" : ::int_query_static_auto_load(),
    "max weight" : _max_weight,
    "allowed positions" : query_allowed_positions(),
  ]);
} /* int_query_static_auto_load() */

mapping query_dynamic_auto_load() {
  mixed inventory;

  // Try the main player object.
  if (!inventory) {
    catch(inventory = PLAYER_OB->
        create_auto_load( all_inventory( this_object() ) ) );
  }

  return ([ "::" : ::query_dynamic_auto_load(),
            "inv" : inventory,
            "bonded" : query_bonded()
         ]);
} /* query_dynamic_auto_load() */

/**
 * This method handles moving objects into the inventory from an auto
 * load.  This should be over ridden by things inheriting us to
 * make sure that the objects can be moved into the inventory.  It
 * should handle the bypassing of open/close/locked etc flags.
 * @param ob the object to move into ourselves
 */
int handle_restore_inventory(object ob) {
  return (int)ob->move(this_object());
} /* handle_restore_inventory() */

void init_dynamic_arg( mapping bing ) {
  function f;

  if ( bing[ "::" ] ) {
    ::init_dynamic_arg( bing[ "::" ] );
  }
  if ( bing[ "inv" ] ) {
    f = (: handle_restore_inventory($1) :);
    if (_player) {
      _player->load_auto_load_to_inventory( bing["inv"], this_object(),
                                            _player, f);
    } else {
      PLAYER_OB->load_auto_load_to_inventory( bing["inv"], this_object(),
                                              this_player(), f);
    }
  }
  set_bonded(bing["bonded"]);
} /* init_dynamic_arg() */

void init_static_arg(mapping bing) {
  if (bing["::"]) {
     ::init_static_arg(bing["::"]);
  }
  if (!undefinedp(bing["max weight"])) {
    _max_weight = bing["max weight"];
  if(!undefinedp(bing["allowed_positions"]))
    set_allowed_positions(bing["allowed_positions"]);
  }
} /* init_static_arg() */

/** @ignore yes */
mixed query_static_auto_load() {
  if ( base_name(this_object()) + ".c" == __FILE__ )
    return int_query_static_auto_load();
  return ([ ]);
} /* query_static_auto_load() */

void dest_me() {
  int i;
  object shadow;

  for ( i = 0; i < sizeof( _shadows ); i++ ) {
    if ( shadow = find_object( _shadows[ i ] ) ) {
      shadow->destruct_shadow( shadow );
    }
  }
  all_inventory()->dest_me();
  object::dest_me();
} /* dest_me() */

/** @ingore yes */
string query_help_file_directory() {
   return "/doc/furniture/";
} /* query_help_file_directory() */
// --- END [/mnt/home2/grok/lib/std/room/furniture/surface.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/furniture/poker.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/furniture/poker.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629206   Available: 13576560
Inodes: Total: 5242880    Free: 4960135
53535 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/furniture/poker.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629206   Available: 13576560
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
// Pinkfish
// Started Wed May 30 21:37:15 PDT 2001

inherit "/std/room/furniture/games/card_base";
inherit "/std/room/furniture/games/multiplayer_base";
inherit "/std/room/furniture/commercial";

#include <money.h>
#include <room/card_base.h>

// The hand types.
#define HAND_TYPE_HIGH_CARD  1
#define HAND_TYPE_PAIR       2
#define HAND_TYPE_TWO_PAIR   3
#define HAND_TYPE_THREE      4
#define HAND_TYPE_STRAIGHT   5
#define HAND_TYPE_FLUSH      6
#define HAND_TYPE_FULL_HOUSE 7
#define HAND_TYPE_FOUR       8
#define HAND_TYPE_STRAIGHT_FLUSH 9

#define POKER_STATE_ANTE      0
#define POKER_STATE_PAID_ANTE 1
#define POKER_STATE_DEALT     2
#define POKER_STATE_BET       3
#define POKER_STATE_DISCARD   4
#define POKER_STATE_AFTER_DISCARD   5
#define POKER_STATE_FINAL_BET 6
#define POKER_STATE_FOLDED    7
#define POKER_STATE_END       8

#define TIE -1

class hand_type {
   int hand_type;
   class playing_card* kickers;
   class playing_card duplicate_1;
   class playing_card duplicate_2;
   class playing_card high_card;
}

class player_data {
   class playing_card* hand;
   class hand_type hand_type;
   int bet;
   int state;
}

#define BOARD_TAG "poker"

//
// This gives an estimated return on the payment.  For example 50%
// return would mean you get back approximately 50% of your money on
// average
//
private int _return;
private int _ante_amount;
private int _ante_house;
private int _house_cut;
private int _min_bet;
private int _max_bet;
private int _current_bet;
private int _pot;
private int _finished;
private int _poker_phase;
private int _turn_timeout;
private int _draw_round;
private int _max_draw_rounds;
private class playing_card* _deck;
private class playing_card* _discard;
private mapping _player_stats;

int query_hand_value(class playing_card* cards);
class hand_type query_hand_type(class playing_card* hand);

void create() {
   multiplayer_base::create();

   set_minimum_needed(2);
   add_help_file("poker");
   _ante_house = 400;
   _ante_amount = 400;
   _min_bet = 400;
   _max_bet = 1200;
   _max_draw_rounds = 1;
   _player_stats = ([ ]);
   set_shop_use_types(({ "poker" }));

   commercial::create();

   set_commercial_type("gambling");
   set_commercial_name("poker");
} /* create() */

string query_hand_type_string(class hand_type bing) {
   string ret;

   switch (bing->hand_type) {
   case HAND_TYPE_FULL_HOUSE :
      ret = "Full house";
      break;
   case HAND_TYPE_THREE :
      ret = "Three of a kind";
      break;
   case HAND_TYPE_FLUSH :
      ret = "Flush";
      break;
   case HAND_TYPE_STRAIGHT :
      ret = "Straight";
      break;
   case HAND_TYPE_STRAIGHT_FLUSH :
      ret = "Straight flush";
      break;
   case HAND_TYPE_PAIR :
      ret = "Pair";
      break;
   case HAND_TYPE_FOUR :
      ret = "Four of a kind";
      break;
   case HAND_TYPE_TWO_PAIR :
      ret = "Two pairs";
      break;
   case HAND_TYPE_HIGH_CARD :
      ret = "High card " + query_card_string(bing->high_card);
      break;
   default :
      ret = "Nothing";
      break;
   }
   return ret;
} /* query_hand_type_string() */

/**
 * This method shows the current status of the cards.
 * @param id the id to show the status for
 * @return the status of the cards
 */
string query_card_status(string id) {
   string id_bing;
   string ret;
   string* not_playing;
   class player_data data;
   string* womble;
   string place;
   int left;

   ret = "";
   not_playing = ({ });
   womble = query_player_ids();
   place = query_money_place();
   foreach (id_bing in womble) {
      if (is_person_playing(id_bing)) {
         ret += capitalize(id_bing) + " (" +
                query_player_cap_name(id_bing) + ")";
         data = query_player_data(id_bing);
         if (data) {
            if (data->state == POKER_STATE_FOLDED) {
               ret += " Folded!\n";
            } else {
               if (data->state == POKER_STATE_PAID_ANTE) {
                  ret += " (paid ante) ";
               }
               if (data->state == POKER_STATE_AFTER_DISCARD) {
                  ret += " (discarded) ";
               }
               if (data->state == POKER_STATE_BET ||
                   data->state == POKER_STATE_FINAL_BET) {
                  if (id_bing == query_current_player()) {
                     ret += " <-- Their bet ";
                  }
               }
               if (data->bet) {
                  ret += "  Current bet " + 
                         MONEY_HAND->money_value_string(data->bet, place);
                  ret += "\n";
               } else {
                  ret += "  No bet yet.\n";
               }
            }
         } else {
            ret += "\n";
         }
      } else {
         not_playing += ({ id_bing });
      }
   }

   if (sizeof(not_playing) > 1) {
      ret += query_multiple_short(map(not_playing, (: capitalize($1) :))) +
                                  " are not playing.\n";
   } else if (sizeof(not_playing) == 1) {
      ret += query_multiple_short(map(not_playing, (: capitalize($1) :))) +
                                  " is not playing.\n";
   }
   ret += "The pot is " +
          MONEY_HAND->money_value_string(_pot, place) + ".\n";
   if (is_game_started()) {
      if (_draw_round < _max_draw_rounds) {
         left = _max_draw_rounds - _draw_round;
         ret += left + " draw round" + (left>1?"s":"") + " left.\n";
      }
   }
   ret += "\n";
   if (id) {
      if (!_finished) {
         data = query_player_data(id);
         if (data && sizeof(data->hand)) {
            ret += "Your hand (" +
                   query_hand_type_string(data->hand_type) +
                   (data->state == POKER_STATE_FOLDED?" -- Folded":"") +
                   "):\n";
            if (data->state != POKER_STATE_FOLDED) {
               ret += query_hand_string(data->hand,
                                     CARD_HAND_THREE|CARD_HAND_LETTERS,
                                     this_player()->query_cols());
            }
         }
         if (_finished) {
            tell_all_players(query_player_cap_name(id) + " peeks at their hand on " +
                         the_short() + ".\n", ({ id }));
         }
      } else {
         foreach (id in query_started_player_ids()) {
            data = query_player_data(id);
            if (data && sizeof(data->hand)) {
               ret += query_player_cap_name(id);
               if (data->state == POKER_STATE_FOLDED) {
                  ret += " folded, so the cards are hidden.\n";
               } else {
                  ret += " hand (" +
                         query_hand_type_string(data->hand_type) + ":\n";
                  ret += query_hand_string(data->hand, CARD_HAND_SINGLE,
                                        this_player()->query_cols());
               }
            }
         }
      }
   }

   return ret;
}
   
/** @ignore yes */
string long(string str, int dark) {
   if (dark) {
      return ::long() +
             "It is too dark to make out the pieces on the board.\n";
   }
   return ::long() + query_card_status(find_player_id_of_person(this_player()));
} /* long() */

/**
 * See if the round has completed.
 */
int check_end_round() {
   int bet;
   string id;
   class player_data data;

   foreach (id in query_started_player_ids()) {
      data = query_player_data(id);
      if (data->state != POKER_STATE_FOLDED) {
         if (!data->bet) {
            return 0;
         } else if (!bet && data->bet) {
            bet = data->bet;
         } else if (bet != data->bet) {
            return 0;
         }
      }
   }

   if (bet) {
      call_out("complete_round", 2);
      _poker_phase = POKER_STATE_END;
      return 1;
   }
} /* check_end_round() */

/**
 * This method bounces to the next person to bid.
 */
void next_person_turn() {
   class player_data data;
   string start_id;

   start_id = query_current_player();
   do {
      increment_current_player();
      data = query_player_data(query_current_player());
   } while (data->state == POKER_STATE_FOLDED &&
            query_current_player() != start_id);
   // Only one person left...
   if (query_current_player() == start_id) {
      printf("Force end of game.\n");
      call_out("complete_round", 2, 1);
      _poker_phase = POKER_STATE_END;
   } else {
      call_out("tell_current_player", 0, "%^BOLD%^Your turn!%^RESET%^\n");
   }
} /* next_person_turn() */

/**
 * This deals cards to everyone.
 */
void deal_cards() {
   string id;
   class player_data data;

   _deck = make_deck(1, 0);
   _deck = shuffle_deck(_deck);
   foreach (id in query_currently_playing_ids()) {
      data = query_player_data(id);
      data->hand = sort_cards(_deck[0..4], 3);
      data->bet = 0;
      if (data->state != POKER_STATE_FOLDED) {
         if (!_max_draw_rounds) {
            data->state = POKER_STATE_FINAL_BET;
         } else {
            data->state = POKER_STATE_BET;
         }
      }
      data->hand_type = query_hand_type(data->hand);
      _deck = _deck[5..];
      if (query_player_object(id)) {
         tell_player(id, "Your hand:\n" +
                query_hand_string(data->hand, CARD_HAND_THREE|CARD_HAND_LETTERS,
                                  query_player_object(id)->query_cols()) +
            query_hand_type_string(data->hand_type) + ".\n");
      }
   }
   if (!_max_draw_rounds) {
      _poker_phase = POKER_STATE_FINAL_BET;
   } else {
      _poker_phase = POKER_STATE_BET;
   }
   next_person_turn();
   tell_all_players(query_player_cap_name(query_current_player()) +
                    " goes first.\n");
   //call_out("tell_current_player", 0, "%^BOLD%^Your turn!%^RESET%^\n");
   //tell_current_player("%^BOLD%^Your turn!%^RESET%^\n");
   _current_bet = 0;
} /* deal_cards() */

/** @ignore yes */
int start_game() {
   class player_data data;
   string id;

   randomise_player_numbers();
   if (!::start_game()) {
      return 0;
   }
   foreach (id in query_player_ids()) {
      data = new(class player_data);
      data->bet = 0;
      data->hand = ({ });
      data->state = POKER_STATE_ANTE;
      set_player_data(id, data);
   }
   _poker_phase = POKER_STATE_ANTE;
   _pot = 0;
   _finished = 0;
   _draw_round = 0;
   _discard = ({ });
   tell_all_players("%^BOLD%^Place your ante to start playing.%^RESET%^\n");
   return 1;
} /* start_game() */

/**
 * Checks to see if all the people playing have put in their first
 * bets.
 */
void check_for_finish_ante() {
   string id;
   class player_data data;
   object ob;

   foreach (id in query_currently_playing_ids()) {
      data = query_player_data(id);
      ob = query_player_object(id);
      if (ob && !interactive(ob)) {
         // Set them to folded.
         data->state = POKER_STATE_FOLDED;
      }
      if (ob && interactive(ob) && data->state == POKER_STATE_ANTE) {
         return ;
      }
   }

   _poker_phase = POKER_STATE_BET;
   // Move to the next state!
   call_out("deal_cards", 2);
} /* check_for_finish_ante() */

/**
 * This figures out if the card is higher than the other one or not.
 * @param card_new the new card o checxl
 * @param card_old the old card to check againt
 * @return 1 if the new card is higher, 0 if the old card is higher
 */
int is_card_higher(class playing_card card_new, class playing_card card_old) {
   if (card_new->number == card_old->number) {
      // Then it is based on suits.
      return 0;
   }

   if (card_new->number == CARD_NUMBER_ACE) {
      return 1;
   }
   if (card_old->number == CARD_NUMBER_ACE) {
      return 0;
   }
   if (card_new->number > card_old->number) {
      return 1;
   }
   return 0;
} /* is_card_higher() */

/**
 * This method returns the basic type of the hand.
 */
class hand_type query_hand_type(class playing_card* hand) {
   int high_num;
   int num;
   int id;
   int i;
   int j;
   class playing_card* tmp_hand;
   class hand_type ret_type;
   class playing_card tmp_card;

   ret_type = new(class hand_type);

   high_num = 0;
   for (i = 1; i < sizeof(hand); i++) {
      if (is_card_higher(hand[i], hand[high_num])) {
         high_num = i;
      }
   }
   ret_type->hand_type = HAND_TYPE_HIGH_CARD;
   ret_type->high_card = hand[high_num];
   //
   // First check for x of a kind.
   //
   high_num = 1;
   for (i = 0; i < sizeof(hand) - 1; i++) {
      num = 1;
      for (j = 0; j < sizeof(hand) - i - 1; j++) {
         if (hand[i]->number == hand[i + j + 1]->number) {
            num++;
         }
      }
      if (num > high_num) {
         high_num = num;
         id = hand[i]->number;
      }
   }

   tmp_hand = hand;
   if (high_num > 1) {
      // Remove the found cards from the list.
      for (i = 0; i < sizeof(tmp_hand); i++) {
         if (tmp_hand[i]->number == id) {
            ret_type->duplicate_1 = tmp_hand[i];
            tmp_hand = tmp_hand[0..i-1] + tmp_hand[i+1..];
            i--;
         }
      }
   }


   //
   // If you have more than one of a certain numbered card you cannot
   // have any of the other bits.
   //
   if (high_num == 2) {
      //
      // Could be two pair.
      //
      high_num = 1;
      for (i = 0; i < sizeof(tmp_hand) - 1; i++) {
         num = 1;
         for (j = 0; j < sizeof(tmp_hand) - i - 1; j++) {
            if (tmp_hand[i]->number == tmp_hand[i + j + 1]->number) {
               num++;
            }
         }
         if (num > high_num) {
            high_num = num;
            id = tmp_hand[i]->number;
         }
      }
      if (high_num == 2) {
         ret_type->hand_type = HAND_TYPE_TWO_PAIR;
         // Remove the found cards from the list.
         for (i = 0; i < sizeof(tmp_hand); i++) {
            if (tmp_hand[i]->number == id) {
               ret_type->duplicate_2 = tmp_hand[i];
               tmp_hand = tmp_hand[0..i-1] + tmp_hand[i+1..];
            }
         }
         if (is_card_higher(ret_type->duplicate_2, ret_type->duplicate_1)) {
            tmp_card = ret_type->duplicate_1;
            ret_type->duplicate_1 = ret_type->duplicate_2;
            ret_type->duplicate_2 = tmp_card;
         }
         ret_type->kickers = sort_cards(tmp_hand, 3);
      } else {
         ret_type->hand_type = HAND_TYPE_PAIR;
         high_num = 0;
         for (i = 1; i < sizeof(tmp_hand); i++) {
            if (is_card_higher(tmp_hand[i], tmp_hand[high_num])) {
               high_num = i;
            }
         }
         ret_type->kickers = sort_cards(tmp_hand, 3);
      }
      return ret_type;
   } else if (high_num == 3) {
      //
      // Could be a full house.
      //
      if (tmp_hand[0]->number == tmp_hand[1]->number) {
         ret_type->hand_type = HAND_TYPE_FULL_HOUSE;
         ret_type->duplicate_2 = tmp_hand[0];
         ret_type->kickers = ({ });
      } else {
         ret_type->hand_type = HAND_TYPE_THREE;
         ret_type->kickers = sort_cards(tmp_hand, 3);
      }
      return ret_type;
   } else if (high_num == 4) {
      ret_type->hand_type = HAND_TYPE_FOUR;
      ret_type->high_card = tmp_hand[0];
      return ret_type;
   }

   //
   // Check for a flush.
   //
   for (i = 0; i < sizeof(hand) - 1; i++) {
      if (hand[i + 1]->suit != hand[0]->suit) {
         break;
      }
   }
   if (i == sizeof(hand) - 1) {
      ret_type->hand_type = HAND_TYPE_FLUSH;
      ret_type->kickers = sort_cards(hand, 3);
      // Find the high card.
      high_num = 0;
      for (i = 1; i < sizeof(hand); i++) {
         if (is_card_higher(hand[i], hand[high_num])) {
            high_num = i;
         }
      }
      ret_type->high_card = hand[high_num];
   }

   //
   // Check for a straight.
   //
   tmp_hand = sort_array(hand, (: ((class playing_card)$1)->number -
                                  ((class playing_card)$2)->number :));
   if (tmp_hand[0]->number == CARD_NUMBER_ACE) {
      if (tmp_hand[1]->number == 2) {
         // Skip the ace at the start.
         j = 1;
      } else {
         // Move the ace to the end.
         j = 0;
         tmp_hand = tmp_hand[1..] + ({ tmp_hand[0] });
      }
   } else {
      j = 0;
   }
   for (i = j; i < sizeof(tmp_hand) - 1; i++) {
      if (tmp_hand[i]->number + 1 != tmp_hand[i + 1]->number) {
         if (tmp_hand[i + 1]->number != CARD_NUMBER_ACE ||
             tmp_hand[i]->number != CARD_NUMBER_KING) {
            break;
         }
      }
   }
   if (i == sizeof(tmp_hand) - 1) {
      if (ret_type->hand_type == HAND_TYPE_FLUSH) {
         ret_type->hand_type = HAND_TYPE_STRAIGHT_FLUSH;
         ret_type->high_card = tmp_hand[<1];
      } else {
         ret_type->hand_type = HAND_TYPE_STRAIGHT;
         ret_type->high_card = tmp_hand[<1];
      }
   }

   if (ret_type->hand_type == HAND_TYPE_HIGH_CARD) {
      ret_type->kickers = sort_cards(hand, 3);
   }

   return ret_type;
} /* query_hand_type() */

/**
 * This figures out which hand is greator than the other.
 */
int is_greator_hand(class hand_type new_hand,
                    class hand_type old_hand) {
   int i;

   if (new_hand->hand_type > old_hand->hand_type) {
      return 1;
   }
   if (new_hand->hand_type < old_hand->hand_type) {
      return 0;
   }
   if (new_hand->hand_type == old_hand->hand_type) {
      // Try and work out ties...
      switch (new_hand->hand_type) {
      case HAND_TYPE_HIGH_CARD :
         if (is_card_higher(new_hand->high_card,
                            old_hand->high_card)) {
            return 1;
         }
         if (is_card_higher(old_hand->high_card,
                            new_hand->high_card)) {
            return 0;
         }
         for (i = 1; i <= sizeof(new_hand->kickers); i++) {
            if (is_card_higher(new_hand->kickers[<i],
                               old_hand->kickers[<i])) {
               return 1;
            } else if (is_card_higher(old_hand->kickers[<i],
                                      new_hand->kickers[<i])) {
               return 0;
            }
         }
         break;
      case HAND_TYPE_FLUSH :
         for (i = 1; i <= sizeof(new_hand->kickers); i++) {
            if (is_card_higher(new_hand->kickers[<i],
                               old_hand->kickers[<i])) {
               return 1;
            } else if (is_card_higher(old_hand->kickers[<i],
                                      new_hand->kickers[<i])) {
               return 0;
            }
         }
         break;
      case HAND_TYPE_PAIR :
         if (is_card_higher(new_hand->duplicate_1,
                            old_hand->duplicate_1)) {
            return 1;
         }
         if (is_card_higher(old_hand->duplicate_1,
                            new_hand->duplicate_1)) {
            return 0;
         }
         for (i = 1; i <= sizeof(new_hand->kickers); i++) {
            if (is_card_higher(new_hand->kickers[<i],
                               old_hand->kickers[<i])) {
               return 1;
            } else if (is_card_higher(old_hand->kickers[<i],
                                      new_hand->kickers[<i])) {
               return 0;
            }
         }
         break;
      case HAND_TYPE_TWO_PAIR :
         if (is_card_higher(new_hand->duplicate_1,
                            old_hand->duplicate_1)) {
            return 1;
         }
         if (is_card_higher(old_hand->duplicate_1,
                            new_hand->duplicate_1)) {
            return 0;
         }
         if (is_card_higher(new_hand->duplicate_2,
                            old_hand->duplicate_2)) {
            return 1;
         }
         if (is_card_higher(old_hand->duplicate_2,
                            new_hand->duplicate_2)) {
            return 0;
         }
         if (is_card_higher(new_hand->kickers[0],
                            old_hand->kickers[0])) {
            return 1;
         }
         if (is_card_higher(old_hand->kickers[0],
                            new_hand->kickers[0])) {
            return 0;
         }
         break;
      case HAND_TYPE_THREE :
         if (is_card_higher(new_hand->duplicate_1,
                            old_hand->duplicate_1)) {
            return 1;
         }
         if (is_card_higher(old_hand->duplicate_1,
                            new_hand->duplicate_1)) {
            return 0;
         }
         for (i = 1; i <= sizeof(new_hand->kickers); i++) {
            if (is_card_higher(new_hand->kickers[<i],
                               old_hand->kickers[<i])) {
               return 1;
            } else if (is_card_higher(old_hand->kickers[<i],
                                      new_hand->kickers[<i])) {
               return 0;
            }
         }
         break;
      case HAND_TYPE_FOUR :
         if (is_card_higher(new_hand->duplicate_1,
                            old_hand->duplicate_1)) {
            return 1;
         }
         if (is_card_higher(old_hand->duplicate_1,
                            new_hand->duplicate_1)) {
            return 0;
         }
         if (is_card_higher(new_hand->kickers[0],
                            old_hand->kickers[0])) {
            return 1;
         }
         if (is_card_higher(old_hand->kickers[0],
                            new_hand->kickers[0])) {
            return 0;
         }
         break;
      case HAND_TYPE_FULL_HOUSE :
         if (is_card_higher(new_hand->duplicate_1,
                            old_hand->duplicate_1)) {
            return 1;
         }
         if (is_card_higher(old_hand->duplicate_1,
                            new_hand->duplicate_1)) {
            return 0;
         }
         if (is_card_higher(new_hand->duplicate_2,
                            old_hand->duplicate_2)) {
            return 1;
         }
         if (is_card_higher(old_hand->duplicate_2,
                            new_hand->duplicate_2)) {
            return 0;
         }
         break;
      case HAND_TYPE_STRAIGHT :
      case HAND_TYPE_STRAIGHT_FLUSH :
         // Use the high card as the kicker.
         if (is_card_higher(new_hand->high_card,
                            old_hand->high_card)) {
            return 1;
         }
         if (is_card_higher(new_hand->high_card,
                            old_hand->high_card)) {
            return 0;
         }
         break;
      }
   }
   return TIE;
} /* is_greator_hand() */

void test_hand_type() {
   class playing_card* other_tmp_hand;
   class playing_card* tmp_hand;

   other_tmp_hand = ({ new(class playing_card, suit: CARD_SUIT_HEARTS, number : 11),
                 new(class playing_card, suit: CARD_SUIT_HEARTS, number : 11),
                 new(class playing_card, suit: CARD_SUIT_HEARTS, number : 12),
                 new(class playing_card, suit: CARD_SUIT_HEARTS, number : 13),
                 new(class playing_card, suit: CARD_SUIT_HEARTS, number : 13) });
   tmp_hand = ({ new(class playing_card, suit: CARD_SUIT_HEARTS, number : 2),
                 new(class playing_card, suit: CARD_SUIT_HEARTS, number : 3),
                 new(class playing_card, suit: CARD_SUIT_HEARTS, number : 4),
                 new(class playing_card, suit: CARD_SUIT_HEARTS, number : 1),
                 new(class playing_card, suit: CARD_SUIT_HEARTS, number : 5) });
write(query_hand_type_string(query_hand_type(tmp_hand)) + " --\n" +
      query_hand_type_string(query_hand_type(other_tmp_hand)));
printf("%O\n", sizeof(query_hand_type(tmp_hand)->kickers));
printf("%O\n", sizeof(query_hand_type(other_tmp_hand)->kickers));
write("Result: " + is_greator_hand(query_hand_type(tmp_hand),
      query_hand_type(other_tmp_hand)) + "\n");
} 

/**
 * This method completes the round.
 */
void complete_round(int force_end) {
   string stuff;
   object ob;
   class player_data data;
   string id;
   string place;
   string* winner;
   class hand_type winning_hand_type;
   class playing_card* winning_hand;
   int paid;
   int discard;
   int result;
   int num;

   if (_finished) {
      return 0;
   }

   place = query_money_place();

   stuff = "";
   winner = ({ });
   foreach (id in query_started_player_ids()) {
      data = query_player_data(id);
      if ((data->state == POKER_STATE_BET || discard) && !force_end) {
         if (data->state != POKER_STATE_FOLDED) {
            data->state = POKER_STATE_DISCARD;
            data->bet = 0;
         }
         discard = 1;
      } else if (data->state != POKER_STATE_FOLDED) {
         num++;
         if (!winning_hand) {
            winning_hand = data->hand;
            winning_hand_type = data->hand_type;
            winner = ({ id });
         } else {
            data->hand_type = query_hand_type(data->hand);
            result = is_greator_hand(data->hand_type, winning_hand_type);
            if (result == TIE) {
               winner += ({ id });
            } else if (result) {
               winning_hand = data->hand;
               winning_hand_type = data->hand_type;
               winner = ({ id });
            }
         }
         stuff += query_player_cap_name(id) + "'s hand (" +
                  query_hand_type_string(data->hand_type) + "):\n" +
                  query_hand_string(data->hand, CARD_HAND_SINGLE,
                                     this_player()->query_cols()) + "\n";
      }
   }

   if (num == 1) {
      stuff = "All but one person folded so the cards are not revealed.\n";
   }

   if (discard) {
      foreach (id in query_started_player_ids()) {
         data = query_player_data(id);
         if (data->state == POKER_STATE_FOLDED) {
            tell_player(id, "%^BOLD%^Now into the discard phase.%^RESET%^\n"
               "You have folded.\n");
         } else {
            data->bet = 0;
            tell_player(id, "%^BOLD%^Now into the discard phase.%^RESET%^\n"
               "Your hand:\n" +
               query_hand_string(data->hand, CARD_HAND_THREE | CARD_HAND_LETTERS,
                                    80));
         }
      }
   } else {
      if (_house_cut) {
         stuff += "House takes " + 
            MONEY_HAND->money_value_string((_pot * _house_cut) / 100, place) +
                  ".\n";
        adjust_float((_pot * _house_cut) / 100);
        //_revenue += (_pot * _house_cut) / 100;
        _pot -= (_pot * _house_cut) / 100;
      }
      if (sizeof(winner) > 1) {
         stuff += "Tie for winning between " +
           query_multiple_short(map(winner, (: query_player_cap_name($1) :))) +
                  ", they each win " +
                  MONEY_HAND->money_value_string(_pot / sizeof(winner), place) +
                  ".\n";
         paid = _pot / sizeof(winner);
         foreach (id in winner) { 
            ob = query_player_object(id);
            if (ob) {
               ob->adjust_money(MONEY_HAND->create_money_array(paid, place), place);
               _player_stats[ob->query_name()] += paid;
            } else {
               stuff += "Unable to find " + id + " to pay them, money "
                               "going to the house.\n";
               adjust_float(paid);
               //_revenue += paid;
            }
         }
      } else {
         stuff += "Winner is " +
           query_multiple_short(map(winner, (: query_player_cap_name($1) :))) +
                  ", and they win " +
                  MONEY_HAND->money_value_string(_pot, place) +
                  ".\n";
         ob = query_player_object(winner[0]);
         ob->adjust_money(MONEY_HAND->create_money_array(_pot, place), place);
         _player_stats[ob->query_name()] += _pot;
      }

      // Do the dealer.
      tell_all_players("The players reveal their cards as:\n" +
                       stuff);
      tell_room(environment(), "The game ends with " + query_multiple_short(winner) +
                               " as the winner.\n");

      finish_game(query_multiple_short(winner));
      _finished = 1;
   }
} /* complete_round() */

/**
 * This method checks to see if everyone has discarded and ready for the
 * next round.
 */
void finish_discard() {
   string id;
   class player_data data;

   foreach (id in query_started_player_ids()) {
      data = query_player_data(id);
      if (data->state != POKER_STATE_AFTER_DISCARD &&
          data->state != POKER_STATE_FOLDED) {
         return 0;
      }
   }

   _draw_round++;

   foreach (id in query_started_player_ids()) {
      data = query_player_data(id);
      if (data->state == POKER_STATE_AFTER_DISCARD) {
         if (_draw_round >= _max_draw_rounds) {
            data->state = POKER_STATE_FINAL_BET;
         } else {
            data->state = POKER_STATE_BET;
         }
      }
   }
   _current_bet = 0;
   _poker_phase = POKER_STATE_FINAL_BET;
   call_out("tell_all_players", 0,
            "Discard round completed.  Now onto the " +
            (_draw_round >= _max_draw_rounds?"final ":"") + "betting round.\n");
   next_person_turn();
   //call_out("tell_current_player", 0, "%^BOLD%^Your turn!%^RESET%^\n");
} /* finish_discard() */

/**
 * Places your bet.
 */
int do_ante() {
   string place;
   string id;
   int amount;
   class player_data data;

   if (!is_game_started()) {
      add_failed_mess("The game has not started.\n");
      return 0;
   }

   id = find_player_id_of_person(this_player());
   if (!id) {
      add_failed_mess("You are not playing.\n");
      return 0;
   }

   data = query_player_data(id);
   if (data->state != POKER_STATE_ANTE) {
      add_failed_mess("You have already put in your ante.\n");
      return 0;
   }

   place = query_money_place();

   amount = _ante_house + _ante_amount;
   if (this_player()->query_value_in(place) < amount) {
      add_failed_mess("You do not have the needed " +
                      MONEY_HAND->money_value_string(amount, place) +
                      " to meet the ante.\n");
      return 0;
   }

   _player_stats[this_player()->query_name()] -= amount;
   this_player()->pay_money(MONEY_HAND->create_money_array(amount, place),
                            place);

   adjust_float(_ante_house);
   //_revenue += _ante_house;
   _pot += _ante_amount;
   data->state = POKER_STATE_PAID_ANTE;
   environment()->event_save(this_object());

   // This is for the starting bet.
   check_for_finish_ante();

   add_succeeded_mess("$N $V " +
                      MONEY_HAND->money_value_string(amount, place) +
                      " on $D.\n");
   return 1;
} /* do_ante() */

/**
 * This hits you for another card.
 */
int do_discard(string throw_away) {
   int i;
   string id;
   class player_data data;
   string* bits;
   int* new_bits;

   throw_away = lower_case(throw_away);
   // Get another card.
   if (!is_game_started()) {
      add_failed_mess("The game has not started.\n");
      return 0;
   }

   id = find_player_id_of_person(this_player());
   if (!id) {
      add_failed_mess("You are not playing.\n");
      return 0;
   }

   data = query_player_data(id);
   if (!sizeof(data->hand)) {
      add_failed_mess("You cannot discard before you have been dealt "
                      "cards.\n");
      return 0;
   }

   if (data->state != POKER_STATE_DISCARD) {
      add_failed_mess("You are not in the discard phase.\n");
      return 0;
   }

   if (throw_away && throw_away != "none") {
      throw_away = lower_case(replace_string(throw_away, " ", ""));
      bits = explode(throw_away, ",");
      if (sizeof(filter(bits, (: strlen($1) > 1 :))) > 0) {
         add_failed_mess("Some of the card references " + throw_away +
                         " are invalid.  Use a command seperated list of "
                         "card ids.\n");
         return 0;
      }
      // Figure out the cards to throw.
      new_bits = map(bits, (: $1[0] - 'a' :));
      if (sizeof(filter(new_bits, (: $1 < 0 || $1 >= 5 :))) > 0) {
         add_failed_mess("Some of the card references " + throw_away +
                         " are invalid.  Use a command seperated list of "
                         "card ids.\n");
         return 0;
      }

      for (i = 0; i < sizeof(new_bits); i++) {
         if (member_array(new_bits[i],
                          new_bits[0..i-1] + new_bits[i+1..]) != -1) {
            add_failed_mess("You have referenced the card " +
                            sprintf("%c", 'A' + new_bits[i]) + " twice.\n");
            return 0;
         }
      }

      new_bits = sort_array(new_bits, (: $2 - $1 :));
      for (i = 0; i < sizeof(new_bits); i++) {
         _discard += ({ data->hand[new_bits[i]] });
         data->hand = data->hand[0..new_bits[i]-1] +
                      data->hand[new_bits[i]+1..];
      }
      i = 5 - sizeof(data->hand) - 1;
      if (sizeof(_deck) < i) {
         _deck += _discard;
         _deck = shuffle_array(_deck);
         _discard = ({ });
      }
      data->hand += _deck[0..i];
      _deck = _deck[i + 1..];
      data->hand = sort_cards(data->hand, 3);
      data->hand_type = query_hand_type(data->hand);
      add_succeeded_mess(({ "", "$N draw$s " + query_num(sizeof(new_bits)) +
                                " new card" +
                               (sizeof(new_bits) > 1?"s":"") + " on $D.\n" }));
      write("Your new hand (" +
            query_hand_type_string(data->hand_type) +
            "):\n" +
            query_hand_string(data->hand, CARD_HAND_THREE,
                                  this_player()->query_cols()));
      data->state = POKER_STATE_AFTER_DISCARD;
   } else {
      new_bits = ({ });
      data->state = POKER_STATE_AFTER_DISCARD;
      add_succeeded_mess("$N do$es not discard any cards on $D.\n");
   }

   finish_discard();

   return 1;
} /* do_discard() */

int do_check() {
   // Get another card.
   if (!is_game_started()) {
      add_failed_mess("The game has not started.\n");
      return 0;
   }

   if (_poker_phase != POKER_STATE_BET &&
       _poker_phase != POKER_STATE_FINAL_BET) {
      add_failed_mess("Not a betting phase.\n");
      return 0;
   }

   if (!is_current_player(this_player())) {
      add_failed_mess("Not your turn to bet.\n");
      return 0;
   }

   if (_current_bet) {
      add_failed_mess("You cannot check since betting has started.\n");
      return 0;
   }

   add_succeeded_mess("$N check$s on $D.\n");
   next_person_turn();
   return 1;
} /* do_stand() */

int do_call() {
   class player_data data;
   int amt;
   string place;

   // Get another card.
   if (!is_game_started()) {
      add_failed_mess("The game has not started.\n");
      return 0;
   }

   if (_poker_phase != POKER_STATE_BET &&
       _poker_phase != POKER_STATE_FINAL_BET) {
      add_failed_mess("Not a betting phase.\n");
      return 0;
   }

   if (!is_current_player(this_player())) {
      add_failed_mess("Not your turn to bet.\n");
      return 0;
   }

   if (!_current_bet) {
      add_failed_mess("No one has bet anything for you to call.\n");
      return 0;
   }

   place = query_money_place();
   data = query_player_data(query_current_player());
   if (_current_bet && data->bet == _current_bet) {
      // They are called.
      call_out("complete_round", 2);
      if (_poker_phase == POKER_STATE_ANTE) {
         _poker_phase = POKER_STATE_DISCARD;
      } else {
         _poker_phase = POKER_STATE_ANTE;
      }
   } else {
      amt = _current_bet - data->bet;
      if (this_player()->query_value_in(place) < amt) {
         add_failed_mess("You do not have the necessary " +
                         MONEY_HAND->money_value_string(amt, place) +
                         " to call the bet.\n");
         return 0;
      }
      _player_stats[this_player()->query_name()] -= amt;
      this_player()->pay_money(MONEY_HAND->create_money_array(amt, place),
                               place);
      _pot += amt;
      data->bet = _current_bet;
      if (!check_end_round()) {
         next_person_turn();
      }
   }

   add_succeeded_mess("$N call$s the bet by adding " +
                      MONEY_HAND->money_value_string(amt, place) +
                      " to the pot for a total bet of " +
                      MONEY_HAND->money_value_string(_current_bet, place) +
                      " on $D.\n");
   return 1;
} /* do_call() */

int do_raise(string amount) {
   class player_data data;
   string place;
   int amt;
   int raise_amt;

   // Get another card.
   if (!is_game_started()) {
      add_failed_mess("The game has not started.\n");
      return 0;
   }

   if (_poker_phase != POKER_STATE_BET &&
       _poker_phase != POKER_STATE_FINAL_BET) {
      add_failed_mess("Not a betting phase.\n");
      return 0;
   }

   if (!is_current_player(this_player())) {
      add_failed_mess("Not your turn to bet.\n");
      return 0;
   }

   place = query_money_place();
   amt = MONEY_HAND->value_from_string(amount, place);
   raise_amt = amt;
   if (!amt) {
      add_failed_mess("The value " + amount + " is not a valid "
                      "money amount.\n");
      return 0;
   }

   if (amt < _min_bet) {
      add_failed_mess("The minimum bet is " +
                      MONEY_HAND->money_value_string(_min_bet, place) +
                      ".\n");
      return 0;
   }
   if (amt > _max_bet) {
      add_failed_mess("The maximum bet is " +
                      MONEY_HAND->money_value_string(_max_bet, place) +
                      ".\n");
      return 0;
   }

   data = query_player_data(query_current_player());
   amt = _current_bet + amt - data->bet;
   if (this_player()->query_value_in(place) < amt) {
      add_failed_mess("You do not have the nessessary " +
                      MONEY_HAND->money_value_string(amt, place) +
                      " to raise the bet.\n");
      return 0;
   }
   _player_stats[this_player()->query_name()] -= amt;
   this_player()->pay_money(MONEY_HAND->create_money_array(amt, place),
                               place);
   _current_bet = data->bet + amt;
   data->bet = _current_bet;
   _pot += amt;

   add_succeeded_mess("$N raise$s the bet by " +
                      MONEY_HAND->money_value_string(raise_amt, place) +
                      " to " +
                      MONEY_HAND->money_value_string(_current_bet, place) +
                      " on $D.\n");
   next_person_turn();
   return 1;
} /* do_raise() */

int do_bet(string amount) {
   class player_data data;
   string place;
   int amt;
   int raise_amt;

   // Get another card.
   if (!is_game_started()) {
      add_failed_mess("The game has not started.\n");
      return 0;
   }

   if (_poker_phase != POKER_STATE_BET &&
       _poker_phase != POKER_STATE_FINAL_BET) {
      add_failed_mess("Not a betting phase.\n");
      return 0;
   }

   if (!is_current_player(this_player())) {
      add_failed_mess("Not your turn to bet.\n");
      return 0;
   }

   place = query_money_place();
   amt = MONEY_HAND->value_from_string(amount, place);
   if (!amt) {
      add_failed_mess("The value " + amount + " is not a valid "
                      "money amount.\n");
      return 0;
   }

   if (amt == _current_bet) {
      return do_call();
   }

   if (amt < _current_bet) {
      add_failed_mess("You have to bet higher than the current bet of " +
                      MONEY_HAND->money_value_string(_current_bet, place) +
                      " money amount.\n");
      return 0;
   }

   amt = amt - _current_bet;
   raise_amt = amt;

   if (amt < _min_bet) {
      add_failed_mess("The minimum bet is " +
                      MONEY_HAND->money_value_string(_min_bet, place) +
                      ".\n");
      return 0;
   }
   if (amt > _max_bet) {
      add_failed_mess("The maximum bet is " +
                      MONEY_HAND->money_value_string(_max_bet, place) +
                      ".\n");
      return 0;
   }

   data = query_player_data(query_current_player());
   amt = _current_bet + amt - data->bet;
   if (this_player()->query_value_in(place) < amt) {
      add_failed_mess("You do not have the nessessary " +
                      MONEY_HAND->money_value_string(amt, place) +
                      " to raise the bet.\n");
      return 0;
   }
   _player_stats[this_player()->query_name()] -= amt;
   this_player()->pay_money(MONEY_HAND->create_money_array(amt, place),
                               place);
   _current_bet = data->bet + amt;
   data->bet = _current_bet;
   _pot += amt;

   add_succeeded_mess("$N raise$s the bet by " +
                      MONEY_HAND->money_value_string(raise_amt, place) +
                      " to " +
                      MONEY_HAND->money_value_string(_current_bet, place) +
                      " on $D.\n");
   next_person_turn();
   return 1;
} /* do_raise() */

int do_fold() {
   class player_data data;
   string id;
   int not_folded;

   // Get another card.
   if (!is_game_started()) {
      add_failed_mess("The game has not started.\n");
      return 0;
   }

   if (!is_current_player(this_player())) {
      add_failed_mess("Not your turn to bet.\n");
      return 0;
   }

   data = query_player_data(query_current_player());
   data->state = POKER_STATE_FOLDED;

   add_succeeded_mess("$N fold$s on $D.\n");
   // Figure out if there is only one non-folded player left.
   foreach (id in query_started_player_ids()) {
      data = query_player_data(id);
      if (data->state != POKER_STATE_FOLDED) {
         not_folded++;
      }
   }
   if (not_folded == 1) {
      call_out("complete_round", 0, 1);
      _poker_phase = POKER_STATE_END;
   } else if (!check_end_round()) {
      next_person_turn();
   }
   return 1;
} /* do_fold() */

/**
 * Starts a nice furry game.
 */
int do_start() {
   int old_pot;

   if (!is_open_for("poker", this_player()->query_name())) {
      add_failed_mess("The poker table is not open.\n");
      return 0;
   }

   //
   // There must eb enough money in the float for everyone to bid the max amo
   // amount and win with a poker.
   //
   if (!is_playing(this_player())) {
      add_failed_mess("You must be playing the game to start it.\n");
      return 0;
   }

   old_pot = _pot;
   if (!start_game()) {
      add_failed_mess("You need at least two people to play poker.\n");
      return 0;
   }

   adjust_float(old_pot);
   //_revenue += old_pot;
   add_succeeded_mess("$N $V a game on $D.\n");
   return 1;
} /* do_start() */

/**
 * If it is finished early...  Oh dear.
 */
int do_finish() {
   string person;

   if (!is_game_started()) {
      add_failed_mess("The game has not started.\n");
      return 0;
   }

   person = find_player_id_of_person(this_player());
   if (!person) {
      add_failed_mess("You must actually be playing to finish the game.\n");
      return 0;
   }

   finish_game(0);
   reset_game();
   return 1;
} /* do_finish() */

string query_main_status(int hint) {
   string place;
   string ret;
   string name;
   int amt;

   place = query_money_place();
   ret = "$I$0=Poker table:\n"
          "$I$6=   Maximum bet: " +
              MONEY_HAND->money_value_string(_max_bet, place) +
          "\n$I$6=   Minimum bet: " +
              MONEY_HAND->money_value_string(_min_bet, place) +
          "\n$I$6=   Ante       : " +
              MONEY_HAND->money_value_string(_ante_amount, place) +
          "\n$I$6=   House Ante : " +
              MONEY_HAND->money_value_string(_ante_house, place) +
          "\n$I$6=   Draw Rounds: " + _max_draw_rounds +
          "\n$I$6=   Cut        : " + _house_cut + "%"
          "\n$I$6=   Revenue    : " +
              MONEY_HAND->money_value_string(query_revenue(), place) +
          "\n$I$0=";
   foreach (name, amt in _player_stats) {
      ret += sprintf(" %-13s: %s\n" , name,
                     MONEY_HAND->money_value_string(amt, place));
   }
   return ret + "\n";
} /* query_main_status() */

/**
 * This method sets the ante amounts.
 * @param str the amount string
 * @param max_bet if it a max or min bet to set
 */
int do_set_ante(string str, int ante_game) {
   string place;
   int value;

   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to change the paramaters of "
                   "$D.\n");
      return 0;
   }
   if (lower_case(str) == "none" && !ante_game) {
      value = 0;
   } else {
      place = query_money_place();
      value = MONEY_HAND->value_from_string(str, place);
      if (!value) {
         add_failed_mess("Unable to parse the string " + str + ".\n");
         return 0;
      }
   }
   if (ante_game) {
      _ante_amount = value;
      add_succeeded_mess("$N set$s the ante amount to play to " +
          MONEY_HAND->money_value_string(value, place) + " on $D.\n");
   } else {
      _ante_house = value;
      add_succeeded_mess("$N set$s the ante amount for the house to " +
          MONEY_HAND->money_value_string(value, place) + " on $D.\n");
   }

   return 1;
} /* do_set_ante() */

/**
 * This method sets the ante amounts.
 * @param str the amount string
 * @param max_bet if it a max or min bet to set
 */
int do_set_bet(string str, int max_bet) {
   string place;
   int value;

   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to change the paramaters of "
                   "$D.\n");
      return 0;
   }
   place = query_money_place();
   value = MONEY_HAND->value_from_string(str, place);
   if (!value) {
      add_failed_mess("Unable to parse the string " + str + ".\n");
      return 0;
   }
   if (max_bet) {
      _max_bet = value;
      add_succeeded_mess("$N set$s the maximum bet to " +
          MONEY_HAND->money_value_string(value, place) + " on $D.\n");
   } else {
      _min_bet = value;
      add_succeeded_mess("$N set$s the minimum bet to " +
          MONEY_HAND->money_value_string(value, place) + " on $D.\n");
   }

   return 1;
} /* do_set_bet() */

/**
 * This method sets the cut
 * @param percent the cut percentage
 */
int do_set_cut(int percent) {

   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to change the paramaters of "
                   "$D.\n");
      return 0;
   }
   if (percent < 0) {
      add_failed_mess("You cannot set the cut less than 0.\n");
      return 0;
   }
   if (percent > 100) {
      add_failed_mess("You cannot set the cut to greator than 100%.\n");
      return 0;
   }

   _house_cut = percent;

   add_succeeded_mess("$N set$s the cut to " + percent + "% on $D.\n");
   return 1;
} /* do_set_cut() */

/**
 * This method sets the maximum number of draw rounds.
 * @param percent the cut percentage
 * @param draw the maximum number of draw rounds
 */
int do_set_draw(int draw) {

   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to change the paramaters of "
                   "$D.\n");
      return 0;
   }
   if (draw < 0) {
      add_failed_mess("You cannot set the number of draws less than 0.\n");
      return 0;
   }
   if (draw > 5) {
      add_failed_mess("You cannot set the draw to greator than 5.\n");
      return 0;
   }

   _max_draw_rounds = draw;

   add_succeeded_mess("$N set$s the number of draw rounds to " + draw + " on $D.\n");
   return 1;
} /* do_set_draw() */

/**
 * This method shows the current set of house rules.  This will contain
 * any modifiable bits.
 */
int do_rules() {
   string ret;
   string place;

   place = query_money_place();
   ret = "The rules for this table are:\n";
   ret += "$I$6=   Maximum amount that can be raised " +
              MONEY_HAND->money_value_string(_max_bet, place) +
          "\n$I$6=   Minimum amount that can be raised " +
              MONEY_HAND->money_value_string(_min_bet, place) +
          "\n$I$6=   Total ante " +
              MONEY_HAND->money_value_string(_ante_amount + _ante_house, place) +
          "\n$I$6=   Cut of the pool : " + _house_cut +
          "\n$I$6=   Draw Rounds     : " + _max_draw_rounds +
          "\n$I$6=   House Ante      : " +
              MONEY_HAND->money_value_string(_ante_house, place);
   write("$P$Rules$P$" + ret);
} /* do_rules() */

int do_reset() {
   if (::do_reset()) {
      _player_stats = ([ ]);
      add_succeeded_mess("$N clear$s the player stats.\n");
      return 1;
   }
} /* do_reset() */

void init() {
   multiplayer_base::init();
   commercial::init();
   add_command("discard", "<string'card'> on <direct:object>",
               (: do_discard($4[0]) :));
   add_command("ante", "on <direct:object>",
               (: do_ante() :));
   add_command("check", "on <direct:object>",
               (: do_check() :));
   add_command("call", "on <direct:object>",
               (: do_call() :));
   add_command("bet", "<string'total bet'> on <direct:object>",
               (: do_bet($4[0]) :));
   add_command("raise", "<string'raise'> on <direct:object>",
               (: do_raise($4[0]) :));
   add_command("fold", "on <direct:object>",
               (: do_fold() :));
   add_command("finish", "game on <direct:object>",
               (: do_finish() :));
   add_command("start", "game on <direct:object>",
               (: do_start() :));
   add_command("rules", "<direct:object>",
               (: do_rules() :));
   add_command("rules", "{for|on|of} <direct:object>",
               (: do_rules() :));

   if (environment()->is_allowed(this_player()->query_name())) {
      add_command("set", "draw <number'rounds'> on <direct:object>",
                  (: do_set_draw($4[0]) :));
      add_command("set", "cut <number'percentage'> on <direct:object>",
                  (: do_set_cut($4[0]) :));
      add_command("set", "ante house <string'amount|none'> on <direct:object>",
                  (: do_set_ante($4[0], 0) :));
      add_command("set", "ante game <string'amount'> on <direct:object>",
                  (: do_set_ante($4[0], 1) :));
      add_command("set", "minimum bet <string'amount'> on <direct:object>",
                  (: do_set_bet($4[0], 0) :));
      add_command("set", "maximum bet <string'amount'> on <direct:object>",
                  (: do_set_bet($4[0], 1) :));
   }
} /* init() */

void resign_person(string id) {
   class player_data data;
   int not_folded;

   data = query_player_data(id);
   if (data && data->state != POKER_STATE_FOLDED) {
      // Make them fold.
      tell_all_players(query_player_cap_name(id) +
                       " resigns and folds.\n");
      data->state = POKER_STATE_FOLDED;
      foreach (id in query_started_player_ids()) {
         data = query_player_data(id);
         if (data->state != POKER_STATE_FOLDED) {
            not_folded++;
         }
      }
      if (not_folded == 1) {
         call_out("complete_round", 0, 1);
         _poker_phase = POKER_STATE_END;
      }
   } else {
      // Check and see if the round finished.
      switch (_poker_phase) {
      case POKER_STATE_ANTE :
         check_for_finish_ante();
         break;
      case POKER_STATE_BET :
         check_end_round();
         break;
      case POKER_STATE_DISCARD :
         finish_discard();
         break;
      }
   }
} /* resign_person() */

void event_exit(object ob, string mess, object to) {
   string id;

   if (userp(ob) && to != environment()) {
      id = find_player_id_of_person(ob);
      if (id) {
         resign_person(id);
      }
   }
} /* event_exit() */

void multiplayer_someone_resigns(string id, string name) {
   resign_person(id);
} /* multiplayer_someone_resigns() */

/** @ignore yes */
mapping query_dynamic_auto_load() {
   mapping map;

   map = commercial::query_dynamic_auto_load();
   multiplayer_base::query_dynamic_auto_load(map);
   add_auto_load_value(map, BOARD_TAG, "return", _return);
   //add_auto_load_value(map, BOARD_TAG, "revenue", _revenue);
   add_auto_load_value(map, BOARD_TAG, "ante amount", _ante_amount);
   add_auto_load_value(map, BOARD_TAG, "house cut", _house_cut);
   add_auto_load_value(map, BOARD_TAG, "ante house", _ante_house);
   add_auto_load_value(map, BOARD_TAG, "min bet", _min_bet);
   add_auto_load_value(map, BOARD_TAG, "max bet", _max_bet);
   add_auto_load_value(map, BOARD_TAG, "current bet", _current_bet);
   add_auto_load_value(map, BOARD_TAG, "pot", _pot);
   add_auto_load_value(map, BOARD_TAG, "deck", _deck);
   add_auto_load_value(map, BOARD_TAG, "poker phase", _poker_phase);
   add_auto_load_value(map, BOARD_TAG, "draw round", _draw_round);
   add_auto_load_value(map, BOARD_TAG, "max draw rounds", _max_draw_rounds);
   add_auto_load_value(map, BOARD_TAG, "discard", _discard);
   add_auto_load_value(map, BOARD_TAG, "player stats", _player_stats);
   return map;
} /* query_dynamic_auto_load() */

/** @ignore yes */
void init_dynamic_arg(mapping map, object player) {
   commercial::init_dynamic_arg(map, player);
   multiplayer_base::init_dynamic_arg(map, player);

   _return = query_auto_load_value(map, BOARD_TAG, "return");
   //_revenue = query_auto_load_value(map, BOARD_TAG, "revenue");
   _ante_amount = query_auto_load_value(map, BOARD_TAG, "ante amount");
   _ante_house = query_auto_load_value(map, BOARD_TAG, "ante house");
   _house_cut = query_auto_load_value(map, BOARD_TAG, "house cut");
   _deck = query_auto_load_value(map, BOARD_TAG, "deck");
   _current_bet = query_auto_load_value(map, BOARD_TAG, "current bet");
   _pot = query_auto_load_value(map, BOARD_TAG, "pot");
   _min_bet = query_auto_load_value(map, BOARD_TAG, "min bet");
   _max_bet = query_auto_load_value(map, BOARD_TAG, "max bet");
   _poker_phase = query_auto_load_value(map, BOARD_TAG, "poker phase");
   _draw_round = query_auto_load_value(map, BOARD_TAG, "draw round");
   _max_draw_rounds = query_auto_load_value(map, BOARD_TAG, "max draw rounds");
   _discard = query_auto_load_value(map, BOARD_TAG, "discard");
   _player_stats = query_auto_load_value(map, BOARD_TAG, "player stats");
   if (!_player_stats) {
      _player_stats = ([ ]);
   }
} /* init_dynamic_arg() */
// --- END [/mnt/home2/grok/lib/std/room/furniture/poker.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/furniture/dividor_room.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/furniture/dividor_room.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629193   Available: 13576547
Inodes: Total: 5242880    Free: 4960135
473 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/furniture/dividor_room.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629193   Available: 13576547
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/shops/commercial";

private string _main_room;

/**
 * This method sets the location of the main room.
 * @param room the location of the main room
 */
void set_main_room(string room) {
   _main_room = room;
}

/**
 * This method returns the location of the main room.
 * @return the main room of the shop
 */
string query_main_room() {
   return _main_room;
}

/**
 * @ignore yes
 */
string query_parcel_post() {
   return _main_room->query_parcel_post();
}
// --- END [/mnt/home2/grok/lib/std/room/furniture/dividor_room.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/furniture/bank_franchise.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/furniture/bank_franchise.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629193   Available: 13576547
Inodes: Total: 5242880    Free: 4960135
11286 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/furniture/bank_franchise.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629193   Available: 13576547
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
// Pinkfish
// Started Wed May 30 21:37:15 PDT 2001

inherit "/std/room/furniture/commercial";
inherit "/std/shops/inherit/bank_franchise";
#include <money.h>
#include <am_time.h>

#define SAVE_TIME 300

#define OBJECT_TAG "bank franchise"

#define MONTH_LENGTH (AM_SECONDS_PER_WEEK * 4)

private nosave int _maximum_total_difference;
private int _last_paid;

//
// This gives an estimated return on the payment.  For example 50%
// return would mean you get back approximately 50% of your money on
// average
//
void create() {
   _maximum_total_difference = 4000;
   _last_paid = time();
   bank_franchise::create();
   set_shop_use_types(({ "use", "buy" }));
   commercial::create();

   set_commercial_name("bank");
   set_commercial_information("A franchise is connected up to a main "
          "bank.  You will pay a monthly fee to the main bank that is "
          "settable by the owner of the main bank.  The maximum balance "
          "of the bank counter is variable, but it is controlled at purchase "
          "time.  The bank balance and the float of the shop are tied "
          "together.");
   add_help_file("bank_franchise");
} /* create() */


/**
 * A call to make sure this registers as a player bank.
 * @return 1 for player banks
 */
int query_player_bank() {
   return 1;
} /* query_player_bank() */

/**
 * This method sets the maximum total difference allowed by this
 * franchise.
 * @param max the maximum total difference
 */
void set_maximum_total_difference(int max) {
   _maximum_total_difference = max;
} /* set_maximum_total_difference() */

/**
 * This method returns the maximum total difference allowed by this
 * franchise.
 * @return the maximum allowed total difference
 */
int query_maximum_total_difference() {
   return _maximum_total_difference;
} /* query_maximum_total_difference() */

/**
 * This method sets the last paid date of the franchise.
 * @param paid the last paid date
 */
void set_last_paid(int paid) {
   _last_paid = paid;
} /* set_last_paid() */

/**
 * This method returns the last paid date of the franchise
 * franchise.
 * @return the last paid date
 */
int query_last_paid() {
   return _last_paid;
} /* query_last_paid() */

/**
 * @ignore yes
 * With franchises the float and the accounts are tied.
 */
void adjust_account(string person, int amount) {
   adjust_float(amount);
} /* adjust_account() */

/** @ignore yes */
object find_main_bank() {
   object office;
   object* obs;

   office = load_object(BANK_HANDLER->query_bank_master_office(query_bank_name()));
   if (!office) {
      return 0;
   }

   if (office->query_bank()) {
      return office;
   }

   obs = filter(office->find_commercial_items(query_commercial_name()),
                (: $1->query_bank_name() == query_bank_name() :));
   if (!sizeof(obs)) {
      return 0;
   }

   return obs[0];
} /* find_main_bank() */

/** @ignore yes */
int can_adjust_account(string person, int amount) {
   int amt;

   amt = query_total_difference() + amount;
   if (amt < -query_maximum_total_difference()  ||
       amt > query_maximum_total_difference()) {
      if (amt < 0) {
         add_failed_mess("This bank does not have the funds to handle "
                            "your request.\n");
      } else {
         add_failed_mess("This bank does not have the vault space to handle "
                            "your request.\n");
      }
      return 0;
   }
   return ::can_adjust_account(person, amount);
} /* can_adjust_account() */

/** @ignore yes */
string query_commercial_information() {
   string* bits;
   string bank;
   string place;

   place = previous_object()->query_money_place();
   bits = ({ });
   foreach (bank in BANK_HANDLER->query_banks()) {
      bits += ({ bank + " costs " + 
                 MONEY_HAND->money_value_string(BANK_HANDLER->query_bank_default_cost_per_month(bank), place) +
                 " per month and " +
                 MONEY_HAND->money_value_string(BANK_HANDLER->query_bank_default_cost_to_open(bank), place) +
                 " to open" });
   }
   return ::query_commercial_information() + 
          "This counter has a fixed maximum bank balance of " +
          MONEY_HAND->money_value_string(query_maximum_total_difference(), place) +
          ".  The costs of the franchises are " + query_multiple_short(bits) +
          ".";
} /* query_commercial_information() */

/**
 * This method sets the cut
 * @param percent the cut percentage
 */
int do_set_cut(int percent) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to change the paramaters of "
                   "$D.\n");
      return 0;
   }
   if (percent < 0) {
      add_failed_mess("You cannot set the cut less than 0.\n");
      return 0;
   }
   if (percent > 100) {
      add_failed_mess("You cannot set the cut to greator than 100%.\n");
      return 0;
   }

   set_percentage(percent);

   add_succeeded_mess("$N set$s the cut to " + percent + "% on $D.\n");
   return 1;
} /* do_set_cut() */

/**
 * This method sets the ante amounts.
 * @param str the amount string
 */
int do_set_open_cost(string str) {
   string place;
   int value;

   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to change the paramaters of "
                   "$D.\n");
      return 0;
   }
   place = query_money_place();
   value = MONEY_HAND->value_from_string(str, place);
   if (!value) {
      add_failed_mess("Unable to parse the string " + str + ".\n");
      return 0;
   }
   set_account_cost(value);
   add_succeeded_mess("$N set$s the account open cost to " +
          MONEY_HAND->money_value_string(value, place) + " on $D.\n");

   return 1;
} /* do_set_open_cost() */

/** @Ignore yes */
int is_allowed(string name) {
   return commercial::is_allowed(name);
} /* is_allowed() */

void init() {
   bank_franchise::init();
   commercial::init();

   if (is_allowed(this_player()->query_name())) {
      add_command("set", "percentage <number> on <direct:object>",
                  (: do_set_cut($4[0]) :));
      add_command("set", "account cost <string'open cost'> on <direct:object>",
                  (: do_set_open_cost($4[0]) :));
   }
} /* init() */

string query_franchise() {
   return file_name(environment());
} /* query_franchise() */

void event_save(object ob) {
   environment()->event_save(ob);
} /* event_save() */

mapping query_commercial_options() {
   string bank;
   mapping ret;

   ret = ([ ]);
   foreach (bank in BANK_HANDLER->query_banks()) {
      ret[bank] = BANK_HANDLER->query_bank_default_cost_to_open(bank);
   }
   return ([ "branch" : ret ]);
} /* query_commercial_options() */

void set_commercial_option(string type, string name, object room) {
   switch (type) {
   case "branch" :
      set_bank_name(name);
      BANK_HANDLER->add_new_franchise(name,
                                      file_name(room->query_main_room()));
      break;
   }
} /* set_commercial_option() */

/**
 * This returns the amount of money te franchise will cost per month.
 * @return the cost per month
 */
int query_monthly_fee() {
   return BANK_HANDLER->query_bank_franchise_cost_per_month(
             query_bank_name(), query_franchise());
} /* query_monthly_fee() */

/** @ignore yes */
int is_open_for(string type, string name) {
   if (query_monthly_fee() == -1) {
      return 0;
   }
   return ::is_open_for(type, name);
} /* is_open_for() */

/**
 * This method sets up the calout for the next payment period.
 */
void setup_call_out() {
   int tim;

   if (!_last_paid) {
      _last_paid = time();
   }
   tim = _last_paid + MONTH_LENGTH - time();
   call_out("make_payment", tim);
} /* setup_call_out() */

/**
 * This method makes the payment for the month.
 */
void make_payment() {
   _last_paid += MONTH_LENGTH;
   adjust_float(-query_monthly_fee());
   //find_master_bank()->adjust_float(query_monthly_fee());
   setup_call_out();
} /* make_payment() */

string query_main_status(int hints) {
   string ret;
   string place;

   // Make sure it is added.
   add_help_file("bank_franchise");
   place = query_money_place();
   ret = "$I$0=" + the_short() + ":\n"
         "$I$6=   Bank Branch                  : " + query_bank_name() + "\n"
         "$I$6=   Revenue                      : " +
             MONEY_HAND->money_value_string(query_revenue(), place) + "\n"
           "$I$6=   Master Address               : " +
             BANK_HANDLER->query_bank_master_office(query_bank_name())->query_address() +
         "\n$I$6=   Maximum allowed bank balance : " +
             MONEY_HAND->money_value_string(query_maximum_total_difference(), place) +
         " (fixed)\n$I$6=   Bank Balance                 : " +
             MONEY_HAND->money_value_string(query_total_difference(), place) +
         "\n$I$6=   Credit Notes Outstanding     : " +
             MONEY_HAND->money_value_string(query_outstanding_credit_value(), place) + "\n";
   if (hints) {
      ret += "$I$6=     Hint: list credit notes\n";
      ret += "$I$6=     Hint: create credit note\n";
      ret += "$I$6=     Hint: recind credit note <id>\n";
   }
   ret += "$I$6=   Monthly Fee                  : " +
             MONEY_HAND->money_value_string(query_monthly_fee(), place) +
         " (set by bank owner)\n"
         "$I$6=   Next Pay Day                 : " +
             AM_TIME_HANDLER->query_am_time(_last_paid + MONTH_LENGTH) +
             " (" + ctime(_last_paid + MONTH_LENGTH) + ")\n"
         "$I$6=   Percentage                   : " +
             query_percentage() + "%"
         "\n$I$6=   Open account cost            : " +
             MONEY_HAND->money_value_string(query_account_cost(), place) +
       "\n";
   if (hints) {
      ret += "$I$6=     Hint: set open cost <amount> on <bank>\n";
   }
   return ret;
} /* query_main_status() */

mapping query_dynamic_auto_load() {
   mapping map;

   map = ::query_dynamic_auto_load();
   add_auto_load_value(map, OBJECT_TAG, "bank", query_bank_name());
   add_auto_load_value(map, OBJECT_TAG, "open", query_account_cost());
   add_auto_load_value(map, OBJECT_TAG, "percentage", query_percentage());
   add_auto_load_value(map, OBJECT_TAG, "difference", query_total_difference());
   add_auto_load_value(map, OBJECT_TAG, "notes", query_credit_notes());
   add_auto_load_value(map, OBJECT_TAG, "credit num", query_credit_num());
   add_auto_load_value(map, OBJECT_TAG, "last paid", query_last_paid());
   return map;
} /* query_dynamic_auto_load() */

void init_dynamic_arg(mapping map, object player) {
   commercial::init_dynamic_arg(map, player);
   set_bank_name(query_auto_load_value(map, OBJECT_TAG, "bank"));
   set_account_cost(query_auto_load_value(map, OBJECT_TAG, "open"));
   set_percentage(query_auto_load_value(map, OBJECT_TAG, "percentage"));
   set_total_difference(query_auto_load_value(map, OBJECT_TAG, "difference"));
   set_credit_notes(query_auto_load_value(map, OBJECT_TAG, "notes"));
   set_credit_num(query_auto_load_value(map, OBJECT_TAG, "credit num"));
   set_last_paid(query_auto_load_value(map, OBJECT_TAG, "last paid"));
   setup_call_out();
} /* init_dyanmic_arg() */

mixed* stats() {
   return bank_franchise::stats() + commercial::stats() + ({
          ({ "last paid", ctime(_last_paid) }) });
} /* stats() */
// --- END [/mnt/home2/grok/lib/std/room/furniture/bank_franchise.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/furniture/shop_base.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/furniture/shop_base.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629190   Available: 13576544
Inodes: Total: 5242880    Free: 4960135
5504 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/furniture/shop_base.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629190   Available: 13576544
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
// Pinkfish
// Started Wed May 30 21:37:15 PDT 2001

inherit "/std/room/furniture/commercial";
inherit "/std/shops/inherit/player_craft_shop_base";

#define SAVE_TIME 1

private int _save_call;
private int _last_saved;
private string _counter_short;

#define OBJECT_TAG "shop base"

//
// This gives an estimated return on the payment.  For example 50%
// return would mean you get back approximately 50% of your money on
// average
//
void create() {
   player_craft_shop_base::create();
   set_shop_use_types(({ "use", "buy" }));
   commercial::create();
   set_commercial_name("craft shop");
} /* create() */

int query_player_craft_shop() {
   return 1;
} /* query_player_craft_shop() */

int disallow_sale_here(object room) {
   object* obs;

   obs = room->find_commercial_items(query_commercial_name());
   return sizeof(obs);
} /* disallow_sale_here() */

int query_royalty(string person) {
   return commercial::query_royalty(person);
} /* query_royalty() */

string query_craft_shop_save_dir() {
   return environment()->query_save_dir() + "craft_shop";
} /* query_craft_shop_save_dir() */

void adjust_royalty(string person, int amount) {
   commercial::adjust_royalty(person, amount);
} /* adjust_royalty() */

string query_parcel_post() {
   return commercial::query_parcel_post();
} /* query_parcel_post() */

void reset_weekly_status() {
   player_craft_shop_base::reset_weekly_status();
} /* reset_weekly_status() */

string query_weekly_status_string() {
   return player_craft_shop_base::query_weekly_status_string();
} /* query_weekly_status_string() */

void load_me() {
  string fname, tmp;
#ifdef USE_RAMDISK
  tmp = replace_string(query_save_dir() + "craft_shop_file", "/save/",
                       "/save/ramdisk/");
  if(unguarded((: file_size($(tmp) = ".o.gz") :)) > 0 ||
     unguarded((: file_size($(tmp) = ".o") :)) > 0) {
    fname = tmp;
  }
#endif
  
  if(!fname) {
    fname = query_save_dir() + "craft_shop_file";
  }
 
   unguarded( (: restore_object($(fname)) :));
#ifdef USE_RAMDISK
   tmp = replace_string(query_craft_shop_save_dir(), "/save/",
                        "/save/ramdisk/");
   unguarded( (: mkdir($(tmp)) :));
#endif
   unguarded( (: mkdir(query_craft_shop_save_dir()) :));
   
   reload_shop();
   add_property("place", environment()->query_property("place"));
} /* load_me() */

void init() {
   player_craft_shop_base::init();
   commercial::init();
} /* init() */

void do_save() {
  string fname;
  string dir;
  
   _save_call = 0;
   if (environment() && query_save_dir()) {
#ifdef USE_RAMDISK
     dir = replace_string(query_save_dir(), "/save/",
                            "/save/ramdisk/");
     if (file_size(dir) == -2) {
        fname = dir + "craft_shop_file";
     }
#endif
     if(!fname) {
       fname = query_save_dir() + "craft_shop_file";
     }
     debug_printf("Saving to %O\n", fname); 
     unguarded( (: save_object($(fname), 2) :));
   }
} /* do_save() */

void dest_me() {
   do_save();
   player_craft_shop_base::dest_me();
   commercial::dest_me();
} /* dest_me() */

string query_commercial_information() {
   return "This shop can have a maximum of " + query_maximum_inventory_size() +
          " items for sale.  "
          "You can only have "
          "one shop counter in any room, more than one will not be "
          "able to be bought.";
} /* query_commercial_information() */

/**
 * This does some nice saving stuff.  However, since we are on the
 * ramdrive now, lets save very quickly with a little delay to debounce
 * issues.
 */
void event_save(object ob) {
   if (!_save_call) {
      if(_last_saved > time() - SAVE_TIME) {
         _save_call = call_out("do_save", SAVE_TIME - (time() - _last_saved));
      } else {
         _save_call = call_out("do_save", SAVE_TIME);
      }
#ifdef DEBUG
      debug_printf("Adding call_out");
#endif      
   }
} /* event_save() */

mapping query_commercial_options() {
   return ([
    "counter type" : ([
       "polished hardwood counter" : 500000,
       "shiny polished counter" : 150000,
       "unfinished pine counter" : 0,
      ]),
   "stockroom size" : ([
       "50" : 0,
       "100" : 1000000,
       "150" : 2500000,
      ]),
   ]);
} /* query_commercial_options() */

void set_commercial_option(string type, string name) {
   string* bits;
   int size;

   switch (type) {
   case "counter type" :
      _counter_short = name;
      set_short(_counter_short);
      bits = explode(lower_case(_counter_short), " ");
      add_adjective(bits[0..<2]);
      add_alias(bits[<1]);
      break;
   case "stockroom size" :
      sscanf(name, "%d", size);
      set_maximum_waiting_queue_size(size);
      break;
   }
} /* set_commercial_option() */

mapping query_dynamic_auto_load() {
   mapping map;

   map = ::query_dynamic_auto_load();
   add_auto_load_value(map, OBJECT_TAG, "stocksize", query_maximum_waiting_queue_size());
   add_auto_load_value(map, OBJECT_TAG, "counter short", _counter_short);
} /* query_dynamic_auto_load() */

void init_dynamic_arg(mapping map, object player) {
   string* bits;
   int size;

   commercial::init_dynamic_arg(map, player);
   size = query_auto_load_value(map, OBJECT_TAG, "stocksize");
   _counter_short = query_auto_load_value(map, OBJECT_TAG, "counter short");

   if (size) {
      set_maximum_waiting_queue_size(size);
   }
   if (_counter_short) {
      bits = explode(lower_case(_counter_short), " ");
      add_adjective(bits[0..<2]);
      add_alias(bits[<1]);
   }
} /* init_dyanmic_arg() */
// --- END [/mnt/home2/grok/lib/std/room/furniture/shop_base.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/furniture/fireplace.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/furniture/fireplace.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629188   Available: 13576542
Inodes: Total: 5242880    Free: 4960135
15899 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/furniture/fireplace.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629188   Available: 13576542
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is a fireplace inheritable for the playerhouses.
 * There are lots of functions for you to customise it. They all
 * have default settings so you don't have to override all of them
 * but try to make each fireplace look and feel different.
 * @author Aquilo
 */

#include <fuel_handler.h>
#include <move_failures.h>

#define WIZARD "/std/guilds/wizard"
#define CMD "/cmds/"
#define BURN_PER_TICK   1
#define BRIGHT 30
#define K      1  // A constant to relate weight and fuel

inherit "/std/room/furniture/surface";

private nosave int _light_produced;
private nosave int _is_lit;
private nosave int _frequency;
private nosave string _lit_mess;
private nosave string _unlit_mess;
private nosave string *_lit_chats;
private nosave string *_dying_chats;
private nosave string _turn_on_mess;
private nosave string _turn_off_mess;
private nosave string _out_of_fuel_mess;

void set_light_produced(int b);

void set_lit_mess(string str);
void set_unlit_mess(string str);

void set_frequency(int i);

void set_lit_chats(string *str);

void add_lit_chat(string str);
string request_lit_chat();

void set_dying_chats(string *str);
void add_dying_chat(string str);
string request_dying_chat();

void set_turn_on_mess(string mess);
void set_turn_off_mess(string mess);

void set_out_of_fuel_mess(string mess);

  // Internal functions
int do_light(object *obs);
int do_zap();
int turn_on();
int do_dowse(object *obs);
int turn_off();
int calc_fuel();

/** @ignore yes */
void create() {
  do_setup++;
  surface::create();
  do_setup--;

  set_name("fireplace");
  add_alias( ({ "fireplace", "furniture", "hearth", "fire" }) );
  add_plural( "fireplaces" );
  add_property( "shop type", "furniture" );
  add_property( "degrees", 0 );

  set_light_produced( BRIGHT );

  set_lit_mess("A fire blazes happily in the hearth, providing "
      "a soft red glow and pleasant warmth. It crackles and spits "
      "occasionally, giving the room that homely feel.\n");

  set_unlit_mess("The hearth is blackened with ashes and old embers.\n");

  set_frequency(5);

  set_lit_chats( ({
      "The fire crackles and spits cheerfully.",
      "The warm fire soothes your weariness.",
      "An enchanting orange glow radiates from the hearth.",
      "Small glowing embers dance over the fire.",
      "The fire blazes in the grate." }) );

  set_dying_chats( ({
      "The fire splutters.",
      "The warm red glow flickers.",
      "A whisp of smoke from the fire trails around the room." }) );

  set_turn_on_mess("Soon a roaring fire is blazing in the grate.\n");

  set_turn_off_mess("The embers smoke slightly and their glow dims.\n");

  set_out_of_fuel_mess("The fire flickers and dies away.\n");

  if ( !do_setup ) {
      this_object()->setup();
  }

  this_object()->add_extra_look( this_object() );

  add_help_file("fireplace");

}

/** @ignore yes */
void init() {

  this_player()->add_command("light", this_object(), "<direct:object> with <indirect:object>");
  this_player()->add_command("extinguish", this_object(), "<direct:object>", (: do_dowse :) );
  this_player()->add_command("dowse", this_object(), "<direct:object>");

  if( this_player()->query_guild_ob() == WIZARD ){
    this_player()->add_command("zap", this_object(), "<direct:object>");
    this_player()->add_command("point", this_object(), "[finger] at <direct:object>", (: do_zap :) );
  }

}

/**
 * Tell us the amount of the fuel the fireplace has left to burn.
 * @return the amount of fuel the fireplace has left to burn
 */
int query_fuel_left(){  return calc_fuel();  }

/**
 * This sets the amount of light produced by the fireplace (when it is on).
 * @param b the amount of light produced by the fireplace
 */
void set_light_produced(int b){  _light_produced = b;  }

/**
 * The amount of light produced by the fireplace (when it is on).
 * @return the amount of light produced by the fireplace
 */
int query_light_produced(){  return _light_produced;  }

/**
 * This function sets the frequency at which roomchats from the fireplace
 * are printed to the room. ( i * 15 ) is the average time in seconds
 * inbetween each roomchat.
 * @param i the frequency ( 0 no roomchats are printed )
 */
void set_frequency(int i){  _frequency = i + 1;  } /* +1 because
                                                    random(1) still = 0
                                                   */

/**
 * The current frequency (*15 seconds) at which roomchats are
 * printed from the fireplace.
 * @return the current frequency of the room chats
 */
int query_frequency(){  return _frequency;  }

/** @ignore yes */
int do_light(object *obs){
  string q_n;
  q_n = obs[0]->query_name();

  if( _is_lit ){
    this_player()->add_failed_mess( this_object(),
         "$D is already ablaze.\n", ({ }) );
    return 0;
  }

  if( q_n != "flint" && q_n != "match" && q_n != "lighter" ){
    this_player()->add_failed_mess(this_object(),
         "You can't light $D with $I.\n", ({ obs[0] }) );
    return 0;
  }

  //Bring in the fact that matches and lighters are always fiddly :)
  if( this_player()->query_dex() < random(18) ){
    this_player()->add_failed_mess(this_object(),
      "You strike $I, but can't quite get the spark to catch.\n", ({ obs[0] }) );
    return 0;
  }

  if ( calc_fuel() <= 0 ) {
    this_player()->add_failed_mess( this_object(),
        "There is nothing in the fireplace to burn.\n", ({ }) );
    return 0;
  }

  this_player()->add_succeeded_mess(this_object(),
    "$N $V $D with $I.\n", ({ obs[0] }) );

  return turn_on();

}

/** @ignore yes */
int do_zap(){
  object tp;
  tp = this_player();

  if(tp->query_gp() < 10){
    tell_object(tp, "You don't even have the energy for such a small task!\n");
    return 1;
  }

  if(_is_lit){
    tell_object(tp, "There is already a merry fire burning in the fireplace.\n");
    return 1;
  } else {

    tp->add_succeeded_mess(this_object(),
      "$N extend$s an arm towards $D.\nA small fireball leaps from $p "
      "index finger and throws itself onto the hearth.\n", ({ }) );
    tp->adjust_gp( -10 );
    return turn_on();
  }

}

/**
 * This function sets the message that is printed to the room containing
 * the fireplace, a few seconds after it has been turned on.
 * @param mess the message. Use "" for no message.
 */
void set_turn_on_mess(string mess){  _turn_on_mess = mess;  }

/**
 * This function returns the message that is printed to the room containing
 * the fireplace after is has been turned on.
 * @return the message.
 */
string query_turn_on_mess(){  return _turn_on_mess;  }

/**
 * This function sets the message that is printed to the room containing
 * the fireplace, a few seconds after it has been turned off.
 * @param mess the message. Use "" for no message.
 *
 *
 */
void set_turn_off_mess(string mess){  _turn_off_mess = mess;  }

/**
 * This function returns the message that is printed to the room
 * containing the fireplace a few seconds after is has been turned off.
 * @return the message.
 */
string query_turn_off_mess(){  return _turn_off_mess;  }

/** @ignore yes */
void msg_on(){
  if(_is_lit){
    tell_room(environment( this_object() ), query_turn_on_mess() );
  }
}

/** @ignore yes */
int turn_on(){
  int x;
  FUEL_HANDLER->add_burner( this_object() );
  _is_lit = 1;
  adjust_light( query_light_produced() );

    x = query_light_produced() / 4;
    add_property("degrees", query_light_produced() * 4);
    environment( this_object() )->add_property("warmth", x );

  call_out( "msg_on", 7 );
  return 1;
}

/** @ignore yes */
int do_dowse(object *obs){

  if( !_is_lit ){
    this_player()->add_failed_mess( this_object(),
         "There is no fire to put out.\n", ({ }) );
    return 0;
  } else {
    this_player()->add_succeeded_mess(this_object(),
      "$N $V $D and the room loses its warm glow.\n", ({ }) );
    return turn_off();
  }

}

/** @ignore yes */
void msg_off() {
  if(!_is_lit){
    tell_room(environment( this_object() ), query_turn_off_mess() );
  }
}

/** @ignore yes */
int turn_off(){

  FUEL_HANDLER->remove_burner( this_object() );
  _is_lit = 0;
  adjust_light( -query_light_produced() );
  add_property( "degrees", 0 );
  environment( this_object() )->remove_property("warmth");

  call_out( "msg_off", 10 );
  return 1;

}

/**
 * This function sets the message that is printed to the room containing
 * the fireplace, when the fuel runs out.
 * @param mess the message.
 */
void set_out_of_fuel_mess(string mess){  _out_of_fuel_mess = mess;  }

/**
 * This function returns the message that is printed to the room
 * containing the fireplace when it runs out of fuel.
 * @return the message.
 */
string query_out_of_fuel_mess(){  return _out_of_fuel_mess;  }

/** @ignore yes */
void out_of_fuel() {

  turn_off();
  tell_room(environment( this_object() ), query_out_of_fuel_mess() );
}


/**
 * This function sets the array of room chats that will be printed
 * when the fireplace is lit. One chat is chosen randomly every
 * 15 * query_frequency() seconds.
 * @param str an array containing the desired chats
 * @see query_frequency()
 * @see set_frequency()
 * @see set_dying_chats()
 */
void set_lit_chats(string *str){  _lit_chats = str;  }

/**
 * This functions adds a string to the array of room chats that
 * will be printed
 * when the fireplace is lit. One chat is chosen randomly every
 * 15 * query_frequency() seconds.
 * @param str the string to be added to the array
 * @see query_frequency()
 * @see set_frequency()
 * @see set_dying_chats()
 * @see set_lit_chats()
 */
void add_lit_chat(string str){
  if( !_lit_chats ){
    _lit_chats = ({ });
  }
  _lit_chats += ({ str });
}

/** @ignore yes */
string request_lit_chat(){
  return _lit_chats[random( sizeof(_lit_chats) - 1 )];
}

/**
 * This functions sets the array of room chats that will be printed
 * when the fire is dying away. One chat is chosen randomly every
 * 15 * query_frequency() seconds.
 * @param str an array containing the desired chats
 * @see query_frequency()
 * @see set_frequency()
 * @see set_lit_chats()
 */
void set_dying_chats(string *str){  _dying_chats = str;  }

/**
 * This functions adds a string to the array of room chats that
 * will be printed
 * when the fire is dying away. One chat is chosen randomly every
 * 15 * query_frequency() seconds.
 * @param str the string to be added to the array
 * @see query_frequency()
 * @see set_frequency()
 * @see set_dying_chats()
 * @see set_lit_chats()
 */
void add_dying_chat(string str){
  if( !_dying_chats ){
    _dying_chats = ({ });
  }
  _dying_chats += ({ str });
}

/** @ignore yes */
string request_dying_chat(){
  return _dying_chats[random( sizeof(_dying_chats) - 1 )];
}

/**
 * This function sets the message that will be appended to the fireplace's
 * long when it is lit
 * @param str the message to be displayed
 */
void set_lit_mess(string str){  _lit_mess = str;  }

/** @ignore yes */
string query_lit_mess(){  return _lit_mess;  }

/**
 * This function sets the message that will be appended to the fireplace's
 * long when it is not lit
 * @param str the message to be displayed
 */
void set_unlit_mess(string str){  _unlit_mess = str;  }

/** @ignore yes */
string query_unlit_mess(){  return _unlit_mess;  }


/* This function is called by the burner handler even few seconds.
   It sorts out the burning of fuel and printing of messages
 */
/** @ignore yes */
void consume_fuel() {
  int x;
  int q;
  int z;
  int w;
  int amount;
  string r;
  object *inv;
  object ashes;
  object thing;
  object env;

  inv = filter(all_inventory( this_object() ),
              (:$1->query_property("fuel") :));

  if( !inv || inv == ({ }) || calc_fuel() < 1){
    out_of_fuel();
    return;
  }

  x = sizeof(inv);

  foreach(thing in inv){
      q = thing->query_amount_left();
      w = thing->query_weight();

      z = q - ( ( BURN_PER_TICK * 100 / x ) / w );

      if ( z < 1 ){
          thing->move("/room/rubbish");
          amount = roll_MdN(4, 20);
          ashes = clone_object("/obj/cont_medium");
          ashes->set_name("ash");
          ashes->set_short("fine grey ash");
          ashes->add_property("determinate", "some ");
          ashes->add_adjective(({"some", "fine", "grey", "pinch", "pinches",
           "handful", "handfuls", "bucketful", "bucketfuls", "of"}));
          ashes->add_plural("ash");
          ashes->set_long("This is $pile_size$ of fine grey ash, "
            "$amount_size$. It looks like it was the leftovers "
            "from someone's camp fire.\n");
          ashes->set_weight_unit(({ 1, 50 }));
          ashes->set_medium_alias("FiNeGrEyAsH");
          ashes->set_amount_types((["pinch" : ({1, "pinches"}),
           "handful" : ({50, "handfuls"}),
           "bucketful" : ({1000, "bucketfuls"})]));
          ashes->set_pile_types(({50, "small", 100, "medium",
            200, "large", "huge"}));
          ashes->set_continuous();
          ashes->set_amount(amount);
          ashes->move(this_object());
      } else {
        thing->set_amount_left( z );
      }

  }

  // Re calculate fuel left
  calc_fuel();

  // Now sort out the printing of messages
  env = environment( this_object() );

  /* Adding and removing room chats was a hassle, and things didn't go
   * smoothly. Using tell_room is much easier
   */
  if( random( query_frequency() ) == 1 ){
    if( calc_fuel() > 10 ){

      r = request_lit_chat();
      tell_room( env, r + "\n");

    } else {

      r = request_dying_chat();
      tell_room( env, r + "\n");

    }
  }

}

/** @ignore yes */
int calc_fuel(){
  object *inv;
  object thing;
  int tot_fuel = 0;
  int w;
  int amt;

  inv = all_inventory( this_object() );

  if( !inv || inv == ({ }) ) { return 0; }

  foreach(thing in inv){
    if( thing->query_property("fuel") ){
      w =  thing->query_weight();
      amt = thing->query_amount_left();
      tot_fuel += w * amt * K / 100 ;
    }
  }

  return tot_fuel;

}

/** @ignore yes */
int test_remove( object thing, int flat, mixed dest){
  object tp;
  object *prev;
  tp = this_player();
  prev = previous_object(-1);

  /* Below: make sure this func is being called by a person trying to get
   * items from here, not by a move call made in earlier functions.
   */
  if(_is_lit && tp && strsrch( file_name(prev[1]), CMD ) != -1 ){
    tell_object(tp, "You reach out towards the fire but "
       "you can't brave the flames and quickly pull away.\n");

    tell_room( environment(tp), tp->query_short() + " tries to take something "
      "from the fire but pulls back sucking " + tp->query_possessive() +
      " fingers.\n", tp);
    tp->adjust_hp( -random(120) );
    return 0;
  }
  return ::test_remove(thing, flat, dest);
}

/** @ignore yes */
int test_add( object thing, int flag ) {

  if( !thing->query_property("fuel") && environment(thing) ){
    tell_object(this_player(), "You don't think " + thing->the_short() +
      " would be a suitable fuel.\n");
    return 0;
  }

  if( _is_lit ){
    tell_room(environment( this_object() ),
      ({ "The fire crackles.\n",
         "A shower of glowing embers tumble around the hearth.\n" })[random(2)] );
  }


  call_out("calc_fuel",1);
  return 1;
}

/** @ignore yes */
string extra_look( object ob ){

  if( _is_lit ) {
      return query_lit_mess();
  }
  else {
      return query_unlit_mess();
  }

}

void pre_dest_me() {
  int tmp;

  if(_is_lit && environment()) {
    FUEL_HANDLER->remove_burner( this_object() );
    _is_lit = 0;
    adjust_light( -query_light_produced() );
    tmp = environment()->query_property("warmth");
    if(tmp > query_light_produced() / 4)
      environment()->add_property("warmth", tmp -
                            (query_light_produced() / 4));
    else
      environment()->remove_property("warmth");
  }

  return;
}

/** @ignore yes */
void dest_me() {
  FUEL_HANDLER->remove_burner( this_object() );
  _is_lit = 0;
   ::dest_me();
}

// --- END [/mnt/home2/grok/lib/std/room/furniture/fireplace.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/furniture/vessel.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/furniture/vessel.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629184   Available: 13576538
Inodes: Total: 5242880    Free: 4960135
2891 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/furniture/vessel.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629184   Available: 13576538
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is a furniture item for making vessel furniture.
 * It is basically the basic furniture inherit with 
 * /obj/vessel instead of /std/object as a inherit
 * @author Gin
 * @started Sat Aug  4 10:53:51 PDT 2001
 */
#include <move_failures.h>
#include <position.h>

inherit "/obj/vessel";
inherit "/std/basic/item_chat";
inherit "/std/room/furniture/inherit/furniture_base";

void create() {
   do_setup++;
   vessel::create();
   furniture_base::create();
   add_alias( "furniture" );
   add_plural( "furniture" );
   add_property("talisman", "no one");
   set_opaque();
   if ( !query_property( "shop type" ) ) {
      add_property( "shop type", "furniture" );
   }

   do_setup--;
   if ( !do_setup ) {
     this_object()->setup();
   }
   // Don't respond to 'get all'
   set_no_all(1);
} /* create() */

void init() {
   item_chat::init();
} /* init() */

/* Furniture is much harder to carry than just its weight, therefore we
 * multiply its weight by 5 to determine if someone can carry it.
 */
/** @ignore yes */
varargs int move( mixed dest, string messin, string messout ) {
  int i, t, f;
  object from;

  if(stringp(dest)) {
    dest = find_object(dest);
  }

  if (!move_check(dest)) {
     write(the_short() + " resists being picked up and shocks you slightly.\n");
     return MOVE_INVALID_DEST;
  }

  if(!dest) {
    return MOVE_INVALID_DEST;
  }

  if(living(dest)) {
    t = (int)this_object()->query_complete_weight() * 2;
    if(!(dest->add_weight(t))) {
      return MOVE_TOO_HEAVY;
    }
    debug_printf("Added %d", t);
  }

  i = ::move(dest, messin, messout);

  if(i != MOVE_OK) {
    dest->add_weight(-t);
    return i;
  }

  from = environment();
  if(from && living(from)) {
    f = (int)this_object()->query_complete_weight() * 2;
    from->add_weight(-f);
  }

  return i;
} /* move() */

/** @ignore yes
 * This stops people dragging items awa
y if they aren't allowed to.
 */
int get(mixed dest) {
  if(!move_check(dest)) {
    write("You feel it would be wrong to take " + the_short() + ".\n");
    return 2;
  }
  return ::get(dest);
}
/** @ignore yes */
mixed query_static_auto_load() {
  if ( base_name(this_object()) + ".c" == __FILE__ ) {
    return int_query_static_auto_load();
  }
  return ([ ]);
}

/** @ignore yes */
mixed query_dynamic_auto_load() {
   mapping junk;

   junk = vessel::query_dynamic_auto_load();
   if (!junk) {
      junk = ([ ]);
   }
   junk["bonded"] = query_bonded();
   return junk;
} /* query_dynamic_auto_load() */

/** @ignore yes */
void init_dynamic_arg(mapping map) {
   vessel::init_dynamic_arg(map);
   set_bonded(map["bonded"]);
} /* init_dynamic_arg() */

/** @ignore yes */
string query_help_file_directory() {
   return "/doc/furniture/";
} /* query_help_file_directory() */

/** @ignore yes */
mixed *stats() {
   return ::stats() +
          ({ ({ "bonded", query_bonded() }) });
} /* stats() */
// --- END [/mnt/home2/grok/lib/std/room/furniture/vessel.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/furniture/chime_inherit.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/furniture/chime_inherit.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629183   Available: 13576537
Inodes: Total: 5242880    Free: 4960135
5580 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/furniture/chime_inherit.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629183   Available: 13576537
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*
 * @author Tannah
 * @started April 2k
 *
 * A fnu little wind chime thingie.  You can set its type to whatever
 * you like.  Be sure to also set its value to something appropriate
 * for its type.  The default type is "metal"; the default value is
 * 420.  It also comes with a couple default verbs which can be
 * removed or added to as desired.  It will chime only when hung up
 * in a room that 1) returns a value to query_wind_speed(), 2) is
 * outside, or 3) has the property "windy".  It can be "hung" on 
 * things that return a value to query_hook() or have the property
 * "hook", and then "unhung".
 */

inherit "/std/object";
inherit "/std/room/furniture/inherit/furniture_base";

#include <weather.h>
#define TIME 120 // 2 minutes

string chimes_short();
string chimes_long();
void set_chime_type( string type );
string chime_type();
void jingle();
string chime_verb();
void add_chime_verb( string verb );
void remove_chime_verb( string verb );
string *query_chime_verbs();
void set_hung_up( int up ); 
int hung_up();
void set_hook( object hook );
object hook();

int do_hang( object hook );
int do_unhang();

private string _chime_type = "metal";
private string *_chime_verbs = ({ "jingles", "tinkles" });
private int _hung_up = 0;
private object _hook;

void create() {
   furniture_base::create();
   object::create();
} /* create() */

/** @ignore */
void setup() {
  set_name( "chime" );
  set_short( (: chimes_short() :) );
  set_long( (: chimes_long() :) );
  add_adjective( ({ "wind", chime_type() }) );
  set_value( 420 );
} /* setup() */

/** @ignore */
void init() {
  add_command( "hang", "<direct:object'chime'> {on|from} "
      "<indirect:object'hook'>", (: do_hang( $1[0] ) :) );
  add_command( "unhang", "<direct:object'chime'>" );
} /* init() */

/** @ignore */
string chimes_short() { 
  return chime_type() + " wind chime";
} /* chimes_short() */

/** @ignore */
string chimes_long() {
  return "This little wind chime is nothing more than bits of "
             + chime_type() + " dangling from strings tied to a "
             "ring.\n";
} /* chimes_long() */

/** @ignore */
void set_chime_type( string type ) { 
  remove_adjective( _chime_type );
  add_adjective( type );
  _chime_type = type;
} /* set_chime_type() */

/** @ignore */
string chime_type() { return _chime_type; }

/** @ignore */
void jingle() {
  object env = environment();
  int wind;

  if( !env )
    return;

  if( !hung_up() )
    return;

  if( !inherits( "/std/room", env ) )
    return;

  wind = env->query_wind_speed();

  if( undefinedp( wind ) ) {
    if( env->query_property( "location" ) == "outside" ||
        env->query_property( "windy" ) )
      wind = WEATHER->query_windsp( this_object() );
    else
      return;
  }

  if( random( wind ) ) // the chance is higher for high winds. D'oh.
    tell_room( env, the_short() + chime_verb() + " in the "
        "wind.\n" );
  call_out( "jingle", TIME );
} /* jingle() */

/** @ignore */
string chime_verb() { 
  return " " + _chime_verbs[ random( sizeof( _chime_verbs ) ) ];
} /* chime_verb() */

/** @ignore */
void add_chime_verb( string verb ) {
  _chime_verbs += ({ verb });
} /* add_chime_verb() */

/** @ignore */
void remove_chime_verb( string verb ) {
  _chime_verbs -= ({ verb });
} /* remove_chime_verb() */

/** @ignore */
void set_chime_verbs( string *verbs ) { _chime_verbs = verbs; }

/** @ignore */
string *query_chime_verbs() { return _chime_verbs; }

/** @ignore */
void set_hung_up( int up ) { 
  remove_call_out( "jingle" );
  if( up )
    call_out( "jingle", 30 );
  _hung_up = up;
} /* set_hung_up() */

/** @ignore */
int hung_up() { return _hung_up; }

/** @ignore */
void set_hook( object hook ) { _hook = hook; }

/** @ignore */
object hook() { return _hook; }

/** @ignore */
int jingling() { return find_call_out( "jingle" ); }

/** @ignore */
void init_dynamic_arg( mapping arg ) {
  set_chime_type( arg[ "type" ] );
  set_chime_verbs( arg[ "chime verbs" ] );
  set_hook( arg[ "hook" ] );
  set_hung_up( arg[ "hung up" ] );
  if( undefinedp( hook() ) || !hung_up() ||
      !sizeof( match_objects_for_existence( hook(), ({ environment() }) ) ) ) {
    remove_property( "there" );
    set_hung_up( 0 );
  }
} /* init_dynamic_arg() */

/** @ignore */
mixed query_dynamic_auto_load() {
  return ([ "::" : ::query_dynamic_auto_load(),
            "type" : chime_type(),
            "chime verbs" : query_chime_verbs(),
            "hung up" : hung_up(),
            "hook" : hook() ]);
} /* query_dynamic_auto_load() */

/** @ignore yes */
int do_hang( object hook ) {
  string where = hook->a_short();

  /* Is it already hanging? */
  if( hung_up() ) {
    add_failed_mess( "The chime is already hanging up.\n" );
    return 0;
  }
    
  /* Can the hook actually be used to hang things from? */
  if( !hook->query_hook() && !hook->query_property( "hook" ) )
    return 0;

  /* Can the chime be dropped? */
  if( move( environment( this_player() ) ) )
    return 0;

  /* set its position and make it impossible to get */
  if( where )
    where = "on " + where;
  else
    where = "up";

  add_property( "there", "hanging "+ where );
  reset_get();
  set_hung_up( 1 );
  set_hook( hook );
  this_player()->add_succeeded_mess( this_object(), "$N $V $D on "
      "$I.\n", ({ hook }) );
  return 1;
} /* do_hang() */

/** @ignore yes */
int do_unhang() {
  if( !hung_up() ) {
    add_failed_mess( "The chime isn't hanging from anything.\n" );
    return 0;
  }
  remove_property( "there" );
  set_get();
  set_hung_up( 0 );
  move( this_player() );
  return 1;
} /* do_unhang() */
// --- END [/mnt/home2/grok/lib/std/room/furniture/chime_inherit.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/furniture/storage.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/furniture/storage.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629182   Available: 13576536
Inodes: Total: 5242880    Free: 4960135
9837 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/furniture/storage.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629182   Available: 13576536
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: storage.c,v 1.26 2003/04/22 16:55:09 ceres Exp $
 *
 *
 */
/**
 * This is a furniture item for making all kinds of furniture that store
 * things.
 *
 * If you want to make a chest just use set_max_weight() to set how much
 * weight it can store.
 *
 * If you want it to have drawers or shelves use the add_drawer() and
 * set_drawer_mess() functions to set them up.
 *
 */
#include <move_failures.h>
#include <position.h>
#include <tasks.h>

inherit "/obj/cont_save";
inherit "/std/basic/trap";
inherit "/std/room/furniture/inherit/furniture_base";

private nosave string _drawer_mess;
private nosave mixed *_drawers;
private nosave int _biggest;
private nosave int _drawers_inside;

#undef DEBUG

void create() {
   do_setup++;
   furniture_base::create();
   cont_save::create();
   _drawer_mess = "a drawer in $ob_short$";
   _drawers = ({ });
   add_alias( "furniture" );
   add_plural( "furniture" );
   set_opaque();

   do_setup--;
   if ( !do_setup ) {
     this_object()->setup();
   }
   // Don't respond to 'get all'
   set_no_all(1);
} /* create() */

/**
 * This method returns the message associated with the drawer.
 * @return the message associated with the drawer
 * @see set_drawer_mess()
 * @see query_drawers()
 * @see add_drawer()
 */
string query_drawer_mess() { return _drawer_mess; }

/**
 * This method sets the message associated with the drawer.
 * @param words the message associated with the drawer
 * @see query_drawer_mess()
 * @see add_drawer()
 */
void set_drawer_mess( string words ) { _drawer_mess = words; }

/**
 * This method returns all the drawers on the object.
 * @return all the drawers on the object
 * @see add_drawer()
 */
mixed *query_drawers() { return _drawers; }

/**
 * This method adds a drawer onto the furniture.
 *
 * @param type the type of drawer
 * @param amount the amount the drawer can hold
 * @see query_drawers()
 * @see set_drawer_mess()
 * @see query_drawer_mess()
 */
void add_drawer( string type, int amount ) {
   if ( !type || ( type == "" ) || ( amount < 1 ) ) {
      return;
   }
   _drawers += ({ type, amount });
   set_max_weight(query_max_weight() + amount);
   if ( amount > _biggest ) {
      _biggest = amount;
   }
} /* add_drawer() */


/**
 * Set the drawers to be on the inside, and hence not visible when the
 * door is closed.
 */
void set_drawers_inside(int i) { _drawers_inside = i; }

/**
 * Set the drawers to be on the inside, and hence not visible when the
 * door is closed.
 */
int query_drawers_inside() { return _drawers_inside; }

/** @ignore yes */
/* Furniture is much harder to carry than just its weight, therefore we
 * multiply its weight by 5 to determine if someone can carry it.
 */
varargs int move( mixed dest, string messin, string messout ) {
  int i, w;
  object from;

  if (!move_check(dest)) {
     write(the_short() + " resists being picked up and shocks you slightly.\n");
     return MOVE_INVALID_DEST;
  }

  w = (int)this_object()->query_complete_weight() * 5;
  if ( from = environment() ) {
    from->add_weight( -w );
  }
  if(!dest) {
    return MOVE_INVALID_DEST;
  }
  
  if (!( dest->add_weight( w ) ) ) {
    if ( from ) {
      from->add_weight( w );
    }
    return MOVE_TOO_HEAVY;
  }
  if ( stringp( dest ) ) {
    dest = find_object( dest );
  }
  i = ::move( dest, messin, messout );
  if ( i != MOVE_OK ) {
    if ( from ) {
      from->add_weight( w );
    }
    dest->add_weight( -w );
  } else if (query_light_needs_inform()) {
    if ( from ) {
      inform_of_light_level_change(from);
    }
    inform_of_light_level_change(dest);
  }
  return i;
} /* move() */

/** @ignore yes
 * This stops people dragging items away if they aren't allowed to.
 */
int get(mixed dest) {
  if(!move_check(dest)) {
    write("You feel it would be wrong to take " + the_short() + ".\n");
    return 2;
  }
  return ::get(dest);
}

/** @ignore yes */
string long( string word, int dark ) {
   int i;
   string ret, *sizes;
   mapping types;

  ret = ::long( word, dark );
   if ( sizeof( _drawers ) && !dark &&
        (!query_closed() || !_drawers_inside)) {
     types = ([ ]);
     for ( i = 0; i < sizeof( _drawers ); i += 2 ) {
       types[ _drawers[ i ] ]++;
     }
     sizes = m_indices( types );
     for ( i = 0; i < sizeof( sizes ); i++ ) {
       sizes[ i ] = query_num( types[ sizes[ i ] ] ) +" "+ sizes[ i ] +
         " drawer"+ ( types[ sizes[ i ] ] > 1 ? "s" : "" );
     }
     ret += "It has "+ query_multiple_short( sizes ) +".\n";
   }
   return ret;
} /* long() */

/**
 * @ignore yes
 * Makes sure furniture is removed from the save file
 * when its removed from this room.
 */
int test_remove(object thing, int flag, mixed dest) {
  int result;
  mixed *stuff;
  object thief;
  
  result = ::test_remove(thing, flag, dest);

  if(result && environment() && this_player()) {
    thief = this_player();
    if(thief->query_caster())
      thief = find_player(thief->query_caster());
    else if(thief->query_owner())
      thief = thief->query_owner();
    
    stuff = thing->query_property("dropped");
    
    /*
     * It's theft if the item is being removed by someone other than the
     * occupier and someone other than the person who dropped it.
     */
    if(function_exists("test_occupier", environment()) &&
       !environment()->test_occupier(thief->query_name()) &&
       (!sizeof(stuff) || stuff[0] != thief->query_name()) &&
       thief && environment(thief)) {
      event(environment(thief), "theft", thief, this_object(), ({ thing }));
    }
    
#ifdef DEBUG
    if(base_name(environment()) != "/room/rubbish")
      log_file(base_name(environment()) + ".log",
               "%s %s moved from %s to %s.\n", ctime(time())[4..18],
               thing->query_short(), this_object()->query_short(),
               dest->query_short());
#endif
    event(environment(), "save");
  }
  
  return result;
}
 
/** @ignore yes */
int test_add( object thing, int flag ) {
  int i;
  
  if ( flag )
    return 0;
  
  if(!environment(thing))
    return 1;

  // Lets see if we're using drawers or not.
  if(sizeof(_drawers)) {
    if ( !_biggest )
      for ( i = 0; i < sizeof( _drawers ); i+= 2 )
        if ( _drawers[ i + 1 ] > _biggest )
          _biggest = _drawers[ i + 1 ];
    
    if ( (int)thing->query_complete_weight() > _biggest )
      return write( (string)thing->the_short() +" is too big "+
                    "to fit in any of "+ the_short() +"'s drawers.\n" );
  }
  
  event(environment(), "save", this_object());
  
  i = ::test_add(thing, flag);
#ifdef DEBUG
  if(environment() && base_name(environment()) != "/room/rubbish")
    log_file(base_name(environment()) + ".log",
             "%s %s put in %s by %s [%d].\n", ctime(time())[4..18],
             thing->query_short(), this_object()->query_short(),
             this_player() ? this_player()->query_name() : "Unknown",
             i);
#endif
  return i;
}

/** @ignore yes */
private int pick_ok(object player) {
  mixed owner;

  if(!environment() ||
     !function_exists("query_owner", environment()) ||
     environment()->test_occupier(player->query_name()))
    return ::pick_unlock(player);

  // Ok, we have two situations. Single owner (then do PK check) or
  // multiple owner, in which case we just check the player is a pk.
  owner = environment()->query_owner();

  if(stringp(owner) && pk_check(player, owner, 1)) { // do the PK check
    write("You feel it would be wrong to try to break into "+
          this_object()->query_short() + ".\n");
    return 0;
  }

  return ::pick_unlock(player);
}

/** @ignore yes */
int pick_unlock(object player) {
  if(!pick_ok(player))
    return 0;
  
  return ::pick_unlock(player);
}

/** @ignore yes */
int pick_lock(object player) {
  if(!pick_ok(player))
    return 0;
  
  return ::pick_lock(player);
}

/** @ignore yes */
mixed *stats() {
  int i;
  mixed *ret;
  ret = ::stats();
  for ( i = 0; i < sizeof( _drawers ); i += 2 )
    ret += ({ ({ _drawers[ i ] +" drawer", _drawers[ i + 1 ] }) });
  return ret;
} /* stats() */

/** @ignore yes */
mapping int_query_static_auto_load() {
  return ([
           "::" : ::int_query_static_auto_load(),
           "drawer mess" : _drawer_mess,
           "drawers" : _drawers,
           "allowed_positions" : query_allowed_positions(),
           "trap" : query_trap_data(),
           "trap armed": query_trap_armed(),
           ]);
} /* query_static_auto_load() */

/** @ignore yes */
mapping query_static_auto_load() {
  return int_query_static_auto_load();
} /* query_static_auto_load() */

/** @ignore yes */
void init_static_arg( mapping map ) {
  if ( !mapp( map ) )
    return;
  if ( map[ "::" ] )
    ::init_static_arg( map[ "::" ] );
  if ( !undefinedp( map[ "drawer mess" ] ) )
    _drawer_mess = map[ "drawer mess" ];
  if ( !undefinedp( map[ "drawers" ] ) )
    _drawers = map[ "drawers" ];
  if(!undefinedp(map["allowed_positions"]))
    set_allowed_positions(map["allowed_positions"]);
  if(!undefinedp(map["trap"]))
    setup_trap(map["trap"][0],
                   map["trap"][1],
                   map["trap"][2],
                   map["trap"][3],
                   map["trap"][4]);
  if(!undefinedp(map["trap armed"]))
    set_trap_armed(map["trap armed"]);
} /* init_static_arg() */

/** @ingore yes */
string query_help_file_directory() {
   return "/doc/furniture/";
} /* query_help_file_directory() */

/** @ignore yes */
mixed query_dynamic_auto_load() {
   mapping junk;

   junk = cont_save::query_dynamic_auto_load();
   if (!junk) {
      junk = ([ ]);
   }
   junk["bonded"] = query_bonded();
   return junk;
} /* query_dynamic_auto_load() */

/** @ignore yes */
void init_dynamic_arg(mapping map, object) {
   cont_save::init_dynamic_arg(map, 0);
   set_bonded(map["bonded"]);
} /* init_dynamic_arg() */
// --- END [/mnt/home2/grok/lib/std/room/furniture/storage.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/furniture/document_handler.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/furniture/document_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629179   Available: 13576533
Inodes: Total: 5242880    Free: 4960135
1922 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/furniture/document_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629179   Available: 13576533
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * The furniture object for the document handler.
 * @author Pinkfish
 * @started Tue Jan 15 16:43:39 PST 2002
 */

inherit "/std/room/furniture/commercial";
inherit "/std/room/furniture/inherit/document_handler";

#include <room/document_handler.h>

void create() {
   document_handler::create();
   commercial::create();
   add_help_file("document_handler");
   set_shop_use_types( ({ "document_view",
                          "document_add",
                          "document_delete" }) );
} /* create() */

/** @ignore yes */
string query_save_dir() {
   return commercial::query_save_dir() + "/" + query_commercial_id();
} /* query_save_dir() */

/** @ignore yes */
void load_me() {
   if (!query_commercial_id()) {
      setup_new_commercial_id();
   }

   // Make the directory for our stuff to go in.
   if (unguarded( (: file_size(query_save_dir()) :) ) != -2) {
      unguarded( (: mkdir(query_save_dir()) :));
   }
} /* load_me() */

void save_me() {
   environment()->event_save(this_object());
} /* save_me() */

/** @ignore yes */
void init() {
   add_command("list", "documents [from] <direct:object>", (: do_list() :));
   add_command("view", "document <string'id'> [from] <direct:object>",
                (: do_display($4[0]) :));
   add_command("add", "documents {html|plain} called <string:quoted'title'> to <direct:object>",
               (: do_add_document($4[1], ($4[0] == "html"?DOCUMENT_HTML:DOCUMENT_PLAIN)) :));

   add_command("delete", "document <string'id'> [from] <direct:object>",
                (: do_delete_document($4[0]) :));
} /* init() */

/** @ignore yes */
mapping query_dynamic_auto_load() {
   mapping map;

   map = commercial::query_dynamic_auto_load();
   document_handler::query_dynamic_auto_load(map);
   return map;
}

void init_dynamic_arg(mapping map) {
   document_handler::init_dynamic_arg(map);
   commercial::init_dynamic_arg(map);
} /* init_dynamic_arg() */
// --- END [/mnt/home2/grok/lib/std/room/furniture/document_handler.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/furniture/games/card_base.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/furniture/games/card_base.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629178   Available: 13576532
Inodes: Total: 5242880    Free: 4960135
9779 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/furniture/games/card_base.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629178   Available: 13576532
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is a base to make up randomised decks of cards.
 * @author Pinkfish
 * @started Thu Dec  7 07:34:10 PST 2000
 */
#include <room/card_base.h>

#define CARD_NUM_MAX CARD_NUMBER_KING

int is_card_red(class playing_card card);

class playing_card* make_deck(int number_of_decks,
                              int number_of_jokers) {
   class playing_card* deck;
   class playing_card card;
   int i;
   int suit;
   int num;

   deck = ({ });
   for (i = 0; i < number_of_decks; i++) {
      for (suit = CARD_SUIT_HEARTS; suit <= CARD_SUIT_SPADES; suit++) {
         for (num = 1; num <= CARD_NUM_MAX; num++) {
            card = new(class playing_card);
            card->suit = suit;
            card->number = num;
            deck += ({ card });
         }
      }
   }
   for (i = 0; i < number_of_jokers; i++) {
      card = new(class playing_card);
      card->suit = CARD_SUIT_JOKER;
      deck += ({ card });
   }
   return deck;
} /* make_deck() */

/**
 * This method scrabled the deck and shuffles it.
 * @param deck the deck to shuffle
 * @return a shuffled deck
 */
class playing_card* shuffle_deck(class playing_card* deck) {
   class playing_card* new_deck;
   int pos;
   int i;

   for (i = 0; i < 2; i++) {
      new_deck = ({ });
      while (sizeof(deck)) {
         pos = random(sizeof(deck));
         new_deck += deck[pos..pos];
         deck = deck[0..pos - 1] + deck[pos+1..];
      }
      deck = new_deck;
   }
   return deck;
} /* shuffle_deck() */

/**
 * This method returns the suit letter associated with the card.
 * @param suit the suit to get the letter of
 * @return the letter of the suit
 */
string query_suit_letter(int suit) {
   switch (suit) {
   case CARD_SUIT_SPADES :
      return "S";
      break;
   case CARD_SUIT_HEARTS :
      return "H";
      break;
   case CARD_SUIT_DIAMONDS :
      return "D";
      break;
   case CARD_SUIT_CLUBS :
      return "C";
      break;
   case CARD_SUIT_JOKER :
      return "J";
   }
} /* query_suit_letter() */

/**
 * This method returns the three character string for the card.
 * @return the three character string for the card
 */
string query_card_string(class playing_card card) {
   string ret;
   string colour;

   if (card->suit == CARD_SUIT_JOKER) {
      return "*J*";
   }
   ret = query_suit_letter(card->suit) + "%^RESET%^";
   if (is_card_red(card)) {
      colour = "%^BOLD%^%^RED%^";
   } else {
      colour = "%^BOLD%^";
   }

   if (card->number > 10 || card->number == CARD_NUMBER_ACE) {
      switch (card->number) {
      case CARD_NUMBER_JACK :
         ret = colour + "J " + ret;
         break;
      case CARD_NUMBER_QUEEN :
         ret = colour + "Q " + ret;
         break;
      case CARD_NUMBER_KING :
         ret = colour + "K " + ret;
         break;
      case CARD_NUMBER_ACE :
         ret = colour + "A " + ret;
         break;
      }
   } else {
      ret = sprintf("%s%-2d%s", colour, card->number, ret);
   }
   return ret + "%^RESET%^";
} /* query_card_string() */

/**
 * This method determines if the card colour is red.
 * @param card the card to check
 * @return 1 if it is, 0 if not
 */
int is_card_red(class playing_card card) {
   return card->suit == CARD_SUIT_HEARTS || card->suit == CARD_SUIT_DIAMONDS;
} /* is_card_red() */

/**
 * This method determines if the card colour is black.
 * @param card the card to check
 * @return 1 if it is, 0 if not
 */
int is_card_black(class playing_card card) {
   return card->suit == CARD_SUIT_SPADES || card->suit == CARD_SUIT_CLUBS;
} /* is_card_black() */

/**
 * This method checks to see if the card is a joker.
 * @param card the card to check
 * @return 1 if it is, 0 if not
 */
int is_card_joker(class playing_card card) {
   return card->suit == CARD_SUIT_JOKER;
} /* is_card_joker() */

/**
 * This method makes a array for a 3x3 card.
 * @param card the card to make 3x3
 * @return the three line array
 */
string* query_card_three(class playing_card card) {
   string* lines;

   if (is_card_red(card)) {
      lines = allocate(3, "%^BOLD%^%^RED%^");
   } else {
      lines = allocate(3, "%^BOLD%^");
   }
   switch (card->suit) {
   case CARD_SUIT_HEARTS :
      lines[0] += "H  %^RESET%^";
      lines[2] += "  H%^RESET%^";
      break;
   case CARD_SUIT_DIAMONDS :
      lines[0] += "D  %^RESET%^";
      lines[2] += "  D%^RESET%^";
      break;
   case CARD_SUIT_CLUBS :
      lines[0] += "C  %^RESET%^";
      lines[2] += "  C%^RESET%^";
      break;
   case CARD_SUIT_SPADES :
      lines[0] += "S  %^RESET%^";
      lines[2] += "  S%^RESET%^";
      break;
   case CARD_SUIT_JOKER :
      lines[0] += "J *%^RESET%^";
      lines[1] += " O %^RESET%^";
      lines[2] += "* K%^RESET%^";
      return lines;
   }

   if (card->number <= 10 && card->number != CARD_NUMBER_ACE) {
      if (card->number == 10) {
         lines[1] += " 10%^RESET%^";
      } else {
         lines[1] += " " + card->number + " %^RESET%^";
      }
   } else {
      switch (card->number) {
      case CARD_NUMBER_KING :
         lines[1] += " K %^RESET%^";
         break;
      case CARD_NUMBER_QUEEN :
         lines[1] += " Q %^RESET%^";
         break;
      case CARD_NUMBER_JACK :
         lines[1] += " J %^RESET%^";
         break;
      case CARD_NUMBER_ACE :
         lines[1] += " A %^RESET%^";
         break;
      }
   }
   return lines;
} /* query_card_three() */

/**
 * This method makes a array for a 2x2 card.
 * @param card the card to make 2x2
 * @return the two line array
 */
string* query_card_two(class playing_card card) {
   string* lines;

   lines = allocate(2);
   switch (card->suit) {
   case CARD_SUIT_HEARTS :
      lines[0] = "H ";
      break;
   case CARD_SUIT_DIAMONDS :
      lines[0] = "D ";
      break;
   case CARD_SUIT_CLUBS :
      lines[0] = "C ";
      break;
   case CARD_SUIT_SPADES :
      lines[0] = "S ";
      break;
   case CARD_SUIT_JOKER :
      lines[0] = "J*";
      lines[1] = "*O";
      return lines;
   }

   if (card->number <= 10 && card->number != CARD_NUMBER_ACE) {
      lines[1] = sprintf("%2d", card->number);
   } else {
      switch (card->number) {
      case CARD_NUMBER_KING :
         lines[1] = " K";
         break;
      case CARD_NUMBER_QUEEN :
         lines[1] = " Q";
         break;
      case CARD_NUMBER_JACK :
         lines[1] = " J";
         break;
      case CARD_NUMBER_ACE :
         lines[1] = " A";
         break;
      }
   }
   return lines;
} /* query_card_three() */

/**
 * This method returns a string showing the hand.
 * @param hand the hand to show
 * @param three 1 for a 3x3, 0 for a 2x2
 * @return a string representation of the hand
 */
string query_hand_string(class playing_card* hand, int flags, int cols) {
   string hand_str;
   int i;
   int j;
   int width;
   int start_pos;
   string top;
   string line;
   string start;
   string end;
   string start_space;
   string end_space;
   mixed card_str;

   if (!sizeof(hand)) {
      return "No cards\n";
   }
   hand_str = "";
   if (!(flags & CARD_HAND_NO_ADORNMENTS)) {
      if (flags & CARD_HAND_THREE ||
          flags & CARD_HAND_SINGLE) {
         top = "+---+";
         width = 5;
      } else {
         top = "+--+";
         width = 4;
      }

      start = "|";
      end = "|";
      start_space = " ";
      end_space = " ";
   } else {
      top = 0;
      line = "";
      start = " ";
      end = " ";
      start_space = " ";
      end_space = " ";
      if (flags & CARD_HAND_THREE ||
          flags & CARD_HAND_SINGLE) {
         width = 3;
      } else {
         width = 2;
      }
   }

   start_pos = 0;
   if (flags & CARD_HAND_THREE) {
      card_str = map(hand, (: query_card_three :));
   } else if (flags & CARD_HAND_SINGLE) {
      card_str = map(hand, (: ({ query_card_string($1) }) :));
   } else {
      card_str = map(hand, (: query_card_two :));
   }

   while (start_pos < sizeof(hand)) {
      if (top) {
         //
         // Make the top of the card.
         //
         line = "";
         for (i = 0; i + start_pos < sizeof(hand) && (i + 1) * width < cols; i++) {
            line += top;
         }
         line += "\n";
      }
      if (flags & CARD_HAND_LETTERS) {
         for (i = 0; i + start_pos < sizeof(hand) && (i + 1) * width < cols; i++) {
            if (flags & CARD_HAND_THREE) {
               hand_str += start_space + sprintf(" %c ", 'A' + i + start_pos) + end_space;
            } else {
               hand_str += start_space + sprintf("%c ", 'A' + i + start_pos) + end_space;
            }
         }
      }
      hand_str += "\n" + line;

      for (j = 0; j < sizeof(card_str[0]); j++) {
         for (i = 0; i + start_pos < sizeof(card_str) && (i + 1) * width < cols; i++) {
            hand_str += start + (card_str[i + start_pos][j]) + end;
         }
         hand_str += "\n";
      }

      hand_str += line;
      start_pos += cols / width;
   }

   return hand_str;
} /* query_hand_string() */

private int compare_cards(class playing_card card1, class playing_card card2,
                          int flags) {
   if (card1->suit == card2->suit ||
       (flags & 2)) {
      if (!(flags & 1)) {
         return card1->number - card2->number;
      }
      if (card1->number == CARD_NUMBER_ACE) {
         return 1;
      }
      if (card2->number == CARD_NUMBER_ACE) {
         return -1;
      }
      return card1->number - card2->number;
   }
   return card1->suit - card2->suit;
} /* compare_cards() */

/**
 * This method sorts the cards into useful clumps.
 * @param deck the deck to sort
 * @param flags 1 = ace high, 2 = only numbers
 * @return the sorted deck
 */
class playing_card* sort_cards(class playing_card* deck, int flags) {
   return sort_array(deck,
                (: compare_cards($1, $2, $(flags)) :));
} /* sort_cards() */
// --- END [/mnt/home2/grok/lib/std/room/furniture/games/card_base.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/furniture/games/multiplayer_base.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/furniture/games/multiplayer_base.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629176   Available: 13576530
Inodes: Total: 5242880    Free: 4960135
17528 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/furniture/games/multiplayer_base.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629176   Available: 13576530
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * The base chunk for doing multiplayer board games.
 * @author Pinkfish
 * @started Thu Dec  7 01:27:46 PST 2000
 */
private inherit "/std/basic/auto_load";

#define LOAD_TAG "multiplayer base"

class player_info {
   int number;
   string cap_name;
   string name;
   mixed data;
}

private mapping _players;
private string _winner;
private string* _ids_when_started;
private string _current_player;
private int _minimum_needed;
private int _maximum_allowed;
private int _can_join_as_new;
private int _game_started;

string* query_currently_playing_ids();
void delete_gone_players();
string find_player_id_of_person(object person);

void create() {
   _players = ([ ]);
   _ids_when_started = ({ });
} /* create() */

/**
 * This method should be defined in the top level, it should also
 * call this method to setup stuff as needed when a game starts.
 */
void reset_game() {
//   renumber_players();
} /* reset_game() */

/**
 * This method should be called when a game starts.
 * @return 1 if started, 0 if not enough players
 */
int start_game() {
   delete_gone_players();
   if (sizeof(query_currently_playing_ids()) < _minimum_needed) {
      return 0;
   }
   _winner = 0;
   _game_started = 1;
   _ids_when_started = query_currently_playing_ids();
   //
   // Pick one of these guys to start with.
   //
   _current_player = _ids_when_started[random(sizeof(_ids_when_started))];
   return 1;
} /* start_game() */

/**
 * This method is called when the game ends to set the winner.
 * @param winner the winner
 */
void finish_game(string winner) {
   _winner = winner;
   _game_started = 0;
} /* finish_game() */

/**
 * This method returns the current winner of the game.
 * @return the winner of the game
 */
string query_winner() {
   return _winner;
} /* query_winner() */

/**
 * This method checks to see if the game has started.
 * @return 1 if it has, 0 if it has not
 */
int is_game_started() {
   return _game_started;
} /* is_game_started() */

/**
 * This method checks to see if you can join as a new player, or only
 * occupy the slots from the start of the game.
 * @return 1 if you can join as new
 */
int can_join_as_new_player() {
   return _can_join_as_new;
} /* can_join_as_new_player() */

/**
 * This method sets the flag to allow you to make the game allow players
 * to join after they have started the game.
 * @param join 1 if they can join after the game has started
 */
void set_can_join_as_new_player(int join) {
   _can_join_as_new = join;
} /* set_can_join_as_new_player() */

/**
 * This method checks to see if the person is here.
 * @param person the person to check
 * @return 1 if they are, 0 if not
 */
int is_person_playing(string id) {
   if (_players[id]->name) {
      if (find_player(_players[id]->name) &&
          is_in_me_or_environment(this_object(),
                                  find_player(_players[id]->name)) &&
          interactive(find_player(_players[id]->name))) {
         return 1;
      }
   }
   return 0;
} /* is_person_player() */

/**
 * This method checks to see if the player is player.
 * @return 1 if they are playing, 0 if not
 */
int is_playing(object ob) {
   string id;

   id = find_player_id_of_person(ob);
   return id != 0;
} /* is_playing() */

/**
 * This method checks to see if the object is the current player or not.
 * @return 1 if they are, 0 if not
 */
int is_current_player(object ob) {
   string id;

   id = find_player_id_of_person(ob);
   return id == _current_player;
} /* is_current_player() */

/**
 * This method lets the person join the game.
 * @param id the id of the person to add
 * @param person the person to join
 * @return 1 on success, 0 on failure
 */
int add_person_to_game(string id, object person) {
   class player_info info;

   if (is_person_playing(id)) {
      return 0;
   }
   info = _players[id];
   //info->player_num = _current_player_num++;
   info->name = person->query_name();
   info->cap_name = person->query_cap_name();
   return 1;
} /* add_person_to_game() */

/**
 * This method removes a person from the game.
 * @param person the person to remove
 * @return 1 on success, 0 on failure
 */
int remove_person_object_from_game(object person) {
   class player_info info;
   string id;

   foreach (id, info in _players) {
      if (find_player(info->name) == person) {
         info->name = 0;
         info->cap_name = 0;
         return 1;
      }
   }
   return 0;
} /* remove_person_object_from_game() */

/**
 * This method removes a person from the game.
 * @param id the id to remove
 * @return 1 on success, 0 on failure
 */
int remove_person_id_from_game(string id) {
   if (_players[id]->name) {
      _players[id]->name = 0;
      return 1;
   }
   return 0;
} /* remove_person_object_from_game() */

/**
 * This method randomises the numbers  of the players.
 */
void randomise_player_numbers() {
   string* ids;
   int num;
   int pos;

   ids = keys(_players);
   num = 0;
   while (sizeof(ids)) {
      pos = random(sizeof(ids));
      _players[ids[pos]]->number = num;
      ids = ids[0..pos-1] + ids[pos+1..];
      num++;
   }
} /* randomise_player_nambers() */

/**
 * This method adds a type of allowed player.
 * @param id the id to be allowed
 * @param number the start player number
 */
void add_player_id_type(string id, int number) {
   _players[id] = new(class player_info);
   _players[id]->number = number;
} /* add_player_id_type() */

/**
 * This method removes a player id type.
 * @param id the id to remove
 */
void remove_player_id_type(string id) {
   map_delete(_players, id);
} /* remove_player_id_type() */

/**
 * This method figures out the info structure from the number of the player.
 * @param number the number to lookup
 * @return the info structure, 0 if not found
 */
class player_info find_player_info_from_number(int num) {
   class player_info info;
   string id;

   foreach (id, info in _players) {
      if (info->number == num) {
         return info;
      }
   }
   return 0;
} /* find_player_info_from_number() */

/**
 * This method figures out the id from the number of the player.
 * @param number the number to lookup
 * @return the id, 0 if not found
 */
string find_player_id_from_number(int num) {
   class player_info info;
   string id;

   foreach (id, info in _players) {
      if (info->number == num) {
         return id;
      }
   }
   return 0;
} /* find_player_info_from_number() */

/**
 * This method returns all the ids for the players.
 * @return the ids for the player
 */
string* query_player_ids() {
   return keys(_players);
} /* query_player_ids() */

/**
 * This method returns the list of ids who are current playing.
 * @return the list of currently playing ids
 */
string* query_currently_playing_ids() {
   return filter(keys(_players), (: is_person_playing($1) :));
} /* query_currently_playing_ids() */

/**
 * This method returns the list of ids of people who started playing the
 * game.
 * @return the list of people who started playing the game
 */
string* query_started_player_ids() {
   return _ids_when_started;
} /* query_started_player_ids() */

/**
 * This method returns the players cap name from the player id.
 * @param id the id to look up from
 * @return the players cap name
 */
string query_player_cap_name(string id) {
   if (_players[id] && _players[id]->name) {
      return _players[id]->cap_name;
   }
   return "No one";
} /* query_player_cap_name() */

/**
 * This method returns the player object from the player id.
 * @param id the id for the player
 * @return the player object
 */
object query_player_object(string id) {
   return find_player(_players[id]->name);
} /* query_player_object() */

/**
 * This method returns the players the short from the player id.
 * @param id the id to look up from
 * @return the players 'the short' string
 */
string query_player_the_short(string id) {
   object ob;

   if (_players[id]->name) {
      ob = query_player_object(id);
      if (ob) {
         return ob->the_short();
      }
   }
   return "No one";
} /* query_player_the_short() */

/**
 * This method returns the players poss short from the player id.
 * @param id the id to look up from
 * @return the players 'poss short' string
 */
string query_player_poss_short(string id) {
   object ob;

   if (_players[id]->name) {
      ob = query_player_object(id);
      if (ob) {
         return ob->poss_short();
      }
   }
   return "No one";
} /* query_player_poss_short() */

/**
 * This method nips through the list of players and checks to see if they
 * are in the room or not.  If they are not it deletes them from the array.
 * Useful for start games or cleanups.
 */
void delete_gone_players() {
   string id;
   class player_info info;

   foreach (id, info in _players) {
      if (info->name) {
         if (!find_player(info->name) ||
             !is_in_me_or_environment(this_object(), find_player(info->name))) {
            info->name = 0;
         }
      }
   }
} /* delete_gone_players() */

/**
 * This method sets the minimum number of players needed to play the
 * game.
 * @param minimum the minimum needed
 */
void set_minimum_needed(int minimun) {
   _minimum_needed = minimun;
} /* set_minimum_needed() */

/**
 * This method checks to see if the minimum requirements for starting the
 * game have been met.
 * @return 1 on success, 0 on failure
 */
int can_start_game() {
   if (sizeof(query_currently_playing_ids()) > _minimum_needed) {
      return 1;
   }
   return 0;
} /* can_start_game() */

/**
 * This method finds the next player to the specified one.
 * @param id the id of the player to find, 0 means current player
 * @return the next id
 */
string find_next_player(string id) {
   class player_info info;
   int start;
   int cur;
   string new_id;

   if (!id) {
      id = _current_player;
   }

   start = _players[id]->number;
   cur = start;
   do {
      cur = (cur + 1) % sizeof(_players);
      new_id = find_player_id_from_number(cur);
      info = _players[new_id];
   } while (((_can_join_as_new && !info->name) ||
            (!_can_join_as_new &&
                member_array(new_id, _ids_when_started) == -1)) &&
            cur != start);
   return new_id;
} /* find_next_player() */

/**
 * This method finds the previous player to the specified one.
 * @param id the id of the player to find, 0 means current player
 * @return the previous id
 */
string find_previous_player(string id) {
   class player_info info;
   int start;
   string new_id;
   int cur;

   if (!id) {
      id = _current_player;
   }

   start = _players[id]->number;
   cur = start;
   do {
      cur = (cur - 1 + sizeof(_players)) % sizeof(_players);
      new_id = find_player_id_from_number(cur);
      info = _players[new_id];
   } while (((_can_join_as_new && !info->name) ||
            (!_can_join_as_new &&
               member_array(new_id, _ids_when_started) == -1)) &&
            cur != start);
   return new_id;
} /* find_previous_player() */

/**
 * This method increments the player number to the next available player.
 */
void increment_current_player() {
   _current_player = find_next_player(_current_player);
} /* increment_current_player() */

/**
 * This method finds the id of the person from their object.
 * @param person the person to find
 * @return the id of the person
 */
string find_player_id_of_person(object person) {
   class player_info info;
   string id;

   foreach (id, info in _players) {
      if (find_player(info->name) == person) {
         return id;
      }
   }
   return 0;
} /* find_id_of_person() */

/**
 * This method finds the id of the current player.
 * @return the id of the current player
 */
string query_current_player() {
   if (!_current_player) {
      _current_player = find_player_id_from_number(0);
   }
   return _current_player;
} /* query_current_player() */

/**
 * This method finds the specified person and sets the current player
 * number to them.
 * @param person the person to find
 * @return the id the of the person, 0 on failure
 */
string set_current_player(string id) {
   _current_player = id;
} /* set_current_player() */

/**
 * This method tells the specified player the message.
 * @param id the id to tell the message to
 * @param message the message to send
 */
void tell_player(string id, string message) {
   object player;

   player = find_player(_players[id]->name);
   if (player && (environment(player) == environment() ||
                  player == environment())) {
      tell_object(player, message);
   }
} /* tell_player() */

/**
 * THis method tells a message to the current player.
 * @param message the message to send
 */
void tell_current_player(string message) {
   tell_player(_current_player, message);
} /* tell_current_player() */

/**
 * This method tells everyone playing the game something.
 * @param message the message to send to everyone
 * @param exclude the ids to optionaly exclude
 */
varargs void tell_all_players(string message, string* exclude) {
   class player_info info;
   string id;

   if (!exclude) {
      exclude = ({ });
   }
   foreach (id, info in _players) {
      if (member_array(id, exclude) == -1) {
         tell_player(id, message);
      }
   }
} /* tell_all_players() */

/**
 * This method gets the extra data associated with the player id.
 * @param id the id to look up the data for
 * @return the extra data
 */
mixed query_player_data(string id) {
   return _players[id]->data;
} /* query_player_data() */

/**
 * This method sets the extra data associated with the player id.
 * @param id the id to set the data for
 * @param data the data to set
 */
void set_player_data(string id, mixed data) {
   _players[id]->data = data;
} /* set_player_data() */

/**
 * This method is called when an id joins the game.  This method should 
 * be overridden in higher up objects to handle special events.
 * @param id the id of the person joining
 */
void multiplayer_someone_joins(string id) {
} /* multiplayer_someone_joins() */

/**
 * This method is called when an id resigns from the game.  This method should 
 * be overridden in higher up objects to handle special events.
 * @param id the id of the person joining
 * @param name the name of the person leaving
 */
void multiplayer_someone_resigns(string id, string name) {
} /* multiplayer_someone_resigns() */

/**
 * This method scrambles the array.
 * @return the array shuffled
 */
mixed* shuffle_array(mixed *arr) {
   int i;
   int pos;
   mixed* new_arr;

   for (i = 0; i < 2; i++) {
      new_arr = ({ });
      while (sizeof(arr)) {
         pos = random(sizeof(arr));
         new_arr += arr[pos..pos];
         arr = arr[0..pos - 1] + arr[pos + 1..];
      }
      arr = new_arr;
   }
   return arr;
} /* shuffle_array() */

/**
 * This method is the one that does the joining.
 * @param id the id they wish to join as
 * @return 1 on success, 0 on failure
 */
int do_join(string id) {
   if (is_person_playing(id)) {
      add_failed_mess("Someone is already playing " + id + " on $D.\n");
      return 0;
   }

   if (is_playing(this_player())) {
      add_failed_mess("You are already playing on $D.\n");
      return 0;
   }

   if (is_game_started() &&
       !can_join_as_new_player() &&
       member_array(id, query_started_player_ids()) == -1) {
      add_failed_mess("You can only take over one of the spots vacated by "
                      "someone else.\n");
      return 0;
   }

   if (add_person_to_game(id, this_player())) {
      add_succeeded_mess("$N $V as " + id + " on $D.\n");
      multiplayer_someone_joins(id);
      return 1;
   }

   add_failed_mess("Some weird error joining game on $D.\n");
   return 0;
} /* do_join() */

/**
 * This method is the one that does the resignation from the game.
 * @return 1 on success, 0 on failure
 */
int do_resign() {
   string id;

   id = find_player_id_of_person(this_player());
   if (remove_person_object_from_game(this_player())) {
      add_succeeded_mess("$N $V from the game on $D.\n");
      multiplayer_someone_resigns(id, this_player()->query_cap_name());
      if (id == query_current_player()) {
         increment_current_player();
      }
      return 1;
   }
   add_failed_mess("You are not playing on $D to resign.\n");
   return 0;
} /* do_resign() */

/** @ignore yes */
void init() {
   string ids;

   ids = implode(keys(_players), "|");
   add_command("join", "[game] [as] {" + ids + "} on <direct:object>",
                (: do_join($4[0]) :));
   add_command("resign", "[from] [game] on <direct:object>",
               (: do_resign() :));
} /* init() */

/** @ignore yes */
mapping query_dynamic_auto_load(mapping map) {
   if (!map) {
      return 0;
   }
   add_auto_load_value(map, LOAD_TAG, "players", _players);
   add_auto_load_value(map, LOAD_TAG, "current player", _current_player);
   add_auto_load_value(map, LOAD_TAG, "started ids", _ids_when_started);
   add_auto_load_value(map, LOAD_TAG, "winner", _winner);
   add_auto_load_value(map, LOAD_TAG, "game started", _game_started);
   return map;
} /* query_dynamic_auto_load() */

/** @ignore yes */
void init_dynamic_arg(mapping map, object player) {
   if (!map) {
      return ;
   }
   _players = query_auto_load_value(map, LOAD_TAG, "players");
   _current_player = query_auto_load_value(map, LOAD_TAG, "current player");
   _ids_when_started = query_auto_load_value(map, LOAD_TAG, "started ids");
   _winner = query_auto_load_value(map, LOAD_TAG, "winner");
   _game_started = query_auto_load_value(map, LOAD_TAG, "game started");
} /* init_dynamic_arg() */
// --- END [/mnt/home2/grok/lib/std/room/furniture/games/multiplayer_base.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/furniture/bank_master.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/furniture/bank_master.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629171   Available: 13576525
Inodes: Total: 5242880    Free: 4960135
10785 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/furniture/bank_master.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629171   Available: 13576525
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is the bank inheritable.  It handles all the bank transactions
 * and other such exciting stuff.
 * @author Pinkfish
 */
#include <money.h>
#include <move_failures.h>

nosave inherit "/std/room/furniture/commercial";
nosave inherit "/std/shops/inherit/bank_master";

#define OBJECT_TAG "bank master"

private nosave string _place;

void create() {
  add_help_file("bank_master");
  commercial::create();
  bank_master::create();

  set_commercial_name("bank");
} /* create() */

/**
 * This method does the actual save.
 */
void event_save(object ob) {
   environment()->event_save(ob);
} /* event_save() */

mixed *stats() {
  return commercial::stats() + 
         bank_master::stats();
} /* stats() */

/**
 * Find the object associated with the bank.
 * @param franchise the franchise to find the object for
 * @return the bank object
 */
object find_bank_object(string franchise) {
   object* obs;
   object room;

   room = load_object(franchise);
   if (room->query_bank()) {
      return room;
   }
   obs = filter(room->find_commercial_items(query_commercial_name()),
                (: $1->query_bank_name() == query_bank_name() :));
   if (sizeof(obs)) {
      return obs[0];
   }
   return 0;
} /* find_bank_object() */

/**
 * Show a list of all the franchises.
 */
int do_list_franchises() {
   string franchise;
   int pos;
   object bank_ob;
   string ret;
   string place;

   if (!sizeof(BANK_HANDLER->query_franchises(query_bank_name()))) {
      add_failed_mess("This bank has no franchises.\n");
      return 0;
   }

   place = query_money_place();

   ret = "Franchises:\n";
   foreach (franchise in BANK_HANDLER->query_franchises(query_bank_name())) {
      bank_ob = find_bank_object(franchise);
      ret += sprintf("$I$6=   %c %s Balance %s (cost per month %s)\n",
                      pos + 'A', franchise->the_short(),
                      MONEY_HAND->money_value_string(bank_ob->query_total_difference(), place),
                      MONEY_HAND->money_value_string(BANK_HANDLER->query_bank_franchise_cost_per_month(query_bank_name(), franchise), place));
      pos++;
   }
   write("$P$Franchises$P$" + ret);
   return 1;
} /* do_list_franchises() */

/**
 * Set how much it costs to open a franchise.
 */
int do_set_franchise_cost(string cost) {
   int amount;
   string place;

   place = query_money_place();
   amount = MONEY_HAND->value_from_string(cost, place);
   if (amount <= 0) {
      add_failed_mess("Unknown amount " + cost + ".\n");
      return 0;
   }

   BANK_HANDLER->set_bank_default_cost_to_open(query_bank_name(), amount);
   add_succeeded_mess("$N set$s the cost to open a franchise to " +
          MONEY_HAND->money_value_string(BANK_HANDLER->query_default_cost_to_start(query_bank_name()), place) + "\n");
   return 1;
} /* do_set_franchise_cost() */

/**
 * Set how much it costs to open a franchise.
 */
int do_set_default_monthly_cost(string cost) {
   int amount;
   string place;

   place = query_money_place();
   amount = MONEY_HAND->value_from_string(cost, place);
   if (amount <= 0) {
      add_failed_mess("Unknown amount " + cost + ".\n");
      return 0;
   }

   BANK_HANDLER->set_bank_default_cost_per_month(query_bank_name(), amount);
   add_succeeded_mess("$N set$s the cost to open a franchise to " +
          MONEY_HAND->money_value_string(BANK_HANDLER->query_default_cost_to_start(query_bank_name()), place) + "\n");
   return 1;
} /* do_set_default_cost() */

/**
 * This method sets the new name of the bank.
 * @param new_name the new bank name
 */
int do_set_main_bank_name(string new_name) {
   string* names;
   string name;

   if (query_bank_name()) {
      add_failed_mess("This bank already has a name.\n");
      return 0;
   }

   //
   // Check and see if the name is valid and not already used.
   //
   names = BANK_HANDLER->query_banks();
   foreach (name in names) {
      if (lower_case(name) == lower_case(new_name)) {
         add_failed_mess("There is already a bank called " +
                         name + ".\n");
         return 0;
      }
   }

   write("Do you really want to set the bank name to " + new_name +
         " (Make sure you have correct capitalisation)? ");
   input_to("check_bank_name", 0, new_name);
   add_succeeded_mess("");
   return 1;
} /* do_set_main_bank_name() */

/** @ignore yes */
void check_bank_name(string response, string new_name) {
   if (!strlen(response) || lower_case(response)[0] != 'y') {
      write("Ok, aborting.\n");
      return ;
   }
   write("You set the bank name to " + new_name + ".\n");
   BANK_HANDLER->create_new_bank(new_name, file_name(environment()));
   ::set_bank_name(new_name);
} /* set_bank_name() */

/**
 * This method sets the cut
 * @param percent the cut percentage
 */
int do_set_cut(int percent) {

   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to change the paramaters of "
                   "$D.\n");
      return 0;
   }
   if (percent < 0) {
      add_failed_mess("You cannot set the cut less than 0.\n");
      return 0;
   }
   if (percent > 100) {
      add_failed_mess("You cannot set the cut to greator than 100%.\n");
      return 0;
   }

   set_percentage(percent);

   add_succeeded_mess("$N set$s the cut to " + percent + "% on $D.\n");
   return 1;
} /* do_set_cut() */

/**
 * This method sets the ante amounts.
 * @param str the amount string
 */
int do_set_open_cost(string str) {
   string place;
   int value;

   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to change the paramaters of "
                   "$D.\n");
      return 0;
   }
   place = query_money_place();
   value = MONEY_HAND->value_from_string(str, place);
   if (!value) {
      add_failed_mess("Unable to parse the string " + str + ".\n");
      return 0;
   }
   set_account_cost(value);
   add_succeeded_mess("$N set$s the account open cost to " +
          MONEY_HAND->money_value_string(value, place) + " on $D.\n");

   return 1;
} /* do_set_open_cost() */

/**
 * This method allows you to change the cost per month to the specific
 * franchise.
 * @param id the franchise id
 * @param amount the new amount to cost per month
 */
int do_set_franchise_cost_per_month(string id, string amount) {
   string *franchises;
   int id_num;
   int amt;

   id = lower_case(id);
   if (strlen(id) != 1) {
      add_failed_mess("Must be one letter.\n");
      return 0;
   }
   franchises = BANK_HANDLER->query_franchises(query_bank_name());
   id_num = id[0] - 'a';
   if (id_num < 0 || id_num >= sizeof(franchises)) {
      add_failed_mess("The id of the franchises must be between 'A' and '" +
                      sprintf("%c", 'A' + sizeof(franchises) - 1) + ".\n");
      return 0;
   }

   amt = MONEY_HAND->value_from_string(amount, query_money_place());
   if (amt <= 0) {
      add_failed_mess("The amount " + amount + " is invalid.\n");
      return 0;
   }

   BANK_HANDLER->set_bank_franchise_cost_per_month(query_bank_name(),
               franchises[id_num], amt);
   add_succeeded_mess(({ "You set the cost per month for the franchise " +
                         franchises[id_num]->query_address() + " to " +
                         MONEY_HAND->money_value_string(amt, query_money_place()) + ".\n",
                         "" }));
   return 1;
} /* do_set_franchise_cost_per_month() */

/** @ignore yes */
string query_main_status(int hints) {
   string ret;
   string place;

   place = query_money_place();
   ret = "$I$0=" + the_short() + ":\n";
   ret += "$I$6=   Bank Name             : " +
          query_bank_name() + "\n";
   ret += "$I$6=   Revenue               : " +
          MONEY_HAND->money_value_string(query_revenue(), place) + "\n";
   ret += "$I$6=   Cost to buy franchise : " +
          MONEY_HAND->money_value_string(BANK_HANDLER->query_bank_default_cost_to_open(query_bank_name()), place) + "\n";
   if (hints) {
      ret += "$I$9=      Hint: set buy franchise cost <amount> on <object>\n";
   }
   ret += "$I$6=   Franchise cost per month : " +
          MONEY_HAND->money_value_string(BANK_HANDLER->query_bank_default_cost_per_month(query_bank_name()), place) + "\n";
   if (hints) {
      ret += "$I$9=      Hint: set default franchise monthly cost <amount> on <object>\n";
   }
   ret += "$I$6=   Percentage            : " +
             query_percentage() + "%\n";
   if (hints) {
      ret += "$I$9=      Hint: set percentage <number> on <counter>\n";
   }

   ret += "$I$6=   Cost to open account  : " +
          MONEY_HAND->money_value_string(query_account_cost(), place) + "\n";
   if (hints) {
      ret += "$I$9=      Hint: set account cost <amount> on <object>\n";
   }
   ret += "$I$6=   Number of Franchises  : " +
          sizeof(BANK_HANDLER->query_franchises(query_bank_name())) + "\n";
   return ret;
} /* query_main_status() */

mapping query_dynamic_auto_load() {
   mapping map;

   map = ::query_dynamic_auto_load();
   add_auto_load_value(map, OBJECT_TAG, "bank", query_bank_name());
   add_auto_load_value(map, OBJECT_TAG, "open", query_account_cost());
   add_auto_load_value(map, OBJECT_TAG, "percentage", query_percentage());
   add_auto_load_value(map, OBJECT_TAG, "difference", query_total_difference());
   return map;
} /* query_dynamic_auto_load() */

void init_dynamic_arg(mapping map, object player) {
   commercial::init_dynamic_arg(map, player);
   set_bank_name(query_auto_load_value(map, OBJECT_TAG, "bank"));
   set_account_cost(query_auto_load_value(map, OBJECT_TAG, "open"));
   set_percentage(query_auto_load_value(map, OBJECT_TAG, "percentage"));
   set_total_difference(query_auto_load_value(map, OBJECT_TAG, "difference"));
} /* init_dyanmic_arg() */

void init() {
   commercial::init();
   bank_master::init();

   if (is_allowed(this_player()->query_name())) {
      add_command("set", "bank name <string'name'> on <direct:object>",
                  (: do_set_main_bank_name($4[0]) :));
      add_command("set", "buy franchise cost <string'cost'> on <direct:object>",
                  (: do_set_franchise_cost($4[0]) :));
      add_command("set", "franchise monthly cost <string'cost'> on <direct:object>",
                  (: do_set_default_monthly_cost($4[0]) :));
      add_command("set", "percentage <number> on <direct:object>",
                  (: do_set_cut($4[0]) :));
      add_command("set", "account cost <string'open cost'> on <direct:object>",
                  (: do_set_open_cost($4[0]) :));
      add_command("set", "franchise monthly cost <string'cost'> for <string'franchise id'> on <direct:object>",
                  (: do_set_franchise_cost_per_month($4[1], $4[0]) :));
      add_command("list", "franchises on <direct:object>",
                  (: do_list_franchises :));
   } 
} /* init() */
// --- END [/mnt/home2/grok/lib/std/room/furniture/bank_master.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/furniture/bath.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/furniture/bath.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629168   Available: 13576522
Inodes: Total: 5242880    Free: 4960135
15273 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/furniture/bath.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629168   Available: 13576522
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is a bath tub inheritable.  It will wash off stuff and also allow
 * people to splash each other and other exciting and wild things along
 * those lines.
 * @author Triana
 */
#include <effect.h>

inherit "/std/room/furniture/surface";
/* #include "path.h"; */

#define WET_EFFECT "/std/effects/other/wetness"
#define SOAP_EFFECT "/std/effects/healing/antiseptic_soap"

/* Is it full of water? */
int water = 0;
int dirt = 0;

string* dirt_messages = ({
    "clear",
    "almost clear",
    "soapy",
    "foamy",
    "slightly dirty",
    "fairly dirty",
    "dirty",
    "very dirty",
    "muddy"
});

void zap_bad_effects( object who );
int do_wash(object *indirect_obs );

void create(){
    ::create();
    add_property( "no recycling", 1 );
    this_object()->add_extra_look( this_object() );
    add_help_file("bath");
}
/* setup() */

/** @ignore yes */
string extra_look() {
    object *stuff;
    string answer = "";

    stuff = all_inventory( this_object() ); 
    if (water) {
        if (dirt >= sizeof(dirt_messages)) {
            dirt = sizeof(dirt_messages) - 1;
        }
        answer = answer + "It's about three quarters full of " + 
            dirt_messages[dirt] + " water.\n";
    }
    if( sizeof( stuff ) ) {
        answer = answer + "It has "+ query_multiple_short( stuff ) +" in it.\n"; 
    }

   return answer;
}
/* extra_look */

/** @ignore yes */
string long_status() {
    return "";
}

/** @ignore yes */
void init(){
    ::init();
    add_command( "lie", "in <direct:object>");
    add_command( "sit", "in <direct:object>");
    add_command( "kneel", "in <direct:object>");
    add_command( "stand", "in <direct:object>");
    add_command( "leave", "<direct:object>");
    add_command( "fill", "<direct:object>");
    add_command( "empty", "<direct:object>");
    add_command( "splash", "<indirect:living:here>");
    add_command( "wash", "<indirect:living:here>");
} /* init() */

/** @ignore yes */
int can_player_get_in_it() {
    if (environment(this_object())!=environment(this_player())) {
      this_player()->add_failed_mess(this_object(), "The " + this_object()->short() + " needs to "
      "be on the floor for you to get in it.\n");
      return 0;
    }
    /*
    if (this_player()->query_complete_weight()
        +this_object()->query_complete_weight()
        >this_object()->query_max_weight()) {
      this_player()->add_failed_mess(this_object(), "The bath tub is "
      "too full of other things.\n");
      return 0;
    }
    */
    if( environment( this_object() ) == this_player() ){
        this_object()->move(environment(this_player() ));
        tell_object(this_player(), "You drop the "+ 
            this_object()->short()+".\n");
        tell_room(environment(this_player()), this_player()->short()+" drops "
        "a "+this_object()->short()+".\n", this_player() );
    
    } 
    return 1;
}

/** @ignore yes */
void wet_everyone_in() {
    object *victims;
    if (!water) {
        return;
    }
    victims = filter(all_inventory(environment(this_object())),
        (: living($1) :) );
    foreach( object victim in victims ) {
        if (victim -> query_position_type() == "in" &&
            victim -> query_position_on() == "the "+this_object()->short()) {

            victim->add_effect( WET_EFFECT, 500 );
        }
    }
}

/** @ignore yes */
void reset() {
    wet_everyone_in();
}

/** @ignore yes */
int do_fill() {
    object player;
    player=this_player();
    if (water) {
        player->add_failed_mess(this_object(), "The " + this_object()->short() + " is "
            "already full of water.\n");
        return 0;
    }
    add_succeeded_mess( "", ({ }) );
    tell_object(player, "You fill the " + this_object()->short() + " with clean water.\n" );
    tell_room(environment(player), player->short()+" fills "
        "the " + this_object()->short() + " with clean water.\n", player );
    water=1;
    dirt=0;
    wet_everyone_in();
    return 1;
}

/** @ignore yes */
int do_empty() {
    object player;
    player=this_player();
    if (!water) {
        player->add_failed_mess(this_object(), "The " + this_object()->short() + " is "
            "already as empty as it gets.\n");
        return 0;
    }
    add_succeeded_mess( "", ({ }) );
    tell_object(player, "You reach into the " + this_object()->short() + " and "
                "pull the plug, allowing the water to drain away.\n" );
    tell_room(environment(player), player->short()+" reaches into "
        "the " + this_object()->short() + " and pulls the plug, allowing "
        "the water to flow away.\n", player );
    water=0;
    dirt=0;
    return 1;
}

int do_lie() {
    object player;
    if (!can_player_get_in_it()) {
        return 0;
    }
    player=this_player();
    add_succeeded_mess( "", ({ }) );
    if (player->query_position_on() == "the "+this_object()->short()) {
        if (player->query_position() == "lying") {
            tell_object(player, "You are already lying in the pool.\n" );
            return 1;
        }
        tell_object(player, "You lie in the " + this_object()->short() + ".\n" );
        tell_room(environment(player), player->short()+" lies "
            "in the " + this_object()->short() + ".\n", player );
    }
    else {
        tell_object(player, "You step into the " + this_object()->short() + " and lie down.\n" );
        tell_room(environment(player), player->short()+" steps "
            "into the " + this_object()->short() + " and lies down.\n", player );
        if (water) {
            player->add_effect( WET_EFFECT, 500 );
        }
    }
    player->set_position( "lying" );
    player->set_position_type( "in" );
    player->set_position_on( "the "+this_object()->short() );
    return 1;
}
/* lie() */

/** @ignore yes */
int do_sit() {
    object player;
    if (!can_player_get_in_it()) {
        return 0;
    }
    player=this_player();
    add_succeeded_mess( "", ({ }) );
    if (player->query_position_on() == "the "+this_object()->short()) {
        if (player->query_position() == "sitting") {
            tell_object(player, "You are already sitting in the " + this_object()->short() + ".\n" );
            return 1;
        }
        tell_object(player, "You sit in the " + this_object()->short() + ".\n" );
        tell_room(environment(player), player->short()+" sits "
            "in the " + this_object()->short() + ".\n", player );
    }
    else {
        tell_object(player, "You step into the " + this_object()->short() + " and sit down.\n" );
        tell_room(environment(player), player->short()+" steps "
            "into the " + this_object()->short() + " and sits down.\n", player );
        if (water) {
            player->add_effect( WET_EFFECT, 500 );
        }
    }
    player->set_position( "sitting" );
    player->set_position_type( "in" );
    player->set_position_on( "the "+this_object()->short() );
    return 1;
}
/* sit() */

int do_kneel() {
    object player;
    if (!can_player_get_in_it()) {
        return 0;
    }
    add_succeeded_mess( "", ({ }) );
    player=this_player();
    if (player->query_position_on() == "the "+this_object()->short()) {
        if (player->query_position() == "kneeling") {
            tell_object(player, "You are already kneeling in the " + this_object()->short() + ".\n" );
            return 1;
        }
        tell_object(player, "You kneel in the " + this_object()->short() + ".\n" );
        tell_room(environment(player), player->short()+" kneels "
            "in the " + this_object()->short() + ".\n", player );
    }
    else {
        tell_object(player, "You step into the " + this_object()->short() + " and kneel down.\n" );
        tell_room(environment(player), player->short()+" steps "
            "into the " + this_object()->short() + " and kneel down.\n", player );
        if (water) {
            player->add_effect( WET_EFFECT, 500 );
        }
    }
    player->set_position( "kneeling" );
    player->set_position_type( "in" );
    player->set_position_on( "the "+this_object()->short() );
    return 1;
}
/* kneel() */

/** @ignore yes */
int do_stand() {
    object player;
    if (!can_player_get_in_it()) {
        return 0;
    }
    add_succeeded_mess( "", ({ }) );
    player = this_player();
    if (player->query_position_on() == "the "+this_object()->short()) {
        if (player->query_position() == "standing") {
            tell_object(player, "You are already standing in the " + this_object()->short() + ".\n" );
            return 1;
        }
        tell_object(player, "You stand in the " + this_object()->short() + ".\n" );
        tell_room(environment(player), player->short()+" stands "
            "in the " + this_object()->short() + ".\n", player );
    }
    else {
        tell_object(player, "You step into the " + this_object()->short() + ".\n" );
        tell_room(environment(player), player->short()+" steps "
            "into the " + this_object()->short() + ".\n", player );
        if (water) {
            player->add_effect( WET_EFFECT, 500 );
        }
    }
    player->set_position( "lying" );
    player->set_position_type( "in" );
    player->set_position_on( "the "+this_object()->short() );
    return 1;
}
/* lie() */

/** @ignore yes */
void event_exit(object ob, string message, object to) {
  if (ob==this_player() && this_player()->query_position_on() == this_object()) {
    this_player()->return_to_default_position(1);
  }
}
/* event_exit() */

/** @ignore yes */
int do_leave(){
    
    if (this_player()->query_position_on() == "the "+this_object()->short()) {
        this_player()->return_to_default_position(1);
        tell_object(this_player(), "You clamber out of the " + this_object()->short() + ".\n" );
        tell_room(environment(this_object()), this_player()->short()+" clambers "
            "out of the " + this_object()->short() + ".\n", this_player() );
    }
    else {
        tell_object(this_player(), "Umm... You're not in the " + this_object()->short() + " in the "
            "first place.\n" );
    }
    add_succeeded_mess( "", ({ }) );
    return 1;
}
/* do_leave() */

/** @ignore yes */
int do_splash( object *indirect_obs ) {
    if (environment(this_object())!=environment(this_player())) {
      this_player()->add_failed_mess(this_object(), "The " + this_object()->short() + " needs to "
      "be on the floor for you to splash with it.\n");
      return 0;
    }
    if (!water) {
        this_player()->add_failed_mess(this_object(), "It's not a bad idea,  "
            " but maybe you'd need some water in the " + this_object()->short() + 
            " before you can splash.\n");
        return 0;
    }
    if ( sizeof( indirect_obs ) ) {
        add_succeeded_mess( "$N splash$es $I.\n", indirect_obs );
        return 1;
    }
    
    this_player()->add_succeeded_mess( this_object(),
        "$N splash$es $oself.\n", ({ }) );
    return 1;
}

int do_wash( object *indirect_obs ) {   

    if (!can_player_get_in_it()) {
        return 0;
    }
    if (this_player() -> query_position_type() != "in" &&
        this_player()->query_position_on() != "the "+this_object()->short()) {
      this_player()->add_failed_mess(this_object(), "You need to get "
                                     "into the " + this_object()->short() +
                                     " first.\n");
      return 0;
    }
    if (!water) {
        this_player()->add_failed_mess(this_object(), "It's not a bad idea,  "
            " but maybe you'd need some water in the " + this_object()->short() + 
            " before you can wash.\n");
        return 0;
    }
    if (dirt >= sizeof(dirt_messages) - 1) {
        this_player()->add_failed_mess(this_object(), "The water in the " +
            this_object()->short() +
            " looks so muddy, it probably would just soil anyone.  Maybe " +
            " it would be a better idea to empty it and fill it again " +
            " with fresh water.\n");
        return 0;
    }

    if ( sizeof( indirect_obs ) ) {
        foreach( object victim in indirect_obs ) {
            call_out( (: zap_bad_effects( $1 ) :), 0, victim );
        }
        
        add_succeeded_mess( "$N wash$es $I using a bar of pleasant smelling soap.\n", indirect_obs );
        return 1;
    }
    
    call_out( (: zap_bad_effects( $1 ) :), 0, this_player() );
    this_player()->add_succeeded_mess( this_object(),
        "$N wash$es $oself using a bar of pleasant smelling soap.\n", ({ }) );
    return 1;
} /* wash_self() */

/**
 * This method returns 1 if it is a bath.
 * @return 1 if it is a bath
 */
int query_baths() {
    return 1;
} /* query_baths() */

/**
 * Since we have a limited quantity of water here, it may wash an effect
 * right away, or it may need more washing.  It also means the water
 * itself will become dirty in the process.  The dirtier the water is,
 * the less likely it is to wash anything out.  Fresh water has about
 * 50% chance of washing anything out.
 */
void zap_bad_effects( object who ) {
    int i, flag, *enums;
    class effect *effs;
    
    dirt++;

    effs = (class effect *)who->query_effs();
    enums = (int *)who->effects_matching( "body.smell" );
    i = sizeof( enums );
    if ( !random(dirt) && i ) {
        i = random( i );
        flag = 1;
        write( "The antiseptic power of the soap defeats "+
          (string)effs[ enums[ i ] ]->ob_name->smell_string( who,
            effs[ enums[ i ] ]->arg ) +".\n" );
        who->delete_effect( enums[ i ] );
        dirt ++;
    }

    enums = who->effects_matching("pie.cream");
    if (!random(dirt) && sizeof(enums)) {
        tell_object(who, "The cream washes right off your body.\n");
        who->delete_effect(enums[0]);
        dirt ++;
    }

    enums = (int *)who->effects_matching( "misc.ketchup" );
    i = sizeof( enums );
    if ( !random(dirt) && i ) {
        i = random( i );
        flag = 1;
        write( "The soap rinses the ketchup off your face.\n" );
        who->delete_effect( enums[ i ] );
        dirt ++;
    }

    enums = who->effects_matching("exploded.apples");
    if (!random(dirt) && sizeof(enums)) {
        tell_object(who, "The apples wash right off your body.\n");
        who->delete_effect(enums[0]);
        dirt ++;
    }
    
    enums = (int *)who->effects_matching("object.label");
    if (!random(dirt) && sizeof(enums)) {
        // They cannot have this effect if they have no labels...
        tell_object(who, "The labels stuck on you peel off in "
          "the water.\n");
        who->delete_effect(enums[0]);
        dirt ++;
    }

    enums = who->effects_matching("body.frog-adhesive");
    if (!random(dirt) && sizeof(enums)) {
        tell_object(who, "The frog adhesive washes off in the water.\n");
        who->delete_effect(enums[0]);
        dirt ++;
    }

    enums = who->effects_matching("body.writing.soap");
    if (!random(dirt) && sizeof(enums)) {
        tell_object(who, "The rest of the words wash off without a single "
            "bubble in sight.\n");
        who->delete_effect(enums[0]);
        dirt ++;
    }

    if (!random(dirt)) {
        /* cure the fleas */
        who->add_effect( SOAP_EFFECT, 10000 );
    }
    who->add_effect( WET_EFFECT, 250 );
} /* zap_bad_effects() */
// --- END [/mnt/home2/grok/lib/std/room/furniture/bath.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/furniture/mirror.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/furniture/mirror.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629164   Available: 13576518
Inodes: Total: 5242880    Free: 4960135
594 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/furniture/mirror.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629164   Available: 13576518
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is a mirror inheritable.
 * @author Ceres
 */
#include <effect.h>

inherit "/std/room/furniture/basic";

int _in_extra;

void create(){
	::create();
	add_extra_look(this_object());
}

string extra_look(object ob) {
	int dark;
	object env;

	env = environment(ob);
	if(living(env))
		return "You can see yourself in the mirror.";
	
	dark = (int) this_player()->check_dark((int)env->query_light());
	if(dark)
		return "It is too dark to see much in the room.";

	return "Reflected in the mirror is " +
		query_multiple_short(all_inventory(env) - ({ ob }), "a", 0, 1, dark) +
		".";
}
// --- END [/mnt/home2/grok/lib/std/room/furniture/mirror.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/furniture/dividor.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/furniture/dividor.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629164   Available: 13576518
Inodes: Total: 5242880    Free: 4960135
3534 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/furniture/dividor.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629164   Available: 13576518
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This object makes a room divideor.  This allows the room to be split
 * in two.
 * @author David Bennett
 * @started Sun Sep  9 17:58:16 PDT 2001
 */
inherit "/std/room/furniture/commercial";

#include <room.h>

#define SIZE_OF_FURNITURE 5
#define TAG "dividor"
#define TEMPLATE_DIVIDOR_ROOM "/mudlib/data/dividor_template.c"

private int _size;
private string _exit_direction;
private string _our_room;

/** @ignore yes */
int query_furniture_size() {
   return _size + SIZE_OF_FURNITURE;
} /* query_furniture_size() */

/**
 * This finds the commercial id for the dividor.
 */
int query_commercial_id() {
   if (!::query_commercial_id()) {
      setup_new_commercial_id();
   }
   return ::query_commercial_id();
}

/**
 * This method returns the exit direction.
 * @return the exit direction
 */
string query_exit_direction() {
   return _exit_direction;
}

/**
 * This method returns the path of the room on the other side of the
 * dividor.
 * @return the path of the room on the other side of the dividor
 */
string query_exit_destination() {
   return _our_room;
}

/**
 * This method creates the extra room based on our current room.
 * If the room already exists we do nothing.  It reads in a template
 * file and replaces MAIN_ROOM, SAVE_DIR and EXIT_DIRECTION with the
 * correct text.
 * @return 1 if the room was created, 0 if not
 */
int create_room() {
   string path;
   string *bits;
   string room_path;
   string stuff;

   // First setup the save path.
   path = environment()->query_save_dir();
   path += "/division" + query_commercial_id();
   if (file_size(path) == -2) {
      mkdir(path);
   }

   // Now get the path to put the file in.
   bits = explode(base_name(environment()), "/");
   room_path = implode(bits[0..<2], "/");
   room_path += "/" + bits[<1] + "_dividor";
   if (file_size(room_path) == -2) {
      mkdir(room_path);
   }
   room_path += "/" + query_commercial_id();

   if (file_size(room_path + ".c") > 0) {
      return 0;
   }

   _our_room = room_path;

   stuff = "inherit \"/std/room/furniture/dividor_room\";\n\n"
           "void setup() {\n"
           "   set_base_desc(\"" + environment()->query_base_desc() + "\");\n"
           "   set_main_room(\"" + base_name(environment()) + "\");\n"
           "   set_save_dir(\"" + path + "\");\n"
           "   set_theft_handler(\"" + environment()->query_theft_handler() + "\");\n"
           "   add_exit(\"" + ROOM_HANDLER->query_opposite_direction(query_exit_direction()) + "\", \"" + base_name(environment() + "\", \"door\");\n"
           "   set_property_size(" + _size + ");\n"
           "   add_property(\"place\", \"" + environment()->query_property("place") + "\");\n"
           "}";
   write_file(room_path + ".c", stuff, 1);
   return 1;
} /* create_room() */

/**
 * This method adds in the exit to the newly created room into the main
 * room.
 */
void add_exit_to_room() {
   environment()->add_exit(query_exit_direction(), query_exit_destination(), "door");
} 

/** @ignore yes */
mapping query_dynamic_auto_load() {
   mapping map;

   map = ::query_dynamic_auto_load();
   add_auto_load_value(map, TAG, "exit", _exit_direction);
   add_auto_load_value(map, TAG, "room", _our_room);
   add_auto_load_value(map, TAG, "size", _size);
   return map;
}

/** @ignore yes */
void init_dynamic_arg(mapping map) {
   _exit_direction = query_auto_load_value(map, TAG, "exit");
   _our_room = query_auto_load_value(map, TAG, "room");
   _size = query_auto_load_value(map, TAG, "size");
   ::init_dynamic_arg(map);
}
// --- END [/mnt/home2/grok/lib/std/room/furniture/dividor.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/furniture/furniture.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/furniture/furniture.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629163   Available: 13576517
Inodes: Total: 5242880    Free: 4960135
8954 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/furniture/furniture.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629163   Available: 13576517
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: furniture.c,v 1.1 2001/05/15 20:06:00 pinkfish Exp $
 */
/**
 * This is a furniture item for making all kinds of furniture that store
 * things.
 *
 * If you want to make a chest just use set_max_weight() to set how much
 * weight it can store.
 *
 * If you want it to have drawers or shelves use the add_drawer() and
 * set_drawer_mess() functions to set them up.
 *
 */
#include <move_failures.h>
#include <position.h>
#include <tasks.h>

inherit "/obj/cont_save";
inherit "/std/basic/trap";
inherit "/std/room/furniture/inherit/furniture_base";

private nosave string _drawer_mess;
private nosave mixed *_drawers;
private nosave int _biggest;
private nosave int _drawers_inside;
private nosave object *_on_top;
private nosave int _has_surface;

#define DEBUG

void create() {
  do_setup++;
  ::create();
  _drawer_mess = "a drawer in $ob_short$";
  _drawers = ({ });
  _on_top = ({ });
  add_alias( "furniture" );
  add_plural( "furniture" );
  set_opaque();
  if (!query_property("shop type"))
    add_property( "shop type", "furniture" );

   do_setup--;
   if(!do_setup)
     this_object()->setup();
}

/**
 * This method returns the message associated with the drawer.
 * @return the message associated with the drawer
 * @see set_drawer_mess()
 * @see query_drawers()
 * @see add_drawer()
 */
string query_drawer_mess() { return _drawer_mess; }

/**
 * This method sets the message associated with the drawer.
 * @param words the message associated with the drawer
 * @see query_drawer_mess()
 * @see add_drawer()
 */
void set_drawer_mess( string words ) { _drawer_mess = words; }

/**
 * This method returns all the drawers on the object.
 * @return all the drawers on the object
 * @see add_drawer()
 */
mixed *query_drawers() { return _drawers; }

/**
 * This method adds a drawer onto the furniture.
 *
 * @param type the type of drawer
 * @param amount the amount the drawer can hold
 * @see query_drawers()
 * @see set_drawer_mess()
 * @see query_drawer_mess()
 */
void add_drawer( string type, int amount ) {
   if ( !type || ( type == "" ) || ( amount < 1 ) ) {
      return;
   }
   _drawers += ({ type, amount });
   set_max_weight(query_max_weight() + amount);
   if ( amount > _biggest ) {
      _biggest = amount;
   }
} /* add_drawer() */

int query_has_surface() { return _has_surface; }
void set_has_surface(int i) { _has_surface = i; }

/**
 * Set the drawers to be on the inside, and hence not visible when the
 * door is closed.
 */
void set_drawers_inside(int i) { _drawers_inside = i; }

/**
 * Set the drawers to be on the inside, and hence not visible when the
 * door is closed.
 */
int query_drawers_inside() { return _drawers_inside; }

/** @ignore yes */
/* Furniture is much harder to carry than just its weight, therefore we
 * multiply its weight by 5 to determine if someone can carry it.
 */
varargs int move( mixed dest, string messin, string messout ) {
  int i, w;
  object from;

  w = (int)this_object()->query_complete_weight() * 5;
  if ( from = environment() ) {
    from->add_weight( -w );
  }
  if(!dest) {
    return MOVE_INVALID_DEST;
  }
  
  if (!( dest->add_weight( w ) ) ) {
    if ( from ) {
      from->add_weight( w );
    }
    return MOVE_TOO_HEAVY;
  }
  if ( stringp( dest ) ) {
    dest = find_object( dest );
  }
  i = ::move( dest, messin, messout );
  if ( i != MOVE_OK ) {
    if ( from ) {
      from->add_weight( w );
    }
    dest->add_weight( -w );
  } else if (query_light_needs_inform()) {
    if ( from ) {
      inform_of_light_level_change(from);
    }
    inform_of_light_level_change(dest);
  }
  return i;
}

/** @ignore yes */
string long( string word, int dark ) {
   int i;
   string ret, *sizes;
   mapping types;

  ret = ::long( word, dark );
   if ( sizeof( _drawers ) && !dark &&
        (!query_closed() || !_drawers_inside)) {
     types = ([ ]);
     for ( i = 0; i < sizeof( _drawers ); i += 2 ) {
       types[ _drawers[ i ] ]++;
     }
     sizes = m_indices( types );
     for ( i = 0; i < sizeof( sizes ); i++ ) {
       sizes[ i ] = query_num( types[ sizes[ i ] ] ) +" "+ sizes[ i ] +
         " drawer"+ ( types[ sizes[ i ] ] > 1 ? "s" : "" );
     }
     ret += "It has "+ query_multiple_short( sizes ) +".\n";
   }
   if(sizeof(_on_top))
     ret += query_contents( "On " + the_short() + " " +
                            (sizeof(_on_top) == 1 ? "is " : "are " ), _on_top);
   return ret;
}
varargs string query_contents( string start, object *things,
  int ignore_living) {
  if(!arrayp(things)) {
    things = this_object()->find_inv_match( "", this_player() );
    things -= ({ this_player() });
    things = filter_array( things, (: environment( $1 ) == this_object() :) );
    things -= _on_top;
  }
  return ::query_contents(start, things, ignore_living);
}

/**
 * @ignore yes
 * Makes sure furniture is removed from the save file
 * when its removed from this room.
 */
int test_remove(object thing, int flag, mixed dest) {
  int result;
  mixed *stuff;
  
  result = ::test_remove(thing, flag, dest);

  if(result) {
    stuff = thing->query_property("dropped");

    if(environment() &&
       dest == this_player() &&
       function_exists("test_occupier", environment()) &&
       !environment()->test_occupier(this_player()->query_name()) &&
       (!sizeof(stuff) || stuff[0] != this_player()->query_name())) {
      event(environment(this_player()), "theft", this_player(), this_object(),
            ({ thing }));
    }

    if(dest) {
      _on_top -= ({ thing });
      thing->remove_property("_on_top");
    }
    event(environment(), "save");
  }
  
  return result;
}
 
/** @ignore yes */
int test_add( object thing, int flag ) {
  int i;
  int result;
  
  if ( flag )
    return 0;
  
  if(!environment(thing))
    return 1;

  result = ::test_add(thing, flag);

  if(!result)
    return 0;
  
  if("/cmds/living/put"->query_con() == "on" && _has_surface) {
    _on_top += ({ thing });
    thing->add_property("_on_top", 1);
  } else if(sizeof(_drawers)) {
    if ( !_biggest )
      for ( i = 0; i < sizeof( _drawers ); i+= 2 )
        if ( _drawers[ i + 1 ] > _biggest )
          _biggest = _drawers[ i + 1 ];
    
    if ( (int)thing->query_complete_weight() > _biggest )
      return write( (string)thing->the_short() +" is too big "+
                    "to fit in any of "+ the_short() +"'s drawers.\n" );
  }
  event(environment(), "save", this_object());
  return result;
}

/** @ignore yes */
int pick_unlock(object player) {
  mixed owner;

  if(!environment())
    return ::pick_unlock(player);

  if(!environment() || !function_exists("query_owner", environment()))
    return ::pick_unlock(player);

  // Ok, we have two situations. Single owner (then do PK check) or
  // multiple owner, in which case we just check the player is a pk.
  owner = environment()->query_owner();

  if(stringp(owner) && pk_check(player, owner, 1)) { // do the PK check
    write("You feel it would be wrong to try to break into "+
          this_object()->query_short() + ".\n");
    return 0;
  } 

  return ::pick_unlock(player);
}

/** @ignore yes */
mapping int_query_static_auto_load() {
  return ([
           "::" : ::int_query_static_auto_load(),
           "drawer mess" : _drawer_mess,
           "drawers" : _drawers,
           "allowed_positions" : query_allowed_positions(),
           "trap" : query_trap_data(),
           "trap armed": query_trap_armed(),
           ]);
} /* query_static_auto_load() */

/** @ignore yes */
mapping query_static_auto_load() {
  return int_query_static_auto_load();
} /* query_static_auto_load() */

/** @ignore yes */
void init_static_arg( mapping map ) {
  if ( !mapp( map ) )
    return;
  if ( map[ "::" ] )
    ::init_static_arg( map[ "::" ] );
  if ( !undefinedp( map[ "drawer mess" ] ) )
    _drawer_mess = map[ "drawer mess" ];
  if ( !undefinedp( map[ "drawers" ] ) )
    _drawers = map[ "drawers" ];
  if(!undefinedp(map["allowed_positions"]))
    set_allowed_positions( map["allowed_positions"]);
  if(!undefinedp(map["trap"]))
    setup_trap(map["trap"][0],
                   map["trap"][1],
                   map["trap"][2],
                   map["trap"][3],
                   map["trap"][4]);
  if(!undefinedp(map["trap armed"]))
    set_trap_armed(map["trap armed"]);
} /* init_static_arg() */

/** @ignore yes */
void init_dynamic_arg(mapping bing) {
  object item;
  
  ::init_dynamic_arg(bing);
  foreach(item in all_inventory(this_object())) {
    
    if(item->query_property("_on_top"))
      _on_top += ({ item });
  }
}

/** @ingore yes */
string query_help_file_directory() {
  return "/doc/furniture/";
} /* query_help_file_directory() */

/** @ignore yes */
mixed *stats() {
  int i;
  mixed *ret;
  ret = ::stats();
  ret += ({ ({ "surface", _has_surface }) });
  for ( i = 0; i < sizeof( _drawers ); i += 2 )
    ret += ({ ({ _drawers[ i ] +" drawer", _drawers[ i + 1 ] }) });
  return ret;
} /* stats() */
// --- END [/mnt/home2/grok/lib/std/room/furniture/furniture.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/furniture/basic.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/furniture/basic.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629161   Available: 13576515
Inodes: Total: 5242880    Free: 4960135
2628 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/furniture/basic.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629161   Available: 13576515
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: basic.c,v 1.23 2003/02/14 21:55:25 pinkfish Exp $
 *
 *
 */
/**
 * This is a furniture item for making all kinds of furniture.
 */
#include <move_failures.h>
#include <position.h>
#include <room/placement.h>

inherit "/std/object";
inherit "/std/basic/item_chat";
inherit "/std/room/furniture/inherit/furniture_base";

void create() {
  do_setup++;
  object::create();
  furniture_base::create();

  add_alias( "furniture" );
  add_plural( "furniture" );
  set_opaque();
  
  do_setup--;
  if ( !do_setup ) {
    this_object()->setup();
  }

  // Don't respond to 'get all'
  set_no_all(1);
}

/* Furniture is much harder to carry than just its weight, therefore we
 * multiply its weight by 5 to determine if someone can carry it.
 */
/** @ignore yes */
varargs int move( mixed dest, string messin, string messout ) {
  int i, t, f;
  object from;

  if(stringp(dest)) {
    dest = find_object(dest);
  }

  if (!move_check(dest)) {
     write(the_short() + " resists being picked up and shocks you slightly.\n");
     return MOVE_INVALID_DEST;
  }

  if(!dest) {
    return MOVE_INVALID_DEST;
  }

  if(living(dest)) {
    t = (int)this_object()->query_complete_weight() * 2;
    if(!(dest->add_weight(t))) {
      return MOVE_TOO_HEAVY;
    }
  }

  i = ::move(dest, messin, messout);

  if(i != MOVE_OK) {
    dest->add_weight(-t);
    return i;
  }

  from = environment();
  if(from && living(from)) {
    f = (int)this_object()->query_complete_weight() * 2;
    from->add_weight(-f);
  }

  return i;
} /* move() */

/** @ignore yes
 * This stops people dragging items away if they aren't allowed to.
 */
int get(mixed dest) {
  if(!move_check(dest)) {
    write("You feel it would be wrong to take " + the_short() + ".\n");
    return 2;
  }
  return ::get(dest);
}

/** @ignore yes */
mixed query_static_auto_load() {
  if ( base_name(this_object()) + ".c" == __FILE__ ) {
    return int_query_static_auto_load();
  }
  return ([ ]);
}

/** @ignore yes */
mixed query_dynamic_auto_load() {
   mapping junk;

   junk = object::query_dynamic_auto_load();
   if (!junk) {
      junk = ([ ]);
   }
   junk["bonded"] = query_bonded();
   return junk;
} /* query_dynamic_auto_load() */

/** @ignore yes */
void init_dynamic_arg(mapping map) {
   object::init_dynamic_arg(map);
   set_bonded(map["bonded"]);
} /* init_dynamic_arg() */

/** @ingore yes */
string query_help_file_directory() {
   return "/doc/furniture/";
} /* query_help_file_directory() */

/** @ingore yes */
mixed *stats() {
   return ::stats() +
          ({ ({ "bonded", query_bonded() }) });
} /* stats() */
// --- END [/mnt/home2/grok/lib/std/room/furniture/basic.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/furniture/sink_inherit.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/furniture/sink_inherit.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629160   Available: 13576514
Inodes: Total: 5242880    Free: 4960135
7495 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/furniture/sink_inherit.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629160   Available: 13576514
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is a sink inheritable.  It will wash stuff off, basically.
 * @author Rue - modified from Triana's bathtub inherit
 */
#include <effect.h>

inherit "/std/room/furniture/surface";
/* #include "path.h"; */

#define WET_EFFECT "/std/effects/other/wetness"
#define SOAP_EFFECT "/std/effects/healing/antiseptic_soap"

/* Is it full of water? */
int water = 0;
int dirt = 0;

string* dirt_messages = ({
    "clear",
    "almost clear",
    "soapy",
    "foamy",
    "slightly dirty",
    "fairly dirty",
    "dirty",
    "very dirty",
    "muddy"
});

void zap_bad_effects( object who );
int do_wash(object *indirect_obs );

void create(){
    ::create();
    add_property( "no recycling", 1 );
    this_object()->add_extra_look( this_object() );
    //add_help_file("bath");
}
/* setup() */

/** @ignore yes */
string extra_look() {
    object *stuff;
    string answer = "";

    stuff = all_inventory( this_object() ); 
    if (water) {
        if (dirt >= sizeof(dirt_messages)) {
            dirt = sizeof(dirt_messages) - 1;
        }
        answer = answer + "It's about three quarters full of " + 
            dirt_messages[dirt] + " water.\n";
    }
    if( sizeof( stuff ) ) {
        answer = answer + "It has "+ query_multiple_short( stuff ) +" in it.\n"; 
    }

   return answer;
}
/* extra_look */

/** @ignore yes */
string long_status() {
    return "";
}

/** @ignore yes */
void init(){
    ::init();
    add_command( "fill", "<direct:object>");
    add_command( "empty", "<direct:object>");
    add_command( "splash", "<indirect:living:here>");
    add_command( "wash", "<indirect:living:here>");
} /* init() */


/** @ignore yes */
void wet_everyone_in() {
    object *victims;
    if (!water) {
        return;
    }
    victims = filter(all_inventory(environment(this_object())),
        (: living($1) :) );
    foreach( object victim in victims ) {
        if (victim -> query_position_type() == "in" &&
            victim -> query_position_on() == "the "+this_object()->short()) {

            victim->add_effect( WET_EFFECT, 500 );
        }
    }
}

/** @ignore yes */
void reset() {
    wet_everyone_in();
}

/** @ignore yes */
int do_fill() {
    object player;
    player=this_player();
    if (water) {
        player->add_failed_mess(this_object(), "The " + this_object()->short() + " is "
            "already full of water.\n");
        return 0;
    }
    add_succeeded_mess( "", ({ }) );
    tell_object(player, "You fill the " + this_object()->short() + " with clean water.\n" );
    tell_room(environment(player), player->short()+" fills "
        "the " + this_object()->short() + " with clean water.\n", player );
    water=1;
    dirt=0;
    wet_everyone_in();
    return 1;
}

/** @ignore yes */
int do_empty() {
    object player;
    player=this_player();
    if (!water) {
        player->add_failed_mess(this_object(), "The " + this_object()->short() + " is "
            "already as empty as it gets.\n");
        return 0;
    }
    add_succeeded_mess( "", ({ }) );
    tell_object(player, "You reach into the " + this_object()->short() + " and "
                "pull the plug, allowing the water to drain away.\n" );
    tell_room(environment(player), player->short()+" reaches into "
        "the " + this_object()->short() + " and pulls the plug, allowing "
        "the water to flow away.\n", player );
    water=0;
    dirt=0;
    return 1;
}

/** @ignore yes */
int do_splash( object *indirect_obs ) {
    
    if (!water) {
        this_player()->add_failed_mess(this_object(), "It's not a bad idea,  "
            "but maybe you'd need some water in the " + this_object()->short() + 
            "before you can splash.\n");
        return 0;
    }
    if ( sizeof( indirect_obs ) ) {
        add_succeeded_mess( "$N splash$es $I.\n", indirect_obs );
        return 1;
    }
    
    this_player()->add_succeeded_mess( this_object(),
        "$N splash$es $oself.\n", ({ }) );
    return 1;
}

int do_wash( object *indirect_obs ) {   

    if (!water) {
        this_player()->add_failed_mess(this_object(), "It's not a bad idea,  "
            "but maybe you'd need some water in the " + this_object()->short() + 
            "before you can wash.\n");
        return 0;
    }
    if (dirt >= sizeof(dirt_messages) - 1) {
        this_player()->add_failed_mess(this_object(), "The water in the " +
            this_object()->short() +
            " looks so muddy, it probably would just soil anyone.  Maybe " +
            " it would be a better idea to empty it and fill it again " +
            " with fresh water.\n");
        return 0;
    }

    if ( sizeof( indirect_obs ) ) {
        foreach( object victim in indirect_obs ) {
            call_out( (: zap_bad_effects( $1 ) :), 0, victim );
        }
        
        add_succeeded_mess( "$N wash$es $I using a bar of pleasant smelling soap.\n", indirect_obs );
        return 1;
    }
    
    call_out( (: zap_bad_effects( $1 ) :), 0, this_player() );
    this_player()->add_succeeded_mess( this_object(),
        "$N wash$es $oself using a bar of pleasant smelling soap.\n", ({ }) );
    return 1;
} /* wash_self() */


/**
 * Since we have a limited quantity of water here, it may wash an effect
 * right away, or it may need more washing.  It also means the water
 * itself will become dirty in the process.  The dirtier the water is,
 * the less likely it is to wash anything out.  Fresh water has about
 * 50% chance of washing anything out.
 */
void zap_bad_effects( object who ) {
    int i, flag, *enums;
    class effect *effs;
    
    dirt++;

    effs = (class effect *)who->query_effs();
    enums = (int *)who->effects_matching( "body.smell" );
    i = sizeof( enums );
    if ( !random(dirt) && i ) {
        i = random( i );
        flag = 1;
        write( "The antiseptic power of the soap defeats "+
          (string)effs[ enums[ i ] ]->ob_name->smell_string( who,
            effs[ enums[ i ] ]->arg ) +".\n" );
        who->delete_effect( enums[ i ] );
        dirt ++;
    }

    enums = who->effects_matching("pie.cream");
    if (!random(dirt) && sizeof(enums)) {
        tell_object(who, "The cream washes right off your body.\n");
        who->delete_effect(enums[0]);
        dirt ++;
    }

    enums = (int *)who->effects_matching( "misc.ketchup" );
    i = sizeof( enums );
    if ( !random(dirt) && i ) {
        i = random( i );
        flag = 1;
        write( "The soap rinses the ketchup off your face.\n" );
        who->delete_effect( enums[ i ] );
        dirt ++;
    }

    enums = who->effects_matching("exploded.apples");
    if (!random(dirt) && sizeof(enums)) {
        tell_object(who, "The apples wash right off your body.\n");
        who->delete_effect(enums[0]);
        dirt ++;
    }
    
    enums = (int *)who->effects_matching("object.label");
    if (!random(dirt) && sizeof(enums)) {
        // They cannot have this effect if they have no labels...
        tell_object(who, "The labels stuck on you peel off in "
          "the water.\n");
        who->delete_effect(enums[0]);
        dirt ++;
    }

    enums = who->effects_matching("body.frog-adhesive");
    if (!random(dirt) && sizeof(enums)) {
        tell_object(who, "The frog adhesive washes off in the water.\n");
        who->delete_effect(enums[0]);
        dirt ++;
    }


    if (!random(dirt)) {
        /* cure the fleas */
        who->add_effect( SOAP_EFFECT, 10000 );
    }
    who->add_effect( WET_EFFECT, 250 );
} /* zap_bad_effects() */
// --- END [/mnt/home2/grok/lib/std/room/furniture/sink_inherit.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/stable.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/stable.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629158   Available: 13576512
Inodes: Total: 5242880    Free: 4960135
15016 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/stable.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629158   Available: 13576512
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * A stable in which to house your lucky transport.
 * @author Pinkfish
 * @started Tue Nov 30 23:37:12 PST 1999
 */
#include <money.h>
#include <player.h>
inherit "/std/room/basic_room";

void load_me();

class stable {
   int date_in;
   int last_paid;
   string name;
   mixed* save_info;
}

private nosave string _directory;
private nosave int _start_cost;
private nosave int _cost_per_week;
private nosave mapping _stable_cache;
private nosave string* _stable_types;
private mapping _accounts;

int do_list();
int do_stable( object *obs );
int do_deposit( string mon );
int do_return( string num );

void create() {
  _start_cost = 400;
  _cost_per_week = 400;
  _stable_cache = ([ ]);
  _accounts = ([ ]);
  _stable_types = ({ });
  add_help_file( "stable" );
  ::create();
} /* create() */

void init() {
  add_command( "list", "", (: do_list() :) );
  add_command( "stable", "<indirect:object:here>", (: do_stable($1) :) );
  add_command( "deposit", "<string'money'>", (: do_deposit($4[0]) :) );
  add_command( "return", "<string'horse num'>", (: do_return($4[0]) :) );
} /* init() */

/**
 * This method sets the directory we will use to save the players
 * transports in.
 * @param save the directory to save the transports in
 */
void set_save_directory( string directory ) {
  if ( directory[<1] != '/' )
    directory += "/";

  _directory = directory;
  load_me();
} /* set_save_directory() */

/**
 * This method queries the directory we will use to save the players
 * transports in.
 * @return the save directory
 */
string query_save_directory() {
  return _directory;
} /* query_save_directory() */

/**
 * This method sets the basic cost of stabling the animal.
 * @param start_cost the basic cost
 */
void set_start_cost( int start_cost ) {
  _start_cost = start_cost;
} /* set_start_cost() */

/**
 * This method returns the basic cost of stabling the animal.
 * @return the basic cost
 */
int query_start_cost() {
  return _start_cost;
} /* query_start_cost() */

/**
 * This method sets the cost per week in the stables.
 * @param cost_per_week the cost per week
 */
void set_cost_per_week( int cost_per_week ) {
  _cost_per_week = cost_per_week;
} /* set_cost_per_week() */

/**
 * This method returns the cost per week in the stables.
 * @return the cost per week
 */
int query_cost_per_week() {
  return _cost_per_week;
} /* query_cost_per_week() */

/**
 * This method saves the room.
 */
void save_me() {
  unguarded( (: save_object(_directory + "main_account") :) );
} /* save_me() */

/**
 * This method loads the room.
 */
void load_me() {
  unguarded( (: restore_object(_directory + "main_account", 1) :) );
} /* load_me() */

/**
 * This method returns the players current balance in their stable
 * account.
 * @return the current stable balance
 */
int query_balance( string name ) {
  return _accounts[name];
} /* query_balance() */

/**
 * This method sets the current balance of the player stable account.
 * @param name the name of the player
 * @param amt the amount to set the stable account as
 */
void set_balance( string name, int amt ) {
  _accounts[name] = amt;
   save_me();
} /* set_balance() */

/**
 * This method adjusts the balance of the players stable account.
 * @param name the name of the player
 * @param amt the amount to adjust the account by
 */
void adjust_balance( string name, int amt ) {
  _accounts[name] += amt;
  save_me();
} /* adjust_balance() */

/**
 * This method returns the amount of money on the player and in their
 * account.
 * @param player the player to check the balance of
 * @param place the place in which to check the money
 * @return the total money on the player and in their account
 */
int query_player_money( object player, string place ) {
  return player->query_value_in( place ) +
         query_balance( player->query_name() );
} /* query_player_money() */

/**
 * This method removes money from the player, it will try and remove from
 * their stable balance before taking money off them.
 * @param player the player to remove the money off
 * @param amt the amount to remove
 * @param place the place the money is from
 */
void remove_player_money( object player, int amt, string place ) {
  int balance;

  balance  = query_balance( player->query_name() );
  if ( balance < 0 ) {
     //
     // We need to steal other money off the player too :)
     //
     amt += -balance;
     balance = 0;
  } else {
    if ( amt <= balance ) {
      balance -= amt;
      amt = 0;
    } else {
      amt -= balance;
      balance = 0;
    }
  }

  if ( amt > 0 ) {
    player->pay_money( MONEY_HAND->create_money_array( amt, place ),
                       place );
   }

   set_balance( player->query_name(), balance );
} /* remove_player_money() */

/**
 * This method adds in a type of transport that can be stabled in this
 * stable.
 * @param type the type of transport to add
 */
void add_stable_type( string type ) {
  if ( member_array( type, _stable_types ) == -1) {
    _stable_types += ({ type });
  }
} /* add_stable_type() */

/**
 * This method returns the types of transports that can be stabled here.
 * @return the types of transport that can be stabled here
 */
string* query_stable_types() {
  return _stable_types;
} /* query_stable_types() */

/**
 * This method checks to see if the specified type of transport can be
 * stabled here.
 * @param type the type to check
 * @return 1 if it can be stabled, 0 if not
 */
int can_stable_type( string type ) {
  if ( member_array( type, _stable_types ) != -1 ) {
    return 1;
  }
  return 0;
} /* can_stable_type() */

/**
 * This method will find the stable associated with the specified player.
 * @return the found stable, or 0 if not found
 */
protected class stable* query_stable( string name ) {
  string str;

  if ( !_stable_cache[name] && file_size( _directory + name + ".o" ) > 0 ) {
    // Load it!
    str = read_file( _directory + name + ".o" );
    if ( str ) {
      _stable_cache[name] = restore_variable( str );
    }
  }
  return _stable_cache[name];
} /* query_stable() */

/**
 * This method sets the stable to the new value.
 * @param name the name of the stable
 * @param value the new value of the stable
 */
protected void set_stable( string name, class stable* value ) {
  _stable_cache[name] = value;
  if ( !value || !sizeof( value ) ) {
    // Remove it!
    unguarded( (: rm(_directory + $(name) + ".o") :) );
  } else {
    unguarded( (: write_file( _directory + $(name) + ".o",
                  save_variable( $(value) ), 1 ) :) );
  }
} /* set_stable() */

/**
 * This method returns the cost of stabling the horse up to the current
 * time.
 * @param name the name of the owner of the stable
 * @return the cost of stabling the horse
 */
int query_stabling_cost( string name, int pos ) {
  class stable* bing;

  bing = query_stable( name );
  if ( pos < 0 || pos >= sizeof( bing ) ) {
    return 0;
  }

  return ( ( time() - bing[pos]->last_paid ) * _cost_per_week ) /
           (7 * 24 * 60 * 60);
} /* query_stabling_cost() */

/**
 * This method adds the horses to the stable.
 * @param name the player to whose stable we are adding the horse
 * @param horses the horses to add
 * @return 1 if they are successfuly added
 */
int add_to_stable( string name, object* horses ) {
  class stable* bing;
  class stable womble;
  object horse;

  bing = query_stable( name );
  if ( !bing ) {
    bing = ({ });
  }

  foreach ( horse in horses ) {
    womble = new( class stable );
    womble->date_in = time();
    womble->last_paid = time();
    womble->name = horse->query_short();
    womble->save_info = AUTO_LOAD_OB->create_auto_load( ({ horse }) );
    bing += ({ womble });
  }
  set_stable( name, bing );
  horses->move("/room/rubbish");
  return 1;
} /* add_to_stable() */

/**
 * This message prints out something happy when you actually do the
 * stabling.
 * @param me the person doing the stabling
 * @param horses the horses being stabled
 */
void print_ok_message( object me, object* horses ) {
  write( "You stable " + query_multiple_short( horses ) + " into " +
         the_short() + ".\n" );
  say( this_player()->the_short() + " stables " +
       query_multiple_short( horses ) + " into " + the_short() + ".\n" );
} /* print_ok_message() */

/**
 * This method allows the person to stable their animal.  It will cost
 * them (of course).
 */
int do_stable( object *obs ) {
  class stable* bing;
  int cost;
  object horse;
  object *ok;
  string place;

  place = query_property( "place" );
  if ( !place )
    place = "default";

  bing = query_stable( this_player()->query_name() );

  ok = ({ });
  foreach ( horse in obs ) {
    if ( !can_stable_type( horse->query_transport_type() ) ) {
      add_failed_mess( "$I is not able to be stabled here.\n", ({ horse }) );
    } else if ( horse->query_owner() != this_player()->query_name() ) {
      add_failed_mess( "You do not own $I and therefore cannot stable them.\n",
                       ({ horse }) );
    } else {
      ok += ({ horse });
      cost += _start_cost;
    }
  }

  if ( sizeof( ok ) ) {
    if ( query_player_money( this_player(), place ) < cost ) {
      add_failed_mess( "You do not have enough money to stable $I, you "
                       "need " + MONEY_HAND->money_value_string(cost, place) +
                       ".\n", ok );
      return 0;
    }

    write( "It will cost you " + MONEY_HAND->money_value_string( cost, place ) +
           " to stable " + query_multiple_short( ok ) + " here and " +
           MONEY_HAND->money_value_string( _cost_per_week, place ) +
           " for each horse for every week it stays here.\nDo you accept "
           "this? " );
    input_to( "check_stable", 0, cost, ok, place );
    add_succeeded_mess( "" );
  }

  return sizeof( ok );
} /* do_stable() */

/**
 * This method is used to confirm that they want to spend theirn
 * money stabling the horse.
 * @param mess what the player types
 * @param cost the cost of the stabling
 * @param ok the horses being stabled
 */
protected void check_stable( string mess, int cost, object *ok, string place ) {
  if ( strlen( mess ) && lower_case( mess )[0] == 'y' ) {
    if ( query_player_money( this_player(), place ) < cost ) {
      write("Oops!  You seem to have run out of money.\n" );
    } else {
      remove_player_money( this_player(), cost, place );
      add_to_stable( this_player()->query_name(), ok );
      print_ok_message( this_player(), ok );
    }
  } else {
    write( "Ok, abandoning the check in.\n" );
  }
} /* check_stable() */

/**
 * This method shows you a list of all the horse you have in the stables.
 * @return 1 on success, 0 on failure
 */
int do_list() {
  class stable* bing;
  int i;
  int cost;
  int balance;
  string debt;
  string place;

  place = query_property( "place" );
  if ( !place )
    place = "default";

  bing = query_stable( this_player()->query_name() );
  balance = query_balance( this_player()->query_name() );
  if ( !bing || !sizeof( bing ) ) {
    if( !balance ) {
      add_failed_mess( "You do not have any horses stabled here.\n" );
      return 0;
    }
    write( "You have a balance of " +
           MONEY_HAND->money_value_string( cost, place ) +
           " in your stabling account.\n" );
    return 1;
  }

  for ( i = 0; i < sizeof( bing ); i++ ) {
    cost = query_stabling_cost( this_player()->query_name(), i );
    if ( cost == 0 ) {
      debt = "paid up";
    } else if (cost < 0) {
      debt = "in credit " + MONEY_HAND->money_value_string( -cost, place );
    } else {
      debt = "in debt " + MONEY_HAND->money_value_string( cost, place );
    }
    write( sprintf( " %c) %s; %s\n ", 'A' + i, bing[i]->name, debt ) );
  }

  if ( balance > 0 ) {
    write( "You have a stable balance of " +
           MONEY_HAND->money_value_string( balance, place ) + ".\n" );
  } else if ( balance < 0 ) {
    write( "You have a stable balance of " +
           MONEY_HAND->money_value_string( balance, place ) + " in debt.\n" );
  } else {
    write( "You do not have a balance at this time.\n" );
  }

  add_succeeded_mess( ({ "", "$N checks out $p horses.\n" }) );
  return 1;
} /* do_list() */

/**
 * This method removes an animal from the stables and runs off with it.
 * @return 1 on success, 0 on failure
 */
int do_return( string num ) {
  class stable* bing;
  int pos;
  int cost;
  object* horses;
  string place;

  place = query_property( "place" );
  if ( !place )
    place = "default";

  bing = query_stable( this_player()->query_name() );
  if ( !sizeof( bing ) ) {
    add_failed_mess( "You do not have any horses stabled here.\n" );
    return 0;
  }

  num = lower_case( num );
  pos = num[0] - 'a';
  if ( pos < 0 || pos > sizeof( bing ) ) {
    add_failed_mess( "You must return a horse in the range 'A' - '" +
                     sprintf( "%c", 'A' + sizeof( bing ) - 1 ) + "'.\n" );
    return 0;
  }

  cost = query_stabling_cost( this_player()->query_name(), pos );
  if ( query_player_money( this_player(), place ) < cost ) {
    add_failed_mess( "You do not have enough money to return this horse "
                     "you need " +
                     MONEY_HAND->money_value_string( cost, place ) +
                     ".\n" );
    return 0;
  }

  horses = AUTO_LOAD_OB->load_auto_load_to_array( bing[pos]->save_info );
  horses->move( this_object() );
  horses->set_owner( this_player()->query_name() );
  bing = bing[0..pos - 1] + bing[pos + 1..];
  set_stable( this_player()->query_name(), bing );
  if ( cost > 0 ) {
    remove_player_money( this_player(), cost, place );
  }
  add_succeeded_mess( "$N $V $I from " + the_short() + ".\n", horses );
  return 1;
} /* do_return() */

/**
 * This method adds money to the players stable account.
 * @param obs the money to be deposited
 * @return 1 on success, 0 on failure
 */
int do_deposit( string mon ) {
  string place;
  mixed money;
  int amt;

  place = query_property( "place" );
  if ( !place )
    place = "default";

  if ( undefinedp( query_balance( this_player()->query_name() ) ) ) {
    add_failed_mess( "You do not currently have a balance here.\n" );
    return 0;
  }

  money = MONEY_HAND->parse_money( mon, this_player(), place );
  if ( intp( money ) ) {
    switch ( money ) {
      case NO_MATCH :
        add_failed_mess( "You do not have '" + mon + "'.\n" );
        return 0;
      case NO_MONEY :
        add_failed_mess( "You can only deposit money.\n" );
        return 0;
      default :
        add_failed_mess( "You can only deposit legal tender.\n" );
        return 0;
    }
  }

  amt = money->query_value_in( place );
  if ( place != "default" ) {
    amt += money->query_value_in( "default" );
  }

  adjust_balance( this_player()->query_name(), amt );
  add_succeeded_mess( ({ "You deposit " +
                      MONEY_HAND->money_string( money->query_money_array() ) +
                      " into your stable account.\n",
                      "$N deposits some money into $p account.\n" }) );
  return 1;
} /* do_deposit() */
// --- END [/mnt/home2/grok/lib/std/room/stable.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/bath_house_outside.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/bath_house_outside.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629154   Available: 13576508
Inodes: Total: 5242880    Free: 4960135
353 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/bath_house_outside.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629154   Available: 13576508
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * Outdoors bath house inheritable.
 * @author Taffyd
 * @started 3/05/00 9:55
 */

inherit "/std/room/outside";
inherit "/std/room/inherit/bath_house";

/** @ignore yes */
void create() {
    bath_house::create();
    outside::create();
} /* create() */

/** @ignore yes */
void init() {
    outside::init();
    bath_house::init();
} /* init() */
// --- END [/mnt/home2/grok/lib/std/room/bath_house_outside.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/basic_room_new.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/basic_room_new.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629154   Available: 13576508
Inodes: Total: 5242880    Free: 4960135
88329 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/basic_room_new.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629154   Available: 13576508
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  RCS stuff...  -*- LPC -*-
 * $Locker: pinkfish $
 *
 * $Id: basic_room.c,v 1.10 2001/01/14 03:28:59 ceres Exp pinkfish $
 *
 */

/**
 * The standard room inheritable.  This contains all the stuff needed to
 * construct a standard room.
 * @author Pinkfish
 * @see /std/room/outside.c
 */

#include <armoury.h>
#include <dirs.h>
#include <door.h>
#include <move_failures.h>
#include <room.h>
#include <position.h>
#include <situations.h>
#include <twilight.h>
#include <nroff.h>

inherit "/std/basic/cute_look";
inherit "/std/basic/desc";
inherit "/std/basic/extra_look";
inherit "/std/basic/light";
inherit "/std/basic/property";
inherit "/std/basic/export_inventory";
inherit "/std/basic/help_files";

nosave int do_setup;
nosave int *co_ord;
nosave int co_ord_calculated;
nosave string long_exit;
nosave string short_exit;
nosave string theft_handler;
nosave string *aliases;
nosave string *exits;

nosave object item;
nosave object chatter;
nosave object sitchanger;
nosave object effects;
nosave object linker;
nosave object terrain;
nosave object wall; 
nosave object *hidden_objects;
private nosave object* _use_internal_objects;
nosave mapping door_control;
nosave mixed *dest_other;
nosave int enchant_time;
nosave int background_enchant;
nosave float dynamic_enchant;
private nosave int last_visited;

// This is the day/night stuff.
nosave string *variablelongs;
nosave mixed variablechats;
nosave mixed variableitems;
nosave int is_day = -1;

varargs int add_item( mixed shorts, mixed desc, int no_plural );
int remove_item( string word );
varargs void room_chat( mixed *args, object chatobj );
void set_not_replaceable(int replace);
int query_not_replaceable();
void set_night_long( string str );

protected void create() {
   object *npcs;
   object virt_room;
   string *inhs;

   desc::create();
   extra_look::create();
   property::create();
   export_inventory::create();
   light::create();
   set_can_export_inventory();
   set_ignore_livings_in_inventory( 0 );
   aliases = ({ });
   exits = ({ });
   hidden_objects = ({ });
   _use_internal_objects = ({ });
   door_control = ([ ]);
   dest_other = ({ });
   seteuid( (string)"/secure/master"->creator_file( file_name(
           this_object() ) ) );
   add_property( "location", "inside" );
   add_property( "here", "on the floor" );
   if ( !do_setup ) {
      this_object()->setup();
      this_object()->reset();
   }
   if ( find_object( "/obj/handlers/map" ) ) {
      catch( "/obj/handlers/map"->check_map( file_name( this_object() ) ) );
   }
   if( (virt_room = find_object("/room/virtual") ) ){
     npcs = ({}) + all_inventory(virt_room);
     catch(npcs->real_room(file_name()));
   }

   // Check to see if the room is replaceable...
   inhs = inherit_list(this_object());
   if (sizeof(inhs) == 1) {
      if (replaceable(this_object(), ({ "setup" }))) {
         // Do it after a delay so that setup() has definately finished.
         call_out(function(string fname) {
           if (!query_not_replaceable()) {
             replace_program(fname);
           }
         }, 0, inhs[0]);
      }
   }
} /* create() */

/**
 * Returns 1 to indicate that this object is a room.
 * @return 1 to indicate that this is a room
 */
int query_is_room()
{
  return 1;
}

/**
 * Returns the current enchantment level of the room.  The enchanment
 * level controls things like what happens when you flip coins and
 * some special messages which give wizards some idea about magic
 * levels.
 * @return the current enchantment
 * @see set_enchant()
 */
int query_enchant() {
  int enchant_level =  to_int( floor( 0.5 + dynamic_enchant *
                        exp( -0.693 *
                             ( time() - enchant_time ) /
                             ENCHANT_HALF)) +
                 background_enchant );
  if ( enchant_level > 5000 ) {
    return 5000;
  }

  return enchant_level;
} /* query_enchant() */

/**
 * Sets the current enchantment level of the room.  The enchanment
 * level controls things like what happens when you flip coins and
 * some special messages which give wizards some idea about magic
 * levels.
 * When called from the room itself, it sets a background level of 
 * enchantment that don't decay, when called from another object it
 * sets the current enchantment which then decays towards the background 
 * level.
 * @param number the new enchantment level to set
 * @see query_enchant()
 */
int set_enchant(int number) {
  if (number < 0) {
    number = 0;
  }

  if (previous_object()==this_object()) { 
    /* setting up the background enchantment */
    background_enchant = (float) number;
    dynamic_enchant = 0.0;
    enchant_time = time();
  } else {
    /* by design, this can result in negative dynamic enchantment
     * it is definitely possible to suck out all magic in an area,
     * but it'll seep back in if the background level is higher.
     */
    dynamic_enchant = number - background_enchant;
    enchant_time=time();
  }
  return number;
} /* set_enchant() */

/**
 * Adds number to the current enchantment level of the room.
 * The enchanment level controls things like what happens when you
 * flip coins and some special messages which give wizards some 
 * idea about magic levels.
 * @param number the new enchantment level to set
 * @see query_enchant()
 */
int add_enchant( int number ) {
  dynamic_enchant = dynamic_enchant * exp( -0.693 * 
                                           ( time() - enchant_time ) /
                                           ENCHANT_HALF ) + number;
  enchant_time = time();
  return floor( 0.5 + dynamic_enchant ) + background_enchant;
} /* add_enchant() */
  
/**
 * This method sets the background enchantment of the room.
 * @return the theft handler of the room
 * @see set_enchant()
 */
void set_background_enchant( int number ) { 
  background_enchant = number;
} /* set_background_enchant() */

/**
 * This method sets the current dynamic enchantment of the room.
 * @return the theft handler of the room
 * @see set_enchant()
 */
void set_dynamic_enchant( float number ) { 
  dynamic_enchant = number;
  enchant_time = time();
} /* set_dynamic_enchant() */

/**
 * This method returns the background enchantment of the room.
 * @return the theft handler of the room
 * @see query_enchant()
 */
int query_background_enchant() { 
  return background_enchant;
} /* query_background_enchant() */

/**
 * This method returns the current dynamic enchantment of the room.
 * @return the theft handler of the room
 * @see query_enchant()
 */
float query_dynamic_enchant() { 
  dynamic_enchant = dynamic_enchant * exp( -0.693 * 
                                           ( time() - enchant_time ) /
                                           ENCHANT_HALF );
  enchant_time = time();
  return dynamic_enchant;
} /* set_dynamic_enchant() */

/**
 * Returns the current co-ordinates of the room.  The co-ordinates are
 * 3d, ({ x, y, z }).  So an array with three elements.
 * @return the current co-ordinates
 * @see set_co_ord()
 */
int *query_co_ord() {
  if ( pointerp( co_ord ) ) {
    return copy(co_ord);
  }
  return 0;
} /* query_co_ord() */

/**
 * Sets the current co-ordinates of the room.  The co-ordinates are
 * 3d, ({ x, y, z }).  So an array with three elements.
 * @param new_co_ord the new co-ordinates for the room.
 * @see query_co_ord()
 * @see query_co_ord_calculated()
 */
void set_co_ord( int *new_co_ord ) {
  if ( !pointerp( new_co_ord ) ) {
    write( "Warning: Co-ordinate must be an array.\n" );
    return;
  }
  if ( sizeof( new_co_ord ) != 3 ) {
      write( "Warning: The co-ordinate must have three elements.\n" );
      return;
  }
  co_ord = new_co_ord;
  if ( previous_object() == this_object() ) {
    co_ord_calculated = 0;
  } else {
    co_ord_calculated = 1;
  }
} /* set_co_ord() */

/**
 * This tells us if the co-ordinates were set or if they were calculated.
 * If they were set with set_co_ord then the value of this will be 0
 * otherwise it will be 1.
 * @return 1 if it is calculated, 0 if it is not
 * @see query_co_ord()
 * @see set_co_ord()
 */
int query_co_ord_calculated() { return co_ord_calculated; }

/**
 * This returns the long exit string.  This is calculated when it is
 * first needed by the calc_long_exit function.
 * @return the long exit string
 * @see calc_long_exit()
 * @see long()
 */
string query_long_exit() { return long_exit; }

/**
 * This method creates the long exit description used in the room long
 * descriptions.
 * @see query_long_exit()
 */
void calc_long_exit() {
  int i, add;
  string *words;
  mixed tmp;
  
  words = ({ });
  for ( i = 0; i < sizeof( dest_other ); i += 2 ) {
    tmp = dest_other[ i + 1 ][ ROOM_OBV ];
    if ( !tmp ) {
      continue;
    }
    if ( intp( tmp ) && tmp ) {
      add = 1;
    }
    if ( stringp( tmp ) ) {
      add = (int)call_other( this_object(), tmp, dest_other[ i ] );
    }
    if ( pointerp( tmp ) ) {
      add = (int)call_other( tmp[ 0 ], tmp[ 1 ], dest_other[ i ] );
    }
    if ( add ) {
      if(dest_other[i+1][ROOM_REL]) {
        words += ({ "$R$-"+ dest_other[ i ] +"$R$" });
      } else {
        words += ({ dest_other[i] });
      }
    }
  }
  switch ( sizeof( words ) ) {
  case 0 :
    long_exit = "There are no obvious exits.";
    break;
  case 1 :
    long_exit = "There is one obvious exit: "+ words[ 0 ];
    break;
  default :
    long_exit = "There are "+ query_num( sizeof( words ), 0 ) +
      " obvious exits: "+ query_multiple_short( words ) +
      ".";
  }
} /* calc_long_exit() */

/**
 * This method returns the current theft handler for the room.
 * @return the theft handler of the room
 * @see set_theft_handler()
 */
string query_theft_handler() { return theft_handler; }

/**
 * This method sets the current theft handler for the room.
 * @param word the new theft handler for the room
 * @see query_theft_handler()
 */
void set_theft_handler( string word ) { theft_handler = word; }

/**
 * This method returns the current exit aliases for the room.
 * @return the exit aliases of the room
 * @see add_alias()
 * @see remove_alias()
 */
string *query_aliases() { return copy( aliases ); }

/**
 * This method adds an exit alias to the room.
 * Aliases are convenient extra forms that can be attached to certain
 * exits. In the above functions, the variable names is either a string
 * or an array of strings and is, respectively, the alias or aliases
 * for the direction passed in word. Since, sometimes, the same alias
 * could be used for more than one exit, remove_alias() requires both
 * alias(es) and direction in order to remove the correct alias(es). 
 * @param names the exit names to alias
 * @param word the name to alias them too
 * @see query_aliases()
 * @see remove_alias()
 * @example
 * add_exit( "north", PATH +"dining_hall", "corridor" );
 * add_alias( ({ "enter", "enter hall", "enter dining hall" }), "north" );
 * @example
 * add_exit( "board carriage", PATH +"carriage", "door" );
 * add_alias( "board", "board carriage" );
 */
void add_alias( mixed names, string word ) {
  string name;

  if ( !aliases ) {
    aliases = ({ });
  }
  if ( pointerp( names ) ) {
    foreach ( name in names ) {
      add_alias( name, word );
    }
    return;
  }
  aliases += ({ word, names });
  if ( find_call_out( "calc_exits" ) == -1 ) {
    call_out( "calc_exits", 1 );
  }
} /* add_alias() */

/**
 * This method removes the exit aliases from the room.
 * Aliases are convenient extra forms that can be attached to certain
 * exits. In the above functions, the variable names is either a string
 * or an array of strings and is, respectively, the alias or aliases
 * for the direction passed in word. Since, sometimes, the same alias
 * could be used for more than one exit, remove_alias() requires both
 * alias(es) and direction in order to remove the correct alias(es). 
 * @param names the names to remove
 * @param word what they were aliased to
 * @see add_alias()
 * @see query_aliases()
 * @example
 * remove_exit( "board carriage" );
 * remove_alias( "board", "board carriage" );
 */
void remove_alias( mixed names, string word ) {
  int i;
  string name;

  if ( !aliases ) {
    return;
  }
  if ( pointerp( names ) ) {
    foreach ( name in names ) {
      remove_alias( name, word );
    }
    return;
  }
  for ( i = sizeof( aliases ) - 2; i >= -1; i -= 2 ) {
    if ( ( aliases[ i ] == word ) && ( aliases[ i + 1 ] == names ) ) {
      aliases = delete( aliases, i, 2 );  
    }
  }
} /* remove_alias() */

/**
 * This returns the current array of exits.
 * @return the exits array
 * @see add_exit()
 * @see remove_exit()
 * @see modify_exit()
 */
string *query_exits() { return copy(exits); }

/**
 * This method removes all the current exits in the room.
 * @see add_exit()
 * @see remove_exit()
 * @see modify_exit()
 */
void reset_exits() { exits = ({ }); }

/**
 * This method returns the current item object.
 * @return the current item object
 * @see add_item()
 */
object query_item() { return item; }

/**
 * This method returns the current chatter object.
 * @return the chatter object
 * @see add_room_chat()
 */
object query_chatter() { return chatter; }

/**
 * This method returns the current situation changer object.
 * @return the situation changer object
 * @see add_situation()
 * @see automate_situation()
 * @see change_situation
 */
object query_situation_changer() { return sitchanger; }

/**
 * This method returns the current effects object.
 * @return the effects object
 * @see add_effect()
 */
object query_effects() { return effects; }

/**
 * This method returns the current linker object.
 * @return the linker object
 */
object query_linker() { return linker; }

/**
 * This method returns the current terrain object.
 * @return the terrain object
 * @see add_room_chat()
 */
object query_terrain() { return terrain; }

/**
 * This method returns the current wall object.
 * @return the wall object
 * @see add_room_chat()
 */
object query_wall() { return wall; }

/**
 * This returns the current array of hidden objects.  The hidden objects
 * are used to allow things to not actually be in the room description
 * but be able to be manipulated by commands.
 * @see add_hidden_object()
 * @see remove_hidden_object()
 * @return the array of hidden objects
 */
object *query_hidden_objects() { return hidden_objects + ({ }); }

/**
 * This puts a hidden object into a room. A hidden object is an object that
 * exists in the room as far as all the find_match calls go. So, for look at's
 * and so on, but does not actually exist in the room so it does not show up
 * in the inventory when the player does a look. This is the method used for
 * putting signs and doors into rooms, that actually have shorts and you can
 * do things to, but do not show up in the inventory. The function init is also
 * called on these objects when init is called in the room. The only thing you
 * cannot put in your init function is an add_action. You can however define
 * up bunches of add_commands...
 * <p>
 * If this sounds complicated. Think of it as an object that IS in the room, but
 * you cannot see it. 
 * <p>
 * A word of warning here, the init() function will *not* be called on all
 * the players when the object is added as hidden.  This means that the
 * commands on it will not be available until the player re-enters the room.
 * You could get around this by moving everyone out of the room and
 * then back in again.
 * @example
 * #include <room.h>
 * sign = clone_object(PATH + SIGN);
 * add_hidden_object(sign);
 * @example
 * // Add a hidden object that has actions we want players to be able to
 * // use.
 * add_hidden_object(fluffy_container);
 * players = filter(all_inventory(), (: living($1) :));
 * players->move(ROOM_VOID);
 * // This forces init() to be recalled.  (This is realtivatively icky
 * // way of doing it, but the driver does not give us many alternatives).
 * players->move(this_object());
 * @see query_hidden_object()
 * @see remove_hidden_object()
 * @param thing the hidden object to add
 * @return 1 if successful, 0 on a failure
 */
int add_hidden_object( object thing ) {
  if ( member_array( thing, hidden_objects ) != -1 ) {
    return 0;
  }
  hidden_objects += ({ thing });
  return 1;
} /* add_hidden_object() */

/**
 * This method removes a hidden object.
 * @param thing the hidden object to remove
 * @return 1 on success, 0 on failure
 * @see add_hidden_object()
 * @see query_hidden_objects()
 */
int remove_hidden_object( object thing ) {
  int i;

  i = member_array( thing, hidden_objects );
  if ( i == -1 ) {
    return 0;
  }
  hidden_objects = hidden_objects[0..i - 1] + hidden_objects[i + 1..];
  return 1;
} /* remove_hidden_object() */

/**
 * This method adds an object whose interior bits want to be able to export
 * commands.  You can use this for tables an so on, so that stuff on a table
 * can still be used.
 * @param thing the thing whose inventory bits are to be exported
 */
void add_use_internal_object(object thing) {
   _use_internal_objects |= ({ thing });
} /* add_use_internal_objects() */

/**
 * This method removes an object whose interor bits want to export.
 * @param thing the object to remove
 */
void remove_use_internal_object(object thing) {
   _use_internal_objects -= ({ thing });
} /* remove_use_internal_object() */

/**
 * This method returns all the current use internal objects available.
 * @return the list of use internal objects here
 */
object* query_use_internal_objects() {
   return _use_internal_objects;
} /* query_use_internal_objects() */

/**
 * This returns the information about the door in the specified direction.
 * @param direc the direction to query the door in
 * @return the door control information
 * @see modify_exit()
 */
varargs mixed query_door_control( string direc ) {
   if ( !stringp( direc ) ) {
      return copy( door_control );
   }
   return door_control[ direc ];
} /* query_door_control() */

/**
 * This returns information about the exits in the room.  This is the
 * information set by modify_exit().  The values from this are probably
 * not very useful for normal coding.
 * @see modify_exit()
 * @see query_dest_dir()
 */
varargs mixed *query_dest_other( string direc ) {
  int i;

  if ( !stringp( direc ) ) {
    return copy( dest_other );
  }
  i = member_array( direc, dest_other );
  if ( i == -1 ) {
    return 0;
  }
  return copy( dest_other[ i + 1 ] );
} /* query_dest_other() */

/**
 * Returns an array containing just the destinations and directions used to
 * get there. This is useful for monster or whatever that you want to scan a
 * room for exits to leave out of. The array is of the format. ({ direction1,
 * destination1, direction2, destination2, ... })
 * <p>
 * The thing passed in is used as the basis for the relative directions
 * if it is an object.  If it is not an object then this is ignored
 * altogether.
 * @see query_dest_other()
 * @see add_exit()
 * @param thing used to get the relative directions according to thing
 * @return the array of direction, destination pairs
 */
varargs string *query_dest_dir( object thing ) {
  int i;
  string *ret;
  
  ret = ({ });
  for ( i = sizeof( dest_other ) - 2; i > -1; i -= 2 ) {
    if ( !dest_other[ i + 1 ][ ROOM_REL ] || !objectp( thing ) ) {
      ret += ({ dest_other[ i ], dest_other[ i + 1 ][ ROOM_DEST ] });
    } else {
      ret += ({ (string)thing->find_rel( dest_other[ i ] ),
                  dest_other[ i + 1 ][ ROOM_DEST ] });
    }
  }
  return ret;
} /* query_dest_dir() */

/**
 * This method just returns all the directions available to leave from
 * the room.
 * <p>
 * The thing passed in is used as the basis for the relative directions
 * if it is an object.  If it is not an object then this is ignored
 * altogether.
 * <p>
 * <b>Strawberries</b>
 * <p>
 * Starting from a above,<br>
 * Working slowly down under.<br>
 * Sliding up the sides<br>
 * Eating a meal, fresh cream and syrup.<br>
 * <p>
 * Round and round, and round again<br>
 * Grining micheviously<br>
 * One tongue at play<br>
 * Firm and hard, fresh strawberries today.
 *
 * @see query_dest_other()
 * @see add_exit()
 * @param thing used to get the relative directions according to thing
 * @return the array of directions
 */
varargs string *query_direc( object thing ) {
  int i;
  string *ret;
  
  ret = ({ });
  for ( i = sizeof( dest_other ) - 2; i > -1; i -= 2 ) {
    if ( !dest_other[ i + 1 ][ ROOM_REL ] || !objectp( thing ) ) {
      ret += ({ dest_other[ i ] });
    } else {
      ret += ({ (string)thing->find_rel( dest_other[ i ] ) });
    }
  }
  return ret;
} /* query_direc() */

/**
 * This method returns the destination room for an exit.
 * @param exit the exit name
 * @return the path of the destination room, or ROOM_VOID on error
 * @see query_dest_dir()
 * @example
 * #include <room.h>
 * string dest;
 *
 * dest = room->query_destination("south");
 * if (dest == ROOM_VOID) {
 *    do_error();
 * } else {
 *    do_move("south");
 * }
 */
string query_destination( string exit ) {
   int i;

   i = member_array( exit, dest_other );
   if ( ( i < 0 ) && objectp( this_player() ) )
      i = member_array( (string)this_player()->reorient_rel( exit ),
            dest_other );
   if ( i < 0 )
      return ROOM_VOID;
   return dest_other[ i + 1 ][ ROOM_DEST ];
} /* query_destination() */

/** @ignore yes */
int test_add( object thing, int flag ) { return 1; }

/** @ignore yes */
int test_remove( object thing, int flag, mixed dest ) { return 1; }

/** @ignore yes */
int add_weight( int number ) { return 1; }

/** @ignore yes */
int query_no_writing() { return 1; }

/** @ignore yes */
int query_decay() { return 10; }

/**
 * This method sets the default attack speed for the room.
 * This defaults to 15.
 * @return the default attack speed
 */
int attack_speed() { return 15; }

/**
 * This is the message to print instead of the room description when the
 * room is dark.  It defaults to the message "It's dark in here isn't it?".
 * @return the dark message
 * @see set_dark_mess()
 * @see long()
 * @see query_bright_mess()
 */
string query_dark_mess() {
  mixed dark_mess;

  if ( !stringp( dark_mess = query_property( "dark mess" ) ) ) {
    return "It's dark here, isn't it?";
  }
  return dark_mess;
} /* query_dark_mess() */

/**
 * This method sets the dark message associated with the room.
 * @param word the new dark message
 * @see query_dark_mess()
 * @see long()
 */
void set_dark_mess( string word ) {
    add_property( "dark mess", word );
} /* set_dark_mess() */

/**
 * This method returns the message to use when it is too bright to see in
 * the room.  It defaults to: "It's too bright to see anything!".
 * @return the message to print when it is too bright
 * @see query_dark_mess()
 * @see long()
 * @see set_bright_mess()
 */
string query_bright_mess() {
  mixed bright_mess;
 
  if ( !stringp( bright_mess = query_property( "bright mess" ) ) ) {
    return "It's too bright to see anything!";
  }
  return bright_mess;
} /* query_bright_mess() */

/**
 * This method sets the bright message associated with the room.
 * @param word the new bright message
 * @see query_bright_mess()
 * @see long()
 */
void set_bright_mess( string word ) { add_property( "bright mess", word ); }

/**
 * This method queries the size of the room.  The default size of a room
 * is 10x10x10.  A room can be any rectangular size, this method will return
 * an array of three elements if the room is a non-cube.  If it returns
 * a single number then the room is assumed to be cubic.
 * <p>
 * ({ north-south size, east-west size, up-down size })
 * <p>
 * The sizes are all radii's so they are half the actual width of the room.
 * @return the size of the room
 * @see set_room_size()
 * @see query_room_size_array()
 */
mixed query_room_size() {
   mixed room_size;

   room_size = query_property( "room size" );
   if ( !room_size ) {
      return 10;
   }
   return room_size;
} /* query_room_size() */

/**
 * This method returns the size of the room as a three element array always.
 * <p>
 * ({ north-south size, east-west size, up-down size })
 * <p>
 * The sizes are all radii's so they are half the actual width of the room.
 * @return the size of the room as a three element array
 * @see query_room_size()
 * @see set_room_size()
 */
int *query_room_size_array() {
   mixed room_size;

   room_size = query_room_size();
   if ( pointerp( room_size ) ) {
      return room_size;
   }
   return ({ room_size, room_size, room_size });
} /* query_room_size_array() */

/**
 * This method sets the rooms principle radii.  If the parameter isa single
 * number then the room is assumed to be cubic and dimension applies in
 * all directions.  If the input is a three element array then the elements
 * apply to all the directions.<br>
 * ({ north-south size, east-west size, up-down size })
 * <p>
 * The sizes are all radii's so they are half the actual width of the room.
 * @param number the new size of the room
 * @see query_room_size()
 * @see query_room_size_array()
 */
void set_room_size( mixed number ) {
   if ( intp( number ) ) {
      add_property( "room size", number );
      return;
   }
   if ( pointerp( number ) ) {
      if ( sizeof( number ) == 3 ) {
         add_property( "room size", number );
         return;
      }
   }
   write( "Room size must be an integer or an array of three integers.\n" );
} /* set_room_size() */

/** @ignore yes */
int id( string word ) { return 0; }

string expand_alias( string word ) {
   int i;

   if ( !aliases || !sizeof( aliases ) ) {
      return word;
   }
   i = member_array( word, aliases );
   if ( i == -1 ) {
      return word;
   }
   if ( i % 2 ) {
      return aliases[ i - 1 ];
   }
   return word;
} /* expand_alias() */

/**
 * This method returns the exit string used when in brief mode.
 * @return the brief exit string
 * @see calc_exit_string()
 */
string calc_short_exit_string() {
   int i, add;
   string *words;
   mixed tmp;

   words = ({ });
   for ( i = 0; i < sizeof( dest_other ); i += 2 ) {
      tmp = dest_other[ i + 1 ][ ROOM_OBV ];
      if ( !tmp ) {
         continue;
      }
      if ( intp( tmp ) && tmp ) {
         add = 1;
      }
      if ( stringp( tmp ) ) {
         add = (int)call_other( this_object(), tmp, dest_other[ i ] );
      }
      if ( pointerp( tmp ) ) {
         add = (int)call_other( tmp[ 0 ], tmp[ 1 ], dest_other[ i ] );
      }
      if ( add ) {
         if ( tmp = SHORTEN[ dest_other[ i ] ] ) { // is there a short form?
            if (dest_other[i+1][ROOM_REL]) {// is the exit relative
               words += ({ "$r$-"+tmp+"$r$" });
            } else {
               words += ({ tmp });
            }
         } else {                // no short form
            if (dest_other[i+1][ROOM_REL]) { // is the exit relative?
               words += ({ "$r$-"+dest_other[ i ]+"$r$" });
            } else {
               words += ({ dest_other[i] });
            }
         }
      }
   }
   if(!sizeof(words)) {
     return " [none]";
   }
   return " ["+ implode( words, "," ) +"]";
} /* calc_short_exit_string() */

/**
 * This method returns the short exit string.  The short exit string is the
 * string used in 'brief' mode of a players look.
 * @return the short exit string
 * @see calc_short_exit_string()
 * @see query_exit_string()
 */
string query_short_exit_string() {
   string tmp;
  
   if(short_exit) {
      return this_player()->colour_event("exits", "%^GREEN%^") +
     short_exit + "%^RESET%^";
   }
   
   tmp = calc_short_exit_string();
   if (!query_property("no exit cache")) {
      short_exit = tmp;
   }
   return this_player()->colour_event("exits", "%^GREEN%^") +
     tmp + "%^RESET%^";
} /* query_short_exit_string() */

/**
 * @ignore yes
 */
string enchant_string() {
   string words;
   
   words = (string)this_object()->query_property( "octarine_mess" );
   if ( words ) {
      return words +"\n";
   }
   switch ( query_enchant() ) {
      case 0 .. 49 :
         return "";
      case 50 .. 149 :
         return "There is the residual taste of magic in this place.\n";
      case 150 .. 299 :
         return "This place has seen some use of magic.\n";
      case 300 .. 499 :
         return "A considerable amount of magic has been used here.\n";
      case 500 .. 749 :
         return "A very large quantity of magic has been manipulated here.\n";
      case 750 .. 1000 :
         return "You can feel the Dungeon Dimensions trying to push in.\n";
      case 1001 .. 1500 :
         return "Little sparks flash in from the Dungeon Dimensions.\n";
      case 1501 .. 2000 :
         return "Apparations of things with lots of tentacles seem to be "
                "on the edge of your vision.\n";
      default :
         return "So much magic has been expended here that the area is in "+
               "danger of dumping itself into the Dungeon Dimensions.\n";
   }
} /* enchant_string() */

/** @ignore yes */
string long( string word, int dark ) {
   string ret;

   if ( !long_exit ) {
      calc_long_exit();
   }
   if ( dark ) {
      if ( dark < 0 ) {
         ret = this_object()->query_dark_mess() +"\n";
      } else {
         ret = this_object()->query_bright_mess() +"\n";
      }
      if ( query_property( "location" ) == "outside" ) {
         ret += "$weather$";
      }
      if ( ( dark == 1 ) || ( dark == -1 ) ) {
         ret = "$C$"+ a_short() +".  "+ ret +
           this_player()->colour_event("exits", "%^GREEN%^") +long_exit
           +"%^RESET%^\n";
         if ( query_contents( "" ) != "" ) {
            ret += this_player()->colour_event("inventory", "") + "Some objects you can't make out are here.%^RESET%^\n";
         }
      }
   } else {
      if ( query_property( "location" ) == "outside" ) {
         ret = "$long$";
      } else {
         ret = query_long();
      }

      if(!ret) {
         ret = "Erk, this room seems to be broken.\n";
      }
      
      word = calc_extra_look();
      if ( stringp( word ) && ( word != "" ) ) {
         ret += word;
      }
      if ( this_player()->query_see_octarine() ) {
         ret += enchant_string();
      }
      if ( query_property( "location" ) == "outside" ) {
         ret += "$weather$";
      }
      ret += this_player()->colour_event("exits", "%^GREEN%^") +
        long_exit +"%^RESET%^\n"+ query_contents( "" );
   }
   if ( query_property( "no exit cache" ) )  {
      long_exit = 0;
   }
   return ret;
} /* long() */

/** @ignore yes */
string pretty_short( object thing ) {
   int dark;

   if ( thing ) {
      dark = (int)thing->check_dark( (int)this_object()->query_light() );
   }
   return ::short( dark );
} /* pretty_short() */

/**
 * This method calculates the co-ordinates of this room.  The co-ordinates
 * are based on the surrounding rooms co-ordinates, if one of those rooms
 * are loaded.
 * @see query_co_ord()
 * @see modify_exit()
 */
void calc_co_ord() {
  int i, j, k, shift, *delta, *other_co_ord;
  string other;
   
  for ( i = sizeof( dest_other ) - 2; ( i > -1 ) && !co_ord; i -= 2 ) {
    /* if destination isn't loaded, skip it */
    other = dest_other[ i + 1 ][ ROOM_DEST ];
    if ( !find_object( other ) ) {
      continue;
    }
    /* if destination has no coordinates, skip it */
    other_co_ord = (int *)other->query_co_ord();
    if ( !other_co_ord ) {
      continue;
    }

    /* if exit had a delta defined, use that */
    j = -1;
    if ( delta = dest_other[ i + 1 ][ ROOM_DELTA ] ) {
      co_ord = copy( other_co_ord );
      if (pointerp(delta)) {
        k = 3;
        while ( k-- ) {
          /*
           * it's -= to make delta here the offset from this
           * room to the destination 
           */
          co_ord[ k ] -= delta[ k ];
        }
        continue;
      } else {
        j = member_array(delta, STD_ORDERS);
      }
    }

    /* if exit isn't a direction, skip it */
    if (j == -1) {
      j = member_array( dest_other[ i ], STD_ORDERS );
      if ( j == -1 ) {
        continue;
      }
    }

    co_ord = copy( other_co_ord );
    delta = query_room_size_array() + (int *)other->query_room_size_array();
    for ( k = 0; k < 3; k++ ) {
      co_ord[ k ] += STD_ORDERS[ j + 1 ][ k ] *
        ( delta[ k ] + delta[ k + 3 ] );
    }
    if ( ( j < 16 ) && dest_other[ i + 1 ][ ROOM_GRADE ] ) {
      /* one of the lateral directions */
      switch ( j ) {
      case 0 .. 1 :
        shift = delta[ 0 ] + delta[ 3 ];
        break;
      case 2 .. 3 :
        shift = delta[ 1 ] + delta[ 4 ];
        break;
      default :
        shift = delta[ 0 ] + delta[ 1 ] + delta[ 3 ] + delta[ 4 ];
      }
      co_ord[ 2 ] -= ( dest_other[ i + 1 ][ ROOM_GRADE ] * shift ) / 100;
      }
    co_ord_calculated = 1;
  }
} /* calc_co_ord() */

/**
 * This method calculates all the exit strings to be used for this room.
 */
void calc_exits() {
   int i, j;
   string exit, word, *tmp_al;

   exits = ({ });
   for ( i = sizeof( dest_other ) - 2; i > -1; i -= 2 ) {
      exit = dest_other[ i ];
      if ( member_array( exit, exits ) == -1 ) {
         exits += ({ exit });
         word = SHORTEN[ exit ];
         if ( stringp( word ) ) {
            exits += ({ word });
         }
      }
      tmp_al = aliases;
      j = member_array( exit, tmp_al );
      while ( j != -1 ) {
         if ( j % 2 ) {
            j--;
         } else {
            word = tmp_al[ j + 1 ];
            if ( member_array( word, exits ) == -1 ) {
               exits += ({ word });
            }
         }
         tmp_al = delete( tmp_al, j, 2 );
         j = member_array( exit, tmp_al );
      }
   }
} /* calc_exits() */

/** @ignore yes */
void init() {
  object ob;
  int i;
  
  /* This is some experimental XP stuff for exploration.
   *
  if(this_player() &&
     !this_player()->query_queued_commands() &&
     ((!last_visited && uptime() > 1800 + random(3600)) ||
      (random(time() - last_visited) > 900))) {
    this_player()->adjust_xp(random(random(500)), 0);
  }
  */

  
  // Has the day/night changed and do we care?
  if(is_day != -1 && ((WEATHER_HANDLER->query_day() > 0) != is_day)) {
    is_day = (1 - is_day);
    
    // Do longs;
    if(variablelongs && strlen(variablelongs[is_day]))
      set_long(variablelongs[is_day]);
    
    // Do items.
    if(variableitems) {
      for(i=0; i<sizeof(variableitems[1-is_day]); i += 2)
        remove_item(variableitems[1-is_day][i]);
      
      for(i=0; i<sizeof(variableitems[is_day]); i += 2)
        add_item(variableitems[is_day][i], variableitems[is_day][i+1]);
    }
    
    // Do chats.
    if(variablechats) 
      room_chat(variablechats[is_day]);
  }

  if(chatter)
    chatter->check_chat();

  if(sitchanger)
    sitchanger->check_situations();

  if(!sizeof(exits))
    calc_exits();

  if(!pointerp(co_ord))
    this_object()->calc_co_ord();

  foreach (ob in hidden_objects) {
    if ( ob && objectp( ob ) ) {
      ob->init();
    } else {
      hidden_objects -= ({ 0, ob });
    }
  }

  if (userp(this_player())) {
    foreach (ob in _use_internal_objects) {
      if (ob && objectp(ob)) {
        _use_internal_objects->find_inv_match("all", this_player())->init();
      } else {
        _use_internal_objects -= ({ 0, ob });
      }
    }
  }

  if(item)
    item->init();
}

/**
 * This method returns the set of move zones for this room.  This is used
 * by npcs to see which rooms they are allowed to move into.
 * @see add_zone()
 * @see /obj/monster->add_move_zone()
 */
string *query_zones() {
  string *zones;

  zones = query_property( "room zone" );
  if ( !zones ) {
    return ({ "nowhere" });
  }
  return zones + ({ });
} /* query_zones() */

/**
 * This method adds a move zone into the current list of movement zones
 * for the room.  The move zones are used by npcs to see which rooms they
 * are allowed to move into.
 * @see set_zone()
 * @see query_zones()
 * @see /obj/monster->add_move_zone()
 */
void add_zone(string zone) {
   string *zones;

   zones = query_property( "room zone" );
   if ( !zones ) {
      zones = ({ zone });
   } else {
      zones += ({ zone });
   }
   add_property( "room zone", zones );
} /* add_zone() */

/**
 * This method adds a move zone into the current list of zones.
 * This method is depreciated, add_zone should be used instead.
 * @see add_zone()
 * @see query_zones()
 */
void set_zone( string zone ) {
   add_zone(zone);
} /* set_zone() */

/**
 * This method determines if there is an exit in the specified direction.
 * @param direc the exit to test for
 * @return 1 if it exists, 0 if it does now
 */
int query_exit( string direc ) {
  return ( member_array( direc, dest_other ) != -1 );
} /* query_exit() */

/**
 * This method adds an exit to the room.   The direction is the direction in
 * which the exit should go.  This is something like "north" or "enter
 * gate".  The destination field is where the player will go when they
 * enter the exit.  The type is a set type that sets a whole bunch of
 * defaults for the room.  The destination can be either a strong
 * or an object.
 * <p>
 * The types are controlled by /obj/handlers/room_handler.c and the current
 * types and what this all means are:
 * <dl>
 * <dd>
 * <dl>
 * <dt>road
 * <dd>Wide road.
 * <dt>path
 * <dd>Narrower path
 * <dt>door
 * <dd>And exit with a door.  Defaults to closed but not locked.
 * <dt>secret
 * <dd>A secret door.  Defaults to closed but not locked.
 * <dt>corridor
 * <dd>A corridor (bing).
 * <dt>hidden
 * <dd>A hidden exit without a door
 * </dl>
 * </dl>
 * <p>
 * The room aliases are used to expand things for exits.  However they
 * don't expand the entire exit name.  They expand it in bits.  For
 * instance, if the exit was "enter live eel", you could
 * add_alias("eel", "live eel"); and add_alias("bing", "enter"); to
 * get both of the bits of the exit.  So "bing eel", "enter eel",
 * "bing live eel" etc would work.
 * @example
 * add_exit("north", PATH + "market2", "road");
 * add_alias("eel", "live eel");
 * add_exit("enter live eel", PATH + "live_eel", "secret");
 * @example
 * object fluffy_room;
 *
 * fluffy_room = clone_object(PATH + "fluffy_room");
 * add_exit("north", fluffy_room, "road");
 * @see modify_exit()
 * @see query_dest_dir()
 * @see remove_exit()
 * @see /obj/handlers/room_handler
 */
int add_exit( string direc, mixed dest, string type ) {
   mixed *stuff;

   if ( !dest_other ) dest_other = ({ });
   if ( member_array( direc, dest_other ) != -1 ) return 0;
   if ( objectp( dest ) )
      dest = file_name( dest );
   if ( dest[ 0 .. 0 ] != "/" )
      dest = "/"+ dest;
   stuff = ({ dest }) + (mixed *)ROOM_HANDLER->query_exit_type( type, direc );
   dest_other += ({ direc, stuff });
   if ( ( stuff = (mixed *)ROOM_HANDLER->query_door_type( type, direc,
                                                         dest ) ) ) {
      door_control[ direc ] = clone_object( DOOR_OBJECT );
      door_control[ direc ]->setup_door( direc, this_object(), dest, stuff,
                                         type);
      hidden_objects += ({ door_control[ direc ] });
      door_control[ dest ] = direc;
   }
   if ( find_call_out( "calc_exits" ) == -1 )
      call_out( "calc_exits", 1 );
   long_exit = 0;
   short_exit = 0;
   return 1;
} /* add_exit() */

/**
 * This method modifies the parameters for the exit.  See the docs in
 * /doc/new/room/modify_exit for more complete information.
 */
int modify_exit( mixed direc, mixed *data ) {
   int i, j, k;
   
   if(pointerp(direc)) {
     for(k = 0; k < sizeof(direc); k++) {
       modify_exit(direc[k], data);
     }
     return 0;
   }
   if ( ( i = member_array( direc, dest_other ) ) == -1 ) {
     return 0;
   }
   for ( j = 0; j < sizeof( data ); j+= 2 ) {
     switch ( lower_case( data[ j ] ) ) {
     case "message" :
       dest_other[ i + 1 ][ ROOM_EXIT ] = data[ j + 1 ];
       break;
     case "exit mess" :
     case "exit_mess" :
       dest_other[ i + 1 ][ ROOM_EXIT ] = data[ j + 1 ];
       break;
     case "move mess" :
       dest_other[ i + 1 ][ ROOM_MESS ] = data[ j + 1 ];
       break;
     case "linker mess" :
       dest_other[ i + 1 ][ ROOM_LINK_MESS ] = data[ j + 1 ];
       break;
     case "obvious" :
       dest_other[ i + 1 ][ ROOM_OBV ] = data[ j + 1 ];
       if ( !intp( data[ j + 1 ] ) )
         add_property( "no exit cache", 1 );
       long_exit = 0;
       short_exit = 0;
       break;
     case "function" :
       dest_other[ i + 1 ][ ROOM_FUNC ] = data[ j + 1 ];
       break;
     case "size" :
       dest_other[ i + 1 ][ ROOM_SIZE ] = data[ j + 1 ];
       break;
     case "upgrade" :
       dest_other[ i + 1 ][ ROOM_GRADE ] = data[ j + 1 ];
       break;
     case "downgrade" :
       dest_other[ i + 1 ][ ROOM_GRADE ] = -data[ j + 1 ];
       break;
     case "enter" :
       dest_other[ i + 1 ][ ROOM_ENTER ] = data[ j + 1 ];
       break;
     case "enter mess" :
     case "enter_mess" :
       if ( sizeof( dest_other[ i + 1 ][ ROOM_ENTER ] ) == 2 )
         dest_other[ i + 1 ][ ROOM_ENTER ] = replace( data[ j + 1 ],
           "$F", dest_other[ i + 1 ][ ROOM_ENTER ][ 1 ] );
       else
         dest_other[ i + 1 ][ ROOM_ENTER ] = data[ j + 1 ];
       break;
     case "dest" :
       dest_other[ i + 1 ][ ROOM_DEST ] = data[ j + 1 ];
       if ( objectp( door_control[ direc ] ) ) {
         door_control[ direc ]->set_dest( data[ j + 1 ] );
         door_control[ data[ j + 1 ] ] = direc;
       }
       break;
     case "relative" :
       dest_other[ i + 1 ][ ROOM_REL ] = data[ j + 1 ];
       break;
     case "look" :
       dest_other[ i + 1][ ROOM_LOOK ] = data[ j + 1 ];
       break;
     case "look func" :
       dest_other[ i + 1][ ROOM_LOOK_FUNC ] = data[ j + 1 ];
       break;
     case "no map" :
       dest_other[ i + 1][ ROOM_NO_MAP ] = data[ j + 1 ];
       break;
     case "delta" :
       dest_other[ i + 1][ ROOM_DELTA ] = data[ j + 1 ];
       break;
     case "closed" :
       if ( objectp( door_control[ direc ] ) ) {
         data[j+1] ? door_control[ direc ]->set_closed() :
           door_control[ direc ]->set_open();
       }
       break;
     case "open" :
       if ( objectp( door_control[ direc ] ) ) {
         data[j+1] ? door_control[ direc ]->set_open() :
           door_control[ direc ]->set_closed();
       }
       break;
     case "transparent" :
       if ( objectp( door_control[ direc ] ) ) {
         data[j+1] ? door_control[ direc ]->set_transparent() :
           door_control[ direc ]->reset_transparent();
       }
       break;
     case "stuck" :
       if ( objectp( door_control[ direc ] ) ) {
         door_control[ direc ]->set_stuck( data[ j + 1 ] );
       }
       break;
     case "locked" :
       if ( objectp( door_control[ direc ] ) ) {
         if(data[j+1]) {
           door_control[ direc ]->set_closed();
           door_control[ direc ]->set_locked();
         } else
           door_control[ direc ]->set_unlocked();
       }
       break;
     case "unlocked" :
       if ( objectp( door_control[ direc ] ) ) {
         data[j+1] ? door_control[ direc ]->set_unlocked() :
           door_control[ direc ]->set_locked();
       }
       break;
     case "autolock":
       if ( objectp( door_control [direc ] ) ) {
         door_control[ direc ]->set_autolock( data[ j + 1 ] );
       }
       break;
     case "key" :
       if ( objectp( door_control[ direc ] ) ) {
         door_control[ direc ]->set_key( data[ j + 1 ] );
       }
       break;
     case "other" :
       if ( objectp( door_control[ direc ] ) ) {
         door_control[ direc ]->set_other_id( data[ j + 1 ] );
       }
       break;
     case "difficulty" :
       if ( objectp( door_control[ direc ] ) ) {
         door_control[ direc ]->set_difficulty( data[ j + 1 ] );
       }
       break;
     case "door long" :
       if ( objectp( door_control[ direc ] ) ) {
         door_control[ direc ]->set_long( data[ j + 1 ] );
       }
       break;
     case "open/close func" :
       if ( objectp( door_control[ direc ] ) ) {
         door_control[direc]->set_open_trap(data[j+1][0], data[j+1][1]);
       }
       break;
     case "lock/unlock func" :
       if ( objectp( door_control[ direc ] ) ) {
         door_control[direc]->set_lock_trap(data[j+1][0], data[j+1][1]);
       }
       break;
     case "door short" :
       if ( objectp( door_control[ direc ] ) ) {
         door_control[ direc ]->set_short( data[ j + 1 ] );
       }
       break;
     case "double doors" :
       if ( objectp( door_control[ direc ] ) ) {
         door_control[ direc ]->set_how_many( data[ j + 1 ] );
       }
       break;
     case "one way" :
       if ( objectp( door_control[ direc ] ) ) {
         door_control[ direc ]->set_one_way( data[ j + 1 ] );
       }
       break;
     case "secret" :
       if ( objectp( door_control[ direc ] ) ) {
         door_control[ direc ]->remove_hide_invis( "secret" );
         if ( data[ j + 1 ] > 0 ) {
           door_control[ direc ]->add_hide_invis( "secret", 0,
                                                  data[ j + 1 ], 0 );
         }
       }
       break;
     case "undoor" :
       if ( objectp( door_control[ direc ] ) ) {
         door_control[ direc ]->go_away();
         hidden_objects -= ({ door_control[ direc ] });
         door_control = m_delete( door_control, direc );
         door_control = m_delete( door_control,
                                  dest_other[ i + 1 ][ ROOM_DEST ] );
         /* Hope that something takes care of the other side. */
       }
       break;
     }
   }
   return 1;
} /* modify_exit() */

/**
 * This method removes the specified exit from the room.
 * @see add_exit()
 * @see modify_exit()
 */
int remove_exit( string direc ) {
  int i;

  if ( !dest_other ) {
    dest_other = ({ });
    return 0;
  }
  i = member_array( direc, dest_other );
  if ( i == -1 )
    return 0;
  if ( door_control[ direc ] ) {
    door_control[ direc ]->dest_me();
    hidden_objects -= ({ door_control[ direc ] });
    door_control = m_delete( door_control, direc );
    door_control = m_delete( door_control, dest_other[ i + 1 ][ ROOM_DEST ] );
  }
  dest_other = delete( dest_other, i, 2 );
  if ( find_call_out( "calc_exits" ) == -1 )
    call_out( "calc_exits", 1 );
   long_exit = 0;
   short_exit = 0;
  return 1;
} /* remove_exit() */

/**
 * This method checks to see if the door is open.
 * @param direc the direction of the door
 * @return -1 on an error, 0 for closed, 1 for open
 * @see modify_exit()
 */
int query_door_open( string direc ) {
  if ( !objectp( door_control[ direc ] ) ) {
    return -1;
  }
  return (int)door_control[ direc ]->query_open();
} /* query_door_open() */

/**
 * This method checks to see if the exit is a relative one.
 * @param direc the direction to check
 * @see modify_exit()
 */
int query_relative( string direc ) {
   int i;

   i = member_array( direc, dest_other );
   if ( i == -1 ) {
      return 0;
   }
   return dest_other[ i + 1 ][ ROOM_REL ];
} /* query_relative() */

string query_look( string direc ) {
   int i;

   i = member_array( direc, dest_other );
   if ( i == -1 )
      return 0;
   if ( !dest_other[ i + 1 ] )
      return 0;
   return (string)evaluate(dest_other[ i + 1 ][ ROOM_LOOK ]);
} /* query_look() */

mixed *query_look_func( string direc ) {
  int i;
  if ( ( i = member_array( direc, dest_other ) ) == -1 ) return 0;
  if( !dest_other[ i + 1 ] ) return 0;
  return dest_other[ i + 1 ][ ROOM_LOOK_FUNC ];
}

/**
 * This method returns the size of the exit.  This is used to check to make
 * sure that people can enter it.
 * @param direc the direction of the exit to check
 * @return the size of the exit
 * @see modify_exit()
 */
int query_size( string direc ) {
  int i;
  if ( ( i = member_array( direc, dest_other ) ) == -1 ) return 0;
  if ( stringp( dest_other[ i + 1 ][ ROOM_SIZE ] ) )
    return (int)call_other( this_object(), dest_other[ i + 1 ][ ROOM_SIZE ] );
  if ( pointerp( dest_other[ i + 1 ][ ROOM_SIZE ] ) )
    return (int)call_other( dest_other[ i + 1 ][ ROOM_SIZE ][ 0 ],
        dest_other[ i + 1 ][ ROOM_SIZE ][ 1 ] );
  return dest_other[ i + 1 ][ ROOM_SIZE ];
} /* query_size() */
 
/** @ignore yes */
void event_magic( object channel, int amount, object caster ) {
   add_enchant( amount / 5 );
} /* event_magic() */

/** @ignore yes */
void event_theft( object command_ob, object thief, object victim,
                  object *stolen ) {
  log_file( "THEFT", "%s: %s stole %s from %s in %s\n",
            ctime( time() ), (string)thief->query_short(),
            implode( (string *)stolen->query_short(), ", " ),
            (string)victim->query_short(), file_name() );
  
  if ( stringp( theft_handler )) {
    if( theft_handler != "none" )
      theft_handler->handle_theft( this_object(), command_ob, thief,
                                   victim, stolen );
  } else
    "/obj/handlers/theft_handler"->handle_theft( this_object(), command_ob,
                                                 thief, victim, stolen );
} /* event_theft() */

/** @ignore yes */
void event_exit(object ob, string message, object to) {
    if(interactive(ob))
    last_visited = time();
} /* event_exit() */

/** @ignore yes */
int query_last_visited() { return last_visited; }

/**
 * This method adds an item description to a room.  This allows you to
 * set up objects which do not as such exist, but can be looked at for
 * instance.  There should be a lot of these in rooms.  The name of
 * the item can be multiple word, and the plural for it is
 * automagicaly added, unless the no_plural flag is set.  If the name
 * is an array all of the elements in the array respond to the
 * description.
 * <p>
 * If the desc is set to an array, you can use this for handling
 * things like read messages and so on too.  Every second element in
 * the array is the description/text to be printed and the other
 * element is the command upon which the text should be printed.  The
 * special command 'long' is used to set the long description.
 * <p>
 * The special type 'position' is used to allow people to use that
 * item to do positions on, like stand, sit, lie etc.
 * <p>
 * This method also allows you to setup add_command patterns.  If the
 * name after the verb is just a string, then the string will be printed
 * when that verb is used.  If it is just a function pointer then the
 * function will be evaluated and the return result printed.  If it
 * is an array, then the first element must be a function pointer and
 * the second optional element is the pattern to use for that method.
 * Multiple patterns and functions may be specified.
 * @param shorts the short description of the item
 * @param desc the description of the item
 * @param no_plural do not automaticaly add a plural for the item
 * @return 1 if successfully added, 0 if not
 * @example
 * add_item("green pot plant", "It is a nasty green pot plant lurking by "
 *                             "the door.\n");
 * @example
 * add_item(({ "telephone", "red phone" }),
 *          "Sitting in the corner is the red phone, it is staring unhappily "
 *          "into space thinking of cupcakes and better times.\n");
 * @example
 * add_item("small book", ({ "long", "A small red book with dots on the
 *                                   "cover.\n",
 *                           "read", "It says 'Rabbit!' in big letters.\n" }) );
 * @example
 * add_item("green leather couch",
 *          ({ "long", "The green leather couch is wonderful , so comfy!  "
 *                     " So... Comfy!\n"m
 *             "position", "the green leather couch" }) );
 * @example
 * add_item("rotating hologram", (: query_current_hologram_string() :));
 * @example
 * add_item("glue stick",
 *          ({ "long", "The glue stick looks sticky, like you could slime "
 *                     "something with it.\n",
 *             "slime", ({ (: do_slime :),
 *                         "<indirect:living> with <direct:object>" }) }) );
 * @see query_item()
 * @see remove_item()
 * @see modify_item()
 */
varargs int add_item( mixed shorts, mixed desc, int no_plural ) {
  if (!desc) {
     // A 0 description is a definate no no.
     printf("Error!  In %O add_item(%O, 0), not added.\n", file_name(),
                                                           shorts);
     return 0;
  }

  if ( !item ) {
     item = clone_object( ITEM_OBJECT );
  }
  item->setup_item( shorts, desc, no_plural );
  return 1;
} /* add_item() */

/**
 * This method will attempt to remove the item defined by the given string.
 * This will remove everything associated with that item, verbs, patterns,
 * everything.
 * @param word the name of the item to remove
 * @return 1 if successful, 0 on a failure
 * @example
 * add_item("frog", "Cute, green and sitting on a lilly pad.  Yes!\n");
 * ...
 * remove_item("frog");
 * @example
 * add_item(({ "big bad chicken", "clucker" }),
 *          "The big bad chicken sits and stares at you.\n");
 * ...
 * remove_item("big bad chicken");
 * @see add_item()
 * @see query_item()
 */
int remove_item( string word ) {
  if ( !item ) {
    return 1;
  }
  return (int)item->remove_item( word );
} /* remove_item() */

/**
 * This method will modify certain bits of the specified item.  This will
 * change only the bits of the pattern that are specified.  If you wish to
 * remove elements a better method would be to remove the item and
 * then readd it.  The format of the new_desc array is the same as in the
 * add_item code.
 * @param word the name of the item to change
 * @param new_desc the bits of the item to change
 * @see remove_item()
 * @see add_item()
 */
int modify_item( string word, mixed new_desc ) {
  if ( !item ) {
    return 0;
  }
  return (int)item->modify_item( word, new_desc );
} /* modify_item() */

/** @ignore yes */
void add_effect( string eff, mixed arg ) {
   effects = clone_object( "/std/shadows/misc/effects" );
   effects->setup_shadow( this_object() );
   effects->add_effect( eff, arg );
} /* add_effect() */

/**
 * This method sets up a linkage between the current room and othert
 * rooms.  The linkage broadcasts things like says and enter/exit
 * messages between the rooms.
 * <P>
 * The the dynamic preposition is used when someone enters/exits
 * the room, the static preposition is used when someone says something
 * in the room.  The dynamic proposition defaults to "into" and the
 * static preposition defaults to "in".
 * @param rooms the rooms to link together
 * @param d_prep the dynamic preposition
 * @param s_prep the static preposition
 * @param r_name the name of the room/area
 * @example
 * set_linker( ({ PATH + "room1", PATH + "room2", }),
 *             "into", "in", "fluffy square");
 */
varargs int set_linker( string *rooms, string d_prep, string s_prep,
    string r_name ) {
  if ( linker ) {
    return 0;
  }
  linker = clone_object( LINKER_OBJECT );
  linker->setup_shadow( this_object(), rooms, d_prep, s_prep, r_name );
  return 1;
} /* set_linker() */

int set_terrain( string terrain_name ) {
   if ( terrain ) {
      return 0;
   }
   terrain = clone_object( TERRAIN_OBJECT );
   terrain->setup_shadow( this_object(), terrain_name );
   set_not_replaceable(1);
   return 1;
} /* set_terrain() */

void set_wall( mixed *args ) {
   if ( !wall ) {
      wall = clone_object( WALL_OBJECT );
      wall->setup_shadow( this_object() );
   }
   wall->set_wall( args );
} /* set_wall() */

/**
 * This method sets the default position for the room.  Se the set
 * default position in the living code for a more complete
 * example of this.
 * @param pos the default position
 * @see /ostd/living/living->set_default_position()
 */
void set_default_position(mixed stuff) {
  add_property(DEFAULT_POSITION_PROPERTY, stuff);
} /* set_default_position() */

/**
 * This method returns the current default position asigned to this
 * room.
 * @return the current default position
 */
mixed query_default_position() {
   return query_property(DEFAULT_POSITION_PROPERTY);
} /* query_default_position() */

/**
 * This method tells us if the passed i nposition is
 * allowed in this type of room.
 * @param poss the position to check
 */
int is_allowed_position(string poss) {
  switch (poss) {
    case SITTING :
    case STANDING :
    case KNEELING :
    case LYING :
    case MEDITATING :
    case CROUCHING :
      return 1;
    default :
      return 0;
  }
} /* is_allowed_position() */

/** @ignore yes */
void dest_me() {
   int in_armoury, in_void;
   object thing, *things;

   if ( file_name( this_object() ) == ARMOURY )
      in_armoury = 1;
   if ( file_name( this_object() ) == ROOM_VOID )
      in_void = 1;

   /* If this is not the void, remove contents to /room/rubbish for
      recycling. Move players to the void */
   if ( !in_void ) {
      things = all_inventory( this_object() );
      foreach( thing in things ) {
         if ( userp( thing ) ) {
            thing->move_with_look( ROOM_VOID, "$N fall$s into the void." );
            continue;
         }
         if(thing->cleaning_room())
           continue;
         
         thing->move("/room/rubbish");
      }
   }
   if ( chatter )
      chatter->dest_me();
   if ( sitchanger )
      sitchanger->dest_me();
   if ( effects )
      effects->destruct_shadow( effects );
   if ( linker )
      linker->destruct_shadow( linker );
   if ( terrain )
      terrain->destruct_shadow( terrain );
   if(wall)
     wall->destruct_shadow(wall);
   if ( item )
      item->dest_me();
    
   if(door_control)
     foreach(thing in keys(door_control))
       if(objectp(thing))
         catch(thing->dest_me());

   if ( sizeof( hidden_objects ) )
      foreach( thing in hidden_objects ) {
         // Don't dest thing if it's hidden in multiple rooms
         if ( objectp( thing ) && ( thing->multiple_hidden() == 0 ) )
           catch( thing->dest_me() );
      }
   destruct( this_object() );
} /* dest_me() */

/**
 * This method sets the flag that enables or disables the room being
 * cleaned up.  If they flag is set to 1, then room is never cleaned up.
 * @param flag the room being cleaned up flag
 * @see query_keep_room_loaded()
 */
void set_keep_room_loaded(int flag) {
   add_property(ROOM_KEEP_PROP, flag);
} /* set_keep_room_loaded() */

/**
 * This method returns the status of the keep room loaded flag.  If they
 * flag is non-0 then the room with not be unloaded.
 * @return the status of the keep room loaded flag
 */
int query_keep_room_loaded() {
   return query_property(ROOM_KEEP_PROP);
} /* query_keep_room_loaded() */
 
/** @ignore yes */
int clean_up( int parent ) {
  if (parent) {
    return 0;
  }
  if (query_keep_room_loaded()) {
      return 0;
  }
  call_out("real_clean", 30 + random(120));
  return 1;
} /* clean_up() */

/** @ignore yes */
int real_clean() {
   object thing;

   /*
    * Don't clean up the room if:
    * there's a player in it, there's a unique npc in it and it's been visited
    * by a player in the last hour, it's a slave room or there's a corpse in
    * it.
    */
   foreach ( thing in all_inventory( this_object() ) ) {
     if ( thing->query_property( "player" ) ||
          (thing->query_property( "unique" ) &&
           last_visited > time() - 3600) ||
          thing->query_slave() ||
          thing->query_name() == "corpse") {
         return 0;
      }
   }
   dest_me();
   return 1;
} /* real_clean() */

/** 
 * This method returns all the matchable objects in the room.  This is used
 * by find_match to determine the group of objects to select from.
 * @param words the words to match on
 * @param looker the person doing the pmacthing
 * @return the array of objects to match on
 */
object *find_inv_match( string words, object looker ) {
   object *things;

   things = all_inventory( this_object() );
   if ( pointerp( hidden_objects ) ) {
      things += hidden_objects;
   }

   //
   // Only do these extra checks for players.
   //
   if (looker && userp(looker)) {
      /* Chekced to this filter thing to speed it up. */
      things = filter(things, (: $1 && $1->short(0) &&
                              (!$2 || $1->query_visible($2)) :), looker);
   }

   if ( item ) {
      things += ({ item });
   }
   return things;
} /* find_inv_match() */

/**
 * This method adds a sign into the room.  Any of these elements can
 * be set to 0, except the long description.
 * @param sign_long the long description of the sign
 * @param sign_read_mess the readable message on the sign
 * @param sign_short the short description of the sign
 * @param sign_name the name of the sign
 * @param sign_language the language the sign is written in
 * @return the object for the sign
 */
varargs object add_sign( string sign_long, mixed sign_read_mess, string
    sign_short, mixed sign_name, string sign_language ) {
  object sign;
  string* bits;

  sign = clone_object( "/std/object" );
  if ( !sign_name ) {
     sign_name = "sign";
  }
  if (pointerp(sign_name)) {
    bits = explode(sign_name[0], " ");
    sign->set_name( bits[<1] );
    sign->add_adjective( bits[0..<2]);
    sign->add_alias(sign_name[1..]);
  } else {
    bits = explode(sign_name, " ");
    sign->set_name( bits[<1] );
    sign->add_adjective( bits[0..<2]);
  }
  sign->set_long( sign_long );
  if ( !sign_language ) sign_language = "common";
  sign->set_read_mess( sign_read_mess, sign_language );
  sign->reset_get();
  if ( sign_short && ( sign_short != "" ) ) {
    sign->set_short( sign_short );
    sign->set_main_plural( pluralize( sign_short ) );
    sign->move( this_object() );
    sign->add_property("there", "here");
  } else hidden_objects += ({ sign });
  return sign;
} /* add_sign() */

/** @ignore yes */
void tell_door( string direc, string message, object thing ) {
   if ( objectp( door_control[ direc ] ) )
      door_control[ direc ]->tell_door( message, thing );
} /* tell_door() */

/** @ignore yes */
varargs mixed call_door( string direc, string func, mixed arg1, mixed arg2,
      mixed arg3 ) {
   if ( objectp( door_control[ direc ] ) )
      return (mixed)call_other( door_control[ direc ], func, arg1, arg2,
            arg3 );
} /* call_door() */

/**
 * This method determines if the specified exit is a door or not.
 * @param dest the destination to check for being a door
 * @see query_exit()
 * @see add_exit()
 */
string query_door( mixed dest ) {
   int i;
   string direc;
   mixed bing;

   if ( objectp( dest ) ) {
      dest = file_name( dest );
   }
   if ( !stringp( dest ) ) {
      return 0;
   }
   if ( bing = door_control[ dest ] ) {
      if ( !objectp( bing ) ) {
         direc = bing;
      }
   }
   if ( !direc ) {
      return 0;
   }
   bing = door_control[ direc ];
   if ( objectp( bing ) ) {
      return direc;
   }
   bing = clone_object( DOOR_OBJECT );
   i = member_array( direc, dest_other );
   bing->setup_door( direc, this_object(), dest, dest_other[ i + 1 ] );
   hidden_objects += ({ bing });
   door_control[ direc ] = bing;
   return direc;
} /* query_door() */

/**
 * This method stops all the room chats for the room.  It also removes
 * all the room chats, so if you want to have any more you must
 * add them again.
 * @see room_chat()
 */
void stop_room_chats() {
   if ( chatter ) {
      chatter->dest_me();
   }
} /* stop_room_chats() */

/**
 * Allows the chat interval to be changed.
 * @param min minimum interval between chats (seconds)
 * @param max maximum interval between chats (seconds)
 */
void set_chat_min_max( int min,int  max ) {
  if (chatter) chatter->set_chat_min_max(min,max);
}

/**
 * Adds more chats to the existing set of room chats
 * managed by this chatter object.
 * @param new_chats an array of new chat strings
 * @see remove_room_chats
 * @see query_room_chats
 * @see /std/room/basic/chatter
 */
void add_room_chats( string *new_chats ) {
  if (chatter) chatter->add_room_chats( new_chats );
} /* add_room_chats() */

/**
 * Removes chats from the set of room chats
 * managed by this chatter object.  If there are no chats
 * left the chatter is destructed.
 * @param dead_chats an array of chat strings to remove
 * @see add_room_chats
 * @see query_room_chats
 * @see /std/room/basic/chatter
 */
void remove_room_chats( string *dead_chats ) {
 if (chatter) chatter->remove_room_chats( dead_chats );
} /* remove_room_chats() */

/**
 * Returns the set of room chats
 * managed by the chatter object.  
 * @return pointer to the mixed array of chat args
 * @example
 *  ({ 120, 240, ({ "A frog gimbles the curtains.",
 *                  "A truly revolting smell drifts insidiously "
 *                  "from the rug." }) })
 * @see add_room_chats
 * @see remove_room_chats
 * @see room_chat
 * @see /std/room/basic/chatter
 */
mixed *query_room_chats() { 
  if (chatter) return chatter->query_room_chats();
  return 0;
} /* query_room_chats() */

/**
 * This method sets up the room chats.
 * Room chats are strings which are printed at (semi) random intervals
 * in rooms.  They are used to add atmosphere to a room. A chat will
 * be picked at random from the array of chats with a frequency
 * controlled by the times min and max. ie. one will be picked every n
 * seconds where is varies between min and max seconds. Please don't
 * make the values for min and max too small or the messages just
 * become annoying!
 * <p>
 * The argument to the room_chat method is an array of the format:<br>
 * ({ int min, int max, ({ string *chats }) }).  In place of a chat
 * string you may use "#function_name" where function_name is a
 * function that exists on the room object.
 * <p>
 * Repeated calls to this function overwrite the chats for
 * the default chatter.
 * @param args the room chat arguments
 * @param chatobj chatter object in case the default offends you.
 *                This argument may be omitted in which case you get 
 *                /std/room/basic/chatter.c
 * @example
 * room_chat(({ 120, 240, ({ "A string frog wanders past.",
 *                           "#make_soggy_bread",
 *                           "A trully revolting smell drifts insidiously "
 *                                "from the bakery." }) }) );
 * @see stop_room_chat()
 * @see add_room_chats()
 * @see remove_room_chats()
 * @see set_chat_min_max()
 */
varargs void room_chat( mixed *args, object chatobj ) {
   if ( !pointerp( args[ 2 ] ) ) {
      write( "Error: second argument of room_chat args is not an array.\n" );
      return;
   }
  if ( chatter ) {
    chatter->setup_chatter( this_object(), args );
    return;
  }
  if (objectp(chatobj)) chatter = chatobj;
  else chatter = clone_object( CHATTER_OBJECT );
  chatter->setup_chatter( this_object(), args );
} /* room_chat() */

/**
 * Set a situation changer (in place of the default).
 * If there is no argument you get the default:
 * /std/room/basic/situation_changer.
 * You call this before any other situation related functions.
 * If you create your own changer it should inherit one of
 * /std/room/basic/situation_changer or
 * /std/room/basic/multiroom_situation_changer or
 * otherwsie provide the functionality of those objects.
 * @param changer optional parameter specifying either a path for
 * the changer object or an existing object to use.
 * @see add_situation
 * @see start_situation
 * @see automate_situation
 * @see change_situation
 * @example
 * If you have a special changer object used for more than one room
 * then in setup for those rooms you should have:
 * set_situation_changer(load_object("/w/me/mychanger"));
 * Where /w/me/mychanger inherits 
 * /std/room/basic/multiroom_situation_changer
 */
varargs object set_situation_changer( mixed changer ) {
  if (stringp(changer)) {
    sitchanger = clone_object( changer );  
  } else if (objectp(changer)) {
    sitchanger = changer; 
  } else {
    sitchanger = clone_object( SITUATION_CHANGER_OBJECT );
  }
  return (sitchanger = sitchanger->set_room( this_object() ));
} /* set_situation_changer() */

/**
 * Adds a situation to the room.  These situations can be
 * invoked manually with start_situation or automatically via
 * automate_situation.
 * @param label string or number labelling the situation
 * @param sit a structure (class) containing all the bits
 * of the situation you want to add.  It should be a
 * variable of class situation.  You should include
 * situations.h where this class is defined.
 * Every part is optional.
 * eg. 
 * start_func  function to be called at start of situation 
 *             that might be used to load NPC's or anything
 *             beyond a message.
 * 
 *             The start function is passed the label, 
 *             a do_start_mess flag and the room object.  
 *             If the flag is 1 the situation is starting 
 *             rather than being reloaded.  Thus if 
 *             do_start_mess is 0 then you should avoid
 *             any obvious start messages and make it look
 *             like the situation is already underway.
 *
 * end_func    function to be called an the end of a situation.  
 *             The end function is only
 *             passed the label and the room object.
 *
 * start_mess  message told to the room at start of situation
 *
 * end_mess    message told to the room at end of situation
 *
 * extra_look  extra look string appended to rooms long 
 *             during the situation
 * chat_rate   an array of 2 numbers giving the minimum and
 *             maximum delay between chats.  If this is set
 *             then the chats are not merged with the
 *             existing chats but added independently with
 *             their own chat rates as given.
 *
 * chats       an array of chat strings to be active 
 *             during the situation 
 *
 * add_items   a mixed array of ({ item, item description }) 
 *             pairs to be active during the situation
 * 
 * random_words  sets of words to insert into text to replace 
 *               the special character #n where n is a number.
 *             The form of the array is ({  #1array, #2array, ... })
 *             where #1array = ({ "#1word1","#1word2",... }) etc.
 *             For the duration of the situation one of the strings
 *             in #1array is used to replace all instances of #1
 *             in the extra_look, start_mess, end_mess, chats
 *             and key and the long description part of the add_items.
 *             In a situation compounded of many situations
 *             the same random seed is used for choosing all #1's
 *             for each individual situation for the duration, 
 *             and a different seed for all #2's etc. 
 *
 * @see start_situation
 * @see end_situation
 * @see automate_situation
 * @see change_situation
 * @see add_item
 * @see room_chat
 * @see add_extra_look
 * @see set_situation_changer
 * @see make_situation_seed
 * @see /include/situation.h
 * @see goto learning  search  situation  for working examples
 * @example
 * #include <situations.h>
 *
 * class situation frogs;
 * frogs = new(class situation, 
 *     start_mess: "Water seeps out of the ground to form puddles.",
 *     extra_look: "There are large puddles on the ground here.",
 *     chat_rate: ({ 120,180 }),
 *     chats: ({"A hidden frog croaks quietly.",
 *              "There is a blooping sound." }),
 *     add_items:({ ({"puddle", "The puddles are dark and murky.  " 
 *                    "They will probably dry up given time." }) }) );
 * add_situation( "frogs", frogs );
 *
 * @example
 * add_situation( "ship", new(class situation, 
 *      start_mess: "A #1 ship hoves into view.",
 *      extra_look: "There is a #1 ship forging up the river.",
 *      chats: ({"The #1 ship's sails flap in the breeze.",
 *               "Shouts of sailors carry over to you from the #1 ship." }),
 *      add_items: ({ ({"ship", "The #1 ship, the \"#2\" is a small "
 *                    "sailing vessel that transports cargo up and "
 *                    "down the river."}) }),
 *      random_words: ({ ({ "old","waterlogged","heavily laden" }),
 *                       ({ "Jemima", "Old Sea Dog", "Randy Mermaid" }) })
 *      ) );
 * When the situation is started a random choice (eg. "old") replaces #1 
 * and a name (eg. "Jemima") replaces #2 in the text strings for
 * the duration.  
 * 
 * @example
 * add_situation( "frogs", new(class situation, 
 *      start_mess: "Water seeps out of the ground to form puddles.",
 *      extra_look: "There are large puddles on the ground here.",
 *      chats: ({"A hidden frog croaks quietly.",
 *               "There is a blooping sound." }),
 *      add_items: ({ ({"puddle", "The puddles are dark and murky.  " 
 *                      "They will probably dry up given time." }) }) ));
 * @example
 * This is an empty situation, useful for making pauses in the action.
 * add_situation( "pause", new(class situation) );
 */
void add_situation( mixed label, class situation sit ) {
  if (!sitchanger) {
    sitchanger = clone_object( SITUATION_CHANGER_OBJECT );
    sitchanger->set_room( this_object() );
  }
  sitchanger->add_situation( label, sit );
} /* add_situation() */

/**
 * Makes a seed value for the random part of when 
 * situations turn on and off.  The two ints should be
 * constant for a given room -- eg. the coordinates.
 * If this function is not called the seed is 
 * generated from the file_name of the object.
 * For this reason, rooms that are clones will produce
 * erratic results unless this function is called.
 * @param xval integer to use to make a seed (eg. x coordinate)
 * @param yval integer to use to make a seed (eg. y coordinate)
 */
void make_situation_seed(int xval, int yval) {
  if (sitchanger) sitchanger->set_seed(xval,yval);
} /* make_situation_seed() */

/**
 * Starts a situation previously added to the room.  These situations can be
 * invoked manually with start_situation or automatically via
 * automate_situation.  The call is passed to the situation
 * changer object.  If there isn't one nothing happens. 
 * @param label label for the situation as passed to add_situation
 * @param do_start_mess 0 to supress the start_mess string
 *        This is to fake it that a situation has been 
 *        going for a while when really you just loaded it.
 * @see add_situation
 * @see end_situation
 * @see automate_situation
 * @see change_situation
 */
void start_situation(int label, int do_start_mess) {
  if (sitchanger) 
    sitchanger->start_situation( label, do_start_mess );
} /* start_situation */

/**
 * Ends a situation previously added and started on the room.  
 * These situations can be invoked manually with start_situation 
 * or automatically via automate_situation. 
 * @param label label for the situation
 * @see add_situation
 * @see start_situation
 * @see automate_situation
 * @see change_situation
 */
void end_situation(mixed label) {
  if (sitchanger) sitchanger->end_situation( label );
} /* end_situation() */

/**
 * Starts one or more situations that will end after a
 * specified duration.  You can use an array and make
 * further situations commence when others end.
 * @param label (mixed) label of the situation to start up.  
 * If you pass an array such as ({ "frog1", "frog2" }) for the 
 * label then that set of situations are started one at
 * a time and the total duration is split evenly between them.
 * Label is usually an integer or a string or an array of
 * integers and/or strings.
 * If the string is a list of labels
 * separated by , then multiple situations
 * are started using those labels.
 * @param duration (int) total time (seconds) the overall situation 
 * should last.  You can put an array of durations -- one for each
 * situation if the label lists more than one situation and then
 * the overall time is the sum of the numbers.
 * -1 is a special duration.  It means that the labelled situation goes on
 * forever (and thus nothing after it in the array will ever go).
 * @param words is a list of replacements for #n in the text OR
 * a random number seed to use to choose words from random_words.
 * eg. ({ "#1", "frog", "#2", "honey" }) or 22
 *
 * @return handle useful for halting the changes later.  It is typically
 * a small positive integer.
 * @see shutdown_situation
 * @see add_situation
 * @see automate_situation
 * @see goto learning  search  situation  for working examples
 * @example
 * handle=change_situation( ({ "sew1","sew2" }), ({ 60,60 }) );
 * 
 * if (over) shutdown_situation( handle, ({ "sew1","sew2" }) );
 * @example
 * change_situation( ({ "background,sew1","background,sew2" }), 120 );
 * @example
 * change_situation( ({ "building_falling","rubble" }), ({ 120, -1 }) );
 * @example
 * add_situation( "boat1", 
 *   new(class situation,
 *     start_mess: "A little fishing boat comes up to the pier.  "
 *        "It has the name \"#1\" painted on the side.\n"
 *        "A fisherman jumps off the boat and ties its painter to a post.",
 *     chats: ({"The little boat bobs up and down next to the pier.",
 *              "A fisherman hops off the little boat." }),
 *     chat_rate: ({ 20, 30 }),
 *     extra_look: "There is a little boat here.",
 *     add_items: ({ ({ ({ "#1","little boat" }), 
 *       "There is little fishing boat tied up at the pier here.  "
 *       "The name \"#1\" is painted on the side."   }) }),
 *     end_mess: "The fishermen get back on board and "
 *        "the little boat moves on.",
 *     random_words: ({ ({ "Honey Toad", "Piker", "Bing" }) })
 *   )
 * );
 * 
 * change_situation( "boat1", 120, ({ "#1","Floating Egg" }) );
 */
varargs mixed change_situation( mixed label, mixed duration, mixed words ) {
  if (sitchanger) 
    return sitchanger->change_situation(label,duration,words,0);

  return 0;
} /* change_situation() */

/**
 * Automate starting and ending of a situation.
 * These situations can be invoked manually with start_situation.
 * The automated starting and ending is unaffected by the room 
 * unloading.  When the room reloads the situation will be 
 * restarted unless its duration is up.
 * You must include the file situations.h for the definitions
 * of the when masks.  The random seed needs to be set
 * consistently for the situations.  This is probably ok
 * unless your rooms are clones (see make_situation_seed). 
 * @param label (mixed) label of the situation to start 
 *  up.  If you pass an array such as ({ "frog1", "frog2" }) for the 
 * label then that set of situations are started one at
 * a time and the total duration is split evenly between them.
 * Label is usually an integer or a string or an array of
 * integers and/or strings.
 * If the string is a list of labels
 * separated by , then multiple situations
 * are started using those labels.
 * @param duration (int) total time (seconds) the overall situation 
 * should last.  You can put an array of durations -- one for each
 * situation if the label lists more than one situation and then
 * the overall time is the sum of the numbers.
 * -1 is a special duration.  It means that the situaton given that
 * duration is not part of the set but a special background or
 * default situation that occurs all the time except when
 * this automated situation is going.
 * @param when (int) a time of the day mask.  This limits when
 * the situation is allowed to occur.  The mask is composed of
 * the allowed hours in AM time ( 24 hours clock, (1<<hour) and 
 * combined with | (OR) ).   You can just use these
 * predefined masks and ignore how it works:
 *  WHEN_WEE_HOURS, WHEN_EARLY_MORNING, WHEN_LATE_MORNING, WHEN_AFTERNOON
 *  WHEN_EVENING, WHEN_LATENIGHT, WHEN_MIDDAY, WHEN_MORNING, 
 *  WHEN_EARLY_MORNING, WHEN_LATE_MORNING, WHEN_NIGHT, WHEN_DAY
 *  WHEN_ANY_TIME    
 * The masks are defined in /include/situations.h.
 * @param chance  (int) chance in 1000 of starting the situation
 *  This is tested every duration seconds.
 * @param category (optional) if you specify a cateory for the situation
 *                 then no situations with the same category will overlap.
 *                 category would usually be a string eg. "boats".
 * @see add_situation
 * @see start_situation
 * @see end_situation
 * @see situations.h
 * @see set_situation_changer
 * @see make_situation_seed
 * @see goto learning  search  situation  for working examples
 * @example
 * #include <situations.h>
 *
 *  automate_situation( "frog", 300, WHEN_ANY_TIME, 200 );
 *
 * This will automatically start the situation labelled "frog" 
 * at a random time that is any time of the day with a 200/1000
 * chance of it starting per 300 seconds.  It will last for
 * 300 seconds (5 minutes).  
 * @example
 *  automate_situation( ({"frog1,pond","frog2,pond"}), 240, 
 *                        WHEN_EVENING|WHEN_NIGHT, 300 );
 *
 * This will automatically start a situation that is a combination 
 * of "frog1" and "pond" followed by "frog2" and "pond".  They start
 * at a random time but only in the evening or at night.  
 * There will be a 300/1000 chance of 
 * it starting per 240 seconds.  Both the "frog1" and "frog2" 
 * situations will get half the total time (as there are two),  
 * 120 seconds each, for a total duration of 240 seconds (4 minutes).
 * @example
 *  automate_situation( ({"frog1,pond","frog2,pond"}), ({ 80,160 }), 
 *                        WHEN_EVENING|WHEN_NIGHT, 300 );
 * Same as previous example except the durations of the individual
 * parts are set: "frog1,pond" for 80 seconds followed by "frog2,pond"
 * for 160 seconds.  The total time is 80+160.
 */
varargs void automate_situation( mixed label, mixed duration, mixed when, 
    mixed chance, mixed category ) {
  if (sitchanger) 
    sitchanger->automate_situation(label,duration,when,chance,category);
} /* automate_situation() */

/**
 * Shuts down all current and pending situations.  It also turns off the
 * automated situation manager so no more are added.  It does not
 * destruct this object so all the add_situations are still loaded
 * and make be recommenced with automate_situation.  dest_me is
 * the appropriate call to permanently remove all situations.  The
 * call is passed to the situation changer object.  If none exists
 * then nothing happens.  The situation changer is created when
 * an add_situation call is performed. 
 * @see add_situation
 * @see automate_situation
 * @see change_situation
 */
void shutdown_all_situations() {
  if (sitchanger) sitchanger->shutdown_all_situations();
} /* shutdown_all_situations() */

/**
 * Shuts down a situation or set of situations initiated with
 * change_situation based on the call_out handle
 * returned by the call to change_situation.
 * @param callout call_out handle.  If 0 then the last
 * known handle is used.
 * @param label label or array of labels of situations to clean 
 * up with end_situation
 * @param the_room the room
 * @see automate_situation
 * @see change_situation
 */
void shutdown_situation(int call, mixed label) {
  if (sitchanger) sitchanger->shutdown_situation(call,label);
} /* shutdown_situation() */

/**
 * This method checks to see if the program is replaceable.
 * @return 1 if the program is not replaceable
 * @see set_not_replaceable()
 */
int query_not_replaceable() {
   return query_property(ROOM_NOT_REPLACE_PROGRAM_PROP);
} /* query_not_replaceable() */

/**
 * This method sets a property to make the program replaceable.  A program
 * will only be replaced if there is only a setup() function in the room.
 * A reset() or a create() will stop the room from being replace and in
 * fact any other function existing in there will stop it from being
 * replaced as well.
 * @pram replace 1 to make the room not replacable
 * @see query_not_replaceable()
 */
void set_not_replaceable(int replace) {
   add_property(ROOM_NOT_REPLACE_PROGRAM_PROP, replace);
} /* set_not_replaceable() */

/** @ignore yes */
mixed stats() {
   int i;
   mixed *stuff;
   stuff = ({ });
   for ( i = sizeof( dest_other ) - 2; i > -1; i -= 2 )
      stuff += ({
         ({ dest_other[ i ], dest_other[ i + 1 ][ ROOM_DEST ] })
      });
   if ( co_ord )
      stuff += ({
         ({ "co-ord x", co_ord[ 0 ] }),
         ({ "co-ord y", co_ord[ 1 ] }),
         ({ "co-ord z", co_ord[ 2 ] })
      });
   return light::stats() + property::stats() + stuff + ({
      ({ "short", short( 0 ) }),
      ({ "enchantment", query_enchant() }),
      ({ "background enchantment", background_enchant }),
      ({ "dynamic enchantment", dynamic_enchant }),
      ({ "enchantment time", enchant_time }),
      ({ "theft handler", theft_handler }),
   });
} /* stats() */

/**
 * This method sets the long description to display during the day time.
 * @param str the new day long description
 * @see query_day_long()
 * @see set_night_long()
 */
void set_day_long( string str ) {
  if(!variablelongs)
    variablelongs = allocate(2);

  variablelongs[DAY] = str;

  if(is_day == -1)
    is_day = (WEATHER_HANDLER->query_day() > 0);

  if(is_day == DAY)
    set_long(str);
}

/**
 * This method sets up the night long for the room.  This will be the
 * long description displayed at night in the room.
 * @param str the new night long description
 * @see set_day_long()
 * @see query_night_long()
 */
void set_night_long( string str ) {
  if(!variablelongs)
    variablelongs = allocate(2);

  variablelongs[NIGHT] = str;

  if(is_day == -1)
    is_day = (WEATHER_HANDLER->query_day() > 0);
  if(is_day == NIGHT)
    set_long(str);
}

/**
 * This method returns the long description of the room at night.  This is
 * used to print out different strings for rooms during the day and during
 * the night.
 * @return the night long for the room.
 */
string query_night_long() {

   if(variablelongs && strlen(variablelongs[NIGHT]))
     return variablelongs[NIGHT];
   
   return this_object()->query_long();
} /* query_night_long() */

/* Returns the long part of the description. */
private string return_long(mixed desc) {
  int ma;

  if(!pointerp(desc))
    return (string)desc;

  ma = member_array("long", desc);
  if(ma < 0)
    return "Error: No long found.";
  
  return (string)desc[ma+1];
}

/**
 * This method sets up an item which will only be displayed during the
 * day.  All of the standard add_item things are available with this
 * method.
 * @see /std/room->add_item()
 * @see add_night_item()
 */
varargs int add_day_item(mixed shorts, mixed desc, mixed no_plural) {
  string the_item;
  
  if(pointerp(shorts))
    the_item = shorts[0];
  else
    the_item = shorts;

  if(!variableitems)
    variableitems = ({ ({ }), ({ }) });
  
  variableitems[DAY] += ({ the_item, return_long(desc) });

  if(is_day == -1)
    is_day = (WEATHER_HANDLER->query_day() > 0);
  if(is_day == DAY) 
    return add_item(shorts, desc, no_plural);
  
  return 1;
}

/**
 * This method sets up an item which will only be displayed during the
 * night.  All of the standard add_item things are available with this
 * method.
 * @see /std/room->add_item()
 * @see add_day_item()
 */
varargs int add_night_item(mixed shorts, mixed desc, mixed no_plural) {
  string the_item;
  
  if(pointerp(shorts))
    the_item = shorts[0];
  else
    the_item = shorts;

  if(!variableitems)
    variableitems = ({ ({ }), ({ }) });

  variableitems[NIGHT] += ({ the_item, return_long( desc ) });
  
  if(is_day == -1)
    is_day = (WEATHER_HANDLER->query_day() > 0);
  if(is_day == NIGHT) 
    return add_item(shorts, desc, no_plural);

  return 1;
}

/**
 * This method sets up chats for when the room is in the day cycle.
 * @param args the chatter arguements
 * @see room_night_chat()
 * @see /std/room->room_chat()
 */
void room_day_chat(mixed *args) {
  if(!variablechats)
    variablechats = allocate(2);
  
  variablechats[DAY] = args;
  
  if(is_day == -1)
    is_day = (WEATHER_HANDLER->query_day() > 0);
  if(is_day == DAY)
    room_chat(args);
}

/**
 * This method sets up chats for when the room is in the night cycle.
 * @param args the chatter arguements
 * @see room_day_chat()
 * @see /std/room->room_chat()
 */
void room_night_chat( mixed *args ) {
  if(!variablechats)
    variablechats = allocate(2);
  
  variablechats[NIGHT] = args;
  
  if(is_day == -1)
    is_day = (WEATHER_HANDLER->query_day() > 0);
  if(is_day == NIGHT)
    room_chat(args);
}

/** @ignore yes */
string query_help_file_directory() {
  return ROOM_HELP_FILE_DIR;
} /* query_help_file_directory() */
// --- END [/mnt/home2/grok/lib/std/room/basic_room_new.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/lightable.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/lightable.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629132   Available: 13576486
Inodes: Total: 5242880    Free: 4960135
9987 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/lightable.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629132   Available: 13576486
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * @main
 * This is the standard lightable.  It can be used for candles,
 * lanterns, lamps etc.  It adds the commands "light" and
 * "dowse"/"extinguish" to the player, but no refuelling
 * command.  Holding stuff is handled by /obj/weapon and the
 * ho_ld command.
 * @author Gruper
 * @index lightable
 * @started 11th of May, 1998
 */

#include <fuel_handler.h>

#define HOLD_COMMAND "/cmds/living/ho_ld"
#define DEPARTURES "/room/departures"

inherit "/obj/weapon";

int max_fuel, fuel, lit, brightness, time, hold;
string empty_mess;
mixed fuel_messages;

int set_lit(int);
/**
 * @ignore
 */
void create() {
   ::create();
   add_extra_look( this_object() );
}

/**
 * @ignore
 */
void init() {
   this_player()->add_command( "light", this_object() );
   this_player()->add_command( "dowse", this_object() );
   this_player()->add_command( "extinguish", this_object() );
} /* init() */

/**
 * @ignore
 */
varargs string short( int dark ) {
   if( lit )
      return "lit "+ ::short( dark );
   else
      return ::short( dark );
} /* short() */

/**
 * @ignore
 */
void out_of_fuel() {
   object env;

   fuel = 0;
   lit = 0;
   set_lit( 0 );

   FUEL_HANDLER->remove_burner( this_object() );

   if( !environment() ) return;

   env = environment();
   if( living( env ) ) {
      tell_object( env, the_short() +" goes out.\n" );
      tell_room( environment( env ),
            env->the_short() +"'s "+ short() +" goes out.\n", env );
   } else {
      tell_room( env, the_short() +" goes out.\n" );
   }
}

/**
 * @ignore
 */
void delayed_light() {
   lit = 1;
}


/**
 * @ignore
 */
int hold_thing() {

   if( !query_wielded() )
      return HOLD_COMMAND->cmd( ({ this_object() }) );
   else
      return 1;
}

/**
 * This function is used to light or dowse the lightable.
 * Two properties are checked: unextinguishable means that
 * the lightable cannot be extinguished and unlightable that
 * it cannot be lit.
 * @param i 1 for lit and 0 for unlit
 * @return The current state, 1 for lit, 0 for unlit
 */
int set_lit( int i ) {

   if( !i ) {
      if( !query_property( "unextinguishable" ) ) {
         lit = 0;
         FUEL_HANDLER->remove_burner( this_object() );
         remove_adjective( "lit" );
         set_light( 0 );
         return 0;
      }
   } else {
      if( !query_property( "unlightable" ) && fuel > 0 ) {
         if( lit )
            return 1;
         if( hold && !hold_thing() )
            return 0;
         call_out( (: delayed_light :), 2 ); // Delay for sensible light mess.
         FUEL_HANDLER->add_burner( this_object() );
         add_adjective( "lit" );
         set_light( brightness );
         return 1;
      }
   }
} /* set_lit() */

/**
 * @ignore
 */
mixed set_holder( object ob, int pos ) {
   /* no one is holding it and it requires holding when lit; dowse it */
   if( lit && hold && !ob && environment( this_player() )
       && file_name( environment( this_player() ) ) != DEPARTURES )
      if( !set_lit( 0 ) ) {
         tell_object( this_player(), "You extinguish "+ the_short() +".\n" );
         tell_room( environment( this_player() ), this_player()->the_short() +
               " extinguishes "+ the_short() +".\n", this_player() ); 
     }
   return ::set_holder( ob, pos );
} /* set_holder() */

/**
 * @return 1 if lit, 0 if unlit
 */
int query_lit() {
   return lit;
} /* query_lit() */

/**
 * @ignore
 */
int do_light() {
   if( lit )
      return notify_fail( the_short() +" is already lit.\n" );
   if( !fuel )
      return notify_fail( the_short() +" "+ empty_mess +"\n" );
   if( !set_lit( 1 ) )
      return notify_fail( "You cannot light "+ the_short() +".\n" );
   this_player()->add_succeeded_mess( this_object(), "$N $V $D.\n", ({ }) );
   return 1;
}

/**
 * @ignore
 */
int do_dowse() {
   if( !lit )
      return notify_fail( the_short() +" is not lit.\n" );
   if( set_lit( 0 ) ) 
      return notify_fail( "You cannot extinguish "+ the_short() +".\n" );
   this_player()->add_succeeded_mess( this_object(), "$N $V $D.\n", ({ }) );
   return 1;
}

/**
 * @ignore
 */
int do_extinguish() {
   return do_dowse();
}

/**
 * This function is used to set the different messages shown
 * depending on how much fuel is left in the lightable.
 * The fuel messages should be on a form suitable to be
 * appended to the_short() +" is lit/not lit.  "
 * The argument msgs can either be an array of strings or an
 * array of string, int pairs.  In the first case, the fuel
 * messages will be evenly spaced.  In the second case, the
 * int is a percentage (fuel_left*100/max_fuel) below which
 * the string will be used.  If no message for 100 is given,
 * it will default to the last string element in the array.
 *
 * @param msgs A mixed array of either strings or string, int pairs
 * @example
 *     set_fuel_messages( ({ "There is almost no fuel left.", 10
 *                           "It is more than halfway empty.", 50,
 *                           "It is not yet halfway empty.", 80,
 *                           "It is almost full.", 100 }) );
 */
void set_fuel_messages( mixed msgs ) {
   fuel_messages = msgs;
} /* set_fuel_messages() */

/**
 * @return a mapping containing all the different fuel_messages
 */
mixed query_fuel_messages() {
   return fuel_messages;
} /* query_fuel_messages() */

/**
 * Sets the maximum amount of fuel.
 * One fuel unit equals one second of burning time.
 */
void set_max_fuel( int i ) {
   max_fuel = i;
} /* set_max_fuel() */

/**
 * @return The max amount of fuel the object can contain.
 */
int query_max_fuel() {
   return max_fuel;
} /* query_max_fuel() */

/**
 * Sets the current amount of fuel.  One fuel unit equals
 * one second of burning time.  If fuel > max_fuel,
 * fuel = max_fuel, so it is important to set max_fuel
 * before fuel.
 */
void set_fuel( int i ) {
   fuel = i;
   if( fuel > max_fuel )
      fuel = max_fuel;
} /* set_fuel() */

/**
 * @return The current amount of fuel.
 */
int query_fuel() {
   return fuel;
} /* query_fuel() */

/**
 * @return String describing how much fuel is left.
 */
string current_fuel_message() {
   mixed messages;  /* ooo, isn't that a nice variable declaration? :D */
   int fuel_percent, size, i;
   string fuel_string = "";

   if( fuel < 1 )
      return "It "+ empty_mess;

   messages = query_fuel_messages();
   size = sizeof( messages );

   if( !size )
      return "This item needs a creator.  It is broken and lonely.";

   if( size < 2 )
      return messages[0];

   /* Multiplying by 99 guarantees <= index */
   fuel_percent = fuel * 99 / max_fuel;

   if( intp( messages[1] ) ) { // Percenatges given
      for( i = 1; i < size; i += 2 ) {
         if( messages[i] > fuel_percent ) {
            fuel_string = messages[i-1];
            break;
         }
      }
      if( fuel_string == "" )
         fuel_string = messages[ size - 2 ];
   } else { // Percentages not given -> even distribution
      fuel_string = messages[ fuel_percent * size / 100 ];
   }
   return fuel_string;
} /* current_fuel_message() */

/**
 * The empty message is a string used to describe the lightable
 * when it is out of fuel.  It should be on the form
 * "is burnt to a stub." to fit both the_short() +" "+ msg
 * and "It "+ msg.
 */
void set_empty_mess( string msg ) {
   empty_mess = msg;
} /* set_empty_mess() */

/**
 * @return String empty_mess
 */
string query_empty_mess() {
   return empty_mess;
} /* query_empty_mess() */

/**
 * The brightness is the number used in set_light(),
 * ie how brightly the lightable shines when lit.
 */
void set_brightness( int i ) {
   brightness = i;
} /* set_brightness() */

/**
 * @return How brightly the object shines when lit
 */
int query_brightness() {
   return brightness;
} /* query_brightness() */

/**
 * @param hands The number of hands required to hold the object when lit
 * Any non-zero value will cause the ho_ld command to be executed,
 * so use set_no_limbs( 2 ) as usual for two-handed weapons.
 * I guess what I'm really trying to say is that a 0 will not require
 * the object to be held and any other value will.
 *
 * In winter darkness<br>
 * Gruper lights a cheerful flame<br>
 * It smells like honey<br>
 */
void set_hold_required( int hands ) {
   hold = hands;
}

/**
 * @return number of hands required to hold object when lit
 */
int query_hold_required() {
   return hold;
}

/**
 * @ignore
 */
string extra_look() {
   string lit_str;

   if( lit )
      lit_str = "It is lit.  ";
   else
      lit_str = "It is not currently lit.  ";

   return lit_str + current_fuel_message() +"\n";
}

/**
 * @ignore
 */
mixed query_dynamic_auto_load() {

   return ([ "::" : ::query_dynamic_auto_load(),
             "fuel" : fuel,
             "lit" : lit,
           ]);
} /* query_dynamic_auto_load() */

/**
 * @ignore
 */
void init_dynamic_arg(mapping arg, object bing ) {

   fuel = arg["fuel"];
   ::init_dynamic_arg(arg["::"], bing);

   set_lit(arg["lit"]);
/*
   if( lit )
      FUEL_HANDLER->add_burner( this_object() );
 */

} /* init_dynamic_arg() */

/**
 * @ignore
 */
void consume_fuel() {
   /* By using FUEL_TIME we make sure that 1 unit of fuel = 1 second */
   fuel -= FUEL_TIME;
   if( fuel < 1 )
      out_of_fuel();
}

/**
 * @ignore
 */
int query_value() {
   return (int)( ::query_value() * fuel / max_fuel );
}

/**
 * @ignore
 */
varargs int move( mixed dest, string messin, string messout ) {

   object destination;

   if( objectp( dest ) ) {
      destination = dest;
   } else {
      destination = load_object( dest );
   }
   
   // This object is entering a place that may be, ah, hostile
   // to open flames, i.e. containers (that are not people) and
   // water rooms.
   if( ( inherits( "/std/container", destination ) &&
         !living( destination ) ) ||
       inherits( "/std/uwater", destination ) ||
       inherits( "/std/water_inside", destination ) ||
       inherits( "/std/water_outside", destination ) ) {
      set_lit( 0 );
   }

   return ::move( dest, messin, messout );

}
// --- END [/mnt/home2/grok/lib/std/lightable.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/liquids/ink.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/liquids/ink.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629129   Available: 13576483
Inodes: Total: 5242880    Free: 4960135
586 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/liquids/ink.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629129   Available: 13576483
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: ink.c,v 1.1 1998/01/06 04:28:23 ceres Exp $
 * $Log: ink.c,v $
 * Revision 1.1  1998/01/06 04:28:23  ceres
 * Initial revision
 * 
*/
/*
 * Ink defintion file...
 */

int splash_func(object ob) {
  ob->add_extra_look(this_object());
  ob->add_property("splashed with", previous_object()->query_liquid_name());
  return 1;
}

int query_ink() { return 1; }

string extra_look() {
  return capitalize((string)previous_object()->query_name())+
         " has been splashed with "+
         previous_object()->query_property("splashed with");
}
// --- END [/mnt/home2/grok/lib/std/liquids/ink.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shadows/object/death_ward.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shadows/object/death_ward.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629129   Available: 13576483
Inodes: Total: 5242880    Free: 4960135
1113 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shadows/object/death_ward.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629129   Available: 13576483
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: death_ward.c,v 1.1 1998/01/06 04:40:23 ceres Exp $
 * $Log: death_ward.c,v $
 * Revision 1.1  1998/01/06 04:40:23  ceres
 * Initial revision
 * 
*/
inherit "/std/effect_shadow";

void event_death( object thing, object *killers, object killer,
      string room_mess, string killer_mess ) {
   int damage;
   object twit;
   player->event_death( thing, killers, killer, room_mess, killer_mess );
   if ( thing != (object)player->query_worn_by() )
      return;
   tell_room( environment( thing ), (string)player->the_short() +
         " explodes in a ball of flame!\n" );
   thing->remove_armour( player );
   player->move( "/room/rubbish" );
   foreach ( twit in killers ) {
      if ( environment( twit ) != environment( thing ) )
         continue;
      damage = arg();
      if ( twit == killer )
         damage *= 2;
      damage -= (int)twit->query_ac( "fire", damage );
      if ( damage > 0 )
         twit->adjust_hp( -damage );
      if ( (int)twit->query_hp() < 0 )
         twit->attack_by( player );
   }
   remove_this_effect();
} /* event_death() */
// --- END [/mnt/home2/grok/lib/std/shadows/object/death_ward.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shadows/object/owned_weapon.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shadows/object/owned_weapon.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629128   Available: 13576482
Inodes: Total: 5242880    Free: 4960135
684 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shadows/object/owned_weapon.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629128   Available: 13576482
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: owned_weapon.c,v 1.2 1999/02/03 03:38:55 gruper Exp $
 * $Log: owned_weapon.c,v $
 * Revision 1.2  1999/02/03 03:38:55  gruper
 * Rodion added query_owner().
 *
 * Revision 1.1  1998/01/06 04:40:23  ceres
 * Initial revision
 * 
*/
inherit "/std/effect_shadow";

mixed set_holder( object thing, int pos ) {
   this_object()->remove_hide_invis( "concealed" );
   if ( objectp( thing ) )
      if ( !thing->query_corpse() &&
            ( (string)thing->query_name() != arg() ) )
         return 0;
   return (mixed)player->set_holder( thing, pos );
} /* set_holder() */

string query_owner(){
   return (string) arg();
}/*query_owner()*/

// --- END [/mnt/home2/grok/lib/std/shadows/object/owned_weapon.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shadows/object/swim_fins.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shadows/object/swim_fins.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629128   Available: 13576482
Inodes: Total: 5242880    Free: 4960135
224 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shadows/object/swim_fins.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629128   Available: 13576482
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/effect_shadow";

int query_skill_bonus(string skill, int true) {
  if ((skill != "other.movement.swimming") || true)
    return player->query_skill_bonus(skill);
  return player->query_skill_bonus(skill)+50;
}
// --- END [/mnt/home2/grok/lib/std/shadows/object/swim_fins.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shadows/object/basic_trap.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shadows/object/basic_trap.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629128   Available: 13576482
Inodes: Total: 5242880    Free: 4960135
507 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shadows/object/basic_trap.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629128   Available: 13576482
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: basic_trap.c,v 1.1 2000/06/08 01:48:53 pinkfish Exp $
 * $Log: basic_trap.c,v $
 * Revision 1.1  2000/06/08 01:48:53  pinkfish
 * Initial revision
 *
 * Revision 1.1  1998/01/06 04:40:23  ceres
 * Initial revision
 * 
*/
inherit "/std/effect_shadow";

// type == "lock", "unlock" or "pick"
// return 0 for ok, return 1 for failure
int trap_lock(string type) {
  if(type != "pick")
    return 0;

  tell_object(this_player(), "Trap triggered.\n");
  return 0;
}
// --- END [/mnt/home2/grok/lib/std/shadows/object/basic_trap.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shadows/object/no_save.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shadows/object/no_save.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629127   Available: 13576481
Inodes: Total: 5242880    Free: 4960135
259 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shadows/object/no_save.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629127   Available: 13576481
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming

inherit "/std/effect_shadow";

mixed query_auto_load() {
   return 0;
} /* query_auto_load() */

mixed query_dynamic_auto_load() {
   return 0;
} /* query_dynamic_auto_load() */

mixed query_static_auto_load() {
   return 0;
} /* query_static_auto_load() */
// --- END [/mnt/home2/grok/lib/std/shadows/object/no_save.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shadows/object/talker.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shadows/object/talker.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629127   Available: 13576481
Inodes: Total: 5242880    Free: 4960135
26397 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shadows/object/talker.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629127   Available: 13576481
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h"
#include <talker.h>
#include <network.h>
#include <term.h>
#include <playtesters.h>
#include <language.h>
#include <cmds/options.h>

// #define DEBUG 1
#define EMOTE_ENABLED 1
#define BEEP sprintf("%c",7)
#define CTRL sprintf("%c", 13)
//#define NOISY

inherit "/std/effect_shadow";

int do_talker_control(mixed *args, string pattern);
int do_chat(string message, string pattern, string verb);

int handle_status_command(string mode, class talker_args args);
int handle_verbose_command(string mode, class talker_args args);
int handle_history_command(string channel, class talker_args args);
int handle_colour_list(mixed *colour_args, class talker_args args);

int handle_colour_command(string channel, string new_colour, class talker_args args);
int handle_colour_on_off_command( string str_status, class talker_args args);
int handle_colour_toggle_command( class talker_args args);

int handle_echo_command( string mode, class talker_args args);

void init() {
  mixed args;
  object where;
  string channel;

  where = environment(player);
#ifdef DEBUG
  tell_creator("taffyd", "%O, %O, %O.\n", player, this_player(), where);
#endif

  // If this isn't here, living objects can't be moved into talkers
  // that are containers by /global/auto_load.  Go figger.
  if( !where )
    return;

  if (!living(where)) {
    player->init();
    return;
  }

  args = arg();

  if (!classp(args)) {
    args = new(class talker_args, status : 0, channels : ({ "one" }),
               verbose : 1, local_echo : 0, colour : 0 );
    set_arg(args);
  }

  where->add_command("talker", player,
                     ({ON_PATTERN,
                         VERBOSE_PATTERN,
                         CHANNEL_PATTERN,
                         DELETE_CHANNEL_PATTERN,
                         HISTORY_PATTERN,
                         HISTORY_CHANNEL_PATTERN,
                         LIST_PATTERN,
                         LIST_CHANNEL_PATTERN,
                         LIST_CHANNEL_PATTERN_BRIEF,
                         SET_COLOUR_PATTERN,
                         COLOUR_ON_OFF_PATTERN,
                         COLOUR_LIST,
                         TOGGLE_COLOUR_PATTERN,
                         NEW_CHANNEL_PATTERN,
                         ECHO_PATTERN,
                         "delete <string'channel'> from <direct:object'talker'>",
                         "help" }),
                     (: do_talker_control($4, $5) :) );

  where->add_command("chat", player,
                     ({ "<string'message'>" }),
                     (: do_chat($4[0], $5, $6) :) );
#ifdef EMOTE_ENABLED
  where->add_command("chat:", player,
                     ({ "<string'message'>" }),
                     (: do_chat(":" + $4[0], $5, $6) :) );
#endif
  /*
   * If they've picked up a talker that's not theirs...
   * nuke the channels.
   */
  if ( !( EFFECTS + "talker" )->valid( args->channels, where ) ) {
    args->channels = ({ "one" });
    set_arg(args);
  }

  foreach (channel in args->channels) {
#ifdef DEBUG
    tell_creator("taffyd", "Adding channel. %O.\n", channel);
#endif
    where->add_command(lower_case(channel), player,
                       "<string'message'>", (: do_chat($4[0], $5, $6) :) );
#ifdef EMOTE_ENABLED
    where->add_command( lower_case(channel) + ":", player,
                        "<string'message'>",
                        (: do_chat(":" + $4[0], $5, $6) :) );
#endif
  }

  player->init();
} /* init() */

object query_player() {
  if(player && environment(player) && living(environment(player)))
    return environment(player);
  return 0;
}

int do_talker_control(mixed *args, string pattern) {
  class talker_args t_args;
  int position;
  string full_name;

#ifdef DEBUG
  tell_creator("taffyd", "Args to talker control is %O. Pattern is %O.\n",
               args, pattern);
#endif

  t_args = arg();

  switch (pattern) {
  case ON_PATTERN:
    return handle_status_command(args[0], t_args);
  case VERBOSE_PATTERN:
    return handle_verbose_command(args[0], t_args);
  case CHANNEL_PATTERN:
    if ( !t_args->status ) {
      tell_object(this_player(), "The eyes are asleep.\n");
      return 1;
    }

    tell_object(this_player(), "You may use the following channels:\n" +
                (string)( EFFECTS +"talker" )->channels() +
                "You are on channel(s) " +
                query_multiple_short( t_args->channels ) + ".\n" );
    return 1;
    break;

  case ECHO_PATTERN:
    return handle_echo_command( args[0], t_args );

  case "delete <string'channel'> from <direct:object'talker'>":
    add_succeeded_mess( ({ "", "" }) );

  case DELETE_CHANNEL_PATTERN:
    if ( !t_args->status ) {
      tell_object(this_player(),  "The eyes are asleep.\n");
      return 1;
    }

    full_name = (EFFECTS + "talker")->normalise_name( args[ 0 ] );

    if ( !(EFFECTS +"talker")->valid( full_name ) ) {
      tell_object(this_player(), "The eyes are not aware of that "
                  "channel.\n");
      return 1;
    }

    position = member_array(full_name, t_args->channels);

    if (position == -1) {
      tell_object(this_player(), "The eyes are not listening to "
                  "that channel.\n");
      return 1;
    }

    if (sizeof(t_args->channels) > 1) {
      t_args->channels = t_args->channels[0..position-1] +
        t_args->channels[position+1..];
      tell_object(this_player(), "The eyes sigh with relief as they "
                  "can now ignore what happens on "
                  "channel \"" + full_name + "\".\n");
    }
    else {
      tell_object(this_player(), "The eyes are bored with not listening "
                  "to any channel at all, and add channel \"one\" to their "
                  "list again.\n");
      t_args->channels = ({ "one" });
    }

    set_arg(t_args);
    break;

  case NEW_CHANNEL_PATTERN:
    if ( !t_args->status ) {
      tell_object(this_player(),  "The eyes are asleep.\n");
      return 1;
    }
    full_name = (EFFECTS + "talker")->normalise_name( args[ 0 ] );

    (EFFECTS+"talker")->clear_cache(this_player()->query_name());
    if ( ( EFFECTS +"talker" )->valid( full_name ) ) {
      if ( member_array( full_name, t_args->channels ) != -1 ) {
        tell_object(this_player(), "The eyes frown at you; they are "
                    "already listening to that channel.\n");
        return 1;
      }

      tell_object(this_player(),  "You whisper to " +
                  player->the_short() + " and the eyes add "
                  "channel \""+ full_name +"\" to the list.\n");
      t_args->channels += ({ full_name });
      set_arg(t_args);
      this_object()->init();
    } else {
      tell_object(this_player(), "You whisper to " +
                  player->the_short() + ", but the eyes "
                  "refuse to give you that channel.\n");
      return 1;
    }
    break;

  case SET_COLOUR_PATTERN:
  case SET_COLOUR_FULL_PATTERN:
    args[ 0 ] = (EFFECTS+"talker")->normalise_name( args[0] );
    return handle_colour_command( args[0], args[1], t_args );

  case COLOUR_ON_OFF_PATTERN:
    return handle_colour_on_off_command( args[0], t_args );

  case TOGGLE_COLOUR_PATTERN:
    return handle_colour_toggle_command(t_args);

  case COLOUR_LIST:
    return handle_colour_list( args, t_args );
    break;

  case HISTORY_CHANNEL_PATTERN:
    args[ 0 ] = (EFFECTS+"talker")->normalise_name( args[0] );
    return handle_history_command(args[0], t_args);

  case HISTORY_PATTERN:
    return handle_history_command("one", t_args);

  case LIST_PATTERN:
  case LIST_CHANNEL_PATTERN:
  case LIST_CHANNEL_PATTERN_BRIEF:

    if ( !t_args->status ) {
      tell_object(this_player(),  "The eyes are asleep.\n");
      return 1;
    }

    //            add_succeeded_mess("");

    if (sizeof(args) == 1) {
      args[ 0 ] = (EFFECTS + "talker")->normalise_name( args[ 0 ] );
      tell_object(this_player(), "The following people are using "
                  "channel \""+ args[0] + "\":\n" +
                  ( EFFECTS +"talker" )->list( args[0],
                                 pattern == LIST_CHANNEL_PATTERN_BRIEF) );
    } else
      tell_object(this_player(), "The following people are using "
                  "talkers:\n" + (string)( EFFECTS +"talker" )->list() );

    return 1;
    break;

  case "help":
  default:
    write( "Talker commands:\n\n"
           "help               : give this help file\n"
           "on|off             : switch talker on or off\n"
           "brief              : make talker use shorter messages\n"
           "verbose            : make talker use longer messages\n"
           "channels           : list valid channels\n"
           "<channel>          : switch to <channel> if valid\n"
           "delete <channel>   : switch <channel> off if valid\n"
           "list [channel]     : list users of the talker\n"
           "history [channel]  : show chat history of <channel>\n"
           "Prefix commands with \"talker\" to use, e.g. "
           "\"talker help\".  For a more detailed description type "
           "\"help talker\".\n" );
    break;
  }

  return 1;
} /* do_talker_control() */

int handle_history_command(string channel, class talker_args args) {
  mixed *history;
  string result;

  if (!args->status) {
    tell_object(this_player(), "The eyes are asleep.\n");
    return 1;
  }

  if (!channel)
    channel = "one";

  if ( !( EFFECTS +"talker" )->valid( channel ) ) {
    tell_object(this_player(), "The eyes are not aware of that "
                "channel.\n");
    return 1;
  }

  //    add_succeeded_mess("");

  tell_object(this_player(), "You whisper to " + player->the_short() +
              ", asking for the last few chats on channel " + channel + ".\n");

  history = HIST->query_chat_history(lower_case( channel ) );

  if ( !arrayp( history ) || !sizeof( history ) ) {
    tell_object(this_player(), "The eyes mutter that nothing has "
                "been said on this channel, or it is not being remembered.\n");
    return 1;
  }

  result = "$P$Channel " + channel + "$P$The eyes mutter about your bad "
    "memory.\n";

  result += implode(map(history, (: "$I$5=$C$" + $1[0] + ($1[1] ? $1[1] : "") +
                                  "%^RESET%^" :)), "\n");
  tell_object(this_player(), result);
  return 1;
} /* handle_history_command() */

string query_colour_status( class talker_args args ) {
  if ( !mapp( args->colour ) ) {
    return "off";
  }

  return args->colour[ "status" ];
} /* query_colour_status() */

int set_colour_status( class talker_args args, string status ) {
  if ( !args->colour ) {
    args->colour = DEFAULT_COLOUR_SETTINGS;
  } else {
    if ( stringp( args->colour ) ) {
      args->colour = DEFAULT_COLOUR_WITH( args->colour );
    }
  }

  args->colour[ "status" ] = status;
  set_arg( args );
  return 1;
} /* set_colour_status() */

int set_channel_colour(class talker_args args, string channel, string colour) {

  if ( !channel || !colour )
    return 0;

  if ( !mapp( args->colour ) ) {
    args->colour = DEFAULT_COLOUR_WITH(colour);
  }

  args->colour[ channel ] = colour;
  set_arg( args );
  return 1;
} /* set_channel_colour() */

varargs string query_channel_colour( class talker_args args, string channel ) {
  string colour;

  if ( !mapp( args ) ) {
    return DEFAULT_COLOUR;
  }

  if ( colour = args->colour[ channel ] ) {
    return colour;
  } else {
    if ( colour = args->colour[ "default" ] ) {
      return colour;
    }
  }

  return DEFAULT_COLOUR;
} /* query_channel_colour() */

int handle_colour_toggle_command( class talker_args args ) {
  if ( query_colour_status( args ) == "on" ) {
    return handle_colour_on_off_command( "off", args );
  }

  return handle_colour_on_off_command( "on", args );
} /* handle_colour_toggle_command() */

int handle_colour_on_off_command( string str_status, class talker_args args ) {
  string status;

  status = query_colour_status( args );

  switch( str_status ) {
  case "on":
    if ( status == "on" ) {
      add_failed_mess( "Talker colours for $D are already on!\n" );
      return -1;
    }
    set_colour_status( args, "on" );
    add_succeeded_mess( ({ "The eyes on $D flash with " +
                             query_channel_colour( args, "default" ) +
                             "colour%^RESET%^.\n", "" }) );
    break;

  case "off":
    if ( status == "off" ) {
      add_failed_mess("Talker colours for $D have already been turned off!\n");
      return -1;
    }
    set_colour_status( args, "off" );
    add_succeeded_mess( ({ "The eyes on $D blink sadly.\n", "" }) );
    break;

  default:
    args->colour = DEFAULT_COLOUR_SETTINGS;
    set_arg( args );
    add_succeeded_mess( ({ "Talker colour settings for $D have been reset.\n",
                             "" }) );
  }

  return 1;
} /* handle_colour_on_off_command() */

mapping create_valid_colours( string my_colours ) {
  string *colours;
  string *valid_colours = TERM_HANDLER->query_colour_codes();

  colours = map( explode( my_colours, " " ),
                 (: upper_case( $1 ) :) );

  return unique_mapping( colours,
                         (: member_array( $1, $(valid_colours) ) > -1 :) );
} /* create_valid_colours() */

int handle_colour_command(string channel, string new_colour,
                          class talker_args args) {
  mapping colours;
  string valid_colour;

  if ( !(EFFECTS + "talker")->valid( channel ) && channel != "default" ) {
    tell_object( this_player(), "You cannot set that "
                 "channel! Use the channel name \"default\" to set "
                 "the default channel colour.\n" );
    return 1;
  }

  colours = create_valid_colours( new_colour );

  switch( sizeof( colours[ 0 ] ) ) {
  case 0:
    valid_colour = implode( map( colours[ 1 ], (: "%^" + $1 + "%^" :) ), "" );

    set_channel_colour( args, channel, valid_colour );
    add_succeeded_mess( ({ "The eyes flash with" + valid_colour +
                             " colour.%^RESET%^\n", "" }) );
    return 1;

  case 1:
    add_failed_mess( "The colour $I is invalid.\n", colours[ 0 ] );
    return -1;

  default:
    add_failed_mess( "The colours $I are invalid.\n", colours[ 0 ] );
    return -1;
  }
} /* handle_colour_command() */

int handle_status_command(string mode, class talker_args args) {
  switch (mode) {
  case "on" :
    if ( args->status ) {
      tell_object(this_player(),  "The eyes are already alert "
                  "and listening to your every word.\n");
    } else {
      tell_object(this_player(), "The eyes open and light up "
                  "eagerly, then dim to a dull glow.\n");
      args->status = 1;
    }
    break;

  case "off" :
    if ( !args->status ) {
      tell_object(this_player(), "You notice that the eyes are "
                  "already closed, so you wake them up again "
                  "in order to tell them to go to sleep.\n");
    } else {
      tell_object(this_player(), "The eyes slowly lose their "
                  "glow as they close.\n");
      args->status = 0;
    }
    break;
  }

  set_arg(args);
  return 1;
} /* handle_status_command() */

int handle_verbose_command(string mode, class talker_args args) {

  if (!args->status) {
    tell_object(this_player(), "The eyes are asleep.\n");
    return 1;
  }

  switch (mode) {
  case "brief":
    if ( !args->verbose ) {
      tell_object(this_player(), "The eyes ignore you completely.\n");
    } else {
      tell_object(this_player(), "The eyes seem sad as they dim "
                  "slightly.\n");
      args->verbose = 0;
    }
    break;

  case "verbose":
    if ( args->verbose ) {
      tell_object(this_player(),  "The eyes glitter at you "
                  "angrily.  They already know that they are to "
                  "be verbose.\n");
    } else {
      tell_object(this_player(), "The eyes light up happily for "
                  "a moment.\n");
      args->verbose = 1;
    }
    break;
  }
  set_arg(args);
  return 1;
} /* handle_verbose_command() */

void receive(string channel, string sender, string text, object *receivers) {
  class talker_args args;
  string *ignoring;
  object where;
  string colour;
  string txt;

  if(!player || !environment(player) )
    return;

  where = environment(player);
  args = arg();

  if (args && !classp(args))
    return;

  if (!args || !args->status || !living(where) || !interactive(where))
    return;

  /*
   * If we're not listening to this channel, then don't receive the
   * message.
   */
  if(member_array(channel, map(args->channels, (: lower_case($1) :)) ) == -1) {
    return;
   }

  /*
   * Creators can their talker messages through the dwchat command,
   * they don't need to hear it twice.
   */
  if ( channel == "intermud" && where->query_creator() ) {
    return;
  }


  if ( file_name( previous_object( 1 ) ) == "/secure/cmds/creator/exe_c" ||
       file_name( previous_object( 1 ) ) == "/secure/cmds/creator/ca_ll" ) {
    if ( this_player(1) && this_player(1)->query_creator() &&
         !this_player(1)->query_property( "talker cheat" ) ) {

      txt = this_player(1)->query_name() +
        " made " + sender + " chat \"" + text + "\" on "
        "channel " + channel;
      user_event( "inform", txt, "cheat" );
      log_file( "/d/admin/log/TALKER", txt + "\n" );

      this_player(1)->add_property( "talker cheat", 1, 3 );
    }
  }

  ignoring = where->query_property("ignoring");

  if (ignoring && member_array(lower_case(sender), ignoring) != -1 ) {
    return;

  }
  if(player->query_property(SHORTHAND_OUTPUT_PROP))
    text = LANGUAGES->fix_shorthand(text);

  if ( args->verbose ) {
#ifdef EMOTE_ENABLED
    if ( text[0] == '@' || text[0] == ':' ) {
      text = ( channel == "one" ? "" : "("+ capitalize(channel) +
               ") " ) +
        sender +"'s wispy voice comes from " +
        player->the_short()+", saying that " +
        (this_player()?this_player()->query_pronoun():"they") +
        " " + text[1..];
    } else {
#endif
      text = ( channel == "one" ? "" : "("+ capitalize(channel) +
               ") " ) +
        sender +"'s wispy voice comes from " +
        player->the_short()+", saying: " + text;
#ifdef EMOTE_ENABLED
    }
#endif
  } else { // brief mode.
#ifdef EMOTE_ENABLED
    if ( text[0] == '@' || text[0] == ':' ) {
      text = ( channel == "one" ? "" : "("+ capitalize(channel) +
               ") " ) +
        sender +" wisps that " +
        (this_player()?this_player()->query_pronoun():"they") +
        " " + text[1..];
    } else {
#endif
      text = ( channel == "one" ? "" : "("+ capitalize(channel) +
               ") " ) +
        sender +" wisps: " +text;
#ifdef EMOTE_ENABLED
    }
#endif
  }

  if ( stringp( args->colour ) ) {
    colour = args->colour;
  }

  if(mapp(args->colour) && query_colour_status( args ) == "on") {
    if (!( colour = args->colour[ channel ] ) ) {
      if(!(colour = args->colour[(EFFECTS + "talker")->
                                normalise_name(channel)])) {
        colour = args->colour[ "default" ];
        /* Incase... */
        if ( !colour ) {
          colour = DEFAULT_COLOUR;
        }
      }
    }
  } else {
    colour = "";
  }

  tell_object(where, colour +  "$I$5=$C$"+ text + "%^RESET%^\n" );

#ifdef NOISY
  if(receivers && sizeof(receivers) && !where->query_invis() &&
     environment(where) && base_name(environment(where)) != "/room/rubbish") {

    receivers = map(receivers, (: $1->query_player() :));
    receivers += ({ this_player() });

    tell_room(environment(where),
              "A wispy voice comes from " + player->poss_short(1) + ".\n",
              receivers);
  }
#endif
}

int do_chat(string message, string pattern, string verb) {
  class talker_args args;
  object *things, *receivers;
  string sender;
#ifdef DEBUG
  tell_creator("taffyd", "Message is %s, pattern is %s, verb is "
               "%s.\n", message, pattern, verb);
#endif

#ifdef EMOTE_ENABLED
  if ( verb[ <1 ] == ':' ) {
    verb = verb[0..<2];
  }
#endif

  if (pattern == "into <direct:object>") {
    add_succeeded_mess("$N whisper$s lovingly to $D.\n");
    return 1;
  }

  args = arg();
  if (!args->status) {
    tell_object(this_player(), "The eyes are asleep.\n");
    return 1;
  }

  /*
   * Strip colours... makes sure players don't "embed" colour
   * codes.
   */
  while (strsrch(message, "%^") != -1) {
    message = replace(message, ({ "%^", "" }) );
  }

  /*
   * If we're not actually listening to this channel, then stop.
   */

  if(member_array( verb, map(args->channels, (: lower_case($1) :)) ) == -1 &&
     verb != "chat") {
    return 0;
  }

  if(this_player()->query_property("no talker")) {
    add_failed_mess("Sorry, you are not allowed to use a talker.\n");
    return 0;
  }

  if(environment(this_player()) &&
     environment(this_player())->query_property("no talker")) {
    if(stringp(environment(this_player())->query_property("no talker")))
      add_failed_mess(environment(this_player())->query_property("no talker"));
    else
      add_failed_mess("Your talker doesn't seem to work here.\n");
    return 0;
  }

  if (this_player()->query_property("gagged")) {
    add_failed_mess("You have been gagged!  You cannot chat until "
                    "your gag is removed.  Perhaps you should talk to a "
                    "creator about this.\n");
    return 0;
  }

  if (environment(player) != this_player()) {
    add_failed_mess("You're too far away from $D to whisper into it.\n");
    return 0;
  }

  if (verb == "chat") {
    if (member_array("one", args->channels) == -1) {
      verb = args->channels[0];
    }
    else {
      verb = "one";
    }
  }

  sender = this_player()->query_cap_name();

  /* Strip bell characters */
  message = replace(message,
                    ({ BEEP, "", CTRL, "", "[A", "", "[B", "", "[C", "",
                         "[D", "", "%^", " " }));

  if(this_player()->query_property(SHORTHAND_PROP))
    message = LANGUAGES->fix_shorthand(message);

  things = children( PATH + "talker" );

  if ( args->local_echo ) {
    things -= ({ find_object( PATH + "talker" ) });
  } else {
    things -= ({ this_object(), find_object( PATH + "talker" ) });
  }

  tell_object(this_player(), "You whisper into " + player->the_short() +
              ".\n");
  if(!this_player()->query_invis() &&
     base_name(environment(this_player())) != "/room/rubbish" ) {
    receivers = map(things, (: $1->query_player() :));
    receivers += ({ this_player() });
    tell_room(environment(this_player()), this_player()->one_short(1) +
              " whispers into " + this_player()->query_possessive() +
              " " + player->short() + ".\n", receivers);
  }

  things->receive(verb, sender, message, things);

  if( verb == "intermud" ) {
    /*
     * Rudimentary support for Intermud emotes.  Not supported on
     * the receiving end.
     */
    if (message[0] == '@' || message[0] == ':') {
      user_event( "intermud_tell", sender + " ", message[1..], "dwchat" );
      message = "$N " + message[1..];
      SERVICES_D->eventSendChannel(sender, "discworld-chat", message, 1);
    } else {
      /* Intermud "discworld_chat" channel support for players. */
      SERVICES_D->eventSendChannel( sender, "discworld-chat", message, 0 );
      user_event( "intermud_tell", sender +": ", message, "dwchat" );
    }
  }
  if ( verb == "playtesters" ) {
    if ( !this_player()->query_creator() &&
         !PLAYTESTER_HAND->query_playtester(this_player()->query_name()) ) {
      args->channels -= ({ "playtesters" });
      set_arg(args);
      add_failed_mess("You're no longer a playtester!\n");
      return 0;
    }
  }
#ifdef EMOTE_ENABLED
  if ( message[0] == '@' || message[0] == ':' ) {
    HIST->add_chat_history( verb , sender +" wisped that " +
                            this_player()->query_pronoun() + " ",
                            message[1..] );
  } else {
#endif
    HIST->add_chat_history( verb , sender +" wisped: ", message );
#ifdef EMOTE_ENABLED
  }
#endif

  return 1;
} /* do_chat() */

/**
 * @ignore yes
 * Tape did this. This is why items with add_command() stop working
 * when you remove the effect.
 */
void remove_effect_shadow( int i ) {
  if ( i == id ) {
    if ( player && environment( player ) ) {
      // This removes the add_command()s set up by the
      // shadow (this_object()) from the guy who's
      // carrying the talker.  It's a bit hacky, but I
      // can't think of any other way to do it.

//      environment( player )->remove_object2( player, 1 );
      environment( player )->remove_object( player, 1 );
      init();
    }
  }

  ::remove_effect_shadow( i );
} /* remove_effect_shadow() */

/**
 * @ignore yes
 */
protected string format_channel_colour( string colour ) {
  return colour +
    lower_case( replace_string( implode( explode( colour, "%^%^" ), " " ),
                                "%^", "" ) ) + "%^RESET%^";
} /* format_channel_colour() */


int handle_colour_list(mixed *colour_args, class talker_args args) {
  string channel;

  if (!mapp(args->colour) || query_colour_status( args ) == "off" ) {
    add_failed_mess( "You currently have talker colours disabled.  Use "
                     "\"talker colour on\" to turn them on.\n" );
    return 0;
  }

  foreach( channel in args->channels ) {
    if ( args->colour[ channel ] ) {
      tell_object( this_player(),
                   "Channel " + channel + " is " +
                   format_channel_colour( args->colour[ channel ] ) + ".\n");
    }
  }

  if ( args->colour[ "default" ] ) {
    tell_object( this_player(),
                 "The default talker colour is " +
                 format_channel_colour( args->colour[ "default" ] ) + ".\n");
  }

  return 1;
} /* handle_colour_list() */

int handle_echo_command( string mode, class talker_args args) {
  int current;

  current = args->local_echo;

  if ( current ) {
    if ( mode == "on" ) {
      add_failed_mess( "Talker echo is already on for $D!\n" );
      return -1;
    }

    args->local_echo = 0;
    add_succeeded_mess( ({ "The eyes on $D flash slowly.\n", "" }) );
  } else {
    if ( mode == "off" ) {
      add_failed_mess( "Talker echo is already off for $D!\n" );
      return -1;
    }

    args->local_echo = 1;
    add_succeeded_mess( ({ "The eyes on $D flash twice rapidly.\n",
                             "" }) );
  }

  set_arg( args );
  return 1;
} /* handle_echo_command() */
// --- END [/mnt/home2/grok/lib/std/shadows/object/talker.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shadows/object/newbie_shoes.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shadows/object/newbie_shoes.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629121   Available: 13576475
Inodes: Total: 5242880    Free: 4960135
1343 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shadows/object/newbie_shoes.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629121   Available: 13576475
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: newbie_shoes.c,v 1.4 2001/02/25 09:04:59 shrike Exp $
 * $Log: newbie_shoes.c,v $
 * Revision 1.4  2001/02/25 09:04:59  shrike
 * changed the message slightly so that it makes more sense with the untying command.
 *
 * Revision 1.3  2000/01/03 10:13:23  taffyd
 * Fixes!
 *
 * Revision 1.2  1999/10/23 11:31:50  gerbil
 *  Forcibly unlocked by taffyd
 *
 * Revision 1.1  1998/01/06 04:40:23  ceres
 * Initial revision
 *
*/
#include <move_failures.h>

#include "path.h"

inherit "/std/effect_shadow";

int query_orthopaedic_shoes() { return 1; }

string query_msgin()
{
return "$N stagger$s clumsily from $F.";
}

string query_msgout()
{
return "$N stagger$s $T clumsily.";
}

int move(mixed dest, string inmsg, string outmsg)
{
  int ret;

  ret = player->move(dest, inmsg, outmsg);
  if (ret == MOVE_OK) {
    tell_object( player, "You wince as spikes seem to drive themselves "
      "into the balls of your feet, but you get there eventually.\n" );
  }
  return ret;
}

int test_for_effect( object thing ) {
   return member_array( EFFECTS +"newbie_shoes",
      (string *)thing->query_wear_effects() ) != -1;
} /* test_for_effect() */

void taken_off(object what, string eff)
{
  if (eff != EFFECTS + "newbie_shoes")
    player->taken_off(what, eff);
  else {
    remove_this_effect();
  }
}
// --- END [/mnt/home2/grok/lib/std/shadows/object/newbie_shoes.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shadows/object/identity_hold.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shadows/object/identity_hold.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629120   Available: 13576474
Inodes: Total: 5242880    Free: 4960135
3974 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shadows/object/identity_hold.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629120   Available: 13576474
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: identity_hold.c,v 1.10 2001/09/26 02:47:29 presto Exp $
 * $Log: identity_hold.c,v $
 * Revision 1.10  2001/09/26 02:47:29  presto
 * If either keep or identify is removed, then remove the shadow too
 *
 * Revision 1.9  2001/05/03 17:53:10  ceres
 * Fixed runtime
 *
 * Revision 1.8  2000/07/02 10:14:58  taffyd
 * Fixes for component pouch...
 *
 * Revision 1.7  2000/06/28 05:22:01  taffyd
 * Added query_full_identifier().
 *
 * Revision 1.6  2000/06/28 04:18:25  pinkfish
 * Fix it up to not get womelbed when people log in...
 *
 * Revision 1.5  2000/06/28 04:13:48  pinkfish
 * Fix it up when it is just used to keep something.
 *
 * Revision 1.4  2000/06/28 02:30:12  pinkfish
 * Fix up a typo in the object na,e.
 *
 * Revision 1.3  2000/06/28 00:20:37  pinkfish
 * Fix up the identity problems.
 *
 * Revision 1.2  2000/06/08 01:48:53  pinkfish
 * Fix up some stuff.
 *
 * Revision 1.1  1999/10/27 01:29:07  pinkfish
 * Initial revision
 *
 * Revision 1.3  1999/06/19 11:29:54  taffyd
 * Fixed runtime.
 *
 * Revision 1.2  1999/04/10 23:23:24  mansarde
 * Fixed the bug with the shadow being dested when you put something
 * into a container. now the shadow is only removed when the item
 * goes outside of the player.
 *
 * Revision 1.1  1998/01/06 04:40:23  ceres
 * Initial revision
 * 
 */
/**
 * Nothing in this shadow should be modified directly.  The shadow
 * should do it all for us.
 */
inherit "/std/effect_shadow";
#include <move_failures.h>

private int _keep;
private string _identifier;
private string* _adjs;
private object _owner;

int query_keep() { return _keep; }

void set_keep_value(int keep) { _keep = keep; }

void set_keep() { _keep = 1; }

void reset_keep() {
   _keep = 0;
   if (!_identifier)
      remove_this_effect();
}

string query_identifier() { return _identifier; }

/**
 * This is here to maintain compatibility with the magic spell effect
 * until it can be fixed.
 */
string query_full_identifier() {
    string tmp;

    tmp = "";

    if ( sizeof( _adjs ) ) {
        tmp += implode( _adjs, " " ) + " ";
    }

    if ( _identifier ) {
       tmp += _identifier;
    }

    if ( strlen( tmp ) > 0 ) {
       return tmp;
    }

    return 0;
} /* query_all_identifier() */
void set_identifier( string word ) {

   string* bits;

   if (word) {
      bits = explode(word, " ");
      _identifier = bits[<1];
      _adjs = bits[0..<2];
   } else {
      _identifier = 0;
      _adjs = ({ });
      if (!_keep)
         remove_this_effect();
   }
}

void set_identity_hold_owner(object ob) {
   _owner = ob;
} /* set_identity_hold_owner() */

object query_identity_hold_owner() {
   return _owner;
} /* query_identity_hold_owner() */

string *parse_command_id_list() {
   string *words;

   words = (string *)player->parse_command_id_list();
   if ( ( this_player() == _owner ) && stringp( _identifier ) &&
         !sizeof( filter_array( previous_object( -1 ),
         (: $1 && $1->ignore_identifier() :) ) ) ) {
      words += ({ _identifier });
   }
   return words;
} /* parse_command_id_list() */

string *parse_command_adjectiv_id_list() {
   string *words;

   words = (string *)player->parse_command_adjectiv_id_list();
   if ( ( this_player() == _owner ) && pointerp( _adjs ) &&
         !sizeof( filter_array( previous_object( -1 ),
         (: $1->ignore_identifier() :) ) ) ) {
      words += _adjs;
   }
   return words;
} /* parse_command_adjectiv_id_list() */

private void check_move_stuff() {
   object ob;

   ob = environment(player);
   while (ob &&
          ob != _owner) {
      ob = environment(ob);
   }

   if (ob != _owner) {
      remove_this_effect();
   }
} /* check_move_stuff() */

varargs int move( mixed dest, string messin, string messout ) {
   int flag;
    
   flag = player->move( dest, messin, messout );

   if ( flag == MOVE_OK &&
        objectp( dest ) ) {
      call_out((: check_move_stuff :), 2);
   }

   return flag;
} /* move() */
// --- END [/mnt/home2/grok/lib/std/shadows/object/identity_hold.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shadows/disease/flu_shadow.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shadows/disease/flu_shadow.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629119   Available: 13576473
Inodes: Total: 5242880    Free: 4960135
1402 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shadows/disease/flu_shadow.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629119   Available: 13576473
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: flu_shadow.c,v 1.1 1998/01/06 04:36:02 ceres Exp $
 * $Log: flu_shadow.c,v $
 * Revision 1.1  1998/01/06 04:36:02  ceres
 * Initial revision
 * 
*/
inherit "/std/effect_shadow";

string *soulverb;
string *souladverb;

int query_flu(){ return 1; }

/* Flu functions */

string flusoul(){
   string flu;
   soulverb = ({"sneeze",
                "cough"
   });
   souladverb = ({"violently",
                "loudly",
                "suddenly"
   });

this_player()->force_soul_command(soulverb[random(sizeof(soulverb))]+" "+souladverb[random(sizeof(souladverb))]);
   return flu;
}

/* trapped functions */

int look_me(string arg){
   if(!arg){
      if (random(100) > 30){
         tell_object(player, "You feel dizzy and bleary eyed.\n");
      }
      else{
         player->look_me();
      }
      return 1;
   }
   return 1;
}

int attack_ob(object obj){
   object *contents;
   object target;

   if(random(100) > 30){
      tell_object(player, "You feel too ill, and can't be bothered to attack.\n");
      return 1;
   }
   player->attack_ob(target);
   return 1;
}


int cast(string str){
   if(random(100) > 50){
      tell_object(player, "You lose your concentration as you feel a "+
                          "sneeze coming on.\n");
      this_player()->force_soul_command("sneeze");
      return 1;
   }
   player->cast(str);
   return 1;
}
// --- END [/mnt/home2/grok/lib/std/shadows/disease/flu_shadow.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shadows/disease/headache_shadow.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shadows/disease/headache_shadow.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629118   Available: 13576472
Inodes: Total: 5242880    Free: 4960135
552 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shadows/disease/headache_shadow.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629118   Available: 13576472
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**This is the shadow object for the headache effect.  It
 * handles the inability to cast and do special manoeuvres.
 */

inherit "/std/effect_shadow";

/**
 *@ignore yes
 */
int query_special_manoeuvre() {
   tell_object(player, "Your head hurts too much to try anything.\n");
   return 0;
} /* query_special_manoeuvre() */

/**
 *@ignore yes
 */
int command_shadowed(string verb, string arg){
   if(verb=="cast"){
     write("Your head hurts too much to muster your might.\n");
     return 1;
   }
   return player->command_shadowed(verb, arg);
} 

// --- END [/mnt/home2/grok/lib/std/shadows/disease/headache_shadow.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shadows/curses/alone.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shadows/curses/alone.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629118   Available: 13576472
Inodes: Total: 5242880    Free: 4960135
276 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shadows/curses/alone.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629118   Available: 13576472
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: alone.c,v 1.1 1998/01/06 04:35:35 ceres Exp $
 * $Log: alone.c,v $
 * Revision 1.1  1998/01/06 04:35:35  ceres
 * Initial revision
 * 
*/
inherit "/std/effect_shadow";

int query_blinded() {
   return 1; 
} /* query_blinded() */

// --- END [/mnt/home2/grok/lib/std/shadows/curses/alone.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shadows/curses/ken_curse.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shadows/curses/ken_curse.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629118   Available: 13576472
Inodes: Total: 5242880    Free: 4960135
6213 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shadows/curses/ken_curse.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629118   Available: 13576472
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: ken_curse.c,v 1.1 1998/01/06 04:35:35 ceres Exp $
 * $Log: ken_curse.c,v $
 * Revision 1.1  1998/01/06 04:35:35  ceres
 * Initial revision
 * 
*/
/*
 * Converted to effects system by Jeremy, 7-Jun-96
 */

inherit "/std/effect_shadow";

string *replace_matrix;
mapping trans;

void create() {  
  replace_matrix = ({ 
  "Aren't you ", "Aintcha ",
  "aren't you ", "aintcha ",
  "You are", "Yer ",
  "you are ", "yer ",
  "Are not ", "Ain't",
  "are not ", "ain't ",
  "Is not ", "Ain't ",
  " is not ", " ain't ",
  "What is ", "Woss",
  "what is ", "woss",
  "What are you ", "Wotcher ",
  "what are you ", "wotcher ",
  "What you are", "Wotcher",
  "what you are", "wotcher",
  "What you're", "Wotcher",
  "what you're", "wotcher",
  "What are your", "Wotcher",
  "what are your", "wotcher",
  "What do you ", "Wotcher ",
  "what do you ", "wotcher ",
  "What do your", "Wotcher",
  "what do your", "wotcher",
  "a h", "an '",
  "A h", "An '",
  " h", " '",
  " H", " '",
  "Th", "F",
  "Wh", "W",
  "wh", "w",
  "aw", "or",
  "ing ", "in' ",
  " th", " f",
  "th", "ff",
  ".", " .",
  "?", " ?",
  "!", " !",
  });

  trans = ([ ]);
  trans["stairs"] = "apples and pears";
  trans["Downstairs"] = "Down the apples and pears";
  trans["downstairs"] =	"down the apples and pears";
  trans["Upstairs"] = "Up the apples and pears";
  trans["upstairs"] = "up the apples and pears";
  trans["mouth"] = "North and South";
  trans["Mouth"] = "North and South";
  trans["Face"] = "Boat Race";
  trans["face"] = "Boat Race";
  trans["Trouble"] = "Barney Rubble";
  trans["trouble"] = "Barney Rubble";
  trans["wife"] = ({ "trouble and strife", "ole lady" });
  trans["Road"] = "Frog and Toad";
  trans["road"] = "frog and toad";
  trans["pub"] = "rub-a-dub ";
  trans["bar"] = "boozer";
  trans["husband"] = "ole man";
  trans["Party"] = "Knees-up";
  trans["party"] = "knees-up";
  trans["Parties"] = "Knees-ups";
  trans["parties"] = "knees-ups";
  trans["My"] = "Me";
  trans["my"] = "me";
  trans["Your"] = "Yer";
  trans["your"] = "yer";
  trans["You"] = "Yer";
  trans["you"] = "yer";
  trans["Those"] = "Them";
  trans["those"] = "them";
  trans["those"] = "them";
  trans["(those"] = "(them";
  trans["The"] = ({ "The bleedin'", "The" });
  trans["Fe"] = ({ "The bleedin'", "The" });
  trans["the"] = ({ "the bleedin'", "the" });
  trans["fe"] = ({ "the bleedin'", "the" });
  trans["Thus"] = "So";
  trans["thus"] = "so";
  trans["(thus"] = "(so";
  trans["thus"] = "so";
  trans["old"] = "ole";
  trans["to"] = "ter";
  trans["Aren't"] = "Ain't";
  trans["aren't"] = "ain't";
  trans["Isn't"] = "Ain't";
  trans["isn't"] = "ain't";
  trans["Hallo"] = "Wotcher";
  trans["Hello"] = "Wotcher";
  trans["Hullo"] = "Wotcher";
  trans["Hi"] = "Wotcher";
  trans["hallo"] = "wotcher";
  trans["hello"] = "wotcher";
  trans["hullo"] = "wotcher";
  trans["hi"] = "wotcher";
  trans["What"] = "Wot";
  trans["what"] = "wot";
  trans["Were"] = "Was";
  trans["were "] = "was";
  trans["Bother"] = "Ars";
  trans["bother"] = "ars";
  trans["Mother"] = "Muvver";
  trans["Other"] = "Uvver";
  trans["other"] = "uvver";
  trans["Father"] = "Favver";
  trans["father"] = "favver";
  trans["Rather"] = "Ravver";
  trans["rather"] = "ravver";
  trans["Weather"] = "Wevver";
  trans["weather"] = "wevver";
  trans["Leather"] = "Levver";
  trans["leather"] = "levver";
  trans["Wither"] = "Wivver";
  trans["wither"] = "wivver";
  trans["Either"] = "Eever";
  trans["either"] = "eever";
  trans["With"] = "Wiv";
  trans["with"] = "wiv";
  trans["Anything"] = "Anyfink";
  trans["anything"] = "anyfink";
  trans["Something"] = "Sumfink";
  trans["something"] = "sumfink";
  trans["Nothing"] = "Nuffink";
  trans["nothing"] = "nuffink";
  trans["guitars"] = "spoons";
  trans["guitar"] = "spoons";
  trans["drums"] = "spoons";
  trans["drum"] = "spoons";
  trans["trumpets"] = "spoons";
  trans["trumpet"] = "spoons";
  trans["violins"] = "spoons";
  trans["violin"] = "spoons";
  trans["clarinets"] = "spoons";
  trans["clarinet"] = "spoons";
  trans["trombones"] = "spoons";
  trans["trombone"] = "spoons";
  trans["oboes"] = "spoons";
  trans["oboe"] = "spoons";
  trans["flutes"] = "spoons";
  trans["flute"] = "spoons";
  trans["tubas"] = "spoons";
  trans["tuba"] = "spoons";
  trans["Data"] = "Info";
  trans["data"] = "info";
  trans["Directory"] = "Lockup";
  trans["directory"] = "lockup";
  trans["Directories"] = "Lockups";
  trans["directories"] = "lockups";
  trans["Stopped"] = "'Ad the mockers put on";
  trans["stopped"] = "'ad the mockers put on";
  trans["Stopping"] = "Putting the mockers on";
  trans["stopping"] = "putting the mockers on";
  trans["stops"] = "puts the mockers on";
  trans["stop"] = "put the mockers on";
  trans["STOP"] = "Put The Mockers On";
  trans["Londoner"] = "Cockney";
  trans["londoner"] = "Cockney";
  trans["friend"] = ({ "mucker", "mate", "china" });
  trans["sin'"] = "sing";
  trans["rin'"] = "ring";
} /* trans() */

string mangle_speech(string str) {
  string tmp, *bits;
  mixed erp;
  int i;

  tmp = player->mangle_speech( str );
  tmp = replace(" "+(stringp(tmp)?tmp:str)+" ", replace_matrix);
  bits = explode(tmp, " ");
  for (i=0;i<sizeof(bits);i++) {
    if (erp = trans[bits[i]])
      if (stringp(erp))
        bits[i] = erp;
      else
        bits[i] = erp[random(sizeof(erp))];
  }
  tmp = implode(bits, " ");
  while (tmp[strlen(tmp)-1] == ' ')
    tmp = tmp[0..strlen(tmp)-2];
  switch (tmp[strlen(tmp)-1]) {
    case '?' :
      tmp = tmp[0..strlen(tmp)-3]+ ({ ", mate? ", ", guv? ",
                                      ", squire? " })[random(3)];
      break;
    case '!' :
      tmp = tmp[0..strlen(tmp)-3]+ ({ ", cor blimey!", "! Struth!",
		    ", guv!", " ! Honest guv!", ", mate! ", "!", })[random(6)];
      break;
    case '.' :
      tmp = tmp[0..strlen(tmp)-3];
    default :
      tmp += ({
		    ". I'll get out me spoons. ",
		    ". Yer can't 'ave a knees-up wivout a joanna. ",
		    ". Cor blimey guv, would I lie to you. ",
		    ". I'll make us all a nice cup of tea. ",
               })[random(4)];
  }
  return replace(tmp, ({ " !", "!", " .", ".", " ?", "?" }));
} /* mangle_speech() */
// --- END [/mnt/home2/grok/lib/std/shadows/curses/ken_curse.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shadows/curses/ensmurfed.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shadows/curses/ensmurfed.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629116   Available: 13576470
Inodes: Total: 5242880    Free: 4960135
2198 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shadows/curses/ensmurfed.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629116   Available: 13576470
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: ensmurfed.c,v 1.1 1998/01/06 04:35:35 ceres Exp $
 * $Log: ensmurfed.c,v $
 * Revision 1.1  1998/01/06 04:35:35  ceres
 * Initial revision
 * 
*/
inherit "/std/effect_shadow";

varargs string short(int dark) {
   if (player)
     return player->short(dark)+"smurf"; 
   return "Smurf curse shadow";
}

mixed query_short() { return player->query_short()+"smurf"; }
mixed query_long() { return "This is a small blue humanoid.\n"; }

/* childrens cartoon characters don't have sex */
int query_female() { return 0; }
int query_gender() { return 0; }
int query_male() { return 0; }
int query_neuter() { return 1; }
string query_gender_string() { return "smurf"; }
string query_gender_title() { return "smurf"; }
string query_objective() { return "it"; }
string query_possessive() { return "its"; }
string query_pronoun() { return "it"; }

string long(string str, int dark) {
   string s, guild_ob;
   
   s = "You see "+ query_short();
   guild_ob = player->query_guild_ob();
   if (guild_ob)
      s += " "+ (string)guild_ob->query_title( this_object() ) +".\n";
   else
      s += ".\n";
   s += "It is a small blue humanoid wearing white trousers.\n";
   s += capitalize(query_pronoun())+" "+player->health_string()+".\n";
   s += player->calc_extra_look();
   s += player->weather_extra_look();
   s += player->query_living_contents(0);
   return s;
}

string smurf( string str ) {
   string str1;
   
   if ( sscanf( str, "%s,", str ) ) str1 = ",";
   else if ( sscanf( str, "%s.", str ) ) str1 = ".";
   else if ( sscanf( str, "%s!", str ) ) str1 = "!";
   else if ( sscanf( str, "%s;", str ) ) str1 = ";";
   else str1 = "";
   if ( sscanf( str, "%sing", str ) ) str = "smurfing";
   else if ( sscanf( str, "%sd", str ) ) str = "smurfed";
   else if ( sscanf( str, "%ss", str ) ) str = "smurfs";
   else str = "smurf";
   return str + str1;
}

string mangle_speech( string str ) {
   string tmp, *bits;
   int i;

   tmp = player->mangle_speech( str );
   if( !tmp ) tmp = str;
   bits = explode(tmp, " ");
   for (i=1;i<sizeof(bits);i+=3) {
      bits[i] = smurf( bits[i] );
   }
   tmp = implode(bits, " ");
   return tmp;
} /* mangle_speech() */
// --- END [/mnt/home2/grok/lib/std/shadows/curses/ensmurfed.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shadows/curses/antisqeal.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shadows/curses/antisqeal.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629115   Available: 13576469
Inodes: Total: 5242880    Free: 4960135
661 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shadows/curses/antisqeal.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629115   Available: 13576469
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* Antisqeal - Stolen from the chef curse by terano, add them as you think of 
 * them :)
 * 
 */

inherit "/std/effect_shadow";

string *replace_matrix =  ({
"kewl", "cool",
"l33t", "elite",
" ur ", "your",
" r ", " are ",
" u ", " you ",
" y ", " why ",
"2", "two",
"4", "for",
"sum", "some",
"wut", "what",
"z", "s",
"Z", "s",
"k", "c",
"K", "c",
"wif", "with",
"werk", "work" });

#ifdef 0
string mangle_speech( string s ) {
    string s1;

    s1 = player->mangle_speech( s ); return replace( " " + (stringp(s1)?s1:s), 
    replace_matrix)[1..10000]; }
/* mangle_speech() */
#endif

string mangle_chat( string s ) {
  return replace(s, replace_matrix);
}

// --- END [/mnt/home2/grok/lib/std/shadows/curses/antisqeal.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shadows/curses/chef_curse.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shadows/curses/chef_curse.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629115   Available: 13576469
Inodes: Total: 5242880    Free: 4960135
1023 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shadows/curses/chef_curse.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629115   Available: 13576469
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: chef_curse.c,v 1.1 1998/01/06 04:35:35 ceres Exp $
 * $Log: chef_curse.c,v $
 * Revision 1.1  1998/01/06 04:35:35  ceres
 * Initial revision
 * 
*/
/* chef.x - convert English on stdin to Mock Swedish on stdout
 *
 * HISTORY
 *
 * Apr 15, 1992; John Hagerman: Created.
 */
/*
 * Taken from the above and converted into lpc by Pinkfish.
 * Converted to effects sytem by Jeremy, 5-Jun-96
 */

inherit "/std/effect_shadow";

string *replace_matrix =  ({
"the", "zee",
"The", "Zee",
"ir", "ur",
"ow", "oo",
"th", "t",
"au", "oo",
"Au", "Oo",
"u", "oo",
"U", "Oo",
"tion", "shun",
"an", "un",
"An", "Un",
"en ", "ee ",
"ew", "oo",
"a", "e*",
"A", "E*",
"e* ", "e ",
"E* ", "E ",
"e*", "e",
"E*", "E",
"e ", "e-a ",
"f", "ff",
" o", " oo",
" O", " Oo",
"v", "f",
"V", "F",
"w", "v",
"W", "V", });

string mangle_speech( string s ) {
    string s1;

    s1 = player->mangle_speech( s );
    return replace( " " + (stringp(s1)?s1:s), replace_matrix)[1..10000];
} /* mangle_speech() */
// --- END [/mnt/home2/grok/lib/std/shadows/curses/chef_curse.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shadows/curses/no_player_title.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shadows/curses/no_player_title.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629114   Available: 13576468
Inodes: Total: 5242880    Free: 4960135
604 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shadows/curses/no_player_title.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629114   Available: 13576468
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <effect.h>

inherit "/std/effect_shadow";

varargs int add_property(string var, mixed val, int tim) {      
    if ( var == "player_title" ) {
        tell_object( player, "You are not allowed to have a player title.\n" );
        return 0;
    }

    return player->add_property( var, val, tim );
} /* add_property() */

mixed query_property( string prop ) {
    if ( prop == "player_title" ) {
        return 0;
    }

    return player->query_property( prop );
} /* query_property() */

void bing() { 
player->submit_ee2( player->sid_to_enum( id ), "spam", 5, EE_CONTINUOUS );
} /* bing() */
// --- END [/mnt/home2/grok/lib/std/shadows/curses/no_player_title.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shadows/curses/deaf_shadow.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shadows/curses/deaf_shadow.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629114   Available: 13576468
Inodes: Total: 5242880    Free: 4960135
1381 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shadows/curses/deaf_shadow.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629114   Available: 13576468
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: deaf_shadow.c,v 1.1 1998/01/06 04:35:35 ceres Exp $
 * $Log: deaf_shadow.c,v $
 * Revision 1.1  1998/01/06 04:35:35  ceres
 * Initial revision
 * 
*/
inherit "/std/effect_shadow";

#include "effect.h"

void event_whisper(object ob, string start, string mess, object *d, string lang) {
   int i;

   i = (int)arg() / 2;
   if (random(100) < i) {
      player->event_whisper(ob, start, mess, d, lang);
   } else {
      player->add_message(ob, "$N %hiss% something at you, but you just "+
"can't make it out.\n", 1);
   }
}

void event_person_say(object ob, string start, string mess, string lang) {
   string dum1, dum2;
   if (sscanf(start, "%sloud%s", dum1, dum2)) {
      if (random(100) > (100 - (int)arg()) / 2) {
         player->event_person_say(ob, start, mess, lang);
      } else {
         player->add_message(ob, "$N say$s something loudly, but "+
"you fail to hear it properly.\n", 1);
      }
   } else {
      if (random(100) < arg()) {
         player->event_person_say(ob, start, mess, lang);
      } else {
         player->add_message(ob, "$N say$s something, but you just can't "+
   "hear it properly.\n", 1);
      }
   }
}

void event_person_say_new(object ob, string start, string mess, string lang, 
  mixed avoid) {
   tell_object(player, sprintf("New Say: %O %O %O %O %O\n", ob, start, mess, lang, avoid));
}
// --- END [/mnt/home2/grok/lib/std/shadows/curses/deaf_shadow.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shadows/room/terrain_dont_unload.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shadows/room/terrain_dont_unload.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629113   Available: 13576467
Inodes: Total: 5242880    Free: 4960135
275 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shadows/room/terrain_dont_unload.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629113   Available: 13576467
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/effect_shadow";

#define BP tell_object( find_player("gerbil"), "BP.\n");

int i;

int dont_free() {return 1;}

void setup_shad() {
    i++;
}

string test_my_effect() {return "Yup!";}

void ditch_room() {
    if( !--i ) {
        remove_this_effect();
    }
}
// --- END [/mnt/home2/grok/lib/std/shadows/room/terrain_dont_unload.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shadows/room/hat_tent.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shadows/room/hat_tent.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629113   Available: 13576467
Inodes: Total: 5242880    Free: 4960135
467 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shadows/room/hat_tent.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629113   Available: 13576467
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This shadow is supposed to keep the room outside a hat
 * tent from unloading.
 */

inherit "/std/effect_shadow";

/* Make sure the outside room is not unloaded */
/** @ignore */
int query_keep_room_loaded() {
   return 1;
}

/** @ignore */
int dont_free() {
   return 1;
}

/** @ignore */
int clean_up() {
   return 1;
}

/**
 * This method should be called when a tent is collapsed.
 */
void tent_collapsed() {
   remove_this_effect();
} // tent_collapsed()
// --- END [/mnt/home2/grok/lib/std/shadows/room/hat_tent.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shadows/npc/spell_effects.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shadows/npc/spell_effects.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629113   Available: 13576467
Inodes: Total: 5242880    Free: 4960135
522 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shadows/npc/spell_effects.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629113   Available: 13576467
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: spell_effects.c,v 1.1 1998/01/06 04:39:52 ceres Exp $
 * $Log: spell_effects.c,v $
 * Revision 1.1  1998/01/06 04:39:52  ceres
 * Initial revision
 * 
*/
inherit "/std/effect_shadow";

void do_spell_effects(object ob) {
   mixed *bit;
   int ret;

   bit = arg();
   if (functionp(bit)) {
      ret = evaluate(bit, player, ob);
   } else if (pointerp(bit)) {
      ret = call_other(bit[0], bit[1], player, ob);
   }
   player->do_spell_effects(ob);
} /* do_spell_effects() */
// --- END [/mnt/home2/grok/lib/std/shadows/npc/spell_effects.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shadows/npc/eat_corpse.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shadows/npc/eat_corpse.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629113   Available: 13576467
Inodes: Total: 5242880    Free: 4960135
2201 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shadows/npc/eat_corpse.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629113   Available: 13576467
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/effect_shadow";

/** @ignore */
mixed move( mixed dest, string messin, string messout ) {
   int ret;

   ret = player->move( dest, messin, messout );
   if( ret == 0 ) {
      call_out( "find_corpse", 0 );
   }

   return ret;
} /* move() */

/** @ignore */
string *query_valid_bits( object corpse ) {
   object race_obj;
   string *edible_bits;

   if( !corpse )
      return ({ });

   if( !corpse->query_corpse() )
      return ({ });

   edible_bits = corpse->query_edible_bits_left();
   if( !sizeof( edible_bits ) )
      return ({ });

   race_obj = corpse->query_race_ob();
   if( !race_obj )
      return ({ });

   return filter( edible_bits,
                  (: sizeof( $(race_obj)->query_bit($1)[2] ) == 3 :) );
} /* query_valid_bits() */

/** @ignore */
protected void find_corpse() {
   object ob, *obs;

   obs = all_inventory( environment(player) );

   foreach( ob in obs ) {
      if( sizeof( query_valid_bits(ob) ) ) {
         remove_call_out( "eat_corpse" );
         call_out( "eat_corpse", 1 + random(120), ob );
         break;
      }
   }
} /* find_corpse() */

/** @ignore */
protected void eat_corpse( object corpse ) {
   string which_bit;
   string *valid_bits;

   if( !corpse ) {
      call_out( "find_corpse", 1 + random(2*60) );
      return ;
   }

   valid_bits = query_valid_bits( corpse );

   if( sizeof( valid_bits ) && environment(corpse) == environment(player) ) {
      which_bit = valid_bits[ random( sizeof( valid_bits ) ) ];
      corpse->add_bit_gone( which_bit );

      tell_room( environment( player ), "$C$" + player->the_short() +
         " tears the " + which_bit + " from " + corpse->the_short() + " and "
         "begins eating.\n" );
   }

   if( sizeof( valid_bits ) > 1 ) {
      remove_call_out( "eat_corpse" );
      call_out( "eat_corpse", 1 + random(2*60), corpse );
   } else {
      call_out( "find_corpse", 1 + random(2*60) );
   }
} /* eat_corpse() */

/** @ignore */
void event_enter( object ob, string mess, object from ) {
   player->event_enter( ob, mess, from );

   if( sizeof( query_valid_bits(ob) ) ) {
      remove_call_out( "eat_corpse" );
      call_out( "eat_corpse", 10, ob );
   }
} /* event_enter() */
// --- END [/mnt/home2/grok/lib/std/shadows/npc/eat_corpse.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shadows/npc/sell_stuff.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shadows/npc/sell_stuff.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629112   Available: 13576466
Inodes: Total: 5242880    Free: 4960135
1183 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shadows/npc/sell_stuff.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629112   Available: 13576466
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: sell_stuff.c,v 1.1 1998/01/06 04:39:52 ceres Exp $
 * $Log: sell_stuff.c,v $
 * Revision 1.1  1998/01/06 04:39:52  ceres
 * Initial revision
 * 
*/
/*
 * The sell stuff shadow.
 */
inherit "/std/effect_shadow";

void stopped_route() {
  object *obs;
  int i;
  mixed room;

  room = arg();

  if (pointerp(room)) {
    room = room[0];
  }

  if (file_name(environment(player)) == room) {
    /* Sell stuff... */
    obs = all_inventory(player);
    for (i=0;i<sizeof(obs);i++) {
      if (!obs[i]->query_property("start equipment"))
        call_out("sell_the_stuff", 1, obs[i]);
        call_out( "drop_the_stuff", 2, obs[ i ] );
    }
    call_out( "bury_the_stuff", 3, query_multiple_short( obs ) );
  }
  call_out("remove_this_effect", 4);
} /* stopped_route() */

protected void sell_the_stuff(object ob) {
  player->do_command("sell "+ob->query_name());
} /* sell_the_stuff() */

protected void drop_the_stuff( object thing ) {
   player->do_command( "drop "+ (string)thing->query_name() );
} /* drop_the_stuff() */

protected void bury_the_stuff( string words ) {
   player->do_command( "bury "+ words );
} /* bury_the_stuff() */
// --- END [/mnt/home2/grok/lib/std/shadows/npc/sell_stuff.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shadows/npc/uu_staff_protection.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shadows/npc/uu_staff_protection.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629111   Available: 13576465
Inodes: Total: 5242880    Free: 4960135
2220 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shadows/npc/uu_staff_protection.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629111   Available: 13576465
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/** 
 *   A shadow for the wizards_protection effect.
 *   @author Rodion
 */


inherit "/std/effect_shadow";

// The Punishment Handler.
#define HANDLER "/obj/handlers/guild_things/punishment_handler"

// A dummy array, just in case the proper arguments aren't passed.
mixed info = ({":thinks you should contact a creator. Something is wrong.", 
     ":thinks you should contact a creator. Something is wrong.", 
     ":thinks you should contact a creator. Something is wrong.", 0});


/* Shadowing attack_by to find when the NPC is attacked, then calling the 
  necessary punishment functions.  This also sets a timed property on the 
  attacker, because for some reason attack_by is called every round.
  The property lasts for 15 minutes.  If a fight lasts longer than that,
  the player could potentially be punished twice.  That's life.
*/
/** @ignore */
int attack_by(object thing){
      info = arg();
      if(!thing->query_property("player")){
         return 1;
      }
      if(thing->query_property("Wizard attack") != player->query_name()){
         if(info[0] != 0)
            player->do_command(info[0]);
         if(info[3] <= 0)
            info[3] = 1;
         
         HANDLER->add_offender(thing->query_name(), "attacking "+ 
            player->the_short(), info[3]);
         thing->add_property("Wizard attack", player->query_name(), 600);
   }
   return 1;
}

/* Shadowing event_enter in order to punish offenders.  If YOU saw someone
   who assaulted you, you'd call for guards too.
   This checks the handler to see if they're an offender, then calls for 
   the guards.
*/
/** @ignore */
void event_enter(object ob, string mess, object from){
      string name = ob->query_name();
      int bing;
      if(!ob->query_property("player")){
         return;
      }
      bing = (HANDLER->query_no_offences(name));
      info = arg();
      if(bing){
         if(info[1] != 0)
            player->init_command(info[1], 1);
         if(HANDLER->query_unpunished(name)){
            if(info[2] != 0)
               player->init_command(info[2], 1);
            HANDLER->punishment(name);
         }
      }
    
     player->event_enter(ob, mess, from);
}

/*A SkankyCode Creation, by Rodion*/
// --- END [/mnt/home2/grok/lib/std/shadows/npc/uu_staff_protection.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shadows/npc/vampirebite_shadow.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shadows/npc/vampirebite_shadow.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629111   Available: 13576465
Inodes: Total: 5242880    Free: 4960135
1316 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shadows/npc/vampirebite_shadow.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629111   Available: 13576465
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* Lemming, 03/07/2000 */


inherit "/std/effect_shadow";

object vamp_corpse( object corpse ) {
   string player_name;

   if( corpse && objectp( corpse )
       && !corpse->query_property( "vampire corpse" )
       && corpse->query_race_name() == "human" ) {
      corpse->add_property( "no burial", 1 );
      corpse->add_property( "vampire corpse", 1 );

      if( stringp( player->query_property( "determinate" ) ) )
         player_name = player->query_property( "determinate" ) +
            player->query_short();
      else
         player_name =
            "/global/events"->convert_message( player->a_short() );

      corpse->add_effect( "/std/effects/npc/vampirecorpse_effect",
         ({ player_name, copy( player->query_gender() ),
            copy( player->query_level() ), 0 }) );
   }

   return corpse;
} /* vamp_corpse() */

varargs object do_death( object thing, object weapon, string attack ) {
   int *effs;
   object corpse;

   effs = player->effects_matching( "body.bite.vampire" );
   call_out( "remove_this_effect", 2 );

   corpse = player->do_death( thing, weapon, attack );
   vamp_corpse( corpse );

   return corpse;
} /* do_death() */

object make_corpse() {
   object corpse;

   corpse = player->make_corpse();
   vamp_corpse( corpse );

   return corpse;
} /* make_corpse() */
// --- END [/mnt/home2/grok/lib/std/shadows/npc/vampirebite_shadow.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shadows/npc/eat_edible.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shadows/npc/eat_edible.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629110   Available: 13576464
Inodes: Total: 5242880    Free: 4960135
1239 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shadows/npc/eat_edible.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629110   Available: 13576464
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: eat_edible.c,v 1.2 1998/02/20 05:55:47 pinkfish Exp $
 * $Log: eat_edible.c,v $
 * Revision 1.2  1998/02/20 05:55:47  pinkfish
 * Fixed a runtime error and made it more ribust by using
 * function points for the function calls.
 *
 * Revision 1.1  1998/01/06 04:39:52  ceres
 * Initial revision
 * 
*/
/*
 * The eat edible objects shadow.
 */
inherit "/std/effect_shadow";

protected void real_eat(object ob);
protected void do_eat_edible();

mixed move(mixed dest, string messin, string messout) {
  int ret;

  ret = player->move(dest, messin, messout);
  if (ret == 0) {
    call_out((: do_eat_edible :), 0);
  }
  return ret;
} /* move() */

protected void do_eat_edible() {
  int i;
  object *obs;

  obs = all_inventory(player);
  for (i=0;i<sizeof(obs);i++) {
    if (obs[i]->query_edible()) {
      call_out((: real_eat :), 1, obs[i]);
    }
  }
} /* do_eat_edible() */

protected void real_eat(object ob) {
  if (ob && player) {
    player->do_command("eat "+ob->query_name());
  }
} /* real_eat() */

void event_enter(object ob, string mess, object from) {
  player->event_enter(ob, mess, from);
  if (ob->query_edible()) {
    call_out("real_eat", 2, ob);
  }
} /* event_enter() */
// --- END [/mnt/home2/grok/lib/std/shadows/npc/eat_edible.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shadows/npc/ngood_fighter.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shadows/npc/ngood_fighter.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629110   Available: 13576464
Inodes: Total: 5242880    Free: 4960135
14270 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shadows/npc/ngood_fighter.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629110   Available: 13576464
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/**
 * The Good Fighter shadow.  The main docs are stored in the effect
 * header file, not here...  Mostly for standardisation reasons.
 *
 * @see /std/effects/npc/good_fighter
 *
 * @author Sin
 * @created 12 November 1997
 * @changed 13 November 1997 -- Sin
 *     Converted it from a pure shadow to a shadow/effect pair
 * @changed 11 April 1998 -- Sin
 *     Added support for USE_UNARMED.
 *     God rid of some dead wood.
 * @changed 12 April 1998 -- Sin
 *     Added support for crush
 * @changed 3 August 2002 -- Rhinehold
 *     Converted to work with new non-effect combat system
 *     Added support for behead, pierce, bash, smash, chop
 *     Removed strike
 */

#include <good_fighter.h>

#define LOGFILE "good_fighter"
#define CMDS "/cmds/guild-race/fighting/"

#define DEBUG

inherit "/std/effect_shadow";

#define W_ATTACKS ([ "crush"   : "crush $N with $W", \
                     "behead"  : "behead $N with $W", \
                     "impale"  : "impale $N with $W", \
                     "riposte" : "riposte $N with $W", \
                     "stab"    : "stab $N with $W", \
                     "pierce"  : "pierce $N with $W", \
                     "bash"    : "bash $N with $W", \
                     "smash"   : "smash $N with $W", \
                     "slash"   : "slash $N with $W", \
                     "slice"   : "slice $N with $W", \
                     "hack"    : "hack $N with $W", \
                     "chop"    : "chop $N with $W", \
                     "feint"   : "feint at $N with $W" ])
#define U_ATTACKS ([ "trip"    : "trip $N", \
                     "shove"   : "shove $N" ])
                   
string *specials;
mapping weapons;
int bluntorsharp;
int dodgeorparry;
object victim;

/**
 * @ignore
 * Used only to insure that the specials array is actually an array at
 * all times.
 */
void create()
{
  specials = ({ });
  weapons = ([ ]);
}

/**
 * This is a helper function used by the good_fighter_setup() function to
 * ensure that the specified skill is at least at a particular level.
 *
 * @param skill The skill to check
 *
 * @param level The minimum acceptable level for this skill
 */
protected void check_skill(string skill, int level)
{
  int cur;

  cur = player->query_skill(skill);
  if (cur < level)
    player->add_skill_level(skill, level - cur);
}

/**
 * This helper function is used by good_fighter_setup() to add a known
 * command to the NPC's repertoire _only_ if the relevant skill is above
 * a certain level.  If the command is added, then it is also stored in the
 * specials[] array for later use by fight_in_progress()
 *
 * @param command The command to be added
 *
 * @param skill The skill that controls the NPC's effectiveness with this
 * command.
 *
 * @param level The minimum level before the command can be added.
 */
protected void check_add_command(string command, string skill, int level)
{
  int cur;

  cur = player->query_skill(skill);
  if (cur >= level) {
    player->add_known_command(command);
    specials += ({ command });
  }
}

/**
 * This function is called from a callout() registered when setup_shadow()
 * is called.  It is responsible for ensuring that all of the NPC's skills
 * are at a reasonable level, that the NPC has the commands appropriate
 * for its priorities and level, and that the tactics are set appropriately.
 */
void good_fighter_setup()
{
  int adjust;
  int lvl;
  int *args = arg();

  if (!args || !arrayp(args) || sizeof(args) != 2)
    return;

  specials = ({ });
  bluntorsharp = args[0];
  dodgeorparry = args[1];

  lvl = player->query_level();
  check_skill("other.perception", lvl / 2);
  check_skill("other.health", lvl);
  adjust = lvl * 3 / 4;
  if (bluntorsharp == USE_PIERCE) {
    check_skill("fighting.combat.melee.blunt", lvl - adjust);
    check_skill("fighting.combat.melee.sharp", lvl - adjust);
    check_skill("fighting.combat.melee.pierce", lvl + adjust);
    check_skill("fighting.combat.melee.unarmed", lvl - adjust);
  } else if (bluntorsharp == USE_BLUNT) {
    check_skill("fighting.combat.melee.blunt", lvl + adjust);
    check_skill("fighting.combat.melee.sharp", lvl - adjust);
    check_skill("fighting.combat.melee.pierce", lvl - adjust);
    check_skill("fighting.combat.melee.unarmed", lvl - adjust);
  } else if (bluntorsharp == USE_SHARP) {
    check_skill("fighting.combat.melee.blunt", lvl - adjust);
    check_skill("fighting.combat.melee.sharp", lvl + adjust);
    check_skill("fighting.combat.melee.pierce", lvl - adjust);
    check_skill("fighting.combat.melee.unarmed", lvl - adjust);
  } else if (bluntorsharp == USE_UNARMED) {
    check_skill("fighting.combat.melee.blunt", lvl - adjust);
    check_skill("fighting.combat.melee.sharp", lvl - adjust);
    check_skill("fighting.combat.melee.pierce", lvl - adjust);
    check_skill("fighting.combat.melee.unarmed", lvl + adjust);
  } else {
    check_skill("fighting.combat.melee.blunt", lvl);
    check_skill("fighting.combat.melee.sharp", lvl);
    check_skill("fighting.combat.melee.pierce", lvl);
    check_skill("fighting.combat.melee.unarmed", lvl);
  }

  adjust = lvl * 2 / 3;
  if (dodgeorparry == DEFEND_DODGE) {
    check_skill("fighting.combat.dodging", lvl + adjust);
    check_skill("fighting.combat.parry", lvl - adjust);
    player->init_command("tactics response dodge", 1);
  } else if (dodgeorparry == DEFEND_PARRY) {
    check_skill("fighting.combat.dodging", lvl - adjust);
    check_skill("fighting.combat.parry", lvl + adjust);
    player->init_command("tactics response parry", 1);
  } else {
    check_skill("fighting.combat.dodging", lvl);
    check_skill("fighting.combat.parry", lvl);
    player->init_command("tactics response neutral", 1);
  }
  check_skill("fighting.combat.special", lvl / 2);
  check_skill("fighting.points", lvl * 2);

  player->init_command("tactics attitude offensive", 1);

  if (bluntorsharp != USE_BLUNT) {
    if (dodgeorparry == DEFEND_PARRY)
      check_add_command("riposte", "fighting.combat.special", 15);
    if (bluntorsharp == USE_SHARP) {
      check_add_command("hack", "fighting.combat.special", 15);
      check_add_command("slash", "fighting.combat.special", 15);
      check_add_command("slice", "fighting.combat.special", 75);
      check_add_command("chop", "fighting.combat.special", 75);
      if (player->query_guild_ob() == "/std/guilds/warrior")
        check_add_command("behead", "fighting.combat.special", 150);
    }
    if (bluntorsharp == USE_PIERCE) {
      check_add_command("stab", "fighting.combat.special", 15);
      check_add_command("pierce", "fighting.combat.special", 75);
      if (player->query_guild_ob() == "/std/guilds/warrior")
        check_add_command("impale", "fighting.combat.special", 150);
    }
  }
  if (bluntorsharp == USE_BLUNT || bluntorsharp == USE_BALANCED) {
    check_add_command("bash", "fighting.combat.special", 15);
    check_add_command("smash", "fighting.combat.special", 75);
    if (player->query_guild_ob() == "/std/guilds/warrior")
      check_add_command("crush", "fighting.combat.special", 150);
  }
  check_add_command("feint", "fighting.combat.special", 15);
  check_add_command("trip", "fighting.combat.special", 15);
  check_add_command("shove", "fighting.combat.special", 15);
  player->add_known_command("concentrate");
}

/**
 * This helper function is used by fight_in_progress() to see if one of
 * the NPC's weapons are appropriate for use with the command.
 *
 * @param weapon The object to check.
 *
 * @return 1 if the object is appropriate, 0 otherwise
 */
protected int check_weapon(object weapon, string command) {
  if (member_array(weapon->query_command_names(), ({ command })) != -1)
    return 1;
  return 0;
}

/**
 * This helper function is used by fight_in_progress() to see if one of
 * the NPC's weapons are appropriate for use with the 'crush' command.
 *
 * @param weapon The object to check.
 *
 * @return 1 if the object is appropriate, 0 otherwise
 */
protected int check_crush(object weapon)
{
  if (member_array(weapon->query_commands_names(), ({ "smash" })) != -1)
    return 1;
  return 0;
}

/**
 * This helper function is used by fight_in_progress() to see if one of
 * the NPC's weapons are appropriate for use with the 'behead' command.
 *
 * @param weapon The object to check.
 *
 * @return 1 if the object is appropriate, 0 otherwise
 */
protected int check_behead(object weapon)
{
  if (member_array(weapon->query_commands_names(), ({ "slice" })) != -1)
    return 1;
  return 0;
}

/**
 * This helper function is used by fight_in_progress() to see if one
 * of the NPC's weapons are appropriate for use with the 'impale' command.
 *
 * @param weapon The object to check.
 *
 * @return 1 if the object is appropriate, 0 otherwise
 */
protected int check_impale(object weapon)
{
  if (member_array(weapon->query_commands_names(), ({ "pierce" })) != -1)
    return 1;
  return 0;
}

/**
 * This helper function is used by fight_in_progress() to see if one of
 * the NPC's weapons are appropriate for use with the 'riposte' command.
 *
 * @param weapon The object to check.
 *
 * @return 1 if the object is appropriate, 0 otherwise
 */
protected int check_riposte(object weapon)
{
  if (member_array(weapon->query_commands_names(), ({ "slash" })) != -1)
    return 1;
  return 0;
}

/**
 * This function is called once per combat round by the combat shadow,
 * and does most of the work for this shadow.  It controls on whom
 * the NPC is concentrating, chooses an appropriate attack, and chooses
 * an appropriate weapon for the attack.
 *
 * <p>Most of the intelligence is in the specific choice of attack, and
 * there isn't a whole lot in that.  It restricts itself to simply going
 * through the attacks stored in the specials[] array (calculated in
 * the call to good_fighter_setup()), finding which attacks are valid (based
 * on whether the opponent is holding a weapon and which weapons are wielded
 * by the NPC).  Once it has a list of valid commands, it choses from them
 * randomly.
 *
 * <p>Regardless, there is always the possibility that this function will
 * drop through and allow the combat handler to attack normally.  That
 * chance is inversely proportional to the NPC's level.
 *
 * @param attacker The current person attacking the NPC.
 */
void event_fight_in_progress(object attacker, object opponent)
{
  object ts, temp, weapon;
  int chance;
  string cmd, str;

  /* I have to get to the top of the shadow stack, because the combat
   * shadow was probably added after this one. */
  ts = player;
//  while ((temp = shadow(ts, 0)) != 0 && temp != ts)
//    ts = temp;

  ts->event_fight_in_progress(attacker, opponent);

  if (victim && !objectp(victim))
    victim = 0;
  if (victim && !interactive(victim))
    victim = 0;
  if (victim && environment(victim) != environment(player))
    victim = 0;
  if (victim && victim != attacker)
    return;
  if (!victim) {
//    player->do_command("concentrate " + (attacker->query_short()));
//    victim = player->query_concentrating();
    victim = attacker;
    if (!victim)
      return;
  }
/*  if (!ts->query_special_manoeuvre() ||
      (sizeof((int *)ts->effects_matching("fighting.combat.special")))) {
    player->fight_in_progress(attacker);
    return;
  }
*/
  /*
   * As the NPC gets higher level, there should be more possiblity of
   * it using a special command.  But on the other hand, it mustn't
   * ever get to the point that it will _always_ use special commands.
   * I have fixed the upper limit at a 25% chance of using a special
   * command, and that is reached at level 300.
   * Right now the probability curve is linear.  It should really
   * be a sigmoid.
   */
  chance = (player->query_level() / 12) + 5;
  if(chance > 25)
    chance = 25;

  if (random(100) + 1 < chance) {
    object *holding;
    string *candidates;
    int i, j;

    candidates = ({ });
    holding = player->query_holding() - ({ 0 });
    foreach(weapon in holding) {
      // Setup an array of the attack possibilities for each weapon so
      // we don't have to recalc them everytime.
      if(!weapons[weapon]) {
        weapons[weapon] = ({ });
        for (i = 0; i < sizeof(specials); i++)
          if(W_ATTACKS[specials[i]]) {
            weapons[weapon] += ({ replace(W_ATTACKS[specials[i]], "$W",
                                          weapon->query_short()) });
          }
      }

      // Add held weapons to the candidates list
      candidates += weapons[weapon];
    }

    // Setup unarmed attacks.
    if(weapons["unarmed"]) {
      for(i=0; i<sizeof(specials); i++)
        weapons["unarmed"] = ({ });
        if(U_ATTACKS[specials[i]])
          weapons["unarmed"] += ({ U_ATTACKS[specials[i]] });
    }

    // add unarmed attacks to the candidates list
    candidates += weapons["unarmed"];
    
#ifdef DEBUG
    //    debug_printf("Commands available: %O", candidates);
#endif
    if(sizeof(candidates)) {
      cmd = replace(candidates[random(sizeof(candidates))], "$N",
                    opponent->query_name());
      
#ifdef DEBUG
      debug_printf("Trying to perform: %O", cmd);
#endif
      player->do_command(cmd, 1);
    } else {
#ifdef DEBUG
      debug_printf("No command to perform");
#endif
    }
  } else {
#ifdef DEBUG
    debug_printf("Not doing a special this time");
#endif
  }
}

/**
 * When a creator uses the 'stat' command on an NPC that is shadowed
 * by this object, this function gets called.  It returns an array
 * containing the normal stats for tho object that this is shadowing,
 * plus it tacks on some information regarding the configuration of
 * this shadow.
 *
 * @return A list of stats related to this shadow, augmented by
 * the stats of the NPC that this shadow is attached to (if any).
 */
mixed *stats()
{
  if (!player || !objectp(player))
    return ({ ({ "good fighter", "unattached" }) });
  return player->stats() + ({
    ({ "good fighter",
      ((bluntorsharp == USE_BLUNT) ? "blunt" :
        ((bluntorsharp == USE_PIERCE) ? "pierce" :
          ((bluntorsharp == USE_SHARP) ? "sharp" : "balanced"))) +
      ((dodgeorparry == DEFEND_DODGE) ? " dodger" :
        ((dodgeorparry == DEFEND_PARRY) ? " parrier" : " fighter")) }),
    ({ "managed commands", implode(specials, ", ") })
  });
}
// --- END [/mnt/home2/grok/lib/std/shadows/npc/ngood_fighter.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shadows/npc/given.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shadows/npc/given.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629106   Available: 13576460
Inodes: Total: 5242880    Free: 4960135
1195 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shadows/npc/given.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629106   Available: 13576460
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: given.c,v 1.5 2002/04/18 20:42:00 wodan Exp $
 * $Log: given.c,v $
 * Revision 1.5  2002/04/18 20:42:00  wodan
 * fixed the functionpointer/call_other check, i think, probably (just removed two lines)
 *
 * Revision 1.4  2002/04/15 01:26:18  wobin
 * Fixed a runtime due to driver changes.Sun Apr 14 14:22:50 2002:  *Trying to put function in array Object: /std/shadows/npc/given#105785 at line 21
 *
 * Revision 1.3  1998/10/09 10:16:16  terano
 * Changes for ranma
 *
 * Revision 1.1  1998/01/06 04:39:52  ceres
 * Initial revision
 * 
*/
inherit "/std/effect_shadow";

void event_enter(object ob, string mess, object from) {
   mixed *bit = ({ });
   int ret;

   /* Check to see if it is us the object is entering... */
   if (environment(ob) == player) {
      if(sizeof(arg()) > 1)
        bit = arg();
          else
        bit = ({ arg() });
//        if (functionp(bit[0])) {
           if (sizeof(bit) < 2) 
              ret = evaluate(bit[0], player, ob, mess, from);
           else 
              ret = call_other(bit[0], bit[1], player, ob, mess, from);	 
//      }
   }
   player->event_enter(ob, mess, from);
} /* event_enter() */
// --- END [/mnt/home2/grok/lib/std/shadows/npc/given.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shadows/npc/savage_corpse.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shadows/npc/savage_corpse.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629105   Available: 13576459
Inodes: Total: 5242880    Free: 4960135
2147 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shadows/npc/savage_corpse.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629105   Available: 13576459
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: savage_corpse.c,v 1.2 1999/12/31 19:23:03 ceres Exp $
 * $Log: savage_corpse.c,v $
 * Revision 1.2  1999/12/31 19:23:03  ceres
 * Updated with Oaf's changes
 *
 * Revision 1.1  1998/01/06 04:39:52  ceres
 * Initial revision
 * 
*/
/*
 * Rip apart a corpse now and then to remove bits off it (then eat them).
 * This should be used in conjunction with the eat_edible effect to
 * actually eat the stuff ripped off.
 */
inherit "/std/effect_shadow";

mixed move(mixed dest, string messin, string messout) {
   int ret;

   ret = player->move(dest, messin, messout);
   if (ret == 0) {
      call_out("do_savage_corpse", 0);
   }
   return ret;
} /* move() */

protected void do_savage_corpse() {
   int i;
   object *obs;

   obs = all_inventory(environment(player));
   for (i = 0; i < sizeof(obs); i++) {
      if (obs[i]->query_corpse() &&
          sizeof(obs[i]->query_edible_bits_left()) > 0) {
         remove_call_out("real_savage");
         call_out("real_savage", 1 + random(120), obs[i]);
         break;
      }
   }
} /* do_save_corpse() */

protected void real_savage(object ob) {
   string *bits;
   object bit;
   int i;

   if (!ob) {
      call_out("do_savage_corpse", 1 + random(2*60));
      return ;
   }
   bits = ob->query_edible_bits_left();
   if (sizeof(bits) > 0 && environment(ob) == environment(player)) {
      i = random(sizeof(bits));
      bit = ob->make_bit(bits[i]);
      tell_room(environment(player), capitalize(player->the_short()) +
                " rips apart " + ob->the_short() +
                " pulling off " + bit->a_short() + ".\n");
      bit->move(environment(player));
   }

   if (sizeof(bits) > 1) {
      /* Every 2 minutes or so */
      remove_call_out("real_savage");
      call_out("real_savage", 1 + random(2*60), ob);
   } else {
      call_out("do_savage_corpse", 1 + random(2*60));
   }
} /* real_savage() */

void event_enter(object ob, string mess, object from) {
   player->event_enter(ob, mess, from);
   if (ob->query_corpse()) {
      remove_call_out("real_savage");
      call_out("real_savage", 10, ob);
   }
} /* event_enter() */
// --- END [/mnt/home2/grok/lib/std/shadows/npc/savage_corpse.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shadows/npc/guard_duty.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shadows/npc/guard_duty.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629105   Available: 13576459
Inodes: Total: 5242880    Free: 4960135
1090 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shadows/npc/guard_duty.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629105   Available: 13576459
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: guard_duty.c,v 1.1 1998/01/06 04:39:52 ceres Exp $
 * $Log: guard_duty.c,v $
 * Revision 1.1  1998/01/06 04:39:52  ceres
 * Initial revision
 * 
*/
inherit "/std/effect_shadow";

int id;

#define GOTO_DEST "/std/effects/npc/goto_destination"

/*
 * allow them to follow.  When they run out of attackers, send them
 * home...
 */
int move(object ob, string in_thing, string out_thing) {
   int ret;

   ret = player->move(ob, in_thing, out_thing);
   if (ret) {
      if (id) {
         remove_call_out(id);
      }
      if  (!sizeof(player->query_following_route()) &&
           file_name(environment(player)) != arg()) {
         id = call_out(function() {
                       object *arr;

                       arr = filter(player->query_attacker_list(),
                              (: environment($1) == environment(player) :));
                       if (!sizeof(arr)) {
                          player->add_effect(GOTO_DEST, arg());
                       }
                    }, 10);
      }
   }
   return ret;
} /* move() */
// --- END [/mnt/home2/grok/lib/std/shadows/npc/guard_duty.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shadows/npc/i_died.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shadows/npc/i_died.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629104   Available: 13576458
Inodes: Total: 5242880    Free: 4960135
832 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shadows/npc/i_died.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629104   Available: 13576458
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: i_died.c,v 1.2 2001/02/21 06:37:31 shrike Exp $
 * $Log: i_died.c,v $
 * Revision 1.2  2001/02/21 06:37:31  shrike
 * changed from remove_this_effect() to submit_ee2() in an attempt to fix undead NPC porbelms.
 *
 * Revision 1.1  1998/01/06 04:39:52  ceres
 * Initial revision
 * 
*/
#include <effect.h>

inherit "/std/effect_shadow";

#define CLASS "npc.death.me"

int second_life() {
   mixed *bit;
   int ret;

   bit = arg();
   if (functionp(bit)) {
      ret = evaluate(bit, player);
   } else if (pointerp(bit)) {
      ret = call_other(bit[0], bit[1], player);
   }

   if (!pointerp(bit) || sizeof(bit) < 3 || !bit[2]) {
      ret = player->second_life();
   }

   player->submit_ee2( player->effects_matching(CLASS)[0], 0, 0, EE_REMOVE );
   return ret;
} /* second_life() */
// --- END [/mnt/home2/grok/lib/std/shadows/npc/i_died.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shadows/npc/dont_move.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shadows/npc/dont_move.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629104   Available: 13576458
Inodes: Total: 5242880    Free: 4960135
86 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shadows/npc/dont_move.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629104   Available: 13576458
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/effect_shadow";

int cannot_walk() {
   return 1;
} /* cannot_walk() */
// --- END [/mnt/home2/grok/lib/std/shadows/npc/dont_move.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shadows/npc/death.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shadows/npc/death.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629104   Available: 13576458
Inodes: Total: 5242880    Free: 4960135
582 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shadows/npc/death.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629104   Available: 13576458
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: death.c,v 1.1 1998/01/06 04:39:52 ceres Exp $
 * $Log: death.c,v $
 * Revision 1.1  1998/01/06 04:39:52  ceres
 * Initial revision
 * 
*/
inherit "/std/effect_shadow";

int second_life() {
   mixed *bit;
   int ret;

   bit = arg();
   if (functionp(bit)) {
      ret = evaluate(bit, player);
   } else if (pointerp(bit)) {
      ret = call_other(bit[0], bit[1], player);
   }

   if (!pointerp(bit) || sizeof(bit) < 3 || !bit[2]) {
      ret = player->second_life();
   }

   remove_this_effect();
   return ret;
} /* second_life() */
// --- END [/mnt/home2/grok/lib/std/shadows/npc/death.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shadows/npc/no_follow.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shadows/npc/no_follow.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629103   Available: 13576457
Inodes: Total: 5242880    Free: 4960135
359 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shadows/npc/no_follow.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629103   Available: 13576457
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: no_follow.c,v 1.1 1998/01/06 04:39:52 ceres Exp $
 * $Log: no_follow.c,v $
 * Revision 1.1  1998/01/06 04:39:52  ceres
 * Initial revision
 * 
*/
inherit "/std/effect_shadow";

int add_follower(object ob) {
   call_out("do_command", 0, "lose everyone");
   return player->add_follower(ob);
} /* add_follower() */
// --- END [/mnt/home2/grok/lib/std/shadows/npc/no_follow.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shadows/npc/controlled_monster.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shadows/npc/controlled_monster.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629103   Available: 13576457
Inodes: Total: 5242880    Free: 4960135
8240 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shadows/npc/controlled_monster.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629103   Available: 13576457
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: controlled_monster.c,v 1.1 1998/01/06 04:39:52 ceres Exp $
 * $Log: controlled_monster.c,v $
 * Revision 1.1  1998/01/06 04:39:52  ceres
 * Initial revision
 * 
*/
inherit "/std/effect_shadow";

int turn_chance;
object my_owner;
object my_enemy;
string leave_msg;
string enter_msg;   
int summoned;

int set_enemy( object enemy );

object query_owner() { return my_owner; }
object query_enemy() { return my_enemy; }
void set_leave_msg( string mess ) { leave_msg = mess; }
void set_enter_msg( string mess ) { enter_msg = mess; }
void set_summoned( int summ ) { summoned = summ; }

void init() {
   player->init();
   if( this_player() != my_owner )
      return;
   this_player()->add_command( "help", this_object(), "<direct:living:here>" );
   this_player()->add_command( "order", this_object(), 
                              "<direct:living:here> to {kill|attack} <indirect:living:here>" );
   this_player()->add_command( "order", this_object(), 
                              "<direct:living:here> to protect <indirect:living:here>" );
   this_player()->add_command( "order", this_object(), 
                              "<direct:living:here> to leave" );
}

int do_order( object *indir, string indir_match, string dir_match, 
             mixed *args, string pattern ) {
   if( this_player() != my_owner )
      return 0;
   if( pattern == "<direct:living:here> to leave" ) {
      my_owner->add_succeeded_mess( this_object(), 
                                   "$D smiles happily.\n", ({ }) );
      tell_object( my_owner,
                  (string)this_object()->the_short() +
		   " tells you: Thank you.\n");
      if ( summoned ) {
         call_out( "go_away", 1 );
      } else {
         my_owner = 0;
         call_out( "run_away", 1 );
      }
   } else if ( pattern == "<direct:living:here> to protect <indirect:living:here>" ) {
      if ( !indir ) {
         my_owner->add_failed_mess( this_object(), 
                                   "$D asks you: Who do you want me to protect?\n", ({ }) );
         return 0;
      }
      tell_object( indir[ 0 ], (string)this_object()->the_short() +" tells you:  "+ 
                  (string)my_owner->the_short() 
                  +" has asked me to protect you.\n" );
      tell_object( my_owner, (string)this_object()->the_short() 
                  +" tells you: Fine.\n" );
      this_player()->add_succeeded_mess( this_object(), 
                                        "$N $V $D to protect $I.\n ", ({ indir[ 0 ] }) );
      this_object()->do_command( "protect "+
				 (string)indir[ 0 ]->query_name() );
   } else {
      if ( !indir ) {
         my_owner->add_failed_mess( this_object(), 
                                   "$D asks you: Who do you want me to kill?\n", ({ }) );
         return 0;
      }
      if ( !set_enemy( indir[ 0 ] ) ) {
         my_owner->add_failed_mess( this_object(), 
                                   "$D tells you: There is no way you can force me to attack $I.\n", 
                                   ({ indir[ 0 ] }));
         return 0;
      };
      tell_object( my_enemy, (string)this_object()->the_short() +
		   " tells you:  "+ 
                  (string)my_owner->the_short() 
                  +" has asked me to kill you.\nPrepare to die!\n" );
      tell_object( my_owner, this_object()->the_short() +
		   " tells you: Fine.\n" );
   }
   return 1;
}

int do_help( object *indir, string indir_match, string dir_match, 
            mixed *args, string pattern ) {
   if ( this_player() != my_owner )
     return 0;
   this_player()->add_succeeded_mess( this_object(), 
                                     "You can \"order\" "+
				      this_object()->the_short() 
                                     +" to kill someone or to leave.\n ", ({ }) );
   return 1;
}

int set_enemy( object enemy ) {
   object *list;
   int i;
   
   my_enemy = enemy;
   
   if( my_enemy == my_owner ) {
      my_owner = 0;  /******* stop attacking owners foes ******/
      
      list = this_object()->query_attacker_list();
      for( i = 0; i < sizeof(list); i++ ) {
         this_object()->stop_fight( list[i] );
         (list[ i ])->stop_fight( this_object() );
         if ( !pk_check( list[ i ], my_enemy ) ) {
            (list[ i ])->attack_ob( my_enemy );
            my_enemy->attack_ob( list[ i ] );
            tell_object( list[ i ], (string)this_object()->the_short()
                        +" tells you: I will help you fight "+
                        (string)my_enemy->the_short() +".\n");
         }
      }
   } else {
      if ( pk_check( my_owner, my_enemy ) ) {
         if ( turn_chance )
           call_out( "set_enemy", 1, my_owner );
         else 
           call_out( "go_away", 1);
         return 0;
      }
   }   
   this_object()->attack_ob( my_enemy );
   call_out( "move_me", 1 );
   return 1;
}  /* set_enemy() */

int set_owner( object owner, int time, int turn) {
   if ( !owner ) return 0;
   my_owner = owner;
   turn_chance = turn;
   if ( summoned )
     call_out( "do_leave", time ) ;
   call_out( "move_me", 1 );
   return 1;
} /* set_owner() */

void event_dest_me( object ob ) {
   if ( ob == my_owner ) 
     call_out( "go_away", 0 );
   if ( ob == my_enemy ) {
      if ( !my_owner ) 
        call_out( "go_away", 0 );
      if ( my_enemy )
        tell_object( my_owner, (string)my_enemy->the_short() +" has left DiscWorld\n" );
      my_enemy = 0;
      call_out( "move_me",0);
   }
} /* event_dest_me() */
 
void event_death( object ob ) {
   if ( ob == my_enemy ) {
      if ( !my_owner ) call_out( "go_away", 0 );
      /* call_out to preven the monster from bragging 
       * before the death message */
      call_out( "do_tell", 0, my_owner, this_object()->query_short() +" tells you: "+
               my_enemy->the_short() +" has been killed!\n");
      my_enemy = 0;
      call_out( "move_me", 0 );
   }
} /* event_death() */

void do_tell( object ob, string str ) {
   tell_object( ob, str );
} /* do_tell() */

/*********************** Follow owner or enemy **********/
void move_me() {
   if ( my_enemy ) {
      if ( environment() == environment( my_enemy ) ) return;
      player->move( environment( my_enemy ), enter_msg, leave_msg );      
      tell_object( my_enemy, this_object()->the_short() +" says: You cannot escape me!\n" ); 
      return;
   }
   if ( my_owner ) {
      if ( environment() == environment( my_owner ) ) return;
      player->move( environment( my_owner ), enter_msg, leave_msg );     
      this_object()->do_command( "protect "+ (string)my_owner->query_name() );
      this_object()->do_command( "follow "+ (string)my_owner->query_name() );      
      return;
   }
   if ( summoned ) 
     call_out( "go_away", 0 );
   else
     call_out( "run_away", 1 );
} /* move_me() */

int do_leave() {
   if ( my_owner ) {
      tell_object( my_owner, this_object()->the_short()
                  +" tells you:  It is time for me to leave.\n" );
      say( this_object()->the_short() +" smiles happily.\n" );
   }
   call_out( "go_away", 2 );
   return 1;
} /* do_leave() */

/**************************** ATTACK / COMBAT ***************/
int attack_by( object ob ) {
   if ( summoned && !my_owner ) {
      say( this_object()->the_short()
	   +" says: I will not fight without an owner!\n");
      call_out("go_away",0);
      return 1; 
   }
   if ( interactive( my_owner ) ) {
      if ( (string) ob->query_guild_ob() == "/std/guilds/priest" ) {
         tell_object( my_owner, this_object()->the_short() +" tells you: "
                     "I do not wish to kill "+ ob->the_short()+".\n");
         
         if ( !turn_chance ) {
            call_out( "go_away", 1 );
            return 1;
         }
         if ( random( 100 ) < turn_chance ) {
            set_enemy( my_owner );
            return 1;
         }
      }
      if ( random( 100 ) < ( turn_chance / 5 ) ) {
         set_enemy( my_owner );
         return 1;
      }
   }
   return player->attack_by( ob );
} /* attack_by() */

void event_exit( object ob ) {
   if( ob != my_owner && ob != my_enemy ) return;
   call_out( "move_me", 1 );
} 

void go_away() {
  write( leave_msg );
  player->move( "/room/rubbish" );
} /* dest_me() */

// --- END [/mnt/home2/grok/lib/std/shadows/npc/controlled_monster.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shadows/npc/goto_destination.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shadows/npc/goto_destination.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629101   Available: 13576455
Inodes: Total: 5242880    Free: 4960135
1545 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shadows/npc/goto_destination.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629101   Available: 13576455
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: goto_destination.c,v 1.2 1999/07/28 17:59:43 wodan Exp $
 * 
*/
/*
 * The goto destination shadow.
 */
inherit "/std/effect_shadow";

object womble;
int done, moved;

/* When it finishes.  We want to know. */
void stopped_route() {
   /* Is this a find player effect? */
   if (!done) {
      mixed *rabbit;

      rabbit = arg();
      if (objectp(rabbit[0])) {
         womble = rabbit[0];
      }
      done = 1;
   }

   if (womble && environment(womble) != environment(player)) {
      if (!moved) {
         player->move(environment(womble),
                      (string)player->query_mmsgin(),
                      (string)player->query_mmsgout() );
         call_out("remove_this_effect", 0);
      } else {
         player->move_me_to(file_name(environment(womble)));
      }
   } else {
      call_out("remove_this_effect", 0);
   }
} /* stopped_route() */

int move(object ob, string in_thing, string out_thing) {
   int ret;

   if (!done) {
      mixed *rabbit;

      rabbit = arg();
      done = 1;
      if (arrayp(rabbit) && objectp(rabbit[0])) {
         womble = rabbit[0];
         done = 2;
      }
   }

   ret = player->move(ob, in_thing, out_thing);

   if (!ret && womble && environment(womble) == environment(player)) {
      /* We have found our player... */
      player->stop_following_route();
      remove_this_effect();
   }

   if (done == 2 && !womble) {
      call_out("remove_this_effect", 4);
   }

   if (!ret)
      moved = 1;

   return ret;
} /* move() */
// --- END [/mnt/home2/grok/lib/std/shadows/npc/goto_destination.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shadows/npc/mock_block.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shadows/npc/mock_block.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629100   Available: 13576454
Inodes: Total: 5242880    Free: 4960135
1373 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shadows/npc/mock_block.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629100   Available: 13576454
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
* This shadow goes with the "mock.block.npc" effects and adds functions
* that allow its args to be manipulated.
* 
* @author Tannah
**/

inherit "/std/effect_shadow";

/**
* Removes a skill from the list of those blocked from mocking and returns
* the list of those still blocked.
* @param skills - the skills to remove from the list of those blocked.
* @return skills - those skills still blocked from mocking
**/

string *unblock_skills( string *skills ) {
  set_arg( arg() - skills );
  
  /* was that the last skill?  If so, remove the effect */
  if( !sizeof( arg() ) ) {
    remove_this_effect();
    return ({});
  }
  return arg();
} /* unblock_skills() */

/**
* Determines whether or not a skill is blocked from being mocked.  mocked 
* can be a leaf (ie: "magic.methods.mental.charming") or a branch (ie: 
* "magic" or "magic.spells").  If all skills are blocked, this always 
* returns 1.  
* @param mocked - the skill to compare to the list of those blocked.
* @return 1 if the skill is blocked from mocking, 0 if not.
**/

int query_mock_block( string mocked ) {
  
  /* Are all skills blocked from mocking?  Easy! */
  
  if( member_array( "all", arg() ) != -1 ) {
    return 1;
  }
  
  /* check each skill that's blocked */
  foreach( string skill in arg() ) {
    if( !strsrch( mocked, skill ) ) {
      return 1;
    }
  }
} /* query_mock_block() */// --- END [/mnt/home2/grok/lib/std/shadows/npc/mock_block.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shadows/npc/light_change.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shadows/npc/light_change.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629100   Available: 13576454
Inodes: Total: 5242880    Free: 4960135
674 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shadows/npc/light_change.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629100   Available: 13576454
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: light_change.c,v 1.1 1998/01/06 04:39:52 ceres Exp $
 * $Log: light_change.c,v $
 * Revision 1.1  1998/01/06 04:39:52  ceres
 * Initial revision
 * 
*/
inherit "/std/effect_shadow";

void event_light_change(object ob, int delta) {
   call_out("delayed_event_light_change",0, ob, delta );
} /* event_light_change() */

void delayed_event_light_change(object ob, int delta) {
   mixed *bit;
   int ret;

   bit = arg();
   if (functionp(bit)) {
      ret = evaluate(bit, player, ob, delta);
   } else if (pointerp(bit)) {
      ret = call_other(bit[0], bit[1], player, ob, delta);
   }
   player->event_light_change(ob, delta);
}
// --- END [/mnt/home2/grok/lib/std/shadows/npc/light_change.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shadows/npc/basilisk_stare.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shadows/npc/basilisk_stare.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629099   Available: 13576453
Inodes: Total: 5242880    Free: 4960135
1552 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shadows/npc/basilisk_stare.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629099   Available: 13576453
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: basilisk_stare.c,v 1.2 2003/04/02 16:16:42 carmine Exp $
 * $Log: basilisk_stare.c,v $
 * Revision 1.2  2003/04/02 16:16:42  carmine
 * Fixed bug with "helpless" message
 *
 * Revision 1.1  2002/01/27 09:02:51  siel
 * Initial revision
 *
 * Revision 1.1  1998/01/06 04:37:11  ceres
 * Initial revision
 * 
*/
#include <move_failures.h>

inherit "/std/effect_shadow";

int query_basil_stare_shad(){ return 1; }

string query_passed_out_message()
{
  string *msgs = ({
    "The eyes!  They're burning!  Can't think!\n",
    "Your concentration is too fragmented.\n",
    "Why do that when you can just sit here and fall into those eyes?\n",
    "Arrrrgghhhh!  Too much pain!\n"
    }) ;
  return msgs[random(sizeof(msgs))];
}

int move_with_look(object dest, string messin, string messout)
{
   tell_object(player, "Your mind is not here to help you control "+
                       "your movement.\n");
   return MOVE_NO_DROP;
}


int attack_by(object obj)
{
   if( !obj || ( !obj->one_short() ) ) {
      tell_room( environment( player ), player->one_short() + " is totally "
         "helpless.\n", player );
   }
   else {
      tell_room(environment(player), player->one_short()+
        " is totally helpless against "+obj->one_short()+"'s attack.\n",
        player);
   }
   
   tell_object(player, "Oh dear! How do I defend myself? I forgot!\n") ;
   return 1;
}

/* This next function prevents people from dodging or parrying!
 * Ain't I a stinker? */
int query_special_manoeuvre() { return 0; }
// --- END [/mnt/home2/grok/lib/std/shadows/npc/basilisk_stare.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shadows/npc/enter.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shadows/npc/enter.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629099   Available: 13576453
Inodes: Total: 5242880    Free: 4960135
522 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shadows/npc/enter.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629099   Available: 13576453
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: enter.c,v 1.1 1998/01/06 04:39:52 ceres Exp $
 * $Log: enter.c,v $
 * Revision 1.1  1998/01/06 04:39:52  ceres
 * Initial revision
 * 
*/
inherit "/std/effect_shadow";

void event_enter(object ob, string mess) {
   mixed *bit;
   int ret;

   bit = arg();
   if (functionp(bit)) {
      ret = evaluate(bit, player, ob, mess);
   } else if (pointerp(bit)) {
      ret = call_other(bit[0], bit[1], player, ob, mess);
   }
   player->event_enter(ob, mess);
} /* event_enter() */
// --- END [/mnt/home2/grok/lib/std/shadows/npc/enter.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shadows/npc/good_fighter.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shadows/npc/good_fighter.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629098   Available: 13576452
Inodes: Total: 5242880    Free: 4960135
13484 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shadows/npc/good_fighter.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629098   Available: 13576452
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/**
 * The Good Fighter shadow.  The main docs are stored in the effect
 * header file, not here...  Mostly for standardisation reasons.
 *
 * @see /std/effects/npc/good_fighter
 *
 * @author Sin
 * @created 12 November 1997
 * @changed 13 November 1997 -- Sin
 *     Converted it from a pure shadow to a shadow/effect pair
 * @changed 11 April 1998 -- Sin
 *     Added support for USE_UNARMED.
 *     God rid of some dead wood.
 * @changed 12 April 1998 -- Sin
 *     Added support for crush
 * @changed 3 August 2002 -- Rhinehold
 *     Converted to work with new non-effect combat system
 *     Added support for behead, pierce, bash, smash, chop
 *     Removed strike
 */

#include <good_fighter.h>

#define LOGFILE "good_fighter"
#define CMDS "/cmds/guild-race/fighting/"

#define DEBUG

inherit "/std/effect_shadow";

//                     "riposte" : "riposte $N with $W", \
#define W_ATTACKS ([ "crush"   : "crush $N with $W", \
                     "behead"  : "behead $N with $W", \
                     "impale"  : "impale $N with $W", \
                     "stab"    : "stab $N with $W", \
                     "pierce"  : "pierce $N with $W", \
                     "bash"    : "bash $N with $W", \
                     "smash"   : "smash $N with $W", \
                     "slash"   : "slash $N with $W", \
                     "slice"   : "slice $N with $W", \
                     "hack"    : "hack $N with $W", \
                     "chop"    : "chop $N with $W", \
                     "feint"   : "feint at $N with $W" ])
#define U_ATTACKS ([ "trip"    : "trip $N", \
                     "shove"   : "shove $N" ])
                   
string *specials;
mapping weapons;
int bluntorsharp;
int dodgeorparry;
object victim;

/**
 * @ignore
 * Used only to insure that the specials array is actually an array at
 * all times.
 */
void create()
{
  specials = ({ });
  weapons = ([ ]);
}

/**
 * This is a helper function used by the good_fighter_setup() function to
 * ensure that the specified skill is at least at a particular level.
 *
 * @param skill The skill to check
 *
 * @param level The minimum acceptable level for this skill
 */
protected void check_skill(string skill, int level)
{
  int cur;

  cur = player->query_skill(skill);
  if (cur < level)
    player->add_skill_level(skill, level - cur);
}

/**
 * This helper function is used by good_fighter_setup() to add a known
 * command to the NPC's repertoire _only_ if the relevant skill is above
 * a certain level.  If the command is added, then it is also stored in the
 * specials[] array for later use by fight_in_progress()
 *
 * @param command The command to be added
 *
 * @param skill The skill that controls the NPC's effectiveness with this
 * command.
 *
 * @param level The minimum level before the command can be added.
 */
protected void check_add_command(string command, string skill, int level)
{
  int cur;

  cur = player->query_skill(skill);
  if (cur >= level) {
    player->add_known_command(command);
    specials += ({ command });
  }
}

/**
 * This function is called from a callout() registered when setup_shadow()
 * is called.  It is responsible for ensuring that all of the NPC's skills
 * are at a reasonable level, that the NPC has the commands appropriate
 * for its priorities and level, and that the tactics are set appropriately.
 */
void good_fighter_setup()
{
  int adjust;
  int lvl;
  int *args = arg();

  if (!args || !arrayp(args) || sizeof(args) != 2)
    return;

  specials = ({ });
  bluntorsharp = args[0];
  dodgeorparry = args[1];

  lvl = player->query_level();
  check_skill("other.perception", lvl / 2);
  check_skill("other.health", lvl);
  adjust += (lvl / 3);
  if (bluntorsharp == USE_PIERCE) {
    check_skill("fighting.combat.melee.blunt", lvl - adjust);
    check_skill("fighting.combat.melee.sharp", lvl - adjust);
    check_skill("fighting.combat.melee.pierce", lvl + adjust);
    check_skill("fighting.combat.melee.unarmed", lvl - adjust);
  } else if (bluntorsharp == USE_BLUNT) {
    check_skill("fighting.combat.melee.blunt", lvl + adjust);
    check_skill("fighting.combat.melee.sharp", lvl - adjust);
    check_skill("fighting.combat.melee.pierce", lvl - adjust);
    check_skill("fighting.combat.melee.unarmed", lvl - adjust);
  } else if (bluntorsharp == USE_SHARP) {
    check_skill("fighting.combat.melee.blunt", lvl - adjust);
    check_skill("fighting.combat.melee.sharp", lvl + adjust);
    check_skill("fighting.combat.melee.pierce", lvl - adjust);
    check_skill("fighting.combat.melee.unarmed", lvl - adjust);
  } else if (bluntorsharp == USE_UNARMED) {
    check_skill("fighting.combat.melee.blunt", lvl - adjust);
    check_skill("fighting.combat.melee.sharp", lvl - adjust);
    check_skill("fighting.combat.melee.pierce", lvl - adjust);
    check_skill("fighting.combat.melee.unarmed", lvl + adjust);
  } else {
    check_skill("fighting.combat.melee.blunt", lvl);
    check_skill("fighting.combat.melee.sharp", lvl);
    check_skill("fighting.combat.melee.pierce", lvl);
    check_skill("fighting.combat.melee.unarmed", lvl);
  }

  adjust = lvl * 2 / 3;
  if (dodgeorparry == DEFEND_DODGE) {
    check_skill("fighting.combat.dodging", lvl + adjust);
    check_skill("fighting.combat.parry", lvl - adjust);
    player->init_command("tactics response dodge", 1);
  } else if (dodgeorparry == DEFEND_PARRY) {
    check_skill("fighting.combat.dodging", lvl - adjust);
    check_skill("fighting.combat.parry", lvl + adjust);
    player->init_command("tactics response parry", 1);
  } else {
    check_skill("fighting.combat.dodging", lvl);
    check_skill("fighting.combat.parry", lvl);
    player->init_command("tactics response neutral", 1);
  }
  check_skill("fighting.combat.special", lvl / 2);
  check_skill("fighting.points", lvl * 2);

  player->init_command("tactics attitude offensive", 1);

  if (bluntorsharp != USE_BLUNT) {
    if (dodgeorparry == DEFEND_PARRY)
      check_add_command("riposte", "fighting.combat.special", 15);
    if (bluntorsharp == USE_SHARP || bluntorsharp == USE_BALANCED)  {
      check_add_command("hack", "fighting.combat.special", 15);
      check_add_command("slash", "fighting.combat.special", 15);
      check_add_command("slice", "fighting.combat.special", 75);
      check_add_command("chop", "fighting.combat.special", 75);
      if (player->query_guild_ob() == "/std/guilds/warrior")
        check_add_command("behead", "fighting.combat.special", 150);
    }
    if (bluntorsharp == USE_PIERCE) {
      check_add_command("stab", "fighting.combat.special", 15);
      check_add_command("pierce", "fighting.combat.special", 75);
      if (player->query_guild_ob() == "/std/guilds/warrior")
        check_add_command("impale", "fighting.combat.special", 150);
    }
  } else {
    check_add_command("bash", "fighting.combat.special", 15);
    check_add_command("smash", "fighting.combat.special", 75);
    if (player->query_guild_ob() == "/std/guilds/warrior")
      check_add_command("crush", "fighting.combat.special", 150);
  }
  check_add_command("feint", "fighting.combat.special", 15);
  check_add_command("trip", "fighting.combat.special", 15);
  check_add_command("shove", "fighting.combat.special", 15);
  player->add_known_command("concentrate");
}

/**
 * This helper function is used by fight_in_progress() to see if one of
 * the NPC's weapons are appropriate for use with the command.
 *
 * @param weapon The object to check.
 *
 * @return 1 if the object is appropriate, 0 otherwise
 */
protected int check_weapon(object weapon, string command) {

  if(!weapon->query_attack_names())
    return 0;

  switch(command) {
  case "crush":
    command = "smash";
    break;
  case "behead":
    command = "slice";
    break;
  case "impale":
    command = "impale";
    break;
  case "riposte":
    command = "slash";
    break;
  case "feint":
    return 1;
  }

  return (member_array(command, weapon->query_attack_names()) != -1);
}

/**
 * This function is called once per combat round by the combat shadow,
 * and does most of the work for this shadow.  It controls on whom
 * the NPC is concentrating, chooses an appropriate attack, and chooses
 * an appropriate weapon for the attack.
 *
 * <p>Most of the intelligence is in the specific choice of attack, and
 * there isn't a whole lot in that.  It restricts itself to simply going
 * through the attacks stored in the specials[] array (calculated in
 * the call to good_fighter_setup()), finding which attacks are valid (based
 * on whether the opponent is holding a weapon and which weapons are wielded
 * by the NPC).  Once it has a list of valid commands, it choses from them
 * randomly.
 *
 * <p>Regardless, there is always the possibility that this function will
 * drop through and allow the combat handler to attack normally.  That
 * chance is inversely proportional to the NPC's level.
 *
 * @param attacker The current person attacking the NPC.
 */
void event_fight_in_progress(object attacker, object opponent)
{
  object ts, weapon;
  int chance;
  string cmd;

  /* I have to get to the top of the shadow stack, because the combat
   * shadow was probably added after this one. */
  ts = player;
  ts->event_fight_in_progress(attacker, opponent);

  // Make sure we have some GPs.
  if(ts->query_specific_gp("fighting") < 50)
    return;
  
  if (victim && !objectp(victim))
    victim = 0;
  if (victim && !interactive(victim))
    victim = 0;
  if (victim && environment(victim) != environment(player))
    victim = 0;
  if (victim && victim != attacker)
    return;
  if (!victim) {
    // Check the attacker is someone we're fighting
    if(member_array(attacker, ts->query_attacker_list()) != -1)
       victim = attacker;
       
    if (!victim)
      return;
  }

  // If they've been disarmed set them to wimp mode and dodge response.
  if(!sizeof(player->query_weapons()) &&
     player->query_combat_attitude() != "wimp" &&
     arg()[0] != USE_UNARMED) {
    object *shields;

    // No weapons -- go wimp.
    player->queue_command("tactics attitude wimp", 1);
    
    shields = filter(player->query_holding(), (: $1 && $1->id("shield") :));
    // No shield? Then it's unarmed parry or dodge.
    if(!sizeof(shields)) {
      if(player->query_race_ob() == "/std/races/troll") {
        if(!player->query_unarmed_parry())
          player->queue_command("tactics parry unarmed");
      } else {
        player->queue_command("tactics response dodge", 2);
      }
    }
  }

  /*
   * As the NPC gets higher level, there should be more possiblity of
   * it using a special command.  But on the other hand, it mustn't
   * ever get to the point that it will _always_ use special commands.
   * I have fixed the upper limit at a 25% chance of using a special
   * command, and that is reached at level 300.
   * Right now the probability curve is linear.  It should really
   * be a sigmoid.
   */
  chance = (player->query_level() / 12) + 5;
  if(chance > 25)
    chance = 25;

  if(sizeof(player->query_specials()))
    chance /= (sizeof(player->query_specials()) * 10);

  if(random(100) + 1 < chance) {
    string *candidates;
    int i;

    candidates = ({ });
    foreach(weapon in player->query_weapons()) {
      // Setup an array of the attack possibilities for each weapon so
      // we don't have to recalc them everytime.
      if(!weapons[weapon]) {
        weapons[weapon] = ({ });
        for (i = 0; i < sizeof(specials); i++)
          if(W_ATTACKS[specials[i]] && check_weapon(weapon, specials[i])) {
            weapons[weapon] += ({ replace(W_ATTACKS[specials[i]], "$W",
                                          weapon->query_short()) });
          }
      }

      // Add held weapons to the candidates list
      candidates += weapons[weapon];
    }

    // Setup unarmed attacks.
    if(!weapons["unarmed"]) {
      weapons["unarmed"] = ({ });
      for(i=0; i<sizeof(specials); i++)
        if(U_ATTACKS[specials[i]])
          weapons["unarmed"] += ({ U_ATTACKS[specials[i]] });
    }

    // add unarmed attacks to the candidates list
    candidates += weapons["unarmed"];
    
#ifdef DEBUG
    //    debug_printf("Commands available: %O", candidates);
#endif
    if(sizeof(candidates)) {
      cmd = replace(candidates[random(sizeof(candidates))], "$N",
                    victim->query_name());

#ifdef DEBUG
      debug_printf("Trying to perform: %O", cmd);
#endif
      player->do_command(cmd, 1);
    } else {
#ifdef DEBUG
      debug_printf("No command to perform");
#endif
    }
  }
}

/**
 * When a creator uses the 'stat' command on an NPC that is shadowed
 * by this object, this function gets called.  It returns an array
 * containing the normal stats for tho object that this is shadowing,
 * plus it tacks on some information regarding the configuration of
 * this shadow.
 *
 * @return A list of stats related to this shadow, augmented by
 * the stats of the NPC that this shadow is attached to (if any).
 */
mixed *stats()
{
  if (!player || !objectp(player))
    return ({ ({ "good fighter", "unattached" }) });
  return player->stats() + ({
    ({ "good fighter",
      ((bluntorsharp == USE_BLUNT) ? "blunt" :
        ((bluntorsharp == USE_PIERCE) ? "pierce" :
          ((bluntorsharp == USE_SHARP) ? "sharp" : "balanced"))) +
      ((dodgeorparry == DEFEND_DODGE) ? " dodger" :
        ((dodgeorparry == DEFEND_PARRY) ? " parrier" : " fighter")) }),
    ({ "managed commands", implode(specials, ", ") })
  });
}
// --- END [/mnt/home2/grok/lib/std/shadows/npc/good_fighter.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shadows/npc/they_died.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shadows/npc/they_died.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629095   Available: 13576449
Inodes: Total: 5242880    Free: 4960135
529 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shadows/npc/they_died.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629095   Available: 13576449
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: they_died.c,v 1.1 1998/01/06 04:39:52 ceres Exp $
 * $Log: they_died.c,v $
 * Revision 1.1  1998/01/06 04:39:52  ceres
 * Initial revision
 * 
*/
inherit "/std/effect_shadow";

void event_death(object ob, string mess) {
   mixed *bit;
   int ret;

   bit = arg();
   if (functionp(bit)) {
      ret = evaluate(bit, player, ob, mess);
   } else if (pointerp(bit)) {
      ret = call_other(bit[0], bit[1], player, ob, mess);
   }
   player->event_exit(ob, mess);
} /* event_death() */
// --- END [/mnt/home2/grok/lib/std/shadows/npc/they_died.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shadows/npc/gossip.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shadows/npc/gossip.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629094   Available: 13576448
Inodes: Total: 5242880    Free: 4960135
3079 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shadows/npc/gossip.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629094   Available: 13576448
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: gossip.c,v 1.4 2002/08/03 15:52:37 danbala Exp $
 * $Log: gossip.c,v $
 * Revision 1.4  2002/08/03 15:52:37  danbala
 * typo fix
 *
 * Revision 1.3  2000/07/20 18:54:10  gruper
 * Removed duplicate call to event_person_say().
 *
 * Revision 1.2  2000/06/23 02:37:18  pinkfish
 * Allow it to work with non-existent gossip streams.
 *
 * Revision 1.1  1998/01/06 04:39:52  ceres
 * Initial revision
 * 
*/
/*
 * The gossip shadow.  Keeps track of everything that people say.  Then
 * repeats it back in a nice happy go frog format.
 */
inherit "/std/effect_shadow";

#include <gossip.h>

mixed *_says;

private void fixup_says() {
   int i;
   int num;

   if (!_says) {

      _says = ({
    ({ "Pinkfish", "Chickens look good under ultra violet light.", }),
    ({ "Deutha", "In the woods there is a singing lemon.  It has the "
                 "answers to all the quests." }),
    ({ "Turrican", "I am not a number, I am a free womble." }),
    ({ "Ceres", "I want to be a cabbage, I want to see the sea, I want "
                "to live in rabbit land, I want to be with thee.", }),
      });

      /* We only want a random number of these to start with */
      num = random(sizeof(_says));
      while (num > 0) {
         i = random(sizeof(_says));
         _says = _says[0..i-1] + _says[i+1..];
         num--;
      }
   }
} /* fixup_says() */

void event_person_say(object ob, string start, string mess, string lang) {
   int i;
   string *bits;
   string *filter;

   player->event_person_say(ob, start, mess, lang);

   /* Only want players gossip... */
   if (!userp(ob)) {
      return ;
   }

   fixup_says();

   filter = GOSSIP_HANDLER->query_filter();
   bits = explode(mess, " ");
   for (i = 0; i < sizeof(bits); i++) {
      if (member_array(bits[i], filter) != -1) {
         player->event_person_say(ob, start, mess, lang);
         return ;
      }
   }

   if (_says[<1][0] != ob->query_cap_name() ||
       _says[<1][1] != mess) {
      _says += ({ ({ ob->query_cap_name(), mess }) });
   }

   if (!random(50)) {
      GOSSIP_HANDLER->add_gossip(ob->query_cap_name(), mess);
   }

} /* event_person_say() */

void do_gossip_say(string str) {
   int i;
   string *stuff;
   int chance;

   if (!str) {
      str = "$name$ said: $mess$";
   }

   chance = arg();

   if (!intp(chance)) {
      chance = 5;
   }

   fixup_says();

   /* Will handle random gossip off the gossip pool */
   if (sizeof(_says) > 0 && random(chance)) {
      i = random(sizeof(_says));
      stuff = _says[i];
   } else {
      stuff = GOSSIP_HANDLER->query_random_gossip();
   }
   if (!stuff) {
      i = random(sizeof(_says));
      stuff = _says[i];
   }
   if (!stuff) {
      str = replace(str, ({ "$name$", "fluff",
                            "$mess$", "big fluff" }));
   } else {
      str = replace(str, ({ "$name$", stuff[0],
                            "$mess$", stuff[1] }));
   }
   player->do_command("say "+str);
} /* do_gossip_say() */

mixed *query_gossip_says() {
   return _says;
} /* query_gossip_says() */
// --- END [/mnt/home2/grok/lib/std/shadows/npc/gossip.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shadows/npc/exit.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shadows/npc/exit.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629094   Available: 13576448
Inodes: Total: 5242880    Free: 4960135
517 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shadows/npc/exit.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629094   Available: 13576448
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: exit.c,v 1.1 1998/01/06 04:39:52 ceres Exp $
 * $Log: exit.c,v $
 * Revision 1.1  1998/01/06 04:39:52  ceres
 * Initial revision
 * 
*/
inherit "/std/effect_shadow";

void event_exit(object ob, string mess) {
   mixed *bit;
   int ret;

   bit = arg();
   if (functionp(bit)) {
      ret = evaluate(bit, player, ob, mess);
   } else if (pointerp(bit)) {
      ret = call_other(bit[0], bit[1], player, ob, mess);
   }
   player->event_exit(ob, mess);
} /* event_exit() */
// --- END [/mnt/home2/grok/lib/std/shadows/npc/exit.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shadows/npc/pub_brawl.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shadows/npc/pub_brawl.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629093   Available: 13576447
Inodes: Total: 5242880    Free: 4960135
542 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shadows/npc/pub_brawl.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629093   Available: 13576447
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: pub_brawl.c,v 1.1 1998/01/06 04:39:52 ceres Exp $
 * $Log: pub_brawl.c,v $
 * Revision 1.1  1998/01/06 04:39:52  ceres
 * Initial revision
 * 
*/
inherit "/std/effect_shadow";

void event_pub_brawl(object ob, string mess) {
   mixed *bit;
   int ret;

   bit = arg();
   if (functionp(bit)) {
      ret = evaluate(bit, player, ob, mess);
   } else if (pointerp(bit)) {
      ret = call_other(bit[0], bit[1], player, ob, mess);
   }
   player->event_pub_brawl(ob, mess);
} /* event_pub_brawl() */
// --- END [/mnt/home2/grok/lib/std/shadows/npc/pub_brawl.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shadows/misc/team.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shadows/misc/team.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629093   Available: 13576447
Inodes: Total: 5242880    Free: 4960135
4113 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shadows/misc/team.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629093   Available: 13576447
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: team.c,v 1.4 1999/10/28 02:09:56 ceres Exp $
 * 
*/
#define TEAM "/obj/handlers/team"

object player;

void setup_shadow( object thing ) {
   shadow( thing, 1 );
   player = thing;
} /* setup_shadow() */

void destruct_team_shadow() { destruct( this_object() ); }

string extra_score() {
   string team;
   team = (string)TEAM->query_group( player );
   if ( !team ) {
      call_out( "destruct_team_shadow", 1 );
      return (string)player->extra_score();
   }
   return (string)player->extra_score() +
         "You are a team member of "+ team +".\n";
} /* extra_score() */

varargs int adjust_xp( int number, int shared ) {
   int plvl, olvl, divisor;
   string team;
   object other, *others;

   if ( ( number < 0 ) || !shared )
      return (int)player->adjust_xp( number );
   team = (string)TEAM->query_group( player );
   if ( !team ) {
      call_out( "destruct_team_shadow", 1 );
      return (int)player->adjust_xp( number );
   }
   others = (object *)TEAM->query_members( team );
   if ( !others ) {
      call_out( "destruct_team_shadow", 1 );
      return (int)player->adjust_xp( number );
   }
   if ( sizeof( others ) == 1 )
      return (int)player->adjust_xp( number );

   // the more people in the team the smaller the shared Xp.
   divisor = (sizeof(others)-1/ 2);
   if(divisor)
     number /= divisor;
   
   plvl = (int)player->query_level() / 2;
   foreach ( other in others - ({ player }) )
      if ( objectp( other ) ) {
         if ( environment( other ) != environment( player ) )
            continue;
         olvl = (int)other->query_level();
         if ( ( olvl > plvl ) || !plvl )
            other->adjust_xp( number, 0 );
         else
            other->adjust_xp( ( number * ( 1 +
                  ( 99 * olvl ) / plvl ) ) / 100, 0 );
      }
   return (int)player->adjust_xp(number * divisor);
} /* adjust_xp() */

varargs int add_skill_level( string skill, int lvl, mixed exp ) {
  int diff_0, diff_1, diff, width_0, width;
  string team;
  object other, *others;

  // no team advancement unless it's a TM
  if ( ( lvl != 1 ) || intp(exp) ||
       (objectp(exp) && base_name(exp) == base_name(this_object())))
    return (int)player->add_skill_level( skill, lvl, exp );

  if(!exp)
    exp = previous_object();
  
  // Do some checks to make sure they're still in the team.
  team = (string)TEAM->query_group( player );
  if ( !team ) {
    call_out( "destruct_team_shadow", 1 );
    return (int)player->add_skill_level( skill, lvl, exp );
  }
  others = (object *)TEAM->query_members( team );
  if ( !others ) {
    call_out( "destruct_team_shadow", 1 );
    return (int)player->add_skill_level( skill, lvl, exp );
  }
  
  if(skill == "other.perception" || skill[<7..] == ".points")
    return (int)player->add_skill_level( skill, lvl, exp );
   
  if ( sizeof( others ) == 1 )
    return (int)player->add_skill_level( skill, lvl, exp );

  // If they didn't actually get an advance due to hitting a limit or
  // whatever then don't give their team an advance either.
  if(!player->add_skill_level(skill, lvl, exp))
     return 0;
   
  diff_0 = (int)player->query_skill_bonus(skill);
  diff_1 = (int)player->query_skill(skill);
  width_0 = (int)player->stat_modify( 25 * 25, skill );
  foreach ( other in others - ({ player }) ) {
    if (!objectp( other ) )
      continue;
    
    if ( environment( other ) != environment( player ) )
      continue;

    if(diff_0 - (int)other->query_skill_bonus(skill) >
       diff_1 - (int)other->query_skill(skill))
      diff = diff_0 - (int)other->query_skill_bonus( skill );
    else
      diff = diff_1 - (int)other->query_skill(skill);
    width = (int)other->stat_modify( width_0, skill );

    if (random( width + diff * diff + sqrt(other->query_skill(skill)))
        < (width/2) &&
        other->add_skill_level( skill, lvl, this_object())) {
      tell_object( other, "%^YELLOW%^By watching "+
                   (string)player->the_short() +
                   ", you feel you've learnt something.%^RESET%^\n" );
    }
  }
  return 1;
} /* add_skill_level() */
// --- END [/mnt/home2/grok/lib/std/shadows/misc/team.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shadows/misc/poker_shadow.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shadows/misc/poker_shadow.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629092   Available: 13576446
Inodes: Total: 5242880    Free: 4960135
5848 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shadows/misc/poker_shadow.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629092   Available: 13576446
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker: presto $
 * $Id: poker_shadow.c,v 1.1 1998/01/06 04:39:04 ceres Exp presto $
 * $Log: poker_shadow.c,v $
 * Revision 1.1  1998/01/06 04:39:04  ceres
 * Initial revision
 * 
*/
#define FEAR "/std/spells/priest/fear.c"
#define BLIND "/std/effects/religious/blind"

object this_gambler;

void setup_shadow( object gambler )  {
   shadow( gambler, 1 );  
   this_gambler = gambler;  
   return;
}  /* setup_shadow() */

void net_dead()  {
   this_gambler->net_dead();
   if ( !environment( this_gambler )->query_status()  && 
        !environment( this_gambler )->query_anted( this_gambler ) )  {
      tell_room( environment( this_gambler ), "One of the imps taps " +
                 this_gambler->short() + " on the chalky forehead, "
                 "pulls out a small hourglass, and begins watching it "
                 "intently.\n" );
      call_out( "do_leave", 30 );
   }
   else if ( this_gambler ==
             (object)environment( this_gambler )->query_player() )  {
      tell_room( environment( this_gambler ), "One of the imps taps " +
                 this_gambler->short() + " on the chalky forehead, "
                 "pulls out a small hourglass, and begins watching it "
                 "intently.\n" );
      call_out( "do_fold", 30 );
   }
   return;
}  /* net_dead() */

void inform_reconnect_game()  {
    tell_room( environment( this_gambler ), "The imp puts away its "
               "hourglass, nods happily at " +
               this_gambler->short() + ", and returns to the "
               "corner.\n", this_gambler );
    tell_object( this_gambler, "An imp puts away its hourglass, nods "
                 "happily at you, and returns to the corner.\n");
   return;
}

void do_fold()  {
   tell_room( environment( this_gambler ), "The imp gently takes the cards "
              "from " + this_gambler->short() + " and returns to the "
              "corner.\n" );
   environment( this_gambler )->do_fold( this_gambler );
   return;
}  /* do_fold() */

void do_leave()  {
   if ( environment( this_gambler )->query_status() )
      tell_room( environment( this_gambler ), "The imp gently takes the "
                 "cards from " + this_gambler->short() + ", props " +
                 this_gambler->query_objective() +
                 " against the wall, and returns to the corner.\n" );
   else
      tell_room( environment( this_gambler ), "The imp props " +
                 this_gambler->short() + " against the wall and "
                 "returns to the corner.\n" );  
   environment( this_gambler )->do_leave( this_gambler );
   return;
}  /* do_leave() */

void do_check()  {
   tell_room( environment( this_gambler ), "The imp says, \"Time's up!\"\n" );
   environment( this_gambler )->do_check();
   return;
}  /* do_check() */

void do_idle()  {
   tell_room( environment( this_gambler ), "The imp announces, \"Time's up!  "
              "Continue without " + this_gambler->query_short() +
              ".\"\n" );
   tell_room( environment( this_gambler ), "The imp whispers something to " +
              this_gambler->query_short() + ".\n" );
   tell_object( this_gambler, "The imp whispers to you, \"If you can get "
                "some money before the cards are dealt, you can still "
                "play.\"\n" );
   environment( this_gambler )->sit_out( this_gambler );
   return;
}  /* do_idle() */

void do_death()  {
   tell_object( this_gambler, "As you breathe your last, one of the imps "
                "leaps on your head screaming, \"Dead people are not allowed "
                "to play!\"\n" );
   tell_room( environment( this_gambler ), "As " +
              this_gambler->short() + " keels over, one of the imps "
              "leaps on " + this_gambler->query_possessive() +
              " head and screeches, \"Dead people are not allowed to "
              "play!\"\n", this_gambler );
   environment( this_gambler )->do_leave( this_gambler );
   this_gambler->do_death();
   return;
}  /* do_death() */

void dest_poker_shadow()  {
   call_out( "zap", 0 );
   return;
}  /* dest_poker_shadow() */

void zap()  {
   destruct( this_object() );
   return;
}  /* zap() */

void prepare_to_leave()  {
   call_out( "do_leave", 30 );
   return;
}  /* prepare_to_leave() */

void prepare_to_fold( int delay )  {
   call_out( "do_fold", delay );
   return;
}  /* prepare_to_fold() */

void prepare_to_check( int delay )  {
   call_out( "do_check", delay );
   return;
}  /* prepare_to_check() */

void prepare_to_idle( int delay )  {
   call_out("do_idle", delay);
   return;
}  /* prepare_to_idle() */

void cancel_fold()  {
   int i;

   i = 0;
   while( remove_call_out( "do_fold" )  != -1  ||
          remove_call_out( "do_check" ) != -1  ||
          remove_call_out( "do_idle" )  != -1   )  i = 1;
   if ( i )
      tell_room( environment( this_gambler ), "The imp nods, puts away its "
                 "hourglass, and returns to the corner.\n" );
   return;
}  /* cancel_fold() */

void run_away()  {
   if ( previous_object() == find_object( FEAR ) )
      tell_object( this_player( 1 ), "One of the imps screeches, \"Quit "
                   "trying to scare " + this_gambler->short() +
                   "away!\"\n" );
   else this_gambler->run_away();
   return;
}  /* run_away() */

void add_effect( string eff, int duration )  {
   if ( eff == BLIND )  {
      write( "One of the imps jumps up and pokes you in the eyes screaming, "
             "\"How do YOU like it?\"\n" );
      say( "One of the imps pokes " + this_player()->query_short() + "in the "
           "eyes screaming, \"How do YOU like it?\"\n" );
   }
   else this_gambler->add_effect( eff, duration );
   return;
} /* add_effect() */

void event_quit(object me)  {
   environment( this_gambler )->event_exit( this_gambler, 0, 0 );
   return;
}  /* quit() */
// --- END [/mnt/home2/grok/lib/std/shadows/misc/poker_shadow.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shadows/misc/death_shadow.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shadows/misc/death_shadow.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629090   Available: 13576444
Inodes: Total: 5242880    Free: 4960135
4031 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shadows/misc/death_shadow.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629090   Available: 13576444
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  
 * $Locker:  $
 * $Id: death_shadow.c,v 1.2 1998/03/30 01:14:23 olorin Exp $
 * $Log: death_shadow.c,v $
 * Revision 1.2  1998/03/30 01:14:23  olorin
 * added functions so remember if the death cost a life, and if resurrect
 * should restore it.
 *
 * Added autodoc stuff as well.
 *
 * Revision 1.1  1998/01/06 04:39:04  ceres
 * Initial revision
 */
object my_player;
int cost_life, resurrect_adds_life;

/** @ignore yes */
int test_add(object ob) {
   if (ob->query_property("dead usable"))
      return 1;
   return 0;
} /* test_add() */

/** 
 * This function remembers if the death cost a life
 * @param i 1 if it cost a life, 0 if it didn't
 */
void set_death_cost_life( int i ) { cost_life = i; }

/** 
 * This function remembers if the death cost a life
 * @return 1 if it cost a life, 0 if it didn't
 */
int query_death_cost_life() { return cost_life; }

/** 
 * This function remembers if resurrect should restore a life
 * @param i 1 if resurrect should restore a life, 0 if it shouldn't
 */
void set_resurrect_adds_life( int i ) { resurrect_adds_life = i; }

/** 
 * This function remembers if resurrect should restore a life
 * @return 1 if resurrect should restore a life, 0 if it shouldn't
 */
int query_resurrect_adds_life() { return resurrect_adds_life; }

/** @ignore yes */
void attack() {
} /* attack() */

/** @ignore yes */
void adjust_hp() {
} /* adjust_hp() */

/** @ignore yes */
void set_hp() {
} /* set_hp() */
 
/** @ignore yes */
void do_death() {
/* He's already dead...  sheeze.  */
} /* do_death() */
 
/** 
 * This function sets this object up as a clone of ob, and if done
 * while the player is reloading, it'll also restore the values returned 
 * by query_resurrect_adds_life() and query_death_cost_life() 
 * @param ob the object to shadow
 */
void setup_shadow( object ob ) {
   shadow( ob, 1 );
   my_player = ob;
   
   /* restore status */
   cost_life = my_player->query_property( "death cost life" );
   my_player->remove_property( "death cost life" );
   resurrect_adds_life = my_player->query_property( "resurrect should add life" );
   my_player->remove_property( "resurrect should add life" );
} /* setup_shadow() */

/** @ignore yes */
int attack_by( object ob ) {
   tell_object( ob, "This person is a ghost... You cannot attack them.\n" );
   ob->stop_fight( my_player );
   return 1;
} /* attack_by() */

/** @ignore yes */
int attack_ob( object ob ) {
   write( "Your hand passes right through it!  You are just a ghost!\n" );
   return 0;
} /* attack_ob() */

/** @ignore yes */
string short() {
   if ( !my_player )
      return "Death shadow";
   return "the ghost of "+my_player->short();
} /* short() */

/** @ignore yes */
void dest_death_shadow() {
   destruct( this_object() );
} /* dest_death_shadow() */

/** @ignore yes */
int cast() {
   write( "Casting spells when you are dead?\n" );
   return 1;
} /* cast() */

/** @ignore yes */
int do_shout() {
   write( "You are dead, that is not possible.\n" );
   return 1;
} /* do_shout() */

/** @ignore yes */
int do_echo() {
   write( "You are dead...\n" );
   return 1;
} /* do_echo() */

/** @ignore yes */
int do_guild_command() {
   write( "You are dead!\n" );
   return 1;
} /* do_guild_command() */

/** @ignore yes */
int do_race_command() {
   write( "You are dead!\n" );
   return 1;
} /* do_race_command() */

/** @ignore yes */
int score() {
   write( "You are just a disembodied spirit.  What use has a wispy thing "
         "like you have for a collection of meaningless numbers?\n" );
   return 1;
} /* score() */
 
/** @ignore yes */
void second_life() {
} /* second_life() */

/** @ignore yes */
mapping query_dynamic_auto_load() {
   if ( my_player ) {
      /* save status before save */
      my_player->add_property( "death cost life", cost_life );
      my_player->add_property( "resurrect should add life", 
                              resurrect_adds_life );
      return my_player->query_dynamic_auto_load();
   } else
      return ([ ]);
} /* query_dynamic_auto_load() */

// --- END [/mnt/home2/grok/lib/std/shadows/misc/death_shadow.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shadows/misc/surrender_shadow.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shadows/misc/surrender_shadow.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629089   Available: 13576443
Inodes: Total: 5242880    Free: 4960135
5816 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shadows/misc/surrender_shadow.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629089   Available: 13576443
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <player.h>

int protecting;
string protector;
object player;
object *allowed = ({ });

void setup_shadow(object thing, object *victors)
{
  string *bits;

  protector = 0;
  if (environment(thing)) {
    bits = explode(file_name(environment(thing)), "/") - ({ "", "." });
    if (sizeof(bits) > 1 && bits[0] == "d") {
      object mast;
      mast = load_object(implode(bits[0..1] + ({ "master" }), "/"));
      if (mast)
        protector = mast->query_protector_string();
    }
  }
  if (!protector) protector = "The Rules of Fair Play";
  shadow( thing, 1 );
  player = thing;
  protecting = 1;
  call_out( "dest_surrender_shadow", 60 * 5 );
  allowed = victors;
}

int can_be_nasty()
{
  object who;
  object *inv;

  if (!protecting)
    return 1;
  if (!environment(player))
    return 1;
  inv = all_inventory(environment(player));
  foreach (who in allowed)
    if (member_array(who, inv) != -1)
      return 0;
  return 1;
}

string query_surrender_protector() { return protector; }

void zap_surrender_shadow() {
   protecting = 0;
   tell_object( player, "You lose "+ protector +"'s protection.\n" );
   call_out( "dest_surrender_shadow", 1 );
} /* zap_surrender_shadow() */

int adjust_hp( int number, object thing, object weapon, string attack ) {
   if ( ( number > 0 ) || !protecting || 
       !thing || !pk_check(thing, player ) || player == this_player() )
      return (int)player->adjust_hp( number, thing, weapon, attack );
   return (int)player->query_hp();
} /* adjust_hp() */

int set_hp( int number, object thing ) {                     
   int current;
   current = (int)player->query_hp();
   if (number > current || !protecting || !thing)
      return (int)player->set_hp( number, thing );
   return current;
} /* set_hp() */
 
/*
 * Hopefully there's no way a PKer can call these directly...
 *
 * void do_death() { return; }
 * int second_life() { return 1; }
*/

int cannot_walk()
{
  if (!can_be_nasty()) {
    notify_fail("You can't leave while your subduer is here.\n");
    return 1;
  }
  zap_surrender_shadow();
  return player->cannot_walk();
}

int attack_by( object thing ) {
   if (!protecting)
      return (int)player->attack_by( thing );
   tell_object( thing, (string)player->the_short() +
         " is protected from combat by "+ protector +".\n" );
   tell_object( player, "You are protected from combat by "+
         protector +".\n" );
   thing->stop_fight( player );
   return 0;
} /* attack_by() */

int attack_ob( object thing ) {
  if (!can_be_nasty())
    return 0;
  zap_surrender_shadow();
  return (int)player->attack_ob( thing );
} /* attack_ob() */

int query_unambushable() { return 1; }

void do_ambushed() {
   write( protector +" stops you from harming "+
         (string)player->the_short() +".\n" );
   tell_object( player, protector +" stops "+
         (string)this_player()->the_short() +" from harming you.\n" );
} /* do_ambushed() */

int no_offense() {
  if (!can_be_nasty())
    return 1;
  zap_surrender_shadow();
  return (int)player->no_offense();
} /* no_offense() */

mixed query_property( string word ) {
  if (protecting && word == "no attack")
    return 1;
  return (mixed)player->query_property( word );
} /* query_property() */

int query_player_killer() {
   return 0;
}

int command_shadowed( string verb, string args ) {
  if ( member_array( verb, ({ "cast", "scathe" }) ) == -1 )
    return (int)player->command_shadowed( verb, args );
  if (!can_be_nasty())
    return notify_fail("You can't do that while you're subdued\n");
  zap_surrender_shadow();
  return (int)player->command_shadowed( verb, args );
} /* command_shadowed() */

varargs int adjust_xp( int number, int shared ) {
#ifdef DEBUG
  log_file( "PROTECTED", ctime( time() ) +": "+ (string)player->query_name() +
         " gained "+ number +"xp ["+ implode( map_array( previous_object( -1 ),
         (: file_name( $1 ) :) ), ", " ) +"]\n" );
#endif  
   return (int)player->adjust_xp( number, shared );
} /* adjust_xp() */

varargs int add_skill_level( string skill, int lvl, mixed exp ) {
   string what;
   if ( !exp )
      exp = previous_object();
   if ( objectp( exp ) )
      what = " from "+ file_name( exp );
   else
      what = " for "+ exp +"xp";
#ifdef DEBUG
   log_file( "PROTECTED", ctime( time() ) +": "+ (string)player->query_name() +
         " gained "+ lvl +" in "+ skill + what +" ["+
         implode( map_array( previous_object( -1 ), (: file_name( $1 ) :) ),
         ", " ) +"]\n" );
#endif   
   return (int)player->add_skill_level( skill, lvl, exp );
} /* add_skill_level() */

int test_remove(object thing, int flag, mixed dest)
{
  allowed -= ({ 0 });
  if (member_array(this_player(), allowed) != -1)
    return 1;
  else
    return player->test_remove(thing, flag, dest);
}

int allowed_to_loot(object who, object obj)
{
  if (member_array(who, allowed) != -1) {
    object wb;

    if (!obj)
      return 1;
    wb = obj->query_worn_by();
    if (wb == player && player->remove_armour(obj))
      return 0;
    return 1;
  } else
    return player->allowed_to_loot(who);
}

void dest_surrender_shadow()
{
  /* When the shadow wears off, NPCs should run off to /room/rubbish */
  if (!player->query_property("player")) {
    player->move("/room/rubbish", "",
      player->one_short() + " runs off to recuperate.");
  } else {
    tell_object(player, "You feel that you can leave now.\n");
  }
  destruct(this_object());
}

int query_sanctuary()
{
  if (protecting) return 1;
  else return player->query_sanctuary();
}

int do_quit()
{
  if (!can_be_nasty()) {
    write("You cannot quit while your subduer is here.\n");
    return 1;
  }
  return player->do_quit();
}

int quit_alt()
{
  if (!can_be_nasty()) {
    write("You cannot quit while your subduer is here.\n");
    return 1;
  }
  return player->do_quit();
}
// --- END [/mnt/home2/grok/lib/std/shadows/misc/surrender_shadow.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shadows/misc/marry_shadow.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shadows/misc/marry_shadow.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629087   Available: 13576441
Inodes: Total: 5242880    Free: 4960135
8892 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shadows/misc/marry_shadow.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629087   Available: 13576441
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: marry_shadow.c,v 1.2 2003/02/15 20:13:45 pinkfish Exp $
 * $Log: marry_shadow.c,v $
 * Revision 1.2  2003/02/15 20:13:45  pinkfish
 * Fix up some stuff.
 *
 * Revision 1.1  1998/01/06 04:39:04  ceres
 * Initial revision
 * 
*/
/* The wonderful fully interactive marriage shadow by Olorin, 
 * the response mappings basically contain the recognised
 * responses of different types of interaction, if an entry is an 
 * array, both strings have to be in the response ie. shake head is
 * recognized as refusal, shake flipper isn't.
 */

#include "/cmds/guild-race/masters/marry.h"

#define RING "/obj/misc/wedding_ring.c"

#define LOG "/w/olorin/responselog"
#define MAXLOG 8000          

object player, marry1, marry2, ring1, ring2;
int found, response_index;
string asking, askingwho, *words, *yes_array, *no_array;
mapping local_prop, yes_response, no_response;

void do_accept();
void do_refuse();

void create() {
   yes_response = ([ "say":({ "yes", "yep", "sure", "ok", 
                     ({ "will" , "i" }), ({ "do" , "i" }) }), 
                     "soul":({ "nod" , "ack", }) ]);
   no_response = ([ "say":({ "no", "nope", ({ "won't", "i" }), 
                          ({ "don't", "i" }), ({ "can't", "i" }), 
                    "cannot" }), 
                    "soul":({ ({ "shake" , "head" }), "panic", "puke" }) ]);
   local_prop = ([ MARRYPROP : 1, ]);        /* I am performing a wedding */
} /* create() */

object add_marry_shadow( object p, object m1, object m2 ) {
   player = p;
   marry1 = m1;
   marry2 = m2;
   askingwho = (string)marry1->query_name();   /* who am I asking now */
   asking = ASKFIRST;          /* where am I in the ceremony */
   tell_object( player, "Now you should ask " +
         (string) marry1->query_short() + " whether " +
         (string) marry1->query_pronoun() + " will marry " +
         (string) marry2->query_short() + "\n");
   return shadow( p, 1 );
} /* add_marry_shadow() */

/* removing annoying readmarks..  Like .'s and ?'s, taken from response_mon */
string remove_read_marks(string str) {
   int index, size;
   string result;
   string temp;
 
   index = 0;
   size = strlen(str);
   result = "";
   while (index < size) {
      temp = str[index..index];
      if (((temp >= "a") && (temp <= "z")) ||
    (temp == " ") || (temp == "'")) result += temp;
      else result += " ";
      index++;
   }
  return result;
} /* remove_read_marks() */

void check_response( string resptype, string mess ) {
   if ( mess && strlen( mess ) ) {
      mess = lower_case( mess );
      mess = remove_read_marks(mess);
      words = explode( mess, " " );
      yes_array = yes_response[ resptype ];
      no_array = no_response[ resptype ];
      response_index = sizeof( yes_array );
      while ( response_index-- ) {
   if ( !stringp( yes_array[ response_index ] ) ) {
      if ( ( member_array( yes_array[ response_index ][ 0 ], 
         words ) != -1 ) && 
     ( member_array( yes_array[ response_index ][ 1 ], 
         words ) != -1 ) ) {
         do_accept();
         return;
      }
   } else {
      if ( member_array( yes_array[ response_index ], words ) != -1 ) {
             do_accept();
         return;
      } 
   }
      }
      response_index = sizeof( no_array );
      while ( response_index-- ) {
   if ( !stringp( no_array[ response_index ] ) ) {
      if ( ( member_array( no_array[ response_index ][ 0 ], 
         words ) != -1 ) && 
     ( member_array( no_array[ response_index ][ 1 ], 
         words ) != -1 ) ) {
         do_refuse();
         return;
      }
   } else {
      if ( member_array( no_array[ response_index ], words ) != -1 ) {
         do_refuse();
         return;
      } 
   }
      }
#ifdef LOG
      /* for getting more ideas */
      if ( file_size( LOG ) <= MAXLOG)
  unguarded((: write_file, LOG , 
             "MARRY response: "+resptype+": '"+mess+"'\n" :));
#endif
   }
}
   
void event_person_say( object ob, string start, string mess, string lang ) {
   if ( ob->query_name() == askingwho ) {
      check_response("say", mess);
   }
   player->event_person_say( ob, start, mess, lang );
   return;
}  /* event_person_say() */

void event_person_tell(object ob, string start, string mess, string lang) {
   if ( ob->query_name() == askingwho ) {
      check_response("say", mess);
   }
   player->event_person_tell( ob, start, mess, lang );
   return;
}  /* event_person_tell() */

void event_soul(object ob, string mess, object *avoid, string verb,
                string last, mixed at) {
   if ( sizeof( avoid ) &&
       avoid[0]->query_name() == askingwho ) {
      check_response( "soul", mess );
   }
   response_index = sizeof( avoid );
   while ( response_index-- ) {
      if ( avoid[ response_index ] == player ) {
   return;
      }
   }
   tell_object( player, mess );
   return;
}  /* event_soul() */

void do_accept() {
   if ( asking == ASKFIRST ) {
      asking = ASKSECOND;
      askingwho = (string) marry2->query_name();
      tell_object( player, (string) marry1->query_pronoun() +
      " accepted. Now you should ask " +
      (string) marry2->query_short() + " whether " +
      (string) marry2->query_pronoun() + " will marry " +
      (string) marry1->query_short() + "\n" );
      tell_object( marry1, "You accepted.\n" );
   } else if ( asking == ASKSECOND ) {
      asking = DONEASK;
      askingwho = "*NoOne*"; /* I don't think this will match the name of anyone */
      tell_object( player, (string) marry2->query_pronoun() +
      " accepted. Now you can ask if there are any objections or" +
      " you can finalize the wedding with 'marry them'.\n" );
      tell_object( marry2, "You accepted.\n" );
   } else {
      tell_object( player, "Something is wrong here, please tell Olorin " +
      "what you where doing.\n" );
#ifdef LOG
     unguarded((: write_file, LOG ,
                "marry_error "+   /* this is for debugging! */
     "in accept:" + asking + ";" + askingwho + "(" +
     (string) marry1->query_short() + " to " +
     (string) marry2->query_short() + ")" :));
#endif
      call_out( "remove_propose_shadow", 0 );
   }
} /* do_accept() */

void do_refuse() {
   if ( asking == ASKFIRST ) {
      tell_object( player, (string) marry1->query_pronoun() +
      " wimpied out.\n" );
      tell_object( marry1, "You refused, the marriage is off.\n" );
   } else if ( asking == ASKSECOND ) {
      tell_object( player , (string) marry2->query_pronoun() +
      " wimpied out.\nYou'd better try to console " +
      (string) marry1->query_short() + "\n" );
      tell_object( marry2, "You refused, how will you explain that to "+
      (string) marry1->query_short() + ".\n" );
   } else {
      tell_object( player, "Something is wrong here, please tell Olorin " +
      "what you where doing.\n" );
#ifdef LOG
      unguarded((: write_file, LOG ,
                 "marry_error"+   /* this is for debugging! */
     "in refuse:" + asking + ";" + askingwho + "(" +
     (string) marry1->query_short() + " to " +
     (string) marry2->query_short() + ")" :));
#endif
   }
   call_out( "remove_marry_shadow", 0 );
} /* do_refuse() */

mixed query_property( string str ) {
   if ( str == MARRYPROP ) {
      return 1; /* I *am* doing a wedding */
   } else {
      return player->query_property( str );
   }
} /* query_property() overridden because Deutha don't like  
   * having properties rattling around in the player object *grin*
   */

int do_wedding() {
   if ( environment( player ) == environment( marry1 ) ) {
      if ( environment( player ) == environment( marry2 ) ) {
   marry1->add_property( "spouse", marry2->query_name() );
   marry2->add_property( "spouse", marry1->query_name() );
   ring1 = clone_object( RING );
   ring1->set_owner( marry1->query_short() );
   ring1->set_giver( marry2->query_short() );
   ring1->move( marry1 );
   ring2 = clone_object( RING );
   ring2->set_owner( marry2->query_short() );
   ring2->set_giver( marry1->query_short() );
   ring2->move( marry2 );
   tell_object( player, "They are now married, you'd better tell them.\n" );
   call_out( "remove_marry_shadow", 0 );
   return 1;
      } else {
   tell_object( player, marry2->query_short() +
         " seems to have wandered off.\n" +
         "Perhaps you should try to console " +
         (string) marry1->query_short() + "\n" );
      }
   } else {
      tell_object( player, marry2->query_short() +
      " seems to have wandered off.\n" +
      "Perhaps you should try to console " +
      (string) marry2->query_short()+"\n" );
   }
   call_out( "remove_marry_shadow", 0 );
   return 0;
} /* do_wedding() */

int abort_wedding() {
   call_out( "remove_marry_shadow", 0 );
   return 0;  /* returns 0 because the marry command is failing */
} /* abort_wedding() */

void remove_marry_shadow() {
   destruct( this_object() ); 
   return;
} /* remove_marry_shadow() */

// --- END [/mnt/home2/grok/lib/std/shadows/misc/marry_shadow.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shadows/misc/surface.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shadows/misc/surface.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629085   Available: 13576439
Inodes: Total: 5242880    Free: 4960135
976 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shadows/misc/surface.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629085   Available: 13576439
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: surface.c,v 1.1 1998/01/06 04:39:04 ceres Exp $
 * $Log: surface.c,v $
 * Revision 1.1  1998/01/06 04:39:04  ceres
 * Initial revision
 * 
*/
object shadowed, surface;

void setup_shadow( object thing1, object thing2 ) {
  shadow( thing1, 1 );
  shadowed = thing1;
  surface = thing2;
} /* setup_shadow() */

object query_shadowed( object thing ) {
  if ( thing == this_object() ) return shadowed;
  return (object)thing->query_shadowed( thing );
} /* query_shadowed() */

object *find_inv_match( string words ) {
  object *things;
  things = (object *)shadowed->find_inv_match( words );
  if ( surface )
    things += (object *)surface->find_inv_match( words );
  else
    call_out( "destruct_shadow", 1, this_object() );
  return things;
} /* find_inv_match() */

void destruct_shadow( object thing ) {
  if ( thing == this_object() ) destruct( this_object() );
  else thing->destruct_shadow( thing );
} /* destruct_shadow() */
// --- END [/mnt/home2/grok/lib/std/shadows/misc/surface.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shadows/misc/concealment.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shadows/misc/concealment.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629084   Available: 13576438
Inodes: Total: 5242880    Free: 4960135
1390 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shadows/misc/concealment.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629084   Available: 13576438
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: concealment.c,v 1.1 1998/01/06 04:39:04 ceres Exp $
 * $Log: concealment.c,v $
 * Revision 1.1  1998/01/06 04:39:04  ceres
 * Initial revision
 * 
*/
object shadowed, *concealed;

void setup_shadow( object thing ) {
   shadow( thing, 1 );
   shadowed = thing;
   concealed = ({ });
} /* setup_shadow() */

void destruct_shadow( object thing ) {
   if ( thing == this_object() )
      destruct( this_object() );
   else
      thing->destruct_shadow( thing );
} /* destruct_shadow() */

void add_concealed( object thing ) {
   concealed -= ({ 0 });
   if ( member_array( thing, concealed ) == -1 )
      concealed += ({ thing });
} /* add_concealed() */

int set_worn_by( object thing ) {
   int weight;
   if ( thing == (object)shadowed->query_worn_by() )
      return 1;
   if ( !shadowed->set_worn_by( thing ) )
      return 0;
   weight = (int)shadowed->query_weight();
   concealed -= ({ 0 });
   foreach ( thing in concealed ) {
      if ( (int)thing->query_complete_weight() > random( weight ) )
         thing->remove_hide_invis( "concealed" );
   }
   call_out( "destruct_shadow", 0, this_object() );
   return 1;
} /* set_worn_by() */

mixed *stats() {
   concealed -= ({ 0 });
   return ({
      ({ "concealing", array_to_string( concealed ) })
   }) + (mixed *)shadowed->stats();
} /* stats() */

int query_concealing() { return 1; }
// --- END [/mnt/home2/grok/lib/std/shadows/misc/concealment.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shadows/misc/offler_shadow.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shadows/misc/offler_shadow.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629084   Available: 13576438
Inodes: Total: 5242880    Free: 4960135
1864 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shadows/misc/offler_shadow.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629084   Available: 13576438
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: offler_shadow.c,v 1.2 2000/04/26 14:18:40 rhinehold Exp $
 * $Log: offler_shadow.c,v $
 * Revision 1.2  2000/04/26 14:18:40  rhinehold
 * modified the shadowed adjust_hp to make sure the new arguments were caught and passed.
 *
 * Revision 1.1  1998/01/06 04:39:04  ceres
 * Initial revision
 * 
*/
object player;

void setup_shadow( object thing ) {
   shadow( thing, 1 );
   player = thing;
} /* setup_shadow() */

void dest_offler_shadow() { destruct( this_object() ); }

int adjust_hp( int number, object thing, object weapon, string attack ) {
   if ( number > 0 )
      return (int)player->adjust_hp( number, thing, weapon, attack );
   else
      return (int)player->query_hp();
} /* adjust_hp() */

int set_hp( int number, object thing ) {                     
   int current;
   current = (int)player->query_hp();
   if ( number > current )
      return (int)player->set_hp( number, thing );
   else
      return current;
} /* set_hp() */
 
void do_death() { return; }
int second_life() { return 1; }

int attack_by( object thing ) {
   tell_object( thing, (string)player->the_short() +
         " is prevented from fighting by Offler.\n" );
   thing->stop_fight( this_object() );
   return 0;
} /* attack_by() */

int attack_ob( object thing ) {
   tell_object( player, "You are prevented from fighting by Offler.\n" );
   thing->stop_fight( this_object() );
   return 0;
} /* attack_ob() */

int query_unambushable() { return 1; }

void do_ambushed() {
   write( "You suddenly see a terrifying image of a huge crocodile!\n" );
   this_player()->run_away();
} /* do_ambushed() */

int no_offense() {
   write( "You are prevented from offensive actions by Offler.\n" );
   return 1;
} /* no_offense() */

int cast() {
   write( "You are about to start when Offler stops you.\n" );
   return 1;
} /* cast() */
// --- END [/mnt/home2/grok/lib/std/shadows/misc/offler_shadow.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shadows/misc/effects.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shadows/misc/effects.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629083   Available: 13576437
Inodes: Total: 5242880    Free: 4960135
1242 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shadows/misc/effects.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629083   Available: 13576437
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: effects.c,v 1.3 2000/05/08 18:05:06 pinkfish Exp $
 * $Log: effects.c,v $
 * Revision 1.3  2000/05/08 18:05:06  pinkfish
 * Fix up the shadow to work correctly with the effects inheritable using
 * private variables.
 *
 * Revision 1.2  1999/04/21 11:47:21  wodan
 * fixed small bug in stats function
 *
 * Revision 1.1  1998/01/06 04:39:04  ceres
 * Initial revision
 * 
*/
#define EFF_OB_NAME 0
#define EFF_ARG 1

#define EEQ_INCTIME 0
#define EEQ_FUNC 1
#define EEQ_EFF_OB 2
#define EEQ_INTERVAL 3
#define EEQ_FLAGS 4

#define EFF_SIZE 2
#define EEQ_SIZE 5

inherit "/std/basic/effects";

private object shadowed;

void setup_shadow( object thing ) {
   shadow( thing, 1 );
   shadowed = thing;
} /* setup_shadow() */

void destruct_shadow( object thing ) {
   if ( thing == this_object() ) {
      destruct( this_object() );
   } else {
      thing->destruct_shadow( thing );
   }
} /* destruct_shadow() */

void set_effs( mixed *args ) {
  ::set_effs(args);
} /* set_effs() */

void set_eeq( mixed *args ) {
  ::set_eeq(args);
} /* set_eeq() */

mixed *stats() {
  mixed *tmp = (mixed *)shadowed->stats();

  if(!arrayp(tmp)) {
    tmp = ({});
  }
  return ::stats() + tmp; 
} /* stats() */
// --- END [/mnt/home2/grok/lib/std/shadows/misc/effects.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shadows/misc/davidshad.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shadows/misc/davidshad.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629083   Available: 13576437
Inodes: Total: 5242880    Free: 4960135
1417 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shadows/misc/davidshad.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629083   Available: 13576437
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* Shadow to protect against: magic smoke and other things that use
 * run_away, ranged weapons (long shot), and KLK insects. Thanks to
 * Ceres for coding the octagon, which I borrowed a better part of
 * this code from. - Aragorn
 */

object player;

void setup_shadow( object thing ) {
   shadow( thing, 1 );
   player = thing;
} /* setup_shadow() */

void dest_shadow() { destruct( this_object() ); }

void run_away() {
  tell_object(player, "You feel too peaceful to run away.\n");
}

int pk_check( mixed thing1, mixed thing2, int off_line ) {
  return 1;
}

void start_attack(){}


//Changed so you no longer regen HP or GP while you're in here.
//It makes a nice incentive not to stay in here indefinately, 
//also it stops situations where the player exposes themselves to 
//a slow damage source [such as holy sacrifice, or a slow poison]
//and then reaps the gain while standing in here to avoid to
//penalty.
void adjust_hp( int number, object attacker ) {

  if(player->query_attacker_list()) {
    foreach(attacker in player->query_attacker_list()) {
      attacker->stop_fight(player);
      player->stop_fight(attacker);
    }
  }
  
  //if( number < 0 )
    return;

  //player->adjust_hp( number );
}

void adjust_gp( int number ) {
  if ( number < 0 ) 
    return player->adjust_gp( number );
  return;
}

int attack_by(object ob) {
  ob->stop_fight(player);
  player->stop_fight(ob);
  return 1;
}
// --- END [/mnt/home2/grok/lib/std/shadows/misc/davidshad.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shadows/misc/water.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shadows/misc/water.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629082   Available: 13576436
Inodes: Total: 5242880    Free: 4960135
22711 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shadows/misc/water.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629082   Available: 13576436
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: water.c,v 1.12 2002/08/03 22:27:04 ceres Exp $
 * $Log: water.c,v $
 * Revision 1.12  2002/08/03 22:27:04  ceres
 * Fixed skill names
 *
 * Revision 1.11  2002/03/09 20:20:04  tannah
 * Made add_property recognise the third parameter.
 *
 * Revision 1.10  2002/03/01 23:28:25  tannah
 * Made it check for use_base_stats before returning modified bonus, and checked
 * for query_verb() == "skills", too.
 * Made it recalculate bonus whenever query_skill_bonus() is called.
 *
 * Revision 1.9  2002/02/21 14:03:50  taffyd
 * Forced it to recalculate the burdening.
 *
 * Revision 1.8  2002/02/21 13:21:17  presto
 *  Forcibly unlocked by taffyd
 *
 * Revision 1.7  2001/06/07 14:47:41  wobin
 * Added in cascading to do_soak for shadowed functions
 *
 * Revision 1.6  1999/05/25 23:39:50  pinkfish
 * Make it more error safe.
 *
 * Revision 1.5  1999/04/06 00:34:04  ceres
 * Modified to allow query_skill_bonus() to work for the swimming skill.
 *
 * Revision 1.4  1999/03/05 21:06:08  pinkfish
 * Fix up some errors that Mystic pointer out.
 *
 * Revision 1.3  1999/03/05 21:04:05  presto
 *  Forcibly unlocked by pinkfish
 *
 * Revision 1.2  1998/05/14 00:43:52  presto
 * Slave work for Jeremy. :)
 *
 * Revision 1.1  1998/01/06 04:39:04  ceres
 * Initial revision
 *
*/
#include <move_failures.h>

#define SWIMMING_SKILL "other.movement.swimming"
#define STAMINA_SKILL "other.health"
#define BUOYANT_PROP "buoyancy"
#define ANCHOR_PROP "anchor"
#define GILLS_PROP "gills"
#define TROLL_RACE "troll"

object swimmer;
int bonus, buoyancy, drown_stage, swimming = 0, recheck_delay = -1;
string sweep_dir = "";


void calc_swim_bonus();
int abs( int i );
void test_sweep();
void test_float();
void test_drown();
string sweep_string( mixed *dest_other_info, int pos );
varargs int exit_command( string word, mixed verb, object thing );

int abs( int i )  {  return i < 0 ? -i : i;  }

int start_floating();
int start_swimming();

void setup_shadow( object this_swimmer )  {
   shadow( this_swimmer, 1 );
   swimmer = this_swimmer;
   calc_swim_bonus();
}  /* setup_shadow() */


void event_enter( object ob, string message, object from )  {
   int old_bonus, old_buoy;

   if (swimmer) {
      swimmer->event_enter( ob, message, from );
   }
   old_bonus = bonus;
   old_buoy = buoyancy;
   calc_swim_bonus();
   if ( bonus != old_bonus )  test_sweep();
   if ( buoyancy != old_buoy )  {
      buoyancy += (int)ob->query_property( BUOYANT_PROP );
      test_float();
   }
   return;
}  /* event_enter() */


void event_exit( object ob, string message, object to )  {
   int old_bonus, old_buoy;

   if (swimmer) {
      swimmer->event_exit(ob, message, to);
   }
   old_bonus = bonus;
   old_buoy = buoyancy;
   calc_swim_bonus();
   if ( bonus != old_bonus )  test_sweep();
   if ( buoyancy != old_buoy )  {
      buoyancy -= (int)ob->query_property( BUOYANT_PROP );
      test_float();
   }
   return;
}  /* event_exit() */


void calc_swim_bonus()  {
   float pct;
   object *held;

   if ( living( swimmer )  &&
        ( held = (object *)swimmer->query_holding() ) )  {

      // Force a recalculation of their weight.
      swimmer->calc_burden();
      bonus = (int)swimmer->query_skill_bonus( SWIMMING_SKILL ) /
                            ( sizeof( held - (object *)({ 0 }) ) + 1 );
      buoyancy = bonus - (int)swimmer->query_loc_weight() +
                      (int)swimmer->query_property( BUOYANT_PROP );
      if ( (string)swimmer->query_race() == TROLL_RACE )  buoyancy -= 300;
      if ( buoyancy < 0  &&  bonus )  {
         pct = -buoyancy / bonus;
         if ( pct < 1.0 )  {
            bonus += buoyancy;
            buoyancy = 0;
         }
         else  {
            pct -= 1.0;
            buoyancy *= pct;
            bonus = 0;
         }
      }
   } else  {
      if (swimmer) {
         bonus = (int)swimmer->query_property( ANCHOR_PROP );
         buoyancy = (int)swimmer->query_property( BUOYANT_PROP ) -
                    (int)swimmer->query_weight();
      }
   }

   return;
}  /* calc_swim_bonus() */


void add_property( string prop, mixed val, int time )  {
   if (swimmer) {
      swimmer->add_property( prop, val, time );
   }
   if ( prop == GILLS_PROP  &&  val > 0 )  remove_call_out("do_drown");
   if ( prop == BUOYANT_PROP  &&  val )  {
      calc_swim_bonus();
      test_float();
   }
   return;
}  /* add_property() */


void remove_property( string prop )  {
   if (swimmer) {
     swimmer->remove_property( prop );
   }
   if ( prop == GILLS_PROP )  test_drown();
   else if ( prop == BUOYANT_PROP )  {
      calc_swim_bonus();
      test_float();
   }
   return;
}  /* remove_property() */


int add_skill_level( string skill, int lev )  {
   int lvl;

   if ( living(swimmer) )  {
      lvl = (int)swimmer->add_skill_level( skill, lev );
      if ( skill == SWIMMING_SKILL  &&  lev )  {
         calc_swim_bonus();
         test_sweep();
         test_float();
      }
      return lvl;
   }
   else return 0;
}  /* add_skill_level() */


/* Added to allow the use of query_skill_bonus directly and still
 * obtain the correct result. -- Ceres
 */
varargs int query_skill_bonus( string skill, int use_base_stats ) {
  if( ( skill == SWIMMING_SKILL ) &&
      ( !use_base_stats ) &&
      ( query_verb() != "skills" ) ) {
    calc_swim_bonus();
    return bonus;
  }
  return swimmer->query_skill_bonus(skill, use_base_stats);
}

int query_swim_bonus()  {  return bonus;  }

int query_buoyancy()  {  return buoyancy;  }


void test_sweep()  {
   mapping flows, possible;
   int total_flow, r, f, s, flow_rate;
   string *dirs, dir, *dest_dir_info;
   object room;

   s = find_call_out( "do_sweep" );
   room = environment( swimmer );
   flows = (mapping)room->query_flows();
   dest_dir_info = (string *)room->query_dest_dir();
   f = ( 300 - ( evaluate( flows[ sweep_dir ] ) - swimming * bonus ) ) / 30;
   if ( f < 0 )  f = 0;
   f += room->query_min_sweep_delay( sweep_dir );
   if ( s > f )  {
      remove_call_out( "do_sweep" );
      call_out( "do_sweep", f,
                dest_dir_info[ member_array( sweep_dir,
                                             dest_dir_info ) + 1 ] );
   }
   else if ( s == -1  ||
             (int)room->query_flow( sweep_dir ) - swimming * bonus <= 0 )  {
      remove_call_out( "do_sweep" );
      dirs = keys( flows );
      total_flow = 0;
      possible = ([ ]);
      foreach ( dir in dirs )  {
         flow_rate = evaluate( flows[ dir ] );
         if ( ( f = flow_rate - swimming * bonus ) > 0  &&  flow_rate > 0)  {
            total_flow += f;
            possible += ([ dir : f ]);
         }
      }

      r = random( total_flow );
      dirs = keys( possible );
      total_flow = 0;

      foreach ( dir in dirs )  {
         if ( r < total_flow + possible[ dir ] )  {
            sweep_dir = dir;
            f = ( 300 - possible[ dir ] ) / 30;
            if ( f < 0 )  f = 0;
            f += room->query_min_sweep_delay( dir );
//tell_object(swimmer, "Calling do sweep, delay = " + f + ", direction = " + dir + "\n" );
            call_out( "do_sweep", f,
                      dest_dir_info[ member_array( sweep_dir,
                                                   dest_dir_info ) + 1 ] );
            return;
         }
         else total_flow += possible[ dir ];
      }
   }
   return;
}  /* test_sweep() */


void test_float()  {
   object room;
   int s, t;

   room = environment( swimmer );
   if ( buoyancy < 0 )  {
      remove_call_out( "do_rise" );
      s = find_call_out( "do_sink" );
      if ( !( room->query_bottom() ) )  {
         t = (300 + buoyancy) / 30;
         if ( s > t )  {
            remove_call_out( "do_sink" );
            s = -1;
         }
         if ( s == -1 )  {
            call_out( "do_sink", t + room->query_min_sweep_delay( room->
                         query_down_dir() ) );
            swimmer->add_property( "there",
                                   (string)room->query_nonfloat_mess() );
         }
      }
      else  {
         swimmer->add_property( "there", (string)room->query_bottom_mess() );
         if ( s > -1 )  remove_call_out( "do_sink" );
      }
   }
   else if ( buoyancy > bonus )  {
      remove_call_out( "do_sink" );
      s = find_call_out( "do_rise" );
      if ( !( room->query_surface() ) )  {
         t = (300 - buoyancy) / 30;
         if ( s > t )  {
            remove_call_out( "do_rise" );
            s = -1;
         }
         if ( s == -1 )  {
            call_out( "do_rise", t + room->query_min_sweep_delay( room->
                         query_up_dir() ) );
            swimmer->add_property( "there",
                                   (string)room->query_float_mess() );
         }
      }
      else if ( s > -1 )  remove_call_out( "do_rise" );
   }
   else  {
      remove_call_out( "do_rise" );
      remove_call_out( "do_sink" );
      swimmer->add_property( "there", (string)room->query_float_mess() );
   }
   return;
}  /* test_float() */


void test_drown()  {
   int delay;

   if ( environment( swimmer )->query_surface() )
      remove_call_out("do_drown");
   else if ( find_call_out( "do_drown" ) == -1  &&
             !( swimmer->query_property( GILLS_PROP ) ) )  {
      delay = (int)swimmer->query_skill_bonus( STAMINA_SKILL ) / 20;
      if ( delay < 15 )  delay = 15;
      call_out( "do_drown", delay );
      drown_stage = 0;
   }
   return;
}  /* test_drown() */


void do_sweep( string dest )  {
   mixed *dest_other_info;
   object room;

   room = environment(swimmer);
   if ( environment( swimmer )->query_terrain() )
      environment( swimmer )->set_destination( sweep_dir );
   dest_other_info = (mixed *)room->query_dest_other();
   if ( !( swimmer->query_property("player") ) )
      swimmer->move( dest,
                     replace_string( (string)room->query_sweep_in_mess(),
                                     "$F",sweep_string( dest_other_info,
                                        member_array( sweep_dir,
                                          dest_other_info ) + 1 ) ),
                     replace_string( (string)room->query_sweep_out_mess(),
                                     "$T", sweep_dir ) );
   else  {
      tell_object( swimmer, "The current pulls you " + sweep_dir + ".\n" );
      swimmer->move_with_look( dest,
                               replace_string( (string)room->
                                               query_sweep_in_mess(), "$F",
                                               sweep_string( dest_other_info,
                                                 member_array( sweep_dir,
                                                   dest_other_info ) + 1 ) ),
                               replace_string( (string)room->
                                               query_sweep_out_mess(), "$T",
                                               sweep_dir ) );
   }
   return;
}  /* do_sweep() */


void do_sink()  {
   string dir;
   mixed *dest_other_info;
   int i;
   object room;

   room = environment(swimmer);
   dir = (string)room->query_down_dir();
   if ( environment( swimmer )->query_terrain() )
      environment( swimmer )->set_destination( dir );
   dest_other_info = (mixed *)room->query_dest_other();
   if ( ( i = member_array( dir, dest_other_info ) ) > -1 )  {
      if ( !( swimmer->query_property("player") ) )
         swimmer->move( dest_other_info[ i + 1 ][0],
                        replace_string( (string)room->query_sink_in_mess(),
                                        "$F", sweep_string( dest_other_info,
                                          i + 1 ) ),
                        replace_string( (string)room->query_sink_out_mess(),
                                        "$T", dir ) );
      else  {
         tell_object( swimmer, "You sink toward the bottom.\n" );
         swimmer->move_with_look( dest_other_info[ i + 1 ][0],
                                  replace_string( (string)room->
                                                          query_sink_in_mess(),
                                        "$F", sweep_string( dest_other_info,
                                          i + 1 ) ),
                                  replace_string( (string)room->
                                                     query_sink_out_mess(),
                                                  "$T", dir ) );
      }
   }
   return;
}  /* do_sink() */


void do_rise()  {
   string dir;
   mixed *dest_other_info;
   int i;
   object room;

   room = environment( swimmer );
   dir = (string)room->query_up_dir();
   if ( environment( swimmer )->query_terrain() )
      environment( swimmer )->set_destination( dir );
   dest_other_info = (mixed *)room->query_dest_other();
   if ( ( i = member_array( dir, dest_other_info ) ) > -1 )  {
      if ( !( swimmer->query_property("player") ) )
         swimmer->move( dest_other_info[ i + 1 ][0],
                        replace_string( (string)room->query_float_in_mess(),
                                        "$F", sweep_string( dest_other_info,
                                          i + 1 ) ),
                        replace_string( (string)room->query_float_out_mess(),
                                        "$T", dir ) );
      else  {
         tell_object( swimmer, "You drift toward the surface.\n" );
         swimmer->move_with_look( dest_other_info[ i + 1 ][0],
                                  replace_string( (string)room->
                                                     query_float_in_mess(),
                                     "$F", sweep_string( dest_other_info,
                                       i + 1 ) ),
                                  replace_string( (string)room->
                                                     query_float_out_mess(),
                                                  "$T", dir ) );
      }
   }
   return;
}  /* do_rise() */


void do_drown()  {
   string *exits, up;
   int delay;

   delay = (int)swimmer->query_skill_bonus( STAMINA_SKILL ) / 5;
   if ( delay < 15 )  delay = 15;
   switch ( drown_stage )  {
      case 0:
         tell_object( swimmer, "Your lungs start to feel a bit heavy.\n" );
         tell_room( environment( swimmer ), (string)swimmer->query_short() +
                    " begins to look a bit uncomfortable.\n", swimmer );
         call_out( "do_drown", delay );
         break;
      case 1:
         tell_object( swimmer, "Your lungs are starting to burn.\n" );
         tell_room( environment( swimmer ), (string)swimmer->query_short() +
                    " starts to look slightly blue.\n", swimmer );
         call_out( "do_drown", delay );
         break;
      case 2:
         tell_object( swimmer, "Your lungs are fairly bursting.\n" );
         tell_room( environment( swimmer ), (string)swimmer->query_short() +
                    " begins to look panicky.\n", swimmer);
         call_out( "do_drown", delay );
         break;
      default:
         swimmer->adjust_hp( ( 2 - drown_stage ) * 5 *
                             ( 30 - (int)swimmer->query_con() ) );
         if ( swimmer->query_hp() > 0 )  {
            call_out( "do_drown", delay );
            exits = (string *)environment( swimmer )->query_dest_dir();
            if ( member_array( up = (string)environment( swimmer )->
                                            query_up_dir(),
                               exits ) > -1 )  {
               tell_object( swimmer, "You panic and try to flee for the "
                            "surface.\n" );
               tell_room( environment( swimmer ),
                          (string)swimmer->query_short() + " panics and madly "
                          "tries to flee for the surface.\n", swimmer );
               swimmer->exit_command( up );
            }
            else  {
               up = exits[ random( sizeof( exits ) ) / 2 ];
               tell_object( swimmer, "You panic and try to flee " + up +
                            ".\n" );
               tell_room( environment( swimmer ),
                          (string)swimmer->query_short() + " panics and tries "
                          "to flee " + up + ".\n", swimmer );
               swimmer->exit_command( up );
            }
         }
         else swimmer->attack_by( environment( swimmer ) );
         break;
   }
   ++drown_stage;
   return;
}  /* do_drown() */


// Changed slightly by Ceres to make it simpler, if youre swimming it
// makes you soaked immediately now.
void do_soak()  {
   swimmer->add_effect("/std/effects/other/wetness", swimmer->query_weight());
   swimmer->do_soak();
}  /*  do_soak()  */


void cancel_sweep()  {
   remove_call_out( "do_sweep" );
   sweep_dir = "";
   return;
}  /* cancel_sweep() */


void dest_water_shadow()  {
   remove_call_out( "do_sweep" );
   remove_call_out( "do_rise" );
   remove_call_out( "do_sink" );
   remove_call_out( "do_drown" );
   remove_call_out( "do_soak" );
   remove_call_out( "test_again" );
   if (swimmer) {
      swimmer->remove_property("there");
   }
   destruct( this_object() );
   return;
}  /* dest_water_shadow() */


object find_water_shadow()  {  return this_object();  }


int command_shadowed( string verb, string args )  {
   string my_mess, others_mess;

   my_mess = 0;
   if ( !( environment( swimmer )->query_surface() ) )  {
      if ( verb == "say"  ||  verb == "'" )  {
         my_mess = "You try to talk, but only generate some bubbles.";
         others_mess = (string)swimmer->query_short() + " emits a 'glub glub' "
                       "noise.";
         if ( !( swimmer->query_property( GILLS_PROP ) ) )  {
            my_mess += "  In the process you inhale some water.\n";
            others_mess += "  In the process, " +
                           (string)swimmer->query_pronoun() + " inhales "
                           "some water.\n";
            ++drown_stage;
         }
         else  {
            my_mess += "\n";
            others_mess += "\n";
         }
      }
      else if ( verb == "lsay" )  {
         my_mess = "You try to speak loudly, but can only produce a lot of "
                   "bubbles.";
         others_mess = (string)swimmer->query_short() + " produces a sort "
                       "of 'glooob gloob' sound.";
         if ( !( swimmer->query_property( GILLS_PROP ) ) )  {
            my_mess += "  You also inhale a fair amount of water.\n";
            others_mess += "  " + (string)swimmer->query_pronoun() + "also "
                           "inhales a fair amount of water.\n";
            drown_stage += 2;
         }
         else  {
            my_mess += "\n";
            others_mess += "\n";
         }
      }
      else if ( verb == "shout" )  {
         my_mess = "You try to shout, but your main effects are a muffled "
                   "'arrrble' and a lot of bubbles.";
         others_mess = (string)swimmer->query_short() + " open " +
                       (string)swimmer->query_possessive() + " mouth and "
                       "emits a muffled 'arrrble' noise.";
         if ( !( swimmer->query_property( GILLS_PROP ) ) )  {
            my_mess += "  You also inhale about a lungful of water.\n";
            others_mess += "  " + (string)swimmer->query_pronoun() + " sucks "
                           "in a large amount of water in the process.\n";
            drown_stage += 3;
         }
         else  {
            my_mess += "\n";
            others_mess += "\n";
         }
      }
   }
   if ( my_mess )  {
      tell_object( swimmer, my_mess );
      tell_object( environment( swimmer ), others_mess );
      return 1;
   }
   else return (int)swimmer->command_shadowed( verb, args );
}  /* command_shadowed() */


int *set_hold( object ob, int pos )  {
   int *other, old_bonus;

   old_bonus = bonus;
   other = (int *)swimmer->set_hold( ob, pos );
   calc_swim_bonus();
   if ( old_bonus != bonus )  {
      test_sweep();
      test_float();
   }
   return other;
}  /* set_hold() */


void do_death( object thing )  {
   if (swimmer) {
      swimmer->do_death( thing );
   }
   remove_call_out( "do_sweep" );
   remove_call_out( "do_rise" );
   remove_call_out( "do_sink" );
   remove_call_out( "do_drown" );
   remove_call_out( "do_soak" );
   swimmer->remove_property("there");
   return;
}  /* do_death() */


void remove_ghost()  {
  swimmer->remove_ghost();
  environment( swimmer )->event_enter( swimmer, "", 0 );
  return;
}  /* remove_ghost() */


int *set_unhold( object ob )  {
   int *other, old_bonus;

   old_bonus = bonus;
   other = (int *)swimmer->set_unhold( ob );
   calc_swim_bonus();
   if ( old_bonus != bonus )  {
      test_sweep();
      test_float();
   }
   return other;
}  /* set_unhold() */


int move( mixed dest, string messin, string messout )  {
   string where, *dest_dir_info;
   int pos;

   if ( !swimmer->query_property( "dead" )  &&  living( swimmer ) )  {
      if ( objectp( dest ) )  where = file_name( dest );
      else where = dest;
      dest_dir_info = (string *)environment( swimmer )->query_dest_dir();
      pos = member_array( where, dest_dir_info ) - 1;
      if ( pos > -1  &&
           !(int)environment( swimmer )->
                    attempt_exit( dest_dir_info[ pos ], swimmer ) )  {
         notify_fail( "" );
         return MOVE_NO_DROP;
      }
   }
   return swimmer->move( dest, messin, messout );
}  /* move() */



int do_float()  {
   if ( !swimming )  {
      tell_object( swimmer, "You are already drifting with the current.\n" );
   }
   else  {
      tell_object( swimmer, "You stop resisting the current.\n" );
      swimming = 0;
      test_sweep();
   }
   return 1;
}  /* do_float() */


int do_swim()  {
   if ( swimming )  {
      tell_object( swimmer, "You are already fighting the current.\n" );
   }
   else  {
      tell_object( swimmer, "You start to resist the current.\n" );
      swimming = 1;
      test_sweep();
   }
   return 1;
}  /* do_swim() */


void test_again()  {
   test_float();
   test_sweep();
   call_out( "test_again", recheck_delay );
}


void update_recheck( int time_out )  {
   int t;

//tell_object( swimmer, "Called update...\n" );
   recheck_delay = time_out;
   if ( time_out == -1 )  {
      remove_call_out( "test_again" );
   }
   else if ( ( t = find_call_out( "test_again" ) ) == -1 )  {
      call_out( "test_again", time_out );
   }
   else if ( time_out < t )  {
      remove_call_out( "test_again" );
      call_out( "test_again", time_out );
   }
   return;
}


string sweep_string( mixed *dest_other_info, int pos )  {
   if ( pointerp( dest_other_info[pos][5] ) )  {
      return dest_other_info[pos][5][1];
   }
   else  {
      return dest_other_info[pos][5];
   }
}
// --- END [/mnt/home2/grok/lib/std/shadows/misc/water.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shadows/misc/harry_shadow.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shadows/misc/harry_shadow.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629076   Available: 13576430
Inodes: Total: 5242880    Free: 4960135
4304 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shadows/misc/harry_shadow.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629076   Available: 13576430
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: harry_shadow.c,v 1.6 2002/05/24 17:54:29 pinkfish Exp $
 * $Log: harry_shadow.c,v $
 * Revision 1.6  2002/05/24 17:54:29  pinkfish
 * Remove all the pker property stuff.
 *
 * Revision 1.5  2002/05/24 17:41:11  pinkfish
 * Make the shadow remove the player killer function.
 *
 * Revision 1.4  2001/06/11 03:00:20  wobin
 * Added Perform, to the list of 'remove npk' status commandsdded
 *
 * Revision 1.3  2000/04/26 14:17:23  rhinehold
 * modified the shadowed adjust_hp to make sure the new arguments were caught and passed.
 *
 * Revision 1.2  1999/03/05 10:33:10  ceres
 * MOdified only to log in debug mode
 *
 * Revision 1.1  1998/01/06 04:39:04  ceres
 * Initial revision
 * 
*/
#include <player.h>

int protecting;
string protector;
object player;

void setup_shadow( object thing, string word ) {
   shadow( thing, 1 );
   player = thing;
   protector = word;
   protecting = 1;
   call_out( "dest_harry_shadow", 60 * 20 );
} /* setup_shadow() */

string query_harry_protector() { return protector; }

void dest_harry_shadow() { destruct( this_object() ); }

void zap_harry_shadow() {
   protecting = 0;
   tell_object( player, "You lose "+ protector +"'s protection.\n" );
   call_out( "dest_harry_shadow", 1 );
} /* zap_harry_shadow() */

int adjust_hp( int number, object thing, object weapon, string attack ) {
   if ( ( number > 0 ) || !protecting || 
       !thing || !pk_check(thing, player ) || player == this_player() )
      return (int)player->adjust_hp( number, thing, weapon, attack );
   return (int)player->query_hp();
} /* adjust_hp() */

int set_hp( int number, object thing ) {                     
   int current;
   current = (int)player->query_hp();
   if ( ( number > current ) || !protecting || !thing || !thing->query_player_killer() )
      return (int)player->set_hp( number, thing );
   return current;
} /* set_hp() */
 
/*
 * Hopefully there's no way a PKer can call these directly...
 *
 * void do_death() { return; }
 * int second_life() { return 1; }
*/

int attack_by( object thing ) {
   if ( !protecting || !thing->query_player_killer( ) )
      return (int)player->attack_by( thing );
   tell_object( thing, (string)player->the_short() +
         " are protected from combat by "+ protector +".\n" );
   tell_object( player, "You are protected from combat by "+
         protector +".\n" );
   thing->stop_fight( player );
   return 0;
} /* attack_by() */

int attack_ob( object thing ) {
   if ( protecting )
      zap_harry_shadow();
   return (int)player->attack_ob( thing );
} /* attack_ob() */

int query_unambushable() { return 1; }

void do_ambushed() {
   write( protector +" stops you from harming "+
         (string)player->the_short() +".\n" );
   tell_object( player, protector +" stops "+
         (string)this_player()->the_short() +" from harming you.\n" );
} /* do_ambushed() */

int no_offense() {
   if ( protecting )
      zap_harry_shadow();
   return (int)player->no_offense();
} /* no_offense() */

int query_player_killer() {
   return 0;
}

int command_shadowed( string verb, string args ) {
   if ( member_array( verb, ({ "cast", "scathe", "perform" }) ) == -1 )
      return (int)player->command_shadowed( verb, args );
   if ( protecting )
      zap_harry_shadow();
   return (int)player->command_shadowed( verb, args );
} /* command_shadowed() */

varargs int adjust_xp( int number, int shared ) {
#ifdef DEBUG
  log_file( "PROTECTED", ctime( time() ) +": "+ (string)player->query_name() +
         " gained "+ number +"xp ["+ implode( map_array( previous_object( -1 ),
         (: file_name( $1 ) :) ), ", " ) +"]\n" );
#endif  
   return (int)player->adjust_xp( number, shared );
} /* adjust_xp() */

varargs int add_skill_level( string skill, int lvl, mixed exp ) {
   string what;
   if ( !exp )
      exp = previous_object();
   if ( objectp( exp ) )
      what = " from "+ file_name( exp );
   else
      what = " for "+ exp +"xp";
#ifdef DEBUG
   log_file( "PROTECTED", ctime( time() ) +": "+ (string)player->query_name() +
         " gained "+ lvl +" in "+ skill + what +" ["+
         implode( map_array( previous_object( -1 ), (: file_name( $1 ) :) ),
         ", " ) +"]\n" );
#endif   
   return (int)player->add_skill_level( skill, lvl, exp );
} /* add_skill_level() */
// --- END [/mnt/home2/grok/lib/std/shadows/misc/harry_shadow.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shadows/fighting/special_attack.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shadows/fighting/special_attack.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629075   Available: 13576429
Inodes: Total: 5242880    Free: 4960135
4464 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shadows/fighting/special_attack.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629075   Available: 13576429
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: special_attack.c,v 1.7 2000/03/28 21:18:50 ceres Exp $
 * $Log: special_attack.c,v $
 * Revision 1.7  2000/03/28 21:18:50  ceres
 * Can't remember
 *
 * Revision 1.6  2000/03/01 20:09:02  ceres
 * Added debugging informs
 *
 * Revision 1.5  1999/10/28 02:10:10  ceres
 * God knows
 *
 * Revision 1.4  1998/09/07 01:51:42  ceres
 * Minor tweaks.
 *
 * Revision 1.3  1998/03/28 06:17:18  ceres
 * modified advance rate
 *
 * Revision 1.2  1998/01/07 21:53:35  sin
 * Fixed_the_code_to_detect_whether_the_weapon_is_appropriate.
 *
 * Revision 1.1  1998/01/06 04:36:31  ceres
 * Initial revision
 * 
*/
#include <tasks.h>

#define QUEST_MAX 570
#define INFORM

inherit "/std/effect_shadow";

string *data;

void set_data( string *words ) { data = words; }

mapping special_attack( object target ) {
   int i, damage, skill;
   object *args;
   mixed *attacks;
   args = arg();
   if (!args) {
      return 0;
   }
   if ( !data || ( (string)player->query_combat_attitude() != "offensive" ) ||
         ( target != args[ 0 ] ) || !args[ 1 ] ) {
      tell_object( player, "You lose the moment!\n" );
      set_arg( 0 );
      remove_this_effect();
      return ([ ]);
   }
   if ( ( (object)args[ 1 ]->query_wielded() != player ) &&
         ( args[ 1 ] != player ) ) {
      tell_object( player, "What did you do with "+
            (string)args[ 1 ]->the_short() +"?\n" );
      set_arg( 0 );
      remove_this_effect();
      return ([ ]);
   }
   if((object)environment(target) != (object)environment(player)) {
     tell_object(player, "Where did "+target->short()+" go?\n");
     remove_this_effect();
     return ([ ]);
   }
   attacks = (mixed *)args[ 1 ]->weapon_attacks( 100, target );
   if ( !sizeof( attacks ) )
   {
      return 0;
   }
   for ( i = 0; i < sizeof( attacks ); i += 4 ) {
      /* This checks to see if the weapon attack type (attacks[i + 2])
       * is the same as the attack type we need (data[1]), or that
       * the attack type is the same up to the first '-' */
      if (attacks[i + 2] == data[1] ||
            attacks[i + 2][0..sizeof(data[1])] == data[1] + "-")
        damage += attacks[ i ];
   }
   if ( !damage ) {
     tell_object( player, "You manage to botch your use of "+
                  ( args[ 1 ] == player ? "unarmed combat" :
                    (string)args[ 1 ]->the_short() ) +
                  " and barely launch a mediocre attack at "+
                  (string)target->the_short() +".\n" );
#ifdef INFORM
    event(environment(player), "inform", (string)player->query_name() +
          " special manoeuvre failed (no damage)", "combat");
#endif
     return 0;
   }
   
   skill = (int)player->query_skill_bonus( "fighting.combat.melee."+
         data[ 0 ] );
   switch( (int)TASKER->perform_task(player, "fighting.combat.melee."+data[0],
                                     damage, TM_COMMAND) ) {
      case AWARD :
        tell_object( player, "%^YELLOW%^"+ replace( ({ "You feel that "+
               "your skill with $weapon$ has increased.", "You feel "+
               "more able to use $weapon$.", "You seem to be a step "+
               "closer to mastering $weapon$." })[ random( 3 ) ],
               "$weapon$", ( args[ 1 ] == player ? "unarmed combat" :
               (string)args[ 1 ]->a_short() ) ) +"%^RESET%^\n" );
      case SUCCEED :
         tell_object( player, "You launch a powerful attack on "+
               (string)target->the_short() + ( args[ 1 ] == player ? "" :
               " with "+ (string)args[ 1 ]->the_short() ) +".\n" );
         damage = sqrt( ((damage*2/3)) * skill ) + ( damage * skill ) /
           QUEST_MAX;
#ifdef INFORM
    event(environment(player), "inform", (string)player->query_name() +
          " special manoeuvre success, damage: " +damage, "combat");
#endif
         break;
      default :
        damage = 1;
         tell_object( player, "You manage to botch your use of "+
               ( args[ 1 ] == player ? "unarmed combat" :
               (string)args[ 1 ]->the_short() ) +
               " and barely launch a mediocre attack at "+
               (string)target->the_short() +".\n" );
#ifdef INFORM
    event(environment(player), "inform", (string)player->query_name() +
          " special manoeuvre failed", "combat");
#endif
   }
   set_arg( 0 );
   remove_this_effect();
   return ([ args[ 1 ] : ({ damage }) + data ]);
} /* special_attack() */

int tasking_done() { return 1; }
// --- END [/mnt/home2/grok/lib/std/shadows/fighting/special_attack.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shadows/fighting/combat.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shadows/fighting/combat.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629074   Available: 13576428
Inodes: Total: 5242880    Free: 4960135
852 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shadows/fighting/combat.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629074   Available: 13576428
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: combat.c,v 1.8 2002/11/17 03:10:47 ceres Exp $
 * $Log: combat.c,v $
 * Revision 1.8  2002/11/17 03:10:47  ceres
 * Out of date now
 *
 * Revision 1.7  2000/06/29 01:09:32  pinkfish
 * Change around how concentrate works.
 *
 * Revision 1.6  2000/06/08 14:33:54  terano
 * Fixed misc things including initialising an array and adding an #include
 *
 * Revision 1.5  2000/06/08 01:48:53  pinkfish
 * Fix up some stuff.
 *
 * Revision 1.4  2000/05/07 09:54:56  ceres
 *  Forcibly unlocked by terano
 *
 * Revision 1.3  2000/03/23 03:56:07  taffyd
 * ADded is_fighting() function
 *
 * Revision 1.2  1998/06/12 20:56:25  ceres
 * Fixed but with using write instead of tell_object
 *
 * Revision 1.1  1998/01/06 04:36:31  ceres
 * Initial revision
 * 
*/
#include <obj_parser.h>

inherit "/std/effect_shadow";
// --- END [/mnt/home2/grok/lib/std/shadows/fighting/combat.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shadows/fighting/bob.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shadows/fighting/bob.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629073   Available: 13576427
Inodes: Total: 5242880    Free: 4960135
3157 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shadows/fighting/bob.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629073   Available: 13576427
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: bob.c,v 1.3 2000/06/09 06:47:35 pinkfish Exp $
 * 
*/
#include <tasks.h>
#include <weapon.h>

#define QUEST_MAX 570
#define DIFFICULTY 100
//#define DEBUG 1

inherit "/std/effect_shadow";

string *data;

void set_data( string *words ) { data = words; }

mapping special_attack( object target ) {
    int damage;
    int skill;
    int difficulty;
    object *args;

    args = arg();

    if((object)environment(target) != (object)environment(player)) {
        tell_object(player, "Where did "+target->short()+" go?\n");
        remove_this_effect();
        return ([ ]);
    }

    if (!sizeof(match_objects_for_existence("bucket", ({ this_player() }))) &&
        !sizeof(match_objects_for_existence("apple", ({ this_player() })))) {
       add_failed_mess("You must have an apple and a bucket to use bob.\n");
       return 0;
    }

    difficulty += target->query_str() * 10;

    skill = (int)player->query_skill_bonus("fighting.combat.melee."+ data[1]);

    damage = 4 + sqrt( damage ) / 2;
    damage = 2 * damage + 8 * (random(damage)) +
             2 * damage + 8 * (random(damage));

    switch( (int)TASKER->perform_task(player, "fighting.combat.melee."+ data[1],
        difficulty, TM_COMMAND)) {
    case AWARD :
        tell_object( player, "%^YELLOW%^"+ replace( ({ "You feel that "+
              "your skill with a bucket has increased.", "You feel "+
              "more able to use a bucket.", "You seem to be a step "+
              "closer to mastering a bucket." })[ random( 3 ) ],
            "$weapon$", ( args[ 1 ] == player ? "unarmed combat" :
              (string)args[ 1 ]->a_short() ) ) +"%^RESET%^\n" );
    case SUCCEED :
        tell_object( player, "You grab hold of " +
          (string)target->the_short() + "'s head and shove it down "
          "into the bucket.\nYou scream out 'Bob for this!'\n"
          "You try and drown " + target->the_short() + ".\n");
        tell_room( environment(player),
          player->the_short() + " grabs hold of " +
          (string)target->the_short() + "'s head and shoves it down "
          "into the bucket.\n" + player->the_short() +
          " scream out 'Bob for this!'\n" +
          player->the_short() + " tries to drown " + target->the_short() +
          ".\n", ({ player, }));
        set_arg(0);
        break;
    default:
        tell_object( player, "You manage to botch your use of a bucket.\n");
        remove_this_effect();
        return 0;
    }

#ifdef DEBUG
    tell_creator("ceres", sprintf("Crush: player: %s, weapon: %s (%d), Diff: %d, Dam: %d Ski: %d\n",
        player->query_name(),
        args[ 1 ]->query_name(),
        args[1]->query_enchant(),
        difficulty, damage, skill));
#endif

    remove_this_effect();
    return ([ args[ 1 ] : ({ damage }) + data ]);
} /* special_attack() */

int tasking_done() { return 1; }

void event_death(object killed, object * others, object killer, string rmess,
                      string kmess) {
  object *args;

  player->event_death(killed, others, killer, rmess, kmess);
  args = arg();
  if ( killed == args[ 0 ] ) remove_this_effect();
}
// --- END [/mnt/home2/grok/lib/std/shadows/fighting/bob.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shadows/attached/single_shoulder.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shadows/attached/single_shoulder.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629073   Available: 13576427
Inodes: Total: 5242880    Free: 4960135
2221 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shadows/attached/single_shoulder.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629073   Available: 13576427
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: single_shoulder.c,v 1.4 2001/09/16 14:28:12 wodan Exp $
 * $Log: single_shoulder.c,v $
 * Revision 1.4  2001/09/16 14:28:12  wodan
 * fixed type error
 *
 * Revision 1.3  2000/05/08 03:56:57  pinkfish
 * Fix up a problem caused by adding thin the object as the arg to
 * wear effects.
 *
 * Revision 1.2  1998/09/30 09:37:00  pinkfish
 * Changed to handle only satchetls and backppacks as possible things for
 * increasing the dexterity handicap.
 *
 * Revision 1.1  1998/01/06 04:35:11  ceres
 * Initial revision
 * 
*/
#include "path.h"

inherit "/std/effect_shadow";

/**
 * This method makes sure that we are opnly picking up backpacks and
 * satchels etc.
 * @return true if they are a satchel
 */
private int test_sash( object thing ) { 
   return (string)thing->query_type() == "sash" &&
          sizeof(thing->query_pockets());
} /* test_sash() */

/**
 * This method checks to make sure the item has the effect on it.
 */
private int test_for_effect( object thing ) {
   return member_array( EFFECTS +"single_shoulder",
      (string *)thing->query_wear_effects() ) != -1;
} /* test_for_effect() */

/**
 * This method checks the current handicap and sets it up nicely to
 * the correct value.
 */
void check_handicap() {
   int new_arg;
   mixed old_arg;
   object *things;

   things = (object *)player->query_wearing() - ({ 0 });
   old_arg = arg();
   if (objectp(old_arg)) {
      old_arg = 0;
   }
   new_arg = sizeof( filter_array( things, (: test_sash :), this_object() ) ) *
         sizeof( filter_array( things, (: test_for_effect :), this_object() ) );
   if ( !new_arg ) {
      remove_this_effect();
      return;
   }
   new_arg /= 2;
   if ( old_arg == new_arg ) {
      return;
   }
   player->adjust_bonus_dex( old_arg - new_arg );
   set_arg( new_arg );
} /* check_handicap() */

void now_worn( object thing ) {
   player->now_worn( thing );
   if ( find_call_out( "check_handicap" ) == -1 ) {
      call_out( "check_handicap", 0 );
   }
} /* now_worn() */

void now_removed( object thing ) {
   player->now_removed( thing );
   if ( find_call_out( "check_handicap" ) == -1 ) {
      call_out( "check_handicap", 0 );
   }
} /* now_removed() */
// --- END [/mnt/home2/grok/lib/std/shadows/attached/single_shoulder.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shadows/attached/talker_response.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shadows/attached/talker_response.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629072   Available: 13576426
Inodes: Total: 5242880    Free: 4960135
8926 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shadows/attached/talker_response.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629072   Available: 13576426
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: talker_response.c,v 1.4 2002/03/16 04:14:50 wobin Exp $
 *
 *
 */

/**
 * NPC talker response shadow 
 * @author Wobin
 * @started 22/05/01
 * This effect/shadow pair is to be used for NPCs with whom you wish to
 * add interactivity on the talker. It is formatted much like 
 * add_respond_to_with, but with a few alterations. The e/s is placed on
 * the listeners talker item with the NPC itself as the argument. I haven't
 * made it a requirement for the argument NPC to be the holder of the 
 * talker, but it makes more sense to use it that way. (Note, you can
 * only use NPCs as arguments, due to technical difficulties involved 
 * with new_parser.
 *
 * @example
 *     listener called Frog who is holding a talkerised cabbage and
 *     listener called Womble who is holding a talkerised electric shaver
 *
 *     cabbage->add_effect( EFFECTS + "talker_response", frog );
 *     cabbage->add_respond_to_talker_with( "one", "Womble", 
 *               ({ "lost", "brooch" }),
 *               ({ "one Haha!", "one You ditsy gnoll you!" }), 
 *               50 );
 *
 *     shaver->add_effect( EFFECTS + "talker_response", womble );
 *     shaver->add_respond_to_talker_with("one", "Frog",
 *               ({ "gnoll" }), 
 *               ({ "one That's it! I'm telling Pinkfish!" }) );
 *
 *     will have the two of these listener's chatting at one another, with 
 *     the frog responding half of the time to the womble's possible chat 
 *     of a lost brooch, and the womble reacting 1/10 times she is insulted.
 */

class response {
    string  sender;
    string *triggers;
    string *responses;
    int     probability;
    int     delay;
}

inherit "/std/effect_shadow";

public          object  query_listener      ( );
public  varargs void    query_responses     ( string );
public  varargs void    add_respond_to_talker_with( string, string, 
                                                        string *, int, int );
public          int     delete_response     ( string, string, string * ); 
public          void    receive             ( string, string, string, 
                                                        object * );
public          void    process_response    ( string *, string * );
private varargs int     register_listener   ( object );
private         int     compare_arrays      ( mixed *, mixed *);

mapping responses = ([ ]);
object listener;

/**
 * Adds the NPC as the listener, or the arg of the effect as default.
 * Automatically added when add_respond_to_talker_with is called.
 * @param target listener who is to be doing the listening
 * @see add_respond_to_talker_with()
 */ 
private varargs int register_listener(object target) {
  if(objectp(target)) {
    listener = target;
  }
  else
    listener = this_object()->arg_of(this_object()->
                                effects_matching("object.talker.response")[0]);
  if(!objectp(listener))
    this_object()->delete_effect(this_object()->
                                effects_matching("object.talker.response")[0]);
  return 1;
  
} /* register_listener */

/**
 * Who is registered as the listener NPC
 * @return The listener who is listening
 */
public object query_listener() {
  return listener;
}

/**
 * The list of responses that have been entered in for this NPC
 * @param key Optional. The channel to list responses for
 * @return mapping of responses for either the specified key, or all of them
 */
public varargs void query_responses(string key) {
  if(stringp(key)) {
    class response *womble = responses[key];
    
    foreach(class response cabbage in womble) {
      printf("Channel: %s\n\tChatter: %s\n", key, cabbage->sender);
      
      printf("\tTrigger:\n");
      foreach(string trigger in cabbage->triggers)
        printf("\t\t\"%s\"\n",trigger);
      
      printf("\tResponse:\n");
      foreach(string resp in cabbage->responses)
        printf("\t\t\"%s\"\n", resp);
      
      printf("\tProbability:\t%d\n\tDelay:\t%d\n\n",
             cabbage->probability, cabbage->delay);
    }
    return;
  } else {
    foreach(string nextkey in keys(responses)) {
      query_responses(nextkey);
    }
    return;
  }
} /* query_responses */      

/**
 * Adds a trigger for a certain channel and chatter. If this chatter is 
 * found to chat whatever is in the trigger, it will respond accordingly
 * If you use "#function" for the response, the function listed will be 
 * passed the channel, sender and text of the chat as arguments.
 *
 * @param channel The channel to listen to
 * @param sender The person/listener to respond to or "anyone" to listen to all chats.
 * @param trigger The response to trigger off
 * @param response How to respond to the trigger
 * @param probability Optional - Number out of 100 for the probability of the chat happening. Defaults to 10%
 * @param delay Optional - Number of seconds to delay. Defaults to 1 second. Use -1 for instant returns.
 * @example given a talker item...
 *   item->add_respond_to_talker_with("one", "Wobin", 
 *        ({ "woof", "arf", "bow-wow"}), 
 *        ({ "one Down boy!", "one Good Dog!" }), 10, 2 );
 *   item->add_respond_to_talker_with("two", "Archana", ({ "fluff" }),
 *        ({ "two You're so fluffy, Archana", "#fluff_archana" }), 80, 4 );
 *   
 */
public varargs void add_respond_to_talker_with(string channel, string sender, 
                                               string *trigger,
                                               string *response, int probability,
                                               int delay ) {
  
  class response new_item; 
  
  if(!listener)
    register_listener();
  
  if (!channel || !sender || !trigger || !response ){
    listener->call_out("do_command", 3, "'Err. I haven't been setup "
                       "correctly in regards to my talker!");
    return;
  }

  channel = lower_case(channel);
  
  if (undefinedp(responses[channel]))
    responses[channel] = ({});
  else {
      foreach(class response item in responses[channel]) {
        if(item->sender == sender && item->triggers - trigger == ({}) &&
           item->responses - response == ({}) && item->probability == probability)
            return;
      }
  }

  if(!probability)
    probability = 10;
  if(!delay)
    delay = 1;
  if(delay == -1)
    delay = 0;
  if(probability > 100)
    probability = 100;
  
  new_item = new(class response, sender : sender, triggers : trigger, 
                 responses : response, probability : probability, delay : delay);
  
  responses[channel] += ({ new_item });
  
  return;
} /* add_respond_to_talker_with */


/**
 * Used to delete specific responses
 * @param channel The channel the response is on
 * @param sender The person the response is set to
 * @param triggers An array of strings exactly matching the response
 */
public int delete_response( string channel, string sender, string *triggers ) {
  if( sizeof(responses[channel]) != 
      sizeof(responses[channel]   = responses[channel] - 
             filter(filter(responses[channel], (: $1->sender == $(sender) :)), 
                    (: compare_arrays( $1->triggers, $(triggers) ) :)) ) )
    return 1;
  
  return 0;
  
}

/** @ignore */
public void receive(string channel, string sender, string text,
                    object *receivers) {
  class response response;
  
  if(!listener) {
    register_listener();
    return;
  }
  
  if(sizeof(responses) && listener->query_name() != lower_case(sender) ) {
    if(member_array(lower_case(channel), keys(responses)) > -1 &&
       responses[channel]) {
      foreach( response in responses[channel]) {
        if(response->sender == sender || 
           response->sender == "anyone" ) {
          foreach( string trigger in response->triggers ) {
            if(regexp(text, trigger)) {
              if(random(100) < response->probability) {
                call_out("process_response", response->delay, 
                         response->responses, 
                         ({ channel, sender, text }));
              }
              break;
            }
          }
        }
      }
    }
  } else {
    query_shadowing(this_object())->receive(channel, sender, text, receivers);
  }
} /* recieve() */

/** @ignore */
private int compare_arrays( mixed *ar1, mixed *ar2 ) {
  int i;
  if ( !ar1 && !ar2 )
    return 0;
  if ( sizeof( ar1 ) != sizeof( ar2 ) )
    return 1;
  i = sizeof( ar1 );
  while ( i-- ) {
    if ( ar1[ i ] != ar2[ i ] ) {
      return 1;
    }
  }
  return 0;
}

/** @ignore */    
public void process_response( string *commands, string *arguments) {
  if(!query_listener()) return;
  
  foreach(string response in commands) {
    if(response[0] == '#') {
      if(function_exists(response[1..], listener)) {
        call_other( listener, ({ response[1..] }) + arguments);
      }
    } else {
      listener->do_command(response);
    }
  }
}
// --- END [/mnt/home2/grok/lib/std/shadows/attached/talker_response.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shadows/peace_shadow.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shadows/peace_shadow.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629069   Available: 13576423
Inodes: Total: 5242880    Free: 4960135
3412 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shadows/peace_shadow.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629069   Available: 13576423
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * Peace NPC Inherit
 * NPCs inheriting this file will cause their environment to be
 * peaceful
 *
 * Action-trapping code was modified and improved (IMNSHO) from
 * the Brother David's code
 *
 * @author Dasquian
 * @started on 30 December 2000
 *
 */

inherit "/std/effect_shadow";

#define GCR peacenpc->get_combat_reason()
#define GER peacenpc->get_escape_reason()
#define GFR peacenpc->get_fighting_reason()
#define GMR peacenpc->get_magic_reason()
#define GOR peacenpc->get_other_reason()
#define GRR peacenpc->get_ritual_reason()
#define GSR peacenpc->get_stealth_reason()
#define TO this_object()
#define TP this_player()

object peacenpc;

void setup_shadow(object person, object thing) {
    shadow( person, 1 );
    peacenpc=thing;
} /* setup_shadow() */

void dest_peace_shadow() { destruct(TO); } /* dest_peace_shadow() */

void event_exit(object ob, string message, object to) {
    if (ob==peacenpc)
        dest_peace_shadow();
} /* event_exit() */

void event_move_object(mixed from, mixed to) {
    dest_peace_shadow();
} /* event_move_object() */

// This function should just stop players doing anything that could
// possibly harm each other.
int command_shadowed( string verb, string args ) {

    switch(verb) {
        case "attack":
        case "behead":
        case "berserk":
        case "bob":
        case "crush":     
        case "disarm": 
        case "fire":
        case "guard": 
        case "hack":    
        case "hurl":
        case "iai":
        case "impale":
        case "kill":
        case "punch":
        case "riposte":
        case "slash":
        case "throw":
        case "warcry":
            tell_object(TP, GFR);
            return 1;
        case "cast":
        case "circle":
        case "educe":
        case "forget":
        case "invoke":
        case "remember":
        case "scribe":
        case "scry":
        case "spellcheck":
        case "twist":
        case "use":
        case "zap":
            tell_object(TP, GMR);
            return 1;
        case "bodyguard":
        case "bury":
        case "drag":
        case "eye":
        case "fuel":
        case "hedgehog":
        case "judge":
        case "leatherwork":
        case "mock":
        case "tempt":
        case "scathe":
        case "vurdere":        
            tell_object(TP, GOR);
            return 1; 
        case "conflagrate":
        case "consecrate":
        case "decompose":
        case "ensumpf":
        case "envalise":
        case "imbue":
        case "perform":
        case "pray":
        case "pyroscipate":
        case "shroud":
        case "suffuse":     
        case "ventisepelate":     
            tell_object(TP, GRR);
            return 1; 
        case "abscond":
        case "ambush":
        case "case":
        case "conceal":
        case "crack":
        case "disable":
        case "filch":
        case "hide":
        case "inhume":
        case "lpick":
        case "palm":
        case "peek":
        case "plant":
        case "probe":
        case "scope":
        case "shoplift":
        case "slip":
        case "snatch":
        case "sneak":
        case "steal":
        case "unhide":
            tell_object(TP, GSR);
            return 1;
        default:
            return 0;
    }
} /* command_shadowed() */

// Too peaceful to run away...
int run_away() {
    tell_object(TO, GER);
}// --- END [/mnt/home2/grok/lib/std/shadows/peace_shadow.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/house/tworoomflat/flatNbed.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/house/tworoomflat/flatNbed.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629068   Available: 13576422
Inodes: Total: 5242880    Free: 4960135
716 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/house/tworoomflat/flatNbed.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629068   Available: 13576422
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h";
inherit PLAYER_HOUSE;

void setup() {
   set_light(50);
   set_theft_handler( HOSPITAL );
   set_save_file("%savedir%/flat%N%bed");
   
/* DESCRIPTIONS */
   set_orientation(%orientation%);
   set_quit_handler(%out%);

   set_short("bedroom");
   set_base_desc( "a small bedroom" );
   add_surface( "floor", "finished pine board" );
   add_surface( "ceiling", "plain plaster" );
   add_surface( "%0% wall", "plain plaster" );
   add_surface( "%2% wall", "plain plaster" );
   add_surface( "%4% wall", "plain plaster" );
   add_surface( "%6% wall", "plain plaster" );

/* EXITS */

   add_exit( "%6%", PATH +"flat%N%", "door" );
   modify_exit("%6%", ({ "door short", "livingroom door" }));
   
}

// --- END [/mnt/home2/grok/lib/std/house/tworoomflat/flatNbed.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/house/tworoomflat/flatN.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/house/tworoomflat/flatN.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629068   Available: 13576422
Inodes: Total: 5242880    Free: 4960135
1164 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/house/tworoomflat/flatN.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629068   Available: 13576422
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h";

inherit PLAYER_HOUSE;

void setup() {
   set_light(50);
   set_theft_handler( HOSPITAL );
   set_save_file("%savedir%/flat%N%");
   
/* DESCRIPTIONS */
   set_orientation(%orientation%);
   set_quit_handler(%out%);

   set_short("front room");
   set_base_desc("a small and cosy front room" );
   add_surface( "floor", "finished pine board" );
   add_surface( "ceiling", "plain plaster" );
   add_surface( "%0% wall", "plain plaster" );
   add_surface( "%2% wall", "plain plaster" );
   add_surface( "%4% wall", "plain plaster" );
   add_surface( "%6% wall", "plain plaster" );
   
   /* EXITS */

   add_exit("out", %out%, "door");
   modify_exit("out", ({ "door short", "front door"}));
   add_exit("%2%", PATH+"flat%N%bed", "door");
   modify_exit("%2%", ({ "door short", "bedroom door"}));
   modify_exit("out", ({"exit mess", "$N leaves the flat.",
                         "enter mess",
                           ({ 1,
                              "$N enters from a flat.", 
                              "$N enter from a flat."
                           }),
                       }) );
   modify_exit( "out", ({ "closed", 1 }) );
}

// --- END [/mnt/home2/grok/lib/std/house/tworoomflat/flatN.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/house/onebedhouse/Nhall.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/house/onebedhouse/Nhall.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629067   Available: 13576421
Inodes: Total: 5242880    Free: 4960135
1241 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/house/onebedhouse/Nhall.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629067   Available: 13576421
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h";

/* MAIN ROOM -- Used by the housing handler to determine the main room. */

inherit PLAYER_HOUSE;

void setup() {
   set_light(50);
   set_theft_handler( HOSPITAL );
   set_save_file("%savedir%/%N%hall");
   
/* DESCRIPTIONS */
   set_orientation(%orientation%);
   set_quit_handler(%out%);

   set_short("front room");
   set_base_desc("a small hallway" );
   add_surface( "floor", "finished pine board" );
   add_surface( "ceiling", "plain plaster" );
   add_surface( "%0% wall", "plain plaster" );
   add_surface( "%2% wall", "plain plaster" );
   add_surface( "%4% wall", "plain plaster" );
   add_surface( "%6% wall", "plain plaster" );
   
   /* EXITS */

   add_exit("out", %out%, "door");
   modify_exit("out", ({"door short", "front door",
                          "exit mess", "$N leaves the house.",
                          "closed", 1,
                          "enter mess",
                          ({ 1,
                               "$N enters from a house.", 
                               "$N enter from a house."
                               }),
                          }) );

   add_exit("%0%", PATH+"%N%livingroom", "door");
   modify_exit("%0%", ({ "door short", "livingroom door"}));

}

// --- END [/mnt/home2/grok/lib/std/house/onebedhouse/Nhall.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/house/onebedhouse/Nbed.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/house/onebedhouse/Nbed.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629067   Available: 13576421
Inodes: Total: 5242880    Free: 4960135
704 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/house/onebedhouse/Nbed.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629067   Available: 13576421
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h";
inherit PLAYER_HOUSE;

void setup() {
   set_light(50);
   set_theft_handler( HOSPITAL );
   set_save_file("%savedir%/%N%bed");
   
/* DESCRIPTIONS */
   set_orientation(%orientation%);
   set_quit_handler(%out%);

   set_short("bedroom");
   set_base_desc( "a small bedroom" );
   add_surface( "floor", "finished pine board" );
   add_surface( "ceiling", "plain plaster" );
   add_surface( "%0% wall", "plain plaster" );
   add_surface( "%2% wall", "plain plaster" );
   add_surface( "%4% wall", "plain plaster" );
   add_surface( "%6% wall", "plain plaster" );

/* EXITS */

   add_exit( "down", PATH +"%N%livingroom", "stair" );
   modify_exit("down", ({ "downgrade", 9 }));
   
}

// --- END [/mnt/home2/grok/lib/std/house/onebedhouse/Nbed.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/house/onebedhouse/Nlivingroom.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/house/onebedhouse/Nlivingroom.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629067   Available: 13576421
Inodes: Total: 5242880    Free: 4960135
794 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/house/onebedhouse/Nlivingroom.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629067   Available: 13576421
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h";

inherit PLAYER_HOUSE;

void setup() {
   set_light(50);
   set_theft_handler( HOSPITAL );
   set_save_file("%savedir%/%N%livingroom");

/* DESCRIPTIONS */
   set_orientation(%orientation%);
   set_quit_handler(%out%);
   set_short("livingroom");
   set_base_desc("a comfortable livingroom");
   add_surface("floor", "finished pine board" );
   add_surface("ceiling", "plain plaster" );
   add_surface("%0% wall", "plain plaster");
   add_surface("%2% wall", "plain plaster");
   add_surface("%4% wall", "plain plaster");
   add_surface("%6% wall", "plain plaster");
   
   /* EXITS */
   add_exit("%4%", PATH+"%N%hall", "door");
   modify_exit("%4%", ({"door short", "hallway door"}));
   add_exit("up", PATH+"%N%bed", "stair");
   modify_exit("up", ({ "upgrade", 9 }));
}

// --- END [/mnt/home2/grok/lib/std/house/onebedhouse/Nlivingroom.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/house/onebedhut/Nbed.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/house/onebedhut/Nbed.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629066   Available: 13576420
Inodes: Total: 5242880    Free: 4960135
752 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/house/onebedhut/Nbed.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629066   Available: 13576420
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h";
inherit PLAYER_HOUSE;

void setup() {
   set_light(50);
   set_theft_handler( HOSPITAL );
   set_save_file("%savedir%/%N%bed");
   
/* DESCRIPTIONS */
   set_orientation(%orientation%);
   set_quit_handler(%out%);

   set_short("bedroom");
   set_base_desc( "a small bedroom" );
   add_surface( "floor", "stone paving" );
   add_surface( "ceiling", "roughly finished wood" );
   add_surface( "%0% wall", "roughly finished wood" );
   add_surface( "%2% wall", "roughly finished wood" );
   add_surface( "%4% wall", "roughly finished wood" );
   add_surface( "%6% wall", "roughly finished wood" );

/* EXITS */

   add_exit( "%4%", PATH +"%N%livingroom", "door" );
   modify_exit("%4%", ({ "door short", "living room door" }));
   
}

// --- END [/mnt/home2/grok/lib/std/house/onebedhut/Nbed.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/house/onebedhut/Nlivingroom.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/house/onebedhut/Nlivingroom.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629066   Available: 13576420
Inodes: Total: 5242880    Free: 4960135
1184 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/house/onebedhut/Nlivingroom.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629066   Available: 13576420
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h";

inherit PLAYER_HOUSE;

void setup() {
   set_light(50);
   set_theft_handler( HOSPITAL );
   set_save_file("%savedir%/%N%livingroom");

/* DESCRIPTIONS */
   set_orientation(%orientation%);
   set_quit_handler(%out%);
   set_short("livingroom");
   set_base_desc("a small cramped livingroom");
   add_surface("floor", "stone paving" );
   add_surface("ceiling", "roughly finished wood" );
   add_surface("%0% wall", "roughly finished wood" );
   add_surface("%2% wall", "roughly finished wood" );
   add_surface("%4% wall", "roughly finished wood" );
   add_surface("%6% wall", "roughly finished wood" );
   
   /* EXITS */
   add_exit("out", %out%, "door");
   modify_exit("out", ({"door short", "front door",
                          "exit mess", "$N leaves the hut.",
                          "closed", 1,
                          "enter mess",
                          ({ 1,
                               "$N enters from a hut.",
                               "$N enter from a hut."
                               }),
                          }) );

   add_exit("%0%", PATH+"%N%bed", "door");
   modify_exit("%0%", ({"door short", "bedroom door"}));
}

// --- END [/mnt/home2/grok/lib/std/house/onebedhut/Nlivingroom.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/house/fourbedhouse/Nbed2.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/house/fourbedhouse/Nbed2.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629065   Available: 13576419
Inodes: Total: 5242880    Free: 4960135
763 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/house/fourbedhouse/Nbed2.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629065   Available: 13576419
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h";
inherit PLAYER_HOUSE;

void setup() {
   set_light(50);
   set_theft_handler( HOSPITAL );
   set_save_file("%savedir%/%N%bed2");

/* DESCRIPTIONS */

   set_orientation(%orientation%);
  set_quit_handler(%out%);

   set_short("bedroom");
   set_base_desc( "a small bedroom" );
   add_surface( "floor", "finished pine board" );
   add_surface( "ceiling", "plain plaster" );
   add_surface( "%0% wall", "plain plaster" );
   add_surface( "%2% wall", "plain plaster" );
   add_surface( "%4% wall", "plain plaster" );
   add_surface( "%6% wall", "plain plaster" );

/* EXITS */

   add_exit( "%0%", PATH +"%N%landing1", "door" );
   modify_exit("%0%", ({ "door short", "bedroom door" }));
   add_exit("window", PATH + "%N%half-roof", "window");
}

// --- END [/mnt/home2/grok/lib/std/house/fourbedhouse/Nbed2.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/house/fourbedhouse/Nbed4.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/house/fourbedhouse/Nbed4.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629065   Available: 13576419
Inodes: Total: 5242880    Free: 4960135
714 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/house/fourbedhouse/Nbed4.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629065   Available: 13576419
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h";
inherit PLAYER_HOUSE;

void setup() {
   set_light(50);
   set_theft_handler( HOSPITAL );
   set_save_file("%savedir%/%N%bed4");

/* DESCRIPTIONS */

   set_orientation(%orientation%);
  set_quit_handler(%out%);

   set_short("bedroom");
   set_base_desc( "a small bedroom" );
   add_surface( "floor", "finished pine board" );
   add_surface( "ceiling", "plain plaster" );
   add_surface( "%0% wall", "plain plaster" );
   add_surface( "%2% wall", "plain plaster" );
   add_surface( "%4% wall", "plain plaster" );
   add_surface( "%6% wall", "plain plaster" );

/* EXITS */

   add_exit( "%4%", PATH +"%N%landing2", "door" );
   modify_exit("%4%", ({ "door short", "livingroom door" }));
   
}

// --- END [/mnt/home2/grok/lib/std/house/fourbedhouse/Nbed4.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/house/fourbedhouse/Nbed3.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/house/fourbedhouse/Nbed3.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629065   Available: 13576419
Inodes: Total: 5242880    Free: 4960135
763 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/house/fourbedhouse/Nbed3.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629065   Available: 13576419
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h";
inherit PLAYER_HOUSE;

void setup() {
   set_light(50);
   set_theft_handler( HOSPITAL );
   set_save_file("%savedir%/%N%bed3");

/* DESCRIPTIONS */

   set_orientation(%orientation%);
  set_quit_handler(%out%);

   set_short("bedroom");
   set_base_desc( "a small bedroom" );
   add_surface( "floor", "finished pine board" );
   add_surface( "ceiling", "plain plaster" );
   add_surface( "%0% wall", "plain plaster" );
   add_surface( "%2% wall", "plain plaster" );
   add_surface( "%4% wall", "plain plaster" );
   add_surface( "%6% wall", "plain plaster" );

/* EXITS */

   add_exit( "%0%", PATH +"%N%landing2", "door" );
   modify_exit("%0%", ({ "door short", "bedroom door" }));
   add_exit("window", PATH + "%N%half-roof", "window");
}

// --- END [/mnt/home2/grok/lib/std/house/fourbedhouse/Nbed3.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/house/fourbedhouse/Nfamilyroom.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/house/fourbedhouse/Nfamilyroom.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629064   Available: 13576418
Inodes: Total: 5242880    Free: 4960135
706 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/house/fourbedhouse/Nfamilyroom.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629064   Available: 13576418
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h";

inherit PLAYER_HOUSE;

void setup() {
   set_light(50);
   set_theft_handler( HOSPITAL );
   set_save_file("%savedir%/flat%N%study");

/* DESCRIPTIONS */

   set_orientation(%orientation%);
  set_quit_handler(%out%);

   set_short("small study");
   set_base_desc("a small study");
   add_surface( "floor", "finished pine board" );
   add_surface( "ceiling", "plain plaster" );
   add_surface( "%0% wall", "plain plaster" );
   add_surface( "%2% wall", "plain plaster" );
   add_surface( "%4% wall", "plain plaster" );
   add_surface( "%6% wall", "plain plaster" );
   
   /* EXITS */

   add_exit("%6%", PATH+"%N%kitchen", "corridor");
   add_exit("%0%", PATH+"%N%garden", "door");
}

// --- END [/mnt/home2/grok/lib/std/house/fourbedhouse/Nfamilyroom.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/house/fourbedhouse/Nlanding2.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/house/fourbedhouse/Nlanding2.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629064   Available: 13576418
Inodes: Total: 5242880    Free: 4960135
817 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/house/fourbedhouse/Nlanding2.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629064   Available: 13576418
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h";
inherit PLAYER_HOUSE;

void setup() {
   set_light(50);
   set_theft_handler( HOSPITAL );
   set_save_file("%savedir%/flat%N%bed");

/* DESCRIPTIONS */

   set_orientation(%orientation%);
  set_quit_handler(%out%);

   set_short("hallway");
   set_base_desc( "a hallway" );
   add_surface( "floor", "finished pine board" );
   add_surface( "ceiling", "plain plaster" );
   add_surface( "%0% wall", "plain plaster" );
   add_surface( "%2% wall", "plain plaster" );
   add_surface( "%4% wall", "plain plaster" );

/* EXITS */

   add_exit( "%0%", PATH +"%N%bed4", "door" );
   modify_exit("%0%", ({ "door short", "bedroom door" }));

   add_exit( "%4%", PATH +"%N%bed3", "door" );
   modify_exit("%4%", ({ "door short", "bedroom door" }));

   add_exit( "%6%", PATH +"%N%landing1", "corridor" );

}

// --- END [/mnt/home2/grok/lib/std/house/fourbedhouse/Nlanding2.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/house/fourbedhouse/Nlanding1.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/house/fourbedhouse/Nlanding1.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629063   Available: 13576417
Inodes: Total: 5242880    Free: 4960135
946 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/house/fourbedhouse/Nlanding1.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629063   Available: 13576417
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h";
inherit PLAYER_HOUSE;

void setup() {
   set_light(50);
   set_theft_handler( HOSPITAL );
   set_save_file("%savedir%/%N%landing1");

/* DESCRIPTIONS */

   set_orientation(%orientation%);
  set_quit_handler(%out%);

   set_short("landing");
   set_base_desc( "a landing at the top of the stairs" );
   add_surface( "floor", "finished pine board" );
   add_surface( "ceiling", "plain plaster" );
   add_surface( "%0% wall", "plain plaster" );
   add_surface( "%4% wall", "plain plaster" );
   add_surface( "%6% wall", "plain plaster" );

/* EXITS */

   add_exit( "%0%", PATH +"%N%masterbed", "door" );
   modify_exit("%0%", ({ "door short", "bedroom door" }));

   add_exit( "%4%", PATH +"%N%bed2", "door" );
   modify_exit("%4%", ({ "door short", "bedroom door" }));


   add_exit("%2%", PATH+"%N%landing2", "corridor");

   add_exit("down", PATH+"%N%livingroom", "corridor");
   modify_exit("down", ({"downgrade", 9 }));
}

// --- END [/mnt/home2/grok/lib/std/house/fourbedhouse/Nlanding1.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/house/fourbedhouse/Ndiningroom.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/house/fourbedhouse/Ndiningroom.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629063   Available: 13576417
Inodes: Total: 5242880    Free: 4960135
781 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/house/fourbedhouse/Ndiningroom.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629063   Available: 13576417
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h";

inherit PLAYER_HOUSE;

void setup() {
   set_light(50);
   set_theft_handler( HOSPITAL );
   set_save_file("%savedir%/%N%diningroom");

/* DESCRIPTIONS */

   set_orientation(%orientation%);
  set_quit_handler(%out%);

   set_short("spacious dining room");
   set_base_desc("a spacious dining room");
   add_surface( "floor", "finished pine board" );
   add_surface( "ceiling", "plain plaster" );
   add_surface( "%0% wall", "plain plaster" );
   add_surface( "%2% wall", "plain plaster" );
   add_surface( "%4% wall", "plain plaster" );
   add_surface( "%6% wall", "plain plaster" );
   
/* EXITS */

   add_exit("%3%", PATH+"%N%livingroom", "corridor");
   add_exit("%2%", PATH+"%N%kitchen", "corridor");
   add_exit("window", PATH+"%N%garden", "window");
}

// --- END [/mnt/home2/grok/lib/std/house/fourbedhouse/Ndiningroom.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/house/fourbedhouse/Nhalf-roof.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/house/fourbedhouse/Nhalf-roof.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629063   Available: 13576417
Inodes: Total: 5242880    Free: 4960135
606 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/house/fourbedhouse/Nhalf-roof.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629063   Available: 13576417
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h";

inherit "/std/rooftop";

void setup() {
  set_light(100);
  set_short("half-roof");
  set_long("This is a half-roof, a piece of sloping roof halfway up the "
           "front of the house.  There is a window to the %2% and another "
           "to the %6%.\n");

  set_slope(30, "half-roof", %out%);
  
  add_exit("%6% window", PATH+"%N%bed2", "window");
  add_exit("%2% window", PATH+"%N%bed3", "window");
  
  set_wall( ({ "bottom", ({ %out", 250 }), }) );
  set_wall( ({ "move", ({ "down", 30, %out%,
                            "$N climb$s down from above to join you." }) }) );
}
// --- END [/mnt/home2/grok/lib/std/house/fourbedhouse/Nhalf-roof.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/house/fourbedhouse/Nkitchen.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/house/fourbedhouse/Nkitchen.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629062   Available: 13576416
Inodes: Total: 5242880    Free: 4960135
770 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/house/fourbedhouse/Nkitchen.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629062   Available: 13576416
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h";

inherit PLAYER_HOUSE;

void setup() {
   set_light(50);
   set_theft_handler( HOSPITAL );
   set_save_file("%savedir%/%N%kitchen");

/* DESCRIPTIONS */

   set_orientation(%orientation%);
  set_quit_handler(%out%);

   set_short("large kitchen");
   set_base_desc("a large kitchen");
   add_surface( "floor", "finished pine board" );
   add_surface( "ceiling", "plain plaster" );
   add_surface( "%0% wall", "plain plaster" );
   add_surface( "%2% wall", "plain plaster" );
   add_surface( "%4% wall", "plain plaster" );
   add_surface( "%6% wall", "plain plaster" );
   
/* EXITS */

   add_exit("%6%", PATH+"%N%diningroom", "corridor");
   add_exit("%4%", PATH+"%N%livingroom", "corridor");
   add_exit("%2%", PATH+"%N%familyroom", "corridor");
}

// --- END [/mnt/home2/grok/lib/std/house/fourbedhouse/Nkitchen.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/house/fourbedhouse/Ngarden.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/house/fourbedhouse/Ngarden.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629062   Available: 13576416
Inodes: Total: 5242880    Free: 4960135
735 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/house/fourbedhouse/Ngarden.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629062   Available: 13576416
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h";

inherit PLAYER_HOUSE_OUTSIDE;

void setup() {
   set_light(50);
   set_theft_handler( HOSPITAL );
   set_save_file("%savedir%/%N%garden");

   /* DESCRIPTIONS */

   set_orientation(%orientation%);
  set_quit_handler(%out%);

   set_short("small garden");
   set_base_desc("a quiet and secluded garden");
   add_surface("floor", "grass");
   add_surface("%0% wall", "red brick" );
   add_surface( "%2% wall", "red brick" );
   add_surface( "%6% wall", "red brick" );
   
   /* EXITS */

   add_exit("%4%", PATH+"%N%familyroom", "door");
   modify_exit("%4%", ({ "door short", "garden door" }));

   //add_exit("%5% window", PATH+"%N%familyroom", "window");
   add_exit("window", PATH+"%N%diningroom", "window");
}

// --- END [/mnt/home2/grok/lib/std/house/fourbedhouse/Ngarden.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/house/fourbedhouse/Nmasterbed.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/house/fourbedhouse/Nmasterbed.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629061   Available: 13576415
Inodes: Total: 5242880    Free: 4960135
721 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/house/fourbedhouse/Nmasterbed.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629061   Available: 13576415
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h";
inherit PLAYER_HOUSE;

void setup() {
   set_light(50);
   set_theft_handler( HOSPITAL );
   set_save_file("%savedir%/%N%masterbed");

/* DESCRIPTIONS */
   set_orientation(%orientation%);
  set_quit_handler(%out%);

   set_short("bedroom");
   set_base_desc( "a huge master bedroom" );
   add_surface( "floor", "finished pine board" );
   add_surface( "ceiling", "plain plaster" );
   add_surface( "%0% wall", "plain plaster" );
   add_surface( "%2% wall", "plain plaster" );
   add_surface( "%4% wall", "plain plaster" );
   add_surface( "%6% wall", "plain plaster" );

/* EXITS */

   add_exit( "%4%", PATH +"%N%landing1", "door" );
   modify_exit("%4%", ({ "door short", "bedroom door" }));
   
}

// --- END [/mnt/home2/grok/lib/std/house/fourbedhouse/Nmasterbed.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/house/fourbedhouse/Nlivingroom.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/house/fourbedhouse/Nlivingroom.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629061   Available: 13576415
Inodes: Total: 5242880    Free: 4960135
1460 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/house/fourbedhouse/Nlivingroom.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629061   Available: 13576415
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h";

/* MAIN ROOM -- Used by the housing handler to determine the main room. */

inherit PLAYER_HOUSE;

void setup() {
   set_light(50);
   set_theft_handler( HOSPITAL );
   set_save_file("%savedir%/%N%livingroom");

/* DESCRIPTIONS */
   set_orientation(%orientation%);
  set_quit_handler(%out%);
   set_short("livingroom");
   set_base_desc("a large, comfortable, and sunny livingroom");
   add_surface("floor", "finished pine board" );
   add_surface("ceiling", "plain plaster" );
   add_surface("%0% wall", "plain plaster");
   add_surface("%2% wall", "plain plaster");
   add_surface("%4% wall", "plain plaster");
   add_surface("%6% wall", "plain plaster");
   
   /* EXITS */
   add_exit("out", %out%, "door");   
   modify_exit("out", ({"door short", "front door"}));
   add_exit("%7%", PATH+"%N%diningroom", "corridor");
   add_exit("%0%", PATH + "%N%kitchen", "corridor");
   add_exit("up", PATH + "%N%landing1", "corridor");
   modify_exit("up", ({"upgrade", 9}));
   modify_exit("out", ({"message", "$N leaves the house.",
                          "enter",
                          ({ 1,
                             "$N enters from a house.",
                             "$N enter from a house." }),
                          "closed", 1,
                          "door long", "This is the front door to a house.  "
                          "It has the numerals '%N%' in brass lettering.\n",
                          }) );
}

// --- END [/mnt/home2/grok/lib/std/house/fourbedhouse/Nlivingroom.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/object/bug_effect.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/object/bug_effect.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629060   Available: 13576414
Inodes: Total: 5242880    Free: 4960135
2246 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/object/bug_effect.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629060   Available: 13576414
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: bug_effect.c,v 1.1 1998/01/06 04:19:27 ceres Exp $
 * $Log: bug_effect.c,v $
 * Revision 1.1  1998/01/06 04:19:27  ceres
 * Initial revision
 * 
*/
/**
 * This is the effect skelton docs.  This effect
 * has a classification of "object.bug".
 * <p>
 * Describe the arguments in here.
 * @classification object.bug
 * @see help::effects
 */
#include <effect.h>

/** @ignore yes */
void beginning( object player, int time, int id ) {
   if (time == 0) {
      /* Make up our own time... */
      time = 30*60;
   }

   /* about every 7 minutes... */
   player->submit_ee( "create_bug", ({ 5*60, 5*60 }), EE_CONTINUOUS );
   player->submit_ee( 0, time, EE_REMOVE );
} /* beginning() */

/** @ignore yes */
void end( object player, int time, int id ) {
} /* end() */
 
void create_bug( object player, int time, int id ) {
   object bug;
   object room;
   string env_string;
   object *ignore;

   bug = clone_object("/obj/monster/cockroach");
   room = environment(player);
   env_string = player->the_short();
   ignore = ({ });
   while (room) {
      if (room == environment(player) && living(player)) {
         tell_object(player, env_string+" have "+bug->a_short()+
                             " suddenly pop out of your "
                             "ear.\n");
         ignore += ({ player });
         tell_room(room, env_string+" has "+bug->a_short()+
                         " suddenly pop out of "+
                         player->query_possessive()+
                         " ear.\n", ignore);
      } else if (living(player)) {
         tell_room(room, env_string+" has "+bug->a_short()+
                         " suddenly pop out of "+
                         player->query_possessive()+
                         " ear.\n", ignore);
      } else {
         tell_room(room, env_string+" has "+bug->a_short()+
                         " suddenly pop out of it.\n", ignore);
      }
      if (living(room))
        ignore += ({ room });
      env_string = env_string + " in " + room->the_short();
      if (!environment(room))
        bug->move(room);
      room = environment(room);
   }
} /* create_bug() */

/** @ignore yes */
string query_classification() { return "object.bug"; }
// --- END [/mnt/home2/grok/lib/std/effects/object/bug_effect.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/object/horse.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/object/horse.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629060   Available: 13576414
Inodes: Total: 5242880    Free: 4960135
794 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/object/horse.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629060   Available: 13576414
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <effect.h>

#define SHADOWS "/std/effects/object/"

string query_classification(){return "object.horse"; }

void beginning(object player, int amount){
    player->submit_ee(0, amount, EE_REMOVE);
    player->add_extra_look(this_object());
}/*beginning()*/

int merge_effect(object player, int old_amount, int new_amount){
   if (old_amount > new_amount)
      return old_amount;
   return new_amount;
}/*merge_effect()*/


string query_shadow_ob(){
   return SHADOWS+"shadow_horse";
}

int survive_death(){ 
   return 0; 
}

string extra_look(object player){
   return capitalize((string)player->the_short()) +
         " is mounted on a large, black horse.\n";
}/*extra_look()*/

void end(object player, int amount, int id){
   player->remove_extra_look(this_object());
} /* end() */
// --- END [/mnt/home2/grok/lib/std/effects/object/horse.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/object/cabbage.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/object/cabbage.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629059   Available: 13576413
Inodes: Total: 5242880    Free: 4960135
1588 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/object/cabbage.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629059   Available: 13576413
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming

#include <effect.h>

/** @ignore yes */
void beginning( object player, int time, int id ) {
/* Commenting out these first messages because they appear almost before
** the player has eaten the cabbage.
**   tell_object( player, "A foul smell wafts from your nether regions.\n" );
**   tell_room( environment( player ), "A loud trumpet"
**   " comes from "+ (string)player->one_short() +
**   "'s backside.  The accompanying smell is quite pungent.\n", player );
*/
   player->submit_ee( "make_stink", ({ 20, 20 }), EE_CONTINUOUS );
   player->submit_ee( 0, time, EE_REMOVE );
} /* beginning() */

/** @ignore yes */
int merge_effect( object player, int time1, int time2, int id ) {
   player->submit_ee( 0, time1 + time2 - (int)player->expected_tt(),
         EE_REMOVE );
   return time1 + time2;
} /* merge_effect() */
 
/** @ignore yes */
void end( object player, int time, int id ) {
   tell_object( player, "Your stomach calms down at last.\n" );
} /* end() */
 
void make_stink( object player, int time, int id ) {
   tell_object( player, "A huge trumpeting noise comes from your "
   "rear, closely followed by a stench of boiled cabbage.\n" );
   tell_room( environment( player ), "The smell of sprouts and cabbages from "
   + (string)player->one_short() +
         " wafts over you and you find yourself thinking of school dinners."
         "\n", player );
} /* make_stink() */

/** @ignore yes */
string query_classification() { return "body.smell.scent"; }

string smell_string( object player, int time ) {
   return "the delicious doughnutty smell";
} /* smell_string() */
// --- END [/mnt/home2/grok/lib/std/effects/object/cabbage.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/object/wet.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/object/wet.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629059   Available: 13576413
Inodes: Total: 5242880    Free: 4960135
2840 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/object/wet.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629059   Available: 13576413
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: wet.c,v 1.4 2002/01/06 04:57:44 presto Exp $
 * $Log: wet.c,v $
 * Revision 1.4  2002/01/06 04:57:44  presto
 * Add message for case where wetness is less than the weight
 *
 * Revision 1.3  2001/08/15 04:09:31  presto
 * added wet_string function to help out with the 'wet' command
 *
 * Revision 1.2  1998/01/11 17:03:41  pinkfish
 * fixed_up_the_extra_look_stuff,_tomake_them_ignored.
 *
 * Revision 1.1  1998/01/06 04:19:27  ceres
 * Initial revision
 * 
*/
/**
 * This is the effect skelton docs.  This effect
 * has a classification of "object.wet".
 * <p>
 * Describe the arguments in here.
 * @classification object.wet
 * @see help::effects
 */
// The target object will now receive the "wet" adjective
// while it is wet - Fiona

#include <effect.h>

/** @ignore yes */
string query_classification() { return "object.wet"; }

/** @ignore yes */
void beginning( object thing, int amount, int id ) {
   thing->submit_ee( "dry_off", ({ 30, 90 }), EE_CONTINUOUS );
   thing->add_extra_look( this_object() );
   // Now we can call a towel "a wet towel" or "a wet frog green towel" etc.
   // It will not actually change its short but spells will now
   // recognize the wetness effect.
   thing->add_adjective("wet");
} /* beginning() */

/** @ignore yes */
int merge_effect( object thing, int old_amount, int new_amount, int id ) {
   return old_amount + new_amount;
} /* merge_effect() */

/** @ignore yes */
void end( object thing, int amount, int id ) {
   thing->remove_extra_look( this_object() );
   // This thing is no longer wet. Remove the adjective
   thing->remove_adjective("wet");
} /* end() */

void restart( object thing, int amount, int id ) {
   thing->add_extra_look( this_object() );
} /* restart() */

void dry_off( object thing, int amount, int id ) {
   amount -= 100 + amount / 10;
   if ( amount > 0 )
      thing->set_arg_of( (int)thing->sid_to_enum( id ), amount );
   else
      thing->submit_ee( 0, 0, EE_REMOVE );
} /* dry_off() */

/** @ignore yes */
string wet_string( object thing ) {
   int *enums;
   string wetness;

   enums = (int *)thing->effects_matching( "object.wet" );
   if ( !sizeof( enums ) )
      return "";
   switch ( (int)thing->arg_of( enums[ 0 ] ) / ( 1 +
         (int)thing->query_weight() ) ) {
      case 0 :
         return "just barely damp";
      case 1 .. 5 :
         wetness = "slightly wet";
         break;
      case 6 .. 10 :
         wetness = "wet";
         break;
      case 11 .. 30 :
         wetness = "very wet";
         break;
      case 31 .. 80 :
         wetness = "sopping wet";
         break;
      default :
          wetness = "absolutely soaking wet";
   }
   return wetness;
} /* extra_look() */

/** ignore yes */
string extra_look(object thing)  {
   return "It is " + wet_string(thing) + ".\n";
}

// --- END [/mnt/home2/grok/lib/std/effects/object/wet.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/object/death_ward.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/object/death_ward.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629058   Available: 13576412
Inodes: Total: 5242880    Free: 4960135
753 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/object/death_ward.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629058   Available: 13576412
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: death_ward.c,v 1.1 1998/01/06 04:19:27 ceres Exp $
 * $Log: death_ward.c,v $
 * Revision 1.1  1998/01/06 04:19:27  ceres
 * Initial revision
 * 
*/
/**
 * This is the effect skelton docs.  This effect
 * has a classification of "magic.ward.death".
 * <p>
 * Describe the arguments in here.
 * <p>
 * This effect has a shadow associated with it.
 * @classification magic.ward.death
 * @see help::effects
 */
#include "path.h"

/** @ignore yes */
string query_classification() { return "magic.ward.death"; }

/** @ignore yes */
string query_shadow_ob() { return SHADOWS +"death_ward"; }

int query_indefinite() { return 1; }

/** @ignore yes */
int beginning( object thing, int amount, int id ) { return 0; }
// --- END [/mnt/home2/grok/lib/std/effects/object/death_ward.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/object/owned_weapon.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/object/owned_weapon.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629057   Available: 13576411
Inodes: Total: 5242880    Free: 4960135
1100 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/object/owned_weapon.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629057   Available: 13576411
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: owned_weapon.c,v 1.1 1998/01/06 04:19:27 ceres Exp $
 * $Log: owned_weapon.c,v $
 * Revision 1.1  1998/01/06 04:19:27  ceres
 * Initial revision
 * 
*/
/**
 * This is the effect skelton docs.  This effect
 * has a classification of "mudlib.owned.weapon".
 * <p>
 * Describe the arguments in here.
 * <p>
 * This effect has a shadow associated with it.
 * @classification mudlib.owned.weapon
 * @see help::effects
 */
#include "path.h"

/** @ignore yes */
string query_classification() { return "mudlib.owned.weapon"; }

/** @ignore yes */
string query_shadow_ob() { return SHADOWS +"owned_weapon"; }

int query_indefinite() { return 1; }

/** @ignore yes */
void beginning( object thing, string owner, int id ) { return; }

/** @ignore yes */
string merge_effect( object thing, string old_owner, string new_owner,
      int id ) {
   write( "There is a bug with the ownership of "+
         (string)thing->the_short() +" ("+ file_name( thing ) +
         ")!  Please bug report it and contact a creator!\n" );
   return old_owner;
} /* merge_effect() */
// --- END [/mnt/home2/grok/lib/std/effects/object/owned_weapon.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/object/swim_fins.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/object/swim_fins.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629057   Available: 13576411
Inodes: Total: 5242880    Free: 4960135
997 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/object/swim_fins.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629057   Available: 13576411
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <effect.h>

#define SHADOW "/std/shadows/object/swim_fins"

string query_classification() { return "clothing.swim_fins"; }

string query_shadow_ob() { return SHADOW; }

void beginning(object player, int time ) { 
   player->submit_ee( "test_worn", 1, EE_ONCE );
   player->submit_ee( "test_worn", 20, EE_CONTINUOUS );
}

void restart( object player ) {
} /* restart() */

int merge_effect( object player, int old_state, int new_state ) {
   return old_state | new_state;
} /* merge_effect() */

int test_for_effect( object thing ) {
   if ( !thing )
      return 0;
   return member_array( file_name( this_object() ),
         (string *)thing->query_wear_effects() ) != -1;
} /* test_for_effect() */

void test_worn( object player ) {
   if ( player->still_auto_loading() )
      return;
   if ( !sizeof( filter_array( (object *)player->query_armours(),
         "test_for_effect", this_object() ) ) ) {
      player->submit_ee( 0, 0, EE_REMOVE );
      return;
   }
} /* test_worn() */

// --- END [/mnt/home2/grok/lib/std/effects/object/swim_fins.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/object/basic_trap.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/object/basic_trap.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629057   Available: 13576411
Inodes: Total: 5242880    Free: 4960135
881 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/object/basic_trap.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629057   Available: 13576411
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: death_ward.c,v 1.1 1998/01/06 04:19:27 ceres Exp $
 * $Log: death_ward.c,v $
 * Revision 1.1  1998/01/06 04:19:27  ceres
 * Initial revision
 * 
*/
/**
 * This effect has a classification of "object.trap.basic".
 * <p>
 * No arguments.
 * <p>
 * This effect has a shadow associated with it. It is a basic trap for a
 * container.
 * @classification object.trap.basic
 * @see help::effects
 */
#include "path.h"

/** @ignore yes */
string query_classification() { return "object.trap.basic"; }

/** @ignore yes */
string query_shadow_ob() { return SHADOWS +"basic_trap"; }

int query_indefinite() { return 1; }

/** @ignore yes */
int beginning( object thing, int amount, int id ) {
	tell_object(find_player("ceres"), sprintf("Adding trap to %O\n",
																						thing));
	thing->set_lock_trap(thing, "trap_lock");
	return 0;
}
// --- END [/mnt/home2/grok/lib/std/effects/object/basic_trap.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/object/no_save.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/object/no_save.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629056   Available: 13576410
Inodes: Total: 5242880    Free: 4960135
980 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/object/no_save.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629056   Available: 13576410
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: no_save.c,v 1.1 2000/04/24 21:18:27 pinkfish Exp $
 * $Log: no_save.c,v $
 * Revision 1.1  2000/04/24 21:18:27  pinkfish
 * Initial revision
 *
 * Revision 1.1  1998/01/06 04:19:27  ceres
 * Initial revision
 * 
*/
/**
 * This is the effect skelton docs.  This effect
 * has a classification of "mudlib.owned.weapon".
 * <p>
 * Describe the arguments in here.
 * <p>
 * This effect has a shadow associated with it.
 * @classification mudlib.owned.weapon
 * @see help::effects
 */
#include "path.h"

/** @ignore yes */
string query_classification() { return "mudlib.object.nosave"; }

/** @ignore yes */
string query_shadow_ob() { return SHADOWS +"no_save"; }

int query_indefinite() { return 1; }

/** @ignore yes */
void beginning( object thing, string owner, int id ) { return; }

/** @ignore yes */
string merge_effect( object thing, string old_owner, string new_owner,
      int id ) {
   return old_owner;
} /* merge_effect() */
// --- END [/mnt/home2/grok/lib/std/effects/object/no_save.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/object/talker.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/object/talker.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629056   Available: 13576410
Inodes: Total: 5242880    Free: 4960135
12439 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/object/talker.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629056   Available: 13576410
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is the effect skelton docs.  This effect
 * has a classification of "magic.talker".
 * <p>
 * Describe the arguments in here.
 * @classification magic.talker
 * @see help::effects
 */
 
#include "path.h"
#include <library.h>
#include <talker.h>
#include <player.h>
#include <playtesters.h>
#include <deity.h>
#include <nomic_system.h>

#define HELP_CMD "/cmds/player/help"

nosave mapping _channel_cache;

// New channels must be added to this list.
nosave string *valid_channels = ({"one", "two", "A'Tuin", "Intermud", "Apex",
    "Adventurers", "Priests", "Wizards",
    "Assassins", "Warriors", "Thieves",
    "Witches", "playerkillers",
    "playtesters", "Catfish", "Fish",
    "Gapp", "Gufnork", "Hat",
    "Pishe", "Sandelfon", "Sek",
      "theAgateanEmpireCouncil",
     "KlatchCouncil", "KlatchCouncilMagistrate",
    "Ankh-MorporkCouncil",
    "Ankh-MorporkCouncilMagistrate" });

/** @ignore yes */
string query_classification() { return "magic.talker"; }

/** @ignore yes */
string query_shadow_ob() { return SHADOWS +"talker"; }

/** @ignore yes */
int query_indefinite() { return 1; }

/**
 * This method returns the "default" effect arguments. They are used
 * if the existing ones are invalid (or old).
 * @return a talker_args class containing "new" arguments.
 */
protected class talker_args new_talker_args() {
    return new(class talker_args, status : 1, channels : ({ "one" }),
        verbose : 1, local_echo : 0, colour : 0 );
} /* new_talker_args() */

/** @ignore yes */
class talker_args beginning( object thing, mixed args, int id ) {

    if ( environment( thing ) )
        tell_object( environment( thing ), "Somewhere inside " +
            thing->the_short() + " a pair of glittering eyes swirl "
            "into being.\n" );
    
    thing->add_extra_look( this_object() );
    thing->add_alias( "talker" );
    thing->add_plural( "talkers" );
    
    if (arrayp(args)) {
        args = new_talker_args();
        return args;
    }
    
    if (!classp(args)) {
        return new_talker_args();    
    }
} /* beginning() */

/** @ignore yes */
class talker_args merge_effect(object thing, mixed old_args, mixed new_args) {
    class talker_args args;
    
    if (!classp(old_args) || !classp(new_args))
        return new_talker_args();
    
    args = copy(old_args);
    
    args->channels += new_args->channels;
    args->channels = uniq_array(args->channels);
    
    return args;
} /* merge_effect() */

/** @ignore yes */
void restart( object thing, mixed args, int id ) {
    if (!classp(args)) {
        thing->set_arg_of(thing->sid_to_enum(id), new_talker_args());
        tell_object( environment( thing ), "Your talker quivers "
            "uncontrollably and starts to jump around.  You will have "
            "to re-add your talker channels and reconfigure your talker.\n" );
    }
    
    thing->add_extra_look( this_object() );
    thing->add_alias( "talker" );
    thing->add_plural( "talkers" );
} /* restart() */

/** @ignore yes */
void end( object thing, mixed *args, int id ) {
    if ( environment( thing ) )
        tell_object( environment( thing ), "The pair of glittering eyes in "+
          (string)thing->the_short() +" close and fade away forever.\n" );
    thing->remove_extra_look( this_object() );
    thing->remove_alias( "talker" );
    thing->remove_plural( "talkers" );
} /* end() */

/** @ignore yes */
string extra_look( object thing ) {
    int *enums;
    mixed args;

    enums = (int *)thing->effects_matching( "magic.talker" );
    if ( !sizeof( enums ) ) {
        return "";
    }
    args = thing->arg_of( enums[ 0 ] );
    
    if (!classp(args)) {
         return "";
    }
        
    if ( args->status ) {
        return "Just beneath the surface, you can make out what looks like a "
        "pair of glittering eyes.\n";
    }
    return "Just beneath the surface, you can make out what looks like a "
    "pair of closed eyes.\n";
} /* extra_look() */

/**
 * This method is used to determine which talker channels can use.
 * It also caches the data so that it only has to be recalculated 
 * once.
 * <p>
 * @param player the player's channel list to generate
 * @return an array of channel names. (string *)
 * @see clear_cache()
 * @see query_channel_cache()
 */
string *all_channels( object player ) {
    string word, *list;
    string p_name;
    class cache_data settings;
    string* areas;

    if ( player->query_property("gagged") ) {
        return ({ });
    }

    list = ({ "one", "two" });
    word = (string)player->query_guild_ob();

    if ( file_size( word +".c" ) > 0 ) {
        if (word != "disavowed") {
            list += ({ capitalize(word->query_name()) });
        }
    }
    else {
        list += ({ "Adventurers" });
    }

    word = (string)player->query_deity();

    if ( stringp( word ) ) {
        list += ({ capitalize( word ) });
    }

    word = (string)player->query_name();

    p_name = player->query_name();

    /* This stores the channels so that we only have to check the data
       once. */

    if (!_channel_cache) {
        _channel_cache = ([ ]);
    }

    if (undefinedp(_channel_cache[p_name])) {
        _channel_cache[p_name] = new(class cache_data,
          talker_quest : LIBRARY->query_quest_done(p_name, "talker quest"),
          playtester : PLAYTESTER_HAND->query_playtester(p_name),
          apex_member : "/d/am/buildings/apex/admin_office"->query_member(p_name)
        );
    }

    settings = _channel_cache[p_name];

    if (settings->talker_quest) {
        list += ({ "A'Tuin", "Intermud" });
    }

    if (settings->apex_member) {
        list += ({ "Apex" });
    }

    if (settings->playtester) {
        list += ({ "playtesters" });
    }

    if ( player->query_player_killer()) {
        list += ({ "playerkillers" });
    }

    areas = NOMIC_HANDLER->query_citizenship_areas();
    foreach (word in areas) {
       if (NOMIC_HANDLER->is_citizen_of(word, p_name)) {
          list += ({ replace_string(word, " ", "") + "Council" });
       }
       if (NOMIC_HANDLER->is_magistrate_of(word, p_name)) {
          list += ({ replace_string(word, " ", "") + "CouncilMagistrate" });
       }
    }

    return list;
} /* all_channels() */

/**
 * This returns the channels that a player is on in a nifty
 * formatted way.  Used in the channel list and talker shadow.
 * @return a list of channels that this_player() is on.
 */
string channels() {
    return sprintf( "%#-*s\n", (int)this_player()->query_cols(),
      implode( all_channels( this_player() ), "\n" ) );
} /* channels() */

/**
 * This method is used to check whether or not a channel (or a list of
 * channels are valid.
 * @param word if this is a string, then valid() checks to see whether
 * or not the channel can be used.  If it is an array, then it validates
 * all the channels mentioned.
 * @return 1 if the channel (or channels) are valid, 0 if they are not.
 */
varargs int valid( mixed word, object who) {
    
    if (!who) {
        who = this_player();
    }

    if (arrayp(word) && arrayp(valid_channels)) {
        if (sizeof( word - valid_channels ) != 0) {
            return 0;
        }
    } else {
        if (member_array( word, valid_channels ) == -1) {
            return 0;
        }
    }

    if (who->query_lord()) {
       return 1;
    }

    if ( who->query_creator() ) {
        if (stringp(word) &&
            word[<7..] != "Council" &&
            word[<10..] != "Magistrate") {
            return 1;
        } else if (arrayp(word)) {
            if (!sizeof(filter(word, (: $1[<7..] == "Council" &&
                                        $1[<10..] == "Magistrate" :)))) {
                return 1;
            }
        }
    }
    if ( arrayp( word ) ) {
        return sizeof( word - all_channels( who ) ) == 0;
    }
    
    return ( member_array( word, all_channels( who ) ) != -1 );
} /* valid() */

object find_actual_talker( object thing ) {
    object talker;
    
    while ( thing ) {
        talker = thing;
        thing = query_shadowing( thing );
    }
    
    return talker;
} /* find_actual_talker() */
   
/**
 * This method returns a formatted list of which players are using the 
 * talker.
 * @param word the name of a specific channel to get a listing of.
 * @param brief only show the people, not what they are listening to
 * @return a formatted string containing who is on a channel.
 */
string list( string word, int brief ) {
    int space;
    int *enums;
    string sender;
    string table;
    object thing;
    object *ok;
    object *things;
    object holder;
    class talker_args args;

    table = "";

    space = (int)this_player()->query_cols() - 20;
        
    things = children( SHADOWS + "talker" ) - 
        ({ find_object( SHADOWS + "talker" ) });
        
    things = filter( map( things, (: find_actual_talker( $1 ) :) ), 
        (: $1 && environment($1) && living(environment($1)) &&
           (!userp($1) || interactive($1)) :) );
    
    /* Remove duplicates.  If you have a lot of talkers, they won't
       all show up. */
    things = uniq_array(things);
    things = sort_array( things, 
        (: strcmp( environment($1)->query_name(), 
            environment($2)->query_name() ) :) );
    ok = ({ });
    foreach( thing in things ) {
        holder = environment( thing );
        if (userp(holder)) {
            sender = capitalize( holder->query_cap_name() );
        } else {
            sender = capitalize( holder->query_name() );
        }
            
        if ( holder->query_invis() ) {
            continue;
        }
                        
        enums = (int *)thing->effects_matching( "magic.talker" );

        if ( !sizeof( enums ) ) {
            if ( !word ) {
                table += sprintf( LIST_FORMAT, sender, space, "(barfed)" );
            }
            continue;
        }
        
        args = thing->arg_of( enums[ 0 ] );
        
        if (!classp(args)) {
            continue;
        }
            
        if ( !args->status) {
            if ( !word ) {
                table += sprintf( LIST_FORMAT, sender, space, "(asleep)" );
            }
            continue;
        }
        
        if ( !word || ( member_array( word, args->channels ) != -1 ) ) {
            if (brief) {
                ok += ({ sender });
            } else {
                table += sprintf( LIST_FORMAT, sender, space,
                    query_multiple_short( args->channels ) );
            }
        }
    }

    if (brief) {
       return "$I$5=People listing to the channel " + word + " are: " +
              query_multiple_short(ok) + "\n";
    }
    
    if ( table == "" ) {
        return sprintf( LIST_FORMAT, "None", space, "" );
    }
    
    return table;
} /* list() */

string normalise_name( string channel ) {
    int position;
    mixed *details;
    string *lower_names;
    string lower_channel;
    
    lower_channel = lower_case( channel );
    lower_names = map( valid_channels, (: lower_case($1) :) );
    
    
    position = member_array( lower_channel, lower_names );
    
    if ( position == -1 ) {
        details = HELP_CMD->find_match_in_array( lower_channel,
            lower_names );
        
        if ( details[ 1 ] > 70 ) {
            return valid_channels[ details[ 0 ] ];
        }
        
        return channel;
    }
    
    return valid_channels[ position ];
} /* normalise_name() */

/**
 * This method is used for debugging purposes to query the 
 * channel cache.
 * @param person the name of a person to query. If this is not
 * specified, then the entire channel cache is returned.
 * @return a mapping containing channel cache data.
 */ 
varargs mapping query_channel_cache(string person) {
    if (!_channel_cache)
        return ([ ]);

    if (stringp(person) && classp(_channel_cache[person])) {
        return copy(_channel_cache[person]);
    } 

    return copy(_channel_cache);
} /* query_channel_cache() */

/** @ignore yes */
void reset() {
    _channel_cache = ([ ]);
} /* reset() */

/**
 * This method is used to clear a specific person's cache 
 * details.  It is called from the shadow when a person
 * attempts to re-add a channel, so they their details
 * can be updated.
 * @param person the person's name to clear from the cache.
 */
void clear_cache(string person) {
    if (_channel_cache) {
        map_delete(_channel_cache, person);
    }
} /* clear_cache() */
// --- END [/mnt/home2/grok/lib/std/effects/object/talker.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/object/newbie_shoes.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/object/newbie_shoes.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629052   Available: 13576406
Inodes: Total: 5242880    Free: 4960135
2266 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/object/newbie_shoes.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629052   Available: 13576406
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: newbie_shoes.c,v 1.2 1998/10/27 23:27:30 sin Exp $
 * $Log: newbie_shoes.c,v $
 * Revision 1.2  1998/10/27 23:27:30  sin
 * Silenced the shoes on net dead players.
 *
 * Revision 1.1  1998/01/06 04:19:27  ceres
 * Initial revision
 * 
*/
/*
 * Effect for the evil orthopaedic shoes.
 * by Sin
 */
#include "path.h"

#include <effect.h>

#define CLASS "misc.worn.shoes.orthopaedic"

string query_classification() { return CLASS; }
int query_indefinite() { return 1; }
string query_shadow_ob() { return SHADOWS + "newbie_shoes"; }

void chat(object player, mixed arg, int id)
{
  string *mechats = ({
    "Something's crawling inside the shoes.\n",
    "The Cobblers of Sek must've made these things!\n",
    "Did that vice just screw down tighter?\n",
    "*OUCH* that stung!\n",
    "You not-so-idly wonder who came up with these shoes.\n"
    });
  string *youchats = ({
    " winces in pain.\n",
    " mutters something about shoes.\n",
    " stumbles.\n"
    });

  if (!interactive(player)) return;

  tell_object(player, mechats[random(sizeof(mechats))]);
  tell_room(environment(player),
    player->query_cap_name() + youchats[random(sizeof(youchats))],
    ({ player }) );
}

void notify(object player, mixed arg, int id)
{
  tell_object(player,
    "A fiery pain shoots up your legs from your feet.\n");
}

void beginning( object player, int amount, int id )
{
  player->add_extra_look( this_object() );
  player->adjust_bonus_dex(-1);
  player->submit_ee("chat", ({ 10, 30 }), EE_CONTINUOUS);
  player->submit_ee("notify", 1, EE_ONCE);
} /* beginning() */

void restart( object player, int amount, int id )
{
  beginning(player, amount, id);
} /* restart() */

void merge_effect(object player, mixed oldarg, mixed newarg, int id)
{
  return;
}

void end( object player, int amount, int id )
{
  player->remove_extra_look( this_object() );
  player->adjust_bonus_dex(1);
  tell_object(player, "Ahhhh!  Free from those evil shoes!\n");
} /* end() */

string extra_look( object player )
{
  int *enums;
  enums = (int *)player->effects_matching( CLASS );
  if ( !sizeof( enums ) )
     return "";
  return(capitalize(player->query_pronoun()) +
    " looks embarrassed and uncomfortable.\n");
} /* extra_look() */
// --- END [/mnt/home2/grok/lib/std/effects/object/newbie_shoes.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/object/heat.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/object/heat.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629051   Available: 13576405
Inodes: Total: 5242880    Free: 4960135
2638 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/object/heat.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629051   Available: 13576405
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
// Gototh, 16/06/99

/**
 * This effect is for heating metals in a forge.  It lets people know
 * when something is red hot.
 */
#include "path.h"
#include <effect.h>

/**
 * @ignore yes 
 */
string query_classification()
{
  return "object.heat";
} /* query_classification() */

string query_shadow_ob()
{
  return SHADOWS+"heat_shadow";
} /* query_shadow_ob() */

/**
 * @ignore yes
 */
int beginning(object ob, int heat, int id)
{
  ob->submit_ee("change_temperature", ({ 45, 15 }), EE_CONTINUOUS);
  ob->add_extra_look(this_object());
  return heat;
}

/**
 * @ignore yes 
 */
void restart(object ob)
{
  ob->add_extra_look(this_object());
}

/**
 * @ignore yes
 */
int merge_effect(object ob, int new_heat, int old_heat, int id)
{
  int heat;
  heat = new_heat + old_heat;
  if(heat < 21)
  {
    ob->submit_ee(0, 0, EE_REMOVE);
  }
  return heat;
} /* merge_effect() */

/**
 * @ignore yes
 */
void end(object ob, int heat, int id)
{
  ob->remove_extra_look(this_object());
} /* end() */

void change_temperature(object ob, int heat, int id)
{
  int shift;
  int env_temp;
  int new_heat;
  
  // Read the heat of the forge (or whatever).
  env_temp = environment(ob)->query_heat();
  if(!env_temp)
  {
    env_temp = 20;
  }
  // Make it shift up to 100 degrees in the direction of the 
  // environment's heat.
  if(env_temp > heat)
  {
    shift = 100 + ((env_temp - heat) / 10);
    if((heat + shift) > env_temp)
    {
      shift = env_temp - heat;
    }
  }
  else
  {
    shift = -100 - ((heat - env_temp) / 10);
    if((heat + shift) < env_temp)
    {
      shift = env_temp - heat;
    }
  }
  tell_creator(find_living("gototh"), "Heat shift: %O\n", shift);
  new_heat = heat + shift;
  if(heat > ob->query_property("red hot at") && 
    new_heat < (ob->query_property("red hot at") + 1))
  {
    tell_room(environment(ob), 
      "$C$" + ob->one_short() + " stops glowing red hot.\n");
  }
  if((heat > 80) && (new_heat < 81))
  {
    tell_room(environment(ob), 
      "$C$" + ob->one_short() + " seems to have cooled down.\n");
  }
  if(new_heat < 21)
  {
    ob->submit_ee(0, 0, EE_REMOVE);
  }
  else
  {
    ob->set_arg_of(ob->sid_to_enum(id), new_heat);
  }
} /* change_temperature() */

string extra_look(object ob)
{
  int heat;
  int *enums;
  int red_hot;
  enums = ob->effects_matching("object.heat");
  if(!sizeof(enums))
  {
    return "";
  }
  heat = ob->arg_of(enums[0]);
  
  red_hot = ob->query_property("red hot at");
  if(red_hot)
  {
    if(heat > red_hot)
    {
      return "It is red hot.\n";
    }
    if(heat > 80)
    {
      return "It looks hot.\n";
    }
  }
  return "";
} /* extra_look() */
// --- END [/mnt/home2/grok/lib/std/effects/object/heat.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/object/object_desc.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/object/object_desc.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629050   Available: 13576404
Inodes: Total: 5242880    Free: 4960135
1311 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/object/object_desc.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629050   Available: 13576404
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <effect.h>

string query_classification(){return "crafts.description"; }

//Desc[0]: short
//Desc[1]: long
//Desc[2]: adjective
//Desc[3]: alias
//Desc[4]: determinate

//string* description = ({"bing", "bing", "bing", "bing", "bing"});
 //Whee. Global effect variables. Kids, don't try this at home.

string* beginning(object thing, string* desc){
   //description = desc;
   switch(sizeof(desc)){
      case 5:
         thing->add_property("determinate", desc[4]);
      case 4:
         thing->add_alias(desc[3]);
      case 3:
         thing->add_adjective(desc[2]);
      case 2:
         thing->set_long(desc[1]);
      case 1:
         thing->set_short(desc[0]);
   }
   return desc;
}/*beginning()*/

string* merge_effect(object player, string* old_desc, string* new_desc){
   return new_desc;
}/*merge_effect()*/

mixed* restart(object thing, string* description, int id){
   switch(sizeof(description)){
      case 5:
         thing->add_property("determinate", description[4]);
      case 4:
         thing->add_alias(description[3]);
      case 3:
         thing->add_adjective(description[2]);
      case 2:
         thing->set_long(description[1]);
      case 1:
         thing->set_short(description[0]);
   }
   return ({thing, description, id});
}

/*A SkankyCode Creation, by Rodion*/// --- END [/mnt/home2/grok/lib/std/effects/object/object_desc.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/object/extra_description.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/object/extra_description.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629049   Available: 13576403
Inodes: Total: 5242880    Free: 4960135
1553 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/object/extra_description.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629049   Available: 13576403
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* This method allows you to add an extra bit to a description, which will
 * time out after a specified duration.
 * The argument is of the form: ({ string description , int duration , string end_mess })
 * The end_mess option is optional and supplies the end message.
 * Have fnu!
 * @author Furcifer 4 October 2000
 */
#include <effect.h>

string query_classification() {
    return "object.extra_description";
}

void beginning( object thing , mixed *args ) {
    string description;
    int duration;
    
    description = args[ 0 ];
    duration = args[ 1 ];
    
    if( !stringp( description ) || !intp( duration ) ) return;
    
    thing->add_extra_look( this_object() );
    thing->submit_ee( 0 , duration , EE_REMOVE );
}

string extra_look( object thing ) {
    int *enums;
    string message, temp;
    
    enums = thing->effects_matching( query_classification() );
    if( !sizeof( enums ) ) {
        thing->remove_extra_look( this_object() );
        return "";
    }
    message = "";
    foreach( int elem in enums ) {
        temp =  ( thing->arg_of( elem ) ) [ 0 ];
        if( !stringp( temp ) ) {
            temp = ""; 
        } else {
           if( strlen( temp ) < 2 || temp[ <2 .. ] != "\n" ) temp += "\n";
        }
        message += temp;
    }
    return message;
}

void end( object thing , mixed *args , int id ) {
    if( sizeof( args ) == 3 && stringp( args[ 2 ] ) ) {
         string end_mess = args[ 2 ];
         if( end_mess[<2 .. ] != "\n" ) end_mess += "\n";
         tell_object( thing , end_mess );
    }
}// --- END [/mnt/home2/grok/lib/std/effects/object/extra_description.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/object/label.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/object/label.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629049   Available: 13576403
Inodes: Total: 5242880    Free: 4960135
4079 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/object/label.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629049   Available: 13576403
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: label.c,v 1.9 2003/04/10 20:59:35 ceres Exp $
 * $Log: label.c,v $
 * Revision 1.9  2003/04/10 20:59:35  ceres
 * Tried a second time
 *
 * Revision 1.7  1999/05/25 20:39:40  pinkfish
 * Fix up the label code to correctly work really this time. :)
 *
 * Revision 1.6  1999/05/24 20:59:04  pinkfish
 * Fix up the label effect.
 *
 * Revision 1.5  1999/05/16 03:50:47  pinkfish
 * Reformat it a little.
 *
 * Revision 1.4  1998/07/28 13:38:00  wodan
 * fixed it for real now, i hope.
 *
 * Revision 1.3  1998/07/24 14:17:57  wodan
 * fixed a memory leak.
 *
 * Revision 1.2  1998/01/11 17:03:41  pinkfish
 * fixed_up_the_extra_look_stuff,_tomake_them_ignored.
 *
 * Revision 1.1  1998/01/06 04:19:27  ceres
 * Initial revision
 * 
*/
/**
 * This is the effect skelton docs.  This effect
 * has a classification of "object.label".
 * <p>
 * The arguement is the storage container.  It is either the object itself
 * (when the player is running) or the mapping of the dynamic loading
 * of the container (when the player logs on/off).
 * @classification object.label
 * @see help::effects
 */
#include <effect.h>

/** @ignore yes */
int query_indefinite() { return 1; }

/**
 * Create the storage container for the labels.
 * @return the storage container
 */
object create_store(mapping map,
                    object player) {
   object store;

   store = clone_object( "/std/container" );
   if ( objectp( player ) ) {
      store->set_player( player );
   }
   if ( mapp( map ) ) {
      store->init_dynamic_arg( map );
   }
   return store;
} /* create_store() */

/** @ignore yes */
string query_classification() { return "object.label"; }

/** @ignore yes */
mixed* beginning( object thing, object label, int id ) {
   object store;

   store = clone_object( "/std/container" );
   label->move( store );
   thing->add_extra_look( file_name(this_object()) );
   return ({ store, store->query_dynamic_auto_load() });
} /* beginning() */

/** @ignore yes */
mixed* merge_effect( object thing, mixed* store, object label, int id ) {
   if (!store) {
      store = ({ 0, ([ ]) });
   }

   if (mapp(store)) {
      store = ({ 0, store });
   }

   if ( !store[0] ) {
      store[0] = create_store(store[1], environment(thing));
   }
   label->move( store[0] );
   store[1] = store[0]->query_dynamic_auto_load();
   return store;
} /* merge_effect() */

/** @ignore yes */
void end( object thing, mixed* store, int id ) {
  int i;
  
  if (arrayp(store)) {
    for(i=0; i<sizeof(store); i++)
      if(objectp(store[i]))
         store[i]->dest_me();
  } else if(objectp(store))
    store->dest_me();
  
   thing->remove_extra_look( this_object() );
} /* end() */

/** @ignore yes */
mixed* restart( object thing, mixed stuff, int id ) {
   object player;
   object store;
   mapping map;
   int enum;

   if (mapp(stuff)) {
      map = stuff;
   } else if (stuff) {
      map = stuff[1];
   } else {
      map = ([ ]);
   }
   player = environment( thing );
   thing->add_extra_look( file_name(this_object()) );
   store = create_store(map, environment(thing));
   enum = thing->sid_to_enum(id);
   thing->set_arg_of(enum, ({ store, map }));
} /* restart() */

/** @ignore yes */
string extra_look( object thing ) {
   int *enums;
   object store;
   object *labels;
   mixed *bing;

   enums = (int *)thing->effects_matching( "object.label" );
   if ( !sizeof( enums ) ) {
      return "";
   }
   bing = thing->arg_of( enums[ 0 ] );
   if (pointerp(bing)) {
      store = bing[0];
      if (!store) {
         store = create_store(bing[1], environment(thing));
         thing->set_arg_of(enums[0], ({ store, bing[1] }));
      }
   }
   //store = (object)thing->arg_of( enums[ 0 ] )[0];
   if ( !objectp( store ) ) {
      return "";
   }
   labels = (object *)store->find_inv_match( "" );
   if ( !sizeof( labels ) ) {
      return "";
   }
   return capitalize( (string)thing->query_pronoun() ) +" has "+
         query_multiple_short( labels ) +" stuck on "+
         (string)thing->query_objective() +".\n";
} /* extra_look() */
// --- END [/mnt/home2/grok/lib/std/effects/object/label.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/object/identity_hold.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/object/identity_hold.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629048   Available: 13576402
Inodes: Total: 5242880    Free: 4960135
1956 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/object/identity_hold.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629048   Available: 13576402
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/**
 * This is the effect skelton docs.  This effect
 * has a classification of "object.identify".
 * <p>
 * The arguement is a mapping which has the "keep" or the "identity"
 * bit set.  If either of these are set then that bit of the objects
 * definition is overwritten.
 * @classification object.identify
 * @see help::effects
 */
#include <effect.h>
#include "path.h"

class special_stuff {
   int keep;
   string identity;
}

/** @ignore yes */
int query_indefinite() { return 1; }

/** @ignore yes */
string query_classification() { return "object.identify"; }

/** @ignore yes */
string query_shadow_ob() { return SHADOWS + "identity_hold"; }

/** @ignore yes */
class special_stuff beginning( object thing, mapping data, int id ) {
   class special_stuff special_stuff;

   special_stuff = new(class special_stuff);
   special_stuff->keep = data["keep"];
   special_stuff->identity = data["identity"];
   thing->set_keep_value(special_stuff->keep);
   thing->set_identifier(special_stuff->identity);
   thing->set_identity_hold_owner(this_player());
   return special_stuff;
} /* beginning() */

/** @ignore yes */
class special_stuff merge_effect( object thing,
                                  class special_stuff data,
                                  mapping arg,
                                  int id ) {
   if (!nullp(arg["keep"])) {
      data->keep = arg["keep"];
   }
   if (!nullp(arg["identity"])) {
      data->identity = arg["identity"];
   }
   thing->set_keep_value(data->keep);
   thing->set_identifier(data->identity);
   return data;
} /* merge_effect() */

/** @ignore yes */
void end( object thing, mixed* store, int id ) {
} /* end() */

/** @ignore yes */
class special_stuff restart( object thing, class special_stuff data, int id ) {
   thing->set_keep_value(data->keep);
   thing->set_identifier(data->identity);
   thing->set_identity_hold_owner(this_player());
   return data;
} /* restart() */
// --- END [/mnt/home2/grok/lib/std/effects/object/identity_hold.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/external/flea_cure.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/external/flea_cure.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629047   Available: 13576401
Inodes: Total: 5242880    Free: 4960135
3119 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/external/flea_cure.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629047   Available: 13576401
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: flea_cure.c,v 1.2 1999/10/24 16:12:47 gruper Exp $
 * $Log: flea_cure.c,v $
 * Revision 1.2  1999/10/24 16:12:47  gruper
 * Did I change this one?
 *
 * Revision 1.1  1998/01/06 04:10:22  ceres
 * Initial revision
 * 
*/
/**
 * This is the effect skelton docs.  This effect
 * has a classification of "body.smell.insecticide".
 * <p>
 * Describe the arguments in here.
 * @classification body.smell.insecticide
 * @see help::effects
 */
/*
** flea_cure - for curing the flea effect.
**
** Written by: Jeremy - 6-Oct-95
**
** Deutha added smell_string(), capitalised Grflx and put a "u" in odour :)
*/

#include <effect.h>

int infested;

int cleanse( object thing, int bonus ) {
    int i, flag, *effnums;
    class effect *effs;
    
    if ( !thing )
      return 0;
    if ( !living( thing ) )
      return 0;
    effnums = (int *)thing->effects_matching(
              "disease.parasite.external.flea");
    if ( !sizeof( effnums ) )
      return 0;
    effs = (class effect *)thing->query_effs();
    for ( i = sizeof( effnums ) - 1; i >= 0; i-- )
      if ( effs[ effnums[ i ] ]->ob_name->test_remove( thing,
          effs[ effnums[ i ] ]->arg, effnums[ i ], bonus ) ) {
          thing->delete_effect( effnums[ i ] );
          flag = 1;
      }
    infested = flag;
    return flag;
} /* cleanse() */

/** @ignore yes */
void beginning( object player, int time ) {
   player->submit_ee( "make_smell", ({ 20, 30 }), EE_CONTINUOUS );
   player->submit_ee( "kill_flea", ({ 30, 40 }), EE_CONTINUOUS );
   call_out("cleanse", 0, player, time/10);
   //cleanse(player, time/10);
   player->submit_ee( 0, time, EE_REMOVE );
} /* beginning() */

/** @ignore yes */
int merge_effect( object player, int time1, int time2 ) {
   player->submit_ee( 0, time1 + time2 - (int)player->expected_tt(),
         EE_REMOVE );
   if (!infested)
       call_out("cleanse", 0, player, (time1+time2)/10);
   return time1 + time2;
} /* merge_effect() */
 
/** @ignore yes */
void end( object player, int time ) {
   tell_object( player, "The odd odour is gone now.\n" );
} /* end() */
 
void kill_flea( object player ) {
    if (infested && random(2)) {
        tell_object( player, "You hear a faint scream and see a small dot " +
                    "fall past your eyes.\n" );
        tell_room( environment( player ), "You see a tiny speck leap from " +
                  (string)player->short() + "'s head, screaming pitifully.\n",
                  player );
    }
} /* kill_flea() */

void make_smell( object player ) {
    tell_object( player, "You notice a strange odour, like wet Grflx "
              "and rotting cabbage, in the air.\n" );
    tell_room( environment( player ),  "A smell reminiscent of a wet Grflx "+
              "and rotting cabbages seems to emanate from "+
              (string)player->short() + ".\n", player );
} /* make_smell() */

/** @ignore yes */
string query_classification() { return "body.smell.insecticide"; }

string smell_string( object player, int time ) {
   return "the odd odour of wet Grflx and rotting cabbage";
} /* smell_string() */
// --- END [/mnt/home2/grok/lib/std/effects/external/flea_cure.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/external/insect_repellent.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/external/insect_repellent.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629046   Available: 13576400
Inodes: Total: 5242880    Free: 4960135
2107 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/external/insect_repellent.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629046   Available: 13576400
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: insect_repellent.c,v 1.1 2001/11/16 09:09:10 siel Exp $
 *
 *
 */

#include "effect.h"

string query_classification() {
  return "herb.insect.repellent";
}

int beginning(object them, int power, int id) {
  if (power <= 0) {
    them->submit_ee(0, 1, EE_REMOVE);
    return 0;
  }
  them->add_property("insect", power);
  them->submit_ee("start_mess", 2, EE_ONCE);
  them->submit_ee("smell", ({30, 60}), EE_CONTINUOUS);
  return power;
}

int merge_effect(object them, int power, int adjust) {
  power += adjust;
  if (power <= 0) {
    them->submit_ee(0, 1, EE_REMOVE);
    return 0;
  }
  them->submit_ee(0, -1, EE_REMOVE);
  return power;
}

void start_mess(object them, int power, int id) {
  string start_mess;
  switch (power) {
  case 1:
    start_mess = "You smell rather pleasant, much as you might wish to for a "
           "date.";
    break;
  case 2..3:
    start_mess = "A pungent smell envelops you.";
    break;
  default:
    start_mess = "A horribly pungent smell envelops you, sufficient to make "
           "anyone with a sense of smell keep their distance.";
  }
  tell_object(them, start_mess+"\n");
}

void smell(object them, int power, int id) {
  string self_mess, other_mess;
  object env;

  if (--power <= 0) {
    tell_object(them, "The herbal odour around you fades away.\n");
    them->remove_property("insect");
    them->submit_ee(0, 1, EE_REMOVE);
    return 0;
  }
  switch (power) {
  case 1:
    self_mess = "A pleasant smell emanates from your body.";
    other_mess = "A pleasant smell emanates from "+them->one_short()+".";
    break;
  case 2..3:
    self_mess = "A pungent herbal smell emanates from your body.";
    other_mess = "A pungent herbal smell emanates from "+them->one_short()+".";
    break;
  default:
    self_mess = "You reek of pungent herbs.";
    other_mess = "$C$"+them->one_short()+" $V$0=reeks,reek$V$ of pungent "
           "herbs.";
  }
  tell_object(them, self_mess+"\n");
  if ((env = environment(them)) && env->query_property("location")) {
    tell_room(env, other_mess+"\n", them);
  }
}
// --- END [/mnt/home2/grok/lib/std/effects/external/insect_repellent.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/external/snowball.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/external/snowball.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629045   Available: 13576399
Inodes: Total: 5242880    Free: 4960135
2525 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/external/snowball.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629045   Available: 13576399
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: snowball.c,v 1.1 1998/01/06 04:10:22 ceres Exp $
 * $Log: snowball.c,v $
 * Revision 1.1  1998/01/06 04:10:22  ceres
 * Initial revision
 * 
*/
/**
 * This is the effect skelton docs.  This effect
 * has a classification of "mudlib.snowball".
 * <p>
 * Describe the arguments in here.
 * @classification mudlib.snowball
 * @see help::effects
 */
#include <effect.h>

/** @ignore yes */
string query_classification() { return "mudlib.snowball"; }

/** @ignore yes */
void beginning( object player, int amount, int id ) {
   player->add_extra_look( this_object() );
   player->submit_ee( "decrease_amount", 15, EE_CONTINUOUS );
} /* beginning() */

void restart( object player, int amount, int id ) {
   player->add_extra_look( this_object() );
} /* restart() */

/** @ignore yes */
int merge_effect( object player, int old_amount, int new_amount, int id ) {
   return old_amount + new_amount;
} /* merge_effect() */

/** @ignore yes */
void end( object player, int amount, int id ) {
   player->remove_extra_look( this_object() );
} /* end() */

void decrease_amount( object player, int amount, int id ) {
   amount -= 3 + random( random(amount) );
   if ( amount < 0 ) {
      amount = 0;
      player->submit_ee( 0, 1, EE_REMOVE );
   }
   player->set_arg_of( (int)player->sid_to_enum( id ), amount );
   player->add_effect("/std/effects/other/wetness", roll_MdN( 10, 10 ) );
} /* decrease_amount() */

string extra_look( object player ) {
   int *enums;
   string desc;
   enums = (int *)player->effects_matching( "mudlib.snowball" );
   if ( !sizeof( enums ) )
      return "";
   switch ( (int)player->arg_of( enums[ 0 ] ) ) {
      case 0 .. 99 :
         desc = " has a little bit of snow";
         break;
      case 100 .. 199 :
         desc = " has a bit of snow";
         break;
      case 200 .. 299 :
         desc = " has a few small lumps of snow";
         break;
      case 300 .. 399 :
         desc = " has a few lumps of snow";
         break;
      case 400 .. 499 :
         desc = " has a number of lumps of snow";
         break;
      case 500 .. 599 :
         desc = " has quite a lot of snow";
         break;
      case 600 .. 699 :
         desc = " has a lot of snow";
         break;
      default :
/* They should be blind with this much... */
         desc = " has a thick layer of snow";
   }
   return capitalize( (string)player->query_pronoun() ) + desc +" on "+
         (string)player->query_possessive() +" face.\n";
} /* extra_look() */
// --- END [/mnt/home2/grok/lib/std/effects/external/snowball.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/external/coffee_nose.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/external/coffee_nose.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629044   Available: 13576398
Inodes: Total: 5242880    Free: 4960135
1457 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/external/coffee_nose.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629044   Available: 13576398
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
  This effect has a classification
  of "coffee.nose".
   It was written by Gin for Starbanks.
 */
#include <effect.h>

/** @ignore yes */
void beginning( object player, int time ) {
    if (time > 1800)
        time = 1800;

    tell_object( player, "\n" );
    tell_room( environment( player ), (string)player->the_short() + " drinks some of his coffee and ends up with a small amount of froth on "+player->query_possessive()+" nose.\n", player);
    player->submit_ee( 0, time, EE_REMOVE );
    player->add_extra_look( this_object() );

} /* beginning() */

/** @ignore yes */
int merge_effect( object player, int time1, int time2 ) {
    int newtime;
     newtime = (time1 > time2 ) ? time1 : time2; 
     newtime = ( newtime > 1800 ) ? 1800 : newtime; 
    player->submit_ee( 0, newtime, EE_REMOVE );
    return newtime;
} /* merge_effect() */

/** @ignore yes */
void end( object player, int time ) {
    if ( !player->query_property( "dead" ) )
        tell_object( player, "A small amount of frothy Coffee drops onto the floor.\n" );
    player->remove_extra_look( this_object() );
} /* end() */

/** @ignore yes */
string query_classification() { return "coffee.nose"; }
/** @ignore yes */
string extra_look( object player ) {
    return capitalize( player->query_pronoun()+" looks "
      "like "+player->query_pronoun()+" has a small amount of creamy, frothy coffee on "+player->query_possessive()+" nose.\n" );
}/* end query_extra_look() */
// --- END [/mnt/home2/grok/lib/std/effects/external/coffee_nose.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/disease/basic_disease.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/disease/basic_disease.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629044   Available: 13576398
Inodes: Total: 5242880    Free: 4960135
2120 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/disease/basic_disease.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629044   Available: 13576398
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: basic_disease.c,v 1.1 1998/01/06 04:08:27 ceres Exp $
 * $Log: basic_disease.c,v $
 * Revision 1.1  1998/01/06 04:08:27  ceres
 * Initial revision
 * 
*/
/**
 * This is the effect skelton docs.  This effect
 * has a classification of "misc.curse.smurf".
 * <p>
 * Describe the arguments in here.
 * @classification misc.curse.smurf
 * @see help::effects
 */
/* Basic file meant to be inherited by all diseases.  -*- LPC -*-
 * Very much a work in progress
 * If you change this file, remember to update
 * /doc/creator/files/std.effects.disease.basic_disease as well
 */
#include <effect.h>
#include <disease.h>

int do_setup;
string name, classification, shadow_ob;

void set_name( string str ) { name = str; }
string query_name() { return name; }

void set_classification( string str ) { classification = str; }
/** @ignore yes */
string query_classification() { return classification; }

void create() {
   name = "Some undefined disease";
   classification = "disease.unset";
   if ( !do_setup )
      this_object()->setup();
} /* create() */

/* returned value is amount of curative power not used, 
 * so it only returns a positive value when this disease is actually cured
 */
int cure( object person, string cure_classification, int power, int enum ) {
   int arg, i, scale;
   string *cure_class, *disease_class;
   
   arg = person->arg_of( enum );
   disease_class = explode( classification, "." )[ 1 .. <1 ];
   cure_class = explode( cure_classification, "." )[ 1 .. <1 ];
   while ( sizeof( disease_class ) && sizeof( cure_class ) &&
          ( disease_class[ 0 ] == cure_class[ 0 ] ) ) {
      disease_class = disease_class[ 1 .. <1 ];
      cure_class = cure_class[ 1 .. <1 ];
   }
   scale = 1;
   i = sizeof( disease_class );
   while ( i-- )  
      scale *= DISEASE_SCALE[ i ];
   i = sizeof( cure_class );
   while ( i-- ) 
      scale *= CURE_SCALE[ i ];
   arg -= power / scale;
   power = -arg * scale;
   person->set_arg_of( enum, arg );
   if ( arg > 0 )
      this_object()->disease_better( person, arg );
   return power;
} /* disease_tick() */

// --- END [/mnt/home2/grok/lib/std/effects/disease/basic_disease.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/disease/hypothermia.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/disease/hypothermia.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629043   Available: 13576397
Inodes: Total: 5242880    Free: 4960135
4197 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/disease/hypothermia.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629043   Available: 13576397
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: hypothermia.c,v 1.2 1999/04/02 16:47:24 taffyd Exp $
 * $Log: hypothermia.c,v $
 * Revision 1.2  1999/04/02 16:47:24  taffyd
 * Made it so you could have your own custom level of freezing. (defaults to 100).
 *
 * Revision 1.1  1998/01/06 04:08:27  ceres
 * Initial revision
 * 
*/
/**
 * This is the effect skelton docs.  This effect
 * has a classification of "disease.hypothermia".
 * <p>
 * Describe the arguments in here.
 * @classification disease.hypothermia
 * @see help::effects
 */
#include <effect.h>

/** @ignore yes */
string query_classification() { return "disease.hypothermia"; }

/** @ignore yes */
int beginning( object player, int index, int id ) {

    if ( !index ) 
        index = 100;

   tell_object( player, "You feel a bit chilly.\n" );
   player->submit_ee( "change_index", ({ 60, 60 }), EE_CONTINUOUS );
   player->submit_ee( "stat_adjusts", ({ 90, 90 }), EE_CONTINUOUS );

   return index;

} /* beginning() */

/** @ignore yes */
int merge_effect( object player, int index ) { return index; }

/** @ignore yes */
void end( object player ) {

   tell_object( player, "You feel a lot warmer now.\n" );

} /* end() */

void change_index( object player, int index, int id ) {
  int *enums, pwet;
  
   if ( !environment( player ) )
      return;
   if ( !environment( player )->query_property( "freezer" ) ) {
      player->submit_ee( 0, 0, EE_REMOVE );
      return;
   }
   index -= 7 - (int)player->query_con() / 7;
   if ( index < 0 ) {
      player->dest_hide_shadow();
      tell_object( player, "The cold is just too much for you.\n" );
      tell_room( environment( player ), "Frost riming "+
            (string)player->query_possessive() +" skin in a thick crust, "+
            (string)player->the_short() +" expires.\n", player );
      player->do_death();
      return;
   }
   switch( random( 4 ) ) {
      case 0 :
         player->dest_hide_shadow();
         tell_object( player, "You shiver.\n" );
         tell_room( environment( player ),
               capitalize( (string)player->short() ) +" shivers.\n", player );
         break;
      case 1 :
         player->dest_hide_shadow();
         tell_object( player, "You rub your arms briskly in an attempt to "+
               "keep warm.\n" );
         tell_room( environment( player ),
               capitalize( (string)player->short() ) +" rubs "+
               (string)player->query_possessive() +" arms briskly.\n",
               player );
         break;
      case 2 :
        enums = (int *)player->effects_matching("body.wetness"); 
         if ( sizeof( enums ) )
           pwet = (int)player->arg_of( enums[ 0 ] );
         
         if ( (int)pwet > 25 ) {
            player->dest_hide_shadow();
            tell_object( player, "You dislodge a lump of ice, which falls "+
                  "and shatters on the floor.\n" );
            tell_room( environment( player ),
                  capitalize( (string)player->short() ) +" dislodges a lump "+
                  "of ices, which falls and shatters on the floor.\n",
                  player );
            player->add_effect("/std/effects/wetness", -25 );
         }
         break;
      default :
         tell_object( player, "You're getting really cold in here.\n" );
   }
   player->set_arg_of( (int)player->sid_to_enum( id ), index );

} /* change_index() */

void stat_adjusts( object player ) {

   switch ( random( 3 ) ) {
      case 0 :
         tell_object( player, "You feel your strength being drained by the "+
               "below freezing temperatures.\n" );
         player->adjust_tmp_str( -1 );
         return;
      case 1 :
         tell_object( player, "You really don't feel at all well stuck in "+
               "here.\n" );
         player->adjust_tmp_con( -1 );
         return;
      default :
         if ( (string)player->query_race() == "troll" ) {
            tell_object( player, "You feel a tingling between your ears and "+
                  "new and strangely clever thoughts race along the "+
                  "superconducting neural pathways of your brain.\n" );
            player->adjust_int( 1 );
         }
   }

} /* stat_adjusts() */
// --- END [/mnt/home2/grok/lib/std/effects/disease/hypothermia.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/disease/simple_disease.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/disease/simple_disease.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629042   Available: 13576396
Inodes: Total: 5242880    Free: 4960135
4823 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/disease/simple_disease.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629042   Available: 13576396
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: simple_disease.c,v 1.4 2002/05/11 16:11:58 tannah Exp $
 * $Log: simple_disease.c,v $
 * Revision 1.4  2002/05/11 16:11:58  tannah
 * Fixed id to be the actual enum rather than an effect id, which
 * in turn fixed the common colds.
 *
 * Revision 1.3  1999/03/05 07:22:45  ceres
 * Modified only to log during debyug
 *
 * Revision 1.2  1999/02/25 05:20:06  ceres
 * Modified to prevent communication in the void.
 *
 * Revision 1.1  1998/01/06 04:08:27  ceres
 * Initial revision
 * 
*/
/**
 * This is the effect skelton docs.  This effect
 * has a classification of "disease.hypothermia".
 * <p>
 * Describe the arguments in here.
 * <p>
 * This effect has a shadow associated with it.
 * @classification disease.hypothermia
 * @see help::effects
 */
/* Basic file meant to be inherited by all diseases.  -*- LPC -*-
 * Very much a work in progress
 * If you change this file, remember to update
 * /doc/creator/files/std.effects.disease.basic_disease as well
 */
#include <effect.h>
#include <disease.h>
inherit BASIC_DISEASE;

int cure_rate, infection_chance;
string shadow_ob;
function infection_check;

void set_cure_rate( int i ) { cure_rate = i; }
int query_cure_rate() { return cure_rate; }

void set_infection_chance( int i ) { infection_chance = i; }
int query_infection_chance() { return infection_chance; }

void set_infection_check( function f ) { infection_check = f; }

void set_shadow_ob( string str ) { shadow_ob = str; }
/** @ignore yes */
string query_shadow_ob() { return shadow_ob; }

void create() {
   do_setup++;
   ::create();
   do_setup--;
   shadow_ob = 0;
   infection_chance = 0;
   infection_check = 0;
   cure_rate = 0;
   if ( !do_setup )
      this_object()->setup();
} /* create() */

/* the effects stuff starts here */

/** @ignore yes */
int beginning( object person, int arg, int id ) {
  id = person->sid_to_enum( id );
   arg = this_object()->disease_start( person, arg, id );
   if ( !arg ) {
      person->submit_ee( 0, 0, EE_REMOVE );
      return 0;
   }
   person->submit_ee( "disease_tick", ( arg > 60 ) ? 60 : arg, EE_ONCE );
   return arg;
} /* beginning() */

/* when reinfected, get the worse of the two */
/** @ignore yes */
int merge_effect( object person, int old_arg, int new_arg, int id ) {
   if ( old_arg < new_arg ) {
      old_arg = new_arg;
      this_object()->disease_worse( person, old_arg, id );
   }
   return old_arg;
} /* merge_effect() */

/** @ignore yes */
void end( object person, int arg, int id ) {
/** @ignore yes */
   this_object()->disease_end( person, arg, id );
} /* end() */

void disease_tick( object person, int arg, int id ) {
   object *things;
   int i;

   /* this can be removed later */
   if ( arg > 100000 )
      arg = 10000;
   arg -= ( cure_rate*( (int)person->query_con() + 7 ) ) / 20 ;
   person->set_arg_of( (int)person->sid_to_enum( id ), arg );
   if ( arg < 0) {
      person->submit_ee( 0, 0, EE_REMOVE );
      return;
   }
   if (person && environment(person) &&
       file_name(environment(person)) != "/room/void" &&
       file_name(environment(person)) != "/room/rubbish" &&
       infection_chance > 0 &&
       (random( 100 ) < infection_chance) ) {

     if ( functionp( infection_check ) ) {
       things = filter_array( all_inventory( environment( person ) ),
                             infection_check ) - ({ person }); 
     } else {
       things = filter_array( all_inventory( environment( person ) ),
                  /* Something can catch diseases if it's alive, and */
                  (: living( $1 ) &&
                   /* is an NPC that is not unique */
                   ( ( !userp( $1 ) && !$1->query_property( "unique" ) ) ||
                   /* or is a player and is not dead. */
                   userp( $1 ) ) && !$1->query_property( "dead" ) :) )
            - ({ person });
     }

     i = sizeof( things );
     if ( i ) {
       i = random( i );
       things[ i ]->add_effect( file_name( this_object() ), arg );
#ifdef DEBUG
       log_file( "INFECTION", "%s, %s infected with %s by %s\n",
                ctime( time() ),
                things[ i ]->query_name(),
                this_object()->query_name(),
                person->query_name() );
#endif       
     }
   }
   person->submit_ee( "disease_tick", ( arg > 60 ) ? 60 : arg, EE_ONCE );
   /* If it has no heart beat, don't waste processor time in case
    * disease_action would have caused it to take damage and start the heatbeat
    */
   if ( !query_heart_beat( person ) )
      return;
   this_object()->disease_action( person, arg, id );
} /* disease_tick() */

int test_remove( object, int, int, int ) {
#ifdef DEBUG
  log_file( "OLD_CURE", file_name( previous_object() ) +" "+
            file_name( this_object() ) +"\n" );
#endif  
} /* test_remove() */
// --- END [/mnt/home2/grok/lib/std/effects/disease/simple_disease.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/disease/hp_drain_effect.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/disease/hp_drain_effect.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629040   Available: 13576394
Inodes: Total: 5242880    Free: 4960135
1769 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/disease/hp_drain_effect.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629040   Available: 13576394
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: hp_drain_effect.c,v 1.1 2000/11/04 12:20:02 turvity Exp $
 *
 *
 */

#include <effect.h>

#include "path.h"
#include "/std/living/stats.c"

#define CLASS "general.hp.drain"

/** @ignore yes */
string query_classification(){
  return CLASS;
}

/** @ignore yes */
string query_death_reason(){
  return "wasting away slowly";
}

/** @ignore yes */
void adjust_health( object player ){
  int damage,
    *enums = player->effects_matching( query_classification() );
  mixed *args;
  if( sizeof( enums ) ){
    args = player->arg_of( enums[ 0 ] );
  }

  /* Damages the player for a weighted amount of damage. */
  tell_object( player, "You feel weak.\n" );
  damage = roll_MdN( 2, ( ( args[0] ) / 2 ) );
  if( ( player )->adjust_hp( -damage ) < 0 ){
    ( player )->attack_by( this_object() );
  }
  tell_creator( player,
                "Damage: " + damage + "\n" );
}

/** @ignore yes
 * Arguments in the form:
 *  int *arg = ({ damage, duration, ({ beginning_message, end_message }) })
 */
mixed  *beginning( object player, mixed *arg ){
  tell_object( player, arg[2][0] + "\n" );
  player->submit_ee( "adjust_health", ({ 5, 10 }),
                     EE_CONTINUOUS, player );
  player->submit_ee( 0, arg[1], EE_REMOVE );
  return arg;
}

/** @ignore yes */
mixed *merge_effect( object player, mixed *old_arg, mixed *arg ){
  arg[0] = ( old_arg[0] + arg[0] ) / 2;
  player->submit_ee( 0, arg[1] + player->expected_tt(), EE_REMOVE );
  return arg;
}

/** @ignore yes */
void end( object player, mixed *arg ){
  string *message = arg[2];

  tell_object( player, message[1] + "\n" );
}

/** @ignore yes */
void restart( object player, mixed *arg ){
  string *message = arg[2];
  
  tell_object( player, message[0] + "\n" );
}

// --- END [/mnt/home2/grok/lib/std/effects/disease/hp_drain_effect.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/disease/rabies.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/disease/rabies.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629040   Available: 13576394
Inodes: Total: 5242880    Free: 4960135
2577 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/disease/rabies.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629040   Available: 13576394
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*
 * Rabies.  Originally written for the Alchemists' Guild
 * Foolish 2002
 * This effect has classification body.disease.rabies
 * Tweaked and tidied by Carmine, 2002
 */

#include <effect.h>

#define COMBAT_EFFECT "/std/effects/fighting/combat"


string *wretch_msg = ({
    "You start to froth at the mouth and your head spins.\n",
    "The pain is so intense you want to rip your eyes out.\n",
    "The pain from your ripped flesh radiates through your body.\n",
    "You feel like howling at the moon in rabid madness.\n",
    "You spray rabid froth everywhere.\n"
});


string *room_msg = ({
    " starts to froth at the mouth and looks crazed.\n",
    "'s eyes roll in crazed fury.\n",
    " seethes in agony.\n",
    " howls at the moon in rabid agony.\n",
    " sprays froth everywhere.\n"
});


/** @ignore yes */
string query_classification() { return "body.disease.rabies"; }


/** @ignore yes */
int beginning( object player, int time ) {
   if( player->query_property( "undead" ) ) {
      player->submit_ee( 0, 0, EE_REMOVE );
      return -1;
   } 

   player->submit_ee( "wretch", ({ 30, 60 }), EE_CONTINUOUS );
   player->submit_ee( 0, time, EE_REMOVE );
   
   player->adjust_bonus_wis( -2 );
   player->adjust_bonus_int( -2 );
  
   tell_object( player, "Throbbing pains radiate from your bite wound, and "
      "you feel your sanity slip away.\n" );
 
   return time;
} /* beginning() */


/*
   Merge has no effect - if you've got rabies, you've just got it, no
   amount of trying to catch it again will affect that
*/
int merge_effect( object player, int time1, int time2 ) {
    return time1;
} /* merge_effect() */


int restart( object player, int time ) {
   player->adjust_bonus_wis( -2 );
   player->adjust_bonus_int( -2 );
   return time;
} /* restart() */


/** @ignore yes */
void end( object player, int time ) {
   player->adjust_bonus_int( 2 );
   player->adjust_bonus_wis( 2 );
   tell_object( player, "You feel the madness leave you, and stop frothing"
      ".\n" );
} /* end() */


void wretch( object player, int time ) {
    int msg_no;

    msg_no = random( sizeof( wretch_msg ) );
    tell_object( player, wretch_msg[ msg_no ] );
    tell_room( environment( player ), (string)player->the_short() +
              room_msg[ msg_no ], player );
              
    player->adjust_hp( - ( ( (int)player->query_hp() / 10 ) + 
                           ( random( 50 ) ) ) );
    COMBAT_EFFECT->monitor_points( player, 1 );
} /* wretch() */


string query_death_reason() {
   return "a nasty case of rabies";
} /* query_death_reason() */
// --- END [/mnt/home2/grok/lib/std/effects/disease/rabies.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/disease/flea_infestation.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/disease/flea_infestation.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629039   Available: 13576393
Inodes: Total: 5242880    Free: 4960135
3166 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/disease/flea_infestation.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629039   Available: 13576393
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: flea_infestation.c,v 1.6 2001/06/01 21:17:44 ceres Exp $
 * $Log: flea_infestation.c,v $
 * Revision 1.6  2001/06/01 21:17:44  ceres
 * Stopped massive outbreaks
 *
 * Revision 1.5  2000/11/18 07:25:08  ceres
 * Made fleas disappear more quickly.
 *
 * Revision 1.4  2000/01/07 22:17:54  ceres
 * Added a chance that an NPC will stop having fleas.
 *
 * Revision 1.3  1998/04/21 02:15:24  terano
 * Changed % infection per EE from 15 to 2..
 *
 * Revision 1.2  1998/04/20 18:20:03  hobbes
 * changed set_infection_chance() from 1 to 15
 *
 * Revision 1.1  1998/01/06 04:08:27  ceres
 * Initial revision
 * 
*/
/**
 * This is the effect skelton docs.  This effect
 * has a classification of "misc.curse.smurf".
 * <p>
 * Describe the arguments in here.
 * @classification misc.curse.smurf
 * @see help::effects
 */
/* Flea infestation, use 10000 as standard severity  -*- LPC -*-
 */
#include <effect.h>
#include <disease.h>
inherit SIMPLE_DISEASE;

void setup() {
   set_name( "Fleas" );
   set_classification( "disease.parasite.external.flea" );
  set_infection_chance( 2 );
   /* Something can catch fleas if it's alive, and */
   set_infection_check( (: living( $1 ) &&
         /* is an NPC that is not unique or */
               ( ( !userp( $1 ) && !$1->query_property( "unique" ) ) ||
         /* is a mature player, and is not dead. */
               $1->query_mature() ) && !$1->query_property( "dead" ) :) );
} /* setup() */

int disease_start( object player, int arg, int ) {
   string race_ob;

   race_ob = (string)player->query_race_ob();
   /* Trolls can't have fleas. */
   if ( ( (string)race_ob->query_name() == "troll" ) ||
         player->query_property( "no fleas" ) ) {
      player->submit_ee( 0, 0, EE_REMOVE );
      return 0;
   }
   return arg;
} /* disease_start() */

void disease_action( object player, int, int ) {
   switch( random( 14 ) ) {
      case 0 .. 3 :
         player->remove_hide_invis( "hiding" );
         tell_object( player, "Something itches.  You scratch yourself.\n" );
         tell_room( environment( player ), (string)player->one_short() +
               " scratches "+ (string)player->query_objective() +"self.\n",
               player );
         break;
      case 4 .. 7 :
         player->remove_hide_invis( "hiding" );
         tell_object( player, "Ouch!  Something bit you!\n" );
         tell_room( environment( player ), (string)player->one_short() +
               " starts as if bitten.\n", player );
         /* Should this use ac? */
         player->adjust_hp( -10 - random( 10 ) );
         break;
      case 8 .. 11 :
         tell_object( player, "You notice a small red welt on your skin.\n" );
         break;
      default:
   }

   if(!random(10) && !userp(player))
     player->submit_ee(0, 0, EE_REMOVE);
   
} /*  disease_action( */

int test_remove( object player, int arg, int enum, int bonus ) {
   log_file( "OLD_CURE", file_name( previous_object() ) +" "+
            file_name( this_object() ) +"\n" );
   if ( arg + bonus < 30 ) {
      player->set_arg_of( enum, arg + bonus );
      return 0;
   }
   return 1;
} /* test_remove() */
// --- END [/mnt/home2/grok/lib/std/effects/disease/flea_infestation.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/disease/common_cold.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/disease/common_cold.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629038   Available: 13576392
Inodes: Total: 5242880    Free: 4960135
1670 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/disease/common_cold.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629038   Available: 13576392
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: common_cold.c,v 1.1 1998/01/06 04:08:27 ceres Exp $
 * $Log: common_cold.c,v $
 * Revision 1.1  1998/01/06 04:08:27  ceres
 * Initial revision
 * 
*/
/**
 * This is the effect skelton docs.  This effect
 * has a classification of "misc.curse.smurf".
 * <p>
 * Describe the arguments in here.
 * @classification misc.curse.smurf
 * @see help::effects
 */
/* -*- LPC -*-
 * with a cure_rate of 6, use 20000 as "standard" severity
 * since a cold normally takes a week, 
 */
#include <disease.h>
#include <effect.h>
inherit SIMPLE_DISEASE;

void setup() {
   set_name( "Common Cold" );
   set_cure_rate( 6 );
   set_classification( "disease.infection.respiratory.cold" );
} /* setup() */

int disease_start( object player, int arg, int sid ) {
   tell_object( player, "You realise that your nose is running.\n" );
   player->submit_ee2( sid, "sap_strength", ({ 600, 600 }), EE_CONTINUOUS );
   return arg;
} /* disease_start() */

/** @ignore yes */
void disease_end( object player, int arg, int sid ) {
   if ( !player->query_property( "dead" ) )
      tell_object( player, "You realise that your nose is clear again.\n" );
} /* disease_end() */

void disease_action( object player, int arg ) {
   switch ( random( 3 ) ) {
      case 0 :
         player->new_parser( "sniff" );
         break;
      case 1 :
         player->new_parser( "cough" );
         break;
      default :
         player->new_parser( "sneeze" );
   }
} /* cold_symptoms() */

void sap_strength( object player ) {
   tell_object( player, "You feel your strength being sapped by the cold.\n" );
   player->adjust_tmp_str( -1 );
} /* sap_strength() */

// --- END [/mnt/home2/grok/lib/std/effects/disease/common_cold.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/disease/headache.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/disease/headache.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629037   Available: 13576391
Inodes: Total: 5242880    Free: 4960135
2709 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/disease/headache.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629037   Available: 13576391
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/** This is an effect to give the player a nasty headache.
*   It lowers their dex, con, wis, and int by 1, as well as 
*   Making them unable to concentrate enough to do spells or 
*   special fighting commands.  Ouch!  It has a classification 
*   of disease.pain.headache
*/
#include <effect.h>
#include "path.h"
string query_classification() { return "disease.pain.headache"; }

/** @ignore yes */
int beginning(object player, mixed arg) {
   tell_object(player, "Your head hurts.\n");
   player->submit_ee(0, arg, EE_REMOVE);
   player->submit_ee("pains", ({30, 60}), EE_CONTINUOUS);
   player->adjust_bonus_con(-1);
   player->adjust_bonus_dex(-1);
   player->adjust_bonus_int(-1);
   player->adjust_bonus_wis(-1);
   return arg;
}

/** @ignore yes */

int restart(object player, mixed arg) {
   player->submit_ee("pains", ({30, 60}), EE_CONTINUOUS);
   player->adjust_bonus_con(-1);
   player->adjust_bonus_dex(-1);
   player->adjust_bonus_int(-1);
   player->adjust_bonus_wis(-1);
   return arg;
}

/** @ignore yes */

int merge_effect( object player, int time1, int time2 ) {
   int duration;
   duration = time2 + player->expected_tt();
   player->submit_ee( "end", duration, EE_REMOVE );
   player->submit_ee("pains", ({30, 60}), EE_CONTINUOUS);
   return duration;
}

/** @ignore yes */

void pains( object player) {
   switch (random(5)) {
    case 0:
      tell_object( player, "Your head hurts.\n");
      tell_room( environment( player ), player->the_short()
           + " looks pained.\n",  ({ player }) );
      break;
    case 1:
      tell_object( player, "You clutch your aching head.\n");
      tell_room( environment( player ), player->the_short()
           + " clutches " + player->query_possessive() + " head.\n",
          ({ player }) );
      break;
    case 2:
      tell_object( player, "Owwwwwwwwwwww!\n");
      tell_room( environment( player ), player->the_short()
           + " moans.\n",  ({ player }) );
      break;
    case 3:
      tell_object( player, "Your head pounds!\n");
      tell_room( environment( player ), player->the_short()
           + " clutches " + player->query_possessive()
           + " head and moans.\n",  ({ player }) );
      break;
    case 4:
      tell_object( player, "Arrrrgh!  Migraine!\n");
      tell_room( environment( player ), player->the_short()
           + " whimpers.\n",  ({ player }) );
      break;
   }
}


/** @ignore yes */
void end(object player) {
   tell_object(player, "Your head feels better.\n");
   player->adjust_bonus_con(1);
   player->adjust_bonus_dex(1);
   player->adjust_bonus_wis(1);
   player->adjust_bonus_int(1);
}
/** @ignore yes */
string query_shadow_ob(){ return SHADOWS+"disease/headache_shadow"; }
// --- END [/mnt/home2/grok/lib/std/effects/disease/headache.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/disease/flu.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/disease/flu.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629036   Available: 13576390
Inodes: Total: 5242880    Free: 4960135
1126 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/disease/flu.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629036   Available: 13576390
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: flu.c,v 1.1 1998/01/06 04:08:27 ceres Exp $
 * $Log: flu.c,v $
 * Revision 1.1  1998/01/06 04:08:27  ceres
 * Initial revision
 * 
*/
/**
 * This is the effect skelton docs.  This effect
 * has a classification of "disease.infection.general.flu".
 * <p>
 * Describe the arguments in here.
 * <p>
 * This effect has a shadow associated with it.
 * @classification disease.infection.general.flu
 * @see help::effects
 */
#include <effect.h>
#include "path.h"
int query_secs_between_hb() { return 1; }

/** @ignore yes */
string query_classification() { return "disease.infection.general.flu"; }

/** @ignore yes */
int beginning(object player, mixed arg) {
   tell_object(player, "You shiver.\n");
   return arg;
}

int effect_heart_beat(object player, int hbnum, mixed arg, int id){
   /* test for the duration finished yet */

   if (hbnum == arg) return REMOVE_THIS_EFFECT;
   return arg;
}

/** @ignore yes */
void end(object player) {
   tell_object(player, "You feel altogether healthy again.\n");
}
/** @ignore yes */
string query_shadow_ob(){ return SHADOWS+"flu_shadow"; }
// --- END [/mnt/home2/grok/lib/std/effects/disease/flu.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/disease/gp_drain_effect.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/disease/gp_drain_effect.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629036   Available: 13576390
Inodes: Total: 5242880    Free: 4960135
1653 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/disease/gp_drain_effect.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629036   Available: 13576390
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: gp_drain_effect.c,v 1.1 2000/11/04 12:20:02 turvity Exp $
 *
 *
 */

#include <effect.h>

#include "path.h"
#include "/std/living/stats.c"

#define CLASS "general.gp.drain"

/** @ignore yes */
string query_classification(){
  return CLASS;
}

/** @ignore yes */
string query_death_reason(){
  return "wasting away slowly";
}

/** @ignore yes */
void adjust_health( object player ){
  int damage,
    *enums = player->effects_matching( query_classification() );
  mixed *args;

  if( sizeof( enums ) ){
    args = player->arg_of( enums[ 0 ] );
  }
  
  tell_object( player, "You feel woozy.\n" );
  damage = roll_MdN( 2, ( ( args[0] ) / 2 ) );
  ( player )->adjust_gp( -damage );
  tell_creator( player,
                "Drain: " + damage + "\n" );
}

/** @ignore yes
 * Arguments in the form:
 *  int *arg = ({ drain, duration, ({ beginning_message, end_message }) })
 */
mixed  *beginning( object player, mixed *arg ){
  tell_object( player, arg[2][0] + "\n" );
  player->submit_ee( "adjust_health", ({ 5, 10 }),
                     EE_CONTINUOUS, player );
  player->submit_ee( 0, arg[1], EE_REMOVE );
  return arg;
}

/** @ignore yes */
mixed *merge_effect( object player, mixed *old_arg, mixed *arg ){
  arg[0] = ( old_arg[0] + arg[0] ) / 2;
  player->submit_ee( 0, arg[1] + player->expected_tt(), EE_REMOVE );
  return arg;
}

/** @ignore yes */
void end( object player, mixed *arg ){
  string *message = arg[2];

  tell_object( player, message[1] + "\n" );
}

/** @ignore yes */
void restart( object player, mixed *arg ){
  string *message = arg[2];
  
  tell_object( player, message[0] + "\n" );
}

// --- END [/mnt/home2/grok/lib/std/effects/disease/gp_drain_effect.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/disease/general_hypothermia.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/disease/general_hypothermia.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629035   Available: 13576389
Inodes: Total: 5242880    Free: 4960135
6870 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/disease/general_hypothermia.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629035   Available: 13576389
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: general_hypothermia.c,v 1.2 2000/01/07 22:18:49 ceres Exp $
 * $Log: general_hypothermia.c,v $
 * Revision 1.2  2000/01/07 22:18:49  ceres
 * bing
 *
 * Revision 1.1  1998/01/06 04:08:27  ceres
 * Initial revision
 * 
*/
/**
 * This effect has a classification of "disease.hypothermia".
 * <p>
 * Describe the arguments in here.
 * @classification disease.hypothermia
 * @see help::effects
 */
#include <effect.h>
#include <weather.h>
#include <clothing.h>

#define DEBUG 1
#define COMFORTABLE 20
#define DEATH -500

void shiver(object player, int temperatureess, int id);
int calc_personal_temp(object player);

/** @ignore yes */
string query_classification() { return "disease.hypothermia"; }

/** @ignore yes */
int beginning( object player, int temperature, int id ) {
  if(temperature + calc_personal_temp(player) < COMFORTABLE) {
    tell_object(player, "You feel a bit chilly.\n");
    
    player->submit_ee( "shiver", ({ 20, 20 }), EE_CONTINUOUS );
    player->submit_ee( "stat_adjusts", ({ 240, 240 }), EE_CONTINUOUS );
    player->add_extra_look( this_object() );

  } else {
    player->submit_ee(0, 0, EE_REMOVE );
  }
  return temperature + calc_personal_temp(player) - COMFORTABLE;
}

/** @ignore yes */
int merge_effect( object player, int new_temperature, int old_temperature,
                  int id ) {
  return old_temperature + (new_temperature + calc_personal_temp(player) -
                            COMFORTABLE);
}

void restart(object player) {
  player->add_extra_look( this_object() );
}

/** @ignore yes */
void end( object player ) {
  tell_object( player, "You don't feel cold anymore.\n" );
  player->remove_extra_look( this_object() );
}

void shiver(object player, int temperature, int id) {
  int *enums, pwet, personal;
  int room_temp, min;
  
  if (!environment(player))
    return;

  // Update the temperature factor so they warm up or cool down as
  // appropriate.
  room_temp = WEATHER->temperature_index(environment(player));
  personal = calc_personal_temp(player);
  if(room_temp + personal > COMFORTABLE)
    temperature += (room_temp + personal - COMFORTABLE);

  // Set a lower limit on the coldness factor. This stops people dying of
  // hypothermia at 5C
  min = 100 * (personal + room_temp - COMFORTABLE);
  if(min > COMFORTABLE)
    min = personal + room_temp - COMFORTABLE;
  
  if(temperature < min)
    temperature = min;

  if(temperature >= COMFORTABLE)
    player->submit_ee(0, 0, EE_REMOVE );

  // They die if their temperature factor gets too low.
  if ( temperature < DEATH ) {
    player->dest_hide_shadow();
    tell_object( player, "The cold is just too much for you.\n" );
    tell_room( environment( player ), "Frost riming "+
              (string)player->query_possessive() +" skin in a thick crust, "+
              (string)player->the_short() +" expires.\n", player );
    player->do_death();
    return;
  }

  // Display some messages to them about how cold they are.
  switch(random(4)) {
  case 0 :
    player->new_parser("shiver");
    tell_object(player, "You feel cold to your bones.\n");
    break;
  case 1 :
    player->dest_hide_shadow();
    tell_object( player, "You rub your arms briskly in an attempt to "+
                "keep warm.\n" );
    tell_room( environment( player ),
              capitalize( (string)player->short() ) +" rubs "+
              (string)player->query_possessive() +" arms briskly.\n",
              player );
    break;
  case 2 :
    player->new_parser("shiver");
    enums = (int *)player->effects_matching("body.wetness"); 
    if ( sizeof( enums ) )
      pwet = (int)player->arg_of( enums[ 0 ] );
         
    if ( (int)pwet > 25 ) {
      tell_object( player, "You dislodge a lump of ice, which falls "+
                  "to the ground and shatters.\n" );
      tell_room( environment( player ),
                capitalize( (string)player->short() ) +" dislodges a lump "+
                "of ices, which falls to the ground and shatters.\n",
                player );
      player->add_effect("/std/effects/other/wetness", -25 );
    }
    break;
  default :
    player->new_parser("shiver");
    tell_object(player, "You feel really cold.\n" );
  }

  player->set_arg_of( (int)player->sid_to_enum( id ), temperature );
  return;
}

int calc_personal_temp(object player) {
  object where;
  string item, zone, type, *types, *zones;
  int count;

  zones = ({ });
  
  where = environment(player);
  count = 0;
  
  if(where->query_property("location") == "inside")
    count += 20;
  
  count += where->query_property("warmth");

  // Add up the number of zones covered by the clothing. The more zones the
  // warmer they'll be.
  foreach(item in player->query_wearing()) {
    types = item->query_type();
    if(!arrayp(types))
      types = ({ item->query_type() });
    
    foreach(type in types) {
      // Find out what zone this clothing type covers.
      // If it doesn't cover a zone (eg. jewellery) it doesn't give any
      // warmth.
      foreach(zone in CLOTHING_HANDLER->query_zone_names(type)) {
        if(member_array(zone, zones) == -1)
          zones += ({ zone });
        if(item->query_property("warmth"))
          count += item->query_property("warmth");
        else
          count ++;
      }
    }
  }

  count += sizeof(zones);
  count += environment(player)->query_property("warmth");

  return count;
}

void stat_adjusts(object player, int temperature, int id ) {
  if(WEATHER->temperature_index(environment(player)) > 0 ||
     temperature > -100)
    return;

  switch(player->query_race()) {
  case "troll":
    tell_object( player, "You feel a tingling between your ears and "+
                 "new and strangely clever thoughts race along the "+
                 "superconducting neural pathways of your brain.\n" );
    player->adjust_int( 1 );
    break;
  default:
    tell_object( player, "You feel your strength being drained by the "+
                 "freezing temperatures.\n" );
    player->adjust_tmp_str( -1 );
    player->adjust_tmp_con( -1 );
    break;
  }
}

string extra_look( object player ) {
  string desc;
  int temperature;
  int *enums;

  enums = (int *)player->effects_matching( "disease.hypothermia" );
  if ( !sizeof( enums ) )
    return "";

  temperature = (int)player->arg_of(enums[0]);

  switch(temperature/5) {
    case -5 .. 100 :
      desc = "looks a bit cold.\n";
      break;
    case -10 .. -6 :
      desc = "looks rather cold.\n";
      break;
    case -30 .. -11 :
      desc = "looks very cold.\n";
      break;
    case -80 .. -31 :
      desc = "appears to be suffering from extreme hypothermia.\n";
      break;
    case -100 .. -81 :
      desc = "looks close to death from hypothermia.\n";
      break;
    default :
      return "";
  }
  return capitalize( (string)player->query_pronoun() ) +" "+ desc;
}
// --- END [/mnt/home2/grok/lib/std/effects/disease/general_hypothermia.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/curses/alone.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/curses/alone.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629034   Available: 13576388
Inodes: Total: 5242880    Free: 4960135
1340 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/curses/alone.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629034   Available: 13576388
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: alone.c,v 1.1 1998/01/06 04:07:14 ceres Exp $
 * $Log: alone.c,v $
 * Revision 1.1  1998/01/06 04:07:14  ceres
 * Initial revision
 * 
*/
/**
 * Make the player feel they are alone on the disc.  The classification of this
 * effect is "misc.curse.alone".
 * <p>
 * The argument to the effect does nothing at all.  The effect
 * can only be removed by a call to remove effect.  It does not
 * time out.
 * <p>
 * This effect has a shadow associated with it.
 * @classification misc.curse.alone
 * @example
 * add_effect("/std/effects/curses/alone");
 */
#include <effect.h>
#include "path.h"

/** @ignore yes */
string query_classification() { return "misc.curse.alone"; }
/** @ignore yes */
string query_shadow_ob() { return SHADOWS+"alone"; }

/** @ignore yes */
int beginning( object player, int time ) { 
   player->add_extra_look( this_object() );
} /* beginning() */

/** @ignore yes */
void merge_effect( object player, int time1, int time2 ) {
} /* merge_effect() */

/** @ignore yes */
void end(object player) { 
   player->remove_extra_look( this_object() );
} /* end() */

/** @ignore yes */
string extra_look( object player ) {
   if ( player == this_player() )
     return "";
   return capitalize( (string)player->query_pronoun() )+
     " can't see you.\n";
} /* extra_look() */

// --- END [/mnt/home2/grok/lib/std/effects/curses/alone.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/curses/ken_curse.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/curses/ken_curse.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629033   Available: 13576387
Inodes: Total: 5242880    Free: 4960135
1284 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/curses/ken_curse.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629033   Available: 13576387
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: ken_curse.c,v 1.1 1998/01/06 04:07:14 ceres Exp $
 * $Log: ken_curse.c,v $
 * Revision 1.1  1998/01/06 04:07:14  ceres
 * Initial revision
 * 
*/
/**
 * Makes the player speak like an obnoxious english person.
 * The classification of the effect is "misc.curse.ken".
 * <p>
 * The argument to the effect specifies how long the effect will lasyt
 * for.
 * <p>
 * This effect has  ashadw associated with it
 * @classification misc.curse.ken
 * @example
 * // give them the curse for 3 minutes
 * add_effect("/std/effects/curses/ken_curse", 360);
 */
#include <effect.h>

/** @ignore yes */
int beginning( object player, int time ) {
    player->submit_ee( 0, time, EE_REMOVE );
    return time;
}

/** @ignore yes */
int merge_effect( object player, int time1, int time2 ) {
   int duration;

   duration = time2 + player->expected_tt();
   player->submit_ee( 0, duration, EE_REMOVE );
   return duration;
} /* merge_effect() */
 
/** @ignore yes */
void end( object player, int time ) {
    tell_object( player, "Your craving for fish & chips passes.\n");
} /* end() */

/** @ignore yes */
string query_classification() { return "misc.curse.ken"; }

/** @ignore yes */
string query_shadow_ob() { return "/std/shadows/curses/ken_curse"; }
// --- END [/mnt/home2/grok/lib/std/effects/curses/ken_curse.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/curses/smurf.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/curses/smurf.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629032   Available: 13576386
Inodes: Total: 5242880    Free: 4960135
1538 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/curses/smurf.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629032   Available: 13576386
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: smurf.c,v 1.1 1998/01/06 04:07:14 ceres Exp $
 * $Log: smurf.c,v $
 * Revision 1.1  1998/01/06 04:07:14  ceres
 * Initial revision
 * 
*/
/**
 * Turns the player into a smurf.  The classification of this effect is
 * is "misc.curse.smurf".
 * <p>
 * If a time is specifed then this is how long the effect lasts.
 * If no time is specifed then the effect is never removed.
 * <p>
 * This effect has a shadow associated with it.
 * @classification misc.curse.smurf
 * @example
 * // Give them the curse for 6 minutes
 * add_effect("/std/effects/curses/smurf", 360);
 * @example
 * // Give them the curse forever!
 * add_effect("/std/effects/curse/smurf");
 */
#include <effect.h>

/** @ignore yes */
string query_classification() { return "misc.curse.smurf"; }

/** @ignore yes */
string query_shadow_ob() { return "/std/shadows/curses/ensmurfed"; }

/** @ignore yes */
int beginning( object player, int time ) {
   tell_object( player, "You suddenly find yourself filled with a strange "
               "fear of someone called \"Gargamel\".\n");
   if (time)
     player->submit_ee( 0, time, EE_REMOVE );
   return time;
}

/** @ignore yes */
int merge_effect( object player, int time1, int time2 ) {
   int duration;

   duration = time2 + player->expected_tt();
   player->submit_ee( 0, duration, EE_REMOVE );
   return duration;
} /* merge_effect() */
 
/** @ignore yes */
void end( object player, int time ) {
   tell_object( player, "Your fear of Gargamel has abated.\n");
} /* end() */

// --- END [/mnt/home2/grok/lib/std/effects/curses/smurf.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/curses/antisqeal.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/curses/antisqeal.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629032   Available: 13576386
Inodes: Total: 5242880    Free: 4960135
1141 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/curses/antisqeal.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629032   Available: 13576386
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming

/**
 * This curse converts all a players Ks to Cs
 * The classification of the effect is "misc.curse.antisqeal".
 * <p>
 * The argument is an integer and specifies how long the
 * curse will last.
 * <p>
 * This effect has a shadow associated with it.
 * @classification misc.curse.antisqeal
 * @example
 * // give them the curse for 2 minutes
 * add_effect("/std/effects/curses/chef_curse", 120);
 */
#include <effect.h>
/** @ignore yes */
int beginning( object player, int time ) {
    player->submit_ee( 0, time, EE_REMOVE );
    return time;
}

/** @ignore yes */
int merge_effect( object player, int time1, int time2 ) {
   int duration;

   duration = time2 + player->expected_tt();
   player->submit_ee( 0, duration, EE_REMOVE );
   return duration;
} /* merge_effect() */
 
/** @ignore yes */
void end( object player, int time ) {
    tell_object( player, "Your ability to mangle the english language "
                         "returns.\n");
} /* end() */

/** @ignore yes */
string query_classification() { return "misc.curse.antisqeal"; }

/** @ignore yes */

string query_shadow_ob() { return "/std/shadows/curses/antisqeal"; }
// --- END [/mnt/home2/grok/lib/std/effects/curses/antisqeal.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/curses/deaf_effect.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/curses/deaf_effect.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629031   Available: 13576385
Inodes: Total: 5242880    Free: 4960135
1604 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/curses/deaf_effect.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629031   Available: 13576385
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: deaf_effect.c,v 1.1 1998/01/06 04:07:14 ceres Exp $
 * $Log: deaf_effect.c,v $
 * Revision 1.1  1998/01/06 04:07:14  ceres
 * Initial revision
 * 
*/
/**
 * Makes the player deaf.  The classification of the effect
 * is "misc.curse.deafness".
 * <p>
 * This effect has a shadow associated with it.
 * @classification misc.curse.deafness
 */
#include "effect.h"

/** @ignore yes */
string query_classification() { return "misc.curse.deafness"; }

/** @ignore yes */
int query_indefinite() { return 1; }

/** @ignore yes */
string query_shadow_ob() { return "/std/shadows/curses/deaf_shadow"; }

/** @ignore yes */
mixed beginning( object player, mixed arg ) {
   tell_object( player, "Sounds seem dim and muffled.\n" );
   if ( pointerp( arg ) ) {
      player->submit_ee( "hear_better", arg[ 1 ], EE_CONTINUOUS );
      return arg[ 0 ];
   } else {
      return arg;
   }
}

/** @ignore yes */
void end( object player ) {
   tell_object( player, "Your hearing has returned to normal.\n" );
}

/** @ignore yes */
void hear_better( object player, mixed arg, int id ) {
   player->add_message(this_object(), "Your hearing improves somewhat.\n", 0);
   arg = 100 - ((100 - arg) * 2/3);
   if (arg == 100) player->delete_effect( player->sid_to_enum( id ) );
   else 
      player->set_arg_of( player->sid_to_enum( id ), arg );
}

/** @ignore yes */
mixed merge_effect( object player, mixed old_arg, mixed new_arg, int id ) {
   player->add_message( this_object(), "Your hearing gets worse.\n", 0 );
   player->set_arg_of( player->sid_to_enum( id ), new_arg );
}

// --- END [/mnt/home2/grok/lib/std/effects/curses/deaf_effect.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/curses/ridcullian_curse.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/curses/ridcullian_curse.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629031   Available: 13576385
Inodes: Total: 5242880    Free: 4960135
2587 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/curses/ridcullian_curse.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629031   Available: 13576385
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: ridcullian_curse.c,v 1.1 1998/01/06 04:07:14 ceres Exp $
 * $Log: ridcullian_curse.c,v $
 * Revision 1.1  1998/01/06 04:07:14  ceres
 * Initial revision
 * 
*/
/**
 * Makes the players hair fall out.
 * The classification of this effect is "misc.curse.ridcullian".
 * <p>
 * The argument specifies how long the hair loss will last.
 * @classification misc.curse.ridcullian
 * @example
 * // Give them the curse for 5 minutes
 * add_effect("/std/effects/curse/ridcullian", 300);
 */
#include <effect.h>

/** @ignore yes */
string query_classification() { return "misc.curse.ridcullian"; }

/** @ignore yes */
int merge_effect( object player, int old_arg, int new_arg, int id ) {
   player->submit_ee( 0, player->expected_tt() + new_arg, EE_REMOVE );
   tell_object(player, "You feel more concerned about your hair loss.\n");
}

/** @ignore yes */
int test_remove( object player, int a, int id, int bonus) {
   if (bonus > 150) return 1;
   tell_object(player, "You feel less concerned about your hair loss.\n");
   player->submit_ee(0, player->expected_tt() - bonus, EE_REMOVE);
   return 0;
}

/** @ignore yes */
int beginning( object player, int a, int id) {
   player->submit_ee("hair_worry", ({ 10, 20 }), EE_CONTINUOUS);
   player->submit_ee(0, a, EE_REMOVE);
   
   tell_object( player, "You reach up to smooth your hair, and a large "+
               "chunk of hair comes out.\n");
   tell_room( environment( player ), player->the_short() + " smooths " +
             player->query_possessive() + " hair and then stares in "+
             "horror at " + player->query_possessive() + " hands.\n",
             ({ player }) );
}

/** @ignore yes */
void end( object player, mixed a, int id ) {
   tell_object( player, "Ahhhh.  Your hair seems to have stopped "
               "falling out so prematurely.\n");
}

/** @ignore yes */
void hair_worry( object player, mixed a, int id ) {
   switch (random(5)) {
    case 0:
      player->do_say("I'm not going bald!  I mean it's "+
                     "ridiculous!  My family have never gone "+
                     "bald, except for one of my aunts!");
      break;
    case 1:
      player->do_say("I mean it wasn't there yesterday!");
      break;
    case 2:
      player->do_say("I have NOT got a bald spot!");
      break;
    case 3:
      player->do_say("Something's definitely happening, "+
                     "I can feel it in my water.");
      
      break;
    case 4:
      /* need soul thingy here :( */
      player->do_say("What about this, then?");
      break;
   }
}

// --- END [/mnt/home2/grok/lib/std/effects/curses/ridcullian_curse.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/curses/chef_curse.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/curses/chef_curse.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629030   Available: 13576384
Inodes: Total: 5242880    Free: 4960135
1310 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/curses/chef_curse.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629030   Available: 13576384
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: chef_curse.c,v 1.1 1998/01/06 04:07:14 ceres Exp $
 * $Log: chef_curse.c,v $
 * Revision 1.1  1998/01/06 04:07:14  ceres
 * Initial revision
 * 
*/
/**
 * This curse makes the players talk as if they are the sweedish chef.
 * The classification of the effect is "misc.curse.chef".
 * <p>
 * The argument is an integer and specifies how long the
 * curse will last.
 * <p>
 * This effect has a shadow associated with it.
 * @classification misc.curse.chef
 * @example
 * // give them the curse for 2 minutes
 * add_effect("/std/effects/curses/chef_curse", 120);
 */
#include <effect.h>

/** @ignore yes */
int beginning( object player, int time ) {
    player->submit_ee( 0, time, EE_REMOVE );
    return time;
}

/** @ignore yes */
int merge_effect( object player, int time1, int time2 ) {
   int duration;

   duration = time2 + player->expected_tt();
   player->submit_ee( 0, duration, EE_REMOVE );
   return duration;
} /* merge_effect() */
 
/** @ignore yes */
void end( object player, int time ) {
    tell_object( player, "Your craving for swedish meatballs goes away.\n");
} /* end() */

/** @ignore yes */
string query_classification() { return "misc.curse.chef"; }

/** @ignore yes */
string query_shadow_ob() { return "/std/shadows/curses/chef_curse"; }
// --- END [/mnt/home2/grok/lib/std/effects/curses/chef_curse.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/curses/no_player_title.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/curses/no_player_title.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629029   Available: 13576383
Inodes: Total: 5242880    Free: 4960135
640 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/curses/no_player_title.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629029   Available: 13576383
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This curse stops a player from having a player 
 * title.
 * @author Taffyd
 */

#include <effect.h>
#include "path.h"

void beginning( object ob, int time, int id ) {
    if ( time > 0 ) {
        ob->submitt_ee( 0, time, EE_REMOVE );
    }
} /* beginning() */ 

void end( object ob, int time, int id ) {
    // nothing.
} /* end() */

string query_classification() {
    return "player.no-title-allowed";
} /* query_classification() */

string query_shadow_ob() {
    return SHADOWS + "no_player_title";
} /* query_shadow_ob() */

void spam( object player, mixed args, int id ) {
tell_creator ("taffyd", "Spam\n" );
} /* spam() */
// --- END [/mnt/home2/grok/lib/std/effects/curses/no_player_title.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/room/vomit.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/room/vomit.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629029   Available: 13576383
Inodes: Total: 5242880    Free: 4960135
2024 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/room/vomit.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629029   Available: 13576383
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* 
 * This is an effect to add vomit to rooms.
 * arguments are given in the form ({ duration , pools })
 * duration = length of time
 * pools = number of pools of vomit to be added.
 *         ( should be 1 or more )
 */

#include <effect.h>
void pool_descripts( object room , int pools );
/** @ignore */
string query_classification () { return "room.vomit"; }

/** @ignore */
void beginning ( object room, int *args )
{
    int duration, pools ;

    duration = args [ 0 ] ;
    pools    = args [ 1 ] ;

    pool_descripts ( room , pools ) ;
    room -> submit_ee ( 0 , duration , EE_REMOVE ) ;

} /* beginning */

void pool_descripts ( object room , int pools ) 
{
    room -> remove_item( "pool" );
    room -> add_item( ({ "pool" , "vomit" , "puddle"  }) , "There " +
        ( ( pools == 1 ) ? "is a pool" : "are " + query_num( pools , 10 ) +
        " pools" ) + " of vomit decorating the place.  Inevitably there "
        "are little bits of carrot in it, and it would also be a good "
        "idea to watch one's step." ) ;
    room->add_extra_look( this_object() );
} /* pool_descripts */

/** @ignore */
int *merge_effect( object room , int *new_args , int *old_args )
{
    int duration , pools ;
    duration = new_args [ 0 ] + room -> expected_tt()  ;
    pools =    new_args [ 1 ] + old_args [ 1 ] ;

    pool_descripts( room , pools ) ;
    return ({ duration , pools }) ;

} /* merge_effect*/

/** @ignore */
void end( object room, mixed names )
{
    room -> remove_item ( "pool" );
    room -> remove_extra_look( this_object() );
} /* end() */

string extra_look( object room )
{
    int     *enums;
    int     pools; 
    string  look, number;

    enums = room -> effects_matching( query_classification() );
    if( !sizeof( enums ) ) return "";
    pools = ( room -> arg_of( enums[0] ) ) [ 1 ] ;
    number = query_num( pools , 10 );
    look = "There " + ( ( pools == 1 ) ? ( "is a pool " ) : ( "are " + 
        number + " pools ") ) + "of vomit here.\n" ;
    return look;

} /* extra_look() */
// --- END [/mnt/home2/grok/lib/std/effects/room/vomit.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/room/albatross_attack.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/room/albatross_attack.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629028   Available: 13576382
Inodes: Total: 5242880    Free: 4960135
4171 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/room/albatross_attack.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629028   Available: 13576382
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <effect.h>

#define BLIND "/std/effects/religious/blind"
#define CLASS "auriental.punishment.albatross"
#define COMBAT "/std/effects/fighting/combat"

string query_classification(){ return CLASS; }
int query_indefinite(){ return 1; }

void damage_player( object pl, int damage ){
  if( damage > 0 ) 
    damage = damage * -1;
  if( pl->adjust_hp( damage ) <= 0 )
    pl->attack_by( this_object() );
  COMBAT->monitor_points( pl, 1 );
} /* damage_player() */

void pecking( object pl ){
  int damage = roll_MdN( 3, 150 );
  object room = environment( pl );

  if( room->query_property( "location" ) != "outside" ){
    if( pl->expected_tt() )
      pl->submit_ee( 0, ( pl->expected_tt() + 15 + random( 20 ) ), EE_REMOVE );
    tell_object( pl,
      "The albatrosses pace around the area, glaring at you.\n" );
    tell_room( room,
      "Albatrosses pace underfoot, looking quite upset.\n",
      pl );
    return;
  }

  switch( roll_MdN( 2, 3 ) ){
    case 2:
      tell_object( pl,
        "The albatrosses peck at your eyes, blinding you.\n" );
      tell_room( room,
        "A flock of albatrosses peck at " + pl->the_short() + "'s eyes.\n",
        ({ pl }) );
      damage_player( pl, damage * 3 / 2 );
      pl->add_effect( BLIND, damage / 2 );
      break;
    case 3:
      tell_object( pl,
        "A lone albatross dive-bombs you, skewering you with its beak.\n" );
      tell_room( room,
        "A single albatross dives at " + pl->the_short() + ", impaling " +
        pl->query_objective() + " with its beak.\n",
        ({ pl }) );
      damage_player( pl, damage );
      break;
    case 4:
      tell_room( room,
        "The albatrosses circle, watching you with cold, beady eyes.\n" );
      break;
    case 5:
      tell_object( pl,
        "One of the albatrosses swoops low above you, dropping an oyster "
        "shell directly on your head.\n" );
      tell_room( room,
        "A large oyster shell drops from the sky, splitting open on " +
        pl->the_short() + "'s head.\n",
        ({ pl }) );
      damage_player( pl, damage / 2 );
      break;
    default:
      tell_object( pl,
        "Several albatrosses land on your shoulders, spearing their beaks "
        "into you.\n" );
      tell_room( room,
        "Several albatrosses drop onto " + pl->the_short() + "'s shoulders, "
        "skewering " + pl->query_objective() + " with their beaks before "
        "taking off again.\n",
        ({ pl }) );
      damage_player( pl, damage * 2 );
      break;
  }
} /* pecking() */

int beginning( object pl, int args ){
  tell_object( pl,
    "A flock of albatrosses forms above you.  They don't look pleased to see "
    "you at all.\n" );
  tell_room( environment( pl ),
    "A flock of albatrosses circles above " + pl->the_short() + "\n",
    ({ pl }) );
  pl->submit_ee( "pecking", ({ 15, 45 }), EE_CONTINUOUS, pl );
  pl->submit_ee( 0, args, EE_REMOVE );
  pl->add_extra_look( this_object() );
  return args;
} /* beginning() */

int merge_effect( object pl, int old_args, int new_args ){
  pl->submit_ee( 0, new_args, EE_REMOVE );
  return new_args;
} /* merge_effect() */

int restart( object pl, int args ){
  tell_object( pl,
    "The flock of albatrosses returns, apparently not finished with their "
    "attack.\n" );
  tell_room( environment( pl ),
    "A flock of albatrosses forms above " + pl->the_short() + "\n",
    ({ pl }) );
  pl->add_extra_look( this_object() );
  return args;
} /* restart() */

void end( object pl, int args ){
  tell_room( environment( pl ),
    "The albatrosses lose interest and slowly fly away, trying to remember "
    "how to be properly pointless.\n" );
  pl->remove_extra_look( this_object() );
} /* end() */

string extra_look( object pl ){
  if( environment( pl )->query_property( "location" ) != "outside" ){
    return capitalize( pl->query_pronoun() ) +
      " is surrounded by angry albatrosses.\n";
  }
  return capitalize( pl->query_pronoun() ) + 
    " has an angry flock of albatrosses around " + 
    pl->query_objective() + ".\n";
} /* extra_look() */

string query_death_reason(){ 
  return "being pecked to death by albatrosses";
} /* query_death_reason() */// --- END [/mnt/home2/grok/lib/std/effects/room/albatross_attack.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/room/burial.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/room/burial.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629027   Available: 13576381
Inodes: Total: 5242880    Free: 4960135
5025 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/room/burial.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629027   Available: 13576381
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * @main
 * An effect to keep track of things which are burried in a room.
 *
 * @classification room.burial
 * @see help::effects
 * @author Pinkfish
 */

#include <effect.h>
#include <cmds/bury.h>

class arg_stuff {
   object cont;
   object* obs;
   int* added;
}

private mapping _stuff;
private int _call_id;

int timeout_ob(object room, int enum, object ob);
void check_buried();

void create() {
   _stuff = ([ ]);
} /* create() */

/** @ignore */
string query_classification() { return "room.burial"; }

/** @ignore */
mixed beginning( object room, object ob ) {
   if (!_stuff[room]) {
      _stuff[room] = new(class arg_stuff);
      _stuff[room]->cont = clone_object("/std/container");
      _stuff[room]->cont->add_property("burial object", 1);
      _stuff[room]->obs = ({ });
      _stuff[room]->added = ({ });
   }
   ob->move(_stuff[room]->cont);
   event (ob, "bury", ob, room);   
   _stuff[room]->obs += ({ ob });
   _stuff[room]->added += ({ time() });
   if (!_call_id) {
      _call_id = call_out("check_buried", BURY_TIMEOUT);
   }

   return room;
} /* beginning() */

/** @ignore */
mixed merge_effect( object room, class arg_stuff womble, object ob ) {
   if (!_stuff[room]) {
      _stuff[room] = new(class arg_stuff);
      _stuff[room]->cont = clone_object("/std/container");
      _stuff[room]->obs = ({ });
      _stuff[room]->added = ({ });
      _stuff[room]->cont->add_property("burial object", 1);
   }

   ob->move(_stuff[room]->cont);
   event (ob, "bury", ob, room);   
   _stuff[room]->obs += ({ ob });
   _stuff[room]->added += ({ time() });

   if (!_call_id) {
      _call_id = call_out("check_buried", BURY_TIMEOUT);
   }

   return room;
} /* merge_effect() */

/** @ignore */
void end( object room, class arg_stuff womble ) {
   //
   // Zap out container and clear out any inventory.
   //
    if ( womble && classp( womble ) ) {
      all_inventory(womble->cont)->move("/room/rubbish");
      womble->cont->dest_me();
    }
} /* end() */

/** @ignore */
int query_indefinite() { return 1; }  /* don't end effect */

/** @ignore */
void check_buried() {
   object room;
   int i;
   class arg_stuff bing;

   _call_id = call_out("check_buried", BURY_TIMEOUT);
   foreach (room, bing in _stuff) {
     if(!classp(bing))
       continue;
     
     if (!room) {
       bing->obs = filter(bing->obs, (: $1 && environment($1) == $2 :),
                          bing->cont);
       bing->obs->dest_me();
       if(bing->cont)
         bing->cont->dest_me();
       map_delete(_stuff, room);
     } else {
       for (i = 0; i < sizeof(bing->obs); i++) {
         if (!bing->obs[i] ||
             environment(bing->obs[i]) != bing->cont)  {
           bing->obs = bing->obs[0..i-1] + bing->obs[i+1..];
           bing->added = bing->added[0..i-1] + bing->added[i+1..];
         } else if (bing->added[i] + BURY_TIMEOUT < time()) {
           bing->obs[i]->dest_me();
           bing->obs = bing->obs[0..i-1] + bing->obs[i+1..];
           bing->added = bing->added[0..i-1] + bing->added[i+1..];
         }
       }
       if (!sizeof(bing->obs)) {
         if (bing->cont) {
           bing->cont->dest_me();
         }
         map_delete(_stuff, room);
       }
     }
   }
   if (!sizeof(_stuff)) {
     remove_call_out(_call_id);
     _call_id = 0;
   }
} /* check_buried() */

/**
 * This method returns all the stuff buried here.
 * @param room the room to get the burial objects from
 * @return the array of buried objects
 */
object* query_buried_objects(object room) {
   if (_stuff[room]) {
      return _stuff[room]->obs;
   }
   return ({ });
} /* query_buried_objects() */

/**
 * This method returns the container that has all the buried items
 * in it.
 * @param room the room to get the burial object from
 * @return the container with the buried items
 */
object query_buried_container(object room) {
   if (_stuff[room]) {
      return _stuff[room]->cont;
   }
   return 0;
} /* query_buried_container() */

/**
 * This method removes the specified object from the queue to be buried.
 * @param room the room to remove the object from the queue of
 * @param ob the object to remove from the queue
 * @return 1 if it is removed, 0 if not
 */
int remove_from_burial(object room, object ob) {
   int i;

   if (_stuff[room]) {
      i = member_array(ob, _stuff[room]->obs);
      if (i != -1) {
         _stuff[room]->obs = _stuff[room]->obs[0..i-1] +
                             _stuff[room]->obs[i+1..];
         _stuff[room]->added = _stuff[room]->added[0..i-1] +
                               _stuff[room]->added[i+1..];
         return 1;
      }
   }
   return 0;
} /* remove_froM_burial() */

/** @ignore yes */
mapping query_dynamic_auto_load() {
   return ([ "stuff" : _stuff ]);
} /* query_dynamic_auto_load() */

/** @ignore yes */
void init_dynamic_arg(mapping map) {
   if (map && map["stuff"]) {
      _stuff = map["stuff"];
      if (!_call_id) {
         _call_id = call_out("check_buried", BURY_TIMEOUT);
      }
   }
} /* init_dynamic_arg() */
// --- END [/mnt/home2/grok/lib/std/effects/room/burial.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/room/yellow-green_gas.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/room/yellow-green_gas.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629026   Available: 13576380
Inodes: Total: 5242880    Free: 4960135
2182 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/room/yellow-green_gas.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629026   Available: 13576380
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*
 * Gototh, 17/11/98
 */
/**
 * This effect fills a room with poisonous gas for a specified
 * length of time.  Armour class of type "gas" on the head zone
 * will offer protection to the player from the damage it causes.
 * <p>
 * The only argument is the time it will remain in the room for.
 * <p>
 * @classification gas.poisonous.yellow-green
 * @see help::effects
 */
#include <effect.h>

#define DAMAGE 1 + random(300)
#define CHOKE_TIME 20

/**
 * @ignore yes
 */
string query_classification()
{
  return "gas.poisonous";
} /* query_classification() */

/**
 * @ignore yes
 */
void beginning(object room, int time, int)
{
  tell_room(room, 
    "A billowing yellow-green gas fills the area!\n");
  room->submit_ee("choke", CHOKE_TIME, EE_CONTINUOUS);
  room->submit_ee("clear", time, EE_REMOVE);
  room->add_extra_look(this_object());
  room->add_item("billowing yellow-green gas", 
    "A thick, yellow-green gas swirls around the area.");
} /* beginning() */

/**
 * @ignore yes
 */
int merge_effect(object, int new_time, int old_time, int)
{
  int time_left;
  time_left = new_time + old_time;
  return time_left;
} /* merge_effect() */

/**
 * @ignore yes
 */
void clear(object room, int, int)
{
  tell_room(room, "The yellow-green gas clears.\n");
  room->remove_item("gas");
} /* clear() */

/**
 * @ignore yes
 */
void choke(object room, int, int)
{
  int damage;
  object ob, *obs;
  obs = filter(all_inventory(room), (: living($1) :));
  foreach(ob in obs)
  {  
    damage = DAMAGE;
    damage -= ob->query_ac("gas", damage, "head");
    if(damage > 0)
    {
      tell_object(ob,
        "You choke as you inhale the noxious gas!\n");
      tell_room(room,
        "$C$"+ob->one_short()+" chokes as "+ob->query_pronoun()+
        " inhales the noxious gas!\n", ob);
      ob->adjust_hp(-damage);
      if(ob->query_monitor())
      {
        ob->monitor_points();
      }
    }
  }
} /* choke() */

/**
 * @ignore yes
 */
void end(object room, int time, int id)
{
  room->remove_extra_look(this_object());
} /* end() */

/**
 * @ignore yes
 */
string extra_look(object thing)
{
  return "A billowing yellow-green gas swirls around here.\n";
} /* extra_look() */
// --- END [/mnt/home2/grok/lib/std/effects/room/yellow-green_gas.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/room/terrain_dont_unload.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/room/terrain_dont_unload.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629025   Available: 13576379
Inodes: Total: 5242880    Free: 4960135
677 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/room/terrain_dont_unload.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629025   Available: 13576379
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <effect.h>

/**
* This is the effect skelton docs.  This effect
* has a classification of "terrain.dont.unload".
* p
* Describe the arguments in here.
* p
* This effect has a shadow associated with it.
* @classification terrain.dont.unload
* @see help::effects
*/

/** @ignore
*/
string query_classification() {return "terrain.dont.unload"; }
/** @ignore */
string query_shadow_ob() {return "/std/shadows/room/terrain_dont_unload"; }

/** @ignore */
mixed beginning( object player, mixed *arg) {
    player->setup_shad();
    return arg;
}

/** @ignore */
mixed merge_effect( object player, mixed *old, mixed *newish ) {
    player->setup_shad();
    return newish;
}
// --- END [/mnt/home2/grok/lib/std/effects/room/terrain_dont_unload.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/room/magic_octogram.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/room/magic_octogram.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629025   Available: 13576379
Inodes: Total: 5242880    Free: 4960135
1726 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/room/magic_octogram.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629025   Available: 13576379
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: magic_octogram.c,v 1.1 1998/01/06 04:15:00 ceres Exp $
 * $Log: magic_octogram.c,v $
 * Revision 1.1  1998/01/06 04:15:00  ceres
 * Initial revision
 * 
*/
/**
 * This is the effect skelton docs.  This effect
 * has a classification of "magic.octogram".
 * <p>
 * Describe the arguments in here.
 * @classification magic.octogram
 * @see help::effects
 */
#include <effect.h>

/** @ignore yes */
string query_classification() { return "magic.octogram"; }

/** @ignore yes */
void beginning( object thing, int number, int id ) {
   tell_room( thing, "An octogram begins to glow "+
         (string)thing->query_property( "here" ) +".\n" );
   thing->submit_ee( 0, number, EE_REMOVE );
   thing->add_extra_look( this_object() );
/*
 * Something nasty until a better solution appears.
*/
   thing->add_item( "octogram", "The octogram glows in eldritch fashion, "
         "and that has nothing to do with being oblong." );
} /* beginning() */

/** @ignore yes */
int merge_effect( object thing, int old_arg, int new_arg, int id ) {
   tell_room( thing, "The octogram pulses for a moment.\n" );
   thing->submit_ee( 0, new_arg + (int)thing->expected_tt(), EE_REMOVE );
   return old_arg + new_arg;
} /* merge_effect() */

/** @ignore yes */
void end( object thing, int number, int id ) {
   if ( !sizeof( filter_array( previous_object( -1 ),
         (: $1->query_magic_spell() :) ) ) )
      tell_room( thing, "The octogram flickers and disappears.\n" );
   thing->remove_extra_look( this_object() );
} /* end() */

string extra_look( object thing ) {
   return "An octogram "+ (string)thing->query_property( "here" ) +
         " glows in eldritch fashion.\n";
} /* extra_look() */
// --- END [/mnt/home2/grok/lib/std/effects/room/magic_octogram.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/room/bubble_bath.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/room/bubble_bath.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629024   Available: 13576378
Inodes: Total: 5242880    Free: 4960135
4696 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/room/bubble_bath.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629024   Available: 13576378
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  Object:         Bubblebath!
    Author:         Wobin
    Description:    Makes funtime bath! ... err... or something...
                    Uses the argument 
                    ({ <expiry time>, ({ <colour>, <fragrance> }) })
*/
                    
#include <effect.h>
#define PATH __DIR__

string query_classification() { return "room.bubblebath"; }

int query_surface_water(object room) {
    return room->query_surface() ||
     sizeof(filter(all_inventory(room), (: $1->query_baths() :)));
}

void beginning( object room, mixed *args) {
    object uproom;

   tell_room( room, "As the liquid enters the water it diffuses into " 
         "a "+ args[1][0] +" coloured cloud.\n" );
   if(query_surface_water(room))
       tell_room( room, "A gentle fragrance of " + args[1][1] + 
          " fills the room.\n");
   else if(uproom = find_object(room->query_destination(room->query_up_dir())))
       uproom->add_effect(PATH + "bubble_bath", args);

   room->submit_ee( "bubblebubble", ({10,30}), EE_CONTINUOUS );
   room->submit_ee( 0, args[0], EE_REMOVE );

   room->add_extra_look( this_object() );
   room->add_item(args[1][0] + " bubbles", "These " + args[1][0] + " coloured "
           "bubbles fill the room.");
} /* beginning() */

/** @ignore yes */
mixed *merge_effect( object room, mixed *old_arg, mixed *new_arg, int id ) {

  int index,count,copy=0;
  string type;
  object uproom;

   tell_room( room, "The bubbles surge as more bubble bath is added.\n" );
   room->submit_ee( 0, new_arg[0] + (int)room->expected_tt(), EE_REMOVE );

   count = sizeof(old_arg);
   for( index = 1; index < count; index++) {
     if( new_arg[1][0] == old_arg[index][0] ) {
       copy = 1;
       break;
     }
   }

   if(!copy) {
     old_arg += ({ new_arg[1] });
     room->add_extra_look(this_object());
     type = (room->query_surface()?"air":"water");
     room->add_item( new_arg[1][0] + " bubbles", "These " + new_arg[1][0] + 
        " coloured bubbles fill the " + type + ".");
     tell_room( room, "As the liquid enters the water it diffuses into " 
         "a "+ new_arg[1][0] +" coloured cloud.\n" );
     if(query_surface_water(room))
     tell_room( room, "A gentle fragrance of " + new_arg[1][1] + 
          " fills the air.\n");
     else if(uproom = find_object(room->query_destination(room->query_up_dir()))) {
         uproom->add_item( new_arg[1][0] + " bubbles", "These " + new_arg[1][0] + 
        " coloured bubbles fill the " + type + ".");
         uproom->add_effect(PATH + "bubble_bath", new_arg);
     }
     return old_arg;
   }

   return 0;
} /* merge_effect() */

/** @ignore yes */
void end( object room, mixed *args, int id) {
    int index, count;
    string type =(room->query_surface()?"fragrant":"colourful");
    tell_room( room, "The last of the bubbles disappear with a " + type +
             " *pop*.\n" );
    room->remove_extra_look( this_object() );
    
    count = sizeof(args);
    for (index = 1; index < count; index++ )
       room->remove_item( args[index][0] + " bubbles" );
       
} /* end() */

string extra_look( object room ) {
    
  int *enums;  /* effects list */
  int count, size;
  mixed  shades=({}); /* list of colours */
  string bubblez;  /* description to return */
  string type;

  enums = room->effects_matching( query_classification() );
  type = (room->query_surface()?"smelling":"looking"); 
  if ( !sizeof ( enums )) return "";

  /* Since there should be only one effect... */  
  shades = room->arg_of( enums[0] );

  if ( !sizeof ( shades )) return "";
    
  if ( sizeof ( shades ) == 1 )
      bubblez = "A multitude of " + shades[1][0] +" coloured bubbles fill the "
      "room, " + type +  " delicately of " + shades[1][1] + ".\n";

  if ( sizeof ( shades ) > 1 ) {
    size = sizeof ( shades );
    bubblez = "The room is filled with " + shades[1][0];
    for ( count = 2; count < size; count++ ) {

        if ( count != size-1 ) {
            bubblez += ", ";
        }
        else {
            bubblez += " and ";
        }           
            bubblez += shades[count][0];
    }
    bubblez += " coloured bubbles, floating everywhere.\n";
  }
      return bubblez;

} /* extra_look() */

void bubblebubble( object room, mixed *args) {
    int index = 0;
    string type = (query_surface_water(room)?"fragrance":"colours"); 
    string where= (query_surface_water(room)?"air":"water"); 
    /* Get a random index that isn't 0 */
    while (!index) index = random(sizeof(args));
    tell_room( room, "The gentle " + type + " of " + args[index][1] + " floats "
               "through the " + where + " as some of the " + args[index][0] + " bubbles "
               "pop.\n");
}               

// --- END [/mnt/home2/grok/lib/std/effects/room/bubble_bath.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/room/crater.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/room/crater.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629023   Available: 13576377
Inodes: Total: 5242880    Free: 4960135
2629 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/room/crater.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629023   Available: 13576377
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* 
* @main
* A nice little effect so that witches who plummet out of the sky
* when their brooms break in midflight will leave a crater in the
* ground where they fall.  
*
* add_effect is called in the crash site; the name of the victim
* is passed to the effect.  The arg of the effect is an array of
* strings, each of which is the name of someone who's landed in
* that particular crash site.
*
* @classification room.crater.broom
* @see help::effects
*/

#include <effect.h>

/** @ignore */
string query_classification() { return "room.crater.broom"; }

/** @ignore */
string *beginning( object room, string name ) {
  
  room->add_item( ({ name + " shaped crater", "crater" }),
      "There is a large crater in the ground, as if " + 
      capitalize( name ) + " happened here recently, from a "
      "very great height indeed." );

  room->add_extra_look( this_object() );

  return ({ name });

} /* beginning() */

/** @ignore */
string *merge_effect( object room, mixed old_names, string name ) {

  // Don't add a new crater if this witch has already left one here.
  if( member_array( name, old_names ) != -1 ) {
    return old_names;
  }

  room->add_item( ({ name + " shaped crater", "crater" }),
      "There is a large crater in the ground, as if " + 
      capitalize( name ) + " happened here recently, "
      "from a very great height indeed." );

  return old_names += ({ name });

} /* merge_effect() */


/** @ignore */
void end( object room, mixed names ) {
  string name;
   
  /* remove the items that were added for each crash */
  foreach( name in names )  {
    room->remove_item( name + " shaped crater" );
  }

  room->remove_extra_look( this_object() );

} /* end() */

/** @ignore */
int query_indefinite() { return 1; }  /* don't end effect */

string extra_look( object room ) {
   int     *enums;          /* Effect numbers */
   string  *shapes;         /* Who made the crater */

   /* Find out the effect number we have */
   enums = room->effects_matching( query_classification() );

   /* Make sure we have something to show them... */
   if( !sizeof( enums ) )
     return "";

   /* Check the args.  We should only have one effect, since we
    * take care of merging */
   shapes = room->arg_of( enums[0] );
   if( !sizeof( shapes ) )
     return "";

   if( sizeof( shapes ) == 1 )
     return "There is " + add_a( capitalize( shapes[0] ) ) +
         " shaped crater in the ground.\n";
              
   else {
     return "There are " + query_multiple_short( map( shapes, (: capitalize(
                $1 ) :) ) ) + " shaped craters in the ground.\n";
   }
} /* extra_look() */
// --- END [/mnt/home2/grok/lib/std/effects/room/crater.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/room/hat_tent.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/room/hat_tent.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629022   Available: 13576376
Inodes: Total: 5242880    Free: 4960135
528 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/room/hat_tent.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629022   Available: 13576376
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This effect keeps track of the hat tent shadow which
 * keeps rooms outside hat tents from unloading.
 */

#include <effect.h>

/** @ignore */
void beginning() {
   // Do nothing?
} // beginning()

// No merge effect!  We want multiple effects/shadows.

/** @ignore */
void end() {
   // Do nothing...
} // end()

/** @ignore */
string query_shadow_ob() {
   return "/std/shadows/room/hat_tent";
} // query_shadow_ob()

/** @ignore */
string query_classification() {
   return "room.hattent";
} // query_classification()
// --- END [/mnt/home2/grok/lib/std/effects/room/hat_tent.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/room/swinging.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/room/swinging.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629021   Available: 13576375
Inodes: Total: 5242880    Free: 4960135
4036 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/room/swinging.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629021   Available: 13576375
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* 28 NOV 00 - Awful's swinging effect.  A very simple little
 * effect, useful for playground swings.
 * Allow for a simple "stop" swinging as well as being able to
 * "jump" from the swing in the traditional playground daredevil
 * method.
 */

/*                        72 column spacing                           */

#include <effect.h>

#define SWINGS "/d/sur/Sto_Lat/hill_street/playground/playground04"

string query_classification() { return "other.swinging"; }


void beginning(object player, int arg) {
  int st, tt;
  player->submit_ee("swinging", ({15, 30}), EE_CONTINUOUS);
  player->submit_ee( 0, arg, EE_REMOVE );
  tt = (int)player->expected_tt();
  st = (tt - 15);
  player->submit_ee("slowing", (st), EE_ONCE);

  if (tt < 61) {
    player->add_succeeded_mess(previous_object(), ({
      "You push off with your feet and start to swing back and "
        "forth.\n",
      "$N push$s off with $p feet and start$s to swing back and "
        "forth.\n"}));
    player->set_position("swinging back and forth");
    player->set_position_type("on");
  }
} /* void beginning(object player, mixed arg) */


void merge_effect(object player, int old_arg, int new_arg) {
  int tt, st;
  tt = (int)player->expected_tt();
  tell_room(environment(player), capitalize(player->a_short() ) +
    " leans back and pulls on the swing to gain momentum.\n", player);
  tell_object(player, "You lean back and pull on the swing "
    "to gain momentum.\n");
  player->submit_ee(0, new_arg + tt, EE_REMOVE);
  st = (tt -15);
  player->submit_ee("slowing", (st), EE_ONCE);
}


void end(object player) {
  if(file_name(environment(player)) != SWINGS)
      return;
  tell_object(player, "You stop swinging.\n");
  tell_room(environment(player), capitalize(player->a_short()) +
    " stops swinging.\n", player);
  player->set_position("sitting");
  player->set_position_type("in");
} /* void end(object player) */


void swinging(object player) {
   if(file_name(environment(player)) != SWINGS){
      player->submit_ee(0, 0, EE_REMOVE);
      return;
   }
   
  switch (random(3)) {
  case 1 :
    if (player->query_gender() == 2) {
      tell_room(environment(player), capitalize(player->a_short() ) +
        " seems very happy as she reaches the bottom of her "
        "arc on the swing.\n", player);
      tell_object(player, "You feel a pleasant tickling sensation "
        "in your stomach as you reach the bottom of your arc on "
        "the swing.\n");
    }
    else {
      tell_room(environment(player), capitalize(player->a_short() ) +
        " swings back and forth happily, just like a child again.\n",
        player);
      tell_object(player, "You swing back and forth happily, just "
        "like a child again.\n");
    }
  break;
  case 2 :
    tell_room(environment(player), capitalize(player->a_short() ) +
      " looks at if "+player->query_pronoun()+" could just "
      "fly right off into the sky as "+player->query_pronoun()+
      " reaches the top of "+player->query_possessive()+" arc on "
      "the swing.\n", player);
    tell_object(player, "You feel as if you could just fly right "
      "off into the sky as you reach the top of your arc on the "
      "swing.\n");
  break;
  case 3 :
    tell_room(environment(player), capitalize(player->a_short() ) +
      " arcs through the air like a pendlum.\n", player);
    tell_object(player, "You arc through the air like a "
      "pendlum.\n");
  break;
  default :
    tell_room(environment(player), capitalize(player->a_short() ) +
      " swings back and forth.\n", player);
    tell_object(player, "You swing back and forth.\n");
  }
} /* void swinging(object player) */


void slowing(object player) {
  if ( (int)player->expected_tt() < 20 ) {
    tell_object(player, "Your swinging is slowing down as you "
      "gradually lose momentum.\n");
    tell_room(environment(player), capitalize(player->a_short()) +
      " slows down a bit as "+player->query_pronoun()+" loses "
      "momentum.\n", player);
  }
}  /* void slowing(object player) */// --- END [/mnt/home2/grok/lib/std/effects/room/swinging.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/npc/drink_silly.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/npc/drink_silly.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629020   Available: 13576374
Inodes: Total: 5242880    Free: 4960135
3663 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/npc/drink_silly.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629020   Available: 13576374
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker: pinkfish $
 * $Id: drink_silly.c,v 1.1 1998/01/06 04:16:50 ceres Exp pinkfish $
 * $Log: drink_silly.c,v $
 * Revision 1.1  1998/01/06 04:16:50  ceres
 * Initial revision
 * 
*/
/**
 * This is the effect skelton docs.  This effect
 * has a classification of "npc.drink".
 * <p>
 * Describe the arguments in here.
 * @classification npc.drink
 * @see help::effects
 */
/**
 * This is the drink yourself silly effect...
 * <p>
 * Keeps drinking until we run out of money.  Then gets depressed...
 * <p>
 * The argument will be the call back function to be used when the
 * effect ends.  ie: ran out of money :)  If the arguemet is a 
 * function pointer, it will be evaluated.  If it is a str thing that
 * function will be called on the player, if it is an array of two elements..
 * the first contains the object and the second the function.
 */
#include <effect.h>
#include <pub.h>
#include <shops/pub_shop.h>

#include "path.h"

/** @ignore yes */
mixed normalise(mixed arg, object player) {
   if (stringp(arg)) {
      arg = ({ arg, player });
   } else if (functionp(arg)) {
      arg = ({ arg, player });
   } else if (!pointerp(arg)) {
      arg = ({ });
   }
   return arg;
} /* normalise() */

/*
 * This effect will make the cute little critters eat things.
 */
/** @ignore yes */
void beginning( object player, mixed arg, int id ) {
   player->submit_ee("buy_something", 5, EE_CONTINUOUS);
   player->do_command("stand at bar");
   return normalise(arg, player);
} /* beginning() */

/** @ignore yes */
int merge_effect( object player, int time1, int time2, int id ) {
   return normalise(time1, player) + normalise(time2, player);
} /* merge_effect() */

/** @ignore yes */
void end(object player, mixed arg, int id) {
   int i;

   for (i = 0; i < sizeof(arg); i += 2) {
      if (functionp(arg[i])) {
         evaluate(arg[i]);
      } else {
         call_other(arg[i], arg[i+1]);
      }
   }
} /* end() */
 
/** @ignore yes */
string query_classification() { return "npc.drink"; }

/** @ignore yes */
void buy_something(object player, mixed arg, int id) {
   mapping items;
   mixed *stuff;
   string *rabbit;
   int i;
   int value;
   mixed ret;
   string place;
   string name;
   class menu_item menu;

   /* Ok.  Now we try and buy something... */
   items = environment(player)->query_menu_items();
   rabbit = ({ });
   if (mapp(items)) {
      stuff = keys(items);

      place = environment(player)->query_property( "place" );
      if ( !place || ( place == "" ) ) {
         place = "default";
      }
      value = (int)player->query_value_in( place );
      if ( place != "default" ) {
         value += (int)player->query_value_in( "default" );
      }

      /* Now, we only want stuff with an alcohol rating :) */
      if (environment(player)->query_pub()) {
         foreach (name, menu in items) {
            if (menu->intox > 0 &&
                menu->cost < value) {
               rabbit += ({ name });
            }
         }
      } else {
         foreach (name, stuff in items) {
            if (stuff[DR_INTOX] > 0 &&
                stuff[DR_COST] < value) {
               rabbit += ({ name });
            }
         }
      }
   }

   if (!sizeof(rabbit)) {
      player->delete_effect(player->sid_to_enum(id));
   } else {
      do {
         i = random(sizeof(rabbit));
         ret = player->do_command("buy "+rabbit[i]);
         rabbit = rabbit[0..i-1] + rabbit[i+1..];
      } while (ret <= 0 && sizeof(rabbit));
      if (ret <= 0) {
         /* Ran out of usable money :( */
         player->delete_effect(player->sid_to_enum(id));
      }
   }
} /* buy_something() */
// --- END [/mnt/home2/grok/lib/std/effects/npc/drink_silly.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/npc/spell_effects.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/npc/spell_effects.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629019   Available: 13576373
Inodes: Total: 5242880    Free: 4960135
1010 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/npc/spell_effects.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629019   Available: 13576373
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: spell_effects.c,v 1.1 1998/01/06 04:16:50 ceres Exp $
 * $Log: spell_effects.c,v $
 * Revision 1.1  1998/01/06 04:16:50  ceres
 * Initial revision
 * 
*/
/**
 * This is the effect skelton docs.  This effect
 * has a classification of "npc.spell_effects".
 * <p>
 * Describe the arguments in here.
 * <p>
 * This effect has a shadow associated with it.
 * @classification npc.spell_effects
 * @see help::effects
 */
#include <effect.h>

#include "path.h"

/*
 * Do something when an npc died.
 * 
 * The argument set on this one...  If the is a function pointer it is
 * evaluated.  If it is array, the function in position 1 is called on
 * object in position 0.  If the array is three long, and the last
 * arguement is non 0 then the second_life funciton is not called up
 * the object list...
 */
/** @ignore yes */
string query_classification() { return "npc.spell_effects"; }

/** @ignore yes */
string query_shadow_ob() { return SHADOWS + "spell_effects"; }
// --- END [/mnt/home2/grok/lib/std/effects/npc/spell_effects.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/npc/eat_corpse.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/npc/eat_corpse.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629019   Available: 13576373
Inodes: Total: 5242880    Free: 4960135
849 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/npc/eat_corpse.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629019   Available: 13576373
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This effect tears small edible parts from the corpse (bits with no sub 
 * bits) and eats them immediately.  It should be used instead of the
 * savage_corpse effect if the NPC is too small to rip apart a corpse
 * completely.
 * @author Lemming
 * @started 3/8/2000
 * @classification npc.eat.savage
 * @see /std/effects/npc/savage_corpse.c
 * @see /std/effects/npc/eat_edible.c
 */

#include <effect.h>

#include "path.h"

/** @ignore */
void beginning( object player, string dest, int id ) {
} /* beginning() */

/** @ignore */
int merge_effect( object player, int time1, int time2, int id ) {
   return time1;
} /* merge_effect() */
 
/** @ignore */
string query_classification() { return "npc.eat.corpse"; }

/** @ignore */
string query_shadow_ob() { return SHADOWS + "eat_corpse"; }

/** @ignore */
int query_indefinate() { return 1; }
// --- END [/mnt/home2/grok/lib/std/effects/npc/eat_corpse.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/npc/eat_edible.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/npc/eat_edible.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629018   Available: 13576372
Inodes: Total: 5242880    Free: 4960135
977 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/npc/eat_edible.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629018   Available: 13576372
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: eat_edible.c,v 1.1 1998/01/06 04:16:50 ceres Exp $
 * $Log: eat_edible.c,v $
 * Revision 1.1  1998/01/06 04:16:50  ceres
 * Initial revision
 * 
*/
/**
 * This is the effect skelton docs.  This effect
 * has a classification of "npc.eat.edible".
 * <p>
 * Describe the arguments in here.
 * <p>
 * This effect has a shadow associated with it.
 * @classification npc.eat.edible
 * @see help::effects
 */
#include <effect.h>
#include <route.h>
#include <wander.h>

#include "path.h"

/*
 * This effect will make the cute little critters eat things.
 */
/** @ignore yes */
void beginning( object player, string dest, int id ) {
} /* beginning() */

/** @ignore yes */
int merge_effect( object player, int time1, int time2, int id ) {
   return time1;
} /* merge_effect() */
 
/** @ignore yes */
string query_classification() { return "npc.eat.edible"; }

/** @ignore yes */
string query_shadow_ob() { return SHADOWS + "eat_edible"; }
// --- END [/mnt/home2/grok/lib/std/effects/npc/eat_edible.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/npc/given.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/npc/given.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629018   Available: 13576372
Inodes: Total: 5242880    Free: 4960135
847 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/npc/given.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629018   Available: 13576372
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: given.c,v 1.1 1998/01/06 04:16:50 ceres Exp $
 * $Log: given.c,v $
 * Revision 1.1  1998/01/06 04:16:50  ceres
 * Initial revision
 * 
*/
/**
 * This is the effect skelton docs.  This effect
 * has a classification of "npc.given".
 * <p>
 * Describe the arguments in here.
 * <p>
 * This effect has a shadow associated with it.
 * @classification npc.given
 * @see help::effects
 */
#include <effect.h>

#include "path.h"

/*
 * Do something when something leaves the room....
 * 
 * The argument set on this one...  If the is a function pointer it is
 * evaluated.  If it is array, the function in position 1 is called on
 * object in position 0. 
 */
/** @ignore yes */
string query_classification() { return "npc.given"; }

/** @ignore yes */
string query_shadow_ob() { return SHADOWS + "given"; }
// --- END [/mnt/home2/grok/lib/std/effects/npc/given.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/npc/savage_corpse.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/npc/savage_corpse.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629018   Available: 13576372
Inodes: Total: 5242880    Free: 4960135
986 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/npc/savage_corpse.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629018   Available: 13576372
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: savage_corpse.c,v 1.1 1998/01/06 04:16:50 ceres Exp $
 * $Log: savage_corpse.c,v $
 * Revision 1.1  1998/01/06 04:16:50  ceres
 * Initial revision
 * 
*/
/**
 * This is the effect skelton docs.  This effect
 * has a classification of "npc.eat.savage".
 * <p>
 * Describe the arguments in here.
 * <p>
 * This effect has a shadow associated with it.
 * @classification npc.eat.savage
 * @see help::effects
 */
#include <effect.h>
#include <route.h>
#include <wander.h>

#include "path.h"

/*
 * This effect will make the cute little critters eat things.
 */
/** @ignore yes */
void beginning( object player, string dest, int id ) {
} /* beginning() */

/** @ignore yes */
int merge_effect( object player, int time1, int time2, int id ) {
   return time1;
} /* merge_effect() */
 
/** @ignore yes */
string query_classification() { return "npc.eat.savage"; }

/** @ignore yes */
string query_shadow_ob() { return SHADOWS + "savage_corpse"; }
// --- END [/mnt/home2/grok/lib/std/effects/npc/savage_corpse.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/npc/vampirebite_effect.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/npc/vampirebite_effect.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629017   Available: 13576371
Inodes: Total: 5242880    Free: 4960135
8906 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/npc/vampirebite_effect.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629017   Available: 13576371
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* Blood Loss Effect for use with vampire bites.                       *
 * based on the drunk effect by ceres.                                 *
 *                                                                     *
 * Archana 4/20/97                                                     *
 *                                                                     *
 * Updated to cause vampirism on death, various other modifications as *
 * well to make is simpler and add more descriptions.                  *
 *                                                                     *
 * Arguements are: int duration                                        *
 * See also "vampirebite_shadow.c" and "vampirecorpse_effect.c"        *
 *                                                                     *
 * Lemming, 03/07/2000                                                 */

#include <effect.h>
#include <living.h>
#include <move_failures.h>
#include <player.h>

mapping compass = ([ "north" : 1, "northeast" : 1, "east" : 1, "southeast" : 1,
                     "south" : 1, "southwest" : 1, "west" : 1, "northwest" : 1
                    ]);

void come_around( object person );

/** @ignore yes */
string query_classification() { return "body.bite.vampire"; }

/** @ignore yes */
string query_shadow_ob() { return "/std/shadows/npc/vampirebite_shadow"; }

/** @ignore yes */
int survive_death() { return 1; }

/** @ignore yes */
int beginning( object person, int extent, int id ) {
   int con, time;
 
   tell_object( person, "Pain shoots through your veins, exploding inside "
      "your head, making you scream in agony as the effect of the vampire's "
      "bite fills your body.\n" );
   person->add_extra_look( this_object() );
   person->adjust_bonus_int(-2);
   person->adjust_bonus_wis(-2);
   person->adjust_bonus_str(-2);
   person->adjust_bonus_dex(-2);

   person->submit_ee( "bite_pain", ({ 10, 60 }), EE_CONTINUOUS );

   // The duration should be similar to the old /global/player drunk
   // effect, ie, time = 2*extent/query_con().

   con = person->query_con();
   if( con < 1 ) con = 1;

   time = 2 * extent / con;
   person->submit_ee( 0, time, EE_REMOVE );

   return time;
} /* beginning() */

/** @ignore yes */
int merge_effect( object person, int old_time, int new_extent, int id ) {
   int con, new_time;

   con = person->query_con();
   if( con < 1 ) con = 1;

   new_time = ( 2 * new_extent / con ) + person->expected_tt();
   person->submit_ee( 0, new_time, EE_REMOVE );

   return new_time;
} /* merge_effect() */

/** @ignore yes */
void restart( object person, int time, int id ) {
   person->adjust_bonus_int(-2);
   person->adjust_bonus_wis(-2);
   person->adjust_bonus_str(-2);
   person->adjust_bonus_dex(-2);
} /* restart() */

/** @ignore yes */
void end( object person, int time, int id ) {
   if( person->query_property( PASSED_OUT_PROP ) )
      come_around( person );

   person->adjust_bonus_int(2);
   person->adjust_bonus_wis(2);
   person->adjust_bonus_str(2);
   person->adjust_bonus_dex(2);

   tell_object( person, "The firey pain screaming through your veins and "
      "incessant pounding inside your head finally wear off, leaving you "
      "with a mild headache.\n" );
} /* end() */

/** @ignore yes */
void bite_pain( object person, int time, int id ) {
   int timeleft, selector;

   timeleft = (int)person->expected_tt();
  
   if( person->query_property( PASSED_OUT_PROP ) ) {
      switch( random(3) ) {
      case 0 :
         tell_room( environment(person), person->one_short() + " shakes "
            "slightly in silent agony.\n", person );
         break;
      case 1 :
         tell_room( environment(person), person->one_short() + " moans, "
            "writhing on the ground.\n", person );
         break;
      case 2 :
         tell_room( environment(person), person->one_short() + " opens " +
            person->query_possessive() + " eyes, stares around wildly as if "
            "in a fever, and passes out again with a groan.\n", person );
         break;
      }
      return;
   }

   selector = random( timeleft ) / person->query_con() / 5;

   switch( selector ) {
   case 0 :
      break;
   case 1 :
   case 2 :
      switch( random(4) ) {
      case 0 :
         person->new_parser( "gasp in pain" );
         break;
      case 1 :
         person->new_parser( "moan agonisingly" );
         break;
      case 2 :
         person->new_parser( "stumble" );
         break;
      default :
         person->new_parser( "dloh head in pain" );
         break;
      }
      break;
   case 3 :
   case 4 :
   case 5 :
      switch( random(4) ) {
      case 0 :
         tell_object( person, "You clutch your head and groan in agony as "
            "the effect of the vampires bite burns through you.\n" );
         tell_room( environment( person ), person->the_short() +
            " clutches " + person->query_possessive() + " head and groans "
            "in agony.\n", person );
         break;
      case 1 :
         tell_object( person, "You stagger about, your vision blurring and "
            "fading for a moment while your head throbs with pain.\n" );
         tell_room( environment( person ), person->the_short() +
            " staggers about, " + person->query_possessive() + " eyes "
            "drifting in and out of focus.\n", person );
         break;
      case 2 :
         tell_object( person, "You feel yourself go lightheaded and the "
            "pain fades for just a moment, before slamming back into you "
            "like a hammer to the forehead.\n" );
         tell_room( environment( person ), person->the_short() + " pales "
            "as the blood drains from " + person->query_possessive() +
            " face, then clenches " + person->query_possessive() + " teeth "
            "and groans with pain.\n", person );
         break;
      default :
         tell_object( person, "The fire flooding through your veins causes "
            "you to scream in agony, your body racked with pain.\n" );
         tell_room( environment( person ), person->the_short() + " leans "
            + person->query_possessive() + " head back and screams in "
            "pain.\n", person );
         break;
      }
      break;
   default :
      if( timeleft > 100 ) {
         switch( random(2) ) {
         case 0 :
            tell_object( person, "The world goes black.  You have "+
                "passed out.\n" );
            tell_room( environment( person ), "The blood drains from " +
                person->the_short() + "'s face, and " +
                person->query_pronoun() + " collapses heavily to the "
                "ground.\n", person );
            person->add_property( PASSED_OUT_PROP, 1 );
            person->submit_ee( "come_around", ({ 50, 80 }), EE_ONCE );
            break;
         case 1 :
            person->submit_ee( "wander_about", 3, EE_ONCE );
            break;
         }
      } 
   }
} /* bite_pain() */

/** @ignore yes */
void come_around( object person ) {
   tell_object( person, "You feel a pounding headache coming on and realise "
      "you are finally conscious.\n" );
   tell_room( environment( person ), person->the_short() + " groans "
      "painfully, opens " + person->query_possessive() + " eyes and slowly "
      "picks " + person->query_objective() + "self up.\n", person );
   person->remove_property( PASSED_OUT_PROP );
} /* come_around() */

/** @ignore yes */
void wander_about( object person, int time, int id ) {
   int i, flag;
   string *direcs;

   if( person->query_property( PASSED_OUT_PROP ) || !environment( person ) )
      return;

   if( random( 4 ) )
      person->submit_ee( "wander_about", ({ 8, 8 }), EE_ONCE );

   direcs = (string *)environment( person )->query_direc();
   while( sizeof( direcs ) && !flag ) {
      i = random( sizeof( direcs ) );
      if( /* !environment( person )->query_obvious_exit( direcs[ i ] ) || */
          !environment( person )->query_door_open( direcs[ i ] ) ) {
         direcs = delete( direcs, i, 1 );
         continue;
      }

      person->add_property( UNKNOWN_MOVE, 1 );
      if( compass[direcs[i]] )
         flag = person->exit_command( 0, ({ direcs[ i ], "$N attempt$s to "
            "walk in one direction and instead stumble$s off towards the "
            "$T." }) );
      else
         flag = person->exit_command( 0, ({ direcs[ i ], "$N stumble$s off "
            "towards the $T." }) );

      tell_object( person, "You attempt to get up and walk and just "
         "manage to stumble around a bit.\n" );
      person->remove_property( UNKNOWN_MOVE );

      if( !flag )
         direcs = delete( direcs, i, 1 );
   }
} /* wander_about() */
string extra_look( object player, mixed *args ) {
    return capitalize(player->query_pronoun()+" looks rather pale with cold,"
    " clammy skin and a look of dizziness.\n");
} /* extra_look() */// --- END [/mnt/home2/grok/lib/std/effects/npc/vampirebite_effect.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/npc/i_died.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/npc/i_died.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629015   Available: 13576369
Inodes: Total: 5242880    Free: 4960135
974 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/npc/i_died.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629015   Available: 13576369
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: i_died.c,v 1.1 1998/01/06 04:16:50 ceres Exp $
 * $Log: i_died.c,v $
 * Revision 1.1  1998/01/06 04:16:50  ceres
 * Initial revision
 * 
*/
/**
 * This is the effect skelton docs.  This effect
 * has a classification of "npc.death.me".
 * <p>
 * Describe the arguments in here.
 * <p>
 * This effect has a shadow associated with it.
 * @classification npc.death.me
 * @see help::effects
 */
#include <effect.h>

#include "path.h"

/*
 * Do something when an npc died.
 * 
 * The argument set on this one...  If the is a function pointer it is
 * evaluated.  If it is array, the function in position 1 is called on
 * object in position 0.  If the array is three long, and the last
 * arguement is non 0 then the second_life funciton is not called up
 * the object list...
 */
/** @ignore yes */
string query_classification() { return "npc.death.me"; }

/** @ignore yes */
string query_shadow_ob() { return SHADOWS + "i_died"; }
// --- END [/mnt/home2/grok/lib/std/effects/npc/i_died.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/npc/dont_move.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/npc/dont_move.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629014   Available: 13576368
Inodes: Total: 5242880    Free: 4960135
1222 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/npc/dont_move.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629014   Available: 13576368
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: dont_move.c,v 1.1 2000/07/26 23:58:04 pinkfish Exp $
 * $Log: dont_move.c,v $
 * Revision 1.1  2000/07/26 23:58:04  pinkfish
 * Initial revision
 *
 * Revision 1.1  1998/01/06 04:16:50  ceres
 * Initial revision
 * 
*/
/**
 * This an effect that will stop an npc from moving for a while.  It
 * has a classification of "npc.move.no".
 * <p>
 * The argument is the amount of time the npc is to be frozen for.
 * <p>
 * This effect has a shadow associated with it.
 * @classification npc.move.no
 * @see help::effects
 */
#include <effect.h>
#include <route.h>
#include <wander.h>

#include "path.h"

/*
 * This effect will make the cute little critters eat things.
 */
/** @ignore yes */
void beginning( object player, int arg, int id ) {
   player->submit_ee(0, arg, EE_REMOVE);
} /* beginning() */

/** @ignore yes */
int merge_effect( object player, int time1, int time2, int id ) {
   player->submit_ee( 0, time1 + time2 - player->expected_tt(),
          EE_REMOVE );
   return time1 + time2;
} /* merge_effect() */
 
/** @ignore yes */
string query_classification() { return "npc.move.no"; }

/** @ignore yes */
string query_shadow_ob() { return SHADOWS + "dont_move"; }
// --- END [/mnt/home2/grok/lib/std/effects/npc/dont_move.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/npc/no_follow.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/npc/no_follow.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629014   Available: 13576368
Inodes: Total: 5242880    Free: 4960135
1011 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/npc/no_follow.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629014   Available: 13576368
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: no_follow.c,v 1.1 1998/01/06 04:16:50 ceres Exp $
 * $Log: no_follow.c,v $
 * Revision 1.1  1998/01/06 04:16:50  ceres
 * Initial revision
 * 
*/
/**
 * This is the effect skelton docs.  This effect
 * has a classification of "npc.follow.no".
 * <p>
 * Describe the arguments in here.
 * <p>
 * This effect has a shadow associated with it.
 * @classification npc.follow.no
 * @see help::effects
 */
#include <effect.h>
#include <route.h>
#include <wander.h>

#include "path.h"

/*
 * This effect will make the cute little critters eat things.
 */
/** @ignore yes */
void beginning( object player, string dest, int id ) {
   player->do_command("lose everyone");
} /* beginning() */

/** @ignore yes */
int merge_effect( object player, int time1, int time2, int id ) {
   return time1;
} /* merge_effect() */
 
/** @ignore yes */
string query_classification() { return "npc.follow.no"; }

/** @ignore yes */
string query_shadow_ob() { return SHADOWS + "no_follow"; }
// --- END [/mnt/home2/grok/lib/std/effects/npc/no_follow.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/npc/controlled_monster.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/npc/controlled_monster.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629013   Available: 13576367
Inodes: Total: 5242880    Free: 4960135
952 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/npc/controlled_monster.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629013   Available: 13576367
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: controlled_monster.c,v 1.1 1998/01/06 04:16:50 ceres Exp $
 * $Log: controlled_monster.c,v $
 * Revision 1.1  1998/01/06 04:16:50  ceres
 * Initial revision
 * 
*/
/**
 * This is the effect skelton docs.  This effect
 * has a classification of "npc.controlled_monster".
 * <p>
 * Describe the arguments in here.
 * <p>
 * This effect has a shadow associated with it.
 * @classification npc.controlled_monster
 * @see help::effects
 */
#include "path.h"

/* This effect will make the critter controllable.
 */
/** @ignore yes */
string query_shadow_ob() { return SHADOWS + "controlled_monster"; }

/** @ignore yes */
void beginning( object player, string dest, int id ) {
} /* beginning() */

/** @ignore yes */
int merge_effect( object player, int time1, int time2, int id ) {
   return time2;
} /* merge_effect() */
 
/** @ignore yes */
string query_classification() { return "npc.controlled_monster"; }

// --- END [/mnt/home2/grok/lib/std/effects/npc/controlled_monster.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/npc/wizards_protection.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/npc/wizards_protection.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629013   Available: 13576367
Inodes: Total: 5242880    Free: 4960135
1511 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/npc/wizards_protection.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629013   Available: 13576367
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * @main
 * The effect put on NPCs who are protected by Unseen University's Porters.
 *
 * The argument is an array containing, in this order, the attack string, 
 * (what the  NPC does/says when attacked), the enter string (what the 
 * NPC does/says when a criminal enters), the warning string (how the NPC 
 * warns the guards), and the integer severity of attacking the NPC. 
 * (Usually 1, but potentially more for "better" NPCS).
 * The strings will be passed right into init_command, so they will need to 
 * have the appropriate command at the front. 
 * (for example, ":cowers away in terror."). Optionally, zeroes may be passed 
 * to leave out that string.
 * There is no timing on this effect because, well, that's just silly.
 *
 * @classification npc.protection.wizards
 * @author Rodion
 */

#include <effect.h>

#define SHADOWS "/std/shadows/npc/"
#define SHADOW_OB  "uu_staff_protection"

/** @ignore */
string query_classification(){return "npc.protection.wizards"; }

/** @ignore */
void beginning(object player, mixed arg){
   player->submit_ee( 0, -1, EE_REMOVE );
}/*beginning()*/

/** @ignore */
string query_shadow_ob() {
   return (SHADOWS SHADOW_OB);
} /* query_shadow_ob() */

// If a new effect is added, the arguments from it will replace those of the 
// prior effect.
/** @ignore */
mixed merge_effect(object player, mixed old_arg, mixed new_arg){
   return new_arg;
}/*merge_effect()*/

/** @ignore */
int query_indefinite() { return 1; }
/*A SkankyCode Creation, by Rodion*/// --- END [/mnt/home2/grok/lib/std/effects/npc/wizards_protection.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/npc/vampirecorpse_effect.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/npc/vampirecorpse_effect.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629012   Available: 13576366
Inodes: Total: 5242880    Free: 4960135
4034 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/npc/vampirecorpse_effect.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629012   Available: 13576366
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* Makes the corpse twitch a bit, then ressurects it as a vampire. *
 * When the corpse is ressurected it will drop all its inventory   *
 * to the floor and clone its own clothing.                        *
 *                                                                 *
 * I wouldn't try applying this effect to anything other than a    *
 * corpse.  Bad Things would happen.                               *
 *                                                                 *
 * Arguements are: ({ the name of the creature killed,             *
 *                    player->gender(),                            *
 *                    player->level(),                             *
 *                    0 })                                         *
 * See also "vampirebite_effect.c" and "corpse_vampire.c"          *
 *                                                                 *
 * Lemming, 03/07/2000                                             */

#include <effect.h>


/** @ignore yes */
string query_classification() { return "corpse.transformation.vampire"; }

/** @ignore yes */
void beginning( object corpse, mixed *args ) {
   corpse->add_extra_look( this_object() );
   corpse->submit_ee( "corpse_action", 10, EE_CONTINUOUS );
  
} /* beginning() */

/** @ignore yes */
mixed *merge_effect( object corpse, mixed *old_args, mixed *new_args ) {
   return new_args;
} /* merge_effect() */

/** @ignore yes */
void end( object corpse, mixed *args ) {
   object ob, vampire;

   tell_room( environment(corpse), "The corpse's eyes snap open, and a "
      "vicious grin spreads across its face.  It rises upwards without "
      "bothering to push away from the ground, standing upright, its eyes "
      "flashing.  You notice that the fangs of the corpse look considerably "
      "longer than they used to.\n" );

   vampire = clone_object( "/d/ram/chars/Uberwald/corpse_vampire" );
   vampire->setup_vampire( args[0], args[1] );
   vampire->move( environment( corpse ), vampire->the_short() + " glances "
      "down at " + vampire->query_objective() + "self and grimaces.  " +
      capitalize( vampire->query_pronoun() ) + " waves one arm and is "
      "instantly clothed in more fitting garments.\n"  );
   vampire->do_command( "grin viciously" );

   corpse->clear_armours();

   foreach( ob in all_inventory( corpse ) ) {
      ob->move( environment( corpse ) );
   }

   corpse->remove_extra_look( this_object() );
   corpse->move( "/room/rubbish" );
} /* end() */

/** @ignore yes */
void corpse_action( object corpse, mixed *args ) {
   int rate;
   object *stuff; 
   stuff = all_inventory (corpse); 
   rate = (int) (corpse->query_decay());
  if( sizeof( stuff ) ) {
    tell_room( environment(corpse), corpse->one_short() + " twitches "
         "slightly.\n" );
   
    if (rate < 20) {
      tell_room( environment(corpse), corpse->one_short() + " seems to "
         "arch its back, and a faint gasp comes from its mouth.\n" );
      //tell_creator("archana","Yes I'm being called ");   
      corpse->submit_ee( 0, 1, EE_REMOVE ); 
      
     }      
    return;    
   }  
   
 
   switch( args[3] ) {
   case 0 :
      tell_room( environment(corpse), corpse->one_short() + " twitches "
         "slightly.\n" );
     
      break;
   case 1 :
      tell_room( environment(corpse), corpse->one_short() + " jerks "
         "violently, its limbs quivering.\n" );
     
      break;
   case 2 :
      tell_room( environment(corpse), corpse->one_short() + " seems to "
         "arch its back, and a faint gasp comes from its mouth.\n" );
      //tell_creator("archana","Yes I'm being called ");   
      corpse->submit_ee( 0, 1, EE_REMOVE ); 
      break;
      
  }       
   args[3]++;
} /* corpse_action() */

/** @ignore yes */
string extra_look( object corpse, mixed *args ) {
   return "It seems to be twitching slightly, almost as if it's still "
      "alive.  You probably shouldn't get too close.\n";
} /* extra_look() */

/** @ignore yes */
int query_theft_command() { return -1; }
// --- END [/mnt/home2/grok/lib/std/effects/npc/vampirecorpse_effect.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/npc/goto_destination.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/npc/goto_destination.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629011   Available: 13576365
Inodes: Total: 5242880    Free: 4960135
6737 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/npc/goto_destination.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629011   Available: 13576365
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: goto_destination.c,v 1.4 1999/03/05 07:21:06 ceres Exp $
 * $Log: goto_destination.c,v $
 * Revision 1.4  1999/03/05 07:21:06  ceres
 * Made it only log during debug
 *
 * Revision 1.3  1999/01/06 20:36:30  ceres
 * Added more error checking.
 *
 * Revision 1.2  1998/02/08 06:54:41  sin
 * Fixed a problem that could cause the goto_destination effect to stop working.
 *
 * Revision 1.1  1998/01/06 04:16:50  ceres
 * Initial revision
 * 
*/
/**
 * This is the goto destination effect, it also handles selling
 * stuff at the destination. This effect
 * has a classification of "npc.move".
 * <p>
 * The argument to this can be one of three things, it can be a
 * string, an object or an array.  If it is a string the string
 * specifies the room which the npc will try to go to.  If it
 * is an object then the npc will try and get to the living object
 * or room specified by the object.  The array consists of three
 * elements:
 * <ol>
 * <li>The destination as given above, string or object
 * <li>The end function, 0 for nothing, "sell" to sell the inventory
 * <li>The delay before heading off to the next destination.
 * </ol>
 * <p>
 * If the thing to do at the end is a function it is called with
 * the following parameters: <br>
 *   <code>function(object player, int found_it, string destination)</code><br>
 * The found_it parameter will be 1 if the room is correct or 0
 * if it is not correct.
 * <p>
 * This effect has a shadow associated with it.
 * @classification npc.move
 * @see help::effects
 */
#include <effect.h>

#include "path.h"

#define LOG_FILE "EFFECTS"

private string standardize(mixed dest);

/**
 * @ignore
 */
void call_move_to(object player, string dest)
{
  if (!player) {
#ifdef DEBUG
    log_file(LOG_FILE,
             sprintf("%O %s: player became 0 before call_move_to() called\n",
                     this_object(), ctime(time())));
#endif
    return;
  }

  if(!dest) {
#ifdef DEBUG
    log_file(LOG_FILE,
             sprintf("%O %s: dest became 0 before call_move_to() called\n",
                     this_object(), ctime(time())));
#endif
    return;
  }
    
  player->move_me_to(dest);
}

/**
 * @ignore
 */
void remove_effect(object player, int id)
{
  if (player)
    player->remove_effect(id);
}

/*
 * This is used to get a npc to wander somewhere and do something.
 * It takes either a string, being the destination to go to, or a
 * array of 3 elements.  The first is the destination, the second
 * is what to do when you get there and the third is the delay before
 * the next sequence occurs.
 *
 * If the thing to do at the end is a function it is called with
 * the following parameters:
 *   function(object player, string destination, int found_it)
 *
 * The found_it parameter will be 1 if the room is correct or 0
 * if it is not correct.
 */
/** @ignore yes */
void beginning( object player, mixed arg, int id ) {
   mixed dest;

   if (pointerp(arg)) {
      if (sizeof(arg) > 3) {
         arg = arg[0..2];
      } else while (sizeof(arg) < 3) {
         arg += ({ 20 });
      }
   } else {
      arg = ({ arg, 0, 20 });
   }

   arg[0] = standardize(arg[0]);

   if (!dest) {
      while (!arg[0] && sizeof(arg) > 3) {
         arg = arg[3..];
         arg[0] = standardize(arg[0]);
      }
      if (!arg[0]) {
         /* Remove ourselves. */
         call_out("remove_effect", 2, player, id);
         return ;
      }
   }

   if (objectp(arg[0])) {
      call_out("call_move_to", 2, player, file_name(environment(arg[0])));
   } else {
      call_out("call_move_to", 2, player, arg[0]);
   }
} /* beginning() */

/** @ignore yes */
private string standardize(mixed dest) {
   if (objectp(dest)) {
      if (!living(dest)) {
         dest = file_name(dest);
      }
   } else if (stringp(dest)) {
      if (catch(dest->rabbit_well())) {
         dest = 0;
      } else {
         dest = file_name(find_object(dest));
      }
   }

   return dest;
} /* standardize() */

/** @ignore yes */
mixed merge_effect( object player, mixed arg1, mixed arg2, int id ) {
   if (!pointerp(arg1)) {
      arg1 = ({ arg1, 0, 20 });
   }

   if (sizeof(arg1) > 0) {
      while (sizeof(arg1) < 3) {
         arg1 += ({ 20 });
      }
      arg1[0] = standardize(arg1[0]);
   }

   if (!pointerp(arg2)) {
      arg2 = ({ arg2, 0, 20 });
   }

   if (sizeof(arg2) > 0) {
      while (sizeof(arg2) < 3) {
         arg2 += ({ 20 });
      }
      arg2[0] = standardize(arg2[0]);
   }

   arg1 += arg2;

   while (!arg1[0] && sizeof(arg1) > 3) {
      arg1 = arg1[3..];
      arg1[0] = standardize(arg1[0]);
   }
   if (!arg1[0]) {
      /* Remove ourselves. */
      call_out("remove_effect", 2, player, id);
      return ({ });
   }

   /* Stack them up... */
   return arg1;
} /* merge_effect() */

/** @ignore yes */
void effect_womble(object player, mixed *arr) {
  if(!player)
    return;
   player->add_effect(file_name(this_object()), arr);
} /* effect_womble() */

/**
 * This method sells everything the npc currently has and is not
 * marked with the property "start equipment".  This can be called from
 * outside the effect to sell things.
 * @param player the players whose inventory is to be sold
 */
void do_the_sell(object player) { 
   object *obs;
   int i;
   
   /* Sell stuff... */
   obs = all_inventory(player);
   for (i = 0; i < sizeof(obs); i++) {
      if (!obs[i]->query_property("start equipment")) {
         call_out((: $1->do_command("sell "+file_name($2)) :),
                   1, player, obs[i]);
      }
   }
} /* do_the_sell() */

/** @ignore yes */
void end( object player, mixed room, int id ) {
   int ok;

   if (pointerp(room)) {
      if (sizeof(room) > 3) {
         /* 20 seconds between actions... */
         call_out( "effect_womble", room[2], player, room[3..]);
      }

      if (!room[0]) {
         ok = 0;
      } else if (objectp(room[0])) {
         ok = (environment(room[0]) == environment(player));
      } else {
         ok = file_name(environment(player)) == room[0];
      }

      if (functionp(room[1])) {
         evaluate(room[1], player, room[0], ok, room[1]);
      }

      if (stringp(room[1])) {
         if (ok) {
            switch (room[1]) {
               case "sell" :
                  do_the_sell(player);
                  break;
               default :
                  player->do_command(room[1]);
                  break;
            }
         }
      }

      if (pointerp(room[1])) {
         call_other(room[1][0], room[1][1], player, room[0], ok, room[1]);
      }
   }
} /* end() */
 
/** @ignore yes */
string query_classification() { return "npc.move"; }

/** @ignore yes */
string query_shadow_ob() { return SHADOWS + "goto_destination"; }
// --- END [/mnt/home2/grok/lib/std/effects/npc/goto_destination.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/npc/mock_block.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/npc/mock_block.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629009   Available: 13576363
Inodes: Total: 5242880    Free: 4960135
1374 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/npc/mock_block.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629009   Available: 13576363
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
* This is a very boring effect that does nothing but add a shadow to
* the npc, preventing one or more of his skills from being mocked.
* The skills need not be leaves - branches are allowed.  Ie: "magic"
* will block all ma.* skills, "magic.spells" will block ma.sp.*, etc.
* Also, if "all" is included in the array, all skills will be blocked
* from being mocked.
*
* The shadow has a few functions in to query the list.
*
* Pass add_effect one arg: string *skills - the skills to block
* 
* This effect has one arg: *string skills - the skills blocked.
* This effect is indefinite.
* This effect has a shadow associated with it.
* This effect has a classification of "mock.block.npc"
*
* @author Tannah
**/

#include "path.h"

/** @ignore yes */
string *beginning( object player, string *skills ) { 
  return skills;
} /* beginning() */

/* restart or end needed */

/** @ignore yes */
string *merge_effect( object player, string *old, string *arg ) {

  /* Might as well take the duplicates out, even though it's not really 
   * necessary. */
  arg = filter( arg, (: member_array( $1, $2 ) == -1 :), old );

  return old + arg;
} /* merge_effect() */

/** @ignore yes */
string query_classification() { return "mock.block.npc"; }

/** @ignore yes */
string query_shadow_ob() { return SHADOWS "mock_block"; }

/** @ignore yes */
int query_indefinite() { return 1; }
// --- END [/mnt/home2/grok/lib/std/effects/npc/mock_block.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/npc/light_change.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/npc/light_change.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629009   Available: 13576363
Inodes: Total: 5242880    Free: 4960135
1004 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/npc/light_change.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629009   Available: 13576363
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: light_change.c,v 1.1 1998/01/06 04:16:50 ceres Exp $
 * $Log: light_change.c,v $
 * Revision 1.1  1998/01/06 04:16:50  ceres
 * Initial revision
 * 
*/
/**
 * This is the effect skelton docs.  This effect
 * has a classification of "npc.light_change".
 * <p>
 * Describe the arguments in here.
 * <p>
 * This effect has a shadow associated with it.
 * @classification npc.light_change
 * @see help::effects
 */
#include <effect.h>

#include "path.h"

/*
 * Do something when an npc died.
 * 
 * The argument set on this one...  If the is a function pointer it is
 * evaluated.  If it is array, the function in position 1 is called on
 * object in position 0.  If the array is three long, and the last
 * arguement is non 0 then the second_life funciton is not called up
 * the object list...
 */
/** @ignore yes */
string query_classification() { return "npc.light_change"; }

/** @ignore yes */
string query_shadow_ob() { return SHADOWS + "light_change"; }
// --- END [/mnt/home2/grok/lib/std/effects/npc/light_change.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/npc/unsocial_effect.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/npc/unsocial_effect.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629008   Available: 13576362
Inodes: Total: 5242880    Free: 4960135
3241 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/npc/unsocial_effect.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629008   Available: 13576362
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: unsocial_effect.c,v 1.2 2002/09/19 10:15:36 tilly Exp $
 * $Log: unsocial_effect.c,v $
 * Revision 1.2  2002/09/19 10:15:36  tilly
 * Typo!
 *
 * Revision 1.1  1998/01/06 04:16:50  ceres
 * Initial revision
 * 
*/
/**
 * This is the effect skelton docs.  This effect
 * has a classification of "curse.magic.social".
 * <p>
 * Describe the arguments in here.
 * @classification curse.magic.social
 * @see help::effects
 */
#include <effect.h>

/** @ignore yes */
void beginning( object player,mixed *arg, int id ) {
   tell_object( player, "The spectral image of a "+arg[0]+" appears in front "
         "of you and looks sadly at you through pale eyes.  You shudder "
         "in horror as the image passes through you with tears in its "
         "eyes.  You find your yourself less able to communicate from the "
         "shock.\n");
   tell_room( environment( player ), player->the_short()+" suddenly looks "
         "straight ahead and shudders for no visible reason.\n", player );
   player->submit_ee( "reminder_mess", 20, EE_CONTINUOUS );
   player->submit_ee( 0, arg[1], EE_REMOVE );
   player->set_max_sp( 0 );
} /* beginning() */


/** @ignore yes */
int merge_effect( object player, int time1, int time2, int id ) {
   player->submit_ee( 0, time1 + time2 - (int)player->expected_tt(),
         EE_REMOVE );
   return time1 + time2;
} /* merge_effect() */
 
/** @ignore yes */
void end( object player, int time, int id ) {
   int number;
   tell_object( player, "You feel you have recovered and are ready to "
         "communicate with the world again.\n");
   number= player->query_real_max_sp();
   player->adjust_max_sp( number );
} /* end() */
 
void reminder_mess( object player, mixed *arg, int id ) {
   string message;
   if (!random(4))
       switch(random(2)){
         case 0 : 
           message = "The spectral image of a "+arg[0]+" just like you had "
            "as a "
            "child appears in front of you.  Before you know what you are "
            "doing you strike out at the "+arg[0]+" spilling spectral blood "
            "everywhere.\n";
           break;       
         default :
           message = "You have a vision of yourself walking down a street "
            "when suddenly a masked "+arg[0]+" jumps out of the shadows "+
            "and cuts you into pieces with its natural weapons.\n";
           break;
       } /* switch() */
   else message = "The pitiful looking ghost of a "+arg[0]+
         " suffering from horrifying wounds drifts past you.\n";
            

   tell_object( player, message);
 
   tell_room( environment( player ),player->the_short()+" shudders and "
         "looks worried.\n", player );
   player->run_away();
   if (sizeof(player->effects_matching("priest.paralysis"))){
     tell_object(player,"You look around in panicked confusion, unsure "
                 "of exactly where you are.\n");
     tell_room( environment( player ),player->the_short()+ " stares dazedly "
                "at their surroundings.\n",player);
     tell_object(player,((environment(player)->query_long() )+"\n"));
  }
} /* reminder_mess() */

/** @ignore yes */
string query_classification() { return "curse.magic.social"; }
// --- END [/mnt/home2/grok/lib/std/effects/npc/unsocial_effect.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/npc/basilisk_stare.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/npc/basilisk_stare.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629007   Available: 13576361
Inodes: Total: 5242880    Free: 4960135
3139 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/npc/basilisk_stare.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629007   Available: 13576361
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: basilisk_stare.c,v 1.3 2000/06/07 21:28:35 pinkfish Exp $
 * $Log: basilisk_stare.c,v $
 * Revision 1.3  2000/06/07 21:28:35  pinkfish
 * FIx it up to use correct find_match code.
 *
 * Revision 1.2  2000/06/07 21:27:17  sin
 * Stuff.
 *
 * Revision 1.1  1998/01/06 04:16:50  ceres
 * Initial revision
 * 
*/
#include <effect.h>
#include "path.h"

void do_damage(object to, int amount, object from, int id)
{
  if (!to) return;
  if (to->query_hp() <= amount)
    to->delete_effect(to->sid_to_enum(id));
  to->attack_by(this_object());
  to->adjust_hp(-amount, from);
}

void stop_fighting(object who, mixed arg, int id)
{
  int *fights, i;

  /* I should really be calling test_remove() here, but none of the
   * fighting effects have a test_remove() defined, so I'm kinda 
   * screwed.  -- Sin */
  fights = who->effects_matching("fighting");
  if (sizeof(fights))
    for (i = sizeof(fights) - 1; i >= 0; i--)
      who->delete_effect(fights[i]);
}

void doit(object them, int arg, int id)
{
  int dam;
  object basilisk;

  arg--;
  them->set_arg_of(them->sid_to_enum(id), arg);
  if (!arg) {
    them->delete_effect(them->sid_to_enum(id));
    return;
  }
  if (sizeof(match_objects_for_existence("basilisk", environment(them))) == 0) {
    tell_object(them, "You suddenly notice that the basilisk is no "
                "longer here.\n");
    them->delete_effect(them->sid_to_enum(id));
    return;
  }
  tell_object(them,
         ({
      "You cannot stand the deadly stare.\n",
      "Your soul is being drilled through and out the other side.\n",
      "Your eyeballs are being ripped apart.\n",
      "Your brain is being flayed.\n"
      })[random(4)]);
  tell_room(environment(them),
       ({
         them->one_short()+" cannot bear the deadly gaze.\n",
         them->one_short()+"'s soul is being torn apart.\n",
         them->one_short()+"'s brain is afire.\n",
         them->one_short()+"'s eyeballs are being drilled through.\n"
         })[random(4)], them);
  
  basilisk = find_living("basilisk");
  if (basilisk) {
    dam = random(50)+50;
    call_out("do_damage", 1, them, dam, basilisk, id);
  }
} /* mixed_effect_heart_beat() */

int beginning(object them, int arg, int id)
{
  tell_object(them, "You feel a pair of mental diamond drills penetrating "
         "your brain.\n");
  tell_room(environment(them), them->one_short() +
            "'s soul is about to be ripped apart.\n", them) ;
  them->submit_ee("stop_fighting", 1, EE_ONCE);
  them->submit_ee("doit", 10, EE_CONTINUOUS);
  them->add_property("passed out", 1);
  return arg;
} /* beginning() */

void end(object them)
{
  tell_object(them, "You are freed from the basilisk's deadly stare.\n");
  them->remove_property("passed out");
}

string query_shadow_ob() {
  return SHADOWS+"basilisk_stare";
} /* query_shadow_ob() */

void merge_effect(object them, int arg1, int arg2, int id)
{
  them->set_arg_of(them->sid_to_enum(id), arg1 + arg2);
} /* merge_effect() */

string query_classification() { return "magic.offensive.paralysis.stare"; }

string query_name()
{
  return "a horrible sight";
}
// --- END [/mnt/home2/grok/lib/std/effects/npc/basilisk_stare.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/npc/enter.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/npc/enter.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629006   Available: 13576360
Inodes: Total: 5242880    Free: 4960135
847 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/npc/enter.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629006   Available: 13576360
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: enter.c,v 1.1 1998/01/06 04:16:50 ceres Exp $
 * $Log: enter.c,v $
 * Revision 1.1  1998/01/06 04:16:50  ceres
 * Initial revision
 * 
*/
/**
 * This is the effect skelton docs.  This effect
 * has a classification of "npc.enter".
 * <p>
 * Describe the arguments in here.
 * <p>
 * This effect has a shadow associated with it.
 * @classification npc.enter
 * @see help::effects
 */
#include <effect.h>

#include "path.h"

/*
 * Do something when something leaves the room....
 * 
 * The argument set on this one...  If the is a function pointer it is
 * evaluated.  If it is array, the function in position 1 is called on
 * object in position 0. 
 */
/** @ignore yes */
string query_classification() { return "npc.enter"; }

/** @ignore yes */
string query_shadow_ob() { return SHADOWS + "enter"; }
// --- END [/mnt/home2/grok/lib/std/effects/npc/enter.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/npc/scavenge.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/npc/scavenge.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629006   Available: 13576360
Inodes: Total: 5242880    Free: 4960135
853 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/npc/scavenge.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629006   Available: 13576360
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: scavenge.c,v 1.1 1998/01/06 04:16:50 ceres Exp $
 * $Log: scavenge.c,v $
 * Revision 1.1  1998/01/06 04:16:50  ceres
 * Initial revision
 * 
*/
/**
 * This is the effect skelton docs.  This effect
 * has a classification of "npc.given".
 * <p>
 * Describe the arguments in here.
 * <p>
 * This effect has a shadow associated with it.
 * @classification npc.given
 * @see help::effects
 */
#include <effect.h>

#include "path.h"

/*
 * Do something when something leaves the room....
 * 
 * The argument set on this one...  If the is a function pointer it is
 * evaluated.  If it is array, the function in position 1 is called on
 * object in position 0. 
 */
/** @ignore yes */
string query_classification() { return "npc.given"; }

/** @ignore yes */
string query_shadow_ob() { return SHADOWS + "given"; }
// --- END [/mnt/home2/grok/lib/std/effects/npc/scavenge.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/npc/good_fighter.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/npc/good_fighter.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629005   Available: 13576359
Inodes: Total: 5242880    Free: 4960135
4703 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/npc/good_fighter.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629005   Available: 13576359
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: good_fighter.c,v 1.3 1998/04/11 23:55:16 sin Exp $
 * $Log: good_fighter.c,v $
 * Revision 1.3  1998/04/11 23:55:16  sin
 * Changed documentation to describe USE_UNARMED
 *
 * Revision 1.2  1998/02/06 22:18:18  sin
 * Change in preparation for the skills rearrange.
 *
 * Revision 1.1  1998/01/06 04:16:50  ceres
 * Initial revision
 * 
*/
/**
 * The Good Fighter effect makes the npc fight a lot better.  It has a
 * classification of "npc.fighter".
 *
 * <p>Many NPCs need to be able to fight well.  Generally "fight well"
 * simply means using the special combat commands that their guild
 * offers.  Of course, since the use of those commands requires that an
 * NPC have the requisite skills, the NPC will also have to include
 * logic to set those skills to an appropriate level.  Since many
 * NPCs need to be good fighters, this kind of code is duplicated
 * all over the Disc.
 *
 * <p>This shadow does everything necessary to turn a plain, stupid,
 * NPC into a semi-intelligent fighter.
 *
 * <p>To be more specific, when this shadow is applied to an NPC, it'll
 * do everything necessary to make sure the NPC has the commands
 * appropriate to their level, has the skills to use those commands,
 * and has the intelligence to use the commands in a useful way.
 *
 * <p>Currently, this shadow is only really useful to members of the
 * warriors' guild.  It should be relatively straightforward to
 * generalize this shadow to the needs of other guilds, or to write
 * customized shadows based on this one but tuned for those others.
 * But that is a later project.
 *
 * <p>To use this shadow, you must first set the NPC's guild, race,
 * and level, and their stats (strength, constitution, &c.).  Then
 * add the effect to the NPC.  Defines are provided in good_fighter.h
 * to simplify this.  Generally, this would be done in the setup()
 * function for the NPC, but it can also be done later, in response
 * to some event, or a player's statement, or what have you.  The
 * only thing that is important is that the effect needs to get added
 * after the NPC's stats are set, and before the NPC enters combat.
 *
 * <p>When you add the effect, you need to give an argument.  This
 * argument tunes the effect to one of 15 different variants, depending
 * on how the fighter should use blunt, sharp, and pierce attacks, and
 * how the fighter defends itself.  Defines for the attacks are
 * USE_SHARP, USE_PIERCE, USE_BLUNT, USE_UNARMED, and USE_BALANCED.
 * Defines for the defenses are DEFEND_DODGE, DEFEND_PARRY, and 
 * DEFEND_BALANCED.  As an example, if you want a fighter who uses 
 * piercing attacks, while defending with parry, then use the following 
 * code:
 * <pre>
 *   add_effect(GOOD_FIGHTER, ({ USE_PIERCE, DEFEND_PARRY }) );
 * </pre>
 * Always put the USE_xxx before the DEFEND_xxx!
 *
 * <p>Obviously, it doesn't make a whole lot of since to set an NPC
 * to USE_UNARMED and DEFEND_PARRY unless you also give them a
 * shield.
 *
 * <p>The skills and intelligence of the NPC are driven largely by
 * the NPC's level.  The higher level an NPC is, the more special
 * commands will be available to the NPC, and the more often the NPC
 * will use these commands.
 *
 * <p>The effect applies a shadow to the NPC.  It is in that shadow
 * that nearly all the intelligence resides.
 *
 * @see /std/shadows/fighting/combat
 * @see /std/race->set_guild()
 * @see /std/race->set_level()
 * @see clone_object()
 *
 * @author Sin
 * @created 12 November 1997
 * @changed 13 November 1997 -- Sin
 *     Converted it from a pure shadow to a shadow/effect pair.
 * @changed 6 Feb 1998 -- Sin
 *     Fixed documentation, and modified effect to support the skill
 *     changeover (USE_PIERCE).
 * @changed 11 April 1998 -- Sin
 *     Changed documentation to discuss USE_UNARMED.
 */

#include "path.h"

#include <effect.h>

#define CLASS "npc.fighter"

/** @ignore yes */
string query_classification() { return CLASS; }

/** @ignore yes */
int query_indefinite() { return 1; }

/** @ignore yes */
string query_shadow_ob() { return SHADOWS "good_fighter"; }

/** @ignore yes */
void gfs(object player)
{
  player->good_fighter_setup();
}

/** @ignore yes */
int *beginning(object player, int *arg)
{
  if (!arg || !arrayp(arg) || sizeof(arg) != 2)
    arg = ({ 0, 0 });
  player->submit_ee("gfs", 1, EE_ONCE);
  return arg;
} /* beginning() */

/** @ignore yes */
void restart(object player, int *arg)
{
  beginning(player, arg);
} /* restart() */

/** @ignore yes */
int *merge_effect(object player, int *oldarg, int *newarg)
{
  return oldarg;
} /* merge_effect() */

/** @ignore yes */
void end(object player, int *arg)
{
} /* end() */
// --- END [/mnt/home2/grok/lib/std/effects/npc/good_fighter.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/npc/they_died.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/npc/they_died.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629004   Available: 13576358
Inodes: Total: 5242880    Free: 4960135
989 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/npc/they_died.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629004   Available: 13576358
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: they_died.c,v 1.1 1998/01/06 04:16:50 ceres Exp $
 * $Log: they_died.c,v $
 * Revision 1.1  1998/01/06 04:16:50  ceres
 * Initial revision
 * 
*/
/**
 * This is the effect skelton docs.  This effect
 * has a classification of "npc.death.them".
 * <p>
 * Describe the arguments in here.
 * <p>
 * This effect has a shadow associated with it.
 * @classification npc.death.them
 * @see help::effects
 */
#include <effect.h>

#include "path.h"

/*
 * Do something when an npc died.
 * 
 * The argument set on this one...  If the is a function pointer it is
 * evaluated.  If it is array, the function in position 1 is called on
 * object in position 0.  If the array is three long, and the last
 * arguement is non 0 then the second_life funciton is not called up
 * the object list...
 */
/** @ignore yes */
string query_classification() { return "npc.death.them"; }

/** @ignore yes */
string query_shadow_ob() { return SHADOWS + "they_died"; }
// --- END [/mnt/home2/grok/lib/std/effects/npc/they_died.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/npc/gossip.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/npc/gossip.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629004   Available: 13576358
Inodes: Total: 5242880    Free: 4960135
1370 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/npc/gossip.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629004   Available: 13576358
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: gossip.c,v 1.1 1998/01/06 04:16:50 ceres Exp $
 * $Log: gossip.c,v $
 * Revision 1.1  1998/01/06 04:16:50  ceres
 * Initial revision
 * 
*/
/**
 * This is the effect skelton docs.  This effect
 * has a classification of "npc.gossip".
 * <p>
 * Describe the arguments in here.
 * <p>
 * This effect has a shadow associated with it.
 * @classification npc.gossip
 * @see help::effects
 */
#include <effect.h>
#include "path.h"

/*
 * Gossip effect...  For those gossiping beggers etc.
 *
 * Simple to use.  Add it to the thingy you want to gossip...  It
 * then calls do_gossip_say(str);
 * to do the gossping.  The str is the pattern to use.  The string
 * $name$ is replaced with the name of the person who gossiped
 * and $mess$ is replaced with the message they said.
 *
 * You can do this with the standard chat strings by placing a
 * "#do_gossip_say:$name$ said: $mess$"
 * or whatever in place of a say or emote or whatever...
 *
 * See the beggars in ankh-morpork for an example.
 *
 * The specified arguement is the chance of it getting the gossip from
 * the central gossip pool.  Its one in the given number, so the higher
 * the number the less the chance...
 */
/** @ignore yes */
string query_classification() { return "npc.gossip"; }

/** @ignore yes */
string query_shadow_ob() { return SHADOWS + "gossip"; }
// --- END [/mnt/home2/grok/lib/std/effects/npc/gossip.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/npc/exit.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/npc/exit.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629003   Available: 13576357
Inodes: Total: 5242880    Free: 4960135
841 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/npc/exit.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629003   Available: 13576357
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: exit.c,v 1.1 1998/01/06 04:16:50 ceres Exp $
 * $Log: exit.c,v $
 * Revision 1.1  1998/01/06 04:16:50  ceres
 * Initial revision
 * 
*/
/**
 * This is the effect skelton docs.  This effect
 * has a classification of "npc.exit".
 * <p>
 * Describe the arguments in here.
 * <p>
 * This effect has a shadow associated with it.
 * @classification npc.exit
 * @see help::effects
 */
#include <effect.h>

#include "path.h"

/*
 * Do something when something leaves the room....
 * 
 * The argument set on this one...  If the is a function pointer it is
 * evaluated.  If it is array, the function in position 1 is called on
 * object in position 0. 
 */
/** @ignore yes */
string query_classification() { return "npc.exit"; }

/** @ignore yes */
string query_shadow_ob() { return SHADOWS + "exit"; }
// --- END [/mnt/home2/grok/lib/std/effects/npc/exit.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/npc/pub_brawl.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/npc/pub_brawl.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629003   Available: 13576357
Inodes: Total: 5242880    Free: 4960135
871 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/npc/pub_brawl.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629003   Available: 13576357
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: pub_brawl.c,v 1.1 1998/01/06 04:16:50 ceres Exp $
 * $Log: pub_brawl.c,v $
 * Revision 1.1  1998/01/06 04:16:50  ceres
 * Initial revision
 * 
*/
/**
 * This is the effect skelton docs.  This effect
 * has a classification of "npc.pub_brawl".
 * <p>
 * Describe the arguments in here.
 * <p>
 * This effect has a shadow associated with it.
 * @classification npc.pub_brawl
 * @see help::effects
 */
#include <effect.h>

#include "path.h"

/*
 * Do something when something leaves the room....
 * 
 * The argument set on this one...  If the is a function pointer it is
 * evaluated.  If it is array, the function in position 1 is called on
 * object in position 0. 
 */
/** @ignore yes */
string query_classification() { return "npc.pub_brawl"; }

/** @ignore yes */
string query_shadow_ob() { return SHADOWS + "pub_brawl"; }
// --- END [/mnt/home2/grok/lib/std/effects/npc/pub_brawl.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/fighting/bob.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/fighting/bob.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629002   Available: 13576356
Inodes: Total: 5242880    Free: 4960135
1633 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/fighting/bob.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629002   Available: 13576356
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker: pinkfish $
 * $Id: bob.c,v 1.1 2000/05/10 07:55:11 pinkfish Exp pinkfish $
 * $Log: bob.c,v $
 * Revision 1.1  2000/05/10 07:55:11  pinkfish
 * Initial revision
 *
 * Revision 1.1  1998/01/06 04:11:58  ceres
 * Initial revision
 * 
*/
/*
 * $Locker: pinkfish $
 * $Id: bob.c,v 1.1 2000/05/10 07:55:11 pinkfish Exp pinkfish $
 * $Log: bob.c,v $
 * Revision 1.1  2000/05/10 07:55:11  pinkfish
 * Initial revision
 *
 * Revision 1.1  1998/01/06 04:11:58  ceres
 * Initial revision
 * 
*/
/**
 * This is the effect skelton docs.  This effect
 * has a classification of "fighting.combat.special.punch".
 * <p>
 * Describe the arguments in here.
 * <p>
 * This effect has a shadow associated with it.
 * @classification fighting.combat.special.punch
 * @see help::effects
 */
#include "path.h"
#include <effect.h>
#include <player.h>

/** @ignore yes */
void beginning( object player, object *things, int id ) {
   tell_object( player, "You prepare to bob "+
         (string)things[ 0 ]->the_short() +".\n" );
   player->set_data( ({ "unarmed", "blunt", "hands" }) );
   player->submit_ee( 0, 10 * COMBAT_SPEED, EE_REMOVE );
} /* beginning() */

/** @ignore yes */
void end( object player, object *things, int id ) {
   if ( sizeof( things ) )
      tell_object( player, "You missed your opportunity!\n" );
} /* end() */

void restart( object player, object *things, int id ) {
   player->submit_ee( 0, 0, EE_REMOVE );
} /* restart() */

/** @ignore yes */
string query_classification() { return "fighting.combat.special.punch"; }

/** @ignore yes */
string query_shadow_ob() { return SHADOWS +"bob"; }
// --- END [/mnt/home2/grok/lib/std/effects/fighting/bob.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/attached/stat_adjustment.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/attached/stat_adjustment.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629002   Available: 13576356
Inodes: Total: 5242880    Free: 4960135
6508 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/attached/stat_adjustment.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629002   Available: 13576356
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*
 * $Locker:  $
 * $Id: stat_adjustment.c,v 1.8 2003/03/25 19:46:47 presto Exp $
 * $Log: stat_adjustment.c,v $
 * Revision 1.8  2003/03/25 19:46:47  presto
 * Forcibly released due to inactivity
 *
 * Revision 1.7  2002/02/10 18:46:14  pinkfish
 * changes that turvity and tannah suggested.
 * ./
 *
 * Revision 1.6  2000/05/09 07:51:51  pinkfish
 * Make some minior changes to how the stat adjustments work.
 *
 * Revision 1.5  2000/05/08 07:47:56  pinkfish
 * Fix up some stuff to do with a mess..
 *
 * Revision 1.4  2000/05/08 03:51:07  pinkfish
 * Fix up a bunch of problems with starting/resrtarting of effects.
 *
 * Revision 1.3  2000/05/08 01:41:05  pinkfish
 * Fix up some problems with yhow it does things.
 *
 * Revision 1.2  2000/05/07 23:32:17  pinkfish
 * Fix up a few bits of the stat adjustment code.
 *
 * Revision 1.1  2000/02/17 01:29:15  pinkfish
 * Initial revision
 *
 * 
 */
/**
 * This is the effect skelton docs.  This effect
 * has a classification of "mudlib.clothing.stat".
 * <p>
 * The argument to this effect should be a mapping with the set of
 * stat adjustments for the item and the item doing the adjusting.
 * ie: ({ ob, ([ "str" : 1, "dex" : -1 ]) })
 * <p>
 * If you add the effect with the same object twice, the new set of
 * stat adjustments overrides the old ones.
 * @classification mudlib.clothing.stat
 * @see help::effects
 * @author Pinkfish
 */
#include "path.h"
#include <effect.h>

class stat_class {
   mapping current_adjustments;
   object* obs;
   mapping* adjs;
   object me;
}

private string* _stats;

void create() {
   _stats = ({ "str", "dex", "wis", "int", "con" });
} /* create() */

/** @ignore yes */
string query_classification() { return "mudlib.clothing.stat"; }

/**
 * This method adjusts bonuses on the player based on the current
 * set of stats and things.
 * @param player the player to update the stats on
 * @param arg
 */
void update_adjustments(object player, class stat_class arg) {
   mapping stats;
   mapping bing;
   string stat;
   int i;
   int num;

   if (sizeof(arg) == 4 && arg->me != player) {
      arg->me = player;
      arg->current_adjustments = ([ ]);
   }

if (player == find_player("presto"))  printf("UPDATE: %O\n", arg);
if (player == find_player("presto"))  printf("UPDATE: %O\n", arg->obs);
   for (i = 0; i < sizeof(arg->obs); i++) {
if (player == find_player("presto"))  {
printf("%O, %d\n", arg->obs, i);
printf( "UPDATE: checkpoint 2: %O\n", arg->obs[i]);
}
      if (!arg->obs[i]) {
         arg->obs = arg->obs[0.. i -1] + arg->obs[i+1..];
         arg->adjs = arg->adjs[0.. i -1] + arg->adjs[i+1..];
      }
   }

if (player == find_player("presto"))
tell_creator("presto", "checkpoint 3\n");
   stats = ([ ]);
   foreach (stat in _stats) {
      num = 0;
      for (i = 0; i < sizeof(arg->adjs); i++) {
         bing = arg->adjs[i];
         if (bing[stat] > 0) {
            if (i > 0) {
               num += bing[stat] / (i + 1);
            } else {
               num += bing[stat];
            }
         } else if (bing[stat] < 0) {
            if (i > 1) {
               num += bing[stat] * i;
            } else {
               num += bing[stat];
            }
         } else if (i > 0) {
            num -= i;
         }
      }
/*
      if (num > 0) {
         num = num / sizeof(arg->adjs);
      }
 */
      stats[stat] = num;
   }

if (player == find_player("presto"))
tell_creator("presto", "UPDATE: checkpoint 1\n");
   foreach (stat in _stats) {
      if (stats[stat] != arg->current_adjustments[stat]) {
         call_other(player,
                    "adjust_bonus_" + stat,
                    stats[stat] - arg->current_adjustments[stat]);
         arg->current_adjustments[stat] = stats[stat];
      }
   }
} /* update_adjustments() */

/** @ignore yes */
class stat_class beginning(object player, mixed arg, int id) {
   class stat_class bing;

//log_file("STAT_EFFECT", "Added from %O\n", previous_object(-1));
   bing = new(class stat_class);
   bing->current_adjustments = ([ ]);
   bing->obs = ({ arg[0] });
   bing->adjs = ({ arg[1] });
   bing->me = player;
if (player == find_player("presto"))  printf("BEFORE: %O\n", bing);
   update_adjustments(player, bing);
if (player == find_player("presto"))
tell_creator("presto", "BEGINNING: bing == %O, player == %s\n", bing, player->short());
   return bing;
} /* begining() */

/** @ignore yes */
int query_indefinite() { return 1; }

/** @ignore yes */
class stat_class merge_effect( object player, class stat_class old_arg, mixed new_arg ) {
   int i;

//log_file("STAT_EFFECT", "Merged from %O\n", previous_object(-1));
   if (pointerp(old_arg)) {
      player->submit_ee(0, 0, EE_REMOVE);
/*
      call_out((: $1->delete_effect($2) :), player,
               player->query_current_effect_enum());
 */
      return old_arg;
   }

   i = member_array(new_arg[0], old_arg->obs);
   if (i != -1) {
      old_arg->adjs[i] = new_arg[1];
   } else {
      old_arg->obs += ({ new_arg[0] });
      old_arg->adjs += ({ new_arg[1] });
   }
   update_adjustments(player, old_arg);
   return old_arg;
} /* merge_effect() */

/** @ignore yes */
void restart( object player, class stat_class edible ) {
   update_adjustments(player, edible);
} /* restart() */

/** @ignore yes */
void quiting( object player, class stat_class womble ) {
   //womble->current_adjustments = ([ ]);
   womble->obs = ({ });
   womble->adjs = ({ });
   update_adjustments(player, womble);
} /* restart() */

/** @ignore yes */
void end( object player, class stat_class bing ) {
   bing->obs = ({ });
   bing->adjs = ({ });
   update_adjustments(player, bing);
} /* end() */

/**
 * This method is called to remove the stat adjusts for the specified
 * id.
 * @param player the player to remove the adjustments
 * @param ob the object to remove the stats
 */
void remove_stat_adjustment_ob(object player, object ob) {
   class stat_class fluff;
   int *ids;
   int i;

   ids = player->effects_matching(query_classification());
   if (sizeof(ids)) {
      fluff = player->arg_of(ids[0]);
      for (i = 0; i < sizeof(fluff->obs); i++) {
         if (fluff->obs[i] == ob) {
            fluff->adjs = fluff->adjs[0..i-1] + fluff->adjs[i+1..];
            fluff->obs = fluff->obs[0..i-1] + fluff->obs[i+1..];
         }
      }
      if (!sizeof(fluff->obs)) {
         player->delete_effect(ids[0]);
      } else {
         update_adjustments(player, fluff);
         player->set_arg_of(ids[0], fluff);
      }
   }
} /* remove_stat_adjustment_ob() */
// --- END [/mnt/home2/grok/lib/std/effects/attached/stat_adjustment.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/attached/single_shoulder.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/attached/single_shoulder.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629000   Available: 13576354
Inodes: Total: 5242880    Free: 4960135
1475 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/attached/single_shoulder.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629000   Available: 13576354
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: single_shoulder.c,v 1.4 2000/05/10 03:03:03 pinkfish Exp $
 * $Log: single_shoulder.c,v $
 * Revision 1.4  2000/05/10 03:03:03  pinkfish
 * Make sure it works correctly.
 *
 * Revision 1.3  2000/05/08 17:56:09  pinkfish
 * Fix up some runtimes.
 *
 * Revision 1.2  2000/05/08 03:55:32  pinkfish
 * *** empty log message ***
 *
 * Revision 1.1  1998/01/06 04:06:32  ceres
 * Initial revision
 * 
*/
/**
 * This is the effect skelton docs.  This effect
 * has a classification of "mudlib.clothing.single-shoulder".
 * <p>
 * Describe the arguments in here.
 * <p>
 * This effect has a shadow associated with it.
 * @classification mudlib.clothing.single-shoulder
 * @see help::effects
 */
#include "path.h"
#include <effect.h>

/** @ignore yes */
string query_classification() { return "mudlib.clothing.single-shoulder"; }

int query_indefinite() { return 1; }

/** @ignore yes */
string query_shadow_ob() { return SHADOWS +"single_shoulder"; }

/** @ignore yes */
int merge_effect( object, int old_arg, int new_arg ) {
   if (objectp(new_arg)) {
      new_arg = 0;
   }
   if (objectp(old_arg)) {
      old_arg = 0;
   }
   return old_arg + new_arg;
} /* merge_effect() */

void restart( object player, int handicap ) {
   player->adjust_bonus_dex( -handicap );
} /* restart() */

/** @ignore yes */
void end( object player, int handicap ) {
   if (intp(handicap)) {
      player->adjust_bonus_dex( handicap );
   }
} /* end() */
// --- END [/mnt/home2/grok/lib/std/effects/attached/single_shoulder.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/attached/owned_transport.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/attached/owned_transport.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628999   Available: 13576353
Inodes: Total: 5242880    Free: 4960135
4160 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/attached/owned_transport.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628999   Available: 13576353
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This effect is for the nice people who own a transport.
 * @author Pinkfish
 * @started Fri Sep 24 1:00:00 1999
 * @classification mudlib.riding.owned
 */
#include <player.h>
inherit "/std/basic/virtual_quit_control";

class riding {
   object* transport;
   string* environments;
   mixed save_stuff;
}

private nosave int _transport_id;

void create() {
   _transport_id = random(3000) + 1;
} /* create() */

/** @ignore yes */
string query_classification() {
   return "mudlib.riding.owned";
} /* query_classification() */

/** @ignore yes */
int query_indefinite() {
   return 1;
} /* query_indefinite() */

/** @ignore yes */
class riding beginning(object player, object transport, int id) {
   class riding bing;

   bing = new(class riding);
   bing->transport = ({ transport });
   bing->save_stuff = 0;
   transport->set_transport_id(_transport_id++);
   return bing;
} /* begining() */

/** @ignore yes */
class riding merge_effect(object player, class riding fluff, object transport) {
   if ( member_array(transport, fluff->transport) == -1) {
      if (!transport->query_transport_id()) {
         while(sizeof(filter(fluff->transport,
                             (: $1 && $1->query_transport_id() == $2 :),
                             _transport_id))) {
            _transport_id++;
         }
         transport->set_transport_id(_transport_id++);
      } else if (sizeof(filter(fluff->transport,
                        (: $1 && $1->query_transport_id() == $2 :),
                        transport->query_transport_id()))) {
         transport->dest_me();
         return fluff;
      }
      fluff->transport += ({ transport });
   }
   return fluff;
} /* merge_effect() */

/** @ignore yes */
void end(object player, class riding arg) {
   //tell_creator("pinkfish", "Ending owned effect...\n");
} /* end() */

/** @ignore yes */
void restart(object player, class riding bing) {
   int i;
   object* blue;
   object* green;

   //tell_creator("pinkfish", "Restart! %O\n", bing->transport);
   blue = filter(bing->transport, (: $1 :));
   if (!sizeof(blue) &&
       bing->save_stuff) {
      green = AUTO_LOAD_OB->load_auto_load_to_array(bing->save_stuff,
                                         player);
      //tell_creator("pinkfish", "Cuddles %O\n", green);
      for (i = 0; i < sizeof(bing->transport); i++) {
         if (green) {
            bing->transport[i] = green[i];
            green->move(bing->environments[i],
                        "$N appears with a puff of fluff.");
         }
      }
      //tell_creator("pinkfish", "Restart! %O\n", bing->transport);
   }
} /* restart() */

/** @ignore yes */
void clear_thingy(class riding bing) {
   bing->save_stuff = 0;
} /* clear_thingy() */

/** @ignore yes */
void saving(object player, class riding bing) {
   string *env;

   bing->transport -= ({ 0 });
   env = map(bing->transport,
             (: find_start_pos($1, environment($1)) :));
   bing->environments = map(bing->transport,
                            (: find_start_pos($1, environment($1)) :));
   bing->save_stuff = AUTO_LOAD_OB->create_auto_load( bing->transport );
   call_out( (: clear_thingy :), 2, bing);
   //tell_creator("pinkfish", "Saving %O %O\n", bing->transport, bing->environments);
} /* saving() */

/** @ignore yes */
void quiting(object player, class riding bing) {
   //tell_creator("pinkfish", "Quiting %O\n", bing->transport);
   call_out((: $1->move("/room/rubbish", 0,
                        "$N vanishes in a puff of fluff.") :),
            2, bing->transport);
} /* quiting() */

/**
 * This method removes the specified transport from the list of
 * current transports on the player.
 * @param player the player the transport is removed from
 * @param bing the class!
 * @param id the id of the effect
 * @param trans the transport to remove
 */
void remove_owner(object player, class riding bing, int id, object trans) {
//tell_creator("pinkfish", "Remove owner of %O (%O)\n", trans, player);
   bing->transport -= ({ trans });
   if (!sizeof(bing->transport)) {
      //tell_creator("pinkfish", "Deleting!\n");
      player->delete_effect(id);
   }
} /* remove_owner() */
// --- END [/mnt/home2/grok/lib/std/effects/attached/owned_transport.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/attached/talker_response.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/attached/talker_response.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628997   Available: 13576351
Inodes: Total: 5242880    Free: 4960135
916 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/attached/talker_response.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628997   Available: 13576351
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
	/**
 * Talker Response effect/shadow pair
 * @see help::talker_response shadow
 */

#include <effect.h>
#define CLASS "object.talker.response"
#define SHADOW "/std/shadows/attached/"

/** @ignore yes */
string query_classification() { return CLASS; }

int query_indefinite() { return 1; }

/** @ignore yes */
string query_shadow_ob() { return SHADOW + "talker_response"; }

/** @ignore yes */
mixed beginning( object item, mixed arg, int id )
{   
//    if(!objectp(arg)) {
//        item->delete_effect(item->sid_to_enum(id));
//        return -1;
//    }
//
//    return arg;
} /* beginning() */

mixed restart( object player, mixed arg, int id )
{
/** @ignore yes */
  return beginning(player, arg, id);
} /* restart() */

/** @ignore yes */
mixed merge_effect(object player, mixed oldarg, mixed newarg, int id)
{
	return oldarg;
}

/** @ignore yes */
void end( object player, mixed arg, int id )
{} /* end() */
// --- END [/mnt/home2/grok/lib/std/effects/attached/talker_response.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/attached/riding.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/attached/riding.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628997   Available: 13576351
Inodes: Total: 5242880    Free: 4960135
1033 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/attached/riding.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628997   Available: 13576351
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This effect is for the nice people who ride a horse.
 * @author Pinkfish
 * @started Fri Sep 24 1:00:00 1999
 * @classification mudlib.riding
 */

class riding {
   object transport;
   mixed saved_info;
}

/** @ignore yes */
string extra_look(object player) {
   return player->query_pronoun() + " is riding on " +
          environment(player)->the_short();
} /* extra_look() */

/** @ignore yes */
string query_classification() {
   return "mudlib.riding.transport";
} /* query_classification() */

/** @ignore yes */
int query_indefinate() {
   return 1;
} /* query_indefinate() */

/** @ignore yes */
class riding beginning(object player, mixed arg, int id) {
   class riding bing;

   bing = new(class riding);
   return bing;
} /* begining() */

/** @ignore yes */
class riding end(object player, class riding arg) {
} /* end() */

/** @ignore yes */
void restart(object player, class riding bing) {
   //
   // In here we should figure out if the horse has shown up and
   // then ride them...
   //
} /* restart() */
// --- END [/mnt/home2/grok/lib/std/effects/attached/riding.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/attached/living_light.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/attached/living_light.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628996   Available: 13576350
Inodes: Total: 5242880    Free: 4960135
3780 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/attached/living_light.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628996   Available: 13576350
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: living_light.c,v 1.2 2002/11/10 20:03:18 ceres Exp $
 * $Log: living_light.c,v $
 * Revision 1.2  2002/11/10 20:03:18  ceres
 * Fixed runtime
 *
 * Revision 1.1  1998/01/06 04:06:32  ceres
 * Initial revision
 * 
*/
/**
 * This is the effect skelton docs.  This effect
 * has a classification of "magic.body.light".
 * <p>
 * Describe the arguments in here.
 * @classification magic.body.light
 * @see help::effects
 */
#include "path.h"
#include <effect.h>

#define COST_PER_ROUND 30
#define INTENSITY 25

/** @ignore yes */
string query_classification() { return "magic.body.light"; }

/** @ignore yes */
int beginning( object player ) {
   tell_object( player, "A soft glow spreads out from your middle to "+
         "envelop you.\n" );
   tell_room( environment( player ), "A soft glow spreads out from "+
         (string)player->the_short() +"'s middle to envelop "+
         (string)player->query_objective() +".\n", player );
   player->adjust_light( INTENSITY );
   player->add_extra_look( this_object() );
   player->submit_ee( "decrease_points", 1, EE_ONCE );
   player->submit_ee( "decrease_points", ({ 30, 60 }), EE_CONTINUOUS );
   return INTENSITY;
} /* beginning() */

void restart( object player, int light ) {
   player->adjust_light( light );
   player->add_extra_look( this_object() );
} /* restart() */

/** @ignore yes */
int merge_effect( object player, int light ) {
   int times;
   times = sizeof( filter_array( (object *)player->query_armours(),
         "test_for_effect", this_object() ) );
   if ( light >= ( INTENSITY * times ) )
      return light;
   tell_object( player, "The light surrounding you intensifies.\n" );
   tell_room( environment( player ), "The light around "+
         (string)player->short() +" grows brighter.\n", player );
   player->adjust_light( INTENSITY );
   return light + INTENSITY;
} /* merge_effect() */

/** @ignore yes */
void end( object player, int light ) {
   tell_object( player, "The light surrounding you flickers and winks "+
         "out.\n" );
   tell_room( environment( player ), "The light around "+
         (string)player->short() +" flickers and winks out.\n", player );
   player->adjust_light( -light );
   player->remove_extra_look( this_object() );
} /* end() */

int test_for_effect( object thing ) {
   if( !thing || !thing->query_wear_effects() )
     return 0;
   
   return member_array( file_name( this_object() ),
         (string *)thing->query_wear_effects() ) != -1;
} /* test_for_effect() */

void decrease_points( object player, int light, int id ) {
   int times;
   if ( player->query_auto_loading() )
      return;
   times = sizeof( filter_array( (object *)player->query_armours(),
         "test_for_effect", this_object() ) );
   if ( !times ) {
      player->submit_ee( 0, 0, EE_REMOVE );
      return;
   }
   if ( (int)player->query_gp() < times * COST_PER_ROUND ) {
      player->submit_ee( 0, 0, EE_REMOVE );
      return;
   }
   player->clear_gp_info();
   player->adjust_gp( - times * COST_PER_ROUND );
   if ( light != ( times * INTENSITY ) ) {
      tell_object( player, "The light surrounding you flickers and "+
            "stabilises, only a little dimmer than before.\n" );
      tell_room( environment( player ), "The light around "+
         (string)player->short() +" flickers and stabilises, only a "+
         "little dimmer than before.\n", player );
      player->adjust_light( times * INTENSITY - light );
      light = times * INTENSITY;
      player->set_arg_of( (int)player->sid_to_enum( id ), light );
   }
} /* decrease_points() */

string extra_look( object player ) {
   return capitalize( (string)player->query_pronoun() ) +" is surrounded by "+
         "a soft yellow glow.\n";
} /* extra_look() */
// --- END [/mnt/home2/grok/lib/std/effects/attached/living_light.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/other/wetness.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/other/wetness.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628995   Available: 13576349
Inodes: Total: 5242880    Free: 4960135
5708 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/other/wetness.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628995   Available: 13576349
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: wetness.c,v 1.14 2002/09/24 02:30:10 presto Exp $
 * $Log: wetness.c,v $
 * Revision 1.14  2002/09/24 02:30:10  presto
 * No squelching underwater!
 *
 * Revision 1.13  2002/02/24 04:27:15  ceres
 * Stopped you drying out in waer
 *
 * Revision 1.12  2001/11/04 05:33:32  presto
 * Added another parameter to wet_string so I can get both 'wet' and 'look' to work
 * correctly.
 *
 * Revision 1.11  2001/10/02 02:30:33  presto
 * Fixed wet_string to work right.  Um, I hope.
 *
 * Revision 1.10  2001/08/20 03:06:28  presto
 * Changed the range for "slightly wet" to be 0 .. 5 rather than 1 .. 5
 *
 * Revision 1.9  2001/08/19 02:11:03  presto
 * Misspelled "extra_look" and "exta_look".  Surprisingly, it didn't work.  Also changed
 * how it decides which string to build
 *
 * Revision 1.8  2001/08/15 04:10:02  presto
 * added wet_string function to help out with the 'wet' command
 *
 * Revision 1.7  2001/06/01 21:18:17  ceres
 * Can't recall
 *
 * Revision 1.6  2000/03/03 07:11:44  ceres
 * Can't remember
 *
 * Revision 1.5  2000/01/12 00:29:31  ceres
 * Tweaked drying out.
 *
 * Revision 1.4  1999/12/31 03:19:34  pinkfish
 * Hopefully fix up a runtime in the wetness effect.
 *
 * Revision 1.3  1999/07/30 17:55:41  tannah
 * Added an initial "Squelch" in beginning() so that players never
 * get the "dry off" message without being told they were wet.
 *
 * Revision 1.2  1998/06/07 00:42:35  gruper
 * Gruper added extra_look in restart().
 *
 * Revision 1.1  1998/01/06 04:20:30  ceres
 * Initial revision
 * 
*/
/**
 * This is the effect skelton docs.  This effect
 * has a classification of "body.wetness".
 * <p>
 * Describe the arguments in here.
 * @classification body.wetness
 * @see help::effects
 */
#include "path.h"
#include <effect.h>
#include <weather.h>

#define MAX_EFFECT 200
#define MAX_DURATION 120
#define MAX_STRENGTH 240
#define MIN_STRENGTH 20

/** @ignore yes */
string query_classification() { return "body.wetness"; }

/** @ignore yes */
int beginning( object player, int wetness, int id ) {
  int dryness;
  
  tell_object( player, "Squelch.\n" );
  player->submit_ee( "squelch", ({ 20, 20 }), EE_CONTINUOUS );
  player->add_extra_look( this_object() );

  // check for magical (or other) protection from the rain.
  if(dryness = (int)player->check_dryness())
    wetness -= dryness;
  
  if ( wetness > (int)player->query_weight() )
    wetness = (int)player->query_weight();

  return wetness;
}

/** @ignore yes */
void restart( object player ) {
  player->add_extra_look( this_object() );
}

/** @ignore yes */
int merge_effect( object player, int new_wetness, int old_wetness, int id ) {
  int wetness, dryness;

  wetness = new_wetness + old_wetness;

  // check for magical (or other) protection from the rain.
  if(dryness = (int)player->check_dryness())
    wetness -= dryness;

  if ( wetness > (int)player->query_weight() )
      wetness = (int)player->query_weight();

  if ( wetness <= 0 )
    player->submit_ee(0, 0, EE_REMOVE );

  return wetness;
}

// End the effect
/** @ignore yes */
void end( object player, int strength, int id ) {
  tell_object(player, "You feel dry now.\n");
  player->remove_extra_look( this_object() );
}

void squelch(object player, int wetness, int id) {
  string loc;
  object env;
  int bingle;

  env = environment(player);

  if(!env)
    return;
  
  loc = (string)env->query_property("location");
  
  if(loc == "outside" && (int)WEATHER->query_temperature(env) > 0) {
    bingle = (int)WEATHER->query_temperature(env) / 2 +
      env->query_property("warmth");
  } else if(loc == "inside")
    bingle = (20 / 2) + env->query_property( "warmth" );
  
  if(player->query_personal_temp() / 3 > bingle)
    bingle -= (player->query_personal_temp() / 3);
  
  if(!env->query_water() && bingle > 0)
    wetness -= bingle;

  if(player->query_property("dead"))
    wetness = 0;

  if(wetness <= 0)
    player->submit_ee(0, 0, EE_REMOVE );

  if (wetness > 10 && !random(3) && !env->query_water() ) {
    tell_object(player, "Squelch.\n" );
  }
  /*  
  if ( ( ( 100 * wetness ) > ( 80 * (int)player->query_weight() ) ) &&
      !random( 1440 ) && !( player->query_creator() ) )
    player->add_effect( "/std/effects/disease/common_cold", wetness);
  */
  player->set_arg_of(player->sid_to_enum(id), wetness);
  
}

string wet_string( object player, int self ) {
  int wetness;
  int *enums;

  enums = (int *)player->effects_matching( "body.wetness" );
  if ( !sizeof( enums ) )
    return "";

  wetness = (int)player->arg_of(enums[0]);

  if (!intp(wetness)) {
     wetness = 0;
     player->submit_ee(0, 0, EE_REMOVE );
  }
  
  switch ( ( wetness * 100 ) / ( 1 +
      (int)player->query_weight() ) ) {
    case 0 .. 5 :
      if (self)
        return "look slightly wet";
      else
        return "looks slightly wet";
    case 6 .. 10 :
      if (self)
        return "look rather wet";
      else
        return "looks rather wet";
    case 11 .. 30 :
      if (self)
        return "look wet and bedraggled";
      else
        return "looks wet and bedraggled";
    case 31 .. 80 :
      if (self)
        return "are soaked and don't look that well at all";
      else
        return "is soaked and doesn't look that well at all";
    case 81 .. 100 :
      if (self)
        return "look like you have just been dunked in a lake";
      else
        return "looks like "+ player->query_pronoun() +
          " has just been dunked in a lake";
      break;
    default :
      return "";
  }
} /* extra_look() */

/** ignore yes */
string extra_look(object player)  {
   return capitalize(player->query_pronoun()) + " " + wet_string(player, 0) +
             ".\n";
}
// --- END [/mnt/home2/grok/lib/std/effects/other/wetness.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effects/basic.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effects/basic.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628994   Available: 13576348
Inodes: Total: 5242880    Free: 4960135
3319 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effects/basic.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628994   Available: 13576348
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: basic.c,v 1.1 1998/01/06 04:06:18 ceres Exp $
 * $Log: basic.c,v $
 * Revision 1.1  1998/01/06 04:06:18  ceres
 * Initial revision
 * 
*/
#include "potion_attrs.h"

int x1, x2, y1, y2;

void set_boundaries(int *min, int *max)
{
   x1 = min[0];
   x2 = max[0];
   y1 = min[1];
   y2 = max[1];
}

int *query_coordinate()
/*
 * this is for setting up potions ... say a wizard wants to put a healing
 * potion on her monster, she would put the line
 * set_ps_coord_quantity("/std/effects/cure_wounds"->query_coordinate(), 1000)
 * on it ... this one is the dumb standard one which just averages them
 * to get the midpoint
 */
{
   return ({ (x1 + x2) / 2, (y1 + y2) / 2 });
}

#pragma no_warnings
mixed *query_attrs(int *coord)
/*
 * return attrs@coord.  attrs is an array with elements as defined in
 *  include/potion_attrs.h ... definitely to be masked
 */
{
   return ({ 0, 100, ({ }), ({ }), ({ }), ({ }) });
}

int query_pass_through(int *coord)
/*
 * how much of any 'masked' effects will be passed through?
 * returns percentage 
 */
{
   return 100;
}

/* 
backdrop(int *coord)
 * if this returns true if this effect is just a 'backdrop' 
 * if it _is_ then unless it is the first effect to be found, it 
 * will _not_ be called at all.  This is so that an area can have
 * a poison defined over it as a backdrop, then wherever useful potions
 * are placed on it the backdrop potion is not used, tho any given
 * healing/whatever potion will probably pass all or most through
 */

/*
void action_drunk(object ob, int *coord, int quantity)
 * this is called when a player drinks a potion @ relevant coordinate
 */

/*
void action_touch(object ob, int *coord, int quantity)
 * this is called when an object is splashed with a potion of this effect
 */

/*
void action_smell(object ob, int *coord, int quantity)
 * this is called when a player smells the potion.  The quantity is
 * a measure of the concentration of the potion ... basically
 * the potions ps_quantity * 100 / volume
 */

/*
void action_create(object ob, int *coord, int quantity)
 * this is called when a potion is assigned the coordinate appropriate.
 * This is intended for those effects that are spontaneous upon creation ...
 * eg.  Exploding spontaneously
 *      Turning into a sludge monster
 *      Such concentrated acid that it dissolves the container its in
 *      etc
 * 'ob' is the container with the liquid in it.
 */

void install_effect()
/*
 * install potion in potion space handler dbase
 */
{
   (void)POTION_SPACE_HANDLER->remove_effect(file_name(this_object()));
   (void)POTION_SPACE_HANDLER->add_effect(file_name(this_object()), x1, x2, y1, y2);
}

int sqrt(int p)
{
   int i;
   
   for (i = 1; i < 500; i++) if (i * i > p) return i-1;
}
 
int distance_within_region(int *coord)
{
   int dx, dy;
 
   if (x1 < 0) {
      if (x2 > 0)
         dx = (coord[0] < 0) ? -coord[0] : coord[0];
      else
         dx = (x2 - coord[0]);
   } else 
      dx = coord[0] - x1;
 
   if (y1 < 0) {
      if (y2 > 0)
         dy = (coord[1] < 0) ? -coord[1] : coord[1];
      else
         dy = (y2 - coord[1]);
   } else 
      dy = coord[1] - y1;
   
   return sqrt(dx * dx + dy * dy);
}
 
int distance_from_origin(int *coord)
{
   return sqrt(coord[0] * coord[0] + coord[1] * coord[1]);
}
// --- END [/mnt/home2/grok/lib/std/effects/basic.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/learning.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/learning.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628993   Available: 13576347
Inodes: Total: 5242880    Free: 4960135
11502 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/learning.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628993   Available: 13576347
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* Higher level inheritable for learning a skill
   This could be inherited by a room or an NPC
   Belle April 2002
*/

#include <money.h>
#include <tasks.h>

class step {
  string *blurbs;
  string skill;
  int difficulty;
  string *responses;
  string *params;
  string award_mess;
  string succeed_mess;
  string fail_mess;
}

class lesson {
  mapping minimum_skills;
  mapping maximum_skills;
  string *materials;
  int cost;
  string currency;
  string *lesson_ending;
  object teacher;
  class step *plan;
}

private nosave mapping _lessons;
private nosave int current_step;
private nosave int attempt;

int lesson_response(string, object, int, string);

/**
 * Register a lesson with the learning system.
 *
 * @param name the name of the lesson
 * @param minimum_skills a mapping of skill names & bonuses that are
 *  required in order to take this lesson
 * @param maximum_skills a mapping of skill names & bonuses that are the
 *  maximum allowed to take this lesson
 * @param materials a list items required in order to take the lesson
 * @param cost the price of the lesson
 * @param currency the name of the currency required for the lesson
 * @param lesson_ending an array of strings that happen at the end the lesson to end it
 * @param teacher an optional teacher object
 * 
 */
int register_lesson(string name, mapping minimum_skills,
                    mapping maximum_skills, string *materials, int cost, 
                    string currency, string *lesson_ending, object teacher ) {
  if(!_lessons)
    _lessons = ([ ]);
  
  if(_lessons[name])
    return 0;
  
  _lessons[name] = new(class lesson,
                       minimum_skills : minimum_skills,
                       maximum_skills : maximum_skills,
                       materials : materials,
                       cost : cost,
                       currency : currency,
                       lesson_ending : lesson_ending,
                       teacher : teacher
                       );
  return 1;
}


/** 
 * Add a step to a lesson plan.  This is the interaction between student and 
 * teacher. One step should be defined for each thing you want the student
 * to learn.
 *
 * @param lesson_name the name of the lesson this lesson plan is 
 * associated with. 
 * @param blurbs An array of strings in order that they should be given 
 * during the lesson.  This is what the teacher says to the student. ', :, #, etc. 
 * can be used for say, emote and execute a command respectively.
 * @param skill The skill being learned.
 * @param difficulty The bonus level of the skill being learned.
 * @param responses An array of strings.  These are the expected responses 
 * to the teacher's blurbs.
 * @param params an array of strings given as arguments to the responses in 
 * order.
 * @param award_mess The string a player sees if they get a TM award during this step. It
 * should not end in a newline \n.
 * @param succeed_mess The string a player gets if they are successful in doing what the 
 * step asks.  It should not end in a newline \n.
 * @param fail_mess A string telling the player that they've failed.  It should not 
 * end in a newline \n.
 */
int add_step( string lesson_name, string *blurbs, string skill, int diff,
        string *responses, string *params, string award_mess, string succeed_mess, 
        string fail_mess) {

  if(!_lessons)
    _lessons = ([ ]);
  
  if( !_lessons[lesson_name] ){
    return 0;
  }
  if( !_lessons[lesson_name]->plan ){
    _lessons[lesson_name]->plan = ({ });
  }

  _lessons[lesson_name]->plan += ({ new(class step,
          blurbs : blurbs,
          skill : skill,
          difficulty : diff,
          responses : responses,
          params : params,
          award_mess : award_mess,
          succeed_mess : succeed_mess,
          fail_mess : fail_mess
          ) });
  
  return 1;
}


/** has_required_skills( string name, object player )
 * Skills: Skills and skill levels which may be necessary to learn something
 * For instance, one should learn to walk before one learns to run.  If you
 * don't have sufficient skill levels in walking, you won't be able to learn
 * how to run.
 * @param name name of the lesson they're trying to learn
 * @param player player object of the player trying to learn
 */

 
int has_required_skills( string name, object player ) {
  string skill;
  int p_level;

 // make sure the player meets the minimum skill requirements 
  foreach( skill in (keys(_lessons[name]->minimum_skills)) ){
    p_level = player->query_skill(skill);
    // debug_printf( "Skill check: Player has %d in %s.  Must be a min of %d", 
    //      p_level, skill, _lessons[name]->minimum_skills[skill]);
    if( p_level < _lessons[name]->minimum_skills[skill] ){
      // player doesn't have enough skill to learn this
      return 0;
    } 
  }
  
 // make sure the player is under the maximum skill requirements 
  foreach( skill in (keys(_lessons[name]->maximum_skills)) ){
    p_level = player->query_skill(skill);
    //debug_printf( "Skill check: Player must have a max of %d",
    //      _lessons[name]->maximum_skills[skill] );
    if( p_level > _lessons[name]->maximum_skills[skill] ){
      // player has too much skill to learn this
      return 0;
    }
  }

  return 1;
}

/** has_required_materials( string name, object player )
 *  Materials: Materials are objects which are necessary for a student to learn
 * something.  For instance, to learn to speak a language, you might need
 * a textbook. To learn to ride a horse, you might want to require a helmet.
 * @param name name of the lesson they're trying to learn
 * @param player player object of the player trying to learn
 */
int has_required_materials( string name, object player ) {
  // if it's in their inventory they have it
  string mat;
  
  foreach( mat in _lessons[name]->materials ) {
    if( sizeof( filter_array(deep_inventory(player),
           (: ($1)->query_short() :) ) ) ){
      return 1;
    }
  }
  // these are not the materials we're looking for
  return 0;
}
/** has_required_cash( string name, object player )
 * Give some, get some. Money makes a teacher more likely to teach you.
 * @param name name of the lesson they're trying to learn
 * @param player player object of the player trying to learn
 */

int has_required_cash( string name, object player ) {
  //debug_printf( "Cash check: Player has %d in %s needs to have %d", 
  //              player->query_value_in(_lessons[name]->currency), 
  //              _lessons[name]->currency, _lessons[name]->cost );
  if(player->query_value_in(_lessons[name]->currency) < _lessons[name]->cost) {
    return 0;
  } else {
    return 1;
  }
}

/**
 * This method starts a lesson for a given player.
 * @param the lesson name
 * @param the player
 */
int start_lesson(string name, object player) {
  string *needed;
    
  if(!_lessons[name])
    return notify_fail(player, "Sorry, it's not clear what you want to learn "
                "here.\n");

  needed = ({ });
  if(!has_required_skills(name, player))
    needed += ({ "skills" });
  if(!has_required_materials( name, player ))
    needed += ({ "materials" });
  if(!has_required_cash( name, player ))
    needed += ({ "cash" });

  
  if(sizeof(needed)) {
    debug_printf( "Player doesn't have the correct %s\n", 
                  query_multiple_short(needed) );
 
    return add_failed_mess("Sorry, You don't have the correct " +
                  query_multiple_short(needed) + " to learn today.\n");
  }
  
  
  // Call the lesson step function for the first step.
  call_out("lesson_step", 1, name, player, 0);
  return 1;
}

/**
 * This method returns an array of the registered lessons.
 * @return a list of lesson names.
 */
string *query_lessons() { return keys(_lessons); }

protected void lesson_step(string name, object student, int lessonstep) {
  string str;
  class step current;
  object teacher = _lessons[name]->teacher;
  int i;
  
  // The current step in the lesson plan.
  current = _lessons[name]->plan[lessonstep];
  //tell_creator( "belle", "Current lessonstep is %O\n", current );

  // register response commmand
  str = "";
  //tell_creator( "belle", "command %s\n params %s\n", current->responses[0], current->params[0] );
  //tell_creator( "belle", "Sizeof current responses is %d", sizeof(current->responses) );

  for(i=0; i<sizeof(current->responses); i++) {
    if(current->params && sizeof(current->params) > i) {
      str = " <string:'" + current->params[i] + "'>";
      //tell_creator( "belle", "Str is %s\n", str );
      student->add_command(current->responses[i], this_object(), str,
                           (: lesson_response($(name), $(student),
                                              $(lessonstep), $4) :));
      //tell_creator( "belle", "Added command %s to %O with extra string %s\n",
      //              current->responses[i], this_object(), str );
    } else {
      str = "";
      student->add_command(current->responses[i], this_object(), str,
                           (: lesson_response($(name), $(student),
                                              $(lessonstep), "") :));
      //tell_creator( "belle", "Added command %s to %O with extra string %s\n", 
      //              current->responses[i], this_object(), str );
    }
  }

  // output blurbs (via teacher if appropriate)
  foreach( str in (current->blurbs) ) {
   if( teacher )
      teacher->queue_command(str);
    else
      tell_object(student, str);
  }

}

int lesson_response(string name, object student, int lessonstep, string args) {
  class step current;
  
  // validate response
  if(this_player() != student)
    return 0;

  current = _lessons[name]->plan[lessonstep];
  //tell_creator( "belle", "Args is %O\nSizeof Current-params is %d\n", args[0], sizeof(current->params) );
  
  // If this step has response paramters we need to validate them.
  if(sizeof(current->params) && 
     member_array(args[0], current->params) == -1)
    return student->add_failed_mess(this_object(), "Invalid response.\n",
            ({ }));
  
  // perform TM check
  //tell_creator( "belle", "TM Check skill: %s diff: %d\n", current->skill, current->difficulty );
  switch(TASKER->perform_task(student, current->skill, current->difficulty,
                              TM_FIXED)) {
  case AWARD:
    // display award message
    tell_object(student, "%^YELLOW%^"+current->award_mess+"%^RESET%^\n");
    
  case SUCCEED:
    //move on.
    tell_object( student, current->succeed_mess + "\n");

    // This removes the last add_command.
    student->remove_object(this_object(), 1);

    //tell_creator( "belle", "lessonstep is %d, number of lesson steps is %d\n",
    //		  lessonstep, (sizeof(_lessons[name]->plan)-1) );
    // Is this the last step?
    if( (sizeof(_lessons[name]->plan)-1) == lessonstep ) {
      tell_creator("belle", "Lesson is on its last step: %d\n", lessonstep );
      call_out( "lesson_end", 1, name, student ); 
      return 1;
    } else {
      call_out("lesson_step", 1, name, student, ++lessonstep);
    }
    break;
    
  default:
    // repeat
    tell_object(student, current->fail_mess + "\n" );
    break;
  }
  return 1;
}

int lesson_end ( string name, object student ) {
  string str;
  object teacher = _lessons[name]->teacher;
  
  // output blurbs (via teacher if appropriate)
  foreach( str in (_lessons[name]->lesson_ending) ) {
    if( teacher )
      teacher->queue_command(str);
    else
      tell_object(student, str);
  }  
  return 1;
}
// --- END [/mnt/home2/grok/lib/std/learning.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/book.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/book.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628990   Available: 13576344
Inodes: Total: 5242880    Free: 4960135
24781 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/book.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628990   Available: 13576344
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  RCS stuff...  -*- LPC -*-
 * $Locker:  $
 *
 * $Id: book.c,v 1.39 2003/03/23 03:30:02 presto Exp $
 *
 */
/**
 * A nice book object.  A book will be a collection of pages.
 * You can tear pages out of a book, you can add pages (though adding
 * a page isnt overly useful, unless you bind it in of course).
 *<p>
 * Each page is an object.  Pages that are torn out are handled
 * as empty spots in the array.
 *<p>
 * @change 26-Feb-96 Jeremy
 * I took out the "my book" checks in test_add() and test_remove()
 * because they were keeping written pages from loading.  If
 * anyone knows why the checks were necessary, let me know.
 * @change 25-Aug-96 Jeremy
 * Changed test_add() so that it won't add things held by players.
 * This is because if they "put" something in the book, it's inaccessible
 * (maybe this is why pages had the "my book" property?  I like this
 * solution better, but not much).
 * @author Pinkfish
 */
inherit "/std/object";

#include <move_failures.h>
#include <player.h>

private mixed *_pages;
private string _default_page_object;
private object _def_p_obj;
/* Open_page set to 0 means closed. */
private int _open_page;
private int _book_num;
/*
 * If this is set, we ignore the flag and only print the real
 * short of the book.
 */
private int _ignore_open_page;
/*
 * This should be used in conjuction with created books
 * that yuou wish the contents to update when changed.
 */
private int _ignore_saved_pages;
private nosave object _player;
private nosave int _num_torn_out = -1;

protected int do_open(int page);
protected int do_tear(int number);
protected int do_turn(int number);
protected int do_close();
object create_default_page_object();

void create() {
  _pages = ({ });
  _default_page_object = "/obj/misc/paper";
  load_object(_default_page_object);
  _def_p_obj = find_object(_default_page_object);
  ::create();
  add_help_file("book");
} /* create() */

/**
 * Tells us if this is a book object.
 * @return always returns 1
 */
int query_book() { return 1; }

/**
 * @ignore yes
 * Mess with the weight to make the pages taken into account as well.
 */
int query_weight() {
   if (!_def_p_obj) {
      load_object(_default_page_object);
      _def_p_obj = find_object(_default_page_object);
   }
   return ::query_weight() +
          sizeof(filter(_pages, (: objectp($1) :))) * _def_p_obj->query_weight();
} /* query_weight() */

/**
 * Adds the commands onto the player.  The commands are "read", "open",
 * "tear", "turn" and "close".
 * @ignore yes
 */
void init() {
  add_command("open", "<direct:object>", (: do_open(1) :));
  add_command("open", "<direct:object> to [page] <number>",
              (: do_open($4[1]) :));
  add_command("tear", "page from <direct:object>", (: do_tear(1) :));
  add_command("tear", "[all] pages from <direct:object>", (: do_tear(0) :));
  add_command("tear", "<number> [of] pages from <direct:object>",
              (: do_tear($4[0]) :));
  add_command("rip", "page from <direct:object>", (: do_tear(1) :));
  add_command("rip", "<number> [of] pages from <direct:object>",
              (: do_tear($4[0]) :));
  add_command("rip", "[all] pages from <direct:object>", (: do_tear(0) :));
  add_command("turn", "[a|1] page of <direct:object>", (: do_turn(1) :));
  add_command("turn", "<number> pages of <direct:object>",
              (: do_turn($4[0]) :));
  add_command("turn", "<direct:object> to [page] <number>",
              (: do_open($4[1]) :) );
  add_command("turn", "to page <number> of <direct:object>",
              (: do_open($4[0]) :) );
  add_command("close", "<direct:object>", (: do_close() :));
} /* init() */

/**
 * @ignore yes
 */
int add_weight( int number ) {
   adjust_weight( number );
   return 1;
} /* add_weight() */

/**
 * To see if things can be added to us.  This has a few nasty
 * cludges in it to stop a few things. 
 * @see /std/basic/misc
 * @param ob the object being added
 * @param flag the flag sent to this function
 * @return 1 if it can be added, 0 if it cannot
 * @ignore
 */
int test_add(object ob, int flag) {
  return (object)ob->query_property("my book") == this_object();
  // This is a kludge to keep people from putting things in the book.
  // It's not foolproof, but it should do until I think of a better way.
/*
  if (!environment(ob) || !living(environment(ob)))
    return 1;
  return 0;
 */
} /* test_add() */

/**
 * To check to see if things can be removed from us.
 * @see /std/basic/misc
 * @param ob the object being removed
 * @param flag the flag sent to the function
 * @param dest where it is going to
 * @return 1 if it can be removed, 0 if it cannot
 * @ignore
 */
int test_remove( object ob, int flag, mixed dest ) {
  return ob->query_property("my book") != this_object();
  //return 1;
} /* test_remove() */

/**
 * Set the number of pages in the book.  If there are too many pages
 * in the book, then pages are removed from the top to create the
 * correct size and if there are too few pages then pages are
 * added onto the end of the pages array.
 * @param no the number of pages
 * @see query_pages()
 * @see query_num_pages()
 */
void set_no_pages(int no) {
  int i;
  int siz;

  siz = sizeof(_pages);
  if (no < siz) { /* removeing pages?  Oh well, if you insist. */
    _pages = _pages[0..no-1];
    if (_open_page >= no) {
      _open_page = no;
    }
  } else {
    /* Adding pages, more normal... */
    _pages = _pages + allocate(no-siz);
    for (i=siz;i<no;i++) {
      /* Set them empty and only make them real if someone wants them. */
      _pages[i] = ({ });
    }
  }
} /* set_no_pages() */

/**
 * Returns the pages array.
 * @return the array containing the pages information
 */
mixed *query_pages() { return _pages; }

/**
 * Sets the currently open page.  This does all the magic needed to make
 * the book appear as if it is the currently opened page.  If the open
 * page is 0 then the book is closed.  If it is out of the upper
 * bound then the book is opened to the last page.
 * @param i the page to open to
 * @see query_open_page()
 * @see query_current_page()
 */
void set_open_page(int i) {
  /* Valid page or already there. */
  if (i < 0 || i == _open_page) {
     return ;
  }

  if (!_open_page && i) {
    add_alias("page");
    add_plural("pages");
  }

  if (i > sizeof(_pages)) {
    _open_page = sizeof(_pages);
  } else {
    _open_page = i;
  }

  if (!_open_page) {
    remove_alias("page");
    remove_plural("pages");
  }
} /* set_open_page() */

/** 
 * What is the current open page.  Returns 0 if the book is not
 * open.
 * @return the current open page
 * @see set_open_page()
 * @see query_current_page()
 */
int query_open_page() {
   return _open_page;
} /* query_open_page() */

/**
 * This method checks to see if the current page is torn out.
 * @return 1 if torn out, 0 if not
 * @see query_current_page()
 * @see query_open_page()
 * @see is_page_torn_out()
 */
int is_current_page_torn_out() {
   if (!_open_page) {
      /* The cover cannot be torn out. */
      return 0;
   }
   if ( !_pages ) {
      return 0;
   }
     
   if (!_pages[_open_page-1]) {
      return 1;
   }
   return 0;
} /* is_current_page_torn_out() */

/**
 * This method checks to see if the specified page is torn out.
 * @param page the page number to check
 * @return 1 if it is torn out, - if not
 * @see is_current_page_torn_out()
 */
int is_page_torn_out(int page) {
   if (page < 1 || page > sizeof(_pages)) {
      return 0;
   }

   if (!_pages[page - 1]) {
      return 1;
   }
   return 0;
} /* is_page_torn_out() */

/**
 * Returns the object associated with the current open page.  If the
 * page does not actualy exist yet then the default base object
 * is returned.  This object should be handled carefully...  If the
 * page is torn out then the next readable page is returned or
 * 0 is returned.
 * @return the current page object
 * @see query_current_page_clone()
 * @see set_open_page()
 * @see query_open_page()
 * @see query_current_page_clone()
 */
object query_current_page() {
   int i;

   if (!_open_page) {
      return this_object(); /* The book itself... */
   }
   for (i = _open_page - 1; i < sizeof(_pages); i++) {
     if (_pages[i]) {
       if (!_def_p_obj) {
         load_object(_default_page_object);
         _def_p_obj = find_object(_default_page_object);
       }
       return _def_p_obj;
     }
   }
   return 0;
} /* query_current_page() */

/**
 * This function makes sure the page actually
 * exists.  If it does not exist, then it will clone one
 * up for us.  This one should be used as you will not end up with the
 * base object in this case.  If you are planning to modify the page,
 * then use this call.
 * @see query_current_page()
 * @return the object of the current page
 */
object query_current_page_clone() {
  return this_object();
} /* query_current_page_clone() */

/**
 * This method checks to see if the page is still the default page object
 * or if it is something else altogether.
 * @return 1 if it is the default page object, 0 if not
 */
int is_default_page(int num) {
   if (num > 0 && num <= sizeof(_pages)) {
      if (_pages[num - 1] &&
          !objectp(_pages[num - 1])) {
         return 1;
      }
   }
   return 0;
} /* is_default_page() */

/**
 * This method returns the contents of the selected page.  The number
 * must be greator than 0.  This will return the exact value of the
 * page, it will not search for non-torn out pages.  Becare with
 * the return value of this as the default page object might be
 * returned if the page does not actually exist.  If you need a
 * real object remember to use the clone version.
 * @param num the page to return
 * @return 0 on failure or if the page is torn out, the object on success
 */
object query_selected_page(int num) {
   if (!intp(num) || num <= 0 || num > sizeof(_pages)) {
      return 0;
   }

   if (_pages[num - 1]) {
      if (objectp(_pages[num - 1])) {
         return _pages[num - 1];
      } else {
         if (!_def_p_obj) {
            load_object(_default_page_object);
            _def_p_obj = find_object(_default_page_object);
         }
         return _def_p_obj;
      }
   }
   return 0;
} /* query_selected_page() */

/**
 * This method returns the contents of the selected page, if a default
 * object is returned a real clone for the page is created instead.
 * @param num the page to return
 * @return 0 on failure or if the page is torn out, the object on success
 */
object query_selected_page_clone(int num) {
  return this_object();
} /* query_selected_page_clone() */

/**
 * This method tears the current page out of the book and returns it
 * to us.  This object will be moved into the destination so that it is
 * no longer inside us.  If it cannot be moved of the page has already
 * been remove then the function will return 0.
 * @param dest the destination to move the page to
 * @return the torn out page, or 0 on failure
 */
object tear_current_page_out(object dest) {
  object page;

  if (is_current_page_torn_out()) {
    /* Too late... */
    return 0;
  }

  if (_pages[_open_page-1]) {
    page = clone_object(_default_page_object);
    page->add_alias("page");
    page->add_plural("pages");
    if(_pages[_open_page-1] != 1)
      page->set_read_mess(_pages[_open_page-1]);
   }

  // First remove the weight from the outside.
  if (page && page->move(dest) == MOVE_OK) {
    _pages[_open_page-1] = 0;
    return page;
  }
  return 0;
} /* tear_current_page_out() */

/**
 * This method adds a new page in after the selected page.  The pages
 * are numbered from 1, so adding a page after page 0 will place a
 * page on the start and after the last page onto the end.
 * @param page the page to add
 * @param after the page to add it after
 * @return 1 on success, 0 on failure
 * @see query_current_page()
 * @see query_num_pages()
 */
int add_page_after(object page, int after) {
   if (after < 0 || after > sizeof(_pages) + 1 ||
       !objectp(page) || !intp(after)) {
      return 0;
   }
   _pages = _pages[0..after - 1] + page->query_read_mess() + _pages[after..];
   page->move("/room/rubbish");
   return 1;
} /* add_page_after() */

/**
 * This method replaces the selected page with a new page.  The old page
 * is dested if it can be and replaced with a nice shiny new page object.
 * @param page the page to replace with
 * @param num the page number to replace
 * @return 1 on success, 0 on failure
 * @see add_page_after()
 */
int replace_page_with(object page, int num) {
   if (num < 1 || num > sizeof(_pages) ||
       !objectp(page) || !intp(num)) {
      return 0;
   }
   _pages[num-1] = page->query_read_mess();
   page->move("/room/rubbish");
} /* replace_page_with() */

/**
 * This method makes the selected page blank.  It defaults it back to a
 * default page object as if the book had just been created.
 * @param num the page to make blank
 * @see replace_page_with()
 * @see add_page_after()
 * @see add_blank_page_after()
 */
int make_page_blank(int num) {
   if (num < 1 || num > sizeof(_pages) || !intp(num)) {
      return 0;
   }
   _pages[num-1] = 1;
} /* make_page_blank() */

/**
 * @ignore yes
 */
string short(int flags) {
  if (!flags || _ignore_open_page) {
    return ::short(flags);
  }
  if (_open_page) {
    return "open " + ::short(flags);
  }
  return "closed " + ::short(flags);
} /* short() */

/**
 * This is over ridden here to allow the open/closed sttus of the book to be
 * matched.
 * @ignore yes 
 */
string *parse_command_adjectiv_id_list() {
   if (_open_page) {
      return ::parse_command_adjectiv_id_list() + ({ "open" });
   }
   return ::parse_command_adjectiv_id_list() + ({ "closed" });
} /* parse_command_adjectiv_id_list() */

/**
 * @ignore yes
 */
string long(string str, int dark) {
  string ret;
  int i;

  if (!_open_page) {
    return ::long(str, dark)+"It is closed.\n";
  }
  ret = ::long(str, dark)+"It is open at page " + _open_page + ".\n";
  for (i=_open_page-1;i<sizeof(_pages) && !_pages[i];i++) {
    if (!_pages[i]) {
      ret += "Page "+(i+1)+" has been torn out.\n";
    }
  }
  if (i >= sizeof(_pages)) {
    ret += "All the rest of the pages have been torn out!\n";
  } else {
    if (i != _open_page -1) { /* A page has been torn out... */
      ret += "You can see page "+(i+1)+" however.\n";
    }

    // Only show the page if they "look page of book" or somesuch.
    if(str && strsrch(str, "page") != -1) {
      ret += _default_page_object->long(str, dark);
    }
  }
  return ret;
} /* long() */

/**
 * Opens the book to the right place.  This is the add_command function.
 * @param indir the indirect objects (not used)
 * @param id_mactch the string matching the id (not used)
 * @param ind_match the string matching the indirect ob (not used)
 * @param args the arguments associated with the pattern
 * @param the pattern which was matched.
 * @see /global/new_parse->add_command()
 * @return 1 if it succeeded, 0 if it failed
 * @ignore yes
 */
protected int do_open(int page) {
  if (page <= 0)  {
     write("Oddly enough, the first page is page 1.\n");
     page = 1;
  }
  else if (page > sizeof(_pages))  {
     write("There " + (sizeof(_pages) == 1 ? "is only " : "are only ") +
           query_num(sizeof(_pages)) +
           (sizeof(_pages) == 1 ? " page in " : " pages in ") +
           the_short() + ".\n");
     page = sizeof(_pages);
  }
  if (query_open_page() == page) {
    add_failed_mess("The $D is already open at page " + page + ".\n");
  }
  if (_open_page > 0  &&  is_page_torn_out (page)) {
     add_failed_mess("The page " +  page + " in $D is torn out.\n");
     return 0;
  }
  _ignore_open_page = 1;
  call_out((: _ignore_open_page = 0 :), 4);
  set_open_page(page);
  add_succeeded_mess("$N $V $D to page " + page + ".\n", ({ }));
  return 1;
} /* do_open() */

/**
 * Turns a page of the book.
 * @return always returns 1
 * @ignore yes
 */
protected int do_turn(int number) {
  int tmp;

  tmp = query_open_page();
  if (tmp+number > sizeof(_pages)) {
    set_open_page(0);
    add_succeeded_mess("$N close$s $D.\n");
  } else {
    if (tmp == 0) {
       add_succeeded_mess("$N turn$s $D to page " + number + ".\n");
    }
    else add_succeeded_mess("$N turn$s " + number +
           (number > 1 ? " pages " : " page ") + "of $D.\n");
    set_open_page(tmp + number);
  }
  if (tmp == query_open_page()) {
     add_failed_mess("Unable to turn page of $D.\n", ({ }));
     return 0;
  }
  _ignore_open_page = 1;
  call_out((: _ignore_open_page = 0 :), 4);
  return 1;
} /* do_turn() */

/**
 * Closes the book.
 * @return 0 if it failed, 1 if it succeeded
 * @ignore yes
 */
protected int do_close() {
  if (!query_open_page()) {
    this_player()->add_failed_mess(this_object(), "$D is already closed.\n",
                                   ({}));
    return 0;
  }
  _ignore_open_page = 1;
  call_out((: _ignore_open_page = 0 :), 4);
  set_open_page(0);
  return 1;
} /* do_close() */

/**
 * Tears out the current page.
 * @return 0 if it failed, 1 if it succeded
 * @ignore yes
 */
int do_tear(int number) {
  int i;
 
  if (_ignore_saved_pages) {
    add_failed_mess("For some reason you cannot seem to tear any pages "
                    "from $D.\n");
    return 0;
  }
 
  if (!_open_page) {
    this_player()->add_failed_mess(this_object(), "$D is closed!\n",
                                   ({}));
    return 0;
  }

  // do all the pages.
  if(number == 0) {
    _open_page = 1;
    number = sizeof(_pages);
  }
  
  for(i=0; i<number; i++) {
    
    if(!tear_current_page_out(this_player()))
      break;
      
    if ( _open_page != sizeof( _pages ) ) {
        _open_page++;
    }
  }

  if(i) {
    if(i > 1)
      add_succeeded_mess("$N $V " + i + " pages from $D.\n");
    else
      add_succeeded_mess("$N $V a page from $D.\n");
    return 1;
  }

  return 0;
} /* do_tear() */

/* The stuff redefined for handleing books... */
/**
 * @ignore yes 
 */
varargs void set_read_mess(string str, string lang, int size) {

  if (_open_page) {
    if(pointerp(str)) {
      _pages[_open_page-1] = str;
      return;
    }
    if(str)
      _pages[_open_page-1] = ({ ({ str, 0, lang, size }) });
    else
      _pages[_open_page-1] = 1;
    return;
  }
  return ::set_read_mess(str, lang, size);
} /* set_read_mess() */

/**
 * @ignore yes 
 */
void add_read_mess(mixed str, string type, string lang, int size) {
  if(_open_page) {
    if(!arrayp(_pages[_open_page-1]))
      _pages[_open_page-1] = ({ });
    _pages[_open_page-1] += ({ ({ str, type, lang, size }) });
    return;
  }
  ::add_read_mess(str, type, lang, size);
} /* add_read_mess() */

/**
 * @ignore yes 
 */
mixed query_read_mess() {
  if (_open_page) {
    if(!_pages[_open_page-1])
      return ({ });
    return _pages[_open_page-1];
  }
  return ::query_read_mess();
} /* query_read_mess() */

/** @ignore yes */
mixed *stats() {
  return ({
    ({ "num pages" , sizeof(_pages) }),
    ({ "ignore saved pages" , _ignore_saved_pages }),
    ({ "default page ob" , _default_page_object }),
    ({ "open page", _open_page }),
    ({ "book number" , _book_num }),
  }) + ::stats();
} /* stats() */

/**
 * @ignore yes 
 */
void dest_me() {
  int i;

  for (i=0;i<sizeof(_pages);i++) {
    if (objectp(_pages[i])) {
      _pages[i]->dest_me();
    }
  }
  ::dest_me();
} /* dest_me() */

/**
 * @ignore yes 
 */
mixed query_static_auto_load() {
  if (file_name(this_object())[0..8] == "/std/book") {
    return int_query_static_auto_load();
  }
} /* query_static_auto_load() */

/**
 * @ignore yes 
 */
mapping query_dynamic_auto_load() {
  mapping bing;

  bing = ([
      "::" : ::query_dynamic_auto_load(),
      "default page object" : _default_page_object,
      "open page" : _open_page,
      "book num" : _book_num,
    ]);
  if (!_ignore_saved_pages) {
    bing["pages"] = _pages;
  }
  return bing;
} /* query_dynamic_auto_load() */

/**
 * @ignore yes 
 */
void init_dynamic_arg(mapping map, object player) {
  int i;
  object *tmp;

  if (!player) {
    player = _player;
    if (!player) {
       player = this_player();
    }
  }
  if (map["::"]) {
    ::init_dynamic_arg(map["::"]);
  }
  if (map["default page object"]) {
    _default_page_object = map["default page object"];
    load_object(_default_page_object);
    _def_p_obj = find_object(_default_page_object);
  }
  if (map["pages"] && !_ignore_saved_pages) {
    // Are we looking at an old-style book that needs converting?
    if(sizeof(map["pages"]) && sizeof(map["pages"][0]) == 3) {
      for(i=0; i<sizeof(_pages); i++) {
        tmp = (object *)player->load_auto_load_to_array(map["pages"][i],
                                                        this_object(), player);
        if(sizeof(tmp->query_read_mess()))
          _pages[i] = tmp->query_read_mess()[0];
        tmp->move("/room/rubbish");
      }
    } else
      _pages = map["pages"];
  }
  _book_num = map["book num"];
  set_open_page(map["open page"]);
} /* init_dynamic_arg() */

/**
 * Sets the object to use as the default page.  If this is not set the
 * the object /obj/misc/paper.c will be used.
 * @param ob the object to use as the default page
 */
void set_default_page_object(string obj) {
  load_object(obj);
  if (find_object(obj)) {
    _default_page_object = obj;
    _def_p_obj = find_object(obj);
  }
} /* set_default_page_object() */

/**
 * This method returns the default page object.
 * @return the default page object (as a string)
 */
string query_default_page_object() {
   return _default_page_object;
} /* query_default_page_object() */

/**
 * This method creates a new default page object for this book.  THis
 * can be used for whatever nefarious purposes you want.
 * @return a new default page object
 */
object create_default_page_object() {
   return clone_object(_default_page_object);
} /* create_default_page_object() */

/**
 * Queries the number of pages in the book.
 * @return the number of pages in the book
 * @see set_no_pages()
 */
int query_num_pages() {
  return sizeof(_pages);
} /* query_num_pages() */

/**
 * This method returns the current number of the book.  This is assigned
 * and used in conjunction with the book handler.
 * @see /obj/handlers/book_handler.c
 * @see /std/print_shop.c
 * @return the current book number
 */
int query_book_num() {
   return _book_num;
} /* query_book_num() */

/**
 * This method sets the current number of the book.  This is assigned
 * and used in conjunction with the book handler.
 * @see /obj/handlers/book_handler.c
 * @see /std/print_shop.c
 * @param num the new book number
 */
void set_book_num(int num) {
   _book_num = num;
} /* set_book_num() */

/**
 * This method returns the current setting of the ignore saved
 * pages variable.  If this is true then
 * the pages form the players auto_load stuff will be ignored totaly
 * and only the page creates in setup would be
 * used.
 * @see set_ignore_saved_pages()
 * @return the current ignore saved page attribute
 */
int query_ignore_saved_pages() {
   return _ignore_saved_pages;
} /* query_ignore_saved_pages() */

/**
 * This method sets the current setting of the ignore saved
 * pages variable.  If this is true then
 * the pages form the players auto_load stuff will be ignored totaly
 * and only the page creates in setup would be
 * used.  This can only be called from an object
 * which inherits this one (hence the protected method).
 * @param saved the new value of the saved attribute
 * @see query_ignore_saved_pages()
 */
protected void set_ignore_saved_pages(int saved) {
   _ignore_saved_pages = saved;
} /* set_ignore_saved_pages() */

/**
 * This method is called by the auto loading process to set the current
 * player on this object.
 * @param player the player to set
 * @see query_player()
 */
void set_player(object player) {
   _player = player;
} /* set_player() */

/**
 * This method will return  the player associated with the auto loading
 * process.
 * @return the player in use by the autoloading
 * @see set_player()
 */
object query_player() {
   return _player;
} /* query_player() */

/**
 * @ignore
 * This will determine the books read short, which is different to a
 * normal short because it says wild stuff about the cover and things.
 */
string query_read_short(object player, int ignore_labels) {
  if(!::query_read_short(player, 0))
    return 0;
  if (!_open_page) {
    return "the cover of " + ::query_read_short(player, 0);
  }

  return "page " + query_num(_open_page) + " of " +
    ::query_read_short(player, 1);
} /* query_read_short() */

/**
 * @ignore
 * This is overridden specifically to stop labels appearing on anything
 * but the cover.
 */
string query_readable_message(object player, int ignore_labels) {
   return ::query_readable_message(player, _open_page != 0);
} /* query_readable_message() */
// --- END [/mnt/home2/grok/lib/std/book.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/hospital.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/hospital.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628983   Available: 13576337
Inodes: Total: 5242880    Free: 4960135
43020 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/hospital.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628983   Available: 13576337
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * @main
 * This is a generalised hospital inheritable for the creation of NPCs.
 * <p>
 * The NPCs within the hospital are defined in the configuration files which
 * are parsed by the hospital. The configuration files can define zones,
 * groups and npcs.
 * <p>
 * A zone is a region of the mud. It can have any name you choose and is then
 * used as the first parameter to load_random_npc(). A zone may be made up of
 * other zones, groups and npcs.
 * 
 * <p>
 * A group is a group of NPCs. It may be made up of other groups and npcs. A
 * group has a name by which it is referenced by zones and other groups.
 * <p>
 * An npc is the definition of a specific type of NPC.
 *
 * @example
 * A typical hospital setup would look like this:
 *
 * void setup() {
 *   set_save_file(SAVE + "/hospital");
 *   set_data_directory(DATA + "/hospital");
 *   set_log_directory(LOG + "/hospital");
 *   set_npc_path(CHARS + "/hospital");
 *   set_not_replaceable(1);
 *
 *   set_short("Our hospital");
 *   set_long("This is the hospital.\n");
 * }
 *
 * @example
 * These are examples of zones, groups & npcs.
 *
 * (zone
 *   (name "desert")
 *   (busy 5)
 *   (group
 *     (name "vultures")
 *     (chance 1)
 *   )
 *   (npc
 *     ("name "lizard")
 *     (chance 1)
 *   )
 * )
 *
 * (group
 *   (name "vultures")
 *   (transient "true")
 *   (npc
 *     (name "vulture")
 *     (quantity 1 + 1d5)
 *   )
 * )
 *
 * (npc
 *   (name "vulture")
 *   (path "vulture")
 *   (transient true)
 * )
 * (npc
 *   (name "lizard")
 *   (path "lizard")
 *   (transient true)
 *   (diurnal true)
 * )
 *
 * The above configuration file defines a zone "desert". The zone has a
 * business factor of 5 which means rooms in the zone will typically get a
 * chance at cloning npcs 5% of the time (every 20 rooms).
 * <p>
 * The zone is made up of a group called "vultures" and an npc called
 * "lizard".
 * <p>
 * The vultures group is transient (ie. the NPCs will be removed from the
 * room when the player leaves the room, rather like wandering monsters) and
 * contains 1 + 1d5 "vulture" npcs.
 * <p>
 * The vulture NPC is transient and can be found in the filename "vulture.c" in
 * the path defined by set_npc_path(). The lizard NPC is also transient and
 * diurnal (it only comes out during the day) and can be found in the filename
 * "lizard.c" in the path defined by set_npc_path().
 *
 * <p>
 * @author Taffyd
 * @changed Ceres November 14th 2002<br>
 * Altered to work as a hospital for terrain NPCs especially the transient
 * ones. It now handles transient npcs as well as conditions for
 * diurnal, nocturnal and seasonal npcs.
 * @changed Pinkfish March 10th<br>
 * Major rewrite of bits to make it use a lisp like data file format.
 * @changed Carmine April 9th<br>
 * Added some alignment-generation code.
 * @started December 3, 1998.
 * @index hospital
 */

#include <armoury.h>
#include <data.h>
#include <weather.h>
#include <hospital.h>

/* Comment this out if you want to disable hospital generation
   of NPC's through the new data compiler system. */
#define CREATE_NPCS 1

// #define REGENERATE_AFTER_DEATH

inherit "/std/room";
inherit HOSPITAL_ALIGNMENT_INHERIT;

public object *load_random_npc(string zone, int wealth, int busy);
protected void load_file();
protected void save_file();
protected void set_save_file(string new_save);

public void hospital_log_file(string file, string format, mixed *args ...);
public int get_item(object destination, string *items);
public string query_save_file();
public int *query_npcs();
public mapping query_hospital_npcs();
public void add_npc_type(string type, string *data);
public void regen_after_death( object dead_npc );

private nosave string _save_file;
private nosave string _hospital_type;
private nosave mixed *_regenerated_npcs;
private nosave int _hospital_call_id;
private nosave mapping _log_file_info;
private nosave string _hospital_log_directory;
private nosave string _data_directory;
private nosave string _npc_path;
private nosave string _domain;
private nosave int _max_cache;

// Used when the system is in debug mode.
private nosave int _disable_npc_generation;

private mapping _unique_npcs;
private mapping _hospital_npcs;
private mapping _cache_inventory;

private int _last_npc_check;
private int _zone_npcs;

private mapping _group_info;
private mapping _npc_info;
private mapping _zone_info;
private mapping _path_to_npc;

// Details on the files to load.
private mapping _file_modified_time;

/** @ignore yes */
void create() {
    seteuid(master()->creator_file(file_name(this_object())));

    do_setup++;
    ::create();
    do_setup--;


    if (!_group_info) {
        _group_info = ([ ]);
    }

    if (!_npc_info) {
        _npc_info = ([ ]);
    }

    if (!_zone_info) {
        _zone_info = ([ ]);
    }

    if (!_path_to_npc) {
        _path_to_npc = ([ ]);
    }

    if (!_file_modified_time) {
        _file_modified_time = ([ ]);
    }

    if (!_unique_npcs) {
        _unique_npcs = ([ ]);
    }

    if (!_cache_inventory) {
      _cache_inventory = ([ ]);
    }
    
    _regenerated_npcs = ({ });
    _log_file_info = ([ ]);

    if(!_max_cache)
      _max_cache = DEFAULT_MAX_CACHE;
    
    if (!do_setup) {
        set_short( "Un-configured Hospital" );
        set_long("This is an unconfigured hospital.  Find the right one.\n");
        add_property("determinate", "the ");
        set_light(60);
        // Setup extra stuff if they wish
        this_object()->setup();
    }
} /* create() */

/** @ignore yes */
int ok_to_clone() {
   return 1;
} /* ok_to_clone() */ 

/**
 * This function returns an array of the gods in Ankh-Morpork
 * <p>
 */
public string *query_deities() {
   return ({ "fish", "pishe", "sek", "hat", "gapp",
      "gufnork", "sandelfon" });
}

/**
 * This function provides an interface to the armoury, selecting
 * an item at random from the 'items' array and attempting to
 * clone it.
 * <p>
 * Any items of jewellery, clothing, weapons, armour or scabbards
 * that are available in the armoury can be accessed using this
 * function.
 * <p>
 * @param destination where to place the item that is fetched
 * from the armoury.
 * @param items an array of items, of which one will be selected,
 * cloned, and then moved to destination.
 * <p>
 * @see /obj/handlers/armoury
 * @return 1 if the item was successfully created, 0 if it was not.
 */
public int get_item(object destination, string *items) {
    int i;
    object item;

    if (!objectp(destination)) {
        return 0;
    }

    while (!item) {
        i = random(sizeof(items));
        item = ARMOURY->request_item(items[i], 80 + random(21), _domain);

        if (!item) {
            item = ARMOURY->request_item(items[i], 80 + random(21) );
            if ( !item ) {
                items = items[0..i-1] + items[i+1..];
                continue;
            }
        }

        if (!sizeof(items)) {
            hospital_log_file("BROKEN_ITEMS", "Unable to select any items "
                "for %s in the Ankh-Morpork hospital.\n",
                previous_object()->short());
            break;
        }
    }

    if (objectp(item)) {
        item->move(destination);
        return 1;
    }

    return 0;
} /* get_item() */

/** @ignore yes */
protected void load_file() {
    class npc_info npc;
    class group_info group;
    string name;

    if (file_size(_save_file + ".o") > -1) {
        unguarded((: restore_object, _save_file :));
        if (!_group_info) {
            _group_info = ([ ]);
        } else {
            // Zap all the population data
            foreach (name, group in _group_info) {
                group->storage = 0;
            }
        }

        if (!_npc_info) {
            _npc_info = ([ ]);
        } else {
            // Zap all the population data
            foreach (name, npc in _npc_info) {
                npc->population = ({ });
            }
        }

        if (!_zone_info) {
            _zone_info = ([ ]);
        }

        if (!_path_to_npc) {
            _path_to_npc = ([ ]);
        }

        if (!_file_modified_time) {
            _file_modified_time = ([ ]);
        }

        if (!_unique_npcs) {
            _unique_npcs = ([ ]);
        }
    }
} /* load_file() */

/** @ignore yes */
protected void save_file() {
    unguarded((: save_object, _save_file :));
} /* save_file() */

/**
 * This method is used to set the save file for the hospital.  This
 * file is where all of the hospitals NPC data is stored while it is
 * not active and in between reboots.
 * <p>
 * If this file does not exist when the hospital is loaded, then the
 * variables will be initialised to their defaults and
 * <b>restore_default_npcs()</b> called.
 * <p>
 * @param new_save the file name to save the hospital data in
 */
protected void set_save_file(string new_save) {
    _save_file = new_save;
    load_file();
} /* set_save_file() */

/**
 * This returns the location where hospital data will be stored.
 *
 * @see set_save_file()
 */
public string query_save_file() {
    return _save_file;
} /* query_save_file() */

/**
 * This method sets the directory to scan for new files. The data directory
 * stores the configuration files for the hospital that define the zones,
 * groups and npcs.
 *
 * @param dir the directory to scan for new files
 */
void set_data_directory(string dir) {
   _data_directory = dir;
   call_out("scan_for_new_data", 2);
} /* set_data_directory() */ 

/**
 * This method returns the directory to scan for new files.
 *
 * @return the directory to scan new data
 * @see set_data_directory()
 */
string query_data_directory() {
   return _data_directory;
} /* query_data_directory() */ 

/**
 * This method sets the directory for npcs.  The filename for npcs defined
 * in the configuration files is realtive to this path.
 *
 * @param dir the director for npcs.
 */
void set_npc_path(string path) {
  _npc_path = path;
} /* set_npc_path() */ 

/**
 * This method sets the domain string used when requesting things
 * from the hospital.
 *
 * @param domain the domain name
 */
void set_domain(string domain) {
  _domain = domain;
} /* set_domain() */ 

/**
 * This method sets the maximum number of transient npcs of a given type
 * that the hospital will cache. 
 *
 * @param num the maximum number
 */
void set_max_cache(int num) {
  _max_cache = num;
} /* set_max_cache() */ 

/**
 * This method sets the flag which enables or disables npc generation. This
 * is mostly used for debugging.
 *
 * @param value the new value of the flag
 */
void set_disable_npc_generation(int value) {
   _disable_npc_generation = value;
} /* set_disable_npc_generation() */ 

/**
 * This method returns the flag that disables the npc generation.
 *
 * @return the flag that disables the npc generation
 * @see set_disable_npc_generation
 */
int query_disable_npc_generation() {
   return _disable_npc_generation;
} /* query_disable_npc_generation() */ 

/**
 * This method returns whether or not it is time to regenerate a
 * unique NPC. The regeneration time is controlled by the REGEN_TIME
 * #define.
 * <p>
 * @param who this is the name or object reference of the NPC
 * @return 1 if it is time to make the unique NPC, or 0 if it is not.
 */
public int make_unique(mixed who) {
    int delay;

    if (!_unique_npcs) {
        return 0;
    }

    if (objectp(who)) {
        who = who->query_name();
    }

    if (!_unique_npcs[who]) {
        _unique_npcs[who] = new(class unique_npc);
    }

    if ( _unique_npcs[who]->next_regen_time > time() ) {
        return 0;
    }

    if (_npc_info[who] && _npc_info[who]->delay) {
        delay = _npc_info[who]->delay;
    } else {
        delay = REGEN_TIME;
    }
    _unique_npcs[who]->next_regen_time = time() + delay;
    save_file();
    return 1;
} /* make_unique() */

/**
 * This method resets the unique status of the npc so it can be tested for
 * loading over again.
 * @param npc the name of the npc
 */
public void reset_unique(string who) {
    if (!_unique_npcs[who]) {
        return ;
    }
    _unique_npcs[who]->next_regen_time = 0;
}

#ifdef REGENERATE_AFTER_DEATH
/**
 * This method is called by the npc.death effect after an NPC that is handled
 * by the hospital has died. It tells the room where it was generated to
 * make a new NPC and to all sorts of funky things.
 * <p>
 * This is not fully implemented yet.
 */
public void regen_after_death( object dead_npc ) {
    object *monsters, destination;
    class regenerated_npc new_npc;
    int i, max;

    if ( !dead_npc )
        return;

    _regenerated_npcs += ({ new( class regenerated_npc,
        type : dead_npc->query_property("monster_type"),
        load_position : previous_object()->query_property("start location") ) });

    if ( !ok_to_clone(_hospital_type) || sizeof(_regenerated_npcs) < MINIMUM_DEATH_REGEN )
        return;

    new_npc = _regenerated_npcs[0];

    if ( !classp( new_npc ) )
        return;

    _regenerated_npcs = _regenerated_npcs[1..];

    if (!new_npc->load_position || !new_npc->type );
        return;

    max = random(5);

    for ( i = 0; i < max; i++ ){
        destination = find_object( new_npc->load_position );

        if ( !objectp( destination ) )
            return;

        monsters = get_monster(new_npc->type);
        destination->replace_monster(previous_object(), monsters);

        call_out((: $1->announce_entry($2) :), 8 + random(6), destination,
            monsters);
    }
} /* regen_after_death() */
#endif

/**
 * This method expands the path for the given npc by combining the npc_path
 * set in set_npc_path with the relative path defined in the configuration
 * file.
 *
 * @param path the path to expand
 * @return the expanded path
 */
string npc_path(string str) {
   return _npc_path + "/" + str;
} /* npc_path() */ 

/**
 * This method provides log_file() functionality but for /d/am/log
 * instead.  You should use this method to record errors and whatever
 * that are domain specific instead of using log_file().
 * @example
 * hospital_log_file("BAD_HOSPITAL_NPC", "%s: Bad NPC hospital data, %O.\n",
 * ctime(time()), _regenerated_npcs);
 * // This would log to /d/am/log/BAD_HOSPITAL_NPC.
 * @param file the file name to log to. This will have /d/am/log/
 * inserted before it.
 * @param format the text to log, can contain sprintf() format specifiers.
 * @param args the arguments for any sprintf format thingies
 */
public void hospital_log_file(string file, string format, mixed *args ...) {
    string filename;

    filename = _hospital_log_directory;

    /* We are restricted to logging in our domain, let's be neat about it. */

    if (file[0] == '/') {
        file = file[ strsrch( file, "/", -1 ) + 1 .. ];
    }

    /* Link to sefun */

    log_file( _hospital_log_directory + "/" + file, ctime(time()) + ": " + format, args ...);
} /* hospital_log_file() */

/**
 * This method sets the directory in to which hospital_log_file will
 * log by default. If the directory does not exist, then it is set to
 * DEFAULT_LOG_DIRECTORY.
 * @param new_dir the directory to log to.
 * @example
 * set_log_directory( "/d/cwc/Bes_Pelargic/log" );
 * // log directory is now /d/cwc/Bes_Pelargic/log
 * @example
 * // (cre) MacChirton: ithinkmykeyboardisbroken
 * set_log_directory( "/d/cWc/BeS_pelarGic/lrg" );
 * // Displays: "/d/cwc/hospital/bes_pelargic: Invalid log
 * // directory, defaulting to /log"
 */
protected void set_log_directory(string new_dir) {

    if (file_size(new_dir) != -2) {
        debug_printf( "%s: Invalid "
            "log directory -- defaulting to %s.\n",
            file_name( this_object() ), DEFAULT_LOG_DIRECTORY );

        new_dir = DEFAULT_LOG_DIRECTORY;
    }

    _hospital_log_directory = new_dir;
} /* set_log_directory() */

/** @ignore yes */
private void parse_zone(string fname, mapping data) {
   string name;
   class zone_info info;
   mapping bing;
   int chance;
   string* bits;

   if (!data["name"]) {
      debug_printf("No name for zone %O\n", data);
      hospital_log_file("COMPILE_ERROR", "No name for zone %O\n", data);
      return 0;
   }

   name = data["name"];
   if (data["group"] && !arrayp(data["group"])) {
      data["group"] = ({ data["group"] });
   } else if (!arrayp(data["groups"])) {
      data["group"] = ({ });
   }
   if (data["npc"] && !arrayp(data["npc"])) {
      data["npc"] = ({ data["npc"] });
   } else if (!arrayp(data["npc"])) {
      data["npc"] = ({ });
   }
   if (data["zone"] && !arrayp(data["zone"])) {
      data["zone"] = ({ data["zone"] });
   } else if (!arrayp(data["zone"])) {
      data["zone"] = ({ });
   }

   info = new(class zone_info, npcs : ([ ]), groups : ([ ]), zones : ([ ]));
   chance = 0;
   foreach (bing in data["npc"]) {
      if (!mapp(bing) || !stringp(bing["name"]) || !intp(bing["chance"])) {
         debug_printf("Invalid data for zone (%s) %O\n", name, bing);
         hospital_log_file("COMPILE_ERROR", "Invalid data for zone (%s) %O\n", name,  bing);
      } else {
         info->npcs[bing["name"]] = bing["chance"];
         chance += bing["chance"];
      }
   }
   info->npc_chance = chance;

   chance = 0;
   foreach (bing in data["group"]) {
      if (!mapp(bing) || !stringp(bing["name"]) || !intp(bing["chance"])) {
         debug_printf("Invalid data for zone (%s) %O\n", name, bing);
         hospital_log_file("COMPILE_ERROR", "Invalid data for zone (%s) %O\n", name,  bing);
      } else {
         info->groups[bing["name"]] = bing["chance"];
         chance += bing["chance"];
      }
   }
   info->group_chance = chance;

   chance = 0;
   foreach (bing in data["zone"]) {
      if (!mapp(bing) || !stringp(bing["name"]) || !intp(bing["chance"])) {
         debug_printf("Invalid data for zone (%s) %O\n", name, bing);
         hospital_log_file("COMPILE_ERROR", "Invalid data for zone (%s) %O\n", name,  bing);
      } else {
         info->zones[bing["name"]] = bing["chance"];
         chance += bing["chance"];
      }
   }
   info->zone_chance = chance;
   info->busy = data["busy"];
   
   bits = keys(data) - ({ "zone", "group", "npc", "name", "busy" });
   if (sizeof(bits)) {
      debug_printf("Unknown keys %s in zone %s\n", query_multiple_short(bits),
                   name);
      hospital_log_file("COMPILE_ERROR", "Unknown keys %s in %s\n",
                         query_multiple_short(bits), name);
   }
   _zone_info[name] = info;
   save_file();
} /* parse_zone() */

private void parse_npc(string fname, mapping data) {
   string name;
   class npc_info info;
   string* bits;

   if (!data["name"]) {
      debug_printf("No name for npc %O\n", data);
      hospital_log_file("COMPILE_ERROR", "No name for npc %O\n", data);
      return 0;
   }
   name = data["name"];
   if (!data["path"]) {
      hospital_log_file("COMPILE_ERROR", "Required path field not present for npc %s\n", name);
      return 0;
   }

   if (file_size(npc_path(data["path"]) + ".c") < 0) {
      hospital_log_file("BAD_NPC_PATH", "Bad path for npc %s (%s)\n", name, data["path"]);
   }

   if (data["command"] && !arrayp(data["command"])) {
      data["command"] = ({ data["command"] });
   }
   if (data["move_zone"] && !arrayp(data["move_zone"])) {
      data["move_zone"] = ({ data["move_zone"] });
   }

   info = new(class npc_info, move_zones : ({ }), commands : ({ }));
   info->unique = data["unique"];
   info->path = data["path"];
   info->delay = data["delay"];
   info->max_population = data["population"];
   
   if(data["transient"])
     info->transient = 1;
   if(data["nocturnal"])
     info->nocturnal = 1;
   if(data["diurnal"])
     info->diurnal = 1;
   if(data["seasonal"]) {
     if(!arrayp(data["group"]))
       info->seasonal = ({ data["seasonal"] });
     else
       info->seasonal = data["seasonal"];
   }

   if (data["move_zone"]) {
      info->move_zones = data["move_zone"];
   }
   if (data["command"]) {
      info->commands = data["commands"];
   }

   bits = keys(data) - ({ "unique", "path", "move_zone", "population", "name", "delay", "transient", "nocturnal" });
   if (sizeof(bits)) {
      debug_printf("Unknown keys %s in npc %s\n", query_multiple_short(bits),
                   name);
      hospital_log_file("COMPILE_ERROR", "Unknown keys %s in npc %s\n",
                         query_multiple_short(bits), name);
   }
   if (_path_to_npc[info->path] && _path_to_npc[info->path] != name) {
      hospital_log_file("NPC_NAME_CLASH", "NPC path %s is used by %s and %s.\n",
                         info->path, name, _path_to_npc[info->path]);
   }
   _path_to_npc[info->path] = name;
   if (_npc_info[name]) {
      info->population = _npc_info[name]->population;
      info->no_created = _npc_info[name]->no_created;
      info->no_reused = _npc_info[name]->no_reused;
      info->no_deaths = _npc_info[name]->no_deaths;
   }
   _npc_info[name] = info;
   save_file();
} /* parse_npc() */

/** @ignore yes */
private void parse_group(string fname, mapping data) {
   string name;
   class group_info info;
   mapping bing;
   int chance;
   string* bits;

   if (!data["name"]) {
      debug_printf("No name for group %O\n", data);
      hospital_log_file("COMPILE_ERROR", "No name for group %O\n", data);
      return 0;
   }

   name = data["name"];

   if (data["npc"] && !arrayp(data["npc"])) {
      data["npc"] = ({ data["npc"] });
   } else if (!arrayp(data["npc"])) {
      data["npc"] = ({ });
   }

   info = new(class group_info, npcs : ([ ]), move_zones : ({ }),
                                npc_commands : ([ ]));
   chance = 0;
   foreach (bing in data["npc"]) {
      if (!mapp(bing) || !stringp(bing["name"]) ||
          (!intp(bing["quantity"]) && !classp(bing["quantity"]))) {
         debug_printf("Invalid data for group (%s) %O\n", name, bing);
         hospital_log_file("COMPILE_ERROR", "Invalid data for group (%s) %O\n", name,  bing);
      } else {
         info->npcs[bing["name"]] = bing["quantity"];
         if (bing["command"]) {
            if (arrayp(bing["command"])) {
               info->npc_commands[bing["name"]] = bing["command"];
            } else {
               info->npc_commands[bing["name"]] = ({ bing["command"] });
            }
         }
      }
   }
   if (data["move_zone"]) {
      info->move_zones = data["move_zone"];
   }
   info->max_population = data["population"];
   info->protect = data["protect"];
   info->defend = data["defend"];
   info->transient = data["transient"];
   
   bits = keys(data) - ({ "npc", "name", "population", "move_zone", "protect", "defend", "transient", });
   if (sizeof(bits)) {
      debug_printf("Unknown keys %s in group %s\n", query_multiple_short(bits),
                   name);
      hospital_log_file("COMPILE_ERROR", "Unknown keys %s in group %s\n",
                         query_multiple_short(bits), name);
   }
   if (_group_info[name]) {
     info->storage = _group_info[name]->storage;
   }
   _group_info[name] = info;
} /* parse_group() */

/**
 * This is called by the data compiler when the system has
 * finished compiling the data file.
 * @param data the data to deal with
 */
protected void finish_compiling(string fname, mapping data) {
   mixed* bits;
   mapping thing;
   string name;

   foreach (name, bits in data) {
      switch (name) {
      case "zone" :
         foreach (thing in bits) {
            parse_zone(fname, thing);
         }
         break;
      case "npc" :
         foreach (thing in bits) {
            parse_npc(fname, thing);
         }
         break;
      case "group" :
         foreach (thing in bits) {
            parse_group(fname, thing);
         }
         break;
      default :
         debug_printf("Unknown data area %s in %s\n", name, fname);
         hospital_log_file("COMPILE_ERROR", "Unknown data area %s in %s\n", name, fname);
         break;
      }
   }

   _file_modified_time[fname] = unguarded( (: stat($(fname)) :))[1];
   save_file();
}

/**
 * This method scans through all the files and sees if anything has
 * changed.
 */
int scan_for_new_data(int force) {
  string *files;
  string fname;
  string *bits;
  
  debug_printf("Scan for new data.");
  if (unguarded( (: stat(__FILE__)[1] :)) !=
      _file_modified_time[__FILE__]) {
    _file_modified_time = ([ ]);
  }
  
  if(force) {
    _npc_info = ([ ]);
    _zone_info = ([ ]);
    _group_info = ([ ]);
  }
  
  files = ({ _data_directory });
  while (sizeof(files)) {
    fname = files[0];
    files = files[1..];
    if (unguarded( (: file_size($(fname)) :)) == -2) {
      // Directory!
      bits = get_dir(fname + "/");
      if (bits) {
        bits -= ({ "RCS", ".", ".." });
        bits = filter(bits, (: $1[0] != '.' :));
        files += map(bits, (: $2 + "/" + $1 :), fname);
      }
    } else {
      if(unguarded((: stat($(fname)) :))[1] != _file_modified_time[fname] ||
         force) {
        debug_printf("Compiling %s", fname);
        DATA_HANDLER->compile_file(fname, (: finish_compiling :));
      }
    }
  }
  _file_modified_time[__FILE__] = unguarded( (: stat(__FILE__)[1] :));
  return 1;
} /* scan_for_new_data() */

/**
 * This method rolls the dice, if a dice is specified.
 * @param dice the dice or number
 * @return the actual number
 */
int roll_dice(mixed die) {
   int result;
   int i;

   if (intp(die)) {
      return die;
   }

   if (classp(die)) {
      for (i = 0; i < die->number; i++) {
         result += random(die->die) + 1;
      }
      result += die->modifier;
      return result;
   }

   return 0;
} /* roll_dice() */ 

/**
 * This method returns the maximum population of this npc.
 * @param npc the name of the npc
 * @return the npc population
 */
int query_npc_max_population( string npc) {
   if (!_npc_info[npc]) {
      return -1;
   }

   return ((class npc_info)_npc_info[npc])->max_population;
} /* query_npc_max_population() */

/**
 * This method returns the current population of this npc
 * @param npc the name of the npc
 * @return the npc population
 */
int query_npc_current_population( string npc, int clean) {
   class npc_info data;

   if (!_npc_info[npc]) {
      return -1;
   }
   data = _npc_info[npc];

   if (!data->population) {
      data->population = children(npc_path(data->path));
      data->next_update = time() + POPULATION_UPDATE_TIME;
   }

   if (clean || data->next_update < time()) {
      data->population = filter(data->population, (: objectp($1) :));
      data->next_update = time() + POPULATION_UPDATE_TIME;
   }

   return sizeof(data->population);
} /* query_npc_current_population() */

/**
 * THis method checks to see if the number of npcs of this
 * type is under the maximum population.
 * @param npc the npc to check to see if it is under population max
 * @return 1 if is under, 0 if is not
 */
int is_npc_under_max_population(string name) {
    class npc_info info;

    info = _npc_info[name];
    if (!info) {
       return 0;
    }

    // There are no population limits for transient NPCs since they
    // are (theoretically) destroyed as soon as the players leave their
    // room.
    if(info->transient)
      return 1;

    if (info->max_population) {
       return query_npc_current_population(name, 1) < info->max_population;
    }
    return 1;
} /* is_npc_under_max_population() */

/**
 * This method checks to see if the number of npcs of this
 * type is under the maximum population.
 * @param npc the npc to check to see if it is under population max
 * @return 1 if is under, 0 if is not
 */
int is_group_under_max_population(string name) {
    class group_info group;

    group = _group_info[name];
    if (!group) {
       return 0;
    }

    if (!group->max_population || group->transient) {
       return 1;
    }

    if (!group->storage) {
        group->storage = ({ });
    } else if (group->next_update < time()) {
        group->storage = map(group->storage, (: filter($1, (: objectp($1) :)) :));
        group->storage = filter(group->storage, (: sizeof($1) :));
        group->next_update = time() + POPULATION_UPDATE_TIME;
    }
    /*
     * If we have more NPC's than the population, then stop right now.
     */
    if (sizeof(group->storage) >= group->max_population) {
        return 0;
    }
    return 1;
} /* is_group_under_max_population() */

/**
 * This method loads the specific npc.  It will do everything it needs
 * to create the npc.  In the case of unique npcs they are not cloned.
 * @param npc_name the name of the npc to load
 * @return the npc object
 */
public object load_npc_object(string npc_name) {
    class npc_info info;
    object npc;
    string zone;
    string cmd;

    if ( undefinedp(_npc_info[npc_name])) {
        debug_printf("Unable to find npc %O", npc_name);
        return 0;
    }

    info = _npc_info[npc_name];

    // Validity checks for given NPCs.
    if(info->diurnal && !WEATHER->query_day(previous_object()))
      return 0;
    if(info->nocturnal && !WEATHER->query_day(previous_object()))
      return 0;
    if(info->seasonal &&
       member_array(WEATHER->query_season(), info->seasonal) == -1)
      return 0;
    
    if (stringp(info->path)) {
        if ( info->unique ) {
            npc = find_object( npc_path(info->path) );
            if ((!npc || !environment(npc)) && make_unique(npc_name)) {
               debug_printf("Unique npc %O", info);
               if (catch(npc = load_object( npc_path(info->path) ))) {
                   hospital_log_file("BAD_NPC_PATH", "Error loading %s (%s)\n", npc_name, info->path);
                   return 0;
               }
               if (!objectp(npc) || npc == 0) {
                   hospital_log_file("BAD_NPC_PATH", "Failed to load %s (%s)\n", npc_name, info->path);
                   return 0;
               }

               /* If the NPC has an environment, then we have to
                  bail because the NPC is already loaded somewhere. */

               if ( environment( npc ) ) {
                   debug_printf("NPC unique and already exists %O", npc_name);
                   return 0;
               }
            }
        } else if(info->transient) {
          if(!_cache_inventory)
            _cache_inventory = ([ ]);
          else if(_cache_inventory[npc_name])
            _cache_inventory[npc_name] -= ({ 0 });
          
          if(sizeof(_cache_inventory[npc_name])) {
            npc = _cache_inventory[npc_name][0];
            _cache_inventory[npc_name] -= ({ npc });
            info->no_reused++;
          } else {
            npc = clone_object( npc_path(info->path) );
            if(npc) {
              npc->add_property("transient", 1);
              npc->add_property("npc_id", npc_name);
              npc->add_property("hospital", base_name(this_object()));
              info->no_created++;
            } else
              debug_printf("Failed to clone %s", npc_path(info->path));
          }
        } else {
            if (is_npc_under_max_population(npc_name)) {
               npc = clone_object( npc_path(info->path) );
               info->no_created++;
               if (!npc) {
                  debug_printf("Npc path does not exist %O (%O)", npc, npc_path(info->path));
               }
            } else {
               debug_printf("NPC over max population %O", npc_name);
            }
        }
    } else {
        debug_printf("Broken npc data %O", info->path);
        return 0;
    }

    if (npc && !info->transient) {
        if( info->population == 0 )
            info->population = ({ });
        info->population += ({ npc });
        npc->add_property("npc_id", npc_name);
        foreach (zone in info->move_zones) {
            npc->add_move_zone(zone);
        }
        foreach (cmd in info->commands) {
            npc->init_command(cmd, 2);
        }
    }

    return npc;
} /* load_npc_object() */

/**
 * This method creates the npcs for the specificed group of npcs.
 * @param group_name the name of the group
 * @return the npcs
 */
public object *load_group_npcs(string group_name) {
    class group_info group;
    int quantity;
    int i;
    object *npcs;
    string npc_name;
    object ob;
    object ob_bing;
    string cmd;

    if ( undefinedp(_group_info[group_name]) ||
         !is_group_under_max_population(group_name)) {
        return 0;
    }

    group = _group_info[group_name];

    /* Determine the population from the class, if this is undefined
     * then we make set it to DEFAULT_POPULATION.
     */

    npcs = ({ });
    foreach (npc_name, quantity in group->npcs) {
        quantity = roll_dice(quantity);
        for (i = 0; i < quantity; i++) {
            // If we have a problem loading one.  Dest them all.
            ob = load_npc_object(npc_name);
            if (!ob) {
               npcs->move("/room/rubbish");
               return ({ });
            }
            npcs += ({ ob });
            if (group->npc_commands[npc_name]) {
               foreach (cmd in group->npc_commands[npc_name]) {
                  ob->init_command(cmd, 2);
               }
            }
        }
    }

    if (!group->storage) {
        group->storage = ({ });
    }

    group->storage += ({ npcs });

    npcs->add_property("group_id", group_name);
    // Do any extra stuff on the npcs.
    foreach (ob in npcs) {
       foreach (ob_bing in npcs) {
          if (ob != ob_bing) {
             ob->add_follower(ob_bing);
             if (group->defend) {
               ob->add_defender(ob_bing);
             }
             if (group->protect) {
                ob->add_protector(ob_bing);
             }
          }
       }
    }

    return npcs;
} /* load_group_npcs() */

/**
 * This returns the npc info class for the npc in question.  THis should
 * only be used for debugging.
 * @param npc the name of the npc to get the info on
 * @return the class of the npc
 */
public class npc_info query_npc_info( string npc ) {
    if ( !_npc_info ) {
        return 0;
    }

    return _npc_info[ npc ];
} /* get_npc_info() */

/**
 * This returns all the npcs in the debug data array.
 * @return this returns the debug information for the npcs
 */
mapping query_debug_npc_info() {
   return _npc_info;
}

/**
 * This returns the group info class for the group in question.  THis should
 * only be used for debugging.
 * @param group the name of the group to get the info on
 * @return the class of the group
 */
public class group_info query_group_info( string group ) {
    if ( !_group_info ) {
        return 0;
    }

    return _group_info[ group ];
} /* query_group_info() */

/**
 * This method is called when a specific npc dies so we can do some
 * tracking on it.
 * @param npc_ob the npc object
 */
void npc_died(object ob) {
   string npc_id;
   class npc_info info;
   int i;
   mixed* stuff;

   npc_id = ob->query_property("npc_id");
   info = _npc_info[npc_id];
   if (!info || !npc_id) {
      return ;
   }

   info->population -= ({ ob });
   info->no_deaths++;

   // Find the npc in thr group if it is set.
   npc_id = ob->query_property("group_id");
   stuff = _group_info[npc_id]->storage;
   if (sizeof(stuff)) {
      for (i = 0; i < sizeof(stuff); i++) {
         stuff[i] -= ({ ob, 0 });
      }
      _group_info[npc_id]->storage = filter(_group_info[npc_id]->storage,
                                             (: sizeof($1) :));
   }
} /* npc_died() */

/** @ignore yes */
mapping query_all_npc_info() {
   return _npc_info;
} /* query_all_npc_info() */ 

/** @ignore yes */
mapping query_all_group_info() {
   return _group_info;
} /* query_all_group_info() */ 

/** @ignore yes */
mapping query_all_zone_info() {
   return _zone_info;
} /* query_all_zone_info() */ 

private int count_chances_in_zone(string zone) {
    class zone_info info;
    int chance;

    info = _zone_info[zone];
    if (!zone) {
       return 0;
    }

    chance = info->npc_chance + info->group_chance + info->zone_chance;
    return chance;
} /* count_chance_in_zone() */

private object* create_npcs_in_zone(string zone, int pos) {
    class zone_info info;
    string extra;
    string npc;
    object ob;
    object* obs;
    int chance;

    info = _zone_info[zone];
    if (!zone) {
       return ({ });
    }

    if (pos < info->npc_chance) {
       foreach (npc, chance in info->npcs) {
          if (pos < chance) {
             ob = load_npc_object(npc);
             if (ob) {
               if(environment(ob) == this_object())
                 debug_printf("Reused %s in %s", npc, zone);
               else
                 debug_printf("Created %s in %s", npc, zone);
                return ({ ob });
             }
          }
          pos -= chance;
       }
    }
    pos -= info->npc_chance;
    if (pos < info->group_chance) {
       foreach (npc, chance in info->groups) {
          if (pos < chance) {
             obs = load_group_npcs(npc);
             if (sizeof(obs)) {
                return obs;
             }
          }
          pos -= chance;
       }
    }
    pos -= info->group_chance;
    foreach (extra, chance in info->zones) {
        if (pos < chance) {
           return load_random_npc(extra, -1, -1);
        }
    }
    return ({ });
} /* create_npcs_in_zone() */

/**
 * This method randomly selects an NPC or a group of NPC's from
 * the list of defined NPC's for the room/region.
 *
 * @param zone This is a zone (as defined in the configuration files).
 * @param wealth How wealthy this particular part of this zone is.
 * @param busy How busy this particular part of this zone is.
 * 
 * @return Returns a group of NPCs randomly selected.
 */
public object *load_random_npc(string zone, int wealth, int busy) {
    int chance;
    int pos;

    if (_disable_npc_generation) {
        return ({ });
    }

    //
    // Try and see if we can find a specific zone for the
    // busyness/wealth of this zone
    //
    if (_zone_info[zone + "-w" + wealth + "-b" + busy]) {
       zone = zone + "-w" + wealth + "-b" + busy;
    } else if (_zone_info[zone + "-w" + wealth]) {
       zone = zone + "-w" + wealth;
    } else if (_zone_info[zone + "-b" + busy]) {
       zone = zone + "-b" + busy;
    }

    if (!_zone_info[zone]) {
        return ({ });
    }

    if(_zone_info[zone]->busy &&
       _zone_info[zone]->busy < random(random(100)))
      return ({ });

    chance = count_chances_in_zone(zone);
    if (!chance) {
       return ({ });
    }
    pos = random(chance);
    return create_npcs_in_zone(zone, pos);
} /* load_random_npc() */

/**
 * Prints a report of all the npcs in the hospital currently.
 */
int do_report() {
    string name;
    class group_info group;
    class npc_info npc;
    string txt;
    int total;
    int max;
    int pop;

    txt = "";
    total = 0;

    txt += "%^WHITE%^NPCs%^RESET%^\n";
    foreach( name, npc in _npc_info ) {
      // Otherwise we can't get any real stats. :(
      reset_eval_cost();
      if(stringp(npc->path) && file_size(npc_path(npc->path) + ".c") > 0) {
        pop = query_npc_current_population(name, 0);
      } else {
        pop = 0;
      }
      if(npc->transient)
        txt += sprintf( "$I$5=Name: %s. (%s) (Transient) Reused %d Created %d Died %d\n", name + "",
                        (stringp(npc->path)?npc->path:"Broken!"),
                        npc->no_reused, npc->no_created, npc->no_deaths);
      else
        txt += sprintf( "$I$5=Name: %s. (%s) Population: (%d/%d) Created %d Died %d\n", name + "",
                        (stringp(npc->path)?npc->path:"Broken!"),
            pop, npc->max_population, npc->no_created, npc->no_deaths );
        total += pop;
        max += npc->max_population;
    }

    txt += "$I$0=%^WHITE%^Groups%^RESET%^\n";
    foreach( name, group in _group_info ) {
      if(group->transient)
        txt += sprintf( "$I$5=Name: %s. (%s) (Transient)\n", name,
            query_multiple_short(keys(group->npcs)));
      else
        txt += sprintf( "$I$5=Name: %s. (%s) Population: (%d/%d)\n", name,
            query_multiple_short(keys(group->npcs)),
            sizeof( group->storage ), group->max_population );
    }

    txt += "$I$0=%^WHITE%^Cache%^RESET%^\n";
    foreach(name in keys(_cache_inventory))
      _cache_inventory[name] -= ({ 0 });
      
    foreach(name, group in _cache_inventory)
      txt += sprintf("$I$5=Name: %s %d\n", name, sizeof(group));

    txt += "\nTotal NPCs in hospital: " + total + "/" +
            max + ".\n";
    write("$P$Report$P$" + txt );

    return 1;

} /* create_hospital_report() */

/** @ignore yes */
void init() {
  object ob;
  ob = this_player();

  add_command("report", "", (: do_report :));
  add_command("scan", "", (: scan_for_new_data :));
  
  // Add returning npcs to our cache.
  if(ob->query_property("npc_id") && ob->query_property("hospital") &&
     ob->query_property("hospital") == base_name(this_object())) {
    if(!_cache_inventory[ob->query_property("npc_id")])
      _cache_inventory[ob->query_property("npc_id")] = ({ ob });
    else if(sizeof(_cache_inventory[ob->query_property("npc_id")]) >
            _max_cache)
      ob->move("/room/rubbish");
    else
      _cache_inventory[ob->query_property("npc_id")] += ({ ob });
  } else if(base_name(ob) == "/obj/corpse")
    ob->move("/room/rubbish");

} /* init() */

/** @ignore yes */
int no_attack() { return 1; }

/** @ignore yes */
mapping query_dynamic_auto_load() {
    string group_name;
    string npc;
    class group_info data;
    class npc_info npc_data;
    mapping tmp;
    mapping tmp2;

    tmp = allocate_mapping( sizeof( _group_info ) );

    foreach( group_name, data in _group_info ) {
        tmp[ group_name ] = data->storage;
    }

    tmp2 = allocate_mapping( sizeof( _npc_info) );
    foreach( npc, npc_data in _npc_info ) {
        tmp2[ npc ] = npc_data->population;
    }

    return ([ file_name( this_object() ) : tmp, "npcs" : tmp2 ]);

} /* query_dynamic_auto_load() */

/** @ignore yes */
void init_dynamic_arg( mapping tmp ) {
    string group_name;
    object *npcs;

    if ( tmp[ file_name( this_object() ) ] ) {
        foreach( group_name, npcs in tmp[ file_name( this_object() ) ] ) {
            if (_group_info[group_name]) {
               _group_info[ group_name ]->storage = npcs;
            }
        }
        foreach( group_name, npcs in tmp[ "npcs" ]) {
            if (_npc_info[group_name]) {
               _npc_info[ group_name ]->population = npcs;
            }
        }
    }
} /* init_dynamic_arg() */

/** @ignore yes
 * This is a debugging function. Beware, if you have a large hospital this
 * may lockup/crash the mud!
 */
mixed query_all_npcs() {
    return values( map( _group_info, (: $2->storage :) ) );
}
/** @ignore yes
 * This is a debugging function.
 */
mapping query_inventory_cache() {
  return copy(_cache_inventory);
}

/**
 * This function returns the ids of all the NPCs which are registered with the 
 * hospital, ie the ones that have to be specified with add_hospital_npc().
 *
 * @return All the ids.
 */
string* query_registered_npcs() {
    return keys( _npc_info );
} /* string* query_registered_npcs() */
// --- END [/mnt/home2/grok/lib/std/hospital.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/npc/goals/basic/stay_alive.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/npc/goals/basic/stay_alive.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628973   Available: 13576327
Inodes: Total: 5242880    Free: 4960135
797 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/npc/goals/basic/stay_alive.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628973   Available: 13576327
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is the very basic stay alive goal.  It will attempt to keep the npc
 * alive if they are being beaten up by someone.  All this goal will do is
 * cause the npc to run away, and attempt to stop the player from following
 * them.  This is exactly the same as the previous wimpy code.
 * @author Pinkfish
 * @started Sat Aug  1 18:15:30 PDT 1998
 */
#include <goals.h>

inherit BASE_GOAL;

void create() {
   ::create();
   // All keep alive goals should be at a high priority.
   set_default_priority(GOAL_HIGH_PRIORITY);
   add_default_plan(EVENT_HP_LOST,
                    GOAL_PLAN_DIR + "basic/run_away");
   // This method will only lose people attacking them.
   add_default_plan(EVENT_PLAN_FINISHED,
                    GOAL_PLAN_DIR + "basic/lose_attackers");
} /* create() */
// --- END [/mnt/home2/grok/lib/std/npc/goals/basic/stay_alive.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/npc/goals/basic/stay_alive_basic.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/npc/goals/basic/stay_alive_basic.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628972   Available: 13576326
Inodes: Total: 5242880    Free: 4960135
1755 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/npc/goals/basic/stay_alive_basic.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628972   Available: 13576326
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is the very basic stay alive goal.  It will attempt to keep the npc
 * alive if they are being beaten up by someone.  All this goal will do is
 * cause the npc to run away, and attempt to stop the player from following
 * them.  This is exactly the same as the previous wimpy code.
 * @author Pinkfish
 * @started Sat Aug  1 18:15:30 PDT 1998
 */
#include <npc/goals.h>
#include <npc/events.h>
#include <npc/plan.h>

inherit GOAL_BASE_INHERIT;

/** @ignore yes */
void setup() {
   // All keep alive goals should be at a high priority.
   set_default_priority(GOAL_HIGH_PRIORITY);
   add_default_plan(EVENT_LOSE_HPS,
                    PLAN_DIR + "basic/run_away");

   // This method will only lose people attacking them.
   /*
   add_default_plan(EVENT_PLAN_FINISHED,
                    PLAN_DIR + "basic/lose_attackers");
    */
} /* setup() */

/**
 * This goal is never completed...
 * @ignore yes
 */
int invarient(object npc) {
   return 1;
} /* invarient() */

/**
 * This setups all the goal specific stuff for this goal.  In the case of
 * this goal, the data is the wimpy value.
 * @param npc the npc the goal is being added to
 * @param goal_name the name of the goal
 * @param stuff the parameter passed in by the creator
 * @return any specific information to store in the goal data
 * @ignore yes
 */
mixed initialise_plans(object npc, 
                       string goal_name,
                       int wimpy) {
tell_creator("pinkfish", "Initialise_plans(%O, %O, %O)\n", npc, goal_name, wimpy);
   /* Setup the wimpy values for the run away plan. */
   npc->set_goal_plan_data(goal_name, 
                           PLAN_DIR + "basic/run_away",
                           wimpy);
   return wimpy;
} /* create_goal_data() */
// --- END [/mnt/home2/grok/lib/std/npc/goals/basic/stay_alive_basic.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/npc/goals/base.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/npc/goals/base.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628972   Available: 13576326
Inodes: Total: 5242880    Free: 4960135
9622 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/npc/goals/base.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628972   Available: 13576326
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * The standard base for all the npc goals.  This should be inherited into
 * every goal.  The methods can be overridden is specific behaviour of some
 * sort is required.
 * @author Pinkfish
 * @started Thu Jul 30 18:17:35 PDT 1998
 */

#include <npc/goals.h>

private mapping _default_plans;
private int _default_priority;

#define GOAL_PLAN_ARRAY_SIZE 1
#define GOAL_PLAN_PLAN 0

/** @ignore yes */
void setup() {
} /* setup() */

void create() {
   _default_plans = ([ ]);
   _default_priority = GOAL_INVALID_PRIORITY;
   setup();
} /* create() */

/**
 * This method initialises all the plans associated with this goal.  It
 * should be overridden by the higher level objects to allow them to
 * initialise the plans and stuff.
 * @param npc the npc the goal is on
 * @param goal_name the name of the goal
 * @param control the control data
 */
void initialise_plans(object npc,
                      string goal_name,
                      mixed data) {
} /* initialise_plans() */

/**
 * This method initialises the goal.  It sets up all the call back
 * events and anything that needs to be done at startup.  This method will
 * also call the initialise_plan() method to setup all the default
 * plan information for this goal.
 * @param npc the npc to initialise
 * @param goal_name the name of the goal
 * @param control the control data
 */
void initialise(object npc, 
                string goal_name,
                class goal_control control) {
   string name;

   foreach (name in keys(_default_plans)) {
tell_creator("pinkfish", "Adding event hook for %O\n", name);
      npc->add_goal_event(base_name(this_object()), name);
   }

   foreach (name in keys(control->extra_plans)) {
      npc->add_goal_event(base_name(this_object()), name);
   }

   initialise_plans(npc, goal_name, control->data);
} /* initialise() */

/**
 * This method returns the current plan associated with the goal control
 * for this goal.
 * @param npc the npc the goal is operating on
 * @param control the goal control class
 */
string query_current_plan(object npc, 
                          class goal_control control) {
   return control->current_plan;
} /* query_current_plan() */

/**
 * This method is used to create the plan specific data.
 * @param npc the npc that the goal is being setup on
 * @param goal_name the noralised name of the goal
 * @param stuff the information passed in when the goal was created
 * @return the data used by the goal
 */
mixed create_goal_data(object npc,
                       string goal_name,
                       mixed stuff) {
   return stuff;
} /* create_goal_data() */

/**
 * This method creats a goal control class with any of the extra bits that are
 * required.  The extra plans are a mapping which is indexed on the event
 * name and contains values which are the plans to use for that goal.
 * @param npc the npc creating the goal
 * @param extra_plans the extra plans needed for this npc
 * @param stuff the startup goal data
 * @return the class to use as an initial argument to the goal
 */
void add_goal_to_npc(object npc,
                     mapping extra_plans,
		     mixed stuff) {
   class goal_control frog;
   mixed value;
   string goal_name;

tell_creator("pinkfish", "Adding goal %O to npc(%O).\n", base_name(this_object()), stuff);
   if (!mapp(extra_plans)) {
      extra_plans = ([ ]);
   }
   goal_name = base_name(this_object());
   frog = new(class goal_control);
   frog->extra_plans = extra_plans;
   frog->current_plan = 0;
   frog->priority = GOAL_DEFAULT_PRIORITY;
   frog->data = create_goal_data(npc, goal_name, stuff);
   frog->plan_info = ([ ]);
   npc->add_goal(goal_name, frog);
} /* add_goal_to_npc() */

/**
 * This method returns the current priority for the goal.
 * @param npc the npc the goal is linked to
 * @param control the control information for the goal
 * @return the priority of the goal
 */
int query_priority(object npc,
                   class goal_control control) {
   if (control->priority != GOAL_DEFAULT_PRIORITY) {
      return control->priority;
   }
   return _default_priority;
} /* query_priority() */

/**
 * This method returns the default priority for the goal.
 * @return the default priority
 */
int query_default_priority() {
   return _default_priority;
} /* query_default_priority() */

/**
 * This method sets the default priority for the goal.
 * @param priority the new default priority
 */
protected void set_default_priority(int priority) {
   _default_priority = priority;
} /* set_default_priority() */

/**
 * This method handles an incoming event and will see which of the
 * possible plans might need to be setup to run.
 * @param event_name the name of the event
 * @return notification of the event handling
 */
int notify_of_event(object npc,
                    class goal_control control,
                    string event,
                    mixed *data) {
   int value;
   string plan;
   int max_value;
   string max_plan;
   mixed max_data;
   int i;
   mixed info;

   /* Check the extra known plans for sutability. */
   if (control->extra_plans[event]) {
      for (i = 0; i < sizeof(control->extra_plans[event]);
           i += GOAL_PLAN_ARRAY_SIZE) {
         plan = control->extra_plans[event][i + GOAL_PLAN_PLAN];
         info = control->plan_info[plan];
         if (plan->pre_condition(npc,
                                 base_name(this_object()),
                                 info,
                                 event,
                                 data)) {
            value = plan->query_sutability(npc,
                                           base_name(this_object()),
                                           info,
                                           event,
                                           data);
            if (value > max_value) {
               max_value = value;
               max_plan = plan;
               max_data = plan->query_data(npc,
                                           base_name(this_object()),
                                           info,
                                           event,
                                           data);
            }
         }
      }
   }

   /* Check the default plans for sutability. */
   if (_default_plans[event]) {
      for (i = 0; 
           i < sizeof(_default_plans[event]);
           i += GOAL_PLAN_ARRAY_SIZE) {
         plan = _default_plans[event][i + GOAL_PLAN_PLAN];
         info = control->plan_info[plan];
         if (plan->pre_condition(npc,
                                 base_name(this_object()),
                                 info,
                                 event,
                                 data)) {
            value = plan->query_sutability(npc,
                                           base_name(this_object()),
                                           info,
                                           event,
                                           data);
            if (value > max_value) {
               max_value = value;
               max_plan = plan;
               max_data = plan->query_data(npc,
                                           base_name(this_object()),
                                           info,
                                           event,
                                           data);
            }
         }
      }
   }

   /* If we found a plan to activate, activate it. */
   if (max_plan) {
      // Allow plans to modify their priority up and down a bit.
      return npc->activate_plan(max_plan,
                                base_name(this_object()),
                                query_priority(npc, control) + 
                                   max_plan->query_priority_offset(),
                                max_data);
   }
   return GOAL_EVENT_NOT_HANDLED;
} /* notify_of_event() */

/**
 * This method returns the known set of default plans for the goal.
 * @return the default known plans
 */
mapping query_default_plans() {
   return _default_plans;
} /* query_default_plans() */

/**
 * This method adds a default plan to the currently known list of plans.
 * @param event_name the name of the event to trigger the plan on
 * @param plan the name of the plan to add
 * @param activate the function pointer to create the data for the plan
 */
protected void add_default_plan(string event_name,
                                string plan) {
   if (!_default_plans[event_name]) {
      _default_plans[event_name] = ({ plan });
   } else if (member_array(plan, _default_plans[event_name]) == -1) {
      _default_plans[event_name] += ({ plan });
   }
} /* add_default_plan() */

/**
 * This method changes the data associated with the plan for the particular
 * npc and goal.
 * @param npc the npc that the goal is on
 * @param control the data associated with the goal
 * @param plan the name of the plan to setup
 * @param plan_data the data to set for the plan
 */
void set_plan_data(object npc,
                   class goal_control control,
                   string plan,
                   mixed plan_data) {
   control->plan_info[plan] = plan_data;
} /* set_plan_data() */

/**
 * This method returns the data associated withthe plan for the particular
 * npc and goal.
 * @param npc the npc the goal is on
 * @param control the control data for the goal
 * @param plan the name of the plan to setup
 * @param plan_data the data to set for the plan
 */
mixed query_plan_data(object npc,
                      class goal_control control,
                      string plan) {
   return control->plan_info[plan];
} /* query_plan_data() */
// --- END [/mnt/home2/grok/lib/std/npc/goals/base.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/npc/goals/misc/get_drunk.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/npc/goals/misc/get_drunk.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628969   Available: 13576323
Inodes: Total: 5242880    Free: 4960135
1565 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/npc/goals/misc/get_drunk.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628969   Available: 13576323
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This goal tries to get the npc as drunk as they possibly can be.
 * @author Pinkfish
 * @started Sat Feb 27 19:14:58 EST 1999
 */
#include <npc/goals.h>
#include <npc/events.h>
#include <npc/plan.h>

inherit GOAL_BASE_INHERIT;

/** @ignore yes */
void setup() {
   // All keep alive goals should be at a high priority.
   set_default_priority(GOAL_LOW_PRIORITY);
   add_default_plan(EVENT_GIVEN_MONEY,
                    PLAN_DIR + "control/goto_location");

   // This method will only lose people attacking them.
   /*
   add_default_plan(EVENT_PLAN_FINISHED,
                    PLAN_DIR + "basic/lose_attackers");
    */
} /* setup() */

/**
 * This goal is never completed...
 * @ignore yes
 */
int invarient(object npc) {
   return 1;
} /* invarient() */

/**
 * This setups all the goal specific stuff for this goal.  In the case of
 * this goal, the data the set of locations to run to when drunk.
 * @param npc the npc the goal is being added to
 * @param goal_name the name of the goal
 * @param stuff the parameter passed in by the creator
 * @return any specific information to store in the goal data
 * @ignore yes
 */
mixed initialise_plans(object npc, 
                       string goal_name,
                       int wimpy) {
tell_creator("pinkfish", "Initialise_plans(%O, %O, %O)\n", npc, goal_name, wimpy);
   /* Setup the wimpy values for the run away plan. */
   npc->set_goal_plan_data(goal_name, 
                           PLAN_DIR + "basic/run_away",
                           wimpy);
   return wimpy;
} /* create_goal_data() */
// --- END [/mnt/home2/grok/lib/std/npc/goals/misc/get_drunk.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/npc/inherit/owned.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/npc/inherit/owned.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628968   Available: 13576322
Inodes: Total: 5242880    Free: 4960135
914 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/npc/inherit/owned.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628968   Available: 13576322
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * Common functionality for an npc that is owned (ie summoned/controlled
 * by someone else).
 * @author Aquilo
 */

/* 
Store player owners as string name as it means they remain owner over su's.
*/

private mixed _owner;

/**
 * Set who owns us. 
 * @param owner either player name, player ob, or other living ob
 */
object set_owner( mixed owner ){
  if( stringp(owner) )
    _owner = owner;
  if( objectp(owner) && living(owner) ){
    if( userp(owner) )
      _owner = owner->query_name();
    else
      _owner = owner; 
  }

  return _owner;
}

/**
 * @return the ob pointing to the thing that owns/controls us
 */
object query_owner() {
  if( stringp(_owner) )
    return find_player(_owner);
  else
    return _owner;
}


/** 
 * Checked by pk checking code
 * @ignore yes */
object query_owner_pk_check() {
   return query_owner();
}


mixed *stats(){
  return ({ 
    ({ "owner", _owner }),
  });
}
// --- END [/mnt/home2/grok/lib/std/npc/inherit/owned.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/npc/plans/basic/run_away.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/npc/plans/basic/run_away.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628968   Available: 13576322
Inodes: Total: 5242880    Free: 4960135
2311 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/npc/plans/basic/run_away.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628968   Available: 13576322
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is the run away plan.  It will cause the npc to dash off somewhere
 * in terrible excitement.
 * @author Pinkfish
 * @started Wed Sep 23 00:15:02 EDT 1998
 */

#include <npc/plan.h>
#include <npc/events.h>

inherit PLAN_BASE_INHERIT;

int moved_event(object npc,
                mixed plan_data,
                string event,
                mixed *data);

/** @ignore yes */
void setup() {
   set_sutability(PLAN_MEDIUM_SUTABILITY);
   add_hooked_event(EVENT_MOVED, (: moved_event :));
} /* setup() */

/** @ignore yes */
protected int being_attacked(object npc) {
   object *attackers;

   attackers = filter(npc->query_attacker_list(), (: environment($1) ==
                                                 environment($2) :), npc);
   return sizeof(attackers);
} /* being_attacked() */

/** @ignore yes */
void activate_plan(object npc,
                   mixed data) {
   /* This should do the run away thing. */
   npc->run_away();
   //   npc->remove_plan(base_name(this_object()));
} /* activate_plan() */

/** @ignore yes */
int pre_condition(object npc,
                  string goal,
                  mixed plan_info,
                  string event,
                  mixed *data) {
   int wimpy_level;
   int percent;

tell_creator("pinkfish", "Precondition!\n");
   // The wimpy level should be determined by the plan.
   if (!plan_info) {
      wimpy_level = 50;
   } else {
      wimpy_level = plan_info;
   }

tell_creator("pinkfish", sprintf("%O: %O, %O\n", event, goal, plan_info));
   percent = (npc->query_hp() * 100) / npc->query_max_hp();
   if (percent < wimpy_level) {
      // Being attacked or we lost hps.  Out of here.
      if (being_attacked(npc) ||
          event == EVENT_LOSE_HPS) {
         return 1; 
      }
   }
   return 0;
} /* pre_condition() */

/** @ignore yes */
int finished(object npc) {
   /* We are finished if there are no attackers in our environment. */
   return !being_attacked(npc);
} /* finished() */

/** @ignore yes */
int moved_event(object npc,
                mixed plan_data,
                string event,
                mixed *data) {
   // We moved!  Maybe now we are finished?
   if (finished(npc)) {
      return 1;
   } else {
      // Need to run away again dammit!
      npc->run_away();
   }
   return 0;
} /* notify_event() */
// --- END [/mnt/home2/grok/lib/std/npc/plans/basic/run_away.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/npc/plans/base.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/npc/plans/base.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628967   Available: 13576321
Inodes: Total: 5242880    Free: 4960135
3354 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/npc/plans/base.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628967   Available: 13576321
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * The base inherit for all plans.
 * @author Pinkfish
 * @started Wed Aug  5 15:39:52 PDT 1998
 */
#include <npc/plan.h>

private nosave int _sutability;
private nosave mapping _hooked_events;

/** @ignore yes */
void setup() {
} /* setup() */

void create() {
   _sutability = PLAN_INVALID_SUTABILITY;
   _hooked_events = ([ ]);
   setup();
} /* create() */

/**
 * The precondition to the plan starting.
 * The default is to never let it start and always let them be finished.
 * @return always returns 0
 */
int pre_condition(object npc,
		  string goal,
                  mixed goal_info,
		  string event,
		  mixed *data) {
   return 0;
} /* pre_condition() */

/**
 * This method determines if the plan has been finished.
 * @return always returns 1
 */
int finished(object npc,
             mixed *data) {
   return 1;
} /* finished() */

/**
 * This method should return a number saying how sutiable this plan is
 * for this operation.,
 * @return the sutability level, always invalid
 * @see set_sutability()
 */
int query_sutability(object npc,
		     string goal,
                     mixed goal_info,
		     string event,
		     mixed *data) {
   return _sutability;
} /* query_sutability() */

/**
 * This method sets the sutability of the plan.  This is the default
 * sutability level, if you wish to make the sutability more complicate than
 * a simple number then the query_sutability method should be overridden.
 * @param sutability the new sutability
 * @see query_sutability()
 */
void set_sutability(int sutability) {
   _sutability = sutability;
} /* set_sutability() */

/**
 * This method should return any extra data needed to be passed onto the
 * plan.
 * @return the needed data, always 0
 */
int query_data(object npc,
	       string goal,
               mixed goal_info,
	       string event,
	       mixed *data) {
   return 0;
} /* query_data() */

/**
 * This method creates the plan control information, if any is needed.
 * If this is not setup with the plan then the default values will be
 * used.
 * @return the plan data
 */
mixed create_plan_data() {
   return 0;
} /* create_plan_data() */

/**
 * This method sets up a hooked event, the function will be called if the
 * event is called.  Thus things like completion events and followon stuff
 * can be done.  The function will be called with 4 arguments, the 
 * arguments are:<br>
 * func(npc, plan_data, event, data)
 * @param event the event to call
 * @param func the function to call with the event
 */
void add_hooked_event(string event, function func) {
   _hooked_events[event] = func;
} /* add_hooked_event() */

/**
 * This method removes a hooked event.
 * @param event the event to remove the data for
 */
void remove_hooked_event(string event) {
   map_delete(_hooked_events, event);
} /* remove_hooked_event() */

/**
 * This method will be called when an event is setup.
 * @param npc the npc that called the event
 * @param plan_data the data associated with the plan
 * @param event the event which is called
 * @param data the data associated with the event
 */
int notify_event(object npc,
                 mixed plan_data,
                 string event,
                 mixed *data) {
   if (_hooked_events[event]) {
      return evaluate(_hooked_events[event], npc, plan_data, event, data);
   }
   return 0;
} /* notify_event() */
// --- END [/mnt/home2/grok/lib/std/npc/plans/base.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/npc/npc_intelligent.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/npc/npc_intelligent.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628966   Available: 13576320
Inodes: Total: 5242880    Free: 4960135
1472 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/npc/npc_intelligent.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628966   Available: 13576320
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is a test npc ai object.
 * @author Pinkfish
 * @started Tue Aug  4 19:13:19 PDT 1998
 */
#include <npc/events.h>

inherit "/obj/monster";
inherit "/std/npc/goals_inherit";

int _last_hp;

protected int check_heart_beat_results();

void create() {
   goals_inherit::create();
   monster::create();
} /* create() */

/** @ignore yes */
void heart_beat() {
   int hp;

   ::heart_beat();
   call_out((: check_heart_beat_results :), 0);
} /* heart_beat() */

/**
 * This is just to make sure that the heart beat is not broken by
 * our processing errors.
 * @ignore yes
 */
protected int check_heart_beat_results() {
   hp = query_hp();
   if (hp != _last_hp) {
      if (hp > _last_hp) {
         notify_npc_event(EVENT_GAIN_HPS, hp - _last_hp, hp);
      } else {
         notify_npc_event(EVENT_LOSE_HPS, _last_hp - hp, hp);
      }
      _last_hp = hp;
   }
} /* heart_beat() */

/** @ignore yes */
mixed *stats() {
   return monster::stats() + goals_inherit::stats();
} /* stats() */

/** @ignore yes */
int move(mixed dest, string messin, string messout) {
   int ret;
   object from;

   from = environment();
   ret = ::move(dest, messin, messout);
   if (from) {
      call_out((: notify_npc_event :), 0, EVENT_MOVED, from);
   }
   return ret;
} /* move() */

/** @ignore yes */
void event_enter(object moving, string mess, object from) {
   if (living(from)) {
      call_out((: notify_npc_event :), 0, EVENT_GIVEN, moving);
   }
} /* event_enter() */
// --- END [/mnt/home2/grok/lib/std/npc/npc_intelligent.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/npc/goals_inherit.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/npc/goals_inherit.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628966   Available: 13576320
Inodes: Total: 5242880    Free: 4960135
14121 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/npc/goals_inherit.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628966   Available: 13576320
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is the goal handler for the npcs.  It will handle all the goals
 * and ordering them, figuring out which goal to run.
 * @author Pinkfish
 * @started Thu Jul 30 17:06:19 PDT 1998
 */
#include <npc/goals.h>
// Local inherit stuff.
#include "goal_inherit.h"

class goal_information {
   mixed data;
   int priority;
   string *events;
}

class plan_info {
   int priority;
   mixed data;
}

// The index of the mapping is the goal.
private nosave mapping _goals;
private nosave mapping _events;
private nosave mapping _emotions;
// The format of this array is:
//  ({ priority, plan, priority, plan, ... })
private nosave mixed* _plans;
private nosave string  _current_plan;

private class goal_information query_goal_information(string goal);
void remove_goal_event(string goal, string event);
void add_goal_event(string goal, string event);
int query_goal_priority(string goal);
int check_current_plan_finished();

void create() {
   _goals = ([ ]);
   _events = ([ ]);
   _plans = ({ });
} /* create() */

/**
 * This method is *only* to be used for debugging.
 */
mapping query_goals() {
   return _goals;
} /* query_goals() */

/**
 * This method is *only* to be used for debugging.
 */
mapping query_events() {
   return _events;
} /* query_events() */

/**
 * This method will add a goal to the NPC.
 * @param goal the goal to add
 * @param data the data associated with the goal
 */
void add_goal(string goal, mixed data) {
   class goal_information frog;

   if (!goal->invarient(this_object())) {
      // Cannot add the goal.
      return ;
   }

   if (!_goals[goal]) {
      frog = new(class goal_information);
      frog->data = data;
      frog->priority = goal->query_priority(this_object(), data);
      frog->events = ({ });
      _goals[goal] = frog;
      goal->initialise(this_object(), goal, data);
   } else {
      goal->add_again(this_object(), query_goal_information(goal)->data, data);
   }
} /* add_goal() */

/**
 * This method removes the goal from the current goal list.
 * @param goal the goal to remove
 */
void remove_goal(string goal) {
   class goal_information frog;
   string event;

   frog = query_goal_information(goal);
   if (frog) {
      goal->finalise(this_object(), frog->data);
      foreach (event in frog->events) {
         remove_goal_event(goal, event);
      }
      map_delete(_goals, goal);
   }
} /* remove_goal() */

/**
 * This method gets the information associated with the goal.
 * @param goal the goal to get the information for
 * @return the goal information
 */
private class goal_information query_goal_information(string goal) {
   class goal_information frog;

   frog = _goals[goal];
   return frog;
} /* query_goal_information() */

/**
 * This method returns the data associated with this goal.
 * @param goal the goal to get the data for
 * @return the data associated with the goal
 * @see query_goal_priority()
 * @see set_goal_data()
 */
mixed query_goal_data(string goal) {
   class goal_information frog;

   frog = query_goal_information(goal);
   if (frog) {
      return frog->data;
   }
   return 0;
} /* query_goal_data() */

/**
 * This method returns the data associated with this goal.
 * @param goal the goal to get the data for
 * @param data the new data for the goal
 * @return 1 on success, 0 on failure
 * @see query_goal_priority()
 * @see query_goal_data()
 */
int set_goal_data(string goal, mixed data) {
   class goal_information frog;

   frog = query_goal_information(goal);
   if (frog) {
      frog->data = data;
      return 1;
   }
   return 0;
} /* set_goal_data() */

/**
 * This method returns the priotity of the goal.
 * @param goal the goal to query the priority of
 * @return the priority of the goal
 * @see change_goal_priority()
 */
int query_goal_priority(string goal) {
   class goal_information frog;

   frog = query_goal_information(goal);
   if (frog) {
      return frog->priority;
   }
   return GOAL_INVALID_PRIORITY;
} /* query_priority() */

/**
 * This method changes the priority of the specified goal.  It will recall
 * the query_priority() method on the goal to figure out the new priority.
 * @param goal the goal whose priority to change
 * @see add_goal_event()
 * @see remove_goal_event()
 * @see query_goal_priority()
 */
void change_goal_priority(string goal) {
   class goal_information frog;
   int new_priority;
   string evt;

   frog = query_goal_information(goal);
   if (frog) {
      new_priority = goal->query_priority(this_object(), frog->data);
      if (new_priority != frog->priority) {
         frog->priority = new_priority;
      }
      foreach (evt in frog->events) {
         /* Put itself back into the event list. */
         remove_goal_event(goal, evt);
         add_goal_event(goal, evt);
      }
   }
} /* change_goal_priority() */

/**
 * This method adds an event for a goal to react to.  This should only be
 * done from inside the goal initialisation code, and other parts of the
 * goal.  We will only add things for goals which we know about.
 * @param goal the goal the event is for
 * @param event the event name to react to
 * @see change_priority()
 * @see remove_goal_event()
 */
void add_goal_event(string goal, string event) {
   class goal_information frog;
   string test_goal;
   int i;
   int priority;
   int found;

   frog = query_goal_information(goal);
   if (frog) {
      if (!_events[event]) {
         _events[event] = ({ goal });
      } else if (member_array(goal, _events[event]) == -1) {
         // Place the goal into the list in priority order.
         priority = query_goal_priority(goal);
         while (i < sizeof(_events[event])) {
            test_goal = _events[event][i];
            if (query_goal_priority(_events[event][i]) < priority) {
               _events[event] = _events[event][0..i-1] + ({ goal }) +
                                _events[event][i..];
               found = 1;
               break;
            }
            i++;
         }
         if (!found) {
            _events[event] += ({ goal });
         }
      }
      frog->events += ({ event });
   }
} /* add_goal_event() */

/**
 * This method removes the goal event for the goal.
 * @param goal the goal to remove the event for
 * @param event the event name to not react to
 * @see add_goal_event()
 * @see change_priority()
 */
void remove_goal_event(string goal, string event) {
   class goal_information frog;

   frog = query_goal_information(goal);
   if (frog && _events[event]) {
      _events[event] -= ({ goal });
      if (!sizeof(_events[event])) {
         map_delete(_events, event);
      }
      frog->events -= ({ event });
   }
} /* remove_goal_event() */

/**
 * This method is called when an event needs to be notified about.
 * The event handling routines should try to be short.  They should
 * just modify the priority of something, or add a new goal to the
 * current list.
 * @param event the event to tell us about
 * @param information the information associated with the event
 */
varargs void notify_npc_event(string event, mixed *information ...) {
   string goal;

tell_creator("pinkfish", "%s %O\n", event, _events[event]);
   if (_events[event]) {
      foreach (goal in _events[event]) {
  	 // If the event is handled then we break out.
         if (goal->notify_of_event(this_object(),
                                   query_goal_information(goal)->data,
                                   event,
                                   information)) {
            return ;
         }
      }
   }

   if (sizeof(_plans)) {
      if (_plans[PLAN_PLAN]->notify_of_event(this_object(),
                                      ((class plan_info)_plans[PLAN_INFO])->data,
                                      event,
				      information)) {
         check_current_plan_finished();
      }
   }
} /* notify_npc_event() */

/**
 * This activates the plan on the npc.
 * @param plan the plan to activate
 * @param goal the goal which is activating the plan
 */
void activate_plan(string plan,
                   string goal,
                   mixed data) {
   int priority;
   int pos;
   int i;
   int old;
   mixed *tmp;
   class plan_info info;

   priority = query_goal_priority(goal);
   /* First see if the plan is already activated. */
   pos = member_array(plan, _plans);
   if (pos != -1) {
      /* Update the data value */
      info = _plans[pos + PLAN_INFO];
      info->data = plan->combine_plans(info->data, data);
      if (info->priority != priority) {
         /* Priority has changed... Tricky... */
         /* First see if we should move up the list. */
         old = -1;
         for (i = pos - PLAN_ARRAY_SIZE; i >= 0; i -= PLAN_ARRAY_SIZE) {
            if (priority > ((class plan_info)_plans[i + PLAN_INFO])->priority) {
               old = i;
            } else {
               break;
            }
         }
         if (old != -1) {
            /* We move upwards! */
            tmp = _plans[pos..pos + PLAN_ARRAY_SIZE];
            _plans = _plans[0..pos - 1] + _plans[pos + PLAN_ARRAY_SIZE..];
            _plans = _plans[0..old - 1] + tmp + _plans[old..];
         } else {
            /* Check to see if we need to move down. */
            for (i = pos + PLAN_ARRAY_SIZE; i < sizeof(_plans);
                 i += PLAN_ARRAY_SIZE) {
               if (priority < ((class plan_info)_plans[i + PLAN_INFO])->priority) {
                  old = i;
               } else {
                  break;
               }
            }
            if (old != -1) {
               /* We move down... :( */
               tmp = _plans[old..old + PLAN_ARRAY_SIZE];
               _plans = _plans[0..old - 1] + _plans[old + PLAN_ARRAY_SIZE..];
               _plans = _plans[0..pos - 1] + tmp + _plans[pos..];
            }
         }
      }
   } else {
      old = -1;

      info = new(class plan_info);
      info->data = data;
      info->priority = priority;
      /* Try to find the right spot to put it into the array. */
      for (i = 0; i < sizeof(_plans); i += PLAN_ARRAY_SIZE) {
         if (priority > ((class plan_info)_plans[i + PLAN_INFO])->priority) {
            /* We go here... */
            _plans = _plans[0..i - 1] + ({ plan, info }) +
                     _plans[i..];
            old = i + PLAN_ARRAY_SIZE;
            break;
         }
      }
      if (i >= sizeof(_plans)) {
         _plans += ({ plan, info });
      }
   }

tell_creator("pinkfish", "Activating %O, %O, %O\n", _current_plan, _plans[PLAN_PLAN], _plans[PLAN_INFO]);
   /* Check to see if any plans should be suspended or activated. */
   if (_plans[PLAN_PLAN] != _current_plan) {
      if (_current_plan) {
         pos = member_array(_current_plan, _plans);
         if (pos != -1) {
            _plans[pos + PLAN_PLAN]->suspend_plan(this_object(),
                                                  ((class plan_info)_plans[pos + PLAN_INFO])->data);
         }
      }
      _plans[PLAN_PLAN]->activate_plan(this_object(),
                                       ((class plan_info)_plans[PLAN_INFO])->data);
      // Check to see if any of the plans are completed now...
      while (check_current_plan_finished());
   }
} /* activate_plan() */

/**
 * This method checks to see if the top plan is finished or not.
 * @param plan the plan to finish
 * @return 1 if the plan has been finished, 0 if not
 */
int check_current_plan_finished() {
   if (sizeof(_plans)) {
      if (_plans[PLAN_PLAN]->finished(this_object(),
                                      ((class plan_info)_plans[PLAN_INFO])->data)) {
         _plans = _plans[PLAN_ARRAY_SIZE..];
         if (sizeof(_plans)) {
            _plans[PLAN_PLAN]->activate_plan(this_object(),
                                             ((class plan_info)_plans[PLAN_INFO])->data);
         }
         return 1;
      }
   }
   return 0;
} /* finish_plan() */

/**
 * This method changes the data associated with the specified plan.  This
 * should only be called from the plan itself, as the plan will not be
 * informed of this change.
 * @param data the new data for the plan
 */
void set_plan_data(string plan, mixed data) {
   int pos;

   pos = member_array(plan, _plans);
   if (pos != -1) {
      ((class plan_info)_plans[pos + PLAN_INFO])->data = data;
   }
} /* set_plan_data() */

/** @ignore yes */
mixed *stats() {
   mixed *ret;
   string goal;
   class goal_information frog;
   int goal_num;
   int i;

   goal_num = 0;
   ret = ({ });
   foreach (goal in keys(_goals)) {
      frog = query_goal_information(goal);
      ret += ({ ({ "Goal " + goal_num + ") name", goal }) });
      ret += ({ ({ "Goal " + goal_num + ") events",
                   query_multiple_short(frog->events) }) });
      ret += ({ ({ "Goal " + goal_num + ") priority",  frog->priority }) });
      goal_num++;
   }

   for (i = 0; i < sizeof(_plans); i += PLAN_ARRAY_SIZE) {
      ret += ({ ({ "Plan " + goal_num + ") name", _plans[i + PLAN_PLAN] }) });
      ret += ({ ({ "Plan " + goal_num + ") priority",
                   ((class plan_info)_plans[i + PLAN_INFO])->priority }) });
   }

   return ret;
} /* stats() */

/**
 * This method sets the default data associated with the specified plan.
 * This should be things like global plan things, the level at which the
 * npc will run away.  Etc.
 * @param goal the goal to check the data for
 * @param plan the name of the plan
 * @param data the data associated with the plan
 * @see query_default_plan_data()
 */
void set_goal_plan_data(string goal, string plan, mixed data) {
   mixed goal_data;

   goal_data = query_goal_data(goal);
   goal->set_plan_data(this_object(), goal_data, plan, data);
} /* set_default_plan_data() */

/**
 * This method returns the data associated with the specified plan.
 * @param goal the foal to query the information for
 * @param plan the name of the plan to get the data for
 * @return the plans data
 * @see set_default_plan_data()
 */
mixed query_goal_plan_data(string goal, string plan) {
   mixed goal_data;

   goal_data = query_goal_data(goal);
   return goal->query_plan_data(this_object(), goal_data, plan);
} /* query_default_plan_data() */
// --- END [/mnt/home2/grok/lib/std/npc/goals_inherit.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/npc/surface_decorator.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/npc/surface_decorator.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628962   Available: 13576316
Inodes: Total: 5242880    Free: 4960135
12299 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/npc/surface_decorator.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628962   Available: 13576316
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 *  This is a inheritable for playerhousing surface decorating npcs.
 *  
 *  With this you can add carpets, wood panelling, beams or anything your 
 *  little heart desires to npcs that will then go out and make the world a    
 *  prettier place.
 *
 *  If you want to add a surface to an npc that he will be able to 
 *  decorate, use eg:
 *  
 *  add_allowed_surface( "floor" );    
 *
 *  If you want to add a type of decoration that the npc can install, use eg:
 *  
 *  add_fitted_surface( "plush blue carpet", "covered with plush "
 *  "blue carpet", <cost> );
 *
 *  @September 3rd, 2002
 *  @authors Una and Dasquian
 *
 **/

#include <money.h>

inherit "/obj/monster";

private mapping fitted_surfaces = ([ ]);
private string *allowed_surfaces = ({ });
private string *allowed_domains = ({ });
private string *responses = ({ 
        "'I don't fit those kinds of surfaces.",
        "'I don't fit that kind of decor.",
        "'You don't own this place, sorry!",
        "'I can't decorate surfaces here!",
        "'Something went horribly wrong!",
        "'All finished!",
        "'You don't have enough money to pay for the $decor$!  It "
        "will cost you $amount$.",
        "'I can fit $allowed$ with any of the following:", 
        "'I don't have any stock right now.",
        "'Ok, I'll get right on with it.", 
        "'What?  Did somebody say something?",
        "'I've already been hired by $employer$.",
        "'Ok, take me to the room you want decorated and ask me to "
        "fit something when we get there.", 
        "'Sorry, I don't go there."
    });
private string under_construction_mess = "covered in dust and dirt" ;
private int work_time = 10;
private object employer;
private string last_ok;

int do_ask( string surface, string decor );


void create() {
 
    do_setup++;
    ::create();
    do_setup--;
    
    if (!do_setup) {
        this_object()->setup();
        this_object()->reset();
    }
    add_help_file("/doc/object/surface_decorator");
    add_enter_commands("#check_domain");
    
} /* create() */


void init() {

    ::init();
    this_player()->add_command( "ask", this_object(), "<direct:object> to "
        "fit the <string'surface'> with <string'decor'>", 
        (: do_ask($4[1], $4[2])  :) );
        
    this_player()->add_command( "list", this_object(), "goods from "
        "<direct:object>" );
        
    this_player()->add_command( "hire", this_object(), "<direct:object>");

} /* init() */


/**
 * Causes the surface decorator to give a list of the surfaces he decorates
 * and what he can decorate them with, or says that he has no stock.
 */
int do_list() {
    int i;
    string thing;
    
    i=1;
    
    if( !sizeof( fitted_surfaces ) ) {
        init_command( responses[8], 1 );
        return 1;
    }
    
    init_command( replace( responses[7], ({
            "$allowed$", query_multiple_short( map( allowed_surfaces, 
                (: pluralize($1) :) ) )
        }) ), i );

    foreach( thing in keys( fitted_surfaces ) ) {
        i++;
        init_command("'" + capitalize(thing) + " for " + 
            MONEY_HAND->money_value_string(fitted_surfaces[thing][1], 
            query_property("place")) + ".", i);
    }
    return 1;
    
} /* do_list() */


/**
 * Sets him to follow the player and marks that player as his current 
 * employer
 */
int do_hire() {
    
    this_player()->add_succeeded_mess( this_object(), "$N ask$s $D about "
        + this_object()->query_possessive() + " services.\n", ({ }) );

    // Make sure he can see you    
    if( !this_player()->query_visible( this_object() ) ) {
        init_command( responses[10], 1 );
        return 1;
    }
    
    // Make sure he isn't already following someone else
    if( employer && 
        environment( employer ) == environment( this_object() ) &&
        this_player() != employer ) {
        
        init_command( replace( responses[11], ({ "$employer$", "$C$" + 
            employer->query_name() }) ), 1 );
        return 1;
    }
    
    // Sets him as following the player
    employer = this_player();
    do_command("unfollow everyone");
    employer->add_follower(this_object());
    
    init_command( responses[12], 1 );
    
    return 1;

} /* do_hire() */


/** 
 * Does all the necessary checks to see if he can decorate the requested 
 * surface with the requested decor, handles payment and starts the work. 
 *
 * @param surface the surface to be decorated 
 * @param decor the short name of the decor to be used, eg. green carpet
 * 
 * @see finish_work
 */
int do_ask( string surface, string decor ) {
    string long, allowed, place;
    int fee, can_do;
    object where;
    
    can_do = 0;
    
    // Checks to see if the requested surface contains any of the words 
    // in the list of allowed surfaces, eg. if "wall" is in the allowed
    // surfaces, then "north wall" will be allowed.
    foreach( allowed in allowed_surfaces ) {
        if( strsrch( surface, allowed ) != -1 ) {
            can_do = 1;
        }
    }
    
    if( !can_do ) {
        do_command(responses[0]);
        return 1;
    }   
    
    // Checks that the npc does the requested decor
    if( member_array( decor, keys( fitted_surfaces ) ) == -1 ) {
        do_command(responses[1]);
        return 1;
    }
    
    long = fitted_surfaces[decor][0];
    fee  = fitted_surfaces[decor][1];
    where = environment( this_object() );

    // Checks that the player owns the room
    if(!where->test_occupier( this_player()->query_name() ) ) {
        do_command(responses[2]);
        return 1;        
    }
  
    // Checks that the room can be decorated at all
    if(!function_exists("decorate_surface", where)) {
        do_command(responses[3]);
        return 1;        
    }
  
    place = query_property("place");
  
    // Checks the player has enough money
    if ( this_player()->query_value_in( place ) < fee ) {
        do_command( replace( responses[6], ({
            "$decor$", decor, 
            "$amount$", MONEY_HAND->money_value_string(fee, place)
        }) ) );
        queue_command("stare" + this_player()->query_name());
        return 1;
    }
    
    // Try to set the surface to be under construction and bail if
    // we fail, otherwise set the call_out to finish the work    
    if(!where->decorate_surface(surface,under_construction_mess)) {
        
        do_command(responses[4]);
        return 1;
    }
    call_out( "finish_work", work_time, surface, long, where );
    do_command( responses[9] );
    do_command( "unfollow everyone" );
    
    // Finally, charge the player after we know the work is going to be 
    // done    
    this_player()->pay_money( (mixed *)MONEY_HAND->create_money_array( fee,
            place ), place);
            
    this_player()->add_succeeded_mess( this_object(), "$N pay$s $D some "
        "money and " + this_object()->query_pronoun() + " starts to go "
        "about his work on the " + surface + ".\n", ({ }) );  
    return 1;
        
} /* do_ask() */


/**
 * Called by do_ask(), this finishes decorating the surface
 *
 * @param surface the surface to be decorated
 * @param long the long description of the decorated surface, eg. carpeted   
 * with plush green carpet
 * 
 * @see do_ask
 */
void finish_work( string surface, string long, object where ) {

    do_command(":finishes his work.");
    if( employer ) {
        employer->add_follower(this_object());
    }
    
    // The work is finished.  Set the surface's description to that which
    // was requested!
    if(!where || !where->decorate_surface(surface, long )) {
        do_command(responses[4]);
        return;
    }
    
    else {
        do_command(responses[5]);
        return;
    }

} /* finish_work() */

/**
 * Attempts to move the npc back to its good location.  It first moves it
 * to the rubbish room so that if it hasn't got a last good location or
 * fails to be moved to that location, it stays in the rubbish room.
 */
private void go_back() {
    
    move("/room/rubbish", "$N walk$s in.", "$N walk$s away.");
    
    if( last_ok ) {
        move(last_ok, "$N walk$s in.", "$N walk$s away.");
    }
        
} /* go_back() */


/** 
 * Called every time the npc moves.  This function checks that the file name 
 * of its new environment contains at least one of the allowed domains.  If
 * it does, it will store the current room as being its last good location.  
 * Otherwise, it will move it to its last good location.
 *
 * @see go_back
 */
void check_domain() {
    string allowed, here;
    int ok;
    
    here = file_name( environment( this_object() ) );
    ok = 0;
    
    foreach( allowed in allowed_domains ) {
        if( strsrch( here, allowed ) != -1 ) {
            ok = 1;
        }
    }   
    
    if( ok ) {
        last_ok = here;
        return;
    }
    else {
        do_command("unfollow everyone");
        do_command( responses[13] );
        go_back();
        return;
    }
    
} /* check_domain() */


/**
 * Adds a new decoration that the npc can use to his stock list
 *
 * @param short the short description used in the stock list and for ordering
 * @param long the long description actually used for the new decoration in 
 * the room
 * @param cost the cost of installing this decoration
 */
void add_fitted_surface( string short, string long, int cost ) {
    fitted_surfaces[ short ] = ({ long, cost });
} /* add_fitted_surface() */

mapping query_fitted_surfaces() { return fitted_surfaces; }


/**
 * Removes a decoration whose short matches the argument given
 *
 * @param short the short description of the surface to remove
 */
void remove_fitted_surface( string short ) {
    map_delete( fitted_surfaces, short );
} /* remove_fitted_surface() */


/**
 * Removes all decorations from the npc's stock list
 */
void remove_all_fitted_surfaces() {
    fitted_surfaces = ([ ]);
} /* remove_all_fitted_surfaces() */


/**
 * Allows the npc to work on a specific surface in a room, eg. floor, ceiling
 * If the argument passed is "wall", they will be able to work on all walls,
 * eg. north wall, east wall, south wall, etc.
 *
 * @param surface the name of the surface to be added
 */ 
void add_allowed_surface( string surface ) {
    if( member_array( surface, allowed_surfaces ) == -1 ) {
        allowed_surfaces += ({ surface });
    }
} /* add_allowed_surface() */

string *query_allowed_surfaces() { return allowed_surfaces; }


/**
 * Adds a string to the list of domains to be checked by the npc when it 
 * moves to see if it's allowed to be in that room, eg. "/d/guilds" or 
 * "Bes_Pelargic"
 *
 * @param domain the name of the domain to be added
 */ 
void add_allowed_domain( string domain ) {
    if( member_array( domain, allowed_domains ) == -1 ) {
        allowed_domains += ({ domain });
    }
} /* add_allowed_domain() */

string *query_allowed_domains() { return allowed_domains; }


/**
 * Sets custom responses.  The array size must match the existing one or the  
 * call will be disregarded.
 *
 * @param the_responses the array of responses to be used
 */
void set_responses( string *the_responses ) {

    if( sizeof(the_responses) != sizeof(responses) ) {
        return 0;
    }
    else {
        responses = the_responses;
    }
    
} /* set_responses() */

string *query_responses() { return responses; } /* query_responses() */


/** 
 * Sets what a surface looks like while the npc is working on it.
 *
 * @param mess the description to replace the surface's appearance in the 
 * room while it is being worked on
 */
void set_under_construction_mess( string mess ) {
    under_construction_mess = mess;    
} /* set_under_construction_mess() */

string query_under_construction_mess() { return under_construction_mess; }
    

/**
 * Sets the time it takes to finish the work.
 *
 * @param time the time (in seconds) taken to complete the work
 */
void set_work_time( int time ) {
    work_time = time;
} /* set_work_time() */

int query_work_time() { return work_time; }


/**
 * Sets the current player employer
 *
 * @param player the player object currently using the npc
 */
void set_employer( object player ) {
    employer = player;
} /* set_employer() */

object query_employer() { return employer; } /* query_employer() */
// --- END [/mnt/home2/grok/lib/std/npc/surface_decorator.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/npc/taliswoman.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/npc/taliswoman.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628959   Available: 13576313
Inodes: Total: 5242880    Free: 4960135
7746 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/npc/taliswoman.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628959   Available: 13576313
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming

inherit "/obj/clothing";

//defines various locations taliswoman will go to
#include "/d/guilds/witches/include/taliswoman.h"

/* start of function prototypes */
void setup();
void init();
void high_level();
void set_destination(string city);
int go_granny( string *args );

/* end of function prototypes */

//Global Variables
nosave mapping _city_destinations = ([
 
   "default" : AM,
   "klk" : KLK,
   "stolat" : STO_LAT,
// "stohelit" : STO_HELIT   
// "genua" : GENUA    

]);
 
nosave private string set_destination;

string _city;


void setup() {

    set_name( "taliswoman" );
    add_alias( ({ "stone", "ass", "thong" }) );
    set_short( "taliswoman" );
    add_adjective( ({ "small", "surly", "ass", "smooth", "leather", "thin",
        "witches'", "witches", "guild", "stone" }) );
    add_property( "talisman", "no one" );
    add_property( "no recycling", 1 );
    set_main_plural( "taliswomen" );

    set_long( "This small stone shaped like a small and surly ass has been "
      "worn smooth by frequent handling.  A thin, leather thong has been "
      "threaded through its hole.  " );
    add_extra_look( this_object() );

    set_value(1);
    set_weight(2);
    set_type( "necklace" );
    set_max_cond( 70 );
    set_cond( 70 );
    
    init_dynamic_arg(query_dynamic_auto_load());
    
} /* setup() */


string extra_look() {

    if( this_player()->query_name() != query_property( "talisman" ) ) {
        return "\n";
    }
    
    return "This taliswoman will get you to the Witches Guild to see Granny "
        "Weatherwax if you rub the tail of the ass, and back to "
        "Ankh-Morpork if you rub its head. You can only use it once in "
        "each direction, but you can get a new one from Gennie if you "
        "haven't outgrown them.\n";
        
} /* extra_look() */


void init() {
    add_command( "rub" , "{head|tail} of <direct:object'ass'>",
      (: go_granny( $4[0] ) :) );
} /* init() */


void high_level() {
    string gender;

    switch( this_player()->query_gender() ) {
        case 0:
            gender = "thing";
            break;
        case 1:
            gender = "boy";
            break;
        case 2:
            gender = "girl";
            break;
    }
    add_failed_mess( "$D says \"You are a big " + gender + " now, so you'll "
        "have to manage without me.  Good luck on your adventures!\"\n", );
    set_worn_by(0);
    this_player()->remove_property( "given taliswoman" );
    move( "/room/rubbish", "", "$N vanishes in a puff of smoke." );
    
} /* high_level() */


void set_destination( string city ) { 
    _city = "city";
} /* set_destination() */


mapping query_dynamic_auto_load() {
    return ([
        "::" : ::query_dynamic_auto_load(),
        "new_destination" : _city,
    ]);
} /* int_query_static_auto_load() */


void init_dynamic_arg( mapping map, object ) {
 
    if (map["::"]) ::init_dynamic_arg(map["::"]);
   
    if (map[ "city" ] ]) _city = map["city"];
        else {
            _city = "default";
        }

} /* init_dynamic_arg() */

int go_granny( string where ) {
    mixed destination;

    destination = _city;


    if( !query_property( "talisman" ) ) {
        add_failed_mess( "$D blinks rapidly and vanishes in a sudden fit "
            "of quantum insecurity.\n" );
        set_worn_by(0);
        move( "/room/rubbish" );
        return -1;
    }

    if( query_property( "talisman" ) != this_player()->query_name() ) {
        this_player()->add_failed_mess( this_object(), "$D isn't yours!\n"
            "It thumbs its metaphorical nose at you and refuses to do "
            "anything.\n" );
        return -1;
    }

    if( where == "tail" ) {

    /*  Gennie won't give you a taliswoman if you're above level 20, so if 
        you've been sneaky and kept one, it shouldn't work. */
    
        if( this_player()->query_level() > 20 ) {
            high_level();
            return -1;
        }
        if( query_property( "been to bad ass" ) ) {
            add_failed_mess( "You have already used $D to travel to the "
                "witches once.\n" );
            return -1;
        }
    
        if( file_name( environment( this_player() ) ) == destination ) {
            add_failed_mess( "But you are already here!\n" );
            return -1;
        }

        add_succeeded_mess( ({ "$D starts to glow.  The bright glow makes "
            "you blink and when you open your eyes, you're in a new place.\n",
            "$N $V $D.\n" }) );

        if( this_player()->query_guild_ob() != "/std/guilds/witch" ) {
            call_out( (: tell_object( $(this_player()), "The taliswoman "
                "says: To the northwest, then north of here is the home of "    
                "Granny Weatherwax.  You need to speak with her about "
                "becoming a witch.  To get into the cottage you will need "
                "the key to the back door; it's hidden in the privy.  To get "
                "back to Ankh-Morpork, you can rub my head or catch the "
                "carriage in Bad Ass to the southeast of here.  "
                "Good luck!\n" ) :), 2 );
            add_property( "been to bad ass", 1 );
        }
    }
    
    else {
   
    /*  Gennie won't give you a taliswoman if you're above level 20, so if 
        you've been sneaky and kept one, it shouldn't work. */
    
        if( this_player()->query_level() > 20 ) {
            high_level();
            return -1;
        }
        if( query_property( "been to city" ) ) {
            add_failed_mess( "You have already used $D to travel to the "
                "city once.\n" );
            return -1;
        }
    
        if( file_name( environment( this_player() ) ) == destination ) {
            add_failed_mess( "But you are already here!\n" );
            return -1;
        }

        add_succeeded_mess( ({ "$D starts to glow.  The bright glow makes "
            "you blink and when you open your eyes, you're in a new place.\n",
            "$N $V $D.\n" }) );
        add_property( "been to city", 1 );
    }

    call_out( (: $(this_player())->move_with_look( $(destination),
        "You notice a glimmering light to the side of the road.  As you "
        "watch, the light begins to take the shape of $N as she "
        "arrives from somewhere else.",
        "A bright light surrounds $N.  It dims suddenly, then "
        "vanishes.  It seems to have taken $N with it." ) :), 0 );

    if( query_property( "been to bad ass" ) && 
        query_property( "been to city" ) ) {
        
        call_out( (: tell_object( $(this_player()), the_short() +
            " says: You have now used me to travel once in each direction, "
            "so our ways part here.  If you need me again, just go see "
            "Gennie.\n" ) :), 1 );
        // so she can get another without waiting 30 minutes...
        this_player()->remove_property( "given taliswoman" );
        call_out( (: set_worn_by(0), move( "/room/rubbish", "",
            "$N vanishes in a puff of smoke." ) :), 1 );
    }
    return 1;
}  /*  go_granny()  */


varargs int add_property( string var, mixed val, int tim ) {

    if( var == "talisman" ) {
        
        if( query_property( "talisman" ) && 
            query_property( "talisman" ) != "no one" ) {
                
            call_out( (: tell_object( $(environment()), "The taliswoman "
                "blinks rapidly and vanishes in a sudden fit of quantum "
                "insecurity.\n" ) :), 1 );
            call_out( (: set_worn_by(0), move( "/room/rubbish" ) :), 1 );
        }
    }
    return ::add_property( var, val, tim );
    
} /* add_property() */



string query_destination() {
    return _city;
} /* query_destination() */


// --- END [/mnt/home2/grok/lib/std/npc/taliswoman.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/npc/locksmith.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/npc/locksmith.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628957   Available: 13576311
Inodes: Total: 5242880    Free: 4960135
22915 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/npc/locksmith.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628957   Available: 13576311
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*
 *
 *$Id: locksmith.c,v 1.8 2002/10/11 10:32:25 wirble Exp $
 *
 */

/**
 * -- Inheritable for playerhousing locksmiths --
 * An NPC using this inherit is able to unlock the doors to playerhouses and
 * commercial properties when prompted to do so by the rightful owner.
 *
 * -- How such an NPC works from a player's point of view --
 * - A player can "hire" the npc if he wants a door of his house opened.
 * - He then has to "pay" (*) the amount the npc demands (if that player killed
 *   the npc before, the base price is doubled).  He has 120 seconds to do so.
 * - After that happens, the npc will follow the player until the player
 *   "asks"s him to opens an exit door.
 * - Then player is prompted to enter [y]es [n]o".  If the player confirms and
 *   the handler doesn't return this as well, the npc complains and walks off
 *   (keeping the money, of course).  Otherwise it unlocks the door and then
 *   leaves.
 *
 * (*) Giving the money to the npc does not work, it'll return it.
 *
 * The same procedure applies if the player wants all doors opened.
 *
 * All attempts to hire a locksmith with the result of that action are logged
 * in the file defined in LOG
 *
 * In case of problems you can always try to:
 * 1) look at the log to see if the player in question hired and payed the npc
 * 2) call query_client() on the npc
 * 3) call free_for_hire() on the npc
 * 4) dest and re-load the npc
 *
 *
 * @example
 * inherit "/std/npc/types/locksmith";
 *
 * void setup() {
 *     // basic npc-setup
 *     set_savefile(SAVE + "glodson_killers");
 *     set_price(20000); // 50 $AM
 *     set_currency_region("Ankh-Morpork");
 *     set_domain("/d/am/");
 * }
 *
 * @author Wirble
 * @started Nov. 2001
 */

#include <armoury.h>
#include <money.h>

#define LOG "/log/LOCKSMITH"
#define LOGGING 1

inherit "/obj/monster";


//private functions
private void save_killers();
private void load_killers();
private void remove_killer(string name);
private void clear_false_client();
private void payment_timeout();
private int check_owner();
private void unlock(object door);
private string get_price();
private int calc_price();
private void generic_responses();
private void go_back();
private void unlock_all( string path );
private void delay_opening( string env );
void finish_opening( string path, string env );

// public functions
public void confirmation(string response, object player);
public void free_for_hire();
public string query_client();
public void move_recording();
public string* query_killers();
public string* query_responses();
public string query_domain();
public string query_last_room();

//setup functions
protected int set_savefile(string file);
protected int set_price(int price);
protected int set_currency_region(string region);
protected int set_responses(string *responses);
protected int set_domain(string domain);

// command functions
public int do_hire( int all );
public int do_pay();
public int do_ask(string exit);

// Variables
private string _client;
private string* _killers;
private int _price;
private int _paid;
private int _all_doors;
private object _door;
private string _savefile;
private string _region;
private string* _responses;
private string _domain;
private string _last_room;

// -------------------- basic functions --------------------

/** @ignore */
void create() {
  generic_responses();
  do_setup++;
  ::create();
  do_setup--;  
  if (!do_setup)
    this_object()->setup();
  add_enter_commands("#move_recording");
}


/** @ignore */
void init() {
  ::init();
  if(interactive(this_player())) {
    this_player()->add_command("hire", this_object(), "<direct>",
                                  (: do_hire( 0 ) :) );
    this_player()->add_command("hire", this_object(),
                                   "<direct> to unlock an entire house",
                                   (: do_hire( 1 ) :) );
    this_player()->add_command("pay", this_object(), "<direct>");
    this_player()->add_command("ask", this_object(),
                                "<direct> to {open|unlock} [the] "
                                "<word'exit'> door",
                                (: do_ask($4[2]) :));
    this_player()->add_command("confirm", this_object(), "");

  }
}


/** @ignore */
void reset() {
  clear_false_client();
}

// -------------------- public functions --------------------

/**
 * Use this function if something went wrong and the NPC does not react to the
 * client/new clients anymore.
 */
public void free_for_hire() {
  _client = 0;
  _paid = 0;
  _door = 0;
  _all_doors = 0;
  set_move_after(60, 60);
}


/**
 * This queries the client's name.
 * @return the name of the client or 0 for no client
 */
public string query_client() {
  if(!_client)
    return 0;
  return _client;
}


/**
 * This function gets called after every move of the NPC and records it for a
 * potential return.  It should not be called manually.
 */
public void move_recording() {
  object room = environment(this_object());
  if(!room) {
    if(query_name() != "object")
      call_out("dest_me", 5);
    return;
  }
  if(_client) {
    // check if the NPC is still in the designated domain
    if(_domain && base_name(room)[0..5] == _domain) {
      // record the room if it's not inside housing
      if(!room->query_owner())
        _last_room = base_name(room);
      return;
    }
    do_command("sayto " + _client + " " + _responses[11]);
    go_back();
  }
}


/**
 * This queries the killers of the NPC.
 * @return an array listing the killers' names
 */
public string* query_killers() {
  return _killers;
}


/**
 * This queries the NPC's domain.
 * @return the first 6 chars of the domain.
 */
public string query_domain() {
  return _domain;
}


/**
 * This queries the last valid room the NPC was in.
 * @return the basename of the last room
 */
public string query_last_room() {
  return _last_room;
}


/**
 * This function is used to evaluate the client's response to the "is this the
 * door"-question.
 * @param response the response the player entered
 * @param player the player doing the input
 */
public void confirmation(string response, object player) {
  if(!response || !player)
    return;
  switch(lower_case(response)) {
  case "yes":
  case "y":
    break;
  case "no":
  case "n":
    do_command("nod");
    do_command("follow " + player->query_name());
    _door = 0;
    return;
  default:
    do_command("sayto " + player->query_name() + " " + _responses[0]);
    return;
  }
  if(!_client || player->query_name() != _client) {
    do_command("sayto " + player->query_name() + " " + _responses[1]);
    return;
  }
  // If the destination doesn't belong to the client, abort and move away
  if(!check_owner()) {
    do_command("sayto " + player->query_name() + " " + _responses[2]);
#ifdef LOGGING
    log_file(LOG, "%s: %s tried to get %s to unlock door in %s leading "
              "to %s.\n", ctime(time()), _client, query_short(),
              base_name(environment(this_object())),_door->query_dest());
#endif
  } else if( _all_doors == 0 ) {
    queue_command("emote eyes the lock on the door.", 1);
    queue_command("emote fiddles around on the lock with some wires.", 5);
    queue_command("emote seems satisfied.", 5);
    unlock(_door);

    queue_command("sayto " + player->query_name() + " " + _responses[3], 2);
#ifdef LOGGING
    log_file(LOG,
              "%s: %s successfully got %s to unlock door in %s leading %s.\n",
              ctime(time()), _client, query_short(),
              base_name(environment(this_object())), _door->query_dest());
#endif
  } else {
    queue_command("emote eyes the lock on the door.", 1);
    queue_command("emote fiddles around on the lock with some wires.", 5);
    queue_command("'Stand back and wait for me.", 5 );
    queue_command("emote opens the door and disappears into the house, locking "
                      "the door after " + query_objective() + ".", 2 );
    delay_opening( base_name( environment( this_object() ) ) );
    return;
  }
  free_for_hire();
  go_back();
}


/**
 * This queries the responses of the NPC.
 * @return an array of response-strings
 */
public string* query_responses() {
  return _responses;
}

// -------------------- setup functions --------------------

/**
 * Use this function to set the file where the killers of the NPC are stored,
 * if you want to charge the killers the double price for opening their house.
 * @param file the name of the file to save to
 * @return 1 on success, 0 on failure
 */
protected int set_savefile(string file) {
  if(!file)
    return 0;
  _savefile = file;
  load_killers();
  return 1;
}


/**
 * This function sets the base price for unlocking a door.  If the savefile is
 * set, a killer will be charged the double price.
 * @param price the base-price in money-units
 * @return 1 on success, 0 on failure
 */
protected int set_price(int price) {
  if(!price)
    return 0;
  _price = price;
  return 1;
}


/**
 * This function sets the NPCs region for determining the currency.
 * @param region the region to use
 * @return 1 on success, 0 on failure
 */
protected int set_currency_region(string region) {
  if(!region)
    return 0;
  _region = region;
  return 1;
}


/**
 * This sets the domain the NPC is restricted to.
 * @param domain the first 6 letters of the domain-path, ie "/d/am/"
 * @return 1 on success, 0 on failure
 */
protected int set_domain(string domain) {
  if(sizeof(domain) != 6)
    return 0;
  _domain = domain;
}


/**
 * This function sets the NPC's responses for the various commands.  If not
 * used generic answers will be used.  Mind that you cannot enter only a few
 * responses.  It's all or nothing.  The array should be like this:
 * 1) response to failed confirmation
 * 2) response for not hired by that player
 * 3) response for trying to enter another player's house
 * 4) response for successful opening of the door
 * 5) response for already hired by other player
 * 6) response for not paid yet
 * 7) response for attempt to hire
 * 8) response for already paid
 * 9) response for not enough money to pay
 * 10) response for cannot find specified exit
 * 11) response for successful payment (please include 'ask' hint)
 * 12) response for not leaving the domain
 * 13) response for already hired by that player
 * @param responses an array with the responses, as explained above
 * @return 1 on success, 0 on failure
 */
protected int set_responses(string* responses) {
  if(sizeof(responses) != 13)
    return 0;
  _responses = responses;
}

// -------------------- command functions --------------------

/** @ignore */
public int do_hire( int all ) {
  if(!this_player())
    return 0;
  // If the prospective client is invis to the NPC, abort
  if(!this_player()->query_visible(this_object())) {
    this_player()->add_failed_mess(this_object(),
                                    "$C$" + this_object()->the_short() +
                                   " cannot even see you.\n", ({ }));
    return 0;
  }
  // If the NPC is already hired by someone else, abort
  if(_client && this_player()->query_name() != _client) {
    do_command("sayto " + this_player()->query_name() + " " + _responses[4]);
    this_player()->add_failed_mess(this_object(), "", ({ }));
    return 0;
  }
  // If he is already hired by the player asking, abort
  if(_client && this_player()->query_name() == _client) {
    if(_paid) {
      if(member_array(this_object(), this_player()->query_followers())
          == -1) {
        do_command("nod " + this_player()->query_name());
        do_command("follow " + this_player()->query_name());
        this_player()->add_succeeded_mess(this_object(), "", ({ }));
        return 1;
      }
      do_command("sayto " + this_player()->query_name() + " " +
                  _responses[12]);
      this_player()->add_failed_mess(this_object(), "", ({ }));
      return 0;
    }
    do_command("sayto " + this_player()->query_name() + " " +
                _responses[5]);
    this_player()->add_failed_mess(this_object(), "", ({ }));
    return 0;
  }
  // Otherwise accept
  _client = this_player()->query_name();
  _all_doors = all;
  queue_command("sayto " + this_player()->query_name() + " " +
                 _responses[6], 1);
  if(member_array(_client, _killers) != -1)
    queue_command("sayto " + this_player()->query_name() +
                   " I remember you... for you it'll be " + get_price() +
                   ".  Up front, of course.", 2);
  else
    queue_command("sayto " + this_player()->query_name() + " That'll be "+
                   get_price() + " up front.", 2);
  this_player()->add_succeeded_mess(this_object(), "", ({ }));
  call_out((: payment_timeout() :), 60);
  return 1;
}


/** @ignore */
public int do_pay() {
  if(!this_player())
    return 0;
  // If the player is invis to the NPC, abort
  if(!this_player()->query_visible(this_object())) {
    this_player()->add_failed_mess(this_object(),
                                    "$C$" + this_object()->the_short() +
                                   " cannot even see you.\n", ({ }));
    return 0;
  }
  // Only accept payment from the client
  if(!_client || this_player()->query_name() != _client) {
    do_command("whisper " + this_player()->query_name() + " I appreciate "
                "that you want to give away your cash, but don't you think "
                "should 'hire' me first?");
    this_player()->add_failed_mess(this_object(), "", ({ }));
    return 0;
  }
  // If he has already been paid, abort
  if(_paid) {
    do_command("sayto " + this_player()->query_name() + " " + _responses[7]);
    this_player()->add_failed_mess(this_object(), "", ({ }));
    return 0;
  }
  // In case the client can't pay, abort
  if(this_player()->query_value_in(_region) < _price) {
    do_command("sayto " + this_player()->query_name() + " " +
                _responses[8]);
    free_for_hire();
    this_player()->add_failed_mess(this_object(), "", ({ }));
    return 0;
  }
  this_player()->pay_money(MONEY_HAND->create_money_array(calc_price(),
                                                            _region), _region);
  _paid = 1;
  set_move_after(1200, 0);
  do_command("emote puts the money into a pocket.");
  do_command("whisper " + this_player()->query_name() + " " + _responses[10]);
  init_command("follow " + this_player()->query_name(), 1);
  this_player()->add_succeeded_mess(this_object(), "$N pay$s $D.\n", ({ }));
#ifdef LOGGING
  log_file(LOG, "%s: %s hired %s for %s" +
      ( (_all_doors == 1)?" (all doors)":"" ) + "\n",
      ctime(time()), _client, query_short(), get_price() );
#endif
  remove_killer(_client);
  return 1;
}


/** @ignore */
public int do_ask(string exit) {
  object room, door;
  string dest;

  room = environment(this_object());
  if(!this_player() || !exit || !room)
    return 0;
  // If the player is invis to the NPC, abort
  if(!this_player()->query_visible(this_object())) {
    this_player()->add_failed_mess(this_object(),
                                    "$C$" + this_object()->the_short() +
                                   " cannot even see you.\n", ({ }));
    return 0;
  }
  // If the player asking is not the client, abort
  if(!_client || this_player()->query_name() != _client) {
    do_command("sayto " + this_player()->query_name() + " " + _responses[1]);
    this_player()->add_failed_mess(this_object(),
                                   "You are not " + the_short() +
                                   "'s client.\n", ({ }));
    return 0;
  }
  do_command("unfollow " + this_player()->query_name());
  dest = this_player()->find_abs(exit);
  if(room->query_destination(dest) == "/room/void") {
    do_command("sayto " + this_player()->query_name() + " " +
                _responses[9]);
    do_command("follow " + this_player()->query_name());
    this_player()->add_failed_mess(this_object(),
                                    "This exit is not valid.\n", ({ }));
    return 0;
  }
  foreach(door in room->query_hidden_objects())
    if(door->query_dest() == room->query_destination(dest)) {
      _door = door;
      break;
    }
  if( _all_doors == 0 )
    do_command("whisper " + this_player()->query_name() + " Can you confirm "
                "that this is your place?  And that you want the " + exit +
                " door opened?");
  else
    do_command("whisper " + this_player()->query_name() + " So that's your "
                "place on the other side?  Can you confirm that you want the " +
                exit + " door and all the others in your house opened?" );
  this_player()->add_succeeded_mess(this_object(), "", ({ }));
  tell_object(this_player(), "[y]es/[n]o: ");
  input_to("confirmation", 0, this_player());
  return 1;
}

// -------------------- internals --------------------

/** @ignore */
void event_enter(object ob, string message, object from) {
  if(from && environment(ob) == this_object()) {
    if(ob->query_name() == "coin") {
      do_command("sayto " + file_name(from) + " You have to pay me.");
      do_command("give coins to " + file_name(from));
      return;
    }
    do_command("sayto " + file_name(from) + " I don't take donations.");
    do_command("give " + file_name(ob) + " to " + file_name(from));
  }
}


/** @ignore */
private void save_killers() {
  string killerstring, killer;

  if(!_savefile)
    return;
  if(!sizeof(_killers)) {
    unguarded((: write_file($(_savefile), "--- no killers ---", 1) :));
    return;
  }
  killerstring = "";
  foreach(killer in _killers)
    killerstring += killer + " ";
  unguarded((: write_file($(_savefile), $(killerstring), 1) :));
}


/** @ignore */
private void load_killers() {
  string killerstring;

  if(!_savefile)
    return;
  if(file_size(_savefile) == -1) {
    _killers = ({ });
    return;
  }
  killerstring = unguarded((: read_file($(_savefile)) :));
  if( !killerstring || killerstring == "--- no killers ---" ||
      !_killers = explode(killerstring, " "))
    _killers = ({ });
}


/** @ignore */
varargs object do_death(object killer, object weapon, string attack) {
  if(killer && interactive(killer)) {
    if(member_array(killer->query_name(), _killers) == -1) {
      if (!_killers) {
         _killers = ({ });
      }
      _killers += ({ killer->query_name() });
    }
  }
  save_killers();
  if(weapon && attack)
    return ::do_death(killer, weapon, attack);
  if(weapon)
    return ::do_death(killer, weapon);
  if(killer)
    return ::do_death(killer);
  return ::do_death();
}


/** @ignore */
private void remove_killer(string name) {
  int index;

  index = member_array(name, _killers);
  if(index == -1)
    return;
  if(sizeof(_killers) == 1)
    _killers = ({ });
  if(index == 0)
    _killers = _killers[ 1.. ];
  if(index == sizeof(_killers))
    _killers = _killers[ 0..(sizeof(_killers) -1) ];
  _killers = _killers[ 0..(index - 1) ] + _killers[ (index + 1).. ];
}

/** @ignore */
private void clear_false_client() {
  if(_client && find_living(_client) &&
      environment(find_living(_client)) == environment(this_object()))
    return;
  free_for_hire();
}


/** @ignore */
private void payment_timeout() {
  if(_client && !_paid)
    free_for_hire();
}


/** @ignore */
private int check_owner() {
  string dest = _door->query_dest();

  if(load_object(dest)->query_owner() == _client)
    return 1;
  return 0;
}

/** @ignore */
private void unlock(object door) {
  door->set_unlocked();
  event( load_object( door->query_dest() ), "save");
  event( environment(), "save");
}

/** @ignore */
private string get_price() {
  int price;
  if(member_array(_client, _killers) != -1)
    price = 2 * _price;
  else
    price = _price;
  if( _all_doors == 1 )
    price*= 5;
  return MONEY_HAND->money_string(MONEY_HAND->create_money_array(price,
                                                                 _region));
}


/** @ignore */
private int calc_price() {
  int price;
  if(member_array(_client, _killers) != -1)
    price = 2 * _price;
  price = _price;
  if( _all_doors == 1 )
    price *= 5;
  return price;
}


/** @ignore */
private void go_back() {
  object room, door;
  int i;
  if(!room = environment(this_object()))
    return;
  if(!_last_room || base_name(room) == _last_room) {
    do_command(room->query_exits()[random(sizeof(room->query_exits()))]);
    return;
  }
  i = member_array(_last_room, room->query_dest_dir());
  if(i == -1)
    move(_last_room, "$N walk$s in.", "$N walk$s away.");
  else {
    foreach(door in room->query_hidden_objects())
      if(door->query_dest() == _last_room &&
          door->query_locked()) {
        move(_last_room, "$N walk$s in, locking the door.",
              "$N unlock$s the door and leave$s, locking it "
              "again.");
        return;
      }
    do_command(room->query_dest_dir()[i-1]);
  }
}


/** @ignore */
private void generic_responses() {
  _responses = ({0,0,0,0,0,0,0,0,0,0,0,0,0});
  _responses[0] = "I do not understand.";
  _responses[1] = "You have to hire me.";
  _responses[2] = "This door does not lead to your house.  I cannot help you.";
  _responses[3] = "It has been a pleasure doing business with you.";
  _responses[4] = "I am already hired by someone else.";
  _responses[5] = "You have to 'pay' me.";
  _responses[6] = "You do require my services?";
  _responses[7] = "You already paid me.";
  _responses[8] = "You do not have enough money.";
  _responses[9] = "I cannot find that door.";
  _responses[10] = "Very well.  Please lead me to your house and 'ask' me to "
    "open the door that troubles you.";
  _responses[11] = "I won't leave my beloved home, sorry.  I'll wait there "
    "for a while, if you change your mind and come back.";
  _responses[12] = "You already hired me.";
}

/** @ignore */
private void unlock_all( string path ) {
    string* files = get_dir( path + "*.c" );
    string file;
    object room, ob;

    if( !sizeof( files ) )
        return;
    foreach( file in files ) {
        room = load_object( path + file );
        if( room ) {
            foreach( ob in room->query_hidden_objects() )
                if( ob->query_dest() )
                     ob->set_unlocked();
            event( room, "save" );
        }
    }
}

/** @ignore */
private void delay_opening( string env ) {
    string path;
    string* path_bits;
    path_bits = explode( env, "/" );
    path_bits[ sizeof( path_bits ) -1 ] = "";
    path = "/" + implode( path_bits, "/" );
    move( "/room/void" );
    call_out( "finish_opening", 30, path, env );
}

/** @ignore */
void finish_opening( string path, string env ) {
    unlock_all( path );
#ifdef LOGGING
    log_file(LOG,
              "%s: %s successfully got %s to unlock all doors in %s.\n",
              ctime(time()), _client, query_short(), path );
#endif
    move( env, "$N leaves the house, rubbing " + query_objective() +
           " hands.\n", "" );
    free_for_hire();
    go_back();
}
// --- END [/mnt/home2/grok/lib/std/npc/locksmith.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/npc/test_npc.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/npc/test_npc.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628951   Available: 13576305
Inodes: Total: 5242880    Free: 4960135
469 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/npc/test_npc.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628951   Available: 13576305
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <npc/goals.h>
#include <npc/plan.h>

inherit "/std/npc/npc_intelligent";

void setup() {
   string goal;

   set_name("fluff");
   set_short("bit of fluff");
   set_long("A small bit of fluff.");
   set_race("human");
   set_guild("warrior");
   set_level(10);
   goal = GOALS_DIR + "basic/stay_alive_basic";
   goal->add_goal_to_npc(this_object(), ([ ]), 100);
   load_chat(100, ({ 1, "'Scruff!",
                     1, "'Chickens?",
			}));
} /* setup() */
// --- END [/mnt/home2/grok/lib/std/npc/test_npc.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/hospital/alignment.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/hospital/alignment.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628951   Available: 13576305
Inodes: Total: 5242880    Free: 4960135
3101 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/hospital/alignment.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628951   Available: 13576305
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This code is used to determine the alignment of NPCs in the hospital.
 */ 

/*
 * These defines set the shape of the distribution of alignments handed out
 * by pick_al.  Using the standard normal distribution, split into ten steps
 * on each side of the average, we can safely disregard the probability of
 * values outside of the range of -3.0 to 3.0 (99.7% of values will fall
 * within this range of three * standard deviation from the average).
 *        Range           Prob.
 *  P( 0.0 < z < 0.3 ) = 0.1179
 *  P( 0.3 < z < 0.6 ) = 0.1078
 *  P( 0.6 < z < 0.9 ) = 0.0902
 *  P( 0.9 < z < 1.2 ) = 0.0690
 *  P( 1.2 < z < 1.5 ) = 0.0483
 *  P( 1.5 < z < 1.8 ) = 0.0309
 *  P( 1.8 < z < 2.1 ) = 0.0180
 *  P( 2.1 < z < 2.4 ) = 0.0097
 *  P( 2.4 < z < 2.7 ) = 0.0047
 *  P( 2.7 < z ) =       0.0035
 *
 *  These probabilites are then converted into cumulative limits out of
 *  a total chance, as integers:
*/
#define TOTAL_CHANCE 150
#define CENTRE 0
#define LIMIT_ONE     35
#define LIMIT_TWO     68
#define LIMIT_THREE   95
#define LIMIT_FOUR   115
#define LIMIT_FIVE   130
#define LIMIT_SIX    139
#define LIMIT_SEVEN  145
#define LIMIT_EIGHT  147
#define LIMIT_NINE   149

/**
 * This function produces a random alignment for an npc, based on a
 * normal distribution around a supplied average, with a maximum and
 * minimum limit provided by a requested range.
 * <p>
 * The alignment produced will be within the range[ average - range,
 * average + range ]
 * @param average The average alignment for this npc
 * @param range The range request for alignment - the difference between
 * average and maximum possible alignment
 * <p>
 */
int pick_al( int average, int range ) {
   int choice, section, section_width, result;

   // Must be a positive range.
   if( range < 0 ) {
      range = -range;
   }

   // Must have a range of 10 at least.
   if( range < 10 ) {
      range = 10;
   }

   section_width = floor( range / 10 );

   choice = random( TOTAL_CHANCE );

   switch( choice ) {
      case CENTRE..LIMIT_ONE:
         section = 0;
         break;
      case ( LIMIT_ONE + 1 )..LIMIT_TWO:
         section = 1;
         break;
      case ( LIMIT_TWO + 1 )..LIMIT_THREE:
         section = 2;
         break;
      case ( LIMIT_THREE + 1 )..LIMIT_FOUR:
         section = 3;
         break;
      case ( LIMIT_FOUR + 1 )..LIMIT_FIVE:
         section = 4;
         break;
      case ( LIMIT_FIVE + 1 )..LIMIT_SIX:
         section = 5;
         break;
      case ( LIMIT_SIX + 1 )..LIMIT_SEVEN:
         section = 6;
         break;
      case ( LIMIT_SEVEN + 1 )..LIMIT_EIGHT:
         section = 7;
         break;
      case ( LIMIT_EIGHT + 1 )..LIMIT_NINE:
         section = 8;
         break;
      default:
         section = 9;
         break;
   }

   result = section * section_width;
   result = result + random( section_width );

   switch( random( 2 ) ) {
      case( 0 ):
         result = average + result;
         break;
      default:
         result = average - result;
         break;
   }

   result = result + average;
   return result;
} /* pick_al */
// --- END [/mnt/home2/grok/lib/std/hospital/alignment.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/guilds/standard.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/guilds/standard.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628950   Available: 13576304
Inodes: Total: 5242880    Free: 4960135
12705 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/guilds/standard.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628950   Available: 13576304
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*   -*- LPC -*-   */
/*
 * $Locker:  $
 * $Id: standard.c,v 1.10 2003/04/15 17:01:47 ceres Exp $
 */
#include <skills.h>
#include <tune.h>
#include <guilds.h>
#include <config.h>

inherit "/std/object";

nosave string gp_skill;
nosave string start_pos;
nosave mixed *commands;
nosave string *skills;
nosave mixed *spells;

protected void create() {
   gp_skill = "other.points";
   start_pos = CONFIG_START_LOCATION;
   skills = ({ "crafts", "faith", "fighting", "other" });
   commands = ({ });
   spells = ({ });
   ::create();
}

string query_gp_skill() { return gp_skill; }

void set_gp_skill( string word ) { gp_skill = word; }

void set_gp( object thing ) {
   if ( !thing ) {
      return;
   }
   thing->set_max_gp( 50 + (int)thing->query_skill_bonus( gp_skill ) );
} /* set_gp() */

string query_start_pos( object thing ) { return start_pos; }

void set_start_pos( string word ) { start_pos = word; }

string *query_skills() { return skills; }

void set_skills( string *words ) { skills = words; }

int add_command(string name, int add_if_player) {
   if (member_array(name, commands) != -1) {
      return 0;
   }
   commands += ({ name, ({ add_if_player }) });
   return 1;
}

int remove_command(string name) {
   int i;

   if ((i = member_array(name, commands)) == -1) {
      return 0;
   }
   commands = delete(commands, i, 1);
   return 1;
}

int do_command(string name, mixed param) {
   log_file("BAD_COMMANDS", "do_command() called on /std/guilds/standard.c\n");
   return 0;
}

int add_spell(string name, mixed ob, string func_name, int add_if_player) {
   int i;

   if ((i = member_array(name, spells)) != -1) {
      return 0;
   }
   spells += ({ name, ({ ob, func_name, add_if_player }), });
   return 1;
}

int remove_spell(string name) {
   int i;

   if ((i= member_array(name, spells)) == -1) {
      return 0;
   }
   spells = delete(spells, i, 2);
   return 1;
}

int cast_spell(string name, mixed bing) {
   int i;

   if ((i=member_array(name, spells)) == -1) {
      return 0;
   }
   return (int)call_other(spells[i+1][0], spells[i+1][1], bing);
}

mixed *query_spells() { return spells; }

string *query_commands() { return commands; }

/*
 * The next two functions should be redefined on any guild item you write...
 */
int query_skill_cost( string skill ) { return 10; }

int query_skill_max_level( string skill ) { return 10; }

/**
 * This is where you would set up any shadows you want on the player
 * object, or just do what you will..
 * @param pl the player being started
 */
void start_player(object pl) {
   int i;

   if (!spells) {
      spells = ({ });
   }
   for (i=0;i<sizeof(spells);i+=2) {
      if (spells[i+1][2] || !interactive(pl)) {
         pl->add_spell(spells[i], spells[i+1][0], spells[i+1][1]);
      }
   }
   if (!pointerp(commands)) {
      commands = ({ });
   }
   for (i=0;i<sizeof(commands);i+=2) {
      if (commands[i+1][0] || !interactive(pl)) {
         pl->add_known_command(commands[i]);
      }
   }
}

void leave_guild() { return; }

void player_quit() { return; }

void player_save() { return; }

void player_heart_beat( string guild, object thing ) {
/* This is already done in the /obj/monster and /global/player heart beats.
   int *rates;
   rates = this_player()->query_inc_rates();
   thing->adjust_gp( rates[ 0 ] );
   thing->adjust_hp( rates[ 1 ] );
*/
} /* player_heart_beat() */

void set_level( object thing, int level, string guild ) {
   call_out( "set_new_level", 1, ({ thing, level, guild }) );
} /* set_level() */

string adjust_primaries( object thing, int level ) {
  int i;
  string stat_list;
  
  stat_list = "";
  for ( i = 0; i < sizeof( skills ); i++ ) {
    if(level - thing->query_skill(skills[i]) > 0)
      thing->add_skill_level(skills[i], level - thing->query_skill(skills[i]));
    
    stat_list += (string)SKILL_OB->query_skill_stat(skills[i]);
    if(random(2)) {
      stat_list += "C";
    }
  }
  return stat_list;
}

void set_new_level( mixed *args ) {
   int i, j, level;
   string stat_list;
   object thing;

   thing = args[ 0 ];
   if ( !thing ) {
      return;
   }
   level = args[ 1 ];

   thing->add_skill_level("fighting", level / 4 );
   thing->add_skill_level("other", level / 4 );
   switch(thing->query_guild_ob()) {
   case "/std/guilds/warrior":
   case "/std/guilds/assassin":
     thing->add_skill_level("other.health", level);
     break;
   case "/std/guilds/thief":
     thing->add_skill_level("other.health", (level * 3) / 4);
     break;
   default:
     thing->add_skill_level("other.health", level / 2);
   }
   thing->add_skill_level("other.perception", level / 3);

   
   stat_list = adjust_primaries( thing, level );
   
   
   // Unique NPCs, non-sentient npcs or thise with "keep setup stats"
   // don't require custom stat arrangements.
   if(thing->query_property( "unique" ) ||
      thing->query_property( "keep setup stats" ) ||
      (!thing->query_race_ob() ||
       !(thing->query_race_ob())->query_humanoid()))
     return;
   
   thing->adjust_con( -6 + random( 3 ) );
   thing->adjust_dex( -6 + random( 3 ) );
   thing->adjust_int( -6 + random( 3 ) );
   thing->adjust_str( -6 + random( 3 ) );
   thing->adjust_wis( -6 + random( 3 ) );
   for ( i = 0; i < 25; i++ ) {
      j = random( strlen( stat_list ) );
      switch ( stat_list[ j .. j ] ) {
         case "C" :
            thing->adjust_con( 1 );
            break;
         case "D" :
            thing->adjust_dex( 1 );
            break;
         case "I" :
            thing->adjust_int( 1 );
            break;
         case "S" :
            thing->adjust_str( 1 );
            break;
         default :
            thing->adjust_wis( 1 );
            break;
      }
   }
} /* set_new_level() */

/**
 * This method figures out the level of the npc or player.
 * @param thing the thing to find the level of
 * @return the level of the thing
 */
int query_level( object thing ) {
   int i, lvl;

   if ( !thing || !sizeof( skills ) ) {
      return 0;
   }
   for ( i = 0; i < sizeof( skills ); i++ ) {
      lvl += (int)thing->query_skill( skills[ i ] );
   }
   lvl /= sizeof( skills );
   return lvl;
} /* query_level() */

/**
 * This method returns the title of the player.
 * @param player the player to find the title of
 * @return the title name
 */
string query_title( object player ) { return "the Adventurer"; }

/**
 * This method is called whenever a player advances a skill.
 * @param thing the player advacing the skill
 * @param skill the name of the skill
 * @param level the level it is advanced to
 */
void skills_advanced( object thing, string skill, int level ) {
   if ( strsrch( skill, "covert" ) != -1 ) {
      if ( ( (int)thing->query_skill( "covert.stealth" ) > 5 ) &&
             !thing->query_known_command( "peek" ) ) {
         tell_object( thing, "You realise that you could use your newly "
                      "improved stealth to \"peek\" covertly at someone, and "
                      "maybe they won't notice...\n" );
         thing->add_known_command( "peek" );
      }
   } else if ( strsrch( skill, "fighting.combat.parry.held" ) != -1 ) {
      if ( ( (int)thing->query_skill( "fighting.combat.parry.held" ) > 50 ) &&
                  !thing->query_known_command( "riposte" ) ) {
         tell_object( thing, "You realise that you could use your newly "
                     "improved parry to \"riposte\" someones attack.\n" );
         thing->add_known_command( "riposte" );
      }
   }
} /* skills_advanced() */

/**
 * Dummy function for guilds without positions
 * This method adds a new position for the subguild.
 * @param sub_guild the sub guild
 * @param position position to add
 * @param max the maximum number of people appointed to this position
 * @param abilities the abilities associated with this position
 * @param description the descriptions associated with this position
 * ({ title|({male_title,female_title}), ... })
 * @return DEITY_POSITION_OK if successful, DEITY_POSITION_FAIL if the
 * position already exists
 * @see remove_position()
 * @see query_position()
 * @see query_positions()
 */
int add_position( string sub_guild, string position, 
                           int max, string* abilities, mixed* description ) {
    return POSITION_FAIL;
} /* add_position() */

/**
 * Dummy function for guilds without positions
 * This method removes a position for this subguild.
 * @param sub_guild the sub guild
 * @param position position to remove
 * @return POSITION_OK if successful, POSITION_FAIL if the
 * position didn't exist
 * @see add_position()
 * @see query_position()
 * @see query_positions()
 */
int remove_position( string sub_guild, string position ) {
    return POSITION_FAIL;
} /* remove_position() */

/**
 * Dummy function for guilds without positions
 * This method returns all positions for this guild.
 * @param sub_guild the sub guild
 * @return 0 if the position don't exist, an array of appointments
 * if is does, with 0's for unfilled positions
 * @see add_position()
 */
mapping query_positions( string sub_guild, string position ) {
    return 0;
} /* query_positions() */

/**
 * Dummy function for guilds without positions
 * This method returns the appointments for this position in this 
 * subguild.
 * @param sub_guild the sub guild
 * @param position position to return
 * @return 0 if the position don't exist, an array of appointments
 * if is does, with 0's for unfilled positions
 * @see add_position()
 */
string *query_position_appointments( string sub_guild, string position ) {
    return 0;
} /* query_position_appointments() */

/**
 * Dummy function for guilds without positions
 * This method returns the description array for this position.
 * @param sub_guild the sub guild
 * @param position position to return
 * @return 0 if the position don't exist, an array of descriptions if 
 * it does, currently defined to hold the title
 * ({ title|({male_title,female_title}), ... })
 * @see add_position()
 */
mixed *query_position_description( string sub_guild, string position ) {
    return 0;
} /* query_position_description() */

/**
 * Dummy function for guilds without positions
 * This method returns the abilities for a position.
 * @param sub_guild the sub guild
 * @param position position to return
 * @return 0 if the position don't exist, an array of abilities
 * if is does
 * @see add_position()
 */
string *query_position_abilities( string sub_guild, string position ) {
    return 0;
} /* query_position_abilities() */

/**
 * Dummy function for guilds without positions
 * This method removes all appointments for a guild.   
 * @param sub_guild the sub guild
 * @see add_position()
 */
void reset_positions( string sub_guild ) {
} /* reset_position() */

/**
 * Dummy function for guilds without positions
 * This method appoints the player to a position.   If sub_guild is 0,
 * the guild object is supposed to figure out the subguild from the 
 * player_name.
 * @param sub_guild the sub guild
 * @param position the position
 * @param player_name the player
 * @return POSITION_FAIL if it failed, POSITION_OK if it succeeded.
 */
int appoint_position( string sub_guild, string position,
                                 string player_name ) {
    return POSITION_FAIL;
} /* appoint_position() */

/**
 * Dummy function for guilds without positions
 * This method dismisses the player from a position.   If sub_guild is 0,
 * the guild object is supposed to figure out the subguild from the 
 * player_name.
 * @param sub_guild the sub guild
 * @param position the position
 * @param player_name the player
 * @return POSITION_FAIL if it failed, POSITION_OK if it succeeded.
 */
int dismiss_position( string sub_guild, string position,
                                 string player_name ) {
    return POSITION_FAIL;
} /* dismiss_position() */

/**
 * Dummy function for guilds without positions
 * This method returns the position held by the player. If sub_guild is
 * 0, the guild object is supposed to figure out what sub_guild (if any)
 * is relevant.
 * @param sub_guild the sub guild
 * @param player_name the player
 * @return the position the player is appointed to in sub_guild.
 */
string query_position( string sub_guild, string player_name ) {
    return 0;
} /* query_position() */

/**
 * Dummy function for guilds without positions
 * Test if a player/npc has a specific ability.
 * @param thing either a string, being the name of a player, or an object
 * being the actual player/npc to check for a guild ability.
 * @param ability the ability to check for.
 * @return 1 if thing has that ability, 0 if not.
 */
int query_guild_ability( mixed thing, string ability ) {
    return 0;
} /* query_guild_ability() */

// --- END [/mnt/home2/grok/lib/std/guilds/standard.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/guilds/warrior.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/guilds/warrior.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628946   Available: 13576300
Inodes: Total: 5242880    Free: 4960135
3219 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/guilds/warrior.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628946   Available: 13576300
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <player_handler.h>
#include <top_ten_tables.h>
#include <playtesters.h>

#define SAVE_FILE ( "/save/guilds/warriors/warrior_ob" )

inherit "/std/guilds/standard";

void load_file();
void save_file();

void setup() {
  set_name("warriors");
  set_short("Warriors' Guild");
  set_long("The Warriors' Guild.\n\n"
           "The Warriors' Guild is for the brave and "
           "heroic.  As a member you can expect to "
           "recieve a sound background in beating, "
           "bashing, slicing, and dicing a variety of "
           "opponents up with a wide selection of "
           "weapons.  The evaluation of arms and armour "
           "will also be covered in detail.  Join this "
           "guild if you wish to journey to interesting "
           "places, meet interesting people, and give "
           "them a sound thrashing.\n");
  set_gp_skill("fighting.points");
  set_start_pos("/d/dist/pumpkin/squash/squash5");
  set_skills(({  "fighting.points",
                 "fighting.combat.melee.sharp",
                 "fighting.combat.melee.pierce",
                 "fighting.combat.melee.blunt",
                 "fighting.combat.melee.unarmed",
                 "fighting.combat.range.thrown",
                 "fighting.combat.range.fired",
                 "fighting.combat.parry.melee",
                 "fighting.combat.parry.range",
                 "fighting.combat.dodging.melee",
                 "fighting.combat.dodging.range",
                 "fighting.combat.special.weapon",
                 "fighting.combat.special.unarmed",
                 "other.evaluating.weapons",
                 "other.evaluating.armour"  }));
} /* setup() */


int query_skill_cost(string skill) {
  string *bits;
  if(member_array(skill, skills) != -1)
    return 3;
  bits = explode(skill, ".");
  switch(bits[0]) {
    case "faith" :
      return 15;
    case "fighting" :
      return 5;
    case "magic" :
      return 50;
    default :
      return 10;
  }
} /* query_skill_cost() */

int query_skill_max_level( string skill ) {
  string *bits;
  if(member_array(skill, skills) != -1)
    return 300;
  bits = explode(skill, ".");
  switch (bits[0]) {
    case "faith" :
      return 25;
    case "fighting" :
      return 50;
    case "magic" :
      return 5;
    case "other" :
      return 25;
    default :
      return 10;
  }
} /* query_skill_max_level() */

string query_title( object player ) {
  int lvl, female;
  female = (int)player->query_gender() == 2;
  lvl = query_level( player );
  switch( lvl ) {
      case 0..15: return "the Novice Fighter";
      case 16..30: return "the Apprentice Fighter";
      case 31..45: return "the Skillful Fighter";
      default: return "the Grave of All Hope";
    }
} /* query_title() */

/**
 *Method is used to see if a player is a warrior
 *@param player name of player
 */
int query_warrior( string player ) {
  if( PLAYER_HANDLER->test_guild( player ) == "/std/guilds/warrior" ) {
    return 1;
  }
  return 0;
}

/**
 *Method is used to see if a player is a warrior
 *@param player player object
 */
int query_warrior_ob( object player ) {
  if( player->query_guild_ob() == "/std/guilds/warrior" ) {
    return 1;
  }
  return 0;
}
// --- END [/mnt/home2/grok/lib/std/guilds/warrior.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/languages/rabbit.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/languages/rabbit.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628945   Available: 13576299
Inodes: Total: 5242880    Free: 4960135
573 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/languages/rabbit.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628945   Available: 13576299
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*
 * Rabbit
 *
 * by pinkfish
 */

#include <language.h>

inherit LANGUAGE_INHERIT;

void setup() {
   set_long( "This is the local language of Rabbit.\n" );
   set_name( "Rabbitian" );
   set_start_text_bit( "Some carefully constructed characters "
                       "that might mean:\n" );
} /* setup() */

mixed do_garble_text( string text ) {
    return ({ "whats", "up", "doc", "carrot" })[random(4)];
} /* do_garble_text() */


string do_garble( string text, string text_type )  {
    return ({ "whats", "up", "doc", "carrot" })[random(4)];
} /* do_garble() */
// --- END [/mnt/home2/grok/lib/std/languages/rabbit.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/languages/language_inherit.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/languages/language_inherit.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628945   Available: 13576299
Inodes: Total: 5242880    Free: 4960135
7024 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/languages/language_inherit.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628945   Available: 13576299
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: language_inherit.c,v 1.9 2003/06/04 23:30:00 pinkfish Exp $
 * 
*/
#include <fixed_random.h>
#include <tasks.h>
#include <living.h>

/*
 * The standard language unit.
 *
 * The level of a language ranges from 0-200.  At 0 everything is
 * garbled, at 200 nothing is.  In between the value is basicly
 * a percentage (with modifications due to length of word).
 */

private string _long;
private string _name;
private string _start_text_bit;

void setup();

void create() {
  setup();
} /* create() */

void set_long(string str) {
   _long = str;
} /* set_long() */

string query_long() {
   return _long;
} /* query_long() */

void set_name(string str) {
   _name = str;
} /* set_name() */

string query_name() {
   return _name;
} /* set_name() */

/*
 * This function should be overwritten higher up the chain.
 */
void setup() {
} /* setup() */

void set_start_text_bit(string str) {_start_text_bit = str; }

/*
 * Default garbler, over-ridden by functions  higher in the
 * inherit chain.
 */
string do_garble(string word, string type) {
  string ret;
  int i;

  ret = "";
  for (i=0;i<strlen(word);i++)
    if (word[i] != ' ')
      ret += "*";
    else
      ret += " ";
  return ret;
} /* do_garble() */

void check_level_increase(object player, int difficulty, int level,
                          string skill, string mess) {
   int chance;


   if(query_verb() == "shout" || player->query_property("dead") ||
      player->query_property(PASSED_OUT) ||
      (userp(player) && !interactive(player)))
     return;

   // If they arent speaking this language then don't use their gps and
   // don't give them a chance of an increase.
   if(player->query_current_language() !=
      lower_case(this_object()->query_name()))
     return;
   
   if (player->query_property("last message:" + skill) == mess ||
       player->query_property("dead")) {
      return ;
   }

   if(player->query_specific_gp("other") < difficulty) {
     return;
   } else {
     player->adjust_gp(-(difficulty*2));
   }
   
   /* 6 minute timeout...  Can get a thingy on it again after 6 minutes */
   player->add_property("last message:" + skill, mess, 360);

   if (difficulty <= level && level < 100) {
      /*
       * This is the base chance, hard at the edges and easier in the
       * middle. 
       */
        // chance = 525 + ((level - 50) * (level - 50)) / 8;
        // tweaked by ceres to give a slightly higher chance at low
        // skill levels.
        chance = 800 + ((level - 40) * (level - 40)) / 20;

      /* How to modify by difficulty? */
      chance -= level - difficulty;

      if (random(1000) > chance) {
          // Taffyd removed the third parameter so that the standard tm 
          // delay checks would still apply. 
        if(player->add_skill_level(skill, 1)) {
          /* Give them a level */
          //
          // Also commented this out, the message is done after the 
          // tm_check_ok() is successfully executed.
          //
          //TASKER->award_made(player->query_name(), file_name(this_object()),
          //                   skill, level);
          tell_object(player, "%^YELLOW%^You feel like the " +
                      capitalize(_name) +
                      " language is less confusing.%^RESET%^\n");
        }
      }
   }
} /* check_level_increase() */

string garble_message(string mess, object player, object speaker,
                      string type, string skill, int no_increase) {
  int i, level, num;
  int max_difficulty, diff, difference;
  string *bits;
  int something_garbled;

  level = player->query_skill(skill);
  if (level > 100) {
    player->add_skill_level(skill, 100 - level, 1);
  }
  num = speaker->query_skill(skill);
  if (num > 100) {
    speaker->add_skill_level(skill, 100 - num, 1);
  }

  difference = speaker->query_skill(skill) - player->query_skill(skill);
  
  if (num < level)
    level = num;
  if (level >= 100) {
    return mess;
  }

  if (level == 0) {
    max_difficulty = 0;
  } else {
    max_difficulty = 1000;
  }

  /* Otherwise it is more complicated */
  /*
   * This will always generate the same garbled string from the
   * same input
   */
  /*
   * Don't remove the seed thingy.  I want the same random sequence each
   * time..
   */
  RANDOM_OBJ->set_seed(crc32(mess));
  bits = explode(mess, " ");
  for (i=0;i<sizeof(bits);i++) {
    if (strlen(mess)) {
      if (level > 0) {
         num = (int)RANDOM_OBJ->random(100);
         if (strlen(mess) < 8) {
           diff = (level*100) / (strlen(mess)*10);
           if (num >= (level*100 / strlen(mess)*10)) {
             if (max_difficulty > diff)
               max_difficulty = diff;
             if (interactive(player)) {
               bits[i] = do_garble(bits[i], type);
               something_garbled = 1;
             } else {
               /* Don't waste time garbling for npcs. */
               bits[i] = "";
             }
           }
         } else {
           diff = (level*100) / 90;
           if (num >= diff) {
             max_difficulty = level*100 / 100;
             if (interactive(player)) {
               bits[i] = do_garble(bits[i], type);
               something_garbled = 1;
             } else {
               /* Don't waste time garbling for npcs. */
               bits[i] = "";
             }
           }
         }
      } else {
         if (interactive(player)) {
           bits[i] = do_garble(bits[i], type);
           something_garbled = 1;
         } else {
           /* Don't waste time garbling for npcs. */
           bits[i] = "";
         }
      }
    }
  }

  /* Max_diffculty is actually a lower bound, not an upper bound... */

  if (something_garbled && (difference > -10) && !no_increase) {
    /* Only get a level increase if you did not understand something */
    check_level_increase(player, max_difficulty, level, skill, mess);
  }
  return implode(bits, " ");
} /* garble_message() */

mixed garble_say(string start, string mess, object player,
                 object from, string type, string skill, int no_increase) {
  return ({ start, garble_message(mess, player, from, "speech", skill,
                                  no_increase) });
} /* garble_say() */

string garble_text( mixed text, object thing, object player, string skill) {
  string bing;

  if (stringp(text)) {
    if (player->query_default_language() != query_name()) {
      return _start_text_bit +
        garble_message(text, player, player, "text", skill, 0);
    } else {
      return garble_message(text, player, player, "text", skill, 0);
    }
  }

  if ( pointerp( text ) ) {
    if ( ( bing = (string)text[ 0 ]->garble_text( text, thing, player ) ) ) {
      if (player->query_default_language() != query_name()) {
        return _start_text_bit + bing;
      } else {
        return bing;
      }
    }
  }

  return "You cannot read the spidery writing.\n";
} /* garble_text() */

void dest_me() {
  destruct(this_object());
} /* dest_me() */
// --- END [/mnt/home2/grok/lib/std/languages/language_inherit.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/languages/general.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/languages/general.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628943   Available: 13576297
Inodes: Total: 5242880    Free: 4960135
1071 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/languages/general.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628943   Available: 13576297
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: general.c,v 1.2 2002/07/30 20:58:30 pinkfish Exp $
 * $Log: general.c,v $
 * Revision 1.2  2002/07/30 20:58:30  pinkfish
 * Make the garbling work.
 *
 * Revision 1.1  2002/07/30 20:53:05  pinkfish
 * Initial revision
 *
 * Revision 1.1  1998/01/06 04:27:40  ceres
 * Initial revision
 * 
*/
/*
 * THis is a language to use where anyone can understand it.
 */

string long() {
  return 
"This is the normal language spoken by most creatures.\n";
}

mixed garble_tell(string start, string mess) {
  return ({ start, mess });
}

mixed garble_shout(string start, string mess) {
  return ({ start, mess });
}

mixed garble_say(string start, string mess) {
  return ({ start, mess });
}

string garble_text( mixed text, object thing, object player, string skill) {
   string bing;

   if (stringp(text)) {
      return text;
   }

   if ( pointerp( text ) ) {
      if ( ( bing = (string)text[ 0 ]->garble_text( text, thing, player ) ) ) {
         return bing;
      }
   }

   return "You cannot read the furry writing.\n";
}


// --- END [/mnt/home2/grok/lib/std/languages/general.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/languages/wommon.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/languages/wommon.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628943   Available: 13576297
Inodes: Total: 5242880    Free: 4960135
1244 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/languages/wommon.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628943   Available: 13576297
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: wommon.c,v 1.1 1998/01/06 04:27:40 ceres Exp $
 * $Log: wommon.c,v $
 * Revision 1.1  1998/01/06 04:27:40  ceres
 * Initial revision
 * 
*/
/*
 * The standard language unit.
 */

string long() {
  return
"International womens day language.\n";
}

string filter_string(string str) {
  return replace(" "+str,
      ({ " he ", " they ",
         " He ", " They ",
         " HE ", " THEY ",
         " his ", " theirs ",
         " His ", " Theirs ",
         " HIs ", " THEIrs ",
         " HIS ", " THEIRS ",
         " him ", " them ",
         " Him ", " Them ",
         " HIm ", " THem ",
         " HIM ", " THEM ",
         "man", "person",
         "Man", "Person",
         "MAn", "PERson",
         "MAN", "PERSON", }))[1..10000];
} /* filter_string() */

mixed garble_tell(string start, string mess) {
  return ({ start, filter_string(mess) });
} /* garble_tell() */

mixed garble_shout(string start, string mess) {
  return ({ start, filter_string(mess) });
} /* garble_shout() */

mixed garble_say(string start, string mess) {
  return ({ start, filter_string(mess) });
} /* garble_say() */

mixed garble_text(string str, object ob) {
  return filter_string(str);
} /* garble_text() */
// --- END [/mnt/home2/grok/lib/std/languages/wommon.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/languages/grunt.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/languages/grunt.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628942   Available: 13576296
Inodes: Total: 5242880    Free: 4960135
781 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/languages/grunt.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628942   Available: 13576296
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: grunt.c,v 1.1 1998/01/06 04:27:40 ceres Exp $
 * $Log: grunt.c,v $
 * Revision 1.1  1998/01/06 04:27:40  ceres
 * Initial revision
 * 
*/
/*
 * The language everyone can speak.  But no one understands.
 */

string long() {
  return "Consists of grunting noises.\n";
}

mixed garble_say(string start, string rest) {
  string nam, loud;

  sscanf(start, "%s %s:", nam, start);
  if (sscanf(start, "%s loudly", start) == 1)
    loud = " loudly";
  else
    loud = "";
  switch (start) {
    case "asks" :
       nam = nam+" quizzically grunts"+loud;
       break;
    case "exclaims" :
       nam = nam+" pointedly grunts"+loud;
       break;
    default :
       nam = nam+" grunts"+loud;
       break;
  }
  return ({ nam+".", "" });
}
// --- END [/mnt/home2/grok/lib/std/languages/grunt.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/weapon_logic.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/weapon_logic.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628942   Available: 13576296
Inodes: Total: 5242880    Free: 4960135
7528 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/weapon_logic.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628942   Available: 13576296
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This class has alkl the stuff for anything which can damage something
 * else, this is included into living and weapons.
 * @author Pinkfish.
 */
#include <weapon.h>

nosave string *attack_names;
nosave string *attack_types;
nosave mixed *attack_data;
nosave mapping special_messages;

void create() {
   attack_names = ({ });
   attack_types = ({ });
   attack_data = ({ });
   special_messages = ([ ]);
} /* create() */

string *query_attack_names() { return copy( attack_names ); }
string *query_attack_types() { return uniq_array( attack_types ); }
mixed *query_attack_data() { return copy( attack_data ); }
mapping query_special_messages() { return copy( special_messages ); }

/**
 * This method adds a special attack message set onto the weapon.  The type
 * and name are around this way to correspond
 * to the parameters to add_attack.
 * @see /obj/handlers/attack_messages
 *
 * @param name the name of the attack (0 for none)
 * @param type the type of attack
 * @param data the attack data
 * @see query_special_message()
 * @example
 * inherit "/obj/weapon";
 *
 * void setup() {
 *   ...
 *   add_attack_message("gumboot", "blunt", ({
 *     0, "$N gumboot$s at $I with $D",
 *    20, "$N lightly gumboot$s $I in the $z with $D",
 *    60, "$N gumboot$s $I in the $z with $D",
 *  5000, "$N heavily gumboot$s $I in the $z with $D" }));
 *   ...
 * } /\* setup() *\/
 */
void add_attack_message(string name, string type, string *data) {
   string nam;

   nam = type;
   if (name) {
      nam += "-" + name;
   }
   special_messages[nam] = data;
} /* add_attack_message() */

/**
 * This method returns the attack message associated with the
 * type and name.  The type and name are around this way to correspond
 * to the parameters to add_attack.
 * @param name the name of the attack
 * @param type the type of the attack
 * @return the attack message array, 0 for none
 */
mixed *query_attack_message(string name, string type) {
   if (special_messages[type + "-" + name]) {
      return special_messages[type + "-" + name];
   }
   if (special_messages[type]) {
     return special_messages[type];
   }
   return 0;
} /* query_attack_message() */

/**
 * This method adds an attack onto the object.  The name of the attack
 * must be unique on each object.
 * @param a_name attack name
 * @param change the chance of it occuring
 * @param damage the damage it will do
 * @param type the type of the attack
 * @param skill the skill used by the attack
 * @param func the special function
 * @param bogus_1 errrr.
 * @param bogus_2 frog.
 * @see remove_attack()
 */
varargs int add_attack( string a_name, int chance, int *damage, string type,
      string skill, mixed func, mixed bogus_1, mixed bogus_2 ) {
   if ( stringp( bogus_1 ) ) {
      write( file_name( this_object() ) +" is using the obselete syntax "+
            "of add_attack.\n" );
      return 0;
   }
   if ( member_array( a_name, attack_names ) != -1 )
      return 0;
   attack_names += ({ a_name });
   attack_types += ({ type });
   attack_data += ({ chance, damage, type, skill, func });
   return 1;
} /* add_attack() */

/**
 * This method removes the attack of the given name.
 * @param a_name the name of the attack to remove
 * @see add_attack()
 */
void remove_attack( string a_name ) {
   int i;

   i = member_array( a_name, attack_names );
   if ( i == -1 )
      return;
   attack_names = delete(attack_names, i, 1);
   attack_types = delete(attack_types, i, 1);
   attack_data = delete( attack_data, i * W_ARRAY_SIZE, W_ARRAY_SIZE );
} /* remove_attack() */

int modify_damage( int damage, string attack_name ) { return damage; }

int calc_attack( int number, int percent ) {
   int damage, *data;

   data = attack_data[ number * W_ARRAY_SIZE + W_DAMAGE ];
   damage = data[ F_FIXED ] + roll_MdN( data[ F_NUM ], data[ F_DIE ] );
   damage = (int)this_object()->modify_damage( damage,
         attack_names[ number ] );
   damage = ( damage * percent ) / 100;
   return damage;
} /* calc_attack() */

/**
 * This function returns 0 or more attacks for this weapon against the
 * given target.
 *
 * @param percent the attack percentage
 * @param target who is being hit
 *
 * @return an array of 0 or more attacks. This array is indexed by the
 * AT_ macros defined in combat.h
 *
 * @see combat.h
 */
mixed *weapon_attacks(int percent, object target ) {
   int i, *order;
   mixed *attacks;
   if ( !percent )
      percent = 100;
   order = ({ });
   for ( i = 0; i < sizeof( attack_names ); i++ )
      order += ({ i });
   order = shuffle( order );
   attacks = ({ });
   for ( i = 0; i < sizeof( order ); i++ ) {
      if ( random( percent ) <
            attack_data[ order[ i ] * W_ARRAY_SIZE + W_CHANCE ] ) {
         attacks += ({ calc_attack( order[ i ], percent ),
               attack_data[ order[ i ] * W_ARRAY_SIZE + W_SKILL ],
               attack_data[ order[ i ] * W_ARRAY_SIZE + W_TYPE ],
               attack_names[ order[ i ] ] });
      }
   }
   return attacks;
} /* weapon_attacks() */

void attack_function( string a_name, int damage, object attack_ob,
      object attack_by ) {
   int i;

   i = member_array( a_name, attack_names );
   if ( i == -1 ) {
      return;
   }
   i *= W_ARRAY_SIZE;
   if ( !attack_data[ i + W_FUNCTION ] ) {
      return;
   }
   if ( stringp( attack_data[ i + W_FUNCTION ] ) ) {
      call_other( this_object(), attack_data[ i + W_FUNCTION ],
            damage, attack_ob, attack_by, attack_data[ i + W_TYPE ], a_name );
   } else {
      call_other( attack_data[ i + W_FUNCTION ][ 1 ],
            attack_data[ i + W_FUNCTION ][ 0 ], damage, attack_ob, attack_by,
            attack_data[ i + W_TYPE ], a_name );
   }
} /* attack_function() */

/**
 * This method attempts to work out what type of weapon this is.
 * @return the weapon type
 */
string query_weapon_type() {
   int i;
   string type;

   for ( i = 0; i < sizeof( attack_data ); i += W_ARRAY_SIZE ) {
      if ( !type ) {
         type = attack_data[ i + W_SKILL ];
         continue;
      }
      if ( type != attack_data[ i + W_SKILL ] )
         return "mixed";
   }
   return type;
} /* query_weapon_type() */

/** @ignore yes */
mixed weapon_stats() {
   int i, j;
   string bit;
   mixed *ret;
   ret = ({ });
   for ( i = 0; i < sizeof( attack_data ); i += W_ARRAY_SIZE, j++ ) {
      ret += ({
         ({ "attack #"+ j, attack_names[ j ] }),
         ({ "   chance", attack_data[ i + W_CHANCE ] })
      });
      if ( attack_data[ i + W_DAMAGE ][ F_FIXED ] )
         bit = attack_data[ i + W_DAMAGE ][ F_FIXED ] +"+";
      else
         bit = "";
      if ( attack_data[ i + W_DAMAGE ][ F_NUM ] )
         bit += attack_data[ i + W_DAMAGE ][ F_NUM ] +"d"+
               attack_data[ i + W_DAMAGE ][ F_DIE ];
      else
         if ( attack_data[ i + W_DAMAGE ][ F_DIE ] )
            bit += "1d"+ attack_data[ i + W_DAMAGE ][ F_DIE ];
      ret += ({
         ({ "   damage", bit }),
         ({ "     type", attack_data[ i + W_TYPE ] }),
         ({ "    skill", attack_data[ i + W_SKILL ] })
      });
      if ( stringp( attack_data[ i + W_FUNCTION ] ) )
         ret += ({ ({ " function", attack_data[ i + W_FUNCTION ] }) });
      else
         if ( pointerp( attack_data[ i + W_FUNCTION ] ) )
            ret += ({
               ({ " function", attack_data[ i + W_FUNCTION ][ 0 ] }),
               ({ "called on", attack_data[ i + W_FUNCTION ][ 1 ] })
            });
   }
   return ret;
} /* weapon_stats() */

/** @ignore yes */
mixed stats() { return weapon_stats(); }
// --- END [/mnt/home2/grok/lib/std/weapon_logic.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/dom/master.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/dom/master.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628940   Available: 13576294
Inodes: Total: 5242880    Free: 4960135
1493 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/dom/master.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628940   Available: 13576294
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: master.c,v 1.2 2003/04/15 23:50:10 pinkfish Exp $
 * $Log: master.c,v $
 * Revision 1.2  2003/04/15 23:50:10  pinkfish
 * *** empty log message ***
 *
 * Revision 1.1  1998/01/06 04:03:45  ceres
 * Initial revision
 * 
*/
/*
 * Beware editing this file.
 * Make sure you know what you are doing.  Stuffing this up could be
 * fatal in some ways.
 */

inherit "/std/dom/base_master";

string query_lord() {
  return LORD;
}

string author_file(string *path) {
  return capitalize(DOMAIN);
}

int check_permission(string euid, string *path, int mask) {
  if (euid == query_lord())
    return 1;
  return ::check_permission(euid, path, mask);
}

/*
 * By default, use the valid_read()/valid_write() functions defined in the
 * inherited file /std/dom/base_master.c.
 * These default to reading allowed for everyone, writing only allowed
 * for independent creators and the domain lord.
 * This is all overridden by the check_permission() function
 * which is called first, which should be used instead.
 */
int valid_read(string *path, string euid, string funct);

int valid_write(string *path, string euid, string funct);

int query_member(string name) {
  return !undefinedp(members[name]) || name == LORD;
} /* query_member() */

string log_who(string where) {
  return LORD;
} /* log_who() */

/* Please change this to a text describing the domain, it will be used
   on the WWW pages and in finger info. */

string query_info() {
  return "";
}
// --- END [/mnt/home2/grok/lib/std/dom/master.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/dom/base_master.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/dom/base_master.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628939   Available: 13576293
Inodes: Total: 5242880    Free: 4960135
14044 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/dom/base_master.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628939   Available: 13576293
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: base_master.c,v 1.17 2003/04/15 23:52:04 pinkfish Exp $
 * $Log: base_master.c,v $
 * Revision 1.17  2003/04/15 23:52:04  pinkfish
 * Fix up the assignment stuff anfd add in the ability to set a directory
 * assigned to no one.
 *
 * Revision 1.16  2003/03/05 22:40:59  pinkfish
 * Fix up an error which caused the size of the array to get over keen.
 *
 * Revision 1.15  2003/03/05 22:30:32  pinkfish
 * Make the lord default to the top of the domain.
 *
 * Revision 1.14  2003/03/04 22:57:33  pinkfish
 * Fix it up to remove things correctly.
 *
 * Revision 1.13  2003/03/04 22:47:21  pinkfish
 * Fix up the assignment stuff.
 *
 * Revision 1.12  2003/03/04 22:38:45  pinkfish
 * Make it do directory assignment stuff.
 *
 * Revision 1.11  2002/03/01 15:14:24  taffyd
 * Fixed a STUPID mistake.
 *
 * Revision 1.10  2002/02/24 17:02:47  taffyd
 * Added set_idle_mess() and query_idle_mess() for use in /secure/finger.
 *
 * Revision 1.9  2002/02/24 06:20:05  taffyd
 * Added better rcsforce allowed code
 *
 * Revision 1.8  2001/11/05 06:33:46  drakkos
 * Added support for $project$ codes in creator projects to query the project tracker for project info.
 *
 * Revision 1.7  2001/09/08 00:23:13  ceres
 * Mofified to let HLs change stuff
 *
 * Revision 1.6  2001/08/14 14:36:48  drakkos
 * Added a base query_changelog() method.
 *
 * Revision 1.5  2001/04/05 21:00:25  pinkfish
 * Add in allowing deputies to rcsforce.
 *
 * Revision 1.4  2001/02/27 23:54:22  pinkfish
 * Fix up the copy() around the deputies.
 *
 * Revision 1.3  2001/02/27 23:53:27  ceres
 *  Forcibly unlocked by pinkfish
 *
 * Revision 1.2  1999/10/04 23:31:22  turrican
 * Fixed permission checking function
 *
 * Revision 1.1  1998/01/06 04:03:45  ceres
 * Initial revision
 * 
*/
/*
 * This file is inherited by the domain master objects.
 */

#include <project_management.h>
#include <player_handler.h>
#include <error_handler.h>

#define LOCK_MASK 8
#define PROJECT_CODE "$project$"

mapping members;
mapping access;
nosave private mapping _project_cache;
private int _use_tracker;
private string _idle_mess;
string *deputies;
private mapping _directory_assignments;
private mapping _rcsforce_allowed; 

string query_lord();
int query_use_tracker();
void set_use_tracker(int);

string query_domain() {
  string *words;
  
  if (!file_name (this_object())) {
    return "";
  }    
  words =  explode (file_name(this_object()), "/");
  
  if (sizeof (words) < 2) {
    return "";
  }
  
  return words[1]; 
}

int query_prevent_shadow() {
   return 1;
}                               /* query_prevent_shadow() */

protected void create() {
   members = ([ ]);
   access = ([ ]);
   deputies = ({ });
   _project_cache = ([ ]);
   _rcsforce_allowed = ([ ]); 
   _idle_mess = 0; 
   unguarded((: restore_object, file_name(this_object()) :));
   if (!deputies) { 
      deputies = ({ });
   }

   if (!_directory_assignments) {
      _directory_assignments = ([ ]);
   }

   if ( !_rcsforce_allowed ) {
       _rcsforce_allowed = ([ ]);
   }
}                               /* create() */

void save_me() {
   unguarded((: save_object, file_name(this_object()) :));
}                               /* save_me() */

int add_permission(string euid,
                   string path,
                   int mask)
{
   if (previous_object() != master()) {
      return 0;
   }
   if (!access[path]){
      access[path] = ([ euid : mask ]);
   } else {
      access[path][euid] |= mask;
   }
   save_me();
   return 1;
}                               /* add_permission() */

int remove_permission(string euid,
                      string path,
                      int mask)
{
   if (previous_object() != master())
      return 0;
   if (!access[path])
      return 0;
   if (!access[path][euid])
      return 0;
   access[path][euid] &= ~mask;
   if (!access[path][euid])
      map_delete(access[path], euid);
   if (!sizeof(access[path]))
      map_delete(access, path);
   save_me();
   return 1;
}                               /* remove_permission() */

int check_permission(string euid,
                     string *path,
                     int mask)
{
   string p;
   mapping perms;

   if ((sizeof(path) >= 3)
       && (path[2] == "master.c" || path[2] == "master.o"
           || path[2] == "master"))
      return 0;
   p = "/" + implode(path, "/");
   perms = master()->permission_match_path(access, p);
   if (!perms || !sizeof(perms)) {
      return 0;
   }
   if (perms[euid] && ((perms[euid] & mask) || (perms["all"] & mask))) {
      return 1;
   }
   if (perms["all"] & LOCK_MASK) {
      return -1;
   }
   return 0;
}                               /* check_permission() */

int valid_read(string,
               string euid,
               string)
{
   /*
    * Default is to allow reading for everyone.
    */
   return 1;
   /* Use this if you only want your domain members to be able to read in the
    * the domain. */
   return (members[euid] != 0);
}                               /* valid_read() */

int valid_write(string *path,
                string euid,
                string)
{
   /*
    * Default is to deny write access for everyone, except the lord
    * and independent creators.
    */
   return 0;
   /*
    * Blue...  Use this if you want all your creators to have
    * write access everywhere in the domain.
    */
   if ((sizeof(path) >= 3)
       && (path[2] == "master.c" || path[2] == "master.o"
           || path[2] == "master"))
      return 0;
   return (members[euid] != 0);
}                               /* valid_write() */

void dest_me()
{
   destruct(this_object());
}                               /* dest_me() */

int check_call_tree(int only_lord)
{
   object *obs;
   int found;
   int i;

   obs = previous_object(-1);
   for (i = 0; i < sizeof(obs); i++) {
      /* Look for all the creator/lord objects */
     if (file_name(obs[i])[0..12] == "/global/lord#" ||
         (file_name(obs[i])[0..15] == "/global/creator#")) {
       if("/secure/master"->query_administrator(obs[i]->query_name()) ||
          obs[i]->query_name() == query_lord() ||
          (!only_lord &&
           (member_array(obs[i]->query_name(), deputies) != -1))) {
         found = 1;
       } else {
         return 0;
       }
     }
   }
   return found;
}                               /* check_call_tree() */

int add_member(string name)
{
   if (!check_call_tree(0)) {
      return 0;
   }
   if (members[name])
      return 0;
   members[name] = "newbie";
   save_me();
   return 1;
}                               /* add_member() */

int remove_member(string name)
{
   int pos;

   /* Only the lord can delete deputies... */
   if (!check_call_tree(member_array(name, deputies) != -1)) {
      return 0;
   }
   if (!members[name])
      return 0;
   members = m_delete(members, name);
   pos = member_array(name, deputies);
   if (pos != -1) {
      deputies = deputies[0..pos - 1] + deputies[pos + 1..];
   }
   save_me();
   return 1;
}                               /* remove_member() */

int add_deputy(string name)
{
   if (!check_call_tree(1)) {
      return 0;
   }
   if (!members[name])
      return 0;
   if (!deputies)
      deputies = ({ });
   if (member_array(name, deputies) != -1)
      return 1;
   deputies += ({ name });
   save_me();
   return 1;
}                               /* add_deputy() */

int remove_deputy(string name)
{
   int pos;

   if (!check_call_tree(1)) {
      return 0;
   }
   if (!deputies)
      deputies = ({ });
   pos = member_array(name, deputies);
   if (pos == -1)
      return 0;
   deputies = deputies[0..pos - 1] + deputies[pos + 1..];
   save_me();
   return 1;
}                               /* remove_deputy() */

int add_rcsforce_allowed( string creator, string directory ) {
    if (!check_call_tree(1)) {
      return 0;
   }

   if ( _rcsforce_allowed[ creator ] ) {
        _rcsforce_allowed[ creator ] += ({ directory });
   }
   else { 
        _rcsforce_allowed[ creator ] = ({ directory }); 
   }

   save_me(); 
   return 1;
} /* add_rcsforce_allowed() */ 

int remove_rcsforce_allowed( string creator, string directory ) {
    if (!check_call_tree(1)) {
      return 0;
   }

   if ( _rcsforce_allowed[ creator ] ) {
        _rcsforce_allowed[ creator ] -= ({ directory });

        if ( sizeof( _rcsforce_allowed ) == 0 ) {
            map_delete( _rcsforce_allowed, creator );
        }
        save_me(); 
   }

   return 1;
} /* remove_rcsforce_allowed() */ 

string *query_members()
{
   return keys(members);
}                               /* query_members() */

int set_project(string name,
                string pro)
{
   if (!check_call_tree(0)) {
      return 0;
   }
   if (!members[name])
      return 0;
   if (!pro || pro == "")
      pro = "project unset";
   members[name] = pro;
   save_me();
   return 1;
}                               /* set_project() */

string query_project(string name)
{
  string *proj;
  string project;  
  
  project = members[name];

  // Check to see if they have a project set.  
  if (!project) {
    // Nope.  Return project unset.
    return "project unset";
  }
  
  // Check to see if the string $project$ appears
  // anywhere in the string.  If it does, we will
  // replace this string with the project information
  // from the tracker.
  if (strsrch (project, PROJECT_CODE) != -1) {
    // No sizeof the cache... so let's initialise it.
    if (!sizeof (_project_cache)) {
      _project_cache = ([ ]);
    }              
   if (undefinedp (_project_cache[name])) {    
      // We haven't already queried the manager for this 
      // creator, so we'd better do that.  We cache what we get
      // back so that we don't continually hammer the CPU every
      // time.
      proj = PROJECT_HANDLER->query_projects_for_creator_in_domain
        (name, query_domain());
            
      if (sizeof (proj)) {
        // There were projects returned by the tracker, so 
        // let's make the project cache equal a q_m_s string
        // of the projects.
        _project_cache[name] = query_multiple_short (proj);
      }
      else {
        // Nothing is stored for this creator, so we'll
        // simply replace $project$ with the currently set
        // project.  
        _project_cache[name] = members[name];
      }

    }
  
    // Now, return the proper project code.
    return replace (project, ({PROJECT_CODE, 
      _project_cache[name]}));
  }
  else {
    return members[name];
  }
}                               /* query_project() */

int query_deputy(string name)
{
   if (!deputies)
      return 0;
   if (member_array(name, deputies) != -1)
      return 1;
   return 0;
}                               /* query_deputy() */

string *query_deputies()
{
   return copy(deputies);
}

mapping query_access()
{
   return copy(access);
}                               /* query_access() */

string query_lord()
{
   return "Something is broken";
}                               /* query_lord() */

/**
 * Called to check for rcsforcing of a file.  By default we allow the deputies
 * to rcsforce things.
 * @param file the file to check
 * @param person the person forcing
 * @param locker the person who has the lock
 */
int can_rcsforce(string file, string person, string locker) {
    string *directories; 
    string fdir;

    if (query_deputy(person)) {
        return 1;
    }

    directories = _rcsforce_allowed[ person ];

    if ( directories ) { 
        fdir = file[ 0..strsrch( file, "/", -1 ) -1 ]; 
        foreach ( string directory in directories ) {
            if ( fdir[ 0.. sizeof( directory ) - 1 ] == directory ) {
                return 1;
            }
        }
    }
    
    return 0; 
} /* can_rcsforce() */

string query_changelog (string filename) {
  return  "/d/" + query_domain() + "/ChangeLog";
}

void set_use_tracker(int i) {
  _use_tracker = i;
}

int query_use_tracker() {
  return _use_tracker;
}

int nuke_creator_project_cache(string *creators) {
  
  if (!_project_cache) {
    return 0;
  }
  
  foreach (string c in creators) {
    map_delete (_project_cache, c);
    return 1;
  }
}

int set_idle_mess( string txt ) {
   if (!check_call_tree(1)) {
        return 0;
   }

   _idle_mess = txt;
   save_me();
   return 1;
} /* set_idle_mess() */

string query_idle_mess() {
    return _idle_mess;
} /* query_idle_mess() */ 

/**
 * Finds the person assigned to the specific directory.  It will climb
 * up the directory tree looking for who to assign the directory too.
 * @param dir the directory to find assignments in
 * @return the array of people assigned to the directory
 */
string* query_assigned_to_directory(string* dir) {
   string str;
   int i;

   i = sizeof(dir) - 1;
   do {
      str = "/" + implode(dir[0..<i], "/");
      i--;
   } while (i >= 0 && !_directory_assignments[str]);
   if (_directory_assignments[str]) {
      return _directory_assignments[str];
   }
   // Make the default the lord
   return ({ query_lord() });
}

/**
 * This method allows a specific person to be assigned to the given
 * directory.
 * @param dir the directory to assign someone too
 * @param people the people who are assigned to the directory
 */
int assign_people_to_directory(string dir, string* people) {
   if (previous_object() != master()) {
      return 0;
   }

   

   if (sizeof(people)) {
      if (sizeof(people) == 1 && people[0] == ERROR_ASSIGNED_NO_ONE) {
         people = ({ });
      }
      _directory_assignments[dir] = people;
   } else {
      map_delete(_directory_assignments, dir);
   }
   save_me();
   return 1;
}

/**
 * This method returns all the current assignments from directory to the
 * people who are looking after them.
 * @return the directory assignment mapping
 */
mapping query_directory_assignments() {
   mapping ret;
   string dir;

   ret = copy(_directory_assignments);
   dir = "/d/" + query_domain();
   if (!ret[dir]) {
      ret[dir] = ({ query_lord() });
   } else {
      ret[dir] |= ({ query_lord() });
   }
   return ret;
}
// --- END [/mnt/home2/grok/lib/std/dom/base_master.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/dom/cmn_mas.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/dom/cmn_mas.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628936   Available: 13576290
Inodes: Total: 5242880    Free: 4960135
4048 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/dom/cmn_mas.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628936   Available: 13576290
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: cmn_mas.c,v 1.5 2000/12/19 07:21:36 drakkos Exp $
*/
/* inherited by the common rooms in the domains*/
inherit "/std/room/basic_room";
private nosave string _dom_name;

string query_dom() { return _dom_name; }
void set_dom(string str) { _dom_name = str; }

int do_list(string);
int add_creator(string);
int delete_creator(string);
int set_project(string, string);

void create() {
  do_setup++;
  ::create();
  do_setup--;

  add_property ("no scry", 1);
  add_property ("no teleport", 1);
  add_help_file ("/doc/creator/room/commonroom");
         
  if ( !do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }
}

void init() {
  ::init();
  add_command("list", "<word'domain'>", (:do_list($4[0]):));
  add_command("list", "", (:do_list(0):));
  add_command("add", "<word'creator'>", (:add_creator($4[0]):));
  add_command("delete", "<word'creator'>" ,(:delete_creator($4[0]):));
  add_command("project", "<word'name'> <string'project'>", 
    (:set_project($4[0], $4[1]):));
}

int do_list(string arg) {
  string *domains, mast, s = "";
  string *members;
  int i, j;

  if(arg == "all")
    domains = get_dir("/d/");
  else if(!arg)
    domains = ({ _dom_name });
  else {
    domains = ({ arg });
  }

  if(sizeof(domains) > 1) {
    write("All domains:\n");
  }  
  else {
    write("This domain:\n");
  }
    
  for(i=0; i<sizeof(domains); i++) {
    mast = "/d/" + domains[i] + "/master";
    if (!load_object (mast)) {
      continue;
    }
    
    members = mast->query_members();
    
    if(!members) {
      members = ({ });
    }
    
    s += sprintf("%s has %s members and is owned by %s.\n", capitalize (domains[i]),
      query_num (sizeof(members)), capitalize((string)mast->query_lord()));

    for(j=0; j<sizeof(members); j++)
      s +=sprintf("* %s's project: %-=*s\n", capitalize(members[j]),
                       this_player()->query_cols()-12-strlen(members[j]),
                       mast->query_project(members[j]));
      s += "\n\n";
  }
    
  this_player()->set_finish_func(0);
  this_player()->more_string(s);
  return 1;
}

int add_creator(string arg) {
  string mast;
  
  arg = (string)this_player()->expand_nickname(arg);
  mast = "/d/" + _dom_name + "/master";
  if((string)mast->query_lord() != geteuid(this_player())) {
    this_player()->add_failed_mess(this_object(), "You are not the Lord of "
      "this Domain.\n", ({ }));
    return 0;
  }
  if(!mast->add_member(arg)) {
    this_player()->add_failed_mess(this_object(), sprintf ("%s is already a "
      "member of %s.\n", capitalize (arg), capitalize (query_dom())), 
      ({ }));
    return 0;
  }
  write("Creator " + capitalize(arg) + " now added to " + _dom_name + ".\n");
  return 1;
}

int delete_creator(string arg) {
  string mast;

  arg = (string)this_player()->expand_nickname(arg);
  mast = "d/" + _dom_name + "/master";
  if((string)mast->query_lord() != geteuid(this_player())) {
    this_player()->add_failed_mess(this_object(), "You are not the Lord of "
      "this Domain.\n", ({ }));    
    return 0;
  }
  if (!mast->remove_member(arg)) {
    this_player()->add_failed_mess(this_object(), sprintf ("%s is not a "
      "member of %s.\n", capitalize (arg), capitalize (query_dom())), 
      ({ }));
    return 0;
  }
  write("Member " + capitalize(arg) + " removed from " + _dom_name + ".\n");
  return 1;
}

int set_project(string arg, string project)
{
  string mast;
    
  mast = "d/" + _dom_name + "/master";

  if((string)mast->query_lord() != geteuid(this_player())) {
    this_player()->add_failed_mess(this_object(), "You are not the Lord of "
      "this Domain.\n", ({ }));   
    return 0;
  }
  arg = (string)this_player()->expand_nickname(arg);
  if(!mast->set_project(arg, project)) {
    this_player()->add_failed_mess(this_object(), sprintf ("%s is not a "
      "member of %s.\n", capitalize (arg), capitalize (query_dom())), 
      ({ }));
    return 0;
  }
  write(capitalize(arg) + "'s project set to : " + project + ".\n");
  return 1;
}
// --- END [/mnt/home2/grok/lib/std/dom/cmn_mas.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/dom/common.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/dom/common.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628934   Available: 13576288
Inodes: Total: 5242880    Free: 4960135
3302 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/dom/common.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628934   Available: 13576288
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: common.c,v 1.2 2000/06/27 00:24:50 pinkfish Exp $
 * $Log: common.c,v $
 * Revision 1.2  2000/06/27 00:24:50  pinkfish
 * Fix up the drum exit.
 *
 * Revision 1.1  1998/01/06 04:03:45  ceres
 * Initial revision
 * 
*/
/* PLEASE re-describe me */
#include <config.h>
inherit "/std/dom/cmn_mas";
object board;

void setup() {
  set_dom(DOMAIN);
  set_light(100);
  add_exit("drum", CONFIG_START_LOCATION, "door");
  set_short("Common room of "+DOM_TITLE);
  set_long("Large relaxing chairs addorn the room.  The walls are covered "+
           "with strange motifs from different lands and the little shelf "+
           "above the fireplace is chocker block full of strange figurines "+
           "and bits of cloth.  It appears to be the common room of "+
           DOM_TITLE+" the large red letters on the wall were the " +
           "give away.\n");
  add_alias("chairs", "chair");
  add_alias("cloths", "cloth");
  add_alias("motifs", "motif");
  add_alias("figurines", "figurine");
  add_item("chair", "The chairs are lazing around the room relaxing it looks "+
                    "like they come here after a hard days working in "+
                    DOM_TITLE+".\n");
  add_item("fireplace", "A nice little fire place with a cheery fire burning "+
                        "in it keeping every one warm.\n");
  add_item("figurine", "Small figurines, they look strangely familiar "+
                         "until you realise they are the members of "+
                         DOM_TITLE+".\n");
  add_item("cloth", "Strange coloured bits of cloth strewn over the "+
                    "mantlepice for no readily apparent reason.\n");
  add_item("motif", "The motifs on close inspection look like stylised "+
                     "signatures of all the members of "+DOM_TITLE+
                     ".  Some of them are very strange, in fact there "+
                     "seem to be more than there are members of the house.  "+
                     "perhaps it is the members of the future.\n");
  add_item("shelf", "A nice normal sort of shelf thing.  It is like all "+
                    "those ones you see in houses all over the place, "+
                    "execpt... the way it has been burnt... hmm it does "+
                    "not look like the fire did it.\n");
  add_item("fire", "There is a fire happily burning away in the fireplace "+
                   "spluttering and crackling to itself.  The flames almost "+
                   "seem afraid of something.  Looking closer you notice a "+
                   "picture tacked to the side of the fire place.\n");
  add_item("picture", "Tacked to the inside wall of the fire thingy, you "+
                      "know the hole bit at the bottom, is a small picture "+
                      "it looks like it was taken with the best of demon "+
                      "photography.  It is a picture of a person holding "+
                      "a small staff, you think it might be "+LORD+
                      " but you are not sure as the fire light sparkles "+
                      "in your eyes.\n");
  board = clone_object("/obj/misc/board");
  board->set_datafile(DOMAIN);
  board->move(this_object());
}

void dest_me()
{
  if(board) board->dest_me();
  ::dest_me();
}
// --- END [/mnt/home2/grok/lib/std/dom/common.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/dom/error_tracker_master.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/dom/error_tracker_master.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628933   Available: 13576287
Inodes: Total: 5242880    Free: 4960135
12748 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/dom/error_tracker_master.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628933   Available: 13576287
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* Hey Emacs, this is -*- LPC -*- ! */
/*
 * $Id: error_tracker_master.c,v 1.27 2003/07/15 12:16:39 taffyd Exp $
 */
/**
 * The nice error handler for domains to do wonderful things with.
 * Lots hacked by Pinkfish to make it work with the mysql handler and not
 * use blocking io calls.
 * @author Sin
 */
#include <board.h>
#include <db.h>
#include <config.h>
#include <project_management.h>

#define HELPER "/obj/handlers/finderror_helper"

inherit "/global/path";

private void finished_count_errors( object player, int status, mixed data );

private string domain = "unset";
private string _board;
private string tracker_name = "generic error tracker";
private string *other_dirs = ({ });
private int period = 604800;
private int nexttime;

private nosave mapping _messages;
private nosave string *_queue;
private nosave object _tester;
private nosave string _save_file;
private nosave int starttime;

#define ERROR_INDEX 0
#define TYPO_INDEX 1
#define IDEA_INDEX 2

/* Define this to use the old ERROR_REPORTS file system */
#undef OLD_SYTEM

void do_the_work();

/** @ignore yes */
protected void save_me()
{
   if (domain != "unset" && _save_file) {
      unguarded( (: save_object, _save_file, 0 :) );
   }
}

void create()
{
   int retval;

   _messages = ([ ]);
   _tester = 0;

   seteuid(master()->creator_file(file_name()));
   _save_file = file_name();
   if (catch(retval = unguarded((: restore_object, _save_file, 1 :))) ||
         !retval) {
      string temp;
// #ifdef BROKEN
      temp = "/save/" + replace(file_name()[1..], "/", "_");
      if (catch(retval = unguarded((: restore_object, temp, 1 :))) ||
            !retval) {
         /* The save file doesn't exist.   Try to make it here, then
          * /save */
         if (catch(save_me())) {
            _save_file = temp;
         }
      } else {
         _save_file = temp;
      }
// #endif
   }
   if (!retval) {
      nexttime = 0;
   }
   if (nexttime < time()) {
      do_the_work();
   } else {
      call_out("do_the_work", nexttime - time());
   }
}

/**
 * This method sets the board to post the messages to.  The board defaults
 * to the domain name, so this is not required for most domains.
 * @param board the board to post to
 */
void set_board(string board) {
   _board = board;
} /* set_board() */

/**
 * This method returns the board to post the messages to.
 * @return the board to post the messages to
 */
string query_board() {
   return _board;
} /* query_board() */

/** @ignore yes */
void dest_me()
{
   save_me();
   destruct(this_object());
}

/** @ignore yes */
nomask mixed dwep()
{
   destruct(this_object());
   return "Destructed With Extreme Prejudice";
}

/**
 * This method posts the results to the correct board.
 * @param message the message to post
 * @param title the title of the message
 */
protected varargs int post( string message, string title )
{
   string temp;

   if( undefinedp( title ) ) {
      temp = "Status summary for "+ capitalize( domain ) + ".";
   } else {
      temp = title;
   }

   if (_tester) {
      _tester->more_string(message);
      _tester = 0;
      return 0;
   }
   if (_board) {
      return BOARD_HAND->add_message(_board,
         capitalize(tracker_name), temp ,
         message);
   } else {
      return BOARD_HAND->add_message(domain,
         capitalize(tracker_name), temp ,
         message);
   }
}

string * query_classifications() {
    return ({ "live", "playtesting", "development" });
} /* query_classifications() */


/**
 * This method makes the message to post to the board from all the
 * other rubbish.
 * @return the message to post
 */
string query_post_message() {
   string message;
   int diff;

   if (!sizeof(_messages)) {
      message = "Congratulations!   There are no errors in all of " +
         capitalize(domain) + "!   Excellent work, everyone.\n";
   } 
   else {
       message = "";

         foreach( string key in query_classifications() ) {
            if ( _messages[ key ] ) { 
                message += "There are reports in the following " + key + 
                    " areas:\n\n" + _messages[ key ] + "\n";
            }
            else {
                if ( key == "live" ) { 
                    message += "\n\nThere are no live bugs in all of " +
                        capitalize(domain) + ".   Good work, everyone!\n";
                }
                else {
                    message += "\n\nThere are no outstanding " + key + " bugs.\n";
                }
            }
        }
   }

   diff = (real_time() - starttime);

   message += "\n\nThis message took " + diff +
     " second" + (diff != 1 ? "s" : "") + " to produce.\n";
   
   return message;
} /* query_post_message() */

string query_project_message() {
   string str;
   class project* projects, *my_projects;
   class project project;
   mapping status; 

   str = "\nCurrent Domain Projects:\n\n";
   projects = PROJECT_HANDLER->filter_by_query(([ "domains" : domain ]));
   if (sizeof(projects)) {
        status = unique_mapping( projects, (: STATUS[((class project)$1)->status] :) ); 
        map_delete( status, "play" ); 

        if ( !sizeof(status) ){
            str += "This domain is project free.\n";
        }
        
        foreach( string key in sort_array( keys( status ), 1 ) ) {
            str += "Projects classified as " + 
                upper_case(key) + ":\n";
            my_projects = sort_array(status[key], 
                (: strcmp(((class project)$1)->name, 
                ((class project)$2)->name) :) );
            foreach (project in my_projects) {
                str += "    * " + project->name + " - " + 
                    query_multiple_short(sort_array(map(project->creators, 
                    (: capitalize :) ), 1)) + "\n";
            }

            str += "\n";
        }
   } 
   else {
      str += "This domain is project free.\n";
   }
   return str;
}


/**
 * This method goes over all the directories and makes up the
 * complete report.
 */
protected void iterate()
{
#ifdef OLD
   string message;

   if (sizeof(_queue)) {
      string dir = _queue[0];

      if (sizeof(_queue) > 1) {
         _queue = _queue[1..];
      } else {
         _queue = ({ });
      }
      if (strsrch (dir, "_dev") != -1) {
         dodir(dir, (: _dev_msg += ({ $1 }), iterate() :));
      } else if (strsrch (dir, "_pt") != -1) {
         dodir(dir, (: _pt_msg += ({ $1 }), iterate() :));
      } else {
         dodir(dir, (: _messages += ({ $1 }), iterate() :));
      }
   } else {
      message = query_project_message() + "\n";
      message += query_post_message();

      post(message);
      _messages = ({ });

      //This check is used by the AM domain error tracker.
      if( function_exists( "domain_customisation" , this_object() ) ) {
            call_out( "domain_customisation" , 1 );
      }
   }
#endif
   
    HELPER->query_errors_in_dirs(_queue, (: finished_count_errors :) ); 
} /* iterate() */

/**
 * This method initialises all the variables for a error run.
 */
void initialise_variables() {
   _queue = ({ "/d/" + domain + "%" }) + other_dirs;
   _messages = ([ ]);
} /* initialise_variables() */

/**
 * This bit does the actual processing and prints the results.
 */
void do_the_work()
{
   if (domain == "unset") return;

   nexttime = time() + period;
   remove_call_out("do_the_work");
   call_out("do_the_work", period);
   save_me();

   starttime = real_time();
   initialise_variables();
   iterate();
}

/** @ignore yes */
varargs void test()
{
   _tester = this_player();
   starttime = real_time();
   initialise_variables();

   iterate();
}

/**
 * This method sets the name of the tracker.
 * @param name the name of the tracker
 */
void set_name(string name)
{
   tracker_name = name;
   save_me();
}

/**
 * This method sets the domain of the tracker.
 * @param name the domain of the tracker
 */
void set_domain(string name)
{
   domain = name;
   save_me();
}

/**
 * This method returns the domain of the tracker.
 * @return the domain of the tracker
 */
string query_domain() {
   return domain;
} /* query_domain() */

/**
 * This method sets how long between each time the error tracker fires.
 * @param length the length of time in seconds
 */
void set_period(int length)
{
   remove_call_out("do_the_work");
   nexttime -= period;
   period = length;
   nexttime += period;
   save_me();
/*
   if (nexttime < time()) {
      do_the_work();
   } else {
      call_out("do_the_work", nexttime - time());
   }
 */
}

/**
 * This method sets the list of other directories to use for tracking
 * errors.
 * @param others the other directories to use
 */
void set_other_dirs(string *others)
{
   if (arrayp(others)) {
      other_dirs = others;
   } else {
      other_dirs = ({ });
   }
   save_me();
}

/** @ignore yes */
mixed stats()
{
   return ({
      ({ "domain", domain }),
      ({ "name", tracker_name }),
      ({ "period", period }),
      ({ "next time", ctime(nexttime) }),
      ({ "testing by", _tester }),
      ({ "queue length", sizeof(_queue) }),
      ({ "message length", sizeof(_messages) }),
      ({ "other dirs", sizeof(other_dirs) ? implode(other_dirs, ", ") : 0 }),
      ({ "save file", _save_file }),
   });
}

protected string classify_directory(string path) {
    if ( strsrch( path, "_pt" ) > -1 ) {
        return "playtesting";
    }
    if ( strsrch( path, "_dev" ) > -1 ) {
        return "development";
    }

    return "live";
} /* classify_directory() */ 

private int sort_errors( mapping mdata, string key1, string key2 ) {
    int total1, total2;

    total1 = mdata[key1][0] + mdata[key1][1] + mdata[key1][2];
    total2 = mdata[key2][0] + mdata[key2][1] + mdata[key2][2];

    if ( total1 > total2 )  {
        return -1;
    } else {
        if ( total1 == total2 ) {
            return 0;
        } else {
            return 1;
        }
    }
} /* sort_errors() */ 

private void finished_count_errors( object player, int status, mixed data ) {
    int *count; 
    string *paths; 
    mapping errors = ([ ]); 
    // int *total = ({ 0, 0, 0 });
    mapping total = ([ ]);
    string txt; 
    string classification; 
    mapping mdata;
    string message;

    // tell_creator( player, "%O, %O\n", status, data );

    foreach( mapping direc in data ) {
        classification = classify_directory( direc[ "Directory" ] );

        if ( !errors[ classification ] ) {
            errors[ classification ] = ([ ]);
        }

        if ( !total[ classification ] ) {
            total[ classification ] = ({ 0, 0, 0 }); 
        }

        count = errors[ classification ][ direc[ "Directory" ] ];

        if ( undefinedp( count ) ) { 
            count = ({ 0, 0, 0 });
        }

        switch( direc[ "Type" ] ) {
            case "BUG":
                count[ 0 ] = direc[ "C" ]; 
                total[ classification ][ 0 ] += count[ 0 ];
            break;
            case "TYPO":
                count[ 1 ] = direc[ "C" ]; 
                total[ classification ][ 1 ] += count[ 1 ];
            break;
            case "IDEA":
            default:
                count[ 2 ] = direc[ "C" ]; 
                total[ classification ][ 2 ] += count[ 2 ];
        }

        errors[ classification ][ direc[ "Directory" ] ] = count; 
    } 
    
    foreach ( classification, mdata in errors ) { 
        // paths = sort_array( keys( mdata ), 1 ); 
        paths = sort_array( keys( mdata ), (: sort_errors( $(mdata), $1, $2 ) :) );
        
        txt = "BUGS TYPO IDEA [Assigned] Dir\n"; 

        foreach( string key in paths ) {
            string* assigned;

            assigned = master()->query_assigned_to_directory(key);
            if (!sizeof(assigned)) {
               assigned = ({ "No one" });
            }
            txt += sprintf( "%4d %4d %4d %-11s %s\n", 
                mdata[ key ][ 0 ],
                mdata[ key ][ 1 ], 
                mdata[ key ][ 2 ], 
                query_multiple_short(assigned),
                key ); 
        } 
        
        txt += "-------------\n"; 
        txt += sprintf( "%4d %4d %4d\n", 
            total[ classification ][ 0 ], total[ classification ][ 1 ], 
            total[ classification ][ 2 ] ); 
        
        _messages[ classification ] = txt; 
    }

  message = query_project_message() + "\n";
  message += query_post_message();

  if (function_exists("extend_error_message", this_object())) { 
      message += this_object()->extend_error_message( copy( errors ) ); 
  }

  post(message);
  _messages = ([ ]);

  //This check is used by the AM domain error tracker.
  if( function_exists( "domain_customisation" , this_object() ) ) {
        call_out( "domain_customisation" , 1 );
  }
} /* finished_count_errors() */ 
// --- END [/mnt/home2/grok/lib/std/dom/error_tracker_master.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/dom/loader.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/dom/loader.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628930   Available: 13576284
Inodes: Total: 5242880    Free: 4960135
2252 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/dom/loader.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628930   Available: 13576284
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: loader.c,v 1.1 1998/01/06 04:03:45 ceres Exp $
 * $Log: loader.c,v $
 * Revision 1.1  1998/01/06 04:03:45  ceres
 * Initial revision
 * 
*/
/* this is the file you use to preload things...
 * It will be added to the preload list on the maste object automaticly
 */

string *pre_load;

void create() {
  int i;
  string domain;
  
  foreach(domain in "/secure/master"->query_domains()) {
    //seteuid((string)"/secure/master"->creator_file("/d/"+domain+"/loader"));
    unguarded((: restore_object, "/d/"+ domain + "/loader" :));
    if (!pre_load)
      pre_load = ({ });
    for (i=0;i<sizeof(pre_load);i++) {
      if(pre_load && explode(pre_load[i], "/")[1] != domain)
        printf("invalid " + domain + " preload: " + pre_load[i] +
               "\n");
      else {
        printf(domain +" pre_loading "+pre_load[i]+".\n");
        if (catch(call_other(pre_load[i], "??")))
          call_out("do_load", 0, pre_load[i]);
      }
    }
  }
}

/* this is so the errors get done... ;) */
void do_load(string str) {
  call_other(str, "??");
}

int add_pre_load(string domain, string str) {
  if(member_array(domain, "/secure/master"->query_domains()) == -1)
    return 0;
  
  unguarded((: restore_object, "/d/"+ domain + "/loader" :));
  if (!pre_load)
    pre_load = ({ });
  
  if (member_array(str, pre_load) == -1)
    pre_load += ({ str });
  
  //seteuid((string)"/secure/master"->creator_file("/d/"+domain+"/loader"));
  save_object("/d/" + domain + "/loader");
  return 1;
}

int remove_pre_load(string domain, string str) {
  int i;

  if(member_array(domain, "/secure/master"->query_domains()) == -1)
    return 0;
  
  unguarded((: restore_object, "/d/"+ domain + "/loader" :));
  if (!pre_load)
    pre_load = ({ });

  if ((i=member_array(str, pre_load)) == -1)
    return 0;
  pre_load = delete(pre_load, i, 1);
  //seteuid((string)"/secure/master"->creator_file("/d/"+domain+"/loader"));
  save_object("/d/" + domain + "/loader");
}

string *query_pre_load(string domain) {
  if(member_array(domain, "/secure/master"->query_domains()) == -1)
    return ({ });
  
  unguarded((: restore_object, "/d/"+ domain + "/loader" :));
  if (!pre_load)
    pre_load = ({ });
  return pre_load;
}
// --- END [/mnt/home2/grok/lib/std/dom/loader.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/dom/interview_inherit.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/dom/interview_inherit.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628929   Available: 13576283
Inodes: Total: 5242880    Free: 4960135
39404 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/dom/interview_inherit.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628929   Available: 13576283
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 *  Domain Interview Room
 *  @author Drakkos
 *  @started on 02/12/2000
 *  
 */
   
#include <player_handler.h>
#include <mail.h>
#define LORD capitalize (load_object ("/d/" + query_domain() + "/master")->query_lord())
#define SECURE "/d/" + query_domain() + "/secure/"
#define SAVE query_interview_dir() + "candidate_list"
#define LOG query_interview_dir() + "candidate_log.txt"
#define EVENTS "/global/events"

#define DEBUG 1

inherit "/std/room";

int add_creator (string);
int do_add (string);
int do_confirm (string);
int do_flag (string, string);
varargs int do_interview (object, string);
int do_query_text(string);
int do_list();
int do_read (string);
int flush();
int query_allowed_creators();
int query_interview();
int remove_candidate (string);
int remove_creator (string);
int remove_interviewed (string);
int set_interview_dir (string);
int set_part_two (string);
int query_part_two_required();

void set_acceptance(string);
void set_confirmation(string);
void set_rejection(string);
void set_interview (int);
void set_subject (string);
void set_interviewer(mixed);
void set_cc (string*);

string query_acceptance();
string query_applicants_text();
string query_cc();
string query_confirmation();
string query_domain();
string query_interview_dir();
string query_part_two();
string query_rejection();
string query_subject();

private nosave int _interview;
private nosave int _pt_two = 1;

private nosave string _acceptance_text;
private nosave string _confirmation_text;
private nosave string _domain;
private nosave string _filename;
private nosave string _interview_dir;
private nosave string _rejection_text;
private nosave string _subject;
private nosave string *_int;

private string *_allowed_creators = ({ });
private string *candidates = ({ });
private string *_cc = ({ });
private string *interviewed = ({ });
private string *submitted = ({ });
private string *accepted = ({ });
private string *rejected = ({ });

nosave string *movie = ({
  "First of all, I'd like to congratulate you for getting this far with the "
  "application process.  The second part of the application, in addition to "
  "testing descriptive and coding skills, is also designed to help weed out "
  "those who aren't really serious about becoming creators.  :-)",
  "I should make it clear at this point that getting this far doesn't mean "
  "that you're guaranteed a promotion.  We just want to get a fuller "
  "appreciation of applicants before we reach a decision on whether you are "
  "to be promoted or not.  :-)",
  "Being a creator, regardless of the rumours or jokes to the contrary, is "
  "not an easy option.  Unlike many MUDs, being a creator on " + mud_name() + " is "
  "not the same as early retirement.  You'll be expected to spend time "
  "coming to terms with the mudlib (the body of code that is used to "
  "create the MUD) and your domain (the areas you actually adventure "
  "in).  As a creator, you have considerable power over large segments of "
  "the MUD.  The important thing is learning how to use that power "
  "responsibly.", 
  "We have a number of strict rules on " + mud_name() + " .. rules you should be "
  "aware of before you make any decisions as to whether the role is for "
  "you.  Creators aren't allowed to affect the game in any measurable "
  "way.  Chatting is fine... killing NPCs at random or indiscriminately "
  "cloning cash for players is not.",
  "Being a creator is also not about policing the " + mud_name() + "   That falls "
  "under the jurisdiction of Admin and the Liaison domain.  As a coding "
  "creator your responsibilities lie in dealing with the code that "
  "makes up the MUD.  It is quite common that you will be approached by "
  "players with questions, particularly when they are no liaisons "
  "online.  In cases such as this, you are expected to refer them to "
  "a liaison or a Director.  If none are online, you are expected to ask "
  "them to wait until one is.",
  "In rare cases, it will be necessary for immediate action to be "
  "taken... in such cases, it may be acceptable for you to deal with a "
  "player problem yourself.  Always keep in mind however that you are "
  "here to code.  If it is liaising and player interaction that you think "
  "you would enjoy most, it would be best to consider an application "
  "instead to the Liaison domain.",
  "There is also a stern security policy on " + mud_name() + "   As a creator, you "
  "are expected not to violate this policy.  This means:  No passing "
  "creator information on to players, and no revealing what is posted on "
  "creator boards.   As a creator you have access to a lot of information "
  "players do not... this information should be treated as confidential "
  "unless you have Express Permission from your Leader that you may reveal "
  "it.  In short, we have to be able to trust you with sensitive "
  "information.",
  "The most important thing to remember is that you are expected to "
  "create.  If all you're really interested in is coding toys, then this "
  "role is not for you.  " + mud_name() + " is not strict in the sense of 'You have "
  "to code X rooms per day!', but you are expected to make a measurable "
  "and consistent contribution to your domain.  Your Leader and the "
  "deputy immediately supervising you will check up on this on a "
  "regular basis.",  
  "It may sound like an awful lot of work to be a creator... and it is.  "
  "But at the same time, it's an awful lot of fun, and provides you with "
  "the means of giving something back to a MUD that has hopefully provided "
  "you with many hours of entertainment.  :-)",
  "Now that the movie is over, are you still willing to continue your "
  "application to be a creator?  If not, then the exit 'drum' will "
  "return you to the " + mud_name() + "   If you are, hang around a while.  :-)"
  });

void save() {
  unguarded ((: save_object (SAVE) :));
}

void load() {
  unguarded ((: restore_object (SAVE) :));
}

void create() {

  do_setup++;
  ::create();
  do_setup--;

  add_property ("no scry", 1);
  add_property ("no teleport", 1);
  add_help_file ("/doc/creator/room/interview_help");
         
  if ( !do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }
}


void init() {
  ::init();
  this_player()->add_command ("show", this_object(), "movie");
  this_player()->add_command ("stop", this_object(), "movie");
  this_player()->add_command ("interview", this_object(), 
      "<indirect:living>", (: do_interview ($1[0]) :));
  this_player()->add_command ("interview", this_object(), 
      "<indirect:living> with <string>", (: do_interview ($1[0], $4[1]) :));
      
  this_player()->add_command ("end", this_object(), "interview");
  this_player()->add_command ("add", this_object(), "<string> [as "
      "candidate]", (: do_add ($4[0]) :));
  this_player()->add_command ("query", this_object(), "applicants");
  this_player()->add_command ("query", this_object(), "permitted "
    "[creators]", (: query_allowed_creators () :));
  this_player()->add_command ("query", this_object(), 
    "{confirmation|acceptance|rejection} [text]",
    (: do_query_text ($4[0]) :));
  this_player()->add_command ("delete", this_object(), "<string> [from "
      "candidates]", (: remove_candidate ($4[0]) :));        
  this_player()->add_command ("clear", this_object(), "[all] candidates",
      (: flush() :));
  this_player()->add_command ("confirm", this_object(), "<string>",
      (: do_confirm ($4[0]) :));
  this_player()->add_command ("grant", this_object(), "[access to] "
    "<string>", (: add_creator ($4[0]) :));
  this_player()->add_command ("remove", this_object(), "<string> "
    "[as allowed]", (: remove_creator ($4[0]) :));
  this_player()->add_command ("flag", this_object(), "<string> as "
    "{accepted|rejected}", (: do_flag ($4[0], $4[1]) :));
  this_player()->add_command ("read", this_object(), 
    "interview for <string>",
    (: do_read ($4[0]) :));   
  this_player()->add_command ("list", this_object(), "interviews");     

}

/** 
 * Tests to see if a particular creator is permitted to make use of the 
 * interview room.  Domain lords and deputies are always permitted.
 * @param name the name of the object attempting to use the room.
 * @return 1 if the creator is allowed, 0 if they are not.
 */

void set_movie (string *m) {
  movie = m;
}

int query_permitted(string name) {
  object ob = load_object("/d/" + query_domain() + "/master");
  
  
  if (!ob) {
    printf ("Erk, this room is horribly borken!!  Please set the domain "
      "correctly.\n");
    return 0;
  }
  if (member_array (ob, previous_object (-1)) != -1) {
    return 2;
  }
    
  if (master()->high_programmer (name)) {
    return 1;
  }
  
  
#ifdef DEBUG
  if (name == "drakkos") {
    return 1;
  }  
#endif  
  
  if ((ob->query_lord() != name) &&  
    !(ob->query_deputy (name)) && (member_array (name, _allowed_creators) 
    == -1)) {
        return 0;
    }    
    
  return 1;
}

/** 
 * Logs text to the interview text file, which will be in the domain's 
 * secure directory, in a sub-directory called 'interviews'.  Interviews are
 * stored with the name of the subject, plus a .txt extension:  drakkos.txt, 
 * for example.
 * @param text the text to be written to the file.
 */

private void write_to_file (string text) {
  unguarded ((: write_file (query_interview_dir()
        +query_subject() +".txt", 
        sprintf ("%-=*s", 79, $(text) + "\n")) :));
}
      
/** 
 * If there is currently a 'subject' of the room... in other words, an 
 * interview is underway, all says in the room get logged to the interview
 * file.
 * @ignore yes
 */
  
void event_person_say(object ob, string start, string mess, string lang) {
  if (query_subject()) {
      write_to_file (sprintf ("%s says: %s\n", ob->short(),
          mess));
  }        
}

void event_emote(object ob, string mess) {
  if (query_subject()) {
      write_to_file (replace (EVENTS->convert_message (mess), ({"$C$", ""})));
  }        
}

/** 
 * This function will show the embedded 'movie' text at regular intervals.
 * @return returns 0 on failure, 1 on success.
 */


int do_show() {
  
  if (!query_permitted (this_player()->query_name())) {
      this_player()->add_failed_mess (this_object(), "You cannot show a "
        "movie!\n", ({ }));
      return 0;
  }    
  
  else {            
    call_out ("play_movie", 5, 0);
  }
  
  this_player()->add_succeeded_mess (this_object(), "$N dim$s the light "
          "before pulling out a grubby looking movie projector and pointing "
          "it at an empty wall.  After flicking a switch, a thin ray of "
          "light shoots at the wall.\n", ({ }));
  return 1;
}

int do_stop() {
  
  int i;
  if (!query_permitted (this_player()->query_name())) {
      this_player()->add_failed_mess (this_object(), "You cannot stop a "
        "movie!\n", ({ }));
      return 0;
  }    
  
  do {
    i = remove_call_out ("play_movie");
  } while (i != -1);
  
  
  this_player()->add_succeeded_mess (this_object(), "$N stop$s the movie.\n", 
    ({ }));
  return 1;
}

/** 
 * This function does a person_say event on the environmen.  The 
 * content of the event is the relevant movie text to be said.
 * @param i the index of the movie to be be played.
 */

void play_movie (int i) {
  
  if (movie[i][0] == '#') {
    tell_room (this_object(), "The movie shows " + 
      movie[i][1..sizeof(movie[i])] + "\n");
  }
  else {
    event (this_object(), "person_say", "The voice from the movie says: ", 
      movie[i], "general");  
  }
  
  if (i < sizeof (movie)) {    
    call_out ("play_movie", 15, ++i);    
  }
  
}

/** 
 * This function is the main entry point for the interview code.  It 
 * will set the subject of the room, and write an entry in the interview
 * text containing who the interview is with, when it was started, and
 * who conducted the interview.
 * @param ob the object to interview
 * @return 0 on failure, 1 on success
 */


varargs int do_interview (object ob, string names) {
  string *inter = ({ });
  if (!query_permitted (this_player()->query_name())) {
      this_player()->add_failed_mess (this_object(), "You cannot start an "
        "interview!\n", ({ }));
      return 0;
  }    
  
  if (query_subject()) {
      this_player()->add_failed_mess (this_object(), "You'll have to end "
          "the interview with " + query_subject() + " first.\n", ({ }));
      return 0;
  }
  else {
      if (sizeof (names)) {
        names = replace (names, ({" ", ""}));
        inter = explode (names, ",");
        tell_creator ("drakkos", "%O.\n", inter);
        inter = filter (inter, (: find_player ($1) 
          && find_player ($1)->query_playtester() :));
        tell_creator ("drakkos", "%O.\n", inter);

      }
      inter += ({ this_player()->query_name() });
      set_subject (ob->query_name());   
      set_interviewer (inter);     
      write_to_file (sprintf ("Interview with %s, started %s.  Interview " 
        "conducted by %s.\n\n", ob->short(), ctime (time()), 
        query_multiple_short (inter)));
        
  }
  this_player()->add_succeeded_mess (this_object(), "$N press$es a button "
      "on $p tape recorder, indicating the interview is now being "
      "recorded.\n", ({ }));
  return 1;
}

/** 
 * The function to end the interview.  Will write an entry in the interview
 * text containing who the interview was with and when the interview was
 * ended.  It will then add the subject to the list of interviewed names and
 * save the object.  Finally, it will reset the subject of the room. 
 * @return 0 on failure, 1 on success.
 */

int do_end() {
  if (!query_permitted (this_player()->query_name())) {
      this_player()->add_failed_mess (this_object(), "You cannot end an "
        "interview!\n", ({ }));
      return 0;
  }    
  
  if (!query_subject()) {
      this_player()->add_failed_mess (this_object(), "You are not currently "
          "interviewing anyone!\n", ({ }));
      return 0;
  }
  else {
      if (member_array (query_subject(), candidates) != -1) {
          candidates -= ({query_subject()});
      }
      if (member_array (query_subject(), submitted) != -1) {
          submitted -= ({query_subject()});
      }
      
      interviewed += ({query_subject()});
      interviewed = uniq_array (interviewed);
      save();
      
      write_to_file (sprintf ("Interview with %s, ended %s.\n", query_subject(), 
        ctime (time())));
        
      set_subject (0);
      set_interviewer (0);
      this_player()->add_succeeded_mess (this_object(), "$N switch$es off "
          "$p tape recorder, indicating the interview is at an end.\n", ({ }));
      return 1;
  }
    
}

/** 
 * If there is currently a 'subject' of the room... in other words, an 
 * interview is underway, all souls in the room get logged to the intervie
 * file.
 * @ignore yes
 */
 
void event_soul(object ob, string str, mixed avoid) {
  if (environment (this_player()) != this_object()) {
    return;
  }
  if (query_subject()) {
    write_to_file (EVENTS->convert_message (str));
  }      
}

/** 
 * Give the room some privacy.
 * @ignore yes
 */
int *query_co_ord() { 
  return 0; 
} 

/** 
 * Query the current state of applications.
 * @return 0 on failure, 1 on success
 */
int do_query() {
  if (!query_permitted (this_player()->query_name())) {
      this_player()->add_failed_mess (this_object(), "You cannot query "
        "creator candidates!\n",
          ({ }));
      return 0;
  }    
  
  if (!sizeof (query_applicants_text())) {
    this_player()->add_failed_mess (this_object(), "No information.\n");
  }
  else {
    tell_object (this_player(), this_object()->query_applicants_text());
  }  
  return 1;
}

/** 
 * Start off a creator application by sending them out the second part of
 * the application procedure.  
 * @param candidate the name to send the second part of the application to.
 * @return 0 on failure, 1 on success
 */
     
int do_add (string candidate) {
  int i = query_permitted (this_player()->query_name());
                   
  if (!i) {
      this_player()->add_failed_mess (this_object(), "You cannot add a "
        "candidate!\n", ({ }));
      return 0;
  }
  
  if (!PLAYER_HANDLER->test_user(candidate)) {
      this_player()->add_failed_mess (this_object(), "This player "
          "exists nowhere on " + mud_name() + " \n", ({ }));
      return 0;
      
  }
  
  if (query_part_two_required()) {
    if (member_array (candidate, candidates) == -1) {
        unguarded ((: write_file (LOG, sprintf ("%s added %s as a "
            "candidate on %s.\n", ($(i) == 2? "The " + query_domain() 
            + " master object" : this_player()->query_name()),
            $(candidate), ctime(time()))) :));
        candidates += ({candidate});
    }
    else {
      this_player()->add_failed_mess (this_object(), "This player has "
          "already been mailed about creatorship.\n", ({ }));
      return 0;
    }    
  }
  else if (member_array (candidate, submitted) == -1) {
        unguarded ((: write_file (LOG, sprintf ("%s added %s as a "
            "candidate on %s.\n", ($(i) == 2? "The " + query_domain() 
            + " master object" : this_player()->query_name()),
            $(candidate), ctime(time()))) :));
        submitted += ({candidate});
  } 
  else {
      this_player()->add_failed_mess (this_object(), "This player has "
          "already been mailed about creatorship.\n", ({ }));
      return 0;
  }     
    AUTO_MAILER->auto_mail( candidate, capitalize 
      (this_player()->query_name()), "Your application to " 
        + capitalize (query_domain()) + ".", query_cc(), 
        query_part_two(), 0, 0);
    save();
    this_player()->add_succeeded_mess (this_object(), "$N add$s a "
      "name to the candidate list.\n", ({ }));
    return 1;
}

string* query_submitted() {
  return submitted;
}


/** 
 * Return which candidates have been mailed, which have sent in their 
 * submission, and which are left to be interviewed or replied to.
 * @return the text to be displayed
 */
 
string query_applicants_text() {
  string ret = "", *temp = allocate (sizeof (submitted));
  int i;
  
  if (sizeof (submitted)) {
      for (i = 0; i < sizeof (submitted); i++) {
          if (find_player (submitted[i])) {
              temp [i] = "%^BOLD%^"+submitted[i] + "%^RESET%^";
          }
          else {
              temp [i] = submitted [i];
          }
      }
    }   
      
  if (query_part_two_required()) {
    if (sizeof (candidates)) {        
      ret += sprintf ("The candidates for %s still to submit answers to "
          "part two of the application process are: %s.\n", 
            capitalize (query_domain()), query_multiple_short (candidates));
    }    
  }
  else {              
    if (query_interview()) {
      if (sizeof (temp)) {
        ret += sprintf ("The following candidates for %s " + 
        (query_part_two_required()? "have submitted "
          "answers to part two of the test and " :  "") 
          + "are awaiting an interview.  "
          "Names in bold are currently online: %s.\n",
          capitalize (query_domain()), query_multiple_short (temp));
      }
    }
    else {
      ret += sprintf ("The following candidates for %s have submitted "
        "answers to part two of the test and are awaiting a response.  "
        "Names in bold are currently online: %s.\n",
        capitalize (query_domain()), query_multiple_short (temp));
    }        
  }
                              
  if (query_interview()) {
    if (sizeof (interviewed)) {        
        ret += sprintf ("The following candidates have been interviewed "
            "for %s, and are awaiting a response: %s.\n", 
            capitalize (query_domain()), query_multiple_short (interviewed));
    }
  }
  
  if (sizeof (accepted)) {
    ret += sprintf ("The following candidates have been accepted "
            "for %s: %s.\n", 
            capitalize (query_domain()), query_multiple_short (accepted));
  }

  if (sizeof (rejected)) {
    ret += sprintf ("The following candidates have been rejected from "
            "%s: %s.\n", 
            capitalize (query_domain()), query_multiple_short (rejected));
  }    
  
          
  if (!sizeof (ret)) {
      ret += "There are no outstanding candidates, and no-one has been "
          "interviewed recently.\n";
  }
  
  return ret;
}

/** 
 * Clear the list of interviewed players.
 * @return 0 on failure, 1 on success
 */
 
int clear_interviewed() {

  if (!query_permitted (this_player()->query_name())) {
      this_player()->add_failed_mess (this_object(), "You cannot do this!\n",
          ({ }));
      return 0;
  }    
  interviewed = ({ });
  return 1;
}
/** 
 * Clear the list of player candidates.
 * @return 0 on failure, 1 on success
 */

int clear_candidates() {

  if (!query_permitted (this_player()->query_name())) {
      this_player()->add_failed_mess (this_object(), "You cannot do this!\n",
          ({ }));
      return 0;
  }    
  candidates = ({ });
  return 1;
}

/** 
 * Flush the candidate, interviewed and submitted lists.
 * @return 0 on failure, 1 on success
 */

int flush() {

  if (!query_permitted (this_player()->query_name())) {
      this_player()->add_failed_mess (this_object(), "You cannot do this!\n",
          ({ }));
      return 0;
  }    
  candidates = ({ });
  interviewed = ({ });
  submitted = ({ });
  accepted = ({ });
  rejected = ({ });
  return 1;
}

/** 
 * Delete a player from the list.  Will search through all three lists for
 * an occurance of the name before deleting it where found.
 * @param candidate the name of the player to remove.
 * @return 0 on failure, 1 on success
 */


int remove_candidate(string candidate) {

  int i;
  
  if (!query_permitted (this_player()->query_name())) {
      this_player()->add_failed_mess (this_object(), "You cannot do this!\n",
          ({ }));
      return 0;
  }    
  if (member_array (candidate, candidates) != -1) {
      candidates -= ({candidate});
      i = 1;
  }
  if (member_array (candidate, submitted) != -1) {
      submitted -= ({candidate});
      i = 1;
  }
  if (member_array (candidate, interviewed) != -1) {
      interviewed -= ({candidate});
      i = 1;
  }
  if (member_array (candidate, accepted) != -1) {
      accepted -= ({candidate});
      i = 1;
  }
  if (member_array (candidate, rejected) != -1) {
      rejected -= ({candidate});
      i = 1;
  }
        
  if (i == 1) {
    this_player()->add_succeeded_mess (this_object(), "$N delete$s a "
      "name from the candidate list.\n", ({ }));
    save();
    return 1;
  }
  
  this_player()->add_failed_mess (this_object(), "No candidate by that "
    "name is on the list.\n", ({ }));          
  return 0;
}

/** 
 * Add a candidate to the list.  Will not send part two of the application
 * to them.
 * @param name name of the player to add.
 * @return 0 on failure, 1 on success
 */


int add_candidate(string name) {

  if (!query_permitted (this_player()->query_name())) {
      this_player()->add_failed_mess (this_object(), "You cannot do this!\n",
          ({ }));
      return 0;
  }    
  
  if (!PLAYER_HANDLER->test_user(name)) {
      this_player()->add_failed_mess (this_object(), "This player "
          "exists nowhere on " + mud_name() + " \n", ({ }));
      return 0;
      
  }

  if (member_array (name, candidates) == -1) {
      candidates += ({name});
      return 1;
  }
  return 0;
}

int add_interviewed(string name) {

  if (!query_permitted (this_player()->query_name())) {
      this_player()->add_failed_mess (this_object(), "You cannot do this!\n",
          ({ }));
      return 0;
  }    
  
  if (!PLAYER_HANDLER->test_user(name)) {
      this_player()->add_failed_mess (this_object(), "This player "
          "exists nowhere on " + mud_name() + " \n", ({ }));
      return 0;
      
  }

  if (member_array (name, interviewed) == -1) {
      interviewed += ({name});
      return 1;
  }
  return 0;
}

int add_confirmed(string name) {

  if (!query_permitted (this_player()->query_name())) {
      this_player()->add_failed_mess (this_object(), "You cannot do this!\n",
          ({ }));
      return 0;
  }    
  
  if (!PLAYER_HANDLER->test_user(name)) {
      this_player()->add_failed_mess (this_object(), "This player "
          "exists nowhere on " + mud_name() + " \n", ({ }));
      return 0;
      
  }

  if (member_array (name, submitted) == -1) {
      submitted += ({name});
      return 1;
  }
  return 0;
}

/** 
 * Remove a player from the interviewed list.
 * @param candidate name of the player to add.
 * @return 0 on failure, 1 on success
 */


int remove_interviewed(string candidate) {

  if (!query_permitted (this_player()->query_name())) {
      this_player()->add_failed_mess (this_object(), "You cannot do this!\n",
          ({ }));
      return 0;
  }     
  if (member_array (candidate, interviewed) != -1) {
      interviewed -= ({candidate});
      return 1;
  }
  return 0;
}

/** 
 * Confirm receipt of a candidate's submission.
 * @param candidate name of the player to add.
 * @return 0 on failure, 1 on success
 */

int do_confirm (string candidate) {
  
  if (!query_permitted (this_player()->query_name())) {
      this_player()->add_failed_mess (this_object(), "You cannot do this!\n",
          ({ }));
      return 0;
  }    

  if (!PLAYER_HANDLER->test_user(candidate)) {
      this_player()->add_failed_mess (this_object(), "This player "
          "exists nowhere on " + mud_name() + " \n", ({ }));
      return 0;
      
  }    
  
  if (member_array (candidate, submitted) != -1) {
    this_player()->add_failed_mess (this_object(), "You have already "
      "confirmed receipt of this candidate's submission.\n", ({ }));
    return 0;
  }
  if (member_array (candidate, interviewed) != -1) {
    this_player()->add_failed_mess (this_object(), "This candidate "
      "has already been interviewed.\n", ({ }));
    return 0;
  }
  
  if (member_array (candidate, candidates) != -1) {
    candidates -= ({candidate});
  }

    submitted += ({candidate});
             
    AUTO_MAILER->auto_mail( candidate, capitalize 
        (this_player()->query_name()), "Thank you for your submission.",  
        query_cc(), query_confirmation(), 0, 0);
    save();
  
  this_player()->add_succeeded_mess (this_object(), "$N confirm$s "
    "receipt of a candidate's application.\n", ({ }));
  return 1;
}

/** 
 * Set the domain the room exists in.
 * @param dom name of the domain.
 */
  
void set_domain(string dom) {
  _domain = dom;
}

/** 
 * Return the domain the room exists in.
 * @return The name of the domain, or 'unset' if none is set.
 */

string query_domain () {
  if (!_domain) {
    return "unset";
  }
  else {
    return _domain;
  }
  
}

/** 
 * Set the text of the confirmation mail.
 * @param dom name of the domain.
 */


void set_confirmation(string text) {  
  _confirmation_text = text;
}

/** 
 * Returns the confirmation mail text.
 * @return The confirmation text
 */

string query_confirmation() {
  
  if (!sizeof (_confirmation_text)) {
  
    if (query_interview()) {
      return sprintf ("Bing!\n\n"
        "Thank you for sending in the second part of the application.  "
        "The next part of the application process will be an interview "
        "to discuss your application to the %s domain.  "
        "This interview is likely to take around an hour of your time, "
        "so if you could mail me with a list of your "
        "common online times, hopefully we'll be able to make an "
        "appointment that is mutually convenient.\n\nRegards,\n%s.",
        query_domain(), LORD); 
    }
    else {
      return sprintf ("Bing!\n\n"
        "Thank you for sending in the second part of the application.  "
        "Your application to the %s domain is now being considered, and "
        "you should expect to hear back within a week or two with an "
        "answer.\n\nRegards,\n%s.",
        query_domain(), LORD);
    }
                
  }
  else {
    return _confirmation_text;
  }
}

/** 
 * Return the domain's lord.
 * @return the capitalised name of the lord.
 */

string query_lord() {
  return LORD;
}

void set_part_two_required (int i) {
  _pt_two = i;
}

int query_part_two_required () {
  return _pt_two;
}

/** 
 * Set whether an interview is required of creator candidates.
 * @param i the interview state.
 */

  
void set_interview(int i) {
  _interview = i;
}

/** 
 * Return whether creator candidates require an interview for this domain.
 * @return 0 if an interview is not required.  Anything else if it is.
 */

int query_interview() {
  return _interview;
}

/** 
 * Query the subject of an interview if one is ongoing.
 * @return 0 if there is no subject.  The name of the subject if there is.
 */

string query_subject(){
  if (_subject) {
    return _subject;
  }

  return 0;
}

/** 
 * Set the subject of an interview.
 * @pram name name of the subject.
 */

private void set_subject (string name) {
    _subject  = name;
}      

private void set_interviewer (mixed name) {
  if (arrayp (name)) {
    _int  = name;
  }
  else {
    _int = ({ name });
  }
}      

string *query_interviewer() {
  return _int;
}

int query_is_interviewer (string name) {
  if (!sizeof (_int)) {
    return 0;
  }
  
  if (member_array (name, _int) != -1) {
    return 1;
  }
  return 0;
}  

/** 
 * Query the creators permitted to use this room.
 * @return an empty array if no creators are permitted.  The array of creators 
 * otherwise.
 */

string* query_permitted_creators() {
  return copy (_allowed_creators);
}

/** 
 * Permit a creator to use this room..
 * @param name name of the creator to allow
 */

private void add_permitted_creator(string name) {
  if (member_array (name, _allowed_creators) == -1) {
    _allowed_creators += ({ name });
  }
  
}

/** 
 * Remove permission for a creator to use this room.
 * @param name name of the creator to remove
 */

private void remove_permitted_creator(string name) {
  if (member_array (name, _allowed_creators) != -1) {
    _allowed_creators -= ({ name });
  }
  
}

/** 
 * Entry point to the add creator command.
 * @param name name of the creator to allow
 * @return 0 on failure, 1 on success.
 */

int add_creator (string name) {
  object ob = find_object ("/d/" + query_domain() + "/master");
  
  if (this_player()->query_name() != ob->query_lord()) {
    this_player()->add_failed_mess (this_object(), "Only the lord "
      "may permit creators to use this room.\n", ({ }));
    return 0;
  }
  if (!PLAYER_HANDLER->test_creator (name)) {
      this_player()->add_failed_mess (this_object(), "Only creators "
        "may be permitted to use the interview room.\n", ({ }));
      return 0;
  }

  add_permitted_creator (name);
  save();
  
  this_player()->add_succeeded_mess (this_object(), "$N add$s a creator "
    "as allowed.\n", ({ }));
  return 1;
}

/** 
 * The entry point to the remove creator command.
 * @param name name of the creator to remove
 * @return 0 on failure, 1 on success.
 */

int remove_creator (string name) {

  object ob = find_object ("/d/" + query_domain() + "/master");
      
  if (this_player()->query_name() != ob->query_lord()) {
    this_player()->add_failed_mess (this_object(), "Only the lord "
      "may permit creators to use this room.\n", ({ }));
    return 0;
  }
  
  remove_permitted_creator (name);
  save();
  
  this_player()->add_succeeded_mess (this_object(), "$N remove$s a creator "
    "as allowed.\n", ({ }));
  return 1;
}  

/** 
 * Entry point to the query allowed creators command.
 * @return 0 on failure, 1 on success.
 */

int query_allowed_creators() {
  
  if (!sizeof (query_permitted_creators())) {
    this_player()->add_failed_mess (this_object(), "Only the domain lord and "
      "the domain deputies are currently permitted to use this room.\n", 
      ({ }));
    return 0;
  }
        
  tell_object (this_player(), sprintf ("In addition to the domain Lord and "
    "the domain deputies, the following creators are permitted "
    "to make use of this room: %s.\n", query_multiple_short 
    (query_permitted_creators())));
  return 1;
}

/** 
 * Return the text for the second part of the application.
 * @return application text.
 */

string query_part_two(){
  string temp;
  
  if (_filename) {
    temp = unguarded ((: read_file (_filename) :));
    
    if (sizeof (temp)) {
      return temp;
    }
  }
  
  return sprintf ("Bing!\n\nThank you for your application to the %s domain. "
    "\n\nYour application has been received and is awaiting processing.\n\n"
    "Regards,\n%s.", query_domain(), LORD);
}

/** 
 * Set the filename for the second part of the application.
 * @param file filename of the second part.
 * @return 0 on failure, 1 on success.
 */
 
int set_part_two(string file) {
  
  if (!sizeof (file)) {
    printf ("No file given for part two of application.  Aborting.\n");
    return 0;
  }
  
  if (file_size(file) == -1) {
    printf ("File given for set_part_two() does not exist.  No file set.\n");
    return 0;
  }
  
  _filename = file;
  return 1;
}

/** 
 * Return the directory where interviews are to be stored.
 * @return interview directory.
 */

string query_interview_dir(){
  if (sizeof (_interview_dir)) {
    return _interview_dir;
  }
  else {
    return SECURE;
  }
  
}

/** 
 * Set the directory where interviews are to be stored.
 * @param dir interview directory.
 * @return 0 on failure, 1 on success.
 */
 
int set_interview_dir(string dir) {
  
  if (!sizeof (dir)) {
    printf ("No directory given for interviews.  Aborting.\n");
    return 0;
  }
  
  if (file_size(dir) != -2) {
    printf ("Directory given for set_interview_dir does not exist.  "
      "Aborting.\n");
    return 0;
  }
  
  _interview_dir = dir;
  return 1;
}

/** 
 * Entry point for the query command.
 * @return 0 on failure, 1 on success.
 */
 
int do_query_text(string flag) {
  string temp;
  
  switch (flag) {
    case "confirmation":
      temp = query_confirmation();
    break;
    case "acceptance":
      temp = query_acceptance();
    break;
    case "rejection":
      temp = query_rejection();
    break;
    default:
      temp = "I'm sorry, there has been an error.\n";
    break;
  }
  
      
  tell_object (this_player(), temp);
  return 1;
}
  
/** 
 * Entry point for the flag command.  Sets an application as accepted or 
 * rejected, and sends out the appropriate form mail.
 * @param name name of candidate.
 * @param flag "accepted" or "rejected"
 * @return 0 on failure, 1 on success.
 */
int do_flag(string name, string flag) {
  
  if (member_array (name, candidates) != -1) {
        candidates -= ({name});
  }
  if (member_array (name, submitted) != -1) {
      submitted -= ({name});
  }
  if (member_array (name, interviewed) != -1) {
      interviewed -= ({name});
  }

  
  if (flag == "accepted") {
    AUTO_MAILER->auto_mail( name, capitalize 
      (this_player()->query_name()), "Congratulations!",  
          query_cc(), query_acceptance(), 0, 0);
    if (member_array (name, accepted) == -1) {
      accepted += ({name});
    }
  }
  else {
        
    AUTO_MAILER->auto_mail( name, capitalize 
      (this_player()->query_name()), sprintf ("Your application to the %s "
        "domain.", query_domain()), query_cc(), query_rejection(), 0, 0);    
    if (member_array (name, rejected) == -1) {
      rejected += ({name});
    }
    
  }
  
  this_player()->add_succeeded_mess (this_object(), sprintf ("$N flag$s a "
    "player as %s.\n", flag), ({ }));
  save();
  unguarded ((: write_file (LOG, sprintf ("%s flagged %s as %s "
          "on %s.\n", this_player()->query_name(),
          $(name), $(flag), ctime(time()))) :));
  return 1;
    
}

/** 
 * Set the rejection mail text.
 * @param text the rejection mail text
 */
 
void set_rejection(string text) {  
  _rejection_text = text;
}

/** 
 * Set the acceptance mail text.
 * @param text the acceptance mail text
 */
 
void set_acceptance(string text) {  
  _acceptance_text = text;
}

/** 
 * Query the rejection mail text.
 * @return the rejection text
 */

string query_rejection() {  
  if (!sizeof (_rejection_text)) {    
    return sprintf ("Hello.\n\n"
      "I'm sorry to say that your application to the %s domain has been "
      "unsuccessful.  My apologies that I cannot hire you at this time.  "
      "I will of course keep your details on file should you wish to "
      "apply again in the future.\n\nRegards,\n%s.",
          query_domain(), LORD);
  }
  else {
    return _rejection_text;
  }
}    

/** 
 * Query the acceptance mail text.
 * @return the rejection text
 */

string query_acceptance() {  
  if (!sizeof (_acceptance_text)) {    
    return sprintf ("Bing!\n\n"
      "It is my great pleasure to inform you that your application to the %s "
        "domain has been successful.  Congratulations!\n\nBefore being promoted, "
        "you will need to ensure you repay any debts you have.  If you wish "
        "to bequeath your inventory on a fellow player, this must also be "
        "done before you are employed - you won't get a chance once you're "
        "a creator.\n\nPlease send me a mail letting me know when you will "
        "be available for promotion and your orientation lecture.\n\n"
        "Congratulations,\n%s.",query_domain(), LORD);
  }
  else {
    return _acceptance_text;
  }
}    

/**
 * This function will take the name of a player and if the interview document
 * for that player exists, print it to the screen of this_player().
 * @param name the name of the player.
 * @return 0 on failure, 1 on success.
 */
 
int do_read (string name) {
  string path;
  
  if (!query_permitted (this_player()->query_name())) {
    this_player()->add_failed_mess (this_object(), "You cannot do this!\n",
        ({ }));
    return 0;
  } 
  
  path = query_interview_dir() + name + ".txt";
  
  if (!file_size (path)) {
    this_player()->add_failed_mess (this_object(), "This document does "
      "not exist.\n", ({ }));
    return 0;
  }
  
  this_player()->more_string (unguarded ((: read_file ($(path)) :)));
  return 1;    
}

/** 
 * Query the names cc'd by default.
 * @return an imploded string of cc'd names
 */
 
string query_cc() {
  if (sizeof (_cc)) {
    return implode (_cc, ",");
  }
  return 0;
}

/** 
 * Set the names cc'd by default.
 * @param i an array of cc'd names.
 */
void set_cc (string *i) {
  _cc = i;
}

int do_list() {
  string *list, text;
  
  if (!query_permitted (this_player()->query_name())) {
    this_player()->add_failed_mess (this_object(), "You are not permitted "
      "to do this.\n", ({ }));
    return 0;
  }  
  else {
    list = get_dir (query_interview_dir());
    list -= ({"candidate_list.o", "candidate_log.txt"});
  }
    
  list = map (list, (: capitalize ($1) :));
  text = replace (query_multiple_short (list), ({".txt", ""}));
  
  tell_object (this_player(), sprintf ("The following interviews have been "
    "conducted for the %s domain: %s.\n", query_domain(), 
      text));
  
  this_player()->add_succeeded_mess (this_object(), "$N list$s the completed "
    "interviews.\n", ({ }));
  return 1;
}

    
string* query_all_applicants() {
  return uniq_array (candidates + interviewed + submitted + accepted + rejected);
}

string* query_interviewed() {
  return interviewed;
}
// --- END [/mnt/home2/grok/lib/std/dom/interview_inherit.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/dom/error_tracker.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/dom/error_tracker.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628920   Available: 13576274
Inodes: Total: 5242880    Free: 4960135
184 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/dom/error_tracker.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628920   Available: 13576274
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/dom/error_tracker_master";

void create()
{
  set_domain("klatch");
  set_name("klatchian error tracker");
  set_other_dirs(({ }));
  set_period(604800);
  ::create();
}
// --- END [/mnt/home2/grok/lib/std/dom/error_tracker.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/container.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/container.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628919   Available: 13576273
Inodes: Total: 5242880    Free: 4960135
16898 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/container.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628919   Available: 13576273
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * The basic container inheritable, please note this is *not* a container
 * like a bucket.  This now allows things inside the container to
 * inform us that they should be used as part of the inventory of this
 * object.  This means the contents of containers will look like they
 * are not inside containers to the outside world.
 * @author Pinkfish
 * @see /obj/container.c
 * @see /obj/baggage.c
 * @see /obj/vessel.c
 * @see /obj/clothing.c
 */
#include <move_failures.h>
#include <player.h>
#include <player_handler.h>

inherit "/std/object";
inherit "/std/basic/cute_look";
inherit "/std/basic/export_inventory";
inherit "/global/auto_load";

private nosave int _max_weight;
private nosave int _loc_weight;
private nosave int _max_items;
private nosave int _prevent_insert;
private nosave string _ownership;
private nosave object _player;
private nosave int _n_tracked_items;
private nosave int _tracking;

void create() {
  registered_containers = ({ });
  _n_tracked_items = 0;
  _tracking = 1;
  export_inventory::create();
  object::create();
} /* create() */

/**
 * This method returns the maximum number of items that can
 * be carried in this container.
 * @return the maximum number of items
 * @see set_max_items()
 */
int query_max_items() {
  if(_max_items)
    return _max_items;
  if(_max_weight)
    return 4 * sqrt(_max_weight);
  return -1;
}

/**
 * This method sets the maximum number of items that can
 * be carried in this container.
 * @param number the new maximum number of items
 * @see query_max_items()
 */
void set_max_items( int number ) { _max_items = number; }

/**
 * This method returns the maximum amount of weight that can
 * be carried in this container.
 * @return the maximum weight
 * @see set_max_weight()
 */
int query_max_weight() { return _max_weight; }

/**
 * This method sets the maximum amount of weight that can
 * be carried in this container.
 * @param number the new maximum weight
 * @see query_max_weight()
 */
void set_max_weight( int number ) { _max_weight = number; }

/**
 * This method returns the current local weight in this
 * container.
 * @return the local weight
 */
int query_loc_weight() { return _loc_weight; }

/**
 * This method determins the current local weight from all the
 * objects inside the container
 * @see query_loc_weight()
 */
void update_loc_weight() {
   object thing;

   _loc_weight = 0;
   foreach ( thing in all_inventory( this_object() ) )
      _loc_weight += (int)thing->query_complete_weight();
} /* update_loc_weight() */

/**
 * This method returns the complete weight of the object.  This is the
 * weight of the container itself, plus the weight of the things
 * inside it
 * @return the complete_weight()
 * @see /std/basic/misc->query_weight()
 * @see query_loc_weight()
 */
int query_complete_weight() {
   return ::query_complete_weight() + _loc_weight;
} /* query_complete_weight() */

/**
 * This method is called in the move functions, it adds extra
 * weight onto the object when something is moved inside it.
 * @return 1 if successfuly added
 * @param n the amount to add
 * @see /std/basic/misc->query_weight()
 */
int add_weight( int n ) {
#ifdef 0
  // This shouldn't be here should it? 
  if ( _prevent_insert )
    return 0;
#endif
  if ( !_max_weight ) {
    _loc_weight += n;
    return 1;
  }
  if ( n + _loc_weight > _max_weight )
    return 0;
  if ( !environment() ) {
    _loc_weight += n;
    return 1;
  }
  if ( !environment()->add_weight( n ) )
    return 0;
  _loc_weight += n;
  return 1;
} /* add_weight() */

/**
 * This returns who owns the container, if it set to 0 then no one
 * owns it.  This is used in the theft determination for the object.
 * @return who owns the container
 * @see set_ownership()
 */
string query_ownership() { return _ownership; }

/**
 * This sets who owns the container, if it set to 0 then no one
 * owns it.  This is used in the theft determination for the object.
 * @param word who owns the container
 * @see query_ownership()
 */
void set_ownership( string word ) {
  if( word )
    _ownership = lower_case( word );
  else
    _ownership = word;
}

/**
 * This method checks to see if the object can be taken out of
 * us.
 * @param thing the object coming out
 * @param flag the move flag
 * @param dest the destination object
 * @see /std/basic/move.c
 * @return 1 if it can be taken out, 0 if not.
 */
int test_remove( object thing, int flag, mixed dest ) {
  int player;
  string str;

  if( !_ownership || !this_player() ) {
    return 1;
  }

  if( objectp( dest ) ) {
    dest = file_name( dest );
  }

  if( dest == "/room/rubbish" || dest == "/room/vault" ) {
    return 1;
  }

  str = "Item " + file_name( this_object() ) + " accessed by " +
    this_player()->query_short() + " which belongs to $C$" + _ownership;

  // It's this_player's
  if( (string)this_player()->query_name() == _ownership ) {
    str += ".  Taking items, no theft event.";
    log_file( "/w/trilogy/CONTAINER", str + "\n" );
    return 1;
  }

  player = PLAYER_HANDLER->test_user( _ownership );
  // Owner is a player
  if( player ) {
    // PK check, even if player is offline
    str += ", who is a player.  ";
    if( !pk_check( this_player(), _ownership, 1 ) &&
      environment( this_player() ) ) {
      str += "PK check succeded: Taking items, theft event triggered.";
      this_player()->zap_harry_shadow();
      event( environment( this_player() ), "theft", this_player(),
        this_object(), ({ thing }) );
      log_file( "/w/trilogy/CONTAINER", str + "\n" );
      return 1;
    } else {
      // Cannot take stuff from NPK's containers
      str += "PK check failed: Cannot take items.";
      write( "An unseen force stays your hand.\n" );
      log_file( "/w/trilogy/CONTAINER", str + "\n" );
      return 0;
    }
  } else {
  // Owner not a player
    str += ", which is not a player.  Taking items, theft event triggered.";
    this_player()->zap_harry_shadow();
    event( environment( this_player() ), "theft", this_player(),
      this_object(), ({ thing }) );
    log_file( "/w/trilogy/CONTAINER", str + "\n" );
    return 1;
  }
} /* test_remove() */

/**
 * This method allows things to be added into us.  If we have an 
 * environment check that for the ability to add into us.
 * @param ob the object being added
 * @param flag the add flags
 * @see /std/basic/move.c
 */
int test_add(object ob, int flag) {

  if(!_max_weight && !_max_items)
    return 1;

  // Prevent larger containers being placed in smaller ones
  if(ob->query_max_weight() > _max_weight - _loc_weight) {
    return 0;
  }

  // Prevent longer/wider objects being placed in shorter/thinner ones.
  // We check for a length/width greater than 1 since many items don't
  // have length/width yet.
  if(this_object()->query_length() > 1 &&
     this_object()->query_length() < ob->query_length()) {
    return 0;
  }
  if(this_object()->query_width() > 1 &&
     this_object()->query_width() < ob->query_width()) {
    return 0;
  }

  // Check if it's truly a container. If it is then count its inventory,
  // if not don't.
  if(ob->query_max_weight())
    return ((sizeof(deep_inventory(this_object())) +
             sizeof(deep_inventory(ob))) < query_max_items());
  else
    return sizeof(deep_inventory(this_object())) < query_max_items();
}

/**
 * items21 stops this container from being put into other containers.
 * @see reset_prevent_insert()
 * @see query_prevent_insert()
 */
int set_prevent_insert() { _prevent_insert = 1; }
/**
 * This allows this container to be put into other containers (default).
 * @see set_prevent_insert()
 * @see query_prevent_insert()
 */
int reset_prevent_insert() { _prevent_insert = 0; }
/**
 * If this is true, this container cannot be put into other containers.
 * @see reset_prevent_insert()
 * @see set_prevent_insert()
 */
int query_prevent_insert() { return _prevent_insert; }

/** @ignore yes */
varargs int move(mixed dest, mixed messin, mixed messout) {
  if (_prevent_insert && _loc_weight && !living(dest) && environment(dest))
    return MOVE_INVALID_DEST;

  return object::move( dest, messin, messout );
} /* move() */

/**
 * This method finds the matching objects inside this object
 * that are visible to the looker.  This will also use the
 * registered containers and add them into the array returned
 * (if visible and contained in the object).
 * @see /secure/simul_efun->find_match()
 * @param words the words matched on
 * @param looker who is looking
 * @see add_inventory_container()
 */
object *find_inv_match( string words, object looker ) {
   object *things;

   things = all_inventory( this_object() );

   /* Remove the for loop and make this a touch faster. */
   things = filter(things, (: $1->short(0) &&
                              (!$2 || $1->query_visible($2)) :), looker);

   return things;
} /* find_inv_match() */

/**
 * This method handles the case where the return of the move flag is not
 * MOVE_OK.  This can do whatever we want to make it work in a more useful
 * fashion.
 */
int do_restore_inventory_error(object ob, int move_flag) {
   object receipt;
   int ret;

   receipt = clone_object(PLAYER_RECEIPT);
   receipt->setup_receipt(ob);
   // Just in case it was too heavy.
   receipt->set_weight(0);
   ret = receipt->move(this_object());
   if (ret != MOVE_OK) {
      // Bugger it.
      receipt->dest_me();
   } else {
      move_flag = MOVE_OK;
      ob->move("/room/rubbish");
   }
   return move_flag;
} /* do_restore_inventory_error() */

/**
 * This method handles moving objects into the inventory from an auto
 * load.  This should be over ridden by things inheriting us to
 * make sure that the objects can be moved into the inventory.  It
 * should handle the bypassing of open/close/locked etc flags.
 * @param ob the object to move into ourselves
 */
protected int handle_restore_inventory(object ob) {
  /* The standard container needs to do nothing special. */
  int move_flag;

  ob->disable_item_tracking();
  move_flag = ob->move(this_object());
  ob->enable_item_tracking();
  if (move_flag != MOVE_OK) {
     // Turn it into a receipt and pop it in there ourselves.
     move_flag = do_restore_inventory_error(ob, move_flag);
  }
  return move_flag;
} /* handle_restore_inventory() */

/** @ignore yes */
mixed stats() {
  return ::stats() + ({
    ({ "loc_weight", query_loc_weight(), }),
    ({ "max_weight", query_max_weight(), }),
    ({ "max_items", query_max_items(), }),
    ({ "export invent", query_can_export_inventory() }),
  });
} /* stats() */

/** @ignore yes */
mapping int_query_static_auto_load() {
  mapping tmp;
  tmp = ::int_query_static_auto_load();
  return ([
     "::" : tmp,
     "max weight" : _max_weight,
     "prevent insert" : _prevent_insert,
     "can export inventory" : query_can_export_inventory(),
  ]);
} /* int_query_static_auto_load() */

/** @ignore yes */
mapping query_dynamic_auto_load() {
  mixed inventory;

  // Create out auto load stuff.
  catch(inventory = create_auto_load( all_inventory( this_object() ), 0 ) );

  return ([
    "::" : object::query_dynamic_auto_load(),
    "inv" : inventory
  ]);
} /* query_dynamic_auto_load() */

/**
 * This method is used in the auto loading sequence to set the
 * player who is loading the container.
 * @param thing the player loading the container
 * @see query_player()
 */
void set_player( object thing ) {
   ::set_player(thing);
    _player = thing;
}

/**
 * This method returns the player who is loading the container
 * during the autoload sequence.
 * @return the player who loaded the object
 */
object query_player() { return _player; }

/**
 * This method enables item tracking
 * @see event_enter_tracked_item
 * @see disable_item_tracking
 */
nomask void enable_item_tracking() { _tracking = 1; }

/**
 * This method disables item tracking
 * @see event_enter_tracked_item
 * @see enable_item_tracking
 */
nomask void disable_item_tracking() { _tracking = 0; }

/**
 * This method handles the movement of the containers of this object.
 * Tracked items want to be notified if the container moves or anything
 * containing it does.  The movement of the outmost moving container is 
 * propagated down to all tracked items.
 * @param mover    The outermost container object that moved
 * @param from     The start environment of the outermost container 
 * @param to       The destination of the outermost container 
 * @see event_enter_tracked_item
 */
nomask void event_container_move( object mover, mixed from, mixed to ) {
  if (_n_tracked_items) 
    all_inventory()->event_container_move( mover, from, to );
}

/**
 * This method is called from move to notify any tracked items contained of
 * the move using event_container_moved.
 * @param from   start
 * @param to     destination
 */
void event_move_object( mixed from, mixed to ) {
  if (_n_tracked_items && _tracking && !interactive()) {
    all_inventory()->event_container_move( this_object(), from, to );
    if (objectp(from)) from->remove_tracked_items( _n_tracked_items );   
    if (objectp( to )) to->add_tracked_items( _n_tracked_items );   
  }
}

/** 
 * This method is called to adjust the status reason.
 * occurences.  
 * @see event_buried 
 * @see event_player_quit 
 * @see event_enter_tracked_item
 */
nomask void set_tracked_item_status_reason(string reason) {
  if (_n_tracked_items) 
    all_inventory()->set_tracked_item_status( reason );
}

/**
 * This method handles the addition of tracked items.
 * Tracked items want to be notified if the container moves.
 * @param n_items the number of tracked items added
 * @see remove_tracked_items
 * @see event_container_move
 */
nomask void add_tracked_items( int n_items ) {
   _n_tracked_items += n_items;
   if (environment()) environment()->add_tracked_items( n_items );
}

/**
 * This method handles the removal of tracked items.
 * Tracked items want to be notified if the container moves.
 * @param n_items the number of tracked items  removed
 * @see add_tracked_items
 * @see event_container_move
 */
nomask void remove_tracked_items( int n_items ) {
  _n_tracked_items -= n_items;
  if (environment()) environment()->remove_tracked_items( n_items );
}

/**
 * This method returns the number of tracked item contained.
 * Tracked items want to be notified if the container moves.
 * @see add_tracked_items
 * @see event_container_move
 */
nomask int query_tracked_items() {
  return _n_tracked_items;
}

/**
 * This method allows the container to have stuff inside it checked.
 * @param looker the person doing the checking
 * @return 1 on success, 0 on failur
 */
int can_find_match_recurse_into(object looker) {
   object env;

   //
   // If the looked is one of our environments, then yes! they can.
   //
   env = environment();
   while (env &&
          !living(env) &&
          env != looker &&
          env != environment(looker)) {
      env = environment(looker);
   }
   return env == looker || env == environment(looker);
} /* can_find_match_recurse_into() */

/**
 * This method checks to see if the find match code can actually
 * reference this object inside us.
 * @param thing the thing to reference
 * @param looker the person looking at it
 * @return 1 if they can, 0 if they cannot
 */
int can_find_match_reference_inside_object(object thing, object looker) {
   return 1;
} /* can_find_match_reference_inside_object() */

/** @ignore yes */
void init_dynamic_arg( mapping bing, object ) {
  function f;

  if ( bing[ "::" ] ) {
    ::init_dynamic_arg( bing[ "::" ] );
  }
  /*
   * Potential order of inventory generation problem here...  Where the
   * upper parts of the container don't initialise until after we
   * return...
   */
  if ( bing[ "inv" ] ) {
    f = (: handle_restore_inventory($1) :);
    if (!_player) {
      _player = this_player();
    }
    if (_player) {
      load_auto_load_to_inventory( bing["inv"], this_object(), _player, f );
    } else {
      load_auto_load_to_inventory( bing["inv"], this_object(), this_player(), f);
    }
  }
} /* init_dynamic_arg() */

/** @ignore yes */
void init_static_arg( mapping bing ) {
  if ( bing[ "::" ] ) {
    ::init_static_arg( bing[ "::" ] );
  }
  if ( !undefinedp( bing[ "max weight" ] ) ) {
    _max_weight = bing[ "max weight" ];
  }
  if ( !undefinedp( bing[ "prevent insert" ] ) ) {
    _prevent_insert = bing[ "prevent insert" ];
  }
  if (bing["can export inventory"]) {
    set_can_export_inventory();
  } else {
    reset_can_export_inventory();
  }
} /* init_static_arg() */

/** @ignore yes */
mixed query_static_auto_load() {
  if (file_name(this_object())[0..13] == "/std/container") {
    return int_query_static_auto_load();
  }
  return ([ ]);
} /* query_static_auto_load() */

/** @ignore yes */
void dest_me() {

   foreach( object ob in all_inventory( this_object() ) ) { 
       reset_eval_cost();
       ob->dest_me();
   }

   ::dest_me();
} /* dest_me() */
// --- END [/mnt/home2/grok/lib/std/container.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/bit_set.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/bit_set.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628915   Available: 13576269
Inodes: Total: 5242880    Free: 4960135
3852 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/bit_set.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628915   Available: 13576269
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: bit_set.c,v 1.2 1998/01/23 21:38:08 dragonkin Exp $
 *
 * $Log: bit_set.c,v $
 * Revision 1.2  1998/01/23 21:38:08  dragonkin
 * Fixed to work with new bits.
 *
 * Revision 1.1  1998/01/15 19:20:53  dragonkin
 * Initial revision
 *
*/
#include "corpse.h"
inherit "std/bit";

#include <bit.h>

void create() {
  ::create();

  set_short("anonymous set of bits");
  set_long("This is an unknown set of bits of some creature.\n");
  corpse_weight = STD_CORPSE_WEIGHT;
  set_weight(5);
  set_name("bit");
  add_property( "corpse bit", 1 );
  add_property("cureable", 1);
} /* create() */

void setup_long() {
  if ( !bit_data )
    return;
  if (no_decay()) {
    if (race_name) {
      set_short( "set of "+ race_name +" "+ bit_data[ BIT_NAME ] );
      set_main_plural( "sets of "+ race_name +" "+ bit_data[ BIT_NAME ] );
      set_long("This is a set of " + (bit_data[BIT_NAME]) +
               " from " + add_a(race_name) + ".\n");
    } else {
      set_short( "set of "+ bit_data[ BIT_NAME ] );
      set_main_plural( "sets of "+ bit_data[ BIT_NAME ] );
      set_long("This is a set of " + (bit_data[BIT_NAME]) +
               " from an unknown creature.\n");
    }
  } else if (decay > 80) {
    if (race_name) {
      set_short( "set of "+ race_name +" "+ bit_data[ BIT_NAME ] );
      set_main_plural( "sets of "+ race_name +" "+ bit_data[ BIT_NAME ] );
      set_long("This is a fresh set of " + (bit_data[BIT_NAME]) +
               " severed from the corpse of " + add_a(race_name) + ".\n");
    } else {
      set_short( "set of "+ bit_data[ BIT_NAME ] );
      set_main_plural( "sets of "+ bit_data[ BIT_NAME ] );
      set_long("This is a fresh set of " + (bit_data[BIT_NAME]) +
               " severed from the corpse of an unknown creature.\n");
    }
  } else if (decay > 50) {
    if (race_name) {
      set_short( "set of "+ race_name +" "+ bit_data[ BIT_NAME ] );
      set_main_plural( "sets of "+ race_name +" "+ bit_data[ BIT_NAME ] );
      set_long("This is a set of " + bit_data[BIT_NAME] + " severed from the " +
               "corpse of " + add_a(race_name) + ".\n");
    } else {
      set_short( "set of "+ bit_data[ BIT_NAME ] );
      set_main_plural( "sets of "+ bit_data[ BIT_NAME ] );
      set_long("This is a set of " + bit_data[BIT_NAME] + " severed from the " +
               "corpse of an unknown creature.\n");
    }
  } else if (decay > 30) {
    if (race_name) {
      set_short( "set of "+ race_name +" "+ bit_data[ BIT_NAME ] );
      set_main_plural( "sets of "+ race_name +" "+ bit_data[ BIT_NAME ] );
      set_long("This is the partially decayed remains of a set of " +
               bit_data[BIT_NAME] +" severed from the "
               "corpse of " + add_a(race_name) + ".\n");
    } else {
      set_short( "set of "+ bit_data[ BIT_NAME ] );
      set_main_plural( "sets of "+ bit_data[ BIT_NAME ] );
      set_long("This is the partially decayed remains of a set of " +
               bit_data[BIT_NAME] + " severed from the " +
               "corpse of an unknown creature.\n");
    }
  } else {
    if (race_name) {
      set_short( "set of "+ race_name +" "+ bit_data[ BIT_NAME ] );
      set_main_plural( "sets of "+ race_name +" "+ bit_data[ BIT_NAME ] );
      set_long("This is the almost unrecognizable remains of a set of " +
         bit_data[BIT_NAME] +" severed from the "
         "corpse of " + add_a(race_name) + ".\n");
    } else {
      set_short( "set of "+ bit_data[ BIT_NAME ] );
      set_main_plural( "sets of "+ bit_data[ BIT_NAME ] );
      set_long("This is the almost unrecognizable remains of a set of " +
         bit_data[BIT_NAME] + " severed from the " +
         "corpse of an unknown creature.\n");
    }
  }
  if ( cured )
    set_long( query_long() +"It seems to have been pickled.\n" );
} /* setup_long() */

// --- END [/mnt/home2/grok/lib/std/bit_set.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/effect_shadow.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/effect_shadow.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628914   Available: 13576268
Inodes: Total: 5242880    Free: 4960135
949 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/effect_shadow.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628914   Available: 13576268
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* this is to be inherited by effect shadows -*- LPC -*- */

object player;
int id;

object attach_to_player(object p, int i) {
  player = p;
  id = i;
  return shadow( player, 1 );
}

void remove_effect_shadow(int i) {
  if (i == id) { if( this_object() ) destruct( this_object() ); return; }
  player->remove_effect_shadow(i);
}

protected mixed arg() {
   int enum;
   enum = (int)player->sid_to_enum( id );
   if ( enum == -1 ) {
#ifdef DEBUG
     log_file( "EFFECTS", time() +": no effect for "+
               file_name( this_object() ) +"\n           on "+
               file_name( player ) +"\n" );
#endif
      destruct( this_object() );
      return 0;
   }
   return (mixed)player->arg_of( enum );
} /* arg() */

protected void set_arg(mixed newarg) {
   player->set_arg_of(player->sid_to_enum(id), newarg);
}

protected void remove_this_effect() {
  player->delete_effect( (int)player->sid_to_enum( id ) );
} /* remove_this_effect() */
// --- END [/mnt/home2/grok/lib/std/effect_shadow.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/scroll.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/scroll.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628913   Available: 13576267
Inodes: Total: 5242880    Free: 4960135
3169 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/scroll.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628913   Available: 13576267
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/object";

int num_pages, open_page;
mixed *pages;

void create() {
  num_pages = 1;
  open_page = 1;
  pages = ({ ({ 0, 0, 0 }) });
  ::create();
} /* create() */

void init() {
  add_command("scroll", "<word'forward|backward'>", (:this_object()->do_scroll($4[0]):));
} /* init() */

void set_read_mess( string mess, string lang, int size ) {
  pages[ open_page ] = ({ mess, lang, size });
  ::set_read_mess( mess, lang, size );
} /* set_read_mess() */

void add_read_mess( string mess, string type, string lang, string size ) {
  pages[ open_page ] = ({ mess, lang, size });
  ::set_read_mess( mess, lang, size );
} /* add_read_mess( mess, type, lang, size ) */

int query_num_pages() { return num_pages; }

void set_num_pages( int number ) { num_pages = number; }

int query_open_page() { return open_page; }

void set_open_page( int number ) {
  int size;
  string mess, lang;
  mixed *text;
  if ( ( number < 0 ) || ( number > num_pages ) )
    open_page = 1;
  else
    open_page = number;
  text = pages[ open_page ];
  if ( !text || ( sizeof( text ) < 3 ) )
    text = ({ 0, 0, 0 });
  mess = text[ 0 ];
  lang = text[ 1 ];
  size = text[ 2 ];
  ::set_read_mess( mess, lang, size );
} /* set_num_pages() */

int do_scroll( string word ) {
  if ( ( word != "forward" ) && ( word != "backward" ) ) {
    notify_fail( "Syntax: scroll forward|backward\n" );
    return 0;
  }
  if ( word == "forward" ) {
    if ( open_page == num_pages ) {
      notify_fail( "The scroll is already rolled forward to the last "+
          "section.\n" );
      return 0;
    }
    set_open_page( ++open_page );
    write( "You roll the scroll forward to the next section.\n" );
    say( (string)this_player()->one_short() +" rolls the "+ short( 0 ) +
        " forward.\n" );
    return 1;
  }
  if ( open_page == 1 ) {
    notify_fail( "The scroll is already open at the first section.\n" );
    return 0;
  }
  set_open_page( --open_page );
  write( "You roll the scroll backward to the previous section.\n" );
  say( (string)this_player()->one_short() +" rolls the "+ short( 0 ) +
      " backward.\n" );
  return 1;
} /* do_scroll() */

mixed *stats() {
  return ::stats() + ({
    ({ "pages", num_pages }),
    ({ "open at", open_page })
  });
} /* stats() */

mapping query_auto_dynamic_load() {
  return ([
    "::": ::query_dynamic_auto_load(),
    "open_page": open_page
  ]);
} /* query_auto_dynamic_load() */

mapping int_query_static_auto_load() {
  return ([
    "::": ::int_query_static_auto_load(),
    "num_pages": num_pages,
    "pages": pages
  ]);
} /* int_query_static_auto_load() */

mixed query_static_auto_load() {
  if ( ( file_name( this_object() ) )[ 0 .. 10 ] != "/std/scroll" )
    return 0;
  return int_query_static_auto_load();
} /* query_static_auto_load() */

void init_dynamic_arg( mapping args ) {
  ::init_dynamic_arg( args[ "::" ] );
  open_page = args[ "open_page" ];
} /* init_dynamic_arg() */

void init_static_arg( mapping args ) {
  if ( args[ "::" ] ) ::init_static_arg( args[ "::" ] );
  if ( args[ "num_pages" ] ) num_pages = args[ "num_pages" ];
  if ( args[ "pages" ] ) pages = args[ "pages" ];
} /* init_static_arg() */
// --- END [/mnt/home2/grok/lib/std/scroll.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/storeroom.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/storeroom.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628913   Available: 13576267
Inodes: Total: 5242880    Free: 4960135
81 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/storeroom.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628913   Available: 13576267
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/shops/storeroom";

void create() {
   ::create();
} /* create() */
// --- END [/mnt/home2/grok/lib/std/storeroom.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/plant.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/plant.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628912   Available: 13576266
Inodes: Total: 5242880    Free: 4960135
1410 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/plant.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628912   Available: 13576266
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming

/*  This is the plant object thingy.  This is the quite the easy part.   */

inherit "/std/object";

string plant_name, plant_type, plant_desc;

void set_plant(string name) { plant_name = name; add_alias(name);  }
void set_plant_type(string type) { plant_type = type; }
void set_plant_desc(string desc) { plant_desc = desc; }
string query_plant() { return plant_name; }
string query_plant_type() { return plant_type; }

string get_plant_short() {
  if (plant_name && plant_type)
    return plant_type;
  return "plant";
}

string get_plant_long() {
  if (plant_desc)
    return plant_desc;
  return "A lovely plant thingy.\n";
}

void setup() {
  set_name("plant");
  set_short((: get_plant_short() :));
  set_long((: get_plant_long() :));
  add_property("plant",1);
}


mapping query_dynamic_auto_load() {
   return ([
      "::" : ::query_dynamic_auto_load(),
      "plant_name" : plant_name,
      "plant_type" : plant_type,
      "plant_desc" : plant_desc,
   ]);
} /* query_dynamic_auto_load() */


void init_dynamic_arg( mapping map, object bing ) {
   if ( map["::"] )
      ::init_dynamic_arg( map["::"], bing );
   if ( !undefinedp( map["plant_name"] ) ) {
      plant_name = map["plant_name"];
   }
   if( !undefinedp( map["plant_type"] ) ) {
      plant_type = map["plant_type"];
   }
   if( !undefinedp( map["plant_desc"] ) ) {
      plant_desc = map["plant_desc"];
   }
} /* init_dynamic_arg() */// --- END [/mnt/home2/grok/lib/std/plant.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/environ/snowball.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/environ/snowball.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628912   Available: 13576266
Inodes: Total: 5242880    Free: 4960135
4174 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/environ/snowball.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628912   Available: 13576266
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: snowball.c,v 1.8 2002/06/06 14:19:35 ohdamn Exp $
 * $Log: snowball.c,v $
 * Revision 1.8  2002/06/06 14:19:35  ohdamn
 * Fixed typo
 *
 * Revision 1.7  2002/06/06 14:17:44  taffyd
 * Fixed some things!
 *
 * Revision 1.6  2001/03/21 13:53:32  taffyd
 * Fixed pattern
 *
 * Revision 1.5  2001/03/13 00:04:52  pinkfish
 * Fix up the message when hitting.
 *
 * Revision 1.4  2000/11/16 06:31:29  ceres
 * Fixed typo
 *
 * Revision 1.3  2000/04/15 01:46:54  pinkfish
 * Make them use skills to determine the hits.
 *
 * Revision 1.2  2000/04/15 01:05:19  pinkfish
 * Make it so that it hits the person on the way up.
 *
 * Revision 1.1  1998/01/06 04:23:53  ceres
 * Initial revision
 * 
*/
#include <tasks.h>
inherit "std/object";

int strength;

void set_strength( int number );

void setup() {
   set_name( "snowball" );
   add_alias( "ball" );
   add_adjective( "snow" );
   set_strength( 99 );
   set_heart_beat( 1 );
} /* setup() */

int query_strength() { return strength; }

void set_strength( int number ) { strength = number; }

string long( string word, int dark ) {
   return "This is a "+ ({
      "very small lump of slush",
      "small and rather soggy lump of snow",
      "small snowball",
      "smallish snowball",
      "vaguely small snowball",
      "decent sized snowball",
      "reasonably sized snowball",
      "snowball for throwing at someone",
      "good snowball for throwing at someone",
      "nice, big snowball, just right for throwing at someone"
   })[ strength / 10 ] +".\n";
} /* long() */

void init() {
    add_command( "throw", "<direct:object> {at|to} <indirect:object>" );
} /* init() */

void heart_beat() {
   strength--;
   if ( strength < 1 ) {
      set_heart_beat( 0 );
      move( "/room/rubbish" );
   }
} /* heart_beat() */

private object find_person(object ob) {
   if (living(ob)) {
      return ob;
   } else {
      while (ob && !living(ob)) {
         ob = environment(ob);
      }

      if (ob) {
         return ob;
      }
   }
   return 0;
} /* find_person() */

int do_throw( object *obs ) {
   object per;
   int chance;

   per = find_person(obs[0]);
   if (per) {
      //
      // Make it harder if you are aiming at a specific bit rather than
      // the person.
      //
      if (per != obs[0]) {
         chance = 0;
      } else {
         chance = 30;
      }
      if (per == this_player()) {
         per->add_effect( "/std/effects/external/snowball", strength );
      } else {
         switch (TASKER->compare_skills(this_player(),
                                        "fighting.combat.range.thrown",
                                        per,
                                        "fighting.combat.dodging.range",
                                        chance,
                                        TM_FREE,
                                        TM_FREE)) {
         case OFFAWARD :
            tell_object(this_player(), "%^YELLOW%^You feel more able to throw "
                                       "snowballs at people.\n%^YELLOW%^");
         case OFFWIN :
            per->add_effect( "/std/effects/external/snowball", strength );
            
            add_succeeded_mess( ({ "$N throw$s $D at $I and hit$s!\n", 
                "$N throw$s $D at $I and hits!\n" }),  ({ obs[0] }) );
            break;
         case DEFAWARD :
            tell_object(this_player(), "%^YELLOW%^You feel more able to dodge "
                                       "snowball thrown by people.\n%^YELLOW%^");
         case DEFWIN :
            add_succeeded_mess( "$N throw$s $D at $I and miss$es!\n",
                                   ({ obs[0] }) );
            break;
         }
      }
   } else {
      add_succeeded_mess( "$N throw$s $D at $I.\n", ({ obs[ 0 ] }) );
   }
   move( "/room/rubbish" );
   return 1;
} /* do_throw() */

mapping query_dynamic_auto_load() {
   return ([
      "::" : ::query_dynamic_auto_load(),
      "strength" : strength
   ]);
} /* query_dynamic_auto_load() */

void init_dynamic_arg( mapping map, object ) {
   ::init_dynamic_arg( map[ "::" ] );
   strength = map[ "strength" ];
} /* init_dynamic_arg() */
// --- END [/mnt/home2/grok/lib/std/environ/snowball.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/environ/snowman.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/environ/snowman.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628911   Available: 13576265
Inodes: Total: 5242880    Free: 4960135
2117 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/environ/snowman.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628911   Available: 13576265
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: snowman.c,v 1.5 2003/01/30 16:38:28 taffyd Exp $
 * $Log: snowman.c,v $
 * Revision 1.5  2003/01/30 16:38:28  taffyd
 * Exciting bug fixes!
 *
 * Revision 1.4  2001/06/01 20:55:39  ceres
 * Can't remember
 *
 * Revision 1.3  1999/12/31 03:22:49  pinkfish
 * Fix up a typo.
 *
 * Revision 1.2  1999/05/15 12:58:49  rywfol
 * Uncapitalized (is that a word?) the short()
 *
 * Revision 1.1  1998/01/06 04:23:53  ceres
 * Initial revision
 * 
*/
#include <move_failures.h>

inherit "/std/object";

private int _call_out_handle; 

/** @ignore yes */ 
void setup() {
    reset_get();
    if ( clonep() ) { 
        _call_out_handle = call_out("die",400);
    }
} /* setup() */ 

/** 
 * This method sets the type of the snowman.  
 * @param type the type of the snowman, ie, snowman, snowwoman, snowwomble.
 * snowfrog, etc.
 */ 
void set_type(string type) {
    set_name(type);
    set_short(type);
    set_long("A wonderful " + type + " with glowing eyes made of coal and twigs "
      "for ears.\n");
    add_extra_look( this_object() ); 
} /* set_type() */ 

/** @ignore yes */ 
string extra_look( object ob ) {
    int time_left;

    if ( !_call_out_handle ) {
        return "";
    }

    time_left = find_call_out( _call_out_handle );

    debug_printf( "time left is %d\n", time_left );

    if ( time_left > 300 || time_left < 0 ) {
        return "";
    }

    return "It is " + ({ "mostly", "half", "slightly" })[time_left/100] + 
        " melted.\n";
} /* extra_look() */ 

/** @ignore yes */ 
void die() {
    string noun;

    switch( environment( this_object() )->query_property( "location" ) ) { 
    case "inside":
        noun = "floor";
        break;
    case "outside":
        noun = "ground";
        break;
    case "underwater":
        noun = "seabed";
        break;
    default:
        noun = "floor";
        break;
    }

    tell_room( environment( this_object() ), 
      the_short() + " $V$0=melts,melt$V$ into the " + noun + ".\n");

    if ( this_object()->move( "/room/rubbish" ) != MOVE_OK ) { 
        dest_me(); 
    }
} /* die() */
// --- END [/mnt/home2/grok/lib/std/environ/snowman.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/environ/weather_room.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/environ/weather_room.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628910   Available: 13576264
Inodes: Total: 5242880    Free: 4960135
2952 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/environ/weather_room.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628910   Available: 13576264
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: weather_room.c,v 1.1 1998/01/06 04:23:53 ceres Exp $
 * $Log: weather_room.c,v $
 * Revision 1.1  1998/01/06 04:23:53  ceres
 * Initial revision
 * 
*/
inherit "std/room";

mixed leverarr;

reset (arg) {
  if (arg) return;

  set_short("The weather room");
  set_long("The weather control center for the entire mud. On the floor should\n"+
           "be the controller itself, scattered around the room are hundred of impresive\n"+
           "flashing lights, dials and levers. You get the feeling however that they dont\n"+
           "actually do anything.\n");

  set_light(1);
  seteuid("pinkfish");
  add_property("inside");
  add_exit("pinkfish","d/Fish/pinkfish/workroom");
  add_item("lights","What did I say? there are lots of them and they are insesantly\n"+
           "flashing.\n");
  add_item("dials","Large dials with all sort of things on them. One you can see says\n"+
           "'Colour of spring', it is currently pointing at purple.\n");
  add_item("levers",
           "The levers are large multicolour protuberances which are scattered around the\n"+
           "room in random profusion.\n");
  leverarr = ({ ({ "blue",
       "The rooms spins and a small bit of printed paper falls from the\n"+
       "Weather controller saying:\n#query_rain" }),
                ({ "white",
       "The ground heaves in a major convulsion and a mound of paper falls onto\n"+
       "You from the ceiling saying:\n#query_cloud" }) });
       
}

init() {
  ::init();
  add_action("pull","pull");
  add_action("push","push");
}


pull(str) {
  int i;
  string type,rand;
  object lever, weather;

  if (str == "lever" || str == "levers")
    lever = leverarr[random(sizeof(leverarr))];
  else {
    if (!sscanf(str,"%s lever%s",type,rand)) {
      notify_fail("You have to pull a lever.\n");
      return 0;
    }
    for (i=0;i<sizeof(leverarr);i++) {
      if (leverarr[i][0] == type) {
        lever = leverarr[i];
        break;
      }
    }
  }
  if (!lever) {
    notify_fail("You need to choose and existing lever");
    return ;
  }

  weather = present("weather",this_object());
  if (!weather) {
    notify_fail("Opps the weather controller does not exist.\n");
    return 0;
  }
  sscanf(lever[1],"%s#%s",type,rand);
  write(type);
  this_player()->print_object(call_other(weather,rand));
  return 1;
}

push(str) {
  object lever;
  int i;
  string type,bing;

  if (str == "levers" && str == "lever")
    lever = leverarr[random(sizeof(leverarr))];
  else {
    if (!sscanf(str,"%s lever%s",type,bing)) {
      notify_fail("You must push an existing lever.\n");
      return 0;
    }
    for (i=0;i<sizeof(leverarr);i++)
      if (type == leverarr[i][0]) {
        lever = leverarr[i];
        break;
      }
  }
  if (!lever) {
    notify_fail("An existing lever could be usefull...\n");
    return 0;
  }

  write("You huff and you puff, but you just cant push that lever.\n");
}
// --- END [/mnt/home2/grok/lib/std/environ/weather_room.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/environ/weather.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/environ/weather.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628909   Available: 13576263
Inodes: Total: 5242880    Free: 4960135
10420 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/environ/weather.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628909   Available: 13576263
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: weather.c,v 1.2 2000/06/27 00:25:57 pinkfish Exp $
 * $Log: weather.c,v $
 * Revision 1.2  2000/06/27 00:25:57  pinkfish
 * Fix up the mended drum reference.
 *
 * Revision 1.1  1998/01/06 04:23:53  ceres
 * Initial revision
 * 
*/
#include <config.h>
inherit "std/object";
 
#include "climate.h"
#define FILE_NAME "/save/environ/weather"
#define HOME "/obj/handlers/weather_room"
#define MAX_DIST 100
#define YEAR 60
#define DAY 60
#define SPEED 40
 
/*
 * hmmmmm. ok well cloud cover...
 *                   wind speed...
 * hmmm. what would be a nice way of doing that? and climate...
 *
 * well we could do something like having the cloud cover sort of follow the low
 * or we could change the low scheme. I dont belive in global patterns, ie the
 * whole mud having the same weather. but nearby rooms should have very similar
 * weather.
 */
 
mixed *coldarr,
      *cloudarr,
      *rainarr;
 
int timeofyear,
    mooncycle,
    moonoff,
    timeofday,
    intensity;
 
int distance(mixed *co_ord1,mixed *co_ord);
int cloud_index(object env);
int rain_index(object env);
int temperature_index(object env);
string cloud_string(object env);
string rain_string(object env);
string temperature_string(object env);
 
void setup() {
  set_name("weather");
  set_short("weather controller extrodinare");
  set_long("The weather controller, at least this one is always right!\n");
  cloudarr = ({ ({ 0,0 }), ({ 50,50 }), ({ -50,-50 }) });
  rainarr = ({ ({ 0,0 }), ({ 50,50 }), ({ -50,-50 }) });
  coldarr = ({ ({ 0,0 }), ({ 50,50 }), ({ -50,-50 }) });
 
  intensity = 100;
  restore_object(FILE_NAME);
  call_out("update_low",SPEED);
  move("bing");
}
 
/* have this move here to get it to my weather room ;) */
move(arg) {
  ::move(HOME);
}
 
mixed *query_cold() { return coldarr; }
mixed *query_rain() { return rainarr; }
mixed *query_cloud() { return cloudarr; }
int query_moon() { return mooncycle; }
string query_moon_string(object env) {
  int bing;
 
  bing = timeofday - (DAY/4) -
         (distance((mixed *)env->query_co_ord(), ({ 0, 0, 0, }))/100);
  if (bing<0) bing += DAY;
  if ((moonoff+(DAY/2)<bing) && (bing<DAY-moonoff))
    return 0; /* the moon is not up... */
  return ({ "full moon",
            "waning three quarter moon",
            "waning half moon",
            "waning quarter moon",
            "waning cresent moon", /* from here */
            "new moon",
            "waxing cresent moon", /* to here you cannot see at night... ! */
            "waxing quarter moon",
            "waxing half moon",
            "waxing three quarter moon" })[mooncycle];
}
 
int distance(mixed *co_ord1, mixed *co_ord2) {
  int off;
  if (!pointerp(co_ord1) || !pointerp(co_ord2))
    return 0;
  if (co_ord1[0]>co_ord2[0])
    off = co_ord1[0] - co_ord2[0];
  else
    off = co_ord2[0] - co_ord1[0];
  if (co_ord1[1]>co_ord2[1])
    off += co_ord1[1] - co_ord2[1];
  else
    off += co_ord2[1] - co_ord1[1];
  return off;
}
 
int query_season() { return timeofyear/15; }
int query_time_of_year() { return timeofyear; }
int query_time_of_day() { return timeofday; }
int query_day(object env) {
  int bing, bit;
 
  if (!env) {
    load_object(CONFIG_START_LOCATION);
    env = find_object(CONFIG_START_LOCATION);
  }
/* make it change... but not very quickly... */
  bing = timeofday - (DAY/4) -
         (distance((mixed *)env->query_co_ord(), ({ 0, 0, 0, }))/100);
  if (bing<0) bing += DAY;
  bit = (DAY/2)-(timeofyear-(YEAR/2))/(YEAR/10);
  if (bing>bit)
    return 0;
  if (bit < 10)
    return bit;
  return -(bing - bit);
}
 
/*
 * returns a percentage of light.... 100 being full sunlight...
 * down
 */
int query_darkness(object env) {
  int bing, per, i;
 
/* so thats the day.... we should make the light fade towards night
 * though.... Hmmm.
 */
  per = -cloud_index(env);
  if (per <-100)
    per = -100;
  if (per > 100)
    per = 100;
  if ((i=query_day(env))) {
    i *= 20;
    if (i>100)
      i = 100;
    return 50+(per+100)*150*i/20000;
  }
  bing = timeofday - (DAY/4) -
         (distance((mixed *)env->query_co_ord(), ({ 0, 0, 0, }))/100);
  if (bing<0) bing += DAY;
  if ((moonoff+(DAY/2)<bing) && (bing<DAY-moonoff))
    return 15+(per+100)*30/200;
  if (timeofday<0) timeofday += DAY;
  i = mooncycle -5;
  if (i<0)
    i = -i;
  return 30+(per+100)*14*i/200; /* lit up by the light of the moon... tell them about it? */
}
 
string weather_string(object env) {
  return temperature_string(env)+" with "+cloud_string(env)+
         rain_string(env);
}
 
int query_raining(object env) {
  int cloud,rain;
  if (temperature_index(env)/(100/7)<2) {
    cloud = cloud_index(env);
    if (cloud<=0)
      return 0;
    rain = rain_index(env);
    if (cloud-rain<=0)
      return 0;
    return cloud-rain;
  }
  return 0;
}
 
int query_hailing(object env) {
  int cloud, rain;
 
  if (temperature_index(env)/(100/7)==2) {
    cloud = cloud_index(env);
    if (cloud <=0)
      return 0;
    rain = rain_index(env);
    if (cloud-rain <=0)
      return 0;
    return cloud-rain;
  }
  return 0;
}
 
int query_snowing(object env) {
  int cloud,rain;
  if ((temperature_index(env)/(100/7))>=3) {
    cloud = cloud_index(env);
    if (cloud<=0)
      return 0;
    rain = cloud_index(env);
    if (cloud-rain<=0)
      return 0;
    return cloud-rain;
  }
  return 0;
}
 
string rain_string(object env) {
  int cloud, rain, temp;
  string tempstr1,tempstr2;
 
  cloud = cloud_index(env);
  rain = rain_index(env);
  if (cloud<=0) return "";
  if (cloud-rain<=0) return "";
  temp = temperature_index(env)/(100/7);
  if (temp>3) temp = 3;
  if (temp<-3) temp = -3;
  tempstr1 = ({ "very hot ",
                "hot ",
                "warm ",
                "nice ",
                "cold ",
                "",
                "" })[temp+3];
  tempstr2 = ({ " rain",
                " rain",
                " rain",
                " rain",
                " rain",
                " hail",
                " snow" })[temp+3];
  cloud = (cloud-rain) / 20;
  if (cloud>5) cloud = 5;
  return "\n"+capitalize(tempstr1 + ({ "very light",
                      "light",
                      "medium",
                      "heavy",
                      "very heavy" }) [cloud]+tempstr2);
}
 
string temperature_string(object env) {
  int inten;
  inten = temperature_index(env);
  inten /= 10;
  if (inten>10)
    inten = 10;
  if (inten<-10)
    inten = -10;
  return ({ "Its one of those baking eggs on the pavement days", /* -10 */
            "So hot that the sun feels like its right next door", /* -9 */
            "Damn hot", /* -8 */
            "Very hot", /* -7 */
            "Hot", /* -6 */
            "Hot", /* -5 */
            "Reasonably hot", /* -4 */
            "Very warm", /* -3 */
            "Warm", /* -2 */
            "Pleasantly warm", /* -1 */
            "Average temerature", /* 0 */
            "A little chilly", /* 1 */
            "A slight nip in the air", /* 2 */
            "Chilly", /* 3 */
            "Very chilly", /* 4 */
            "Cold", /* 5 */
            "Cold", /* 6 */
            "Very cold", /* 7 */
            "Damn cold", /* 8 */
            "Incredibly cold", /* 9 */
            "Freezing cold" })[inten+10]; /* 10 */
}
 
string cloud_string(object env) {
  int off;
 
  off = cloud_index(env) / 20;
  if (off>5) off = 5;
  if (off<-5) off = -5;
  return ({ "a beatifully clear sky", /* -5 */
            "a few high level sirius clouds", /* -4 */
            "scattered puffy clouds", /* -3 */
            "very thin complete cloud cover", /* -2 */
            "light cloud cover", /* -1 */
            "medium cloud cover", /* 0 */
            "dense cloud cover", /* 1 */
            "packed cloud cover", /* 2 */
            "packed cloud cover", /* 3 */
            "heavy black clouds", /* 4 */
            "thick heavy clouds", /* 5 */
         })[off+5];
}
 
int temperature_index(object env) {
  int off,i;
  mixed clim, *co_ord;
 
  for (i=0;i<sizeof(coldarr);i++)
    off += (distance((mixed *)env->query_co_ord(), coldarr[i]) % (MAX_DIST*2));
  off = off / sizeof(coldarr);
  if ((clim = (mixed *)env->query_property("climate")))
    off += clim[C_TEMP];
  if (off>MAX_DIST) off = (MAX_DIST*2) - off;
  off -= (MAX_DIST/2);
  off = 0 - off;
  co_ord = (mixed *)env->query_co_ord();
  if (!co_ord)
    co_ord = ({ 0, 0, 0 });
  return (off + (timeofyear - (YEAR/2)) + (timeofday - (DAY/2)) + co_ord[2]);
}
 
int cloud_index(object env) {
  int off;
  mixed *clim;
  int i;
 
  for (i=0;i<sizeof(cloudarr);i++)
    off += (distance((mixed *)env->query_co_ord(), cloudarr[i]) % (MAX_DIST*2));
  off = off / sizeof(cloudarr);
  if ((clim = (mixed *)env->query_property("climate")))
    off += clim[C_CLOUD];
  if (off>MAX_DIST) off = (MAX_DIST*2) - off;
  off -= (MAX_DIST/2);
  off = 0-off;
  return (off + (timeofyear - (YEAR/2)));
}
 
int rain_index(object env) {
  int off;
  mixed *clim;
  int i;
 
  for (i=0;i<sizeof(rainarr);i++)
    off += (distance((mixed *)env->query_co_ord(), rainarr[i]) % (MAX_DIST*2));
  off = off / sizeof(rainarr);
  if ((clim = (mixed *)env->query_property("climate")))
    off += clim[C_RAIN];
  if (off>MAX_DIST) off = (MAX_DIST*2) - off;
  off -= MAX_DIST/2;
  off = 0-off;
  return off;
}
 
void update_low() {
  int i;
 
  timeofday++;
  if (timeofday>DAY) {
    timeofday = 0;
    timeofyear++;
    mooncycle++;
    if (mooncycle %2) {
      moonoff += 1;
      moonoff = moonoff % (DAY/2);
    }
    timeofyear = timeofyear % YEAR;
    mooncycle = mooncycle % 10;
    save_object(FILE_NAME);
  }
  for (i=0;i<sizeof(rainarr);i++) {
    rainarr[i][0] += random(3)-1;
    rainarr[i][0] = rainarr[i][0] % (MAX_DIST*2);
    rainarr[i][1] += random(3)-1;
    rainarr[i][1] = rainarr[i][1] % (MAX_DIST*2);
  }
  for (i=0;i<sizeof(cloudarr);i++) {
    cloudarr[i][0] += random(3)-1;
    cloudarr[i][0] = cloudarr[i][0] % (MAX_DIST*2);
    cloudarr[i][1] += random(3)-1;
    cloudarr[i][1] = cloudarr[i][1] % (MAX_DIST*2);
  }
  for (i=0;i<sizeof(coldarr);i++) {
    coldarr[i][0] += random(3)-1;
    coldarr[i][0] = coldarr[i][0] % (MAX_DIST*2);
    coldarr[i][1] += random(3)-1;
    coldarr[i][1] = coldarr[i][1] % (MAX_DIST*2);
  }
  intensity += random(3)-1;
  if (intensity<50)
    intensity=50;
  if (intensity>300)
    intensity=300;
  call_out("update_low",SPEED);
}
 
void dest_me() {
  save_object(FILE_NAME);
  ::dest_me();
}
// --- END [/mnt/home2/grok/lib/std/environ/weather.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/living/skills.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/living/skills.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628906   Available: 13576260
Inodes: Total: 5242880    Free: 4960135
23271 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/living/skills.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628906   Available: 13576260
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: skills.c,v 1.24 2003/05/07 22:49:32 ceres Exp $
 * 
*/
/**
 * This skills modules for living creates.  This deals will all the
 * skill interactions needed for the living objects.
 *
 * @author Pinkfish
 */
/*
 * sigh, this will be interesting wont it?
 * quick summary of routines
 * skill_bonus(string,int)     - gives the bonus...
 * skill_lvl(string)           - gives the raw level, with out stat bonus etc
 * modify_skill(string,int,int)- modifies the skills level by int.
 * calc_bonus(int,string,int)  - given the skill lvl, stat bonus str cals bonus
 * calc_lvl(string *)          - calculate number of lvls in the path
 * add_skill_lvl(...)          - horror recursive skill adder. arghh
 * teach_skill(objct *,string) - Used to teach skills to other people.
 * skill_commands()            - all the skill add_actioned commands.
 */
 
#include <skills.h>
#include <tasks.h>
#include <tune.h>

// #define BAD_TM "BAD_TM"
#undef LOGGING

varargs int calc_bonus( int lvl, string skill, int use_base_stats );
varargs int stat_modify( int bonus, string skill, int use_base_stats );
mixed recursive_skill_add(mixed skil, string *path, int avr, int lvl, int exp,
                           mixed standard);
private void convert_skills(mixed *skills, string path);
int query_skill(string skill);

mapping new_skills;
 
nosave mapping _bonus_cache,
               _stat_cache,
               _teach_offer;

mapping _last_info;

mapping query_skills() { return copy( new_skills ); }
void set_skills( mapping map ) { new_skills = map; }
int calc_level(string *path);

void create() {
  _bonus_cache = ([ ]);
  _teach_offer = ([ ]);
  _stat_cache = ([ ]);
  new_skills = ([ ]);
  if(!_last_info)
    _last_info = ([ "time" : time() ]);
} /* create() */

/**
 * This method checks to see if the skill exists in the skill array or
 * not.
 * @param skill the skill to check for non-existance
 * @return 0 if it does not exist, 1 if it does
 */
int not_there( string skill ) {
   //return member_array( skill, keys( new_skills ) ) == -1;
   return undefinedp(new_skills[skill]);
} /* not_there() */

/**
 * This method returns the current bonus cache for the living thing.
 * The bonus cache is where the calculated bonuses for the skills are
 * kept.
 * @return the bonus cache mapping
 */
mapping query_bonus_cache() { return copy(_bonus_cache); }
/**
 * This method returns the cached values for the stats.
 * @return the caches stat values
 */
mapping query_stat_cache() { return copy(_stat_cache); }

/**
 * This method zaps the stat cache when a certain stat changes.
 * It calls the function stats_to_zap() on the living object to
 * figure out which stats have changed.
 * @see /std/living/stats->stats_to_zap()
 */
void zap_stat_cache() {
   int i;
   string word, *list, stat;

   stat = this_object()->stats_to_zap();
   if ( !stat ) {
      return;
   }
   if ( find_call_out( "reset_all2" ) == -1 ) {
      call_out( "reset_all2", 1 );
   }
   foreach( i in stat ) {
      list = _stat_cache[ i ];
      if ( !list )
         continue;
      foreach( word in list ) {
         map_delete( _stat_cache, word );
      }
   }
   word = (string)this_object()->query_race_ob();
   if ( word ) {
      word->set_unarmed_attacks( this_object() );
   }   
} /* zap_stat_cache() */

/**
 * This method zaps the bonus cache.
 */
void totaly_zap_bonus_cache() {
   _bonus_cache = ([ ]);
} /* zap_bonus_cache() */

/**
 * This method zaps the stat cache.
 */
protected void totaly_zap_stat_cache() {
   _stat_cache = ([ ]);
} /* zap_stat_cache() */

/**
 * This method returns the skill bonus for the specified skill.
 * It returns the skill + all its bonsues for stats/whatever.
 * It first checks to see if the skill is in it's cache.   THe
 * real stat values are ones not modified by bonuses or temporary
 * values.
 * @param skill the skill to get the bonus for
 * @param use_base_stats tells the system not to use the real stat values
 * @return the skill bonus
 */
varargs int query_skill_bonus( string skill, int use_base_stats ) {
#ifdef 0  
   int tmp, lvl;
   string *path;
   object guild, race;
#endif
   
  if (!stringp(skill) || !strlen(skill)) {
    return 0;
  }
  if (!new_skills) {
    new_skills = ([ ]);
  }
  if (skill[0] == '.') {
    skill = skill[1..];
  }
  TASKER->set_control( ({ this_object(), skill }) );
  if ( _bonus_cache[ skill ] )
     return stat_modify( _bonus_cache[ skill ], skill, use_base_stats ); 
  return calc_bonus( query_skill(skill), skill, use_base_stats );
#ifdef 0
  // The following just isn't used anymore so can be removed.
  lvl = query_skill(skill);
  guild = (object)this_object()->query_guild_ob();
  race = (object)this_object()->query_race_ob();
  if (race) {
    tmp = (int)race->query_skill_bonus(lvl, skill);
  }
  if (guild) {
    tmp += (int)guild->query_skill_bonus(lvl, skill);
  }
  return calc_bonus( lvl + tmp, skill, use_base_stats );
#endif  
} /* query_skill_bonus() */

/**
 * This returns jus the skill level.  Used a lot to determine if you
 * can use/teach/whatever a skill.
 * This also uses a cache.
 * @param skill the skill to return the level of
 * @return the skill level
 */ 
int query_skill(string skill) {
   string *path;

   if (!new_skills) {
      new_skills = ([ ]);
   }
   if (!stringp(skill)) {
      return 0;
   }
   if (skill[0] == '.') {
      skill = skill[1..];
   }
   TASKER->set_control( ({ this_object(), skill }) );
   if ( not_there( skill ) ) {
      int i;

      path = (string *)SKILL_OB->query_skill_tree(skill);
      if (path) {
         for (i=0;i<sizeof(path);i++) {
            if ( !not_there( path[ i ] ) ) {
               return new_skills[path[i]];
            }
         }
      }
   } else {
      return new_skills[skill];
   }
   return 0;
} /* query_skill() */

/**
 * This method fills out a complete skill branch, complete with ALL child skills.
 * It saves using many call_others to check skills.
 * @arg string The branch you want to query [ie: faith, magic, etc.]
 */
mapping query_complete_skill_branch( string branch ) {
  string *skills = SKILL_OB->query_all_children( branch );

  if ( !arrayp( skills ) || !sizeof( skills ) ) 
    return ([ ]);
  
  return allocate_mapping( skills, (: query_skill( $1 ) :) );
}

/**
 * This is used to convert a previously not only_leaf tree into an only_leaf
 * tree.
 */
protected void flatten_it(string skill) {
   int value;
   int i;
   string *same;

   reset_eval_cost();
   value = new_skills[skill];
   same = (mixed *)SKILL_OB->query_immediate_children(skill);
   for (i=0;i<sizeof(same);i++) {
      if ( not_there( same[ i ] ) ) {
         new_skills[same[i]] = value;
      }
      flatten_it(same[i]);
   }
   if (sizeof(same)) {
      map_delete(new_skills, skill);
   }
} /* flatten_it() */

int tm_check_ok(string skill, object exp) {
  string *history, *bits, *abits;
  int i, j, last, delay;

  if ( !_last_info ) { 
    _last_info = ([ "time" : time() ]);
  }

#ifdef LOGGING
  if(base_name(previous_object()) != "/obj/handlers/taskmaster" &&
     base_name(previous_object()) != "/std/effects/fighting/combat" &&
     base_name(previous_object()) != "/std/shadows/misc/team" &&
     base_name(previous_object()) != "/std/shadows/other/group" &&
     base_name(previous_object()) != "/global/player" &&
     base_name(previous_object())[0..2] != "/w/") {
     log_file("ATTEMPT_TASK", "Object %s gave skill increase without using "
              "the taskmaster.\n", base_name(previous_object()));
   }
#endif

  history = this_object()->get_history();
  if(sizeof(history)) {
    // This code looks for people repeating commands over and over in an
    // attempt to gain TMs.
    for(i=0; i<sizeof(history) && history[i]; i++)
      ;
    
    last = i - 1;

    // deal with aliases and command queuing
    if(!this_object()->is_alias(history[last]))
      last -= this_object()->query_queued_commands();
  
    if(last > 0 && sizeof(history[last]) > 1 && skill[<7..] != ".points") {
      for(i=0; i<sizeof(history) && history[i]; i++) {
        if(history[last] == history[i]) {
          j++;
        }
      }
      
      if(j > 5 || j * 100 / i > 30) {
#ifdef BAD_TM
        log_file(BAD_TM, "%s %s in %s by %O too many attempts at %s [%s]\n",
                 ctime(time())[4..18], this_object()->query_name(), skill,
                 exp, history[last], history[i-1]);
#endif

        if(!_last_info["skill"] || _last_info["skill"][0] != skill)
          _last_info["skill"] = ({ skill, 2 });
        else
          _last_info["skill"][1] += 1;
        
        _last_info["time"] = time();
        
        if(!_last_info["object"] || _last_info["object"][0] != base_name(exp))
          _last_info["object"] = ({ base_name(exp), 2 });
        else
          _last_info["object"][1] += 1;

        if(!_last_info["env"] || _last_info["env"][0] != environment())
          _last_info["env"] = ({ environment(), 2 });
        else
          _last_info["env"][1] += 1;
        
        return 0;
      }
    }
  }
  
  // Checks for repeated TMs with the same or similar skill trees.

  // starting value (minimum delay) is proportional to their guild level
  // and the level of this skill.
  delay = 30 + random(this_object()->query_level()) +
    random(this_object()->query_skill(skill));
  
  // if this is the same object as last award then double the delay required
  if(_last_info["object"] && base_name(exp) == _last_info["object"][0])
    delay *= _last_info["object"][1];

  // if this skill is more than twice their guild level then increase the
  // delay.
  if(this_object()->query_level() * 2 < this_object()->query_skill(skill))
    delay *= 2;

  if(_last_info["env"] && environment(this_object()) == _last_info["env"][0]) {
    delay *= _last_info["env"][1];
  }
  
  // see how many parts of the tree matches. The closer the skill
  // matches the longer between repeats.
  // Note that if there is no match at all their delay will be 60 seconds.
  bits = explode(skill, ".");
  if(_last_info["skill"])
    abits = explode(_last_info["skill"][0], ".");
  else
    abits = ({ });
  for(i=0; i<sizeof(bits) && i<sizeof(abits) && bits[i] == abits[i]; i++)
    ;

  if(i && _last_info["skill"])
    delay *= (i * _last_info["skill"][1]);
  else
    delay = 60;
  
  if(_last_info["time"] > (time() - delay)) {
#ifdef BAD_TM
    log_file(BAD_TM, "%s %s in %s by %O last %d secs ago, delay %d.\n",
             ctime(time())[4..18], this_object()->query_name(), skill,
             exp, (time() - _last_info["time"]), delay);
#endif
    if(!_last_info["skill"] || _last_info["skill"][0] != skill)
      _last_info["skill"] = ({ skill, 2 });
    else
      _last_info["skill"][1] += 1;
    
    _last_info["time"] = time();
    
    if(!_last_info["object"] || _last_info["object"][0] != base_name(exp))
      _last_info["object"] = ({ base_name(exp), 2 });
    else
      _last_info["object"][1] += 1;
    
    if(!_last_info["env"] || _last_info["env"][0] != environment())
      _last_info["env"] = ({ environment(), 2 });
    else
      _last_info["env"][1] += 1;
    return 0;
  }

  if(!_last_info["skill"] || _last_info["skill"][0] != skill)
    _last_info["skill"] = ({ skill, 2 });
  else
    _last_info["skill"][1] += 1;
  
  _last_info["time"] = time();
  
  if(!_last_info["object"] || _last_info["object"][0] != base_name(exp))
    _last_info["object"] = ({ base_name(exp), 2 });
  else
    _last_info["object"][1] += 1;
  
  if(!_last_info["env"] || _last_info["env"][0] != environment())
    _last_info["env"] = ({ environment(), 2 });
  else
    _last_info["env"][1] += 1;
  return 1;
}

/**
 * This method adds a skill level to the specified skill to the
 * system.
 * @param skill the skill to add a level to
 * @param lvl the number of levels to add
 * @param exp the amount of exp spent on the skill
 * @return 1 if the skill level was changed
 * @see query_skill()
 * @see query_skill_bonus()
 */
varargs int add_skill_level( string skill, int lvl, mixed exp ) {
   string guild, *recursive_skills, *same_level, *bits, *tree;
   int i;

   reset_eval_cost();
   if (!stringp(skill) || !intp(lvl) || lvl > 1000) {
      return 0;
   }
   
   if (!new_skills || (!mapp(new_skills))) {
      new_skills = ([ ]);
   }
   if (skill[0] == '.') {
      skill = skill[1..];
   }

   recursive_skills = (string *)SKILL_OB->query_related_skills(skill);
   if (!recursive_skills) {
      return 0;
   }

   bits = explode(skill, ".");
   /*
    * Make sure the path leading up to this skill exists so that we can
    * get the right value for the skill when we add it in.
    * This should only be done if they are not only leaf skills.
    */
   if ( not_there( skill ) && !SKILL_OB->query_only_leaf(skill)) {
      int tmp_lvl, j;

      if (sizeof(bits) > 1) {
         tmp_lvl = 0;
         for (i=sizeof(bits)-1;!tmp_lvl && i>=0;i--) {
            if ( !not_there( implode( bits[ 0 .. i ], "." ) ) ) {
               tmp_lvl = new_skills[implode(bits[0..i], ".")];
               break;
            }
         }
         if (i>=0) {
            for (;i<sizeof(bits);i++) {
               same_level = (string *)
                 SKILL_OB->query_immediate_children(implode(bits[0..i], "."));
               for ( j = 0; j < sizeof( same_level ); j++ ) {
                  new_skills[ same_level[ j ] ] = tmp_lvl;
                  map_delete( _bonus_cache, same_level[ j ] );
               }
            }
         } else {
            tmp_lvl = 0;
         }
      }
   }

   /* Includes the current skill */
   for (i=0;i<sizeof(recursive_skills);i++) {
      if ( !not_there( recursive_skills[ i ] ) ) {
         new_skills[recursive_skills[i]] += lvl;
         if (new_skills[recursive_skills[i]] < 0) {
            new_skills[recursive_skills[i]] = 0;
         }
      }
      map_delete(_bonus_cache, recursive_skills[i]);
   }

   if ( not_there( skill ) ) {
      new_skills[skill] = lvl;
   }

   /*
    * If it is not a only_leaf heirarchy, then fix up all the lower level
    * average skill levels.
    * The first element is the current skill.
    */
   tree = (string *)SKILL_OB->query_skill_tree(skill);
   for (i=1;i<sizeof(tree);i++) {
      int total, j;

      same_level = (string *)SKILL_OB->query_immediate_children(tree[i]);
      if (sizeof(same_level)) {
         total = 0;
         for (j=0;j<sizeof(same_level);j++) {
            /* If it does not exist.  Set it from the top value down. */
            if ( not_there( same_level[ j ] ) ) {
               new_skills[ same_level[ j ] ] = new_skills[ tree[ i ] ];
               map_delete( _bonus_cache, same_level[ j ] );
            }
            total += new_skills[same_level[j]];
         }
         new_skills[tree[i]] = total/sizeof(same_level);
         map_delete( _bonus_cache, tree[ i ] );
      }
   }

   /* Update the high level players table */
   if ( interactive( this_object() ) &&
         ( guild = (string)this_object()->query_guild_ob() ) ) {
      if ( stringp( guild ) ) {
        //         TOP_TEN_HANDLER->player_skill_advance( explode( guild, "/" )[ 2 ],
        //this_object() );
         guild->skills_advanced( this_object(), skill, new_skills[ skill ] );
      }
  }

  if((lvl == 1) && userp(this_object()) && (!exp || objectp(exp))) {
    if(!exp)
      exp = previous_object();
    if(!tm_check_ok(skill, exp)) {
      new_skills[skill] -= 1; // take the award away again.
      return 0;
    } else {
      TASKER->award_made( (string)this_object()->query_name(),
                          base_name( exp ), skill, new_skills[ skill ] );
    }
  }
  
  /* Make sure that there is at most one call_out running */
  if ( find_call_out( "reset_all" ) == -1 ) {
    call_out( "reset_all", 1 );
  }

  if(interactive(this_object()) && !this_object()->query_auto_loading())
     this_object()->save();

  return 1;
} /* add_skill_level() */

/**
 * This method returns the skill as it should be modified by the
 * stats associated with it.
 * @param lvl the level to modify
 * @param skill the skill the modify the bonus of
 * @param use_base_stats use the real unmodified stat values
 * @see query_skill_bonus()
 * @return the stat modification
 */
varargs int stat_modify( int lvl, string skill, int use_base_stats ) {
   int i, stat;
   string stat_bonus;
   float bonus;

   bonus = 0.0;

   if ( !_stat_cache[ skill ] || use_base_stats ) {
      stat_bonus = (string)SKILL_OB->query_skill_stat(skill);
      foreach ( i in stat_bonus ) {
         switch( i ) {
            case 'C' :
               if ( use_base_stats )
                  stat = (int)this_object()->query_real_con();
               else
                  stat = (int)this_object()->query_con();
               break;
            case 'D' :
               if ( use_base_stats )
                  stat = (int)this_object()->query_real_dex();
               else
                  stat = (int)this_object()->query_dex();
               break;
            case 'I' :
               if ( use_base_stats )
                  stat = (int)this_object()->query_real_int();
               else
                  stat = (int)this_object()->query_int();
               break;
            case 'S' :
               if ( use_base_stats )
                  stat = (int)this_object()->query_real_str();
               else
                  stat = (int)this_object()->query_str();
               break;
            case 'W' :
            default :
               if ( use_base_stats )
                  stat = (int)this_object()->query_real_wis();
               else
                  stat = (int)this_object()->query_wis();
         }
         //bonus += ( stat - 13 ) * 3;
         if (stat > 0) {
            bonus += (log(stat) / 9.8) - 0.25;
         } else if (stat < 0) {
            bonus -= (log(-stat) / 9.8) + 0.25;
         } else {
            bonus -= 0.25;
         }
         if ( !_stat_cache[ i ] ) {
            _stat_cache[ i ] = ({ skill });
         } else {
            _stat_cache[ i ] |= ({ skill });
         }
      }
      if ( !use_base_stats ) {
         _stat_cache[ skill ] = ({ bonus, stat_bonus });
      }
   } else {
      bonus = _stat_cache[ skill ][ 0 ];
      stat_bonus = _stat_cache[ skill ][ 1 ];
   }
   i = strlen( stat_bonus );
   if ( i ) {
      //return lvl + ( lvl * bonus ) / ( i * 60 );
      stat = to_int(lvl + ( lvl * bonus ));
      if (stat < 0) {
         return 0;
      }
      return stat;
   }
   return lvl;
} /* stat_modify() */

/*
 * Handy fact: stat_modify( 100, skill ) - 35 is the stat total
*  for that skill.
*/

/**
 * This method calculates the bonus for the skill.  It takes the raw
 * level and turns that into a bonus and then adds on the stats
 * modifications.
 * @param lvl the level to turn into bonus
 * @param skill the skill to modify the bonus of
 * @param use_base_stats use the real unmodified stats
 * @return the bonus associated with the skill
 */
varargs int calc_bonus( int lvl, string skill, int use_base_stats ) {
//  int bonus, stat, i;
   if (lvl > 60) {
      lvl = 170 + ((lvl-60) >> 1);
   } else if (lvl > 40) {
      lvl = 150 + (lvl-40);
   } else if (lvl > 20) {
      lvl = 100 + ( ((lvl-20)*5) >> 1);
   } else {
      lvl = lvl * 5;
   }
   if ( !use_base_stats ) {
      _bonus_cache[ skill ] = lvl;
   }
   return stat_modify( lvl, skill, use_base_stats );
} /* calc_bonus() */

/**
 * This method does a skill successful check.  Does this check:<br>
 * (bonus + mos) >= random(200)
 * @param str the skill to check
 * @param mod the modification value
 * @return 1 if the skill check is successful
 */
int query_skill_successful(string str, int mod) {
  return (query_skill_bonus(str, 0) + mod >= random(200));
} /* query_skill_successful */

/**
 * This method adds a teaching offer to the living object.
 * @param ob the object teaching us
 * @param skill the skill they are teaching
 * @param num the number of levels they are teaching
 * @param lvl the level they are teaching us from
 * @param xp the cost of the level increase in xp
 */
void add_teach_offer(object ob, string skill, int num, int lvl, int xp) {
  _teach_offer[ob] = ({ skill, num, lvl, xp });
} /* add_teach_offer() */

/**
 * This method returns the current list of teach offerings on the
 * living object.
 * @return the mapping containing the teach offerings
 */
mapping query_teach_offer() { return copy(_teach_offer); }

/**
 * The method to call when we stop teaching skills.  THis will stop the
 * stuff being taught if the stop is successful, and only teach partial
 * amounts if we are not finished yet.
 * @param left the amount of time left
 * @param bing the data associated with the command
 */
void stop_teaching_skills(int left, mixed bing) {
   object ob;

   if (left > 0) {
      /* Someone did a stop!  Naughty frogs! */

      if (bing[O_OTHER_PER] == this_object()) {
         say(this_object()->short() + " stops teaching themselves some "
             "skills.\n");
      } else if (previous_object() == this_object()) {
         ob = bing[O_OTHER_PER];
         tell_object(ob, this_object()->short() + " interupts your "
                         "training.\n");
      } else {
         ob = this_object();
         tell_object(ob, bing[O_OTHER_PER]->short() + " interupts your "
                         "training.\n");
      }
      say(bing[O_OTHER_PER]->short() + " stops teaching some skills to " +
          this_object()->short() + ".\n",
          ({ this_object(), bing[O_OTHER_PER] }));

      this_object()->adjust_time_left(-((int)this_object()->query_time_left()));
      this_object()->set_interupt_command(0);

      return ;
   }
  
   if (previous_object() != this_object()) {
      /* First make sure we dont get the level twice... */
      return ;
   }

   // additional test added by ceres coz people are getting put into negative
   // xp by getting taught twice somehow.
   if(this_object()->query_xp() < bing[O_XP]) {
      write("Something has gone wrong. :(\n");
      return;
   }
   /* Ok...  We did it!  Finished! */
   if (this_object() != bing[O_OTHER_PER]) {
      bing[O_OTHER_PER]->adjust_xp(bing[O_XP]/10);
   }
   this_object()->adjust_xp(-bing[O_XP]);
   add_skill_level(bing[O_SKILL], bing[O_NUM], bing[O_XP]);
   if (this_object() != bing[O_OTHER_PER]) {
      tell_object(this_object(), "You finish learning " + bing[O_NUM] +
                  " levels of "
                  + bing[O_SKILL] + " from " + bing[O_OTHER_PER]->short() +
                  ".\n");
      tell_object(bing[O_OTHER_PER], this_object()->short() + " finishes " +
                  "learning " + bing[O_NUM] + " levels of "
                  +bing[O_SKILL] + " from you.\n");
      say(this_object()->short() + " finishes learning some skills "+
          "from "+bing[O_OTHER_PER]->short()+".\n",
          ({ this_object(), bing[O_OTHER_PER] }));
   } else {
      tell_object(this_object(), "You finish teaching yourself " + bing[O_NUM] +
                  " levels of " + bing[O_SKILL] + ".\n");
      say(this_object()->short() + " finishes learning some skills "
          "from " + this_object()->query_objective() + "self.\n",
          ({ this_object(), bing[O_OTHER_PER] }));
   }
} /* stop_teaching_skills() */
// --- END [/mnt/home2/grok/lib/std/living/skills.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/living/nationality.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/living/nationality.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628900   Available: 13576254
Inodes: Total: 5242880    Free: 4960135
3404 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/living/nationality.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628900   Available: 13576254
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * The details for handling nationality.
 * @author Pinkfish
 * @started Wed Jun 26 13:22:26 PDT 2002
 */
#include <living.h>
#include <config.h>

private class living_nationality _nationality_data;

/**
 * This method returns the nationality of the living.
 * @return the nationality of the living object
 */
string query_nationality() {
   if (_nationality_data && _nationality_data->nationality) {
      return _nationality_data->nationality;
   }
   return 0;
}

/**
 * This method returns the nationality region of the living.
 * @return the nationality region of the living object
 */
string query_nationality_region() {
   if (_nationality_data && _nationality_data->region) {
      return _nationality_data->region;
   }
   return 0;
}

/**
 * This method returns the nationality data of the living.  The
 * data is any free form data needed by the nationality.
 * @return the nationality data of the living object
 */
mixed query_nationality_data() {
   if (_nationality_data && _nationality_data->data) {
      return _nationality_data->data;
   }
   return 0;
}

/**
 * This method sets the nationality of the living.
 * @param nationaltiy the new nationality
 *
 * @see setup_nationality
 */
void set_nationality(string nationality) {
   if (!_nationality_data) {
      _nationality_data = new(class living_nationality);
   }
   _nationality_data->nationality = nationality;
}

/**
 * This method sets the nationality region of the person.
 * @param region the new region of the person
 *
 * @see setup_nationality
 */
void set_nationality_region(string region) {
   if (!_nationality_data) {
      _nationality_data = new(class living_nationality);
   }
   _nationality_data->region = region;
}

/**
 * This method sets the nationality data of the person.  The
 * data is any extre free form data needed by the nationality.
 *
 * @param data the new data for the living
 */
void set_nationality_data(mixed data) {
   if (!_nationality_data) {
      _nationality_data = new(class living_nationality);
   }
   _nationality_data->data = data;
}

/**
 * This method returns the name of the nationality.
 *
 * @return the name of the nationality
 */
string query_nationality_name() {
   if (_nationality_data && _nationality_data->nationality) {
      return _nationality_data->nationality->query_name();
   }
   return 0;
}

/**
 * This method returns the description of the nationality.
 * @param looker the person looking at the them
 * @return the name of the nationality
 */
string query_nationality_description(object looker) {
   if (_nationality_data && _nationality_data->nationality) {
      return _nationality_data->nationality->query_look_description(this_object(), looker);
   }
   return 0;
}

/**
 * This method returns the accent to use for this nationality/region
 * setup on the player.
 * @return the accent object to use
 */
string query_nationality_accent_ob() {
   if (_nationality_data && _nationality_data->nationality) {
      return _nationality_data->nationality->query_region_accent_ob(_nationality_data->region);
   }
}

/**
 * This method returns the start location for this player/npc.
 * @return the start location
 */
string query_nationality_start_location() {
   if (_nationality_data && _nationality_data->nationality) {
      return _nationality_data->nationality->query_start_location(_nationality_data->region);
   }
   return CONFIG_START_LOCATION;
}
// --- END [/mnt/home2/grok/lib/std/living/nationality.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/living/holding.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/living/holding.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628899   Available: 13576253
Inodes: Total: 5242880    Free: 4960135
8083 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/living/holding.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628899   Available: 13576253
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * New holding code!
 * Because the old stuff wasn't OO enough for me.
 * @author Pinkfish
 * @changes See the RCS log, but this change is made by Terano
 *
 * This has the controlling code for holding/wielding objects
 */

/**
 * This stuff is setup by other parts of /std/living, and can't be
 * changed.
 */
nosave mixed *_using;
nosave mixed *_weapons;

//This is somewhat strangely named, it is actually an int that is 1 on
//success and 0 on fail.

#define START_VALUE "1"

/**
 * We have to keep the interfaces the same so has to not break things
 */
int *set_hold(object ob, int location, int limbs);
int *set_unhold(object ob);
private int sub_hold(object ob, int pos, int first);

/**
 * @ignore
 */
void create()
{
   _weapons = ({ });
}

/**
 * This method returns the an array of the names of the limbs 
 * on the living object.
 * @return an array of limbs
 */
string *query_limbs()
{
   //Be type safe!
   string race_ob;
   string *limbs;

   race_ob = this_object()->query_race_ob();

   if (!race_ob) {
      _using = ({ });
      return ({ });
   }
   limbs = race_ob->query_limbs();

   if (!_using) {
      _using = allocate(sizeof(limbs));
   }
   return limbs;
}

string* query_using_array() {
   return copy(_using);
} /* query_using_array() */


/**
 * This method returns the current holding array of the living object.
 * This has one element in the array for each object and a 0 is in the
 * array if that limb is not holding anything.  The positions correspond
 * to the positions returned by the query_limbs() function.
 * @return an array of held objects
 * @see query_holding()
 * @see query_free_limbs()
 * @see query_weapons()
 */
object *query_holding()
{
   if (!arrayp(_using)) {
      //Generate a using array
      query_limbs();
   }
   _using =
      map(_using, (: $1 ? (environment($1) == this_object()? $1 : 0) : 0 :));
   return copy(_using);
}                               /* query_holding() */

/**
 * This method returns the list of limbs the object is being held in.
 * @param ob the object to check the limbs for
 * @return the limbs it is held in
 */
string* query_holding_limbs(object ob) {
   string* ret;
   int i;
   object* holding;
   string* limbs;

   ret = ({ });
   holding = query_holding();
   limbs = query_limbs();
   for (i = 0; i < sizeof(holding); i++) {
      if (holding[i] == ob) {
         ret += ({ limbs[i] });
      }
   }
   return ret;
}

/**
 * This method returns the number of free limbs on the living object.
 * A free limb!  Yes, have a couple of free legs, beat the rush!
 * Buy now!
 * @return the number of free limbs
 * @see query_holding()
 * @see query_limbs()
 */
int query_free_limbs()
{
   if (!arrayp(_using)) {
      query_limbs();
   }
   return
      sizeof(filter(_using, (: !$1 || environment($1) != this_object() :)));
}


/**
 * This method returns the currently held weapons on the living object.
 * This is an array of held items which are weapons and can be used
 * in combat.
 * @return the array of held weapons
 * @see query_holding()
 */
object *query_weapons()
{
// I don't quite understand the bit after the ||
// Also, it runtimes if $1 is 0  --Presto
//   return filter(_weapons, (: $1 || environment($1) != this_object() :));
   return filter(_weapons, (: $1 :));
}

/**
 * This method sets the object as unheld.  It will attempt to remove
 * the object from a held limb.
 * <p>
 * The return array contains the index of the limbs from which the
 * item was removed, if the array is 0 size then no items were
 * removed.
 * @param ob the object to unhold
 * @return a array of limb numbers
 * @see set_hold()
 * @see query_limbs()
 */
int *set_unhold(object ob)
{
   int *pos;

   if (!objectp(ob)) {
      return ({ });
   }
   if (member_array(ob, _using) == -1) {
      return ({ });
   }

   if (!ob->set_holder(0)) {
      return ({ });
   }

   pos = find_member(ob, _using);

   if (ob->query_weapon()) {
      _weapons = filter(_weapons, (: $1 != $(ob) :));
   }

   if (ob->query_armour()) {
      this_object()->remove_armour(ob);
   }

   _using = map(_using, (: $1 == $(ob) ? 0 : $1 :));

   this_object()->do_burden_call();
   return pos;
}

/**
 * This method sets the object as held.  It will attempt to hold it starting
 * at the given position in the limbs array.
 * <p>
 * The return array contains the index of the limbs from which the
 * item was added, if the array is 0 size then no items were
 * added.
 * @param ob the object to hold
 * @param pos the position in the limb array to start holding at
 * @param limbs the number of limbs to be used (1 or 2 usually). leave as
 * zero for default.
 * @return a array of limb numbers
 * @see set_unhold()
 * @see query_limbs()
 *
 * Editors Note: I have changed set_hold so that it no longer 
 * automatically unholds objects. I am moving that functionality to the
 * hold command. If you want your objects to be in a specific limb,
 * you have to free it up yourself using set_unhold.
 * If you don't care which limbs, you just have to free up enough limbs
 * to hold it.
 */
int *set_hold(object ob, int pos, int limbs)
{

   int limb_count;
   int *free = ({ });
   int *used = ({ });
   int total = 0;
   int temp = 0;
   int ok;
   int failed;

   if (environment(ob) != this_object()) {
      debug_printf("Bad environment");
      return ({ });
   }

   limb_count = sizeof(this_player()->query_limbs());
   if (!arrayp(_using)) {
      query_limbs();
   }

   /** 
    * Find out if we have enough free arms.. if not scream and die.
    *  I want to do it this way, because the hold command should
    * be responsable for freeing limbs.. not us.
    */

   //We are trying any and all limbs.
   if (pos == -1) {
      total = ob->query_no_limbs();
      if (total > this_object()->query_free_limbs()) {
         debug_printf("Too many limbs");
         return ({ });
      }
      //Find out which limbs are free
      free = find_member(0, _using);

      if (!sizeof (free)) {
        return ({ });
      }
      // Start with the first one and do the normal hold attempts.      
      pos = free[0];
   }
   //It wants a specific position - is it free?
   if (objectp(_using[pos]) && environment(_using[pos]) == this_object()) {
      //Nope! Remember, only you can make sure your limbs are free before
      //using them!
      return ({ });
   }
   //Set the first one that they asked for, guess the rest ourselves.
   ok = sub_hold(ob, pos, 1);

   if (ok) {
      used += ({ pos });
   } else {
      return ({ });
   }

   //Initialise our 'guessing' variables.
   //Get all free limbs and note the used limb.
   if(limbs)
     total = limbs - 1;
   else
     total = ob->query_no_limbs() - 1;

   free = find_member(0, _using);
   temp = 0;

   while (temp < total && temp < sizeof(free)) {
      //Oops, we've run out of limbs!
      if (temp > limb_count) {
         set_unhold(ob);
         return ({ });
      }

      sub_hold(ob, free[temp], 0);
      if (ok) {
         used += ({ free[temp] });
         temp++;
      } else {
         failed = 1;
      }
   }

   if (failed) {
      set_unhold(ob);
      return ({ });
   } else {
     this_object()->do_burden_call();
      return used;
   }
}

/**
 * Does a lot of the grunt work in holding, does all the validation
 * for each limb for starters. More stuff might come later!
 * Tannah - you can mask this if you want.
 * Terano.
 */
private int sub_hold(object ob,
                     int pos,
                     int first)
{
   int success;

   // Must be in our inventory to hold it.
   if (environment(ob) != this_object()) {
      return 0;
   }
   //If failed_mess = 1 [note that this means that we haven't failed yet]
   //and if we haven't held it yet. [If failed mess is one and there is no 
   //holder, we haven't tried yet.]
   if (first) {
      success = ob->set_holder(this_object(), pos);
      if (!success) {
         return 0;
      }
   }
   _using[pos] = ob;

   if (ob->query_weapon()) {
      if (member_array(ob, _weapons) == -1) {
         _weapons += ({ ob });
      }
   }
   return 1;
}
// --- END [/mnt/home2/grok/lib/std/living/holding.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/living/response_mon.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/living/response_mon.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628897   Available: 13576251
Inodes: Total: 5242880    Free: 4960135
19473 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/living/response_mon.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628897   Available: 13576251
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: response_mon.c,v 1.31 2003/04/01 21:39:38 ceres Exp $
 *
*/
/**
 * This file contains the methods to make the npcs in game respond
 * to soul and says.  Allows for a level of npc interation.
 * <p>
 * Code originaly by nimmox@igor.  Modified for discworld by Pinkfish.
 * <p>
 * @change Olorin Sep 97
 * event_soul does a convert_message on the mess first,
 * to avoid spurious matches caused by a message like eg.
 * "$the_short:/global/lord#64387$ $V$0=smiles,smile$V$ .... in souln
 * @change who knows when
 * changed to stop the responses when the npc is in /room/rubbish
 * @author Pinkfish
 * @see /obj/monster.c
 */
#include <soul.h>
#include <language.h>

#define SPECIAL_DAY "/obj/handlers/special_day"

class response_data {
   object last_ob;
   string last_mess;
   int stop_responding;
   int use_regexp;
   int last_count;
   int last_time;
   int understand_anything;
   object* only_respond_to;
}

mixed *_respond_to_with;
nosave class response_data _response_data;

int match(string str, mixed str2);
void event_soul(object per, string mess, object *avoid, string verb,
                string last, mixed at) ;

void create() {
  _respond_to_with = ({ });
  _response_data = new(class response_data);
  _response_data->only_respond_to = ({ });
} /* create() */

/**
 * This method sets or clears the flag that allows the npc to understand
 * any language at all.  THis is useful for those times when you need an
 * npc that speaks/understands any language.
 * @param flag the new value of the flag
 */
void set_response_mon_understand_anything(int flag) {
   _response_data->understand_anything = flag;
}


/**
 * This method sets or clears the flag to use regular expressions instead of
 * the traditional arrays of words.  In addition, this flag inhibits
 * the usual stripping of non-alphanumerics from the input strings.
 * @param flag the new value of the flag: 1 says to use regular expressions,
 * 0 to not use them
 */
void set_response_mon_regexp(int flag) { _response_data->use_regexp = flag; }

/**
 * This method returns the current state of the flag that indicates whether
 * to use regular expressions instead of the traditional array of words.
 * @return 1 if using regular expressions, 0 if not
 */
int query_response_mon_regexp() { return _response_data->use_regexp; }

/**
 * This method checks to see if the response monster code is in
 * debug mode.
 * @return 1 if in debug mode, 0 if not
 * @see set_response_mon_debug_mode()
 */
int query_response_mon_debug_mode() {
  return this_object()->query_property("respon mon debug");
} /* query_response_mon_debug_mode() */

/**
 * This method sets the current debug flag for the response monster
 * code.
 * @param flag the new value of the flag, 1 on, 0 off
 * @see query_response_mon_debug_mode()
 */
void set_response_mon_debug_mode(int flag) {
  this_object()->add_property("respon mon debug", flag);
} /* set_response_mon_debug_mode() */

/**
 * This method allows the toggling of the responses of the npc.
 * If this is set to 1, then the npc will stop responding to
 * messages.
 * @param i 1 to make the npc not respond, 0 to make it respond again
 * @see query_stop_responding()
 */
void set_stop_responding(int i) { _response_data->stop_responding = i; }
/**
 * This method returns the flag determining the toggling of the responses
 * of the npc.
 * If this is set to 1, then the npc will stop responding to
 * messages.
 * @return 1 to the npc will not respond, 0 it is responding
 * @see query_stop_responding()
 */
int query_stop_responding() { return _response_data->stop_responding; }

/**
 * This method checks to see if the response is allowed for this object.
 * NB: objects to which this_object is not visible are disallowed.
 * @param ob the object to check
 * @param response the response that is matched
 * @return 1 if the object is allowed, 0 if it is not
 */
int query_response_allowed(object ob,
                           string *response) {
  if (!this_object()->query_visible(ob)) {
    return 0;
  }
  return 1;
} /* query_response_allowed() */

/**
 * This method sets the current responses for the npc.
 * This will overwrite the current responses in the npc.
 * Please use add_respond_to_with in your NPC's instead of this function
 * call, as it requires prior knowledge as to the internal structure of
 * the respond_to_with code that add_respond_to_with handles nicely.
 * The array is of the formant:<pre>
 *   ({
 *      trigger1,
 *      response1,
 *      trigger2,
 *      response2,
 *      ...
 *    })
 * </pre>
 * @see add_respond_to_with()
 * @see query_respond_to_with()
 */
void set_respond_to_with( mixed map ) {
  mixed *old_keys;
  int i;

  if ( mapp( map ) ) {
#ifdef DEBUG
    log_file("BAD_RESPONSE", "set_respond_to_with() called by %O (%s)\n",
             previous_object(), previous_object()->query_name());
#endif    
    old_keys = keys(map);
    _respond_to_with = allocate(sizeof(old_keys) * 2);
    for (i = sizeof(old_keys); i--; ) {
      _respond_to_with[2*i] = old_keys[i];
      _respond_to_with[2*i+1] = map[old_keys[i]];
    }
    return;
  }
  _respond_to_with = map;
} /* set_respond_to_with() */

/**
 * This method returns the current responding to with array.
 * The array is of the formant:<pre>
 *   ({
 *      trigger1,
 *      response1,
 *      trigger2,
 *      response2,
 *      ...
 *    })
 * </pre>
 * @see add_respond_to_with()
 */
mixed *query_respond_to_with() { return _respond_to_with; }

/**
 * This method adds a respond message to respond to into the
 * current array of responses.
 * <p>
 * If response_mon_regexp is not set, the trigger consists of an
 * array of words to be matched
 * (in order) in the string.  If there is an array instead of
 * a single word at one point then any of the words in the
 * array will be matched.  If response_mon_regexp is set, the
 * trigger is a single string, representing the regular expression
 * to be matched in the string.
 * <p>
 * The response is either an array of things to execute
 * (in which case a random one will be chosen each time) or
 * a function pointer or a string.  If it is a string then
 * the command of that name will be executed, if the
 * string starts with a '#' then the function named after that
 * will be called on the npc.  That was exciting wasn't it?
 * If the string has a $hname$ name in it and it is not a
 * function call (starts with a #) then the $hname$ will be replaced
 * with the name of the triggering object. $hcname$ or $short$ will be
 * replaced with the short of the triggering object.
 * <p>
 * In the case of a function call, two arguments are passed into
 * the function: the first is the person which triggered the effect
 * and the second in the message which triggered the effect.
 * <p>
 * NOTE: The NPC must explicitly know the language being spoken, even
 * if it's "common".  I don't know why.  That's just the way it is.  See
 * add_language().
 * @example
 * // Simple response
 * add_respond_to_with(({ "@say", "bing" }), "'Yes!  Bing bing bing!");
 * @example
 * // respond to someone saying 'frog' or 'toad'
 * add_respond_to_with(({ "@say", ({ "frog", "toad" }) }),
 *                     "'Frogs and toads are nice.");
 * @example
 * // Randomly say something or bing back at them
 * add_respond_to_with(({ "@say", "bing" }),
 *                     ({ "'Yes!  Bing bing bing!", "bing $hname$" }));
 * @example
 * // Call the function 'rabbit' on the npc.
 * add_respond_to_with(({ "@say", "bing" }), "#rabbit");
 * @example
 * // Do something cute with a function pointer
 * add_respond_to_with(({ "@bing" }),
 *                  (: do_command("'something wild for " + $1->a_short()) :));
 * @param trigger the trigger to trigger the action on
 * @param response the response to the action
 * @see query_respond_to_with()
 * @see query_response_allowed()
 * @see set_response_mon_regexp()
 * @see query_response_mon_regexp()
 * @see regexp()
 * @see add_language()
 */
void add_respond_to_with( mixed *trigger, mixed response ) {
  _respond_to_with += ({ trigger, response });
} /* add_response() */

/**
 * This adds an object into the list of objects that we will only respond
 * to.  If this array is empty then we will respond to anyone, if it has
 * something in it then we will only respond to them.
 * @param person the person to add to the response array
 */
void add_only_respond_to(object person) {
  _response_data->only_respond_to += ({ person });
} /* add_only_respond_to() */

/**
 * This method removes an object from the list of people to respond to.
 * @param person the person to remove
 */
void remove_only_respond_to(object person) {
   _response_data->only_respond_to -= ({ person });
} /* remove_only_respond_to() */

/**
 * This method returns the current list of people we are only responding
 * to.
 * @return the array of people we are responding to
 */
object* query_only_respond_to() {
   return _response_data->only_respond_to;
} /* query_only_respond_to() */

/* Check_sub_sequence checks whether the array (words) contains a subsequence
   as specified in the respond_to_with array */
/**
 * This method checks the subsequence of words to see if it matches
 * any of our current response sets.
 * @param words the words which are to be tested
 * @return the response to be executed
 * @see add_respond_to_with()
 */
protected mixed *check_sub_sequence( mixed *words ) {
  int word_index;
  int format_index; /* what do you know....Meaningful names :-) */
  int format_size;
  int word_size;
  int match_counter;
  int cu_format_size;
  string word_str;
  mixed data;
  string *patterns;
  string pattern;
  string extra;

  format_index = 0;
  word_size = sizeof( words );
  word_str = implode(words, " ");
  format_size = sizeof( _respond_to_with );
  while (format_index < format_size) {
    if ( _response_data->use_regexp ) {
        data = _respond_to_with[ format_index ];

        if ( arrayp( data ) && sizeof( data ) > 1 ) {
            // Excellent. Now, let's add our @say data to the front of
            // the pattern.

            if ( arrayp( data[0] ) ) {
                // Combine the first part into the array, separated
                // by or's, with at least one match.
                extra = "(" + implode( data, "|" ) + ")+";
            }
            else {
                extra = data[0];
            }

            patterns = map( data[1], (: $(extra) + " " + $1 :) );
        }
        else {
            patterns = ({ data });
        }

        //tell_creator( "taffyd", "%O, %O\n", word_str, patterns );

        // Check all of the possible responses.
        foreach( pattern in patterns ) {
            // tell_creator( "taffyd", "%O\n", pattern );
            if ( regexp( word_str, pattern ) ) {
                return _respond_to_with[ format_index + 1 ];
            }
        }
    }
    else {
        word_index = 0;
        match_counter = 0;
        cu_format_size = sizeof(_respond_to_with[format_index]);
        while ((word_index < word_size) && (match_counter < cu_format_size)) {
          match_counter += match(words[word_index],
                                 _respond_to_with[format_index][match_counter]);
          word_index++;
        }
        if (match_counter == (cu_format_size)) {
          return _respond_to_with[format_index + 1];
        }
    }

    format_index += 2;
  }
  return 0;
} /* check_sub_sequence() */

/* match returns 1 if str matches the format.... see also the definitions in
   the example file... */
/** @ignore yes */
protected int match(string str, mixed format) {
  if (pointerp(format)) {
    return (member_array(str, format) != -1);
  }
  if (str == format) {
    return 1;
  }
  return 0;
} /* match() */

/* removing annoying readmarks....  Like .'s and ?'s */
/**
 * This method removes annoying read marks to make the string easier to
 * parse.  Basically it strips puncutation.
 * @param str the string to remove the punctuation from
 * @return the string without any punctuation
 */
protected string remove_read_marks(string str) {
  int blij;
  string result;
  int size;
  string temp;

  size = strlen(str);
  blij = 0;
  result = "";
  while (blij < size) {
    temp = str[blij..blij];
    if (((temp >= "a") && (temp <= "z")) ||
        ((temp >= "0") && (temp <= "9")) ||
        (temp == " ")) {
      result += temp;
    } else {
      result += " ";
    }
    blij++;
  }
  return result;
} /* remove_read_marks() */

/**
 * This method runs the command passed in, doing some substitution.
 * @param str the string to execute
 * @param per the person who triggered the command
 */
protected void senddstr(string str, object per) {
  if ( environment( this_object() ) ) {
    if ( per ) {
      command(replace(str, ({ "$hname$", per->query_name(), "$hcname$",
                                per->query_short(),
                              "$hshort$", per->query_short() })));
    } else {
      command( str );
    }
  }
} /* sendstr() */

/* Take care not to send to other monsters.... Infinite recursion problem...*/

/* Imagine two monsters chatting with each other......*/
/**
 * This method executes the response to the matched string.
 * @param rep the response to execute
 * @param per the person who initiated the event
 * @param mess the message that was matched
 * @see add_respond_to_with()
 */
protected void exec_response(mixed rep, object per, string mess) {
  string *rabbit;

  if (pointerp(rep)) {
    return exec_response(rep[random(sizeof(rep))], per, mess);
  }

  if (functionp(rep)) {
    evaluate(rep, per, mess);
  } else if (stringp(rep)) {
    if (rep[0..0] == "#") {
      rabbit = explode(rep[1..], "#");
      if (sizeof(rabbit) > 1) {
        call_out((: call_other($1, $2, $3, $4) :), 0,
                 rabbit[0], rabbit[1], per, mess);
      } else {
        call_out(rabbit[0], 0, per, mess);
      }
    } else {
      call_out("senddstr", 0, rep, per);
    }
  }
} /* exec_response() */

/** @ignore yes */
private void do_delay_thingy(string *extra, string mess, object per) {
  mixed *response;

  // It does lower case stuff sin...
  mess = lower_case(mess);
  if (!_response_data->use_regexp) {
    mess = remove_read_marks(mess);
  }
  if (query_response_mon_debug_mode()) {
    tell_object(per, "Parsing the text: " + implode(extra, " ") + " " + mess + "\n");
  }
  response = check_sub_sequence(extra + explode(mess, " "));
  if (query_response_mon_debug_mode()) {
    tell_object(per, sprintf("Responding with %O\n", response));
  }

  if (response) {
    if (query_response_allowed(per, response)) {
      exec_response(response, per, mess);
    }
  }
} /* do_delay_thingy() */

/** @ignore yes
 * Some new loop detection. Track the last object, message we responded
 * to and when. Don't respond to the same object & message more than twice in
 * a suitable period.
 * Clearly this won't detect three-way, or other complex, loops.
 */
int check_loop(object per, string mess) {

  // We'll assume players can't get into loops. :)
  if(interactive(per)) {
    return 0;
  }

  if (_response_data->last_ob == per &&
      (_response_data->last_mess = mess) &&
      _response_data->last_time > time() - 10)
  {
    if(_response_data->last_count > 1) {
      return 1;
    } else {
      _response_data->last_count++;
    }
    _response_data->last_time = time();
  } else {
    _response_data->last_ob = per;
    _response_data->last_mess = mess;
    _response_data->last_count = 1;
    _response_data->last_time = time();
  }

  return 0;
}

/** @ignore yes */
private void do_response(string *extra, string mess, object per) {
  if (sizeof(_response_data->only_respond_to)) {
     _response_data->only_respond_to -= ({ 0 });
     if (sizeof(_response_data->only_respond_to) &&
         member_array(per, _response_data->only_respond_to) == -1) {
        return ;
     }
  }
  call_out((: do_delay_thingy($1, $2, $3) :), 2, extra, mess, per);
} /* do_response() */

/*
 * respond as defined in respond_to_with array...See also
 * the definitions in the example monster
 */

/**
 * This method is called on the npcs to help in recognising saytos.
 * Beware...  A @say message will also be added, so you need to make sure
 * you respond to the correct message and not to both.
 */
void event_person_sayto(object per, string mess, string lang, object* targets) {
  string skill;

  if(_response_data->stop_responding ||
     !sizeof(_respond_to_with) ||
     environment() == find_object( "/room/rubbish" ) ||
     environment() == find_object( "/room/void" ) ||
     !per || per == this_object()) {
    return ;
  }

  if(check_loop(per, mess)) {
    return;
  }

  skill = LANGUAGES->query_language_spoken_skill(lang);
  if (this_object()->query_skill(skill) < 90 ||
      per->query_skill(skill) < 60) {
    return;
  }

  do_response(({ "@sayto" }), mess, per);
} /* event_person_say() */

/** @ignore yes */
void event_person_say(object per, string start, string mess, string lang) {
  string skill;

  if(_response_data->stop_responding ||
     !sizeof(_respond_to_with) ||
     environment() == find_object( "/room/rubbish" ) ||
     environment() == find_object( "/room/void" ) ||
     !per || per == this_object()) {
    return ;
  }

  if(check_loop(per, mess))
    return;

  if (!_response_data->understand_anything) {
     skill = LANGUAGES->query_language_spoken_skill(lang);
     if (this_object()->query_skill(skill) < 90 ||
         per->query_skill(skill) < 60) {
       return;
     }
  }

  do_response(({ "@say" }), mess, per);
} /* event_person_say() */

/** @ignore yes */
varargs void event_soul(object per, string mess, object *avoid, string verb,
                        string last, mixed at) {
  if (per == find_object(SOUL_OBJECT))
    per = previous_object(2);

  if(!interactive(per) ||
     _response_data->stop_responding ||
     environment() == find_object( "/room/rubbish" ) ||
     environment() == find_object( "/room/void" ) ||
      member_array(this_object(), avoid) != -1 ||
     !sizeof(_respond_to_with)) {
    return ;
  }

  if((!objectp(at) || (objectp(at) && at != this_object())) &&
     environment(per) != environment() ) {
    return;
  }

  mess = this_object()->convert_message( mess );

  if(check_loop(per, mess))
    return;
  if (objectp(at)) {
    do_response(({ "@" + verb, "#" + last, at->query_name() }), mess, per);
  } else {
    do_response(({ "@" + verb, "#" + last }), mess, per);
  }
} /* event_soul() */

/** @ignore yes */
varargs void event_whisper(object per, string mess, object *obs, string lang,
                           object me) {
  string skill;
  
  if (!interactive(per) || _response_data->stop_responding ||
      environment() == find_object( "/room/rubbish" ) ||
      !sizeof(_respond_to_with)) {
    return ;
  }

  if(check_loop(per, mess)) {
    return;
  }

  if (!_response_data->understand_anything) {
    skill = LANGUAGES->query_language_spoken_skill(lang);
    if (this_object()->query_skill(skill) < 90 ||
        per->query_skill(skill) < 60) {
      return;
    }
  }

  // Don't let them see the message unless it is actually directed at them.
  if (member_array(this_object(), obs) == -1) {
    do_response(({ "@whisper", map(obs, (: $1->query_name() :)) }),
                "", per);
  } else {
    mess = this_object()->convert_message( mess );
    do_response(({ "@whisper", map(obs, (: $1->query_name() :)) }),
                mess, per);
  }
}
// --- END [/mnt/home2/grok/lib/std/living/response_mon.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/living/health.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/living/health.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628892   Available: 13576246
Inodes: Total: 5242880    Free: 4960135
11310 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/living/health.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628892   Available: 13576246
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: health.c,v 1.41 2003/05/13 20:21:07 ceres Exp $
 */
#include <drinks.h>
#include <living.h>

#undef POINTS_LOG
#ifdef USE_SURRENDER
#define SURRENDER_SHADOW "/std/shadows/misc/surrender_shadow"
#endif

varargs int adjust_xp( int number, int shared );

int hp, max_hp, gp, max_gp, xp, wimpy, *drink_info;
#ifdef USE_SURENDER
int surrender;
#endif
nosave int max;
nosave int* runaway_callout_handles;
nosave string which;
nosave mapping counts;
mapping verbs;
nosave int callingdeath;

void create() {
   max_hp = 1;
   max_gp = 1;
#ifdef USE_SURRENDER
   surrender = -1;
#endif   
   drink_info = allocate( D_SIZEOF );
   counts = ([ ]);
   verbs = ([ ]);
   callingdeath = 0;
   runaway_callout_handles = ({ });
} /* create() */

int query_hp() { return hp; }
 
varargs int set_hp( int number, object attacker ) {
   if ( number > max_hp )
      number = max_hp;
   hp = number;
   if ( ( hp < 0 ) && ( find_call_out( "do_death" ) == -1 ) )
      call_out( "do_death", 0, attacker );
   return hp;
} /* set_hp() */
 
protected int check_wimpy() {
    int hp;
  
    hp = this_object()->query_hp();
    if ( hp < 1 )
        return 0;
        
    if( 100 * hp < this_object()->query_wimpy() * 
        this_object()->query_max_hp()) {
    
        if(find_call_out("run_away") == -1) {
            // Add the runaway callout handle to our other ones
            runaway_callout_handles += ({ call_out("run_away", 0) });
        }
        return 1;
    }
    return 0;
}

#ifdef USE_SURRENDER
protected int check_surrender() {
   int hp;
   object *attackers, *all, shad;
   
   hp = this_object()->query_hp();
   if (hp < 1)
      return 0;
   
   if (hp * 100 < this_object()->query_surrender() *
       this_object()->query_max_hp()) {
     attackers = filter(this_object()->query_attacker_list(),
                        (: $1 && !$1->query_property("dead") &&
                         environment($1) == environment($2) :),
                        this_object());
     all = attackers + ({ this_object() });
     all->event_surrender(this_object(), attackers);

     shad = clone_object(SURRENDER_SHADOW);
     if (shad) {
       shad->setup_shadow(this_object(), attackers);
     }
     return 1;
   }
   return 0;
}
#endif

/*
 * Resets the flag that prevents the creation of a new do_death
 * callout
 */
void reset_callingdeath() {
  callingdeath = 0;
}

/** 
 * Returns the current value of the callingdeath variable.
 */
int query_callingdeath() { 
    return callingdeath;
} /* query_callingdeath() */ 


varargs int adjust_hp(int number, object attacker, object weapon,
                      string attack) {
    int i;

    hp += number;
    if ( hp > max_hp )
        hp = max_hp;
    if (hp <= 0 && !callingdeath) {
        /* Set the flag so that I won't create another do_death
         * callout, and then create the callout.  I'm expecting
         * do_death to reset this flag.  Not that it should need
         * to, but we want to be clean. */
        callingdeath = time();
        call_out("do_death", 0, attacker, weapon, attack);
        // Get rid of any call_outs to run away
        for( i=0; i<sizeof(runaway_callout_handles); i++ ) {
            remove_call_out( runaway_callout_handles[i] );
        }
        runaway_callout_handles = ({ });
    }

    if (hp > 0 && number < 0 && attacker && attacker != this_object()) {
#ifdef USE_SURRENDER
        if(this_object()->query_surrender() >= this_object()->query_wimpy()) {
            if (!check_surrender())
                check_wimpy();
        }
        else {
            if (!check_wimpy())
                check_surrender();
        }
#else
        check_wimpy();
#endif     
    }
    return hp;
}
 
/* undefinedp() doesn't seem to work on reference arguments.  Have to
   work around. */
varargs string health_string(int flag, int ref health_level) {
   int level;
   string ret;

   if ( this_object()->query_property( "dead" ) )  {
      ret = "appears to be dead";
      level = 0;
   }
   else if ( hp < max_hp / 10 )  {
      ret = "is in very bad shape";
      level = 1;
   }
   else if ( hp < max_hp / 5 )  {
      ret = "is in bad shape";
      level = 2;
   }
   else if ( hp < max_hp / 2 )  {
      ret = "is not in good shape";
      level = 3;
   }
   else if ( hp < ( max_hp - 200 ) )  {
      ret = "is slightly hurt";
      level = 4;
   }
   else  {
      ret = "is in good shape";
      level = 5;
   }
   if (!undefinedp(flag))   health_level = level;
   return ret;
} /* health_string() */
 
int query_max_hp() { return max_hp; }
 
int set_max_hp( int number ) {
  int old_hp;
  old_hp = hp;
  if ( max_hp == hp )
    hp = number;
  else
    if ( max_hp )
      hp = ( hp * number ) / max_hp;
    else
      hp = number;
  max_hp = number;
  if ( hp > max_hp )
    hp = max_hp;
  if ( ( hp < 0 ) && ( old_hp > 0 ) )
    hp = max_hp;
  return max_hp;
} /* set_max_hp() */
 
int query_gp() { return gp; }

int query_specific_gp( string gp_type ) {
   int now;
   if ( !gp_type )
      return 0;
   max = (int)this_object()->query_skill_bonus( gp_type
         +".points" ) + 50;
   if ( max >= max_gp )
      max = max_gp;
   now = gp + max - max_gp;
   which = gp_type;
   if ( find_call_out( "clear_gp_info" ) == -1 )
      call_out( "clear_gp_info", 1 );
   return now;
} /* query_specific_gp() */

void clear_gp_info() { which = 0; }
 
int set_gp( int number ) {
   gp = number;
   if ( gp > max_gp )
      gp = max_gp;
   return gp;
} /* set_gp() */
 
int adjust_gp( int number ) {
  int tmp, diff;
  string guild_ob, current_verb;
  mixed *bits;
  
  if ( gp + number < 0 )
    return -1;
  
  gp += number;
  
  if ( gp > max_gp )
    gp = max_gp;

  tmp = number;

  /* Give people automatic gp advances.
   * which is setup by query_specific_gp.
   * max is their maximum gp.
   *
   * Also, give people XP for using guild commands.
   */
  if((number < 0) && stringp(which)) {
    
    if (number > ( GP_ADVANCE_MOD * max ) / MIN_TIMES)
      number = (GP_ADVANCE_MOD * max) / MIN_TIMES;
    
    counts[ which ] -= number;
    if (counts[ which ] > GP_ADVANCE_MOD * max) {
      counts[ which ] = 0;
      
      // they get a chance of an advance not a guarantee.
      // the use of exp(skill/somevalue) causes a steep growth
      // curve at higher values thus preventing massive levels
      // in .points skills.
      number = this_object()->query_skill(which +".points");
      if(!random(to_int(exp(number/150.0))) &&
         this_object()->add_skill_level( which +".points", 1,
                                         this_object())) {
        tell_object( this_object(), "%^YELLOW%^You find yourself "
                     "more able to concentrate on this task than you "
                     "thought.%^RESET%^\n" );
      }
      
#ifdef POINTS_LOG
      log_file( "POINTS", time() +" "+
                (string)this_object()->query_name() +" gets "+
                which +" ("+ max +")\n" );
#endif
    }
    
    // Give them Xp if they used a guild command.
    number = tmp;
    guild_ob = this_object()->query_guild_ob();
    
    /*
     * If it's one of their guild commands give them 10x the GP.
     * if it's not then give then 4x the GP. Give 6x for cast since
     * 
     */
    if(guild_ob && member_array(query_verb(), guild_ob->query_commands()) != -1)
      number *= -10;
    else
      number *= -4;

    // These use all available GPs so need to give less XP.
    // These use all available GPs so need to give less XP.
    if(query_verb() == "pray" || query_verb() == "berserk" ||
       query_verb() == "spellcheck" || query_verb() == "octograve")
      number /= 2;
    
    // If it's a repeat command and repeated too quickly then
    // or if it's just another command done very quickly (eg. a;b;a;b)
    // we reduce the Xp they get.
    current_verb = query_verb();
    if(current_verb == "cast" || current_verb == "perform") {
      current_verb = this_object()->query_current_cmd();
    }

    if(verbs[current_verb]) {
      bits = verbs[current_verb];
      diff = time() - bits[0];

      // see when they last did this command. If it was more than 5 minutes
      // ago then reduce their count of repeats.
      if(diff > 300)
        bits[1] /= 2;
      if(bits[1] < 1)
        bits[1] = 1;

      if(bits[1] > 1 && bits[2] == environment())
        bits[1] += 1;

      // they're repeating the command so reduce their xp somewhat.
      if(bits[1] < 10)
         number /= (random(bits[1]) + 1);
      else
        number = 0;
      verbs[current_verb] = ({ time(), bits[1]+1, environment() });
    } else {
      verbs[current_verb] = ({ time(), 1, environment() });
    }

    if(number)
      adjust_xp(number, 1);
    
#ifdef GUILD_XP
    log_file("GUILD_XP", "%s Gave %s %d points for %s [%s, %d]\n",
             ctime(time()), this_object()->query_name(), number,
             current_verb, verbs[current_verb][0], verbs[current_verb][1]);
#endif
  }
  return gp;
}

int query_max_gp() { return max_gp; }
 
int set_max_gp( int number ) {
  if ( max_gp ) gp = ( gp * number ) / max_gp;
  else gp = number;
  max_gp = number;
  if ( gp > max_gp ) gp = max_gp;
  return max_gp;
} /* set_max_gp() */
 
int query_xp() { return xp; }

varargs int adjust_xp( int number, int shared ) {
  if(number > 0 && (xp > 10000000 || xp + number > 10000000))
    return xp;
  
  if(number > 10000 && previous_object() &&
     explode(file_name(previous_object()), "/")[0] == "w")
    log_file("/d/admin/log/CHEAT", ctime(time()) + " " +
             file_name(previous_object()) +
             " gave " + number + " Xp for " + this_object()->query_name() +
             "\n");
             
   xp += number;
   return xp;
} /* adjust_xp() */
 
int query_wimpy() { return wimpy < 30 ? wimpy : 30; }
 
int set_wimpy( int number ) {
  if ( ( number < 0 ) || ( number > 30 ) ) return -1;
  return wimpy = number;
} /* set_wimpy() */
 
#ifdef USE_SURRENDER
int query_surrender() {
  if (surrender == -1) {
    if (wimpy > 94)
      return 100;
    else
      return wimpy + 5;
  } else
    return surrender;
}

int set_surrender( int number ) {
  if ( ( number < 0 ) || ( number > 100 ) ) return -1;
  return surrender = number;
} /* set_surrender() */
#endif

int *query_drink_info() { return drink_info; }

int query_volume( int type ) {
  if ( type >= D_SIZEOF ) return 0;
  return drink_info[ type ];
} /* query_volume() */
 
int adjust_volume( int type, int amount ) {
  if ( type >= D_SIZEOF ) return 0;

  return drink_info[ type ] += amount;
} /* adjust_volume() */
 
void update_volumes() {
  int i, delta;
  delta = (int)this_object()->query_con();
  for ( i = 0; i < sizeof( drink_info ); i++ ) {
    if ( drink_info[ i ] > delta ) {
      drink_info[ i ] -= delta;
      // drinking cools you down if you're hot, eating warms you up
      // if you're cold.
      if(this_object()->query_personal_temp() >  0 && i == D_DRINK)
  this_object()->adjust_personal_temp(-(delta/3));
      else if(this_object()->query_personal_temp() <  0 && i == D_FOOD)
  this_object()->adjust_personal_temp(delta/3);
    } else
      if ( drink_info[ i ] < -delta )
        drink_info[ i ] += delta;
      else
        drink_info[ i ] = 0;
  }
} /* update_volumes() */

mapping query_counts() { return counts; }
// --- END [/mnt/home2/grok/lib/std/living/health.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/living/carrying.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/living/carrying.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628889   Available: 13576243
Inodes: Total: 5242880    Free: 4960135
9140 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/living/carrying.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628889   Available: 13576243
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: carrying.c,v 1.17 2003/04/15 20:56:09 ceres Exp $
 * $Log: carrying.c,v $
 * Revision 1.17  2003/04/15 20:56:09  ceres
 * Fixed possible runtime if they have no limbs
 *
 * Revision 1.16  2001/08/10 09:01:15  pinkfish
 * Make it fix all the corpse errors.
 *
 * Revision 1.15  2001/05/23 00:28:12  pinkfish
 * Fix up all the warnings (really).
 *
 * Revision 1.14  2001/05/23 00:16:06  pinkfish
 * Fix up a warning.
 *
 * Revision 1.13  2001/04/20 18:51:00  ceres
 * Fixed runtime if you do an 'i' while logging in
 *
 * Revision 1.12  1999/11/18 09:23:11  pinkfish
 * Fix it up to move the hidden determination code out of the armour_list
 * code.
 *
 * Revision 1.11  1999/10/25 23:09:45  pinkfish
 * Some changes to make dealing with transports a little better.
 *
 * Revision 1.10  1999/07/20 23:44:57  presto
 * Fixed so that when it's dark, when you do an inventory, you get
 * "Your purse is ... " instead of "His/Her purse is ..."
 *
 * Revision 1.9  1999/05/18 22:21:25  taffyd
 * Fixed small bug with light levels doing weird descriptions for players.
 *
 * Revision 1.8  1999/05/18 21:28:06  pinkfish
 *  Forcibly unlocked by rywfol
 *
 * Revision 1.7  1998/08/25 10:09:06  pinkfish
 * Reverse the order of the inventory display.
 *
 * Revision 1.6  1998/07/24 05:04:07  pinkfish
 * Fix this up to work with something I then changed back...
 *
 * Revision 1.5  1998/03/29 16:31:42  pinkfish
 * Revese the order of the inventory stuff.
 *
 * Revision 1.4  1998/03/28 17:37:25  pinkfish
 * Documetnaiotn and changes to support the new clothing handler.
 *
 * Revision 1.3  1998/03/05 11:37:17  pinkfish
 * changed the find_inv_match() call to use all_inventory()
 *
 * Revision 1.2  1998/02/04 02:41:21  presto
 * Fixed problem with getting limb list from race objects
 *
 * Revision 1.1  1998/01/06 04:29:08  ceres
 * Initial revision
 * 
*/
/**
 * This file contains all the code need to handle the types of carrying
 * which npcs tend to involve themselves in.
 * @author Pinkfish
 */
#include <clothing.h>
#include <money.h>

object* query_wearing();

/**
 * This method returns the list of types of things which are passed into
 * the array.
 * <p>
 * Two elements in an array is returned, the first element is the list of
 * all of the different types which are worn and the second is the list
 * of types corresponding to each of the inputs.
 * @param things the things to check
 * @return a two element array
 * @see armour_list()
 */
protected varargs string *query_types_worn( object *things ) {
   int i;
   string *types;
   mixed *stuff;
   
   types = ({ });
   if ( !things ) {
      things = (object *)this_object()->query_wearing();
   }
   stuff = (mixed *)things->query_type();
   for ( i = sizeof( stuff ) - 1; i > -1; i-- ) {
      if ( stringp( stuff[ i ] ) ) {
         stuff[ i ] = ({ stuff[ i ] });
      }
      if ( !pointerp( stuff[ i ] ) ) {
         printf( "%O (%s) has an invalid type.  Please bug report it.\n",
                 things[ i ], (string)things[ i ]->query_short() );
         stuff[ i ] = ({ "broken" });
      }
      types += stuff[ i ];
   }
   return ({ types, stuff });
} /* query_types_worn() */

/**
 * This method returns the items that are hidden by something on top of
 * them.
 * @param looker the person looking at the items
 * @param things an optional set of things
 * @return the hidden worn types
 */
object* query_wearing_hidden(object looker, object *things) {
   mixed* bing;
   string* types;
   mixed* obj_types;
   object* worn;
   object* ret;
   int i;
   int found_under;
   string fluff;
   string under_type;
   string* under;

   if (!things) {
      worn = query_wearing();
   } else {
      worn = things;
   }
   bing = query_types_worn( worn );
   types = bing[0];
   obj_types = bing[1];
   ret = ({ });
   for (i = 0; i < sizeof(worn); i++) {
      if (worn[i]->query_visible(looker)) {
         found_under = 0;
         foreach (fluff in obj_types[i]) {
            under = CLOTHING_HANDLER->query_clothing_hiding( fluff );
            if ( under && sizeof(under)) {
               foreach (under_type in under) {
                  if (member_array(under_type, types) != -1) {
                     ret += ({ worn[i] });
                     found_under = 1;
                     break;
                  }
               }
            }
            if (found_under) {
               break;
            }
         }
      } else {
         ret += ({ worn[i] });
      }
   }
   return ret;
} /* query_wearing_hidden() */

/**
 * This method returns a string list of the armours which the player
 * is wearing.  It will show also modify the list to show only hidden
 * items (items under other items are considered hidden).
 * @param things the things to get the list of armours from
 * @param hidden_only only show the list of hidden objects
 * @see query_types_worn()
 * @see query_living_contents()
 */
protected string armour_list( object *things, int hidden_only, int self) {
   string word;
   object* hidden;

   hidden = query_wearing_hidden( this_player(), things); 
   if (hidden_only) {
      things = filter(hidden, (: $1->query_visible( this_player() ) :));
   } else {
      things = things - hidden;
   }
   if ( !sizeof( things ) ) {
      return 0;
   }
   if (!self) {
      /* Order them in a reasonable way */
      things = sort_array(things,
               (: CLOTHING_HANDLER->query_clothing_depth($2->query_type())  -
                  CLOTHING_HANDLER->query_clothing_depth($1->query_type()) :));
   }
   word = query_multiple_short( things );
   return word;
} /* armour_list() */

/**
 * This method does the inventory of the living objects we all know and
 * love.  It is used in the long description and the inventory commands.
 * @param self are we showing our own inventory
 * @see armour_list()
 * @index inventory
 */
string query_living_contents( int self ) {
   string s;
   string fish;
   string *limbs;
   string *bits;
   string *strs;
   object *holding;
   object *arms;
   object *carry;
   object *conts;
   object money;
   object ob;
   int i;
   int coins;
   int pos;

   s = "";
   strs = ({ });
   conts = ({ });
   limbs = this_object()->query_limbs();
   if (!limbs) {
      limbs = ( this_object()->query_race_ob() )->query_limbs();
   }
   /* I wonder why this uses find_inv_match? */
   conts = filter(all_inventory(), (: $1->short(0) :) );
   //conts = (object *)this_object()->find_inv_match();
   if(!limbs || !sizeof(limbs))
     holding = ({ });
   else
     holding = (object *)this_object()->query_holding() + ({ });
   
   arms = (object *)this_object()->query_armours() - holding;
   money = present(MONEY_ALIAS, this_object());
   if(!arms) {
      arms = ({ });
   }
   carry = conts - arms - holding - ({ money });
   for (i = 0; i < sizeof(holding); i++) {
     if (holding[i] && environment(holding[i]) == this_object()) {
       bits = ({ limbs[i] });
       ob = holding[i];
       holding[i] = 0;
       while ((pos = member_array(ob, holding)) != -1) {
         bits += ({ limbs[pos] });
         holding[pos] = 0;
       }
       strs += ({  ob->a_short() + " (" +
                     query_multiple_short(bits, "a", 1)+")" });
     }
   }
   if (sizeof(strs)) {
      s += "$I$+10,+0=%^RED%^Holding%^RESET%^ : " + 
         query_multiple_short( strs ) +
         ".\n$I$-10,-0=";
   }
   if ( sizeof( arms ) ) {
      if ( fish = armour_list( arms, 0, self) ) {
         s += "$I$+10,+0=%^YELLOW%^Wearing%^RESET%^ : " + fish + 
            ".\n$I$-10,-0=";
      }
      if ( self && (fish = armour_list(arms, 1, self) ) ) {
         s += "$I$+10,+0=%^YELLOW%^(under)%^RESET%^ : " + fish + 
            ".\n$I$-10,-0=";
      }
   }
   if ( sizeof( carry ) ) {
      fish = this_object()->query_contents(0, carry, 1);
      if ( fish ) {
         if (pointerp(fish)) {
            s += "$I$+10,+0=%^GREEN%^" + fish[1] + "%^RESET%^: " + fish[0] +
               "$I$-10,-0=";
         } else {
            s += "$I$+10,+0=%^GREEN%^Carrying%^RESET%^: " + fish +
               "$I$-10,-0=";
         }
      }
   }
   if ( self && environment() &&
        this_object()->check_dark(environment()->query_light()) > -1) {
      if ( money ) {
         fish = query_multiple_short( (string *)money->half_short( 1 ) );
      } else {
         fish = 0;
      }
      if ( s == "" ) {
         s = "You are empty handed.\n";
      }
      s += "Your purse contains " + (fish?fish:"only moths") + ".\n";
   } else if(money) {
      coins = (int)money->query_number_coins();    
      if (self) {
         s += "Your purse is ";
      } else {
         s += capitalize( (string)this_object()->query_possessive() ) +
              " purse is ";
      }
      switch(coins) {
      case 0..10:    
         s += "home to only moths!\n"; 
         break;
      case 11..100:  
         s += "tinkling with coins.\n"; 
         break;
      case 101..300: 
         s += "bulging with coins.\n"; 
         break;
      default:       
         s += "fit to burst!\n";
         break;
      }
   }
   return s;
} /* query_living_contents() */
// --- END [/mnt/home2/grok/lib/std/living/carrying.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/living/combat.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/living/combat.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628887   Available: 13576241
Inodes: Total: 5242880    Free: 4960135
109423 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/living/combat.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628887   Available: 13576241
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This file contains all the methods and fun things actually run combat.
 * @author Ceres
 *
 *
 * TODO: Add offensive & defensive criticals -- broken limbs etc.
 *
 */
inherit "/std/living/corpse";
inherit "/std/weapon_logic";

#include <attack_messages.h>
#include <tasks.h>
#include <player.h>
#include <living.h>
#include <weapon.h>
#ifdef COMBAT_SPEED
#undef COMBAT_SPEED
#endif
#include <combat.h>

#ifdef ABS
#undef ABS
#endif
#define ABS(n) (n) < 0 ? -(n) : (n)

// 2 == verbose, 1 == brief, 0 == none.
#define DEBUG 1
#undef USE_SURRENDER

class tactics _tactics;

#ifdef USE_SURRENDER
class surrender_information _surrender;
#endif

nosave class combat_information _combat;
nosave string tmpzone; // needed for function pointer.
nosave int _callout;

object *query_attacker_list();
void stop_all_fight();
int query_distance(object);
int set_distance(object, int);
void adjust_action_defecit(int amount);
private void init_tactics();
#ifdef USE_SURRENDER
object *query_surrenderers();
#endif

/** @ignore yes */
void create() {
  ::create();

  init_tactics();
  _combat = new(class combat_information,
                in_combat : 0,
                protectors : ({ }),
                defenders : ({ }),
                attacker_list : ([ ]),
                hunting_list : ([ ]),
                specials : ({ })
                );

#ifdef USE_SURRENDER
  _surrender = new(class surrender_information,
                   to : ({ }),
                   from : ({ }),
                   refusers : ({ }));
#endif
}

private void init_tactics() {
  if(!classp(_tactics) || sizeof(_tactics) != 8) {
    _tactics = new(class tactics,
                   attitude : "neutral",
                   response : "neutral",
                   parry : "both",
                   attack : "both",
                   parry_unarmed : 0,
                   mercy : "ask",
                   focus_zone : 0,
                   ideal_distance : 0);
  }
}

#ifdef DEBUG
class combat_information query_combat() { return _combat; }
#ifdef USE_SURRENDER
class surrender_information query_surrender() { return _surrender; }
#endif
#endif

/** @ignore yes */
void combat_debug(string fmt, mixed args ...) {
  if(userp(this_object()))
    this_object()->event_inform(this_object(),
                                sprintf("%s " + fmt,
                                        this_object()->query_name(), args ...),
                                      "combat-debug", this_object());
  event(environment(this_object()), "inform",
        sprintf("%s " + fmt, this_object()->query_name(), args ...),
        "combat-debug", this_object());
}

/**
 * Decide if we will attack this round or not.  This function can be
 * overloaded if necessary. It also checks for the property "cannot attack"
 * on this object. If the property is set the object cannot attack.
 *
 * @return 1 if we want to, 0 if we don't.
 */
int query_can_attack() {
  if(this_object()->query_property(PASSED_OUT) ||
     this_object()->query_property("dead") ||
     this_object()->query_auto_loading() ||
     this_object()->query_hp() < 0 ||
     this_object()->query_casting_spell() ||
     (userp(this_object()) && !interactive(this_object())) ||
     this_object()->query_property("cannot attack"))
    return 0;

  return 1;
}

/**
 * Decide if we are able to defend ourselves this time or not.
 * This function can be overloaded if necessary. It also checks for the
 * property "cannot defend"
 * on this object. If the property is set the object cannot defend.
 *
 * @return 1 if we want to, 0 if we don't.
 */
int query_can_defend() {
  if(this_object()->query_property(PASSED_OUT) ||
     this_object()->query_property("dead") ||
     this_object()->query_auto_loading() ||
     this_object()->query_hp() < 0 ||
     this_object()->query_casting_spell() ||
     (userp(this_object()) && !interactive(this_object())) ||
     this_object()->query_property("cannot defend"))
    return 0;

  return 1;
}

/**
 * Choose an opponent and attack them.
 *
 * This method must fill in the opponent variable. If no opponent is chosen
 * the attack will be aborted.
 *
 * PRE: Attacker information has been filled in.
 * POST: opponent must be chosen or the attack will be aborted.
 *
 * @param class attack
 * @return class attack
 */
protected class attack choose_opponent(class attack att) {
  mixed *opponents, opponent;
  int i;
  
#ifdef USE_DISTANCE
  mixed tmp;
#endif

  // TODO: More advanced opponent selection.
  opponents = map(keys(_combat->attacker_list),
                  (: $1 && objectp($1) ? $1 : find_player($1) :));
  opponents = filter(opponents, (: $1 && environment($1) == environment($2) &&
                                 $1->query_attackable() :), att->attacker);
  
#ifdef USE_SURRENDER
  // Remove surrendered people from the opponent list so we don't kill
  // anyone during the surrender.
  foreach(opponent in query_surrenderers()) {
    if(userp(opponent))
      opponent = opponent->query_name();
    opponents -= ({ opponent });
  }
#endif

  // we pick the closest opponent.
  if(!sizeof(opponents))
    return att;

  // Attack whoever we're concentrating on.
  if(interactive(this_object()) &&
     objectp(att->attacker_concentrating) && 
     member_array(att->attacker_concentrating, opponents) != -1)
    opponent = att->attacker_concentrating;
  else {
#ifdef USE_DISTANCE
    opponent = opponents[0];
    foreach(tmp in opponents)
      if(_combat->attacker_list[tmp] < _combat->attacker_list[opponent])
        opponent = tmp;
#endif

    // Three different NPC algorithms. good_fighter should use better
    // ones.
    switch(random(3)) {
    case 2:
      opponent = opponents[0];
      for(i=0; i<sizeof(opponents); i++)
        if((opponent->query_hp() / 10 + random(100)) >
           (opponents[i]->query_hp() / 10 + random(100)))
          opponent = opponents[i];
      break;
    case 1:
      opponent = opponents[0];
      for(i=0; i<sizeof(opponents); i++)
        if((opponent->query_hp() / 10 + random(100)) <
           (opponents[i]->query_hp() / 10 + random(100)))
          opponent = opponents[i];
      break;
    default:
      opponent = opponents[random(sizeof(opponents))];
    }
  }

#ifdef USE_DISTANCE
  // Set the opponent and distance.
  att->distance = _combat->attacker_list[opponent];
#endif

  if(stringp(opponent))
    att->opponent = find_player(opponent);
  else
    att->opponent = opponent;

  // Just in case they disappeared somehow.
  if(environment(att->opponent) != environment(this_object()))
    return att;

  // Automatically concentrate on someone if they're the only opponent.
  if(sizeof(opponents) == 1)
    _combat->concentrating = att->opponent;

  return att;
}

/** @ignore yes */
void clear_protection(object attacker, object protector) {
  if(attacker->remove_protector(protector))
    protector->event_combat(protector,
                            "You stop protecting "+ attacker->the_short() +
                            " as "+ attacker->query_pronoun() +
                            " moves to attack "+
                            "you!\n", ({ }), 0);
  if(attacker->remove_defender(protector))
    protector->event_combat(protector, "You stop defending "+
                            attacker->the_short() + " as "+
                            attacker->query_pronoun() +" moves to attack "+
                            "you!\n", ({ }), 0);
}

/**
 * This method is used to choose who will defend this attack. Typically this
 * will be the person who was attacked, however it could be someone else in
 * some circumstances.
 *
 * PRE: attacker, attack and defender information has been set.
 * POST: defender and person_hit must be set.
 *
 * @param class attack
 * @return class attack
 */
class attack choose_defender(class attack att) {
  object *protectors, *defenders;

  // If the combat system (or a special) has already chosen a protector
  // we won't override it.
  if(!att->person_hit) {
    // People who will protect (ie. jump infront of an attack)
    protectors = filter((att->opponent)->query_protectors(),
                        (: $1 && environment($1) == environment($2) &&
                         $1->query_protect() && !pk_check($1, $2) :),
                        att->attacker);
    
    if(sizeof(protectors)) {
      protectors->attack_by(att->attacker);
      
      att->person_hit = protectors[random(sizeof(protectors))];
#if DEBUG == 1
      combat_debug("picked %s to protect", (att->person_hit)->query_name());
#endif
    }
  }
  
  // If the combat system (or a special) has already chosen a defender
  // we won't override it.
  if(!att->defender) {
    defenders = filter((att->opponent)->query_defenders(),
                       (: $1 && environment($1) == environment($2) &&
                        !pk_check($1, $2) :), att->attacker);

    // Make sure local defenders join in the fight.
    if(sizeof(defenders)) {
      defenders->attack_by(att->attacker);
      defenders = filter(defenders, (: $1->query_defend() :));
    }

    // See if we have someone to defend.
    if(sizeof(defenders)) {
      att->defender = defenders[random(sizeof(defenders))];
#if DEBUG == 1
      combat_debug("picked %s to defend", (att->defender)->query_name());
#endif
    }
  }
  
  // Do the defaults if we haven't been protected or defended.
  if(!att->person_hit)
    att->person_hit = att->opponent;
  if(!att->defender)
    att->defender = att->opponent;
  
  return att;
}

/**
 * Is this object attackable or not?
 *
 * @return 1 or 0 for true or false.
 */
int query_attackable() {
  if(this_object()->query_property(PASSED_OUT) ||
     this_object()->dont_attack_me() ||
     this_object()->attack_inhibit() ||
     this_object()->query_property("dead") ||
     this_object()->query_auto_loading() ||
     this_object()->query_hp() < 0 ||
     (userp(this_object()) && !interactive(this_object())))
    return 0;
  return 1;
}

/**
 * Is this object prepared to try to defend someone else at this time?
 *
 * @return 1 or 0 for true or false.
 */
int query_defend() {
  if(!query_attackable() || this_object()->query_casting_spell() ||
     this_object()->query_specific_gp("fighting") < 1)
    return 0;
  return ((_tactics->response == "parry" || _tactics->response == "both") &&
          _combat->action_defecit < (COMBAT_ACTION_TIME * 4));
}

/**
 * Is this object prepared to try to protect someone else at this time?
 * @return 1 or 0 for true or false.
 */
int query_protect() {
  if(!query_attackable() || this_object()->query_casting_spell() ||
     this_object()->query_specific_gp("fighting") < 1)
    return 0;
  return (_combat->action_defecit < (COMBAT_ACTION_TIME * 4));
}


/**
 * Determine which attack they'll use.
 *
 * This picks a weapon, gets the attack data and the weapon skill and
 * determines how much the attack will cost.
 *
 * PRE: attacker info, opponent and defender info have been set.
 * POST: attack weapon, attack skill, attack data, and attack_cost must
 * be set.
 *
 * @param class attack
 * @return class attack
 */
protected class attack choose_attack(class attack att) {
  object weapon, *weapons;
  string hand, *tmp;
  int perc, which_attack, i;
  class tactics tactics;
  mixed *attacks;
  string zone;
  float sz;

  tactics = att->attacker_tactics;

  if(!this_object()->query_can_attack())
    return att;

  // Depending on their tactics they will go further into defecit in order
  // to attack.
  if(!OFFENSIVE_DEFECITS[tactics->attitude])
    tactics->attitude = "neutral";

  if(att->attacker_defecit > OFFENSIVE_DEFECITS[tactics->attitude])
    return att;

  weapons = (att->attacker)->query_holding();
  tmp = (att->attacker)->query_limbs();

  // Do they have a preferred attacking hand?
  hand = (att->attacker_tactics)->attack;
  if(hand && hand != "both") {
    for(i=0; i<sizeof(tmp); i++)
      if(tmp[i] == hand + " hand")
        break;
    if(!weapons[i]) // they're going to attack unarmed.
      weapons = ({ });
    else if(weapons[i]->query_weapon()) // they'll attack with the weapon
      weapons = ({ weapons[i] });
  }

  // Make sure we have a unique list of weapons if we're going to have to
  // pick one.
  if(sizeof(weapons) > 1)
    weapons = uniq_array(filter(weapons, (: $1 && $1->query_weapon() :)));
  
  // Pick the attacking weapon from what's left by using the most appropriate
  // for distance.
  switch(sizeof(weapons)) {
  case 0:
    
    weapon = att->attacker;
    break;
  case 1:
    // Tend to attack with the weapon in the left hand.
    weapon = weapons[0];
    break;
  default:
#ifdef USE_DISTANCE
    // Pick the weapon that best fits the combat distance we're at right now.
    weapon = weapons[0];
    foreach(wtmp in weapons)
      if(ABS(REACH + weapon->query_length() - att->distance) >
         ABS(REACH + wtmp->query_length() - att->distance))
        weapon = wtmp;
#else
    weapon = weapons[random(sizeof(weapons))];
#endif
  }

  att->attack_weapon = weapon;

  // Calculate their attack percentage.

  // For the moment I've just given a simple strength bonus so that stronger
  // players hit slightly harder.
  perc = 75 + (att->attacker)->query_str() + (att->attacker)->query_dex();

  // The heavier the weapon the harder it is to hit hard with it.
  if(weapon != att->attacker)
    perc -= weapon->query_weight() / 2;

  if(perc < 25)
    perc = 25;
  
  attacks = weapon->weapon_attacks(perc, att->defender);
  
  if(!sizeof(attacks)) {
#if DEBUG == 2
    combat_debug("No attacks with %O, terminating [%d, %O].", weapon,
                 perc, att->defender);
#endif
    return att;
  }

  // Choose an attack at random from the list of attacks. This should probably
  // be a weighted average (since each attack has a %age chance)
  which_attack = random(sizeof(attacks) / AT_ARRAY_SIZE);
  attacks = attacks[(which_attack * AT_ARRAY_SIZE)..];

  // No free hands? Can't attack with your hands then.
  if(attacks[AT_NAME] == "hands" && !(att->attacker)->query_free_limbs())
    return att;
  
  att->attack_data = attacks;
  att->attack_skill = ATTACK_SKILL + attacks[AT_SKILL];

  // Choose an attack zone. If they've chosen one then they get a -ve modifier
  // If they haven't set a preference then choose one at random.
  if((att->attacker_tactics)->focus_zone == "upper body") {
    tmp = ((att->opponent)->query_race_ob())->query_target_zones();
    zone = tmp[random(sizeof(tmp) / 2)];
  } else  if((att->attacker_tactics)->focus_zone == "lower body") {
    zone = tmp[random(sizeof(tmp) / 2) + sizeof(tmp)/2];
  } else if((att->attacker_tactics)->focus_zone &&
     (att->attacker_tactics)->focus_zone != "none") {
    // generic zone.
    zone = (att->attacker_tactics)->focus_zone;
    // map to the races zone
    zone = ((att->opponent)->query_race_ob())->map_target_zone(zone);
    att->target_zone = zone;    
  } else {
    if(att->attack_data[AT_SKILL] == "unarmed") {
      // for humanoids punches will typically be upper body while
      // kicks will typically be lower body (depending on target size).
      if(att->attack_data[AT_NAME] == "hands")
        sz = ((att->attacker)->query_height() * 2) /
          (att->opponent)->query_height();
      else if(att->attack_data[AT_NAME] == "feet")
        sz = ((att->attacker)->query_height() / 2) /
          (att->opponent)->query_height();
    } else
      sz = to_float((att->attacker)->query_height()) /
        to_float((att->opponent)->query_height());

    // The relative sizes of combatants lead to more attacks higher or lower
    // on the body.
    tmp = ((att->opponent)->query_race_ob())->query_target_zones();
    if(sizeof(tmp)) {
      if(sz > 1.5)
        zone = tmp[random(random(sizeof(tmp)))];
      if(sz < 0.75) {
        i = random(sizeof(tmp) + 10);
        if(i > sizeof(tmp)-1)
          i = sizeof(tmp) - 1;
        zone = tmp[i];
      } else {
        zone = tmp[random(sizeof(tmp))];
      }
    }
  }
  att->target_zone = zone;

  return att;
}

/**
 * Will the defender defend or not? If so, with what skill and weapon and at
 * what action cost?
 *
 * PRE: all attack data and opponent and defender data have been set.
 * POST: defense type, skill and weapon must be set. If defense_action
 * is "none" the defender will have a big negative modifier.
 *
 * @param class attack
 * @return class attack
 */
class attack choose_defense(class attack att) {
  object defender;
  string response, *hands, hand;
  object *weapons;
  class tactics tactics;
  int i, which;
#ifdef USE_DISTANCE
  int move_cost;
#endif  

  defender = att->defender;
  att->defense_action = "none";
  att->defense_skill = DODGE;
  att->defense_weapon = 0;

  tactics = att->defender_tactics;

  // Defenders (when the defender is not the opponent) have already
  // decided that they'll take on this action regardless of their
  // defecit thus only check defecits if opponent == defender.
  if(defender == att->opponent) {
    if(!defender->query_can_defend())
      return att;
    
    if(!DEFENSIVE_DEFECITS[tactics->attitude])
      tactics->attitude = "neutral";

    if(att->defender_defecit > DEFENSIVE_DEFECITS[tactics->attitude])
      return att;
  }

#ifdef USE_DISTANCE
  else if(att->distance != defender->query_distance(att->attacker) &&
            ABS(defender->query_distance(att->attacker)) >
            MOVE_DISTANCE[tactics->attitude]) {
    // If we have a defender or protector and they aren't in the right
    // position they need to move there and that will cost them some extra
    // actions. This _could_ lead to them spending all their time running
    // back and forth if they try to protect/defend too many people.

    defender->set_distance(att->attacker, att->distance);
    move_cost = MOVE_COST;
    move_cost -= defender->query_skill_bonus(MOVE_SKILL) / 50;
    if(move_cost < 0)
      move_cost = 0;

    (att->opponent)->event_combat(att->opponent, defender->one_short() +
                                  " moves to " +
                                  (att->person_hit == defender ?
                                   "protect" : "defend" ) + " you.\n",
                                  ({ }), 0);
    defender->event_combat(defender, "You move to " +
                           (att->person_hit == defender ?
                            "protect" : "defend") + " " +
                           (att->opponent)->one_short() + ".\n",
                           ({ }), 0);
    event(environment(att->opponent), "combat", defender->one_short() +
          " moves to " + (att->person_hit == defender ? "protect" : "defend") +
          " " + (att->opponent)->one_short() + ".\n",
          ({ att->opponent, defender, att->person_hit }), 1);
  }
#endif

  response = tactics->response;

  // Defenders have two choices, parry or don't, dodging isn't any use.
  if(defender != att->opponent) {
    if(response == "dodge")
      return att;
    response = "parry";
  } else if(!response || response == "neutral") // opponents get a free choice.
    response = ({"parry", "dodge"})[random(2)];

  if(response == "parry") {
    weapons = (object *)defender->query_holding();

    // Figure out which weapon index is the hand they prefer to parry with.
    hand = (att->defender_tactics)->parry;
    which = -1;
    hands = (att->defender)->query_limbs();
    for(i=0; i<sizeof(hands); i++)
      if(hands[i][0..sizeof(hand)-1] == hand)
        which = i;
    
    // If we found a preferred hand then try to parry with it, or parry
    // unarmed if they want to.
    if(which != -1) {
      if(weapons[which]) {
        att->defense_action = "parry";
        att->defense_skill = WEAPON_PARRY;
        att->defense_weapon = weapons[which];
      } else if((att->defender_tactics)->parry_unarmed) {
        att->defense_action = "parry";
        att->defense_skill = UNARMED_PARRY;
        att->defense_weapon = att->defender;
        att->defense_limb = (att->defender)->query_limbs()[which];
      }
    } else {
      // If there's no preferred hand and they have weapons they parry with
      // whichever they have a weapon in. Otherwise, they parry unarmed if
      // they want to do that, otherwise it's no defense.
      weapons -= ({ 0 });
      if(!sizeof(weapons)) {
        if((att->defender_tactics)->parry_unarmed) {
          att->defense_action = "parry";
          att->defense_skill = UNARMED_PARRY;
          att->defense_weapon = att->defender;
        }
      } else {
        att->defense_action = "parry";
        att->defense_skill = WEAPON_PARRY;
        att->defense_weapon = weapons[random(sizeof(weapons))];
      }
    }

  } else {
    att->defense_action = "dodge";
    att->defense_skill = DODGE;
    att->defense_weapon = 0;
  }

  return att;
}

/**
 * This method calculates the modifier to the attack.
 *
 * It will take into account all the basic stuff that makes the attack
 * harder or easier.
 *
 * PRE: All attack and response data has been filled in.
 * POST: The offensive modifier must be set.
 *
 * @param class attack
 * @return class attack
 */
protected class attack calc_attack_modifier(class attack att) {
  object attacker, attack_weapon, *holding;
  int mod, wep, hld, lght, mntd, hlth, brdn, dist, tact, targ, oth;
  int tmp, tmp2, limbs, dex, num, actions;
  string zone, *attackers;
  
  attacker = att->attacker;
  dex = attacker->query_dex();
  attack_weapon = att->attack_weapon;
  mod = wep = hld = lght = mntd = hlth = brdn = dist = tact = 0;

  if(attack_weapon != attacker) {
    /*
     * Find out how heavy the weapon is, how many hands they're using to hold
     * it, how many other weapons they're holding, which hand they're
     * holding their many hands they're using to hold the weapon and decrease
     * a based on that.
     */
    holding = attacker->query_holding();

    // tmp -- how many hands they're using to hold the attacking weapon
    // tmp2 -- weight factor for other held items.
    limbs = tmp2 = 0;
    for(num = 0; num < sizeof(holding); num++) {
      if(holding[num] == attack_weapon)
        limbs++;
      else if(holding[num]) {
        if((holding[num])->id("shield"))
          tmp2 += (holding[num])->query_weight() / 5;
        else
          tmp2 += (holding[num])->query_weight();
      }
    }

    // If they're holding a second weapon but aren't parrying with it
    // then their negative modifier for it is lower.
    switch((att->attacker_tactics)->response) {
    case "both":
      tmp2 = (tmp2 * 3) / 2;
      break;
    case "dodge":
      // To hold multiple weapons your dex must outweigh the weight of the
      // secondary weapons.
      if(tmp2 < dex)
        tmp2 /= 2;
    }
    
    // weapon weight.
    wep = attack_weapon->query_weight() + (tmp2 / 2);
    
    // 2/3 for one hand. 2 / 4 for two hands. 2 / 5 for three etc.
    wep /= (limbs + 1);
    wep -= (att->attacker)->query_str();
    
    // If their weapon weight factor adds up to more than their strength
    // they take a negative modifier.
    if(wep > 0 ) {
      wep = - to_int(pow(wep, 1.4));
    } else
      wep = 0;


    // If you're attacking with your off-hand (ie. not your prime hand)
    // you take a negative modifier if your dex is low.
    // (index 0 is your prime hand)
    if(dex < 14 && sizeof(holding) && holding[0] != attack_weapon)
      hld = dex - 14;
    
  } else {
    wep =  (dex * 2) - attacker->query_burden();
  }

  // light levels
  switch(attacker->check_dark(environment(attacker)->query_light())) {
  case -2:
  case 2:
    lght = -50;
    break;
  case -1:
  case 1:
    lght = -25;
    break;
  }

  // mountedness
  mntd = 0;

  // health (up to -50)
  hlth -= (50 - (attacker->query_hp() * 50) / attacker->query_max_hp());
  
  // fatigue (up to -25)
  tmp = attacker->query_specific_gp("fighting");
  if(tmp < -50)
    hlth += -25;
  else if(tmp < 0)
    hlth += (tmp / 2);

  // burden (up to -33)
  brdn -= (attacker->query_burden() / 3);

#ifdef USE_DISTANCE
  // distance from opponent & length of weapon.
  if(att->attack_weapon == att->attacker)
    dist = -3 * ABS(REACH - att->distance);
  else
    dist = -3 * ABS(REACH + (att->attack_weapon)->query_length() -
                    att->distance);
#endif

  // Bonus for offensive tactics.
  switch((att->attacker_tactics)->attitude) {
  case "insane":
    tact = 25;
    break;
  case "offensive":
    tact = 15;
    break;
  case "defensive":
    tact = -25;
    break;
  case "wimp":
    tact = -50;
    break;
  }

  switch(att->attacker_tactics->focus_zone) {
  case 0:
  case "none":
    targ = 0;
    break;
  case "upper body":
  case "lower body":
    targ -= 25;
    break;
  default:
    tmp = 0;
    foreach(zone in ((att->opponent)->query_race_ob())->query_target_zones())
      if(zone == att->target_zone)
        tmp++;
    num = sizeof(((att->opponent)->query_race_ob())->query_target_zones());
    // between -0 & -25 depending on what %age of the body the target zone
    // accounts for.
    targ -= ((num - tmp) * 25 / num);
  }

  if(targ < -25) {
    debug_printf("Targ too small (%s) %d. num: %d, tmp: %d\n",
                 (att->attacker_tactics)->focus_zone, targ, num,tmp);
    targ = -25;
  }

  // If you're further down the attacker list than the second person
  // you take a negative modifier since only the first 2-4 people
  // can really get a hit in on someone.
  attackers = filter((att->opponent)->query_attacker_list(),
                     (: $1 && environment($1) == environment(this_object()):));
  num = member_array(this_object(), attackers);
  if(num > 1)
    num += -25 * num;

  if((att->attacker_tactics)->attack == "both")
    oth += 5;
  
  mod = wep + hld + lght + mntd + hlth + brdn + dist + tact + targ + oth + num;
  att->attack_modifier += mod;

  // Calculate how much time an attack takes.
  actions += ATTACK_COST;
  
  // heavier weapons are slower to attack with.
  if(attack_weapon != att->attacker)
    actions += (sqrt(attack_weapon->query_weight()) * 3) / (limbs + 1);

  // Holding two weapons gives a slight advantage.
  if(sizeof((att->attacker)->query_weapons()) > 1)
    actions -= ATTACK_COST / 4;
  
  // more skilled opponents are more fluid in their movements.
  actions -= ((att->attacker)->query_skill_bonus(att->attack_skill) +
              (att->attacker)->query_skill_bonus(TACTICAL_SKILL)) / 50;
  
  if(actions < ATTACK_COST / 5)
    actions = ATTACK_COST / 5;
  else if(actions > ATTACK_COST * 2)
    actions = ATTACK_COST * 2;
  att->attack_cost = actions;

#if DEBUG == 1
  combat_debug("Attack %s (%s): wep: %d hld: %d lght: %d mntd: %d "
               "hlth: %d brdn: %d dist: %d tact: %d targ: %d oth: %d "
               "num: %d = %d [%d] (actions: %d %d)",
               att->attack_data[AT_NAME],
               (att->attack_weapon)->query_name(),
               wep, hld, lght, mntd, hlth, brdn, dist, tact, targ, oth, num,
               mod, att->attack_modifier, actions, att->attacker_defecit);
#endif
  return att;
}

/**
 * This method calculates the modifier to the defense.
 *
 * It will take into account all the basic stuff that makes the defense
 * harder or easier.
 *
 * PRE: All attack and response data has been filled in.
 * POST: The defensive modifier must be set.
 *
 * @param class attack
 * @return class attack
 */
class attack calc_defense_modifier(class attack att) {
  object defender, attacker, attack_weapon, defense_weapon, *holding;
  int mod, wep, wght, dist, brdn, hnd, lght, hlth, tact, prot, oth;
  int tmp, num, dex, limbs, actions;
  
  mod = wep = wght = dist = brdn = hnd = lght = hlth = tact = prot = oth = 0;
  defender = att->defender;
  defense_weapon = att->defense_weapon;
  dex = defender->query_dex();
  attacker = att->attacker;
  attack_weapon = att->attack_weapon;

  // Parry & Dodge are somewhat different. Obviously parrying depends on
  // using an object to block while dodge requires moving ones whole body.
  // They should each have strengths and weaknesses.
  switch(att->defense_action) {
  case "parry":
    if(defense_weapon != defender && defense_weapon) {

      holding = defender->query_holding();

      // weapon weight
      if(defense_weapon->id("shield"))
        wep = defense_weapon->query_weight() / 5;
      else
        wep = defense_weapon->query_weight() * 2;

      /*
       * Find out how many hands they're using to hold the weapon/shield
       */
      limbs = 0;
      for(num = 0; num < sizeof(holding); num++)
        if(holding[num] && holding[num] == defense_weapon)
          limbs++;

      // 2/2 for one hand. 2 / 3 for two hands. 2 / 4 for three etc.
      wep /= (limbs + 2);

      if(wep > defender->query_str())
        wep = - to_int(pow(wep - defender->query_str(), 1.3));

      // relative weight of attackers weapon to ours?
      if(attack_weapon != attacker)
        wght = 2 * (defense_weapon->query_weight() -
                    attack_weapon->query_weight());
      else
        wght = defense_weapon->query_weight() / 2;

      // Having a heavier defensive weapon doesn't help much, if at all.
      // However, having a light defensive weapon is a disadvantage.
      if(wght > 5)
        wght = 5;
      
#ifdef USE_DISTANCE
      dist = - ABS(REACH + defense_weapon->query_length() - att->distance);
#endif
    } else {
#ifdef USE_DISTANCE
      dist = - ABS(REACH - att->distance);
#endif
    }

    brdn = -(defender->query_burden() / 3);

    if(sizeof(holding)) {
      // If you're parrying with your off-hand (ie. not your prime hand)
      // you take a negative modifier.
      if(dex < 14 && holding[0] != defense_weapon)
        hnd = dex - 14;
    
      // If you're parrying with the same weapon you attack with
      // (ie. you're parrying & only holding one weapon that's a -ve.
      holding = uniq_array(filter(holding, (: $1 :)));
      if(dex  < 16 && sizeof(holding) == 1)
        hnd += dex - 16;
    }
    break;

  case "dodge":
    // All actions get the 1/3rd burden.
    brdn = -(defender->query_burden() / 3);

    // Dodgers get a dex mitigated burden modifier
    if(dex < (defender->query_burden() / 2))
      brdn -= dex - (defender->query_burden() / 2);
    
    if(att->attack_weapon != att->attacker)
      wght = ((att->attack_weapon)->query_weight() / 10);
    break;
  }

  // light levels / visibility of opponent
  if(!(att->attacker)->query_visible(defender))
    lght = -100;
  else {
    switch(defender->check_dark(environment(defender)->query_light())) {
    case -2:
    case 2:
      lght = -50;
      break;
    case -1:
    case 1:
      lght = -25;
      break;
    }
  }
  
  // mountedness

  // health (up to -25)
  hlth = - (25 - (defender->query_hp() * 25) / defender->query_max_hp());

  // fatigue (up to -25)
  tmp = defender->query_specific_gp("fighting");
  if(tmp < -50)
    hlth += -25;
  else if(tmp < 0)
    hlth += (tmp / 2);

  // Bonus for defensive tactics.
  switch((att->defender_tactics)->attitude) {
  case "insane":
    tact = -50;
    break;
  case "offensive":
    tact = -25;
    break;
  case "defensive":
    tact = 15;
    break;
  case "wimp":
    tact = 25;
    break;
  }

  // Protecting is a -15 modifier. Defending is an extra -15. This is because
  // it's easier to just jump in the way than to actually parry for someone.
  prot = 0;
  if(defender != att->opponent) {
    if(defender != att->person_hit) {
      // defending someone else with a shield is very tricky since shields
      // are setup only to protect you.
      if(defense_weapon->id("shield")) 
        prot -= 15;
      prot -= 15;
    }
    prot -= 15;
  }

  // Small bonus for response of both.
  if((att->defender_tactics)->response == "both")
    oth += 5;
  
  if(defender->query_casting_spell())
    oth -= 25;

  mod = wep + wght + dist + brdn + hnd + lght + hlth + tact + prot + oth;

  att->defense_modifier += mod;

  // Calculate how much time a parry/dodge takes.
  if(att->defense_action != "none") {
    actions = DEFENSE_COST;
    actions -= ((att->defender)->query_skill_bonus(att->defense_skill) +
      (att->attacker)->query_skill_bonus(TACTICAL_SKILL)) / 50;

    // heavier weapons are slower to parry with.
    if(att->defense_weapon && att->defense_weapon != att->defender) {
      if((att->defense_weapon)->id("shield"))
        actions += sqrt(att->defense_weapon->query_weight() / 4);
      else {
        actions += sqrt((att->defense_weapon->query_weight() * 2) /
                        (limbs + 1));

        if(sizeof((att->defender)->query_weapons()) > 1)
          actions -= DEFENSE_COST / 4;
      }
      
    } else if(att->defense_action == "dodge")
      actions += sqrt(defender->query_burden());

    if(actions < DEFENSE_COST / 5)
      actions = DEFENSE_COST / 5;
    else if(actions > DEFENSE_COST * 2)
      actions = DEFENSE_COST * 2;
    
    att->defense_cost = actions;
  }

#if DEBUG == 1
  combat_debug("Defense %s (%s): wep: %d wght: %d dist: %d "
               "brdn: %d hnd: %d lght: %d hlth: %d tact: %d prot: %d "
               "oth: %d = %d [%d] (actions: %d %d)",
               att->defense_action,
               att->defense_weapon ? (att->defense_weapon)->query_name() : "",
               wep, wght, dist, brdn, hnd, lght, hlth, tact, prot, oth,
               mod, att->defense_modifier, actions, att->defender_defecit);
#endif

  return att;
}

/****************************************************************************
 * Now we're into the damage phase.
 ****************************************************************************/

/**
 * After a successful attack (or possibly a parried one) calculate the
 * amount of damage done to the opponent.
 *
 * This method must fill in the amount of damage to be done and may adjust
 * the time taken too.
 *
 * PRE: the outcome of an attack must have been determined.
 * POST: damage must be filled in.
 */
protected class attack calc_damage(class attack att) {
  int damage, weapon_damage;
  object attacker;

  // Damage is a weighted average of the weapon damage and the
  // players skill.

  attacker = att->attacker;
  damage = att->attack_data[AT_DAMAGE];
  weapon_damage = damage;

  // This rather hampers unarmed, perhaps it should be removed.
  if(att->attack_weapon != attacker)
    damage = sqrt(damage * attacker->query_skill_bonus(att->attack_skill));

  if(damage > 3 * weapon_damage)
    damage = 3 * weapon_damage;

  // As the combat gets slower so the damage goes up to compensate otherwise
  // people heal faster than they take damage.
  damage *= COMBAT_SPEED;

  att->damage = damage;

  switch(att->result) {
  case OFFAWARD:
  case OFFWIN:
    // Critical attacks do 2x damage, exceptional attacks 1.5x
    switch(att->degree) {
    case TASKER_CRITICAL:
      att->damage *= 2;
      break;
    case TASKER_EXCEPTIONAL:
      att->damage = (att->damage * 3) / 2;
    case TASKER_MARGINAL:
      att->damage /= 2;
      break;
    }
    break;

  case DEFAWARD:
  case DEFWIN:
    // A Critical or Exceptional parry can cause the opponent to use up
    // extra combat actions since the defense pushed the attackers weapon
    // out of position or brought the defender into a better position.
    switch(att->degree) {
    case TASKER_CRITICAL:
      att->defense_cost = 0;
      break;
    case TASKER_EXCEPTIONAL:
      att->defense_cost /= 2;
      break;
    case TASKER_MARGINAL:
      att->defense_cost *= 2;
      break;
    }
    // All damage is always stopped.
    att->damage = 0;
  }

  combat_debug("Damage: %d %d",
               att->damage,
               attacker->query_skill_bonus(att->attack_skill));
  return att;
}

/**
 * Calculate how much of the damage is saved by the armour.
 *
 * PRE: all information has been filled in except the amount of damage
 * stopped by armour, and which piece of armour did the stopping.
 * POST: The damage stopped and which armour did it is filled in.
 *
 * @param class attack
 * @return class attack
 */
class attack calc_armour_protection(class attack att) {
  object person_hit;
  string armour_zone, damage_type;

  if(!att->damage || (att->result != OFFWIN && att->result != OFFAWARD))
    return att;

  person_hit = att->person_hit;

  // Specials/Criticals may change this calculation.
  armour_zone = (person_hit->query_race_ob())->
    map_armour_zone(att->target_zone);

  damage_type = att->attack_data[AT_TYPE];
  if(damage_type == "unarmed")
    damage_type = "blunt";

  att->armour_stopped = (int)person_hit->query_ac(damage_type, att->damage,
                                                  armour_zone);
  if(att->armour_stopped < 0) {
    debug_printf("armour stopped %d for %s %d %s",
                 att->armour_stopped, damage_type, att->damage, armour_zone);
    att->armour_stopped = 0;
  }
  
  return att;
}

/**
 * Do damage to the attacking & defending weapons.
 *
 * PRE: all information has been filled in
 * POST: the weapons involved have taken appropriate damage.
 *
 * @param class attack
 * @return class attack
 */
protected class attack damage_weapon(class attack att) {
  int off_damage, def_damage;

  switch(att->result) {
  case OFFAWARD:
  case OFFWIN:
    // The weapon hit the opponents armour.
    if(att->armour_stopped && att->degree)
      off_damage = att->armour_stopped / att->degree;
    // No def_damage needed since the query_ac() call damages the armour
    // directly (which is bad, but there we are).
    break;
  case DEFWIN:
  case DEFAWARD:
    // The defender successfully defended. If they parried then their
    // parrying weapon may take some damage and the attacking
    // weapon too.
    if(att->defense_action == "parry" && att->damage && att->degree) {
      off_damage = att->damage * (att->degree - 1);
      def_damage = att->damage / att->degree;
    }
    break;
  }

  if(off_damage) {
    if(att->attack_weapon == att->attacker)
      if((att->attack_weapon)->query_hp() > (off_damage / 10))
        (att->attack_weapon)->adjust_hp(- (off_damage / 10), att->defender,
                                        att->defense_weapon,
                                        "hitting someone.");
    else if(function_exists("hit_weapon", att->attack_weapon))
      (att->attack_weapon)->hit_weapon(off_damage, att->attack_data[AT_SKILL]);
    else
      (att->attack_weapon)->do_damage(att->attack_data[AT_SKILL], off_damage);
  }

  if(def_damage) {
    if(att->defense_weapon == att->defender)
      (att->defense_weapon)->adjust_hp(- def_damage, att->attacker,
                                       att->attack_weapon,
                                       "parrying an attack with a limb.");
    else if(function_exists("hit_weapon", att->defense_weapon))
      (att->defense_weapon)->hit_weapon(def_damage,
                                        att->attack_data[AT_SKILL]);
    else
      (att->defense_weapon)->do_damage(att->attack_data[AT_SKILL], def_damage);
  }

  return att;
}

/**
 * Prepare the result messages.
 *
 * This method prepares the attack and defense messages setting up the 5
 * element arrays of att_mess & def_mess. The elements are as follows:
 * 0 - the attacker, 1 - the opponent, 2 - everyone else, 3 - the defender
 * 4 - the person hit
 *
 * PRE: The attack has been done and the amount of damage done and stopped
 * has been calculated.
 * POST: The 5 element att_mess & def_mess arrays are populated.
 *
 * @param class attack
 */
protected class attack prepare_messages(class attack att) {
  object attacker, opponent, defender, person_hit;
  string *verb, def_short, margin;
  string *def_mess, *att_mess;
  int damage, armour_stopped;

  attacker = att->attacker;
  opponent = att->opponent;
  defender = att->defender;
  person_hit = att->person_hit;
  damage = att->damage;
  armour_stopped = att->armour_stopped;

  // Set attack part of the message.
  switch(att->result) {
  case OFFAWARD:
    tell_object(att->attacker,
                "%^YELLOW%^"+ replace(({ "You feel "
                "that your skill with $weapon$ has increased.", "You "
                "feel more able to use $weapon$.", "You seem to be a "
                "step closer to mastering $weapon$." })[random(3)],
                "$weapon$", (att->attack_weapon == att->attacker ?
                "unarmed combat" : (string)(att->attack_weapon)->a_short())) +
                "%^RESET%^\n" );

  case OFFWIN:
    if(person_hit == opponent) {
      att_mess = ATTACK_MESSAGE->query_message(damage - armour_stopped,
                                               att->attack_data[AT_SKILL],
                                               opponent, attacker,
                                               att->attack_data[AT_NAME],
                                               att->attack_weapon,
                                               att->target_zone);
      
      if(sizeof(att_mess) != 3) {
        att_mess = ({"You hit "+opponent->the_short()+"",
                       attacker->the_short()+" hits you",
                       attacker->the_short()+" hits "+opponent->the_short()});
      }
      
      att_mess += ({ att_mess[M_SPECTATORS], att_mess[M_SPECTATORS] });
    } else {
      att_mess = ATTACK_MESSAGE->query_message(damage - armour_stopped,
                                               att->attack_data[AT_SKILL],
                                               opponent, attacker,
                                               att->attack_data[AT_NAME],
                                               att->attack_weapon,
                                               att->target_zone);
      
      if(sizeof(att_mess) != 3) {
        att_mess = ({"You almost hit "+opponent->the_short()+"",
                       attacker->the_short()+" almost hits you",
                       attacker->the_short()+" almost hits "+
                       opponent->the_short()});
      }
      
      att_mess += ({ att_mess[M_SPECTATORS], att_mess[M_SPECTATORS] });

      att_mess[M_ATTACKER] += " but at the last second " +
        person_hit->the_short() + " leaps in and protects " +
        opponent->query_objective();
      att_mess[M_OPPONENT] += " but at the last second " +
        person_hit->the_short() + " leaps in and protects you";
      att_mess[M_SPECTATORS] += " but at the last second " +
        person_hit->the_short() + " leaps in and protects " +
        opponent->query_objective();
      if(defender == person_hit)
        att_mess[M_DEFENDER] += " but at the last second " +
          person_hit->the_short() + " leap in and protect " +
          opponent->query_objective();
      else
        att_mess[M_DEFENDER] += " but at the last second " +
          person_hit->the_short() + " leaps in and protects " +
          opponent->query_objective();

      att_mess[M_PERSON_HIT] += " but at the last second you leap in and "
        "protect " + opponent->query_objective();
    }
    break;
  case DEFAWARD:
  case DEFWIN:
    att_mess = ATTACK_MESSAGE->query_message(0,
                                             att->attack_data[AT_SKILL],
                                             opponent, attacker,
                                             att->attack_data[AT_NAME],
                                             att->attack_weapon,
                                             att->target_zone);
    if(sizeof(att_mess) != 3) {
      att_mess = ({"You try to hit "+opponent->the_short()+"",
                     attacker->the_short()+" tries to hit you",
                     attacker->the_short()+" tries to hit "+
                     opponent->the_short()});
    }
    att_mess += ({ att_mess[M_SPECTATORS], att_mess[M_SPECTATORS] });
    break;
  }

  def_mess = allocate(5);
  def_mess[M_ATTACKER] = def_mess[M_OPPONENT] = def_mess[M_SPECTATORS] =
    def_mess[M_DEFENDER] = def_mess[M_PERSON_HIT] = "";

  // Now set the response part ie. what happened after the attack.
  switch(att->result) {
  case OFFAWARD:
  case OFFWIN:
    // The attack was successful, so we add armour messages if appropriate.
    if(armour_stopped && armour_stopped > damage / 3) {
      if(objectp(att->stopped_by)) {
        def_mess[M_ATTACKER] = " but " + (att->stopped_by)->poss_short();
        def_mess[M_OPPONENT] = def_mess[M_ATTACKER];
        def_mess[M_SPECTATORS] = def_mess[M_ATTACKER];
        def_mess[M_DEFENDER] = def_mess[M_ATTACKER];
        def_mess[M_PERSON_HIT] = def_mess[M_ATTACKER];
      } else if(att->stopped_by) {
        def_mess[M_ATTACKER] = " but " + person_hit->query_possessive() +
          " " + att->stopped_by;

        if(person_hit == opponent)
          def_mess[M_OPPONENT] = " but your " + att->stopped_by;
        else
          def_mess[M_OPPONENT] = def_mess[M_ATTACKER];

        def_mess[M_SPECTATORS] = def_mess[M_ATTACKER];

        if(person_hit == defender)
          def_mess[M_DEFENDER] = " but your " + att->stopped_by;
        else
          def_mess[M_DEFENDER] = def_mess[M_ATTACKER];

        def_mess[M_PERSON_HIT] = " but your " + att->stopped_by;
      }

      // armour protected them, at least partly
      if(!damage || armour_stopped >= damage) {
        def_mess[M_ATTACKER] += " absorbs all of";
        def_mess[M_OPPONENT] += " absorbs all of";
        def_mess[M_SPECTATORS] += " absorbs all of";
        def_mess[M_DEFENDER] += " absorbs all of";
        def_mess[M_PERSON_HIT] += " absorbs all of";
      } else if(armour_stopped > (damage * 2 / 3)) {
        def_mess[M_ATTACKER] += " absorbs most of";
        def_mess[M_OPPONENT] += " absorbs most of";
        def_mess[M_SPECTATORS] += " absorbs most of";
        def_mess[M_DEFENDER] += " absorbs most of";
        def_mess[M_PERSON_HIT] += " absorbs most of";
      } else {
        def_mess[M_ATTACKER] += " absorbs some of";
        def_mess[M_OPPONENT] += " absorbs some of";
        def_mess[M_SPECTATORS] += " absorbs some of";
        def_mess[M_DEFENDER] += " absorbs some of";
        def_mess[M_PERSON_HIT] += " absorbs some of";
      }
      def_mess[M_ATTACKER] += " the blow";
      def_mess[M_OPPONENT] += " the blow";
      def_mess[M_SPECTATORS] += " the blow";
      def_mess[M_DEFENDER] += " the blow";
      def_mess[M_PERSON_HIT] += " the blow";
    }
    break;

  case DEFAWARD:
    if(att->defense_action == "parry") {
      if(att->defense_weapon && (att->defense_weapon)->query_weapon())
        verb = ({ "parry", "parries", "parrying" });
      else
        verb = ({ "block", "blocks", "blocking" });

      tell_object(att->defender,
                  "%^YELLOW%^"+ replace( ({ "You move more surely "
               "than you thought you could in $verbing$ $attacker$'s attack",
               "You just manage to $verb$ $attacker$'s attack, but you'll "
               "know better next time", "You feel better at $verbing$ as "
               "you $verb$ $attacker$'s attack" })[ random( 3 ) ],
               ({ "$verb$", verb[ 0 ], "$verbing$", verb[ 2 ], "$attacker$",
               (string)(att->attacker)->the_short() }) ) +".%^RESET%^\n" );
    } else if(att->defense_action == "dodge") {
      tell_object(att->defender,
                   "%^YELLOW%^"+ replace( ({ "You move more nimbly "
               "than you thought you could in dodging $attacker$", "You "
               "managed to predict $attacker$'s attack, letting you dodge it "
               "more easily", "You feel better at dodging as you avoid "
               "$attacker$'s attack" })[ random( 3 ) ], "$attacker$",
               (string)(att->attacker)->the_short() ) +".%^RESET%^\n" );
    }
  case DEFWIN:
    // The defense was successful so we print parry/dodge messages as
    // appropriate.
    def_mess = allocate(5);
    def_mess[M_ATTACKER] = "";
    def_mess[M_OPPONENT] = "";
    def_mess[M_SPECTATORS] = "";
    def_mess[M_DEFENDER] = "";
    def_mess[M_PERSON_HIT] = "";
    switch(att->degree) {
    case TASKER_MARGINAL:
      margin = "just ";
      break;
    case TASKER_EXCEPTIONAL:
      margin = "deftly ";
      break;
    case TASKER_MARGINAL:
      margin = "easily ";
      break;
    default:
      margin = "";
      break;
    }

    if(att->defense_action == "parry" && att->defense_weapon) {
      if(defender == opponent)
        def_mess[M_ATTACKER] = " but " + defender->query_pronoun() + " " +
          margin;
      else
        def_mess[M_ATTACKER] = " but " + defender->the_short() + " " + margin;

      if(defender == opponent)
        def_mess[M_OPPONENT] = " but you " + margin;
      else
        def_mess[M_OPPONENT] = def_mess[M_ATTACKER];

      def_mess[M_SPECTATORS] = def_mess[M_ATTACKER];
      def_mess[M_DEFENDER] = " but you " + margin;
      def_mess[M_PERSON_HIT] = def_mess[M_ATTACKER];

      if(att->defense_weapon != defender &&
         !(att->defense_weapon)->id("shield")) {
        def_mess[M_ATTACKER] += "parries";
        if(defender == opponent)
          def_mess[M_OPPONENT] += "parry";
        else
          def_mess[M_OPPONENT] += "parries";

        def_mess[M_SPECTATORS] += "parries";
        def_mess[M_DEFENDER] += "parry";
        if(att->person_hit == att->defender)
          def_mess[M_PERSON_HIT] += "parry";
        else
          def_mess[M_PERSON_HIT] += "parries";
      } else {
        def_mess[M_ATTACKER] += "blocks";
        if(defender == opponent)
          def_mess[M_OPPONENT] += "block";
        else
          def_mess[M_OPPONENT] += "blocks";

        def_mess[M_SPECTATORS] += "blocks";
        def_mess[M_DEFENDER] += "block";
        if(att->person_hit == att->defender)
          def_mess[M_PERSON_HIT] += "block";
        else
          def_mess[M_PERSON_HIT] += "blocks";
      }

      if(att->defense_weapon != defender) {
        def_short = (att->defense_weapon)->short();
      } else if(att->defense_limb) {
        def_short = att->defense_limb;
      } else
        def_short = (defender->query_race_ob())->map_target_zone("hands");


      def_mess[M_ATTACKER] += " the blow with " +
        defender->query_possessive() + " " + def_short;
      if(defender == opponent)
        def_mess[M_OPPONENT] += " the blow with your " + def_short;
      else
        def_mess[M_OPPONENT] += " the blow with " +
          defender->query_possessive() + " " + def_short;

      def_mess[M_SPECTATORS] += " the blow with " +
        defender->query_possessive() + " " + def_short;

      def_mess[M_DEFENDER] += " the blow with your " + def_short;

      if(defender == person_hit)
        def_mess[M_PERSON_HIT] += " the blow with your " + def_short;
            else
        def_mess[M_PERSON_HIT] += " the blow with " +
          defender->query_possessive() + " " + def_short;

    } else if(att->defense_action == "dodge") {
      def_mess[M_ATTACKER] = " but " + defender->query_pronoun() + " " +
        margin + "dodges out of the way";
      def_mess[M_OPPONENT] = " but you " + margin + "dodge out of the way";
      def_mess[M_SPECTATORS] = " but " + defender->query_pronoun() + " " +
        margin + "dodges out of the way";
    } else {
      def_mess[M_ATTACKER] = " but, although unable to defend, " +
        defender->query_pronoun() + " somehow avoids the attack";
      def_mess[M_OPPONENT] = " but, although unable to defend, you somehow "
        "avoid the attack";
      def_mess[M_SPECTATORS] = " but, although unable to defend, " +
        defender->query_pronoun() + " somehow avoids the attack";
    }
  }
  att->attack_messages = att_mess;
  att->defense_messages = def_mess;

  if(att->result == DEFAWARD || att->result == DEFWIN || !damage ||
     armour_stopped >= damage)
    att->verbose = 1;

  return att;
}

/**
 * Write out the attack/defense messages.
 *
 * PRE: all information has been filled in
 * POST: the appropriate messages have been written out.
 *
 * @param class attack
 * @return class attack
 */
protected class attack write_messages(class attack att) {
  int verbose;
  
  verbose = att->verbose;
  (att->attacker)->event_combat(att->attacker,
                                att->attack_messages[M_ATTACKER] +
                                att->defense_messages[M_ATTACKER] + ".\n",
                                ({ }), verbose);
  (att->opponent)->event_combat(att->opponent,
                                att->attack_messages[M_OPPONENT] +
                                att->defense_messages[M_OPPONENT] + ".\n",
                                ({ }), verbose);
  if(att->defender != att->opponent &&
     sizeof(att->attack_messages) > M_DEFENDER)
    (att->defender)->event_combat(att->defender,
                                  att->attack_messages[M_DEFENDER] +
                                  att->defense_messages[M_DEFENDER] + ".\n",
                                  ({ }), verbose);
  if(att->person_hit != att->opponent && att->person_hit != att->defender &&
     sizeof(att->attack_messages) > M_PERSON_HIT)
    (att->person_hit)->event_combat(att->person_hit,
                                    att->attack_messages[M_PERSON_HIT] +
                                    att->defense_messages[M_PERSON_HIT] +
                                    ".\n", ({ }), verbose);

  event(environment(att->attacker), "combat",
        att->attack_messages[M_SPECTATORS] +
        att->defense_messages[M_SPECTATORS] + ".\n",
        ({ att->attacker, att->opponent, att->defender, att->person_hit }),
        verbose);
  return att;
}

/**
 * Adjust the time left, combat actions and gp used by this attack.
 * This calls adjust_action_defecit in both the attacker and defender
 * as appropriate.
 *
 * @param class attack
 */
protected void adjust_actions(class attack att) {
  int tmp;

  // Reduce the attackers time left.
  if((att->attacker)->query_time_left() > 0)
    (att->attacker)->adjust_time_left(-DEFAULT_TIME);

  // Reduce their actions.
  (att->attacker)->adjust_action_defecit(att->attack_cost);
  (att->opponent)->adjust_action_defecit(att->defense_cost);

  // Extra cost for defenders
  if(att->defender != att->opponent)
    (att->defender)->adjust_action_defecit(DEFENSE_COST);

  // Extra cost for protectors
  if(att->person_hit != att->opponent)
    (att->person_hit)->adjust_action_defecit(DEFENSE_COST);

  // Reduce their GP
  tmp = ATTACK_GP[(att->attacker_tactics)->attitude];
  (att->attacker)->adjust_gp(-tmp);

  if(att->defender != att->opponent) {
    tmp = DEFENDER_GP[(att->defender_tactics)->attitude];
    (att->defender)->adjust_gp(-tmp);
  } else if(att->defense_action != "none") {
    tmp = DEFENSE_GP[(att->defender_tactics)->attitude];
    (att->opponent)->adjust_gp(-tmp);
  }

  if(att->person_hit != att->opponent) {
    tmp = DEFENDER_GP[(att->person_hit)->query_combat_attitude()];
    (att->person_hit)->adjust_gp(-tmp);
  }
}

/**
 * This function is called as part of the post attack processing and performs
 * the checks to see if someone can move closer or further away from their
 * opponent.
 *
 * @param class attack
 * @return class attack
 * @see after_attack()
 */
protected class attack perform_movement(class attack att) {
  int ideal, move_cost, closer;

  // Figure out if they will attempt to move-in or move-away from their
  // opponent.
  ideal = DISTANCES[(att->attacker_tactics)->ideal_distance];

  // If the difference between the actual and ideal distance is greater than
  // the acceptable difference defined for our attitude we'll attempt to
  // move in or out to compensate.
  if(ABS(ideal - att->distance) >
     MOVE_DISTANCE[(att->attacker_tactics)->attitude]) {

    if(att->distance > ideal)
      closer = 1;
    move_cost = MOVE_COST;
    move_cost -= (att->attacker)->query_skill_bonus(MOVE_SKILL) / 30;

    if(move_cost > 0)
      att->attack_cost += MOVE_COST;
    
    switch(TASKER->compare_skills(att->attacker, MOVE_SKILL,
                                  att->defender, MOVE_SKILL,
                                  att->attack_modifier -
                                  att->defense_modifier,
                                  TM_CONTINUOUS, TM_CONTINUOUS, 0)) {
    case OFFAWARD:
      tell_object(att->attacker,
                  "%^YELLOW%^You feel that your tactical skill has increased."
                  "%^RESET%^\n");
    case OFFWIN:
      if(closer) {
        (att->attacker)->event_combat(att->attacker, "You move in closer to " +
                                      (att->opponent)->one_short() + ".\n",
                                      ({ }), 0);
        (att->opponent)->event_combat(att->opponent,
                                      (att->attacker)->one_short() +
                                      " moves in closer to you.\n", ({ }), 0);

        event(environment(att->attacker), "combat",
              (att->attacker)->one_short() +
              " moves in closer to " + (att->opponent)->one_short() + ".\n",
              ({ att->attacker, att->opponent }), 1);

        set_distance(att->opponent, query_distance(att->opponent) -
                     DISTANCE_STEP);
        (att->opponent)->set_distance(att->attacker,
                                      query_distance(att->opponent));
      } else {
        (att->attacker)->event_combat(att->attacker,
                                      "You move further away from " +
                                      (att->opponent)->one_short() + ".\n",
                                      ({ }), 0);
        (att->opponent)->event_combat(att->opponent,
                                     (att->attacker)->one_short() +
                                     " moves further away from you.\n",
                                     ({ }), 0);
        event(environment(att->attacker), "combat",
              (att->attacker)->one_short() + " moves further away from " +
              (att->opponent)->one_short() + ".\n",
              ({ att->attacker, att->opponent }), 1);
        set_distance(att->opponent, query_distance(att->opponent) +
                     DISTANCE_STEP);
        (att->opponent)->set_distance(att->attacker,
                                      query_distance(att->opponent));
      }
      break;
    case DEFAWARD:
      tell_object(att->opponent,
                  "%^YELOW%^You feel that your tactical skill has increased."
                  "%^RESET%^\n");
    case DEFWIN:
      if(closer) {
        (att->attacker)->event_combat(att->attacker,
                                      "You try to move in closer to " +
                                      (att->opponent)->one_short() +
                                      " but cannot find "
                                      "an opportunity.\n", ({ }), 1);
        (att->opponent)->event_combat(att->opponent,
                                      (att->attacker)->one_short() +
                                      " tries to move in closer to you "
                                      "but you don't give " +
                                      (att->attacker)->query_objective() +
                                      " an opporunity.\n", ({ }), 1);
        event(environment(att->attacker), (att->attacker)->one_short() +
              " tries to move in closer to " +
              (att->opponent)->one_short() + " but " +
              (att->opponent)->query_pronoun() + " doesn't give " +
              (att->attacker)->query_objective() + " an opportunity.\n",
              ({ att->attacker, att->opponent }), 1);
      } else {
        (att->attacker)->event_combat(att->attacker,
                                      "You try to move further away from  " +
                                      (att->opponent)->one_short() +
                                      " but cannot find an opportunity.\n",
                                      ({ }), 1);
        (att->opponent)->event_combat(att->opponent,
                                      (att->attacker)->one_short() +
                                      " tries to move further away from you "
                                      "but you don't give " +
                                      (att->attacker)->query_objective() +
                                      " an opporunity.\n", ({ }) , 1);
        event(environment(att->attacker), "combat",
              (att->attacker)->one_short() +
              " tries to move further away from " +
              (att->opponent)->one_short() + " but " +
              (att->opponent)->query_pronoun() + " doesn't give " +
              (att->attacker)->query_objective() + " an opportunity.\n",
              ({ att->attacker, att->opponent }), 1);
      }
    }
  }

  return att;
}

/**
 * This function is called after it's all over and done (just before the
 * costs are charged). It can be used to do any special outcomes that
 * we may decide on.
 * Note that if you override this function in a special be absolutely certain
 * you know what you're doing if you return R_ABORT or R_DONE. Use of either
 * of these two could cause really nasty side-effects.
 *
 * @param class attack
 * @return class attack
 */
protected class attack after_attack(class attack att) {
  string *locations;
  int total, count, lperc, hperc;

#ifdef USE_DISTANCE
  if((att->result == OFFWIN || att->result == OFFAWARD) &&
     (att->attacker_tactics)->ideal_distance &&
     environment(att->attacker) == environment(att->opponent))
    att = perform_movement(att);
#endif

  adjust_actions(att);
  if((att->damage - att->armour_stopped) <= 0)
    return att;

  // Do weapon special attacks.
  if((environment(att->person_hit) == environment(att->attacker)) &&
     (att->result == OFFWIN || att->result == OFFAWARD)) {
    (att->attack_weapon)->attack_function(att->attack_data[AT_NAME],
                                          att->damage - att->armour_stopped,
                                          att->person_hit, att->attacker);
  }

  // Determine special injuries if enough damage was done.

  locations = (att->defender->query_race_ob())->query_target_zones();

  total = sizeof(locations);
  tmpzone = att->target_zone;
  locations = filter(locations, (: $1 == tmpzone :));
  count = sizeof(locations);
  lperc = (count * 100) / total;

  if(att->degree == TASKER_CRITICAL) {
    hperc = ((att->damage - att->armour_stopped) * 100) /
      (att->opponent)->query_max_hp();

    if(lperc < hperc) {
      switch(att->target_zone) {
      case "head":
        // Unconscious
        break;
      case "chest":
      case "stomach":
        break;
      case "arm":
        // broken arm.
        break;
      case "leg":
        // broken leg.
        break;
      }
    }
  }
  return att;
}

/**
 * Go through the list of the attacker & opponents specials and
 * call any that have registered for this stage.
 */
protected mixed *call_special(int stage, class attack att) {
  class combat_special *tmp;
  mixed *result;
  int i;

  if(!this_object()->query_no_specials()) {
    tmp = att->attacker_specials;
    for(i=0; i<sizeof(tmp); i++) {
      if((tmp[i]->type & T_OFFENSIVE) && (tmp[i]->events & stage)) {
        if(functionp(tmp[i]->callback))
          result = evaluate(tmp[i]->callback, stage, att, tmp[i]->data);
        else if(arrayp(tmp[i]->callback)) {
          if(!tmp[i]->callback[0] || !tmp[i]->callback[1]) {
            (att->attacker)->remove_special(tmp[i]->id);
          } else 
            result = call_other(tmp[i]->callback[0], tmp[i]->callback[1],
                                stage, att, tmp[i]->data);
        }
        
        if(sizeof(result)) {
          if(!classp(result[1])) {
            debug_printf("Error, call_special received invalid return "
                         "data. %O when calling %O stage %d\n", result,
                         tmp[i]->callback, stage);
            result[0] = R_REMOVE_ME | R_ABORT;
          }
                         
          if(result[0] & R_REMOVE_ME) {
            (att->attacker)->remove_special(tmp[i]->id);
          } else {
            // Set the data to be the new data in both the current attack
            // data & in the original info.
            tmp[i]->data = result[2];
            (att->attacker)->set_special_data(tmp[i]->id, result[2]);
          }
          
          if(result[0] & R_ABORT)
            return result;
          
          if((result[0] & R_DONE) || (result[0] & R_CONTINUE))
            break;
        }
      }
    }
  }

  if(att->defender && !(att->defender)->query_no_specials()) {
    tmp = att->defender_specials;
    for(i=0; i<sizeof(tmp); i++) {
      if((tmp[i]->type & T_DEFENSIVE) && (tmp[i]->events & stage)) {
        if(functionp(tmp[i]->callback))
          result = evaluate(tmp[i]->callback, stage, att, tmp[i]->data);
        else if(arrayp(tmp[i]->callback)) {
          if(!tmp[i]->callback[0] || !tmp[i]->callback[1]) {
            (att->defender)->remove_special(tmp[i]->id);
          } else 
            result = call_other(tmp[i]->callback[0], tmp[i]->callback[1],
                                stage, att, tmp[i]->data);
        }
        
        if(sizeof(result)) {
          if(!classp(result[1])) {
            debug_printf("Error, call_special received invalid return "
                         "data. %O when calling %O stage %d", result,
                         tmp[i]->callback, stage);
            result[0] = R_REMOVE_ME | R_ABORT;
          }

          if(result[0] & R_REMOVE_ME) {
            (att->defender)->remove_special(tmp[i]->id);
          } else {
            // Set the data to be the new data.
            (att->defender)->set_special_data(tmp[i]->id, result[2]);
          }
          
          if(result[0] & R_ABORT)
            return result;

          // Done or continue we stop processing specials.
          // R_PASSTHRU means try the next special.
          if((result[0] & R_DONE) || (result[0] & R_CONTINUE))
            break;
        }
      }
    }
  }
  return result;
}

/**
 * This performs the actual attack itself.
 * All attack data, everything we know about the attacker and the defender
 * is stored in the attack class which is passed into and back by every
 * function at every step of the attack.
 */
void do_attack() {
  class tasker_result result;
  class attack att;
  mixed *sp_result;
  int modifier, tmp;

  // This is required since some people have the old tactics settings :(
  init_tactics();
  if(_callout)
    _callout = remove_call_out("announce_intent");

  att = new(class attack,
            attacker : this_object(),
            attacker_tactics : this_object()->query_tactics(),
            attacker_specials : this_object()->query_specials(),
            attacker_concentrating : this_object()->query_concentrating(),
            attacker_defecit : this_object()->query_action_defecit(),
            attacker_last_opponent : this_object()->query_last_opponent(),
            attacker_last_weapon : this_object()->query_last_weapon(),
            attacker_last_action : this_object()->query_last_action(),
            attacker_last_result : this_object()->query_last_result(),
            repeat : 0
            );

  // choose opponent
  sp_result = call_special(E_OPPONENT_SELECTION, att);
  if(!sp_result || sp_result[0] & R_CONTINUE || sp_result[0] & R_PASSTHRU)
    att = this_object()->choose_opponent(att);
  else if(!(sp_result[0] & R_ABORT) && classp(sp_result[1]))
    att = (class attack)sp_result[1];
  else
    return;

  if(!(att->opponent) || !(att->opponent)->attack_by(att->attacker)) {
    combat_debug("No opponent chosen, aborting attack");
    return;
  }


  event(environment(att->attacker), "fight_in_progress", att->opponent);
  clear_protection(att->attacker, att->opponent);
  _combat->last_opponent = att->opponent;
  
  // This loop causes us to allow a defender to defend and if the defender
  // fails & isn't the opponent the opponent also gets a chance to defend.
  do {
    // Now lets figure out who will do the defense, the person being attacked
    // or someone/thing that wants to defend them.
    sp_result = call_special(E_DEFENDER_SELECTION, att);
    if(!sp_result || sp_result[0] & R_CONTINUE || sp_result[0] & R_PASSTHRU)
      att = (att->opponent)->choose_defender(att);
    else if(!(sp_result[0] & R_ABORT) && classp(sp_result[1]))
      att = (class attack)sp_result[1];
    else
      return;

    att->defender_tactics = (att->defender)->query_tactics();
    att->defender_concentrating = (att->defender)->query_concentrating();
    att->defender_last_opponent = (att->defender)->query_last_opponent();
    att->defender_last_action = (att->defender)->query_last_action();
    att->defender_last_result = (att->defender)->query_last_result();
    att->defender_defecit = (att->defender)->query_action_defecit();
    att->defender_specials = (att->defender)->query_specials();

    clear_protection(att->attacker, att->defender);

    // get weapon and attack data
    sp_result = call_special(E_ATTACK_SELECTION, att);
    if(!sp_result || sp_result[0] & R_CONTINUE || sp_result[0] & R_PASSTHRU)
      att = this_object()->choose_attack(att);
    else if(!(sp_result[0] & R_ABORT) && classp(sp_result[1]))
      att = (class attack)sp_result[1];
    else
      return;

    if(!att->attack_weapon || !sizeof(att->attack_data) || !att->attack_skill){
      combat_debug("Missing attack weapon, attack data or attack skill, "
                   "aborting attack.");
      return;
    }

    // set the 'last' data.
    _combat->last_action = att->attack_data[AT_NAME];
    _combat->last_weapon = att->attack_weapon;

    // will opponent defend? If so determine defense skill & weapon.
    sp_result = call_special(E_DEFENSE_SELECTION, att);
    if(!sp_result || sp_result[0] & R_CONTINUE || sp_result[0] & R_PASSTHRU)
      att = (att->defender)->choose_defense(att);
    else if(!(sp_result[0] & R_ABORT) && classp(sp_result[1]))
      att = (class attack)sp_result[1];
    else
      return;

    // Set the 'last' data.
    (att->opponent)->set_last_opponent(att->attacker);
    if(att->opponent != att->defender)
      (att->defender)->set_last_opponent(att->attacker);
    (att->defender)->set_last_action(att->defense_action);
    (att->defender)->set_last_weapon(att->defense_weapon);
    if(att->person_hit != att->opponent && att->person_hit != att->defender)
      (att->person_hit)->set_last_opponent(att->attacker);
    
    // determine attack modifier
    sp_result = call_special(E_ATTACK_MODIFIER, att);
    if(!sp_result || sp_result[0] & R_CONTINUE || sp_result[0] & R_PASSTHRU) {
      att = this_object()->calc_attack_modifier(att);
    } else if(!(sp_result[0] & R_ABORT) && classp(sp_result[1])) {
      att = (class attack)sp_result[1];
    } else
      return;

    // determine defense modifier
    // If they aren't defending they just get a big fat minus.
    if(!att->defense_action || att->defense_action == "none")
      att->defense_modifier += -1000;
    else {
      sp_result = call_special(E_DEFENSE_MODIFIER, att);
      if(!sp_result || sp_result[0] & R_CONTINUE || sp_result[0] & R_PASSTHRU)
        att = (att->defender)->calc_defense_modifier(att);
      else if(!(sp_result[0] & R_ABORT) && classp(sp_result[1]))
        att = (class attack)sp_result[1];
      else
        return;
    }

    tmp = att->attack_modifier - att->defense_modifier + BALANCE_MOD;
    modifier = tmp;
    // This flattens the modifier out a bit preventing crazy modifiers
    // against extreme skills.
    if(modifier > 25)
      modifier = sqrt(modifier * 25);
    else if(modifier < -25)
      modifier = -sqrt(-modifier * 25);
    
    // compare_skills
    result = TASKER->compare_skills(att->attacker, att->attack_skill,
                                    att->defender, att->defense_skill,
                                    modifier,
                                    TM_CONTINUOUS, TM_CONTINUOUS, 1);
    att->result = result->result;
    att->degree = result->degree;

    // Set the last_result data.
    _combat->last_result = att->result;
    (att->defender)->set_last_result(att->result);

    // If they got hit while being defended then reduce the defenders actions
    // and let them defend themselves.
    if((att->result == OFFWIN || att->result == OFFAWARD) &&
       att->defender != att->opponent && !att->repeat) {
      // charge the defender
      (att->defender)->adjust_action_defecit(att->defense_cost);
      (att->defender)->adjust_gp(-(DEFENSE_GP[att->defender_tactics->attitude]));

      // mark them to defend themselves.
      att->defender = att->opponent;
      att->repeat = 1;
    } else
      att->repeat = 0;
    
  } while(att->repeat);

  // calculate damage
  sp_result = call_special(E_DAMAGE_CALCULATION, att);
  if(!sp_result || sp_result[0] & R_CONTINUE || sp_result[0] & R_PASSTHRU)
    att = this_object()->calc_damage(att);
  else if(!(sp_result[0] & R_ABORT) && classp(sp_result[1]))
    att = (class attack)sp_result[1];
  else
    return;

  // see how much damage was stopped by armour.
  sp_result = call_special(E_ARMOUR_CALCULATION, att);
  if(!sp_result || sp_result[0] & R_CONTINUE || sp_result[0] & R_PASSTHRU)
    att = (att->opponent)->calc_armour_protection(att);
  else if(!(sp_result[0] & R_ABORT) && classp(sp_result[1]))
    att = (class attack)sp_result[1];
  else
    return;

#if DEBUG == 1
  combat_debug("Outcome: mod: %d, res: %d, deg: %d dam: %d arm: %d",
               att->attack_modifier - att->defense_modifier + BALANCE_MOD,
               att->result, att->degree, att->damage, att->armour_stopped);
#endif

  // We'll only damage people if the attack succeeded.
  if(att->result == OFFWIN || att->result == OFFAWARD) {
    // and which armour stopped the attack.
    att->stopped_by = (att->person_hit)->query_stopped();

#if DEBUG == 2
    combat_debug("hit: %s, weapon: %s damage: %d, armour: %d, reducing hp by "
                 "%d to %d",
                 (att->person_hit)->query_name(),
                 (att->attack_weapon)->query_name(),
                 att->damage,
                 att->armour_stopped,
                 (att->damage - att->armour_stopped),
                 (att->person_hit)->query_hp());
#endif
  }

  // Prepare the offense/defense messages.
  att = this_object()->prepare_messages(att);
  if(sizeof(att->attack_messages) != 5 || sizeof(att->defense_messages) != 5) {
    debug_printf("No attack or defense messages.\n");
    return;
  }
    
  // Write out the offense/defense messages.
  sp_result = call_special(E_WRITE_MESSAGES, att);
  if(!sp_result || sp_result[0] & R_CONTINUE || sp_result[0] & R_PASSTHRU)
    att = this_object()->write_messages(att);
  else if(!(sp_result[0] & R_ABORT) && classp(sp_result[1]))
    att = (class attack)sp_result[1];
  else
    return;

  // Damage the person hit
  if(att->damage - att->armour_stopped > 0)
    (att->person_hit)->adjust_hp(-(att->damage - att->armour_stopped),
                                 att->attacker, att->attack_weapon,
                                 _combat->last_action);

  // damage the weapon.
  sp_result = call_special(E_WEAPON_DAMAGE, att);
  if(!sp_result || sp_result[0] & R_CONTINUE || sp_result[0] & R_PASSTHRU)
    att = this_object()->damage_weapon(att);
  else if(!(sp_result[0] & R_ABORT) && classp(sp_result[1]))
    att = (class attack)sp_result[1];
  else
    return;

  // Do post attack stuff.
  sp_result = call_special(E_AFTER_ATTACK, att);
  if(!sp_result || sp_result[0] & R_CONTINUE || sp_result[0] & R_PASSTHRU)
    att = this_object()->after_attack(att);
  else if(!(sp_result[0] & R_ABORT) && classp(sp_result[1]))
    att = (class attack)sp_result[1];
  else
    return;
}

/*
 * Figure out who should be in our attacker list and who should be in our
 * hunting list.
 */
void recalc_hunting_list() {
  mixed ob;
  object tmp;

  tmp = 0;
  foreach(ob in keys(_combat->attacker_list)) {
    if(stringp(ob) && find_player(ob))
      tmp = find_player(ob);
    else if(ob && objectp(ob))
      tmp = ob;

    if(!tmp) {
      // This removes the zeros left by dested objects.
      _combat->attacker_list = filter_mapping(_combat->attacker_list,(: $1 :));
    } else if(tmp->query_property("dead") ||
              !environment(tmp) ||
               base_name(environment(tmp)) == "/room/rubbish") {
      map_delete(_combat->attacker_list, ob);
    } else if(environment(tmp) != environment() ||
              !tmp->query_visible(this_object())) {
      // Add to hunting list, remove from attacker list.
      _combat->hunting_list[ob] = time();
      map_delete(_combat->attacker_list, ob);
    }
  }

  tmp = 0;
  foreach(ob in keys(_combat->hunting_list)) {
    if(stringp(ob) && find_player(ob))
      tmp = find_player(ob);
    else if(ob && objectp(ob))
      tmp = ob;

    if(!tmp) {
      // This removes the zeros left by dested objects.
      _combat->hunting_list = filter_mapping(_combat->hunting_list, (: $1 :));
      map_delete(_combat->hunting_list, ob);
    } else if(tmp->query_property("dead") ||
              base_name(environment(tmp)) == "/room/rubbish") {
      map_delete(_combat->hunting_list, ob);
    } else if(environment(tmp) == environment() &&
              tmp->query_visible(this_object())) {
      // If they are here and we can see them move them from the hunted
      // list to the attacker list.
      _combat->attacker_list[ob] = INITIAL_DISTANCE;
      map_delete(_combat->hunting_list, ob);
    } else if(_combat->hunting_list[ob] < time() - HUNTING_TIME) {
      // If we've been hunting them too long stop hunting them.
      this_object()->event_combat(this_object(), "You stop hunting " +
                                  tmp->one_short() + ".\n", ({ }), 1);
      map_delete(_combat->hunting_list, ob);
    }
  }
}

/**
 * Display the hitpoint monitor.
 */
void monitor_points() {
   int hp;
   int max;
   string colour;

#ifdef UNUSED
   this_object()->clear_gp_info();
   if ( (int)this_object()->adjust_gp( -1 ) < 0 )
     return;
#endif

   hp = (int)this_object()->query_hp();
   if(hp < 0)
     hp = 0;
   max = (int)this_object()->query_max_hp();
   switch ( ( hp * 100 ) / max) {
      case 50 .. 100 :
         colour = "%^GREEN%^";
         break;
      case 20 .. 49 :
         colour = "%^YELLOW%^";
         break;
      default :
         colour = "%^RED%^";
   }
   tell_object( this_object(), colour +"Hp: "+ hp +" (" + max + ") Gp: "+
         (int)this_object()->query_gp() +" (" + this_object()->query_max_gp() +
         ") Xp: " + this_object()->query_xp() + "%^RESET%^\n" );
}

/** @ignore yes */
void announce_intent(object opponent) {
  int difficulty = 50;
  object *things, ob;

  if(environment(opponent) != environment(this_object()))
    return;
  
  switch(this_object()->check_dark((int)environment(this_object())->query_light())) {
   case -2:
   case 2:
     difficulty *= 4;
     break;
   case -1:
   case 1:
     difficulty *= 2;
   }

   things = ({ });
   foreach(ob in filter(all_inventory(environment(this_object())),
                        (: $1 &&living($1) :))) {
     switch(TASKER->perform_task(ob, "other.perception", difficulty, TM_FREE)){
     case AWARD:
       tell_object(ob, "%^YELLOW%^You feel very perceptive."
                   "%^RESET%^\n");
     case SUCCEED:
       if(interactive(ob) && !ob->query_verbose("combat"))
         things += ({ ob });
       break;
     case FAIL:
       things += ({ ob });
     }
   }
   
   opponent->add_message((string)this_object()->one_short() +
                      " $V$0=moves,move$V$ aggressively towards you!\n",
                      ({ }));
   event(environment(opponent), "see", (string)this_object()->one_short() +
          " $V$0=moves,move$V$ aggressively towards "+
          (string)opponent->one_short() +"!\n", this_object(),
          ({ opponent, this_object() }) + things);
}

/**
 * This method is called when combat starts.  You can overload this function
 * to make your NPC do things at the start of combat.
 * You do not need to call ::start_combat() since this is just a stub function.
 *
 * @param opponent The first opponent to be attacked.
 */
void start_combat(object opponent) { return; }

/**
 * This method is called when combat ends.  You can overload this function
 * to make your NPC do things at the end of combat.
 * You do not need to call ::end_combat() since this is just a stub function.
 */
void end_combat() { return; }

/** @ignore yes */
void heart_beat() {
  int i;

  // are they in combat?
  if(!_combat->in_combat)
    return;

  recalc_hunting_list();

  if(!sizeof(keys(_combat->attacker_list)) &&
     !sizeof(keys(_combat->hunting_list))) {
    // Not in combat so remove any non-continuous specials.
    for(i=0; i<sizeof(_combat->specials); i++)
      if(!((_combat->specials[i])->type & T_CONTINUOUS))
        _combat->specials -= ({ (_combat->specials)[i] });

    // mark as not in combat
    _combat->in_combat = 0;
    adjust_action_defecit(-MAX_ACTION_DEFECIT);
    end_combat();
    return;
  }

  // Are they in a fit state to fight & do they have anyone to fight?
  if(!query_attackable() || !sizeof(keys(_combat->attacker_list)))
    return;

  // They get part of their combat actions here (assuming they aren't
  // trying to do something else as well) and part later.
  if((!userp(this_object()) ||
     this_object()->query_time_left() == ROUND_TIME) &&
     !this_object()->query_casting_spell()) {
    adjust_action_defecit(-(ACTIONS_PER_HB / (COMBAT_SPEED + 1)));
  }
  
  // Used to control combat speed, especially during testing.
  if(_combat->hbc++ % COMBAT_SPEED)
    return;
  _combat->hbc = 0;

  if(this_object()->query_monitor() &&
     this_object()->query_monitor() <= ++(_combat->mbc)) {
    monitor_points();
    _combat->mbc = 0;
  }

  do_attack();

  if(!this_object()->query_casting_spell()) {
    adjust_action_defecit(-(ACTIONS_PER_HB / (COMBAT_SPEED + 1)));

    // Give a bonus attack if they have no action defecit.
    if(_combat->action_defecit < (OFFENSIVE_DEFECITS[_tactics->attitude] / 2)) {
#if DEBUG == 1
      combat_debug("Adding bonus attack for %s", this_object()->query_name());
      debug_printf("Bonus attack for %s [%d, %d]",
                   this_object()->query_name(), _combat->action_defecit,
                   OFFENSIVE_DEFECITS[_tactics->attitude]);
#endif
      call_out("do_attack", 1);
    }
  }
}

/**
 * Register a combat special.
 *
 * The combat system maintains a list of combat specials. These specials can
 * be used to override or alter any facet of a combat attack (or defense).
 * <p>
 * A special must register what type of special it is:<br>
 * T_OFFENSIVE - an offensive special<br>
 * T_DEFENSIVE - a defensive special<br>
 * T_CONTINUOUS - can be used with one of the above to indicate that the
 *                special is continuous and not a one-time event.<br>
 * <p>
 * It also indicates which stages of combat it wants to be notified of:<br>
 * E_OPPONENT_SELECTION - selection of an opponent<br>
 * E_DEFENDER_SELECTION - selection of the defender<br>
 * E_ATTACK_SELECTION - selecting which attack the attacker will perform<br>
 * E_DEFENSE_SELECTION - selection of the method of defense<br>
 * E_ATTACK_MODIFIER - calculating the modifier for attack (how easy/hard it
 * is)<br>
 * E_DEFENSE_MODIFIER - doing the same for the defense<br>
 * E_DAMAGE_CALCULATION - calculating how much damage the attack can do<br>
 * E_ARMOUR_CALCULATION - calculating how much damage the armour will stop<br>
 * E_WEAPON_DAMAGE - performing damage to the weapons involved<br>
 * E_WRITE_MESSAGES - writing out the success/failure messages<br>
 * E_AFTER_ATTACK - any post-attack cleanup.<br>
 * <p>
 * The special provides the combat system with a callback function to be
 * called and any additional data the special wants tracked by the combat
 * system.
 * <p>
 * Then, when combat reaches one of the stages requested it calls the callback
 * function. This function is passed the stage we're at, all the data for this
 * attack and also the extra data the special requested.
 * <p>
 * The callback can then modify any aspect of the attack data (it could change
 * the attack skill, the defensive weapon, the defense modifier, anything at
 * all) and then return back into combat.
 * <p>
 * The return tells the combat system what to do next. The options are:<br>
 * R_CONTINUE - continue as though the special hadn't done anything.<br>
 * R_DONE - treat this step as completed.<br>
 * R_ABORT - abort the attack<br>
 * R_REMOVE_ME - do one of the above and then remove the special.
 * 
 * @param type Is this an offensive or defensive special.
 * @param events A bitmap of the events this special is interested in.
 * @param the function to be called. A mixed array containing an object & a
 * function string.
 * @return the id of the special.
 *
 * @example
 *
 * This example registers a special that causes the player to be unable to
 * defend themselves for three rounds.
 *
 * id = player->register_special(T_DEFENSIVE | T_CONTINUOUS,
 *                               E_DEFENSE_SELECTION | E_DAMAGE_CALCULATION,
 *                               ({ base_name(this_object()), "callback" }),
 *                               ({ player, 0}));
 *
 * mixed *callback(int stage, class attack att, mixed data) {
 *   // If it's not our player defending we won't do anything.
 *   if(att->defender != data[1])
 *     return ({ R_CONTINUE, att, data });
 *
 *    switch(stage) {
 *    case E_DEFENSE_SELECTION: // We won't let them defend themselves!
 *      att->defense_action = "none";
 *      return ({ R_DONE, att, data });
 *    case E_DAMAGE_CALCULATION:
 *      // If they managed to defend themself, turn it into a failure.
 *      if(att->result == DEFWIN || att->result == DEFAWARD)
 *        att->result = OFFWIN;
 *
 *      // By using R_CONTINUE they take 500 hits _plus_ the normal damage.
 *      att->damage = 500;
 *
 *      // The R_REMOVE_ME causes our special to disappear once we've hurt
 *      // them three times.
 *      if(data[1] > 3)
 *        return ({ R_CONTINUE & R_REMOVE_ME, att, data });
 *
 *      data[1]++;
 *      return ({ R_CONTINUE, att, data });
 *    }
 * }
 */
int register_special(int type, int events, mixed callback, mixed data) {
  _combat->specials += ({ new(class combat_special,
                              id : ++(_combat->special_id),
                              type : type,
                              events : events,
                              callback : callback,
                              data : data) });
  return _combat->special_id;
}

/**
 * Remove a combat special.
 *
 * @param id The id of the special
 * @return 1 for success, 0 for failure
 */
int remove_special(int id) {
  int i;

  for(i=0; i<sizeof(_combat->specials); i++) {
    if((_combat->specials[i])->id == id) {
      _combat->specials -= ({ (_combat->specials)[i] });
      return 1;
    }
  }

  debug_printf("Failed to remove special %d", id);
  return 0;
}

/**
 * List the specials currently registered for this npc/player.
 * @return an array of comba_special classes.
 */
class combat_special *query_specials() {
  return copy(_combat->specials);
}

/**
 * Directly set the special list. Use with care!
 * @param class combat_special *
 */
void set_specials(class combat_special *specials) {
  _combat->specials = specials;
}

/**
 * Update the user data for a specific special.
 * @param id The id of the special
 * @param data The data to be set
 * @return True or false for success or failure
 */
int set_special_data(int id, mixed data) {
  int i;

  for(i=0; i<sizeof(_combat->specials); i++) {
    if((_combat->specials[i])->id == id) {
      _combat->specials[i]->data = data;
      return 1;
    }
  }

  return 0;
}

void adjust_action_defecit(int amount) {
  _combat->action_defecit += amount;
  if(_combat->action_defecit > MAX_ACTION_DEFECIT)
    _combat->action_defecit = MAX_ACTION_DEFECIT;
  else if(_combat->action_defecit < MIN_ACTION_DEFECIT)
    _combat->action_defecit = MIN_ACTION_DEFECIT;
}

int query_action_defecit() { return _combat->action_defecit; }

/**
 * This method returns the current tactics set using the tactics class.
 * @see set_tactics()
 * @index tactics
 */
class tactics query_tactics() {
  init_tactics();
  return copy(_tactics);
}

/**
 * This sets the current attitude to use in combat.
 * @param attitude the new combat attitude
 * @see query_tactics()
 */
void set_tactics(class tactics new_tactics) { _tactics = new_tactics; }

string query_combat_attitude() { return _tactics->attitude; }
void set_combat_attitude(string attitude) { _tactics->attitude = attitude; }
string query_combat_response() { return _tactics->response; }
void set_combat_response(string response) { _tactics->response = response; }
string query_combat_attack() { return _tactics->attack; }
void set_combat_attack(string attack) { _tactics->attack = attack; }
string query_combat_parry() { return _tactics->parry; }
void set_combat_parry(string parry) { _tactics->parry = parry; }
int query_unarmed_parry() { return _tactics->parry_unarmed; }
void set_unarmed_parry(int parry) {  _tactics->parry_unarmed = parry; }
string query_combat_mercy() { return _tactics->mercy; }
void set_combat_mercy(string mercy) { _tactics->mercy = mercy; }
string query_combat_focus() { return _tactics->focus_zone; }
void set_combat_focus(string focus) { _tactics->focus_zone = focus; }
string query_combat_distance() { return _tactics->ideal_distance; }
void set_combat_distance(string distance) { _tactics->ideal_distance = distance; }

/**
 * This method returns the current array of protectors on the living
 * object.  This is the people who are protecting us, so if we are hit
 * make them attack the hitter.
 * @return the current protectors array
 * @see add_protector()
 * @see remove_protector()
 */
object *query_protectors() {
  _combat->protectors -= ({ 0 });
   return copy(_combat->protectors + ({ }));
}

/**
 * This method will add a protector to the current list of protectors
 * for this living object.
 * @param thing the protector to add
 * @see remove_protector()
 * @see query_protectors()
 */
int add_protector( object thing ) {
  if(thing == this_object() ||
     thing->query_property("dead") ||
     member_array(this_object(), thing->query_protectors() +
                  thing->query_defenders()) != -1 ||
     member_array(thing, query_attacker_list())  != -1)
    return 0;
  
  if(member_array(thing, _combat->protectors) == -1)
    _combat->protectors += ({ thing });
  return 1;
}

/**
 * This method will remove a protector to the current list of protectors
 * for this living object.
 * @param thing the protector to remove
 * @return 1 for success, 0 for failure.
 *
 * @see add_protector()
 * @see query_protectors()
 */
int remove_protector(object protector) {
  if(member_array(protector, _combat->protectors) == -1)
    return 0;
  _combat->protectors -= ({ protector });
  return 1;
}

/**
 * This method resets the protector array back to being nothing.
 */
void reset_protectors() {
  _combat->protectors = ({ });
}

/**
 * This method returns the current array of defenders on the living
 * object.  This is the people who are protecting us, so if we are hit
 * make them attack the hitter.
 * @return the current defenders array
 * @see add_protector()
 * @see remove_protector()
 */
object *query_defenders() {
  _combat->defenders -= ({ 0 });
   return copy(_combat->defenders + ({ }));
}

/**
 * This method will add a defender to the current list of defenders
 * for this living object.
 * @param thing the defender to add
 * @see remove_defender()
 * @see query_defenders()
 */
int add_defender( object thing ) {
  if(thing == this_object() ||
     thing->query_property("dead") ||
     member_array(this_object(), thing->query_defenders() +
                  thing->query_protectors()) != -1 ||
     member_array(thing, query_attacker_list())  != -1)
    return 0;

  if(member_array(thing, _combat->defenders) == -1)
    _combat->defenders += ({ thing });
  return 1;
}

/**
 * This method will remove a defender to the current list of defenders
 * for this living object.
 * @param thing the defender to remove
 * @return 1 for success, 0 for failure.
 *
 * @see add_defender()
 * @see query_defenders()
 */
int remove_defender(object defender) {
  if(member_array(defender, _combat->defenders) == -1)
    return 0;
  _combat->defenders -= ({ defender });
  return 1;
}

/**
 * This method resets the defender array back to being nothing.
 */
void reset_defenders() {
  _combat->defenders = ({ });
}

#ifdef USE_DISTANCE
/**
 * Set the distance from this object to the given opponent.
 *
 * @param opponent the object to set the distance to.
 * @param distance the new distance.
 */
int set_distance(object opponent, int distance) {
  if(userp(opponent)) {
    if(!_combat->attacker_list[opponent->query_name()])
      return 0;
    _combat->attacker_list[opponent->query_name()] = distance;
  } else {
    if(!_combat->attacker_list[opponent])
      return 0;
    _combat->attacker_list[opponent] = distance;
  }

  return 1;
}

/**
 * Query the distance from this object to the given opponent.
 *
 * @param opponent the object to check
 */
int query_distance(object opponent) {
  if(userp(opponent)) {
    if(!_combat->attacker_list[opponent->query_name()])
      return 0;
    return _combat->attacker_list[opponent->query_name()];
  } else {
    if(!_combat->attacker_list[opponent])
      return 0;
    return _combat->attacker_list[opponent];
  }
}
#endif

/**
 * This method returns the current list of people in the attacker list
 * on the object.
 * @return the current attacker array
 */
object *query_attacker_list() {
  return uniq_array(map(keys(_combat->attacker_list) +
                        keys(_combat->hunting_list),
                        (: $1 && objectp($1) ? $1 : find_player($1) :)) -
                    ({ 0 }));
}

/**
 * This method removes someone from an attacker/hunting list.
 * @param ob the object to be removed.
 */
void remove_attacker_list(object ob) {
  if(userp(ob)) {
    map_delete(_combat->attacker_list, ob->query_name());
    map_delete(_combat->hunting_list, ob->query_name());
  } else {
    map_delete(_combat->attacker_list, ob);
    map_delete(_combat->hunting_list, ob);
  }
}

/**
 * This method is called when the living object is attacked by some opponent.
 * @param opponent the opponent we are attacked by
 * @return 0 if we cannot attack them, 1 if we can
 * @see query_attacker_list()
 * @see attack_ob()
 */
int attack_by(object opponent) {
  int starting;

  if(!objectp(opponent) ||
     opponent == this_object() ||
     !this_object()->query_attackable() ||
     pk_check(this_object(), opponent))
    return 0;

  // We'll stop protecting them when they attack us.
  if(member_array(opponent, _combat->protectors) != -1)
    _combat->protectors -= ({ opponent });
  if(member_array(opponent, _combat->defenders) != -1)
    _combat->defenders -= ({ opponent });

  if(!sizeof(query_attacker_list()))
    starting = 1;
  
#ifdef USE_DISTANCE
  if(userp(opponent)) {
    if(!_combat->attacker_list[opponent->query_name()])
      _combat->attacker_list[opponent->query_name()] =
        opponent->query_distance(this_object());
  } else if(!_combat->attacker_list[opponent])
    _combat->attacker_list[opponent] = opponent->query_distance(this_object());
#else
  if(userp(opponent)) {
    if(!_combat->attacker_list[opponent->query_name()])
      _combat->attacker_list[opponent->query_name()] = 1;
  } else if(!_combat->attacker_list[opponent])
    _combat->attacker_list[opponent] = 1;
#endif

  if(starting) {
    _combat->action_defecit = (MAX_ACTION_DEFECIT - MIN_ACTION_DEFECIT) / 3;
    start_combat(opponent);
  }

  _combat->in_combat = 1;

  return 1;
}

/**
 * This method is called to make us attack someone else.
 * @param opponent the person to attack
 * @return 0 if we cannot attack them, 1 if we can
 * @see query_attacker_list()
 * @see attack_by()
 */
int attack_ob(object opponent) {
  int starting, new_opponent;

  if(!objectp(opponent) ||
     opponent == this_object() ||
     !opponent->query_attackable() ||
     !this_object()->query_attackable() ||
     pk_check(this_object(), opponent))
    return 0;

  // They stop protecting you when you attack them.
  if(member_array(opponent, _combat->protectors) != -1)
    _combat->protectors -= ({ opponent });
  if(member_array(opponent, _combat->defenders) != -1)
    _combat->defenders -= ({ opponent });

  if(!sizeof(query_attacker_list()))
    starting = 1;
  else if(member_array(opponent, query_attacker_list()) == -1)
    new_opponent = 1;
  
#ifdef USE_DISTANCE
  if(userp(opponent)) {
    if(!_combat->attacker_list[opponent->query_name()])
      _combat->attacker_list[opponent->query_name()] = INITIAL_DISTANCE;
  } else {
    if(!_combat->attacker_list[opponent])
      _combat->attacker_list[opponent] = INITIAL_DISTANCE;
  }
#else
  if(userp(opponent)) {
    if(!_combat->attacker_list[opponent->query_name()])
      _combat->attacker_list[opponent->query_name()] = 1;
  } else {
    if(!_combat->attacker_list[opponent])
      _combat->attacker_list[opponent] = 1;
  }
#endif
  if((new_opponent || starting) && 
     opponent->query_visible(this_object()))
    _callout = call_out("announce_intent", 0, opponent);

  this_object()->remove_hide_invis("hiding");

  if(starting) {
    _combat->action_defecit = (MAX_ACTION_DEFECIT - MIN_ACTION_DEFECIT) / 3;
    start_combat(opponent);
  }

  _combat->in_combat = 1;

  return 1;
}

void stop_fight(object opponent) {
  class combat_special tmp;
#if DEBUG == 2
  combat_debug("stop_fight called against %s", opponent->query_name());
#endif

  if(!objectp(opponent))
    return;

  if(userp(opponent)) {
    map_delete(_combat->attacker_list, opponent->query_name());
    map_delete(_combat->hunting_list, opponent->query_name());
  } else {
    map_delete(_combat->attacker_list, opponent);
    map_delete(_combat->hunting_list, opponent);
  }

#ifdef USE_SURRENDER
  _surrender->from -= ({ 0, opponent });
  _surrender->refusers -= ({ 0, opponent });
  _surrender->to -= ({ 0, opponent });
#endif

  if(!sizeof(query_attacker_list())) {
    // Not in combat so remove any non-continuous specials.
    foreach(tmp in _combat->specials)
      if(!(tmp->type & T_CONTINUOUS))
        remove_special(tmp->id);

    end_combat();
  }
}

void stop_all_fight() {
  class combat_special tmp;

#if DEBUG == 2
  combat_debug("stop_all_fight called");
#endif

  _combat->attacker_list = ([ ]);
  _combat->hunting_list = ([ ]);
  _combat->in_combat = 0;

#ifdef USE_SURRENDER  _surrender->from = ({ });
  _surrender->refusers = ({ });
  _surrender->to = ({ });
#endif

  // Not in combat so remove any non-continuous specials.
  foreach(tmp in _combat->specials)
    if(!(tmp->type & T_CONTINUOUS))
      remove_special(tmp->id);

  end_combat();
}

void stop_hunting(object opponent) {
  if(userp(opponent))
    map_delete(_combat->hunting_list, opponent->query_name());
  else
    map_delete(_combat->hunting_list, opponent);

  if(!sizeof(query_attacker_list()))
    end_combat();
}

#ifdef USE_SURRENDER
/**
 * This method will be called when we surrender.  This does mean that
 * the opponent must have accepted our surrender plea.
 * @return always returns 0
 * @param thing the thing which made us surrender
 */
object do_surrender(object thing) {
   mixed *attackers;
   mixed att;

   if(this_object()->query_property("dead"))
      return 0;

   death_helper(thing, 0);

   catch(DEATH->someone_surrendered(this_object()));
   attackers = query_attacker_list();
   foreach(att in attackers) {
     att->stop_fight(this_object());
   }
   stop_all_fight();

   return 0;
}

int dont_attack_me() {
  if(sizeof(_surrender->to))
    return 1;
  else
    return 0;
}

/**
 * This method tells us what the npc shouuld do in the case that it
 * might possibly surrender.
 * @param victim the person surrendering
 * @param attacker the person beating up the surrenderer
 */
void event_surrender(object victim, object *attackers) {
  object *offer;

  offer = ({ });
  if (this_object() == victim) {
    _surrender->refusers -= ({ 0 });
    _surrender->to -= ({ 0 });
    offer = filter(attackers, (: member_array($1, _surrender->refusers +
                                              _surrender->to) == -1 :));
    if(sizeof(offer)) {
      event(environment(), "combat",
            sprintf("%s kneels down and surrenders to %s.\n",
                    this_object()->one_short(), query_multiple_short(offer)),
            ({ this_object() }) + _surrender->to + _surrender->refusers, 0);

      this_object()->event_combat(this_object(),
                                sprintf("%s kneel down and surrender to %s.\n",
                                        this_object()->one_short(),
                                        query_multiple_short(offer)), ({ }), 0);
      offer->offered_surrender(victim);
      _surrender->to += offer;
    }
  }
}

/**
 * This method returns the current list of people surrendering to us.
 * @return the list of people surrendering
 * @see remove_surrenderer()
 */
object *query_surrenderers() {
  _surrender->from -= ({ 0 });
  return copy(_surrender->from);
}

/**
 * This method removes a person surrendering from our current list.
 * @param victim the person to remove
 * @see query_surrenderers()
 */
void remove_surrenderer(object victim) {
  _surrender->from -= ({ 0, victim });
  return;
}

/**
 * This method is called when someone offers to surrender to the living
 * object.  It will check the current tactics for surrender and then
 * handle the response appropriately.
 * @param victim the person surrendering
 */
void offered_surrender(object victim) {
  string mercy = this_object()->query_combat_mercy();

  switch(mercy) {
  case "ask":
    if (interactive(this_object())) {
      _surrender->from -= ({ 0, victim });
      _surrender->from += ({ victim });
      this_object()->event_combat(this_object(),
                                  victim->one_short() + " has surrendered to "
                                  "you.  Either \"accept " +
                                  victim->query_name() + "\" or \"reject " +
                                  victim->query_name() + ".\n", ({ }), 0);
    } else {
      if (this_object()->query_accept_surrender(victim))
        victim->accepted_surrender(this_object());
      else
        victim->refused_surrender(this_object());
    }
    break;
  case "always":
    this_object()->event_combat(this_object(),
                                "You accept the surrender of " +
                                victim->one_short() + ".\n", ({ }), 0);
    victim->accepted_surrender(this_object());
    break;
  default:
    this_object()->event_combat(this_object(),
                                sprintf("You refuse the surrender of %s.\n",
                                        victim->one_short()), ({ }), 0);
    victim->refused_surrender(this_object());
  }
}

/**
 * This method is called if surrender was refused for the particular
 * person.
 * @param attacker the person who is surrendering
 * @see accepted_surrender()
 */
void refused_surrender(object attacker) {
  _surrender->to -= ({ 0 });
  if (member_array(attacker, _surrender->to) == -1)
    return;
  _surrender->to -= ({ attacker });
  _surrender->refusers -= ({ 0 });
  _surrender->refusers += ({ attacker });

  this_object()->event_combat(this_object(), attacker->one_short() +
                              " refused your surrender\n", ({ }), 0);
}

/**
 * This method is called if surrender was accepted for the particular
 * person.
 * @param attacker the person who is surrendering
 * @see refused_surrender()
 */
void accepted_surrender(object attacker) {
  _surrender->to -= ({ 0 });
  if(member_array(attacker, _surrender->to) == -1) {
    return;
  }
  _surrender->to -= ({ attacker });

  this_object()->event_combat(this_object(), attacker->one_short() +
                              " accepts your surrender.\n", ({ }));
  this_object()->do_surrender(attacker);
}
#endif

/**
 * This method is called when the fight has stopped.  It propogates the
 * stopped fighting event onto all the objects in the room.
 * @param thing the thing which stopped fighting?
 */
void stopped_fighting(object thing) {
  event( environment(), "stopped_fighting", thing );
}

/**
 * This method is called when there is a fight in progress.  It will
 * propogate the event onto all the objects in the room.
 * @param thing the person fighting
 */
void fight_in_progress(object thing) {
  event(environment(), "fight_in_progress", thing );
}

/* Stuff from the old combat shadow */
int set_concentrating(object thing) {
  if(userp(thing)) {
    if(!_combat->attacker_list[thing->query_name()])
      return 0;
#ifdef USE_DISTANCE
    _combat->attacker_list[thing->query_name()] =
      thing->query_distance(this_object());
#else
    _combat->attacker_list[thing->query_name()] = 1;
#endif
  } else {
    if(!_combat->attacker_list[thing])
      return 0;
#ifdef USE_DISTANCE
    _combat->attacker_list[thing] = thing->query_distance(this_object());
#else
    _combat->attacker_list[thing] = 1;
#endif
  }
  _combat->concentrating = thing;

  return 1;
}

object query_concentrating() {
  object thing;

  thing = _combat->concentrating;
  if(!thing || !objectp(thing))
    return 0;

  if(userp(thing) && !_combat->attacker_list[thing->query_name()])
    return 0;
  else if(!_combat->attacker_list[thing])
    return 0;

  return thing;
}

/** @ignore yes
 * This is here for backward compatibility only.  Use query_last_opponent.
 */
object query_attacker() {
  return _combat->last_opponent;
}

/**
 * This method returns the last known opponent we attacked or defended
 * against.  It is kept as up to date as the system can manage and so will
 * include anyone who is currently attacking us or who we are currently
 * attacking.
 *
 * @return object the opponent.
 */
object query_last_opponent() {
  return _combat->last_opponent;
}

/** @ignore yes
 * This is _internal_ to the combat system and should not be used doing so
 * may have odd side-effects.
 */
void set_last_opponent(object last) { _combat->last_opponent = last; }

/**
 * This method returns the last weapon we used for an attack or defense.
 *
 * @return object the weapon.
 */
object query_last_weapon() {
  return _combat->last_weapon;
}

/** @ignore yes
 * This is _internal_ to the combat system and should not be used doing so
 * may have odd side-effects.
 */
void set_last_weapon(object last) { _combat->last_weapon = last; }

/**
 * This method returns the last (combat) action performed.
 *
 * @return string the action.
 */
string query_last_action() { return _combat->last_action; }

/** @ignore yes
 * This is _internal_ to the combat system and should not be used doing so
 * may have odd side-effects.
 */
void set_last_action(string last) { _combat->last_action = last; }

/**
 * This method returns the result of the last combat round.
 *
 * @return int the result.
 */
int query_last_result() { return _combat->last_result; }

/** @ignore yes
 * This is _internal_ to the combat system and should not be used doing so
 * may have odd side-effects.
 */
void set_last_result(int last) { _combat->last_result = last; }

/**
 * This method determines whether or not the object is fighting another
 * object.
 * @param ob the object being tested
 * @param actively is the opponent being actively fought at this time?
 * @return 1 if it is in combat, 0 if it is not.
 */
varargs int is_fighting(object ob, int actively) {
  
  if(!objectp(ob))
    return 0;

  // Only return those things we are actively fighting right now. Things
  // we're hunting or cannot see are excluded.
  if(actively)
    return userp(ob) ? _combat->attacker_list[ob->query_name()] :
      _combat->attacker_list[ob];
    
  return userp(ob) ? _combat->attacker_list[ob->query_name()] ||
    _combat->hunting_list[ob->query_name()] :
    _combat->attacker_list[ob] || _combat->hunting_list[ob];
}

/**
 * Is the player currently fighting anyone.
 *
 * @return 1 for yes, 0 for no.
 */
int query_fighting() {
  if(!environment() || base_name(environment()) == "/room/rubbish")
    return 0;
  
  // Are any of our opponents here? If so we're fighting.
  if(sizeof(filter(query_attacker_list(),
                   (: environment($1) == environment(this_object()) :))))
    return 1;
  
  // Are any of the people here fighting us? If so we're fighting
  if(sizeof(filter(all_inventory(environment(this_object())),
                   (: $1 && living($1) && $1->is_fighting(this_object(), 1) :))))
    return 1;
  
  return 0;
}

/** @ignore yes */
mixed stats() {
  int i;
  int j;
  object *weapons;
  mixed ret;

  init_tactics();

  ret = ({
    ({ "attitude", _tactics->attitude }),
      ({ "response", _tactics->response }),
      ({ "mercy", _tactics->mercy }),
      ({ "parry", _tactics->parry }),
      ({ "attack", _tactics->attack }),
      ({ "unarmed parry", ({ "no", "yes" })[ _tactics->parry_unarmed ] }),
      ({ "attack zone", _tactics->focus_zone ? _tactics->focus_zone :
        "none" }),
      ({ "distance", _tactics->ideal_distance ? _tactics->ideal_distance :
        "none" }),
      
      });
  weapons = (object *)this_object()->query_weapons();
  if(!sizeof(weapons))
    return ret + weapon_logic::stats();

  for ( i = 0; i < sizeof( weapons ); i++ )
    ret += ({ ({ "weapon #"+ i, weapons[ i ]->short() }) }) +
      (mixed)weapons[ j ]->weapon_stats();

  return ret + weapon_logic::stats();
}
// --- END [/mnt/home2/grok/lib/std/living/combat.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/living/effects.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/living/effects.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628860   Available: 13576214
Inodes: Total: 5242880    Free: 4960135
457 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/living/effects.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628860   Available: 13576214
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: effects.c,v 1.3 2001/03/09 01:07:54 pinkfish Exp $
 * $Log: effects.c,v $
 * Revision 1.3  2001/03/09 01:07:54  pinkfish
 * Stuff.
 *
 * Revision 1.2  1998/03/28 18:35:10  pinkfish
 * Added coumentaiton
 *
 * Revision 1.1  1998/01/06 04:29:08  ceres
 * Initial revision
 * 
 */
/**
 * This file contains all the npcs specific effect code.
 * @author Ember
 */
#include <effect.h>

inherit "/std/basic/effects";
// --- END [/mnt/home2/grok/lib/std/living/effects.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/living/force.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/living/force.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628860   Available: 13576214
Inodes: Total: 5242880    Free: 4960135
4882 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/living/force.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628860   Available: 13576214
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: force.c,v 1.4 1999/12/13 04:13:54 taffyd Exp $
 * $Log: force.c,v $
 * Revision 1.4  1999/12/13 04:13:54  taffyd
 * Fixed up the force check.
 *
 * Revision 1.3  1998/08/31 11:00:05  terano
 * Fixed a runtime and made parts of it a bit nicer :)
 *
 * Revision 1.2  1998/08/28 04:51:15  pinkfish
 * Make the force stuff use add_command and the new defines in player.h
 *
 * Revision 1.1  1998/01/06 04:29:08  ceres
 * Initial revision
 * 
*/
/**
 * This file contains the code to handle forcing.  
 * The method used will be to ask the object to
 * do the command.  While this is similar to the original method of doing this
 * it will be used to be more in the style of asking things to do things,
 * rather than the making things do things without asking them first.
 * @author Furball
 */

#include <player.h>

#define FORCE_COST 1
#define ILLEGAL_FORCE ({ "alias", "unalias", "mv", "mkdir", "call", "rm", \
                         "force", "kill", "gauge", "exec", "promote", \
                         "new_domain", "rmdir", "cd", "history", "echoall", \
                         "shout" })

nosave string fname;
nosave int no_force_me;

protected int no_force(string str);
protected int do_force(object *obs, string str);

/**
 * These are the commands which will allow people to force others.
 * @see no_force()
 * @see do_force()
 */
void force_commands() {
  fname = base_name(this_object());
  if ((!this_object()->query_property("npc") &&
      master()->query_senior( geteuid(this_object()) ) ) || fname == LORD_OB) {
    add_command("force", "<indirect:distant-living> <string'command'>",
                (: do_force($1, $4[1]) :));
 }
  if (fname == LORD_OB) {
    add_command("noforce", "{on|off}", (: no_force($4[0]) :));
    add_command("noforce", "", (: no_force(0) :));
  }
} /* force_commands() */

/**
 * This method is used to set the ability to let yourself be forced on and
 * off.
 * @param str the string which is on, off or 0
 * @see force_commands()
 */
protected int no_force(string str) {
  if (str == "on") {
    no_force_me = 1;
    write("Ok, forcing you disabled.\n");
    return 1;
  }
  if (str == "off") {
    no_force_me = 0;
    write("Ok, forcing you enabled.\n");
    return 1;
  }
  write("Forcing you is currently ");
  if (no_force_me) {
    write("disabled.\n");
  }
  else {
    write("enabled.\n");
  }
  return 1;
} /* no_force() */

/**
 * This is the function which forces another player to do something.
 * @see do_force_on_me()
 * @see force_commands()
 */
protected int do_force(object *obs, string str) {
  object ob;

#ifdef PLAYERS_CAN_FORCE
  if (fname == PLAYER_OB && !this_player()->query_property("force")) {
    notify_fail("You do not have the ability to do that yet.\n");
    return 0;
  }
  if (this_player()->adjust_social_points(-FORCE_COST) < 0) {
    notify_fail("Insufficient social points.\n");
    return 0;
  }
#endif

  foreach( ob in obs ) {
    if(!ob->do_force_on_me( str )) {
      write(capitalize( ob->query_name() ) + " didn't want to do that.\n");
    }
  }
  write("Ok.\n");
  return 1;
} /* do_force() */

/**
 * This is the method called to do the actual force.
 * @param str the string to force us to do
 * @see do_force()
 */
nomask int do_force_on_me(string str) {
  string temp1, temp2;
  object forcer;

  forcer = this_player(1);
  if (!forcer || (this_player() != previous_object())) {
    if (interactive(previous_object())) {
      forcer = previous_object();
    } else {
      log_file("FORCE", "Attempted illegal force from "+ 
               file_name(previous_object())+"\n");
      return 0;
    }
  }

  log_file("FORCE", ctime(time()) + " " + forcer->query_name() + " " +
                    this_object()->query_name() + " : " + str);
  tell_object(this_object(), forcer->query_cap_name() +
        " tries to force you to " + str + "\n");
  if (no_force_me || (string)this_object()->query_name() == "pinkfish") {
    event(users(), "inform", forcer->query_cap_name()+" forces "+
          this_object()->query_name()+" to "+str+" (failed)", "force");
    log_file("FORCE", " (failed)\n");
    return 0;
  }
  if (sscanf(str, "%s %s", temp1, temp2) != 2) {
    temp1 = str;
  }
  /* Delete this at your own peril */
  if (member_array(temp1, ILLEGAL_FORCE) != -1 &&
      !master()->high_programmer(geteuid(forcer))) {
    event(users(), "inform", forcer->query_cap_name()+" forces "+
          this_object()->query_name()+" to "+str+" (failed)", "force");
    log_file("FORCE", " (failed)\n");
    return 0;
  }
  if (function_exists("eventForce", this_object())) {
    command(str);
  } else {
    this_object()->eventForce(str);
  }
  event(users(), "inform", forcer->query_cap_name()+" forces "+
        this_object()->query_name()+" to "+str, "force");
  log_file("FORCE", " (succeeded)\n");
  return 1;
} /* do_force_on_me() */
// --- END [/mnt/home2/grok/lib/std/living/force.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/living/stats.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/living/stats.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628858   Available: 13576212
Inodes: Total: 5242880    Free: 4960135
15473 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/living/stats.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628858   Available: 13576212
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: stats.c,v 1.18 2003/05/06 17:27:47 pinkfish Exp $
 * $Log: stats.c,v $
 * Revision 1.18  2003/05/06 17:27:47  pinkfish
 * Update to allow 0 gp_inc values.
 *
 * Revision 1.17  2003/04/04 03:52:40  ceres
 * Forcibly released due to inactivity
 *
 * Revision 1.16  2002/09/02 08:07:30  ceres
 * Fixed to call do_burden_call() when tmp_str is altered
 *
 * Revision 1.15  2002/08/13 20:24:33  ceres
 * Fixed bug with negative hp regen rates
 *
 * Revision 1.14  2002/08/03 23:56:51  ceres
 * Got it wrong first time round
 *
 * Revision 1.12  2002/03/16 01:05:36  pinkfish
 * Fix up some things with undieing.
 *
 * Revision 1.11  2001/05/11 15:56:28  taffyd
 * Reworked heart_beat() again to support callingdeath to prevent NPCs dying improperly.
 *
 * Revision 1.10  2001/04/25 12:49:51  wodan
 * changed query_weight to match the calls to it
 *
 * Revision 1.9  2001/02/21 06:31:36  sin
 * Fixed the double-death AND the undead NPC bug
 *
 * Revision 1.8  2000/06/15 08:56:28  pinkfish
 * Fix up to use the config.
 *
 * Revision 1.7  2000/06/15 01:53:59  pinkfish
 * Add in some stuff for the distribution lib.
 *
 * Revision 1.6  2000/03/17 05:23:52  ceres
 * Recalculated burden when carrying capacity changes
 *
 * Revision 1.5  2000/03/09 03:20:35  ceres
 * Made hp regen rate work like gp regen rate (ie. using stat modify on appropriate skill)
 *
 * Ceres
 *
 * Revision 1.4  1999/04/14 01:32:35  ceres
 * Modified to handle weightless dead people
 *
 * Revision 1.3  1999/03/06 20:03:17  ceres
 * Made the bad npc log add the time.
 *
 * Revision 1.2  1998/08/10 10:07:44  pinkfish
 * Fix up to help non-guild players.
 *
 * Revision 1.1  1998/01/06 04:29:08  ceres
 * Initial revision
 * 
*/
/*
 * Module to handle con, dex, int, wis and str,
 *                  height and weight,
 *                  hit points and guild points,
 *                  carrying capacity.
 */
 
#include <move_failures.h>
#include <skills.h>
#include <living.h>
#include <config.h>

#define BASE 20
#define ORD1T 1
#define ORD1B 1
#define ORD2T 1
#define ORD2B 5
#define SCALING_DATA ({ 650, 150, 10, 5 })
#define DIVISOR 700

#define DEATH_WAIT_TIME 5

#define INIT_GP_INC -20

int Con, Dex, Int, Str, Wis,
    contmp, dextmp, inttmp, strtmp, wistmp,
    height, base_weight;
nosave int conbon, dexbon, intbon, strbon, wisbon, no_check;
nosave string to_zap;
nosave int gp_inc = INIT_GP_INC, hp_inc;  // increase rates for guild & hitpoints

mixed query_property(string name);

string stats_to_zap() {
   string temp;

   temp = to_zap;
   to_zap = 0;
   return temp;
} /* stats_to_zap() */

void zap_stat( string word ) {
   string dummy;
   
   if ( !to_zap ) {
      to_zap = word;
      if ( find_call_out( "zap_stat_cache" ) == -1 )
         call_out( "zap_stat_cache", 1 );
   }
   if ( sscanf( to_zap, "%s"+ word +"%s", dummy, dummy ) != 2 )
      to_zap += word;
} /* zap_stat() */

int query_no_check() { return no_check; }
void set_no_check( int i ) { no_check = i; }
 
int hp_base() {
  int base;
  base = 150 + 10 * (int)this_object()->query_con();
  if ( base < 5 ) base = 5;
  return base;
} /* hp_base() */
 
int hp_gradient() { return 4; }

int scaled_weight() {
  int i, actual, scaled;
  actual = (int)this_object()->query_weight(1);
  if ( actual < SCALING_DATA[ 0 ] )
    return actual;
  scaled += SCALING_DATA[ 0 ];
  actual -= SCALING_DATA[ 0 ];
  i = 1;
  while ( actual && ( ( i * SCALING_DATA[ 2 ] ) < 100 ) ) {
    if ( actual >= SCALING_DATA[ 1 ] ) {
      scaled += ( ( 100 - SCALING_DATA[ 2 ] * i ) * SCALING_DATA[ 1 ] )
          / 100;
      scaled += ( SCALING_DATA[ 3 ] * SCALING_DATA[ 1 ] ) / 1000;
      actual -= SCALING_DATA[ 1 ];
    } else {
      scaled += ( ( 100 - SCALING_DATA[ 2 ] * i ) * actual ) / 100;
      scaled += ( SCALING_DATA[ 3 ] * actual ) / 1000;
      actual = 0;
    }
    i += 1;
  }
  if ( actual )
    scaled += ( SCALING_DATA[ 3 ] * actual ) / 1000;
  return scaled;
} /* scaled_weight() */
 
void reset_hp() {
  int new_max, skill_bon;
  string report;

  if ( no_check )
    return;
  skill_bon = (int)this_object()->query_skill_bonus( "other.health" );
  new_max = hp_base() + skill_bon * hp_gradient();
  if ( !base_weight ) {
    if ( (string)this_object()->query_name() == "object" )
      return;
    report = file_name( this_object() ) +" ("+
        (string)this_object()->query_name() +"): race object is "+
        (string)this_object()->query_race_ob();
    if ( environment() ) {
      if ( file_name( environment() ) == "/room/void" )
        return;
      report += "; in "+ file_name( environment() );
      this_object()->move( "/room/void", "$N gets booted into the void for "+
          "being a bad NPC." );
    }
    report += ".\n";
    log_file( "BAD_NPC", ctime(time()) + " " + report );
    return;
  }
   new_max = ( new_max * scaled_weight() ) / DIVISOR;
   if ( new_max < 1 )
      this_object()->set_max_hp( 1 );
   else
      this_object()->set_max_hp( new_max );
} /* reset_hp() */
 
void reset_gp() {
   string guild_ob;

   if ( no_check )
      return;
   guild_ob = (string)this_object()->query_guild_ob();
   if (!guild_ob) {
      guild_ob = query_property("backup guild");
   }
   if ( !guild_ob ) {
      this_object()->set_max_gp( 50 +
            (int)this_object()->query_skill_bonus( "other.points" ) );
   } else {
      guild_ob->set_gp( this_object() );
   }
} /* reset_gp() */

void calc_inc_rates() {
   string guild_ob;

   hp_inc = sqrt((int)this_object()->stat_modify(100, "other.health")) - 7;

   guild_ob = (string)this_object()->query_guild_ob();
   if ( !guild_ob ) {
     guild_ob = query_property("backup guild");
     if (!guild_ob) {
       guild_ob = CONFIG_DEFAULT_GUILD;
     }
   }
   /* Believe it or not, this works... See the comment in the skills module. */
   gp_inc = sqrt((int)this_object()->stat_modify(100,
         (string)guild_ob->query_gp_skill())) - 7;
   // The inc cannot be less than 0.
   if(hp_inc < 0) {
     hp_inc = 0;
   }
   if(gp_inc < 0) {
     gp_inc = 0;
   }
} /* calc_inc_rates() */

int *query_inc_rates() { return ({ gp_inc, hp_inc }); }

void heart_beat() {
   int hp;
   int calling_death; 

   hp = this_object()->query_hp();

   if ( hp < 0 ) { 
       calling_death = this_object()->query_callingdeath();

        if ( calling_death ) { 

           // Oops.. if for some reason query_callingdeath() was set to 
           // true.. it means that the do_death() callout has been lost 
           // somehow.
           //
           // So let's die now instead.
           
           // tell_creator( "taffyd", "In do_death()\n" );

           if ( time() > calling_death + DEATH_WAIT_TIME ) { 
                // tell_creator( "taffyd", "DEATH_WAIT triggered\n" );
                this_object()->do_death();
            }
        } else {
            this_object()->do_death();
        }
   }
   else { 
      if ( gp_inc == INIT_GP_INC ) { 
         calc_inc_rates();
      }

      this_object()->adjust_gp( gp_inc );
      this_object()->adjust_hp( hp_inc );
   }
} /* heart_beat() */

void reset_carry_cap() {
   int i, hst_num, hst_wei, new_cap, old_loc, tot_str;
   object *contents, *dropped;

   if ( no_check ) return;
   old_loc = (int)this_object()->query_loc_weight();
   tot_str = Str + strtmp + strbon;
   new_cap = BASE;
   new_cap += ( ORD1T * tot_str ) / ORD1B;
   new_cap += ( ORD2T * tot_str * tot_str ) / ORD2B;
   new_cap = ( new_cap * (int)this_object()->query_weight(1) ) / 100;
   if ( !new_cap )
      new_cap = 1;
   this_object()->set_max_weight( new_cap );
   if ( new_cap >= old_loc ) return;
   this_object()->dest_hide_shadow();
   contents = all_inventory( this_object() ) -
      (object *)this_object()->query_armours();
   dropped = ({ });
   while ( ( old_loc > new_cap ) && sizeof( contents ) ) {
      hst_num = 0;
      hst_wei = 0;
      for ( i = 0; i < sizeof( contents ); i++ )
         if ( (int)contents[ i ]->query_complete_weight() > hst_wei ) {
            hst_wei = (int)contents[ i ]->query_complete_weight();
            hst_num = i;
         }
      if ( (int)contents[ hst_num ]->move( environment() ) == MOVE_OK ) {
         dropped += ({ contents[ hst_num ] });
         old_loc -= hst_wei;
      }
      contents = delete( contents, hst_num, 1 );
   }
   if ( sizeof( dropped ) ) {
      tell_room( environment(), capitalize( (string)this_object()->short() ) +
                " drops "+ query_multiple_short( dropped ) +" under strain.\n",
                this_object() );
      tell_object( this_object(), "Your fading strength makes you drop "+
                  query_multiple_short( dropped ) +".\n" );
   }
   this_object()->update_loc_weight();
   this_object()->calc_burden();
   if ( new_cap >= old_loc ) return;
   /* something nasty here to pin them to the ground with all that heavy
    armour */
   return;
} /* reset_carry_cap() */

void check_stats_zero() {
   if ( Int + inttmp + intbon <= 0 ||
        Wis + wistmp + wisbon <= 0 ) {
      this_object()->add_property( PASSED_OUT, 1, 500 );
      tell_object( this_object(), "You fall asleep.\n" );
   }
} /* check_stats_zero() */

void reset_all() { zap_stat( "CDISW" ); }

void reset_all2() {
   no_check = 0;
   reset_hp();
   reset_gp();
   reset_carry_cap();
   calc_inc_rates();
   check_stats_zero();  /* consequences of going to zero */
   this_object()->do_burden_call();
} /* reset_all2() */
 
int query_con() { return Con + contmp + conbon; }
int query_dex() { return Dex + dextmp + dexbon; }
int query_int() { return Int + inttmp + intbon; }
int query_str() { return Str + strtmp + strbon; }
int query_wis() { return Wis + wistmp + wisbon; }
 
int query_real_con() { return Con; }
int query_real_dex() { return Dex; }
int query_real_int() { return Int; }
int query_real_str() { return Str; }
int query_real_wis() { return Wis; }
                                   
int check( int number ) { return ( number <= 28 ); }
 
int set_con( int number ) {
  if ( !check( number ) ) number = 28;
  if ( Con != number )
    zap_stat( "C" );
  Con = number;
  return Con;
} /* set_con() */
                
int set_dex( int number ) {
  if ( !check( number ) ) number = 28;
  if ( Dex != number )
    zap_stat( "D" );
  Dex = number;
  return Dex;
} /* set_dex() */
 
int set_int( int number ) {
  if ( !check( number ) ) number = 28;
  if ( Int != number )
    zap_stat( "I" );
  Int = number;
  return Int;
} /* set_int() */
 
int set_str( int number ) {
  if ( !check( number ) ) number = 28;
  if ( Str != number )
    zap_stat( "S" );
  Str = number;
  return Str;
} /* set_str() */
 
int set_wis( int number ) {
  if ( !check( number ) ) number = 28;
  if ( Wis != number )
    zap_stat( "W" );
  Wis = number;
  return Wis;
} /* set_wis() */
 
int adjust_con( int number ) {
  if ( check( number + Con ) ) {
    Con += number;
    if ( number )
      zap_stat( "C" );
  }
  return Con;
} /* adjust_con() */
 
int adjust_dex( int number ) {
  if ( check( number + Dex ) ) {
    Dex += number;
    if ( number )
      zap_stat( "D" );
  }
  return Dex;
} /* adjust_dex() */
 
int adjust_int( int number ) {
  if ( check( number + Int ) ) {
    Int += number;
    if ( number )
      zap_stat( "I" );
  }
  return Int;
} /* adjust_int() */
 
int adjust_str( int number ) {
  if ( check( number + Str ) ) {
    Str += number;
    if ( number )
      zap_stat( "S" );
  }
  return Str;
} /* adjustr_str() */
 
int adjust_wis( int number ) {
  if ( check( number + Wis ) ) {
    Wis += number;
    if ( number )
      zap_stat( "W" );
  }
  return Wis;
} /* adjust_wis() */
 
int query_tmp_con() { return contmp; }
int query_tmp_dex() { return dextmp; }
int query_tmp_int() { return inttmp; }
int query_tmp_str() { return strtmp; }
int query_tmp_wis() { return wistmp; }
 
int adjust_tmp_con( int number ) {
  contmp += number;
  if ( number )
    zap_stat( "C" );
   if ( contmp && !dextmp && !inttmp && !strtmp && !wistmp )
      call_out( "update_tmps", 900 );
  return contmp;
} /* adjust_tmp_con() */
 
int adjust_tmp_dex( int number ) {
  dextmp += number;
  if ( number )
    zap_stat( "D" );
   if ( !contmp && dextmp && !inttmp && !strtmp && !wistmp )
      call_out( "update_tmps", 900 );
  return dextmp;
} /* adjust_tmp_dex() */
 
int adjust_tmp_int( int number ) {
  inttmp += number;
  if ( number )
    zap_stat( "I" );
   if ( !contmp && !dextmp && inttmp && !strtmp && !wistmp )
      call_out( "update_tmps", 900 );
  return inttmp;
} /* adjust_tmp_int() */
 
int adjust_tmp_str( int number ) {
  strtmp += number;
  if ( number )
    zap_stat( "S" );
   if ( !contmp && !dextmp && !inttmp && strtmp && !wistmp )
      call_out( "update_tmps", 900 );
  return strtmp;
} /* adjust_tmp_str() */
 
int adjust_tmp_wis( int number ) {
  wistmp += number;
  if ( number )
    zap_stat( "W" );
   if ( !contmp && !dextmp && !inttmp && !strtmp && wistmp )
      call_out( "update_tmps", 900 );
  return wistmp;
} /* adjust_tmp_wis() */
 
int query_bonus_con() { return conbon; }
int query_bonus_dex() { return dexbon; }
int query_bonus_int() { return intbon; }
int query_bonus_str() { return strbon; }
int query_bonus_wis() { return wisbon; }
 
int adjust_bonus_con( int number ) {
  conbon += number;
  if ( number )
    zap_stat( "C" );
  return conbon;
} /* adjust_bonus_con() */

int adjust_bonus_dex( int number ) {
  dexbon += number;
  if ( number )
    zap_stat( "D" );
  return dexbon;
} /* adjust_bonus_dex() */
 
int adjust_bonus_int( int number ) {
  intbon += number;
  if ( number )
    zap_stat( "I" );
  return intbon;
} /* adjust_bonus_int() */

int adjust_bonus_str( int number ) {
  strbon += number;
  if ( number )
    zap_stat( "S" );
  return strbon;
} /* adjust_bonus_str() */
 
int adjust_bonus_wis( int number ) {
  wisbon += number;
  if ( number )
    zap_stat( "W" );
  return wisbon;
} /* adjust_bonus_wis() */
 
void update_tmps() {
  if ( contmp ) {
    zap_stat( "C" );
    contmp = contmp / 2;
  }
  if ( dextmp ) {
    zap_stat( "D" );
    dextmp = dextmp / 2;
  }
  if ( inttmp ) {
    zap_stat( "I" );
    inttmp = inttmp / 2;
  }
  if ( strtmp ) {
    zap_stat( "S" );
    strtmp = strtmp / 2;
  }
  if ( wistmp ) {
    zap_stat( "W" );
    wistmp = wistmp / 2;
  }
   if ( contmp || dextmp || inttmp || strtmp || wistmp )
      call_out( "update_tmps", 900 );
} /* update_tmps() */
 
int query_height() { return height; }
 
void set_height( int number ) {
  if ( number > 0 ) height = number;
} /* set_height() */

int query_base_weight() { return base_weight; }
 
void set_base_weight( int number ) {
   if ( number > 0 )
      base_weight = number;
} /* set_weight() */
 
int query_weight(int) {
  int adjust_weight;
  adjust_weight = ( ( ( Con + 3 * Str ) / 4 ) - 13 ) * ( base_weight / 30 );
  return base_weight + adjust_weight;
} /* query_weight() */
 
mixed *stats() {
  return ({
    ({ "Con", Con + conbon + contmp }),
    ({ "Dex", Dex + dexbon + dextmp }),
    ({ "Int", Int + intbon + inttmp }),
    ({ "Str", Str + strbon + strtmp }),
    ({ "Wis", Wis + wisbon + wistmp }),
    ({ "tmp Con", contmp }),
    ({ "tmp Dex", dextmp }),
    ({ "tmp Int", inttmp }),
    ({ "tmp Str", strtmp }),
    ({ "tmp Wis", wistmp }),
    ({ "bonus Con", conbon }),
    ({ "bonus Dex", dexbon }),
    ({ "bonus Int", intbon }),
    ({ "bonus Str", strbon }),
    ({ "bonus Wis", wisbon }),
    ({ "hp rate", hp_inc }),
    ({ "gp rate", gp_inc }),
    ({ "height", height }),
  });
} /* stats() */
// --- END [/mnt/home2/grok/lib/std/living/stats.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/living/living.eff_shad.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/living/living.eff_shad.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628854   Available: 13576208
Inodes: Total: 5242880    Free: 4960135
43121 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/living/living.eff_shad.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628854   Available: 13576208
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker: ceres $
 * $Id: living.c,v 1.72 2003/03/07 03:24:37 ceres Exp ceres $
 *
 */
/**
 * The main living inherit.  This inherits all the files
 * needed to be in a living object.
 * @author Pinkfish
 */
#include <dirs.h>
#include <drinks.h>
#include <living.h>
#include <move_failures.h>
#include <player.h>
#include <tune.h>
#include <position.h>
#include <obj_parser.h>

inherit "/std/container";
inherit "/std/living/armour";
inherit "/std/living/carrying";
inherit "/std/living/combat";
inherit "/std/living/effects";
inherit "/std/living/force";
inherit "/std/living/gender";
inherit "/std/living/health";
inherit "/std/living/holding";
inherit "/std/living/money";
inherit "/std/living/skills";
inherit "/std/living/spells";
inherit "/std/living/crafts";
inherit "/std/living/stats";
inherit "/std/living/respond_cmd";
inherit "/std/living/nationality";

#define VERBOSE_TYPES ({"combat", "look", "score", "names", "htell", "finger"})

//The maximum amount of religious favour you can have.
#define MAX_FAVOUR 100

class living_data {
  int handicap;
  int burden;
  object* followers;
  class obj_match_context it_them;
  object* to_drop;
  int burden_call;
}

class messages {
   string msgout;
   string msgin;
   string mmsgout;
   string mmsgin;
}

private int alignment;
private class messages _messages;
private mixed *facing;
private mapping verbose;
private mapping abs_facing = ABS_FACING;
private mapping lengthen = LENGTHEN;

//Got religion?
private string deity;         //Your deity of choice.
private mapping deity_favour; //A mapping of deity ratings.

//private nosave object _dragging;
private nosave class living_data _liv_data;
//private nosave int _handicap;
//private nosave object *_followers;
//private nosave class obj_match_context _it_them;
//private nosave object* _to_drop;
//private nosave int _burden_call;

void return_to_default_position(int leaving);
void set_position(string name);
void set_position_on(mixed ob);
void set_position_multiple(int mult);
void set_position_type(string type);
object query_position_on();
protected mixed command(string);

/*
 * What position are they in?  Standing, sitting, lying, froging?
 */
private nosave string position;
private nosave mixed default_position;
private /* This will force an object to not use the position from the room. */
nosave int always_use_default_position;
/* in case they are standing on something or something... */
private nosave mixed position_on;

void create() {
   string t;

   _liv_data = new(class living_data);
   _messages = new(class messages);
   crafts::create();
   container::create();
   armour::create();
   combat::create();
   effects::create();
   health::create();
   holding::create();
   skills::create();
   spells::create();
   respond_cmd::create();
   enable_commands();
   reset_can_export_inventory();
   reset_effects();
   _messages->msgin = "$N arrive$s from $F.";
   _messages->msgout = "$N leave$s $T.";
   _messages->mmsgin = "$N appear$s out of the ground.";
   _messages->mmsgout = "$N disappear$s in a puff of smoke.";
   _liv_data->followers = ({ });
   verbose = ([ ]);
   set_max_items(50);
   _liv_data->to_drop = ({ });
   foreach(t in VERBOSE_TYPES) {
      verbose[t] = 1;
   }

   facing = ({ 0, ({ "north", "northeast", "east", "southeast", "south",
         "southwest", "west", "northwest" }), ({ "up", "down" }) });
   position = STANDING;

   add_adjective("living");
} /* create() */

/** @ignore yes */
void heart_beat() {
  stats::heart_beat();
  combat::heart_beat();
}

/**
 * This method returns the pronoun string of the living object.
 * A pronoun is "he", "she", "it".
 * @return the pronoun string
 */
string query_pronoun() {
   return gender::query_pronoun();
} /* query_pronoun() */

/**
 * This method returns the prossessive string of the living object.
 * A possessive is "her", "his", "its".
 * @return the possessive string
 */
string query_possessive() {
   return gender::query_possessive();
} /* query_possessive() */

/**
 * This method returns the objective string of the living object.
 * An objective is "her", "him", "it".
 * @return the objective string
 */
string query_objective() {
   return gender::query_objective();
} /* query_objective() */

/** @ignore yes */
varargs int query_weight(int actual) {
  if(!actual && this_object()->query_property("dead"))
    return 0;
  return stats::query_weight();
}

/**
 * This method returns the current burden level of the living
 * object.  This is returned as a percentage of the maximum
 * weight that the living can carry.
 * @return the burden level (0-100)
 */
int query_burden() {
  return _liv_data->burden;
} /* query_burden() */

/**
 * This method returns the current handicap of the living
 * object.
 * @return the current handicap.
 * @see calc_burden()
 */
int query_handicap() { return _liv_data->handicap; }

/**
 * This method calculates the current handicap of the living
 * object.  The handicap is based on the burden of the
 * person, the more burdened the higher the handicap.  The
 * handicap is 1 point of dexterity for every 25% burdened.
 * @see query_handicap()
 * @see query_burden()
 */
void calc_burden() {
  int new_handicap;
  int burden;
  object thing;
  mapping hands;
  
  _liv_data->burden_call = 0;
  
  update_loc_weight();
  burden = query_loc_weight();
  foreach(thing in query_wearing())
    burden -= (int)thing->query_complete_weight() / 2;

  hands = ([ ]);
  foreach(thing in query_holding())
    if(objectp(thing))
      hands[thing]++;

  foreach(thing in keys(hands))
    burden += (int)thing->query_complete_weight() / hands[thing];

  if(!query_max_weight()) {
    this_object()->reset_carry_cap();
    _liv_data->burden = 50;
  } else
    _liv_data->burden = (100 * burden) / query_max_weight();
  
  new_handicap = (_liv_data->burden / 25) - 1;
  if(new_handicap < 0)
    new_handicap = 0;
  
  if ( _liv_data->handicap != new_handicap ) {
    adjust_bonus_dex( _liv_data->handicap - new_handicap );
    _liv_data->handicap = new_handicap;
  }
}

/**
 * This method returns the string representation of the current
 * burden level.
 * @return the burden string
 * @see calc_burden()
 * @see query_burden()
 */
string burden_string() {
  switch (_liv_data->handicap) {
  case 0 :
    return "unburdened";
  case 1 :
    return "burdened";
  case 2 :
    return "heavily burdened";
  case 3 :
    return "very heavily burdened";
  default :
    return "incredibly heavily burdened";
  }
} /* burden_string() */

/** @ignore yes */
void add_effect( string eff, mixed arg ) { effects::add_effect( eff, arg ); }

/**
 * This method adds any commands needed by the living inherit.
 */
void living_commands() {
#if efun_defined(add_action)
   add_action( "exit_command", "*", 1 );
#endif
} /* living_commands() */

/**
 * This method allows you to make the living object eat something.
 * @param food the food object to eat
 */
void eat_this( object food ) {
  this_object()->bypass_queue();
  command( "eat " + file_name( food ) );
} /* eat_this() */

/**
 * This method handles the cannot get flags.  This is placed
 * into the living object so that things which are marked as
 * being unable to be picked up can still be put into normal
 * containers.  The upwards checking of containers stops here.
 * This should make it so that objects marked as unable to be
 * picked up cannot be put into objects in the players
 * inventory.
 * @return 1 if the object can be added, 0 if not.
 */
int test_add(object ob, int flag) {
  if(sizeof(all_inventory(this_object())) > query_max_items())
    return 0;
  
  return !flag;
}

/**
 * This method handles the cannot drop flags.  This is placed
 * into the living object so that things which are marked as
 * being unable to be dropped can still be remove from normal
 * containers.  This does all sorts of other exciting checks
 * now.
 * @return 1 if the object can be added, 0 if not.
 */
int test_remove( object ob, int flag, mixed dest ) {
   object thing;

   if ( flag ) {
      return 0;
   }
   if ( !this_player() || ( this_player() == this_object() ) ) {
      return !flag;
   }
   if ( stringp( dest ) ) {
      thing = find_object( dest );
   }
   if ( objectp( dest ) ) {
      thing = dest;
      dest = file_name( dest );
   }
   if ( thing->query_corpse() || ( dest == "/room/rubbish" ) ) {
      return !flag;
   }
/*
 * True theft commands should return 1 to query_theft_command().
 *  Things like the ritual "fumble" and the command "disarm" should return -1.
 */
   if ( sizeof( filter_array( previous_object( -1 ),
         (: $1->query_theft_command() :) ) ) ) {
      return !flag;
   }
/* We should now only be considering things like "get", "take" and "palm". */
   if ( !query_property( PASSED_OUT ) ) {
      return 0;
   }
   if ( !pk_check( this_player(), this_object() ) ) {
      event( environment( this_player() ), "theft", this_player(),
            this_object(), ob );
      return !flag;
   }
   write( "An unseen force stays your hand.\n" );
   return 0;
} /* test_remove() */

/**
 * This method returns the current alignment of the living
 * object.
 * @return the current alignment
 * @see set_al()
 * @see adjust_al()
 * @see adjust_alignment()
 * @see align_string()
 */
int query_al() { return alignment; }

/**
 * This method sets the current alignment of the living
 * object.
 * @param number the new alignment for the object
 * @see query_al()
 * @see adjust_al()
 * @see adjust_alignment()
 * @see align_string()
 */
void set_al( int number ) { alignment = number; }

/**
 * This method adjusts the current alignment of the living
 * object.
 * @param number the amount to change the alignment by
 * @return the new alignment
 * @see query_al()
 * @see set_al()
 * @see adjust_alignment()
 * @see align_string()
 */
int adjust_al( int number ) {
   alignment += number;
   if ( alignment < -MAX_AL ) {
      alignment = -MAX_AL;
   }
   if ( alignment > MAX_AL ) {
      alignment = MAX_AL;
   }
   return alignment;
} /* adjust_al() */

/**
 * This method adjusts the current alignment of the living
 * object.  This is called when an object dies and handles the
 * mangling of the change value based on the current alignment and
 * the alignment of the thing dieing.
 * @param number the amount to change the alignment by
 * @return the new alignment
 * @see query_al()
 * @see adjust_al()
 * @see set_al()
 * @see align_string()
 */
int adjust_alignment( int number ) {
  int change;

  // To become more evil you must kill something that is at least 20%
  // good as you are evil and vice versa.
  change = - (number + alignment/5);

  // This stops the changes being too extreme. Increase this for smaller
  // changes, decrease it for larger ones.
  change /= 20;

  // Now wasn't that nice and easy? :-)
  return adjust_al( change );
} /* adjust_alignment() */

/**
 * This method returns the string associated with the current
 * alignment of the living object.
 * @return the string associated with the alignment
 * @see query_al()
 * @see adjust_al()
 * @see adjust_alignment()
 * @see set_al()
 */
string align_string() {
   switch ( alignment ) {
      case -MAX_AL .. -5001 : return "extremely good"; break;
      case -5000 .. -2501 : return "very good"; break;
      case -2500 .. -1251 : return "quite good"; break;
      case -1250 .. -601 : return "good"; break;
      case -600 .. -301 : return "barely good"; break;
      case -300 .. 300 : return "neutral"; break;
      case 301 .. 600 : return "barely evil"; break;
      case 601 .. 1250 : return "evil"; break;
      case 1251 .. 2500 : return "quite evil"; break;
      case 2501 .. 5000 : return "very evil"; break;
      default : return "extremely evil"; break;
   }
} /* align_string() */

/**
 * This method returns the current deity the living object is
 * worshipping.
 * @return the current deity
 * @see /obj/handlers/diety_handler
 * @see set_deity()
 */
string query_deity() { return deity; }
/**
 * This method sets the current deity the living object is
 * worshipping.
 * @param word the new deity
 * @see /obj/handlers/diety_handler
 * @see query_deity()
 */
void set_deity( string word ) { deity = word; }

/**
 * This is the method used to query the current message to use when
 * entering a room.   A $N in the string will be expanded to the
 * name and a $F will be expanded to the from direction.
 * @return the message to print when entering a room.
 * @see /obj/handlers/room_handler
 * @see query_msgout()
 * @see set_msgin()
 */
string query_msgin() { return _messages->msgin; }
/**
 * This is the method used to query the current message to use when
 * exiting a room.   A $N in the string will be expanded to the
 * name and a $T will be expanded to the to direction.
 * @return the message to print when entering a room.
 * @see /obj/handlers/room_handler
 * @see query_msgin()
 * @see set_msgout()
 */
string query_msgout() { return _messages->msgout; }

/**
 * This is the method used to set the current message to use when
 * entering a room.   A $N in the string will be expanded to the
 * name and a $F will be expanded to the from direction.
 * @param str the message to print when entering a room
 * @see /obj/handlers/room_handler
 * @see query_msgin()
 * @see set_msgout()
 */
int set_msgin(string str) {
   if (strsrch(str, "$N") == -1 || strsrch(str, "$F") == -1) {
      return 0;
   }
   _messages->msgin = str;
   return 1;
} /* set_msgin() */
/**
 * This is the method used to query the current message to use when
 * exiting a room.   A $N in the string will be expanded to the
 * name and a $T will be expanded to the to direction.
 * @return the message to print when entering a room.
 * @see /obj/handlers/room_handler
 * @see query_msgout()
 * @see set_msgin()
 */
int set_msgout(string str) {
   if (strsrch(str, "$N") == -1 || strsrch(str, "$T") == -1) {
      return 0;
   }
   _messages->msgout = str;
   return 1;
} /* set_msgout() */

/**
 * THis is the message to be used when the person is teleported.
 * @return the in message when they teleport
 */
string query_mmsgin() { return _messages->mmsgin; }
/**
 * THis is the message to be used when the person is teleported.
 * @return the out message when they teleport
 */
string query_mmsgout() { return _messages->mmsgout; }

/**
 * The teleport in message.  Sets the message to be seen when
 * a player telerpots into the room.
 * @param str the message to be seen
 */
int set_mmsgin(string str) {
   if (strsrch(str, "$N") == -1) {
      return 0;
   }
   _messages->mmsgin = str;
   return 1;
} /* set_mmsgin() */

/**
 * Sets the teleport out message.  If the player teleports out, this
 * is the message seen.
 * @param str the teleport message
 */
int set_mmsgout(string str) {
   if (strsrch(str, "$N") == -1) {
      return 0;
   }
   _messages->mmsgout = str;
   return 1;
} /* set_mmsgout() */

mixed *query_facing() { return copy( facing ); }

/**
 * The facing array is a list of directions and two integers which determine
 * which way we face.  The layout is:<br>
 * ({ facing, ({ dirs }), up_down_facing, ({ up_down_dirs }) })
 * @param args the facing arguments
 */
void set_facing( mixed *args ) { facing = args; }

/**
 * This method finds the relative direction from the passed in direction.
 * @param word the exit name ('east', 'west',...)
 * @param from the offset to find the exit from
 * @return the relative direction
 */
string find_rel( string word, int from ) {
  int i;

  i = member_array( word, facing[ 1 ] );
  if ( i != -1 ) {
    i = ( i + 8 - facing[ 0 ] ) % 8;
    return REL_DIRS[ 3 * i + from ];
  }
  i = member_array( word, facing[ 2 ] );
  if ( i != -1 ) {
    return ({ "up", "down" })[ i ];
  }
  return word;
} /* find_rel() */

/**
 * Finds the absolute direction from the input relative direction.
 * @param word the exit name ('left', 'right', ...)
 * @return the absolute direction
 */
string find_abs( string word ) {
  int i;

  i = member_array( word, REL_DIRS );
  if ( i != -1 ) {
    i = ( i / 3 + facing[ 0 ]) % 8;
    return facing[ 1 ][ i ];
  }
  i = member_array( word, ({ "up", "down" }) );
  if ( i != -1 ) {
    return facing[ 2 ][ i ];
  }
  return word;
} /* find_rel() */

/**
 * This method takes in a relative direction and reorients us in the correct
 * way to go in that direction.  This also updates our facing so we are
 * facing in the specified relative direction.
 * @param word the direction to look up
 * @return the real direction
 */
string reorient_rel( string word ) {
  int i;

  i = member_array( word, REL_DIRS );
  if ( i != -1 ) {
    i = ( i / 3 + facing[ 0 ] ) % 8;
    facing[ 0 ] = i;
    return facing[ 1 ][ i ];
  }
  i = member_array( word, ({ "up", "down" }) );
  if ( i != -1 ) {
    return facing[ 2 ][ i ];
  }
  return word;
} /* reorient_rel() */

/**
 * This method takes in a absolute direction and reorients us in the correct
 * way to go in that direction.
 * @param word the direction to look up
 */
void reorient_abs( string verb ) {
  if ((ABS_FACING)[verb]) {
    facing[0] = (ABS_FACING)[verb] % 8;
  }
} /* reorient_rel() */

/**
 * This method sets the object for us to drag when we try and leave.
 * @param thing the object to drag off
 */
void set_dragging( object thing ) { add_property("dragging", thing); }

/**
 * This method returns the object we are dragging.
 * @return the thing we are dragging
 */
object query_dragging() { return query_property("dragging"); }

/**
 * This method resets the object we are dragging.
 */
void reset_dragging() { add_property("dragging", 0); }

/**
 * This is used by the movement system to look in the room when we move.
 * It does checks for verbose and other checks before doing the look.
 */
int room_look() {
   if ( query_property( UNKNOWN_MOVE ) || !( interactive( this_object() ) ||
         this_object()->query_slave() ) )
      return 0;
   /* These need to be evaluated immediately, hence the bypass_queue() call. */
   if(!mapp(verbose))
     verbose = ([ ]);

   if(verbose && verbose["look"]) {
      this_object()->ignore_from_history( "look" );
      this_object()->bypass_queue();
      command( "look" );
   } else {
      this_object()->ignore_from_history( "glance" );
      this_object()->bypass_queue();
      command( "glance" );
   }
   return 1;
} /* room_look() */

/**
 * This method returns the current verbose mode setting of the player.
 * @param the type of verbosity, by default it will return the normal stuff.
 * @return the verbose mode of the player
 */
int query_verbose(string type) {
  if(!verbose || !mapp(verbose)) {
    verbose = ([ ]);
  }
  return verbose[type];
} /* query_verbose() */

/**
 * This method sets the verbosity for a given type.
 */
void set_verbose(string type, int val) {
  if(!verbose || !mapp(verbose)) {
    verbose = ([ ]);
  }

  if(member_array(type, VERBOSE_TYPES) != -1) {
    verbose[type] = val;
  }
}

/**
 * This method returns the current verbose/brief types.
 */
string *query_verbose_types() {
  return VERBOSE_TYPES;
}

varargs int move_with_look( mixed dest, string messin, string messout ) {
   return_to_default_position(1);
   if ( (int)this_object()->move( dest, messin, messout ) != MOVE_OK )
      return 0;
   room_look();
   return_to_default_position(1);
   return 1;
} /* move_with_look() */

varargs int exit_command( string word, mixed verb, object thing, int redirection ) {
   string special_mess, *bits, *exits, redirect;
   int temp;

   if ( !environment() ) {
      return 0;
   }

   if ( !verb ) {
      verb = word;
      bits = explode( word, " " );
      if ( sizeof( bits ) > 1 ) {
         word = implode( bits[ 1 .. ], " " );
      } else {
         word = "";
      }
   } else {
      if ( pointerp( verb ) ) {
         special_mess = verb[ 1 ];
         verb = verb[ 0 ];
      }
      bits = explode( verb, " " );
      if ( sizeof( bits ) > 1 ) {
         word = implode( bits[ 1 .. ], " " );
      } else {
         word = "";
      }
   }
   if ( lengthen[ verb ] ) {
      verb = lengthen[ verb ];
   }
   exits = (string *)environment()->query_exits();
   if ( !exits ) {
      return 0;
   }

   if ( member_array( verb, exits ) != -1 ) {
     if ( environment()->query_relative( verb ) ) {
       return 0;
     }

     if ((abs_facing)[verb]) {
       facing[0] = (abs_facing)[verb] % 8;
     }
   } else {
     if (member_array(find_abs(verb), exits ) == -1 ) {
       return 0;
     }
     verb = reorient_rel(verb);
   }
   if ( !thing ) {
      thing = this_object();
   }

    //If the player has redirection enabled!
    //Redirection returns a string which is an alternative exit to try.
    //It calls exit_command to do all of the proper checks before hand,
    //it blocks recursion by way of a flag which is passed as the fourth arg
    //in exit command.
    if ( !redirection ) {
        if ( stringp( redirect = thing->query_exit_redirection( word ) ) ) {
            if ( temp = this_object()->exit_command( verb, redirect, thing, 1 ) ) 
                return temp;
        }
    }

   return (int)"/obj/handlers/room_handler"->exit_move( verb, word,
         special_mess, thing );
} /* exit_command() */

void become_flummoxed() {
   int will;

   will = query_int() * query_wis();
   if ( will < random( WILL_POWER ) )
      this_object()->interrupt_ritual();
   if ( will < random( WILL_POWER ) )
      this_object()->interrupt_spell();
   if ( will < random( WILL_POWER ) )
      this_object()->stop_all_fight();
} /* become_flummoxed() */

int run_away() {
   int i;
   object old_env;
   mixed *direcs;
   
   direcs = (mixed *)environment()->query_dest_dir(this_object());
   old_env = environment();
   while ( sizeof( direcs ) ) {
      i = random( sizeof( direcs ) / 2 ) * 2;
      if ( exit_command( direcs[i] ) ) {
          event( old_env, "run_away", direcs[ i ], direcs[ i + 1 ] );
          return 1;
      }

      direcs = delete( direcs, i, 2 );
   }
   return 0;
} /* run_away() */

/* Now handled in test_remove().
int cannot_get_stuff() { return !query_property( PASSED_OUT ); }
*/

/** @ignore yes */
mixed *stats() {
   return container::stats() + stats::stats() + ({
           ({ "max_hp", max_hp }),
           ({ "hp",  hp }),
           ({ "max_gp", max_gp }),
           ({ "gp", gp }),
           ({ "alcohol", drink_info[ D_ALCOHOL ] }),
           ({ "food", drink_info[ D_FOOD ] }),
           ({ "drink", drink_info[ D_DRINK ] }),
           ({ "gender", query_gender_string() }),
           ({ "alignment", this_object()->query_al() }),
           ({ "deity", deity }),
           ({ "total money", query_value() }),
           ({ "xp", query_xp() }),
   }) + armour::stats() + combat::stats() + (mixed *)effects::stats();
} /*  stats() */

/**
 * This method returns the current array used for calculating 'it' and
 * 'them' in the find_match code.
 * @return the array of objects matching them
 * @see /secure/simul_efun->find_match()
 * @see set_it_them()
 */
class obj_match_context query_it_them() { return _liv_data->it_them; }
/**
 * This method sets the current array used for calculating 'it' and
 * 'them' in the find_match code.
 * @param args the new array of objects
 * @see /secure/simul_efun->find_match()
 * @see query_it_them()
 */
void set_it_them( class obj_match_context args) { _liv_data->it_them = args; }

/**
 * This method adds a follower to the living object.  A follower will
 * happily follow around the person in front.  Used in the follow
 * command.
 * @param ob the object to follow us
 * @see remove_follower()
 * @see query_followers()
 * @return 1 on success, 0 on failure
 */
int add_follower(object ob) {
  if (ob == this_object()) {
    return 0;
  }
  if (member_array(ob, _liv_data->followers) == -1) {
    _liv_data->followers += ({ ob });
  }
  return 1;
} /* add_follower() */

/**
 * This method removes a follower from the living object.  A follower will
 * happily follow around the person in front.  Used in the unfollow
 * and lose commands.
 * @param ob the object to remove from the follow list
 * @see add_follower()
 * @see query_followers()
 * @return 1 on success, 0 on failure
 */
int remove_follower(object ob) {
  int i;

  i = member_array(ob, _liv_data->followers);
  if (i != -1) {
    _liv_data->followers = delete(_liv_data->followers, i, 1);
    return 1;
  }
  return 0;
} /* remove_follower() */

/**
 * This is a method to check to see if this object can actually follow
 * the person they are following.
 * @param thing the thing following us
 * @param verb the direction they are going to
 * @param special any special stuff
 * @return 1 if we are allowed to go there, 0 otherwise
 */
int check_doing_follow(object thing, string verb, string special) {
   return 1;
} /* check_doing_follow() */

/**
 * This method returns the current room of the object.  This was needed
 * previously to use in things like unique_array, before function
 * pointers came into existance.
 * @return the environment of the object
 */
object query_current_room() { return environment(); }

/**
 * This method returns the current list of followers to the living
 * object.
 * @see add_follower()
 * @see remove_follower()
 */
mixed *query_followers() { return copy(_liv_data->followers - ({ 0 })); }

/** @ignore yes */
varargs void adjust_money(mixed amt, string type) {
  return money::adjust_money(amt, type);
} /* adjust_money() */

/** @ignore yes */
mixed *query_money_array() {
  return money::query_money_array();
} /* query_money_array() */

/** @ignore yes */
int query_money(string type) {
  return money::query_money(type);
} /* query_money() */

/** @ignore yes */
int query_value() { return money::query_value(); }

void do_burden_call() {
  if(_liv_data->burden_call)
    remove_call_out(_liv_data->burden_call);
  
  _liv_data->burden_call = call_out("calc_burden", 1);
}

int query_burden_limit() {
  if (this_object()->query_creator()) { 
    return MAX_CREATOR_INVEN;
  } else {
    return MAX_INVEN;
  }
} /* query_burden_limit() */ 

/** @ignore yes */
void event_enter( object thing, string mess, object from ) {
  if(environment( thing ) == this_object()) {
    do_burden_call();
    
    if(sizeof(all_inventory()) > query_burden_limit() ) {
      _liv_data->to_drop += ({ thing });
      remove_call_out("test_number_of_items");
      call_out("test_number_of_items", 5 + random(5));
    }
  }
}

/** @ignore yes */
void event_exit( object thing, string mess, object to ) {
  if(environment(thing) == this_object()) {
    do_burden_call();
  }
}

/** @ignore yes */
void test_number_of_items() {
   int how_many;
   object thing, *things, *dropped;

   things = all_inventory() - query_armours() - query_holding();
   how_many = sizeof(things) - query_burden_limit();
   if ( how_many < 1 ) {
      return;
   }

   _liv_data->to_drop -= ({ 0 });

   dropped = ({ });
   while(how_many > 0 && sizeof(things)) {
      if (sizeof(_liv_data->to_drop)) {
         thing = _liv_data->to_drop[random(sizeof(_liv_data->to_drop))];
      } else {
         thing = things[random(sizeof(things))];
      }
      things -= ({ thing });
      _liv_data->to_drop -= ({ thing });

      if(!thing || !thing->short() || thing->drop() ||
         thing->query_property("cannot fumble") ||
         thing->id("coin") ||
         environment(thing) != this_object()) {
        continue;
      }

      if((int)thing->move(environment()) == MOVE_OK) {
        how_many--;
        dropped += ({ thing });
      }
   }

   _liv_data->to_drop = ({ });

   if(sizeof(dropped)) {
     tell_object( this_object(), "Whoops!  You tried to carry too many "
                  "things and fumbled "+
                  query_multiple_short( dropped ) +".\n" );
     this_object()->dest_hide_shadow();
     tell_room( environment(), capitalize( the_short() ) +" juggles "+
                "around "+ query_possessive() +" stuff and fumbles "+
                query_multiple_short( dropped ) +".\n", this_object() );
   }
}

/**
 * This forces a burden recalculation.  This should also be used to
 * force a recalcuation of the number of items someone can carry.
 */
void force_burden_recalculate() {
   do_burden_call();
   remove_call_out("test_number_of_items");
   call_out("test_number_of_items", 5 + random(5));
}

/** @ignore yes */
object *find_inv_match( string words, object looker ) {
   return sort_array( container::find_inv_match( words, looker ),
         (: ( member_array( $1, query_holding() ) != -1 ? -1 : 0 ) :) );
} /* find_inv_match() */

/** @ignore yes */
int attack_by(object ob) {
   return_to_default_position(0);
   return ::attack_by(ob);
} /* attack_by() */

/** @ignore yes */
int attack_ob(object ob) {
   return_to_default_position(0);
   return ::attack_ob(ob);
} /* attack_ob() */

/**
 * This method sets the always the flag to always use the default position.
 * If this is set then rooms cannot override the position message which is
 * displayed by the object.
 * @param flag if we should always use the default position
 * @see query_always_use_default_position()
 * @see set_default_position()
 * @see return_to_default_position()
 */
void set_always_use_default_position(int flag) {
   always_use_default_position = flag;
} /* set_always_use_default_position() */

/**
 * This method sets the always the flag to always use the default position.
 * If this is set then rooms cannot override the position message which is
 * displayed by the object.
 * @return the always use default position flag
 * @see set_always_use_default_position()
 * @see set_default_position()
 * @see return_to_default_position()
 */
int query_always_use_default_position() {
   return always_use_default_position;
} /* query_always_use_default_position() */

/**
 * This method sets the default position of the object.  This is used to
 * allow things to default to some other exciting off beat and froopy
 * default position.  The value returned by this is the command code
 * used to put the object back into the default position or an
 * array which contains three or one elements, the first is the string
 * to use as the position, the second and third (if they exist) are
 * the string to tell the person when changing and the string to tell
 * everyone else when changing position.
 * @return the default position
 * @see set_default_position()
 * @see return_to_default_position()
 * @see set_always_use_default_position()
 */
string query_default_position() {
   mixed pos;

   if (stringp(default_position) &&
              default_position->query_position_command()) {
      pos = default_position;
   } else if (pointerp(default_position) &&
              (sizeof(default_position) == POSITION_MESS_SIZE ||
               sizeof(default_position) == POSITION_ONLY_TYPE_SIZE)) {
      pos = default_position;
   } else if (functionp(default_position)) {
      pos = default_position;
   }

   if (!pos) {
      pos = STANDING_CMD;
   }

   return pos;
} /* query_default_position() */

/**
 * This sets the default position of the object.  This is used to
 * allow things to default to some other exciting off beat and froopy
 * default position.  The paramater to this is the command code
 * used to put the object back into the default position or an
 * array which contains three or one elements, the first is the string
 * to use as the position, the second and third (if they exist) are
 * the string to tell the person when changing and the string to tell
 * everyone else when changing position.  The paramer can also be
 * a function pointer, if it is then it will be evaluated and
 * have two parameters passed into the function.  The first is
 * the object returing to the position and the second is the leaving
 * flag.
 * <p>
 * Please note!  After setting the position you will need to
 * make the object return to the default position to use it.
 * <p>
 * A second note!  A room can also define a query_default_position()
 * function which will be called, if this returns a value (and the
 * override flag is not set) then that will be used for the default
 * position.
 * @param str the new default position
 * @see query_default_position()
 * @see set_always_use_default_position()
 * @see /obj/monster()->set_cannot_change_position()
 * @see return_to_default_position()
 * @example
 * set_default_position("/cmds/living/kneel");
 * @example
 * set_default_position(({ "running" }));
 * @example
 * set_default_position(({ "fishing",
 *                         "You start to fish.\n",
 *                         the_short() + " starts to fish.\n" }));
 * @example
 * npc->set_default_position(({ "running" }));
 * npc->return_to_default_position(1);
 */
void set_default_position(mixed str) {
   if (stringp(str) && str->query_position_command() && str != STANDING_CMD) {
      default_position = str;
   } else if (!str || str == STANDING_CMD) {
      default_position = 0;
   } else if (pointerp(str) && (sizeof(str) == POSITION_ONLY_TYPE_SIZE ||
                                sizeof(str) == POSITION_MESS_SIZE)) {
      default_position = str;
   } else if (functionp(str)) {
      default_position = str;
   }
} /* set_default_position() */

/**
 * This method returns the living object to its default position.
 * @param leaving this is if we are leaving the room
 * @see set_default_position()
 * @see query_default_position()
 * @see set_always_use_default_position()
 */
void return_to_default_position(int leaving) {
   mixed pos;

   /* See if we are being forced to always use the set default position. */
   if (query_always_use_default_position()) {
      pos = query_default_position();
   } else {
      /* See if the room has a default position they wish to tell us about. */
      pos = 0;
      if (environment()) {
         pos = environment()->query_default_position(this_object());
      }
      if (!pos) {
         pos = query_default_position();
      }
   }

   if (functionp(pos)) {
      if (!evaluate(pos, this_object(), leaving)) {
         pos = 0;
         /* See if the environment has any special conditions */
         if (environment()) {
            pos = environment()->query_default_position(this_object());
         }
         if (!pos) {
            pos = STANDING_CMD;
         }
      }
   }

   if (stringp(pos)) {
      /* If we are not standing up...  Stand up... */
      if (position != pos->query_position_type() ||
          (leaving && query_position_on())) {
         if (leaving) {
            catch(pos->position_floor(this_object()));
         } else {
            /*
             * If they are not leaving, just get them to stand up or
             * whatever, this way people can fight on chairs and
             * stuff...
             */
            catch(pos->position(this_object()));
         }
      }
   } else if (pointerp(pos) && position != pos[POSITION_TYPE_INDEX]) {
      /* If it is a pointer, then we do something special... */
      if (sizeof(pos) > 1) {
         if (pos[POSITION_ME_MESS_INDEX]) {
            tell_object(this_object(), pos[POSITION_ME_MESS_INDEX]);
         }
         if (pos[POSITION_REST_MESS]) {
            tell_room(environment(), pos[POSITION_REST_MESS], this_object());
         }
      }
      set_position(pos[POSITION_TYPE_INDEX]);
      set_position_on(0);
      set_position_type(0);
      set_position_multiple(0);
   }
} /* return_to_default_position() */

/**
 * This sets the current position of the object.
 * @param name the string to use for the position
 * @see query_position()
 * @see query_position_on()
 * @see query_position_multiple()
 * @see query_position_type()
 * @see set_position_on()
 * @see set_position_multiple()
 * @see set_position_type()
 */
void set_position(string name) {
   position = name;
} /* set_position() */

/**
 * This queries the current position of the object.
 * @return the current position of the living
 * @see query_position_on()
 * @see query_position_multiple()
 * @see query_position_type()
 * @see set_position()
 * @see set_position_on()
 * @see set_position_multiple()
 * @see set_position_type()
 */
string query_position() {
   return position;
} /* query_position() */

/**
 * This sets the current object which is being referenced as being
 * 'on', 'beside' or 'at'.
 * @param ob the object being referenced
 * @see query_position()
 * @see query_position_on()
 * @see query_position_multiple()
 * @see query_position_type()
 * @see set_position()
 * @see set_position_multiple()
 * @see set_position_type()
 */
void set_position_on(mixed ob) {
   if (!position_on) {
      position_on = allocate(POSITION_ARRAY_SIZE);
   }
   position_on[POS_ON_OBJECT] = ob;
} /* set_position_on() */

/**
 * This sets fact that the object being referenced is one of many.  So
 * you get something more like 'xx is sitting on one of the couches'.
 * @param mult 0 if non-multiple, 1 if multiple
 * @see query_position()
 * @see query_position_on()
 * @see query_position_multiple()
 * @see query_position_type()
 * @see set_position()
 * @see set_position_multiple()
 * @see set_position_type()
 */
void set_position_multiple(int mult) {
   if (!position_on) {
      position_on = allocate(POSITION_ARRAY_SIZE);
   }
   position_on[POS_MULTIPLE] = mult;
} /* set_position_multiple() */

/**
 * This returns fact that the object being referenced is one of many.  So
 * you get something more like 'xx is sitting on one of the couches'.
 * @return 0 if non-multiple, 1 if multiple
 * @see query_position_on()
 * @see query_position_multiple()
 * @see query_position_type()
 * @see set_position()
 * @see set_position_on()
 * @see set_position_multiple()
 * @see set_position_type()
 */
int query_position_multiple() {
   if (!position_on) {
      return 0;
   }
   return position_on[POS_MULTIPLE];
} /* query_position_multiple() */

/**
 * This sets way the object is being referenced.  The 'on', 'at', 'beside'
 * or whatever strings.
 * @param type the new type string
 * @see query_position()
 * @see query_position_on()
 * @see query_position_multiple()
 * @see query_position_type()
 * @see set_position()
 * @see set_position_on()
 * @see set_position_multiple()
 */
void set_position_type(string type) {
   if (!position_on) {
      position_on = allocate(POSITION_ARRAY_SIZE);
   }
   position_on[POS_TYPE] = type;
} /* set_position_type() */

/**
 * This returns way the object is being referenced.
 * The 'on', 'at', 'beside'
 * or whatever strings.
 * @return the current type string
 * @see query_position()
 * @see query_position_on()
 * @see query_position_multiple()
 * @see set_position()
 * @see set_position_on()
 * @see set_position_multiple()
 * @see set_position_type()
 */
string query_position_type() {
   if (!position_on ||
       !position_on[POS_TYPE]) {
      return "on";
   }
   return position_on[POS_TYPE];
} /* query_position_type() */

/**
 * This queries the current object being referenced.  This can be an
 * object or a string.
 * @return the current object being referenced
 * @see query_position()
 * @see query_position_multiple()
 * @see query_position_type()
 * @see set_position()
 * @see set_position_on()
 * @see set_position_multiple()
 * @see set_position_type()
 */
object query_position_on() {
   if (!position_on) {
      return 0;
   }
   return position_on[POS_ON_OBJECT];
} /* query_position_on() */

/**
 * This method returns the short description of the object
 * we are referencing.
 * @return the short description of the object, "" if none
 * @see query_position_on()
 * @see set_position_on()
 * @see query_position_long()
 */
string query_position_on_short() {
   if (!position_on || !position_on[POS_ON_OBJECT]) {
      return "";
   }
   if (stringp(position_on[POS_ON_OBJECT])) {
      return position_on[POS_ON_OBJECT];
   }
   return position_on[POS_ON_OBJECT]->the_short();
} /* query_position_on_short() */

/**
 * This method returns the string used in the long description of the
 * living object.
 * @return the long description of the position
 * @see query_position_type()
 * @see query_position_on_short()
 */
string query_position_long() {
   if (position != STANDING || position_on) {
      if (position_on) {
         return query_pronoun() + " is " + query_position_type() + " "+
                query_position_on_short()+".\n";
      }
      return query_pronoun()+" is "+position+" on the floor.\n";
   }
   return "";
} /* query_position_long() */

/**
 * This method returns the description used in the inventory listing
 * code.
 * @return the string used in inventory listings
 * @see query_position_long()
 * @see query_position_on_short()
 * @see query_position_type()
 */
string query_position_short() {
   if (!position_on ||
       !position_on[POS_ON_OBJECT]) {
      return position;
   }
   return position + " " + query_position_type() + " " +
          query_position_on_short();
} /* query_position_short() */

/**
 * This method returns 1 if the creature is trapped, ie cannot walk.
 * By default, a creature is free to walk, hence the normal return
 * value of 0.  If you shadow this method, including a message about
 * why the player cannot move move is a good idea.
 * @param verb the exit direction that the player is trying to move.
 * @param dest_other the destination information for the exit.
 * @see /std/room->query_dest_other()
 * @return 0 means creature is free to move, 1 that it is trapped.
 */
varargs int cannot_walk( string verb, mixed *dest_other) {
   return 0;
}

/**
 * This method can be shadowed by all forms of magical and
 * religious shields so that the shields command will give
 * the player a nice description.
 * The first element in the array should contain the description
 * as shown to the player, the second element should contain the
 * description shown to others.
 * @example ({ "You have a nice shield.", "He has a nice shield." })
 * @return Array with description of shield.
 */
string *query_arcane_shields() { return ({ }); }

/** @ignore yes */
int can_find_match_reference_inside_object(object thing, object looker) {
   if (member_array(thing, query_wearing_hidden(looker, 0)) != -1) {
      return 0;
   }
   return 1;
} /* can_find_match_reference_inside_object() */

/**
 * If there is no mapping for deity favour, or if the God is not mentioned, 
 * return 0 as 'no favour'.
 * Otherwise return the favour amount.
 * @args God Name of God
 */
int query_deity_favour( string god ) {
  if ( !mapp( deity_favour ) ) 
    return 0;

  if ( !undefinedp( deity_favour[ god ] ) ) 
    return 0;

  return deity_favour[ god ];
}

/**
 * Adjust the favour rating for 'god' by amount.
 * A +ve amount is good favour, a negative is bad.
 */
void adjust_deity_favour( string god, int amount ) {

  if ( !mapp( deity_favour ) ) 
    deity_favour = ([ ]);
  
  if ( !undefinedp( deity_favour[ god ] ) ) 
    deity_favour[ god ] = amount;

  deity_favour[ god ] += amount;

  if ( deity_favour[ god ] > MAX_FAVOUR )
    deity_favour[ god ] = MAX_FAVOUR;

  if ( deity_favour[ god ] < -MAX_FAVOUR )
    deity_favour[ god ] = -MAX_FAVOUR;

  return;
}

/**
 * Return the deity favour mapping.
 */
mapping query_all_deity_favour() { return deity_favour; }
// --- END [/mnt/home2/grok/lib/std/living/living.eff_shad.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/living/living.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/living/living.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628844   Available: 13576198
Inodes: Total: 5242880    Free: 4960135
42966 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/living/living.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628844   Available: 13576198
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker: pinkfish $
 * $Id: living.c,v 1.73 2003/04/30 18:22:59 ceres Exp pinkfish $
 *
 */
/**
 * The main living inherit.  This inherits all the files
 * needed to be in a living object.
 * @author Pinkfish
 */
#include <dirs.h>
#include <drinks.h>
#include <living.h>
#include <move_failures.h>
#include <player.h>
#include <tune.h>
#include <position.h>
#include <obj_parser.h>

inherit "/std/container";
inherit "/std/living/armour";
inherit "/std/living/carrying";
inherit "/std/living/combat";
inherit "/std/living/force";
inherit "/std/living/gender";
inherit "/std/living/health";
inherit "/std/living/holding";
inherit "/std/living/money";
inherit "/std/living/skills";
inherit "/std/living/spells";
inherit "/std/living/crafts";
inherit "/std/living/stats";
inherit "/std/living/respond_cmd";
inherit "/std/living/nationality";

#define VERBOSE_TYPES ({"combat", "look", "score", "names", "htell", "finger", "errors", "quit"})

//The maximum amount of religious favour you can have.
#define MAX_FAVOUR 100

class living_data {
  int handicap;
  int burden;
  object* followers;
  class obj_match_context it_them;
  object* to_drop;
  int burden_call;
}

class messages {
   string msgout;
   string msgin;
   string mmsgout;
   string mmsgin;
}

private int alignment;
private class messages _messages;
private mixed *facing;
private mapping verbose;
private mapping abs_facing = ABS_FACING;
private mapping lengthen = LENGTHEN;

//Got religion?
private string deity;         //Your deity of choice.
private mapping deity_favour; //A mapping of deity ratings.

//private nosave object _dragging;
private nosave class living_data _liv_data;
//private nosave int _handicap;
//private nosave object *_followers;
//private nosave class obj_match_context _it_them;
//private nosave object* _to_drop;
//private nosave int _burden_call;

void return_to_default_position(int leaving);
void set_position(string name);
void set_position_on(mixed ob);
void set_position_multiple(int mult);
void set_position_type(string type);
object query_position_on();
protected mixed command(string);

/*
 * What position are they in?  Standing, sitting, lying, froging?
 */
private nosave string position;
private nosave mixed default_position;
private /* This will force an object to not use the position from the room. */
nosave int always_use_default_position;
/* in case they are standing on something or something... */
private nosave mixed position_on;

void create() {
   string t;

   _liv_data = new(class living_data);
   _messages = new(class messages);
   crafts::create();
   container::create();
   armour::create();
   combat::create();
   health::create();
   holding::create();
   skills::create();
   spells::create();
   respond_cmd::create();
   enable_commands();
   reset_can_export_inventory();
   reset_effects();
   _messages->msgin = "$N arrive$s from $F.";
   _messages->msgout = "$N leave$s $T.";
   _messages->mmsgin = "$N appear$s out of the ground.";
   _messages->mmsgout = "$N disappear$s in a puff of smoke.";
   _liv_data->followers = ({ });
   verbose = ([ ]);
   set_max_items(50);
   _liv_data->to_drop = ({ });
   foreach(t in VERBOSE_TYPES) {
      verbose[t] = 1;
   }

   facing = ({ 0, ({ "north", "northeast", "east", "southeast", "south",
         "southwest", "west", "northwest" }), ({ "up", "down" }) });
   position = STANDING;

   add_adjective("living");
} /* create() */

/** @ignore yes */
void heart_beat() {
  stats::heart_beat();
  combat::heart_beat();
}

/**
 * This method returns the pronoun string of the living object.
 * A pronoun is "he", "she", "it".
 * @return the pronoun string
 */
string query_pronoun() {
   return gender::query_pronoun();
} /* query_pronoun() */

/**
 * This method returns the prossessive string of the living object.
 * A possessive is "her", "his", "its".
 * @return the possessive string
 */
string query_possessive() {
   return gender::query_possessive();
} /* query_possessive() */

/**
 * This method returns the objective string of the living object.
 * An objective is "her", "him", "it".
 * @return the objective string
 */
string query_objective() {
   return gender::query_objective();
} /* query_objective() */

/** @ignore yes */
varargs int query_weight(int actual) {
  if(!actual && this_object()->query_property("dead"))
    return 0;
  return stats::query_weight();
}

/**
 * This method returns the current burden level of the living
 * object.  This is returned as a percentage of the maximum
 * weight that the living can carry.
 * @return the burden level (0-100)
 */
int query_burden() {
  return _liv_data->burden;
} /* query_burden() */

/**
 * This method returns the current handicap of the living
 * object.
 * @return the current handicap.
 * @see calc_burden()
 */
int query_handicap() { return _liv_data->handicap; }

/**
 * This method calculates the current handicap of the living
 * object.  The handicap is based on the burden of the
 * person, the more burdened the higher the handicap.  The
 * handicap is 1 point of dexterity for every 25% burdened.
 * @see query_handicap()
 * @see query_burden()
 */
void calc_burden() {
  int new_handicap;
  int burden;
  object thing;
  mapping hands;
  
  _liv_data->burden_call = 0;
  
  update_loc_weight();
  burden = query_loc_weight();
  foreach(thing in query_wearing())
    burden -= (int)thing->query_complete_weight() / 2;

  hands = ([ ]);
  foreach(thing in query_holding())
    if(objectp(thing))
      hands[thing]++;

  foreach(thing in keys(hands))
    burden += (int)thing->query_complete_weight() / hands[thing];

  if(!query_max_weight()) {
    this_object()->reset_carry_cap();
    _liv_data->burden = 50;
  } else
    _liv_data->burden = (100 * burden) / query_max_weight();
  
  new_handicap = (_liv_data->burden / 25) - 1;
  if(new_handicap < 0)
    new_handicap = 0;
  
  if ( _liv_data->handicap != new_handicap ) {
    adjust_bonus_dex( _liv_data->handicap - new_handicap );
    _liv_data->handicap = new_handicap;
  }
}

/**
 * This method returns the string representation of the current
 * burden level.
 * @return the burden string
 * @see calc_burden()
 * @see query_burden()
 */
string burden_string() {
  switch (_liv_data->handicap) {
  case 0 :
    return "unburdened";
  case 1 :
    return "burdened";
  case 2 :
    return "heavily burdened";
  case 3 :
    return "very heavily burdened";
  default :
    return "incredibly heavily burdened";
  }
} /* burden_string() */

/**
 * This method adds any commands needed by the living inherit.
 */
void living_commands() {
#if efun_defined(add_action)
   add_action( "exit_command", "*", 1 );
#endif
} /* living_commands() */

/**
 * This method allows you to make the living object eat something.
 * @param food the food object to eat
 */
void eat_this( object food ) {
  this_object()->bypass_queue();
  command( "eat " + file_name( food ) );
} /* eat_this() */

/**
 * This method handles the cannot get flags.  This is placed
 * into the living object so that things which are marked as
 * being unable to be picked up can still be put into normal
 * containers.  The upwards checking of containers stops here.
 * This should make it so that objects marked as unable to be
 * picked up cannot be put into objects in the players
 * inventory.
 * @return 1 if the object can be added, 0 if not.
 */
int test_add(object ob, int flag) {
  if(sizeof(all_inventory(this_object())) > query_max_items())
    return 0;
  
  return !flag;
}

/**
 * This method handles the cannot drop flags.  This is placed
 * into the living object so that things which are marked as
 * being unable to be dropped can still be remove from normal
 * containers.  This does all sorts of other exciting checks
 * now.
 * @return 1 if the object can be added, 0 if not.
 */
int test_remove( object ob, int flag, mixed dest ) {
   object thing;

   if ( flag ) {
      return 0;
   }
   if ( !this_player() || ( this_player() == this_object() ) ) {
      return !flag;
   }
   if ( stringp( dest ) ) {
      thing = find_object( dest );
   }
   if ( objectp( dest ) ) {
      thing = dest;
      dest = file_name( dest );
   }
   if ( thing->query_corpse() || ( dest == "/room/rubbish" ) ) {
      return !flag;
   }
/*
 * True theft commands should return 1 to query_theft_command().
 *  Things like the ritual "fumble" and the command "disarm" should return -1.
 */
   if ( sizeof( filter_array( previous_object( -1 ),
         (: $1->query_theft_command() :) ) ) ) {
      return !flag;
   }
/* We should now only be considering things like "get", "take" and "palm". */
   if ( !query_property( PASSED_OUT ) ) {
      return 0;
   }
   if ( !pk_check( this_player(), this_object() ) ) {
      event( environment( this_player() ), "theft", this_player(),
            this_object(), ob );
      return !flag;
   }
   write( "An unseen force stays your hand.\n" );
   return 0;
} /* test_remove() */

/**
 * This method returns the current alignment of the living
 * object.
 * @return the current alignment
 * @see set_al()
 * @see adjust_al()
 * @see adjust_alignment()
 * @see align_string()
 */
int query_al() { return alignment; }

/**
 * This method sets the current alignment of the living
 * object.
 * @param number the new alignment for the object
 * @see query_al()
 * @see adjust_al()
 * @see adjust_alignment()
 * @see align_string()
 */
void set_al( int number ) { alignment = number; }

/**
 * This method adjusts the current alignment of the living
 * object.
 * @param number the amount to change the alignment by
 * @return the new alignment
 * @see query_al()
 * @see set_al()
 * @see adjust_alignment()
 * @see align_string()
 */
int adjust_al( int number ) {
   alignment += number;
   if ( alignment < -MAX_AL ) {
      alignment = -MAX_AL;
   }
   if ( alignment > MAX_AL ) {
      alignment = MAX_AL;
   }
   return alignment;
} /* adjust_al() */

/**
 * This method adjusts the current alignment of the living
 * object.  This is called when an object dies and handles the
 * mangling of the change value based on the current alignment and
 * the alignment of the thing dieing.
 * @param number the amount to change the alignment by
 * @return the new alignment
 * @see query_al()
 * @see adjust_al()
 * @see set_al()
 * @see align_string()
 */
int adjust_alignment( int number ) {
  int change;

  // To become more evil you must kill something that is at least 20%
  // good as you are evil and vice versa.
  change = - (number + alignment/5);

  // This stops the changes being too extreme. Increase this for smaller
  // changes, decrease it for larger ones.
  change /= 20;

  // Now wasn't that nice and easy? :-)
  return adjust_al( change );
} /* adjust_alignment() */

/**
 * This method returns the string associated with the current
 * alignment of the living object.
 * @return the string associated with the alignment
 * @see query_al()
 * @see adjust_al()
 * @see adjust_alignment()
 * @see set_al()
 */
string align_string() {
   switch ( alignment ) {
      case -MAX_AL .. -5001 : return "extremely good"; break;
      case -5000 .. -2501 : return "very good"; break;
      case -2500 .. -1251 : return "quite good"; break;
      case -1250 .. -601 : return "good"; break;
      case -600 .. -301 : return "barely good"; break;
      case -300 .. 300 : return "neutral"; break;
      case 301 .. 600 : return "barely evil"; break;
      case 601 .. 1250 : return "evil"; break;
      case 1251 .. 2500 : return "quite evil"; break;
      case 2501 .. 5000 : return "very evil"; break;
      default : return "extremely evil"; break;
   }
} /* align_string() */

/**
 * This method returns the current deity the living object is
 * worshipping.
 * @return the current deity
 * @see /obj/handlers/diety_handler
 * @see set_deity()
 */
string query_deity() { return deity; }
/**
 * This method sets the current deity the living object is
 * worshipping.
 * @param word the new deity
 * @see /obj/handlers/diety_handler
 * @see query_deity()
 */
void set_deity( string word ) { deity = word; }

/**
 * This is the method used to query the current message to use when
 * entering a room.   A $N in the string will be expanded to the
 * name and a $F will be expanded to the from direction.
 * @return the message to print when entering a room.
 * @see /obj/handlers/room_handler
 * @see query_msgout()
 * @see set_msgin()
 */
string query_msgin() { return _messages->msgin; }
/**
 * This is the method used to query the current message to use when
 * exiting a room.   A $N in the string will be expanded to the
 * name and a $T will be expanded to the to direction.
 * @return the message to print when entering a room.
 * @see /obj/handlers/room_handler
 * @see query_msgin()
 * @see set_msgout()
 */
string query_msgout() { return _messages->msgout; }

/**
 * This is the method used to set the current message to use when
 * entering a room.   A $N in the string will be expanded to the
 * name and a $F will be expanded to the from direction.
 * @param str the message to print when entering a room
 * @see /obj/handlers/room_handler
 * @see query_msgin()
 * @see set_msgout()
 */
int set_msgin(string str) {
   if (strsrch(str, "$N") == -1 || strsrch(str, "$F") == -1) {
      return 0;
   }
   _messages->msgin = str;
   return 1;
} /* set_msgin() */
/**
 * This is the method used to query the current message to use when
 * exiting a room.   A $N in the string will be expanded to the
 * name and a $T will be expanded to the to direction.
 * @return the message to print when entering a room.
 * @see /obj/handlers/room_handler
 * @see query_msgout()
 * @see set_msgin()
 */
int set_msgout(string str) {
   if (strsrch(str, "$N") == -1 || strsrch(str, "$T") == -1) {
      return 0;
   }
   _messages->msgout = str;
   return 1;
} /* set_msgout() */

/**
 * THis is the message to be used when the person is teleported.
 * @return the in message when they teleport
 */
string query_mmsgin() { return _messages->mmsgin; }
/**
 * THis is the message to be used when the person is teleported.
 * @return the out message when they teleport
 */
string query_mmsgout() { return _messages->mmsgout; }

/**
 * The teleport in message.  Sets the message to be seen when
 * a player telerpots into the room.
 * @param str the message to be seen
 */
int set_mmsgin(string str) {
   if (strsrch(str, "$N") == -1) {
      return 0;
   }
   _messages->mmsgin = str;
   return 1;
} /* set_mmsgin() */

/**
 * Sets the teleport out message.  If the player teleports out, this
 * is the message seen.
 * @param str the teleport message
 */
int set_mmsgout(string str) {
   if (strsrch(str, "$N") == -1) {
      return 0;
   }
   _messages->mmsgout = str;
   return 1;
} /* set_mmsgout() */

mixed *query_facing() { return copy( facing ); }

/**
 * The facing array is a list of directions and two integers which determine
 * which way we face.  The layout is:<br>
 * ({ facing, ({ dirs }), up_down_facing, ({ up_down_dirs }) })
 * @param args the facing arguments
 */
void set_facing( mixed *args ) { facing = args; }

/**
 * This method finds the relative direction from the passed in direction.
 * @param word the exit name ('east', 'west',...)
 * @param from the offset to find the exit from
 * @return the relative direction
 */
string find_rel( string word, int from ) {
  int i;

  i = member_array( word, facing[ 1 ] );
  if ( i != -1 ) {
    i = ( i + 8 - facing[ 0 ] ) % 8;
    return REL_DIRS[ 3 * i + from ];
  }
  i = member_array( word, facing[ 2 ] );
  if ( i != -1 ) {
    return ({ "up", "down" })[ i ];
  }
  return word;
} /* find_rel() */

/**
 * Finds the absolute direction from the input relative direction.
 * @param word the exit name ('left', 'right', ...)
 * @return the absolute direction
 */
string find_abs( string word ) {
  int i;

  i = member_array( word, REL_DIRS );
  if ( i != -1 ) {
    i = ( i / 3 + facing[ 0 ]) % 8;
    return facing[ 1 ][ i ];
  }
  i = member_array( word, ({ "up", "down" }) );
  if ( i != -1 ) {
    return facing[ 2 ][ i ];
  }
  return word;
} /* find_rel() */

/**
 * This method takes in a relative direction and reorients us in the correct
 * way to go in that direction.  This also updates our facing so we are
 * facing in the specified relative direction.
 * @param word the direction to look up
 * @return the real direction
 */
string reorient_rel( string word ) {
  int i;

  i = member_array( word, REL_DIRS );
  if ( i != -1 ) {
    i = ( i / 3 + facing[ 0 ] ) % 8;
    facing[ 0 ] = i;
    return facing[ 1 ][ i ];
  }
  i = member_array( word, ({ "up", "down" }) );
  if ( i != -1 ) {
    return facing[ 2 ][ i ];
  }
  return word;
} /* reorient_rel() */

/**
 * This method takes in a absolute direction and reorients us in the correct
 * way to go in that direction.
 * @param word the direction to look up
 */
void reorient_abs( string verb ) {
  if ((ABS_FACING)[verb]) {
    facing[0] = (ABS_FACING)[verb] % 8;
  }
} /* reorient_rel() */

/**
 * This method sets the object for us to drag when we try and leave.
 * @param thing the object to drag off
 */
void set_dragging( object thing ) { add_property("dragging", thing); }

/**
 * This method returns the object we are dragging.
 * @return the thing we are dragging
 */
object query_dragging() { return query_property("dragging"); }

/**
 * This method resets the object we are dragging.
 */
void reset_dragging() { add_property("dragging", 0); }

/**
 * This is used by the movement system to look in the room when we move.
 * It does checks for verbose and other checks before doing the look.
 */
int room_look() {
   if ( query_property( UNKNOWN_MOVE ) || !( interactive( this_object() ) ||
         this_object()->query_slave() ) )
      return 0;
   /* These need to be evaluated immediately, hence the bypass_queue() call. */
   if(!mapp(verbose))
     verbose = ([ ]);

   if(verbose && verbose["look"]) {
      this_object()->ignore_from_history( "look" );
      this_object()->bypass_queue();
      command( "look" );
   } else {
      this_object()->ignore_from_history( "glance" );
      this_object()->bypass_queue();
      command( "glance" );
   }
   return 1;
} /* room_look() */

/**
 * This method returns the current verbose mode setting of the player.
 * @param the type of verbosity, by default it will return the normal stuff.
 * @return the verbose mode of the player
 */
int query_verbose(string type) {
  if(!verbose || !mapp(verbose)) {
    verbose = ([ ]);
  }
  return verbose[type];
} /* query_verbose() */

/**
 * This method sets the verbosity for a given type.
 */
void set_verbose(string type, int val) {
  if(!verbose || !mapp(verbose)) {
    verbose = ([ ]);
  }

  if(member_array(type, VERBOSE_TYPES) != -1) {
    verbose[type] = val;
  }
}

/**
 * This method returns the current verbose/brief types.
 */
string *query_verbose_types() {
  return VERBOSE_TYPES;
}

varargs int move_with_look( mixed dest, string messin, string messout ) {
   return_to_default_position(1);
   if ( (int)this_object()->move( dest, messin, messout ) != MOVE_OK )
      return 0;
   room_look();
   return_to_default_position(1);
   return 1;
} /* move_with_look() */

varargs int exit_command( string word, mixed verb, object thing, int redirection ) {
   string special_mess, *bits, *exits, redirect;
   int temp;

   if ( !environment() ) {
      return 0;
   }

   if ( !verb ) {
      verb = word;
      bits = explode( word, " " );
      if ( sizeof( bits ) > 1 ) {
         word = implode( bits[ 1 .. ], " " );
      } else {
         word = "";
      }
   } else {
      if ( pointerp( verb ) ) {
         special_mess = verb[ 1 ];
         verb = verb[ 0 ];
      }
      bits = explode( verb, " " );
      if ( sizeof( bits ) > 1 ) {
         word = implode( bits[ 1 .. ], " " );
      } else {
         word = "";
      }
   }
   if ( lengthen[ verb ] ) {
      verb = lengthen[ verb ];
   }
   exits = (string *)environment()->query_exits();
   if ( !exits ) {
      return 0;
   }

   if ( member_array( verb, exits ) != -1 ) {
     if ( environment()->query_relative( verb ) ) {
       return 0;
     }

     if ((abs_facing)[verb]) {
       facing[0] = (abs_facing)[verb] % 8;
     }
   } else {
     if (member_array(find_abs(verb), exits ) == -1 ) {
       return 0;
     }
     verb = reorient_rel(verb);
   }
   if ( !thing ) {
      thing = this_object();
   }

    //If the player has redirection enabled!
    //Redirection returns a string which is an alternative exit to try.
    //It calls exit_command to do all of the proper checks before hand,
    //it blocks recursion by way of a flag which is passed as the fourth arg
    //in exit command.
    if ( !redirection ) {
        if ( stringp( redirect = thing->query_exit_redirection( word ) ) ) {
            if ( temp = this_object()->exit_command( verb, redirect, thing, 1 ) ) 
                return temp;
        }
    }

   return (int)"/obj/handlers/room_handler"->exit_move( verb, word,
         special_mess, thing );
} /* exit_command() */

void become_flummoxed() {
   int will;

   will = query_int() * query_wis();
   if ( will < random( WILL_POWER ) )
      this_object()->interrupt_ritual();
   if ( will < random( WILL_POWER ) )
      this_object()->interrupt_spell();
   if ( will < random( WILL_POWER ) )
      this_object()->stop_all_fight();
} /* become_flummoxed() */

int run_away() {
   int i;
   object old_env;
   mixed *direcs;
   
   direcs = (mixed *)environment()->query_dest_dir(this_object());
   old_env = environment();
   while ( sizeof( direcs ) ) {
      i = random( sizeof( direcs ) / 2 ) * 2;
      if ( exit_command( direcs[i] ) ) {
          event( old_env, "run_away", direcs[ i ], direcs[ i + 1 ] );
          return 1;
      }

      direcs = delete( direcs, i, 2 );
   }
   return 0;
} /* run_away() */

/* Now handled in test_remove().
int cannot_get_stuff() { return !query_property( PASSED_OUT ); }
*/

/** @ignore yes */
mixed *stats() {
   return container::stats() + stats::stats() + ({
           ({ "max_hp", max_hp }),
           ({ "hp",  hp }),
           ({ "max_gp", max_gp }),
           ({ "gp", gp }),
           ({ "alcohol", drink_info[ D_ALCOHOL ] }),
           ({ "food", drink_info[ D_FOOD ] }),
           ({ "drink", drink_info[ D_DRINK ] }),
           ({ "gender", query_gender_string() }),
           ({ "alignment", this_object()->query_al() }),
           ({ "deity", deity }),
           ({ "total money", query_value() }),
           ({ "xp", query_xp() }),
   }) + armour::stats() + combat::stats();
} /*  stats() */

/**
 * This method returns the current array used for calculating 'it' and
 * 'them' in the find_match code.
 * @return the array of objects matching them
 * @see /secure/simul_efun->find_match()
 * @see set_it_them()
 */
class obj_match_context query_it_them() { return _liv_data->it_them; }
/**
 * This method sets the current array used for calculating 'it' and
 * 'them' in the find_match code.
 * @param args the new array of objects
 * @see /secure/simul_efun->find_match()
 * @see query_it_them()
 */
void set_it_them( class obj_match_context args) { _liv_data->it_them = args; }

/**
 * This method adds a follower to the living object.  A follower will
 * happily follow around the person in front.  Used in the follow
 * command.
 * @param ob the object to follow us
 * @see remove_follower()
 * @see query_followers()
 * @return 1 on success, 0 on failure
 */
int add_follower(object ob) {
  if (ob == this_object()) {
    return 0;
  }
  if (member_array(ob, _liv_data->followers) == -1) {
    _liv_data->followers += ({ ob });
  }
  return 1;
} /* add_follower() */

/**
 * This method removes a follower from the living object.  A follower will
 * happily follow around the person in front.  Used in the unfollow
 * and lose commands.
 * @param ob the object to remove from the follow list
 * @see add_follower()
 * @see query_followers()
 * @return 1 on success, 0 on failure
 */
int remove_follower(object ob) {
  int i;

  i = member_array(ob, _liv_data->followers);
  if (i != -1) {
    _liv_data->followers = delete(_liv_data->followers, i, 1);
    return 1;
  }
  return 0;
} /* remove_follower() */

/**
 * This is a method to check to see if this object can actually follow
 * the person they are following.
 * @param thing the thing following us
 * @param verb the direction they are going to
 * @param special any special stuff
 * @return 1 if we are allowed to go there, 0 otherwise
 */
int check_doing_follow(object thing, string verb, string special) {
   return 1;
} /* check_doing_follow() */

/**
 * This method returns the current room of the object.  This was needed
 * previously to use in things like unique_array, before function
 * pointers came into existance.
 * @return the environment of the object
 */
object query_current_room() { return environment(); }

/**
 * This method returns the current list of followers to the living
 * object.
 * @see add_follower()
 * @see remove_follower()
 */
mixed *query_followers() { return copy(_liv_data->followers - ({ 0 })); }

/** @ignore yes */
varargs void adjust_money(mixed amt, string type) {
  return money::adjust_money(amt, type);
} /* adjust_money() */

/** @ignore yes */
mixed *query_money_array() {
  return money::query_money_array();
} /* query_money_array() */

/** @ignore yes */
int query_money(string type) {
  return money::query_money(type);
} /* query_money() */

/** @ignore yes */
int query_value() { return money::query_value(); }

void do_burden_call() {
  if(_liv_data->burden_call)
    remove_call_out(_liv_data->burden_call);
  
  _liv_data->burden_call = call_out("calc_burden", 1);
}

int query_burden_limit() {
  if (this_object()->query_creator()) { 
    return MAX_CREATOR_INVEN;
  } else {
    return MAX_INVEN;
  }
} /* query_burden_limit() */ 

/** @ignore yes */
void event_enter( object thing, string mess, object from ) {
  if(environment( thing ) == this_object()) {
    do_burden_call();
    
    if(sizeof(all_inventory()) > query_burden_limit() ) {
      _liv_data->to_drop += ({ thing });
      remove_call_out("test_number_of_items");
      call_out("test_number_of_items", 5 + random(5));
    }
  }
}

/** @ignore yes */
void event_exit( object thing, string mess, object to ) {
  if(environment(thing) == this_object()) {
    do_burden_call();
  }
}

/** @ignore yes */
void test_number_of_items() {
   int how_many;
   object thing, *things, *dropped;

   things = all_inventory() - query_armours() - query_holding();
   how_many = sizeof(things) - query_burden_limit();
   if ( how_many < 1 ) {
      return;
   }

   _liv_data->to_drop -= ({ 0 });

   dropped = ({ });
   while(how_many > 0 && sizeof(things)) {
      if (sizeof(_liv_data->to_drop)) {
         thing = _liv_data->to_drop[random(sizeof(_liv_data->to_drop))];
      } else {
         thing = things[random(sizeof(things))];
      }
      things -= ({ thing });
      _liv_data->to_drop -= ({ thing });

      if(!thing || !thing->short() || thing->drop() ||
         thing->query_property("cannot fumble") ||
         thing->id("coin") ||
         environment(thing) != this_object()) {
        continue;
      }

      if((int)thing->move(environment()) == MOVE_OK) {
        how_many--;
        dropped += ({ thing });
      }
   }

   _liv_data->to_drop = ({ });

   if(sizeof(dropped)) {
     tell_object( this_object(), "Whoops!  You tried to carry too many "
                  "things and fumbled "+
                  query_multiple_short( dropped ) +".\n" );
     this_object()->dest_hide_shadow();
     tell_room( environment(), capitalize( the_short() ) +" juggles "+
                "around "+ query_possessive() +" stuff and fumbles "+
                query_multiple_short( dropped ) +".\n", this_object() );
   }
}

/**
 * This forces a burden recalculation.  This should also be used to
 * force a recalcuation of the number of items someone can carry.
 */
void force_burden_recalculate() {
   do_burden_call();
   remove_call_out("test_number_of_items");
   call_out("test_number_of_items", 5 + random(5));
}

/** @ignore yes */
object *find_inv_match( string words, object looker ) {
   return sort_array( container::find_inv_match( words, looker ),
         (: ( member_array( $1, query_holding() ) != -1 ? -1 : 0 ) :) );
} /* find_inv_match() */

/** @ignore yes */
int attack_by(object ob) {
   return_to_default_position(0);
   return ::attack_by(ob);
} /* attack_by() */

/** @ignore yes */
int attack_ob(object ob) {
   return_to_default_position(0);
   return ::attack_ob(ob);
} /* attack_ob() */

/**
 * This method sets the always the flag to always use the default position.
 * If this is set then rooms cannot override the position message which is
 * displayed by the object.
 * @param flag if we should always use the default position
 * @see query_always_use_default_position()
 * @see set_default_position()
 * @see return_to_default_position()
 */
void set_always_use_default_position(int flag) {
   always_use_default_position = flag;
} /* set_always_use_default_position() */

/**
 * This method sets the always the flag to always use the default position.
 * If this is set then rooms cannot override the position message which is
 * displayed by the object.
 * @return the always use default position flag
 * @see set_always_use_default_position()
 * @see set_default_position()
 * @see return_to_default_position()
 */
int query_always_use_default_position() {
   return always_use_default_position;
} /* query_always_use_default_position() */

/**
 * This method sets the default position of the object.  This is used to
 * allow things to default to some other exciting off beat and froopy
 * default position.  The value returned by this is the command code
 * used to put the object back into the default position or an
 * array which contains three or one elements, the first is the string
 * to use as the position, the second and third (if they exist) are
 * the string to tell the person when changing and the string to tell
 * everyone else when changing position.
 * @return the default position
 * @see set_default_position()
 * @see return_to_default_position()
 * @see set_always_use_default_position()
 */
string query_default_position() {
   mixed pos;

   if (stringp(default_position) &&
              default_position->query_position_command()) {
      pos = default_position;
   } else if (pointerp(default_position) &&
              (sizeof(default_position) == POSITION_MESS_SIZE ||
               sizeof(default_position) == POSITION_ONLY_TYPE_SIZE)) {
      pos = default_position;
   } else if (functionp(default_position)) {
      pos = default_position;
   }

   if (!pos) {
      pos = STANDING_CMD;
   }

   return pos;
} /* query_default_position() */

/**
 * This sets the default position of the object.  This is used to
 * allow things to default to some other exciting off beat and froopy
 * default position.  The paramater to this is the command code
 * used to put the object back into the default position or an
 * array which contains three or one elements, the first is the string
 * to use as the position, the second and third (if they exist) are
 * the string to tell the person when changing and the string to tell
 * everyone else when changing position.  The paramer can also be
 * a function pointer, if it is then it will be evaluated and
 * have two parameters passed into the function.  The first is
 * the object returing to the position and the second is the leaving
 * flag.
 * <p>
 * Please note!  After setting the position you will need to
 * make the object return to the default position to use it.
 * <p>
 * A second note!  A room can also define a query_default_position()
 * function which will be called, if this returns a value (and the
 * override flag is not set) then that will be used for the default
 * position.
 * @param str the new default position
 * @see query_default_position()
 * @see set_always_use_default_position()
 * @see /obj/monster()->set_cannot_change_position()
 * @see return_to_default_position()
 * @example
 * set_default_position("/cmds/living/kneel");
 * @example
 * set_default_position(({ "running" }));
 * @example
 * set_default_position(({ "fishing",
 *                         "You start to fish.\n",
 *                         the_short() + " starts to fish.\n" }));
 * @example
 * npc->set_default_position(({ "running" }));
 * npc->return_to_default_position(1);
 */
void set_default_position(mixed str) {
   if (stringp(str) && str->query_position_command() && str != STANDING_CMD) {
      default_position = str;
   } else if (!str || str == STANDING_CMD) {
      default_position = 0;
   } else if (pointerp(str) && (sizeof(str) == POSITION_ONLY_TYPE_SIZE ||
                                sizeof(str) == POSITION_MESS_SIZE)) {
      default_position = str;
   } else if (functionp(str)) {
      default_position = str;
   }
} /* set_default_position() */

/**
 * This method returns the living object to its default position.
 * @param leaving this is if we are leaving the room
 * @see set_default_position()
 * @see query_default_position()
 * @see set_always_use_default_position()
 */
void return_to_default_position(int leaving) {
   mixed pos;

   /* See if we are being forced to always use the set default position. */
   if (query_always_use_default_position()) {
      pos = query_default_position();
   } else {
      /* See if the room has a default position they wish to tell us about. */
      pos = 0;
      if (environment()) {
         pos = environment()->query_default_position(this_object());
      }
      if (!pos) {
         pos = query_default_position();
      }
   }

   if (functionp(pos)) {
      if (!evaluate(pos, this_object(), leaving)) {
         pos = 0;
         /* See if the environment has any special conditions */
         if (environment()) {
            pos = environment()->query_default_position(this_object());
         }
         if (!pos) {
            pos = STANDING_CMD;
         }
      }
   }

   if (stringp(pos)) {
      /* If we are not standing up...  Stand up... */
      if (position != pos->query_position_type() ||
          (leaving && query_position_on())) {
         if (leaving) {
            catch(pos->position_floor(this_object()));
         } else {
            /*
             * If they are not leaving, just get them to stand up or
             * whatever, this way people can fight on chairs and
             * stuff...
             */
            catch(pos->position(this_object()));
         }
      }
   } else if (pointerp(pos) && position != pos[POSITION_TYPE_INDEX]) {
      /* If it is a pointer, then we do something special... */
      if (sizeof(pos) > 1) {
         if (pos[POSITION_ME_MESS_INDEX]) {
            tell_object(this_object(), pos[POSITION_ME_MESS_INDEX]);
         }
         if (pos[POSITION_REST_MESS]) {
            tell_room(environment(), pos[POSITION_REST_MESS], this_object());
         }
      }
      set_position(pos[POSITION_TYPE_INDEX]);
      set_position_on(0);
      set_position_type(0);
      set_position_multiple(0);
   }
} /* return_to_default_position() */

/**
 * This sets the current position of the object.
 * @param name the string to use for the position
 * @see query_position()
 * @see query_position_on()
 * @see query_position_multiple()
 * @see query_position_type()
 * @see set_position_on()
 * @see set_position_multiple()
 * @see set_position_type()
 */
void set_position(string name) {
   position = name;
} /* set_position() */

/**
 * This queries the current position of the object.
 * @return the current position of the living
 * @see query_position_on()
 * @see query_position_multiple()
 * @see query_position_type()
 * @see set_position()
 * @see set_position_on()
 * @see set_position_multiple()
 * @see set_position_type()
 */
string query_position() {
   return position;
} /* query_position() */

/**
 * This sets the current object which is being referenced as being
 * 'on', 'beside' or 'at'.
 * @param ob the object being referenced
 * @see query_position()
 * @see query_position_on()
 * @see query_position_multiple()
 * @see query_position_type()
 * @see set_position()
 * @see set_position_multiple()
 * @see set_position_type()
 */
void set_position_on(mixed ob) {
   if (!position_on) {
      position_on = allocate(POSITION_ARRAY_SIZE);
   }
   position_on[POS_ON_OBJECT] = ob;
} /* set_position_on() */

/**
 * This sets fact that the object being referenced is one of many.  So
 * you get something more like 'xx is sitting on one of the couches'.
 * @param mult 0 if non-multiple, 1 if multiple
 * @see query_position()
 * @see query_position_on()
 * @see query_position_multiple()
 * @see query_position_type()
 * @see set_position()
 * @see set_position_multiple()
 * @see set_position_type()
 */
void set_position_multiple(int mult) {
   if (!position_on) {
      position_on = allocate(POSITION_ARRAY_SIZE);
   }
   position_on[POS_MULTIPLE] = mult;
} /* set_position_multiple() */

/**
 * This returns fact that the object being referenced is one of many.  So
 * you get something more like 'xx is sitting on one of the couches'.
 * @return 0 if non-multiple, 1 if multiple
 * @see query_position_on()
 * @see query_position_multiple()
 * @see query_position_type()
 * @see set_position()
 * @see set_position_on()
 * @see set_position_multiple()
 * @see set_position_type()
 */
int query_position_multiple() {
   if (!position_on) {
      return 0;
   }
   return position_on[POS_MULTIPLE];
} /* query_position_multiple() */

/**
 * This sets way the object is being referenced.  The 'on', 'at', 'beside'
 * or whatever strings.
 * @param type the new type string
 * @see query_position()
 * @see query_position_on()
 * @see query_position_multiple()
 * @see query_position_type()
 * @see set_position()
 * @see set_position_on()
 * @see set_position_multiple()
 */
void set_position_type(string type) {
   if (!position_on) {
      position_on = allocate(POSITION_ARRAY_SIZE);
   }
   position_on[POS_TYPE] = type;
} /* set_position_type() */

/**
 * This returns way the object is being referenced.
 * The 'on', 'at', 'beside'
 * or whatever strings.
 * @return the current type string
 * @see query_position()
 * @see query_position_on()
 * @see query_position_multiple()
 * @see set_position()
 * @see set_position_on()
 * @see set_position_multiple()
 * @see set_position_type()
 */
string query_position_type() {
   if (!position_on ||
       !position_on[POS_TYPE]) {
      return "on";
   }
   return position_on[POS_TYPE];
} /* query_position_type() */

/**
 * This queries the current object being referenced.  This can be an
 * object or a string.
 * @return the current object being referenced
 * @see query_position()
 * @see query_position_multiple()
 * @see query_position_type()
 * @see set_position()
 * @see set_position_on()
 * @see set_position_multiple()
 * @see set_position_type()
 */
object query_position_on() {
   if (!position_on) {
      return 0;
   }
   return position_on[POS_ON_OBJECT];
} /* query_position_on() */

/**
 * This method returns the short description of the object
 * we are referencing.
 * @return the short description of the object, "" if none
 * @see query_position_on()
 * @see set_position_on()
 * @see query_position_long()
 */
string query_position_on_short() {
   if (!position_on || !position_on[POS_ON_OBJECT]) {
      return "";
   }
   if (stringp(position_on[POS_ON_OBJECT])) {
      return position_on[POS_ON_OBJECT];
   }
   return position_on[POS_ON_OBJECT]->the_short();
} /* query_position_on_short() */

/**
 * This method returns the string used in the long description of the
 * living object.
 * @return the long description of the position
 * @see query_position_type()
 * @see query_position_on_short()
 */
string query_position_long() {
   if (position != STANDING || position_on) {
      if (position_on) {
         return query_pronoun() + " is " + query_position_type() + " "+
                query_position_on_short()+".\n";
      }
      return query_pronoun()+" is "+position+" on the floor.\n";
   }
   return "";
} /* query_position_long() */

/**
 * This method returns the description used in the inventory listing
 * code.
 * @return the string used in inventory listings
 * @see query_position_long()
 * @see query_position_on_short()
 * @see query_position_type()
 */
string query_position_short() {
   if (!position_on ||
       !position_on[POS_ON_OBJECT]) {
      return position;
   }
   return position + " " + query_position_type() + " " +
          query_position_on_short();
} /* query_position_short() */

/**
 * This method returns 1 if the creature is trapped, ie cannot walk.
 * By default, a creature is free to walk, hence the normal return
 * value of 0.  If you shadow this method, including a message about
 * why the player cannot move move is a good idea.
 * @param verb the exit direction that the player is trying to move.
 * @param dest_other the destination information for the exit.
 * @see /std/room->query_dest_other()
 * @return 0 means creature is free to move, 1 that it is trapped.
 */
varargs int cannot_walk( string verb, mixed *dest_other) {
   return 0;
}

/**
 * This method can be shadowed by all forms of magical and
 * religious shields so that the shields command will give
 * the player a nice description.
 * The first element in the array should contain the description
 * as shown to the player, the second element should contain the
 * description shown to others.
 * @example ({ "You have a nice shield.", "He has a nice shield." })
 * @return Array with description of shield.
 */
string *query_arcane_shields() { return ({ }); }

/** @ignore yes */
int can_find_match_reference_inside_object(object thing, object looker) {
   if (member_array(thing, query_wearing_hidden(looker, 0)) != -1) {
      return 0;
   }
   return 1;
} /* can_find_match_reference_inside_object() */

/**
 * If there is no mapping for deity favour, or if the God is not mentioned, 
 * return 0 as 'no favour'.
 * Otherwise return the favour amount.
 * @args God Name of God
 */
int query_deity_favour( string god ) {
  if ( !mapp( deity_favour ) ) 
    return 0;

  if ( !undefinedp( deity_favour[ god ] ) ) 
    return 0;

  return deity_favour[ god ];
}

/**
 * Adjust the favour rating for 'god' by amount.
 * A +ve amount is good favour, a negative is bad.
 */
void adjust_deity_favour( string god, int amount ) {

  if ( !mapp( deity_favour ) ) 
    deity_favour = ([ ]);
  
  if ( !undefinedp( deity_favour[ god ] ) ) 
    deity_favour[ god ] = amount;

  deity_favour[ god ] += amount;

  if ( deity_favour[ god ] > MAX_FAVOUR )
    deity_favour[ god ] = MAX_FAVOUR;

  if ( deity_favour[ god ] < -MAX_FAVOUR )
    deity_favour[ god ] = -MAX_FAVOUR;

  return;
}

/**
 * Return the deity favour mapping.
 */
mapping query_all_deity_favour() { return deity_favour; }
// --- END [/mnt/home2/grok/lib/std/living/living.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/living/corpse.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/living/corpse.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628833   Available: 13576187
Inodes: Total: 5242880    Free: 4960135
10366 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/living/corpse.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628833   Available: 13576187
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*
 * This file contains all the code for handling corpses.
 * @author Rhinehold
 */
#include <player.h>


/**
 * This method will allow all sorts of modifications to a corpse once it has
 * been created, based on the weapon or attack used for the killing stroke.
 * @param corpse the corpse object
 * @param weapon the weapon used to inflict the fatal damage
 * @param attack the attack used to inflict the fatal damage
 * @return none
 * @see death_helper()
 * @see make_corpse()
 * @see do_death()
 */
int alter_corpse( object corpse, object weapon, string attack ) {
  object head;
  string *heads;
  string behead_message = "";

  if (!attack) attack = "attack";
  switch (attack) {
    case "behead" :
      heads =
        this_object()->query_race_ob( this_object() )->query_possible_bits( "head" );
      if (sizeof(heads) == 0)
        break;

      head = corpse->make_bit(heads[random(sizeof(heads))] );
      head->move( environment( corpse ) );

      switch(random(6)) {
        case 0 : behead_message = head->a_short() +
          " drops onto the ground and rolls head over, well, head "
          "for a bit before coming to a rest.\n";
           break;

        case 1 : behead_message = head->a_short() +
          " sails through the air in a graceful arc before landing "
          "with a very soggy *squish*.\n";
          break;

        case 2 : behead_message = head->a_short() +
          " quivers a bit as it remains in place, perched atop its owner's "
          "corpse for a moment, then falls to pieces.\n";
          break;

        case 3 : behead_message = head->a_short() +
          " tips off to the left to hang by a small bit of flesh, before "
          "gravity has something to say about the matter and pulls it "
          "completely off the corpse, landing with a small bounce.\n";
          break;

        case 4 : behead_message = head->a_short() +
          " slides off its owner's corpse, upends, and lands upside "
          "down, helping to keep some of the blood from spilling.\n";
          break;

        case 5 : behead_message = head->a_short() +
          " drops onto the ground like a ball, *bouncy* *bouncy*.\n";
          break;

        case 6 :
        case 7 :
        case 8 :
        case 9 :
        default : behead_message = "oops, the mushrooms have turned.\n";
      }
      tell_room( environment( corpse ), behead_message );
      break;

    default :
      break;
  }
  return 1;
} /* alter_corpse */

/**
 * This method will create a corpse for the living object when it
 * eventually dies.  Of old age of course, no one would die of having
 * sword rammed through them
 * @return the created corpse object
 */
object make_corpse() {
   int i;
   object corpse, *armour, *weapons, race;

   race = find_object(this_object()->query_race_ob());
   if(race && function_exists("make_corpse", race))
     return race->make_corpse();

   corpse = clone_object( "/obj/corpse" );
   corpse->set_owner( 0, this_object() );
   corpse->set_ownership( (string)this_object()->query_name() );
   if ( this_object()->query_property( "player" ) ) {
      corpse->add_property( "player", 1 );
   }
   corpse->set_race_name( (string)this_object()->query_race() );
   if ( !this_object()->query_race_ob() ) {
      corpse->set_race_ob( "/std/races/unknown" );
   } else {
      corpse->set_race_ob( (string)this_object()->query_race_ob() );
   }
   corpse->add_adjective( (string *)this_object()->query_adjectives() );
   corpse->add_adjective("dead");
   corpse->remove_adjective("living");
   corpse->start_decay();
   corpse->set_max_weight(this_object()->query_max_weight());
   // Make the length a little longer than the player just in case
   // they were carrying a long weapon.
   corpse->set_length(this_object()->query_height() / 2);
   armour = (object *)this_object()->query_armours();
   this_object()->clear_armours();
   weapons = (object *)this_object()->query_weapons();
   all_inventory( this_object() )->set_tracked_item_status_reason( "DIED" );
   all_inventory( this_object() )->move( corpse );
   armour -= ({ 0 });
   for ( i = 0; i < sizeof( armour ); i++ ) {
      if ( environment( armour[ i ] ) != corpse ) {
         armour = delete( armour, i, 1 );
         i--;
      }
   }
   corpse->set_armours( armour );
   armour->set_worn_by( corpse );
   weapons -= ({ 0 });
   for ( i = 0; i < sizeof( weapons ); i++ ) {
      if ( environment( weapons[ i ] ) != corpse ) {
         weapons = delete( weapons, i, 1 );
         i--;
      }
   }
   corpse->set_holding( weapons );
   weapons->set_holder( corpse );
   return corpse;
} /* make_corpse() */

/**
 * This method deals with any cute messages you want to print when
 * something dies or, cute things you want to do (like not dieng
 * at all).  It handles the alignment shift due to the killing of
 * this npc as well.
 * @param thing the thing which killed us
 * @param death
 * @see make_corpse()
 */
mixed *death_helper(object thing, int death) {
   int shift, my_level, att_wimpy, att_level, xp, txp;
   string *messages;
   object *things, tmp;
   mixed *retval;

   retval = ({ });

   // added by ceres - 4 October 1997
   this_object()->remove_property(PASSED_OUT_PROP);
   this_object()->remove_hide_invis( "hiding" );

#ifdef USE_SURRENDER
   _surrender->refusers = ({ });
   _surrender->to = ({ });
#endif

   // Make sure only living things are left in the attacker list or
   // xp will be decreased for kills with e.g. spells, rituals or
   // special weapons.
   things = filter(this_object()->query_attacker_list(),
                   (:  living($1) && !$1->query_property("dead") :));

   if(environment()) {
     if (death) {
       messages = this_object()->query_property("death messages");
       if(!messages)
         messages = ({ "$K dealt the death blow to $D.\n",
                         "You killed $D.\n", "$D dies.\n" });
     } else {
       messages = this_object()->query_property( "surrender messages" );
       if (!messages)
         messages = ({ "$K accepted the surrender of $D.\n",
                         "You subdued $D.\n", "$D surrenders.\n" });
     }
     event( ({ environment() }) + deep_inventory( environment() ), "death",
            things, thing, (thing ? messages[0] : messages[2]), messages[1]);
   }
   if(sizeof(things)) {
     // Deal with alignment shifts.
     foreach(tmp in things) {
#if DEBUG == 2
       int x, y;
       x = tmp->query_al();
#endif

       shift = (int)this_object()->query_al() ;
       if (!death)
         shift -= (shift / 2);
       tmp->adjust_alignment(shift);

#if DEBUG == 2
       y = tmp->query_al();
       if(interactive(tmp))
         log_file("DEATH_ALIGN", "%s %s adjusted from %d to %d by %s [%d]\n",
                  ctime(time()), tmp->query_name(), x, y,
                  this_object()->query_name(), shift);
#endif

     }
     xp = this_object()->query_death_xp();
     if(xp > 0) {
       shift = 50 + xp / sizeof( things );
       debug_printf("%O Death XP: %O", this_object(), xp);

       // xp given to each player depends on their level & wimpy setting
       my_level = this_object()->query_level();
       foreach(tmp in things) {
         att_wimpy = tmp->query_wimpy();
         att_level = tmp->query_level();
         if(att_level <= my_level)
           txp = shift / 2;
         else
           txp = ((shift/2) * my_level) / att_level;

         if(att_wimpy > 0)      // High wimpy == lower xp.
           txp -= (txp * att_wimpy) / 100;

         tmp->adjust_xp(txp, 1);
       }
       return ({ ({ things }), shift/2 });
     }
   }
   return ({ });
} /* death_helper() */


/**
 * This does the actual death and co ordinates the death into a well
 * ordered feeding frenzy.  This method creates the actual corpse itself.
 * If the property "dead" is set on the object no corpse will be
 * created, or if the second_life() function called on the object
 * returns a non-zero value the corpse will not be created.
 * <p>
 * This method calls the second_life() function on the current object,
 * if this returns 1 it must handle all the the death code itself.
 * This is used in the player code to override the death code.
 * @param thing the thing which killed us
 * @param weapon the weapon (sword,claw,etc) object that attacked and killed us
 * @param attack the actual attack that killed us
 * @return the corpse, or 0 if no more action is to be taken
 * @index second_life
 * @see death_helper()
 * @see make_corpse()
 * @see alter_corpse()
 */
varargs object do_death(object thing, object weapon, string attack) {
  object corpse, ob;
  mixed xp_leftover, sec_life;

#if DEBUG == 2
  combat_debug("Do death called.");
#endif

  /* Now we're in do_death, so reset the callout flag */
  this_object()->reset_callingdeath();

  if ( this_object()->query_property( "dead" ) ) {
    if ( !userp( this_object() ) ) {
      if(file_name(environment()) != "/room/rubbish") {
        this_object()->move("/room/rubbish");
      }
      return 0;
    }
    else
      return 0;
  }

  this_object()->end_combat();

  this_object()->add_property("xp before death", this_object()->query_xp());

  xp_leftover = death_helper(thing, 1);
  catch(sec_life = this_object()->second_life());
  if(sec_life) {
    // hand out leftover xp since we're not doing a corpse.
    if(xp_leftover && sizeof(xp_leftover) == 2 && xp_leftover[1] > 0) {
      foreach(ob in xp_leftover[0]) {
        ob->adjust_xp(xp_leftover[1], 1);
      }
    }
    this_object()->stop_all_fight();
    if( objectp( sec_life ) ) {
      return sec_life;
    } else {
      return 0;
    }
  }
  this_object()->add_property( "dead", time() );
  catch(DEATH->someone_died( this_object() ) );
  catch(this_object()->effects_thru_death() );
  this_object()->reset_protectors();
  if ( environment() ) {
    corpse = this_object()->make_corpse();
    if (corpse) {
      corpse->move(environment());
      corpse->add_property("XP", xp_leftover, 300);
      debug_printf("Command: %O", this_object()->query_last_action());
      if (!(alter_corpse( corpse, weapon, attack ))) {
//        log_file("alter_corpse", "%s: corpse: %O, weapon: %O, command: %s.\n",
//                 ctime(time()), corpse, weapon, _command_name);
      }
    }
  }
  this_object()->move( "/room/rubbish" );
  this_object()->stop_all_fight();
  return corpse;
}
// --- END [/mnt/home2/grok/lib/std/living/corpse.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/living/mon_actions.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/living/mon_actions.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628830   Available: 13576184
Inodes: Total: 5242880    Free: 4960135
2716 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/living/mon_actions.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628830   Available: 13576184
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: mon_actions.c,v 1.3 1998/06/09 21:31:31 ceres Exp $
 * $Log: mon_actions.c,v $
 * Revision 1.3  1998/06/09 21:31:31  ceres
 * Commented out some logging to improve performance.
 *
 * Revision 1.2  1998/03/12 09:18:29  pinkfish
 * Added documentaiotn.
 *
 * Revision 1.1  1998/01/06 04:29:08  ceres
 * Initial revision
 * 
 */
/**
 * This is the old method of handling npc actions.  Effects should now
 * always be used instead of these functions.
 * <p>
 * Do not use there functions!
 * @author Pinkfish
 */
#include "monster.h"

#undef DEBUG

mixed *mon_actions;

void create() {
  mon_actions = ({ });
}

/** @ignore yes */
void do_shadow() {
  int i;
  object ob;
  string fname;

/* do we wint the sleaze of the year award???? */
  this_object()->shadow_death();
  fname = (string)MONSTER_HAND->query_shadow_name();
  rm(fname+".c");
  for (i=0;i<sizeof(mon_actions);i+=2)
    write_file(fname+".c",
               "inherit \"/std/trigger/"+mon_actions[i]+"\";\n");
  write_file(fname+".c", read_file("/std/living/mon-shadow.c"));
  ob = clone_object(fname);
  ob->setup_shadow(this_object());
  rm(fname+".c");
}

/**
 * Do not use this method!  Use effects instead.
 */
int add_triggered_action(string name, string trigger, mixed ob,
                         string func) {
  int i, j;

#ifdef DEBUG  
  log_file("TRIGGERED", ctime(time())+": "+
           file_name(this_object())+"  prev: "+
      implode( map_array( previous_object( -1 ), (: file_name( $1 ) :) ),
      ", " ) +"\n" );
#endif  
  if ((i=member_array(trigger, mon_actions)) == -1) {
    mon_actions += ({ trigger, ({ name, ({ ob, func }) }) });
    do_shadow();
  } else if ((j=member_array(name, mon_actions[i+1])) == -1)
    mon_actions[i+1] += ({ name, ({ ob, func }) });
  else
    mon_actions[i+1][j+1] = ({ ob, func });
}

/** @ignore yes */
int remove_trigger(string name) {
  int i;

  if ((i=member_array(name, mon_actions)) == -1)
    return 0;
  mon_actions = delete(mon_actions, i, 2);
  if (!sizeof(mon_actions))
    this_object()->shadow_death();
  else
    do_shadow();
  return 1;
}

/** @ignore yes */
int remove_triggered_action(string trigger, string name) {
  int i, j;

  if ((i=member_array(trigger, mon_actions)) == -1)
    return 0;
  if ((j=member_array(name, mon_actions[i+1])) == -1)
    return 0;
  mon_actions[i+1] = delete(mon_actions[i+1], i, 2);
  if (!sizeof(mon_actions[i+1]))
    remove_trigger(trigger);
  return 1;
}

/** @ignore yes */
mixed *query_actions(string trigger) {
  int i;

  if ((i=member_array(trigger, mon_actions)) == -1)
    return ({ });
  return mon_actions[i+1];
}

/** @ignore yes */
mixed *query_mon_actions() { return mon_actions; }
// --- END [/mnt/home2/grok/lib/std/living/mon_actions.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/living/gender.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/living/gender.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628829   Available: 13576183
Inodes: Total: 5242880    Free: 4960135
2461 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/living/gender.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628829   Available: 13576183
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: gender.c,v 1.4 2002/03/20 16:59:58 gruper Exp $
 * $Log: gender.c,v $
 * Revision 1.4  2002/03/20 16:59:58  gruper
 * Added query_real_gender() to take care of witches' guild
 * joining issues on women's day.
 *
 * Revision 1.3  2001/03/08 13:36:33  taffyd
 * Added query_womens_day()... where did it go?
 *
 * Revision 1.2  1999/01/13 00:41:41  arby
 * Added query_gender_name to return man, woman, or neuter.
 *
 * Revision 1.1  1998/01/06 04:29:08  ceres
 * Initial revision
 * 
*/
int gender;
nosave int womens_day;

int query_female() { return (gender == 2) || womens_day; }
int query_gender() { return (womens_day?2:gender); }
int query_male() { return gender == 1 && !womens_day; }
int query_neuter() { return !gender && !womens_day; }

string query_gender_string() {
    if (!gender && !womens_day) return "neuter";
    else if (gender == 1 && !womens_day) return "male";
    else return "female";
}

string query_gender_title() {
    if (!gender && !womens_day) return "creature";
    else if (gender == 1 && !womens_day) return "sir";
    else return "madam";
}
 
string query_gender_name() {
    if (!gender && !womens_day) return "neuter";
    else if (gender == 1 && !womens_day) return "man";
    else return "woman";
}

string query_objective() {
    if (!gender && !womens_day)
        return "it";
    else if (gender == 1 && !womens_day)
        return "him";
    else return "her";
}
 
string query_possessive() {
    if (!gender && !womens_day)
        return "its";
    else if (gender == 1 && !womens_day)
        return "his";
    else return "her";
}
 
string query_pronoun() {
    if (!gender && !womens_day)
        return "it";
    else if (gender == 1 && !womens_day)
        return "he";
    else return "she";
}

void set_gender(mixed arg) {
  if(stringp(arg)) {
    if(arg == "male")
      gender = 1;
    else if(arg == "female")
      gender = 2;
    else
      gender = 0;
  } else {
    gender = arg;
  }
} /* set_gender() */

/* Can only set ourselves on or off on womens day */
/* Bollocks. */
void set_womens_day(int bing) {
/*
  if (previous_object() != this_object())
    return ;
*/
  womens_day = bing;
} /* set_womens_day() */

int query_womens_day() { 
    return womens_day;
} /* query_womens_day() */

/* This function always returns the real gender, regardless of,
 * ah, pink bow day. */
nomask int query_real_gender() {
   return gender;
} /* query_real_gender() */
// --- END [/mnt/home2/grok/lib/std/living/gender.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/living/respond_cmd.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/living/respond_cmd.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628828   Available: 13576182
Inodes: Total: 5242880    Free: 4960135
2474 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/living/respond_cmd.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628828   Available: 13576182
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This inheritable will handle all the generic stuff for commands that
 * need a response.  Like 'teach' and 'offer'.
 * @author Pinkfish
 * @started Mon Aug 17 04:13:10 EDT 1998
 */
private nosave mapping _respond_cmd;

class respond_data {
   /**
    * The person offering us the thingy.
    */
   object ob;
   mixed data;
}

void remove_respond_command(string type, object ob);

/** @ignore yes */
mapping query_respond_cmd_data() { return _respond_cmd; }

void create() {
   _respond_cmd = ([ ]);
} /* create() */

/**
 * This method adds a responable command set of values to the
 * living object.
 * @param type the type of thing to set as a response
 * @param ob the object which is giving us the thing
 * @param data the data associated with the command
 */
void add_respond_command(string type, object ob, mixed data) {
   class respond_data frog;

   // Make sure we only have one of them.
   remove_respond_command(type, ob);
   frog = new (class respond_data);
   frog->ob = ob;
   frog->data = data;
   if (!_respond_cmd[type]) {
      _respond_cmd[type] = ({ });
   }
   _respond_cmd[type] += ({ frog });
} /* add_respond_commnad() */

/**
 * This method returns the data associated with specified type
 * and object for a respondable command.
 * @param type the type of the respondable
 * @param ob the object we are checking against
 * @return the data associated with the response, 0 if not found
 */
mixed query_respond_command(string type, object ob) {
   class respond_data frog;

   if (_respond_cmd[type]) {
      foreach (frog in _respond_cmd[type]) {
         if (frog->ob == ob) {
            return frog->data;
         }
      }
   }
   return 0;
} /* query_respond_command() */

/**
 * This method removes the response for this command.
 * @param type the type of the responable
 * @param ob the object that we are removing a responable for
 */
void remove_respond_command(string type, object ob) {
   class respond_data frog;
   int i;

   if (_respond_cmd[type]) {
      for (i = 0; i < sizeof(_respond_cmd[type]); i++) {
         frog = _respond_cmd[type][i];
         if (frog->ob == ob) {
            _respond_cmd[type] = _respond_cmd[type][0..i - 1] +
                                 _respond_cmd[type][i+1..];
            i--;
         }
      }
   }
} /* remove_respond_command() */

/** @ignore yes */
/* Added to allow manual clearing of this stuff when it screws up */
void clear_respond_commands() {
   _respond_cmd = ([ ]);
}
// --- END [/mnt/home2/grok/lib/std/living/respond_cmd.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/living/money.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/living/money.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628828   Available: 13576182
Inodes: Total: 5242880    Free: 4960135
4743 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/living/money.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628828   Available: 13576182
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: money.c,v 1.5 2002/04/08 00:52:32 presto Exp $
 * $Log: money.c,v $
 * Revision 1.5  2002/04/08 00:52:32  presto
 * Added call to do_burden_call() in adjust_money()
 *
 * Revision 1.4  2002/03/18 00:37:44  presto
 *  Forcibly unlocked by ceres
 *
 * Revision 1.3  1998/07/25 20:37:35  sin
 * Hopefully fewer 'coins' will show up now.  I changed adjust_money()
 *
 * Revision 1.2  1998/05/13 12:26:04  pinkfish
 * Add in documentation.
 *
 * Revision 1.1  1998/01/06 04:29:08  ceres
 * Initial revision
 * 
*/
/**
 * This file has all the functions to deal with living objects and
 * money.
 * @author Pinkfish
 * @see /obj/money.c
 * @see /obj/handlers/money_handler.c
 */

#include "money.h"

/**
 * This method returns the money object for the player.  If the force
 * flag is set then the object will be created if it does not
 * exist.
 * @param force make the money object exist
 */
object query_money_object(int force) {
   object money;

   money = present( MONEY_ALIAS, this_object() );
   if (!money && force) {
//      money = clone_object( MONEY_OBJECT );
      money = MONEY_VAULT->get_money_ob();
      money->move( this_object() );
   }
   return money;
} /* query_money_object() */

/**
 * This method adjusts the amount of money the player has.
 * It redirects the call off the the money object and calls the
 * adjust_money() function on it.  The amount can be a money
 * array, in which case it will adjust the size by the members
 * of the money array.
 * <p>If the money object doesn't exist yet, this function
 * might create a new money object.  The exception is that if
 * the amount argument is 0, nothing happens.
 * @see /obj/money->adjust_money()
 * @param amount the amount to adjust the money by
 * @param type the type of coin to adjust
 */
varargs void adjust_money( mixed amount, string type ) {
   if (!amount) return;
   query_money_object( 1 )->adjust_money( amount, type );
   this_object()->do_burden_call();
} /* adjust_money() */

/**
 * This method returns the money array associated with the money on
 * the player object.
 * @return the money array on the player object
 * @see set_money_array()
 */
mixed *query_money_array() {
   return query_money_object(1)->query_money_array();
} /* query_money_array() */

/**
 * This method sets the money array associated with the player.   THis
 * will overwrite any current money on the player.
 * @param new_array the new money array for the player
 * @see query_money_array()
 */
void set_money_array( mixed *new_array ) {
   query_money_object(1)->set_money_array( new_array );
} /* set_money_array() */

/**
 * This method returns the value of the money as an integer.  This is
 * an absolute value of their worth.
 * @return an integer value of their money
 * @see query_value_in()
 */
int query_value() {
   object money;

   money = query_money_object(0);
   if ( ! money ) {
      return 0;
   }
   return money->query_value();
} /* query_value() */

/**
 * This method returns the value of the money as in integer in the specified
 * place.
 * @param where the place in which to determine the money from
 * @return the integer value of money
 * @see query_value()
 * @see query_money()
 */
int query_value_in( string where ) {
   object money;

   money = query_money_object(0);
   if ( ! money ) {
      return 0;
   }
   return (int)money->query_value_in( where );
} /* query_value_in() */

/**
 * This method returns all of the money of a certain type on the
 * money object.
 * @param type the type of money to return 
 * @return the number of those money items
 * @see query_value()
 * @see query_value_in()
 */
int query_money( string type ) {
   object money;

   money = query_money_object(0);
   if ( ! money ) {
      return 0;
   }
   return (int)money->query_money( type );
} /* query_money() */

/**
 * This method makes the player make a payment.  This is used for
 * shops and things.
 * @param m_array the money to pay
 * @param where the money area to make the payment in
 * @see /obj/handlers/money_handler->make_payment()
 */
varargs void pay_money( mixed m_array, string where ) {
   int i, j;
   object money;
   mixed *p_array;

   money = query_money_object(0);
   if ( !money ) {
      return;
   }
   for ( i = 0; i < sizeof( m_array ); i += 2 ) {
      p_array = (mixed *)MONEY_HAND->make_payment( m_array[ i ],
         m_array[ i + 1 ], money, where );
      if ( !pointerp( p_array ) ) {
         continue;
      }
      if ( sizeof( p_array[ 1 ] ) ) {
         money->adjust_money( p_array[ 1 ] );
      }
      for ( j = 0; j < sizeof( p_array[ 0 ] ); j += 2 ) {
         money->adjust_money( - p_array[ 0 ][ j + 1 ], p_array[ 0 ][ j ] );
      }
   }
} /* pay_money() */
// --- END [/mnt/home2/grok/lib/std/living/money.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/living/spells.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/living/spells.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628826   Available: 13576180
Inodes: Total: 5242880    Free: 4960135
3426 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/living/spells.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628826   Available: 13576180
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: spells.c,v 1.7 2002/07/10 00:07:17 taffyd Exp $
 * $Log: spells.c,v $
 * Revision 1.7  2002/07/10 00:07:17  taffyd
 * Made it possible to delete spells which have no name.
 *
 * Revision 1.6  2001/11/12 22:48:34  pinkfish
 * Fix up the reset_spells() thingy.
 *
 * Revision 1.5  2001/11/12 22:46:32  pinkfish
 * Add in a protected method to reset spell data,.
 *
 * Revision 1.4  2001/11/12 22:21:24  pinkfish
 * Add in some docs.
 *
 * Revision 1.3  2001/08/15 20:29:49  tannah
 * Fix0rd a bug in query_spells_nocase()
 *
 * Revision 1.2  2001/08/15 04:11:32  presto
 * Added code to handle spell names of any upper/lowercase
 *
 * Revision 1.1  1998/01/06 04:29:08  ceres
 * Initial revision
 *
*/
#include <spells.h>

class spell_process {
   mapping spells;
   mapping process;
}

private mixed spells;

void create() {
   spells = ([ ]);
}

/**
 * This method returns the string help for the spell.  It is used by the
 * help command to find the help for the spell.
 * @param str the spell to find help on
 * @return the help string of the spell
 */
string help_spell(string str) {
   if (!mapp(spells)) {
     spells = ([ ]);
   }
   if (!m_sizeof(spells)) {
      return 0;
   }
   if (!spells[str]) {
      return 0;
   }
   return (string)spells[str][S_OBJECT]->help(str);
}

/**
 * This method returns the current bunch of spells for the object.
 * @return the spells
 */
mapping query_spells() {
   if (!mapp(spells)) {
      spells = ([ ]);
   }
   return spells;
}

/**
 * This method returns the list of spells without any case issues.
 * @return the list of spells without any case
 */
mapping query_spells_nocase() {
  mapping lc_spells = ([]);
  filter( this_object()->query_spells(),
                 (: $3 += ([ lower_case( $1 ) : $2 ]) :), lc_spells );
  return lc_spells;
}

/**
 * This method adds a spell into the current spell list.
 * @param name the name of the spell to add
 * @param ob the object the spell is on
 * @param func the function to call for the spell
 * @return 1 on success, 0 on failure
 */
int add_spell(string name, mixed ob, mixed func) {
   int i;
   mapping tmp;
 
   if (pointerp(spells)) {
      tmp = ([ ]);
      for (i=0;i<sizeof(spells);i+=2)
         tmp[spells[i]] = spells[i+1];
      spells = tmp;
   }
   if (!mapp(spells)) {
      spells = ([ ]);
   }
   spells[name] = ({ ob, func });
   return 1;
}

/**
 * This method removes the spell of the given name.
 * @param name the name of the spell to remove
 * @return 1 on succes, 0 on failure
 */
int remove_spell(string name) {
  string spell, name_lc;
  
  if ( !name ) {
      map_delete( spells, 0 );
      return 1;
  }

  name_lc = lower_case(name);
  foreach (spell in keys(spells)) {
     if (lower_case(spell) == name_lc) {
        map_delete(spells, spell);
     }
  }
  return 1;
}

/**
 * This method finds the data for the spell of the specific name
 * @param word the name of the spell to find data on
 * @return the data for the spell
 */
mixed query_spell( string word ) {
   mapping tmp_spells;
   string test_spell;

   if ( !mapp( spells ) ) {
      return 0;
   }

   tmp_spells = query_spells_nocase();
   test_spell = lower_case(this_object()->expand_nickname(word));
   return tmp_spells[test_spell];
} /* query_spell() */

/** 
 * This method resets all the spell data.
 */
protected void reset_spells() {
   spells = ([ ]);
} /* reset_spells() */
// --- END [/mnt/home2/grok/lib/std/living/spells.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/living/armour.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/living/armour.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628825   Available: 13576179
Inodes: Total: 5242880    Free: 4960135
13506 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/living/armour.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628825   Available: 13576179
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: armour.c,v 1.23 2003/05/21 03:44:20 ceres Exp $
 * 
 */
/**
 * This file contains all the armour related code for the living
 * objects.
 * @author Pinkfish
 */
#include <clothing.h>
#include <function.h>
#include <race.h>
#include <armour.h>

inherit "/std/armour_logic";

#undef INFORM 1

nosave string skin;
nosave object *wearing;
nosave mixed stopped;
nosave mixed *_armour_callbacks;
nosave int *_cids;

void create() {
   skin = "morphological field";
   wearing = ({ });
   if(!_armour_callbacks)
     _armour_callbacks = ({ ({ }), ({ }), ({ }) });
   
   if(!_cids)
     _cids = ({ 0, 0, 0 });
   
   ::create();
} /* create() */

/**
 * Register a callback for magical protection.
 *
 * @param level How close the protection is to the skin.
 * @param callback The object & function to be called.
 * @param data Any extra data to be passed.
 * @return an ID to identify this callback.
 *
 * @example:
 * register_armour_callback(ARM_INNER,
 *                          ({ "/std/effects/religious/shield", "callback" }),
 *                          ({ "pishe" });
 *
 * The callback function will be called as:
 *
 * callback(player, type, amount, zone, ({ "pishe" }));
 *
 */
int register_armour_callback(int level, mixed callback, mixed data) {
  _armour_callbacks[level] += ({ new(class armour_callback,
                                     id : ++(_cids[level]),
                                     callback: callback,
                                     data : data) });
  return _cids[level];
}

/**
 * Remove a registered callback, used when the protection ends.
 *
 * @param level The level of the callback
 * @param id The callbacks ID.
 *
 * @see register_armour_callback()
 */
int remove_armour_callback(int level, int id) {
  int i;

  for(i=0; i<sizeof(_armour_callbacks[level]); i++) {
    if((_armour_callbacks[level][i])->id == id) {
      _armour_callbacks[level] -= ({ _armour_callbacks[level][i] });
      return 1;
    }
  }

  return 0;
}

/**
 * Update the data for an armour callback.
 *
 * @param level The level of the callback
 * @param id The callbacks ID.
 * @param data The new data.
 *
 * @see register_armour_callback()
 */
int update_armour_callback(int level, int id, mixed data) {
  int i;
  
  for(i=0; i<sizeof(_armour_callbacks[level]); i++) {
    if((_armour_callbacks[level][i])->id == id) {
      _armour_callbacks[level][i]->data = data;
      return 1;
    }
  }
  return 0;
}

/**
 * Query all the callback data. This should typically only be used for
 * debugging purposes.
 */
mixed *query_armour_callbacks() { return copy(_armour_callbacks); }

/**
 * This method returns the current skin of the living object.
 * @return the skin of the object
 * @see set_skin()
 */
string query_skin() { return skin; }

/**
 * This method sets the current skin of the living object.  This can
 * be done by the race object and by specific spells or effects.
 * @param word the new skin type
 * @see query_skin()
 */
void set_skin( string word ) { skin = word; }

/**
 * This method returns all the objects you are currently wearing.
 * @return the current array of worn objects
 * @return the array of worn stuff
 * @see query_armours()
 */
object *query_wearing() {
   wearing = filter(wearing, (: $1 && environment($1) == this_object() :));
   return copy( wearing );
} /* query_wearing() */

/**
 * This method returns all the armours that the is currently being
 * worn.  This will always return the same value as query_wearing()
 * @see query_wearing()
 * @return the array of armours
 */
object *query_armours() {
   return query_wearing();
} /* query_armours() */

/**
 * This method will make sure all the armours are unworn by the living
 * object.
 * @see query_wearing()
 */
void clear_armours() {
   wearing->set_worn_by( 0 );
   wearing = ({ });
} /* clear_armours() */

/**
 * This returns the object which stopped the blow.  This is only valid
 * inside and after a query_ac() call.
 * @return the object which stopped the call
 */
mixed query_stopped() {
   return stopped;
} /* query_stopped() */

/**
 * This method sets the object which stops the call.  This should be
 * used to do weird stuff.  I have no idea what it should be used for
 * at all and I am just rambling.
 * @param arg the new value of the stopped object
 */
void set_stopped( mixed arg ) { stopped = arg; }

/**
 * This method checks to see if the two armour types are
 * equivilant or not.
 * @param comp the first type
 * @param type the second type
 */
protected int equivalent_armour_types( mixed comp, string type ) {
   string word;

   if ( stringp( comp ) ) {
      if ( CLOTHING_HANDLER->query_equivilant_type( comp ) ) {
         return CLOTHING_HANDLER->query_equivilant_type( comp ) == type;
      }
      return comp == type;
   }
   foreach ( word in comp ) {
      if ( equivalent_armour_types( word, type ) )
         return 1;
   }
   return 0;
} /* equivalent_armour_types() */

/**
 * This is the method used to get the living object to wear a piece of
 * armour or clothing.  This is called from inside the armour or clothing
 * code itself.  It will call the function set_worn_by() on the
 * armour or clothing and if this returns a non-zero result then it
 * will add it into the current list of worn types.  Assuming the
 * type of the armour fits into the allowed list.  It will also
 * call the functon hold_item on the object if it is required to be
 * held as well (ie: shield).
 * @param armour the armour to wear
 * @param doing_hold if this is called by the hold command
 * @return the failure message, or 0 if ok
 * @see remove_armour()
 * @see query_armours()
 * @see query_wearing()
 */
string wear_armour( object armour, int doing_hold ) {
   int no_limbs;
   string type, word, fail_mess;
   mixed types;
   object thing;
   mapping things;

   if (environment(armour) != this_object()) {
      return "must be in your inventory";
   }

   wearing -= ({ 0 });
   if (member_array(armour, wearing) > -1)
     return "since you already have " + armour->query_objective() + " on";

   types = armour->query_type();
   word = this_object()->not_allowed_to_wear( types );
   if ( word ) {
      return word;
   }
   things = ([ ]);
   if ( stringp( types ) ) {
      types = ({ types });
   }
   if ( !pointerp( types ) ) {
      return "oh dear";
   }
   foreach ( type in types ) {
      if ( CLOTHING_HANDLER->query_equivilant_type( type ) ) {
         type = CLOTHING_HANDLER->query_equivilant_type( type );
      }
      things[ type ] = ({ });
      foreach ( thing in wearing ) {
         if ( equivalent_armour_types( (mixed)thing->query_type(), type ) )  {
            things[ type ] += ({ thing });
         }
      }
   }
   word = (string)this_object()->query_race_ob();
   
   if ( !word )
     return "no race object";
   
   foreach ( type in keys( things ) ) {
      if ( (int)word->query_number_worn( type ) <= sizeof( things[ type ] ) ) {
         return "since you are already wearing "+
               query_multiple_short( things[ type ] );
      }
   }
   no_limbs = (int)armour->query_no_limbs();
   if ( no_limbs && !doing_hold ) {
      if ( member_array( armour,
            (object *)this_object()->query_holding() ) != -1 ) {
         return "already wearing";
      }
      if( sizeof( (int *)armour->hold_item( this_object(), -1 ) ) ) {
         return 0;
      } else {
         return "already holding";
      }
   }
   if ( !armour->set_worn_by( this_object() ) ) {
      if( fail_mess = armour->query_wear_failure_mess() )
         return fail_mess;
      else
         return "oh dear";
   }
   wearing += ({ armour });
   this_object()->do_burden_call();
   return 0;
} /* wear_armour() */

/**
 * This method will remove the armour from the living object.
 * @param thing the armour to remove
 * @return 1 if was unsuccessful and 0 if it was successful
 * @see wear_armour()
 * @see query_armours()
 * @see query_wearing()
 */
int remove_armour( object thing ) {
   int i;

   wearing -= ({ 0 });
   i = member_array( thing, wearing );
   if ( i == -1 ) {
      return 1;
   }
   if ( !thing->set_worn_by( 0 ) ) {
      return 1;
   }
   if ( member_array( thing, (object *)this_object()->query_holding() ) != -1 ) {
      if ( !sizeof( (int *)this_object()->set_unhold( thing ) ) ) {
         return 1;
      }
   }
   wearing = delete( wearing, i, 1 );
   this_object()->do_burden_call();
   return 0;
} /* remove_armour() */

/**
 * This function returns the amount of damage that can be blocked
 * by the armour on a specified zone.  It automatically
 * damages the armour, and sets the stopped object to be the
 * the object (piece of armour) that stopped the blow.
 *
 * @param type The type of damage, eg: "sharp", "blunt", "pierce".
 * @param amount The amount of damage that is being done.
 * @param zone The zone which the damage is being done through, eg: "head".
 * @return The amount of damage that will be blocked.
 * @see query_wearing()
 */
varargs int query_ac( string type, int amount, string zone ) {
  int part, total, i, max;
  string word, *types;
  mixed most;
  object thing;
  object *defenses;
  
  stopped = 0;
#ifdef INFORM
  event( environment(), "inform", "zone "+ zone, "combat" );
#endif
  
  if ( !zone ) {
    switch(random(21)) {
    case 0..1: zone = "head"; break;
    case 2: zone = "neck"; break;
    case 3..6: zone="chest"; break;
    case 7..9: zone="abdomen"; break;
    case 10..12: zone = "arms"; break;
    case 13..14:
      zone = "hands"; break;
    case 15..18: zone = "legs"; break;
    case 19: zone = "feet"; break;
    case 20: zone = "back"; break;
    }
#ifdef INFORM
    event( environment(), "inform", "picked zone "+ zone,
           "combat" );
#endif
  }

  // Do the 'outside the armour' callbacks.
  if(sizeof(_armour_callbacks[ARM_OUTER]) && amount) {
    for(i=0; i<sizeof(_armour_callbacks[ARM_OUTER]); i++) {
      if(!_armour_callbacks[ARM_OUTER][i]->callback[0])
        remove_armour_callback(ARM_OUTER,
                               _armour_callbacks[ARM_OUTER][i]->id);
      else {
        part = call_other(_armour_callbacks[ARM_OUTER][i]->callback[0],
                          _armour_callbacks[ARM_OUTER][i]->callback[1],
                          this_object(),
                          type, amount, zone,
                          _armour_callbacks[ARM_OUTER][i]->data);
        if(part > max) {
          max = part;
          most = stopped;
        }
        total += part;
        amount -= part;
        if(amount < 1)
          break;
      }
    }
  }
  
  if(zone != "self" && amount > 0) {
    types = CLOTHING_HANDLER->query_clothing_zone( zone );
    if(!types) {
      log_file("ARMOUR_DEBUG", "No types for zone: %s", zone);
      return 0;
    }
    
    foreach ( word in  types) {
      wearing -= ({ 0 });
      defenses = wearing + filter_array(this_object()->query_holding(),
                                        (: $1 && $1->query_armour() :));
      foreach ( thing in defenses )
        if ( equivalent_armour_types( (mixed)thing->query_type(), word ) ) {
#ifdef INFORM
          event( environment(), "inform", "testing object "+
                 thing->short(), "combat" );
#endif
          part = (int)thing->query_ac( type, amount, zone );
          if (!stopped && part)
            stopped = thing;
          if(part > max) {
            max = part;
            most = stopped;
          }
          total += part;
          amount -= part;
        }
      if (amount < 1)
        break;
    }
  }

  // Do the 'against the skin' callbacks.
  if(sizeof(_armour_callbacks[ARM_INNER]) && amount > 0) {
    for(i=0; i<sizeof(_armour_callbacks[ARM_INNER]); i++) {
      if(!_armour_callbacks[ARM_INNER][i]->callback[0])
        remove_armour_callback(ARM_INNER,
                               _armour_callbacks[ARM_INNER][i]->id);
      else {
        part = call_other(_armour_callbacks[ARM_INNER][i]->callback[0],
                          _armour_callbacks[ARM_INNER][i]->callback[1],
                          this_object(),
                          type, amount, zone,
                          _armour_callbacks[ARM_INNER][i]->data);
        if(part > max) {
          max = part;
          most = stopped;
        }
        total += part;
        amount -= part;
        if(amount < 1)
          break;
      }
    }
  }

  // Does their race have special ac?
  if(amount > 0 && this_object()->query_race_ob() &&
     function_exists("query_ac", load_object(this_object()->query_race_ob()))){
    part = (this_object()->query_race_ob())->query_ac(type, amount, zone);
    if(part > max) {
      max = part;
      most = stopped;
    }
    total += part;
    amount -= part;
  }

  // Now do their skin.
  if(amount > 0) {
    if(!stopped && type != "skin")
      stopped = skin;

    // Dry them out if fire gets through.
    if(type == "fire") {
      if(this_object()->effects_matching("body.wetness") &&
         sizeof((int *)this_object()->effects_matching("body.wetness"))) {
        this_object()->add_effect("/std/effects/other/wetness", -amount );
      }
    }
    
    // Do the bodies personal AC.
    part = ::query_ac(type, amount, zone);
    if(part > max) {
      max = part;
      most = stopped;
    }
    total += part;
    amount -= part;
  }
  
  if(amount > 0 && most) {
    stopped = most;
  }
  return total;

}

/** @ignore yes */
mixed *stats() {
   return ::stats() + ({
      ({ "skin", skin }),
   });
} /* stats() */
// --- END [/mnt/home2/grok/lib/std/living/armour.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/living/mon-shadow.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/living/mon-shadow.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628822   Available: 13576176
Inodes: Total: 5242880    Free: 4960135
356 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/living/mon-shadow.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628822   Available: 13576176
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: mon-shadow.c,v 1.1 1998/01/06 04:29:08 ceres Exp $
 * $Log: mon-shadow.c,v $
 * Revision 1.1  1998/01/06 04:29:08  ceres
 * Initial revision
 * 
*/
object npc;

void setup_shadow(object ob) {
  shadow(ob,1);
  npc = ob;
}

void death_shadow() { destruct( this_object() ); }

object query_npc() { return npc; }
// --- END [/mnt/home2/grok/lib/std/living/mon-shadow.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/living/living.no_eff_shad.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/living/living.no_eff_shad.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628822   Available: 13576176
Inodes: Total: 5242880    Free: 4960135
42931 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/living/living.no_eff_shad.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628822   Available: 13576176
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: living.c,v 1.72 2003/03/07 03:24:37 ceres Exp $
 *
 */
/**
 * The main living inherit.  This inherits all the files
 * needed to be in a living object.
 * @author Pinkfish
 */
#include <dirs.h>
#include <drinks.h>
#include <living.h>
#include <move_failures.h>
#include <player.h>
#include <tune.h>
#include <position.h>
#include <obj_parser.h>

inherit "/std/container";
inherit "/std/living/armour";
inherit "/std/living/carrying";
inherit "/std/living/combat";
inherit "/std/living/force";
inherit "/std/living/gender";
inherit "/std/living/health";
inherit "/std/living/holding";
inherit "/std/living/money";
inherit "/std/living/skills";
inherit "/std/living/spells";
inherit "/std/living/crafts";
inherit "/std/living/stats";
inherit "/std/living/respond_cmd";
inherit "/std/living/nationality";

#define VERBOSE_TYPES ({"combat", "look", "score", "names", "htell", "finger"})

//The maximum amount of religious favour you can have.
#define MAX_FAVOUR 100

class living_data {
  int handicap;
  int burden;
  object* followers;
  class obj_match_context it_them;
  object* to_drop;
  int burden_call;
}

class messages {
   string msgout;
   string msgin;
   string mmsgout;
   string mmsgin;
}

private int alignment;
private class messages _messages;
private mixed *facing;
private mapping verbose;
private mapping abs_facing = ABS_FACING;
private mapping lengthen = LENGTHEN;

//Got religion?
private string deity;         //Your deity of choice.
private mapping deity_favour; //A mapping of deity ratings.

//private nosave object _dragging;
private nosave class living_data _liv_data;
//private nosave int _handicap;
//private nosave object *_followers;
//private nosave class obj_match_context _it_them;
//private nosave object* _to_drop;
//private nosave int _burden_call;

void return_to_default_position(int leaving);
void set_position(string name);
void set_position_on(mixed ob);
void set_position_multiple(int mult);
void set_position_type(string type);
object query_position_on();
protected mixed command(string);

/*
 * What position are they in?  Standing, sitting, lying, froging?
 */
private nosave string position;
private nosave mixed default_position;
private /* This will force an object to not use the position from the room. */
nosave int always_use_default_position;
/* in case they are standing on something or something... */
private nosave mixed position_on;

void create() {
   string t;

   _liv_data = new(class living_data);
   _messages = new(class messages);
   crafts::create();
   container::create();
   armour::create();
   combat::create();
   health::create();
   holding::create();
   skills::create();
   spells::create();
   respond_cmd::create();
   enable_commands();
   reset_can_export_inventory();
   reset_effects();
   _messages->msgin = "$N arrive$s from $F.";
   _messages->msgout = "$N leave$s $T.";
   _messages->mmsgin = "$N appear$s out of the ground.";
   _messages->mmsgout = "$N disappear$s in a puff of smoke.";
   _liv_data->followers = ({ });
   verbose = ([ ]);
   set_max_items(50);
   _liv_data->to_drop = ({ });
   foreach(t in VERBOSE_TYPES) {
      verbose[t] = 1;
   }

   facing = ({ 0, ({ "north", "northeast", "east", "southeast", "south",
         "southwest", "west", "northwest" }), ({ "up", "down" }) });
   position = STANDING;

   add_adjective("living");
} /* create() */

/** @ignore yes */
void heart_beat() {
  stats::heart_beat();
  combat::heart_beat();
}

/**
 * This method returns the pronoun string of the living object.
 * A pronoun is "he", "she", "it".
 * @return the pronoun string
 */
string query_pronoun() {
   return gender::query_pronoun();
} /* query_pronoun() */

/**
 * This method returns the prossessive string of the living object.
 * A possessive is "her", "his", "its".
 * @return the possessive string
 */
string query_possessive() {
   return gender::query_possessive();
} /* query_possessive() */

/**
 * This method returns the objective string of the living object.
 * An objective is "her", "him", "it".
 * @return the objective string
 */
string query_objective() {
   return gender::query_objective();
} /* query_objective() */

/** @ignore yes */
varargs int query_weight(int actual) {
  if(!actual && this_object()->query_property("dead"))
    return 0;
  return stats::query_weight();
}

/**
 * This method returns the current burden level of the living
 * object.  This is returned as a percentage of the maximum
 * weight that the living can carry.
 * @return the burden level (0-100)
 */
int query_burden() {
  return _liv_data->burden;
} /* query_burden() */

/**
 * This method returns the current handicap of the living
 * object.
 * @return the current handicap.
 * @see calc_burden()
 */
int query_handicap() { return _liv_data->handicap; }

/**
 * This method calculates the current handicap of the living
 * object.  The handicap is based on the burden of the
 * person, the more burdened the higher the handicap.  The
 * handicap is 1 point of dexterity for every 25% burdened.
 * @see query_handicap()
 * @see query_burden()
 */
void calc_burden() {
  int new_handicap;
  int burden;
  object thing;
  mapping hands;
  
  _liv_data->burden_call = 0;
  
  update_loc_weight();
  burden = query_loc_weight();
  foreach(thing in query_wearing())
    burden -= (int)thing->query_complete_weight() / 2;

  hands = ([ ]);
  foreach(thing in query_holding())
    if(objectp(thing))
      hands[thing]++;

  foreach(thing in keys(hands))
    burden += (int)thing->query_complete_weight() / hands[thing];

  if(!query_max_weight()) {
    this_object()->reset_carry_cap();
    _liv_data->burden = 50;
  } else
    _liv_data->burden = (100 * burden) / query_max_weight();
  
  new_handicap = (_liv_data->burden / 25) - 1;
  if(new_handicap < 0)
    new_handicap = 0;
  
  if ( _liv_data->handicap != new_handicap ) {
    adjust_bonus_dex( _liv_data->handicap - new_handicap );
    _liv_data->handicap = new_handicap;
  }
}

/**
 * This method returns the string representation of the current
 * burden level.
 * @return the burden string
 * @see calc_burden()
 * @see query_burden()
 */
string burden_string() {
  switch (_liv_data->handicap) {
  case 0 :
    return "unburdened";
  case 1 :
    return "burdened";
  case 2 :
    return "heavily burdened";
  case 3 :
    return "very heavily burdened";
  default :
    return "incredibly heavily burdened";
  }
} /* burden_string() */

/**
 * This method adds any commands needed by the living inherit.
 */
void living_commands() {
#if efun_defined(add_action)
   add_action( "exit_command", "*", 1 );
#endif
} /* living_commands() */

/**
 * This method allows you to make the living object eat something.
 * @param food the food object to eat
 */
void eat_this( object food ) {
  this_object()->bypass_queue();
  command( "eat " + file_name( food ) );
} /* eat_this() */

/**
 * This method handles the cannot get flags.  This is placed
 * into the living object so that things which are marked as
 * being unable to be picked up can still be put into normal
 * containers.  The upwards checking of containers stops here.
 * This should make it so that objects marked as unable to be
 * picked up cannot be put into objects in the players
 * inventory.
 * @return 1 if the object can be added, 0 if not.
 */
int test_add(object ob, int flag) {
  if(sizeof(all_inventory(this_object())) > query_max_items())
    return 0;
  
  return !flag;
}

/**
 * This method handles the cannot drop flags.  This is placed
 * into the living object so that things which are marked as
 * being unable to be dropped can still be remove from normal
 * containers.  This does all sorts of other exciting checks
 * now.
 * @return 1 if the object can be added, 0 if not.
 */
int test_remove( object ob, int flag, mixed dest ) {
   object thing;

   if ( flag ) {
      return 0;
   }
   if ( !this_player() || ( this_player() == this_object() ) ) {
      return !flag;
   }
   if ( stringp( dest ) ) {
      thing = find_object( dest );
   }
   if ( objectp( dest ) ) {
      thing = dest;
      dest = file_name( dest );
   }
   if ( thing->query_corpse() || ( dest == "/room/rubbish" ) ) {
      return !flag;
   }
/*
 * True theft commands should return 1 to query_theft_command().
 *  Things like the ritual "fumble" and the command "disarm" should return -1.
 */
   if ( sizeof( filter_array( previous_object( -1 ),
         (: $1->query_theft_command() :) ) ) ) {
      return !flag;
   }
/* We should now only be considering things like "get", "take" and "palm". */
   if ( !query_property( PASSED_OUT ) ) {
      return 0;
   }
   if ( !pk_check( this_player(), this_object() ) ) {
      event( environment( this_player() ), "theft", this_player(),
            this_object(), ob );
      return !flag;
   }
   write( "An unseen force stays your hand.\n" );
   return 0;
} /* test_remove() */

/**
 * This method returns the current alignment of the living
 * object.
 * @return the current alignment
 * @see set_al()
 * @see adjust_al()
 * @see adjust_alignment()
 * @see align_string()
 */
int query_al() { return alignment; }

/**
 * This method sets the current alignment of the living
 * object.
 * @param number the new alignment for the object
 * @see query_al()
 * @see adjust_al()
 * @see adjust_alignment()
 * @see align_string()
 */
void set_al( int number ) { alignment = number; }

/**
 * This method adjusts the current alignment of the living
 * object.
 * @param number the amount to change the alignment by
 * @return the new alignment
 * @see query_al()
 * @see set_al()
 * @see adjust_alignment()
 * @see align_string()
 */
int adjust_al( int number ) {
   alignment += number;
   if ( alignment < -MAX_AL ) {
      alignment = -MAX_AL;
   }
   if ( alignment > MAX_AL ) {
      alignment = MAX_AL;
   }
   return alignment;
} /* adjust_al() */

/**
 * This method adjusts the current alignment of the living
 * object.  This is called when an object dies and handles the
 * mangling of the change value based on the current alignment and
 * the alignment of the thing dieing.
 * @param number the amount to change the alignment by
 * @return the new alignment
 * @see query_al()
 * @see adjust_al()
 * @see set_al()
 * @see align_string()
 */
int adjust_alignment( int number ) {
  int change;

  // To become more evil you must kill something that is at least 20%
  // good as you are evil and vice versa.
  change = - (number + alignment/5);

  // This stops the changes being too extreme. Increase this for smaller
  // changes, decrease it for larger ones.
  change /= 20;

  // Now wasn't that nice and easy? :-)
  return adjust_al( change );
} /* adjust_alignment() */

/**
 * This method returns the string associated with the current
 * alignment of the living object.
 * @return the string associated with the alignment
 * @see query_al()
 * @see adjust_al()
 * @see adjust_alignment()
 * @see set_al()
 */
string align_string() {
   switch ( alignment ) {
      case -MAX_AL .. -5001 : return "extremely good"; break;
      case -5000 .. -2501 : return "very good"; break;
      case -2500 .. -1251 : return "quite good"; break;
      case -1250 .. -601 : return "good"; break;
      case -600 .. -301 : return "barely good"; break;
      case -300 .. 300 : return "neutral"; break;
      case 301 .. 600 : return "barely evil"; break;
      case 601 .. 1250 : return "evil"; break;
      case 1251 .. 2500 : return "quite evil"; break;
      case 2501 .. 5000 : return "very evil"; break;
      default : return "extremely evil"; break;
   }
} /* align_string() */

/**
 * This method returns the current deity the living object is
 * worshipping.
 * @return the current deity
 * @see /obj/handlers/diety_handler
 * @see set_deity()
 */
string query_deity() { return deity; }
/**
 * This method sets the current deity the living object is
 * worshipping.
 * @param word the new deity
 * @see /obj/handlers/diety_handler
 * @see query_deity()
 */
void set_deity( string word ) { deity = word; }

/**
 * This is the method used to query the current message to use when
 * entering a room.   A $N in the string will be expanded to the
 * name and a $F will be expanded to the from direction.
 * @return the message to print when entering a room.
 * @see /obj/handlers/room_handler
 * @see query_msgout()
 * @see set_msgin()
 */
string query_msgin() { return _messages->msgin; }
/**
 * This is the method used to query the current message to use when
 * exiting a room.   A $N in the string will be expanded to the
 * name and a $T will be expanded to the to direction.
 * @return the message to print when entering a room.
 * @see /obj/handlers/room_handler
 * @see query_msgin()
 * @see set_msgout()
 */
string query_msgout() { return _messages->msgout; }

/**
 * This is the method used to set the current message to use when
 * entering a room.   A $N in the string will be expanded to the
 * name and a $F will be expanded to the from direction.
 * @param str the message to print when entering a room
 * @see /obj/handlers/room_handler
 * @see query_msgin()
 * @see set_msgout()
 */
int set_msgin(string str) {
   if (strsrch(str, "$N") == -1 || strsrch(str, "$F") == -1) {
      return 0;
   }
   _messages->msgin = str;
   return 1;
} /* set_msgin() */
/**
 * This is the method used to query the current message to use when
 * exiting a room.   A $N in the string will be expanded to the
 * name and a $T will be expanded to the to direction.
 * @return the message to print when entering a room.
 * @see /obj/handlers/room_handler
 * @see query_msgout()
 * @see set_msgin()
 */
int set_msgout(string str) {
   if (strsrch(str, "$N") == -1 || strsrch(str, "$T") == -1) {
      return 0;
   }
   _messages->msgout = str;
   return 1;
} /* set_msgout() */

/**
 * THis is the message to be used when the person is teleported.
 * @return the in message when they teleport
 */
string query_mmsgin() { return _messages->mmsgin; }
/**
 * THis is the message to be used when the person is teleported.
 * @return the out message when they teleport
 */
string query_mmsgout() { return _messages->mmsgout; }

/**
 * The teleport in message.  Sets the message to be seen when
 * a player telerpots into the room.
 * @param str the message to be seen
 */
int set_mmsgin(string str) {
   if (strsrch(str, "$N") == -1) {
      return 0;
   }
   _messages->mmsgin = str;
   return 1;
} /* set_mmsgin() */

/**
 * Sets the teleport out message.  If the player teleports out, this
 * is the message seen.
 * @param str the teleport message
 */
int set_mmsgout(string str) {
   if (strsrch(str, "$N") == -1) {
      return 0;
   }
   _messages->mmsgout = str;
   return 1;
} /* set_mmsgout() */

mixed *query_facing() { return copy( facing ); }

/**
 * The facing array is a list of directions and two integers which determine
 * which way we face.  The layout is:<br>
 * ({ facing, ({ dirs }), up_down_facing, ({ up_down_dirs }) })
 * @param args the facing arguments
 */
void set_facing( mixed *args ) { facing = args; }

/**
 * This method finds the relative direction from the passed in direction.
 * @param word the exit name ('east', 'west',...)
 * @param from the offset to find the exit from
 * @return the relative direction
 */
string find_rel( string word, int from ) {
  int i;

  i = member_array( word, facing[ 1 ] );
  if ( i != -1 ) {
    i = ( i + 8 - facing[ 0 ] ) % 8;
    return REL_DIRS[ 3 * i + from ];
  }
  i = member_array( word, facing[ 2 ] );
  if ( i != -1 ) {
    return ({ "up", "down" })[ i ];
  }
  return word;
} /* find_rel() */

/**
 * Finds the absolute direction from the input relative direction.
 * @param word the exit name ('left', 'right', ...)
 * @return the absolute direction
 */
string find_abs( string word ) {
  int i;

  i = member_array( word, REL_DIRS );
  if ( i != -1 ) {
    i = ( i / 3 + facing[ 0 ]) % 8;
    return facing[ 1 ][ i ];
  }
  i = member_array( word, ({ "up", "down" }) );
  if ( i != -1 ) {
    return facing[ 2 ][ i ];
  }
  return word;
} /* find_rel() */

/**
 * This method takes in a relative direction and reorients us in the correct
 * way to go in that direction.  This also updates our facing so we are
 * facing in the specified relative direction.
 * @param word the direction to look up
 * @return the real direction
 */
string reorient_rel( string word ) {
  int i;

  i = member_array( word, REL_DIRS );
  if ( i != -1 ) {
    i = ( i / 3 + facing[ 0 ] ) % 8;
    facing[ 0 ] = i;
    return facing[ 1 ][ i ];
  }
  i = member_array( word, ({ "up", "down" }) );
  if ( i != -1 ) {
    return facing[ 2 ][ i ];
  }
  return word;
} /* reorient_rel() */

/**
 * This method takes in a absolute direction and reorients us in the correct
 * way to go in that direction.
 * @param word the direction to look up
 */
void reorient_abs( string verb ) {
  if ((ABS_FACING)[verb]) {
    facing[0] = (ABS_FACING)[verb] % 8;
  }
} /* reorient_rel() */

/**
 * This method sets the object for us to drag when we try and leave.
 * @param thing the object to drag off
 */
void set_dragging( object thing ) { add_property("dragging", thing); }

/**
 * This method returns the object we are dragging.
 * @return the thing we are dragging
 */
object query_dragging() { return query_property("dragging"); }

/**
 * This method resets the object we are dragging.
 */
void reset_dragging() { add_property("dragging", 0); }

/**
 * This is used by the movement system to look in the room when we move.
 * It does checks for verbose and other checks before doing the look.
 */
int room_look() {
   if ( query_property( UNKNOWN_MOVE ) || !( interactive( this_object() ) ||
         this_object()->query_slave() ) )
      return 0;
   /* These need to be evaluated immediately, hence the bypass_queue() call. */
   if(!mapp(verbose))
     verbose = ([ ]);

   if(verbose && verbose["look"]) {
      this_object()->ignore_from_history( "look" );
      this_object()->bypass_queue();
      command( "look" );
   } else {
      this_object()->ignore_from_history( "glance" );
      this_object()->bypass_queue();
      command( "glance" );
   }
   return 1;
} /* room_look() */

/**
 * This method returns the current verbose mode setting of the player.
 * @param the type of verbosity, by default it will return the normal stuff.
 * @return the verbose mode of the player
 */
int query_verbose(string type) {
  if(!verbose || !mapp(verbose)) {
    verbose = ([ ]);
  }
  return verbose[type];
} /* query_verbose() */

/**
 * This method sets the verbosity for a given type.
 */
void set_verbose(string type, int val) {
  if(!verbose || !mapp(verbose)) {
    verbose = ([ ]);
  }

  if(member_array(type, VERBOSE_TYPES) != -1) {
    verbose[type] = val;
  }
}

/**
 * This method returns the current verbose/brief types.
 */
string *query_verbose_types() {
  return VERBOSE_TYPES;
}

varargs int move_with_look( mixed dest, string messin, string messout ) {
   return_to_default_position(1);
   if ( (int)this_object()->move( dest, messin, messout ) != MOVE_OK )
      return 0;
   room_look();
   return_to_default_position(1);
   return 1;
} /* move_with_look() */

varargs int exit_command( string word, mixed verb, object thing, int redirection ) {
   string special_mess, *bits, *exits, redirect;
   int temp;

   if ( !environment() ) {
      return 0;
   }

   if ( !verb ) {
      verb = word;
      bits = explode( word, " " );
      if ( sizeof( bits ) > 1 ) {
         word = implode( bits[ 1 .. ], " " );
      } else {
         word = "";
      }
   } else {
      if ( pointerp( verb ) ) {
         special_mess = verb[ 1 ];
         verb = verb[ 0 ];
      }
      bits = explode( verb, " " );
      if ( sizeof( bits ) > 1 ) {
         word = implode( bits[ 1 .. ], " " );
      } else {
         word = "";
      }
   }
   if ( lengthen[ verb ] ) {
      verb = lengthen[ verb ];
   }
   exits = (string *)environment()->query_exits();
   if ( !exits ) {
      return 0;
   }

   if ( member_array( verb, exits ) != -1 ) {
     if ( environment()->query_relative( verb ) ) {
       return 0;
     }

     if ((abs_facing)[verb]) {
       facing[0] = (abs_facing)[verb] % 8;
     }
   } else {
     if (member_array(find_abs(verb), exits ) == -1 ) {
       return 0;
     }
     verb = reorient_rel(verb);
   }
   if ( !thing ) {
      thing = this_object();
   }

    //If the player has redirection enabled!
    //Redirection returns a string which is an alternative exit to try.
    //It calls exit_command to do all of the proper checks before hand,
    //it blocks recursion by way of a flag which is passed as the fourth arg
    //in exit command.
    if ( !redirection ) {
        if ( stringp( redirect = thing->query_exit_redirection( word ) ) ) {
            if ( temp = this_object()->exit_command( verb, redirect, thing, 1 ) ) 
                return temp;
        }
    }

   return (int)"/obj/handlers/room_handler"->exit_move( verb, word,
         special_mess, thing );
} /* exit_command() */

void become_flummoxed() {
   int will;

   will = query_int() * query_wis();
   if ( will < random( WILL_POWER ) )
      this_object()->interrupt_ritual();
   if ( will < random( WILL_POWER ) )
      this_object()->interrupt_spell();
   if ( will < random( WILL_POWER ) )
      this_object()->stop_all_fight();
} /* become_flummoxed() */

int run_away() {
   int i;
   object old_env;
   mixed *direcs;
   
   direcs = (mixed *)environment()->query_dest_dir(this_object());
   old_env = environment();
   while ( sizeof( direcs ) ) {
      i = random( sizeof( direcs ) / 2 ) * 2;
      if ( exit_command( direcs[i] ) ) {
          event( old_env, "run_away", direcs[ i ], direcs[ i + 1 ] );
          return 1;
      }

      direcs = delete( direcs, i, 2 );
   }
   return 0;
} /* run_away() */

/* Now handled in test_remove().
int cannot_get_stuff() { return !query_property( PASSED_OUT ); }
*/

/** @ignore yes */
mixed *stats() {
   return container::stats() + stats::stats() + ({
           ({ "max_hp", max_hp }),
           ({ "hp",  hp }),
           ({ "max_gp", max_gp }),
           ({ "gp", gp }),
           ({ "alcohol", drink_info[ D_ALCOHOL ] }),
           ({ "food", drink_info[ D_FOOD ] }),
           ({ "drink", drink_info[ D_DRINK ] }),
           ({ "gender", query_gender_string() }),
           ({ "alignment", this_object()->query_al() }),
           ({ "deity", deity }),
           ({ "total money", query_value() }),
           ({ "xp", query_xp() }),
   }) + armour::stats() + combat::stats();
} /*  stats() */

/**
 * This method returns the current array used for calculating 'it' and
 * 'them' in the find_match code.
 * @return the array of objects matching them
 * @see /secure/simul_efun->find_match()
 * @see set_it_them()
 */
class obj_match_context query_it_them() { return _liv_data->it_them; }
/**
 * This method sets the current array used for calculating 'it' and
 * 'them' in the find_match code.
 * @param args the new array of objects
 * @see /secure/simul_efun->find_match()
 * @see query_it_them()
 */
void set_it_them( class obj_match_context args) { _liv_data->it_them = args; }

/**
 * This method adds a follower to the living object.  A follower will
 * happily follow around the person in front.  Used in the follow
 * command.
 * @param ob the object to follow us
 * @see remove_follower()
 * @see query_followers()
 * @return 1 on success, 0 on failure
 */
int add_follower(object ob) {
  if (ob == this_object()) {
    return 0;
  }
  if (member_array(ob, _liv_data->followers) == -1) {
    _liv_data->followers += ({ ob });
  }
  return 1;
} /* add_follower() */

/**
 * This method removes a follower from the living object.  A follower will
 * happily follow around the person in front.  Used in the unfollow
 * and lose commands.
 * @param ob the object to remove from the follow list
 * @see add_follower()
 * @see query_followers()
 * @return 1 on success, 0 on failure
 */
int remove_follower(object ob) {
  int i;

  i = member_array(ob, _liv_data->followers);
  if (i != -1) {
    _liv_data->followers = delete(_liv_data->followers, i, 1);
    return 1;
  }
  return 0;
} /* remove_follower() */

/**
 * This is a method to check to see if this object can actually follow
 * the person they are following.
 * @param thing the thing following us
 * @param verb the direction they are going to
 * @param special any special stuff
 * @return 1 if we are allowed to go there, 0 otherwise
 */
int check_doing_follow(object thing, string verb, string special) {
   return 1;
} /* check_doing_follow() */

/**
 * This method returns the current room of the object.  This was needed
 * previously to use in things like unique_array, before function
 * pointers came into existance.
 * @return the environment of the object
 */
object query_current_room() { return environment(); }

/**
 * This method returns the current list of followers to the living
 * object.
 * @see add_follower()
 * @see remove_follower()
 */
mixed *query_followers() { return copy(_liv_data->followers - ({ 0 })); }

/** @ignore yes */
varargs void adjust_money(mixed amt, string type) {
  return money::adjust_money(amt, type);
} /* adjust_money() */

/** @ignore yes */
mixed *query_money_array() {
  return money::query_money_array();
} /* query_money_array() */

/** @ignore yes */
int query_money(string type) {
  return money::query_money(type);
} /* query_money() */

/** @ignore yes */
int query_value() { return money::query_value(); }

void do_burden_call() {
  if(_liv_data->burden_call)
    remove_call_out(_liv_data->burden_call);
  
  _liv_data->burden_call = call_out("calc_burden", 1);
}

int query_burden_limit() {
  if (this_object()->query_creator()) { 
    return MAX_CREATOR_INVEN;
  } else {
    return MAX_INVEN;
  }
} /* query_burden_limit() */ 

/** @ignore yes */
void event_enter( object thing, string mess, object from ) {
  if(environment( thing ) == this_object()) {
    do_burden_call();
    
    if(sizeof(all_inventory()) > query_burden_limit() ) {
      _liv_data->to_drop += ({ thing });
      remove_call_out("test_number_of_items");
      call_out("test_number_of_items", 5 + random(5));
    }
  }
}

/** @ignore yes */
void event_exit( object thing, string mess, object to ) {
  if(environment(thing) == this_object()) {
    do_burden_call();
  }
}

/** @ignore yes */
void test_number_of_items() {
   int how_many;
   object thing, *things, *dropped;

   things = all_inventory() - query_armours() - query_holding();
   how_many = sizeof(things) - query_burden_limit();
   if ( how_many < 1 ) {
      return;
   }

   _liv_data->to_drop -= ({ 0 });

   dropped = ({ });
   while(how_many > 0 && sizeof(things)) {
      if (sizeof(_liv_data->to_drop)) {
         thing = _liv_data->to_drop[random(sizeof(_liv_data->to_drop))];
      } else {
         thing = things[random(sizeof(things))];
      }
      things -= ({ thing });
      _liv_data->to_drop -= ({ thing });

      if(!thing || !thing->short() || thing->drop() ||
         thing->query_property("cannot fumble") ||
         thing->id("coin") ||
         environment(thing) != this_object()) {
        continue;
      }

      if((int)thing->move(environment()) == MOVE_OK) {
        how_many--;
        dropped += ({ thing });
      }
   }

   _liv_data->to_drop = ({ });

   if(sizeof(dropped)) {
     tell_object( this_object(), "Whoops!  You tried to carry too many "
                  "things and fumbled "+
                  query_multiple_short( dropped ) +".\n" );
     this_object()->dest_hide_shadow();
     tell_room( environment(), capitalize( the_short() ) +" juggles "+
                "around "+ query_possessive() +" stuff and fumbles "+
                query_multiple_short( dropped ) +".\n", this_object() );
   }
}

/**
 * This forces a burden recalculation.  This should also be used to
 * force a recalcuation of the number of items someone can carry.
 */
void force_burden_recalculate() {
   do_burden_call();
   remove_call_out("test_number_of_items");
   call_out("test_number_of_items", 5 + random(5));
}

/** @ignore yes */
object *find_inv_match( string words, object looker ) {
   return sort_array( container::find_inv_match( words, looker ),
         (: ( member_array( $1, query_holding() ) != -1 ? -1 : 0 ) :) );
} /* find_inv_match() */

/** @ignore yes */
int attack_by(object ob) {
   return_to_default_position(0);
   return ::attack_by(ob);
} /* attack_by() */

/** @ignore yes */
int attack_ob(object ob) {
   return_to_default_position(0);
   return ::attack_ob(ob);
} /* attack_ob() */

/**
 * This method sets the always the flag to always use the default position.
 * If this is set then rooms cannot override the position message which is
 * displayed by the object.
 * @param flag if we should always use the default position
 * @see query_always_use_default_position()
 * @see set_default_position()
 * @see return_to_default_position()
 */
void set_always_use_default_position(int flag) {
   always_use_default_position = flag;
} /* set_always_use_default_position() */

/**
 * This method sets the always the flag to always use the default position.
 * If this is set then rooms cannot override the position message which is
 * displayed by the object.
 * @return the always use default position flag
 * @see set_always_use_default_position()
 * @see set_default_position()
 * @see return_to_default_position()
 */
int query_always_use_default_position() {
   return always_use_default_position;
} /* query_always_use_default_position() */

/**
 * This method sets the default position of the object.  This is used to
 * allow things to default to some other exciting off beat and froopy
 * default position.  The value returned by this is the command code
 * used to put the object back into the default position or an
 * array which contains three or one elements, the first is the string
 * to use as the position, the second and third (if they exist) are
 * the string to tell the person when changing and the string to tell
 * everyone else when changing position.
 * @return the default position
 * @see set_default_position()
 * @see return_to_default_position()
 * @see set_always_use_default_position()
 */
string query_default_position() {
   mixed pos;

   if (stringp(default_position) &&
              default_position->query_position_command()) {
      pos = default_position;
   } else if (pointerp(default_position) &&
              (sizeof(default_position) == POSITION_MESS_SIZE ||
               sizeof(default_position) == POSITION_ONLY_TYPE_SIZE)) {
      pos = default_position;
   } else if (functionp(default_position)) {
      pos = default_position;
   }

   if (!pos) {
      pos = STANDING_CMD;
   }

   return pos;
} /* query_default_position() */

/**
 * This sets the default position of the object.  This is used to
 * allow things to default to some other exciting off beat and froopy
 * default position.  The paramater to this is the command code
 * used to put the object back into the default position or an
 * array which contains three or one elements, the first is the string
 * to use as the position, the second and third (if they exist) are
 * the string to tell the person when changing and the string to tell
 * everyone else when changing position.  The paramer can also be
 * a function pointer, if it is then it will be evaluated and
 * have two parameters passed into the function.  The first is
 * the object returing to the position and the second is the leaving
 * flag.
 * <p>
 * Please note!  After setting the position you will need to
 * make the object return to the default position to use it.
 * <p>
 * A second note!  A room can also define a query_default_position()
 * function which will be called, if this returns a value (and the
 * override flag is not set) then that will be used for the default
 * position.
 * @param str the new default position
 * @see query_default_position()
 * @see set_always_use_default_position()
 * @see /obj/monster()->set_cannot_change_position()
 * @see return_to_default_position()
 * @example
 * set_default_position("/cmds/living/kneel");
 * @example
 * set_default_position(({ "running" }));
 * @example
 * set_default_position(({ "fishing",
 *                         "You start to fish.\n",
 *                         the_short() + " starts to fish.\n" }));
 * @example
 * npc->set_default_position(({ "running" }));
 * npc->return_to_default_position(1);
 */
void set_default_position(mixed str) {
   if (stringp(str) && str->query_position_command() && str != STANDING_CMD) {
      default_position = str;
   } else if (!str || str == STANDING_CMD) {
      default_position = 0;
   } else if (pointerp(str) && (sizeof(str) == POSITION_ONLY_TYPE_SIZE ||
                                sizeof(str) == POSITION_MESS_SIZE)) {
      default_position = str;
   } else if (functionp(str)) {
      default_position = str;
   }
} /* set_default_position() */

/**
 * This method returns the living object to its default position.
 * @param leaving this is if we are leaving the room
 * @see set_default_position()
 * @see query_default_position()
 * @see set_always_use_default_position()
 */
void return_to_default_position(int leaving) {
   mixed pos;

   /* See if we are being forced to always use the set default position. */
   if (query_always_use_default_position()) {
      pos = query_default_position();
   } else {
      /* See if the room has a default position they wish to tell us about. */
      pos = 0;
      if (environment()) {
         pos = environment()->query_default_position(this_object());
      }
      if (!pos) {
         pos = query_default_position();
      }
   }

   if (functionp(pos)) {
      if (!evaluate(pos, this_object(), leaving)) {
         pos = 0;
         /* See if the environment has any special conditions */
         if (environment()) {
            pos = environment()->query_default_position(this_object());
         }
         if (!pos) {
            pos = STANDING_CMD;
         }
      }
   }

   if (stringp(pos)) {
      /* If we are not standing up...  Stand up... */
      if (position != pos->query_position_type() ||
          (leaving && query_position_on())) {
         if (leaving) {
            catch(pos->position_floor(this_object()));
         } else {
            /*
             * If they are not leaving, just get them to stand up or
             * whatever, this way people can fight on chairs and
             * stuff...
             */
            catch(pos->position(this_object()));
         }
      }
   } else if (pointerp(pos) && position != pos[POSITION_TYPE_INDEX]) {
      /* If it is a pointer, then we do something special... */
      if (sizeof(pos) > 1) {
         if (pos[POSITION_ME_MESS_INDEX]) {
            tell_object(this_object(), pos[POSITION_ME_MESS_INDEX]);
         }
         if (pos[POSITION_REST_MESS]) {
            tell_room(environment(), pos[POSITION_REST_MESS], this_object());
         }
      }
      set_position(pos[POSITION_TYPE_INDEX]);
      set_position_on(0);
      set_position_type(0);
      set_position_multiple(0);
   }
} /* return_to_default_position() */

/**
 * This sets the current position of the object.
 * @param name the string to use for the position
 * @see query_position()
 * @see query_position_on()
 * @see query_position_multiple()
 * @see query_position_type()
 * @see set_position_on()
 * @see set_position_multiple()
 * @see set_position_type()
 */
void set_position(string name) {
   position = name;
} /* set_position() */

/**
 * This queries the current position of the object.
 * @return the current position of the living
 * @see query_position_on()
 * @see query_position_multiple()
 * @see query_position_type()
 * @see set_position()
 * @see set_position_on()
 * @see set_position_multiple()
 * @see set_position_type()
 */
string query_position() {
   return position;
} /* query_position() */

/**
 * This sets the current object which is being referenced as being
 * 'on', 'beside' or 'at'.
 * @param ob the object being referenced
 * @see query_position()
 * @see query_position_on()
 * @see query_position_multiple()
 * @see query_position_type()
 * @see set_position()
 * @see set_position_multiple()
 * @see set_position_type()
 */
void set_position_on(mixed ob) {
   if (!position_on) {
      position_on = allocate(POSITION_ARRAY_SIZE);
   }
   position_on[POS_ON_OBJECT] = ob;
} /* set_position_on() */

/**
 * This sets fact that the object being referenced is one of many.  So
 * you get something more like 'xx is sitting on one of the couches'.
 * @param mult 0 if non-multiple, 1 if multiple
 * @see query_position()
 * @see query_position_on()
 * @see query_position_multiple()
 * @see query_position_type()
 * @see set_position()
 * @see set_position_multiple()
 * @see set_position_type()
 */
void set_position_multiple(int mult) {
   if (!position_on) {
      position_on = allocate(POSITION_ARRAY_SIZE);
   }
   position_on[POS_MULTIPLE] = mult;
} /* set_position_multiple() */

/**
 * This returns fact that the object being referenced is one of many.  So
 * you get something more like 'xx is sitting on one of the couches'.
 * @return 0 if non-multiple, 1 if multiple
 * @see query_position_on()
 * @see query_position_multiple()
 * @see query_position_type()
 * @see set_position()
 * @see set_position_on()
 * @see set_position_multiple()
 * @see set_position_type()
 */
int query_position_multiple() {
   if (!position_on) {
      return 0;
   }
   return position_on[POS_MULTIPLE];
} /* query_position_multiple() */

/**
 * This sets way the object is being referenced.  The 'on', 'at', 'beside'
 * or whatever strings.
 * @param type the new type string
 * @see query_position()
 * @see query_position_on()
 * @see query_position_multiple()
 * @see query_position_type()
 * @see set_position()
 * @see set_position_on()
 * @see set_position_multiple()
 */
void set_position_type(string type) {
   if (!position_on) {
      position_on = allocate(POSITION_ARRAY_SIZE);
   }
   position_on[POS_TYPE] = type;
} /* set_position_type() */

/**
 * This returns way the object is being referenced.
 * The 'on', 'at', 'beside'
 * or whatever strings.
 * @return the current type string
 * @see query_position()
 * @see query_position_on()
 * @see query_position_multiple()
 * @see set_position()
 * @see set_position_on()
 * @see set_position_multiple()
 * @see set_position_type()
 */
string query_position_type() {
   if (!position_on ||
       !position_on[POS_TYPE]) {
      return "on";
   }
   return position_on[POS_TYPE];
} /* query_position_type() */

/**
 * This queries the current object being referenced.  This can be an
 * object or a string.
 * @return the current object being referenced
 * @see query_position()
 * @see query_position_multiple()
 * @see query_position_type()
 * @see set_position()
 * @see set_position_on()
 * @see set_position_multiple()
 * @see set_position_type()
 */
object query_position_on() {
   if (!position_on) {
      return 0;
   }
   return position_on[POS_ON_OBJECT];
} /* query_position_on() */

/**
 * This method returns the short description of the object
 * we are referencing.
 * @return the short description of the object, "" if none
 * @see query_position_on()
 * @see set_position_on()
 * @see query_position_long()
 */
string query_position_on_short() {
   if (!position_on || !position_on[POS_ON_OBJECT]) {
      return "";
   }
   if (stringp(position_on[POS_ON_OBJECT])) {
      return position_on[POS_ON_OBJECT];
   }
   return position_on[POS_ON_OBJECT]->the_short();
} /* query_position_on_short() */

/**
 * This method returns the string used in the long description of the
 * living object.
 * @return the long description of the position
 * @see query_position_type()
 * @see query_position_on_short()
 */
string query_position_long() {
   if (position != STANDING || position_on) {
      if (position_on) {
         return query_pronoun() + " is " + query_position_type() + " "+
                query_position_on_short()+".\n";
      }
      return query_pronoun()+" is "+position+" on the floor.\n";
   }
   return "";
} /* query_position_long() */

/**
 * This method returns the description used in the inventory listing
 * code.
 * @return the string used in inventory listings
 * @see query_position_long()
 * @see query_position_on_short()
 * @see query_position_type()
 */
string query_position_short() {
   if (!position_on ||
       !position_on[POS_ON_OBJECT]) {
      return position;
   }
   return position + " " + query_position_type() + " " +
          query_position_on_short();
} /* query_position_short() */

/**
 * This method returns 1 if the creature is trapped, ie cannot walk.
 * By default, a creature is free to walk, hence the normal return
 * value of 0.  If you shadow this method, including a message about
 * why the player cannot move move is a good idea.
 * @param verb the exit direction that the player is trying to move.
 * @param dest_other the destination information for the exit.
 * @see /std/room->query_dest_other()
 * @return 0 means creature is free to move, 1 that it is trapped.
 */
varargs int cannot_walk( string verb, mixed *dest_other) {
   return 0;
}

/**
 * This method can be shadowed by all forms of magical and
 * religious shields so that the shields command will give
 * the player a nice description.
 * The first element in the array should contain the description
 * as shown to the player, the second element should contain the
 * description shown to others.
 * @example ({ "You have a nice shield.", "He has a nice shield." })
 * @return Array with description of shield.
 */
string *query_arcane_shields() { return ({ }); }

/** @ignore yes */
int can_find_match_reference_inside_object(object thing, object looker) {
   if (member_array(thing, query_wearing_hidden(looker, 0)) != -1) {
      return 0;
   }
   return 1;
} /* can_find_match_reference_inside_object() */

/**
 * If there is no mapping for deity favour, or if the God is not mentioned, 
 * return 0 as 'no favour'.
 * Otherwise return the favour amount.
 * @args God Name of God
 */
int query_deity_favour( string god ) {
  if ( !mapp( deity_favour ) ) 
    return 0;

  if ( !undefinedp( deity_favour[ god ] ) ) 
    return 0;

  return deity_favour[ god ];
}

/**
 * Adjust the favour rating for 'god' by amount.
 * A +ve amount is good favour, a negative is bad.
 */
void adjust_deity_favour( string god, int amount ) {

  if ( !mapp( deity_favour ) ) 
    deity_favour = ([ ]);
  
  if ( !undefinedp( deity_favour[ god ] ) ) 
    deity_favour[ god ] = amount;

  deity_favour[ god ] += amount;

  if ( deity_favour[ god ] > MAX_FAVOUR )
    deity_favour[ god ] = MAX_FAVOUR;

  if ( deity_favour[ god ] < -MAX_FAVOUR )
    deity_favour[ god ] = -MAX_FAVOUR;

  return;
}

/**
 * Return the deity favour mapping.
 */
mapping query_all_deity_favour() { return deity_favour; }
// --- END [/mnt/home2/grok/lib/std/living/living.no_eff_shad.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/living/crafts.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/living/crafts.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628811   Available: 13576165
Inodes: Total: 5242880    Free: 4960135
2230 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/living/crafts.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628811   Available: 13576165
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: crafts.c,v 1.2 2002/03/16 01:05:36 pinkfish Exp $
 * $Log: crafts.c,v $
 * Revision 1.2  2002/03/16 01:05:36  pinkfish
 * Fix up some things with undieing.
 *
 * Revision 1.1  2001/11/12 22:44:49  pinkfish
 * Initial revision
 *
 * Revision 1.4  2001/11/12 22:21:24  pinkfish
 * Add in some docs.
 *
 * Revision 1.3  2001/08/15 20:29:49  tannah
 * Fix0rd a bug in query_spells_nocase()
 *
 * Revision 1.2  2001/08/15 04:11:32  presto
 * Added code to handle spell names of any upper/lowercase
 *
 * Revision 1.1  1998/01/06 04:29:08  ceres
 * Initial revision
 *
*/
private mixed _processes;

void create() {
   _processes = ([ ]);
}

/**
 * This method returns the current bunch of processes for the object.
 * @return the processes
 */
mapping query_processes() {
   return _processes;
}

/**
 * This method returns the list of processes without any case issues.
 * @return the list of processes without any case
 */
mapping query_processes_nocase() {
  mapping lc_processes = ([]);
  filter( this_object()->query_processes(),
                 (: $3 += ([ lower_case( $1 ) : $2 ]) :), lc_processes );
  return lc_processes;
}

/**
 * This method adds a process into the current process list.
 * @param name the name of the process to add
 * @param ob the object the process is on
 * @return 1 on success, 0 on failure
 */
int add_process(string name, string ob) {
   _processes[name] = ob;
   return 1;
}

/**
 * This method removes the spell of the given name.
 * @param name the name of the spell to remove
 * @return 1 on succes, 0 on failure
 */
int remove_process(string name) {
  string process, name_lc;

  name_lc = lower_case(name);
  foreach (process in keys(_processes)) {
     if (lower_case(process) == name_lc) {
        map_delete(_processes, process);
     }
  }
  return 1;
}

/**
 * This method finds the data for the spell of the specific name
 * @param word the name of the spell to find data on
 * @return the data for the spell
 */
string query_process( string word ) {
   return _processes[word];
} /* query_spell() */

/**
 * This method resets all of the process data.
 */
protected void reset_processes() {
   _processes = ([ ]);
} /* reset_processes() */
// --- END [/mnt/home2/grok/lib/std/living/crafts.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/leaflet.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/leaflet.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628810   Available: 13576164
Inodes: Total: 5242880    Free: 4960135
2736 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/leaflet.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628810   Available: 13576164
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/object";

private int page;
private mixed *pages;

int do_open(int page_no);

void create() {
   do_setup++;
   ::create();
   do_setup--;
   pages = ({ ({ }) });
   if ( !do_setup )
      this_object()->setup();
  add_help_file("leaflet");
} /* create() */

int query_leaflet() { return 1; }

int query_page() { return page; }
mixed *query_pages() { return copy( pages ); }

void init() {
   add_command( "turn", "[a] page of <direct:object>" );
   add_command( "open", "<direct:object> to [page] <number>",
                (: do_open($4[1]) :));
} /* init() */

void set_no_pages( int number ) {
   int i;

   if ( number < 1 ) {
      number = 1;
   }
   pages = ({ });
   for ( i = 0; i < number; i++ ) {
      pages += ({ ({ }) });
   }
} /* set_no_pages() */

varargs void set_read_mess( mixed mess, string lang, int size ) {
   ::set_read_mess( mess, lang, size );
   pages[ page ] = query_read_mess();
} /* set_read_mess() */

mixed add_read_mess( mixed mess, string type, string lang, int size ) {
   mixed ret;

   ret = ::add_read_mess( mess, type, lang, size );
   pages[ page ] = query_read_mess();
   return ret;
} /* add_read_mess() */

int query_open_page() { return page + 1; }

void set_open_page( int number ) {
   if ( ( number < 1 ) || ( number > sizeof( pages ) ) ) {
      number = 1;
   }
   page = number - 1;
   ::set_read_mess( pages[ page ] );
} /* set_open_page() */

int do_turn() {
   set_open_page( page + 2 );
   return 1;
} /* do_turn() */

int do_open(int page_no) {
   if ( ( page_no < 1 ) || ( page_no > sizeof( pages ) ) ) {
      add_failed_mess("The page no " + page_no + " does not exist.\n");
      return 0;
   }
   set_open_page(page_no);
   return 1;
} /* do_open() */

mapping query_static_auto_load() {
   if ( explode( file_name( this_object() ), "#" )[ 0 ] != "/std/leaflet" ) {
      return ([ ]);
   }
   return int_query_static_auto_load();
} /* query_static_auto_load() */

mapping query_dynamic_auto_load() {
   return ([
      "::" : ::query_dynamic_auto_load(),
      "page" : page,
      "pages" : copy( pages ),
   ]);
} /* query_dynamic_auto_load() */

void init_dynamic_arg( mapping map ) {
   if ( !mapp( map ) ) {
      return;
   }
   if ( map[ "::" ] ) {
      ::init_dynamic_arg( map[ "::" ] );
   }
   page = map[ "page" ];
   if ( pointerp( map[ "pages" ] ) ) {
      pages = map[ "pages" ];
      set_open_page( page + 1 );
   }
} /* init_dynamic_arg() */

/** @ignore yes */
string query_read_short(object player, int ignore_labels) {
   string ret;

   if (page == 0) {
      ret = ::query_read_short(player, 1);
   } else {
      ret = ::query_read_short(player, 0);
   }
   return "page " + query_num(page) + " of " + ret;
} /* query_read_short() */
// --- END [/mnt/home2/grok/lib/std/leaflet.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/outsides/plain.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/outsides/plain.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628809   Available: 13576163
Inodes: Total: 5242880    Free: 4960135
5336 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/outsides/plain.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628809   Available: 13576163
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker: ceres $
 * $Id: plain.c,v 1.7 2002/03/26 01:41:57 pinkfish Exp ceres $
 * 
 */
#define CREATOR "Ceres"
/**
 * This is a standard field room.  It is a specialisation of /std/outside
 * providing various ready-made add_items for your fields.
 * <p>
 * room_chats are also provided, if you don't wish to keep them simply use
 * room_chat to write your own or stop_room_chats to remove them.
 * <p>
 * The items and chats are seasonal adding richness to your field setting.
 * @author Ceres
 */
#include <weather.h>
#include <terrain_map.h>

inherit TERRAIN_MAP_OUTSIDE_BASE;

void create() {
  do_setup++;
  ::create();
  do_setup--;
  
  set_light(80);
  set_climate("Aw");
  add_zone("plain");
  
  switch((string)WEATHER->query_season()) {
  case "spring":
    add_item("flower", ({"long", "Some pretty flowers.",
                         "get", ({this_object(), "do_get_flower"}),
                         "pick", ({this_object(), "do_get_flower"}),
                         "smell", "The flowers smell wonderful."
                         }));
    add_item("tree", "There is the occasional tree here and there covered "
             "with new leaves at this time of year.");
    add_item(({"floor", "ground", "earth"}),
             "The ground is mostly grassy "
             "with the occasional clump of wild flowers.");
    
    room_chat(({120, 240, ({"Birds sing loudly announcing their presence.",
                              "Bees buzz busily from flower to flower.",
                              "A butterfly alights on a nearby flower.",
                              "A bird takes off from a tree and flies low "
                              "across the fields."})}));
    break;
  case "summer":
    add_item(({"floor", "ground", "earth"}), "The ground is mostly grassy.  "
               "The grass is long and sways gently in the breeze.  Here and "
               "there amongst the grass are wild flowers and other plants.");
    add_item("tree", "There are a few trees which are in their full "
             "foliage right now.");
    add_item(({"flower", "plant"}),
             ({"long", "Some pretty flowers.",
                 "get", ({this_object(), "do_get_flower"}),
                 "pick", ({this_object(), "do_get_flower"}),
                   "smell", "The flowers smell wonderful."
                     }));
    room_chat(({120, 240,
                  ({"The wind stirs the grass which sways reminding "
                      "you of waves on an ocean.",
                      "A small animal rustles in the long grass.",
                      "A butterfly alights on a nearby flower.",
                      "A bee buzzes around looking for nectar."})}));
    break;
  case "autumn":
    add_item(({"floor", "ground", "earth"}), "The ground is mostly grassy.");
    add_item("tree", "The occasional trees are gold and brown as their "
             "leaves die before winter.");
    
    room_chat(({120, 240, ({"A squirrel rushes up a nearby tree trunk.",
                              "A bird of prey soars high overhead looking "
                              "for something to eat."})}));
    break;
  case "winter":
    add_item(({"floor", "ground", "earth"}), "The ground is mostly grassy "+
               "apart from the occasional hardy shrub.");
    add_item("tree", "Dotted here and there are skeletal trees bare of "
             "leaves waiting for spring.");
    room_chat(({120, 240, ({"Somewhere a small animal forages in the "
                              "undergrowth for winter food."})}));
    break;
  }
  add_item("rock", ({ "long", "A nice rock looking thingy.",
                        "get",  ({ this_object(), "do_get_rock" }) }) );
  if (!do_setup) {
    this_object()->setup();
    this_object()->reset();
  }
}

/** @ignore yes */
mixed do_get_rock( string verb, object *dest ) {
  int rock_size;
  string rock_type;
  object rock;

  if ( query_property( "rock object" ) )
    return ( rock = clone_object( (string)query_property( "rock object" ) ) );
  if ( undefinedp( rock_size = (int)query_property( "rock size" ) ) )
    rock_size = 3;
  if ( !rock_size ) return 0;
  rock = clone_object( "/obj/mineral" );
  if ( undefinedp( rock_type = (string)query_property( "rock type" ) ) )
    rock_type = ({ "cinnabar", "coal", "rosy-quartz", "chalk", "flint",
                   "slate" })[ random( 6 ) ];
  rock->make_mineral( rock_type, 1 + random( rock_size ) );
  if ( !( rock->move( this_player() ) ) ) return 1;
  rock->dest_me();
  return 0;
}

/** @ignore yes */
mixed do_get_flower( string verb, object *dest ) {
  string flower_type;
  object flower;

  if ( query_property( "flower object" ) )
    return (flower = clone_object((string)query_property("flower object")));
  if ((int)query_property("noflowers"))
    return 0;
  flower = clone_object("/std/plant");
  
  if(undefinedp(flower_type = (string)query_property("flower type")))
    flower_type = ({"forgetmenot", "buttercup", "daisy"})[ random(2) ];
  flower->set_plant(flower_type);
  flower->set_plant_type(flower_type);
  flower->set_plant_desc("A beautiful "+flower_type+" picked before its "
                         "time.");
  flower->add_plural( pluralize( flower_type ) );
  
  if (!(flower->move(this_player()))) return 1;
  flower->dest_me();
  return 0;
}
// --- END [/mnt/home2/grok/lib/std/outsides/plain.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/outsides/mountain.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/outsides/mountain.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628808   Available: 13576162
Inodes: Total: 5242880    Free: 4960135
5301 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/outsides/mountain.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628808   Available: 13576162
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: mountain.c,v 1.4 2002/03/26 01:41:57 pinkfish Exp $
 * $Log: mountain.c,v $
 * Revision 1.4  2002/03/26 01:41:57  pinkfish
 * Give them all basic inherit stuff so they can work with terrain rooms.
 *
 * Revision 1.3  2000/06/22 01:19:30  pinkfish
 * Make it use autodoc and fix up the inherit paths.
 *
 * Revision 1.2  1999/08/16 23:34:00  rywfol
 * Fixed pluralisation of flowers.
 * Rywfol 990817
 *
 * Revision 1.1  1998/01/06 04:29:46  ceres
 * Initial revision
 * 
*/
#define CREATOR "Ceres"
/**
 * This is a standard woodland room.  It is a specialisation of /std/outside
 * providing various ready-made add_items for your woodland.
 * <p>
 * room_chats are also provided, if you don't wish to keep them simply use
 * room_chat to write your own or stop_room_chats to remove them. 
 * <p>
 * The items and chats are seasonal adding richness to your woodland setting.
 * @author Ceres
 */
#include <weather.h>
#include <terrain_map.h>

inherit TERRAIN_MAP_OUTSIDE_BASE;

void create() {
  ::create();
  add_property("climate", ({-10, 0, 0 }) );
  switch((string)WEATHER->query_season()) {
  case "spring":
    add_item("flower", ({"long", "Very occasionally there are beautiful "+
                           "snowdrops nestled in the shadow of a boulder.",
                         "get", ({this_object(), "do_get_flower"}),
                         "pick", ({this_object(), "do_get_flower"}),
                         "smell", "The flowers smell wonderful."
                         }));
    add_item("tree", "There are only a few stunted trees here clinging "+
             "to life on the steep slopes.  New leaves poke cautiously "+
             "from their gnarled branches");
    add_item(({"floor", "ground", "earth"}), "The ground is mostly covered "+
             "by hardy grass interspersed by small shrubs, however there "+
             "are large patches of bare rock or gravel.  "+
             "Here and there larger rocks protrude from the ground.");
    
    room_chat(({120, 240, ({"A bird of prey swoops overhead.",
                            "A small insect flies past your face."})}));
    add_property("flower type", "snowdrop");
    break;
  case "summer":
  case "autumn":
    add_item(({"floor", "ground", "earth"}), "The ground is largely "+
             "covered with a hardy grass interspersed with small shrubs, "+
             "however there are large patches of bare rock and gravel.  Here "+
             "and there larger rocks protrude from the ground.");
    add_item("tree", "There are a few small trees clinging to life in this "+
             "harsh environment.");
    room_chat(({120, 240, ({"The wind whistles through the mountain passes.",
                            "A bird of prey swoops overhead.",
                            "An insect brushes against your face."})}));
    break;
  case "winter":
    add_item(({"floor", "ground", "earth"}), "The ground is bare earth "+
             "apart from the occasional hardy shrub.");
    add_item("tree", "There are a few trees dotted around their bare "+
             "branches making them look like ghouhlish skeletons.");
    room_chat(({120, 240, ({"The cold wind whistles over the mountains."
                            })}));
    break;
  }
  add_item("rock", ({ "long", "A nice rock looking thingy.",
                      "get",  ({ this_object(), "do_get_rock" }) }) );
  add_item("shrub", "Dotted here and there these hardy plants struggle "+
           "to survive on the thin soil.");
  add_item("grass", "A particularly wiry kind of grass obviously suited "+
           "to the harsh conditions and thins soil.");
  add_property("rock size", 5+random(20));
  add_property("track type", "mountain");
}

/** @ignore yres */
mixed do_get_rock(string verb, object *dest ) {
  int rock_size;
  string rock_type;
  object rock;

  if ( query_property( "rock object" ) )
    return ( rock = clone_object( (string)query_property( "rock object" ) ) );
  if ( undefinedp( rock_size = (int)query_property( "rock size" ) ) )
    rock_size = 3;
  if ( !rock_size ) return 0;
  rock = clone_object( "/obj/mineral" );
  if ( undefinedp( rock_type = (string)query_property( "rock type" ) ) )
    rock_type = ({ "cinnabar", "coal", "rosy-quartz", "chalk", "flint",
                   "slate" })[ random( 6 ) ];
  rock->make_mineral(rock_type, 1 + random(rock_size));
  if (!(rock->move(this_player() ) ) ) return 1;
  rock->dest_me();
  return 0;
}

/** @ignore yres */
mixed do_get_flower( string verb, object *dest ) {
  string flower_type;
  object flower;

  printf("Verb: %s\n", verb);
  if ( query_property( "flower object" ) )
    return (flower = clone_object((string)query_property("flower object")));
  if ((int)query_property("noflowers"))
    return 0;
  flower = clone_object("/std/plant");
  
  if(undefinedp(flower_type = (string)query_property("flower type")))
    flower_type = ({"forgetmenot", "violet"})[ random(2) ];
  flower->set_plant(flower_type);
  flower->set_plant_type(flower_type);
  flower->set_plant_desc("A beautiful "+flower_type+" picked before its "+
                         "time.\n");
  flower->add_plural( capitalize( flower_type ) );
  
  if (!(flower->move(this_player()))) return 1;
  flower->dest_me();
  return 0;
}
// --- END [/mnt/home2/grok/lib/std/outsides/mountain.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/outsides/road.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/outsides/road.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628806   Available: 13576160
Inodes: Total: 5242880    Free: 4960135
575 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/outsides/road.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628806   Available: 13576160
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: woodland.c,v 1.8 2003/04/16 23:12:26 ceres Exp $
*/
#define CREATOR "Ceres"
/**
 * This is a standard road. It hasn't been setup yet.
 */
#include <weather.h>
#include <terrain_map.h>

inherit TERRAIN_MAP_OUTSIDE_BASE;

void create() {
  do_setup++;
  ::create();
  do_setup--;
  add_property("track type", "road");
  add_zone("road");
  
  if(!do_setup) {
    this_object()->setup();
    this_object()->reset();
  }
}

string query_terrain_map_colour() { return "%^RED%^"; }
string query_terrain_map_character() { return "#"; }
// --- END [/mnt/home2/grok/lib/std/outsides/road.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/outsides/desert.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/outsides/desert.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628806   Available: 13576160
Inodes: Total: 5242880    Free: 4960135
2187 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/outsides/desert.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628806   Available: 13576160
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: desert.c,v 1.9 2003/04/16 23:12:26 ceres Exp $
 * 
*/
#define CREATOR "Ceres"
/**
 * This is a standard desert room.  It is a specialisation of /std/outside
 * providing various ready-made add_items for your desert.
 *
 * room_chats are also provided, if you don't wish to keep them simply use
 * room_chat to write your own or stop_room_chats to remove them.
 * @author Ceres
 */
#include <weather.h>
#include <move_failures.h>
#include <terrain_map.h>

inherit TERRAIN_MAP_OUTSIDE_BASE;

void create() {
  ::create();
  set_climate("Bw"); // arid desert.

  add_item("sand", "There is a lot of sand here, tons of it just lying "
     "about the place.");
  add_item("rock", "There are small rocks here and there in the sand.");
    
  room_chat(({120, 240, ({"Grains of sand are blown about in the slight "
          "breeze."})}));
  add_property("rock size", 2+random(5));
  add_property("track type", "desert");
  add_property("sand object", "/obj/media/sand");
}

string query_terrain_map_colour() { return "%^ORANGE%^"; }

int do_get_rock(object *indirs, string dir, string indir, mixed *args,
    string pattern)
{
  int rock_size;
  string rock_type;
  object rock;
  if ( query_property( "rock object" ) )
    rock = clone_object(query_property("rock object"));
  else {
    if ( undefinedp( rock_size = (int)query_property( "rock size" ) ) )
      rock_size = 3;
    if ( !rock_size ) return 0;
    rock = clone_object( "/obj/mineral" );
    if ( undefinedp( rock_type = (string)query_property( "rock type" ) ) )
      rock_type = ({ "cinnabar", "coal", "rosy-quartz", "chalk", "flint",
                     "slate" })[ random( 6 ) ];
    rock->make_mineral(rock_type, 1 + random(rock_size));
  }
  if (!(rock->move(this_player() ) ) ) return 1;
  rock->dest_me();
  return 0;
}

int do_get_sand(object *indirs, string dir, string indir, mixed *args,
    string pattern)
{
  object sand;
  sand = clone_object(query_property("sand object"));
  if (!sand) return 0;
  if (sand->move(this_player()) == MOVE_OK) {
    this_player()->add_succeeded_mess(sand, "$N $V $D.\n", ({ }) );
    return 1;
  }
  sand->dest_me();
  return 0;
}
// --- END [/mnt/home2/grok/lib/std/outsides/desert.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/outsides/woodland.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/outsides/woodland.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628805   Available: 13576159
Inodes: Total: 5242880    Free: 4960135
8372 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/outsides/woodland.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628805   Available: 13576159
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker: ceres $
 * $Id: woodland.c,v 1.8 2003/04/16 23:12:26 ceres Exp ceres $
 */
#define CREATOR "Ceres"
/**
 * This is a standard woodland room.  It is a specialisation of /std/outside
 * providing various ready-made add_items for your woodland.
 * <p>
 * room_chats are also provided, if you don't wish to keep them simply use
 * room_chat to write your own or stop_room_chats to remove them.
 * <p>
 * The items and chats are seasonal adding richness to your woodland setting.
 * @author Ceres
 */
#include <weather.h>
#include <terrain_map.h>

inherit TERRAIN_MAP_OUTSIDE_BASE;

void create() {
  do_setup++;
  ::create();
  do_setup--;
  set_light(80);
  add_zone("woodland");
  
  switch((string)WEATHER->query_season()) {
  case "spring":
    add_item("flower", ({"long", "Some pretty flowers.",
                         "get", ({this_object(), "do_get_flower"}),
                         "pick", ({this_object(), "do_get_flower"}),
                         "smell", "The flowers smell wonderful.\n"
                         }));
    add_item("tree", "There are trees everywhere here, you have "+
             "to pick your way between them.  They are budding with "+
             "new leaves at this time of year.");
    add_item(({"floor", "ground", "earth"}), "The ground is covered "+
             "by a beautiful carpet of flowers interspersed with small "+
             "shrubs.");
    add_item("shrub", "Dotted here and there among the carpet of flowers "+
             "are small shrubs, some thorny, all green.");

    room_chat(({120, 240, ({"Birds sing loudly announcing their presence.",
                            "Bees buzz busily from flower to flower.",
                            "A squirrel rushes up a nearby tree trunk.",
                            "A butterfly alights on a nearby flower.",
                            "A bird takes off from a tree with a furious "+
                              "beating of wings."})}));
    add_property("flower type", "bluebell");
    break;
  case "summer":
    add_item(({"floor", "ground", "earth"}), "You can barely see the "+
             "ground because of the waist-high ferns.  Dotted among the "+
             "ferns are small shrubs.");
    add_item("shrub", "Dotted here and there among the ferns "+
             "are small shrubs, some thorny, all green.");
    add_item("fern", "Everywhere you look there are ferns growing "+
                         "almost waist high between the trees.");
    add_item("tree", "The trees are in their full foliage right now.");
    room_chat(({120, 240, ({"The wind stirs the leaves of the trees making "+
                              "a sound like falling rain.",
                            "A squirrel rushes up a nearby tree trunk.",
                            "A butterfly alights on a nearby flower.",
                            "A bird takes off from a tree with a furious "+
                              "beating of wings."})}));
    break;
  case "autumn":
    add_item(({"floor", "ground", "earth"}), "The ground is littered "+
             "with dead leaves and the stems of dying ferns.");
    add_item("tree", "You are surrounded by trees, they are resplendent "+
             "with their autumn colours of red, gold and brown.");
    add_item("shrub", "Dotted here and there among the ferns "+
             "are small shrubs many with brightly coloured berries.");
    add_item(({"berry", "berries"}),
               ({"long", "There are a variety of berries hanging from the "+
                   "shrubs here.",
                 "get", ({this_object(), "do_get_berry"}),
                 "pick", ({this_object(), "do_get_berry"})}));
    add_item(({"leaf", "leaves"}),
             ({"long", "The ground is littered with dead leaves.",
               "get", ({this_object(), "do_get_leaf"})}));
    add_item("fern", "Here and there are the stems of ferns which have "+
             "died back and will survive the coming winter underground.");
    room_chat(({120, 240, ({"The wind stirs the leaves of the trees causing "+
                              "some to fall gently to earth.",
                            "A squirrel rushes up a nearby tree trunk.",
                            "A bird takes off from a tree with a furious "+
                              "beating of wings."})}));
    add_extra_look(this_object());
    break;
  case "winter":
    add_item(({"floor", "ground", "earth"}), "The ground is bare earth "+
             "apart from the occasional hardy shrub.");
    add_item("shrub", "Dotted here and there among the trees are small "+
             "shrubs trying to survive the winter.");
    add_item("tree", "There are bare trees everywhere here waiting for the "+
             "coming of spring.");
    room_chat(({120, 240, ({"The wind stirs the dry branches of the trees "+
                              "causing them to rustle eerily.",
                            "Somewhere a small animal forages in the "+
                              "undergrowth for winter food."})}));
    break;
  }
  add_item("rock", ({ "long", "A nice rock looking thingy.",
                      "get",  ({ this_object(), "do_get_rock" }) }) );
  add_property("track type", "woodland");
  if(!do_setup) {
    this_object()->setup();
    this_object()->reset();
  }
}

string query_terrain_map_colour() { return "%^GREEN%^"; }

string extra_look() {
  string extra;

  extra = ::extra_look();
  switch((string)WEATHER->query_season()) {
  case "spring":
    return extra + "Spring flowers are everywhere you look.\n";
  case "autumn":
    return extra + "The ground is littered with fallen leaves.\n";
    break;
  default:
    return extra;
  }
}

mixed do_get_rock( string verb, object *dest ) {
  int rock_size;
  string rock_type;
  object rock;
  if ( query_property( "rock object" ) )
    return ( rock = clone_object( (string)query_property( "rock object" ) ) );
  if ( undefinedp( rock_size = (int)query_property( "rock size" ) ) )
    rock_size = 3;
  if ( !rock_size ) return 0;
  rock = clone_object( "/obj/mineral" );
  if ( undefinedp( rock_type = (string)query_property( "rock type" ) ) )
    rock_type = ({ "cinnabar", "coal", "rosy-quartz", "chalk", "flint",
                   "slate" })[ random( 6 ) ];
  rock->make_mineral( rock_type, 1 + random( rock_size ) );
  if ( !( rock->move( this_player() ) ) ) return 1;
  rock->dest_me();
  return 0;
}

mixed do_get_flower( string verb, object *dest ) {
  string flower_type;
  object flower;
  if ( query_property( "flower object" ) )
    return (flower = clone_object((string)query_property("flower object")));
  if ((int)query_property("noflowers"))
    return 0;
  flower = clone_object("/std/plant");
  
  if(undefinedp(flower_type = (string)query_property("flower type")))
    flower_type = ({"forgetmenot", "violet"})[ random(2) ];
  flower->set_plant(flower_type);
  flower->set_plant_type(flower_type);
  flower->set_plant_desc("A beautiful "+flower_type+" picked before its "+
                         "time.\n");
  flower->set_main_plural(flower_type + "s");
  
  if (!(flower->move(this_player()))) return 1;
  flower->dest_me();
  return 0;
}

mixed do_get_berry( string verb, object *dest ) {
  object berry;
  string berry_type;
  if ((int)query_property("noflowers"))
    return 0;
  
  berry_type = ({"blackberry", "raspberry", "blueberry", "strawberry",
                 "blackcurrant"})[random(5)];
  
   berry = clone_object( "/obj/food" );
  berry->set_name(berry_type);
  berry->set_short(berry_type);
  berry->set_long("This is a lovely, plump "+berry_type+" it looks good "+
                  "enough to eat.\n");
  berry->add_alias("berry");
  
  if (!(berry->move(this_player()))) return 1;
  berry->dest_me();
  return 0;
}

mixed do_get_leaf( string verb, object *dest ) {
  object leaf;
  string leaf_type;
  if ((int)query_property("noflowers"))
    return 0;
  
  leaf_type = ({"maple", "oak", "sycamore", "ash", "silver birch"})[random(5)];
  
  leaf = clone_object("/std/object");
  leaf->set_name("leaf");
  leaf->set_short(leaf_type+" leaf");
  leaf->set_long("This is a dead "+leaf_type+" leaf.  Its natural green "+
                 "has turned to shades of gold, red and brown.\n");
  leaf->add_adjective(leaf_type);
  if (!(leaf->move(this_player()))) return 1;
  leaf->dest_me();
  return 0;
}


// --- END [/mnt/home2/grok/lib/std/outsides/woodland.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/outsides/basic.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/outsides/basic.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628803   Available: 13576157
Inodes: Total: 5242880    Free: 4960135
1326 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/outsides/basic.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628803   Available: 13576157
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: basic.c,v 1.3 2002/03/26 01:07:07 pinkfish Exp $
 * $Log: basic.c,v $
 * Revision 1.3  2002/03/26 01:07:07  pinkfish
 * Make all of these rooms have the basic details for handling
 * terrain map rooms.
 *
 * Revision 1.2  2000/06/22 01:19:30  pinkfish
 * Make it use autodoc and fix up the inherit paths.
 *
 * Revision 1.1  1998/01/06 04:29:46  ceres
 * Initial revision
 * 
*/
#include <terrain_map.h>
#define CREATOR "Ceres"
/**
 * This is a really basic outside room. It has rocks and that's about all.
 * @author Ceres
 */
inherit TERRAIN_MAP_OUTSIDE_BASE;

mixed do_get_rock( string verb, object *dest ) {
  int rock_size;
  string rock_type;
  object rock;
  if ( query_property( "rock object" ) )
    return ( rock = clone_object( (string)query_property( "rock object" ) ) );
  if ( undefinedp( rock_size = (int)query_property( "rock size" ) ) )
    rock_size = 3;
  if ( !rock_size ) return 0;
  rock = clone_object( "/obj/mineral" );
  if ( undefinedp( rock_type = (string)query_property( "rock type" ) ) )
    rock_type = ({ "cinnabar", "coal", "rosy-quartz", "chalk", "flint",
                   "slate" })[ random( 6 ) ];
  rock->make_mineral( rock_type, 1 + random( rock_size ) );
  if ( !( rock->move( this_player() ) ) ) return 1;
  rock->dest_me();
  return 0;
}
// --- END [/mnt/home2/grok/lib/std/outsides/basic.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/book_dir.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/book_dir.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628802   Available: 13576156
Inodes: Total: 5242880    Free: 4960135
1307 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/book_dir.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628802   Available: 13576156
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * Make a book with all the files in a dir.
*
 * @author Pinkfish
 */

inherit "/std/book";

#include "nroff.h"

string language = 0;

/**
 * Sets the language of the book
 */
void set_book_language(string lang) {
   language = lang;
}
/**
 * Returns the language of the book
 */
string query_language() { return language; }

/**
 * Sets the directory to look for the book pages in.  It scans every
 * file in this dir to get the pages for the book.
 * This sets the default paper to /obj/misc/nroff_paper.c
 * @param dir the directory in which to search
 * @see /obj/misc/nroff_paper.c
 * @example
 * inherit "/std/book_dir";
 *
 * void setup() {
 *    ...
 *    set_book_dir("/save/books/dead/dead_page");
 *    ...
 * } /\* setup() *\/
 */
void set_book_dir(string dir) {
  int i, max;
  
  set_no_pages(10);
  // The line below should stop books loosing their pages - Gin
  set_ignore_saved_pages(1);
  
  max = 10;
  i = 1;
  set_default_page_object("/obj/misc/nroff_paper");
  set_open_page (0);
  
  while (file_size(dir+i) > 0) {
    set_open_page(i);
    set_read_mess("$$" + dir + i + "$$" , language, 0);
    i++;
    if (i >= max) {
      max += 10;
      set_no_pages(max);
    }
  }

  /* Reduce the number of pages down */
  set_no_pages(i-1);

  set_open_page(0);
} /* set_book_dir() */
// --- END [/mnt/home2/grok/lib/std/book_dir.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/creator/workroom.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/creator/workroom.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628802   Available: 13576156
Inodes: Total: 5242880    Free: 4960135
7725 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/creator/workroom.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628802   Available: 13576156
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <config.h>
inherit "/std/room/basic_room";

object button, bookcase, board;

void setup() {
  /* the short description is what you get in a room in brief mode.
   * use capital letters for proper names only and don't put a period
   * at the end, since the short can be used to construct sentences
   */
  set_short("workroom of "+ CREATOR);
  /* the determinate is put in front of the short.
   * if you don't specify it, "a " or "an " will be used automatically.
   * see help setup
   */
  add_property( "determinate", "the ");
  /* you set this so you can see in the room.
   * for a description of light levels and what they mean type
   * help light
   */
  set_light(100);
  /*
   * and when you work into a room in verbose mode.
   * remember to put two spaces after periods, and uses proper
   * capitalization, punctuation and spelling.
   */
  set_long("This is the workroom of "+CREATOR+".  You can see a small "
     "wooden desk sulking in the corner of the room, it has a "
     "beautifully carved wooden rolly chair in front of it.  It "
     "looks like this was just newly created, there is a smell "
     "of paint and leather in the air.\n");
  /* The items are the things in the room that you can look at.
   * Item longs should be proper sentences and shouldn't have \n at the
   * end.  Make sure you have a room item for every noun described in
   * the long of the room or in the long of another room item.
   */
  add_item("chair",
        ({ "long", "The teak rolly chair has amazing carvings of dragons "
                   "and ... other things on it.  They almost seem alive, "
                   "you especially don't note the way the dragon "
                   "blinks at you.",
                   "position",
                   "the teak rolly chair" }) );
  add_item("desk", "The desk is made of mahogany with a touch of "
     "mountain ash.  The top has two little basket things "
     "on it labelled \"in\" and \"out\".  The in basket "
     "is rather small." );
  add_item( "dragon", "I told you, you don't notice it winking at you." );
  add_item("in basket", "The in basket is full of small yellow forms "
     "with large red letters on them saying "
     "\"Important read me first\" and then not "
     "appearing to actually have any thing else on "
     "them." );
  add_item( "out basket", "The out basket is completely empty." );
  add_item("basket", "There are two baskets sitting on top of the desk.  "
     "They have the words \"in\" and \"out\" written "
     "on them." );
  add_item("paint", "You look around to see the source of the paint "
     "smell and you can't find it.  The walls? of the room "
     "ummm seem to be well shall we just twisting in a "
     "confused mish mash of shapes, you are sure they are "
     "not threatening." );
  add_item("wall", "The walls are made up of a cloudy substance, white "
     "in nature that is roiling around the place where "
     "you are standing.  Great magic must be holding it "
     "back, every now and then you see a demonic head "
     "push its way out of the cloud roll its eyes and fade "
     "back into the cloud." );
  add_item("cloud", "The cloud is white coloured with a few flashes "
     "of light bursting in it." );
  add_item("demon", "The demonic heads that pop out are pretty nasty "
     "looking, they disapear with a snarl of strain." );

  /* adds all the exits to the room.
   * the first parameter is the verb used to get through the exit.
   * the second is where to go once that exit is opened.
   * and the third is the type of the exit.  For a better desription of
   * this read the docs on rooms.
   *
   * remember not to put ".c" at the end of the second parameter
   */
  add_exit("common", "/w/common", "door");
  add_exit("drum", CONFIG_START_LOCATION, "path");
  add_exit("learning", "/d/learning/main", "path");

  /*
   * modify_exit() is used to change how exits operate.  We are going to
   * make it so that only players can move through an exit.  This is
   * so that any NPCs you might have in your workroom can't accidently
   * escape out.
   */

  modify_exit( ({ "common", "drum", "learning" }),
      ({ "function", "check_player" }) );

  /* these two add_alias alias the exits.  Now when you type north (or n)
   * you will go to the mended drum and south to the common room
   */
  add_alias("north", "drum");
  add_alias("south", "common");
  /* this adds an exit in the common room back to your workroom
   * this is not needed for normal exits, but the commonroom doesn't have
   *exits back.
   */
  "/w/common"->add_exit(CREATOR, "/w/"+CREATOR+"/workroom", "door");
} /* create() */

void reset() {
  /* if the button does not exist (it has been dested or it hasn't been
   * created yet the variable is set to 0)  This makes sure you don't get
   * more than one button in your room.
   */
  if (!button) {
    button = clone_object("/obj/misc/button");
    button->move(this_object());
  }
  if (!board) {
    board = clone_object("/obj/misc/board_mas");
    board->move(this_object() );
  }
  if (!bookcase) {
    /* The first parts of making a shelf it covered elsewhere, it's
     * basically a matter of cloning the object and make it look like
     * it should
     */
    bookcase = clone_object("/obj/cont_save");
    bookcase->set_name( "bookcase" );
    bookcase->set_short( "oaken bookcase" );
    bookcase->add_adjective( "wooden" );
    bookcase->add_adjective( "oak" );
    bookcase->add_adjective( "oaken" );
    bookcase->add_property( "there", "standing against the wall" );
    bookcase->set_long( "This bookcase is made from oak and "
      "varnished to bring out the glow.  It has 2 "
      "shelves, upon which you can see some books, and "
      "other objects.\n" );
    bookcase->set_weight( 2000 );
    bookcase->set_max_weight( 4000 );
    bookcase->reset_get();
    /* This call will allow the shelf to write the  savefile in the same
     * domain as the room is in, if you don't do this call, the savefile
     * will have to be somewhere in /save/
     */
    bookcase->check_euid();
    /* This call tells the shelf what file should be used to save the stuff
     * placed on it.
     */
    bookcase->set_save_file( "/w/"+CREATOR+"/creator_kit" );
    /* end by putting the shelf in the room */
    bookcase->move( this_object() );
  }
} /* reset() */


/* This function is used by the button.  It gives a list of things in
 * the room that the button should NOT destroy.
 */
object *query_non_destable()  {
  return ({ bookcase, board });
} /* query_non_destable() */

/* This function is used by modify_exit() to make sure only players can
 * move through the exits in your workroom.
 *
 * WARNING: You cannot under any circumstances use the this_player()
 * function in an exit function.  Doing this will cause your exit
 * function to fail horribly when people are following the person
 * moving through the exit.
 *
 * Because of this, the 'player' variable is passed to the exit
 * function. See help exit_function to see how to write your own exit
 * functions.
 */
int check_player( string verb, object player, string special ) {

    /* We need to check if the person going through the exit is a player.
     * There are several different ways we can do this.  The easiest
     * way is with the interactive() function, which returns 1 if an
     * object is a link-connected player to the MUD or 0 if they are not.
     */
    if ( interactive( player ) ) {
        return 1;
    }

    /* The notify_fail() here sets it so that an invalid target
     * doesn't get a 'What?' message when attempting to go through this
     * exit.
     */
    notify_fail( "" );
    return 0;
} /* check_player() */

// --- END [/mnt/home2/grok/lib/std/creator/workroom.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/object.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/object.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628800   Available: 13576154
Inodes: Total: 5242880    Free: 4960135
14526 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/object.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628800   Available: 13576154
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * The basic object.  This pulls together all the bits needed to create
 * a basic object.
 *
 * @author Pinkfish
 * @change many any many times
 * @see /std/room.c
 */
#include <cmr.h>

inherit "/std/basic/extra_look";
inherit "/std/basic/enchant";
inherit "/std/basic/id";
inherit "/std/basic/misc";
inherit "/std/basic/property";
inherit "/std/basic/read_desc";
inherit "/std/basic/auto_load";
inherit "/std/basic/help_files";
inherit "/std/basic/theft_callback";
inherit "/std/basic/effects";

#define AUTO_LOAD_TAG "basic.object";

nosave int do_setup;
nosave string create_me;
nosave string colour;
private string* _materials;
nosave object player;

void create() {
  _materials = ({ });
  extra_look::create();
  id::create();
  misc::create();
  property::create();
  read_desc::create();
  effects::create();

  seteuid( (string)"/secure/master"->
      creator_file( file_name( this_object() ) ) );
  if ( this_player() ) {
    create_me = (string)this_player()->query_name();
  } else {
    create_me = "who knows";
  }
  if ( !do_setup ) {
    this_object()->setup();
  }
} /* create() */

/**
 * Gives the object a name.  Sets the name to the word and makes it the
 * short description  and attempts to create the pural short description
 * from it.
 * @param name the name to use
 */
void set_name( string word ) {
  if ( query_name() && ( query_name() != "object" ) ) {
    ::set_name(word);
    return;
  }
  ::set_name(word);
  if ( !short_d ) {
    short_d = word;
  }
  add_plural( pluralize( word ) );
} /* set_name() */

/** @ignore yes */
string query_long_details(string arg, int dark, object looker) {
   string stuff;
 
   stuff = "";
   if ( this_player()->query_see_octarine() ) {
      stuff += enchant_string();
   }
   if ( sizeof( query_read_mess() ) ) {
      stuff += "It appears to have something written on it.\n";
   }
   return stuff;
} /* query_long_details() */

/**
 * This method replaces any colours of materials in the given string
 * with the appropriate ccolours or materials for this object.
 * @param player the player attempting to check the colour/material.
 * @param text the text to replace
 * @return a new string with the dollar identities expanded.
 */ 
string replace_long_dollars(object player, string text) { 
   if ( colour ) {
      text = replace( text, "$colour$",
          (string)CMR_HANDLER->identify_colour( colour, player ) );
   }
   if ( sizeof(_materials) ) {
      text = replace( text, "$material$",
          (string)CMR_HANDLER->identify_material( _materials[0], player, 1 ) );
   }

   return text;
} /* replace_long_dollars() */ 

/**
 * The description of an object when someone looks at it.  This handles
 * the extra code for messages, colour and material.
 * @param word the word it was matched on
 * @param dark is it dark from the player's perspecitive
 * @return the long description
 */
string long( string word, int dark ) {
   string stuff;

   stuff = ::long( word, dark );
   stuff += calc_extra_look();
   stuff += query_long_details(word, dark, this_player());
   stuff = replace_long_dollars( this_player(), stuff ); 

   return stuff;
} /* long() */

/**
 * The colour of the object.
 * @return the colour of the objecy
 */
string query_colour() { return colour; }
/**
 * Sets the colour of the object.
 * @param word the colour to make the object
 */
void set_colour( string word ) { colour = word; }

/**
 * The material of the object.
 * @return the name of the material
 */
string query_material() {
   if (sizeof(_materials)) {
      return _materials[0];
   }
   return 0;
}

/**
 * This returns all of the materials of the object.
 * @return all the materials
 */
string* query_materials() {
    string *new_materials;
    
    // We need this for the moment, because a silly mistake was made
    // which was storing lots of arrays in arrays instead of just
    // an array of strings. 

    new_materials = ({ });

     if(!_materials) _materials=({ });
    foreach( mixed bit in _materials ) { 
        if ( stringp( bit ) ) {
            new_materials += ({ bit });
        }
        else {
            if ( arrayp( bit ) ) {
                foreach( mixed inner_bit in bit ) {
                    if( stringp( inner_bit ) ) {
                        new_materials += ({ inner_bit });
                    }
                }
            }
        }
    }

   return new_materials;
} /* query_materials() */
/**
 * Sets the material of the object, this adds this material to the
 * front of the material list.
 * @param word the material to set it to
 */
void set_material( mixed word ) {
   if (!arrayp(word)) {
      word = ({ word });
   }     
   // NB: It is _already_ an array so we don't need to put it in
   // brackets!  This puts an array in an array ...eek.

   if (sizeof (word)) {
      _materials = word + _materials;
      add_adjective(word);
   }
}

/**
 * This method adds a material to the list of current materials.
 * @param material the material to add
 */
void add_material(mixed material) {
   if (pointerp(material)) {
      _materials |= material;
   } else if (stringp(material)) {
      _materials += ({ material });
   }
   add_adjective(material);
} /* add_material() */

/**
 * The pronoun of the object.
 * @return always returns "it"
 */
string query_pronoun() { return "it"; }
/**
 * The possessive of the object.
 * @return always returns "its"
 */
string query_possessive() { return "its"; }
/**
 * The objective of the object.
 * @return always returns "it"
 */
string query_objective() { return "it"; }

/**
 * Who cloned the object.  Used for security reasoin to trace who have
 * been cloning up objects for players.
 * @return the person who cloned the object
 */
string query_cloned_by() { return create_me; }

/**
 * This method sets the quality of the object.  All objects are by
 * default 'normal' quality.
 * @param quality the quality of the object
 */
void set_quality(int quality) {
   add_property("quality", quality);
} /* set_qualist() */

/**
 * This method returns the quality of the object.  The quality is used
 * in the crafts system, amongst other things.
 */
int query_quality() {
   return query_property("quality");
} /* query_quality() */

/**
 * @ignore yes
 */
mixed *stats() {
  if(!_materials) _materials=({ });
  return ({
    ({ "name" , query_name(), }),
    ({ "short", short( 0 ), }),
    ({ "plural", query_plural(0), }),
    ({ "weight", (int)this_object()->query_weight(), }),
    ({ "enchantment", query_enchant(), }),
    ({ "colour", colour, }),
    ({ "material", query_multiple_short(_materials), }),
    ({ "cloned by", create_me, }),
    ({ "length", (int)this_object()->query_length(), }),
    ({ "width", (int)this_object()->query_width(), }),
   }) + property::stats() + misc::stats() + effects::stats();
} /* stats() */

/** 
 * @ignore yes
 */
mapping int_query_static_auto_load() {
  return ([
    "name" : query_name(),
    "short" : short_d,
    "main plural" : plural_d,
    "long" : long_d,
    "alias" : query_alias(1),   // not faux ones
    "adjective" : query_adjectives(1),   // not faux ones
    "plural adjective" : query_plural_adjectives(),
    "plural" : query_plurals(),
    "value" : value,
    "value info" : value_info + ([ ]),
    "weight" : weight,
    "colour" : colour,
    "length" : length,
    "width" : width,
  ]);
} /* int_query_static_auto_load() */

/** 
 * @ignore yes
 */
mapping query_static_auto_load() {
  if ( !query_name() || ( query_name() == "object" ) ) {
    return 0;
  }
  if ( explode( file_name( this_object() ), "#" )[ 0 ] != "/std/object" ) {
    return ([ ]);
  }
  return int_query_static_auto_load();
} /* query_static_auto_load() */

/** 
 * @ignore yes
 */
mapping query_dynamic_auto_load() {
   mapping map;

   if ( !query_name() || ( query_name() == "object" ) ) {
      return 0;
   }

   if ( query_enchant() > this_object()->query_max_enchant() ) {
      set_enchant(this_object()->query_max_enchant());
   }

   map = ([
      "read mess" : ::query_read_mess(),
      "degrade enchantment" : query_degrade_enchant(),
      "enchantment" : query_real_enchant(),
      "enchantment time" : query_enchant_set_time(),
      "light" : query_my_light(),
      "materials" : query_materials(),
      "cloned by" : create_me,
   ]);

   if ( map_prop ) {
      map[ "properties" ] = copy( map_prop );
   }

   if ( timed_properties ) {
      save_player_properties();
      map[ "timed properties" ] = copy(timed_properties);
   }

   if ( sizeof(query_effs() ) ) {
     effect_freeze();
     effects_saving();
     map += ([
              "effects" : ({
                (mixed *)query_effs(),
                  (int *)query_eeq()
                  })
              ]);
     effect_unfreeze();
   }
   
   if ( this_object()->query_special() ) {
      map[ "special" ] =  (mapping)this_object()->query_special_info();
   }

   if ( query_deity() ) {
     map[ "consecrated" ] = query_deity();
   }

   return map;
} /* query_dynamic_auto_load() */

/** 
 * @ignore yes
 */
void init_static_arg( mapping map ) {

   if ( !mapp( map ) ) {
      return;
   }
   if ( !undefinedp( map[ "name" ] ) ) {
      set_name(map[ "name" ]);
   }
   if ( !undefinedp( map[ "short" ] ) ) {
      set_short( map[ "short" ] );
   }
   if ( !undefinedp( map[ "main plural" ] ) ) {
      set_main_plural( map[ "main plural" ] );
   }
   if ( !undefinedp( map[ "long" ] ) ) {
      set_long( map[ "long" ] );
   }
   if ( map[ "alias" ] ) {
      set_aliases( map[ "alias" ] );
   }
   if ( map[ "adjective" ] ) {
      set_adjectives( map[ "adjective" ] );
   }
   if ( map[ "plural adjective" ] ) {
      set_plural_adjectives( map[ "plural adjective" ] );
   }
   if ( map[ "plural" ] ) {
      set_plurals( map[ "plural" ] );
   }
   if ( !undefinedp( map[ "value" ] ) ) {
      set_value( map[ "value" ] );
   }
   if ( !undefinedp( map[ "value info" ] ) ) {
      value_info = map[ "value info" ];
   }
   if ( !undefinedp( map[ "weight" ] ) ) {
      set_weight( map[ "weight" ] );
   }
   if ( !undefinedp( map[ "colour" ] ) ) {
      set_colour( map[ "colour" ] );
   }
   if ( !undefinedp( map[ "material" ] ) ) {
      set_material( map[ "material" ] );
   }                             
   if ( !undefinedp( map[ "length" ] ) ) {
      set_length( map[ "length" ] );
   }                             
   if ( !undefinedp( map[ "width" ] ) ) {
      set_width( map[ "width" ] );
   }                             
   
} /* init_static_arg() */

/**
 * Sets the player associated with the object.  This is used during the
 * autoload sequence.
 *
 * @param thing the player object we belong to
 * @see /global/auto_load.c
 */
void set_player( object thing ) { player = thing; }

/** 
 * @ignore yes
 */
void init_dynamic_arg( mapping map, object ) {
   int recycle;

   if ( !mapp( map ) )
      return;
   /*
    * Because recycling is needs to be preserved into new objects from
    * olds ones (generally speaking).
    */
   recycle = query_property("no recycling");
   if ( map[ "properties" ] )
      map_prop = map[ "properties" ];
   if (recycle)
      add_property("no recycling", recycle);
   if ( map[ "timed properties" ] ) {
      timed_properties = map[ "timed properties" ];
      reload_player_properties();
   }
   if ( sizeof( map[ "read mess" ] ) )
      set_read_mess( map[ "read mess" ] );
   if ( !undefinedp( map[ "materials" ] ) ) {
      _materials = map["materials"];
   }                             
   set_enchant(map["enchantment"]);
   set_degrade_enchant(map["degrade enchantment"]);
   if (map["enchantment time"]) {
      set_enchant_set_time(map["enchantment time"]);
   }
   set_light( map[ "light" ] );
   create_me = map[ "cloned by" ];
   if( map[ "effects" ] ) {
     set_effs( map[ "effects" ][ 0 ] );
     set_eeq( map[ "effects" ][ 1 ] );
     if ( environment() && shadow( this_object(), 0 ) )
       move_object( environment() );
   }
   init_after_save();

   if ( map[ "special" ] ) {
      clone_object( "/std/shadows/object/special_item" )->
            setup_shadow( this_object(), player );
      this_object()->set_special_info( map[ "special" ] );
   }
   if ( map[ "consecrated" ] ) {
     set_deity( map[ "consecrated" ] );
   }
} /* init_dynamic_arg() */

/** @ignore yes */
string query_readable_message(object player, int ignore_labels) {
   string ret;
   string bing;
   object *labels;
   object ob;
   int *enums;
   object store;

   ret = ::query_readable_message(player);
   if (!ignore_labels) {
      enums = (int *)this_object()->effects_matching( "object.label" );
      if ( !sizeof( enums ) ) {
         labels = ({ });
      } else {
         store = (object)this_object()->arg_of( enums[ 0 ] )[ 0 ];
         if ( !objectp( store ) ) {
            labels = ({ });
         } else {
            labels = (object *)store->find_inv_match( "" );
         }
      }
      if (sizeof(labels) && !ret) {
         ret = "";
      }
      foreach (ob in labels) {
         ret += "On " + ob->the_short() + " is written:\n";
         bing = ob->query_readable_message(player, 0);
         if (bing) {
            ret += bing;
         } else {
            ret += "Nothing.\n";
         }
      }
   }
   return ret;
} /* query_readable_message() */

/** @ignore yes */
string query_read_short(object player, int ignore_labels) {
   string ret;
   object *labels;
   int *enums;
   object store;

   ret = ::query_read_short(player);
   if (!ignore_labels) {
      enums = (int *)this_object()->effects_matching( "object.label" );
      if ( !sizeof( enums ) ) {
         labels = ({ });
      } else {
         store = (object)this_object()->arg_of( enums[ 0 ] );
         if ( !objectp( store ) ) {
            labels = ({ });
         } else {
            labels = (object *)store->find_inv_match( "" );
         }
      }
      if (sizeof(labels)) {
         if (ret) {
            ret += " and " + query_multiple_short(labels, "the") +
                   " stuck on $name$";
         } else {
            ret = query_multiple_short(labels, "the") +
                   " stuck on $name$";
         }
      }
   }
   return ret;
} /* query_read_short() */

/** @ignore yes */
string query_help_file_directory() {
   return "/doc/object/";
} /* query_help_file_directory() */

int clean_up(int inherited) {
  if(inherited) {
    log_file("CLEANUP", "%s %s cleaned up.\n", ctime(time()),
             file_name(this_object()));
    move("/room/rubbish");
  }
  return 1;
}

void dest_me() {
  effects_desting();
  ::dest_me();
}
// --- END [/mnt/home2/grok/lib/std/object.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/held.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/held.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628796   Available: 13576150
Inodes: Total: 5242880    Free: 4960135
541 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/held.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628796   Available: 13576150
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* inherit this file anything that wants to be holdable */
inherit "/std/object";

nosave object holder;

int query_holdable() { return 1; }

int set_holder(object ob) {
  holder = ob;
  return 1;
}

object query_holder() { return holder; }

int drop(mixed dest) {
  holder = 0;
  return ::drop(dest);
}

/** @ignore yes */
/** @ignore yes */
varargs int move( mixed dest, string arrive, string leave ) {
  if (holder && dest != holder) {
      holder->unhold_ob(this_object());
      holder = 0;
  }
  return ::move(dest, arrive, leave);
}
// --- END [/mnt/home2/grok/lib/std/held.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/horse.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/horse.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628796   Available: 13576150
Inodes: Total: 5242880    Free: 4960135
3207 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/horse.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628796   Available: 13576150
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* Horse race object. */

inherit "/std/races/base";

void setup() {
   set_name( "horse" );
   set_long( "A large hoofed mammal.  Surprise.\n" );
   set_height( 200 );
   set_weight( 7000 );
   
   /* throw away the human bits and replace totally */
   bits= ({
      "head", "head", ({ 0, 120, 0,
         "left eye", "right eye", "skull", "brain", "left ear",
         "right ear", "tongue" }),
      "left eye", "eye", ({ "head", 2, 0 }),
      "right eye", "eye", ({ "head", 2, 0 }),
      "skull", "cranium", ({ "head", 45, 0, "teeth" }),
      "brain", "brain", ({ "head", 20, 0 }),
      "left ear", "ear", ({"head", 4, 0 }),
      "right ear", "ear", ({"head", 4, 0 }),
      "teeth", "teeth", ({ "skull", 5, ({"/std/bit_set", 1}) }),
      "tooth", "tooth", ({ "teeth", 1, ({"/std/bit", 18}) }),
      "tongue", "tongue", ({ "head", 9, 0 }),
      "neck", "neck", ({ 0, 120, 0 }),
      "torso", "body", ({ 0, 400, 0,
         "heart", "liver", "left kidney", "right kidney", "left lung",
         "right lung", "spleen", "intestine", "pancreas" }),
      "heart", "heart", ({ "torso", 35, 0 }),
      "liver", "liver", ({ "torso", 35, 0 }),
      "left kidney", "kidney", ({ "torso", 20, 0 }),
      "right kidney", "kidney", ({ "torso", 20, 0 }),
      "left lung", "lung", ({ "torso", 35, 0 }),
      "right lung", "lung", ({ "torso", 35, 0 }),
      "spleen", "spleen", ({ "torso", 20, 0 }),
      "intestine", "gut", ({ "torso", 75, 0 }),
      "pancreas", "pancreas", ({ "torso", 20, 0 }),
      "left front leg", "leg", ({ 0, 140, 0, "left front hoof" }),
      "left front hoof", "hoof", ({ "left front leg", 20, 0 }),
      "right front leg", "leg", ({ 0, 140, 0, "right front hoof" }),
      "right front hoof", "hoof", ({ "right front leg", 20, 0 }),
      "left rear leg", "leg", ({ 0, 160, 0, "left rear hoof" }),
      "left rear hoof", "hoof", ({ "left rear leg", 20, 0 }),
      "right rear leg", "leg", ({ 0, 160, 0, "right rear hoof" }),
      "right rear hoof", "hoof", ({ "right rear leg", 20, 0 }),
      "tail", "tail", ({ 0, 15, 0 }),
      "skin", "skin", ({ 0, 175, 0 })
   });
   
   inedible = ({ "skull", "left front hoof", "right front hoof",
      "left rear hoof", "right rear hoof", "tail", "teeth", "tooth" });
   unrottable = ({ "skull", "left front hoof", "right front hoof",
      "left rear hoof", "right rear hoof", "teeth", "tooth" });

   set_desc( "a large, hairy quadruped.  It looks like a horse" );

   add_ac( "blunt", "blunt", 50 );
   add_ac( "sharp", "sharp", 20 );
   add_ac( "pierce", "pierce", 20 );
   set_skin( "skin" );

   set_stats( ({ 4, 4, -2, 6, -2 }) );
} /* setup() */

void set_unarmed_attacks( object thing ) {
   int number;

   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = sqrt( number );

   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );

   thing->remove_attack( "chew" );
   thing->remove_attack( "hoof" );

   thing->add_attack( "chew", 50, ({ number, 2, number }),
      "sharp", "unarmed", 0 );
   thing->add_attack( "hoof", 70, ({ number / 2, 5, number }),
      "blunt", "unarmed", 0 );
   
   thing->tactics( "response dodge" );
} /* set_unarmed_attacks() */
// --- END [/mnt/home2/grok/lib/std/races/horse.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/human.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/human.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628795   Available: 13576149
Inodes: Total: 5242880    Free: 4960135
4623 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/human.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628795   Available: 13576149
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: human.c,v 1.8 2003/02/27 00:20:00 ceres Exp $
 * $Log: human.c,v $
 * Revision 1.8  2003/02/27 00:20:00  ceres
 * Fixed damage for unarmed somewhat.
 *
 * Revision 1.7  2002/08/21 22:23:15  ceres
 * 20 used to be dark, not light. Changed the threshold to 25 (I believe it used to be 30).
 *
 * Revision 1.6  2000/06/22 22:03:18  ceres
 * Altered heatstroke to affect wis & int
 *
 * Revision 1.5  2000/05/22 20:33:00  ceres
 * can't remember
 *
 * Revision 1.4  2000/04/09 19:40:33  ceres
 * Uncommented the death from hypothermia/heatstroke
 *
 * Revision 1.3  2000/03/01 06:37:51  ceres
 * Attack fixes
 *
 * Revision 1.2  1998/03/30 03:17:47  ceres
 * Modified ACs for skin following the armour mods.
 *
 * Revision 1.1  1998/01/06 04:30:16  ceres
 * Initial revision
 * 
*/
inherit "/std/races/humanoid";

void setup() {
   set_long("The human race.  The standard by which all the races are set, "+
           "this is race can be considered the norm.\n");
   set_name("human");
   set_weight(1600);
   set_height(175);
   add_ac( "blunt", "blunt", 3 );
   add_ac( "pierce", "pierce", 2 );
   add_ac( "sharp", "sharp", 2 );
   set_sight( ({ 5, 25, 200, 300 }) );
}

string query_desc( object thing ) {
  if ( (int)thing->query_gender() == 1 )
    return "He is a strapping young human lad.\n";
  if ( (int)thing->query_gender() == 2 )
    return "She is a strapping young human lass.\n";
  return "It is a strapping young human.\n";
} /* query_desc() */

void set_unarmed_attacks( object thing ) {
   int number;
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = 4 + sqrt( number );
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->add_attack( "hands", 75, ({ 2 * number, 5, number }), "blunt",
         "unarmed", "unarmed_hands" );
   thing->add_attack( "feet", 25, ({ 3 * number, 7, number }), "blunt",
         "unarmed", 0 );
} /* set_unarmed_attacks() */

string temperature_effects(object thing, int temperature) {
  string temperature_str;

  switch(temperature/3) {
  case 101 .. 1000:
    thing->dest_hide_shadow();
    tell_object( thing, "The heat is just too much for you.\n" );
    tell_room( environment( thing ), "Sweating profusely and turning "
               "a nasty red-purple colour "+
               (string)thing->the_short() +" expires.\n", thing );
    thing->do_death();
    temperature_str = "";
    break;
  case 81 .. 100:
    temperature_str = "close to death from extreme heatstroke";
    thing->adjust_tmp_wis(-1);
    thing->adjust_tmp_int(-1);
    break;
  case 51 .. 80:
    temperature_str = "sick from heatstroke";
    if(!random(2))
      thing->adjust_tmp_wis(-1);
    if(!random(2))
      thing->adjust_tmp_int(-1);
    break;
  case 21 .. 50:
    temperature_str = "very hot";
    tell_object(thing, "You feel really hot.\n");
    break;
  case 11 .. 20:
    temperature_str = "rather warm";
    tell_object(thing, "You feel quite warm.\n");
    break;
  case -10 .. 10:
    temperature_str = "";
    break;
  case -20 .. -11 :
    temperature_str = "rather cold";
    tell_object(thing, "You feel quite cold.\n");
    break;
  case -50 .. -21 :
    temperature_str = "very cold";
    tell_object(thing, "You feel cold to your bones.\n");
    break;
  case -80 .. -51 :
    temperature_str = "sick from hypothermia";
    tell_object(thing, "You're so cold you feel your energy being drained.\n");
    if(!random(2))
      thing->adjust_tmp_str(-1);
    if(!random(2))
      thing->adjust_tmp_con(-1);
    break;
  case -100 .. -81 :
    temperature_str = "close to death from extreme hypothermia";
    tell_object(thing, "You're so cold you feel as though you're about to "
                "expire.\n");
    thing->adjust_tmp_str(-1);
    thing->adjust_tmp_con(-1);
    break;
  case -1000 .. -101:
    thing->dest_hide_shadow();
    tell_object( thing, "The cold is just too much for you.\n" );
    tell_room( environment( thing ), "Frost riming "+
               (string)thing->query_possessive() +" skin in a thick crust, "+
               (string)thing->the_short() +" expires.\n", thing );
    thing->do_death();
    temperature_str = "";
    break;
  }

  if(temperature /5 >  10) {
    thing->new_parser("sweat");
    thing->add_effect("/std/effects/other/wetness",
                      temperature);
  } else if(temperature/5 < -10) {
    thing->new_parser("shiver");

    if(temperature < -30 && !random(250))
      thing->add_effect( "/std/effects/disease/common_cold",
                         -(temperature*10));
  }

  return temperature_str;
}
// --- END [/mnt/home2/grok/lib/std/races/human.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/amphibian.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/amphibian.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628794   Available: 13576148
Inodes: Total: 5242880    Free: 4960135
1319 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/amphibian.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628794   Available: 13576148
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/races/base";

void create() {
   do_setup++;
   ::create();
   do_setup--;

   set_desc( "your standard amphibian" );
   set_height( 40 );
   set_weight( 600 );

   bits = ({ 
      "head", "head", ({ 0, 40, 0,
         "skull", "left eye", "right eye" }),
      "skull", "skull", ({ "head", 15, 0, "brain" }),
      "left eye", "eye", ({ "head", 1, 0 }),
      "right eye", "eye", ({ "head", 1, 0 }),
      "brain", "brain", ({ "skull", 5, 0 }),
      "torso", "guts", ({ 0, 400, 0,
         "heart", "liver", "left kidney", "right kidney", "spleen" }),
      "heart", "heart", ({ "guts", 10, 0 }),
      "liver", "liver", ({ "guts", 5, 0 }),
      "left kidney", "kidney", ({ "guts", 5, 0 }),
      "right kidney", "kidney", ({ "guts", 5, 0 }),
      "spleen", "spleen", ({ "guts", 5, 0 }),
      "genitals", "genitals", ({ 0, 5, 0 }),
      "right front leg", "leg", ({ 0, 200, 0 }),
      "left front leg", "leg", ({ 0, 200, 0 }),
      "right back leg", "leg", ({ 0, 200, 0 }),
      "left back leg", "leg", ({ 0, 200, 0 }),
      "skin", "skin", ({ 0, 175, 0 })
   });

   inedible = ({ "skull" });
   unrottable = ({ "skull" });
   set_skin( "skin" );

   set_stats( ({ -4, 10, -4, -4, -6 }) );

   if( !do_setup )
      this_object()->setup();
} /* create() */

int lives_in_water() { return 1; }
// --- END [/mnt/home2/grok/lib/std/races/amphibian.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/base.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/base.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628793   Available: 13576147
Inodes: Total: 5242880    Free: 4960135
18944 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/base.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628793   Available: 13576147
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * The base object which all races will be inherited from.
 * @author Pinkfish
 * @started 1992 sometime
 */

#define QUEST_AVE 140
#define QUEST_MAX 570
#define BASE 50
#define SCALE 10
#define NORM 15
#define EXPERT 20
#define A_TYPES ([ \
      "claws" : "sharp", \
      "chew" : "sharp", \
      "beak" : "pierce", \
      "bite" : "pierce", \
      "horn" : "pierce", \
      "hands" : "blunt", \
      "feet" : "blunt", \
      "tail" : "blunt", \
      "hoof" : "blunt", \
      "wrestle" : "blunt", \
   ])

inherit "/std/object";

/* Original by who knows.
 * Modifications by Piecemaker, Ember, Presto, Deutha and Dragonkin.
 */

private int height;
private int *sight;
private int *stats;
private string desc;
private string skin;
string *inedible;
string *unrottable;
string *pluckable;
private string *limbs;
private mixed *acs;
private mixed *attacks;
private mapping _fixed_bits;
mixed *bits;

/* The acs array has element blocks:
 *
 *   name, type, amount
 *
 * The attacks array has element blocks:
 *
 *   name, chance, data relative to bonus of 200
 *
 * The bits array has element blocks:
 *
 *   short, name, ({ parent, percentage weight, ({ file name (0 is "/std/bit"),
 *         amount }), child bit 1, child bit 2, ... })
 *
 *   Note that if the size of ({ file name, amount }) part is less than two,
 *   it'll set the filename to default and the amount to 1
 */

void create() {
   do_setup++;
   ::create();
   do_setup--;

   sight = ({ 5, 20, 200, 300 });
   stats = allocate( 5 );
   desc = "a small non-descript thing";
   inedible = ({  });
   unrottable = ({  });
   pluckable = ({  });
   acs = ({ });
   attacks = ({ });
   bits = ({ });

   if ( !do_setup )
      this_object()->setup();
} /* create() */

/**
 * This method returns the base height of the npc type.
 * @return the current base height
 * @see set_height()
 */
int query_height() { return height; }

/**
 * This method sets the base height of the npc type.
 * @param number the new height
 * @see query_height()
 */
void set_height( int number ) { height = number; }

/**
 * Thie method returns the values of the race which determine visibility.
 * It returns an array of the format:<br>
 * <pre>({
 *    dark
 *    pitch dark,
 *    bright light,
 *    bright
 * })</pre>
 * @return the sight array as detailed above
 * @see set_sight()
 * @see query_dark()
 */
int *query_sight() { return copy(sight); }

/**
 * Thie method sets the current sight array for the npc.  This sets the
 * levels at which the race things things are too dark/too bright.<br>
 * <pre>({
 *    pitch dark,
 *    dark,
 *    bright,
 *    bright light
 * })</pre>
 * @param numbers as detailed above
 * @see query_sight()
 * @see query_dark()
 */
void set_sight( int *numbers ) { sight = numbers; }

/**
 * Determines if the race thinks it is dark or light.
 * @return 0 for normal, -1 for dark, -2 for pitch dark, 1 for bright,
 * 2 for toobright
 * @see set_sight()
 * @see query_sight()
 */
int query_dark( int light ) {
   if ( light < sight[ 0 ] ) {
      return -2;
   }
   if ( light < sight[ 1 ] ) {
      return -1;
   }
   if ( light > sight[ 3 ] ) {
      return 2;
   }
   if ( light > sight[ 2 ] ) {
      return 1;
   }
   return 0;
} /* query_dark() */

/**
 * This method queries the default bonus stat values for the race.<br>
 * <pre>({
 *   con,
 *   dex,
 *   int,
 *   str,
 *   wiz
 * })</pre>
 * @return the current stat offsets
 * @see set_stats()
 */
int *query_stats() { return copy(stats); }

/**
 * This method sets the current default bonuses of the stats.  The parameter
 * is an array of numbers, with the numbers corresponding to the stats as
 * shown below.  It is highly inadvisable to set any stat bonus to less than
 * -6, since in conjunction with the guild stat settings this could combine
 * to give a negative total for that stat.  Negative stats can cause
 * permanent unconsciousness.
 * <pre>({
 *   con,
 *   dex,
 *   int,
 *   str,
 *   wis
 * })</pre>
 * @param numbers sets the default bonuses for the stats
 * @see query_stats()
 */
void set_stats( int *numbers ) { stats = numbers; }

/**
 * This method returns the current skin of the race.
 * @return the current skin of the race
 * @see set_skin()
 */
string query_skin() { return skin; }

/**
 * This method sets the skin of the race.  This is what is given back
 * when the npc's corpse is skinned.
 * @param word the skin of the race
 * @see query_skin()
 */
void set_skin( string word ) { skin = word; }

/**
 * This method returns the current description of the npc.
 * @param thing the object which is being described
 * @return the description of the npc
 * @see query_desc()
 */
string query_desc( object thing ) {
   return capitalize( (string)thing->query_pronoun() ) +" is "+ desc +".\n";
} /* query_desc() */

/**
 * This method sets the description for the npc.
 * @param words the description of the npc
 * @see set_desc()
 */
void set_desc( string words ) { desc = words; }

/**
 * This method returns the current limbs of the race.
 * @return the limbs on the race
 * @see find_limbs()
 */
string *query_limbs() {
   if ( !limbs ) {
      this_object()->find_limbs();
   }
   return copy(limbs);
} /* query_limbs() */

/**
 * This method figures out the current set of limbs on the race.  A creature
 * is assigned one "limb" for every "hand" found in the body part array.  The
 * number of limbs is the number of weapons that can be held.
 * @see query_limbs()
 */
void find_limbs() {
   int i;
   string limb;

   limbs = ({ });
   for ( i = 0; i < sizeof( bits ); i += 3 ) {
     if ( sscanf( bits[ i ], "%s hand", limb ) == 1 ) {
       limbs += ({ bits[ i ] });
     }
   }
} /* find_limbs() */

/**
 * The defaults acs for npcs when they are fighting unarmed.
 * @return the default acs
 * @see add_ac()
 */
mixed *query_acs() { return copy(acs); }

/**
 * Adds a default ac to the npc for when they fight unarmed.  Please look
 * add the armour object for more details on this.
 * @param ac_name the name of the ac
 * @param ac_type the type of the ac
 * @param ac_amount the damage/roll stuff to take off
 * @see query_acs()
 */
void add_ac( string ac_name, string ac_type, mixed ac_amount ) {
   acs += ({ ac_name, ac_type, ac_amount });
} /* add_ac() */

/**
 * The default attacks for the npc when they are fighting unarmed.
 * @return the default attacks
 * @see add_attack()
 */
mixed *query_attacks() { return copy(attacks); }

/**
 * This method adds a default attack to the npc.  Please see the
 * help on the weapons for more details on this.
 * @param attack_name the name of the attack
 * @param attack_chance the chance of the attack occuring
 * @param attack_data the damage roll for the attack
 * @see query_attacks()
 */
void add_attack( string attack_name, int attack_chance, int *attack_data ) {
   attacks += ({ attack_name, attack_chance, attack_data });
} /* add_attack() */

/**
 * This method returns all the bits for the npc.
 * @return the complete array of bits
 * @see add_bit()
 * @see query_bit()
 * @see query_possible_bits()
 * @see query_all_inedible()
 * @see query_all_unrottable()
 * @see query_all_pluckable()
 * @see remove_bit()
 */
mixed *query_bits() { return bits; }

/**
 * This method returns the bits which are children of the specified bit.
 * @param word the bit to look for the children of
 * @return the children bits
 * @see add_bit()
 * @see query_bits()
 * @see remove_bit()
 */
mixed *query_bit( string word ) {
   int i;

   i = member_array( word, bits );
   if ( ( i == -1 ) || ( i % 3 ) ) {
      return ({ });
   }
   return bits[ i .. i + 2 ];
} /* query_bit() */

private void fixup_bits() {
   string* str_bits;
   string pl;
   int i;

   if (_fixed_bits) {
      return ;
   }

   _fixed_bits = ([ ]);

   for ( i = sizeof( bits ) - 3; i > -1; i -= 3 ) {
      str_bits = explode(bits[i], " ");
      pl = pluralize(str_bits[<1]);
      if (!_fixed_bits[str_bits[<1]]) {
         _fixed_bits[str_bits[<1]] = ({ });
      }
      _fixed_bits[str_bits[<1]] += ({ ({ str_bits[0..<2], i, 0 }) });
      if (!_fixed_bits[pl]) {
         _fixed_bits[pl] = ({ });
      }
      _fixed_bits[pl] += ({ ({ str_bits[0..<2], i, 1 }) });
   }
} /* fixup_bits() */

/** @ignore yes 
 * For backwards compatibility, as corpses are currently broken in
 * the way they call the query_possible_bits() method. 
 */ 
private string *query_old_possible_bits( string word ) {
   int i;
  int j;
  string *possibles;

  possibles = ({ });
  for ( i = sizeof( bits ) - 3; i > -1; i -= 3 ) {
    if ( ( bits[ i ] == word ) ||
          ( bits[ i + 1 ] == word ) ||
          !word) {
       if (arrayp( bits[i+2][2] )) {
         for ( j = 0; j < bits[i + 2][2][1]; j++) {
           possibles += ({ bits[ i ] });
         }
       } else {
         possibles += ({ bits[ i ] });
       }
     }
   }
   return possibles;
} /* query_old_possible_bits() */


/**
 * This method returns the names of all the possible bits for the
 * npc.
 * @param word the bits to look for the children under
 * @return the array of possible bit names
 * @see add_bit()
 * @see query_bits()
 * @see query_possible_plural_bits()
 * @see remove_bit()
 */
string *query_possible_bits( string word ) {
  string* str_bits;
  string* adj;
  string *possibles;
  mixed* bing;
  
  if(!word) {
    return query_old_possible_bits( word ); 
  }

  fixup_bits();

  str_bits = explode(word, " ");
  possibles = ({ });
  if (_fixed_bits[str_bits[<1]]) {
     adj = str_bits[0..<2];
     foreach (bing in _fixed_bits[str_bits[<1]]) {
        if (!bing[2] &&
            sizeof(adj) == sizeof(adj & bing[0])) {
           possibles += ({ bits[bing[1]] });
        }
     }
  }
  return possibles;
} /* query_possible_bits() */

/**
 * This method returns the plural names for all the bits.
 * @param word the bit to find the children of
 * @return the plural names of all the bits
 * @see add_bit()
 * @see query_bits()
 * @see query_possible_bits()
 * @see remove_bit()
 */
string *query_possible_plural_bits( string word ) {
  string* str_bits;
  string* adj;
  string *possibles;
  mixed* bing;

  fixup_bits();

  str_bits = explode(word, " ");
  possibles = ({ });
  if (_fixed_bits[str_bits[<1]]) {
     adj = str_bits[0..<2];
     foreach (bing in _fixed_bits[str_bits[<1]]) {
        if (bing[2] &&
            sizeof(adj) == sizeof(adj & bing[0])) {
           possibles += ({ bits[bing[1]] });
        }
     }
  }
  return possibles;
} /* query_possible_plural_bits() */

/**
 * This method adds a bit to the current bit setup.
 * @param bit_short the short of the bit
 * @param bit_name the name of the bit
 * @param bit_array the array of children bits
 * @see query_bits()
 * @see remove_bit()
 */
void add_bit( string bit_short, string bit_name, mixed *bit_array ) {
   int i;

   i = member_array( bit_short, bits );
   if ( !( i % 3 ) ) {
      bits[ i ] = bit_short;
      bits[ i + 1 ] = bit_name;
      bits[ i + 2 ] = bit_array;
      return;
   }
   bits += ({ bit_short, bit_name, bit_array });
} /* add_bit() */

/**
 * This method removes a bit from the current bit array
 * @param word the name of the bit to remove
 * @see add_bit()
 * @see query_bits()
 */
void remove_bit( string word ) {
   int i;

   i = member_array( word, bits );
   if ( ( i == -1 ) || ( i % 3 ) ) {
      return;
   }
   bits = delete( bits, i, 3 );
} /* remove_bit() */

/**
 * This method figures out a modifier for the height based on the base
 * weight and height.
 * @param number the height/weight to modify
 * @return the modified heigh/weight
 */
int modifier( int number ) {
   return ( number * ( roll_MdN( 20, 21 ) - 220 ) ) / 2000;
} /* modifier() */

/**
 * This method is called when the npc is first created.  This sets up
 * the weight/height/stats etc.
 * @param thing the npc being created
 */
void start_player( object thing ) {
   if ( !thing->query_base_weight() ) {
      thing->set_base_weight( 1 + weight + modifier( weight ) );
   }
   if ( !thing->query_height() ) {
      thing->set_height( 1 + height + modifier( height ) );
   }
   thing->adjust_bonus_con( stats[ 0 ] );
   thing->adjust_bonus_dex( stats[ 1 ] );
   thing->adjust_bonus_int( stats[ 2 ] );
   thing->adjust_bonus_str( stats[ 3 ] );
   thing->adjust_bonus_wis( stats[ 4 ] );
   thing->reset_all();
   if ( skin ) {
      thing->set_skin( skin );
   }
} /* start_player() */

/**
 * This method figures out how many of each sort of thing 
 * can be worn.
 * @param type the type to check for numbers worn
 * @return the number of type to worn
 */
int query_number_worn( string type ) {
   switch ( type ) {
      case "armband" :
         return 2;
      case "badge" :
         return 15;
      case "bracelet" :
         return 4;
      case "earring" :
        return 2;/* added by ceres since piercing isn't implemented yet */
//         return (int)previous_object()->query_piercings( "ear" );
      case "garter" :
         return 2;
      case "shoulder" :
         return 2;
      case "necklace" :
         return 5;
      case "ring" :
         return 8;
      case "sash" :
         return 2;
      case "shirt" :
         return 2;
      case "belt scabbard" :
         return 2;
      case "small scabbard" :
         return 2;
      case "bandaid" :
         return 5;
      default :
         return 1;
   }
} /* query_number_worn() */

int query_number_wielded( string type ) { return 1; }

int query_skill_bonus( int number, string word ) { return 0; }

int player_start( object thing ) { return 1; }

int player_quit( object thing ) { return 1; }

/**
 * This method sets the level of the npc.
 * @param thing the npc to set the level of
 * @param level the current level
 */
void set_level( object thing, int level ) {
   int i;

   if ( !thing ) {
      return;
   }
   for ( i = sizeof( acs ) - 3; i > -1; i -= 3 ) {
      thing->add_ac( acs[ i ], acs[ i + 1 ], acs[ i + 2 ] );
   }
} /* set_level() */

int *calc_attack( int *data, int number ) {
   int base;
   int num;
   int rand;
   int rating;
   int scale;

   base =  data[ 0 ] * ( BASE + SCALE * number );
   num = data[ 1 ];
   rand = data[ 2 ] * ( BASE + SCALE * number );
   rating = QUEST_AVE * ( base + num * rand ) +
         QUEST_MAX * ( base + ( num * ( 1 + rand ) ) / 2 );
   scale = BASE + SCALE * NORM;
   rating /= scale;
   rating = ( ( BASE + SCALE * EXPERT ) * rating + QUEST_AVE * QUEST_MAX ) /
         ( 2 * QUEST_AVE * QUEST_MAX );
   if ( rating > scale ) {
      scale = ( rating + scale ) / 2;
   }
   return ({ base / scale, num, rand / scale });
} /* calc_attack() */

/**
 * This method sets up the unarmed attacks on the npc.
 * @param thing the npc to setup the attacks on
 */
void set_unarmed_attacks( object thing ) {
   int i, number;

   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = sqrt( number );

   for ( i = sizeof( attacks ) - 3; i > -1; i -= 3 ) {
      thing->remove_attack( attacks[ i ] );
      thing->add_attack( attacks[ i ], attacks[ i + 1 ],
            calc_attack( attacks[ i + 2 ], number ), A_TYPES[ attacks[ i ] ],
            "unarmed", "unarmed_"+ attacks[ i ] );
   }
} /* set_unarmed_attacks() */

/**
 * This method checks to see if the specified bit of the npc is edible or
 * not.
 * @param bit the bit to check
 * @return 1 if the bit is edible, 0 if not
 * @see add_bit()
 * @see query_bits()
 * @see query_all_inedible()
 * @see remove_bit()
 */
int query_eat( string bit ) {
  if (member_array( bit, inedible) == -1) {
    return 1;
  }
  return 0;
} /* query_eat() */

/**
 * This method checks to see if the bit is unrottable, ie: a bit of
 * skeleton.
 * @param bit the bit to check
 * @return 1 if unrottable, 0 if rottable
 * @see add_bit()
 * @see query_bits()
 * @see query_all_unrottable()
 * @see remove_bit()
 */
int query_unrottable( string bit ) {
  if (member_array( bit, unrottable) == -1) {
    return 0;
  }
  return 1;
} /* query_unrottable() */

/**
 * This method checks to see if the bit is pluckable.
 * @param bit the bit to check
 * @return 1 if pluckable, 0 if not
 * @see add_bit()
 * @see query_bits()
 * @see query_all_pluckable()
 * @see remove_bit()
 */
int query_pluckable( string bit ) {
  if (member_array( bit, pluckable) == -1) {
    return 0;
  }
  return 1;
} /* query_pluckable() */

/**
 * This method returns the array of all the inedible bits of the race.
 * @return all the inedible bits
 * @see add_bit()
 * @see query_bits()
 * @see query_eat()
 * @see remove_bit()
 */
string *query_all_inedible() {
   return inedible;
} /* query_all_inedible() */

/**
 * This method returns the array of all the unrottable bits of the race.
 * @return all the unrottable bits
 * @see add_bit()
 * @see query_bits()
 * @see query_unrottable()
 * @see remove_bit()
 */
string *query_all_unrottable() {
   return unrottable;
} /* query_all_unrottable() */

/**
 * This method returns the array of all the pluckable bits of the race.
 * @return all the pluckable bits of the race
 * @see add_bit()
 * @see query_bits()
 * @see query_pluckable()
 * @see remove_bit()
 */
string *query_all_pluckable() {
   return pluckable;
} /* query_all_pluckable() */


// Very generic. These are the zones
string *query_target_zones() {
  return ({ "head", "head", "neck",
              "chest", "back", "back", "back", "lower back", 
              "left front leg", "left front leg", 
              "stomach", "stomach", 
              "right front leg", "right front leg",
              "left rear leg", "left rear leg",
              "right rear leg", "right rear leg",});
}

string map_target_zone(string zone) {
  switch(zone) {
  case "abdomen":
    return "stomach";
  case "hands":
  case "arms":
    return (random(2) ? "left " : "right ") + "front leg";
  case "feet":
  case "legs":
    return (random(2) ? "left " : "right ") + "rear leg";
  default:
    return zone;
  }
}

string map_armour_zone(string zone) {
  switch(zone) {
  case "thorax":
  case "body":
  case "breast":
  case "trunk":
    return "chest";

  case "tail":
    return "back";
    
  case "stomach":
    return "abdomen";
    
  case "left arm":
  case "right arm":
  case "left front leg":
  case "right front leg":
  case "left petral fin":
  case "right petral fin":
  case "left wing":
  case "right wing":
  case "branches":
    return "arms";

  case "left hand":
  case "right hand":
  case "left middle leg":
  case "right middle leg":
  case "left front paw":
  case "right front paw": 
    return "hands";

  case "left leg":
  case "right leg":
  case "left back leg":
  case "right back leg":
  case "left rear leg":
  case "right rear leg":
  case "dorsal fin":
    return "legs";
    
  case "left foot":
  case "right foot":
  case "left rear paw":
  case "left rear paw":
  case "left rear foot":
  case "left rear foot":
  case "left claw":
  case "right claw":
  case "root":
    return "feet";
    
  default:
    return zone;
  }
}
// --- END [/mnt/home2/grok/lib/std/races/base.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/mole.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/mole.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628788   Available: 13576142
Inodes: Total: 5242880    Free: 4960135
990 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/mole.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628788   Available: 13576142
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming

inherit "/std/races/rodent_base";

void setup() {
  set_name( "mole" );
  set_long( "Any insectivore of the family Talpidae, which includes moles, "
     "shrew moles, and desmans.  They have no ears and tiny eyes, and live "
     "in small burrows.\n" );
  set_height( 30 );
  set_weight( 10 );
  set_desc( "This is a blind and deaf mole." );

  set_sight( ({ -100, -60, 40, 60 }) );
  set_stats( ({ -2, 2, -6, -2, -6 }) );
} /* setup() */

void set_unarmed_attacks( object thing ) {
  int number;

  number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
  number = sqrt( number ) / 6;

  thing->remove_attack( "hands" );
  thing->remove_attack( "feet" );

  thing->remove_attack( "bite" );
  thing->remove_attack( "claws" );

  thing->add_attack( "bite", 75, ({ 0, 3, number }),
    "pierce", "unarmed", 0 );
  thing->add_attack( "claws", 50, ({ 10, 5, number / 2 }),
    "sharp", "unarmed", 0 );

  thing->tactics( "response dodge" );
} /* set_unarmed_attacks() */
// --- END [/mnt/home2/grok/lib/std/races/mole.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/raptor.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/raptor.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628788   Available: 13576142
Inodes: Total: 5242880    Free: 4960135
1309 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/raptor.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628788   Available: 13576142
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/races/bird_base";

void setup() {
   set_name( "raptor" );
   set_long( "A carnivorous bird (as a hawk or falcon) that feeds wholly on "
      "meat taken by hunting.\n" );
   set_height( 65 );
   set_weight( 200 );
   set_desc( "a sharp-eyed raptor" );

   remove_bit( "gizzard" );

   set_stats( ({ 0, 14, -4, 2, -6 }) );
} /* setup() */

void new_set_level( mixed *args ) {
   int level;
   object thing;

   if( sizeof(args) < 2 || !args[1] )
      return;

   level = args[ 0 ];
   thing = args[ 1 ];

   level = 2 * level + random( level );

   thing->add_ac( "blunt", "blunt", level );
   thing->add_ac( "pierce", "pierce", level / 4 );
   thing->add_ac( "sharp", "sharp", level / 4 );
} /* new_set_level() */

void set_unarmed_attacks( object thing ) {
   int number;

   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = sqrt( number ) / 2;

   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );

   thing->remove_attack( "beak" );
   thing->remove_attack( "claws" );

   thing->add_attack( "beak", 50, ({ number / 2, 2, number / 2 }),
      "pierce", "unarmed", 0 );
   thing->add_attack( "claws", 75, ({ number, 5, number / 2 }),
      "sharp", "unarmed", 0 );

   thing->tactics( "response dodge" );
} /* set_unarmed_attacks() */// --- END [/mnt/home2/grok/lib/std/races/raptor.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/luggage.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/luggage.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628787   Available: 13576141
Inodes: Total: 5242880    Free: 4960135
1179 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/luggage.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628787   Available: 13576141
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/races/base";

void setup() {
   set_name( "luggage" );
   set_long( "A sapient pearwood luggage.\n" );
   set_desc( "a nice set of luggage" );
   set_height( 75 );
   set_weight( 5000 );

/*
 *   short, name, ({ parent, percentage weight, ({ file name (0 is "/std/bit"),
 *        amount }), child bit 1, child bit 2, ... })
 */  
   bits = ({ 
      "trunk", "trunk", ({ 0, 400, 0 }),
      "lid", "lid", ({ 0, 1000, 0 }),
      "leg", "leg", ({ 0, 5, ({"/std/bit", 50}) })
   });
    
   inedible = ({ "trunk", "lid" });
   unrottable = ({ "trunk", "lid" });
   set_skin( "casing" );

   add_ac( "blunt", "blunt", 25 );
   add_ac( "pierce", "pierce", 25 );
   add_ac( "sound", "sound", 1000 );
   add_ac( "gas", "gas", 1000 );

   set_stats( ({ 10, 6, -2, 10, -2 }) );
} /* setup() */

void set_unarmed_attacks( object thing ) {
   int number;

   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = 4 + sqrt( number ) / 2;

   thing->remove_attack( "hands" );

   thing->add_attack( "feet", 75, ({ 5 * number, 10, number }), "blunt",
      "unarmed", 0 );

   thing->tactics( "response dodge" );
} /* set_unarmed_attacks() */

// --- END [/mnt/home2/grok/lib/std/races/luggage.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/toad.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/toad.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628787   Available: 13576141
Inodes: Total: 5242880    Free: 4960135
556 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/toad.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628787   Available: 13576141
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/races/amphibian";

void setup() {
   set_name( "toad" );
   set_long( "Toads are amphibians" );
   set_height(10);
   set_weight(10);
   set_desc( "an warty toad" );

   add_ac( "blunt", "blunt", 5 );
   add_ac( "pierce", "pierce", 4 );
   add_ac( "sharp", "sharp", 3 );

   add_attack( "bite", 50, ({ 10, 2, 6 }) );

   set_sight( ({ 5, 20, 200, 300 }) );
   set_stats( ({ -4, 10, -4, -4, -6 }) );
} /* setup() */

void start_player( object thing ) {
   ::start_player( thing );
   thing->tactics( "response dodge" );
} /* start_player() */
// --- END [/mnt/home2/grok/lib/std/races/toad.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/elephant.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/elephant.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628786   Available: 13576140
Inodes: Total: 5242880    Free: 4960135
4642 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/elephant.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628786   Available: 13576140
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/races/ruminant";

void setup() {
   set_name( "elephant" );
   set_long( "This is an elephant.  A large creature with a thick grey "
      "hide.  He seems to weigh a lot so don't let him step on your "
      "toe.\n" );
   set_height( 280 );
   set_weight( 100000 );
   set_desc( "an elephant that looks back at you with small nice eyes" );

   remove_bit( "nose" );
   remove_bit( "head" );

   add_bit( "head", "head", ({ 0, 135, 0,
      "left eye", "right eye", "skull", "tongue", "left ear", "right ear",
      "right tusk" "left tusk", "trunk" }) );
      
   add_bit( "right tusk", "tusk", ({ "head", 20, ({ "/std/bit", 2 }) }) );
   add_bit( "left tusk", "tusk", ({ "head", 20, ({ "/std/bit", 2 }) }) );
   add_bit( "trunk", "trunk", ({ "head", 30, 0 }) );

   remove_bit( "left front leg" );
   remove_bit( "right front leg" );
   remove_bit( "left rear leg" );
   remove_bit( "right rear leg" );
   remove_bit( "left front hoof" );
   remove_bit( "right front hoof" );
   remove_bit( "left rear hoof" );
   remove_bit( "right rear hoof" );
      
   add_bit( "left front leg", "leg", ({ 0, 150, 0, "left front foot" }) );
   add_bit( "right front leg", "leg", ({ 0, 150, 0, "right front foot" }) );
   add_bit( "left rear leg", "leg", ({ 0, 150, 0, "left rear leg" }) );
   add_bit( "right rear leg", "leg", ({ 0, 150, 0, "right rear leg" }) );
   
   add_bit( "left front foot", "foot", ({ "left front leg", 30, 0 }) );
   add_bit( "right front foot", "foot", ({ "right front leg", 30, 0 }) );
   add_bit( "left rear foot", "foot", ({ "left rear leg", 30, 0 }) );
   add_bit( "right rear foot", "foot", ({ "right rear leg", 30, 0 }) );

   add_bit( "tail", "tail", ({ 0, 15, 0 }) );

   inedible += ({ "tail", "right tusk", "left tusk" });  
   unrottable += ({ "left tusk", "right tusk" });

   add_ac( "blunt", "blunt", ({ 40, 20}) );
   add_ac( "pierce", "pierce", ({ 30, 20 }) );
   add_ac( "sharp", "sharp", ({ 50, 20 }) );
   add_ac( "acid", "acid", 20 );
   add_ac( "fire", "fire", 20 );

   set_stats( ({ 30, -6, -4, 16, -2 }) );
} /* setup() */

void set_unarmed_attacks( object thing ) {
   thing->remove_attack( "hands" );

   thing->remove_attack( "tusks" );
   thing->remove_attack( "crush" );
   thing->remove_attack( "ram" );

   thing->add_attack( "tusks", 25, ({200, 10, 30}), "pierce", "unarmed", 0 );
   thing->add_attack( "crush", 10, ({300, 10, 50}), "blunt", "unarmed", 0 );

   thing->add_attack_message( "crush", "unarmed", ({
     0, "$N stand$s on $p hind legs and attempt$s to crash down on $I",
      200, "$N stand$s on $p hind legs and crash$es down, striking $I "
       "a glancing blow",
      400, "$N stand$s on $p hind legs and crash$es down on $I, crushing "
            "$P $z",
      5000, "$N stand$s on $p hind legs and crash$es down on $I, crushing "
            "$P $z into a bloody mess" }) );

   thing->add_attack( "ram", 25, ({200, 10, 20}), "blunt", "unarmed", 0 );
   thing->add_attack_message( "ram", "unarmed", ({
     0, "$N charge$s at $I",
      200, "$N charge$s $I and strike$s $I",
      400, "$N charge$s $I and strike$s $P $z hard, making $I stagger "
            "around",
      5000, "$N charge$s $I and strike$s $I to the ground.  $I "
            "stumbles around a little groggily" }) );

   thing->add_attack( "trunk", 50, ({100, 5, 20}), "blunt", "unarmed", 0 );
   thing->add_attack_message( "trunk", "unarmed", ({
     0, "$N swing$s $p trunk at $I",
      200, "$N swing$s $p trunk at $I, hitting $P $z hard",
      400, "$N swing$s $p trunk, which thumps forcefully into $P $z",
      5000, "$N swing$s $p trunk at $I, nearly knocking $I down" }) );
} /* set_unarmed_attacks() */


string *query_target_zones() {
  return ({ "head", "head", "neck",
              "chest", "back", "back", "back", "lower back", 
              "left front leg", "left front leg", "left front foot",
              "stomach", "stomach", "tail",
              "right front leg", "right front leg", "right front foot",
              "left rear leg", "left rear leg", "left rear foot",
              "right rear leg", "right rear leg", "right rear foot"});
}


string map_target_zone(string zone) {
  switch(zone) {
  case "chest":
    return random(4) ? "back" : "chest";
  case "abdomen":
    return random(4) ? "stomach" : "lower back";
  case "arms":
    return (random(2) ? "left " : "right ") + "front leg";
  case "hands":
    return (random(2) ? "left " : "right ") + "front foot";
  case "legs":
    return (random(2) ? "left " : "right ") + "rear leg";
  case "feet":
    return (random(2) ? "left " :"right ") + "rear foot";
  default:
    return zone;
  }
}
// --- END [/mnt/home2/grok/lib/std/races/elephant.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/spider.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/spider.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628785   Available: 13576139
Inodes: Total: 5242880    Free: 4960135
1809 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/spider.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628785   Available: 13576139
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#define POISON_EFFECT "/std/effects/poisons/spider_venom"

inherit "/std/races/arachnid";

void setup() {
   set_name( "spider" );
   set_long( "A small, poisonous, hairy spider.\n" );
   set_desc( "a hairy arachnid" );
   set_height( 5 );
   set_weight( 2 );

   add_bit( "silk gland", "gland", ({ "abdomen", 10,
      ({"/std/bit", 1, 400}) }) );
   add_bit( "poison gland", "gland", ({ "cephalothorax", 5,
      ({"/std/bit", 1, 400}) }) );

   inedible += ({ "poison gland" });

   set_stats( ({ -6, 4, -6, -6, -6 }) );
} /* setup() */
 
void new_set_level( mixed *args ) {
   int level;
   object thing;

   if( sizeof(args) < 2 || !args[1] )
      return;

   level = args[ 0 ];
   thing = args[ 1 ];

   thing->add_skill_level( "other.health", level * 2 );
   thing->add_ac( "blunt", "blunt", level / 2 );
   thing->add_ac( "pierce", "pierce", level / 4 );
   thing->add_ac( "sharp", "sharp", level / 3 );
} /* new_set_level() */

void set_unarmed_attacks( object thing ) {
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "standard" );

   thing->remove_attack( "bite" );
   thing->remove_attack( "chew" );

   thing->add_attack( "bite", 80, ({ 10, 2, 5 }),
      "pierce", "unarmed", ({ "poison", this_object() }) );
   thing->add_attack( "chew", 100, ({ 2, 2, 10 }),
      "sharp", "unarmed", 0 );

   thing->tactics( "response dodge" );
} /* set_unarmed_attacks() */

void poison( int damage, object him, object me, string a_type,
             string a_name ) {
   tell_room( me->one_short() + " visciously sinks its fangs into " +
      him->one_short() + " who seethes in agony!\n" );
   tell_object( him, me->one_short() + " sinks its fangs into you!  You "
      "seethe in agony.\n" );

   him->add_effect( POISON_EFFECT, 100 );
} /* poison() */
// --- END [/mnt/home2/grok/lib/std/races/spider.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/bear.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/bear.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628784   Available: 13576138
Inodes: Total: 5242880    Free: 4960135
1263 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/bear.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628784   Available: 13576138
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* Dragonkin, Decembar 1997 */

inherit "/std/races/carnivore";

void setup() {
   set_name( "bear" );
   set_desc( "a furry bear" );
   set_height( 200 );
   set_weight( 8000 );

   set_stats( ({ 6, 4, -2, 8, -4 }) );
} /* setup() */

void new_set_level( mixed *args ) {
   int level;
   object thing;

   if( sizeof(args) < 2 || !args[1] )
      return;

   level = args[ 0 ];
   thing = args[ 1 ];

   level = 2 + ( 2 * level + random( level ) ) / 8;

   thing->add_ac( "blunt", "blunt", 20 + level / 3 );
   thing->add_ac( "sharp", "sharp", 50 + level );
   thing->add_ac( "pierce", "pierce", 60 + 2 * level );
} /* new_set_level() */

void set_unarmed_attacks( object thing ) {
   int number;

   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = 4 + sqrt( number ) / 2;

   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );

   thing->remove_attack( "claws" );
   thing->remove_attack( "bite" );

   thing->add_attack( "claws", 100, ({ 2 * number, 10, number }),
      "sharp", "unarmed", 0 );
   thing->add_attack( "bite", 50, ({ 3 * number, 8, number }),
      "pierce", "unarmed", 0 );

   thing->tactics( "response dodge" );
   thing->tactics( "attitude offensive" );
} /* set_unarmed_attacks() */
// --- END [/mnt/home2/grok/lib/std/races/bear.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/deer.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/deer.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628784   Available: 13576138
Inodes: Total: 5242880    Free: 4960135
3392 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/deer.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628784   Available: 13576138
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* deer race object. */

inherit "/std/races/base";

void setup() {
   set_name( "deer" );
   set_long( "A medium-sized hoofed mammal.  Surprise.\n" );
   set_height( 250 );
   set_weight( 4000 );
   
   /* throw away the human bits and replace totally */
   bits= ({
      "head", "head", ({ 0, 120, 0,
         "left eye", "right eye", "skull", "brain", "left ear",
         "right ear", "tongue" }),
      "left antler", "antler", ({ "head", 30, 0 }),
      "right antler", "antler", ({ "head", 30, 0 }),
      "left eye", "eye", ({ "head", 2, 0 }),
      "right eye", "eye", ({ "head", 2, 0 }),
      "skull", "cranium", ({ "head", 45, 0, "teeth" }),
      "brain", "brain", ({ "head", 20, 0 }),
      "left ear", "ear", ({"head", 4, 0 }),
      "right ear", "ear", ({"head", 4, 0 }),
      "teeth", "teeth", ({ "skull", 5, ({"/std/bit_set", 1}) }),
      "tooth", "tooth", ({ "teeth", 1, ({"/std/bit", 18}) }),
      "tongue", "tongue", ({ "head", 9, 0 }),
      "neck", "neck", ({ 0, 120, 0 }),
      "torso", "body", ({ 0, 400, 0,
         "heart", "liver", "left kidney", "right kidney", "left lung",
         "right lung", "spleen", "intestine", "pancreas" }),
      "heart", "heart", ({ "torso", 35, 0 }),
      "liver", "liver", ({ "torso", 35, 0 }),
      "left kidney", "kidney", ({ "torso", 20, 0 }),
      "right kidney", "kidney", ({ "torso", 20, 0 }),
      "left lung", "lung", ({ "torso", 35, 0 }),
      "right lung", "lung", ({ "torso", 35, 0 }),
      "spleen", "spleen", ({ "torso", 20, 0 }),
      "intestine", "gut", ({ "torso", 75, 0 }),
      "pancreas", "pancreas", ({ "torso", 20, 0 }),
      "left front leg", "leg", ({ 0, 140, 0, "left front hoof" }),
      "left front hoof", "hoof", ({ "left front leg", 20, 0 }),
      "right front leg", "leg", ({ 0, 140, 0, "right front hoof" }),
      "right front hoof", "hoof", ({ "right front leg", 20, 0 }),
      "left rear leg", "leg", ({ 0, 160, 0, "left rear hoof" }),
      "left rear hoof", "hoof", ({ "left rear leg", 20, 0 }),
      "right rear leg", "leg", ({ 0, 160, 0, "right rear hoof" }),
      "right rear hoof", "hoof", ({ "right rear leg", 20, 0 }),
      "tail", "tail", ({ 0, 15, 0 }),
      "skin", "skin", ({ 0, 175, 0 })
   });
   
   inedible = ({ "skull", "left front hoof", "right front hoof", "left antler", "right antler",
      "left rear hoof", "right rear hoof", "tail", "teeth", "tooth" });
   unrottable = ({ "skull", "left front hoof", "right front hoof", "left antler", "right antler",
      "left rear hoof", "right rear hoof", "teeth", "tooth" });

   set_desc( "a medium-sized, hairy quadruped.  It looks like a deer" );

   add_ac( "blunt", "blunt", 50 );
   add_ac( "sharp", "sharp", 20 );
   add_ac( "pierce", "pierce", 20 );
   set_skin( "skin" );

   set_stats( ({ 4, 4, -2, 6, -2 }) );
} /* setup() */

void set_unarmed_attacks( object thing ) {
   int number;

   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = sqrt( number );

   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );

   thing->remove_attack( "antlers" );
   thing->remove_attack( "hoof" );

   thing->add_attack( "antlers", 40, ({ number, 2, number }),
      "pierce", "unarmed", 0 );
   thing->add_attack( "hoof", 60, ({ number / 2, 5, number }),
      "blunt", "unarmed", 0 );
   
   thing->tactics( "response dodge" );
} /* set_unarmed_attacks() */
// --- END [/mnt/home2/grok/lib/std/races/deer.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/sheep.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/sheep.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628783   Available: 13576137
Inodes: Total: 5242880    Free: 4960135
954 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/sheep.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628783   Available: 13576137
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/races/ruminant";

void setup() {
   set_name( "sheep" );
   set_long( "The sheep is a wooly mammal.  It is possibly the most stupid "
      "animal in the universe, with the possible exception of the duck.\n" );
   set_height( 50 );
   set_weight( 800 );
   set_skin( "fleece" );
   set_desc( "a wooly sheep" );

   add_ac( "blunt", "blunt", 50 );
   add_ac( "pierce", "pierce", 20 );
   add_ac( "sharp", "sharp", 20 );

   set_stats( ({ 0, 0, -6, -2, -6 }) );
} /* setup() */

void set_unarmed_attacks( object thing ) {
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "standard" );

   thing->remove_attack( "chew" );
   thing->remove_attack( "hoof" );

   thing->add_attack( "chew", 50, ({ 40, 8, 10 }), 
      "sharp", "unarmed", 0 );
   thing->add_attack( "hoof", 50, ({ 60, 10, 40 }), 
      "blunt", "unarmed", 0 );

   thing->tactics( "response dodge" );
} /* set_unarmed_attacks() */
// --- END [/mnt/home2/grok/lib/std/races/sheep.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/cabbage.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/cabbage.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628783   Available: 13576137
Inodes: Total: 5242880    Free: 4960135
1936 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/cabbage.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628783   Available: 13576137
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* Cabbage race object. */

inherit "/std/races/base";

void setup() {
   set_name( "cabbage" );
   set_long("A green, leafy vegetable.  Probably full of vitamins and "+
      "minerals, and plenty of roughage.\n" );
   set_height( 20 );
   set_weight( 40 );
   set_desc( "a cute little green-fronded cabbage.  Awww" );
   set_skin( "fronds" );

   /* throw away the human bits and replace totally */
   bits = ({
      "frond", "frond", ({ 0, 100, ({"/std/bit", 10}) }),
      "stalk", "stalk", ({ 0, 500, 0 })
   });
   
   inedible = ({ });
   unrottable = ({ });

   set_stats( ({ -4, -4, -6, -4, -6 }) );
}  /* end setup */

void player_heart_beat( string word, object brassica ) {
   object *caterpillars;

   if( !environment( brassica ) ) {
      return; 
   }

   caterpillars = match_objects_for_existence( "caterpillar",
      environment( brassica ) );

   if( !sizeof( caterpillars ) ) {
      return;
   }

   if( brassica->caterpillars_here( caterpillars ) ) {
      return;
   }

   brassica->do_command( "gibber" );
   brassica->run_away();
} /* player_heart_beat() */

void set_unarmed_attacks( object thing ) {
   int number;

   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = 4 + sqrt( number ) / 2;

   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );

   thing->remove_attack( "fronds" );

   thing->add_attack( "fronds", 160, ({ 4 * number, 5, 3 * number }),
      "sharp", "unarmed", 0 );

   thing->add_attack_message( "fronds", "sharp", ({
      50, "$N scratch$es $P $z with a frond.\n",
      100, "$N jab$s a sharp frond into $P $z.\n",
      140, "$N chew$s on $P $z.\n",
      180, "$N slash$es $P $z with $p fronds.\n",
      230, "$N climb$s onto %I and cuts $P $z with a sharp frond.\n", 
      0, "$N bite$s $P $z off!\n" }) );

   thing->tactics( "response dodge" );
   thing->tactics( "attitude offensive" );
} /* set_unarmed_attacks() */

// --- END [/mnt/home2/grok/lib/std/races/cabbage.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/hare.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/hare.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628782   Available: 13576136
Inodes: Total: 5242880    Free: 4960135
1079 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/hare.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628782   Available: 13576136
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/races/lagomorpha_base";

void setup() {
   set_name( "hare" );
   set_long( "This is a hare with long ears.\n" );
   set_height( 50 );
   set_weight( 100 );
   set_desc( "a large and meaty hare" );

   set_stats( ({ -2, 8, -4, -4, -6 }) );
} /* setup() */

void new_set_level( mixed *args ) {
   int level;
   object thing;

   if( sizeof(args) < 2 || !args[1] )
      return;

   level = args[ 0 ];
   thing = args[ 1 ];

   thing->add_ac( "blunt", "blunt", level );
   thing->add_ac( "sharp", "sharp", 2 + level );
   thing->add_ac( "pierce", "pierce", 2 * level );
} /* new_set_level() */

void set_unarmed_attacks( object thing ) {
   int number;

   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = sqrt( number ) / 6;

   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );

   thing->remove_attack( "bite" );

   thing->add_attack( "bite", 75, ({ 0, 3, 5 }),
      "pierce", "unarmed", 0 );

   thing->tactics( "response dodge" );
   thing->tactics( "attitude defensive" );
} /* set_unarmed_attacks() */
// --- END [/mnt/home2/grok/lib/std/races/hare.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/caterpillar.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/caterpillar.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628781   Available: 13576135
Inodes: Total: 5242880    Free: 4960135
1902 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/caterpillar.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628781   Available: 13576135
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/races/insect_base";
 
void setup() {
   set_name( "caterpillar" );
   set_long( "The elongated wormlike larva of a butterfly or moth.\n" );
   set_height( 5 );
   set_weight( 2 );
   set_desc( "a caterpillar, crawling along the ground" );

   set_stats( ({ -6, -6, -6, -6, -6 }) );
} /* setup() */
 
void player_heart_beat( string word, object eater ) {
   int i, time;
   object flowers, *things;

   if( !environment( eater ) ) return;
   if( eater->query_property( "eating" ) ) return;
   things = all_inventory( environment( eater ) ) - ({ eater });
   if( !sizeof( things ) ) return;

   for( i = 0; i < sizeof( things ); i++ ) {
      if( !(int)things[ i ]->id( "flowers" ) ) {
         things -= ({ things[ i ] });
         i--;
      } else {
         if( things[ i ]->query_property( "being eaten" ) ) {
            things -= ({ things[ i ] });
            i--;
         }
      }
   }

   if( !sizeof( things ) ) return;
   flowers = things[ random( sizeof( things ) ) ];

   tell_room( environment( eater ), "The " + (string)eater->query_short() +
      " discovers the " + (string)flowers->query_short() + " and starts to "
      + "munch.\n" );

   eater->add_property( "eating", 1 );
   flowers->add_property( "being eaten", 1 );
   time = (int)flowers->query_weight();
   time += random( time );

   call_out( "done_eating", time, eater, flowers );
} /* player_heart_beat() */
 
void done_eating( object eater, object flowers ) {
   if( !eater ) return;
   eater->remove_property( "eating" );
   if( !environment( eater ) ) return;
   if( !flowers ) return;
   if( member_array( flowers, all_inventory( environment( eater ) ) ) == -1 )
      return;

   tell_room( environment( eater ), "The " + (string)eater->query_short() +
      " finishes the " + (string)flowers->query_short() + " and burps " +
      "contentedly.\n" );

   flowers->dest_me();
} /* done_eating() */
// --- END [/mnt/home2/grok/lib/std/races/caterpillar.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/cockroach.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/cockroach.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628781   Available: 13576135
Inodes: Total: 5242880    Free: 4960135
949 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/cockroach.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628781   Available: 13576135
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/races/insect_base";

void setup() {
   set_desc( "a nasty cockroach, ugh" );
   set_name( "cockroach" );
   set_height( 5 );
   set_weight( 2 );

   add_ac( "blunt", "blunt", 40 );
   add_ac( "sharp", "sharp", 20 );
   add_ac( "pierce", "pierce", 10 );

   set_stats( ({ -6, 4, -4, -6, -6 }) );
} /* setup() */

void set_unarmed_attacks( object thing ) {
   int number;
  
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = sqrt( number );

   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );

   thing->remove_attack( "claws" );
   thing->remove_attack( "bite" );

   thing->add_attack( "claws", 100, ({ ( 3 * number ) / 2, 5, number }),
      "sharp", "unarmed", 0 );
   thing->add_attack( "bite", 50, ({3 * number, 2, number }),
      "pierce", "unarmed", 0 );

   thing->tactics( "response dodge" );
   thing->tactics( "attitude defensive" );
} /* set_unarmed_attacks() */
// --- END [/mnt/home2/grok/lib/std/races/cockroach.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/beetle.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/beetle.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628780   Available: 13576134
Inodes: Total: 5242880    Free: 4960135
608 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/beetle.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628780   Available: 13576134
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/races/insect_base";
 
void setup() {
   set_name( "beetle" );
   set_desc( "a hard-carapaced insect that scuttles along the ground" );
   set_height( 5 );
   set_weight( 2 );

   add_bit( "left wing cover", "cover", ({ "thorax", 1, 0 }) );
   add_bit( "right wing cover", "cover", ({ "thorax", 1, 0 }) );

   inedible += ({ "left wing cover", "right wing cover" });

   set_stats( ({ -6, 4, -6, -6, -6 }) );
} /* setup() */

void start_player( object thing ) {
   ::start_player( thing );
   thing->tactics( "response dodge" );
   thing->tactics( "attitude defensive" );
} /* start_player() */
// --- END [/mnt/home2/grok/lib/std/races/beetle.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/venomous_snake.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/venomous_snake.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628780   Available: 13576134
Inodes: Total: 5242880    Free: 4960135
2903 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/venomous_snake.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628780   Available: 13576134
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/races/reptile_base";

void setup() {
   set_name( "snake" );
   set_long( "Snake, Serpent, Legless thingy that crawls on its belly all "
      "day long.\n" );
   set_height( 5 );
   set_weight( 60 );
   set_desc( "a serpent, the type with no legs but with scales." );
  
   /* throw away reptilian bits and replace totally */
   bits = ({ 
      "head", "head", ({ 0, 50, 0,
         "left eye", "right eye", "poison sac", "tongue", "skull" }),
      "left eye", "eye", ({ "head", 5, 0 }),
      "right eye", "eye", ({ "head", 5, 0 }),
      "poison sac", "sac", ({ "head", 10, 0 }),
      "skull", "skull", ({ "head", 40, 0, "tooth", "brain" }),
      "tooth", "tooth", ({ "skull", 5, ({"/std/bit", 2}) }),
      "brain", "brain", ({ "skull", 10, 0 }),
      "torso", "torso", ({ 0, 600, 0,
         "heart", "liver", "left kidney", "right kidney", "spleen",
         "bladder", "intestine" }),
      "heart", "heart", ({ "torso", 20, 0 }),
      "liver", "liver", ({ "torso", 20, 0 }),
      "left lung", "lung", ({ "torso", 20, 0 }),
      "right lung", "lung", ({ "torso", 20, 0 }),
      "left kidney", "kidney", ({ "torso", 10, 0 }),
      "right kidney", "kidney", ({ "torso", 10, 0 }),
      "spleen", "spleen", ({ "torso", 10, 0 }),
      "bladder", "bladder", ({ "torso", 10, 0 }),
      "intestine", "gut", ({ "torso", 100, 0 }),
      "genitals", "genitals", ({ 0, 5, 0 }),
      "tail", "tail", ({ 0, 500, 0 }),
      "skin", "skin", ({ 0, 175, 0 })
   });

   inedible = ({ "poison sac", "tooth" });
   unrottable = ({ "tooth" });

   add_ac( "blunt", "blunt", 40 );
   add_ac( "sharp", "sharp", 20 );
   add_ac( "pierce", "pierce", 10 );

   set_stats( ({ 0, 0, -4, 4, -4 }) );
} /* setup() */
     
void set_unarmed_attacks( object thing ) {
   int number;

   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = sqrt( number );

   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );

   thing->remove_attack( "bite" );
   thing->remove_attack( "crush" );

   thing->add_attack( "bite", 80, ({ ( 3 * number ) / 2, 5, number * 2 }),
      "pierce", "unarmed", ({ "poison", this_object() }) );
   thing->tactics( "response dodge" );
} /* set_unarmed_attacks() */

void poison( int damage, object him, object me, string a_type,
             string a_name ) {
   tell_room( me->one_short() + " visciously sinks its fangs into " +
      him->one_short() + " who seethes in agony!\n" );
   tell_object( him, me->one_short() + " sinks its fangs into you!  You "
      "seethe in agony.\n" );

   him->add_effect( POISON_EFFECT, random(200) );
}

string *query_target_zones() {
  return ({ "head", "body", "body", "body", "tail", "tail", "tail" });
}

string map_target_zone(string zone) {
  switch(zone) {
  case "head":
    return "head";
  case "neck":
  case "chest":
    return "body";
  default:
    return "tail";
  }
}

// --- END [/mnt/home2/grok/lib/std/races/venomous_snake.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/cow.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/cow.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628779   Available: 13576133
Inodes: Total: 5242880    Free: 4960135
1595 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/cow.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628779   Available: 13576133
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/races/ruminant";

void setup() {
   mixed *new_head;

   set_name( "cow" );
   set_long( "A large hoofed mammal.  Surprise.\n" );
   set_height( 175 );
   set_weight( 16000 );
   set_desc( "a large, hairy quadruped reminding you very much of a cow" );

   new_head = query_bit( "head" );
   new_head[ 2 ] += ({ "left horn", "right horn" });
   remove_bit( "head" );
   add_bit( "head", "head", new_head[ 2 ] );
   add_bit( "left horn", "horn", ({ "head", 10, 0 }) );
   add_bit( "right horn", "horn", ({ "head", 10, 0 }) );
   add_bit( "udders", "udders", ({ 0, 60, 0 }) );
   add_bit( "tail", "tail", ({ 0, 15, 0 }) );

   inedible += ({ "left horn", "right horn", "tail" });  
   unrottable += ({ "left horn", "right horn" });

   add_ac( "blunt", "blunt", 50 );
   add_ac( "pierce", "pierce", 20 );
   add_ac( "sharp", "sharp", 20 );

   add_attack( "bite", 20, ({ 40, 8, 10 }) );
   add_attack( "feet", 50, ({ 60, 10, 40 }) );

   set_stats( ({ 4, -2, -4, 6, -6 }) );
} /* setup() */

void set_unarmed_attacks( object thing ) {
   int number;

   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = sqrt( number );

   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );

   thing->remove_attack( "horns" );
   thing->remove_attack( "hoof" );

   if( number < 10 )
      number = 10;
  
   thing->add_attack( "horns", 40, ({ 60, 10, 40 }), 
      "pierce", "unarmed", 0 );
   thing->add_attack( "hoof", 60, ({ 40, 8, 10 }), 
      "blunt", "unarmed", 0 );

   thing->tactics( "response dodge" );
} /* set_unarmed_attacks() */
// --- END [/mnt/home2/grok/lib/std/races/cow.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/guppy.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/guppy.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628779   Available: 13576133
Inodes: Total: 5242880    Free: 4960135
673 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/guppy.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628779   Available: 13576133
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/races/fish_base";

void setup() {
   set_name( "guppy" );
   set_long( "Fish,  yes.  A fish.  Nice generic standard fish thing.\n" );
   set_height( 15 );
   set_weight( 40 );
   set_desc( "a beautiful looking guppy" );

   set_stats( ({ -2, 14, -4, -4, -6 }) );
} /* setup() */

/*
* Need to create a shadow to handle multipleing the armour class by
* an obscene value when underwater...
*/
void start_player( object thing ) {
   ::start_player( thing );
//   thing->add_effect( "/std/effects/other/fish_effect", ({ }) );
   thing->add_property( "gills", 1 );
   thing->tactics( "response dodge" );
} /* start_player() */

int lives_in_water() { return 1; }
// --- END [/mnt/home2/grok/lib/std/races/guppy.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/rodent.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/rodent.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628778   Available: 13576132
Inodes: Total: 5242880    Free: 4960135
1084 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/rodent.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628778   Available: 13576132
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/races/rodent_base";

void setup() {
   set_name( "rodent" );
   set_long( "A generic rodent object.\n" );
   set_height( 10 );
   set_weight( 10 );
   set_desc( "a small rodent" );

   set_stats( ({ -4, 8, -4, -4, -6 }) );
} /* setup() */

void new_set_level( mixed *args ) {
   int level;
   object thing;

   if( sizeof(args) < 2 || !args[1] )
      return;

   level = args[ 0 ];
   thing = args[ 1 ];

   level = 1 + ( 2 * args[ 0 ] + random( level ) ) / 10;

   thing->add_ac( "blunt", "blunt", level );
   thing->add_ac( "sharp", "sharp", 2 + level );
   thing->add_ac( "pierce", "pierce", 2 * level );
} /* new_set_level() */

void set_unarmed_attacks( object thing ) {
   int number;

   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = sqrt( number );

   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );

   thing->remove_attack( "bite" );

   thing->add_attack( "bite", 100, ({ number, 5, number }),
      "pierce", "unarmed", 0 );

   thing->tactics( "response dodge" );
} /* set_unarmed_attacks() */
// --- END [/mnt/home2/grok/lib/std/races/rodent.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/dog.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/dog.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628778   Available: 13576132
Inodes: Total: 5242880    Free: 4960135
1353 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/dog.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628778   Available: 13576132
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* Wolf race object. Maniac, June 1994.
 * Copied to dog race ob by Turrican for now.
 * Modified to use new attacks by Ceres. */

inherit "/std/races/carnivore";

void setup() {
   set_name( "dog" );
   set_long( "A street dog. I wouldn't stay too near, it could bite.\n" );
   set_desc( "a nasty dog" );
   set_height( 50 );
   set_weight( 700 );

   set_stats( ({ 4, 10, -2, 6, -4 }) );
} /* setup() */

void new_set_level( mixed *args ) {
   int level;
   object thing;

   if( sizeof(args) < 2 || !args[1] )
      return;

   level = args[ 0 ];
   thing = args[ 1 ];

   thing->add_ac( "blunt", "blunt", 40 );
   thing->add_ac( "sharp", "sharp", 20 );
   thing->add_ac( "pierce", "pierce", 10 );

   thing->add_skill_level( "other.perception", 200 );
} /* setup() */

void set_unarmed_attacks( object thing ) {
   int number;

   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = sqrt( number );

   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );

   thing->remove_attack( "claws" );
   thing->remove_attack( "bite" );

   thing->add_attack( "claws", 100, ({ ( 3 * number ) / 2, 5, number } ),
      "sharp", "unarmed", 0 );
   thing->add_attack( "bite", 50, ({ 3 * number, 2, number }),
      "pierce", "unarmed", 0 );

   thing->tactics( "response dodge" );
} /* set_unarmed_attacks() */
// --- END [/mnt/home2/grok/lib/std/races/dog.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/fish.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/fish.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628777   Available: 13576131
Inodes: Total: 5242880    Free: 4960135
1584 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/fish.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628777   Available: 13576131
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/races/fish_base";

void setup() {
   set_name( "fish" );
   set_long( "Fish,  yes.  A fish.  Nice generic standard fish thing.\n" );
   set_height( 15 );
   set_weight( 40 );
   set_desc( "a fish, the kind with fins" );

   set_stats( ({ -2, 14, -4, -4, -6 }) );
} /* setup() */

void check_water( object player ) {
   if( !environment( player )->query_water() )
      call_out( "do_drown", 4, player );
} /* check_water() */

void do_drown( object player ) {
   int i;

   if( environment( player )->query_water() )
      return;

   tell_room( environment( player ) , player->one_short() + " gasps for "
      "air.\n" );

   i = player->query_max_hp() / 5;
   if( i < 20 ) i = 20;
   player->adjust_hp( -i );

   call_out( "do_drown", 4, player );
} /* do_drown() */

void start_player( object thing ) {
   ::start_player( thing );

   thing->add_property( "gills", 1 );
   thing->add_property("lives in water", 1);
   thing->add_enter_commands( (: check_water :) );
   thing->set_default_position( ({ "lying" }) );
   thing->return_to_default_position( 0 );
} /* start_player() */

void set_unarmed_attacks( object thing ) {
   int number;

   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = 4 + sqrt( number ) / 2;

   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );

   thing->remove_attack( "bite" );

   thing->add_attack( "bite", 100, ({ 2 * number, 5, number }),
      "pierce", "unarmed", 0 );

   thing->tactics( "response dodge" );
} /* set_unarmed_attacks() */

int lives_in_water() { return 1; }
// --- END [/mnt/home2/grok/lib/std/races/fish.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/penguin.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/penguin.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628777   Available: 13576131
Inodes: Total: 5242880    Free: 4960135
353 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/penguin.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628777   Available: 13576131
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/races/bird_base";

void setup() {
   set_name( "penguin" );
   set_long( "Penguins are always rather formal.\n" );
   set_weight( 600 );

   remove_bit( "gizzard" );

   set_stats( ({ 2, 8, -4, -4, -6 }) );
} /* setup() */

string query_desc( object ob ) {
   return "Penguins are always rather formally dressed.\n";
} /* query_desc() */

// --- END [/mnt/home2/grok/lib/std/races/penguin.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/demon.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/demon.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628776   Available: 13576130
Inodes: Total: 5242880    Free: 4960135
1246 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/demon.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628776   Available: 13576130
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/races/demonic";

void setup() {
   set_long( "This is one of the denizens of the Underworld.\n" );
   set_name( "demon" );
   set_height( 250 );
   set_weight( 5000 );
   set_desc( "a nasty-looking demon" );

   add_ac( "fire", "fire", 100 );

   set_stats( ({ 10, 0, -2, 10, 4 }) );
} /* setup() */

void new_set_level( mixed *args ) {
   int level;
   object thing;

   if( sizeof(args) < 2 || !args[1] )
      return;

   level = args[ 0 ];
   thing = args[ 1 ];

   thing->add_skill_level( "other.health", level * 2 );
   thing->add_ac( "blunt", "blunt", level / 2 );
   thing->add_ac( "pierce", "pierce", level / 4 );
   thing->add_ac( "sharp", "sharp", level / 3 );
} /* new_set_level() */

void set_unarmed_attacks( object thing ) {
   int number;

   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = 4 + sqrt( number );

   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );

   thing->remove_attack( "claws" );
   thing->remove_attack( "bite" );

   thing->add_attack( "claws", 75, ({ 2 * number, 8, number }),
      "sharp", "unarmed", 0 );
   thing->add_attack( "bite", 25, ({ 3 * number, 10, number }),
      "pierce", "unarmed", 0 );
} /* set_unarmed_attacks() */
// --- END [/mnt/home2/grok/lib/std/races/demon.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/camel.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/camel.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628776   Available: 13576130
Inodes: Total: 5242880    Free: 4960135
1097 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/camel.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628776   Available: 13576130
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/races/ruminant";

void setup() {
   set_name( "camel" );
   set_long( "The camel is an animal living in desert regions.  It has two "
      "humps, a mean temper and a good eye for numbers.  They are usually "
      "named things like \"You Bastard\", \"Evil-smelling Bugger\" and so "
      "on, something that might seem strange to anyone who hasn't "
      "actually met one of the beasts.\n" );
   set_height( 170 );
   set_weight( 12000 );
   set_desc( "a camel that looks less interested in you than in sand" );

   add_bit( "tail", "tail", ({ 0, 18, 0 }) );
   add_bit( "fore hump", "hump", ({ 0, 75, 0 }) );
   add_bit( "aft hump", "hump", ({ 0, 50, 0 }) );

   inedible += ({ "tail" });  

   add_ac( "blunt", "blunt", 50 );
   add_ac( "pierce", "pierce", 20 );
   add_ac( "sharp", "sharp", 20 );

   add_attack( "bite", 50, ({ 40, 8, 10 }) );
   add_attack( "feet", 50, ({ 60, 10, 40 }) );

   set_stats( ({ 4, 2, 10, 6, 8 }) );
}  /* setup() */

void start_player( object thing ) {
   ::start_player( thing );
   thing->tactics( "response dodge" );
} /* start_player() */
// --- END [/mnt/home2/grok/lib/std/races/camel.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/parrot.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/parrot.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628775   Available: 13576129
Inodes: Total: 5242880    Free: 4960135
1055 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/parrot.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628775   Available: 13576129
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/races/bird_base";

void setup() {
   set_name( "parrot" );
   set_long( "This is a vicious, evil-looking parrot with a glint of mischief "
      "in its eye.\n" );
   set_weight( 25 );
   set_height( 20 );
   set_desc( "an ordinary parrot" );

   add_ac( "feather_blow", "blunt", 10 );
   add_ac( "feather_slash", "sharp", 2 );
   add_ac( "feather_pierce", "pierce", 2 );

   set_stats( ({ 0, 8, -6, -4, -6 }) );
} /* setup() */

void set_unarmed_attacks( object thing ) {
   int number;
  
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = sqrt( number / 4 ) + ( thing->query_weight() / 20 );

   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );

   thing->remove_attack( "beak" );
   thing->remove_attack( "claws" );
   thing->add_attack( "beak", 50, ({ number / 2, 2, number / 2 }),
      "pierce", "unarmed", 0 );
   thing->add_attack( "claws", 75, ({ number, 5, number / 2 }),
      "sharp", "unarmed", 0 );

   thing->tactics( "response dodge" );
} /* set_unarmed_attacks() */// --- END [/mnt/home2/grok/lib/std/races/parrot.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/shadows/fish_shadow.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/shadows/fish_shadow.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628775   Available: 13576129
Inodes: Total: 5242880    Free: 4960135
1023 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/shadows/fish_shadow.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628775   Available: 13576129
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: fish_shadow.c,v 1.1 1998/01/06 04:31:13 ceres Exp $
 * $Log: fish_shadow.c,v $
 * Revision 1.1  1998/01/06 04:31:13  ceres
 * Initial revision
 * 
*/
object my_player;

void init_shadow(object ob) {
  my_player = ob;
  shadow(ob, 1);
}

int query_ac(string type, int dam) {
  int i;

  i = (int)my_player->query_ac(type);
  if (environment(my_player)->query_underwater())
    return i*100;  /* Clossal ac underwater, perhaps should also check to see
                    * if the thing attacking has free action... */
  return i;
}

/*
 * Ok...  Now when we enter a non-underwater area we start to drown.
 */
int move(object ob, string s1, string s2) {
  int i;

  i = (int)my_player->move(ob, s1, s2);
  if (!i && !ob->query_underwater())
    call_out("do_drown", 2);
  else
    remove_call_out("do_drown");
  return i;
}

void do_drown() {
  tell_room(my_player, my_player->one_short()+" gasps for air.\n");
  my_player->adjust_hp(random(50)+50);
  call_out("do_drown", 2);
}
// --- END [/mnt/home2/grok/lib/std/races/shadows/fish_shadow.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/tree_base.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/tree_base.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628774   Available: 13576128
Inodes: Total: 5242880    Free: 4960135
1283 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/tree_base.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628774   Available: 13576128
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/races/base";

void create() {
   do_setup++;
   ::create();
   do_setup--;

   set_desc( "your standard tree.  Shouldn't be used since this is a base "
      "race" );

   bits = ({
      "trunk", "trunk", ({ 0, 1000, 0 }),
      "branch", "branch", ({ 0, 20, ({"/std/bit", 20}) }),
//      "twig", "twig", ({ "branch", 1, ({"/std/bit", 5}) }),
// I wanted to have 5 twigs per branch, but the bit handler won't allow
// me to do this for some reason.
      "root", "root", ({ 0, 20, ({"/std/bit", 10}) })
   });

   inedible = ({ "trunk", "branch", "root" });
   unrottable = ({ });
   set_skin( "bark" );

   if( !do_setup )
      this_object()->setup();
} /* create() */

string *query_target_zones() {
  return ({ "branch", "branch", "branch", "branch", "branch",
            "branch", "branch", "branch", "branch", "branch",
              "trunk", "trunk", "trunk", "trunk", "trunk",
              "trunk", "trunk", "trunk", "trunk", "trunk",
              "base", "base", "base", "base", "root"});
}

string map_target_zone(string zone) {
  switch(zone) {
  case "chest":
  case "abdomen":
  case "back":
    return "trunk";
  case "hands":
  case "neck":
  case "head":
  case "arms":
  case "legs":
    return "branches";
  case "feet":
    return "root";
  }
}
// --- END [/mnt/home2/grok/lib/std/races/tree_base.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/wolf.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/wolf.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628774   Available: 13576128
Inodes: Total: 5242880    Free: 4960135
1281 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/wolf.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628774   Available: 13576128
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* Wolf race object. Maniac, June 1994. */

inherit "/std/races/carnivore";

void setup() {
   set_name( "wolf" );
   set_desc( "a really nasty, hungry looking canine" );
   set_height( 75 );
   set_weight( 1000 );

   set_stats( ({ 6, 12, -4, 8, -4 }) );
} /* setup() */

void new_set_level( mixed *args ) {
   int level;
   object thing;

   if( sizeof(args) < 2 || !args[1] )
      return;

   level = args[ 0 ];
   thing = args[ 1 ];

   level = 2 + ( 2 * level + random( level ) ) / 8;

   thing->add_ac( "blunt", "blunt", 20 + level / 3 );
   thing->add_ac( "sharp", "sharp", 50 + level );
   thing->add_ac( "pierce", "pierce", 60 + 2 * level );
} /* new_set_level() */

void set_unarmed_attacks( object thing ) {
   int number;

   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = 4 + sqrt( number ) / 2;

   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );

   thing->remove_attack( "claws" );
   thing->remove_attack( "bite" );

   thing->add_attack( "claws", 50, ({ ( 5 * number ) / 2, 8, 2 * number }),
      "sharp", "unarmed", 0 );
   thing->add_attack( "bite", 100, ({ 3 * number, 10, ( 3 * number ) / 2 }),
      "pierce", "unarmed", 0 );

   thing->tactics( "response dodge" );
} /* set_unarmed_attacks() */
// --- END [/mnt/home2/grok/lib/std/races/wolf.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/unknown.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/unknown.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628773   Available: 13576127
Inodes: Total: 5242880    Free: 4960135
152 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/unknown.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628773   Available: 13576127
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/races/human";

/* This is just the standard race ... but because of the problem with
   things being inherited, this is needed for now */
// --- END [/mnt/home2/grok/lib/std/races/unknown.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/fox.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/fox.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628773   Available: 13576127
Inodes: Total: 5242880    Free: 4960135
1326 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/fox.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628773   Available: 13576127
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* Fox race object. Asate, September 1998. */

inherit "/std/races/carnivore";

void setup() {
   set_name( "fox" );
   set_long( "A cat-like creature with red fur, hunts small, "
             "animals like mice and rabbits.\n" );
   set_height( 30 );
   set_weight( 400 );
   set_desc( "A small red fox" );

   set_stats( ({ 0, 10, -2, 4, -4 }) );
} /* setup() */

void new_set_level( mixed *args ) {
   int level;
   object thing;

   if( sizeof(args) < 2 || !args[1] )
      return;

   level = args[ 0 ];
   thing = args[ 1 ];

   level = 1 + ( 2 * level + random( level ) ) / 10;

   thing->add_ac( "blunt", "blunt", level );
   thing->add_ac( "sharp", "sharp", 2 + level );
   thing->add_ac( "pierce", "pierce", 2 * level );
} /* new_set_level() */

void set_unarmed_attacks(object thing) {
   int number;

   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = sqrt( number );

   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );

   thing->remove_attack( "bite" );
   thing->remove_attack( "claws" );

   thing->add_attack( "bite", 100, ({ number / 2, 2, number }),
      "pierce", "unarmed", 0 );
   thing->add_attack( "claws", 150, ({ number / 2, 2, number }),
      "sharp", "unarmed", 0 );

   thing->tactics( "response dodge" );
} /* set_unarmed_attacks() */
// --- END [/mnt/home2/grok/lib/std/races/fox.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/chicken.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/chicken.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628773   Available: 13576127
Inodes: Total: 5242880    Free: 4960135
1096 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/chicken.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628773   Available: 13576127
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/races/bird_base";

void setup() {
   set_name( "chicken" );
   set_long( "Chickens.  That's all there is to say.  Chickens, chickens, "
      "chickens, chickens, chickens.  Thank you.\n" );
   set_weight( 80 );
   set_height( 30 );
   set_desc( "an ordinary brain-dead chicken" );

   add_ac( "feather_blow", "blunt", 10 );
   add_ac( "feather_slash", "sharp", 2 );
   add_ac( "feather_pierce", "pierce", 2 );

   set_stats( ({ 0, 8, -6, -4, -6 }) );
} /* setup() */

void set_unarmed_attacks( object thing ) {
   int number;
  
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = sqrt( number / 4 ) + ( thing->query_weight() / 20 );

   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );

   thing->remove_attack( "beak" );
   thing->remove_attack( "claws" );

   thing->add_attack( "beak", 50, ({ number / 2, 2, number / 2 }),
      "pierce", "unarmed", 0 );
   thing->add_attack( "claws", 75, ({ number, 5, number / 2 }),
      "sharp", "unarmed", 0 );

   thing->tactics( "response dodge" );
} /* set_unarmed_attacks() */
// --- END [/mnt/home2/grok/lib/std/races/chicken.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/rabbit.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/rabbit.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628772   Available: 13576126
Inodes: Total: 5242880    Free: 4960135
1090 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/rabbit.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628772   Available: 13576126
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/races/lagomorpha_base";

void setup() {
   set_name( "rabbit" );
   set_long( "A small furry and fluffy rabbit.\n" );
   set_height( 30 );
   set_weight( 25 );
   set_desc( "a cute and fluffy little bunny" );

   set_stats( ({ -3, 8, -4, -5, -6 }) );
} /* setup() */

void new_set_level( mixed *args ) {
   int level;
   object thing;

   if( sizeof(args) < 2 || !args[1] )
      return;

   level = args[ 0 ];
   thing = args[ 1 ];

   thing->add_ac( "blunt", "blunt", level );
   thing->add_ac( "sharp", "sharp", 2 + level );
   thing->add_ac( "pierce", "pierce", 2 * level );
} /* new_set_level() */

void set_unarmed_attacks( object thing ) {
   int number;

   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = sqrt( number ) / 7;

   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );

   thing->remove_attack( "bite" );

   thing->add_attack( "bite", 75, ({ 1, 3, 4 }),
      "pierce", "unarmed", 0 );

   thing->tactics( "response dodge" );
   thing->tactics( "attitude defensive" );
} /* set_unarmed_attacks() */
// --- END [/mnt/home2/grok/lib/std/races/rabbit.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/crocodile.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/crocodile.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628772   Available: 13576126
Inodes: Total: 5242880    Free: 4960135
1150 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/crocodile.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628772   Available: 13576126
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/races/reptile_base";

void setup() {
   set_name( "crocodile" );
   set_long( "Any of several large voracious thick-skinned long-bodied "
      "aquatic reptiles (as of the genus Crocodylus) of tropical and "
      "subtropical waters.\n" );
   set_height( 30 );
   set_weight( 5000 );
   set_desc( "a crocodile, sharp of tooth and vicious of temper." );

   add_ac( "blunt", "blunt", 80 );
   add_ac( "pierce", "pierce", 80 );
   add_ac( "sharp", "sharp", 80 );

   set_stats( ({ 6, 4, -4, 8, -4 }) );
} /* setup() */

void set_unarmed_attacks( object thing ) {
   int number;

   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = sqrt( number );

   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );

   thing->remove_attack( "chew" );
   thing->remove_attack( "tail" );

   thing->add_attack( "chew", 75, ({ 3 * number, number, number }),
      "sharp", "unarmed", 0 );
   thing->add_attack( "tail", 75, ({ number, number, number }),
      "blunt", "unarmed", 0 );

   thing->tactics( "response dodge" );
   thing->tactics( "attitude offensive" );
} /* set_unarmed_attacks() */
// --- END [/mnt/home2/grok/lib/std/races/crocodile.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/duckling.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/duckling.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628771   Available: 13576125
Inodes: Total: 5242880    Free: 4960135
1022 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/duckling.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628771   Available: 13576125
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/races/bird_base";

void setup() {
   set_name( "duckling" );
   set_long( "Awwwwwwww it's SUCH a cute little duckling!\n" );
   set_weight( 10 );
   set_height( 15 );
   set_desc( "an cute ickle duckling" );

   add_ac( "feather_blow", "blunt", 10 );
   add_ac( "feather_slash", "sharp", 2 );
   add_ac( "feather_pierce", "pierce", 2 );

   set_stats( ({ 0, 14, -6, -4, -6 }) );
} /* setup() */

void set_unarmed_attacks( object thing ) {
   int number;
  
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = sqrt( number / 4 ) + ( thing->query_weight() / 20 );

   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );

   thing->remove_attack( "beak" );

   thing->add_attack( "beak", 50, ({ number / 2, 2, number / 2 }),
      "pierce", "unarmed", 0 );
   thing->add_attack( "feet", 75, ({ number, 5, number / 2 }),
      "blunt", "unarmed", 0 );

   thing->tactics( "response dodge" );
} /* set_unarmed_attacks() */

int lives_in_water() { return 1; }
// --- END [/mnt/home2/grok/lib/std/races/duckling.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/insect.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/insect.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628771   Available: 13576125
Inodes: Total: 5242880    Free: 4960135
1244 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/insect.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628771   Available: 13576125
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/races/insect_base";
 
void setup() {
   set_name( "insect" );
   set_long( "A nondescript insect.\n" );
   set_height( 5 );
   set_weight( 2 );
   set_desc( "a nondescript insect" );

   set_stats( ({ -6, 4, -6, -6, -6 }) );
} /* setup() */
 
int query_eat( string type ) {
   return ( member_array( type, inedible ) == -1 );
} /* query_eat() */

void new_set_level( mixed *args ) {
   int level;
   object thing;

   if( sizeof(args) < 2 || !args[1] )
      return;

   level = args[ 0 ];
   thing = args[ 1 ];

   thing->add_skill_level( "other.health", level * 2 );
   thing->add_ac( "blunt", "blunt", level / 2 );
   thing->add_ac( "pierce", "pierce", level / 4 );
   thing->add_ac( "sharp", "sharp", level / 3 );
} /* new_set_level() */

int query_dark( int light ) { return 0; }

void set_unarmed_attacks( object thing ) {
   int number;

   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = 4 + sqrt( number );

   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );

   thing->remove_attack( "bite" );

   thing->add_attack( "bite", 75, ({ 3 * number, 10, number }),
      "pierce", "unarmed", 0 );

   thing->tactics( "response dodge" );
} /* set_unarmed_attacks() */
// --- END [/mnt/home2/grok/lib/std/races/insect.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/panda.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/panda.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628770   Available: 13576124
Inodes: Total: 5242880    Free: 4960135
1282 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/panda.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628770   Available: 13576124
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* Dragonkin, Decembar 1997 */

inherit "/std/races/carnivore";

void setup() {
   set_name( "panda" );
   set_desc( "a black and white fluffy panda" );
   set_height( 200 );
   set_weight( 8000 );

   set_stats( ({ 6, 4, -2, 8, -4 }) );
} /* setup() */

void new_set_level( mixed *args ) {
   int level;
   object thing;

   if( sizeof(args) < 2 || !args[1] )
      return;

   level = args[ 0 ];
   thing = args[ 1 ];

   level = 2 + ( 2 * level + random( level ) ) / 8;

   thing->add_ac( "blunt", "blunt", 20 + level / 3 );
   thing->add_ac( "sharp", "sharp", 50 + level );
   thing->add_ac( "pierce", "pierce", 60 + 2 * level );
} /* new_set_level() */

void set_unarmed_attacks( object thing ) {
   int number;

   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = 4 + sqrt( number ) / 2;

   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );

   thing->remove_attack( "claws" );
   thing->remove_attack( "bite" );

   thing->add_attack( "claws", 100, ({ 2 * number, 10, number }),
      "sharp", "unarmed", 0 );
   thing->add_attack( "bite", 50, ({ 3 * number, 8, number }),
      "pierce", "unarmed", 0 );

   thing->tactics( "response dodge" );
   thing->tactics( "attitude offensive" );
} /* set_unarmed_attacks() */
// --- END [/mnt/home2/grok/lib/std/races/panda.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/lobster.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/lobster.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628770   Available: 13576124
Inodes: Total: 5242880    Free: 4960135
4000 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/lobster.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628770   Available: 13576124
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/races/base";

void setup() {
    set_name( "lobster" );
    set_long( "A cranky lobster.\n" );
    set_height( 10 );
    set_weight( 18 );
    set_desc( "a cranky lobster" );

    bits = ({ 
        "head", "head", ({ 0, 200, 0,
            "left antenna", "right antenna", "left antennule", "right "
            "antennule", "brain", "left eye", "right eye", "left eyestalk",
            "right eyestalk", "jaw", "skull" }),
        "left antenna", "antenna", ({ "head", 2, 0 }),
        "right antenna", "antenna", ({ "head", 2, 0 }),
        "left antennule", "antennule", ({ "head", 1, 0 }),
        "right antennule", "antennule", ({ "head", 1, 0 }),
        "brain", "brain", ({ "head", 50, 0 }),
        "skull", "skull", ({ "head", 50, 0 }),
        "left eye", "eye", ({ "head", 5, 0 }),
        "right eye", "eye", ({ "head", 5, 0 }),
        "left eyestalk", "eyestalk", ({ "head", 2, 0 }),
        "right eyestalk", "eyestalk", ({ "head", 2, 0 }),
        "jaw", "mouth", ({ "head", 25, 0 }),
        "carapace", "carapace", ({ 0, 25, 0 }),
        "thorax", "thorax", ({ 0, 500, 0,
            "left cheliped", "right cheliped", "left second leg",
            "right second leg", "left third leg", "right third leg", "left "
            "fourth leg", "right fourth leg", "left back leg", "right back "
            "leg", "heart", "hepatopancreas", "intestine", "stomach" }),
        "left cheliped", "cheliped", ({ "thorax", 75, 0 }),
        "right cheliped", "cheliped", ({ "thorax", 75, 0 }),
        "left second leg", "leg", ({ "thorax", 50, 0 }),
        "right second leg", "leg", ({ "thorax", 50, 0 }),
        "left third leg", "leg", ({ "thorax", 50, 0 }),
        "right third leg", "leg", ({ "thorax", 50, 0 }),
        "left fourth leg", "leg", ({ "thorax", 50, 0 }),
        "right fourth leg", "leg", ({ "thorax", 50, 0 }),
        "left back leg", "leg", ({ "thorax", 50, 0 }),
        "right back leg", "leg", ({ "thorax", 50, 0 }),
        "heart", "heart", ({ "thorax", 50, 0 }),
        "hepatopancreas", "hepatopancreas", ({ "thorax", 10, 0 }),
        "intestine", "intestine", ({ "thorax", 30, 0 }),
        "stomach", "stomach", ({ "thorax", 30, 0 }),
        "apron", "apron", ({ 0, 100, 0, "left pleopod", "right pleopod" }),
        "left pleopod", "pleopod", ({ "apron", 20, 0 }),
        "right pleopod", "pleopod", ({ "apron", 20, 0 })
    });

    inedible = ({ "jaw", "carapace", "skull" });
    unrottable = ({ "jaw", "carapace", "skull" });
    set_skin( "shell" );

    set_stats( ({ -6, 4, -6, -4, -6 }) );
} /* setup() */
 
int query_eat( string type ) {
   return ( member_array( type, inedible ) == -1 );
} /* query_eat() */


void new_set_level( mixed *args ) {
   int level;
   object thing;

   if( sizeof(args) < 2 || !args[1] )
      return;

   level = args[ 0 ];
   thing = args[ 1 ];

   thing->add_skill_level( "other.health", level * 2 );
   thing->add_ac( "blunt", "blunt", level / 2 );
   thing->add_ac( "pierce", "pierce", level / 4 );
   thing->add_ac( "sharp", "sharp", level / 3 );
} /* new_set_level() */


void set_unarmed_attacks( object thing ) {
    int number;

    number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
    number = 4 + sqrt( number );

    thing->remove_attack( "hands" );
    thing->remove_attack( "feet" );

    thing->remove_attack( "pincers" );

    thing->add_attack( "pincers", 100, ({ number, 10, number }),
        "unarmed", "unarmed", 0 );

    thing->add_attack_message( "pincers", "unarmed", ({
       20, "$N bat$s $I with $p pincer.\n",
       60, "$N nip$s $P $z with $p pincer.\n",
       100, "$N scratch$es $I deeply with $p pincer.\n",
       140, "$N cut$s $P $z deeply with $p pincer.\n",
       180, "$N dig$s $p pincer into $P $z.\n",
       220, "$N gouge$s $I with $p pincer.\n",
       0, "$N slice$s $P $z up with $p pincer.\n" }) );

   thing->tactics( "response dodge" );
   
} /* set_unarmed_attacks() */

int lives_in_water() { return 1; }


// --- END [/mnt/home2/grok/lib/std/races/lobster.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/bat.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/bat.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628769   Available: 13576123
Inodes: Total: 5242880    Free: 4960135
1767 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/bat.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628769   Available: 13576123
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
// Gototh, 01/03/99

inherit "/std/races/rodent_base";

void setup() {
   set_name( "bat" );
   set_long( "This is a small flying rodent." );
   set_desc( "a small, flying rodent" );
   set_height( 20 );
   set_weight( 40 );

   remove_bit( "torso" );
   remove_bit( "left front leg" );
   remove_bit( "right front leg" );
   remove_bit( "left rear leg" );
   remove_bit( "right rear leg" );

   add_bit( "torso", "torso", ({ 0, 20, 0,
      "heart", "liver", "left kidney", "right kidney", "spleen",
      "right lung", "left lung", "right wing", "left wing" }) );
   add_bit( "right wing", "wing", ({ "torso", 20, 0 }) );
   add_bit( "left wing", "wing", ({ "torso", 20, 0 }) );
   add_bit( "left leg", "leg", ({ 0, 5, 0 }) );
   add_bit( "right leg", "leg", ({ 0, 5, 0 }) );

   set_sight( ({ -20, 0, 80, 120 }) );
   set_stats( ({ 0, 14, -4, -4, -6 }) );
} /* setup() */

void new_set_level( mixed *args ) {
   int level;
   object thing;

   if( sizeof(args) < 2 || !args[1] )
      return;

   level = args[ 0 ];
   thing = args[ 1 ];

   thing->add_ac( "blunt", "blunt", level );
   thing->add_ac( "sharp", "sharp", 2 + level );
   thing->add_ac( "pierce", "pierce", 2 * level );
} /* new_set_level() */

void set_unarmed_attacks( object thing ) {
   int number;

   number = thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = sqrt( number ) / 4;

   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );

   thing->remove_attack( "bite" );
   thing->remove_attack( "claws" );

   thing->add_attack( "bite", 75, ({ 0, 3, number }),
      "pierce", "unarmed", 0 );
   thing->add_attack( "claws", 50, ({ 0, 5, number / 2 }),
      "sharp", "unarmed", 0 );

   thing->tactics( "response dodge" );
} /* set_unarmed_attacks() */
// --- END [/mnt/home2/grok/lib/std/races/bat.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/bufonid.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/bufonid.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628768   Available: 13576122
Inodes: Total: 5242880    Free: 4960135
1009 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/bufonid.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628768   Available: 13576122
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/races/humanoid";

void setup() {
   set_name( "bufonid" );
   set_long( "The bufonids are rare species of humanoid toad-like beings.  "
      "It is rumoured that they were created by wizards as part of a "
      "heinous series of experiments of unknown intent and subsequently "
      "escaped from their creators.  Little is known of them, except that "
      "they keep themselves well hidden from humans.\n" );
   set_height( 150 );
   set_weight( 1800 );
   set_desc( "a strange creature, with webbed feet and warty green skin, "
      "that gives you the impression of being a humanoid toad" );

   remove_bit( "left ear" );
   remove_bit( "right ear" );
   remove_bit( "nose" );
   remove_bit( "scalp" );
   remove_bit( "teeth" );

   add_ac( "blunt", "blunt", 15 );
   add_ac( "pierce", "pierce", 12 );
   add_ac( "sharp", "sharp", 10 );

   add_attack( "hands", 75, ({ 40, 5, 10 }) );
   add_attack( "feet", 25, ({ 30, 5, 20 }) );

   set_stats( ({ 2, 2, 0, 2, 0 }) );
} /* setup() */
// --- END [/mnt/home2/grok/lib/std/races/bufonid.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/demonic.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/demonic.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628768   Available: 13576122
Inodes: Total: 5242880    Free: 4960135
29 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/demonic.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628768   Available: 13576122
Inodes: Total: 5242880    Free: 4960135
2025-03-06 11:07:16.346595885 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/races/base.c";
// --- END [/mnt/home2/grok/lib/std/races/demonic.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/ape.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/ape.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628767   Available: 13576121
Inodes: Total: 5242880    Free: 4960135
1602 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/ape.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628767   Available: 13576121
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/races/humanoid";

void setup() {
   set_name( "ape" );
   set_long( "The apes are any members of the family Pongidae of large "
      "semi-erect primates, including the chimpanzee, gorilla, orangutan "
      "and gibbon.\n" );
   set_weight( 2500 );
   set_height( 175 );

   set_stats( ({ 4, 4, 0, 4, 0 }) );
} /* setup() */

int query_eat( string type ) { return 1; }

string query_desc( object thing ) {
   if( (int)thing->query_gender() == 1 )
      return "He is your average hairy young male ape.\n";

   return "She is your average hairy young female ape.\n";
} /* query_desc() */

void new_set_level( mixed *args ) {
   int level;
   object thing;

   if( sizeof(args) < 2 || !args[1] )
      return;

   level = args[ 0 ];
   thing = args[ 1 ];

   thing->add_ac( "blunt", "blunt", 15 + level / 10 );
   thing->add_ac( "sharp", "sharp", 10 + level / 15 );
   thing->add_ac( "pierce", "pierce", 12 + level / 12 );

   thing->reset_all();
} /* new_set_level() */

int query_dark( int light ) {
   if( light < 10 ) return 1;
   if( light > 200 ) return 2;

   return 0;
} /* query_dark() */

void set_unarmed_attacks( object thing ) {
   int number;

   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = 10 + ( 3 * sqrt( number ) ) / 2;

   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );

   thing->add_attack( "hands", 75, ({ 2 * number, 8, number }),
      "blunt", "unarmed", "unarmed_hands" );
   thing->add_attack( "feet", 25, ({ 3 * number, 10, number }),
      "blunt", "unarmed", 0 );
} /* set_unarmed_attacks() */
// --- END [/mnt/home2/grok/lib/std/races/ape.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/rat.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/rat.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628767   Available: 13576121
Inodes: Total: 5242880    Free: 4960135
1298 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/rat.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628767   Available: 13576121
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/races/rodent_base";

void setup() {
   set_name( "rat" );
   set_long( "A rodent of the genus Rattus, distinguished from a mouse "
      "by its larger size and by structural details, as of the teeth.\n" );
   set_height( 15 );
   set_weight( 10 );
   set_desc( "a vicious-looking rat, scurrying about for food." );

   set_stats( ({ -4, 8, -2, -4, -4 }) );
} /* setup() */

void new_set_level( mixed *args ) {
   int level;
   object thing;

   if( sizeof(args) < 2 || !args[1] )
      return;

   level = args[ 0 ];
   thing = args[ 1 ];
   
   thing->add_ac( "blunt", "blunt", level );
   thing->add_ac( "sharp", "sharp", 2 + level );
   thing->add_ac( "pierce", "pierce", 2 * level );
} /* new_set_level() */

void set_unarmed_attacks( object thing ) {
   int number;

   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = sqrt( number );

   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );

   thing->remove_attack( "bite" );
   thing->remove_attack( "claws" );

   thing->add_attack( "bite", 75, ({ 3*number, 3, number }),
      "pierce", "unarmed", 0 );
   thing->add_attack( "claws", 50, ({ 3*number, 5, number / 2 }),
      "sharp", "unarmed", 0 );

   thing->tactics( "response dodge" );
} /* set_unarmed_attacks() */
// --- END [/mnt/home2/grok/lib/std/races/rat.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/wombat.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/wombat.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628766   Available: 13576120
Inodes: Total: 5242880    Free: 4960135
3182 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/wombat.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628766   Available: 13576120
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/races/base";

void setup() {
   set_name( "wombat" );
   set_long( "One of several stocky marsupials (family Vombatidae) "
      "resembling small bears.\n" );
   set_height( 40 );
   set_weight( 600 );
   set_desc( "a stocky wombat, looking for something to nibble" );

   bits = ({ 
      "head", "head", ({ 0, 100, 0,
         "left eye", "right eye", "left ear", "right ear", "skull" }),
      "left eye", "eye", ({ "head", 1, 0 }),
      "right eye", "eye", ({ "head", 1, 0 }),
      "left ear", "ear", ({ "head", 15, 0 }),
      "right ear", "ear", ({ "head", 15, 0 }),
      "skull", "skull", ({ "head", 50, 0, "teeth", "brain" }),
      "brain", "brain", ({ "skull", 30, 0 }),
      "teeth", "teeth", ({ "skull", 1, ({"/std/bit_set", 1}), "tooth" }),
      "tooth", "tooth", ({ "teeth", 1, ({"/std/bit", 18}) }),
      "torso", "torso", ({ 0, 450, 0,
         "heart", "liver", "left kidney", "right kidney", "spleen",
         "right lung", "left lung", "intestine" }),
      "heart", "heart", ({ "torso", 20, 0 }),
      "liver", "liver", ({ "torso", 20, 0 }),
      "left kidney", "kidney", ({ "torso", 10, 0 }),
      "right kidney", "kidney", ({ "torso", 10, 0 }),
      "spleen", "spleen", ({ "torso", 10, 0 }),
      "right lung", "lung", ({ "torso", 20, 0 }),
      "left lung", "lung", ({ "torso", 20, 0 }),
      "intestine", "gut", ({ "torso", 50, 0 }),
      "genitals", "genitals", ({ 0, 5, 0 }),
      "left front leg", "leg", ({ 0, 150, 0, "left front paw" }),
      "left front paw", "paw", ({ "left front leg", 25, 0 }),
      "right front leg", "leg", ({ 0, 150, 0, "right front paw" }),
      "right front paw", "paw", ({ "right front leg", 25, 0 }),
      "left rear leg", "leg", ({ 0, 150, 0, "left rear paw" }),
      "left rear paw", "paw", ({ "left rear leg", 25, 0 }),
      "right rear leg", "leg", ({ 0, 150, 0, "right rear paw" }),
      "right rear paw", "paw", ({ "right rear leg", 25, 0 }),
      "tail", "tail", ({ 0, 25, 0 }),
      "skin", "skin", ({ 0, 175, 0 })
   });

   inedible = ({ "skull", "teeth", "tail", "skin" });
   unrottable = ({ "skull", "teeth" });
   set_skin( "fur" );

   set_stats( ({ 2, 4, -2, 6, -4 }) );
} /* setup() */

void new_set_level( mixed *args ) {
   int level;
   object thing;

   if( sizeof(args) < 2 || !args[1] )
      return;

   level = args[ 0 ];
   thing = args[ 1 ];

   level = 1 + ( 2 * level + random( level ) ) / 10;

   thing->add_ac( "blunt", "blunt", level );
   thing->add_ac( "sharp", "sharp", 2 + level );
   thing->add_ac( "pierce", "pierce", 2 * level );
} /* new_set_level() */

void set_unarmed_attacks( object thing ) {
   int number;

   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = 4 + sqrt( number ) / 2;

   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );

   thing->remove_attack( "chew" );
   thing->remove_attack( "claws" );

   thing->add_attack( "chew", 100, ({ 3 * number, 0, number }),
      "sharp", "unarmed", 0 );
   thing->add_attack( "claws", 50, ({ ( 3 * number ) / 2, number, number }),
      "sharp", "unarmed", 0 );

   thing->tactics( "response dodge" );
} /* set_unarmed_attacks() */
// --- END [/mnt/home2/grok/lib/std/races/wombat.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/bird.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/bird.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628765   Available: 13576119
Inodes: Total: 5242880    Free: 4960135
1320 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/bird.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628765   Available: 13576119
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* Bird race object.  Made by Ceres and stolen from the vulture object.
Modified by Dragonkin for new race system (this race shouldn't exist btw) */

inherit "/std/races/bird_base";

void setup() {
   set_name( "bird" );
   set_long( "A general, unspecified bird.\n" );
   set_height( 15 );
   set_weight( 60 );

   set_stats( ({ 0, 14, -4, -4, -6 }) );
} /* setup() */

void new_set_level( mixed *args ) {
   int weight;
   object thing;

   thing = args[ 1 ];
   if ( !thing )
     return;

   weight = (thing->query_weight() / 20);
  
   thing->add_ac( "blunt", "blunt", weight / 2 );
   thing->add_ac( "pierce", "pierce", weight );
   thing->add_ac( "sharp", "sharp", weight );
} /* new_set_level() */

void set_unarmed_attacks( object thing ) {
   int number;
  
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = sqrt( number / 4 ) + ( thing->query_weight() / 20 );

   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );

   thing->remove_attack( "beak" );
   thing->remove_attack( "claws" );

   thing->add_attack( "beak", 50, ({ number / 2, 2, number / 2 }),
      "pierce", "unarmed", 0 );
   thing->add_attack( "claws", 75, ({ number, 5, number / 2 }),
      "sharp", "unarmed", 0 );

   thing->tactics( "response dodge" );
} /* set_unarmed_attacks() */
// --- END [/mnt/home2/grok/lib/std/races/bird.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/golem.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/golem.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628765   Available: 13576119
Inodes: Total: 5242880    Free: 4960135
4167 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/golem.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628765   Available: 13576119
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/races/humanoid";

#include <armoury.h>

void knock_out( object player, object golem );
void unarmed_hands( int damage, object him, object me, string a_type,
    string a_name );
object make_corpse();


void setup() {
    set_name( "golem" );
    set_long( "Golems are artifical shaped of clay to resemble humanoids and "
        "animated using religious rituals.  If they are actually alive is a "
        "question under constant debate.\n" );
    set_height( 200 );
    set_weight( 40000 );
    set_desc( "a tall, human-shaped creature made of clay" );

    add_property( "no scry", 1 );

    add_ac( "blunt", "pierce", ({150}) );
    add_ac( "pierce", "pierce", ({250}) );
    add_ac( "sharp", "sharp", ({250}) );
    add_ac( "fire", "fire", ({10000}) );
    add_ac( "cold", "cold", ({10000}) );
    add_ac( "acid", "acid", ({10000}) );
    add_ac( "magic", "magic", ({10000}) );

    set_sight( ({ 0, 5, 100, 125 }) );
    set_stats( ({ 30, 10, 0, 40, 0 }) );
} /* void setup() */


varargs int query_ac( string type, int damage, string zone, int amount ) {
    object attacker, weapon;

    if( type == "blunt" )
        return amount;

    attacker = (object)previous_object()->query_attacker();

    if( attacker ) {
        weapon = (object)attacker->query_weapon();
        if( weapon && weapon != attacker )
            weapon->adjust_cond( -(int)weapon->query_cond() / 15 );
    }

    return amount;
} /* varargs int query_ac() */


object make_corpse() {
    object corpse, owner;

    owner = previous_object();
    corpse = ARMOURY->request_item( "golem corpse", 100 );
    all_inventory( owner )->move( corpse );

    return corpse;
} /* object make_corpse() */


void set_unarmed_attacks( object thing ) {
    if( !thing )
        return;
    thing->remove_attack( "hands" );
    thing->remove_attack( "feet" );

    thing->add_attack( "hands", 75, ({ 50, 10, 15 }),
        "blunt", "unarmed", ({ "unarmed_hands", this_object() }) );
} /* void set_unarmed_attacks() */


void unarmed_hands( int damage, object him, object me, string a_type,
    string a_name ) {
    
    // Golems do not kill people.
    if( damage > 130 || damage >= him->query_hp() ) {
        damage = 0;
        knock_out( him, me );
    }
} /* void unarmed_hands() */



/* This should knock the player out of the room, if possible - if there is no
 * suitable exit, he stays in the room.  In any case, he should pass out for
 * 3 - 6 minutes. */
void knock_out( object player, object golem ) {
    object room, target;
    string *all_exits, *no_doors = ({ });
    string exit;
    int i;

    if( !player || !golem )
        return;

    player->stop_all_fight();
    golem->stop_fight( player );

    if( !( room = environment( golem ) ) )
        return;

    all_exits = room->query_dest_dir();
    for( i = 0; i < sizeof( all_exits ); i += 2 )
        if( !room->query_door( all_exits[i], "door" ) )
            no_doors += ({ all_exits[i + 1]  });
    target = load_object( no_doors[ random( sizeof( no_doors ) ) ] );

    tell_object( player,
        golem->the_short() + "' blow lifts you off your feet and hurls "
        "you through the air.\n"
        "You see the world race past you and then the ground approaching very "
        "fast.\n" );
    if( target ) {
        exit = all_exits[ member_array( file_name( target ), all_exits ) - 1 ];
        player->move( target,
            "$N come$s flying through the air from $F in a high arc and "
            "thump$s onto the ground.",
            "$N is lifted off " + player->query_possessive() + " feet by " +
            golem->the_short() + "'s blow and sail$s out of the room "
            "to the " + exit + "." );
    } else
        tell_room( room,
            player->the_short() + " is lifted off " +
            player->query_possessive() + " feet by " +
            golem->the_short() + "'s blow and smashes to the "
            "ground.\n", ({player}) );

    player->set_position( "lying on the ground unconscious" );
    player->add_property( "passed out", 1, ( 150 + random( 150 ) ) );
} /* void knock_out() */


int stone_skinned() {
    return 1;
} /* int stone_skinned() */


// --- END [/mnt/home2/grok/lib/std/races/golem.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/hedgehog.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/hedgehog.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628764   Available: 13576118
Inodes: Total: 5242880    Free: 4960135
1278 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/hedgehog.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628764   Available: 13576118
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* Hedgehog race. Asate, sep 1998. */

inherit "/std/races/carnivore";

void setup() {
   set_name( "hedgehog" );
   set_long( "A snail and worm eating little bugger.\n" );
   set_height( 30 );
   set_weight( 150 );
   set_desc( "A small spiny hedgehog" );

   set_stats( ({ 2, -2, -4, -2, -6 }) );
} /* setup() */

void new_set_level( mixed *args ) {
   int level;
   object thing;

   if( sizeof(args) < 2 || !args[1] )
      return;

   level = args[ 0 ];
   thing = args[ 1 ];

   level = 1 + ( 2 * level + random( level ) ) / 10;

   thing->add_ac( "blunt", "blunt", level );
   thing->add_ac( "sharp", "sharp", 2 + level );
   thing->add_ac( "pierce", "pierce", 2 * level );
} /* new_set_level() */

void set_unarmed_attacks( object thing ) {
   int number;

   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = sqrt( number );

   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );

   thing->remove_attack( "bite" );
   thing->remove_attack( "claws" );

   thing->add_attack( "bite", 100, ({ number / 2, 2, number }),
      "pierce", "unarmed", 0 );
   thing->add_attack( "claws", 150, ({ number / 2, 2, number }),
      "sharp", "unarmed", 0 );

   thing->tactics( "response dodge" );
} /* set_unarmed_attacks() */
// --- END [/mnt/home2/grok/lib/std/races/hedgehog.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/stoat.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/stoat.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628763   Available: 13576117
Inodes: Total: 5242880    Free: 4960135
1331 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/stoat.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628763   Available: 13576117
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* Mustelidae race object. Asate, November 1998. */

inherit "/std/races/mustelidae_base";

void setup() {
   set_name( "stoat" );
   set_long( "A small black and white animal.\n" );
   set_height( 15 );
   set_weight( 30 );
   set_desc( "small brown meateater" );

   set_stats( ({ -2, 8, -2, -4, -4 }) );
} /* setup() */

void new_set_level( mixed *args ) {
   int level;
   object thing;

   if( sizeof(args) < 2 || !args[1] )
      return;

   level = args[ 0 ];
   thing = args[ 1 ];

   level = 1 + ( 2 * level + random( level ) ) / 8;

   thing->add_ac( "blunt", "blunt", 20 + level / 3 );
   thing->add_ac( "sharp", "sharp", 50 + level );
   thing->add_ac( "pierce", "pierce", 60 + 2 * level );
} /* new_set_level() */

void set_unarmed_attacks( object thing ) {
   int number;

   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = 4 + sqrt( number ) / 2;

   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );

   thing->remove_attack( "claws" );
   thing->remove_attack( "bite" );

   thing->add_attack( "claws", 50, ({ ( 4 * number ) / 2, 8, 2 * number }),
      "sharp", "unarmed", 0 );
   thing->add_attack( "bite", 100, ({ 2 * number, 10, ( 3 * number ) /2 }),
      "pierce", "unarmed", 0 );

   thing->tactics( "response dodge" );
} /* set_unarmed_attacks() */
// --- END [/mnt/home2/grok/lib/std/races/stoat.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/shark.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/shark.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628763   Available: 13576117
Inodes: Total: 5242880    Free: 4960135
1597 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/shark.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628763   Available: 13576117
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/races/fish_base";

void setup() {
   set_name( "shark" );
   set_long( "A big mean shark.\n" );
   set_height( 15 );
   set_weight( 8000 );
   set_desc( "a fish, the kind with fins" );

   set_stats( ({ 10, 14, 2, 21, -4 }) );
} /* setup() */


void check_water( object player ) {
   if( player && !environment( player )->query_water() )
      call_out( "do_drown", 4, player );
} /* check_water() */


void do_drown( object player ) {
   int i;

  if(!player || !environment(player) || environment(player)->query_water() )
      return;

   tell_room( environment( player ) , player->one_short() + " gasps for "
      "air.\n" );

   i = player->query_max_hp() / 5;
   if( i < 20 ) i = 20;
   player->adjust_hp( -i );

   call_out( "do_drown", 4, player );
} /* do_drown() */


void start_player( object thing ) {
   ::start_player( thing );

   thing->add_property( "gills", 1 );
   //thing->add_property("lives in water", 1);
   thing->add_enter_commands( (: check_water :) );
   thing->set_default_position( ({ "lying" }) );
   thing->return_to_default_position( 0 );
} /* start_player() */


void set_unarmed_attacks( object thing ) {
   int number;

   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = 4 + sqrt( number ) * 2;

   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "bite" );

   thing->add_attack( "bite", 100, ({ 2 * number, 5, number }),
      "pierce", "unarmed", 0 );

   thing->tactics( "response dodge" );
} /* set_unarmed_attacks() */


//int lives_in_water() { return 1; }
// --- END [/mnt/home2/grok/lib/std/races/shark.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/weasel.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/weasel.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628762   Available: 13576116
Inodes: Total: 5242880    Free: 4960135
1331 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/weasel.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628762   Available: 13576116
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* Mustelidae race object. Asate, November 1998. */

inherit "/std/races/mustelidae_base";

void setup() {
   set_name( "weasel" );
   set_long( "A small brown furred animal.\n" );
   set_height( 15 );
   set_weight( 30 );
   set_desc( "small brown meateater" );

   set_stats( ({ -2, 8, -2, -4, -4 }) );
} /* setup() */

void new_set_level( mixed *args ) {
   int level;
   object thing;

   if( sizeof(args) < 2 || !args[1] )
      return;

   level = args[ 0 ];
   thing = args[ 1 ];

   level = 2 + ( 2 * level + random( level ) ) / 8;

   thing->add_ac( "blunt", "blunt", 20 + level / 3 );
   thing->add_ac( "sharp", "sharp", 50 + level );
   thing->add_ac( "pierce", "pierce", 60 + 2 * level );
} /* new_set_level() */

void set_unarmed_attacks( object thing ) {
   int number;

   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = 4 + sqrt( number ) / 2;

   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );

   thing->remove_attack( "claws" );
   thing->remove_attack( "bite" );

   thing->add_attack( "claws", 50, ({ ( 4 * number ) / 2, 8, 2 * number }),
      "sharp", "unarmed", 0 );
   thing->add_attack( "bite", 100, ({ 2 * number, 10, ( 3 * number ) / 2 }),
      "pierce", "unarmed", 0  );

   thing->tactics( "response dodge" );
} /* set_unarmed_attacks() */
// --- END [/mnt/home2/grok/lib/std/races/weasel.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/tree.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/tree.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628762   Available: 13576116
Inodes: Total: 5242880    Free: 4960135
1889 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/tree.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628762   Available: 13576116
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/races/tree_base";

void setup() {
   set_name( "tree" );
   set_long( "A tree.\n" );
   set_height( 800 );
   set_weight( 40000 );
   set_desc( "a large tree" );

   add_ac( "blunt", "blunt", 500 );
   add_ac( "sharp", "sharp", 50 );
   add_ac( "pierce", "pierce", 250 );
   add_ac( "fire", "fire", 100 );
   add_ac( "sound", "sound", 1000 );
   add_ac( "gas", "gas", 1000 );

   set_stats( ({ 10, -6, -2, 10, 4 }) );
} /* setup() */

void set_unarmed_attacks( object thing ) {
   int number;

   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = 2 + sqrt( number );

   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );

   thing->remove_attack( "branches" );

   thing->add_attack( "branches", 100, ({ number / 2, 10, number }),
      "blunt", "blunt", 0 );

   thing->add_attack_message( "branches", "blunt", ({
      0, "$N swing$s at $I with $p branches",
        20, "$N tap$s $I in the $z with $p branches",
        60, "$N hit$s $I in the $z with $p branches",
        100, "$N bruise$s $P $z with $p branches",
        140, "$N hit$s $I hard in the $z with $p branches",
        180, "$N smash$es $I in the $z with $p branches",
        220, "$N crush$es $P $z with $p branches",
        5000, "$N mash$es $P $z with $p branches" }));
   thing->set_unarmed_parry(1);
} /* set_unarmed_attacks() */

varargs int query_ac( string type, int damage, string zone, int amount ) {
   object attacker, weapon;

   if( ( type != "pierce" ) && ( type != "sharp" ) )
      return amount;

   attacker = (object)previous_object()->query_last_opponent();
   if( attacker ) {
      weapon = (object)attacker->query_last_weapon();
      if( weapon && ( weapon != attacker ) )
         if( !weapon->id( "axe" ) )
            weapon->adjust_cond( -(int)weapon->query_max_cond() / 20 );
   }

   return amount;
} /* query_ac() */
// --- END [/mnt/home2/grok/lib/std/races/tree.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/cat.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/cat.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628761   Available: 13576115
Inodes: Total: 5242880    Free: 4960135
1337 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/cat.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628761   Available: 13576115
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/races/carnivore";

void setup() {
   set_name( "cat" );
   set_long( "A carnivorous mammal (Felis catus) long domesticated and kept "+
         "by man as a pet or for catching rats and mice.\n" );
   set_height( 20 );
   set_weight( 100 );
   set_desc( "a furry cat, on the hunt for a mouse to play with" );

   set_stats( ({ 0, 10, 2, -2, 2 }) );
} /* setup() */

void new_set_level( mixed *args ) {
   int level;
   object thing;

   if( sizeof(args) < 2 || !args[1] )
      return;

   level = args[ 0 ];
   thing = args[ 1 ];

   level = 1 + ( 2 * level + random( level ) ) / 10;

   thing->add_ac( "blunt", "blunt", level );
   thing->add_ac( "sharp", "sharp", 2 + level );
   thing->add_ac( "pierce", "pierce", 2 * level );
} /* new_set_level() */

void set_unarmed_attacks( object thing ) {
   int number;

   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = sqrt( number );

   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );

   thing->remove_attack( "bite" );
   thing->remove_attack( "claws" );

   thing->add_attack( "bite", 100, ({ number, 5, number }),
      "sharp", "unarmed", 0 );
   thing->add_attack( "claws", 150, ({ number / 2, 7, number }),
      "sharp", "unarmed", 0 );

   thing->tactics( "response dodge" );
} /* set_unarmed_attacks() */
// --- END [/mnt/home2/grok/lib/std/races/cat.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/pig.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/pig.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628760   Available: 13576114
Inodes: Total: 5242880    Free: 4960135
1795 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/pig.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628760   Available: 13576114
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*    Pig     *
 *   Gototh   *
 *  30/11/97  */

inherit "/std/races/ruminant";

void setup() {
   set_name( "pig" );
   set_long( "A domesticated mammal, of the swine family.\n" );
   set_desc( "a domesticated mammal, of the swine family" );
   set_weight( 1200 );
   set_height( 50 );

   remove_bit( "nose" );
   remove_bit( "head" );
   remove_bit( "left front leg" );
   remove_bit( "right front leg" );
   remove_bit( "left rear leg" );
   remove_bit( "right rear leg" );

   add_bit( "head", "head", ({ 0, 135, 0,
      "left eye", "right eye", "snout", "skull", "tongue", "left ear",
      "right ear" }) );
   add_bit( "snout", "snout", ({ "head", 12, 0 }) );
   add_bit( "left front trotter", "trotter", ({ 0, 180, 0, "left front hoof" }) );
   add_bit( "right front trotter", "trotter", ({ 0, 180, 0, "right front hoof" }) );
   add_bit( "left rear trotter", "trotter", ({ 0, 180, 0, "left rear hoof" }) );
   add_bit( "right rear trotter", "trotter", ({ 0, 180, 0, "right rear hoof" }) );

         // "tooth", "tooth", ({ "teeth", 1, ({"/std/bit", 18}) }),
   add_bit( "chop", "chop", ({ 0, 1, 0 }) );
   add_bit( "tail", "tail", ({ 0, 1, 0 }) );

   inedible += ({ "left front trotter", "right front trotter",
      "left rear trotter", "right rear trotter" });
   unrottable += ({ "left front trotter", "right front trotter",
      "left rear trotter", "right rear trotter" });

   set_stats( ({ 2, 0, -2, 4, -4 }) );
} /* setup() */

void set_unarmed_attacks( object thing ) {
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "standard" );

   thing->remove_attack( "hoof" );

   thing->add_attack( "hoof", 60, ({ 32, 10, 11 }),
      "blunt", "unarmed", 0 );

   thing->tactics( "response dodge" );
} /* set_unarmed_attacks() */

// --- END [/mnt/home2/grok/lib/std/races/pig.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/vulture.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/vulture.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628760   Available: 13576114
Inodes: Total: 5242880    Free: 4960135
1510 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/vulture.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628760   Available: 13576114
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* Vulture race object.  Made by Presto.  Most of this stuff was nicked
from the chicken object, except for the parts nicked from the caterpillar,
and except for the parts Deutha put in.  Well, one or two of these lines are
mine, anyway! :-b */

inherit "/std/races/bird_base";

void setup() {
   set_name( "vulture" );
   set_long( "A largish, rather scruffy-looking bird with an ugly, "
      "featherless head and a big crooked beak.\n" );
   set_desc( "a somewhat evil-looking old vulture\n" );
   set_height( 40 );
   set_weight( 200 );

   set_stats( ({ 0, 14, -4, 2, -6 }) );
} /* setup() */

void new_set_level( mixed *args ) {
   int level;
   object thing;

   if( sizeof(args) < 2 || !args[1] )
      return;

   level = args[ 0 ];
   thing = args[ 1 ];

   thing->add_ac( "blunt", "blunt", level / 2 );
   thing->add_ac( "pierce", "pierce", level );
   thing->add_ac( "sharp", "sharp", level );
} /* new_set_level() */

void set_unarmed_attacks( object thing ) {
   int number;

   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = sqrt( number ) / 2;

   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );

   thing->remove_attack( "beak" );
   thing->remove_attack( "claws" );

   thing->add_attack( "beak", 50, ({ number / 2, 2, number / 2 }),
      "pierce", "unarmed", 0 );
   thing->add_attack( "claws", 75, ({ number, 5, number / 2 }),
      "sharp", "unarmed", 0 );

   thing->tactics( "response dodge" );
} /* set_unarmed_attacks() */
// --- END [/mnt/home2/grok/lib/std/races/vulture.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/snake.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/snake.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628759   Available: 13576113
Inodes: Total: 5242880    Free: 4960135
3073 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/snake.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628759   Available: 13576113
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/races/reptile_base";

void setup() {
   set_name( "snake" );
   set_long( "Snake, Serpent, Legless thingy that crawls on its belly all "
      "day long.\n" );
   set_height( 5 );
   set_weight( 60 );
   set_desc( "a serpent, the type with no legs but with scales." );
  
   /* throw away reptilian bits and replace totally */
   bits = ({ 
      "head", "head", ({ 0, 50, 0,
         "left eye", "right eye", "poison sac", "tongue", "skull" }),
      "left eye", "eye", ({ "head", 5, 0 }),
      "right eye", "eye", ({ "head", 5, 0 }),
      "poison sac", "sac", ({ "head", 10, 0 }),
      "skull", "skull", ({ "head", 40, 0, "tooth", "brain" }),
      "tooth", "tooth", ({ "skull", 5, ({"/std/bit", 2}) }),
      "brain", "brain", ({ "skull", 10, 0 }),
      "torso", "torso", ({ 0, 600, 0,
         "heart", "liver", "left kidney", "right kidney", "spleen",
         "bladder", "intestine" }),
      "heart", "heart", ({ "torso", 20, 0 }),
      "liver", "liver", ({ "torso", 20, 0 }),
      "left lung", "lung", ({ "torso", 20, 0 }),
      "right lung", "lung", ({ "torso", 20, 0 }),
      "left kidney", "kidney", ({ "torso", 10, 0 }),
      "right kidney", "kidney", ({ "torso", 10, 0 }),
      "spleen", "spleen", ({ "torso", 10, 0 }),
      "bladder", "bladder", ({ "torso", 10, 0 }),
      "intestine", "gut", ({ "torso", 100, 0 }),
      "genitals", "genitals", ({ 0, 5, 0 }),
      "tail", "tail", ({ 0, 500, 0 }),
      "skin", "skin", ({ 0, 175, 0 })
   });

   inedible = ({ "poison sac", "tooth" });
   unrottable = ({ "tooth" });

   add_ac( "blunt", "blunt", 40 );
   add_ac( "sharp", "sharp", 20 );
   add_ac( "pierce", "pierce", 10 );

   set_stats( ({ 0, 0, -4, 4, -4 }) );
} /* setup() */
     
void set_unarmed_attacks( object thing ) {
   int number;

   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = sqrt( number );

   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );

   thing->remove_attack( "bite" );
   thing->remove_attack( "crush" );

   thing->add_attack( "bite", 75, ({ ( 3 * number ) / 2, 5, number * 2 }),
      "pierce", "unarmed", 0 );
   thing->add_attack( "squeeze", 50, ({ 3 * number, 2, number }),
      "blunt", "unarmed", 0 );

   thing->add_attack_message( "squeeze", "unarmed", ({
     0, "$N attempt$s to wrap $oself around $P $z",
      40, "$N wrap$s $oself around $P $z and squeeze$s",
      80, "$N wrap$s $oself tightly around $P $z and squeeze$s",
      120, "$N wrap$s $oself tightly around $P $z and squeeze$s firmly",
      160, "$N wrap$s $oself around $P $z and squeeze$s tightly, crushing "
           "$I in $p grip",
      0, "$N wrap$s tightly around $I and crush$es $I to a pulp" }) );

   thing->tactics( "response dodge" );
} /* set_unarmed_attacks() */

string *query_target_zones() {
  return ({ "head", "body", "body", "body", "tail", "tail", "tail" });
}

string map_target_zone(string zone) {
  switch(zone) {
  case "head":
    return "head";
  case "neck":
  case "chest":
    return "body";
  default:
    return "tail";
  }
}
// --- END [/mnt/home2/grok/lib/std/races/snake.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/lagomorpha_base.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/lagomorpha_base.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628758   Available: 13576112
Inodes: Total: 5242880    Free: 4960135
3212 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/lagomorpha_base.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628758   Available: 13576112
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* This is the base race inherit for lagomorpha, that is rabbits,
 * hares and pikas.
 * Danbala, 2003
 */
inherit "/std/races/base";

void create() {
   do_setup++;
   ::create();
   do_setup--;

   set_desc( "a generic lagomorph animal.  It shouldn't be used since "
      "this is just a base race" );

   bits = ({ 
      "head", "head", ({ 0, 40, 0,
         "left eye", "right eye", "left ear", "right ear", "skull" }),
      "left eye", "eye", ({ "head", 1, 0 }),
      "right eye", "eye", ({ "head", 1, 0 }),
      "left ear", "ear", ({ "head", 20, 0 }),
      "right ear", "ear", ({ "head", 20, 0 }),
      "skull", "skull", ({ "head", 20, 0, "brain", "teeth" }),
      "brain", "brain", ({ "skull", 10, 0 }),
      "teeth", "teeth", ({ "skull", 5, ({"/std/bit_set", 1}), "tooth" }),
      "tooth", "tooth", ({ "teeth", 1, ({"/std/bit", 20}) }),
      "torso", "torso", ({ 0, 100, 0,
         "heart", "liver", "left kidney", "right kidney", "spleen",
         "right lung", "left lung", "intestine" }),
      "heart", "heart", ({ "torso", 15, 0 }),
      "liver", "liver", ({ "torso", 15, 0 }),
      "left kidney", "kidney", ({ "torso", 10, 0 }),
      "right kidney", "kidney", ({ "torso", 10, 0 }),
      "spleen", "spleen", ({ "torso", 10, 0 }),
      "right lung", "lung", ({ "torso", 15, 0 }),
      "intestine", "gut", ({ "torso", 100, 0 }),
      "genitalia", "genitalia", ({ 0, 5, 0 }),
      "left front leg", "leg", ({ 0, 100, 0, "left front paw" }),
      "left front paw", "paw", ({ "left front leg", 30, 0 }),
      "right front leg", "leg", ({ 0, 100, 0, "right front paw" }),
      "right front paw", "paw", ({ "right front leg", 30, 0 }),
      "left rear leg", "leg", ({ 0, 300, 0, "left rear paw" }),
      "left rear paw", "paw", ({ "left rear leg", 50, 0 }),
      "right rear leg", "leg", ({ 0, 300, 0, "right rear paw" }),
      "right rear paw", "paw", ({ "right rear leg", 50, 0 }),
      "tail", "tail", ({ 0, 25, 0 }),
      "skin", "skin", ({ 0, 175, 0 })
   });

   inedible = ({ "skull", "teeth", "tooth", "tail", "skin" });
   unrottable = ({ "skull", "teeth", "tooth" });
   set_skin( "fur" );

   if( !do_setup )
      this_object()->setup();
} /* create() */

string *query_target_zones() {
  return ({ "head", "head", "neck",
              "chest", "back", "back", "back", "lower back", 
              "left front leg", "left front leg", "left front paw",
              "stomach", "stomach", "tail",
              "right front leg", "right front leg", "right front paw",
              "left rear leg", "left rear leg", "left rear paw",
              "right rear leg", "right rear leg", "right rear paw"});
} /* query_target_zones() */

string map_target_zone(string zone) {
  switch(zone) {
  case "chest":
    return random(4) ? "back" : "chest";
  case "abdomen":
    return random(4) ? "stomach" : "lower back";
  case "arms":
    return (random(2) ? "left " : "right ") + "front leg";
  case "hands":
    return (random(2) ? "left " : "right ") + "front paw";
  case "legs":
    return (random(2) ? "left " : "right ") + "rear leg";
  case "feet":
    return (random(2) ? "left " :"right ") + "rear paw";
  default:
    return zone;
  }
} /* map_target_zone() */
// --- END [/mnt/home2/grok/lib/std/races/lagomorpha_base.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/carnivore.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/carnivore.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628757   Available: 13576111
Inodes: Total: 5242880    Free: 4960135
3703 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/carnivore.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628757   Available: 13576111
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/races/base";

void create() {
   do_setup++;
   ::create();
   do_setup--;

   set_weight( 700 );
   set_height( 50 );
   set_desc( "your standard carnivore.  This should not be used as it is a "
      "base race" );

   bits = ({
      "head", "head", ({ 0, 40, 0,
         "left eye", "right eye", "nose", "skull", "left ear", "right ear",
         "tongue" }),
      "left eye", "eye", ({ "head", 1, 0 }),
      "right eye", "eye", ({ "head", 1, 0 }),
      "skull", "cranium", ({ "head", 20, 0, "brain", "teeth" }),
      "brain", "brain", ({ "skull", 20, 0 }),
      "left ear", "ear", ({"head", 1, 0 }),
      "right ear", "ear", ({"head", 1, 0 }),
      "nose", "nose", ({ "head", 3, 0 }),
      "teeth", "teeth", ({ "skull", 3, ({"/std/bit_set", 1}), "tooth" }),
      "tooth", "tooth", ({ "teeth", 1, ({"/std/bit", 48}) }),
      "tongue", "tongue", ({ "head", 2, 0 }),
      "neck", "neck", ({ 0, 15, 0 }),
      "torso", "body", ({ 0, 350, 0,
         "heart", "liver", "left kidney", "right kidney", "left lung",
         "right lung", "spleen", "intestine", "pancreas" }),
      "heart", "heart", ({ "torso", 10, 0 }),
      "liver", "liver", ({ "torso", 5, 0 }),
      "left kidney", "kidney", ({ "torso", 5, 0 }),
      "right kidney", "kidney", ({ "torso", 5, 0 }),
      "left lung", "lung", ({ "torso", 10, 0 }),
      "right lung", "lung", ({ "torso", 10, 0 }),
      "spleen", "spleen", ({ "torso", 5, 0 }),
      "intestine", "gut", ({ "torso", 15, 0 }),
      "pancreas", "pancreas", ({ "torso", 5, 0 }),
      "genitals", "genitals", ({ 0, 5, 0 }),
      "left front leg", "leg", ({ 0, 130, 0, "left front paw" }),
      "left front paw", "paw", ({ "left front leg", 30, 0, "claw" }),
      "claw", "claw", ({ "left front paw", 1, ({"/std/bit", 4}) }),
      "right front leg", "leg", ({ 0, 130, 0, "right front paw" }),
      "right front paw", "paw", ({ "right front leg", 30, 0, "claw" }),
      "claw", "claw", ({ "right front paw", 1, ({"/std/bit", 4}) }),
      "left rear leg", "leg", ({ 0, 275, 0, "left rear paw" }),
      "left rear paw", "paw", ({ "left rear leg", 30, 0, "claw" }),
      "claw", "claw", ({ "left rear paw", 1, ({"/std/bit", 4}) }),
      "right rear leg", "leg", ({ 0, 275, 0, "right rear paw" }),
      "right rear paw", "paw", ({ "right rear leg", 30, 0, "claw" }),
      "claw", "claw", ({ "right rear paw", 1, ({"/std/bit", 4}) }),
      "tail", "tail", ({ 0, 18, 0 }),
      "skin", "skin", ({ 0, 175, 0 })
   });

   inedible = ({ "skull", "claw", "tail", "teeth", "tooth", "skin" });
   unrottable = ({ "skull", "claw", "teeth", "tooth" });
   set_skin( "pelt" );

   set_stats( ({ 6, 10, -2, 6, -4 }) );

   if( !do_setup )
      this_object()->setup();
} /* create() */

string *query_target_zones() {
  return ({ "head", "head", "neck",
              "chest", "back", "back", "back", "lower back", 
              "left front leg", "left front leg", "left front paw",
              "stomach", "stomach", "tail",
              "right front leg", "right front leg", "right front paw",
              "left rear leg", "left rear leg", "left rear paw",
              "right rear leg", "right rear leg", "right rear paw"});
}

string map_target_zone(string zone) {
  switch(zone) {
  case "chest":
    return random(4) ? "back" : "chest";
  case "abdomen":
    return random(4) ? "stomach" : "lower back";
  case "arms":
    return (random(2) ? "left " : "right ") + "front leg";
  case "hands":
    return (random(2) ? "left " : "right ") + "front paw";
  case "legs":
    return (random(2) ? "left " : "right ") + "rear leg";
  case "feet":
    return (random(2) ? "left " :"right ") + "rear paw";
  default:
    return zone;
  }
}
// --- END [/mnt/home2/grok/lib/std/races/carnivore.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/humanoid.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/humanoid.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628756   Available: 13576110
Inodes: Total: 5242880    Free: 4960135
5032 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/humanoid.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628756   Available: 13576110
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/races/base";

void create() {
   do_setup++;
   ::create();
   do_setup--;

   set_desc( "a humanoid-type being.  This should not be used since it is a "
      "base race" );

   bits = ({
      "head", "head", ({ 0, 40, 0,
         "left ear", "right ear", "left eye", "right eye", "nose", "scalp",
         "tongue", "skull" }),
      "left ear", "ear", ({ "head", 1, 0 }),
      "right ear", "ear", ({ "head", 1, 0 }),
      "left eye", "eye", ({ "head", 1, 0 }),
      "right eye", "eye", ({ "head", 1, 0 }),
      "nose", "nose", ({ "head", 1, 0 }),
      "scalp", "scalp", ({ "head", 3, 0 }),
      "tongue", "tongue", ({ "head", 2, 0 }),
      "skull", "skull", ({ "head", 20, 0, "teeth", "brain" }),
      "brain", "brain", ({ "skull", 40, 0 }),
      "teeth", "teeth", ({ "skull", 2, ({"/std/bit_set", 1}), "tooth" }),
      "tooth", "tooth", ({ "teeth", 1, ({"/std/bit", 32}) }),
      "left arm", "arm", ({ 0, 80, 0, "left hand" }),
      "right arm", "arm", ({ 0, 80, 0, "right hand" }),
      "torso", "torso", ({ 0, 400, 0,
         "heart", "liver", "left kidney", "right kidney", "left lung",
         "right lung", "spleen", "rib" }),
      "left hand", "hand", ({ "left arm", 15, 0,
         "left little finger", "left third finger", "left index finger",
         "left ring finger", "left thumb" }),
      "right hand", "hand", ({ "right arm", 15, 0,
         "right little finger", "right third finger", "right index finger",
         "right ring finger", "right thumb" }),
      "left little finger", "finger", ({ "left hand", 1, 0 }),
      "left third finger", "finger", ({ "left hand", 1, 0 }),
      "left index finger", "finger", ({ "left hand", 1, 0 }),
      "left ring finger", "finger", ({ "left hand", 1, 0 }),
      "left thumb", "thumb", ({ "left hand", 1, 0 }),
      "right little finger", "finger", ({ "right hand", 1, 0 }),
      "right third finger", "finger", ({ "right hand", 1, 0 }),
      "right index finger", "finger", ({ "right hand", 1, 0 }),
      "right ring finger", "finger", ({ "right hand", 1, 0 }),
      "right thumb", "thumb", ({ "right hand", 1, 0 }),
      "heart", "heart", ({ "torso", 10, 0 }),
      "liver", "liver", ({ "torso", 5, 0 }),
      "left kidney", "kidney", ({ "torso", 5, 0 }),
      "right kidney", "kidney", ({ "torso", 5, 0 }),
      "left lung", "lung", ({ "torso", 5, 0 }),
      "right lung", "lung", ({ "torso", 5, 0 }),
      "spleen", "spleen", ({ "torso", 5, 0 }),
      "rib", "rib", ({ "torso", 1, ({"/std/bit", 16}) }),
      "genitals", "genitals", ({ 0 , 5, ({"/std/bit_set", 1}), "genitals" }),
      "left leg", "leg", ({ 0, 300, 0, "left foot", "left femur" }),
      "right leg", "leg", ({ 0, 300, 0, "right foot", "right femur" }),
      "left femur", "femur", ({ "left leg", 1, 0 }),
      "right femur", "femur", ({ "right leg", 1, 0 }),
      "left foot", "foot", ({ "left leg", 50, 0,
         "left big toe", "left second toe", "left third toe",
         "left fourth toe", "left little toe" }),
      "right foot", "foot", ({ "right leg", 50, 0,
         "right big toe", "right second toe", "right third toe",
         "right fourth toe", "right little toe" }),
      "right little toe", "toe", ({ "right foot", 1, 0 }),
      "right second toe", "toe", ({ "right foot", 1, 0 }),
      "right third toe", "toe", ({ "right foot", 1, 0 }),
      "right fourth toe", "toe", ({ "right foot", 1, 0 }),
      "right big toe", "toe", ({ "right foot", 1, 0 }),
      "left little toe", "toe", ({ "left foot", 1, 0 }),
      "left second toe", "toe", ({ "left foot", 1, 0 }),
      "left third toe", "toe", ({ "left foot", 1, 0 }),
      "left fourth toe", "toe", ({ "left foot", 1, 0 }),
      "left big toe", "toe", ({ "left foot", 1, 0 }),
      "skin", "skin", ({ 0, 175, 0 })
   });

   inedible = ({ "skull", "teeth", "tooth", "rib", "left femur", "right femur" });
   unrottable = ({ "skull", "teeth", "tooth", "rib", "left femur", "right femur" });
   set_skin( "skin" );

   if( !do_setup )
      this_object()->setup();
} /* create() */

/**
 * So that all races that inherit this one are marked as humanoids.
 * @return 1 if the race is a humanoid, 0 if not
 */
int query_humanoid() {
   return 1;
} /* query_humanoid() */

string *query_target_zones() {
  return ({ "head", "head", "neck",
              "chest", "chest", "chest", "chest", "back", 
              "left arm", "left arm", "left hand",
              "stomach", "stomach", "stomach",
              "right arm", "right arm", "right hand",
              "left leg", "left leg", "left foot",
              "right leg", "right leg", "right foot"});
}

string map_target_zone(string zone) {
  switch(zone) {
  case "abdomen":
    return "stomach";
  case "arms":
    return (random(2) ? "left " : "right ") + "arm";
  case "hands":
    return (random(2) ? "left " : "right ") + "hand";
  case "legs":
    return (random(2) ? "left " : "right ") + "leg";
  case "feet":
    return (random(2) ? "left " :"right ") + "foot";
  default:
    return zone;
  }
}
// --- END [/mnt/home2/grok/lib/std/races/humanoid.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/imp.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/imp.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628755   Available: 13576109
Inodes: Total: 5242880    Free: 4960135
1178 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/imp.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628755   Available: 13576109
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/races/demonic";

void setup() {
   set_long( "This is one of the smaller denizens of the Underworld.\n" );
   set_name( "imp" );
   set_height( 50 );
   set_weight( 400 );
   set_desc( "a crafty-looking imp" );

   set_stats( ({ 2, 8, 2, 2, 2 }) );
} /* setup() */

void new_set_level( mixed *args ) {
   int level;
   object thing;

   if( sizeof(args) < 2 || !args[1] )
      return;

   level = args[ 0 ];
   thing = args[ 1 ];

   thing->add_skill_level( "other.health", level * 4 );
   thing->add_ac( "blunt", "blunt", level / 4 );
   thing->add_ac( "pierce", "pierce", level / 8 );
   thing->add_ac( "sharp", "sharp", level / 6 );
} /* new_set_level() */

void set_unarmed_attacks( object thing ) {
   int number;

   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = 6 + sqrt( number );

   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );

   thing->add_attack( "hands", 75, ({ 2 * number, 8, number }),
      "blunt", "unarmed", 0 );
   thing->add_attack( "feet", 25, ({ 3 * number, 10, number }),
      "blunt", "unarmed", 0 );

   thing->tactics( "response dodge" );
} /* set_unarmed_attacks() */
// --- END [/mnt/home2/grok/lib/std/races/imp.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/moose.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/moose.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628754   Available: 13576108
Inodes: Total: 5242880    Free: 4960135
1328 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/moose.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628754   Available: 13576108
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/races/ruminant";

void setup() {
   mixed *new_head;

   set_name( "moose" );
   set_long( "The moose is a large woodland animal.\n" );
   set_height( 200 );
   set_weight( 7000 );
   set_desc( "a large, hairy quadruped reminding you very much of a moose" );

   new_head = query_bit( "head" );
   new_head[ 2 ] += ({ "left horn", "right horn" });
   remove_bit( "head" );
   add_bit( "head", "head", new_head[ 2 ] );
   add_bit( "left horn", "horn", ({ "head", 20, 0 }) );
   add_bit( "right horn", "horn", ({ "head", 20, 0 }) );
   add_bit( "tail", "tail", ({ 0, 15, 0 }) );

   inedible += ({"left horn", "right horn", "tail" });  
   unrottable += ({ "left horn", "right horn" });

   add_ac( "blunt", "blunt", 50 );
   add_ac( "pierce", "pierce", 20 );
   add_ac( "sharp", "sharp", 20 );

   set_stats( ({ 4, -2, -4, 8, -4 }) );
}  /* setup() */

void set_unarmed_attacks( object thing ) {
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "standard" );

   thing->remove_attack( "chew" );
   thing->remove_attack( "hoof" );

   thing->add_attack( "chew", 20, ({ 40, 8, 10 }), 
      "sharp", "unarmed", 0 );
   thing->add_attack( "hoof", 50, ({ 60, 10, 40 }), 
      "blunt", "unarmed", 0 );

   thing->tactics( "response dodge" );
} /* set_unarmed_attacks() */
// --- END [/mnt/home2/grok/lib/std/races/moose.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/crab.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/crab.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628754   Available: 13576108
Inodes: Total: 5242880    Free: 4960135
3976 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/crab.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628754   Available: 13576108
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/races/base";

void setup() {
    set_name( "crab" );
    set_long( "A scuttling crab.\n" );
    set_height( 10 );
    set_weight( 18 );
    set_desc( "a scuttling crab" );

    bits = ({ 
        "head", "head", ({ 0, 200, 0,
            "left antenna", "right antenna", "left antennule", "right "
            "antennule", "brain", "left eye", "right eye", "left eyestalk",
            "right eyestalk", "jaw", "skull" }),
        "left antenna", "antenna", ({ "head", 2, 0 }),
        "right antenna", "antenna", ({ "head", 2, 0 }),
        "left antennule", "antennule", ({ "head", 1, 0 }),
        "right antennule", "antennule", ({ "head", 1, 0 }),
        "brain", "brain", ({ "head", 50, 0 }),
        "skull", "skull", ({ "head", 50, 0 }),
        "left eye", "eye", ({ "head", 5, 0 }),
        "right eye", "eye", ({ "head", 5, 0 }),
        "left eyestalk", "eyestalk", ({ "head", 2, 0 }),
        "right eyestalk", "eyestalk", ({ "head", 2, 0 }),
        "jaw", "mouth", ({ "head", 25, 0 }),
        "carapace", "carapace", ({ 0, 25, 0 }),
        "thorax", "thorax", ({ 0, 500, 0,
            "left cheliped", "right cheliped", "left second leg",
            "right second leg", "left third leg", "right third leg", "left "
            "fourth leg", "right fourth leg", "left back leg", "right back "
            "leg", "heart", "hepatopancreas", "intestine", "stomach" }),
        "left cheliped", "cheliped", ({ "thorax", 75, 0 }),
        "right cheliped", "cheliped", ({ "thorax", 75, 0 }),
        "left second leg", "leg", ({ "thorax", 50, 0 }),
        "right second leg", "leg", ({ "thorax", 50, 0 }),
        "left third leg", "leg", ({ "thorax", 50, 0 }),
        "right third leg", "leg", ({ "thorax", 50, 0 }),
        "left fourth leg", "leg", ({ "thorax", 50, 0 }),
        "right fourth leg", "leg", ({ "thorax", 50, 0 }),
        "left back leg", "leg", ({ "thorax", 50, 0 }),
        "right back leg", "leg", ({ "thorax", 50, 0 }),
        "heart", "heart", ({ "thorax", 50, 0 }),
        "hepatopancreas", "hepatopancreas", ({ "thorax", 10, 0 }),
        "intestine", "intestine", ({ "thorax", 30, 0 }),
        "stomach", "stomach", ({ "thorax", 30, 0 }),
        "apron", "apron", ({ 0, 100, 0, "left pleopod", "right pleopod" }),
        "left pleopod", "pleopod", ({ "apron", 20, 0 }),
        "right pleopod", "pleopod", ({ "apron", 20, 0 })
    });

    inedible = ({ "jaw", "carapace", "skull" });
    unrottable = ({ "jaw", "carapace", "skull" });
    set_skin( "shell" );

    set_stats( ({ -6, 4, -6, -4, -6 }) );
} /* setup() */
 
int query_eat( string type ) {
   return ( member_array( type, inedible ) == -1 );
} /* query_eat() */


void new_set_level( mixed *args ) {
   int level;
   object thing;

   if( sizeof(args) < 2 || !args[1] )
      return;

   level = args[ 0 ];
   thing = args[ 1 ];

   thing->add_skill_level( "other.health", level * 2 );
   thing->add_ac( "blunt", "blunt", level / 2 );
   thing->add_ac( "pierce", "pierce", level / 4 );
   thing->add_ac( "sharp", "sharp", level / 3 );
} /* new_set_level() */


void set_unarmed_attacks( object thing ) {
    int number;

    number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
    number = 4 + sqrt( number );

    thing->remove_attack( "hands" );
    thing->remove_attack( "feet" );

    thing->remove_attack( "pincers" );

    thing->add_attack( "pincers", 100, ({ number, 10, number }),
        "unarmed", "unarmed", 0 );

    thing->add_attack_message( "pincers", "unarmed", ({
       20, "$N bat$s $I with $p pincer",
       60, "$N nip$s $P $z with $p pincer",
       100, "$N scratch$es $I deeply with $p pincer",
       140, "$N cut$s $P $z deeply with $p pincer",
       180, "$N dig$s $p pincer into $P $z",
       220, "$N gouge$s $I with $p pincer",
       0, "$N slice$s $P $z up with $p pincer" }) );

   thing->tactics( "response dodge" );
   
} /* set_unarmed_attacks() */

int lives_in_water() { return 1; }


// --- END [/mnt/home2/grok/lib/std/races/crab.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/gnome.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/gnome.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628753   Available: 13576107
Inodes: Total: 5242880    Free: 4960135
530 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/gnome.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628753   Available: 13576107
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/races/humanoid";
 
void setup() {
   set_name( "gnome" );
   set_long( "This is the race for gnomes.\n" );
   set_desc( "a short-looking gnome" );
   set_weight( 25 );
   set_height( 20 );

   set_sight( ({ 0, 5, 150, 200 }) );
   set_stats( ({ -2, 8, 0, 6, 0 }) );
} /* setup() */
 
/* 
int query_skill_bonus( int lvl, string skill ) {
   if( skill == "other.valueing.gems" )
      return 30 + random( 70 );
   if( skill == "other.woodland" )
      return 10 + random( 50 );

   return 0;
}  query_skill_bonus() */
// --- END [/mnt/home2/grok/lib/std/races/gnome.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/arachnid.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/arachnid.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628752   Available: 13576106
Inodes: Total: 5242880    Free: 4960135
2738 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/arachnid.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628752   Available: 13576106
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  Arachnid  *
 *   Gototh   *
 *  23/11/97  */

inherit "/std/races/base";

void create() {
   do_setup++;
   ::create();
   do_setup--;

   set_desc( "A creature like scorpion, spider, daddy longlegs, mite, "
      "tick, and certain other invertebrate animals.  This file should "
      "be inherited by a more specialised race object." );

   bits = ({
      "cephalothorax", "head", ({ 0, 200, 0,
         "middle right upper eye", "middle right lower eye",
         "middle left upper eye", "middle left lower eye",
         "right upper eye", "right lower eye",
         "left upper eye", "left lower eye", "brain", "ganglion",
         "left fang", "right fang", "stomach", "mandible" }),
      "middle right upper eye", "eye", ({ "cephalothorax", 25, 0 }),
      "middle right lower eye", "eye", ({ "cephalothorax", 25, 0 }),
      "middle left upper eye", "eye", ({ "cephalothorax", 25, 0 }),
      "middle left lower eye", "eye", ({ "cephalothorax", 25, 0 }),
      "right upper eye", "eye", ({ "cephalothorax", 25, 0 }),
      "right lower eye", "eye", ({ "cephalothorax", 25, 0 }),
      "left upper eye", "eye", ({ "cephalothorax", 25, 0 }),
      "left lower eye", "eye", ({ "cephalothorax", 25, 0 }),
      "brain", "brain", ({ "cephalothorax", 25, 0 }),
      "ganglion", "ganglion", ({ "cephalothorax", 50, 0 }),
      "left fang", "fang", ({ "cephalothorax", 25, 0 }),
      "right fang", "fang", ({ "cephalothorax", 25, 0 }),
      "stomach", "stomach", ({ "cephalothorax", 50, 0 }),
      "mandible", "mandible", ({ "cephalothorax", 25, 0 }),
      "abdomen", "abdomen", ({ 0, 500, 0, "lung", "stomach", 
         "heart", "right front leg", "right middle front leg", 
         "left front leg", "left middle front leg", "right back leg", 
         "right middle back leg", "left back leg", "left middle back leg" }),
      "left middle back leg", "leg", ({ "abdomen", 25, 0 }),
      "left back leg", "leg", ({ "abdomen", 25, 0 }),
      "right middle back leg", "leg", ({ "addomen", 25, 0 }),
      "right back leg", "leg", ({ "abdomen", 25, 0 }),
      "right middle front leg", "leg", ({ "abdomen", 25, 0 }),
      "right front leg", "leg", ({ "abdomen", 25, 0 }),
      "left middle front leg", "leg", ({ "abdomen", 25, 0 }),
      "left front leg", "leg", ({ "abdomen", 25, 0 }),
      "lung", "lung", ({ "abdomen", 100, 0 }),
      "stomach", "stomach", ({ "abdomen", 100, 0 }),
      "heart", "heart", ({ "abdomen", 100, 0 }),
      "pedicel", "pedicel", ({ 0, 100, 0 })
   });

   inedible = ({ "left fang", "right fang", "mandible" });
   unrottable = ({ "left fang", "right fang", "mandible" });

   set_stats( ({ -6, 4, -6, -6, -6 }) );

   if( !do_setup )
      this_object()->setup();
} /* create() */
// --- END [/mnt/home2/grok/lib/std/races/arachnid.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/reptile.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/reptile.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628751   Available: 13576105
Inodes: Total: 5242880    Free: 4960135
888 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/reptile.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628751   Available: 13576105
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/races/reptile_base";

void setup() {
   set_name( "reptile" );
   set_long( "A normal reptile, wiv scales on.\n" );
   set_weight( 1000 );
   set_height( 20 );
   set_desc( "your standard reptile" );

   set_stats( ({ -2, 2, -4, -2, -6 }) );
} /* setup() */

void set_unarmed_attacks( object thing ) {
   int number;

   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = sqrt( number );

   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );

   thing->remove_attack( "chew" );
   thing->remove_attack( "tail" );

   thing->add_attack( "chew", 75, ({ 3 * number, number / 2, number }),
      "sharp", "unarmed", 0 );
   thing->add_attack( "tail", 75, ({ number, 5, number }),
      "blunt", "unarmed", 0 );

   thing->tactics( "response dodge" );
   thing->tactics( "attitude offensive" );
} /* set_unarmed_attacks() */
// --- END [/mnt/home2/grok/lib/std/races/reptile.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/duck.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/duck.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628751   Available: 13576105
Inodes: Total: 5242880    Free: 4960135
1072 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/duck.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628751   Available: 13576105
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/races/bird_base";

void setup() {
   set_name( "duck" );
   set_long( "Ducks.  That's all there is to say.  Ducks, ducks, ducks, "
      "ducks, ducks.  Thank you.\n" );
   set_weight( 80 );
   set_height( 30 );
   set_desc( "an ordinary brain-dead duck" );

   add_ac( "feather_blow", "blunt", 10 );
   add_ac( "feather_slash", "sharp", 2 );
   add_ac( "feather_pierce", "pierce", 2 );

   set_stats( ({ 0, 14, -6, -4, -6 }) );
} /* setup() */

void set_unarmed_attacks( object thing ) {
   int number;
  
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = sqrt( number / 4 ) + ( thing->query_weight() / 20 );

   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );

   thing->remove_attack( "beak" );

   thing->add_attack( "beak", 50, ({ number / 2, 2, number / 2 }),
      "pierce", "unarmed", 0 );
   thing->add_attack( "feet", 75, ({ number, 5, number / 2 }),
      "blunt", "unarmed", 0 );

   thing->tactics( "response dodge" );
} /* set_unarmed_attacks() */

int lives_in_water() { return 1; }
// --- END [/mnt/home2/grok/lib/std/races/duck.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/frog.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/frog.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628751   Available: 13576105
Inodes: Total: 5242880    Free: 4960135
569 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/frog.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628751   Available: 13576105
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/races/amphibian";

void setup() {
   set_name( "frog" );
   set_long( "Frogs are amphibians" );
   set_height(10);
   set_weight(10);
   set_desc( "an innocent little froggie" );

   add_ac( "blunt", "blunt", 5 );
   add_ac( "pierce", "pierce", 4 );
   add_ac( "sharp", "sharp", 3 );

   add_attack( "bite", 50, ({ 10, 2, 6 }) );

   set_sight( ({ 5, 20, 200, 300 }) );
   set_stats( ({ -4, 10, -4, -4, -6 }) );
} /* setup() */

void start_player( object thing ) {
   ::start_player( thing );
   thing->tactics( "response dodge" );
} /* start_player() */
// --- END [/mnt/home2/grok/lib/std/races/frog.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/rodent_base.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/rodent_base.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628750   Available: 13576104
Inodes: Total: 5242880    Free: 4960135
2137 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/rodent_base.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628750   Available: 13576104
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/races/base";

void create() {
   do_setup++;
   ::create();
   do_setup--;

   set_desc( "a generic rodent.  It shouldn't be used since this is just a "
      "base race" );

   bits = ({ 
      "head", "head", ({ 0, 40, 0,
         "left eye", "right eye", "left ear", "right ear", "skull" }),
      "left eye", "eye", ({ "head", 1, 0 }),
      "right eye", "eye", ({ "head", 1, 0 }),
      "left ear", "ear", ({ "head", 10, 0 }),
      "right ear", "ear", ({ "head", 10, 0 }),
      "skull", "skull", ({ "head", 20, 0, "brain", "teeth" }),
      "brain", "brain", ({ "skull", 10, 0 }),
      "teeth", "teeth", ({ "skull", 5, ({"/std/bit_set", 1}), "tooth" }),
      "tooth", "tooth", ({ "teeth", 1, ({"/std/bit", 20}) }),
      "torso", "torso", ({ 0, 600, 0,
         "heart", "liver", "left kidney", "right kidney", "spleen",
         "right lung", "left lung", "intestine" }),
      "heart", "heart", ({ "torso", 15, 0 }),
      "liver", "liver", ({ "torso", 15, 0 }),
      "left kidney", "kidney", ({ "torso", 10, 0 }),
      "right kidney", "kidney", ({ "torso", 10, 0 }),
      "spleen", "spleen", ({ "torso", 10, 0 }),
        "left lung", "lung", ({ "torso", 16, 0 }),
      "right lung", "lung", ({ "torso", 15, 0 }),
      "intestine", "gut", ({ "torso", 100, 0 }),
      "genitalia", "genitalia", ({ 0, 5, 0 }),
      "left front leg", "leg", ({ 0, 100, 0, "left front paw" }),
      "left front paw", "paw", ({ "left front leg", 30, 0 }),
      "right front leg", "leg", ({ 0, 100, 0, "right front paw" }),
      "right front paw", "paw", ({ "right front leg", 30, 0 }),
      "left rear leg", "leg", ({ 0, 100, 0, "left rear paw" }),
      "left rear paw", "paw", ({ "left rear leg", 30, 0 }),
      "right rear leg", "leg", ({ 0, 100, 0, "right rear paw" }),
      "right rear paw", "paw", ({ "right rear leg", 30, 0 }),
      "tail", "tail", ({ 0, 25, 0 }),
      "skin", "skin", ({ 0, 175, 0 })
   });

   inedible = ({ "skull", "teeth", "tooth", "tail", "skin" });
   unrottable = ({ "skull", "teeth", "tooth" });
   set_skin( "fur" );

   if( !do_setup )
      this_object()->setup();
} /* create() */
// --- END [/mnt/home2/grok/lib/std/races/rodent_base.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/tortoise.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/tortoise.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628750   Available: 13576104
Inodes: Total: 5242880    Free: 4960135
2501 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/tortoise.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628750   Available: 13576104
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/races/base";

void setup() {
   set_name( "tortoise" );
   set_long( "A tortoise.\n" );
   set_height( 40 );
   set_weight( 600 );
   set_desc( "a tortoise, slow and steady" );

   bits = ({ 
      "head", "head", ({ 0, 100, 0,
         "left eye", "right eye", "skull", "tongue" }),
      "left eye", "eye", ({ "head", 1, 0 }),
      "right eye", "eye", ({ "head", 1, 0 }),
      "skull", "skull", ({ "head", 50, 0, "brain" }),
      "beak", 0, ({ "skull", 20, 0 }),      
      "brain", "brain", ({ "skull", 30, 0 }),
      "torso", "torso", ({ 0, 450, 0,
         "heart", "liver", "left kidney", "right kidney", "spleen",
         "right lung", "left lung", "intestine" }),
      "heart", "heart", ({ "torso", 20, 0 }),
      "liver", "liver", ({ "torso", 20, 0 }),
      "left kidney", "kidney", ({ "torso", 10, 0 }),
      "right kidney", "kidney", ({ "torso", 10, 0 }),
      "spleen", "spleen", ({ "torso", 10, 0 }),
      "right lung", "lung", ({ "torso", 20, 0 }),
      "left lung", "lung", ({ "torso", 20, 0 }),
      "intestine", "gut", ({ "torso", 50, 0 }),
      "genitals", "genitals", ({ 0, 5, 0 }),
      "left front leg", "leg", ({ 0, 150, 0, "left front claw" }),
      "left front claw", "claw", ({ "left front leg", 25, 0 }),
      "right front leg", "leg", ({ 0, 150, 0, "right front claw" }),
      "right front claw", "claw", ({ "right front leg", 25, 0 }),
      "left rear leg", "leg", ({ 0, 150, 0, "left rear claw" }),
      "left rear claw", "claw", ({ "left rear leg", 25, 0 }),
      "right rear leg", "leg", ({ 0, 150, 0, "right rear claw" }),
      "right rear claw", "claw", ({ "right rear leg", 25, 0 }),
      "tail", "tail", ({ 0, 25, 0 }),
      "shell", 0, ({ 0, 275, 0 })
   });

   inedible = ({ "skull", "beak", "shell" });
   unrottable = ({ "skull", "beak", "shell" });
   set_skin( "skin" );

   set_stats( ({ 2, 4, -2, 6, -4 }) );
} /* setup() */


void set_unarmed_attacks( object thing ) {
   int number;

   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = 4 + sqrt( number ) / 2;

   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );

   thing->remove_attack( "chew" );
   thing->remove_attack( "claws" );

   thing->add_attack( "chew", 100, ({ 3 * number, 0, number }),
      "sharp", "unarmed", 0 );
   thing->add_attack( "claws", 50, ({ ( 3 * number ) / 2, number, number }),
      "sharp", "unarmed", 0 );

   thing->tactics( "response dodge" );
} /* set_unarmed_attacks() */
// --- END [/mnt/home2/grok/lib/std/races/tortoise.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/goat.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/goat.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628749   Available: 13576103
Inodes: Total: 5242880    Free: 4960135
1167 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/goat.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628749   Available: 13576103
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*   Goat   *
 *  Gototh  *
 * 22/11/97 */

inherit "/std/races/ruminant";

void setup() {
   set_name( "goat" );
   set_long( "A cloven-hoofed, horned mammal closely related to the "
      "sheep.\n" );
   set_desc( "a cloven-hoofed, horned mammal" );

   set_weight( 800 );
   set_height( 80 );

   remove_bit( "head" );

   add_bit( "head", "head", ({ 0, 135, 0,
      "left eye", "right eye", "nose", "skull", "tongue", "left ear",
      "right ear", "left horn", "right horn" }) );
   add_bit( "left horn", "horn", ({ "head", 5, 0 }) );
   add_bit( "right horn", "horn", ({ "head", 5, 0 }) );

   inedible += ({ "left horn", "right horn" });

   set_stats( ({ 4, 8, 0, 2, -4 }) );
} /* setup() */

void set_unarmed_attacks( object thing ) {
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "standard" );

   thing->remove_attack( "horns" );
   thing->remove_attack( "hoof" );

   thing->add_attack( "horns", 60, ({ 21, 8, 11 }),
      "pierce", "unarmed", 0 );
   thing->add_attack( "hoof", 60, ({ 32, 10, 11 }),
      "blunt", "unarmed", 0 );

   thing->tactics( "response dodge" );
} /* set_unarmed_attacks() */

// --- END [/mnt/home2/grok/lib/std/races/goat.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/insect_base.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/insect_base.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628748   Available: 13576102
Inodes: Total: 5242880    Free: 4960135
2210 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/insect_base.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628748   Available: 13576102
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/races/base";

void create() {
   do_setup++;
   ::create();
   do_setup--;

   set_desc( "your standard insect.  This should not be used since it is a "
      "base race" );

   bits = ({ 
      "head", "head", ({ 0, 200, 0,
         "left feeler", "right feeler", "brain", "left eye", "right eye",
         "mandible" }),
      "left feeler", "feeler", ({ "head", 10, 0 }),
      "right feeler", "feeler", ({ "head", 10, 0 }),
      "brain", "brain", ({ "head", 50, 0 }),
      "left eye", "eye", ({ "head", 10, 0 }),
      "right eye", "eye", ({ "head", 10, 0 }),
      "mandible", "mouth", ({ "head", 25, 0 }),
      "thorax", "thorax", ({ 0, 500, 0,
         "left front leg", "right front leg", "left middle leg",
         "right middle leg", "left back leg", "right back leg" }),
      "left front leg", "leg", ({ "thorax", 50, 0 }),
      "right front leg", "leg", ({ "thorax", 50, 0 }),
      "left middle leg", "leg", ({ "thorax", 50, 0 }),
      "right middle leg", "leg", ({ "thorax", 50, 0 }),
      "left back leg", "leg", ({ "thorax", 50, 0 }),
      "right back leg", "leg", ({ "thorax", 50, 0 }),
      "abdomen", "abdomen", ({ 0, 500, 0 })
   });

   inedible = ({ "mandible" });
   unrottable = ({ "mandible" });
   set_skin( "carapace" );

   if( !do_setup )
      this_object()->setup();
} /* create() */

string *query_target_zones() {
  return ({ "head", "head",
              "thorax","thorax", "thorax", "thorax", "thorax", "thorax",
              "left front leg", "left front leg",
              "left middle leg", "left middle leg",
              "right front leg", "right front leg",
              "right middle leg", "right middle leg",
              "abdomen", "abdomen", "abdomen", "abdomen", "abdomen",
              "left back leg", "left back leg", 
              "right back leg", "right back leg" });
}

string map_target_zone(string zone) {
  switch(zone) {
  case "neck":
  case "chest":
    return "thorax";
  case "arms":
  case "hands":
    return (random(2) ? "left " : "right ") +
      (random(2) ? "front " : "middle ") + "leg";
  case "feet":
  case "legs":
    return (random(2) ? "left " : "right ") + "rear leg";
  default:
    return zone;
  }
}
// --- END [/mnt/home2/grok/lib/std/races/insect_base.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/reptile_base.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/reptile_base.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628748   Available: 13576102
Inodes: Total: 5242880    Free: 4960135
2284 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/reptile_base.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628748   Available: 13576102
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/races/base";

void create() {
   do_setup++;
   ::create();
   do_setup--;

   set_desc( "your standard reptile.  This should not be used as it is a "
      "base race" );

   bits = ({ 
      "head", "head", ({ 0, 50, 0,
         "left eye", "right eye", "skull", "tongue", "snout" }),
      "left eye", "eye", ({ "head", 2, 0 }),
      "right eye", "eye", ({ "head", 2, 0 }),
      "skull", "skull", ({ "head", 50, 0, "brain", "teeth" }),
      "brain", "brain", ({ "skull", 25, 0 }),
      "teeth", "teeth", ({ "skull", 5, ({"/std/bit_set", 1}), "tooth" }),
      "tooth", "tooth", ({ "teeth", 1, ({"/std/bit", 48}) }),
      "tongue", "tongue", ({ "head", 10, 0 }),
      "snout", "snout", ({ "head", 10, 0 }),
      "neck", "neck", ({ 0, 50, 0 }),
      "torso", "body", ({ 0, 400, 0,
         "heart", "liver", "left kidney", "right kidney", "left lung",
         "right lung", "spleen", "intestine", "pancreas" }),
      "heart", "heart", ({ "torso", 15, 0 }),
      "liver", "liver", ({ "torso", 15, 0 }),
      "left kidney", "kidney", ({ "torso", 10, 0 }),
      "right kidney", "kidney", ({ "torso", 10, 0 }),
      "left lung", "lung", ({ "torso", 15, 0 }),
      "right lung", "lung", ({ "torso", 15, 0 }),
      "spleen", "spleen", ({ "torso", 10, 0 }),
      "intestine", "gut", ({ "torso", 100, 0 }),
      "pancreas", "pancreas", ({ "torso", 10, 0 }),
      "left front leg", "leg", ({ 0, 180, 0, "left front foot" }),
      "left front foot", "foot", ({ "left front leg", 27, 0 }),
      "right front leg", "leg", ({ 0, 180, 0, "right front foot" }),
      "right front foot", "foot", ({ "right front leg", 27, 0 }),
      "left rear leg", "leg", ({ 0, 180, 0, "left rear foot" }),
      "left rear foot", "foot", ({ "left rear leg", 27, 0 }),
      "right rear leg", "leg", ({ 0, 180, 0, "right rear foot" }),
      "right rear foot", "foot", ({ "right rear leg", 27, 0 }),
      "tail", "tail", ({ 0, 100, 0 }),
      "skin", "skin", ({ 0, 175, 0 })
   });

   inedible = ({ "skull", "left front foot", "right front foot",
      "left rear foot", "right rear foot", "tail", "teeth", "tooth",
      "skin" });
   unrottable = ({ "skull", "teeth", "tooth" });
   set_skin( "scales" );

   if( !do_setup )
      this_object()->setup();
} /* create() */
// --- END [/mnt/home2/grok/lib/std/races/reptile_base.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/lion.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/lion.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628747   Available: 13576101
Inodes: Total: 5242880    Free: 4960135
1524 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/lion.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628747   Available: 13576101
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/races/carnivore";

void setup() {
   set_name( "lion" );
   set_long( "A carnivorous mammal.  This is the real thing though, not "
         "your domesticated house cat, but the king of its kind.  It leaps "
         "over the ground in huge bounding strides, power that other cats "
         "can only dream about.\n" );
   set_height( 150 );
   set_weight( 3500 );
   set_desc( "a rather large lion, bounding vigorously towards you" );

   add_bit( "bile duct", "duct", ({ "torso", 1, 0 }) );

   set_stats( ({ 6, 10, -4, 10, -4 }) );
} /* setup() */

void new_set_level( mixed *args ) {
   int level;
   object thing;

   if( sizeof(args) < 2 || !args[1] )
      return;

   level = args[ 0 ];
   thing = args[ 1 ];

   thing->add_ac( "blunt", "blunt", level );
   thing->add_ac( "sharp", "sharp", 2 + level );
   thing->add_ac( "pierce", "pierce", 2 * level );
} /* new_set_level() */

void set_unarmed_attacks( object thing ) {
   int number;

   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = sqrt( number );

   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );

   thing->remove_attack( "claws" );
   thing->remove_attack( "bite" );

   if( number < 10 )
      number = 10;
  
   thing->add_attack( "claws", 100, ({ number, 10, number }),
      "sharp", "unarmed", 0 );
   thing->add_attack( "bite", 75, ({ 3 * number, number / 2, number }),
      "pierce", "unarmed", 0 );

   thing->tactics( "response dodge" );
} /* set_unarmed_attacks() */
// --- END [/mnt/home2/grok/lib/std/races/lion.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/light.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/light.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628746   Available: 13576100
Inodes: Total: 5242880    Free: 4960135
788 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/light.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628746   Available: 13576100
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* Race object for small lights */

inherit "/std/races/base";

void setup() {
   set_name( "light" );
   set_long( "A small sphere of magical blue light.\n" );
   set_weight( 1 );
   set_height( 1 );
   set_desc( "a small ball of blue light hovering in the air." );
   
   /* throw away the human bits and replace totally */
   bits = ({ });
   inedible = ({ });
   unrottable = ({ });

   add_ac( "fire", "fire", 1000 );
   add_ac( "sound", "sound", 1000 );
   add_ac( "acid", "acid", 1000 );
   add_ac( "gas", "gas", 1000 );
   add_ac( "mental", "mental", 100 );

   set_stats( ({ 0, 14, -6, -6, -6 }) );
}  /* setup() */

void start_player( object thing ) {
   ::start_player( thing );
   thing->tactics( "response dodge" );
} /* start_player() */

int lives_in_water() { return 1; }
// --- END [/mnt/home2/grok/lib/std/races/light.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/fish_base.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/fish_base.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628746   Available: 13576100
Inodes: Total: 5242880    Free: 4960135
1993 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/fish_base.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628746   Available: 13576100
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/races/base";

void create() {
   do_setup++;
   ::create();
   do_setup--;

   set_desc( "your standard fish.  This should not be used since it is a "
      "base race" );

   bits = ({
      "head", "head", ({ 0, 200, 0,
         "left eye", "right eye", "left gill", "right gill" }),
      "left eye", "eye", ({ "head", 1, 0 }),
      "right eye", "eye", ({ "head", 1, 0 }),
      "left gill", "gill", ({ "head", 50, 0 }),
      "right gill", "gill", ({ "head", 50, 0 }),
      "torso", "guts", ({ 0, 800, 0,
         "heart", "liver", "left kidney", "right kidney", "spleen" }),
      "heart", "heart", ({ "guts", 50, 0 }),
      "liver", "liver", ({ "guts", 50, 0 }),
      "left kidney", "kidney", ({ "guts", 25, 0 }),
      "right kidney", "kidney", ({ "guts", 25, 0 }),
      "spleen", "spleen", ({ "guts", 25, 0 }),
      "genitals", "genitals", ({ 0, 10, 0 }),
      "left petral fin", "fin", ({ 0, 100, 0, }),
      "right petral fin", "fin", ({ 0, 100, 0, }),
      "dorsal petral fin", "fin", ({ 0, 100, 0 }),
      "tail", "tail", ({ 0, 150, 0 })
   });

   inedible = ({ "left petral fin", "right petral fin", "dorsal petral fin",
      "tail" });
   unrottable = ({  });
   set_skin( "scales" );

   if( !do_setup )
      this_object()->setup();
} /* create() */



string *query_target_zones() {
  return ({ "head", "head",
              "body","body", "body", "body", "body", "body",
              "left petral fin", "right petral fin",
              "dorsal fin", "body",
              "body", "body",
              "body", "body",
              "body", "body", "body", "body", "body"
              "body", "body", 
              "tail", "tail" });
}

string map_target_zone(string zone) {
  switch(zone) {
  case "head":
    return zone;
  case "arms":
    return (random(2) ? "left " : "right ") + "petral fin";
  case "hands":
    return "dorsal fin";
  case "feet":
    return "tail";
  default:
    return "body";
  }
}

int lives_in_water() { return 1; }
// --- END [/mnt/home2/grok/lib/std/races/fish_base.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/mustelidae.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/mustelidae.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628745   Available: 13576099
Inodes: Total: 5242880    Free: 4960135
1338 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/mustelidae.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628745   Available: 13576099
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* Mustelidae race object. Asate, September 1998. */

inherit "/std/races/mustelidae_base";

void setup() {
   set_name( "mustelidae" );
   set_long( "The typical weasel like animal.\n" );
   set_height( 15 );
   set_weight( 30 );
   set_desc( "small brown meateater" );

   set_stats( ({ -2, 8, -2, -4, -4 }) );
} /* setup() */

void new_set_level( mixed *args ) {
   int level;
   object thing;

   if( sizeof(args) < 2 || !args[1] )
      return;

   level = args[ 0 ];
   thing = args[ 1 ];

   level = 2 + ( 2 * level + random( level ) ) / 8;

   thing->add_ac( "blunt", "blunt", 20 + level / 3 );
   thing->add_ac( "sharp", "sharp", 50 + level );
   thing->add_ac( "pierce", "pierce", 60 + 2 * level );
} /* new_set_level() */

void set_unarmed_attacks( object thing ) {
   int number;

   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = 4 + sqrt( number ) / 2;

   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );

   thing->remove_attack( "claws" );
   thing->remove_attack( "bite" );

   thing->add_attack( "claws", 50, ({ ( 4 * number ) / 2, 8, 2 * number }),
      "sharp", "unarmed", 0 );
   thing->add_attack( "bite", 100, ({ 2 * number, 10, ( 3 * number ) / 2 }),
      "pierce", "unarmed", 0 );

   thing->tactics( "response dodge" );
} /* set_unarmed_attacks() */
// --- END [/mnt/home2/grok/lib/std/races/mustelidae.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/bird_base.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/bird_base.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628745   Available: 13576099
Inodes: Total: 5242880    Free: 4960135
3286 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/bird_base.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628745   Available: 13576099
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/races/base";

void create() {
   do_setup++;
   ::create();
   do_setup--;

   set_desc( "a general, unspecified bird.  This should not be used since "
      "it is a base race" );

   bits = ({
      "head", 0, ({ 0, 150, 0,
         "left eye", "right eye", "beak", "skull" }),
      "left eye", "eye", ({ "head", 1, 0 }),
      "right eye", "eye", ({"head", 1, 0 }),
      "beak", 0, ({ "head", 20, 0 }),
      "skull", "cranium", ({ "head", 30, 0, "brain" }),
      "brain", 0, ({ "skull", 10, 0 }),
      "neck", 0, ({ 0, 25, 0, "gizzard" }),
      "gizzard", "gullet", ({ "neck", 5, 0 }),
      "torso", "body", ({ 0, 500, 0,
         "heart", "liver", "left kidney", "right kidney", "left lung",
         "right lung", "spleen", "intestine", "pancreas", "wishbone",
         "body feather" }),
      "heart", 0, ({ "torso", 50, 0 }),
      "liver", 0, ({ "torso", 25, 0 }),
      "left kidney", "kidney", ({ "torso", 15, 0 }),
      "right kidney", "kidney", ({ "torso", 15, 0 }),
      "left lung", "lung", ({ "torso", 25, 0 }),
      "right lung", "lung", ({ "torso", 25, 0 }),
      "spleen", 0, ({ "torso", 15, 0 }),
      "intestine", "gut", ({ "torso", 50, 0 }),
      "pancreas", 0, ({ "torso", 15, 0 }),
      "wishbone", 0, ({ "torso", 5, 0 }),
      "body feather", "feather", ({ "torso", 1, ({"/std/bit", 6}) }),
      "tail", 0, ({ 0, 50, 0, "tail feather" }),
      "tail feather", "feather", ({ "tail", 1, ({"/std/bit", 4}) }),
      "left wing", "wing", ({ 0, 150, 0,
         "left wing feather" }),
      "left wing feather", "feather", ({ "left wing", 1,
         ({"/std/bit", 5}) }),
      "right wing", "wing", ({ 0, 150, 0,
         "right wing feather" }),
      "right wing feather", "feather", ({ "right wing", 1,
         ({"/std/bit", 5}) }),
      "left leg", "leg", ({ 0, 100, 0, "left claw" }),
      "left claw", "claw", ({ "left leg", 25, 0 }),
      "right leg", "leg", ({ 0, 100, 0, "right claw" }),
      "right claw", "claw", ({ "right leg", 25, 0 })
   });

   inedible = ({ "beak", "skull", "body feather", "left wing feather",
      "right wing feather", "tail feather", "left claw", "right claw",
      "wishbone" });
   unrottable = ({ "beak", "skull", "body feather", "left wing feather",
      "right wing feather", "tail feather", "left claw", "right claw",
      "wishbone" });
   pluckable = ({ "body feather", "left wing feather", "right wing feather",
      "tail feather" });
   set_skin( "feathers" );

   if( !do_setup )
      this_object()->setup();
} /* create() */


string *query_target_zones() {
  return ({ "head", "head", "neck",
              "breast", "breast", "breast", "breast", "back",
              "left wing", "left wing", "left wing", "left wing",
              "right wing", "right wing", "right wing", "right wing",
              "stomach", "stomach", "stomach",
              "left leg", "left leg", "left claw", 
              "right leg", "right leg", "right claw" });
}

string map_target_zone(string zone) {
  switch(zone) {
  case "chest":
    return "breast";
  case "abdomen":
    return "stomach";
  case "hands":
  case "arms":
    return (random(2) ? "left " : "right ") + "wing";
  case "feet":
    return (random(2) ? "left " : "right ") + "claw";
  default:
    return zone;
  }
}
// --- END [/mnt/home2/grok/lib/std/races/bird_base.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/badger.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/badger.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628744   Available: 13576098
Inodes: Total: 5242880    Free: 4960135
1341 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/badger.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628744   Available: 13576098
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* Mustelidae race object. Asate, November 1998. */

inherit "/std/races/mustelidae_base";

void setup() {
   set_name( "badger" );
   set_long( "A big black white and grey burowing animal.\n" );
   set_height( 30 );
   set_weight( 500 );
   set_desc( "small brown meateater" );

   set_stats( ({ 2, -2, -2, 2, -4 }) );
} /* setup() */

void new_set_level( mixed *args ) {
   int level;
   object thing;

   if( sizeof(args) < 2 || !args[1] )
      return;

   level = args[ 0 ];
   thing = args[ 1 ];

   level = 3 + ( 2 * level + random( level ) ) / 8;

   thing->add_ac( "blunt", "blunt", 20 + level / 3 );
   thing->add_ac( "sharp", "sharp", 50 + level );
   thing->add_ac( "pierce", "pierce", 60 + 2 * level );
} /* new_set_level() */

void set_unarmed_attacks( object thing ) {
   int number;

   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = 4 + sqrt( number ) / 2;

   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );

   thing->remove_attack( "claws" );
   thing->remove_attack( "chew" );

   thing->add_attack( "claws", 50, ({ ( 4 * number ) / 2, 8, 2 * number }),
      "sharp", "unarmed", 0 );
   thing->add_attack( "bite", 100, ({ 2 * number, 10, ( 3 * number )/2 }),
      "chew", "unarmed", 0 );

   thing->tactics( "response dodge" );
} /* set_unarmed_attacks() */
// --- END [/mnt/home2/grok/lib/std/races/badger.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/scorpion.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/scorpion.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628743   Available: 13576097
Inodes: Total: 5242880    Free: 4960135
3574 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/scorpion.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628743   Available: 13576097
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* scorpion race object Thought .. 19th Oct 1996
 * Fixed by Sin to do the poisoning correctly. */

#define POISON_EFFECT "/std/effects/poisons/spider_venom"

inherit "/std/races/arachnid";
 
void poison( int damage, object him, object me, string atype, string aname );

void setup() {
   set_name( "scorpion" );
   set_long( "A nasty little poisonous creature, of the arachnid family.\n" );
   set_height( 5 );
   set_weight( 2 );
   set_desc( "a nasty little poisonous creature, of the arachnid family" );

   bits = ({
      "head", "head", ({ 0, 200, 0,
           "left eye", "right eye", "mandible", "brain" }),
      "left eye", "eye", ({ "head", 10, 0 }),
      "right eye", "eye", ({ "head", 10, 0 }),
      "mandible", "mouth", ({ "head", 50, 0 }),
      "brain", "brain", ({ "head", 25, 0 }),
      "thorax", "thorax", ({ 0, 500, 0, "heart", "poison sac" }),
      "heart", "heart", ({ "thorax", 50, 0 }),
      "poison sac", "sac", ({ "thorax", 50, 0 }),     
      "tail", "tail", ({ 0, 300, 0, "sting" }),
      "sting", "sting", ({ "tail", 25, 0 }),
      "left claw", "claw", ({ 0, 100, 0 }),
      "right claw", "claw", ({ 0, 100, 0 }),
      "left front leg", "leg", ({ 0, 50, 0 }),
      "left middle leg", "leg", ({ 0, 50, 0 }),
      "left back leg", "leg", ({ 0, 50, 0 }),
      "right front leg", "leg", ({ 0, 50, 0 }),
      "right middle leg", "leg", ({ 0, 50, 0 }),
      "right back leg", "leg", ({ 0, 50, 0 })
   });

   inedible = ({ "mandible", "left claw", "right claw" });
   unrottable = ({ "mandible", "left claw", "right claw" });

   set_stats( ({ -6, 4, -6, -6, -6 }) );
} /* setup() */
 
void new_set_level( mixed *args ) {
   int level;
   object thing;

   if( sizeof(args) < 2 || !args[1] )
      return;

   level = args[ 0 ];
   thing = args[ 1 ];

   thing->add_skill_level( "other.health", level * 3 );
   thing->add_ac( "blunt", "blunt", level / 2 );
   thing->add_ac( "pierce", "pierce", level / 4 );
   thing->add_ac( "sharp", "sharp", level / 3 );
   thing->add_ac( "fire", "fire", level );

/* Not quite sure about these levels, I know the ordering is right, but
 * the actual values could probably do with tweaking
 */ 
} /* new_set_level() */

int query_dark( int light ) { return 0; }

void set_unarmed_attacks( object thing ) {
   int number;

   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = 4 + sqrt( number );

   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );

   thing->remove_attack( "poison" );
   thing->remove_attack( "bite" );

   thing->add_attack( "sting", 70, ({ 5 * number, 10, number }),
      "pierce", "unarmed", ({ "poison", this_object() }) );
   thing->add_attack( "bite",  20, ({ 3 * number, 10, number }),
      "pierce", "unarmed", 0 );

   thing->add_attack_message( "sting", "pierce", ({
      0, "$N sting$s $P $z.\n" }) );

   thing->tactics( "response dodge" );
} /* set_unarmed_attacks() */

void poison( int damage, object him, object me, string a_type,
             string a_name ) {
   tell_object( me, "You stab " + him->one_short() + " with your tail, "
      "injecting " + him->query_objective() + " with venom.\n" );
   tell_object( him, me->one_short() + " stabs you with " +
      me->query_possessive() + " tail!  You seethe in agony.\n" );
   tell_room( environment( me ), me->one_short() + " visciously stabs " +
      him->one_short() + " with " + me->query_possessive() + " tail!  " +
      him->one_short() + " seethes in agony.\n", ({ me, him }) );

   him->add_effect( POISON_EFFECT, 100 );
} /* poison() */



// --- END [/mnt/home2/grok/lib/std/races/scorpion.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/skunk.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/skunk.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628742   Available: 13576096
Inodes: Total: 5242880    Free: 4960135
1333 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/skunk.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628742   Available: 13576096
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* Mustelidae race object. Asate, November 1998. */

inherit "/std/races/mustelidae_base";

void setup() {
   set_name( "skunk" );
   set_long( "A small black and white animal.\n" );
   set_height( 15 );
   set_weight( 30 );
   set_desc( "small brown meateater" );

   set_stats( ({ -2, 8, -2, -4, -4 }) );
} /* setup() */

void new_set_level( mixed *args ) {
   int level;
   object thing;

   if( sizeof(args) < 2 || !args[1] )
      return;

   level = args[ 0 ];
   thing = args[ 1 ];

   level = 1 + ( 2 * level + random( level ) ) / 8;

   thing->add_ac( "blunt", "blunt", 20 + level / 3 );
   thing->add_ac( "sharp", "sharp", 50 + level );
   thing->add_ac( "pierce", "pierce", 60 + 2 * level );
} /* new_set_level() */

void set_unarmed_attacks( object thing ) {
   int number;

   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = 4 + sqrt( number ) / 2;

   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );

   thing->remove_attack( "claws" );
   thing->remove_attack( "bite" );

   thing->add_attack( "claws", 50, ({ ( 4 * number ) / 2, 8, 2 * number }),
      "sharp", "unarmed", 0 );
   thing->add_attack( "bite", 100, ({ 2 * number, 10, ( 3 * number ) / 2 }),
      "pierce", "unarmed", 0  );

   thing->tactics( "response dodge" );
} /* set_unarmed_attacks() */
// --- END [/mnt/home2/grok/lib/std/races/skunk.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/ferret.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/ferret.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628742   Available: 13576096
Inodes: Total: 5242880    Free: 4960135
1339 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/ferret.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628742   Available: 13576096
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* Mustelidae race object. Asate, November 1998. */

inherit "/std/races/mustelidae_base";

void setup() {
   set_name( "ferret" );
   set_long( "A small black white and grey animal.\n" );
   set_height( 15 );
   set_weight( 30 );
   set_desc( "small brown meateater" );

   set_stats( ({ -2, 8, -2, -4, -4 }) );
} /* setup() */

void new_set_level( mixed *args ) {
   int level;
   object thing;

   if( sizeof(args) < 2 || !args[1] )
      return;

   level = args[ 0 ];
   thing = args[ 1 ];

   level = 1 + ( 2 * level + random( level ) ) / 8;

   thing->add_ac( "blunt", "blunt", 20 + level / 3 );
   thing->add_ac( "sharp", "sharp", 50 + level );
   thing->add_ac( "pierce", "pierce", 60 + 2 * level );
} /* new_set_level() */

void set_unarmed_attacks( object thing ) {
   int number;

   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = 4 + sqrt( number ) / 2;

   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );

   thing->remove_attack( "claws" );
   thing->remove_attack( "bite" );

   thing->add_attack( "claws", 50, ({ ( 4 * number ) / 2, 8, 2 * number }),
      "sharp", "unarmed", 0 );
   thing->add_attack( "bite", 100, ({ 2 * number, 10, ( 3 * number ) / 2 }),
      "pierce", "unarmed", 0  );

   thing->tactics( "response dodge" );
} /* set_unarmed_attacks() */
// --- END [/mnt/home2/grok/lib/std/races/ferret.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/jellyfish.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/jellyfish.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628741   Available: 13576095
Inodes: Total: 5242880    Free: 4960135
1991 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/jellyfish.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628741   Available: 13576095
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * Jellyfish race object
 *
 * @author Dasquian
 * @started 4 March 2001
 */

inherit "/std/races/base";

#define STINGEFFECT "/std/effects/disease/jellyfish_sting"

void setup() {
   set_name( "jellyfish" );
   set_long( "A jelly-like blob with tendrils.\n" );
   set_height( 15 );
   set_weight( 20 );
   set_desc( "a jelly-like blob with tendrils." );

   bits = ({ 
      "tendril", "tendril", ({ 0, 1, ({ "/std/bit", 10 }) }),
      "bell", "bell", ({ 0, 10, 0 })
   });

   inedible = ({ "bell", "tendril" });
   unrottable = ({ });
   set_skin( "exocuticule" );

   add_ac( "acid", "acid", 100 );
   add_ac( "poison", "poison", 100 );
   add_ac( "blunt", "blunt", 75 );
   add_ac( "sharp", "sharp", 25 );
   add_ac( "pierce", "pierce", 25 );

   set_stats( ({ -5, -5, -5, -5, -5 }) );
   
} /* create() */

void set_unarmed_attacks( object thing ) {
   int number;

   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = 2 + (sqrt( number ) / 10);

   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );

   thing->remove_attack( "tendrils" );

   thing->add_attack( "tendrils", 100, ({ number, 10, number }),
      "blunt", "blunt", ({ "sting", this_object() }) );

   thing->add_attack_message( "tendrils", "blunt", ({
      20, "$N brush$es $P $z with $p tendrils",
      60, "$N slap$s $P $z with $p tendrils",
      100, "$N knock$s $I with $p tendrils",
      140, "$N thwack$s $I with $p tendrils",
      180, "$N smack$s $p tendrils into $P $z",
      220, "$N wallop$s $I with $p tendrils",
      0, "$N hammer$s $I with $p tendrils" }) );
    
} /* set_unarmed_attacks() */

void start_player( object thing ) {
   ::start_player( thing );
   thing->add_property( "gills", 1 );
   thing->add_property("lives in water", 1);
} /* start_player() */

int lives_in_water() { return 1; }

void sting( int damage, object him, object me, string atype, string aname ) {
   him->add_effect(STINGEFFECT, damage);
} /* sting() */


// --- END [/mnt/home2/grok/lib/std/races/jellyfish.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/hippo.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/hippo.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628740   Available: 13576094
Inodes: Total: 5242880    Free: 4960135
2812 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/hippo.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628740   Available: 13576094
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/races/ruminant";

void setup() {
   set_name( "elephant" );
   set_long( "This is an elephant.  A large creature with a thick grey "
      "hide.  He seems to weigh a lot so don't let him step on your "
      "toe.\n" );
   set_height( 280 );
   set_weight( 100000 );
   set_desc( "an elephant that looks back at you with small nice eyes" );

   remove_bit( "nose" );
   remove_bit( "head" );

   add_bit( "head", "head", ({ 0, 135, 0,
      "left eye", "right eye", "skull", "tongue", "left ear", "right ear",
      "tusk", "tusks", "trunk" }) );
   add_bit( "tail", "tail", ({ 0, 15, 0 }) );
   add_bit( "tusk", "tusk", ({ "head", 20, ({"/std/bit_set", 1}),
      "tusks" }) );
   add_bit( "tusks", "tusks", ({ "head", 40, ({"/std/bit", 2}) }) );
   add_bit( "trunk", "trunk", ({ "head", 30, 0 }) );

   inedible += ({ "tail", "tusk", "tusks" });  
   unrottable += ({ "tusk", "tusks" });

   add_ac( "blunt", "blunt", ({ 40, 20}) );
   add_ac( "pierce", "pierce", ({ 30, 20 }) );
   add_ac( "sharp", "sharp", ({ 50, 20 }) );
   add_ac( "acid", "acid", 20 );
   add_ac( "fire", "fire", 20 );

   set_stats( ({ 10, -6, -4, 16, -2 }) );
} /* setup() */

void set_unarmed_attacks( object thing ) {
   thing->remove_attack( "hands" );

   thing->remove_attack( "tusks" );
   thing->remove_attack( "crush" );
   thing->remove_attack( "ram" );

   thing->add_attack( "tusks", 20, ({75, 5, 30}),
      "pierce", "unarmed", 0 );

   thing->add_attack( "crush", 10, ({100, 5, 50}),
      "blunt", "unarmed", 0 );

   thing->add_attack_message( "crush", "unarmed", ({
     0, "$N stand$s on $p hind legs and attempt$s to crash down on $I",
      100, "$N stand$s on $p hind legs and crash$es down stricking $I "
       "a glancing blow ",
      150, "$N stand$s on $p hind legs and crash$es down on $I, crushing "
            "$P $z",
      350, "$N stand$s on $p hind legs and crash$es down on $I, crushing "
            "$P $z into a bloody mess" }) );

   thing->add_attack( "ram", 10, ({50, 3, 20}),
      "blunt", "unarmed", 0 );

   thing->add_attack_message( "ram", "unarmed", ({
     0, "$N charge$s at $I",
      100, "$N charge$s $I and strike$s $I",
      150, "$N charge$s $I and strike$s $P $z hard, making $I stagger "
            "around",
      350, "$N charge$s $I and strike$s $I to the ground.  $I "
            "stumbles around a little groggily" }) );

   thing->add_attack( "trunk", 20, ({50, 3, 20}),
      "blunt", "unarmed", 0 );

   thing->add_attack_message( "trunk", "unarmed", ({
     0, "$N swing$s $p trunk at $I",
      100, "$N swing$s $p trunk at $I, hitting $P $z hard",
      150, "$N swing$s $p trunk, which thumps forcefully into $P $z",
      350, "$N swing$s $p trunk at $I, knocking $I down.  $I "
            "gets up groggily" }) );
} /* set_unarmed_attacks() */
// --- END [/mnt/home2/grok/lib/std/races/hippo.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/mustelidae_base.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/mustelidae_base.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628739   Available: 13576093
Inodes: Total: 5242880    Free: 4960135
1909 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/mustelidae_base.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628739   Available: 13576093
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/races/base";

void create() {
   do_setup++;
   ::create();
   do_setup--;

   set_desc( "the usual mustelidae.  This should not be used as it is a "
      "base race" );

   bits = ({ 
      "head", "head", ({ 0, 40, 0,
         "left eye", "right eye", "left ear", "right ear", "skull",
         "tongue", "nose" }),
      "left eye", "eye", ({ "head", 1, 0 }),
      "right eye", "eye", ({ "head", 1, 0 }),
      "left ear", "ear", ({ "head", 1, 0 }),
      "right ear", "ear", ({ "head", 1, 0 }),
      "skull", "skull", ({ "head", 20, 0, "brain", "teeth" }),
      "brain", "brain", ({ "skull", 20, 0 }),
      "teeth", "teeth", ({ "skull", 1, ({"/std/bit_set", 1}), "tooth" }),
      "tooth", "tooth", ({ "teeth", 1, ({"/std/bit", 20}) }),
      "tongue", "tongue", ({ "head", 2, 0 }),
      "nose", "nose", ({ "head", 1, 0 }),
      "torso", "torso", ({ 0, 350, 0,
         "heart", "liver", "left kidney", "right kidney", "left lung",
         "right lung", "spleen", "intestine" }),
      "heart", "heart", ({ "torso", 10, 0 }),
      "liver", "liver", ({ "torso", 5, 0 }),
      "left kidney", "kidney", ({ "torso", 5, 0 }),
      "right kidney", "kidney", ({ "torso", 5, 0 }),
      "left lung", "lung", ({ "torso", 10, 0 }),
      "right lung", "lung", ({ "torso", 10, 0 }),
      "spleen", "spleen", ({ "torso", 5, 0 }),
      "intestine", "gut", ({ "torso", 15, 0 }),
      "genitals", "genitals", ({ 0, 5, 0 }),
      "left front leg", "leg", ({ 0, 5, 0 }),
      "right front leg", "leg", ({ 0, 5, 0 }),
      "left rear leg", "leg", ({ 0, 5, 0 }),
      "right rear leg", "leg", ({ 0, 5, 0 }),
      "tail", "tail", ({ 0, 5, 0 }),
      "skin", "skin", ({ 0, 175, 0 })
   });

   inedible = ({ "skull", "teeth", "tooth", "tail", "skin" });
   unrottable = ({ "skull", "teeth", "tooth" });
   set_skin( "fur" );

   if( !do_setup )
      this_object()->setup();
} /* create() */
// --- END [/mnt/home2/grok/lib/std/races/mustelidae_base.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/ruminant.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/ruminant.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628739   Available: 13576093
Inodes: Total: 5242880    Free: 4960135
3782 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/ruminant.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628739   Available: 13576093
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/races/base";

void create() {
   do_setup++;
   ::create();
   do_setup--;

   set_weight( 800 );
   set_height( 50 );
   set_desc( "a four-legged ruminant.  It shouldn't be used since this is "
      "just a base race" );

   bits = ({ 
      "head", "head", ({ 0, 100, 0,
         "left eye", "right eye", "nose", "skull", "tongue", "left ear",
         "right ear" }),
      "left eye", "eye", ({ "head", 2, 0 }),
      "right eye", "eye", ({ "head", 2, 0 }),
      "skull", "skull", ({ "head", 40, 0, "brain", "teeth" }),
      "brain", "brain", ({ "skull", 20, 0 }),
      "left ear", "ear", ({"head", 5, 0 }),
      "right ear", "ear", ({"head", 5, 0 }),
      "nose", "nose", ({ "head", 15, 0 }),
      "teeth", "teeth", ({ "skull", 5, ({"/std/bit_set", 1}), "tooth" }),
      "tooth", "tooth", ({ "teeth", 1, ({"/std/bit", 18}) }),
      "tongue", "tongue", ({ "head", 10, 0 }),
      "neck", "neck", ({ 0, 100, 0 }),
      "torso", "chest", ({ 0, 300, 0,
         "heart", "liver", "left kidney", "right kidney", "left lung",
         "right lung", "spleen", "first stomach", "second stomach",
         "third stomach", "fourth stomach", "intestine", "pancreas" }),
      "heart", "heart", ({ "torso", 15, 0 }),
      "liver", "liver", ({ "torso", 15, 0 }),
      "left kidney", "kidney", ({ "torso", 10, 0 }),
      "right kidney", "kidney", ({ "torso", 10, 0 }),
      "left lung", "lung", ({ "torso", 15, 0 }),
      "right lung", "lung", ({ "torso", 15, 0 }),
      "spleen", "spleen", ({ "torso", 10, 0 }),
      "intestine", "gut", ({ "torso", 50, 0 }),
      "pancreas", "pancreas", ({ "torso", 10, 0 }),
      "first stomach", "stomach", ({ "torso", 20, 0 }),
      "second stomach", "stomach", ({ "torso", 20, 0 }),
      "third stomach", "stomach", ({ "torso", 20, 0 }),
      "fourth stomach", "stomach", ({ "torso", 20, 0 }),
      "genitals", "genitals", ({ 0, 5, 0 }),
      "left front leg", "leg", ({ 0, 150, 0, "left front hoof" }),
      "left front hoof", "hoof", ({ "left front leg", 30, 0 }),
      "right front leg", "leg", ({ 0, 150, 0, "right front hoof" }),
      "right front hoof", "hoof", ({ "right front leg", 30, 0 }),
      "left rear leg", "leg", ({ 0, 150, 0, "left rear hoof" }),
      "left rear hoof", "hoof", ({ "left rear leg", 30, 0 }),
      "right rear leg", "leg", ({ 0, 150, 0, "right rear hoof" }),
      "right rear hoof", "hoof", ({ "right rear leg", 30, 0 }),
      "skin", "skin", ({ 0, 175, 0 })
   });

   inedible = ({ "skull", "neck", "genitals", "teeth", "left front hoof",
      "right front hoof", "left rear hoof", "right rear hoof", "tooth",
      "skin" });
   unrottable = ({ "skull", "teeth", "tooth" });
   set_skin( "hide" );

   set_stats( ({ 0, 0, -4, 2, -6 }) );

   if( !do_setup )
      this_object()->setup();
} /* create() */

string *query_target_zones() {
  return ({ "head", "head", "neck",
              "chest", "back", "back", "back", "lower back", 
              "left front leg", "left front leg", "left front hoof",
              "stomach", "stomach", "tail",
              "right front leg", "right front leg", "right front hoof",
              "left rear leg", "left rear leg", "left rear hoof",
              "right rear leg", "right rear leg", "right rear hoof"});
}

string map_target_zone(string zone) {
  switch(zone) {
  case "chest":
    return random(4) ? "back" : "chest";
  case "abdomen":
    return random(4) ? "stomach" : "lower back";
  case "arms":
    return (random(2) ? "left " : "right ") + "front leg";
  case "hands":
    return (random(2) ? "left " : "right ") + "front hoof";
  case "legs":
    return (random(2) ? "left " : "right ") + "rear leg";
  case "feet":
    return (random(2) ? "left " :"right ") + "rear hoof";
  default:
    return zone;
  }
}
// --- END [/mnt/home2/grok/lib/std/races/ruminant.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/races/mouse.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/races/mouse.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628738   Available: 13576092
Inodes: Total: 5242880    Free: 4960135
1292 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/races/mouse.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628738   Available: 13576092
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/races/rodent_base";

void setup() {
   set_name( "mouse" );
   set_long( "Any of numerous small rodents (as of the genus Mus) with "
      "pointed snout, rather small ears, elongated body and slender "
      "tail.\n" );
   set_height( 10 );
   set_weight( 5 );
   set_desc( "a little mouse, scurrying about for food." );

   set_stats( ({ -4, 8, -4, -4, -6 }) );
} /* setup() */

void new_set_level( mixed *args ) {
   int level;
   object thing;

   if( sizeof(args) < 2 || !args[1] )
      return;

   level = args[ 0 ];
   thing = args[ 1 ];

   thing->add_ac( "blunt", "blunt", level );
   thing->add_ac( "sharp", "sharp", 2 + level );
   thing->add_ac( "pierce", "pierce", 2 * level );
} /* new_set_level() */

void set_unarmed_attacks( object thing ) {
   int number;

   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = sqrt( number ) / 6;

   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );

   thing->remove_attack( "bite" );
   thing->remove_attack( "claws" );

   thing->add_attack( "bite", 75, ({ 0, 3, number }),
      "pierce", "unarmed", 0 );
   thing->add_attack( "claws", 50, ({ 0, 5, number / 2 }),
      "sharp", "unarmed", 0 );

   thing->tactics( "response dodge" );
} /* set_unarmed_attacks() */
// --- END [/mnt/home2/grok/lib/std/races/mouse.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/key.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/key.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628737   Available: 13576091
Inodes: Total: 5242880    Free: 4960135
1163 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/key.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628737   Available: 13576091
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * A key object.  This provides a nice easy way to create keys.
 *
 * @author ceres
 */
inherit "/std/object";
#include <shops/engrave.h>

/** @ignore yes */
void create() {
  do_setup++;
  ::create();
  do_setup--;

  set_name("key");
  set_long("A key.  Wonder where it fits?.\n");
  add_plural("keys");
  set_short("key");
  add_property(ENGRAVE_PROP, 1);

  if(!do_setup) {
    this_object()->setup();
  }
}

/**
 * Setup the key.  This method handles setting up the short, plural,
 * adjectives etc.
 *
 * @param str The short of the key (minus the word 'key')
 * @param prop The key property (should match the lock)
 */
void set_key( string str, string prop ) {
  string *bits;
  int i;
  set_short( str + " key" );
  set_main_plural( str + " keys" );
  set_name( "key" );
  add_plural( "keys" );
  bits = explode( str, " " );
  for( i = 0; i < sizeof( bits ); i ++ ) {
    add_adjective( bits[i] );
  }
  add_property( prop, 1 );
  set_value( 0 );
  set_weight( 1 );
} /* set_key() */


/** @ignore yes */
mixed query_static_auto_load() {
  if ( base_name(this_object()) + ".c" == __FILE__ )
    return int_query_static_auto_load();
  return ([ ]);
}

// --- END [/mnt/home2/grok/lib/std/key.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/bit.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/bit.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628737   Available: 13576091
Inodes: Total: 5242880    Free: 4960135
18058 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/bit.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628737   Available: 13576091
Inodes: Total: 5242880    Free: 4960135
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * The bit object is the object created to handle bits of corpses, like
 * fingers and eyes and so on.
 * @author Ember
 */
#include <bit.h>
#include <corpse.h>

inherit "std/object";

#define DECAY_TIME 60

mixed *bit_data, *bits;
mixed race_ob;
int corpse_weight;
string race_name, *bits_gone = ({ });
int decay, cured;

void set_bits();
object make_bit(string which_bit);
object *make_bits(string *what_bits);
string *query_bits_left();
string *query_possible_bits(string);

void create() {
  ::create();

  set_short("anonymous bit");
  set_long("This is an unknown bit of some creature.\n");
  corpse_weight = STD_CORPSE_WEIGHT;
  set_weight(5);
  set_name("bit");
  add_property( "corpse bit", 1 );
  add_property("cureable", 1);
} /* create() */

void init() {
  add_command("eat", "<direct:object>");
} /* init() */


/**
 * This method checks to see if the bit is edible or not.
 * @return 1 if it is edible, 0 if not
 */
int query_edible() {
  string bit;
  
  if(!race_ob->query_eat(bit_data[BIT_NAME])) {
    return 0;
  }

  foreach(bit in query_possible_bits(0) - bits_gone) {
    if(!race_ob->query_eat(bit)) {
      return 0;
    }
  }
  return 1;
} /* query_edible() */

/** 
 * The main eat entry point.
 * @return 1 on success, 0 on failure
 */
int do_eat() {
  if(!query_edible())
    return 0;
  move( "/room/rubbish" );
  return 1;
} /* do_eat() */

/**
 * THis method checks to see if the bit can inherently not decay.
 * Like trolls teeth and other such things.
 * @return 1 if it cannot decay, 0 if it can
 */
int no_decay() {
  if( race_ob && bit_data ) {
    return race_ob->query_unrottable(bit_data[BIT_NAME]);
  }
} /* no_decay() */

/**
 * This method sets the race object associated with the corpse.
 * @param s the race object to set
 */
void set_race_ob(object s) {
  race_ob = s;
} /* set_race_ob() */

/**
 * This method sets the name of the race associated with the corpse.
 * @param s the race name to set
 */
void set_race_name(string s) {
  race_name = s;
} /* set_race_name() */

/**
 * This method setsup the long and short based on the current decay
 * levels of the corpse.
 */
void setup_long() {
  if ( !bit_data ) {
    return;
  }
  if (no_decay()) {
    if (race_name) {
      set_short( race_name +" "+ bit_data[ BIT_NAME ] );
      set_main_plural( race_name +" "+ pluralize( bit_data[ BIT_NAME ] ) );
      set_long("This is the " + (bit_data[BIT_NAME]) + " of " +
      add_a(race_name) + ".\n");
    } else {
      set_short( bit_data[ BIT_NAME ] );
      set_main_plural( pluralize( bit_data[ BIT_NAME ] ) );
      set_long("This is the " + (bit_data[BIT_NAME]) +
               " of an unknown creature.\n");
    }
  } else if (decay > 80) {
    if (race_name) {
      set_short( race_name +" "+ bit_data[ BIT_NAME ] );
      set_main_plural( race_name +" "+ pluralize( bit_data[ BIT_NAME ] ) );
      set_long("This is a fresh " + (bit_data[BIT_NAME]) + 
               " severed from the corpse of " + add_a(race_name) + ".\n");
    } else {      set_short( bit_data[ BIT_NAME ] );
      set_main_plural( pluralize( bit_data[ BIT_NAME ] ) );
      set_long("This is a fresh " + (bit_data[BIT_NAME]) +
               " severed from the corpse of an unknown creature.\n");
    }
  } else if (decay > 50) {
    if (race_name) {
      set_short( race_name +" "+ bit_data[ BIT_NAME ] );
      set_main_plural( race_name +" "+ pluralize( bit_data[ BIT_NAME ] ) );
      set_long("This is " + add_a(bit_data[BIT_NAME]) + " severed from the "
               "corpse of " + add_a(race_name) + ".\n");
    } else {
      set_short( bit_data[ BIT_NAME ] );
      set_main_plural( pluralize( bit_data[ BIT_NAME ] ) );
      set_long("This is " + add_a(bit_data[BIT_NAME]) + " severed from the "
               "corpse of an unknown creature.\n");
    }
  } else if (decay > 30) {
    if (race_name) {
      set_short( race_name +" "+ bit_data[ BIT_NAME ] );
      set_main_plural( race_name +" "+ pluralize( bit_data[ BIT_NAME ] ) );
      set_long("This is the partially decayed remains of " +
               add_a(bit_data[BIT_NAME]) + " severed from the "
               "corpse of " + add_a(race_name) + ".\n");
    } else {
      set_short( bit_data[ BIT_NAME ] );
      set_main_plural( pluralize( bit_data[ BIT_NAME ] ) );
      set_long("This is the partially decayed remains of " +
      add_a(bit_data[BIT_NAME]) + " severed from the "
      "corpse of an unknown creature.\n");
    }
  } else {
    if (race_name) {
      set_short( race_name +" "+ bit_data[ BIT_NAME ] );
      set_main_plural( race_name +" "+ pluralize( bit_data[ BIT_NAME ] ) );
      set_long("This is the almost unrecognizable remains of " +
               add_a(bit_data[BIT_NAME]) + " severed from the "
               "corpse of " + add_a(race_name) + ".\n");
    } else {
      set_short( bit_data[ BIT_NAME ] );
      set_main_plural( pluralize( bit_data[ BIT_NAME ] ) );
      set_long("This is the almost unrecognizable remains of " +
               add_a(bit_data[BIT_NAME]) + " severed from the " +
               "corpse of an unknown creature.\n");
    }
  }
  add_extra_look(this_object());
  
  if ( cured ) {
    set_long( query_long() +"It seems to have been pickled.\n" );
  }
} /* setup_long() */

string extra_look() {
  if(sizeof(bits_gone))
    return "It appears to be missing the " + query_multiple_short(bits_gone) + ".\n";
  return "";
}

/**
 * This method sets the weight of the bit.
 * @param i the weight of the bit
 */
void set_corpse_weight(int i) { corpse_weight = i; }

/**
 * This method sets the bit that this actually is.
 * @param s the name of the bit
 * @param dec the current decay numbe
 */
void set_bit(string s, int dec) {
  int temp;

  bit_data = (mixed *)race_ob->query_bit(s);
  if (!bit_data || !sizeof(bit_data)) {
    return;
  }
  if (race_name) {
    add_adjective(race_name);
  } else {
    add_adjective("unknown");
  }
  add_adjective( explode( s, " " ) );
  if ( pointerp( bit_data[ BIT_EXTRA ][ EXTRA_VALUE ] ) &&
       ( sizeof( bit_data[ BIT_EXTRA ][ EXTRA_VALUE ] ) > 3 ) ) {
    set_value(bit_data[BIT_EXTRA][EXTRA_VALUE][3]);
  }
  add_alias( bit_data[ BIT_NAME ] );
  add_plural( pluralize( bit_data[ BIT_NAME ] ) );
  if ( bit_data[ BIT_ALIAS ] && strlen( bit_data[ BIT_ALIAS ] ) ) {
    add_alias(bit_data[BIT_ALIAS]);
    add_plural( pluralize( bit_data[ BIT_ALIAS ] ) );
  }
  if ((temp=bit_data[BIT_EXTRA][EXTRA_WEIGHT] * corpse_weight
             / STD_CORPSE_WEIGHT) > 0) {
    set_weight(temp);
  } else {
    set_weight(1);
  }
  if(dec) {
    decay = dec;
  } else {
    decay = 100;
  }
  if (!no_decay()) {
      BIT_CONTROLLER->add_bit(this_object());
  }
  setup_long();
  set_bits();
  return;
} /* set_bit() */

/**
 * This method is called by the bits controller to do the actual
 * decaying of the object.
 * @return 1 if it still exists, 0 if it has finished decaying
 */
int do_decay() {
  int rate;

  if (!environment()) {
    move( "/room/rubbish" );
    return 0;
  }

  rate = 5 + (int)environment()->query_property( "decay rate" );
  if ( rate > 0 ) {
    decay -= rate;
  }
  if (decay < 0) {
    tell_object(environment(),
                capitalize(the_short()) + " decays to dust.\n");
    move( "/room/rubbish" );
    return 0;
  }
  if (decay == 80 || decay == 50 || decay == 30) {
    setup_long();
  }
  return 1;
} /* do_decay() */

/**
 * This method returns the race object associated with the bit.
 * @return the race object
 */
object query_race_ob() { return race_ob; }

/**
 * This method returns the name of the race associated with this
 * bit.
 * @return the name of the race
 */
string query_race_name() { return race_name; }

/**
 * This method returns the bit data for the bit.  The return array is of
 * the format same format as used in the races.
 * @return the bit data
 * @see /std/races/basic.c
 */
mixed query_bit_data() { return bit_data; }

/**
 * This method returns the current decay level of the corpse
 * @return the current decay level
 */
int query_decay() { return decay; }

/** @ignore yes */
void dest_me() {
  BIT_CONTROLLER->remove_bit(this_object());
  ::dest_me();
} /* dest_me() */

/** @ignore yes */
mixed query_static_auto_load() {
  return int_query_static_auto_load();
} /* query_static_auto_load() */

/** @ignore yes */
mixed query_dynamic_auto_load() {
  return ({ bit_data, race_ob, corpse_weight, race_name,
              decay, cured, bits_gone, ::query_dynamic_auto_load() });
} /* query_dynamic_auto_load() */

/** @ignore yes */
void init_dynamic_arg(mixed arg, object) {
  if (mapp(arg)) {
    ::init_dynamic_arg(arg);
    return ;
  }
  bit_data = arg[0];
  race_ob = arg[1];
  corpse_weight = arg[2];
  race_name = arg[3];
  decay = arg[4];
  cured = arg[5];
  bits_gone = arg[6];
  ::init_dynamic_arg(arg[7]);
  
  if ((!cured) && (!no_decay())) {
    BIT_CONTROLLER->add_bit(this_object());
  }
  setup_long();
  if(sizeof(bit_data))
    set_bits();
} /* init_dynamic_arg() */

/**
 * This method cures the corpse.  A cured bit no longer decays.
 */
void do_cure() {
  if ( cured ) {
    return;
  }
  cured = 1;
  BIT_CONTROLLER->remove_bit( this_object() );
  set_long( query_long() +"It seems to have been pickled.\n" );
  set_short( "cured " + query_short());
  set_main_plural( "cured " + query_main_plural() );
  add_adjective("cured");
} /* do_cure() */

/**
 * This returns the cured state of the bit.
 * @return 1 if it is cured, 0 if not
 */
int query_cured() { return cured; }

/**
 * This method returns the vector used with the potion space.  I 
 * think this call is now obsolete and not used.
 * @return the vectorof the bit
 */
int *query_vect() { return bit_data[BIT_EXTRA][EXTRA_VALUE]; }

/**
 * This method returns the possible bits that can be removed
 * from this bit.  If the bits are restricted then the
 * possible bits are the ones that are contained by that bit.
 * @param word restrict the possible bits
 * @return the list of possible bits
 */
string *query_possible_bits( string word ) {
  int i, j;
  string *possibles;

  possibles = ({ });
  for ( i = sizeof( bits ) - 3; i > -1; i -= 3 ) {
    if ( ( bits[ i ] == word ) ||
         ( bits[ i + 1 ] == word ) ||
         !word) {
      if (arrayp( bits[i+2][2] )) {
        for ( j = 0; j < bits[ i + 2][2][1]; j++ ) {
          possibles += ({ bits[ i ] });
        }
      } else {
        possibles += ({ bits[ i ] });
      }
    }
  }
  return possibles;
} /* query_possible_bits() */

/**
 * This returns the plural of all the possible bit names.
 * If the bits are restricted then the
 * possible bits are the ones that are contained by that bit.
 * @param word restrict the possible bits
 * @return the array of possible bit names
 */
string *query_possible_plural_bits( string word ) {
  int i, j;
  string *possibles;

  possibles = ({ });
  for ( i = sizeof( bits ) - 3; i > -1; i -= 3 ) {
    if (((bits[i] && pluralize(bits[ i ]) == word )) ||
        ((bits[i+1] && pluralize(bits[ i + 1 ]) == word )) ||
        !word) {
      if (arrayp( bits[i+2][2] )) {
        for ( j = 0; j < bits[ i + 2][2][1]; j++ ) {
          possibles += ({ bits[ i ] });
        }
      } else {
        possibles += ({ bits[ i ] });
      }
    }
  }
  return possibles;
} /* query_possible_plural_bits() */

/**
 * This method figures out of the specified bit is left.
 * @return the name of the bit if it is left
 * @param s the bit to check if it is left
 */
string query_bit_left(string s) {
  string *poss_bits;

  poss_bits = query_possible_bits(s);
  if (!poss_bits || !sizeof(poss_bits)) {
     return 0;
  }

  poss_bits = poss_bits - bits_gone;

  if (!sizeof(poss_bits)) {
    return 0;
  }

  return poss_bits[0];
} /* query_bit_left() */

/**
 * This method figures out of the specified bit is left using the plural name.
 * @return the name of the bit if it is left
 * @param s the bit to check if it is left
 */
string *query_bit_left_pl(string s) {
  string *poss_bits;

  poss_bits = query_possible_plural_bits(s);
  if (!poss_bits || !sizeof(poss_bits)) {
    return 0;
  }

  poss_bits = poss_bits - bits_gone;
  if (!sizeof(poss_bits)) {
    return 0;
  }

  return poss_bits;
} /* query_bit_left() */

/** @ignore yes */
object *find_inv_match( string s, object looker ) {
  string bit, *bit_pl;
  object *weap, wep, tmp;
  int cut;

  bit = query_bit_left(s);
  bit_pl = query_bit_left_pl(s);

  if (!bit && !sizeof(bit_pl))
    return all_inventory();
  cut = 0;
  if(looker)
    weap = (object *)looker->query_weapons();
  if (sizeof(weap)) {
    foreach( wep in weap ) {
      if (wep->id("dagger") || wep->id("knife"))
        cut = 1;
    }
  }
  if (bit) {
    if (cut || (string)race_ob->query_pluckable(bit)) {
      tmp = make_bit(bit);
      return ({ tmp  });
    }
    if (sizeof(weap)) {
      tell_object( looker, "You can only cut things from "+a_short()+
                           " with a knife or dagger.\n" );
    } else {
      tell_object( looker, "You can't cut bits from "+a_short()+" with your "
                           "bare hands.\n" );
    }
    return ({ });
  }
  if (sizeof(bit_pl)) {
    if (cut) {
      if (sizeof(bit_pl) > 5) {
        return make_bits(bit_pl[0..4]);
      } else {
        return make_bits(bit_pl);
      }
    }
    foreach( bit in bit_pl ) {
      if (!((string)race_ob->query_pluckable(bit)))
        bit_pl -= ({ bit });
    }
    if (sizeof(bit_pl)) {
      if (sizeof(bit_pl) > 5) {
        return make_bits(bit_pl[0..4]);
      } else {
        return make_bits(bit_pl);
      }
    }
    if (sizeof(weap)) {
      tell_object( looker, "You can only cut things from "+a_short()+
                           " with a knife or dagger.\n" );
    } else {
      tell_object( looker, "You can't cut bits from "+a_short()+" with your "
                           "bare hands.\n" );
    }
    return ({ });
  }
}  /* find_inv_match() */

/**
 * This method creates a bit from the current bit.
 * @param which_bit the name of the bit to create
 * @return the object that is the new bit
 */
object make_bit(string which_bit) {
  mixed *bit;
  object bitobj;
  int i,j;

  bit = race_ob->query_bit(which_bit);
  if ((sizeof(bit[2][2]) > 1) && stringp(bit[2][2][1])) {
    bitobj = clone_object( bit[2][2] );
  } else if (bit[2][2] == 0) {
    bitobj = clone_object("/std/bit");
  } else {
    bitobj = clone_object("/std/bit");
  }
  bitobj->set_race_ob(race_ob);
  if (race_name) bitobj->set_race_name(race_name);
  else bitobj->set_race_name(race_ob->query_name());
  bitobj->set_corpse_weight(query_weight());
  if(!race_ob->query_eat(bit[BIT_NAME])) {
    bitobj->set_bit(bit[0], 0);
  } else {
    bitobj->set_bit(bit[0], (decay * 2) / 3);
  }

  for (i = 0; i < sizeof(bits_gone); i++) {
    j = member_array(bits_gone[i], bit[BIT_EXTRA]);
    if (j >= 0) {
      bitobj->add_bit_gone(bits_gone[i]);
    }
  }
  bits_gone += ({ bit[BIT_NAME] }) + bit[BIT_EXTRA][3..50];
  if (environment()) {
    bitobj->move(environment());
  }
  return bitobj;
} /* make_bit() */

/**
 * This method makes a bunch of bits at once.
 * @param what_bits the list of bits to create
 * @return the array of made bits
 */
object *make_bits(string *what_bits) {
  string bit;
  object *bit_pl = ({ });
  
  foreach(bit in what_bits) {
    bit_pl += ({ make_bit(bit) });
  }
  return bit_pl;
} /* make_bits() */

/**
 * This method returns the current array of bits gone from this
 * bit.
 * @return the list of missing bits
 */
string *query_bits_gone() { return bits_gone; }

mixed *add_bit_gone( string bit ) {
  string *poss_bits, tempbit;
  mixed *bit_details;
  int i;

  poss_bits = query_possible_bits( bit ) - bits_gone;
  if ( !sizeof( poss_bits ) ) return 0;
  bit_details = (mixed *)race_ob->query_bit( poss_bits[ 0 ] );
  bits_gone += ({ bit_details[ BIT_NAME ] });
  foreach (tempbit in bit_details[ BIT_EXTRA ][ 3 .. sizeof(bit_details[BIT_EXTRA]) ]) {
    if (arrayp(race_ob->query_bit( tempbit )[2][2]) && intp(race_ob->query_bit( tempbit )[2][2][1])) {
      for (i = 0; i < race_ob->query_bit( tempbit )[2][2][1]; i++) {
        bits_gone += ({ tempbit });
      }
    }
  }
  return bit_details;
} /* add_bit_gone() */

/**
 * This method sets the array of gone bits on the bit.
 * @param bits the set of bits gone to set
 */
void set_bits_gone( string *bits ) {
  int i;

  bits_gone = ({ });
  for ( i = 0; i < sizeof( bits ); i++ ) {
    add_bit_gone( bits[ i ] );
  }
} /* set_bits_gone() */

/**
 * This method returns the current array of bits left.
 * @return the array of bits left
 */
string *query_bits_left() {
  int i, j;
  string *all_bits;
  mixed *bit_pl;

  bit_pl = (mixed *)race_ob->query_bits();
  all_bits = ({ });
  for ( i = 0; i < sizeof( bit_pl ); i += 3 ) {
    if (arrayp( bit_pl[i+2][2] )) {
      for ( j = 0; j < bit_pl[ i + 2][2][1]; j++ ) {
        all_bits += ({ bit_pl[ i ] });
      }
    } else {
      all_bits += ({ bit_pl[ i ] });
    }
  }
  return all_bits - bits_gone;
} /* query_bits_left */

/**
 * This method sets all the basic bits for the bit when it is first created.
 */
void set_bits() {
  int i, j;
  mixed *these_bits, *all_bits;

  bits = ({ });

  these_bits = bit_data;
  all_bits = race_ob->query_bits();

  for (i=3; i<sizeof(these_bits[2]); i++) {
    for (j=0; j<sizeof(all_bits); j = j+3) {
      if ((these_bits[0] == all_bits[j+2][0]) && (these_bits[2][i] == all_bits[j])) {
        bits += all_bits[j..j+2];
        delete(all_bits, j, 2);
        break;
      }
    }
  }
} /* set_bits */

string query_determinate(object caller)  {
   return race_ob->query_determinate(caller);
}

string query_medium_alias() { 
  string temp;
  string *temp2 = ({ });

    if ( !sizeof( bit_data ) )
        return "";

    //Dodgy string munging stuff. OH YEAH!
    temp = bit_data[0];
    temp2 = explode( temp, " " );
    temp2 = map( temp2, (: capitalize( $1 ) :) );
    temp = implode( temp2, "" );

    return temp + "Of" + capitalize( race_ob->query_name() ) ;
}

int query_collective() {
  if(query_verb() == "get" || query_verb() == "take")
    return 1;
}
// --- END [/mnt/home2/grok/lib/std/bit.c] ---
// --- BEGIN [/mnt/home2/grok/lib/net/daemon/mysql.c] ---
// Size:   File: "/mnt/home2/grok/lib/net/daemon/mysql.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628732   Available: 13576086
Inodes: Total: 5242880    Free: 4960135
7416 bytes, Last Modified:   File: "/mnt/home2/grok/lib/net/daemon/mysql.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628732   Available: 13576086
Inodes: Total: 5242880    Free: 4960135
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: mysql.c,v 1.15 2003/02/19 21:02:07 pinkfish Exp $
 * $Log: mysql.c,v $
 * Revision 1.15  2003/02/19 21:02:07  pinkfish
 * Make better end of packet detection things.
 *
 * Revision 1.14  2003/02/07 02:46:03  pinkfish
 * Fix up some more issues with mysql and newlines.
 *
 * Revision 1.13  2003/02/07 02:07:08  pinkfish
 * Fix up some errors in how it handles the return of sql queries.
 *
 * Revision 1.12  2001/07/26 18:17:57  pinkfish
 * Working fine.
 *
 * Revision 1.11  2001/03/13 04:37:56  ceres
 * Fixed runtime
 *
 * Revision 1.10  2001/03/13 01:03:19  ceres
 * Fixed runtime
 *
 * Revision 1.9  2001/03/11 18:33:38  pinkfish
 * Fix p a runtime that was causing errors in the sql handling.
 *
 * Revision 1.8  2001/03/09 21:15:00  pinkfish
 * Fix up the fix.
 *
 * Revision 1.7  2001/03/09 21:01:14  pinkfish
 * Fix up issues with two many sql reuqests in a row.
 *
 * Revision 1.6  2001/03/09 20:51:51  pinkfish
 * Add in some testing stuff.
 *
 * Revision 1.5  2001/03/07 20:16:15  pinkfish
 * Add in an example and fix some small issues.
 *
 * Revision 1.4  2000/07/14 03:54:50  pinkfish
 * Change it to work over multiple chunk sends.
 *
 * Revision 1.3  2000/07/14 03:10:42  pinkfish
 * Add in some code to do debugging.
 *
 * Revision 1.2  2000/06/21 20:37:17  pinkfish
 * Fix up a biunch of things.
 *
 * Revision 1.1  2000/06/20 05:10:02  pinkfish
 * Initial revision
 *
 * Revision 1.1  1998/01/06 05:17:08  ceres
 * Initial revision
 * 
*/
/**
 * This object handles all the mysql requests for the system.
 * It connects to an external python script todo the actual mysql processing,
 * it is done this way to make the sql requests non-blocking so they do not
 * slow down the mud.
 * @author Pinkfish
 * @started Tue Jun 20 14:29:01 PDT 2000
 */
#include <network.h>

inherit CLIENT;

#include <db.h>

private int _fd;
private int _currentId;
private int _callout_id;
private mapping _requests;
private string data;

protected void setup() {
   int id;
   function func;

   _fd = eventCreateSocket("127.0.0.1", 7865);
   if (_fd < 0) {
      // This has been commented out for my sanity
      //printf("Bad fd.\n");
      remove_call_out(_callout_id);
      _callout_id = call_out("setup", 10);
      //
      // Send back an error to anyone still waiting.
      //
      foreach (id, func in _requests) {
         map_delete(_requests, id);
         evaluate(func, DB_ERROR_BAD_SOCKET, socket_error(_fd));
      }
   }
} /* setup() */

void create() {
   ::create();
   _fd = -1;
   _requests = ([ ]);
   data = "";
   setup();
} /* create() */

private void locate_value(string req, int newline) {
   mixed junk;
   function fluff;
   int index;
   int new_index;
   string test_data;
   string check_data;
	
   if(!req)
     return;

   test_data = data + req;
   index = -1;
   do {
      new_index = strsrch(test_data[index + 1..], "SQL_END_QUERY");
//tell_creator("pinkfish", "Chunk (%O %O %O)\n", test_data[index+1..50], new_index, index);
      // Not found the end marker.
      if (new_index == -1) {
         if (newline) {
            data += req + "\n";
         } else {
            data += req;
         }
         return ;
      }
      index += new_index + 1;
   } while (test_data[index - 1] == '+');
   check_data = test_data[0..index - 1];
   data = test_data[index + 13..];
//tell_creator("pinkfish", "Data: %O %O\n", check_data, data);
   catch(junk = restore_variable(check_data));
   if (pointerp(junk) && sizeof(junk)) {
//tell_creator("pinkfish", "Resolved...\n");
      fluff = _requests[junk[0]];
      map_delete(_requests, junk[0]);
      if (fluff) {
//tell_creator("pinkfish", "%O: %O %O\n", data + req, junk, fluff);
         evaluate(fluff, junk[1], junk[2]);
      }
   }
} /* locate_value() */

/** @ignore yes */
void eventRead(int fd, string str) {
   string req;
   string* bits;

   if (strlen(str) == 1 && str[<1] == '\n') {
      locate_value("", 1);
      return ;
   }
   bits = explode(str, "\n");
//tell_creator("pinkfish", "Stuff (%O)\n", str);
   foreach (req in bits[0..<2]) {
      locate_value(req, 1);
   }
   locate_value(bits[<1], 0);
   //data += bits[<1];
   //if (str[<1] == '\n') {
      //locate_value("");
   //}
} /* eventRead() */

/** @ignore yes */
protected void eventNewConnection(int fd) {
} /* eventNewConnection() */

/** @ignore yes */
protected void eventSocketClosed(int fd) {
  _fd = -1;
  remove_call_out(_callout_id);
  _callout_id = call_out("setup", 10);
} /* eventSocketClosed() */

/** @ignore yes */
protected void eventSocketError(string str, int x) {
  //tell_creator("pinkfish", str + " -- " + socket_error(x) + " -- " + x + "\n");
  _fd = -1;
  remove_call_out(_callout_id);
  _callout_id = call_out("setup", 10);
}

/** @ignore yes */
protected void eventSocketClose(int fd) {
  _fd = -1;
  remove_call_out(_callout_id);
  _callout_id = call_out("setup", 10);
} /* eventSocketClose() */

/**
 * This is the method you call to make an sql request.  You pass in the
 * database, user and password you wish to use to connect to the
 * sql sever.  You also pass in the request you wish to make and the call
 * back function to call.
 * <p>
 * The call back function will be passed two arguements, they are a
 * 'type' and a 'data' arguement.  The type will always be an integer and
 * it registers the success or failure of the database query.  The
 * data will either be a string (in the case of an error) or it will be
 * teh returned data (in the case of request).  The returned data will
 * be an array of mappings, the mappings contain keys of the field type
 * and the data value being the returned data.
 * <p>
 * The format of the function call is:<br>
 * void return_function(int status, mapping data)
 * @example
 * void finish_request(int type, mixed* data, object person) {
 *    string ret;
 *    mapping row;
 * 
 *    if (type == DB_SUCCESS) {
 *       ret = "";
 *       foreach (row in data) {
 *          ret += sprintf("%-15s %s\n", row["Fixer"], "" + row["bing"]);
 *       }
 *    } else {
 *       ret = "Some sort of horrible error!\n";
 *    }
 *    person->more_string(ret, "details");
 * }
 *
 * DB_HANDLER->make_sql_request("errors", CONFIG_DB_USER, "", request,
 *                             (: finish_request($1, $2, $(this_player())) :));
 * @param db the database to connect to
 * @param user the user to use
 * @param pass the password to use
 * @param request the request to make
 * @param finish the call back function
 */
void make_sql_request(string db, string user, string pass, string request,
                      function finish) {
   mixed *stuff;

   if (!functionp(finish)) {
      printf("finish arguement to make_sql_request is not a function.\n");
      return ;
   }

   _requests[_currentId] = finish;
   if (_fd == -1) {
      setup();
   }
   if (_fd == -1) {
      return ;
   }
   stuff = ({ _currentId++, user, pass, db, request });
   eventWrite(_fd, save_variable(stuff) + "\n");
} /* make_sql_request() */

/**
 * This will do exciting things when we dest.
 * @ignore yes
 */
void dest_me() {
   int id;
   function func;

   foreach (id, func in _requests) {
      map_delete(_requests, id);
      catch(evaluate(func, DB_ERROR_BAD_SOCKET, "the server was dested."));
   }
   ::dest_me();
} /* dest_me() */

/** @ignore yes */
mapping query_requests() {
   return copy(_requests);
} /* query_requests() */
// --- END [/mnt/home2/grok/lib/net/daemon/mysql.c] ---
// --- BEGIN [/mnt/home2/grok/lib/net/daemon/out_auth.c] ---
// Size:   File: "/mnt/home2/grok/lib/net/daemon/out_auth.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628730   Available: 13576084
Inodes: Total: 5242880    Free: 4960135
1879 bytes, Last Modified:   File: "/mnt/home2/grok/lib/net/daemon/out_auth.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628730   Available: 13576084
Inodes: Total: 5242880    Free: 4960135
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Id: out_auth.c,v 1.3 1999/11/23 12:58:56 turrican Exp $
 */
/*
 * This will connect up to an auth demon and get it to return our
 * login name.
 * Written by Pinkfish.
 * Rewritten by Turrican on 23-4-96.
 */
#include <network.h>

inherit CLIENT;

class auth {
  object Object;
  string Function;
}

private nosave mapping found;

#define AUTH_PORT 113

protected void create() {
  client::create();
  SetSocketType(STREAM);
  SetDestructOnClose(1);
  found = ([]);
} /* create() */

void query_auth(string func) {
  string addr;
  int port, fd;
  class auth auth;

  /* Disable for now, until we find a way to stop denial-of-service
     attacks */
  call_other(previous_object(), func, 0);
  return;
  addr = socket_address(previous_object());
  if (!addr) {
    call_other(previous_object(), func, 0);
    return;
  }
  sscanf(addr, "%s %d", addr, port);
  if ((fd = eventCreateSocket(addr, AUTH_PORT)) < 0) {
    call_other(previous_object(), func, 0);
    return;
  }
  auth = new(class auth);
  auth->Object = previous_object();
  auth->Function = func;
  found[fd] = auth;
  eventWrite(fd, sprintf("%d , %d\r\n", port,
                         query_ip_port(previous_object())));
} /* query_auth() */

protected void eventRead(int fd, string mess) {
  string name;
  class auth auth;

  mess = replace_string(mess, "\r\n", "\n");
  sscanf(mess, "%*d , %*d : %*s : %*s : %s\n", name);
  if (!(auth = (class auth)found[fd])) {
    eventAbortCallback(fd);
    return;
  }
  if (objectp(auth->Object)) {
    call_other(auth->Object, auth->Function, name);
    auth->Object = 0;
  }
  eventAbortCallback(fd);
}

protected void eventSocketClose(int fd) {
  class auth auth = (class auth)found[fd];

  if (auth) {
    if (objectp(auth->Object))
      call_other(auth->Object, auth->Function, 0);
    map_delete(found, fd);
  }
} /* close_callback() */
// --- END [/mnt/home2/grok/lib/net/daemon/out_auth.c] ---
// --- BEGIN [/mnt/home2/grok/lib/net/daemon/nhttp.c] ---
// Size:   File: "/mnt/home2/grok/lib/net/daemon/nhttp.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628729   Available: 13576083
Inodes: Total: 5242880    Free: 4960135
66986 bytes, Last Modified:   File: "/mnt/home2/grok/lib/net/daemon/nhttp.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628729   Available: 13576083
Inodes: Total: 5242880    Free: 4960135
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker: pinkfish $
 * $Id: http.c,v 1.25 2000/06/27 19:00:39 turrican Exp pinkfish $
 */
/*    /daemon/http.c
 *    from Nightmare IV
 *    an http daemon that can talk to Mosaic and other WWW clients
 *    created by Descartes of Borg 940521
 *    callback fix by Robocoder 950117
 *    modified for discworld Pinkfish 10th of March 1995
 *    modified to allow 302 (diverted address) messages on 23rd of Feburary 1996
 *              - Pinkfish
 *    modified to use the new inheritable server object by Turrican, 24-4-96
 *    basically rewritten to be more HTTP/1.x compliant - Turrican, 31-1-97
 *    modified to add conditional gets and the like - Turrican, 11-2-97
 *    modified to be conditionally HTTP/1.1 compliant - Turrican, 24-6-97
 *    modified to add the "POST" method - Turrican, 27-6-97
 *    modified to add support for byteranges - Turrican, 2-7-97
 *    modified to add support for reading chunked bodies - Turrican, 22-7-97
 *    modified to support files larger than 200k - Pinkfish 11-11-97
 *    modified to add Basic authentication scheme - Turrican, 19-11-97
 *    modified to decode post attempts - Pinkfish, 20-11-97
 */

/* ====================================================================
 * Copyright (c) 1995-1997 The Apache Group.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the Apache Group
 *    for use in the Apache HTTP server project (http://www.apache.org/)."
 *
 * 4. The names "Apache Server" and "Apache Group" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission.
 *
 * 5. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the Apache Group
 *    for use in the Apache HTTP server project (http://www.apache.org/)."
 *
 * THIS SOFTWARE IS PROVIDED BY THE APACHE GROUP ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE APACHE GROUP OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Group and was originally based
 * on public domain software written at the National Center for
 * Supercomputing Applications, University of Illinois, Urbana-Champaign.
 * For more information on the Apache Group and the Apache HTTP server
 * project, please see <http://www.apache.org/>.
 *
 */

#include <network.h>
#include <localtime.h>
#include <runtime_config.h>
#include <login.h>
#include <config.h>

inherit SERVER;

#include <http.h>

#define IS_PATH 1
#define NOT_PATH 0

#define LOGGING 1

protected int www_resolve(class http_request req);
protected void resolve_incoming(string addr, string nom, int cle);
private void http_error(int fd, int status);
varargs private void add_activity(int fd, string str, mixed *args ...);
varargs protected void close_connection(int fd, int persist);
varargs private void get_file(class http_request req, string body);
string format_date(int x);
protected void send_file(int fd, string str);
protected void send_string(int fd, string str, int last_mod, string location,
                           int no_length);
protected void parse_headers(class http_request req, int i);

protected void send_string_array(int fd, string *str, int mod_date,
                           string location, int no_length);

private nosave mapping Sockets;
private nosave mapping Resolve; 
private nosave string current_file;
private nosave int max_file_size;

#ifdef TRACK_PAGE_STATS
mapping http_stats;
#endif

// stuff used for log caching
nosave string log_str;
nosave string cday;

protected void create() {
   server::create();
   SetSocketType(STREAM);
   SetDestructOnClose(1);
   Sockets = ([]);
   Resolve = ([]);

   max_file_size = get_config(__MAX_BUFFER_SIZE__);
   if (get_config(__MAX_STRING_LENGTH__) < max_file_size) {
      max_file_size =get_config(__MAX_STRING_LENGTH__);
   }
   if ( get_config(__MAX_READ_FILE_SIZE__) < max_file_size) {
      max_file_size = get_config(__MAX_READ_FILE_SIZE__);
   }
   if (get_config(__MAX_BYTE_TRANSFER__) < max_file_size) {
      max_file_size = get_config(__MAX_BYTE_TRANSFER__);
   }
   
   call_out("setup", 2);
   call_out("clean_sockets", 180);
   unguarded((: restore_object, SAVE_FILE :));
#ifdef TRACK_PAGE_STATS
   if (!mapp(http_stats)) {
      http_stats = ([]);
   }
#endif  
} /* create() */

protected void setup() {
   if (eventCreateSocket(PORT_HTTP) < 0) {
      if (this_object()) destruct(this_object());
   }
} /* setup() */

protected void reset() {
#ifdef TRACK_PAGE_STATS
   unguarded((: save_object, SAVE_FILE :));
#endif  
}

int hex_to_decimal(string str) {
   int ret;

   ret = ((str[0] >= 'A') ? ((str[0] & 0xdf) - 'A')+10 : (str[0] - '0'));
   ret *= 16;
   ret += (str[1] >= 'A' ? ((str[1] & 0xdf) - 'A')+10 : (str[1] - '0'));
   
   return ret;
} /* hex_to_decimal() */

/*
 * Replace all the mime codes in the address,
 * return HTTP_OK on success, error code on failure.
 */
int unmime(string ref url, int is_path) {
   int x, y, badesc, badpath, len, char, pos = -1;

   badesc = 0;
   badpath = 0;
   len = strlen(url);
   for (x = 0, y = 0; y < len; ++x, ++y) {
      if (url[y] != '%') {
         url[x] = url[y];
      } else {
         if (!isxdigit(url[y+1]) || !isxdigit(url[y+2])) {
            badesc = 1;
            url[x] = '%';
         } else {
            char = hex_to_decimal(url[y+1..]);
            y += 2;
            if (char) {
               url[x] = char;
            } else if (pos == -1) {
               pos = x;
            }
            if ((char == '/' && is_path) || !char) {
               badpath = 1;
            }
         }
      }
   }
   url = url[0..x-1];
   if (badesc) {
      return BAD_CMD;
   } else if (badpath) {
      url = url[0..pos-1];
      return NOT_FOUND;
   } else {
      return HTTP_OK;
   }
} /* unmime() */

string mime(string str) {
   return replace_string(str, " ", "%20");
} /* mime() */

string escape_html(string s) {
   return replace(s, ({ "&", "&amp;", "<", "&lt;", ">", "&gt;"}));
} /* escape_html() */

string next_token(string ref line) {
   int i, len = strlen(line);
   string ret, tspecials = " \t()<>@,;:\\/[]?={}";
   
   while ((i < len) && (iscntrl(line[i]) ||
                        (strsrch(tspecials, line[i]) != -1))) {
      if (line[i] == '"') {
         while ((i < len) && (line[i] != '"'))
            ++i;
      } else {
         ++i;
      }
   }
   if (i == len) {
      ret = 0;
   } else {
      ret = line[i..];
      
      i = 0;
      while ((i < len) && !iscntrl(line[i]) &&
             (strsrch(tspecials, line[i]) == -1)) {
         ++i;
      }
      
      if (i < len) {
         line = line[i+1..];
      } else {
         line = "";
      }
   }
   return (ret ? ret[0..i-1] : 0);
} /* next_token() */

int find_token(string line, string token) {
   string ltok;
  
   if (!line) {
      return 0;
   }

   while ((ltok = next_token(ref line))) {
      if (lower_case(ltok) == lower_case(token)) {
         return 1;
      }
   }

   return 0;
} /* find_token() */

int find_last_token(string line, string token) {
   int tlen;
   
   tlen = strlen(token);
   if (!line ||
       (strlen(line) <= tlen) ||
       (!isspace(line[<tlen+1]) && (line[<tlen+1] != ','))) {
      return 0;
   }
   return (lower_case(line[<tlen..]) == lower_case(token));
} /* find_last_token() */

protected void eventNewConnection(int fd) {
   class http_request t;
   string tmp;
   int x;

   server::eventNewConnection(fd);
   sscanf(socket_address(fd), "%s %*s", tmp);
   x = resolve(tmp, "resolve_callback");
   Resolve[x] = fd;
   t = new(class http_request, uri : "", request : "", status : TIME_OUT);
   t->sess = new(class http_session, fd : fd, address : tmp);
   t->rh = new(class http_request_header);
   t->rh->headers_in = new(class mime_header, header_m : ([ ]), header_k : ({ }));
   t->rh->headers_out = new(class mime_header, header_m : ([ ]), header_k : ({ }));
   t->rh->err_headers_out = new(class mime_header, header_m : ([ ]), header_k : ({ }));
   t->body = new(class http_body);
   t->bi = new(class http_body_info);
   Sockets[fd] = t;
} /* eventNewConnection */

protected int parse_byterange(string range, int clength, int ref start,
                              int ref end) {
   int len;
   int num;
   int dashpos = strsrch(range, '-');
   string dash;

   if (dashpos == -1) {
      return 0;
   }

   if (dashpos == 0) {
      /* In the form "-5" */
      sscanf(range[dashpos+1..], "%d", num);
      start = clength - num;
      end = clength - 1;
   } else {
      len = strlen(range);
      dash = range;
      range = range[0..dashpos-1];
      dashpos++;
      sscanf(range, "%d", start);
      if (dashpos < len) {
         sscanf(dash[dashpos..], "%d", end);
      } else {
         end = clength - 1;
      }
   }
   
   if (start > end) {
      return 0;
   }
   
   if (end >= clength) {
      end = clength - 1;
   }
   
   return 1;
} /* parse_byterange() */

protected int internal_byterange(int realreq, int ref tlength,
                                 class http_request req, string ref r_range,
                                 int ref offset, int ref length) {
   int range_start;
   int range_end;
   int i;
   string range;

   if (!strlen(r_range)) {
      if (req->bi->byterange > 1) {
         if (realreq) {
            eventWrite(req->sess->fd, sprintf("\r\n--%s--\r\n",
                                              req->bi->boundary));
         } else {
            tlength += 4 + strlen(req->bi->boundary) + 4;
         }
      }
      return 0;
   }
   
   if ((i = strsrch(r_range, ',')) == -1) {
      range = r_range;
      r_range = "";
   } else {
      range = r_range[0..i-1];
      r_range = r_range[i+1..];
   }
   
   if (!parse_byterange(range, req->bi->clength, ref range_start,
                        ref range_end))
      return internal_byterange(realreq, ref tlength, req, ref r_range,
                                ref offset, ref length);
   
   if (req->bi->byterange > 1) {
      string ts;
      string ct;
      
      ct = req->bi->content_type ? req->bi->content_type : "text/html";
      ts = sprintf("%d-%d/%d", range_start, range_end, req->bi->clength);
      if (realreq) {
         eventWrite(req->sess->fd, sprintf("\r\n--%s\r\nContent-Type: %s\r\n"
                                           "Content-Range: bytes %s\r\n\r\n",
                                           req->bi->boundary, ct, ts));
      } else {
         tlength += 4 + strlen(req->bi->boundary) + 16 + strlen(ct) + 23 +
            strlen(ts) + 4;
      }
   }
   if (realreq) {
      offset = range_start;
      length = range_end - range_start;
   } else {
      tlength += range_end - range_start + 1;
   }
   return 1;
} /* internal_byterange() */

protected int each_byterange(class http_request req, int ref offset,
                             int ref length) {
   int tlength;
   
   return internal_byterange(1, ref tlength, req, ref req->bi->range,
                             ref offset, ref length);
} /* each_byterange() */

protected int set_byterange(class http_request req) {
   string range;
   string if_range;
   string match;
   int range_start;
   int range_end;
   
   if (!req->bi->clength || req->rh->noheaders) {
      return 0;
   }
  
   if (!(range = req->rh->headers_in->header_m["range"])) {
      range = req->rh->headers_in->header_m["request-range"];
   }

   if (!range || (range[0..5] != "bytes=")) {
      req->rh->headers_out->header_m["Accept-Ranges"] = "bytes";
      req->rh->headers_out->header_k += ({ "Accept-Ranges" });
      return 0;
   }

   if ((if_range = req->rh->headers_in->header_m["if-range"])) {
      if (if_range[0] == '"') {
         if (!(match = req->rh->headers_out->header_m["ETag"]) ||
             (lower_case(match) != lower_case(if_range))) {
            return 0;
         }
      } else if (!(match = req->rh->headers_out->header_m["Last-Modified"]) ||
                 (lower_case(match) != lower_case(if_range))) {
         return 0;
      }
   }

   if (strsrch(range, ',') == -1) {
      if (!parse_byterange(range[6..], req->bi->clength, ref range_start,
                           ref range_end)) {
         return 0;
      }

      req->bi->byterange = 1;
      req->rh->headers_out->header_m["Content-Range"] =
         sprintf("bytes %d-%d/%d", range_start, range_end, req->bi->clength);
      req->rh->headers_out->header_m["Content-Length"] =
         sprintf("%d", range_end - range_start + 1);
      req->rh->headers_out->header_k += ({ "Content-Range" });
   } else {
      int tlength, d1, d2;
      string r_range = range[6..];
      
      req->bi->byterange = 2;
      req->bi->boundary = sprintf("%x%x", req->time, req->sess->fd);
      while (internal_byterange(0, ref tlength, req, ref r_range, ref d1,
                                ref d2)) {
         ;
      }
      req->rh->headers_out->header_m["Content-Length"] =
         sprintf("%d", tlength);
   }
   
   req->status = PARTIAL_CONTENT;
   req->bi->range = range[6..];
   
   return 1;
} /* set_byterange() */

protected int set_persist(class http_request req) {
   int ka_sent;
   int wimpy;
   string conn = req->rh->headers_in->header_m["connection"];
   
   wimpy = find_token(req->rh->headers_out->header_m["Connection"], "close");
   if (((req->status == NOT_MODIFIED) ||
        (req->status == NO_CONTENT) ||
        req->rh->header_only ||
        !undefinedp(req->rh->headers_out->header_m["Content-Length"]) ||
        find_last_token(req->rh->headers_out->header_m["Transfer-Encoding"],
                        "chunked") ||
        ((req->proto_num >= 1001) && (req->bi->chunked = 1))) &&
       !status_drops_connection(req->status) &&
       !wimpy &&
       !find_token(conn, "close") &&
       (((ka_sent = find_token(conn, "keep-alive"))) ||
        (req->proto_num >= 1001))
       ) {
      req->persistent = 1;
      
      /* If they sent a Keep-Alive token, send one back */
      if (ka_sent) {
         req->rh->headers_out->header_m["Keep-Alive"] = "timeout=15";
         req->rh->headers_out->header_k += ({ "Keep-Alive" });
         if (!undefinedp(req->rh->headers_out->header_m["Connection"])) {
            req->rh->headers_out->header_m["Connection"] += ", Keep-Alive";
         } else {
            req->rh->headers_out->header_m["Connection"] = "Keep-Alive";
            req->rh->headers_out->header_k += ({ "Connection" });
         }
      }
      
      return 1;
   }
   
   if (!undefinedp(req->rh->headers_out->header_m["Connection"])) {
      req->rh->headers_out->header_m["Connection"] += ", close";
   } else {
      req->rh->headers_out->header_m["Connection"] = "close";
      req->rh->headers_out->header_k += ({ "Connection" });
   }
   
   req->persistent = 0;
   
   return 0;
} /* set_persist() */

protected void basic_header(class http_request req) {
   int fd = req->sess->fd;
   
   if (req->rh->noheaders) {
      return;
   }
   if (!req->status_line) {
      req->status_line = status_lines[req->status];
   }
   eventWrite(fd, sprintf("%s %s\r\n", HTTP_PROTOCOL, req->status_line));
   eventWrite(fd, sprintf("Date: %s\r\n", format_date(req->time)));
   eventWrite(fd, sprintf("Server: %s\r\n", HTTP_VERSION));
   
   map_delete(req->rh->headers_out->header_m, "Date");
   map_delete(req->rh->headers_out->header_m, "Server");
   req->rh->headers_out->header_k -= ({ "Date", "Server" });
} /* basic_header() */

protected void send_headers(class http_request req, mapping headers,
                            mixed *args ...) {
   string key;
   
   foreach (key in args) {
      if (undefinedp(headers[key])) {
         continue;
      }
      eventWrite(req->sess->fd, sprintf("%s: %s\r\n", key,
                                        headers[key]));
   }
   eventWrite(req->sess->fd, "\r\n");
} /* send_headers() */

protected int use_range_x(class http_request req) {
   string ua;
  
   return (!undefinedp(req->rh->headers_in->header_m["request-range"]) ||
           ((ua = req->rh->headers_in->header_m["user-agent"]) &&
            (strsrch(ua, "MSIE 3") != -1)));
} /* use_range_x() */

protected void http_header(class http_request req) {
   if (req->rh->noheaders)
      return;
   
   basic_header(req);
   
   set_persist(req);
   
   if (req->bi->chunked) {
      if (!undefinedp(req->rh->headers_out->header_m["Transfer-Encoding"])) {
         req->rh->headers_out->header_m["Transfer-Encoding"] += ", chunked";
      } else {
         req->rh->headers_out->header_m["Transfer-Encoding"] = "chunked";
      }
      req->rh->headers_out->header_k += ({ "Transfer-Encoding" });
      map_delete(req->rh->headers_out->header_m, "Content-Length");
      req->rh->headers_out->header_k -= ({ "Content-Length" });
   }
   
   if (req->bi->byterange > 1) {
      req->rh->headers_out->header_m["Content-Type"] =
         sprintf("multipart%sbyteranges; boundary=%s",
                 (use_range_x(req) ? "/x-" : "/"), req->bi->boundary);
   } else if (req->bi->content_type) {
      req->rh->headers_out->header_m["Content-Type"] = req->bi->content_type;
   } else {
      req->rh->headers_out->header_m["Content-Type"] = "text/plain";
   }
   req->rh->headers_out->header_k += ({ "Content-Type" });
   
   /* Not used yet 
      if (req->no_cache &&
      undefinedp(req->rh->headers_out->header_m["Expires"])) {
      req->rh->headers_out->header_m["Expires"] = format_date(req->time);
      req->rh->headers_out->header_k += ({ "Expires" });
      } */

   send_headers(req, req->rh->headers_out->header_m,
                req->rh->headers_out->header_k ...);
} /* http_header() */

protected void handle_request(class http_request req) {
   int errno;
   int fd = req->sess->fd;
   string buff;
   string key;
   
   if (req->method == "HEAD") {
      if (req->rh->noheaders) {
         http_error(fd, BAD_CMD);
         return;
      }
      req->rh->header_only = 1;
   }
   if ((!req->hostname && (req->proto_num >= 1001)) ||
       ((req->proto_num == 1001) &&
        undefinedp(req->rh->headers_in->header_m["host"]))) {
      /* Client didn't send the hostname, HTTP/1.1 requires this. */
      TP("client sent HTTP/1.1 request without hostname\n");
      http_error(fd, BAD_CMD);
      return;
   }
   if (req->method != "TRACE") {
      if ((errno = unmime(ref req->uri, IS_PATH)) != HTTP_OK) {
         http_error(fd, errno);
         return;
      }
      if ((errno = www_resolve(req)) != HTTP_OK) {
         if (!((req->method == "OPTIONS") && (errno == NOT_FOUND))) {
            http_error(fd, errno);
            return;
         }
      }
   }
   switch (req->method) {
   case "POST":
      if (explode(req->filename, ".")[<1] != "c")
         http_error(fd, NOT_ALLOWED);
      return;
   case "TRACE":
      /* We want the original request here. */
      while (req->prev) {
         req = req->prev;
      }
      req->bi->content_type = "message/http";
      http_header(req);
      buff = sprintf("%s\r\n", req->the_request);
      foreach (key in req->rh->headers_in->header_k) {
         if (undefinedp(req->rh->headers_in->header_m[lower_case(key)])) {
            continue;
         }
         buff += sprintf("%s: %s\r\n", key,
                         req->rh->headers_in->header_m[lower_case(key)]);
      }
      buff += sprintf("\r\n");
      if (req->bi->chunked) {
         eventWrite(fd, sprintf("%x\r\n", strlen(buff)));
      }
      eventWrite(fd, buff);
      if (req->bi->chunked) {
         eventWrite(fd, "\r\n0\r\n\r\n");
      }
      return;
   case "OPTIONS":
      if (req->rh->noheaders) {
         http_error(fd, BAD_CMD);
         return;
      }
      basic_header(req);
      req->rh->headers_out->header_m["Content-Length"] = 0;
      if (explode(req->filename, ".")[<1] == "c") {
         req->rh->headers_out->header_m["Allow"] =
            "GET, HEAD, POST, OPTIONS, TRACE";
      } else {
         req->rh->headers_out->header_m["Allow"] = "GET, HEAD, OPTIONS, TRACE";
      }
      req->rh->headers_out->header_k += ({ "Content-Length", "Allow" });
      set_persist(req);
      send_headers(req, req->rh->headers_out->header_m,
                   req->rh->headers_out->header_k ...);
      return;
   case "HEAD":
   case "GET":
      get_file(req);
      return;
   default:
      http_error(fd, NOT_IMPLEMENTED);
      return;
   }
} /* handle_request() */

int handle_body(class http_request req) {
   class http_body body = req->body;
   string tenc;
   string len;
   string buf;
   int i;
   int slen;
   int len_to_read;

   if ((req->status != HTTP_OK) || (req->method != "POST")) {
      return HTTP_OK;
   }
  
   switch (body->state) {
   case BODY_START:
      tenc = req->rh->headers_in->header_m["transfer-encoding"];
      len = req->rh->headers_in->header_m["content-length"];
      if (tenc) {
         if (tenc != "chunked")
            return NOT_IMPLEMENTED;
         /* It's chunked, we don't allow that for POST requests yet.
            return (len) ? BAD_CMD : LENGTH_REQUIRED; */
         
         body->read_chunked = 1;
      } else if (len) {
         slen = strlen(len);
         while ((i < slen) && (isdigit(len[i]) || isspace(len[i]))) {
            ++i;
         }
         if (i != slen) {
            return BAD_CMD;
         }
         sscanf(len, "%d", body->remaining);
      }
      if (!body->read_chunked && !body->remaining) {
         get_file(req);
         return HTTP_OK;
      }
      if (req->proto_num >= 1001) {
         eventWrite(req->sess->fd, sprintf("%s %s\r\n\r\n", HTTP_PROTOCOL,
                                           status_lines[CONTINUE]));
      }
      body->buff = "";
      body->state = BODY_READ;
   case BODY_READ:
      if (!body->read_chunked) {
         if (strlen(req->request) < body->remaining) {
            return CONTINUE;
         } else {
            body->buff = req->request[0..body->remaining-1];
            req->request = req->request[body->remaining..];
            get_file(req);
            return HTTP_OK;
         }
      }
      /* Eek, chunked read. This is no fun :) */
      if (body->remaining == 0) {
         if (sscanf(req->request, "%s\r\n%s", buf, req->request) != 2) {
            return CONTINUE;
         }
         if (!strlen(buf) || !isxdigit(buf[0])) {
            req->persistent = 0;
            return HTTP_OK;
         }
         sscanf(buf, "%x", len_to_read);
         if (len_to_read == 0) { /* last chunk */
            /* Put the previous "\r\n" back in */
            req->request = sprintf("\r\n%s", req->request); 
            if ((i = strsrch(req->request, "\r\n\r\n")) != -1) {
               parse_headers(req, i-1);
               req->request = req->request[i+4..];
               map_delete(req->rh->headers_in->header_m, "transfer-encoding");
               req->rh->headers_in->header_k -= ({ "transfer-encoding" });
               req->rh->headers_in->header_m["content-length"] =
                  sprintf("%d", body->read_length);
               req->rh->headers_in->header_k += ({ "content-length" });
               get_file(req);
               return HTTP_OK;
            } else {
               /* Not complete yet. */
               body->state = BODY_CHUNK_FOOTER;
               return CONTINUE;
            }
         } else {
            body->remaining = len_to_read;
         }
      }
      if (strlen(req->request) < body->remaining) {
         return CONTINUE;
      } else {
         body->buff += req->request[0..body->remaining-1];
         req->request = req->request[body->remaining..];
         body->read_length += body->remaining;
         body->remaining = 0;
         body->state = BODY_CHUNK_END;
      }
   case BODY_CHUNK_FOOTER:
      if ((i = strsrch(req->request, "\r\n\r\n")) != -1) {
         parse_headers(req, i-1);
         req->request = req->request[i+4..];
         map_delete(req->rh->headers_in->header_m, "transfer-encoding");
         req->rh->headers_in->header_k -= ({ "transfer-encoding" });
         req->rh->headers_in->header_m["content-length"] =
            sprintf("%d", body->read_length);
         req->rh->headers_in->header_k += ({ "content-length" });
         get_file(req);
         return HTTP_OK;
      } else {
         return CONTINUE;
      }
   case BODY_CHUNK_END:
      if (strlen(req->request) < 2) {
         return CONTINUE;
      }
      if (req->request[0..1] != "\r\n") {
         req->persistent = 0;
         return HTTP_OK;
      }
      req->request = req->request[2..];
      body->state = BODY_READ;
      if (strlen(req->request)) {
         return handle_body(req);
      }
      return CONTINUE;
   }
} /* handle_body() */

protected void parse_headers(class http_request req, int i) {
   string *bits;
   string bit;
   string cont;
   int idx;
   int len;

   bits = explode(req->request[0..i], "\r\n") - ({ "", 0 });
   foreach (bit in bits) {
      if (cont && ((bit[0] == ' ') || (bit[0] == '\t'))) {
         req->rh->headers_in->header_m[cont] += bit[1..];
         continue;
      }
      len = strlen(bit);
      if ((idx = strsrch(bit, ':')) == -1) {
         continue;
      }
      cont = bit[0..idx-1];
      if (undefinedp(req->rh->headers_in->header_m[lower_case(cont)])) {
         req->rh->headers_in->header_k += ({ cont });
      }
      cont = lower_case(cont);
      ++idx;
      while ((idx < len) && isspace(bit[idx])) {
         ++idx;
      }
      if (undefinedp(req->rh->headers_in->header_m[cont])) {
         req->rh->headers_in->header_m[cont] = bit[idx..];
      } else {
         req->rh->headers_in->header_m[cont] += sprintf(", %s", bit[idx..]);
      }
   }
} /* parse_headers() */

protected string check_fulluri(class http_request req, string uri) {
   string name;
   string host;
   int i;
   int port;
   
   if (lower_case(uri[0..6]) != "http://") {
      return uri;
   }
   name = uri[7..];
   i = strsrch(name, '/');
   name = name[0..i-1];
   if (sscanf(name, "%s:%d", host, port) != 2) {
      port = 80;
   }
   if (port != PORT_HTTP) {
      return uri;
   }
   req->hostname = host;
   /* XXX - should be done with resolve() */
   if (lower_case(host) == "discworld.imaginary.com" ||
       lower_case(host) == "discworld.lspace.org" ||
       lower_case(host) == "atuin.icepack.com" ||
       lower_case(host) == "localhost" ||
       lower_case(host) == "208.202.120.111") {
      return uri[7+i..];
   }
   return uri;
} /* check_fulluri() */

void parse_uri(class http_request req, string uri) {
   int len;
   int i;

   len = strlen(uri);
   for (i = 0; i < len; i++) {
      if (!isalnum(uri[i]) && uri[i] != '+' && uri[i] != '-' &&
          uri[i] != '.') {
         break;
      }
   }
   
   if (uri[i] == ':' && i) {
      req->proxyreq = 1;
      req->uri = uri;
      req->args = 0;
   } else if (req->method == "TRACE") {
      req->proxyreq = 0;
      req->uri = uri;
      req->args = 0;
   } else {
      req->proxyreq = 0;
      if (sscanf(uri, "%s?%s", req->uri, req->args) != 2) {
         req->uri = uri;
         req->args = 0;
      }
   }
} /* parse_uri() */

protected void eventRead(int fd, string str) {
   string uri;
   string rest;
   string protocol;
   int major;
   int minor;
   int i;
   int ret;
   class http_request req = (class http_request)Sockets[fd];

   if (req->id) {
      remove_call_out(req->id);
   }
   if (str) {
      TP("Received: " + replace(str, ({ "\r", "<CR>", "\n", "<LF>\n"})));
      req->request += str;
      if ((req->state != REQ_BODY) && (strsrch(str, '\n') == -1))
         return;
   }
   switch (req->state) {
   case REQ_REQUEST:
      /* Skip leading newlines */
      if (str == "\r\n") {
         return;
      }
      sscanf(req->request, "%*(^(\r\n)*)%s\r\n%*s", req->the_request);
      if (!req->the_request) {
         return;
      }
      req->time = time();
      if ((sscanf(req->request,
                  "%*(^(\r\n)*)%s%*(( |\t)+)%s%*(( |\t)+)%s%((\r\n).*)",
                  req->method, uri, protocol, rest) != 7) &&
          (sscanf(req->request, "%*(^(\r\n)*)%s%*(( |\t)+)%s\r\n%*s",
                  req->method, uri) != 5)) {
         req->rh->noheaders = 1;
         http_error(fd, BAD_CMD);
         return;
      }
      req->request = rest;
      uri = check_fulluri(req, uri);
      parse_uri(req, uri);
      if (!stringp(protocol) || !strlen(protocol)) {
         req->rh->noheaders = 1;
         protocol = "HTTP/0.9";
      }
      sscanf(protocol, "HTTP/%d.%d", major, minor);
      req->proto_num = 1000 * major + minor;
      req->state = REQ_HEADERS;
   case REQ_HEADERS:
      if (!req->rh->noheaders &&
          ((i = strsrch(req->request, "\r\n\r\n")) != -1)) {
         parse_headers(req, i-1);
         req->request = req->request[i+4..];
         req->status = HTTP_OK;
         if (!(req->hostname ||
               undefinedp(req->rh->headers_in->header_m["host"]))) {
            req->hostname = req->rh->headers_in->header_m["host"];
         } else {
            req->hostname = "discworld.imaginary.com:"+ PORT_HTTP;
         }

				 // Does the client support compression?
				 if(!undefinedp(req->rh->headers_in->header_m["ACCEPT_ENCODING"]) &&
						strsrch(req->rh->headers_in->header_m["ACCEPT_ENCODING"],
										"gzip, deflate") != -1)
					 req->compressed = 1;
				 
      } else if (!req->rh->noheaders) {
         /* No full set of headers received yet */
         return;
      } else if (!req->hostname) {
         req->hostname = "discworld.imaginary.com:"+ PORT_HTTP;
      }
      handle_request(req);
      req->state = REQ_BODY;
   case REQ_BODY:
      if ((ret = handle_body(req)) != HTTP_OK) {
         if (ret == CONTINUE)
            return;
         else
            http_error(fd, ret);
      }
      if (!req->persistent) {
         TP("Closing connection\n");
         eventWrite(fd, 0, 1);
         return;
      }
      req->id = call_out("close_connection", 15, fd, 1);
      req->status = TIME_OUT;
      req->rh->headers_in->header_m = ([ ]);
      req->rh->headers_in->header_k = ({ });
      req->rh->headers_out->header_m = ([ ]);
      req->rh->headers_out->header_k = ({ });
      req->rh->err_headers_out->header_m = ([ ]);
      req->rh->err_headers_out->header_k = ({ });
      req->hostname = 0;
      req->rh->noheaders = 0;
      req->rh->header_only = 0;
      req->proto_num = 0;
      req->persistent = 0;
      req->numredirect = 0;
      req->bi->chunked = 0;
      req->status_line = 0;
      req->bi->content_type = 0;
      req->bi->clength = 0;
      req->bi->byterange = 0;
      req->bi->boundary = 0;
      req->bi->range = 0;
      req->method = 0;
      req->args = 0;
      req->filename = 0;
      req->dir = 0;
      req->location = 0;
      req->the_request = 0;
      req->uri = "";
      req->body->state = BODY_START;
      req->state = REQ_REQUEST;
      if (strlen(req->request))
         eventRead(fd, 0);
   }
} /* eventRead() */

protected void eventSocketClosed(int fd) {
   class http_request req = (class http_request)Sockets[fd];
   
   if (req) {
      map_delete(Sockets, fd);
   }
} /* eventSocketClosed() */
     
protected void resolve_callback(string name, string addr, int key) {
   class http_request req;
   
   if (undefinedp(Resolve[key])) {
      return;
   }
   req = (class http_request)Sockets[Resolve[key]];
   if (req && req->sess->address == addr) {
      req->sess->name = (name ? name : addr);
   }
   map_delete(Resolve, key);
} /* resolve_callback() */

string uudecode(string bufcoded) {
   int nbytesdecoded;
   string bufin;
   string prevbufin;
   string bufout;
   int nprbytes;
   int i;
   int nbufcoded;
   int *pr2six = ({
      64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
      64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,62,64,64,64,63,
      52,53,54,55,56,57,58,59,60,61,64,64,64,64,64,64,64,0,1,2,3,4,5,6,7,8,9,
      10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,64,64,64,64,64,64,26,27,
      28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,
      64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
      64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
      64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
      64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
      64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
      64,64,64,64,64,64,64,64,64,64,64,64,64 });

  /* Strip leading whitespace. */

   while (bufcoded[nbufcoded] == ' ' || bufcoded[nbufcoded] == '\t') {
      nbufcoded++;
   }

   /* Figure out how many characters are in the input buffer.
    * Allocate this many from the per-transaction pool for the result.
    */
   bufin = bufcoded[nbufcoded..];
   i = 0;
   while (pr2six[bufin[i++]] <= 63);
   nprbytes = i - nbufcoded - 1;
   nbytesdecoded = ((nprbytes+3)/4) * 3;
   
   bufout = "";
   while (nprbytes > 0) {
      bufout += sprintf("%c%c%c",
                        (pr2six[bufin[0]] << 2 | pr2six[bufin[1]] >> 4),
                        (pr2six[bufin[1]] << 4 | pr2six[bufin[2]] >> 2),
                        (pr2six[bufin[2]] << 6 | pr2six[bufin[3]]));
      prevbufin = bufin;
      bufin = bufin[4..];
      nprbytes -= 4;
   }
   
   if (nprbytes & 03) {
      if ((strlen(prevbufin) >= 2) && (pr2six[prevbufin[<2]] > 63)) {
         nbytesdecoded -= 2;
      } else {
         nbytesdecoded -= 1;
      }
   }
   return bufout[0..nbytesdecoded-1];
} /* uudecode() */
     
private void http_error(int fd, int status) {
   class http_request req = (class http_request)Sockets[fd];
   string buff;
   
   if (undefinedp(status_lines[status])) {
      status = 500;
   }
   req->status = status;
   
   if (status == NOT_MODIFIED) {
      basic_header(req);
      set_persist(req);
      send_headers(req, req->rh->headers_out->header_m,
                   "Connection",
                   "Keep-Alive",
                   "ETag",
                   "Content-Location",
                   "Expires",
                   "Cache-Control",
                   "Vary",
                   "Warning",
                   "WWW-Authenticate");
      return;
   }
   
   if (!req->rh->noheaders) {
      req->rh->headers_out->header_m = req->rh->err_headers_out->header_m;
      req->rh->headers_out->header_k = req->rh->err_headers_out->header_k;
      req->rh->err_headers_out->header_m = ([ ]);
      req->rh->err_headers_out->header_k = ({ });
      if (req->location && (status == MOVED_PERMANENTLY ||
                            status == MOVED_TEMP)) {
         req->rh->headers_out->header_m["Location"] = req->location;
         req->rh->headers_out->header_k += ({ "Location" });
      }
      req->bi->content_type = "text/html";
      if ((status == NOT_ALLOWED) || (status == NOT_IMPLEMENTED)) {
         if (explode(req->filename, ".")[<1] == "c") {
            req->rh->headers_out->header_m["Allow"] =
               "GET, HEAD, POST, OPTIONS, TRACE";
         } else {
            req->rh->headers_out->header_m["Allow"] = "GET, HEAD, OPTIONS, TRACE";
         }
         req->rh->headers_out->header_k += ({ "Allow" });
      }
      http_header(req);
      if (req->rh->header_only) {
         return;
      }
   }
   buff = sprintf("<HTML><HEAD>\n<TITLE>%s</TITLE>\n</HEAD>"
                  "<BODY>\n<H1>%s</H1>\n", status_lines[status],
                 status_lines[status][4..]);
   switch (status) {
   case MOVED_PERMANENTLY:
   case MOVED_TEMP:
      buff += sprintf("The document has moved <A HREF=\"%s\""
                      ">here</A>.<P>\n", escape_html(req->location));
      break;
   case BAD_CMD:
      buff += "Your browser sent a request that\n"
         "this server could not understand.<P>\n";
      break;
   case AUTH_REQUIRED:
      buff += "This server could not verify that you\n"
         "are authorized to access the document you\n"
         "requested.  Either you supplied the wrong\n"
         "credentials (e.g., bad password), or your\n"
         "browser doesn't understand how to supply\n"
         "the credentials required.<P>\n";
      break;
   case ACCESS_DENIED:
      buff += sprintf("You don't have permission to access %s\n"
                      "on this server.<P>\n"
                      "This is either because you do not have the correct "
                      "user permissions or because your site has been "
                      "<b>temporarily</b> locked out due to excessive "
                      "login failures.<p>\n"
                      "If you believe it is the latter wait 15 minutes and "
                      "then try again.<p>\n", escape_html(req->uri));
      break;
   case NOT_FOUND:
      buff += sprintf("The requested URL %s was not found on this "
                      "server.<P>\n", escape_html(req->uri));
      break;
   case NOT_ALLOWED:
      buff += sprintf("The requested method %s is not allowed for the "
                      "URL %s.<P>\n", escape_html(req->method),
                      escape_html(req->uri));
      break;
   case TIME_OUT:
      buff += "Please, I don't have all day. Goodbye.\n";
      break;
   case LENGTH_REQUIRED:
      buff += sprintf("A request of the requested method %s requires a valid "
                      "Content-length.<P>\n", escape_html(req->method));
      break;
   case PRECONDITION_FAILED:
      buff += sprintf("The precondition on the request for the URL %s "
                      "evaluated to false.<P>\n", escape_html(req->uri));
      break;
   case NOT_IMPLEMENTED:
      buff += sprintf("%s to %s not supported.<P>\n",
                      escape_html(req->method),
                      escape_html(req->uri));
      break;
   default:
      buff += "This is the end of the line. The tomatoes have finally "
         "expired.<P>\n";
      break;
   }
   buff += "</BODY></HTML>\n";
   if (req->bi->chunked) {
      eventWrite(fd, sprintf("%x\r\n", strlen(buff)));
   }
   eventWrite(fd, buff);
   if (req->bi->chunked) {
      eventWrite(fd, "\r\n0\r\n\r\n");
   }
} /* http_error() */
     
varargs protected void close_connection(int fd, int persist) {
   class http_request req = (class http_request)Sockets[fd];

   if (!req) {
      return;
   }
   if (!req->sess->name) {
      req->sess->name = req->sess->address;
   }
   if (!persist) {
      http_error(fd, TIME_OUT);
   }
   eventWrite(fd, 0, 1);
} /* close_connection() */
     
protected void clean_sockets() {
   class http_request req;
       
   foreach (req in (class http_request *)values(Sockets)) {
      if (!req->time) {
         req->time = time();
         continue;
      }
      if (time() - req->time > 180) {
         close_connection(req->sess->fd);
      }
   }
   call_out("clean_sockets", 180);
} /* clean_sockets() */

protected string auth_name(class http_request req) {
   return "Discworld-login";
} /* auth_name() */

protected void auth_failure(class http_request req) {
   string mess;

   if (req->user) {
      mess = capitalize(req->user) + " failed to login, web, " +
         (req->sess->name ? req->sess->name + " (" +
          req->sess->address : req->sess->address);
      event(users(), "inform", mess, "bad-password");
      log_file("BAD_PASSWORD", ctime(time()) + ": " + mess + "\n");
      LOGIN_HANDLER->failed_login(req->sess->address);
   }

   req->rh->err_headers_out->header_m["WWW-Authenticate"] =
      sprintf("Basic realm=\"%s\"", auth_name(req));
   req->rh->err_headers_out->header_k += ({ "WWW-Authenticate" });
} /* auth_failure() */

private int is_secure_dir(string dir) {
   if (dir[0..strlen(DIR_WWW+"/secure/")-1] == DIR_WWW+"/secure/") {
      return 1;
   }

   // Check to see if it is a creator or domain directory.
   if (dir[0..2] == "/w/" ||
       dir[0..1] == "w/" ||
       dir[0..2] == "/d/" ||
       dir[0..1] == "d/") {
      if (strsrch(dir, "/secure/") != -1) {
         return 1;
      }
   }

   return 0;
} /* is_secure_dir() */

private int is_secure_creator_dir(string dir) {
   if (dir[0..strlen(DIR_WWW+"/secure/creator/")-1] == 
       DIR_WWW+"/secure/creator/") {
      return 1;
   }

   // Check to see if it is a creator or domain directory.
   if (dir[0..2] == "/w/" ||
       dir[0..1] == "w/" ||
       dir[0..2] == "/d/" ||
       dir[0..1] == "d/") {
      if (strsrch(dir, "/secure/creator/") != -1) {
         return 1;
      }
   }

   return 0;
} /* is_secure_dir() */

protected int www_authenticate(class http_request req) {
   string auth_req = req->rh->headers_in->header_m["authorization"];
   int i;
   string decoded;
   string *bits;
   string mess;
   
   if (!is_secure_dir(req->dir)) {
      return HTTP_OK;
   }

   if (!auth_req) {
      auth_failure(req);
      return AUTH_REQUIRED;
   }

   i = strsrch(auth_req, ' ');
   if ((i == -1) || (auth_req[0..i-1] != "Basic")) {
      auth_failure(req);
      return AUTH_REQUIRED;
   }

   decoded = uudecode(auth_req[i+1..]);
   bits = explode(decoded, ":");
   if (sizeof(bits) < 2) {
      auth_failure(req);
      return AUTH_REQUIRED;
   }

   /* Fill in the user for logging and lockdown purposes */
   req->user = lower_case(bits[0]);

   if(LOGIN_HANDLER->site_lockeddown(req->sess->address)) {
     mess = bits[0] + " attempted login from locked down site, "
       "web, " + (req->sess->name ? req->sess->name + " (" +
                  req->sess->address : req->sess->address);
     event(users(), "inform", mess, "bad-password");
     log_file("BAD_PASSWORD", ctime(time()) + ": " + mess + "\n");
     return ACCESS_DENIED;
   }
   
   if (!PLAYER_HANDLER->test_password(lower_case(bits[0]), bits[1])) {
      auth_failure(req);
      return AUTH_REQUIRED;
   }

   if (is_secure_creator_dir(req->dir)) {
      if (!PLAYER_HANDLER->test_creator(bits[0])) {
         return ACCESS_DENIED;
      }
   }

   req->rh->headers_out->header_m["Cache-Control"] = "private";
   return HTTP_OK;
} /* www_authenticate() */

protected int www_resolve(class http_request req) {
   string *parts;
   string file;
   string dir;
   string args;
   int fsize;
   
   file = req->uri;
   if (file[0] != '/' && (file != "*")) {
      if (req->proxyreq) {
         /* Er. This was a proxy request. We aren't a proxy. */
         return ACCESS_DENIED;
      } else {
         return BAD_CMD;
      }
   }
   parts = explode(file, "/") - ({ ".", "..", "" });
   if (!sizeof(parts)) {
      req->uri += "index.html";
      req->filename = sprintf("%s/index.html", DIR_WWW);
      req->dir = DIR_WWW+ "/";
      return HTTP_OK;
   }
   
   // So that external references are moved to the external httpd..
#ifdef CONFIG_REWRITE_EXTERNAL_ADDRESS
   if (parts[0] == "external") {
      req->location = sprintf("http://discworld.imaginary.com%s",
                              req->uri);
      return MOVED_PERMANENTLY;
   }
#endif
   
   if (parts[0][0] == '~' && strlen(parts[0]) > 2) {
      if (parts[0][1] >= 'a' && parts[0][1] <= 'z') {
         parts[0] = sprintf("/w/%s/public_html", parts[0][1..]);
      } else {
         parts[0] = sprintf("/d/%s/public_html", lower_case(parts[0])[1..]);
      }
      file = implode(parts, "/");
      dir = implode(explode(file, "/")[0..<2], "/");
   } else {
      file = DIR_WWW+"/"+implode(parts, "/");
      dir = DIR_WWW+"/"+implode(parts[0..<2], "/");
   }
   sscanf(file, "%s___%s", file, args);
   fsize = file_size(file);
   
   if(fsize == -2) {
      if (req->uri[<1] == '/') {
         dir = file;
         file += "/index.html";
         fsize = file_size(file);
      } else {
         req->location = sprintf("http://%s%s/", req->hostname, req->uri);
         return MOVED_PERMANENTLY;
      }
   }
   if (args) {
      req->filename = file+"___"+args;
   } else {
      req->filename = file;
   }
   req->dir = (dir[<1] == '/' ? dir : dir + "/");
   if (fsize <= 0) {
      return NOT_FOUND;
   }
   return www_authenticate(req);
} /* www_resolve() */
   
/* This handles the @@ stuff in the files... */ 
private string parse_file_string(string str, class http_request req, mapping fields) {
   string *bits;
   string old_uri;
   string old_dir;
   string old_fname;
   int i;
   string fname;
   string args;

   bits = explode(str, "@@");
   str = "";
   old_uri = req->uri;
   old_fname = req->filename;
   old_dir = req->dir;
   for (i = 0; i < sizeof(bits); i += 2) {
      str += bits[i];
      if (i+1 < sizeof(bits)) {
        sscanf(bits[i+1], "%s:%s", fname, args);
        if (!fname) {
           fname = bits[i + 1];
           args = "";
        }
        if (fname[0] != '/') {
          fname =  old_dir + fname;
        } else {
          req->uri = fname;
          req->dir = old_dir;
          www_resolve(req);
          fname = req->filename;
        }
        bits[i+1] = "Oook!  Error!";
        TP("Calling "+ fname+ "->www_function( \""+ args+ "\" )\n");
        if (catch(bits[i+1] = 
                  call_other(fname, "www_function", args, fields, req))) {
          str += "Error!";
        } else {
          str += bits[i+1];
        }
      }
   }
   req->uri = old_uri;
   req->filename = old_fname;
   req->dir = old_dir;
   return str;
} /* parse_file_string() */

private void get_file(class http_request req) {
   string fname;
   string *bits;
   string bit;
   string id;
   string *parts;
   string location;
   int fsize;
   int errno;
   int mod_date;
   int i;
   int fd = req->sess->fd;
   mapping fields;
   mixed str;
   object cgibin;
       
   TP("Started get.\n");
   fields = ([ ]);
   if (req->args) {
      bits = explode(req->args, "&");
      foreach (bit in bits) {
         sscanf(bit, "%s=%s", id, str);
         
         if (!id) {
            continue;
         }
         if (!str) {
            str = "";
         }
         str = replace_string(str, "+", " ");
         if (((errno = unmime(ref id, NOT_PATH)) != HTTP_OK) ||
             ((errno = unmime(ref str, NOT_PATH)) != HTTP_OK)) {
            http_error(fd, errno);
            return;
         }
         fields[id] = str;
      }
      req->args = 0;
   }
   sscanf(req->filename, "%s___%s", req->filename, req->args);
   
   if (!req->args) {
      req->args = "";
   }
   TP("File = "+req->filename+" Args = "+req->args+"\n");
  
   current_file = req->filename;
#ifdef TRACK_PAGE_STATS 
   http_stats[req->filename]++;
#endif  
    
   TP("Found file "+req->filename+"\n");
   parts = explode(req->filename, ".");

   switch (parts[<1]) {
   case "c":
      TP("Attempting a call.\n");
      if (!(cgibin = find_object(req->filename))) {
         if (catch(cgibin = load_object(req->filename))) {
            TP("error compiling it.\n");
            http_error(fd, INTERNAL_ERROR);
            return;
         }
      }
      if (!function_exists("query_content_type", cgibin)) {
         req->bi->content_type = "text/html";
      } else if (catch(req->bi->content_type =
                       (string)cgibin->query_content_type())) {
         TP("error getting content type.\n");
         http_error(fd, INTERNAL_ERROR);
         return;
      }
      /* If it is a post request we parse the body here */
      bit = req->body->buff;
      req->body->data = ([ ]);
      if (bit && strlen(bit) > 0) {
         bits = explode(bit, "&");
         foreach (bit in bits) {
            string name;
            string arg;
            
            if (sscanf(bit, "%s=%s", name, arg) == 2) {
               /* We will ignore errors here... */
               arg = replace_string(arg, "+", " ");
               unmime(ref arg, NOT_PATH);
               unmime(ref name, NOT_PATH);
               req->body->data[name] = arg;
            }
         }
      }
      if (catch(str = (mixed)cgibin->www_request(req->args, fields, req))) {
         TP("error handling request.\n");
         http_error(fd, INTERNAL_ERROR);
         return;
      }
      mod_date = 0;
      if (pointerp(str) && intp(str[0])) {
         if (sizeof(str) < 2) {
            http_error(fd, INTERNAL_ERROR);
            return;
         }
         mod_date = str[0];
         str = str[1];
      }
      if (mapp(str)) {
         location = str["location"];
         mod_date = str["mod_date"];
         req->status_line = str["status"];
         if (stringp(req->status_line)) {
            sscanf(req->status_line, "%d", req->status);
         }
         str = str["response"];
         if (req->status == AUTH_REQUIRED) {
            req->rh->headers_out->header_m["WWW-Authenticate"] =
               sprintf("Basic realm=\"%s\"", auth_name(req));
            req->rh->headers_out->header_k += ({ "WWW-Authenticate" });
         }
      }
      if (str && (stringp(str) || bufferp(str))) {
         send_string(fd, str, mod_date, location, 1);
      } else {
         TP("invalid result from handler.\n");
         http_error(fd, INTERNAL_ERROR);
         return;
      }
      break;
   case "html":
   case "htm":
      /* This should be done only for .shtml files, the s in shtml means
         server parsed. But we'll leave it for now. */
      TP("Reading buffer.\n");
      fname = req->filename;
      
      TP("Found html file.\n");
      req->bi->content_type = "text/html";
      if ((fsize = file_size(req->filename)) > max_file_size) {
         str = ({ });
         for (i = 0; i < fsize; i += max_file_size) {
            str += ({ parse_file_string(read_bytes(req->filename, i,
                                                   max_file_size),
                                        req, fields) });
         }
         send_string_array(fd, str, stat(req->filename)[1], 0, 0);
         str = "";
      } else {
         str = parse_file_string(read_file(req->filename), req, fields);
         send_string(fd, str, stat(req->filename)[1], 0, 0);
      }
      break;
   default:
      send_file(fd, req->filename);
      return;
   }
   if (!str || (!stringp(str) && !bufferp(str))) {
      http_error(fd, NOT_FOUND);
   }
} /* get_file() */
 
private string log_time(int time) {
   mixed *stuff;
   int offset;
   int sign;
   string month;
  
   stuff = localtime(time);
   offset = stuff[LT_GMTOFF];
   if (offset < 0) {
      offset = -offset;
      sign = '+'; /* Looks strange, but it is correct! */
   } else {
      sign = '-';
   }

   month = ({"Jan", "Feb", "Mar", "Apr", "May",
             "Jun","Jul","Aug","Sep","Oct","Nov","Dec"})[stuff[LT_MON]];
   
   return sprintf("[%02d/%03s/%04d:%02d:%02d:%02d %c%02d%02d]",
                  stuff[LT_MDAY],
                  month,
                  stuff[LT_YEAR],
                  stuff[LT_HOUR],
                  stuff[LT_MIN],
                  stuff[LT_SEC],
                  sign,
                  (offset / 3600),
                  (offset % 60));
} /* log_time() */

private void log_request(class http_request req, int len) {
#ifdef LOGGING
   mixed *stuff;
   
   if(!log_str)
      log_str = "";
   if(!cday)
      cday = "";
   
   stuff = localtime(time());
   
   // Flush the log if the day has changed since the last write.
   if(cday != stuff[LT_MDAY] && sizeof(log_str)) {
      write_file("/log/http/log-" + cday + "-" + (stuff[LT_MON]+1) +
                 "-" + stuff[LT_YEAR], log_str);
      log_str = "";
   }
   
   cday = stuff[LT_MDAY];
   
   log_str += (req->sess->name?req->sess->name:req->sess->address) + 
      " - " + (req->user?req->user:"-") + " " + log_time(time()) + " \"" +
      req->the_request + "\" " + req->status + " " +
      len + "\n";
   
   // Flush the log when it's 4k in size, used to reduce disk seeking.
   if(sizeof(log_str) > 4096) {
      /* Do a log of it... */
      write_file("/log/http/log-" + stuff[LT_MDAY] + "-" + (stuff[LT_MON]+1) +
                 "-" + stuff[LT_YEAR], log_str);
      log_str = "";
   }
#endif
} /* log_request() */

int dest_me() {
   unguarded((: save_object, SAVE_FILE :));
   server::dest_me();
} /* dest_me() */

int ltime2sec(mixed *ltime) {
   int year;
   int days;
   int *dayoffset =
      ({306, 337, 0, 31, 61, 92, 122, 153, 184, 214, 245, 275});
   
   year = ltime[LT_YEAR];
   
   if (year < 70 || year >= 138) {
      return 0;
   }
   
   /* shift new year to 1st March in order to make leap year calc easy */
   
   if (ltime[LT_MON] < 2) {
      year--;
   }
   
   /* Find number of days since 1st March 1900 (in the Gregorian calendar). */
   
   days  = year * 365 + year/4 - year/100 + (year/100 + 3)/4;
   days += dayoffset[ltime[LT_MON]] + ltime[LT_MDAY] - 1;
   days -= 25508; /* 1 jan 1970 is 25508 days since 1 mar 1900 */
   
   days = ((days * 24 + ltime[LT_HOUR]) * 60 + ltime[LT_MIN]) * 60 +
      ltime[LT_SEC];
   if (days < 0) {
      return 0;       /* must have overflowed */
   } else {
      return days;           /* must be a valid time */
   }
} /* ltime2sec() */

/*
 * Parses an HTTP date in one of three standard forms:
 *
 *     Sun, 06 Nov 1994 08:49:37 GMT  ; RFC 822, updated by RFC 1123
 *     Sunday, 06-Nov-94 08:49:37 GMT ; RFC 850, obsoleted by RFC 1036
 *     Sun Nov  6 08:49:37 1994       ; ANSI C's asctime() format
 *
 * and returns the number of seconds since 1 Jan 1970 GMT, or
 * 0 if this would be out of range or if the date is invalid.
 */
int parse_date(string date) {
   string month;
   int day;
   int year;
   int hours;
   int minutes;
   int seconds;
   int mon;
   mixed *ltime = allocate(10);

   if (sscanf(date, "%*s, %d %s %d %d:%d:%d %*s", day, month, year, hours,
              minutes, seconds) == 8) {
      ltime[LT_YEAR] = year - 1900;
      if (ltime[LT_YEAR] < 0) {
         return 0;
      }
   } else if (sscanf(date, "%*s, %d-%s-%d %d:%d:%d %*s", day, month, year, 
                     hours, minutes, seconds) == 8) {
      ltime[LT_YEAR] = year;
      if (ltime[LT_YEAR] < 70)
         ltime[LT_YEAR] += 100;
   } else if (sscanf(date, "%*s %s %d %d:%d:%d %d", month, day, hours, minutes,
                   seconds, year) == 7) {
      ltime[LT_YEAR] = year - 1900;
      if (ltime[LT_YEAR] < 0)
         return 0;
   } else if (sscanf(date, "%*s %s  %d %d:%d:%d %d", 
                     month, day, hours, minutes,
                   seconds, year) == 7) {
      ltime[LT_YEAR] = year - 1900;
      if (ltime[LT_YEAR] < 0)
         return 0;
   } else {
      return 0;
   }
   ltime[LT_MDAY] = day;
   if ((ltime[LT_MDAY] <= 0) || (ltime[LT_MDAY] > 31)) {
      return 0;
   }
   ltime[LT_HOUR] = hours;
   ltime[LT_MIN] = minutes;
   ltime[LT_SEC] = seconds;
   if ((ltime[LT_HOUR] > 23) || (ltime[LT_MIN] > 59) || (ltime[LT_SEC] > 61)) {
      return 0;
   }
   mon = member_array(month[0..2], MONTHS);
   if (mon == -1) {
      return 0;
   }
   if ((ltime[LT_MDAY] == 31) && (mon == 3 || mon == 5 || mon == 8 ||
                                  mon == 10)) {
      return 0;
   }
   
   /* February gets special check for leapyear */
   
   if ((mon == 1) && ((ltime[LT_MDAY] > 29) ||
                      ((ltime[LT_MDAY] == 29) && ((ltime[LT_YEAR] & 3) ||
                                                  (((ltime[LT_YEAR] % 100) == 0) && (((ltime[LT_YEAR] % 400) != 100))))))) {
      return 0;
   }
   
   ltime[LT_MON] = mon;
   return ltime2sec(ltime);
} /* parse_date() */
     
string format_date(int x) {
   string str;
   string mon;
   mixed *tm;
   int offset;
       
   if (x<0 || !intp(x)) {
      return "Bad time";
   }
   
   tm = localtime(x);
   offset = tm[LT_GMTOFF];
   tm = localtime(x + offset);
   str = DAYS[tm[LT_WDAY]];
   mon = MONTHS[tm[LT_MON]];
   str = sprintf("%s, %02d %s %d %02d:%02d:%02d GMT", str, tm[LT_MDAY], mon,
                 tm[LT_YEAR], tm[LT_HOUR], tm[LT_MIN], tm[LT_SEC]);
   return str;
} /* format_date() */

protected int set_last_modified(class http_request req, int mtime) {
   string etag;
   string weak_etag;
   string if_modified_since = req->rh->headers_in->header_m["if-modified-since"];
   string if_unmodified     = req->rh->headers_in->header_m["if-unmodified-since"];
   string if_nonematch      = req->rh->headers_in->header_m["if-none-match"];
   string if_match          = req->rh->headers_in->header_m["if-match"];
   int now = time();
   mixed size;

   if (now < 0) {
      now = req->time;
   }
   req->rh->headers_out->header_m["Last-Modified"] =
      format_date((mtime > now) ? now : mtime);
   req->rh->headers_out->header_k += ({ "Last-Modified" });
   if (intp((size = stat(req->filename)[0]))) {
      weak_etag = sprintf("W/\"%x-%x\"", size, mtime);
   } else {
      weak_etag = sprintf("W/\"%x\"", mtime);
   }
   etag = weak_etag[((req->time - mtime > 1) ? 2 : 0)..];
   req->rh->headers_out->header_m["ETag"] = etag;
   req->rh->headers_out->header_k += ({ "ETag" });
   
   if (if_match) {
      if ((if_match[0] != '*') && !find_token(if_match, etag)) {
         return PRECONDITION_FAILED;
      }
   } else if (if_unmodified) {
      int utime = parse_date(if_unmodified);
      
      if (utime && mtime > utime) {
         return PRECONDITION_FAILED;
      }
   }
   if (if_nonematch) {
      if ((if_nonematch[0] == '*') || find_token(if_nonematch, etag)) {
         return (req->method == "GET") ? NOT_MODIFIED : PRECONDITION_FAILED;
      }
   }
   else if (if_modified_since && (req->method == "GET")) {
      int itime = parse_date(if_modified_since);
      
      if ((itime >= mtime) && (itime <= req->time)) {
         return NOT_MODIFIED;
      }
   }
   
   return HTTP_OK;
} /* set_last_modified() */

protected void internal_redirect(class http_request req, string new_uri) {
   class http_request nreq = new(class http_request);

   nreq->sess = req->sess;
   parse_uri(nreq, new_uri);
   nreq->prev = req;
   nreq->the_request = req->the_request;
   nreq->method = req->method;
   nreq->status = req->status;
   nreq->rh = new(class http_request_header);
   nreq->rh->noheaders = req->rh->noheaders;
   nreq->rh->header_only = req->rh->header_only;
   nreq->proto_num = req->proto_num;
   nreq->hostname = req->hostname;
   nreq->time = req->time;
   nreq->numredirect = req->numredirect + 1;
   nreq->rh->headers_in = req->rh->headers_in;
   nreq->rh->headers_out = new(class mime_header, header_m : ([ ]),
                               header_k : ({ }));
   nreq->rh->err_headers_out = new(class mime_header, header_m : ([ ]),
                                   header_k : ({ }));
   nreq->bi = new(class http_body_info);
   Sockets[nreq->sess->fd] = nreq;
   if (nreq->numredirect > 5) {
      /* recursion ... */
      http_error(nreq->sess->fd, INTERNAL_ERROR);
      return;
   }
   handle_request(nreq);
} /* internal_redirect() */

protected void send_string(int fd, string str, int mod_date, string location,
                           int no_length) {
   class http_request req = (class http_request)Sockets[fd];
   int errstatus;
   int rangestatus;

   if (!req) {
      return;
   }
   if (strlen(location) && location[0] == '/' && req->status == 200) {
      req->location = location;
      req->method = "GET";
      map_delete(req->rh->headers_in->header_m, "content-length");
      req->rh->headers_in->header_k -= ({ "Content-Length" });
      internal_redirect(req, location);
      return;
   } else if (location && req->status == 200) {
      req->location = location;
      http_error(fd, MOVED_TEMP);
      return;
   }
   if (!req->rh->noheaders) {
      if (mod_date) {
         if ((errstatus = set_last_modified(req, mod_date)) != HTTP_OK) {
            http_error(fd, errstatus);
            return;
         }
      }
      if (!no_length) {
         req->bi->clength = strlen(str);
         req->rh->headers_out->header_m["Content-Length"] = ""+strlen(str);
         req->rh->headers_out->header_k += ({ "Content-Length" });
      }
      rangestatus = set_byterange(req);
      http_header(req);
   }
   
   /* Log it... */
   log_request(req, strlen(str));
   
   if (!req->rh->header_only) {
      if (req->bi->chunked) {
         eventWrite(fd, sprintf("%x\r\n", strlen(str)));
      }
      if (!rangestatus) {
         eventWrite(fd, str);
      } else {
         int offset;
         int length;
         
         while (each_byterange(req, ref offset, ref length))
            eventWrite(fd, str[offset..offset + length]);
      }     
      if (req->bi->chunked) {
         eventWrite(fd, "\r\n0\r\n\r\n");
      }
   }
} /* send_string() */
     
protected void send_string_array(int fd, string *str, int mod_date,
                           string location, int no_length) {
   class http_request req = (class http_request)Sockets[fd];
   int errstatus;
   int rangestatus;
   string frog;

   if (!req) {
      return; 
   }      
   if (strlen(location) && location[0] == '/' && req->status == 200) {
      req->location = location;
      req->method = "GET";
      map_delete(req->rh->headers_in->header_m, "content-length");
      req->rh->headers_in->header_k -= ({ "Content-Length" });
      internal_redirect(req, location);
      return;
   } else if (location && req->status == 200) {
      req->location = location;
      http_error(fd, MOVED_TEMP);
      return;
   }
   req->bi->clength = 0;
   foreach (frog in str) {
      req->bi->clength += strlen(frog);
   }
   if (!req->rh->noheaders) {
      if (mod_date) {
         if ((errstatus = set_last_modified(req, mod_date)) != HTTP_OK) {
            http_error(fd, errstatus);
            return;
         }
      }
      if (!no_length) {
         
         req->rh->headers_out->header_m["Content-Length"] = ""+req->bi->clength;
         req->rh->headers_out->header_k += ({ "Content-Length" });
      }
      rangestatus = set_byterange(req);
      http_header(req);
   }

   /* Log it... */
   log_request(req, req->bi->clength);
   
   if (!req->rh->header_only) {
      if (req->bi->chunked) {
         eventWrite(fd, sprintf("%x\r\n", req->bi->clength));
      }
      if (!rangestatus) {
         string rabbit;
         
         foreach (rabbit in str) {
            eventWrite(fd, rabbit);
         }
      } else {
         int offset;
         int length;
         int index;
         int off_min;
         
         while (each_byterange(req, ref offset, ref length)) {
            TP("Ummm " + offset + " + " + length + "\n");
            while (offset - off_min > strlen(str[index])) {
               off_min += strlen(str[index]);
               index++;
            }
            while (offset + length - off_min > strlen(str[index])) {
               TP("Sending " + index + " [" + offset + " (" + off_min + ")..]\n");
               eventWrite(fd, str[index][offset - off_min..]);
               off_min += strlen(str[index]);
               index++;
            }
            TP("Sending " + index + " [" + offset + " (" + off_min + ").." + length + "]\n");
            eventWrite(fd, str[index][offset - off_min..offset + length - off_min]);
         }
      }     
      if (req->bi->chunked) {
         eventWrite(fd, "\r\n0\r\n\r\n");
      }
   }
} /* send_string_array() */

protected void send_file(int fd, string str) {
   string *bits;
   class http_request req = (class http_request)Sockets[fd];
   int errstatus;
   int rangestatus;
   int fsize;

   if (!req) {
      return;
   }
   if (req->rh->noheaders) {
      /* Stupid mode, no header */
      eventWrite(fd, str, 1, 1);
      return;
   }
   if ((errstatus = set_last_modified(req, stat(str)[1])) != HTTP_OK) {
      http_error(fd, errstatus);
      return;
   }
   fsize = file_size(str);
   
   req->bi->clength = fsize;
   req->rh->headers_out->header_m["Content-Length"] = ""+fsize;
   req->rh->headers_out->header_k += ({ "Content-Length" });

   /* Log it... */
   log_request(req, req->bi->clength);
   
   bits = explode(req->uri, ".");
   switch (lower_case(bits[<1])) {
   case "html":
   case "htm":
      req->bi->content_type = "text/html";
      break;
   case "wrl":
   case "vrml":
      req->bi->content_type = "x-world/x-vrml";
      break;
   case "jpeg":
   case "jpg":
   case "jpe":
      req->bi->content_type = "image/jpeg";
      break;
   case "gif":
      req->bi->content_type = "image/gif";
      break;
   case "txt":
      req->bi->content_type = "text/plain";
      break;
   case "class":
      req->bi->content_type = "application/octet-stream";
      break;
   case "wav":
      req->bi->content_type = "audio/x-wav";
      break;
   default:
      req->bi->content_type = "text/plain";
      break;
   }
   rangestatus = set_byterange(req);
   http_header(req);
   if (!req->rh->header_only) {
      if (!rangestatus) {
         eventWrite(fd, str, 0, 1);
      } else {
         int offset;
         int length;
         
         while (each_byterange(req, ref offset, ref length)) {
            eventWrite(fd, str, 0, 1, offset, offset + length);
         }
      }
   }
}  /* send_file() */

string query_current_file() {
   return current_file;
} /* query_current_file() */

/* Number of times a file has been accessed */
int query_current_no_reads(string file) {
#ifdef TRACK_PAGE_STATS
   return http_stats[file];
#else
   return 0;
#endif    
} /* query_current_no_reads() */

#ifdef TRACK_PAGE_STATS
void tidy_files_read() {
   int i;
   string tmp;
   
   foreach(tmp in keys(http_stats)) {
      if(tmp[<5..] != ".html" && tmp[<4..] != ".htm" && tmp[<3..] != ".c") {
         map_delete(http_stats, tmp);
      } else if(tmp[0..3] != "/www") {
         map_delete(http_stats, tmp);
      } else if(tmp[0..11] == "/www/autodoc") {
         //      map_delete(http_stats, tmp);
         write("[" + tmp[0..12] + "] " + tmp + "\n");
      }
   }
} /* tidy_files_read() */
    
int query_files_read() {
   return sizeof(keys(http_stats));
} /* query_files_read() */
#endif
// --- END [/mnt/home2/grok/lib/net/daemon/nhttp.c] ---
// --- BEGIN [/mnt/home2/grok/lib/net/daemon/pop3.c] ---
// Size:   File: "/mnt/home2/grok/lib/net/daemon/pop3.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628713   Available: 13576067
Inodes: Total: 5242880    Free: 4960135
13943 bytes, Last Modified:   File: "/mnt/home2/grok/lib/net/daemon/pop3.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628713   Available: 13576067
Inodes: Total: 5242880    Free: 4960135
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <network.h>
#include <mail.h>
#include <pop3.h>
#include <mime.h>
#include <player_handler.h>

inherit SERVER;

private void parse_comm(class pop_session sess, string str);

private string *pop_states = ({
  "AUTHORIZATION",
  "AUTHORIZATION",
  "TRANSACTION",
  "UPDATE"
});
private mapping Sockets;
private nosave mapping cache;
private nosave int reads, hits;
private mapping last;

protected void create() {
  server::create();
  SetSocketType(STREAM);
  SetDestructOnClose(1);
  Sockets = ([]);
  call_out("setup", 2);
  call_out("clean_sockets", 180);
  unguarded((: restore_object, "/net/save/pop3" :));
  if(!last)
    last = ([ ]);
} /* create() */

/** @ignore yes */
protected void setup() {
  if (eventCreateSocket(PORT_POP3) < 0) {
    if (this_object()) {
      destruct(this_object());
    }
  }
} /* setup() */

/** @ignore yes */
protected void eventNewConnection(int fd) {
  class pop_session sess;
  
  server::eventNewConnection(fd);
  sess = new(class pop_session, fd : fd, state : POP_AUTH_USER, command : "",
             deleted : ({}), messages : ({}));
  Sockets[fd] = sess;
  eventWrite(fd, sprintf("+OK POP3 %s Discworld v%s server ready\r\n",
                         query_host_name(), POP3_VERSION));
} /* eventNewConnection() */

/** @ignore yes */
protected void eventRead(int fd, string str) {
  string *bits, bit;
  class pop_session sess = Sockets[fd];

  if (!sess) {
    return;
  }
  if (str) {
    sess->command += str;
    if (strsrch(str, '\n') == -1) {
      return;
    }
  }
  sess->command = replace_string(sess->command, "\r", "");
  bits = explode(sess->command, "\n");
  if (!sizeof(bits)) {
    eventWrite(fd, "-ERR Null command\r\n");
  } else {
    foreach (bit in bits) {
      parse_comm(sess, bit);
    }
  }
  sess->command = "";
} /* eventRead() */

/** @ignore yes */
protected void eventSocketClosed(int fd) {
  class pop_session sess = Sockets[fd];

  if (!sess) {
    return;
  }
  map_delete(Sockets, fd);
} /* eventSocketClosed() */

private void sign_off(class pop_session sess) {
  int *deleted;
  
  if (sizeof(sess->deleted)) {
    deleted = map(sess->deleted, (: $2->headers[$1-1]->number :), sess);
    FOLDER_H->delete_it(sess->user_name, "inbox", deleted);
  }
  eventWrite(sess->fd, "+OK Sayonara\r\n", 1);
  unguarded((: save_object, "/net/save/pop3" :));
} /* sign_off() */

private void load_message(class pop_session sess, int message) {
  string mess;
  int which;

  reads++;

  which = sess->headers[message]->number;

  if(!cache)
    cache = ([ ]);
  if(cache[which]) {
    hits++;
    sess->messages[message] = cache[which];
    return;
  }
  
  mess = FOLDER_H->load_message(sess->user_name, "inbox",
                                sess->headers[message]->number);
  mess = MIME->rewrite_header(mess);
  mess = replace_string(mess, "\n", "\r\n");

  if (mess[<1] != '\n') {
    mess += "\r\n";
  }
  sess->messages[message] = mess;
  sess->sizes[message] = strlen(mess);
  
  cache[which] = copy(mess);
} /* load_message() */

private void load_folder(class pop_session sess) {
  int *tmp, max, i;
  
  sess->headers = FOLDER_H->get_messages(sess->user_name, "inbox");
  tell_creator("ceres", "Headers: %d\n", sizeof(sess->headers));
  sess->messages = allocate(sizeof(sess->headers));
  sess->sizes = allocate(sizeof(sess->headers));
  sess->num_messages = sizeof(sess->headers);

  // the sizes will start out as an approximation. As we read actual messages
  // the real size will be put in place.

  tmp = sess->sizes;
  
  for(i=0; i<sizeof(sess->headers); i++)
    sess->sizes[i] = 1000;

  // If we'd already got some sizes then copy them into the new size array.
  if(tmp) {
    (sizeof(tmp) > sizeof(sess->headers)) ? max = sizeof(tmp) :
      max = sizeof(sess->headers);
    for(i=0; i<max; i++)
      sess->sizes[i] = tmp[i];
  }
} /* load_folder() */

private void parse_comm(class pop_session sess, string str) {
  string *bits, rest, cmd, message, header;
  int *sizes, lines, i, number, fd = sess->fd;
  
  if (strsrch(lower_case(str), "pass") == -1) {
    TP("Parsing " + str + ".\n");
  }
  bits = explode(str, " ");
  cmd = bits[0];
  if (sizeof(bits) > 1 ) {
    rest = implode(bits[1..], " ");
  } else {
    rest = "";
  }
  sess->time = time();
  switch(lower_case(cmd)) {
  case "dele":
    tell_creator("ceres", "Requesting deletion of %d\n", number);

    CHECK_STATE(POP_TRANSACTION);
    CHECK_CMD(1, "-ERR Missing message number argument\r\n");
    if ((sscanf(bits[1], "%d", number) != 1) || number < 1 ||
        number > sess->num_messages) {
      eventWrite(fd, "-ERR No such message\r\n");
    } else if (member_array(number, sess->deleted) != -1) {
      eventWrite(fd, sprintf("-ERR Message number %d already deleted\r\n",
                             number));
    } else {
      tell_creator("ceres", "Deleting %d\n", number);
      sess->deleted += ({ number });
      eventWrite(fd, "+OK Message deleted\r\n");
    }
    break;
  case "last":
    CHECK_STATE(POP_TRANSACTION);
    eventWrite(fd, sprintf("+OK %d\r\n", last[sess->user_name]));
    tell_creator("ceres", "Returning %d for last\n", last[sess->user_name]);
    break;
  case "list":
    CHECK_STATE(POP_TRANSACTION);
    if (sizeof(bits) > 1) {
      if ((sscanf(bits[1], "%d", number) != 1) || number < 1 ||
          number > sess->num_messages) {
        eventWrite(fd, "-ERR No such message\r\n");
      } else if (member_array(number, sess->deleted) != -1) {
        eventWrite(fd, sprintf("-ERR Message number %d already deleted\r\n",
                               number));
      } else {
        if (!sizeof(sess->headers)) {
          load_folder(sess);
        }
        eventWrite(fd, sprintf("+OK %d %d\r\n", number,
                               sess->sizes[number-1]));
      }
    } else {
      eventWrite(fd, "+OK Mailbox scan listing follows\r\n");
      if (!sizeof(sess->headers)) {
        load_folder(sess);
      }
      i = 0;
      if (!sizeof(sess->deleted)) {
        map(sess->sizes,
            function(int size, int ref idx, int fd) {
              reset_eval_cost();
              eventWrite(fd, sprintf("%d %d\r\n", ++idx, size));
            }, ref i, fd);
      } else {
        map(sess->sizes,
            function (int size, int ref idx, int fd, int *deleted) {
              reset_eval_cost();
              idx++;
              if (member_array(idx, deleted) == -1) {
                eventWrite(fd, sprintf("%d %d\r\n", idx, size));
              }
            }, ref i, fd, sess->deleted);
      }
      eventWrite(fd, ".\r\n");
    }
    break;
  case "noop":
    CHECK_STATE(POP_TRANSACTION);
    eventWrite(fd, "+OK No-op to you too!\r\n");
    break;
  case "pass":
    CHECK_STATE(POP_AUTH_PASS);
    CHECK_CMD(1, "-ERR Missing password argument\r\n");
    if (!PLAYER_HANDLER->test_password(sess->user_name, rest)) {
      sess->state = POP_AUTH_USER;
      eventWrite(fd, "-ERR Bad login\r\n");
    } else {
      sess->state = POP_TRANSACTION;
      load_folder(sess);
      //      sess->headers = FOLDER_H->get_messages(sess->user_name, "inbox");
      //      sess->num_messages = sizeof(sess->headers);
      eventWrite(fd, sprintf("+OK Mailbox open, %d messages\r\n",
                             sess->num_messages));
    }
    break;
  case "quit":
    switch (sess->state) {
    case POP_AUTH_USER:
    case POP_AUTH_PASS:
      eventWrite(fd, "+OK Sayonara\r\n", 1);
      break;
    case POP_TRANSACTION:
      sess->state = POP_UPDATE;
      sign_off(sess);
      break;
    }
    break;
  case "retr":
    CHECK_STATE(POP_TRANSACTION);
    CHECK_CMD(1, "-ERR Missing message number argument\r\n");
    if ((sscanf(bits[1], "%d", number) != 1) || number < 1 ||
        number > sess->num_messages) {
      eventWrite(fd, "-ERR No such message\r\n");
    } else if (member_array(number, sess->deleted) != -1) {
      eventWrite(fd, sprintf("-ERR Message number %d already deleted\r\n",
                             number));
    } else {
      if (!sizeof(sess->headers)) {
        load_folder(sess);
      }
      last[sess->user_name] = number;
      if(!sess->messages[number-1])
        load_message(sess, number-1);
      
      message = replace_string(sess->messages[number-1], "\n.", "\n..");
      eventWrite(fd, sprintf("+OK %d octets\r\n", sess->sizes[number-1]));
      eventWrite(fd, message + ".\r\n");
    }
    break;
  case "rset":
    CHECK_STATE(POP_TRANSACTION);
    sess->deleted = ({});
    last[sess->user_name] = 0;
    eventWrite(fd, "+OK Reset state\r\n");
    break;
  case "stat":
    CHECK_STATE(POP_TRANSACTION);
    if (!sizeof(sess->headers)) {
      load_folder(sess);
    }
    if (!sizeof(sess->deleted)) {
      tell_creator("ceres", "headers: %d, sizes %d\n", sizeof(sess->headers),
                   sizeof(sess->sizes));
      eventWrite(fd, sprintf("+OK %d %d\r\n", sess->num_messages,
                             implode(sess->sizes, (: $1 + $2 :))));
    } else {
      i = 0;
      sizes = map(sess->sizes, function(int size, int ref idx, int *deleted) {
                                 reset_eval_cost();
                                 idx++;
                                 if (member_array(idx, deleted) != -1) {
                                   return 0;
                                 } else {
                                   return size;
                                 }
                               }, ref i, sess->deleted);
      eventWrite(fd, sprintf("+OK %d %d\r\n",
                             (sess->num_messages - sizeof(sess->deleted)),
                             implode(sizes,
                                     (: reset_eval_cost(), $1 + $2 :))));
    }
    break;
  case "top":
    CHECK_STATE(POP_TRANSACTION);
    CHECK_CMD(1, "-ERR Missing message number argument\r\n");
    if ((sscanf(bits[1], "%d", number) != 1) || number < 1 ||
        number > sess->num_messages) {
      eventWrite(fd, "-ERR No such message\r\n");
    } else if (member_array(number, sess->deleted) != -1) {
      eventWrite(fd, sprintf("-ERR Message number %d already deleted\r\n",
                             number));
    } else {
      if (!sizeof(sess->headers)) {
        load_folder(sess);
      }

      last[sess->user_name] = number;
      if(!sess->messages[number-1])
        load_message(sess, number-1);

      if (sizeof(bits) > 2 && (sscanf(bits[2], "%d", lines) == 1) &&
          lines < sess->sizes[number-1]) {
        i = strsrch(sess->messages[number-1], "\r\n\r\n");
        header = sess->messages[number-1][0..i+3];
        message = replace_string(sess->messages[number-1][i+4..], "\n.",
                                 "\n..");
        eventWrite(fd, sprintf("+OK %d octets\r\n", sess->sizes[number-1]));
        eventWrite(fd, header);
        if (lines) {
          bits = explode(message, "\r\n");
          eventWrite(fd, implode(bits[0..lines-1], "\r\n") + "\r\n.\r\n");
        } else {
          eventWrite(fd, ".\r\n");
        }
      } else {
        message = replace_string(sess->messages[number-1], "\n.", "\n..");
        eventWrite(fd, sprintf("+OK %d octets\r\n", sess->sizes[number-1]));
        eventWrite(fd, message + ".\r\n");
      }
    }   
    break;
  case "uidl":
    CHECK_STATE(POP_TRANSACTION);
    if (sizeof(bits) > 1) {
      if ((sscanf(bits[1], "%d", number) != 1) || number < 1 ||
          number > sess->num_messages) {
        eventWrite(fd, "-ERR No such message\r\n");
      } else if (member_array(number, sess->deleted) != -1) {
        eventWrite(fd, sprintf("-ERR Message number %d already deleted\r\n",
                               number));
      } else {
        if (!sizeof(sess->headers)) {
          load_folder(sess);
        }
        eventWrite(fd, sprintf("+OK %d %d\r\n", number,
                               sess->headers[number-1]->number));
      }
    } else {
      eventWrite(fd, "+OK Unique-ID listing follows\r\n");
      if (!sizeof(sess->headers)) {
        load_folder(sess);
      }
      i = 0;
      if (!sizeof(sess->deleted)) {
        map(sess->headers,
            function(class mail_header hdr, int ref idx, int fd) {
              reset_eval_cost();
              eventWrite(fd, sprintf("%d %d\r\n", ++idx, hdr->number));
            }, ref i, fd);
      } else {
        map(sess->headers,
            function (class mail_header hdr, int ref idx, int fd, int *deleted) {
              reset_eval_cost();
              idx++;
              if (member_array(idx, deleted) == -1) {
                eventWrite(fd, sprintf("%d %d\r\n", idx, hdr->number));
              }
            }, ref i, fd, sess->deleted);
      }
      eventWrite(fd, ".\r\n");
    }
    break;
  case "user":
    CHECK_STATE(POP_AUTH_USER);
    CHECK_CMD(1, "-ERR Missing username argument\r\n");
    sess->user_name = bits[1];
    sess->state = POP_AUTH_PASS;
    eventWrite(fd, "+OK User name accepted, password please\r\n");
    break;
  case "":
    eventWrite(fd, "-ERR Null command\r\n");
    break;
  default:
    eventWrite(fd, sprintf("-ERR Unknown command in %s state\r\n",
                           pop_states[sess->state]));
    break;
  }
} /* parse_comm() */

/** @ignore yes */
protected void close_connection(class pop_session sess) {
  if (!sess) {
    return;
  }
  eventWrite(sess->fd, "-ERR Autologout; idle for too long\r\n", 1);
} /* close_connection() */

/** @ignore yes */
protected void clean_sockets() {
  class pop_session sess;
       
  foreach (sess in values(Sockets)) {
    if (!sess->time) {
      sess->time = time();
      continue;
    }
    if (time() - sess->time > 1800)
      close_connection(sess);
  }
  call_out("clean_sockets", 180);
} /* clean_sockets() */

mixed *stats() {
  if(!cache)
    cache = ([ ]);
  return  ({
    ({ "reads", reads, }),
      ({ "cache hit percent", reads != 0 ? (hits * 100) / reads : 0, }),
        ({ "messages in cache", sizeof(keys(cache)), }), 
          });
}
// --- END [/mnt/home2/grok/lib/net/daemon/pop3.c] ---
// --- BEGIN [/mnt/home2/grok/lib/net/daemon/out_tell.c] ---
// Size:   File: "/mnt/home2/grok/lib/net/daemon/out_tell.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628709   Available: 13576063
Inodes: Total: 5242880    Free: 4960135
813 bytes, Last Modified:   File: "/mnt/home2/grok/lib/net/daemon/out_tell.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628709   Available: 13576063
Inodes: Total: 5242880    Free: 4960135
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: out_tell.c,v 1.1 1998/01/06 05:17:08 ceres Exp $
 * $Log: out_tell.c,v $
 * Revision 1.1  1998/01/06 05:17:08  ceres
 * Initial revision
 * 
*/
#include <network.h>

void do_tell(string str) {
  string name, host, mess, newhost;

  if (sscanf(str, "%s@%s %s", name, host, mess) == 3) {
    if ((newhost = INTERMUD_D->GetMudName(replace_string(host, ".", " ")))) {
      SERVICES_D->eventSendTell(name, newhost, mess);
      write(sprintf("You tell %s@%s: %-=*s\n", capitalize(name), host, (int)this_player()->query_cols()
                     -strlen(name)-strlen(host)-13, mess));
      return;
    }
    write(mud_name()+" does not know about the MUD "+host+".\n");
    return;
  }
} /* do_tell() */

void clean_up() {
  destruct(this_object());
} /* clean_up() */
// --- END [/mnt/home2/grok/lib/net/daemon/out_tell.c] ---
// --- BEGIN [/mnt/home2/grok/lib/net/daemon/imap4.c] ---
// Size:   File: "/mnt/home2/grok/lib/net/daemon/imap4.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628709   Available: 13576063
Inodes: Total: 5242880    Free: 4960135
7924 bytes, Last Modified:   File: "/mnt/home2/grok/lib/net/daemon/imap4.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628709   Available: 13576063
Inodes: Total: 5242880    Free: 4960135
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * An attempt at an IMAP4 server. I don't know if I'll actually get it working
 * but I thought it might be fun to try.
 *
 * @author Ceres
 * @date 26 August 2000
 */
#include <network.h>
#include <mail.h>
#include <imap4.h>
#include <mime.h>

inherit SERVER;

private void parse_comm(class imap_session sess, string str);

private string *imap_states = ({
  "CONNECTED",
  "AUTHENTICATED",
  "SELECTED"
});
private mapping Sockets;
private nosave mapping cache;
private nosave int reads, hits;
private mapping last;

protected void create() {
  server::create();
  SetSocketType(STREAM);
  SetDestructOnClose(1);
  Sockets = ([]);
  call_out("setup", 2);
  call_out("clean_sockets", 180);
  unguarded((: restore_object, "/net/save/imap4" :));
  if(!last)
    last = ([ ]);
} /* create() */

/** @ignore yes */
protected void setup() {
  if (eventCreateSocket(PORT_IMAP4) < 0) {
    if (this_object()) {
      destruct(this_object());
    }
  }
} /* setup() */

/** @ignore yes */
protected void eventNewConnection(int fd) {
  class imap_session sess;
  
  server::eventNewConnection(fd);
  sess = new(class imap_session, fd : fd, state : IMAP_CONNECTED, command : "",
             deleted : ({}), messages : ({}));
  Sockets[fd] = sess;
  eventWrite(fd, sprintf("* OK IMAP4 %s Discworld v%s server ready\r\n",
                         query_host_name(), IMAP4_VERSION));
} /* eventNewConnection() */

/** @ignore yes */
protected void eventRead(int fd, string str) {
  string *bits, bit;
  class imap_session sess = Sockets[fd];

  if (!sess) {
    return;
  }
  if (str) {
    sess->command += str;
    if (strsrch(str, '\n') == -1) {
      return;
    }
  }
  sess->command = replace_string(sess->command, "\r", "");
  bits = explode(sess->command, "\n");
  if (!sizeof(bits)) {
    eventWrite(fd, "-ERR Null command\r\n");
  } else {
    foreach (bit in bits) {
      parse_comm(sess, bit);
    }
  }
  sess->command = "";
}

/** @ignore yes */
protected void eventSocketClosed(int fd) {
  class imap_session sess = Sockets[fd];

  if (!sess) {
    return;
  }
  map_delete(Sockets, fd);
} /* eventSocketClosed() */

private void sign_off(class imap_session sess) {
  int *deleted;
  
  if (sizeof(sess->deleted)) {
    deleted = map(sess->deleted, (: $2->headers[$1-1]->number :), sess);
    FOLDER_H->delete_it(sess->user_name, "inbox", deleted);
  }
  unguarded((: save_object, "/net/save/imap4" :));
} /* sign_off() */

private void load_message(class imap_session sess, int message) {
  string mess;
  int which;

  reads++;

  which = sess->headers[message]->number;

  if(!cache)
    cache = ([ ]);
  if(cache[which]) {
    hits++;
    sess->messages[message] = cache[which];
    return;
  }
  
  mess = FOLDER_H->load_message(sess->user_name, "inbox",
                                sess->headers[message]->number);
  mess = MIME->rewrite_header(mess);
  mess = replace_string(mess, "\n", "\r\n");

  if (mess[<1] != '\n') {
    mess += "\r\n";
  }
  sess->messages[message] = mess;
  sess->sizes[message] = strlen(mess);
  
  cache[which] = copy(mess);
} /* load_message() */

private void load_folder(class imap_session sess) {
  int *tmp, max, i;
  
  sess->headers = FOLDER_H->get_messages(sess->user_name, sess->selected);
  tell_creator("ceres", "Headers: %d\n", sizeof(sess->headers));
  sess->messages = allocate(sizeof(sess->headers));
  sess->sizes = allocate(sizeof(sess->headers));
  sess->num_messages = sizeof(sess->headers);

  // the sizes will start out as an approximation. As we read actual messages
  // the real size will be put in place.

  tmp = sess->sizes;
  
  for(i=0; i<sizeof(sess->headers); i++)
    sess->sizes[i] = 1000;

  // If we'd already got some sizes then copy them into the new size array.
  if(tmp) {
    (sizeof(tmp) > sizeof(sess->headers)) ? max = sizeof(tmp) :
      max = sizeof(sess->headers);
    for(i=0; i<max; i++)
      sess->sizes[i] = tmp[i];
  }
} /* load_folder() */

private void parse_comm(class imap_session sess, string str) {
  string *bits, rest, cmd, tmp;
  int fd = sess->fd, i, j, k;
  string id;
	
	TP("Parsing " + str + ".\n");

  bits = explode(str, " ");
	id = bits[0];
  cmd = bits[1];

  sess->time = time();
  switch(lower_case(cmd)) {
	case "capability":
		eventWrite(fd, "* CAPABILITY IMAP4 IMAP4rev1 NAMESPACE AUTH=LOGIN\r\n");
		eventWrite(fd, sprintf("%s OK CAPABILITY completed.\r\n",
													 id, sess->num_messages));
		TP("Sent capability\n");
		break;
	case "noop":
		eventWrite(fd, id + " OK NOOP completed\r\n");
		break;
		
  case "logout":
		sign_off(sess);
		eventWrite(fd, id + " OK LOGOUT completed\r\n", 1);
    break;


	case "authenticate":
    CHECK_STATE(IMAP_CONNECTED);
		eventWrite(fd, sprintf("%s NO - unsupported authentication mechanism.\r\n",
													 id, sess->num_messages));
		break;
  case "login":
    CHECK_STATE(IMAP_CONNECTED);

		if (sizeof(bits) > 4 ) {
			rest = implode(bits[3..], " ");
		} else if(sizeof(bits) > 3) {
			rest = bits[3];
		}
    CHECK_CMD(2, id + " BAD - missing arguments\r\n");
		bits[2] = replace(bits[2], "\"", "");
		rest = replace(rest, "\"", "");
    if (!LOGIN_OB->test_password(bits[2], rest)) {
      sess->state = IMAP_CONNECTED;
      eventWrite(fd, id + " NO - login failure: user name or password rejected\r\n");
    } else {
      sess->state = IMAP_AUTHENTICATED;
			sess->user_name = bits[2];
			TP(bits[2] + " logged in.\n");
      eventWrite(fd, sprintf("%s OK LOGIN completed\r\n",
                             id, sess->num_messages));
    }
		break;

	case "select":
		CHECK_STATE(IMAP_AUTHENTICATED);

		CHECK_CMD(1, id + " BAD - missing argument.\r\n");
		sess->selected = replace(bits[2], ({"\"", "", "/", ""}));
		sess->state = IMAP_SELECTED;
		
		eventWrite(fd, id + " OK - SELECT completed\r\n");
		break;
		
	case "examine":
	case "create":
	case "delete":
	case "rename":
	case "subscribe":
	case "unsubscribe":
	case "list":
		CHECK_STATE(IMAP_AUTHENTICATED);
		foreach(tmp in MAILER->query_folders(sess->user_name)) {
			eventWrite(fd, "* LIST (\\Noselect) \"/\" /" + tmp + "\r\n");
		}
		eventWrite(fd, id + " OK LIST completed\r\n");
		break;
	case "lsub":
		CHECK_STATE(IMAP_AUTHENTICATED);
		foreach(tmp in MAILER->query_folders(sess->user_name)) {
			eventWrite(fd, "* LSUB () \"/\" /" + tmp + "\r\n");
		}
		eventWrite(fd, id + " OK LSUB completed\r\n");
		break;
	case "status":
	case "append":

	case "uid":
		CHECK_STATE(IMAP_SELECTED);

		CHECK_CMD(1, id + " BAD - missing argument.\r\n");
		switch(lower_case(bits[2])) {
		case "fetch":
			TP("Doing fetch\n");
			load_folder(sess);
			if(sscanf(bits[3], "%d:%d", j, k) != 2) {
				sscanf(bits[3], "%d:*", j);
				k = sess->num_messages;
			}

			for(i=j; i<k; i++) {
				eventWrite(fd, " * " + i + " FETCH (FLAGS (\\Seen) UID " +
									 sess->headers[i]->number + "\r\n");
			}
			eventWrite(fd, id + " UID FETCH completed\r\n");
			TP("Ok, done\n");
			break;
		case "copy":
		case "store":
		}
		break;
		
  default:
    eventWrite(fd, sprintf("-ERR Unknown command in %s state\r\n",
                           imap_states[sess->state]));
    break;
  }
	TP("done parsing\n");
} /* parse_comm() */

/** @ignore yes */
protected void close_connection(class imap_session sess) {
  if (!sess) {
    return;
  }
  eventWrite(sess->fd, "-ERR Autologout; idle for too long\r\n", 1);
} /* close_connection() */

/** @ignore yes */
protected void clean_sockets() {
  class imap_session sess;
       
  foreach (sess in values(Sockets)) {
    if (!sess->time) {
      sess->time = time();
      continue;
    }
    if (time() - sess->time > 1800)
      close_connection(sess);
  }
  call_out("clean_sockets", 180);
} /* clean_sockets() */

mixed *stats() {
  if(!cache)
    cache = ([ ]);
  return  ({
    ({ "reads", reads, }),
      ({ "cache hit percent", reads != 0 ? (hits * 100) / reads : 0, }),
        ({ "messages in cache", sizeof(keys(cache)), }), 
          });
}
// --- END [/mnt/home2/grok/lib/net/daemon/imap4.c] ---
// --- BEGIN [/mnt/home2/grok/lib/net/daemon/http.c] ---
// Size:   File: "/mnt/home2/grok/lib/net/daemon/http.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628707   Available: 13576061
Inodes: Total: 5242880    Free: 4960135
71870 bytes, Last Modified:   File: "/mnt/home2/grok/lib/net/daemon/http.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628707   Available: 13576061
Inodes: Total: 5242880    Free: 4960135
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: http.c,v 1.45 2003/04/08 12:54:41 taffyd Exp $
 */
/*    /daemon/http.c
 *    from Nightmare IV
 *    an http daemon that can talk to Mosaic and other WWW clients
 *    created by Descartes of Borg 940521
 *    callback fix by Robocoder 950117
 *    modified for discworld Pinkfish 10th of March 1995
 *    modified to allow 302 (diverted address) messages on 23rd of Feburary 1996
 *              - Pinkfish
 *    modified to use the new inheritable server object by Turrican, 24-4-96
 *    basically rewritten to be more HTTP/1.x compliant - Turrican, 31-1-97
 *    modified to add conditional gets and the like - Turrican, 11-2-97
 *    modified to be conditionally HTTP/1.1 compliant - Turrican, 24-6-97
 *    modified to add the "POST" method - Turrican, 27-6-97
 *    modified to add support for byteranges - Turrican, 2-7-97
 *    modified to add support for reading chunked bodies - Turrican, 22-7-97
 *    modified to support files larger than 200k - Pinkfish 11-11-97
 *    modified to add Basic authentication scheme - Turrican, 19-11-97
 *    modified to decode post attempts - Pinkfish, 20-11-97
 *    modified to support http compression - Ceres, 11-07-01
 *    modified to support delayed http response - Wodan, 19-09-01
 */

/* ====================================================================
 * Copyright (c) 1995-1997 The Apache Group.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the Apache Group
 *    for use in the Apache HTTP server project (http://www.apache.org/)."
 *
 * 4. The names "Apache Server" and "Apache Group" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission.
 *
 * 5. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the Apache Group
 *    for use in the Apache HTTP server project (http://www.apache.org/)."
 *
 * THIS SOFTWARE IS PROVIDED BY THE APACHE GROUP ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE APACHE GROUP OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Group and was originally based
 * on public domain software written at the National Center for
 * Supercomputing Applications, University of Illinois, Urbana-Champaign.
 * For more information on the Apache Group and the Apache HTTP server
 * project, please see <http://www.apache.org/>.
 *
 */

#include <network.h>
#include <localtime.h>
#include <runtime_config.h>
#include <login.h>
#include <config.h>

inherit SERVER;

#include <http.h>

#define IS_PATH 1
#define NOT_PATH 0

#define LOGGING 1

protected int www_resolve(class http_request req);
protected void resolve_incoming(string addr, string nom, int cle);
private void http_error(int fd, int status);
varargs private void add_activity(int fd, string str, mixed *args ...);
varargs protected void close_connection(int fd, int persist);
varargs private int get_file(class http_request req, string body, mixed done);
string format_date(int x);
protected void send_file(int fd, string str);
protected void send_string(int fd, string str, int last_mod, string location,
                           int no_length);
protected void parse_headers(class http_request req, int i);

protected void send_string_array(int fd, string *str, int mod_date,
                           string location, int no_length);

private nosave mapping Sockets;
private nosave mapping Resolve; 
private nosave string current_file;
private nosave int max_file_size;

#ifdef TRACK_PAGE_STATS
mapping http_stats;
#endif

// stuff used for log caching
nosave string log_str;
nosave int cday;

nosave mapping fds_waiting = ([]);
nosave int fd_id;
 
protected void create() {
   server::create();
   SetSocketType(STREAM);
   SetDestructOnClose(1);
   Sockets = ([]);
   Resolve = ([]);

   max_file_size = get_config(__MAX_BUFFER_SIZE__);
   if (get_config(__MAX_STRING_LENGTH__) < max_file_size) {
      max_file_size =get_config(__MAX_STRING_LENGTH__);
   }
   if ( get_config(__MAX_READ_FILE_SIZE__) < max_file_size) {
      max_file_size = get_config(__MAX_READ_FILE_SIZE__);
   }
   if (get_config(__MAX_BYTE_TRANSFER__) < max_file_size) {
      max_file_size = get_config(__MAX_BYTE_TRANSFER__);
   }
   
   call_out("setup", 2);
   call_out("clean_sockets", 180);
   unguarded((: restore_object, SAVE_FILE :));
#ifdef TRACK_PAGE_STATS
   if (!mapp(http_stats)) {
      http_stats = ([]);
   }
#endif  
} /* create() */

protected void setup() {
   if (eventCreateSocket(PORT_INTERNAL_HTTP) < 0) {
      if (this_object()) destruct(this_object());
   }
} /* setup() */

protected void reset() {
#ifdef TRACK_PAGE_STATS
   unguarded((: save_object, SAVE_FILE :));
#endif  
}

int hex_to_decimal(string str) {
   int ret;

   ret = ((str[0] >= 'A') ? ((str[0] & 0xdf) - 'A')+10 : (str[0] - '0'));
   ret *= 16;
   ret += (str[1] >= 'A' ? ((str[1] & 0xdf) - 'A')+10 : (str[1] - '0'));
   
   return ret;
} /* hex_to_decimal() */

/*
 * Replace all the mime codes in the address,
 * return HTTP_OK on success, error code on failure.
 */
int unmime(string ref url, int is_path) {
   int x, y, badesc, badpath, len, char, pos = -1;

   badesc = 0;
   badpath = 0;
   len = strlen(url);
   for (x = 0, y = 0; y < len; ++x, ++y) {
      if (url[y] != '%') {
         url[x] = url[y];
      } else {
         if (!isxdigit(url[y+1]) || !isxdigit(url[y+2])) {
            badesc = 1;
            url[x] = '%';
         } else {
            char = hex_to_decimal(url[y+1..]);
            y += 2;
            if (char) {
               url[x] = char;
            } else if (pos == -1) {
               pos = x;
            }
            if ((char == '/' && is_path) || !char) {
               badpath = 1;
            }
         }
      }
   }
   url = url[0..x-1];
   if (badesc) {
      return BAD_CMD;
   } else if (badpath) {
      url = url[0..pos-1];
      return NOT_FOUND;
   } else {
      return HTTP_OK;
   }
} /* unmime() */

string mime(string str) {
   return replace_string(str, " ", "%20");
} /* mime() */

string escape_html(string s) {
   return replace(s, ({ "&", "&amp;", "<", "&lt;", ">", "&gt;"}));
} /* escape_html() */

string next_token(string ref line) {
   int i, len = strlen(line);
   string ret, tspecials = " \t()<>@,;:\\/[]?={}";
   
   while ((i < len) && (iscntrl(line[i]) ||
                        (strsrch(tspecials, line[i]) != -1))) {
      if (line[i] == '"') {
         while ((i < len) && (line[i] != '"'))
            ++i;
      } else {
         ++i;
      }
   }
   if (i == len) {
      ret = 0;
   } else {
      ret = line[i..];
      
      i = 0;
      while ((i < len) && !iscntrl(line[i]) &&
             (strsrch(tspecials, line[i]) == -1)) {
         ++i;
      }
      
      if (i < len) {
         line = line[i+1..];
      } else {
         line = "";
      }
   }
   return (ret ? ret[0..i-1] : 0);
} /* next_token() */

int find_token(string line, string token) {
   string ltok;
  
   if (!line) {
      return 0;
   }

   while ((ltok = next_token(ref line))) {
      if (lower_case(ltok) == lower_case(token)) {
         return 1;
      }
   }

   return 0;
} /* find_token() */

int find_last_token(string line, string token) {
   int tlen;
   
   tlen = strlen(token);
   if (!line ||
       (strlen(line) <= tlen) ||
       (!isspace(line[<tlen+1]) && (line[<tlen+1] != ','))) {
      return 0;
   }
   return (lower_case(line[<tlen..]) == lower_case(token));
} /* find_last_token() */

protected void eventNewConnection(int fd) {
   class http_request t;
   string tmp;
   int x;

   server::eventNewConnection(fd);
   sscanf(socket_address(fd), "%s %*s", tmp);
   x = resolve(tmp, "resolve_callback");
   Resolve[x] = fd;
   t = new(class http_request, uri : "", request : "", status : TIME_OUT);
   t->sess = new(class http_session, fd : fd, address : tmp);
   t->rh = new(class http_request_header);
   t->rh->headers_in = new(class mime_header, header_m : ([ ]), header_k : ({ }));
   t->rh->headers_out = new(class mime_header, header_m : ([ ]), header_k : ({ }));
   t->rh->err_headers_out = new(class mime_header, header_m : ([ ]), header_k : ({ }));
   t->body = new(class http_body);
   t->bi = new(class http_body_info);
   if (Sockets[fd]) {
      remove_call_out(Sockets[fd]->id);
   }
   Sockets[fd] = t;
} /* eventNewConnection */

protected int parse_byterange(string range, int clength, int ref start,
                              int ref end) {
   int len;
   int num;
   int dashpos = strsrch(range, '-');
   string dash;

   if (dashpos == -1) {
      return 0;
   }

   if (dashpos == 0) {
      /* In the form "-5" */
      sscanf(range[dashpos+1..], "%d", num);
      start = clength - num;
      end = clength - 1;
   } else {
      len = strlen(range);
      dash = range;
      range = range[0..dashpos-1];
      dashpos++;
      sscanf(range, "%d", start);
      if (dashpos < len) {
         sscanf(dash[dashpos..], "%d", end);
      } else {
         end = clength - 1;
      }
   }
   
   if (start > end) {
      return 0;
   }
   
   if (end >= clength) {
      end = clength - 1;
   }
   
   return 1;
} /* parse_byterange() */

protected int internal_byterange(int realreq, int ref tlength,
                                 class http_request req, string ref r_range,
                                 int ref offset, int ref length) {
   int range_start;
   int range_end;
   int i;
   string range;

   if (!strlen(r_range)) {
      if (req->bi->byterange > 1) {
         if (realreq) {
            eventWrite(req->sess->fd, sprintf("\r\n--%s--\r\n",
                                              req->bi->boundary));
         } else {
            tlength += 4 + strlen(req->bi->boundary) + 4;
         }
      }
      return 0;
   }
   
   if ((i = strsrch(r_range, ',')) == -1) {
      range = r_range;
      r_range = "";
   } else {
      range = r_range[0..i-1];
      r_range = r_range[i+1..];
   }
   
   if (!parse_byterange(range, req->bi->clength, ref range_start,
                        ref range_end))
      return internal_byterange(realreq, ref tlength, req, ref r_range,
                                ref offset, ref length);
   
   if (req->bi->byterange > 1) {
      string ts;
      string ct;
      
      ct = req->bi->content_type ? req->bi->content_type : "text/html";
      ts = sprintf("%d-%d/%d", range_start, range_end, req->bi->clength);
      if (realreq) {
         eventWrite(req->sess->fd, sprintf("\r\n--%s\r\nContent-Type: %s\r\n"
                                           "Content-Range: bytes %s\r\n\r\n",
                                           req->bi->boundary, ct, ts));
      } else {
         tlength += 4 + strlen(req->bi->boundary) + 16 + strlen(ct) + 23 +
            strlen(ts) + 4;
      }
   }
   if (realreq) {
      offset = range_start;
      length = range_end - range_start;
   } else {
      tlength += range_end - range_start + 1;
   }
   return 1;
} /* internal_byterange() */

protected int each_byterange(class http_request req, int ref offset,
                             int ref length) {
   int tlength;
   
   return internal_byterange(1, ref tlength, req, ref req->bi->range,
                             ref offset, ref length);
} /* each_byterange() */

protected int set_byterange(class http_request req) {
   string range;
   string if_range;
   string match;
   int range_start;
   int range_end;
   
   if (!req->bi->clength || req->rh->noheaders) {
      return 0;
   }
  
   if (!(range = req->rh->headers_in->header_m["range"])) {
      range = req->rh->headers_in->header_m["request-range"];
   }

   if (!range || (range[0..5] != "bytes=")) {
      req->rh->headers_out->header_m["Accept-Ranges"] = "bytes";
      req->rh->headers_out->header_k += ({ "Accept-Ranges" });
      return 0;
   }

   if ((if_range = req->rh->headers_in->header_m["if-range"])) {
      if (if_range[0] == '"') {
         if (!(match = req->rh->headers_out->header_m["ETag"]) ||
             (lower_case(match) != lower_case(if_range))) {
            return 0;
         }
      } else if (!(match = req->rh->headers_out->header_m["Last-Modified"]) ||
                 (lower_case(match) != lower_case(if_range))) {
         return 0;
      }
   }

   if (strsrch(range, ',') == -1) {
      if (!parse_byterange(range[6..], req->bi->clength, ref range_start,
                           ref range_end)) {
         return 0;
      }

      req->bi->byterange = 1;
      req->rh->headers_out->header_m["Content-Range"] =
         sprintf("bytes %d-%d/%d", range_start, range_end, req->bi->clength);
      req->rh->headers_out->header_m["Content-Length"] =
         sprintf("%d", range_end - range_start + 1);
      req->rh->headers_out->header_k += ({ "Content-Range" });
   } else {
      int tlength, d1, d2;
      string r_range = range[6..];
      
      req->bi->byterange = 2;
      req->bi->boundary = sprintf("%x%x", req->time, req->sess->fd);
      while (internal_byterange(0, ref tlength, req, ref r_range, ref d1,
                                ref d2)) {
         ;
      }
      req->rh->headers_out->header_m["Content-Length"] =
         sprintf("%d", tlength);
   }
   
   req->status = PARTIAL_CONTENT;
   req->bi->range = range[6..];
   
   return 1;
} /* set_byterange() */

protected int set_persist(class http_request req) {
   int ka_sent;
   int wimpy;
   string conn = req->rh->headers_in->header_m["connection"];
   
   wimpy = find_token(req->rh->headers_out->header_m["Connection"], "close");
   if (((req->status == NOT_MODIFIED) ||
        (req->status == NO_CONTENT) ||
        req->rh->header_only ||
        !undefinedp(req->rh->headers_out->header_m["Content-Length"]) ||
        find_last_token(req->rh->headers_out->header_m["Transfer-Encoding"],
                        "chunked") ||
        ((req->proto_num >= 1001) && (req->bi->chunked = 1))) &&
       !status_drops_connection(req->status) &&
       !wimpy &&
       !find_token(conn, "close") &&
       (((ka_sent = find_token(conn, "keep-alive"))) ||
        (req->proto_num >= 1001))
       ) {
      req->persistent = 1;
      
      /* If they sent a Keep-Alive token, send one back */
      if (ka_sent) {
         req->rh->headers_out->header_m["Keep-Alive"] = "timeout=15";
         req->rh->headers_out->header_k += ({ "Keep-Alive" });
         if (!undefinedp(req->rh->headers_out->header_m["Connection"])) {
            req->rh->headers_out->header_m["Connection"] += ", Keep-Alive";
         } else {
            req->rh->headers_out->header_m["Connection"] = "Keep-Alive";
            req->rh->headers_out->header_k += ({ "Connection" });
         }
      }
      
      return 1;
   }
   
   if (!undefinedp(req->rh->headers_out->header_m["Connection"])) {
      req->rh->headers_out->header_m["Connection"] += ", close";
   } else {
      req->rh->headers_out->header_m["Connection"] = "close";
      req->rh->headers_out->header_k += ({ "Connection" });
   }
   
   req->persistent = 0;
   
   return 0;
} /* set_persist() */

protected void basic_header(class http_request req) {
   int fd = req->sess->fd;
   
   if (req->rh->noheaders) {
      return;
   }
   if (!req->status_line) {
      req->status_line = status_lines[req->status];
   }
   eventWrite(fd, sprintf("%s %s\r\n", HTTP_PROTOCOL, req->status_line));
   eventWrite(fd, sprintf("Date: %s\r\n", format_date(req->time)));
   eventWrite(fd, sprintf("Server: %s\r\n", HTTP_VERSION));
   
   map_delete(req->rh->headers_out->header_m, "Date");
   map_delete(req->rh->headers_out->header_m, "Server");
   req->rh->headers_out->header_k -= ({ "Date", "Server" });
} /* basic_header() */

protected void send_headers(class http_request req, mapping headers,
                            mixed *args ...) {
   string key;
   foreach (key in args) {
      if (undefinedp(headers[key])) {
         continue;
      }
      eventWrite(req->sess->fd, sprintf("%s: %s\r\n", key,
                                        headers[key]));
   }
   eventWrite(req->sess->fd, "\r\n");
} /* send_headers() */

protected int use_range_x(class http_request req) {
   string ua;
  
   return (!undefinedp(req->rh->headers_in->header_m["request-range"]) ||
           ((ua = req->rh->headers_in->header_m["user-agent"]) &&
            (strsrch(ua, "MSIE 3") != -1)));
} /* use_range_x() */

protected void http_header(class http_request req) {
   if (req->rh->noheaders)
      return;
   
   basic_header(req);
   
   set_persist(req);
   
   if (req->bi->chunked) {
      if (!undefinedp(req->rh->headers_out->header_m["Transfer-Encoding"])) {
         req->rh->headers_out->header_m["Transfer-Encoding"] += ", chunked";
      } else {
         req->rh->headers_out->header_m["Transfer-Encoding"] = "chunked";
      }
      req->rh->headers_out->header_k += ({ "Transfer-Encoding" });
      map_delete(req->rh->headers_out->header_m, "Content-Length");
      req->rh->headers_out->header_k -= ({ "Content-Length" });
   }
   
   if (req->bi->byterange > 1) {
      req->rh->headers_out->header_m["Content-Type"] =
         sprintf("multipart%sbyteranges; boundary=%s",
                 (use_range_x(req) ? "/x-" : "/"), req->bi->boundary);
   } else if (req->bi->content_type) {
      req->rh->headers_out->header_m["Content-Type"] = req->bi->content_type;
   } else {
      req->rh->headers_out->header_m["Content-Type"] = "text/plain";
   }
   req->rh->headers_out->header_k += ({ "Content-Type" });

   if(req->compression) {
     req->rh->headers_out->header_m[HTTP_CODING_TYPE] = req->compression;
     req->rh->headers_out->header_k += ({ HTTP_CODING_TYPE });
   }
   
   /* Not used yet 
      if (req->no_cache &&
      undefinedp(req->rh->headers_out->header_m["Expires"])) {
      req->rh->headers_out->header_m["Expires"] = format_date(req->time);
      req->rh->headers_out->header_k += ({ "Expires" });
      } */
   
   send_headers(req, req->rh->headers_out->header_m,
                req->rh->headers_out->header_k ...);
} /* http_header() */

protected int handle_request(class http_request req, mixed done) {
   int errno;
   int fd = req->sess->fd;
   string buff;
   string key;
   int t, tmp;
   float secs;
   
   if (req->method == "HEAD") {
      if (req->rh->noheaders) {
         http_error(fd, BAD_CMD);
         return 0;
      }
      req->rh->header_only = 1;
   }
   if ((!req->hostname && (req->proto_num >= 1001)) ||
       ((req->proto_num == 1001) &&
        undefinedp(req->rh->headers_in->header_m["host"]))) {
      /* Client didn't send the hostname, HTTP/1.1 requires this. */
      TP("client sent HTTP/1.1 request without hostname\n");
      http_error(fd, BAD_CMD);
      return 0;
   }
   if (req->method != "TRACE") {
      if ((errno = unmime(ref req->uri, IS_PATH)) != HTTP_OK) {
         http_error(fd, errno);
         return 0;
      }
      if ((errno = www_resolve(req)) != HTTP_OK) {
         if (!((req->method == "OPTIONS") && (errno == NOT_FOUND))) {
            http_error(fd, errno);
            return 0;
         }
      }
   }
   switch (req->method) {
   case "POST":
      if (explode(req->filename, ".")[<1] != "c")
         http_error(fd, NOT_ALLOWED);
      return 0;
   case "TRACE":
      /* We want the original request here. */
      while (req->prev) {
         req = req->prev;
      }
      req->bi->content_type = "message/http";
      http_header(req);
      buff = sprintf("%s\r\n", req->the_request);
      foreach (key in req->rh->headers_in->header_k) {
         if (undefinedp(req->rh->headers_in->header_m[lower_case(key)])) {
            continue;
         }
         buff += sprintf("%s: %s\r\n", key,
                         req->rh->headers_in->header_m[lower_case(key)]);
      }
      buff += sprintf("\r\n");
      if (req->bi->chunked) {
         eventWrite(fd, sprintf("%x\r\n", strlen(buff)));
      }
      eventWrite(fd, buff);
      if (req->bi->chunked) {
         eventWrite(fd, "\r\n0\r\n\r\n");
      }
      return 0;
   case "OPTIONS":
      if (req->rh->noheaders) {
         http_error(fd, BAD_CMD);
         return 0;
      }
      basic_header(req);
      req->rh->headers_out->header_m["Content-Length"] = 0;
      if (explode(req->filename, ".")[<1] == "c") {
         req->rh->headers_out->header_m["Allow"] =
            "GET, HEAD, POST, OPTIONS, TRACE";
      } else {
         req->rh->headers_out->header_m["Allow"] = "GET, HEAD, OPTIONS, TRACE";
      }
      req->rh->headers_out->header_k += ({ "Content-Length", "Allow" });
      set_persist(req);
      send_headers(req, req->rh->headers_out->header_m,
                   req->rh->headers_out->header_k ...);
      return 0;
   case "HEAD":
   case "GET":
      t = time_expression{
        tmp = get_file(req, done);
      };
      secs = t/1000000.0;
      if(secs > 1) {
        log_file("GARBAGE", "%s URI: %s?%s time: %:3f\n",
                 ctime(time())[4..18], req->uri,
                 (req->args?req->args:""),
                 secs);
      }
      return tmp;
   default:
      http_error(fd, NOT_IMPLEMENTED);
      return 0;
   }
} /* handle_request() */

int handle_body(class http_request req) {
   class http_body body = req->body;
   string tenc;
   string len;
   string buf;
   int i;
   int slen;
   int len_to_read;

   if ((req->status != HTTP_OK) || (req->method != "POST")) {
      return HTTP_OK;
   }
  
   switch (body->state) {
   case BODY_START:
      tenc = req->rh->headers_in->header_m["transfer-encoding"];
      len = req->rh->headers_in->header_m["content-length"];
      if (tenc) {
         if (tenc != "chunked")
            return NOT_IMPLEMENTED;
         /* It's chunked, we don't allow that for POST requests yet.
            return (len) ? BAD_CMD : LENGTH_REQUIRED; */
         
         body->read_chunked = 1;
      } else if (len) {
         slen = strlen(len);
         while ((i < slen) && (isdigit(len[i]) || isspace(len[i]))) {
            ++i;
         }
         if (i != slen) {
            return BAD_CMD;
         }
         sscanf(len, "%d", body->remaining);
      }
      if (!body->read_chunked && !body->remaining) {
         get_file(req);
         return HTTP_OK;
      }
      if (req->proto_num >= 1001) {
         eventWrite(req->sess->fd, sprintf("%s %s\r\n\r\n", HTTP_PROTOCOL,
                                           status_lines[CONTINUE]));
      }
      body->buff = "";
      body->state = BODY_READ;
   case BODY_READ:
      if (!body->read_chunked) {
         if (strlen(req->request) < body->remaining) {
            return CONTINUE;
         } else {
            body->buff = req->request[0..body->remaining-1];
            req->request = req->request[body->remaining..];
            get_file(req);
            return HTTP_OK;
         }
      }
      /* Eek, chunked read. This is no fun :) */
      if (body->remaining == 0) {
         if (sscanf(req->request, "%s\r\n%s", buf, req->request) != 2) {
            return CONTINUE;
         }
         if (!strlen(buf) || !isxdigit(buf[0])) {
            req->persistent = 0;
            return HTTP_OK;
         }
         sscanf(buf, "%x", len_to_read);
         if (len_to_read == 0) { /* last chunk */
            /* Put the previous "\r\n" back in */
            req->request = sprintf("\r\n%s", req->request); 
            if ((i = strsrch(req->request, "\r\n\r\n")) != -1) {
               parse_headers(req, i-1);
               req->request = req->request[i+4..];
               map_delete(req->rh->headers_in->header_m, "transfer-encoding");
               req->rh->headers_in->header_k -= ({ "transfer-encoding" });
               req->rh->headers_in->header_m["content-length"] =
                  sprintf("%d", body->read_length);
               req->rh->headers_in->header_k += ({ "content-length" });
               get_file(req);
               return HTTP_OK;
            } else {
               /* Not complete yet. */
               body->state = BODY_CHUNK_FOOTER;
               return CONTINUE;
            }
         } else {
            body->remaining = len_to_read;
         }
      }
      if (strlen(req->request) < body->remaining) {
         return CONTINUE;
      } else {
         body->buff += req->request[0..body->remaining-1];
         req->request = req->request[body->remaining..];
         body->read_length += body->remaining;
         body->remaining = 0;
         body->state = BODY_CHUNK_END;
      }
   case BODY_CHUNK_FOOTER:
      if ((i = strsrch(req->request, "\r\n\r\n")) != -1) {
         parse_headers(req, i-1);
         req->request = req->request[i+4..];
         map_delete(req->rh->headers_in->header_m, "transfer-encoding");
         req->rh->headers_in->header_k -= ({ "transfer-encoding" });
         req->rh->headers_in->header_m["content-length"] =
            sprintf("%d", body->read_length);
         req->rh->headers_in->header_k += ({ "content-length" });
         get_file(req);
         return HTTP_OK;
      } else {
         return CONTINUE;
      }
   case BODY_CHUNK_END:
      if (strlen(req->request) < 2) {
         return CONTINUE;
      }
      if (req->request[0..1] != "\r\n") {
         req->persistent = 0;
         return HTTP_OK;
      }
      req->request = req->request[2..];
      body->state = BODY_READ;
      if (strlen(req->request)) {
         return handle_body(req);
      }
      return CONTINUE;
   }
} /* handle_body() */

protected void parse_headers(class http_request req, int i) {
   string *bits;
   string bit;
   string cont;
   int idx;
   int len;

   bits = explode(req->request[0..i], "\r\n") - ({ "", 0 });
   foreach (bit in bits) {
      if (cont && ((bit[0] == ' ') || (bit[0] == '\t'))) {
         req->rh->headers_in->header_m[cont] += bit[1..];
         continue;
      }
      len = strlen(bit);
      if ((idx = strsrch(bit, ':')) == -1) {
         continue;
      }
      cont = bit[0..idx-1];
      if (undefinedp(req->rh->headers_in->header_m[lower_case(cont)])) {
         req->rh->headers_in->header_k += ({ cont });
      }
      cont = lower_case(cont);
      ++idx;
      while ((idx < len) && isspace(bit[idx])) {
         ++idx;
      }
      if (undefinedp(req->rh->headers_in->header_m[cont])) {
         req->rh->headers_in->header_m[cont] = bit[idx..];
      } else {
         req->rh->headers_in->header_m[cont] += sprintf(", %s", bit[idx..]);
      }
   }
} /* parse_headers() */

protected string check_fulluri(class http_request req, string uri) {
   string name;
   string host;
   int i;
   int port;
   
   if (lower_case(uri[0..6]) != "http://") {
      return uri;
   }
   name = uri[7..];
   i = strsrch(name, '/');
   name = name[0..i-1];
   if (sscanf(name, "%s:%d", host, port) != 2) {
      port = 80;
   }
   if (port != PORT_INTERNAL_HTTP) {
      return uri;
   }
   req->hostname = host;
   /* XXX - should be done with resolve() */
   if (lower_case(host) == "discworld.imaginary.com" ||
       lower_case(host) == "discworld.lspace.org" ||
       lower_case(host) == "atuin.icepack.com" ||
       lower_case(host) == "localhost" ||
       lower_case(host) == "208.202.120.111") {
      return uri[7+i..];
   }
   return uri;
} /* check_fulluri() */

void parse_uri(class http_request req, string uri) {
   int len;
   int i;

   len = strlen(uri);
   for (i = 0; i < len; i++) {
      if (!isalnum(uri[i]) && uri[i] != '+' && uri[i] != '-' &&
          uri[i] != '.') {
         break;
      }
   }
   
   if (uri[i] == ':' && i) {
      req->proxyreq = 1;
      req->uri = uri;
      req->args = 0;
   } else if (req->method == "TRACE") {
      req->proxyreq = 0;
      req->uri = uri;
      req->args = 0;
   } else {
      req->proxyreq = 0;
      if (sscanf(uri, "%s?%s", req->uri, req->args) != 2) {
         req->uri = uri;
         req->args = 0;
      }
   }
} /* parse_uri() */

varargs protected void eventRead(int fd, string str, mixed done) {
   string uri;
   string rest;
   string protocol;
   int major;
   int minor;
   int i;
   int ret;
   class http_request req = (class http_request)Sockets[fd];

   if (!req) {
      return ;
   }

   if (req->id) {
      remove_call_out(req->id);
   }

   if (str) {
      TP("Received: " + replace(str, ({ "\r", "<CR>", "\n", "<LF>\n"})));
      req->request += str;
      if ((req->state != REQ_BODY) && (strsrch(str, '\n') == -1) && !done)
         return;
   }

   switch (req->state) {
   case REQ_REQUEST:
      /* Skip leading newlines */
      if (str == "\r\n") {
         return;
      }
      sscanf(req->request, "%*(^(\r\n)*)%s\r\n%*s", req->the_request);
      if (!req->the_request) {
         return;
      }
      req->time = time();
      if ((sscanf(req->request,
                  "%*(^(\r\n)*)%s%*(( |\t)+)%s%*(( |\t)+)%s%((\r\n).*)",
                  req->method, uri, protocol, rest) != 7) &&
          (sscanf(req->request, "%*(^(\r\n)*)%s%*(( |\t)+)%s\r\n%*s",
                  req->method, uri) != 5)) {
         req->rh->noheaders = 1;
         http_error(fd, BAD_CMD);
         return;
      }
      req->request = rest;
      uri = check_fulluri(req, uri);
      parse_uri(req, uri);
      if (!stringp(protocol) || !strlen(protocol)) {
         req->rh->noheaders = 1;
         protocol = "HTTP/0.9";
      }
      sscanf(protocol, "HTTP/%d.%d", major, minor);
      req->proto_num = 1000 * major + minor;
      req->state = REQ_HEADERS;
   case REQ_HEADERS:
     if(!done){
      if (!req->rh->noheaders &&
          ((i = strsrch(req->request, "\r\n\r\n")) != -1)) {
         parse_headers(req, i-1);
         req->request = req->request[i+4..];
         req->status = HTTP_OK;
         if (!(req->hostname ||
               undefinedp(req->rh->headers_in->header_m["host"]))) {
            req->hostname = req->rh->headers_in->header_m["host"];
         } else {
            req->hostname = "discworld.imaginary.com:"+ PORT_INTERNAL_HTTP;
         }
      } else if (!req->rh->noheaders) {
         /* No full set of headers received yet */
         return;
      } else if (!req->hostname) {
         req->hostname = "discworld.imaginary.com:"+ PORT_INTERNAL_HTTP;
      }
     }
      if(handle_request(req, done))
        return;
      req->state = REQ_BODY;
   case REQ_BODY:
      if ((ret = handle_body(req)) != HTTP_OK) {
         if (ret == CONTINUE)
            return;
         else
            http_error(fd, ret);
      }

      // If we are delayed ignore other rubbish on the line.
      if (req->delayed) {
         return ;
      }

      if (!req->persistent) {
         TP("Closing connection\n");
         eventWrite(fd, 0, 1);
         return;
      }
      req->id = call_out("close_connection", 15, fd, 1);
      req->status = TIME_OUT;
      req->rh->headers_in->header_m = ([ ]);
      req->rh->headers_in->header_k = ({ });
      req->rh->headers_out->header_m = ([ ]);
      req->rh->headers_out->header_k = ({ });
      req->rh->err_headers_out->header_m = ([ ]);
      req->rh->err_headers_out->header_k = ({ });
      req->hostname = 0;
      req->rh->noheaders = 0;
      req->rh->header_only = 0;
      req->proto_num = 0;
      req->persistent = 0;
      req->numredirect = 0;
      req->bi->chunked = 0;
      req->status_line = 0;
      req->bi->content_type = 0;
      req->bi->clength = 0;
      req->bi->byterange = 0;
      req->bi->boundary = 0;
      req->bi->range = 0;
      req->method = 0;
      req->args = 0;
      req->filename = 0;
      req->dir = 0;
      req->location = 0;
      req->the_request = 0;
      req->uri = "";
      req->body->state = BODY_START;
      req->state = REQ_REQUEST;
      if (strlen(req->request))
         eventRead(fd, 0);
   }
} /* eventRead() */

protected void eventSocketClosed(int fd) {
   class http_request req = (class http_request)Sockets[fd];
   
   if (req) {
      map_delete(Sockets, fd);
   }
   map_delete(fds_waiting, fd);
} /* eventSocketClosed() */
     
protected void resolve_callback(string name, string addr, int key) {
   class http_request req;
   
   if (undefinedp(Resolve[key])) {
      return;
   }
   req = (class http_request)Sockets[Resolve[key]];
   if (req && req->sess->address == addr) {
      req->sess->name = (name ? name : addr);
   }
   map_delete(Resolve, key);
} /* resolve_callback() */

string uudecode(string bufcoded) {
   int nbytesdecoded;
   string bufin;
   string prevbufin;
   string bufout;
   int nprbytes;
   int i;
   int nbufcoded;
   int *pr2six = ({
      64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
      64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,62,64,64,64,63,
      52,53,54,55,56,57,58,59,60,61,64,64,64,64,64,64,64,0,1,2,3,4,5,6,7,8,9,
      10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,64,64,64,64,64,64,26,27,
      28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,
      64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
      64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
      64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
      64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
      64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
      64,64,64,64,64,64,64,64,64,64,64,64,64 });

  /* Strip leading whitespace. */

   while (bufcoded[nbufcoded] == ' ' || bufcoded[nbufcoded] == '\t') {
      nbufcoded++;
   }

   /* Figure out how many characters are in the input buffer.
    * Allocate this many from the per-transaction pool for the result.
    */
   bufin = bufcoded[nbufcoded..];
   i = 0;
   while (pr2six[bufin[i++]] <= 63);
   nprbytes = i - nbufcoded - 1;
   nbytesdecoded = ((nprbytes+3)/4) * 3;
   
   bufout = "";
   while (nprbytes > 0) {
      bufout += sprintf("%c%c%c",
                        (pr2six[bufin[0]] << 2 | pr2six[bufin[1]] >> 4),
                        (pr2six[bufin[1]] << 4 | pr2six[bufin[2]] >> 2),
                        (pr2six[bufin[2]] << 6 | pr2six[bufin[3]]));
      prevbufin = bufin;
      bufin = bufin[4..];
      nprbytes -= 4;
   }
   
   if (nprbytes & 03) {
      if ((strlen(prevbufin) >= 2) && (pr2six[prevbufin[<2]] > 63)) {
         nbytesdecoded -= 2;
      } else {
         nbytesdecoded -= 1;
      }
   }
   return bufout[0..nbytesdecoded-1];
} /* uudecode() */
     
private void http_error(int fd, int status) {
   class http_request req = (class http_request)Sockets[fd];
   string buff;
   
   if (undefinedp(status_lines[status])) {
      status = 500;
   }
   req->status = status;
   
   if (status == NOT_MODIFIED) {
      basic_header(req);
      set_persist(req);
      send_headers(req, req->rh->headers_out->header_m,
                   "Connection",
                   "Keep-Alive",
                   "ETag",
                   "Content-Location",
                   "Expires",
                   "Cache-Control",
                   "Vary",
                   "Warning",
                   "WWW-Authenticate");
      return;
   }
   
   if (!req->rh->noheaders) {
      req->rh->headers_out->header_m = req->rh->err_headers_out->header_m;
      req->rh->headers_out->header_k = req->rh->err_headers_out->header_k;
      req->rh->err_headers_out->header_m = ([ ]);
      req->rh->err_headers_out->header_k = ({ });
      if (req->location && (status == MOVED_PERMANENTLY ||
                            status == MOVED_TEMP)) {
         req->rh->headers_out->header_m["Location"] = req->location;
         req->rh->headers_out->header_k += ({ "Location" });
      }
      req->bi->content_type = "text/html";
      if ((status == NOT_ALLOWED) || (status == NOT_IMPLEMENTED)) {
         if (explode(req->filename, ".")[<1] == "c") {
            req->rh->headers_out->header_m["Allow"] =
               "GET, HEAD, POST, OPTIONS, TRACE";
         } else {
            req->rh->headers_out->header_m["Allow"] = "GET, HEAD, OPTIONS, TRACE";
         }
         req->rh->headers_out->header_k += ({ "Allow" });
      }
      http_header(req);
      if (req->rh->header_only) {
         return;
      }
   }
   buff = sprintf("<HTML><HEAD>\n<TITLE>%s</TITLE>\n</HEAD>"
                  "<BODY>\n<H1>%s</H1>\n", status_lines[status],
                 status_lines[status][4..]);
   switch (status) {
   case MOVED_PERMANENTLY:
   case MOVED_TEMP:
      buff += sprintf("The document has moved <A HREF=\"%s\""
                      ">here</A>.<P>\n", escape_html(req->location));
      break;
   case BAD_CMD:
      buff += "Your browser sent a request that\n"
         "this server could not understand.<P>\n";
      break;
   case AUTH_REQUIRED:
      buff += "This server could not verify that you\n"
         "are authorized to access the document you\n"
         "requested.  Either you supplied the wrong\n"
         "credentials (e.g., bad password), or your\n"
         "browser doesn't understand how to supply\n"
         "the credentials required.<P>\n";
      break;
   case ACCESS_DENIED:
      buff += sprintf("You don't have permission to access %s\n"
                      "on this server.<P>\n"
                      "This is either because you do not have the correct "
                      "user permissions or because your site has been "
                      "<b>temporarily</b> locked out due to excessive "
                      "login failures.<p>\n"
                      "If you believe it is the latter wait 15 minutes and "
                      "then try again.<p>\n", escape_html(req->uri));
      break;
   case NOT_FOUND:
      buff += sprintf("The requested URL %s was not found on this "
                      "server.<P>\n", escape_html(req->uri));
      break;
   case NOT_ALLOWED:
      buff += sprintf("The requested method %s is not allowed for the "
                      "URL %s.<P>\n", escape_html(req->method),
                      escape_html(req->uri));
      break;
   case TIME_OUT:
      buff += "Please, I don't have all day. Goodbye.\n";
      break;
   case LENGTH_REQUIRED:
      buff += sprintf("A request of the requested method %s requires a valid "
                      "Content-length.<P>\n", escape_html(req->method));
      break;
   case PRECONDITION_FAILED:
      buff += sprintf("The precondition on the request for the URL %s "
                      "evaluated to false.<P>\n", escape_html(req->uri));
      break;
   case NOT_IMPLEMENTED:
      buff += sprintf("%s to %s not supported.<P>\n",
                      escape_html(req->method),
                      escape_html(req->uri));
      break;
   default:
      buff += "This is the end of the line. The tomatoes have finally "
         "expired.<P>\n";
      break;
   }
   buff += "</BODY></HTML>\n";
   if (req->bi->chunked) {
      eventWrite(fd, sprintf("%x\r\n", strlen(buff)));
   }
   eventWrite(fd, buff);
   if (req->bi->chunked) {
      eventWrite(fd, "\r\n0\r\n\r\n");
   }
} /* http_error() */
     
varargs protected void close_connection(int fd, int persist) {
   class http_request req = (class http_request)Sockets[fd];
   if (!req) {
      return;
   }
   if (!req->sess->name) {
      req->sess->name = req->sess->address;
   }
   if (!persist) {
      http_error(fd, TIME_OUT);
   }
   eventWrite(fd, 0, 1);
} /* close_connection() */
     
protected void clean_sockets() {
   class http_request req;
       
   foreach (req in (class http_request *)values(Sockets)) {
      if (!req->time) {
         req->time = time();
         continue;
      }
      if (time() - req->time > 180) {
         close_connection(req->sess->fd);
      }
   }
   call_out("clean_sockets", 180);
} /* clean_sockets() */

protected string auth_name(class http_request req) {
   return "Discworld-login";
} /* auth_name() */

protected void auth_failure(class http_request req) {
   string mess;

   if (req->user) {
      mess = capitalize(req->user) + " failed to login, web, " +
         (req->sess->name ? req->sess->name + " (" +
          req->sess->address : req->sess->address);
      event(users(), "inform", mess, "bad-password");
      log_file("BAD_PASSWORD", ctime(time()) + ": " + mess + "\n");
      LOGIN_HANDLER->failed_login(req->sess->address);
   }

   req->rh->err_headers_out->header_m["WWW-Authenticate"] =
      sprintf("Basic realm=\"%s\"", auth_name(req));
   req->rh->err_headers_out->header_k += ({ "WWW-Authenticate" });
} /* auth_failure() */

private int is_secure_dir(string dir) {
   if (dir[0..strlen(DIR_WWW+"/secure/")-1] == DIR_WWW+"/secure/") {
      return 1;
   }

   // Check to see if it is a creator or domain directory.
   if (dir[0..2] == "/w/" ||
       dir[0..1] == "w/" ||
       dir[0..2] == "/d/" ||
       dir[0..1] == "d/") {
      if (strsrch(dir, "/secure/") != -1) {
         return 1;
      }
   }

   return 0;
} /* is_secure_dir() */

private int is_secure_creator_dir(string dir) {
   if (dir[0..strlen(DIR_WWW+"/secure/creator/")-1] == 
       DIR_WWW+"/secure/creator/") {
      return 1;
   }

   // Check to see if it is a creator or domain directory.
   if (dir[0..2] == "/w/" ||
       dir[0..1] == "w/" ||
       dir[0..2] == "/d/" ||
       dir[0..1] == "d/") {
      if (strsrch(dir, "/secure/creator/") != -1) {
         return 1;
      }
   }

   return 0;
} /* is_secure_dir() */

protected int www_authenticate(class http_request req) {
   string auth_req = req->rh->headers_in->header_m["authorization"];
   int i;
   string decoded;
   string *bits;
   string mess;
   
   if (!is_secure_dir(req->dir)) {
      return HTTP_OK;
   }

   if (!auth_req) {
      auth_failure(req);
      return AUTH_REQUIRED;
   }

   i = strsrch(auth_req, ' ');
   if ((i == -1) || (auth_req[0..i-1] != "Basic")) {
      auth_failure(req);
      return AUTH_REQUIRED;
   }

   decoded = uudecode(auth_req[i+1..]);
   bits = explode(decoded, ":");
   if (sizeof(bits) < 2) {
      auth_failure(req);
      return AUTH_REQUIRED;
   }

   /* Fill in the user for logging and lockdown purposes */
   req->user = lower_case(bits[0]);

   if(LOGIN_HANDLER->site_lockeddown(req->sess->address)) {
     mess = bits[0] + " attempted login from locked down site, "
       "web, " + (req->sess->name ? req->sess->name + " (" +
                  req->sess->address : req->sess->address);
     event(users(), "inform", mess, "bad-password");
     log_file("BAD_PASSWORD", ctime(time()) + ": " + mess + "\n");
     return ACCESS_DENIED;
   }
   
   if (!PLAYER_HANDLER->test_password(lower_case(bits[0]), bits[1])) {
      auth_failure(req);
      return AUTH_REQUIRED;
   }

   if (is_secure_creator_dir(req->dir)) {
      if (!PLAYER_HANDLER->test_creator(bits[0])) {
         return ACCESS_DENIED;
      }
   }

   req->rh->headers_out->header_m["Cache-Control"] = "private";
   return HTTP_OK;
} /* www_authenticate() */

protected int www_resolve(class http_request req) {
   string *parts;
   string file;
   string dir;
   string args;
   int fsize;
   
   file = req->uri;
   if (file[0] != '/' && (file != "*")) {
      if (req->proxyreq) {
         /* Er. This was a proxy request. We aren't a proxy. */
         return ACCESS_DENIED;
      } else {
         return BAD_CMD;
      }
   }
   parts = explode(file, "/") - ({ ".", "..", "" });
   if (!sizeof(parts)) {
      req->uri += "index.html";
      req->filename = sprintf("%s/index.html", DIR_WWW);
      req->dir = DIR_WWW+ "/";
      return HTTP_OK;
   }
   
   // So that external references are moved to the external httpd..
#ifdef CONFIG_REWRITE_EXTERNAL_ADDRESS
   if (parts[0] == "external") {
      req->location = sprintf("http://discworld.imaginary.com%s",
                              req->uri);
      return MOVED_PERMANENTLY;
   }
#endif
   
   if (parts[0][0] == '~' && strlen(parts[0]) > 2) {
      if (parts[0][1] >= 'a' && parts[0][1] <= 'z') {
         parts[0] = sprintf("/w/%s/public_html", parts[0][1..]);
      } else {
         parts[0] = sprintf("/d/%s/public_html", lower_case(parts[0])[1..]);
      }
      file = implode(parts, "/");
      dir = implode(explode(file, "/")[0..<2], "/");
   } else {
      file = DIR_WWW+"/"+implode(parts, "/");
      dir = DIR_WWW+"/"+implode(parts[0..<2], "/");
   }
   sscanf(file, "%s___%s", file, args);
   fsize = file_size(file);
   
   if(fsize == -2) {
      if (req->uri[<1] == '/') {
         dir = file;
         file += "/index.html";
         fsize = file_size(file);
      } else {
         req->location = sprintf("http://%s%s/", req->hostname, req->uri);
         return MOVED_PERMANENTLY;
      }
   }
   if (args) {
      req->filename = file+"___"+args;
   } else {
      req->filename = file;
   }
   req->dir = (dir[<1] == '/' ? dir : dir + "/");
   if (fsize <= 0) {
      return NOT_FOUND;
   }
   return www_authenticate(req);
} /* www_resolve() */
   
/* This handles the @@ stuff in the files... */ 
private string parse_file_string(string str, class http_request req, mapping fields) {
   string *bits;
   string old_uri;
   string old_dir;
   string old_fname;
   int i;
   string fname;
   string args;

   bits = explode(str, "@@");
   str = "";
   old_uri = req->uri;
   old_fname = req->filename;
   old_dir = req->dir;
   for (i = 0; i < sizeof(bits); i += 2) {
      str += bits[i];
      if (i+1 < sizeof(bits)) {
        sscanf(bits[i+1], "%s:%s", fname, args);
        if (!fname) {
           fname = bits[i + 1];
           args = "";
        }
        if (fname[0] != '/') {
          fname =  old_dir + fname;
        } else {
          req->uri = fname;
          req->dir = old_dir;
          www_resolve(req);
          fname = req->filename;
        }
        bits[i+1] = "Oook!  Error!";
        TP("Calling "+ fname+ "->www_function( \""+ args+ "\" )\n");
        if (catch(bits[i+1] = 
                  call_other(fname, "www_function", args, fields, req))) {
          str += "Error!";
        } else {
          str += bits[i+1];
        }
      }
   }
   req->uri = old_uri;
   req->filename = old_fname;
   req->dir = old_dir;
   return str;
} /* parse_file_string() */

private void send_delayed_data(int fd, int id, mixed str) {
   class http_request req = (class http_request)Sockets[fd];
   string location;
   int mod_date;

   if(id != fds_waiting[fd]){
      return;
   } else {
      map_delete(fds_waiting, fd);
   }

   if (!req) {
      throw("Already finished the callback.");
      return ;
   }

   remove_call_out(req->id);

   mod_date = 0;
   if (mapp(str)) {
      location = str["location"];
      mod_date = str["mod_date"];
      req->status_line = str["status"];
      if (stringp(req->status_line)) {
         sscanf(req->status_line, "%d", req->status);
      }
      str = str["response"];
      if (req->status == AUTH_REQUIRED) {
         req->rh->headers_out->header_m["WWW-Authenticate"] =
            sprintf("Basic realm=\"%s\"", auth_name(req));
         req->rh->headers_out->header_k += ({ "WWW-Authenticate" });
      }
   }

   send_string(fd, str, mod_date, location, 1);
   eventWrite(fd, 0, 1);
}

private int get_file(class http_request req, mixed done) {
   string fname;
   string *bits;
   string bit;
   string id;
   string *parts;
   string location;
   int fsize;
   int errno;
   int mod_date;
   int i;
   int fd = req->sess->fd;
   mapping fields;
   mixed str;
   object cgibin;
       
   TP("Started get.\n");

   fields = ([ ]);
   if (req->args) {
      bits = explode(req->args, "&");
      foreach (bit in bits) {
         sscanf(bit, "%s=%s", id, str);
         
         if (!id) {
            continue;
         }
         if (!str) {
            str = "";
         }
         str = replace_string(str, "+", " ");
         if (((errno = unmime(ref id, NOT_PATH)) != HTTP_OK) ||
             ((errno = unmime(ref str, NOT_PATH)) != HTTP_OK)) {
            http_error(fd, errno);
            return 0;
         }
         fields[id] = str;
      }
      //req->args = 0;
   }
   sscanf(req->filename, "%s___%s", req->filename, req->args);
   
   if (!req->args) {
      req->args = "";
   }
   TP("File = "+req->filename+" Args = "+req->args+"\n");

  
   current_file = req->filename;
#ifdef TRACK_PAGE_STATS 
   http_stats[req->filename]++;
#endif  
    
   TP("Found file "+req->filename+"\n");
   parts = explode(req->filename, ".");

   switch (parts[<1]) {
   case "c":
      TP("Attempting a call.\n");
      if (!(cgibin = find_object(req->filename))) {
         if (catch(cgibin = load_object(req->filename))) {
            TP("error compiling it.\n");
            http_error(fd, INTERNAL_ERROR);
            return 0;
         }
      }
      if (!function_exists("query_content_type", cgibin)) {
         req->bi->content_type = "text/html";
      } else if (catch(req->bi->content_type =
                       (string)cgibin->query_content_type())) {
         TP("error getting content type.\n");
         http_error(fd, INTERNAL_ERROR);
         return 0;
      }
      /* If it is a post request we parse the body here */
      bit = req->body->buff;
      req->body->data = ([ ]);
      if (bit && strlen(bit) > 0) {
         bits = explode(bit, "&");
         foreach (bit in bits) {
            string name;
            string arg;
            
            if (sscanf(bit, "%s=%s", name, arg) == 2) {
               /* We will ignore errors here... */
               arg = replace_string(arg, "+", " ");
               unmime(ref arg, NOT_PATH);
               unmime(ref name, NOT_PATH);
               req->body->data[name] = arg;
            }
         }
      }

      if(!done) {
        req->id = call_out("close_connection", 45, fd, 1);
        fds_waiting[fd] = fd_id;
        catch(done = cgibin->www_delayed((:send_delayed_data, fd, fd_id:), req->args,
                                         fields, req));
        if(done) {
          req->request = "";
          req->delayed = 1;
          fds_waiting[fd]=fd_id++;
          return 1;
        } else
          map_delete(fds_waiting, fd);
      
        if (catch(str = (mixed)cgibin->www_request(req->args, fields, req))) {
          TP("error handling request.\n");
          http_error(fd, INTERNAL_ERROR);
          return 0;
        }
      } else str = done;

      mod_date = 0;
      if (pointerp(str) && intp(str[0])) {
         if (sizeof(str) < 2) {
            http_error(fd, INTERNAL_ERROR);
            return 0;
         }
         mod_date = str[0];
         str = str[1];
      }
      if (mapp(str)) {
         location = str["location"];
         mod_date = str["mod_date"];
         req->status_line = str["status"];
         if (stringp(req->status_line)) {
            sscanf(req->status_line, "%d", req->status);
         }
         str = str["response"];
         if (req->status == AUTH_REQUIRED) {
            req->rh->headers_out->header_m["WWW-Authenticate"] =
               sprintf("Basic realm=\"%s\"", auth_name(req));
            req->rh->headers_out->header_k += ({ "WWW-Authenticate" });
         }
      }
      if (str && (stringp(str) || bufferp(str))) {
         send_string(fd, str, mod_date, location, 1);
      } else {
         TP("invalid result from handler.\n");
         http_error(fd, INTERNAL_ERROR);
         return 0;
      }
      break;
   case "xml":
       req->bi->content_type = "text/xml";
   case "html":
   case "htm":
      /* This should be done only for .shtml files, the s in shtml means
         server parsed. But we'll leave it for now. */
      TP("Reading buffer.\n");
      fname = req->filename;
      
      TP("Found html file.\n");

      if (!req->bi->content_type) {
        req->bi->content_type = "text/html";
      }
      if ((fsize = file_size(req->filename)) > max_file_size) {
         str = ({ });
         for (i = 0; i < fsize; i += max_file_size) {
            str += ({ parse_file_string(read_bytes(req->filename, i,
                                                   max_file_size),
                                        req, fields) });
         }
         send_string_array(fd, str, stat(req->filename)[1], 0, 0);
         str = "";
      } else {
         str = parse_file_string(read_file(req->filename), req, fields);
         send_string(fd, str, stat(req->filename)[1], 0, 0);
      }
      break;
   default:
      send_file(fd, req->filename);
      return 0;
   }
   if (!str || (!stringp(str) && !bufferp(str))) {
      http_error(fd, NOT_FOUND);
   }
} /* get_file() */
 
private string log_time(int time) {
   mixed *stuff;
   int offset;
   int sign;
   string month;
  
   stuff = localtime(time);
   offset = stuff[LT_GMTOFF];
   if (offset < 0) {
      offset = -offset;
      sign = '+'; /* Looks strange, but it is correct! */
   } else {
      sign = '-';
   }

   month = ({"Jan", "Feb", "Mar", "Apr", "May",
             "Jun","Jul","Aug","Sep","Oct","Nov","Dec"})[stuff[LT_MON]];
   
   return sprintf("[%02d/%03s/%04d:%02d:%02d:%02d %c%02d%02d]",
                  stuff[LT_MDAY],
                  month,
                  stuff[LT_YEAR],
                  stuff[LT_HOUR],
                  stuff[LT_MIN],
                  stuff[LT_SEC],
                  sign,
                  (offset / 3600),
                  (offset % 60));
} /* log_time() */

private void log_request(class http_request req, int len) {
#ifdef LOGGING
   mixed *stuff;
   
   if(!log_str)
      log_str = "";
   
   stuff = localtime(time());

   // Flush the log if the day has changed since the last write.
   if(cday != stuff[LT_MDAY] && sizeof(log_str)) {
      write_file("/log/http/log-" + cday + "-" + (stuff[LT_MON]+1) +
                 "-" + stuff[LT_YEAR], log_str);
      log_str = "";
   }
   
   cday = stuff[LT_MDAY];
   
   log_str += (req->sess->name?req->sess->name:req->sess->address) + 
      " - " + (req->user?req->user:"-") + " " + log_time(time()) + " \"" +
      req->the_request + "\" " + req->status + " " +
      len + "\n";
   
   // Flush the log when it's 4k in size, used to reduce disk seeking.
   if(sizeof(log_str) > 4096) {
      /* Do a log of it... */
      write_file("/log/http/log-" + stuff[LT_MDAY] + "-" + (stuff[LT_MON]+1) +
                 "-" + stuff[LT_YEAR], log_str);
      log_str = "";
   }
#endif
} /* log_request() */

int dest_me() {
  mixed *stuff;
  unguarded((: save_object, SAVE_FILE :));
  stuff = localtime(time());
  write_file("/log/http/log-" + stuff[LT_MDAY] + "-" + (stuff[LT_MON]+1) +
             "-" + stuff[LT_YEAR], log_str);
  server::dest_me();
} /* dest_me() */

int ltime2sec(mixed *ltime) {
   int year;
   int days;
   int *dayoffset =
      ({306, 337, 0, 31, 61, 92, 122, 153, 184, 214, 245, 275});
   
   year = ltime[LT_YEAR];
   
   if (year < 70 || year >= 138) {
      return 0;
   }
   
   /* shift new year to 1st March in order to make leap year calc easy */
   
   if (ltime[LT_MON] < 2) {
      year--;
   }
   
   /* Find number of days since 1st March 1900 (in the Gregorian calendar). */
   
   days  = year * 365 + year/4 - year/100 + (year/100 + 3)/4;
   days += dayoffset[ltime[LT_MON]] + ltime[LT_MDAY] - 1;
   days -= 25508; /* 1 jan 1970 is 25508 days since 1 mar 1900 */
   
   days = ((days * 24 + ltime[LT_HOUR]) * 60 + ltime[LT_MIN]) * 60 +
      ltime[LT_SEC];
   if (days < 0) {
      return 0;       /* must have overflowed */
   } else {
      return days;           /* must be a valid time */
   }
} /* ltime2sec() */

/*
 * Parses an HTTP date in one of three standard forms:
 *
 *     Sun, 06 Nov 1994 08:49:37 GMT  ; RFC 822, updated by RFC 1123
 *     Sunday, 06-Nov-94 08:49:37 GMT ; RFC 850, obsoleted by RFC 1036
 *     Sun Nov  6 08:49:37 1994       ; ANSI C's asctime() format
 *
 * and returns the number of seconds since 1 Jan 1970 GMT, or
 * 0 if this would be out of range or if the date is invalid.
 */
int parse_date(string date) {
   string month;
   int day;
   int year;
   int hours;
   int minutes;
   int seconds;
   int mon;
   mixed *ltime = allocate(10);

   if (sscanf(date, "%*s, %d %s %d %d:%d:%d %*s", day, month, year, hours,
              minutes, seconds) == 8) {
      ltime[LT_YEAR] = year - 1900;
      if (ltime[LT_YEAR] < 0) {
         return 0;
      }
   } else if (sscanf(date, "%*s, %d-%s-%d %d:%d:%d %*s", day, month, year, 
                     hours, minutes, seconds) == 8) {
      ltime[LT_YEAR] = year;
      if (ltime[LT_YEAR] < 70)
         ltime[LT_YEAR] += 100;
   } else if (sscanf(date, "%*s %s %d %d:%d:%d %d", month, day, hours, minutes,
                   seconds, year) == 7) {
      ltime[LT_YEAR] = year - 1900;
      if (ltime[LT_YEAR] < 0)
         return 0;
   } else if (sscanf(date, "%*s %s  %d %d:%d:%d %d", 
                     month, day, hours, minutes,
                   seconds, year) == 7) {
      ltime[LT_YEAR] = year - 1900;
      if (ltime[LT_YEAR] < 0)
         return 0;
   } else {
      return 0;
   }
   ltime[LT_MDAY] = day;
   if ((ltime[LT_MDAY] <= 0) || (ltime[LT_MDAY] > 31)) {
      return 0;
   }
   ltime[LT_HOUR] = hours;
   ltime[LT_MIN] = minutes;
   ltime[LT_SEC] = seconds;
   if ((ltime[LT_HOUR] > 23) || (ltime[LT_MIN] > 59) || (ltime[LT_SEC] > 61)) {
      return 0;
   }
   mon = member_array(month[0..2], MONTHS);
   if (mon == -1) {
      return 0;
   }
   if ((ltime[LT_MDAY] == 31) && (mon == 3 || mon == 5 || mon == 8 ||
                                  mon == 10)) {
      return 0;
   }
   
   /* February gets special check for leapyear */
   
   if ((mon == 1) && ((ltime[LT_MDAY] > 29) ||
                      ((ltime[LT_MDAY] == 29) && ((ltime[LT_YEAR] & 3) ||
                                                  (((ltime[LT_YEAR] % 100) == 0) && (((ltime[LT_YEAR] % 400) != 100))))))) {
      return 0;
   }
   
   ltime[LT_MON] = mon;
   return ltime2sec(ltime);
} /* parse_date() */
     
string format_date(int x) {
   string str;
   string mon;
   mixed *tm;
   int offset;
       
   if (x<0 || !intp(x)) {
      return "Bad time";
   }
   
   tm = localtime(x);
   offset = tm[LT_GMTOFF];
   tm = localtime(x + offset);
   str = DAYS[tm[LT_WDAY]];
   mon = MONTHS[tm[LT_MON]];
   str = sprintf("%s, %02d %s %d %02d:%02d:%02d GMT", str, tm[LT_MDAY], mon,
                 tm[LT_YEAR], tm[LT_HOUR], tm[LT_MIN], tm[LT_SEC]);
   return str;
} /* format_date() */

protected int set_last_modified(class http_request req, int mtime) {
   string etag;
   string weak_etag;
   string if_modified_since = req->rh->headers_in->header_m["if-modified-since"];
   string if_unmodified     = req->rh->headers_in->header_m["if-unmodified-since"];
   string if_nonematch      = req->rh->headers_in->header_m["if-none-match"];
   string if_match          = req->rh->headers_in->header_m["if-match"];
   int now = time();
   mixed size;

   if (now < 0) {
      now = req->time;
   }
   req->rh->headers_out->header_m["Last-Modified"] =
      format_date((mtime > now) ? now : mtime);
   req->rh->headers_out->header_k += ({ "Last-Modified" });
   if (intp((size = stat(req->filename)[0]))) {
      weak_etag = sprintf("W/\"%x-%x\"", size, mtime);
   } else {
      weak_etag = sprintf("W/\"%x\"", mtime);
   }
   etag = weak_etag[((req->time - mtime > 1) ? 2 : 0)..];
   req->rh->headers_out->header_m["ETag"] = etag;
   req->rh->headers_out->header_k += ({ "ETag" });
   
   if (if_match) {
      if ((if_match[0] != '*') && !find_token(if_match, etag)) {
         return PRECONDITION_FAILED;
      }
   } else if (if_unmodified) {
      int utime = parse_date(if_unmodified);
      
      if (utime && mtime > utime) {
         return PRECONDITION_FAILED;
      }
   }
   if (if_nonematch) {
      if ((if_nonematch[0] == '*') || find_token(if_nonematch, etag)) {
         return (req->method == "GET") ? NOT_MODIFIED : PRECONDITION_FAILED;
      }
   }
   else if (if_modified_since && (req->method == "GET")) {
      int itime = parse_date(if_modified_since);
      
      if ((itime >= mtime) && (itime <= req->time)) {
         return NOT_MODIFIED;
      }
   }
   
   return HTTP_OK;
} /* set_last_modified() */

protected void internal_redirect(class http_request req, string new_uri) {
   class http_request nreq = new(class http_request);

   nreq->sess = req->sess;
   parse_uri(nreq, new_uri);
   nreq->prev = req;
   nreq->the_request = req->the_request;
   nreq->method = req->method;
   nreq->status = req->status;
   nreq->rh = new(class http_request_header);
   nreq->rh->noheaders = req->rh->noheaders;
   nreq->rh->header_only = req->rh->header_only;
   nreq->proto_num = req->proto_num;
   nreq->hostname = req->hostname;
   nreq->time = req->time;
   nreq->numredirect = req->numredirect + 1;
   nreq->rh->headers_in = req->rh->headers_in;
   nreq->rh->headers_out = new(class mime_header, header_m : ([ ]),
                               header_k : ({ }));
   nreq->rh->err_headers_out = new(class mime_header, header_m : ([ ]),
                                   header_k : ({ }));
   nreq->bi = new(class http_body_info);
   Sockets[nreq->sess->fd] = nreq;
   if (nreq->numredirect > 5) {
      /* recursion ... */
      http_error(nreq->sess->fd, INTERNAL_ERROR);
      return;
   }
   handle_request(nreq, 0);
} /* internal_redirect() */

protected void send_string(int fd, string str, int mod_date, string location,
                           int no_length) {
   class http_request req = (class http_request)Sockets[fd];
   int errstatus;
   int rangestatus;
   //   int crc;
   int length;
   string* types;
   string comp_type;
   mixed buf;

   TP("Using send_string\n");
   
   if (!req) {
      return;
   }
   if (strlen(location) && location[0] == '/' && req->status == 200) {
      req->location = location;
      req->method = "GET";
      map_delete(req->rh->headers_in->header_m, "content-length");
      req->rh->headers_in->header_k -= ({ "Content-Length" });
      internal_redirect(req, location);
      return;
   } else if (location && req->status == 200) {
      req->location = location;
      http_error(fd, MOVED_TEMP);
      return;
   }
   if (!req->rh->noheaders) {
      if (mod_date) {
         if ((errstatus = set_last_modified(req, mod_date)) != HTTP_OK) {
            http_error(fd, errstatus);
            return;
         }
      }

      rangestatus = set_byterange(req);

      buf = str;
      
      if(//"/obj/handlers/player_handler"->test_creator(req->user) &&
         //(req->user == "pinkfish" || req->user == "ceres") &&
         req->rh->headers_in->header_m[HTTP_ACCEPT_ENCODING]) {
        types = explode(replace_string(req->rh->headers_in->header_m[HTTP_ACCEPT_ENCODING], " ", ""), ",");
        if(member_array("*;q=0", types) != -1 ||
           strsrch(req->rh->headers_in->header_m["user-agent"],
                   "Galeon") != -1) {
          // This prevents screwiness with Opera and Galeon
          comp_type = 0;
        } else if (member_array("gzip", types) != -1) {
          comp_type = "gzip";
        } else if (member_array("deflate", types) != -1) {
          comp_type = "deflate";
        }

         if (comp_type) {
           /*
            crc = crc32(str);
            crc = ~ crc; 
            tell_creator("pinkfish", "~CRC: %d\n", crc);
           */
            length = sizeof(str);
            buf = allocate_buffer(16);
            buf[0] = 0x1f;
            buf[1] = 0x8b;
            buf[2] = 0x08;
            buf[3] = 0x00;
            buf[4] = 0x00;
            buf[5] = 0x00;
            buf[6] = 0x00;
            buf[7] = 0x00;

            /*
              buf[11] = crc >> 24 & 0xff;
              buf[10] = crc >> 16 & 0xff;
              buf[9] = crc >> 8 & 0xff;
              buf[8] = crc & 0xff;
            */
            buf[15] = length >> 24 & 0xff;
            buf[14] = length >> 16 & 0xff;
            buf[13] = length >> 8 & 0xff;
            buf[12] = length & 0xff; 

            //tell_creator("ceres", "%x %x %x %x [%d]\n", buf[8], buf[9],
                         //buf[10], buf[11], crc);
            //tell_creator("ceres", "%x %x %x %x [%d]\n", buf[12], buf[13],
                         //buf[14], buf[15], length);
            //buf = buf[0..7] + compress(str)[0..<5] + buf[8..]; // [0..<4] +
                                                               // buf[8..];
            buf = buf[0..7] + compress(str)[0..<3] + buf[12..];
            req->compression = comp_type;
            TP("Sending compressed as " + comp_type + "\n");
         } else
           TP("Sending uncompressed.\n");

      }

      if (!no_length) {
        req->bi->clength = sizeof(buf);
        
        req->rh->headers_out->header_m["Content-Length"] = ""+sizeof(buf);
        req->rh->headers_out->header_k += ({ "Content-Length" });
      }
      
      http_header(req);
   }
   
   /* Log it... */
   log_request(req, sizeof(buf));
   
   if (!req->rh->header_only) {
      if (req->bi->chunked) {
         eventWrite(fd, sprintf("%x\r\n", sizeof(buf)));
      }
      if (!rangestatus) {
         eventWrite(fd, buf);
      } else {
         int offset;
         
        while (each_byterange(req, ref offset, ref length)) {
            eventWrite(fd, buf[offset..offset + length]);
         }
      }     
      if (req->bi->chunked) {
         eventWrite(fd, "\r\n0\r\n\r\n");
      }
   }
} /* send_string() */
     
protected void send_string_array(int fd, string *str, int mod_date,
                           string location, int no_length) {
   class http_request req = (class http_request)Sockets[fd];
   int errstatus;
   int rangestatus;
   string frog;

   if (!req) {
      return; 
   }
   TP("Using send_string_array\n");
   
   if (strlen(location) && location[0] == '/' && req->status == 200) {
      req->location = location;
      req->method = "GET";
      map_delete(req->rh->headers_in->header_m, "content-length");
      req->rh->headers_in->header_k -= ({ "Content-Length" });
      internal_redirect(req, location);
      return;
   } else if (location && req->status == 200) {
      req->location = location;
      http_error(fd, MOVED_TEMP);
      return;
   }
   req->bi->clength = 0;
   foreach (frog in str) {
      req->bi->clength += strlen(frog);
   }
   if (!req->rh->noheaders) {
      if (mod_date) {
         if ((errstatus = set_last_modified(req, mod_date)) != HTTP_OK) {
            http_error(fd, errstatus);
            return;
         }
      }
      
      if (!no_length) {
         
         req->rh->headers_out->header_m["Content-Length"] = ""+req->bi->clength;
         req->rh->headers_out->header_k += ({ "Content-Length" });
      }
      rangestatus = set_byterange(req);
      http_header(req);
   }

   /* Log it... */
   log_request(req, req->bi->clength);
   
   if (!req->rh->header_only) {
      if (req->bi->chunked) {
         eventWrite(fd, sprintf("%x\r\n", req->bi->clength));
      }
      if (!rangestatus) {
         string rabbit;
         
         foreach (rabbit in str) {
            eventWrite(fd, rabbit);
         }
      } else {
         int offset;
         int length;
         int index;
         int off_min;
         
         while (each_byterange(req, ref offset, ref length)) {
            TP("Ummm " + offset + " + " + length + "\n");
            while (offset - off_min > strlen(str[index])) {
               off_min += strlen(str[index]);
               index++;
            }
            while (offset + length - off_min > strlen(str[index])) {
               TP("Sending " + index + " [" + offset + " (" + off_min + ")..]\n");
               eventWrite(fd, str[index][offset - off_min..]);
               off_min += strlen(str[index]);
               index++;
            }
            TP("Sending " + index + " [" + offset + " (" + off_min + ").." + length + "]\n");
            eventWrite(fd, str[index][offset - off_min..offset + length - off_min]);
         }
      }     
      if (req->bi->chunked) {
         eventWrite(fd, "\r\n0\r\n\r\n");
      }
   }
} /* send_string_array() */

protected void send_file(int fd, string str) {
   string *bits;
   class http_request req = (class http_request)Sockets[fd];
   int errstatus;
   int rangestatus;
   int fsize;

   if (!req) {
      return;
   }
   if (req->rh->noheaders) {
      /* Stupid mode, no header */
      eventWrite(fd, str, 1, 1);
      return;
   }
   if ((errstatus = set_last_modified(req, stat(str)[1])) != HTTP_OK) {
      http_error(fd, errstatus);
      return;
   }
   fsize = file_size(str);
   
   req->bi->clength = fsize;
   req->rh->headers_out->header_m["Content-Length"] = ""+fsize;
   req->rh->headers_out->header_k += ({ "Content-Length" });

   /* Log it... */
   log_request(req, req->bi->clength);
   
   bits = explode(req->uri, ".");
   switch (lower_case(bits[<1])) {
   case "html":
   case "htm":
      req->bi->content_type = "text/html";
      break;
   case "wrl":
   case "vrml":
      req->bi->content_type = "x-world/x-vrml";
      break;
   case "jpeg":
   case "jpg":
   case "jpe":
      req->bi->content_type = "image/jpeg";
      break;
   case "gif":
      req->bi->content_type = "image/gif";
      break;
   case "txt":
      req->bi->content_type = "text/plain";
      break;
   case "class":
      req->bi->content_type = "application/octet-stream";
      break;
   case "wav":
      req->bi->content_type = "audio/x-wav";
      break;
   default:
      req->bi->content_type = "text/plain";
      break;
   }
   rangestatus = set_byterange(req);
   http_header(req);
   if (!req->rh->header_only) {
      if (!rangestatus) {
         eventWrite(fd, str, 0, 1);
      } else {
         int offset;
         int length;
         
         while (each_byterange(req, ref offset, ref length)) {
            eventWrite(fd, str, 0, 1, offset, offset + length);
         }
      }
   }
}  /* send_file() */

string query_current_file() {
   return current_file;
} /* query_current_file() */

/* Number of times a file has been accessed */
int query_current_no_reads(string file) {
#ifdef TRACK_PAGE_STATS
   return http_stats[file];
#else
   return 0;
#endif    
} /* query_current_no_reads() */

#ifdef TRACK_PAGE_STATS
void tidy_files_read() {
   int i;
   string tmp;
   
   foreach(tmp in keys(http_stats)) {
      if(tmp[<5..] != ".html" && tmp[<4..] != ".htm" && tmp[<3..] != ".c") {
         map_delete(http_stats, tmp);
      } else if(tmp[0..3] != "/www") {
         map_delete(http_stats, tmp);
      } else if(tmp[0..11] == "/www/autodoc") {
         //      map_delete(http_stats, tmp);
         write("[" + tmp[0..12] + "] " + tmp + "\n");
      }
   }
} /* tidy_files_read() */
    
int query_files_read() {
   return sizeof(keys(http_stats));
} /* query_files_read() */
#endif
// --- END [/mnt/home2/grok/lib/net/daemon/http.c] ---
// --- BEGIN [/mnt/home2/grok/lib/net/daemon/out_finger.c] ---
// Size:   File: "/mnt/home2/grok/lib/net/daemon/out_finger.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628689   Available: 13576043
Inodes: Total: 5242880    Free: 4960135
778 bytes, Last Modified:   File: "/mnt/home2/grok/lib/net/daemon/out_finger.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628689   Available: 13576043
Inodes: Total: 5242880    Free: 4960135
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Id: out_finger.c,v 1.2 1999/07/15 19:34:10 turrican Exp $
 */
#include <network.h>

void do_finger(string str) {
  string name, host, realhost;

  if (sscanf(str, "%s@%s", name, host) == 2) {
    if ((realhost = INTERMUD_D->GetMudName(replace_string(host, ".", " ")))) {
      if (name == "")
        SERVICES_D->eventSendWhoRequest(realhost, this_player()->query_name());
      else
        SERVICES_D->eventSendFingerRequest(name, realhost);
      write("Intermud3 finger on its way.\n");
      return;
    }
    write(mud_name()+" does not know about the MUD "+host+".\n");
    return;
  }
/*
 * Should be a local finger...  no idea why they want to do that though.
 * shrug.
 */
} /* do_finger() */

void clean_up() {
  destruct(this_object());
}
// --- END [/mnt/home2/grok/lib/net/daemon/out_finger.c] ---
// --- BEGIN [/mnt/home2/grok/lib/net/daemon/dictionary.c] ---
// Size:   File: "/mnt/home2/grok/lib/net/daemon/dictionary.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628689   Available: 13576043
Inodes: Total: 5242880    Free: 4960135
12298 bytes, Last Modified:   File: "/mnt/home2/grok/lib/net/daemon/dictionary.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628689   Available: 13576043
Inodes: Total: 5242880    Free: 4960135
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * MUD based dictionary, conforms to the DICT new protocol found in RFC 2229. 
 * See ftp://ftp.isi.edu/in-notes/rfc2229.txt for more information.
 * @author Taffyd@Discworld
 * @changes 5-2-2001 Pinkfish
 * Converted to work as a handler.
 */

#include <network.h>

// #define DNS_LOOKUP

#define DICT_SERVER_NAME "dict.org"
#define DICT_SERVER_IP "66.111.36.30"

#define DISCONNECTED 0
#define WAITING_FOR_CONNECT 1
#define READY 2
#define RECEIVING 3
#define SENDING_DEFINE 4
#define SENDING_MATCH 5
#define WAITING_FOR_DNS 6

#define INACTIVE 0
#define DEFINE 1
#define MATCH 2

#define SEARCH_MODE_ALL "*"
#define DEFAULT_SEARCH_MODE "web1913"

#define DEBUGGER "pinkfish"
//#define DEBUGGER ""

/**
 * This class handles connection details for each person using
 * the dictionary. 
 * @member fd the file descriptor of the socket currently being
 * used by the dictionary.
 * member dns_key the resolve() key used when doing a nslookup.
 */

   // string *dictionaries;
   // string *capabilities;

class request {
   string word;
   string search_mode;
   int type;
   int i;
   function callback;
}

class connection_data {
   int fd;
   int dns_key;
      
   string message;
   mixed definitions;
   mixed *working;

   string ip_address;

   int status;
   int count;
   string search_mode;    
   class request current_request;
}

inherit CLIENT;

private class connection_data _connection;
private class request* _requests;

void remove_request(class request bing);
void close_connection();
void inform_of_problem(class request bing, string str);
void send_request(class request bing);
void make_connection();
void check_send();

void create() {
   client::create();
   SetSocketType(STREAM);
   _requests = ({ });
} /* create() */

void close_socket( int fd, object who ) {
   if ( _connection->fd ) {
      eventWrite(fd, "QUIT\r\n" );
      eventAbortCallback( fd );
      close_connection();
   }
} /* close_socket() */

void do_callback(function callb, string word, mixed result, mixed* data) {
   call_out((: evaluate($1, $2, $3, $4) :), 0, callb, word, result, data);
} /* do_callback() */

void eventRead(int fd, string message) {
   class connection_data dict;
   string *bits;
   string *lines;
   string line;
   string word;
   string extra;
   string dictionary_name;
   mixed *bing;
   mixed *fluff;
   int i;
   int j;
   int ignore;

   //tell_creator(DEBUGGER, "Got %O\n", message);
   /* Check to see if the message is valid. */          
   if ( !stringp( message ) ) {
      return;
   }
   
   /* Find the user for this connection */
   dict = _connection;
   lines = explode( message, "\r\n" );
   
   foreach ( line in lines ) {
      if ( !sizeof( line ) ) {
         line = "\n";
      }
      if ( line == "." ) {
         dict->definitions += ({ dict->working });
         dict->count = -1;
         continue;
      }
            
      bits = explode( line, " " );
      if ( !sizeof( bits ) ) {
         continue;
      }

      //tell_creator(DEBUGGER, sprintf("Event %s received in status %d\n[%s]\n",
                                      //bits[0], dict->status, line));

      switch ( bits[ 0 ] ) {
      case "150":
         dict->count++;
         dict->working = ({ });
         dict->status = RECEIVING;
         word = 0;
         extra = 0;
         dictionary_name = 0;
         break;
         
      case "151":                                           
         if ( dict->status == RECEIVING && 
                ( sscanf( line, "151 \"%s\" %s \"%s\"", word, extra, 
                               dictionary_name ) == 3 ) ) {
            dict->working += ({ ({ word, dictionary_name, extra }) });
         } else {
            //tell_creator( DEBUGGER, "Invalid 151 error code, %s, %s, %s.\n",
                                 //word, extra, dictionary_name );
         }
         break;
         
      case "152":
         dict->count++;
         dict->working = ({ });
         dict->status = RECEIVING;
         word = 0;
         extra = 0;
         dictionary_name = 0;
         break;

      case "220":
         if (dict->status == WAITING_FOR_CONNECT) {
            dict->status = READY;
            check_send();
         }
/*
         tell_object( who, "The dictionary's pages shuffle about. It is now "
            "ready for a query.\n" );
 */

         // dict->capabilities = explode( bits[ <2 ][1..<2], "." );
         break;
                  
      case "250":
//tell_creator(DEBUGGER, "Start...\n");
         switch(dict->current_request->type) {
         case DEFINE:
            bing = ({ });
            for ( i = 0; i < sizeof( dict->definitions ); i++ ) {
               foreach( fluff in dict->definitions[ i ] ) {
                  fluff[2] = replace( fluff[2], 
                                      ({ "    ", " ", "\t", " " }) );
                  ignore = 0;
                  for (j = 0; j < sizeof(bing); j++) {
                     if (bing[j][2] == fluff[2]) {
                        ignore = 1;
                     }
                  }
                  if (!ignore) {
                     bing += ({ fluff });
                  }
               }
            }
//tell_creator(DEBUGGER, "%O %O\n", bing, dict->definitions);
            if (dict->current_request->callback) {
               do_callback(dict->current_request->callback,
                        dict->current_request->word,
                        NETWORK_SUCCESS,
                        bing);
            }
            dict->status = READY;                        
            remove_request(dict->current_request);
                     
            break;
         case MATCH:
            if (dict->current_request->callback) {
               bing = ({ });
               for(i=0; i<sizeof(dict->definitions); i++) {
                  foreach(line in dict->definitions[i]) {
                     if(sscanf(line, "%s \"%s\"", extra, word) == 2) {
                        bing += ({ ({ extra, word }) });
                     }
                  }
               }
//tell_creator(DEBUGGER, "+++ %O\n", dict);
               do_callback(dict->current_request->callback,
                        dict->current_request->word,
                        NETWORK_SUCCESS,
                        bing);
            }
            dict->status = READY;                        
            remove_request(dict->current_request);
         }
//tell_creator(DEBUGGER, "--- Fallout!\n");
         return;
         break;
         
      case "530":
         inform_of_problem(dict->current_request, "Error from server.");
         dict->status = READY;                        
         remove_request(dict->current_request);
         //close_socket( fd, who );
         return;
         break;
         
      case "552":
         if (dict->current_request->callback) {
            do_callback(dict->current_request->callback,
                     dict->current_request->word,
                     NETWORK_SUCCESS,
                     ({ }));
         }
         dict->status = READY;                        
         remove_request(dict->current_request);
         return;
      break;
         
      default:
         if ( dict->status == RECEIVING ) {
            switch(dict->current_request->type) {
            case DEFINE:
               dict->working[<1][<1] += line;
               break;
            case MATCH:
               dict->working += ({ line });
            }
         } else
            //tell_creator(DEBUGGER, "Line not added, status " +
                               //dict->status + "\n");
         break;
      }
   }
} /* eventRead() */

void got_ip_address( string address, string ip_address, int key ) {
    tell_creator( "taffyd", "%s, %s\n", address, ip_address );

   //tell_creator(DEBUGGER, "Ig? %O %O %O %O\n", key, _connection, ip_address, address);
/*
   if ( _connection->dns_key != key ) {
       return ;
   }
 */
   
   if ( !address || !ip_address ) {
      ip_address = "127.0.0.1";
      //inform_of_problem(0, "Unable to lookup dns address.");
      //return;
   }

   //tell_creator(DEBUGGER, "Setup ip.\n");
   _connection->ip_address = ip_address;

   make_connection();
} /* got_ip_address() */

void make_connection() {
   int key;
   int new_fd;

   //tell_creator(DEBUGGER, "Making connection.\n");
   if (!_connection || !_connection->fd) {
       if (!_connection || !_connection->ip_address) {

          _connection = new(class connection_data, fd : 0, 
                   status : WAITING_FOR_DNS, count : -1, definitions : ({ }),
                   dns_key : key );
#ifdef DNS_LOOKUP
          _connection->dns_key = resolve( DICT_SERVER_NAME, "got_ip_address" );
#else
          got_ip_address( DICT_SERVER_NAME, DICT_SERVER_IP, 0 );
#endif
       } else {
          new_fd = eventCreateSocket( _connection->ip_address, 2628 );

          if ( new_fd < 0 ) {
             inform_of_problem(0, "unable to connect");
             return;
          }
       
          _connection->fd = new_fd;
          _connection->status = WAITING_FOR_CONNECT;
   
          call_out( "close_socket", 120, new_fd, this_player() );
       }
   }
} /* make_connection() */

void close_connection() {
   int fd;

   if (_connection && _connection->fd) {
      fd = _connection->fd;
      _connection->fd = 0;
      close_socket( fd, this_player() );
      inform_of_problem(0, "socket closed");
   }
} /* close_connection() */

void check_send() {
//tell_creator(DEBUGGER, "%O\n", _connection);
   if (!_connection || _connection->fd == 0) {
      make_connection();
   } else if (_connection->status == READY && sizeof(_requests)) {
      send_request(_requests[0]);
   }
} /* check_send() */

void send_request(class request bing) {
   //tell_creator(DEBUGGER, "Sending request %O\n", bing);
   switch (bing->type) {
   case DEFINE :
      eventWrite(_connection->fd,
                 sprintf("DEFINE %s %s\r\n", bing->search_mode, 
                                              bing->word));
      _connection->status = SENDING_DEFINE;
      break;
   case MATCH :
      eventWrite(_connection->fd, sprintf("MATCH %s . %s\r\n", bing->search_mode, 
                                              bing->word));
      _connection->status = SENDING_MATCH;
      break;
   }
   _connection->current_request = bing;
   _connection->definitions = ({ });
} /* send_request() */

void remove_request(class request bing) {
   int i;

   for (i = 0; i < sizeof(_requests); i++) {
      if (_requests[i] == bing) {
         _requests = _requests[0..i - 1] + _requests[i + 1..];
         break;
      }
   }
   _connection->definitions = ({ });

   check_send();
} /* remove_request() */

void add_request(class request bing) {
   //tell_creator(DEBUGGER, "Adding request %O\n", bing);
   _requests += ({ bing });

   check_send();
} /* add_request() */

int define_word(string word, int all, function call_back) {
   class request request;

   request = new(class request);
   request->word = word;
   if (all) {
      request->search_mode = SEARCH_MODE_ALL;
   } else {
      request->search_mode = DEFAULT_SEARCH_MODE;      
   }
   request->type = DEFINE;
   request->callback = call_back;

/*
   eventWrite(dict->fd, sprintf("DEFINE %s %s\r\n", dict->search_mode, 
                                              dict->word));
*/
   add_request(request);
} /* define_word() */

int spell_word(string word, int all, function call_back) {
   class request request;

   request = new(class request);
   request->word = word;
   if (all) {
      request->search_mode = SEARCH_MODE_ALL;
   } else {
      request->search_mode = DEFAULT_SEARCH_MODE;      
   }
   request->type = MATCH;
   request->callback = call_back;

/*
   eventWrite(dict->fd, sprintf("MATCH %s . %s\r\n", dict->search_mode, 
                                              dict->current_word));
 */
   add_request(request);
}

void inform_of_problem(class request bing, string mess) {
   if (bing) {
      do_callback(bing->callback, bing->word, mess, ({ }));
      remove_request(bing);
   } else {
      foreach (bing in _requests) {
         do_callback(bing->callback, bing->word, mess, ({ }));
      }
      _requests = ({ });
   }
} /* inform_of_problem() */

void dest_me() {
   close_connection();
   client::dest_me();
} /* dest_me() */
// --- END [/mnt/home2/grok/lib/net/daemon/dictionary.c] ---
// --- BEGIN [/mnt/home2/grok/lib/net/daemon/chars/in_finger_demon.c] ---
// Size:   File: "/mnt/home2/grok/lib/net/daemon/chars/in_finger_demon.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628686   Available: 13576040
Inodes: Total: 5242880    Free: 4960135
3872 bytes, Last Modified:   File: "/mnt/home2/grok/lib/net/daemon/chars/in_finger_demon.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628686   Available: 13576040
Inodes: Total: 5242880    Free: 4960135
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: in_finger_demon.c,v 1.1 1998/01/06 05:17:24 ceres Exp $
 * $Log: in_finger_demon.c,v $
 * Revision 1.1  1998/01/06 05:17:24  ceres
 * Initial revision
 * 
*/
#include <comms.h>

#define CHAR "/net/daemon/chars/"

inherit "/obj/monster";

object my_player,
       notebook;
string thingy;

void got_home(int bing);

void setup() {
  set_name("demon");
  set_short("small blue demon");
  set_long("A small blue demon with a large green note book.  He is a demon "+
           "with a purpose.  He scrutinises everyone who passes by looking "+
           "for that special person.  He is on a mission from a frog.\n");
  add_adjective(({ "small", "blue" }));
  set_race("imp");
  set_level(5);
  add_property("demon", 1);
  add_property("emote", 1);
  notebook = clone_object("/std/object");
  notebook->set_name("notebook");
  notebook->add_alias("book");
  notebook->add_plural("books");
  notebook->add_adjective(({ "large", "green", "note" }));
  notebook->set_long("A large note book, it looks almost brand new.\n");
  notebook->set_short("large green note book");
  notebook->move(this_object());
} /* setup() */

/* Who says you can kill my nice demon? */
void adjust_hp(int hp, object thing) {
  if (!objectp(thing))
    return 0;
  thing->stop_fight(this_object());
  do_command("stare "+ (string)thing->query_name());
  thing->add_effect("/std/effects/ingested/calm", 60);
  return 0;
} /* adjust_hp() */

void got_player(int bing) {
  if (!my_player) {
    /* Oh no!  Woe is me! */
    command("cry");
    command("'There goes my chance for a gold frog.");
    init_command("sigh");
    call_out("go_away", 5);
    return;
  }
  if (!bing) {
    /* Froodle buns */
    move(environment(my_player), "$N appear$s with a blue flash of light.",
         "$N implode$s in a puff of blue.");
  }
  call_out("do_command", 1, "follow "+my_player->query_name());
  call_out("do_command", 2, "'Ahhhh ha!  I have found you.");
  call_out("do_command", 3, "eye "+my_player->query_name());
  call_out("do_command", 4, "mutter");
  call_out("do_command", 5, "emote scribbles something in its notebook.");
  call_out("do_command", 6, "peer care at "+my_player->query_name());
  call_out("do_command", 7, "mutter purple aardvarks");
  call_out("do_command", 8, "smile bri");
  call_out("do_command", 9, "'Right, got all the info.");
  call_out("do_command", 10, "wave mad");
  call_out("do_command", 11, "unfollow "+my_player->query_name());
  call_out("go_home", 15);
} /* got_player() */

void setup_finger(string who) {
  move(COMM_ROOM, "$N appear$s with a blue flash of light.",
       "$N implode$s in a puff of blue.");
  tell_room(environment(),
            one_short()+" hurridly scribbles something down in its "
            "notebook.\n");
  my_player = find_player(who);
  if (!my_player || my_player->query_property("no finger daemon")) {
    command("cry");
    command("'There goes my chance for a gold frog.");
    call_out("go_away", 5);
    return;
  }
  /* 5 minutes... */
  my_player->add_property("no finger daemon", 1, 300);
  /* Ok, now we try and find our pooooor little player.  pat pat */
  add_effect("/std/effects/npc/goto_destination",
               ({ my_player, (: got_player :), 20 }));
} /* setup_finger() */

/* Now try and get back to the communication room */
void go_home() {
  add_effect("/std/effects/npc/goto_destination",
             ({ COMM_ROOM, (: got_home :), 20 }));
} /* go_home() */

void got_home(int bing) {
  if (!bing) {
    move(COMM_ROOM, "$N appear$s with a blue flash of light.",
         "$N implode$s in a puff of blue.");
  }
  command("'Home sweet home!");
  call_out("go_away", 3);
} /* got_home() */

void go_away() {
  command("wave");
  move("/room/rubbish", "$N appears.", "$N slowly becomes more transparent "
       "and then vanishes utterly.");
} /* go_away() */
// --- END [/mnt/home2/grok/lib/net/daemon/chars/in_finger_demon.c] ---
// --- BEGIN [/mnt/home2/grok/lib/net/daemon/chars/tell_demon.c] ---
// Size:   File: "/mnt/home2/grok/lib/net/daemon/chars/tell_demon.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628684   Available: 13576038
Inodes: Total: 5242880    Free: 4960135
3300 bytes, Last Modified:   File: "/mnt/home2/grok/lib/net/daemon/chars/tell_demon.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628684   Available: 13576038
Inodes: Total: 5242880    Free: 4960135
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: tell_demon.c,v 1.1 1998/01/06 05:17:24 ceres Exp $
 * $Log: tell_demon.c,v $
 * Revision 1.1  1998/01/06 05:17:24  ceres
 * Initial revision
 * 
*/
#include <comms.h>

#define CHAR "/net/daemon/chars/"

inherit "/obj/monster";

object my_player,
       notebook;
string thingy;

void setup() {
  set_name("purple demon");
  set_long("A small purple demon with a large note book.  He is looking "+
           "furtively around the room.  He seems in somewhat of a hurry.\n");
  add_alias("demon");
  set_short("purple demon");
  set_race( "imp" );
  set_level(-2);
  add_adjective(({ "purple", "short" }));
  notebook = clone_object("/std/object");
  notebook->set_name("notebook");
  notebook->add_alias("book");
  notebook->add_plural("books");
  notebook->add_adjective(({ "large", "note" }));
  notebook->set_long("A large note book, it looks almost brand new.\n");
  notebook->set_short("large note book");
  notebook->move(this_object());
  add_property("demon", 1);
} /* setup() */

/* Who says you can kill my nice demon? */
void adjust_hp(int hp, object at) {
} /* adjust_hp() */

void got_player(int bing) {
  if (!my_player) {
/* Oh no!  Woe is me! */
    command("cry");
    command("'There goes my chance for a gold frog.");
    init_command("sigh");
    call_out("go_away", 2);
    return ;
  }
  if (!bing) {
/* Froodle buns */
    move_player("X", environment(my_player));
  }
  init_command("give note book to "+my_player->query_name());
  init_command("smile "+my_player->query_name());
  call_out("go_away", 20);
} /* got_player() */

void setup_tell(string person, string mud, string who, string mess) {
  move_player("X", COMM_ROOM);
  tell_room(environment(),
            short(0)+" scribbles something hurridly down in its notebook.\n");
  my_player = find_player(lower_case(who));
/* Ok, now we try and find our pooooor little player.  pat pat */
  if (!my_player->query_creator()) {
    add_property("goto player", my_player->query_name());
    add_triggered_action("player", "goto_player", this_object(),
                         "got_player");
  } else
    got_player(0);
  notebook->set_read_mess(person+"@"+mud+" sent you this message:\n"+mess);
  notebook->add_read_mess(({ CHAR+"tell_demon", "warning" }), 0,
                            "wizard spells", 0);
} /* setup_tell() */

string garble_text(mixed bing, object ob) {
  call_out("do_dest", 10, ob);
  return "Warning, this note will self destruct in ten seconds.\n";
} /* warning() */

string magic_text(mixed bing, object ob) {
  call_out("do_dest", 10, ob);
  return "Warning, this note will self destruct in ten seconds.\n";
} /* warning() */

void do_dest(object ob) {
  object ob2;

  if (!ob) return ;
  ob2 = environment(ob);
  if (living(ob2)) {
    tell_room(environment(ob2), ob2->query_cap_name()+"'s "+
              ob->short()+" spontaneously combusts.\n", ({ ob2 }));
    tell_object(ob2, "Your "+ob->short()+" spontaneously combusts.\n");
  } else {
    tell_room(ob2, ob->short()+" spontaneously combusts.\n");
  }
  ob->dest_me();
} /* do_dest() */

void go_away() {
  command("wave");
  tell_room(environment(), short(0)+" becomes slowly more transperent "+
                           "and then vanishes utterly.\n");
  dest_me();
} /* go_away() */
// --- END [/mnt/home2/grok/lib/net/daemon/chars/tell_demon.c] ---
// --- BEGIN [/mnt/home2/grok/lib/net/daemon/board_thingy.c] ---
// Size:   File: "/mnt/home2/grok/lib/net/daemon/board_thingy.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628683   Available: 13576037
Inodes: Total: 5242880    Free: 4960135
4267 bytes, Last Modified:   File: "/mnt/home2/grok/lib/net/daemon/board_thingy.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628683   Available: 13576037
Inodes: Total: 5242880    Free: 4960135
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: board_thingy.c,v 1.2 2003/03/21 02:29:17 ceres Exp $
 * $Log: board_thingy.c,v $
 * Revision 1.2  2003/03/21 02:29:17  ceres
 * Modified to use player handler
 *
 * Revision 1.1  1998/01/06 05:17:08  ceres
 * Initial revision
 * 
*/
#include <network.h>
#include <localtime.h>
#include <board.h>
#include <player_handler.h>

inherit SERVER;

string *board_names;
string *creator_board_names;
mapping sockets;

void create() {
  sockets = ([ ]);
  server::create();
  SetSocketType(STREAM);
  SetDestructOnClose(1);
  call_out("setup", 2);
  board_names = ({ "frog", "never wending story", "role_playing",
                   "fightersguild", "witchesguild", "thievesguild",
                   "assassinsguild", "alt.fan.pratchett",
                   "wizardsguild", "flame", "newspaper",
                   "priestsguild" });
  creator_board_names = ({ "commonroom", "mudlib", "development",
                           "liaison", "am", "sur", "ram",
                           "klatch", "applications", "learning" });
} /* create() */

protected void setup() {
  if (eventCreateSocket(5700) < 0)
    if (this_object()) destruct(this_object());
} /* setup() */

void eventRead(int fd, string str) {
   string *bits;
   string *frogs;
   mixed *stuff;
   int i;
   int j;
   int creator;

tell_object(find_player("pinkfish"), "Got: "+str);
   /* Ok, we need to mugwump this apart and figure out what it is */
   frogs = explode(replace_string(str, "\r", ""), "\n");
   creator = PLAYER_HANDLER->test_creator(sockets[fd]);
   for (j = 0; j < sizeof(frogs); j++) {
      bits = explode(frogs[j], " ");
      switch (bits[0]) {
         case "boardnames" :
            if (creator) {
               for (i = 0; i < sizeof(board_names); i++) {
                  eventWrite(fd, "board "+board_names[i]+"\n");
               }
               for (i = 0; i < sizeof(board_names); i++) {
                  eventWrite(fd, "board "+creator_board_names[i]+"\n");
               }
            } else {
               for (i = 0; i < sizeof(board_names); i++) {
                  eventWrite(fd, "board "+board_names[i]+"\n");
               }
            }
            break;
         case "board" :
            if (member_array(bits[1], board_names) != -1 ||
                (creator && member_array(bits[1], board_names) != -1)) {
               stuff = BOARD_HAND->get_subjects(bits[1]);
               for (i = 0; i < sizeof(stuff); i++) {
                  eventWrite(fd, "subject "+stuff[i][B_NUM]+" "+bits[1]+" "+
                                 stuff[i][B_NAME]+" "+stuff[i][B_SUBJECT]+" "+
                                 ctime(stuff[i][B_TIME])[4..9]+"\n");
               }
            }
            break;
         case "message" :
            if (member_array(bits[2], board_names) != -1 &&
                (creator && member_array(bits[1], board_names) != -1)) {
               stuff = BOARD_HAND->get_subjects(bits[2]);
               for (i = 0; i < sizeof(stuff); i++) {
                  if (bits[1] == stuff[i][B_NUM]+"") {
                     eventWrite(fd, "message "+bits[1]+" "+bits[2]+"\n");
                     eventWrite(fd, "Note #"+(i+1)+" by "+stuff[i][B_NAME]+
                                    " posted at "+ctime(stuff[i][B_TIME])+"\n"
                                    "Title: \""+stuff[i][B_SUBJECT]+"\"\n"+
                                    BOARD_HAND->get_message(bits[2], i)+
                                    "\n.\n");
                  }
               }
            }
            break;
         case "quit" :
            eventWrite(fd, 0, 1);
            break;
         case "login" :
            if (PLAYER_HANDLER->test_user(bits[1])) {
               sockets[fd] = bits[1];
               eventWrite(fd, "login Ok\n");
            } else {
               eventWrite(fd, "login Failed\n");
            }
            break;
         case "logout" :
            eventWrite(fd, "logout Ok\n");
            sockets[fd] = "No one";
            break;
      }
   }
} /* eventRead() */

protected void eventNewConnection(int fd) {
   sockets[fd] = "No one";
} /* eventNewConnection() */

protected void eventSocketClosed(int fd) {
   map_delete(sockets, fd);
} /* eventSocketClosed() */
// --- END [/mnt/home2/grok/lib/net/daemon/board_thingy.c] ---
// --- BEGIN [/mnt/home2/grok/lib/net/inherit/client.c] ---
// Size:   File: "/mnt/home2/grok/lib/net/inherit/client.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628682   Available: 13576036
Inodes: Total: 5242880    Free: 4960135
3998 bytes, Last Modified:   File: "/mnt/home2/grok/lib/net/inherit/client.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628682   Available: 13576036
Inodes: Total: 5242880    Free: 4960135
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker: pinkfish $
 * $Id: client.c,v 1.3 2002/06/25 18:23:13 ceres Exp pinkfish $
 * $Log: client.c,v $
 * Revision 1.3  2002/06/25 18:23:13  ceres
 * Fixed compiler warning
 *
 * Revision 1.2  2000/06/21 20:35:36  pinkfish
 * Fix up some bits.
 *
 * Revision 1.1  1998/01/06 05:19:01  ceres
 * Initial revision
 * 
*/
/*    /secure/lib/client.c
 *    from the Nightmare IVr1 Object Library
 *    a TCP client object
 *    created by Descartes of Borg 950428
 *    modified for the Discworld mudlib by Turrican 25-10-95
 */

#include <network.h>
#include "client.h"

private nosave int DestructOnClose, SocketType = -1;
private nosave string LogFile;
private nosave function Read;
private nosave mapping Sockets;

void create() {
  seteuid(getuid());
  Sockets = ([]);
}

int eventCreateSocket(string host, int port) {
  int x;
  class client Socket;

  Socket = new(class client);
  Socket->Blocking = 1;
  if( SocketType == -1 ) SocketType = STREAM;
  x = socket_create(SocketType, "eventReadCallback", "eventAbortCallback");
  if( x < 0 ) {
    eventSocketError("Error in socket_create().", x);
    return x;
  }
  Socket->Descriptor = x;
  x = socket_bind(Socket->Descriptor, 0);
  if( x != EESUCCESS ) {
    eventClose(Socket);
    eventSocketError("Error in socket_bind().", x);
    return x;
  }
  x = socket_connect(Socket->Descriptor, host + " " + port, 
                     "eventReadCallback", "eventWriteCallback");
  if( x != EESUCCESS ) {
    eventClose(Socket);
    eventSocketError("Error in socket_connect().", x);
    return x;
  }
  Sockets[Socket->Descriptor] = Socket;
  return Socket->Descriptor;
}

protected void eventAbortCallback(int fd) {
  if (!Sockets[fd]) return;
  ((class client)Sockets[fd])->Closed = 1;
  eventClose((class client)Sockets[fd]);
}

protected void eventReadCallback(int fd, mixed val) {
  if( functionp(Read) ) evaluate(Read, fd, val);
  else eventRead(fd, val);
}

protected void eventRead(int fd, mixed val) { }

protected void eventWriteCallback(int fd) {
  int x;
  class client Socket;
  int times;

  if( !Sockets[fd] ) return;
  Socket = (class client)Sockets[fd];
  Socket->Blocking = 0;
  x = EESUCCESS;
  times = 10;
  while( Socket->Buffer && x == EESUCCESS && times > 0) {
    times--;
    switch( x = socket_write(fd, Socket->Buffer[0]) ) {
    case EESUCCESS:
      break;
    case EECALLBACK:
      Socket->Blocking = 1;
      break;
    case EEWOULDBLOCK:
      call_out( (: eventWriteCallback($(fd)) :), 0);
      return;
    case EEALREADY:
      Socket->Blocking = 1;
      return;
    default:
      eventClose(Socket);
      eventSocketError("Error in socket_write().", x);
      return;
    }
    if( sizeof(Socket->Buffer) == 1 ) Socket->Buffer = 0;
    else Socket->Buffer = Socket->Buffer[1..];
  }
}

void eventWrite(int fd, mixed val) {
  class client Socket;

  if( !Sockets[fd] ) return;
  Socket = (class client)Sockets[fd];
  if( Socket->Buffer ) Socket->Buffer += ({ val });
  else Socket->Buffer = ({ val });
  if( Socket->Blocking ) return;
  else eventWriteCallback(fd);
}

protected void eventClose(class client sock) {
  if (!sock) return;
  if (!sock->Closed && (socket_close(sock->Descriptor) != EESUCCESS))
    return;
  if (!undefinedp(Sockets[sock->Descriptor]))
    map_delete(Sockets, sock->Descriptor);
  eventSocketClose(sock->Descriptor);
  sock = 0;
  if( DestructOnClose && !sizeof(keys(Sockets))) destruct(this_object());
}

protected void eventSocketClose(int fd) { }

int dest_me() {
  class client Socket;

  foreach (Socket in (class client *)values(Sockets))
    eventClose(Socket);
  if (this_object()) destruct(this_object());
  return 1;
}

protected void eventSocketError(string str, int x) { 
  if( LogFile ) 
    log_file(LogFile, ctime(time()) + "\n" + socket_error(x) + "\n");
}

function SetRead(function f) { return (Read = f); }

int SetSocketType(int type) { return (SocketType = type); }

int SetDestructOnClose(int x) { return (DestructOnClose = x); }
// --- END [/mnt/home2/grok/lib/net/inherit/client.c] ---
// --- BEGIN [/mnt/home2/grok/lib/net/inherit/server.c] ---
// Size:   File: "/mnt/home2/grok/lib/net/inherit/server.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628681   Available: 13576035
Inodes: Total: 5242880    Free: 4960135
5505 bytes, Last Modified:   File: "/mnt/home2/grok/lib/net/inherit/server.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628681   Available: 13576035
Inodes: Total: 5242880    Free: 4960135
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: server.c,v 1.1 1998/01/06 05:19:01 ceres Exp $
 * $Log: server.c,v $
 * Revision 1.1  1998/01/06 05:19:01  ceres
 * Initial revision
 * 
*/
/*    /lib/server.c
 *    from the Nightmare IV LPC Library
 *    a TCP server object
 *    created by Descartes of Borg 950429
 *    Hacked for Discworld by Turrican, 21-3-96.
 *    Modified by Turrican to allow files to be sent over, 23-4-96.
 *    Modified by Turrican to allow files to be partly sent over, 2-7-97.
 */


#include <network.h>
#include <server.h>

private nosave int DestructOnClose, SocketType = -1;
private nosave function Read;
private nosave class server Listen;
private nosave mapping Sockets;

protected void create() {
  seteuid(getuid());
  Sockets = ([]);
} /* create() */

int eventCreateSocket(int port) {
  int x;

  if (SocketType == -1)
    SocketType = STREAM;
  x = socket_create(SocketType, "eventServerReadCallback", 
                    "eventServerAbortCallback");
  if( x < 0 ) {
    eventSocketError("Error in socket_create().", x);
    return x;
  }
  Listen = new(class server);
  Listen->Blocking = 0; /* servers are not blocking to start */
  Listen->Descriptor = x;
  x = socket_bind(Listen->Descriptor, port);
  if (x != EESUCCESS) {
    eventClose(Listen);
    eventSocketError("Error in socket_bind().", x);
    return x;
  }
  x = socket_listen(Listen->Descriptor, "eventServerListenCallback");
  if (x != EESUCCESS) {
    eventClose(Listen);
    eventSocketError("Error in socket_listen().", x);
    return x;
  }
  return x;
} /* eventCreateSocket */

protected void eventServerListenCallback(int fd) {
  int x;

  x = socket_accept(fd, "eventServerReadCallback", 
                    "eventServerWriteCallback");
  if (x < 0) {
    eventSocketError("Error in socket_accept().", x);
    return;
  }
  eventNewConnection(x);
} /* eventServerListenCallback() */

void eventServerAbortCallback(int fd) {
  if (Listen && Listen->Descriptor == fd)
    eventClose(Listen);
  else if (Sockets[fd])
    eventClose(Sockets[fd]);
} /* eventServerAbortCallback() */

protected void eventServerReadCallback(int fd, mixed val) {
  if (functionp(Read))
    evaluate(Read, fd, val);
  else
    eventRead(fd, val);
} /* eventServerReadCallback() */

protected void eventRead(int fd, mixed val) {
} /* eventRead() */

protected void eventServerWriteCallback(int fd) {
  class server sock;
  class buff t;
  int x;

  if (Listen && Listen->Descriptor == fd)
    sock = Listen;
  else if (Sockets[fd])
    sock = (class server)Sockets[fd];
  else
    return;
  sock->Blocking = 0;
  if (!sock->Buffer && sock->Closing) {
    eventClose(sock);
    return;
  }
  x = EESUCCESS;
  while (sock->Buffer && x == EESUCCESS) {
    t = sock->Buffer[0];
    if (t->Type == FILE) {
      if (t->Size < (t->Pos+BLOCK_SIZE))
        t->Value = read_buffer(t->Filename, t->Pos, t->Size - t->Pos);
      else
        t->Value = read_buffer(t->Filename, t->Pos, BLOCK_SIZE);
      t->Pos += BLOCK_SIZE;
    }
    switch (x = socket_write(sock->Descriptor, t->Value)) {
    case EESUCCESS:
      break;
    case EECALLBACK:
      sock->Blocking = 1;
      break;
    case EEWOULDBLOCK:
      if (t->Pos)
        t->Pos -= BLOCK_SIZE;
      call_out( (: eventServerWriteCallback :), 1, fd);
      return;
    case EEALREADY:
      sock->Blocking = 1;
      return;
    default:
      eventClose(sock);
      eventSocketError("Error in socket_write().", x);
      return;
    }
    if (t->Type == STRING || t->Pos > t->Size) {
      if (sizeof(sock->Buffer) == 1) {
        sock->Buffer = 0;
        if (sock->Closing && !sock->Blocking)
          eventClose(sock);
      } else
        sock->Buffer = sock->Buffer[1..];
    }
  }
} /* eventServerWriteCallback() */

varargs void eventWrite(int fd, mixed val, int close, int type, int pos,
                        int size) {
  class server sock;
  class buff t;

  if (Listen && Listen->Descriptor == fd)
    sock = Listen;
  else if (Sockets[fd])
    sock = (class server)Sockets[fd];
  else
    return;
  if (val) {
    t = new(class buff);
    t->Type = type;
    if (type == FILE) {
      t->Filename = val;
      if (size)
        t->Size = size;
      else
        t->Size = file_size(val);
      t->Pos = pos;
    } else
      t->Value = val;
    if (sock->Buffer)
      sock->Buffer += ({ t });
    else
      sock->Buffer = ({ t });
  }
  sock->Closing = close;
  if (sock->Blocking)
    return;
  else
    eventServerWriteCallback(sock->Descriptor);
} /* eventWrite() */

protected void eventClose(class server sock) {
  if (!sock)
    return;
  if (Sockets[sock->Descriptor])
    map_delete(Sockets, sock->Descriptor);
  socket_close(sock->Descriptor);
  eventSocketClosed(sock->Descriptor);
  sock = 0;
  if (DestructOnClose && sock == Listen)
    destruct(this_object());
} /* eventClose() */

protected void eventSocketClosed(int fd) {
} /* eventSocketClosed() */

int dest_me() {
  eventClose(Listen);
  if (this_object())
    destruct(this_object());
  return 1;
} /* dest_me() */

protected void eventNewConnection(int fd) {
  Sockets[fd] = new(class server, Descriptor : fd);
} /* eventNewConnection() */

protected void eventSocketError(string str, int x) {
} /* eventSocketError() */

function SetRead(function f) {
  return (Read = f);
} /* SetRead() */

int SetSocketType(int type) {
  return (SocketType = type);
} /* SetSocketType() */

int SetDestructOnClose(int x) {
  return (DestructOnClose = x);
} /* SetDestructOnClose() */
// --- END [/mnt/home2/grok/lib/net/inherit/server.c] ---
// --- BEGIN [/mnt/home2/grok/lib/net/obj/dict.c] ---
// Size:   File: "/mnt/home2/grok/lib/net/obj/dict.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628678   Available: 13576032
Inodes: Total: 5242880    Free: 4960135
11262 bytes, Last Modified:   File: "/mnt/home2/grok/lib/net/obj/dict.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628678   Available: 13576032
Inodes: Total: 5242880    Free: 4960135
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * MUD based dictionary, conforms to the DICT new protocol found in RFC 2229. 
 * See ftp://ftp.isi.edu/in-notes/rfc2229.txt for more information.
 * @author Taffyd@Discworld
 */

#include <network.h>

#define DISCONNECTED 0
#define WAITING_FOR_CONNECT 1
#define READY 2
#define RECEIVING 3
#define SENDING_DEFINE 4
#define SENDING_MATCH 5
#define WAITING_FOR_DNS 6

#define INACTIVE 0
#define DEFINE 1
#define MATCH 2

#define SEARCH_MODE_ALL "*"
#define DEFAULT_SEARCH_MODE "web1913"

// #define DEBUGGER "taffyd"
#define DEBUGGER ""

/**
 * This class handles connection details for each person using
 * the dictionary. 
 * @member fd the file descriptor of the socket currently being
 * used by the dictionary.
 * member dns_key the resolve() key used when doing a nslookup.
 */

  // string *dictionaries;
  // string *capabilities;

class connection_data {
  int fd;
  int dns_key;
    
  string current_word;
  string message;
  mixed definitions;
  mixed *working;
    
  int status;
  int action;
  int count;
  string search_mode;   
}

inherit CLIENT;
inherit "/std/object";

mapping _connections = ([ ]);

void create() {
  client::create();
  SetSocketType(STREAM);
  object::create();

} /* create() */

string calculate_short() {
  if ( !mapp( _connections ) )
    return "dictionary";
    
  if ( _connections[ this_player() ] ) {
    return "open dictionary";
  }
    
  return "closed dictionary";
} /* calculate_short() */

void setup() {
  set_name("dictionary");
  set_short( (: calculate_short() :) );
  set_long("This is a fine dictionary with faded gold embossing.  You could "
           "probably do all manner of things with it such as defining "
           "and spelling words.\n");

  set_weight( 0 );
  _connections = ([ ]);
} /* setup() */

void close_socket( int fd, object who ) {
  if ( _connections[ who ] ) {
    eventWrite(fd, "QUIT\r\n" );
    eventAbortCallback( fd );
    eventSocketClose( fd );
    map_delete( _connections, who );

    if (( environment() == who ) || 
        ( environment( who ) == environment( this_object() ) ) ) {    
      if(query_verb() == "close") {
        tell_object( who, "You close the dictionary.\n" );
      } else {
        tell_object(who, "The dictionary closes.\n");
      }
    }
  }
} /* close_socket() */

void eventRead(int fd, string message) {
  class connection_data dict;
  mapping destination;
  object who;
  string *bits, *lines, line, word, extra, dictionary_name, text;
  mixed *bing;
  int i;

  /* Check to see if the message is valid. */       
  if ( !stringp( message ) )
    return;
  
  /* Find the user for this connection */
  destination = filter( _connections, (: $(fd) == $2->fd :) );
  
  if ( !sizeof( destination ) )
    return;        
  
  who = keys( destination )[ 0 ];
  dict = destination[ who ];
  lines = explode( message, "\r\n" );
  
  foreach ( line in lines ) {
    if ( !sizeof( line ) )
      line = "\n";
    if ( line == "." ) {
      dict->definitions += ({ dict->working });
      dict->count = -1;
      continue;
    }
        
    bits = explode( line, " " );
    if ( !sizeof( bits ) )
      continue;

    tell_creator(DEBUGGER, sprintf("Event %s received in status %d\n[%s]\n",
                                   bits[0], dict->status, line));

    switch ( bits[ 0 ] ) {
    case "150":
      dict->count++;
      dict->working = ({ });
      dict->status = RECEIVING;
      word = 0;
      extra = 0;
      dictionary_name = 0;
      break;
      
    case "151":                             
      if ( dict->status == RECEIVING && 
           ( sscanf( line, "151 \"%s\" %s \"%s\"", word, extra, 
                     dictionary_name ) == 3 ) )
        dict->working += ({ ({ word, dictionary_name, "" }) });
      else
        tell_creator( DEBUGGER, "Invalid 151 error code, %s, %s, %s.\n",
                      word, extra, dictionary_name );
      break;
      
    case "152":
      dict->count++;
      dict->working = ({ });
      dict->status = RECEIVING;
      word = 0;
      extra = 0;
      dictionary_name = 0;
      break;

    case "220":
      dict->status = READY;                
      tell_object( who, "The dictionary's pages shuffle about. It is now "
        "ready for a query.\n" );

      // dict->capabilities = explode( bits[ <2 ][1..<2], "." );
      break;
            
    case "250":
      text = "";
      switch(dict->action) {
      case DEFINE:
        for ( i = 0; i < sizeof( dict->definitions ); i++ ) {
          foreach( bing in dict->definitions[ i ] ) {
            bing[ 2 ] = replace( bing[ 2 ], 
                                 ({ "   ", " ", "\t", " " }) );
            text += who->fix_string( bing[ 2 ], 
                                     who->query_cols() - 5, 0 );
          }
          text += "\n";
        }
        tell_object( who, sprintf( "$P$Definition of %s$P$\n"
                                   "%s\n", dict->current_word, text ) );

      dict->status = READY;                
      tell_object( who, "The dictionary's pages shuffle about. It is now "
        "ready for a query.\n" );

        break;
      case MATCH:
        text = "";
        for(i=0; i<sizeof(dict->definitions); i++) {
          foreach(line in dict->definitions[i]) {
            if(sscanf(line, "%s \"%s\"", extra, word) == 2)
              text += word + "\n";
          }
        }
        tell_object(who, sprintf("$P$Spellings for %s$P$"
                                 "\n%-#*s", dict->current_word,
                                 who->query_cols(), text) + "\n");
      }
      dict->definitions = ({ });
      return;
      break;
      
    case "530":
      tell_object( who, sprintf( "The dictionary reports: %s\n"
                                 "Please contact a creator.\n", line ) );
      close_socket( fd, who );
      return;
      break;
      
    case "552":
      tell_object( who, "No definitions for " + 
                   dict->current_word + ".\n" );
      dict->status = READY;
      tell_object( who, "The dictionary's pages shuffle about. It is now "
        "ready for a query.\n" );
      return;
    break;
      
    default:
      if ( dict->status == RECEIVING ) {
        switch(dict->action) {
        case DEFINE:
          dict->working[<1][<1] += line;
          break;
        case MATCH:
          dict->working += ({ line });
        }
      } else
        tell_creator(DEBUGGER, "Line not added, status " +
                     dict->status + "\n");
      break;
    }
  }
} /* eventRead() */

void got_ip_address( string address, string ip_address, int key ) {
  object player;
  class connection_data dict;
  int found_key;
  int new_fd;

  found_key = 0;

  foreach( player, dict in _connections ) {
    if ( !player ) {
      continue;
    }

    if ( dict->dns_key == key ) {
      found_key = 1;
      break;
    }
  }
  
  if ( !found_key ) {
    map_delete( _connections, player );
    return;
  }
    
  if ( !address || !ip_address ) {
    tell_object( player, the_short() + " quivers and starts to jump "
      "around.  You get the feeling that the dictionary cannot perform "
      "a DNS lookup just right now.\n");
    map_delete( _connections, player );
    return;
  }

  tell_creator( "taffyd", "Dictionary connection details: %s, %s.\n", address, ip_address );
  new_fd = eventCreateSocket( ip_address, 2628 );

  if ( new_fd < 0 ) {
    tell_object( player, the_short() + " quivers and starts to jump "
      "around.  You get the feeling that the dictionary cannot connect "
      "to a dictionary server right now.\n");
    map_delete( _connections, player );
    return;
  }

  dict->fd = new_fd;
  dict->status = WAITING_FOR_CONNECT;

  _connections[ player ] = dict;
  
  call_out( "close_socket", 120, new_fd, this_player() );
} /* got_ip_address() */

/*    
  new_fd = eventCreateSocket("208.48.44.94", 2628); 

  if (new_fd < 0) {
    add_failed_mess("$D quivers and starts to jump around.  You "
                    "get the feeling that it's not going to open.\n");
    return 0;
  }
    
    
  call_out( "close_socket", 120, new_fd, this_player() );
*/    

int do_open() {
  class connection_data dict;
  int key;
    
  if ( _connections[ this_player() ] ) {
    add_failed_mess( "$D is already open!\n" );
    return 0;
  }
    
  key = resolve( "dict.org", "got_ip_address" );

  dict = new(class connection_data, fd : 0, 
    status : WAITING_FOR_DNS, count : -1, definitions : ({ }),
    dns_key : key );

  _connections[ this_player() ] = dict;
  
  tell_object( this_player(), "The dictionary is currently "
    "searching for a valid dictionary server.\n" );

  add_succeeded_mess( "$N $V the dictionary.\n" );
  return 1;
} /* do_open() */

int do_close() {
  class connection_data dict;
    
  if ( undefinedp( _connections[ this_player() ] ) ) {
    add_failed_mess( "You have not opened the dictionary!\n" );
    return 0;
  }

  dict = _connections[ this_player() ];    
  close_socket( dict->fd, this_player() );
    
  add_succeeded_mess( "" );
  return 1;
} /* do_close() */

int do_define(mixed *args) {
  class connection_data dict;
       
  if ( !( dict = _connections[ this_player() ] ) ) {
    add_failed_mess( "The dictionary is closed!\n" );
    return 0;
  }

  if ( dict->status != READY ) {
    add_failed_mess( "The dictionary is currently busy.\n" );
    return -1;
  }
    
  dict->current_word = args[0];        
  if (sizeof(args) > 1)
    dict->search_mode = SEARCH_MODE_ALL;
  else
    dict->search_mode = DEFAULT_SEARCH_MODE;    
    
  dict->status = SENDING_DEFINE;
  dict->action = DEFINE;
  tell_creator(DEBUGGER, sprintf("DEFINE %s %s\r\n", dict->search_mode, 
                                 dict->current_word));
  eventWrite(dict->fd, sprintf("DEFINE %s %s\r\n", dict->search_mode, 
                               dict->current_word));
        
  add_succeeded_mess( ({ "Searching...\n", "" }) );
  return 1;
} /* do_define() */

int do_spell(mixed *args) {
  class connection_data dict;
       
  if ( !( dict = _connections[ this_player() ] ) ) {
    add_failed_mess( "The dictionary is closed!\n" );
    return 0;
  }

  if ( dict->status != READY ) {
    add_failed_mess( "The dictionary is currently busy.\n" );
    return -1;
  }

  dict->current_word = args[0];

  if(sizeof(args) > 1)
    dict->search_mode = SEARCH_MODE_ALL;
  else
    dict->search_mode = DEFAULT_SEARCH_MODE;

  dict->status = SENDING_MATCH;
  dict->action = MATCH;
  tell_creator(DEBUGGER, sprintf("MATCH %s . %s\r\n", dict->search_mode, 
                                 dict->current_word));
  eventWrite(dict->fd, sprintf("MATCH %s . %s\r\n", dict->search_mode, 
                               dict->current_word));
  add_succeeded_mess( ({ "Searching...\n", "" }) );
  return 1;
}

void init() {
  add_command( "open", "<direct:object>", (: do_open() :) );
  add_command( "close", "<direct:object>", (: do_close() :) );
  add_command( "define", "<string> [all]", (: do_define($4) :) );
  add_command( "spell", "<string> [all]", (: do_spell($4) :) );
} /* init() */

void dest_me() {
  class connection_data dict;
  object ob;
    
  foreach ( ob, dict in _connections ) {
    close_socket( dict->fd, ob );
  }

  object::dest_me();
  client::dest_me();
} /* dest_me() */
// --- END [/mnt/home2/grok/lib/net/obj/dict.c] ---
// --- BEGIN [/mnt/home2/grok/lib/net/obj/http.c] ---
// Size:   File: "/mnt/home2/grok/lib/net/obj/http.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628675   Available: 13576029
Inodes: Total: 5242880    Free: 4960135
3642 bytes, Last Modified:   File: "/mnt/home2/grok/lib/net/obj/http.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628675   Available: 13576029
Inodes: Total: 5242880    Free: 4960135
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * A simple HTTP/1.0 complaint browser for retrieving web pages.
 * @author Taffyd
 * @started 13/11/2001
 */ 

#include <network.h>

#define DEFAULT_HTTP_PORT 80 

inherit CLIENT;
inherit "/std/object";

class http_connection { 
    object owner;
    string address;
    string ip_address;
    string path; 
    int port; 
    string data; 
}

mapping _connections = ([ ]);
mapping _dns_lookups = ([ ]); 

int do_http_get( string url ) {
    string protocol, full_host, hostname, path; 
    int port; 
    int key;
    int pos; 

    if ( sscanf( url, "%s://%s/%s", protocol, full_host, path ) != 3 ) {
        add_failed_mess( "Incomplete URL\n" );
        return 0;
    }

    if ( protocol != "http" ) {
        add_failed_mess( "This client only supports the HTTP protocol.\n" );
        return 0;
    }
    
    pos = strsrch( full_host, ":" );

    if ( pos != -1 ) {
        hostname = full_host[0 .. pos-1];
        port = to_int( full_host[pos+1..] );
    }
    else {
        hostname = full_host;
        port = DEFAULT_HTTP_PORT;
    }

    tell_object( this_player(), "Connecting to " + hostname + "...\n" );

    key = resolve( hostname, "got_ip_address" );
    _dns_lookups[ key ] = ({ this_player(), port, path }); 
    
    add_succeeded_mess( "" );
    return 1;
} /* do_http_get() */

void create() {
    client::create();
    SetSocketType(STREAM);
    object::create();
} /* create() */

void setup() { 
    set_name( "browser" );
    set_short( "http browser" );
    add_adjective( "http" );
    set_long( "This small object can be used to retrieve web pages using "
        "the 'http get' command.\n" );
    set_weight( 0 ); 
} /* setup() */ 

void close_socket( int fd ) {
    map_delete( _connections, fd );
    eventAbortCallback( fd );
    eventSocketClose( fd );
} /* close_socket() */

void init() { 
    add_command( "http", "get <string>", (: do_http_get( $4[0] ) :) );
} /* init() */ 

void eventRead(int fd, string message) {
    class http_connection tmp;

    tmp = _connections[ fd ];

    if ( tmp->owner ) {
        tell_object( tmp->owner, message );
    }
} /* eventRead() */ 

void got_ip_address( string address, string ip_address, int key ) {
    object player;
    string path;
    int port;
    int fd;

    tell_creator( "taffyd", "%O, %O, %O\n", address, ip_address, key );

    if ( undefinedp( _dns_lookups[ key ] ) ) {
        return;
    }
    
    player = _dns_lookups[ key ][ 0 ]; 
    port = _dns_lookups[ key ][ 1 ];
    path = _dns_lookups[ key ][ 2 ]; 
    
    map_delete( _dns_lookups, key );

    if ( !ip_address ) {
        tell_object( player, "Unable to resolve " + ip_address + ".\n" );
        return;
    }

    if ( sizeof( path ) == 0 ) {
        path = "/";
    }
    else {
        if ( path[0] != '/' ) {
            path = "/" + path;
        }
    }
    
    tell_object( player, 
        sprintf( "Connecting to %s on port %d.\n", ip_address, port ) );

    fd = eventCreateSocket( ip_address, port ); 
    
    if ( fd != -1 ) { 
        eventWrite( fd, sprintf( "GET %s HTTP/1.0\r\n\r\n", path ) ); 

        _connections[ fd ] = new( class http_connection, 
            owner: player,
            address: address,
            ip_address: ip_address,
            port: port,
            path: path, 
            data: "" );            
        call_out( "close_socket", 30, fd );
    }
} /* got_ip_address() */

void dest_me() {
    foreach( int fd, mixed data in _connections ) {
        close_socket( fd );
    }

    object::dest_me();
    client::dest_me();
} /* dest_me() */

int query_prevent_shadow() { 
    return 1;
} /* query_prevent_shadow() */

// --- END [/mnt/home2/grok/lib/net/obj/http.c] ---
// --- BEGIN [/mnt/home2/grok/lib/net/obj/webster.c] ---
// Size:   File: "/mnt/home2/grok/lib/net/obj/webster.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628674   Available: 13576028
Inodes: Total: 5242880    Free: 4960135
94 bytes, Last Modified:   File: "/mnt/home2/grok/lib/net/obj/webster.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628674   Available: 13576028
Inodes: Total: 5242880    Free: 4960135
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This dictionary is obsolete.  Please use /net/obj/dict.c
 */

inherit "/net/obj/dict";
// --- END [/mnt/home2/grok/lib/net/obj/webster.c] ---
// --- BEGIN [/mnt/home2/grok/lib/net/obj/smtp.c] ---
// Size:   File: "/mnt/home2/grok/lib/net/obj/smtp.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628674   Available: 13576028
Inodes: Total: 5242880    Free: 4960135
3716 bytes, Last Modified:   File: "/mnt/home2/grok/lib/net/obj/smtp.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628674   Available: 13576028
Inodes: Total: 5242880    Free: 4960135
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: smtp.c,v 1.4 2000/11/02 06:38:12 ceres Exp $
 * $Log: smtp.c,v $
 * Revision 1.4  2000/11/02 06:38:12  ceres
 * It needed a FQDN for our current sendmail config
 *
 * Revision 1.3  2000/02/18 17:21:39  turrican
 * Let Sendmail determine the FQDN
 *
 * Revision 1.2  1998/05/22 12:14:34  turrican
 * Added possibility of multiple recipients.
 *
 * Revision 1.1  1998/01/06 05:20:37  ceres
 * Initial revision
 * 
*/
/* 
 * SMTP client, written by Turrican@Discworld.
 * Created 4-2-96.
 */

#include <network.h>
#include <mail.h>
#include <mime.h>
#include "smtp.h"

inherit CLIENT;

private nosave mixed *data = ({});
private nosave string *messages = ({});
private nosave int fd = -1;

protected void create() {
  client::create();
  client::SetSocketType(STREAM);
  client::SetDestructOnClose(1);
}

void eventWrite(string mess) {
  return client::eventWrite(fd, mess);
}

void eventSendMail(mixed to, string from, string mess) {
  if (!to || !from || !mess) {
    return;
  }
  if (stringp(to)) {
    data += ({ ({ "MAIL FROM:<" + from + ".discworld@discworld.imaginary.com>\r\n",
                  "RCPT TO:<" + to + ">\r\n",
                  "DATA\r\n" }) });
  } else if (arrayp(to) && sizeof(to)) {
      string *tmpdata;
  
      tmpdata = ({ "MAIL FROM:<" + from + ".discworld@discworld.imaginary.com>\r\n" });
      tmpdata += map(to, (: "RCPT TO:<" + $1 + ">\r\n" :));
      tmpdata += ({ "DATA\r\n" });
      data += ({ tmpdata });
  } else {
    return;
  }
  mess = MIME->rewrite_header(mess);
  mess = replace(mess, ({"\n.", "\n..", "\n", "\r\n"}));
  messages += ({ mess });
  if (fd > 0) {
    return;
  }
  if ((fd = eventCreateSocket(SMTP_HOST, SMTP_PORT)) < 0) {
    data = data[0..<2];
    messages = messages[0..<2];
  }
}

protected void eventSuccess() {
  if (sizeof(data) && sizeof(data[0])) {
    TP(sprintf("SMTP: Writing %s\n", data[0][0]));
    eventWrite(data[0][0]);
    data[0] = data[0][1..];
  } else if (sizeof(data) && !sizeof(data[0])) {
    TP("SMTP: No more data, next message.\n");
    data = data[1..];
    if (!sizeof(data)) {
      TP(sprintf("SMTP: Writing QUIT\n"));
      eventWrite("QUIT\r\n");
    } else
      eventSuccess();
  }
}

protected void eventOKToSendMail() {
  if (sizeof(messages) && messages[0] && (strlen(messages[0]) > 0)) {
    TP("SMTP: Sending mail message.\n");
    eventWrite(messages[0] + "\n.\n");
    messages = messages[1..];
  } else {
    TP("SMTP: No message...\n");
    messages = messages[1..];
    eventWrite("RSET\r\n");
  }
}

protected void eventForward(string who) {
  if (who && who != "") {
    TP(sprintf("SMTP: Forwarding to %s.\n", who));
    eventWrite("RSET\r\n");
    eventWrite(sprintf("RCPT TO:<%s>\r\n", who));
  } else {
    TP("SMTP: Told to forward, but no forwardee...\n");
    eventWrite("QUIT\r\n");
  }
}

protected void eventRead(int fd, string mess) {
  string forward;

  if (!mess) return;
  mess = replace_string(mess, "\r", "");
  switch (mess[0..2]) {
    case "220":
      eventWrite(sprintf("HELO %s\r\n", MUD_IP_NAME));
      break;
    case "250":
    case "251":
      eventSuccess();
      break;
    case "354":
      eventOKToSendMail();
      break;
    case "421":
    case "450":
    case "451":
    case "452":
    case "500":
    case "501":
    case "502":
    case "503":
    case "504":
    case "550":
    case "552":
    case "553":
    case "554":
      TP(sprintf("<FATAL> SMTP: %s", mess));
      eventWrite("QUIT\r\n");
      break;
    case "551":
      if (sscanf(mess, "%*s<%s>%*s", forward) != 3) {
        TP(sprintf("SMTP: %s", mess));
        break;
      }
      eventForward(forward);
      break;
    default:
      break;
  }
}
// --- END [/mnt/home2/grok/lib/net/obj/smtp.c] ---
// --- BEGIN [/mnt/home2/grok/lib/net/intermud3/oob_client.c] ---
// Size:   File: "/mnt/home2/grok/lib/net/intermud3/oob_client.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628673   Available: 13576027
Inodes: Total: 5242880    Free: 4960135
1770 bytes, Last Modified:   File: "/mnt/home2/grok/lib/net/intermud3/oob_client.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628673   Available: 13576027
Inodes: Total: 5242880    Free: 4960135
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: oob_client.c,v 1.2 2002/08/18 15:21:50 terano Exp $
 * $Log: oob_client.c,v $
 * Revision 1.2  2002/08/18 15:21:50  terano
 * Fixed a bug in i3.
 *
 * Revision 1.1  1998/01/06 05:19:18  ceres
 * Initial revision
 * 
*/
/* client for OOB services of the Intermud 3 Protocol.
 * By Turrican@Discworld, 9-8-96. Based on code in the NM lib.
 */

#include <network.h>

inherit CLIENT;

private nosave mapping Connections = ([]);

protected void create() {
  client::create();
  SetSocketType(MUD);
  SetDestructOnClose(1);
}

int Connect(string mudname, int key, string func) {
  int fd, port;
  string ip, realname;
  mixed *info;

  if (previous_object() != SERVICES_D) return EESECURITY;
  realname = INTERMUD_D->GetMudName(mudname);
  if (!realname)
    return EEBADADDR;
  info = INTERMUD_D->GetMudList()[realname];
  ip = info[1];
  port = info[3];
  if (!port)
    return EETYPENOTSUPP;
  if (info[0] != -1)
    return EECONNREFUSED;
  if ((fd = eventCreateSocket(ip, port)) < 0)
    return EECONNECT;
  Connections[fd] = func;
  eventWrite(fd, ({ "oob-begin", mud_name(), 1, key }));
  return EESUCCESS;
}

protected void eventRead(int fd, mixed *packet) {
  if (!packet) return;
  switch (packet[0]) {
  case "oob-begin":
    if (undefinedp(Connections[fd])) return;
    call_other(SERVICES_D, Connections[fd], packet[1]);
    break;
  case "oob-end":
    dest_me();
    break;
  case "mail-ack":
    SERVICES_D->eventReceiveMailAck(packet);
    break;
  case "file-list-reply":
    SERVICES_D->eventReceiveFileList(packet);
    break;
  case "file-put-ack":
    SERVICES_D->eventReceivePutAck(packet);
    break;
  case "file-get-reply":
    SERVICES_D->eventReceiveFile(packet);
    break;
  default:
    break;
  }
}
// --- END [/mnt/home2/grok/lib/net/intermud3/oob_client.c] ---
// --- BEGIN [/mnt/home2/grok/lib/net/intermud3/mudlist.c] ---
// Size:   File: "/mnt/home2/grok/lib/net/intermud3/mudlist.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628672   Available: 13576026
Inodes: Total: 5242880    Free: 4960135
4037 bytes, Last Modified:   File: "/mnt/home2/grok/lib/net/intermud3/mudlist.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628672   Available: 13576026
Inodes: Total: 5242880    Free: 4960135
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: mudlist.c,v 1.2 2002/08/18 15:21:50 terano Exp $
 * $Log: mudlist.c,v $
 * Revision 1.2  2002/08/18 15:21:50  terano
 * Fixed a bug in i3.
 *
 * Revision 1.1  1998/01/06 05:19:18  ceres
 * Initial revision
 * 
*/
/*    /cmds/player/mudlist.c
 *    from the Nightmare IV LPC Library
 *    gives information about muds
 *    created by Descartes of Borg 950623
 *    Modified for Discworld by Turrican 1-11-95
 */

#define INTERMUD_D "/net/intermud3/intermud"

void cmd(string str) {
    mixed *info;
    string *list;
    mapping borg;
    string mud;

    if( str && str != "" && strlen(str) > 3 ) {
	mapping tmp;
	string opt, tmpstr;

	tmp = (mapping)INTERMUD_D->GetMudList();
	if( str[0] != '-' ) str = "-n " + str;
	opt = str[1..1];
	str = str[3..];
	borg = ([]);
	foreach(mud, info in tmp) {
	    int x, y, z;

	    switch(opt) {
		case "m":
		  x = 5;
		  break;
                case "d":
		  x = 7;
		  break;
		case "n":
		  x = 0;
		  break;
	    }
	    tmpstr = (x ? info[x] : mud);
	    z = strlen(str = replace_string(lower_case(str), " ", ""));
	    y = strlen(tmpstr = replace_string(lower_case(tmpstr), " ", ""));
	    if( str == tmpstr ) {
		borg = ([ mud : info ]);
		break;
	    }
	    else if( y > z && tmpstr[0..z-1] == str && info[0] == -1 ) 
	      borg[mud] = info;
	}
    }
    else {
	borg = ([ ]);
	foreach( mud, info in (mapping)INTERMUD_D->GetMudList() )
	  if( info[0] == -1 ) borg[mud] = info;
    }
    if( !sizeof(borg) ) {
        write(mud_name()+" does not have any MUD matching "+str+" in "+
            "it's mudlist.\n");
	return;
    }
    else if( sizeof(borg) == 1 ) {
	string msg, svc;
	int val, comma = 0;

	mud = keys(borg)[0];
	msg = "\nDetailed information on %^GREEN%^" + mud + "%^RESET%^:\n";
	msg += sprintf("MUD Type: %:-15s Server: %:-15s Library: %s\n",
		       borg[mud][8], borg[mud][7], borg[mud][5]);
	msg += "Status: " + borg[mud][9] + "\n";
        msg += "Admin E-mail: " + borg[mud][10] + "\n";
	msg += "Services: ";
	foreach(svc, val in borg[mud][11]) {
	    if( val == 1 ) {
		if( comma ) msg += ", " + svc;
		else {
		    msg += svc;
		    comma = 1;
		}
	    }
	}
	msg += "\nHost: " + borg[mud][1] + "\n";
	msg += "Telnet port: " + borg[mud][2] + "\n";
	if( borg[mud][11]["http"] ) 
	  msg += "HTTP port (World Wide Web): " + borg[mud][11]["http"]+"\n";
	if( borg[mud][11]["ftp"] ) 
	  msg += "FTP port (File Transfer): " + borg[mud][11]["ftp"] + "\n";
	if( borg[mud][11]["rcp"] )
	  msg += "RCP port (Remote Creator): " + borg[mud][11]["rcp"] + "\n";
	write(msg);
        return;
    }
    list = ({});
    foreach(mud, info in borg)
      list += ({ sprintf("%:-15s %:-10s %:-15s %:-15s %s %d",
			 mud, info[8], info[7], info[5], info[1], info[2]) });
    list = sort_array(list, 1);
    list = ({ mud_name() + " recognizes " + sizeof(borg)+" muds"+
		" matching your query: ", "" }) + list;
    previous_object()->more_string(implode(list, "\n")+"\n", "Mudlist");
}

int alphabet(string a, string b) {
    if((a = lower_case(a)) == (b = lower_case(b))) return 0;
    else if(a > b) return 1;
    else return -1;
}

void help() {
    message("help", "Syntax: <mudlist>\n"
	    "        <mudlist -dmn [arg]>\n\n"
	    "Without any arguments, it gives a full listing of all muds "
	    "with which this mud is capable of communication through "
	    "tell, mail, finger, rwho, and other intermud services.  "
	    "With arguments, <mudlist> requires one and only one option "
	    "which must be one of the following:\n"
	    "\t-d [driver]: List only muds using the named driver\n"
	    "\t-m [mudlib]: List only muds using the named mudlib\n"
	    "\t-n [mudname]: List only the muds with the name given\n\n"
	    "Note that the argument need not be complete, for example:\n"
	    "\t mudlist -n idea\n"
	    "will list IdeaExchange as well as any other mud whose name "
	    "begins with the string \"idea\".\n\n"
	    "See also: finger, mail, rwho, tell", this_player());
}

void clean_up() {
  destruct(this_object());
}
// --- END [/mnt/home2/grok/lib/net/intermud3/mudlist.c] ---
// --- BEGIN [/mnt/home2/grok/lib/net/intermud3/services/channel.c] ---
// Size:   File: "/mnt/home2/grok/lib/net/intermud3/services/channel.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628671   Available: 13576025
Inodes: Total: 5242880    Free: 4960135
9374 bytes, Last Modified:   File: "/mnt/home2/grok/lib/net/intermud3/services/channel.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628671   Available: 13576025
Inodes: Total: 5242880    Free: 4960135
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*
 * $Id: channel.c,v 1.13 2003/03/06 18:31:56 wodan Exp $
 */
/*    /daemon/services/channel.c
 *    from the Nightmare IV LPC Library
 *    handles intermud channels using the Intermud 3 protocols
 *    created by Descartes of Borg 950625
 *    Modified for Discworld by Turrican 1-11-95
 */

#define SERVICE_CHANNEL

#define TALKER "/std/shadows/object/talker"
#define HIST "/obj/handlers/hist_handler"

string GetLocalChannel(string ch);

void eventReceiveChannelWhoReply(mixed *packet) {
  object ob;

  if (file_name(previous_object()) != INTERMUD_D) {
    return;
  }
  if (!(ob = find_player(packet[5]))) {
    return;
  }
  packet[6] = GetLocalChannel(packet[6]);
  if (!sizeof(packet[7])) {
    tell_object(ob, "No one is listening to " + packet[6] + " at " +
                packet[2] + ".\n");
    return;
  }
  tell_object(ob, "Listening to " + packet[6] + " at " + packet[2] + ": ");
  tell_object(ob, implode(packet[7], " ")+"\n");
}

int filter_listeners(object ob, string chan) {
  if (!ob->query_creator() || ob->query_invis() ||
      ob->check_earmuffs("intermud-all") ||
      ob->check_earmuffs(GetLocalChannel(chan))) {
    return 0;
  }
  return 1;
}

void eventReceiveChannelWhoRequest(mixed *packet) {
  string *who;

  if (file_name(previous_object()) != INTERMUD_D) {
    return;
  }
  if (GetLocalChannel(packet[6])) {
     who = (string *)filter_array(users(), "filter_listeners", this_object(),
                                  packet[6])->query_cap_name();
  } else {
     who = ({ });
  }
  INTERMUD_D->eventExternWrite(({ "chan-who-reply", 5, mud_name(), 0, packet[2],
                            packet[3], packet[6], who }));
}

void eventReceiveChannelUserRequest(mixed *packet) {
  object ob;
  string visname;
  int gender;

  if (file_name(previous_object()) != INTERMUD_D) {
    return;
  }
  if (!(ob = find_player(packet[6]))) {
    INTERMUD_D->eventExternWrite(({ "error", 5, mud_name(), 0, packet[2], 0,
                              "unk-user", packet[6] + " is not a valid "
                              "player.", packet }) );
    return;
  }
  visname = (string)ob->query_cap_name();
  switch ((string)ob->query_gender_string()) {
  case "male":
    gender = 0;
    break;
  case "female":
    gender = 1;
    break;
  default:
    gender = 2;
    break;
  }
  INTERMUD_D->eventExternWrite( ({ "chan-user-reply", 5, mud_name(), 0, 
                             packet[2], 0, packet[6], visname, gender }));
}

void eventReceiveChannelMessage(mixed *packet) {
  object *people, *things;

  if (file_name(previous_object()) != INTERMUD_D) {
    return;
  }
  if (packet[2] == mud_name() ||
      !GetLocalChannel(packet[6])) {
    return;
  }

  // If it is orion and they have colour, tell them to stop using it.
  if (lower_case(packet[7]) == "orion" &&
      strsrch(packet[8], "%^") != -1) {
     packet[8] = strip_colours(packet[8]);
  }

  // Perform any channel based filtering. ie: strip out all colours
  // on the DW chat line, but leave it open for others. 

  switch( packet[6] ) {
     case "discworld-chat":
     case "discworld-cre":
        if ( strsrch( packet[8], "%^" ) != -1 ) {
           packet[8] = strip_colours( packet[8] );
        }
        break;

     default: 
  }

  people = filter(users(), (: $1->check_not_ignored($(packet[2])) && 
                              $1->check_not_ignored($(packet[7])) && 
                              $1->check_not_ignored($(packet[7]) + "@" +
                                                    $(packet[2])) :));
  packet[8] = replace(packet[8], ({ sprintf("%c", 7), "!",
                                    sprintf("%c", 27), "ESC" }));
  event(people, "intermud_tell", sprintf("%s@%s: ", packet[7], packet[2]),
        packet[8], GetLocalChannel((string)packet[6]));
  if ((string)packet[6] == "discworld-chat") {
    things = children(TALKER);
    things -= ({ find_object(TALKER) });
    things->receive("intermud", sprintf("%s@%s", packet[7], packet[2]),
                    packet[8]);
    HIST->add_chat_history( "intermud", sprintf( "%s wisped: ",
        packet[7] + "@" + packet[2] ), packet[8] );   
  }
/* 
    CHAT_D->eventSendChannel(packet[7] + "@" + packet[2], packet[6],
           packet[8]); */
}
string clean_emote_string( string txt ) {
    int i = 0;

    txt = replace_string(txt, "$N", "");
    
    while ( txt[i] == ' ' ) {
        i++;
    }
    
    txt = txt[i..];

    return txt;
} /* clean_emote_string() */ 

void eventReceiveChannelEmote(mixed *packet) {
  object *people, *things;

  if (file_name(previous_object()) != INTERMUD_D) {
    return;
  }
  if (packet[2] == mud_name()) {
    return;
  }
  if (!packet[7]) {
    return;
  }

  // ( "taffyd", "%s: %O\n", ctime(time()), packet );


  switch( packet[6] ) {
     case "discworld-chat":
     case "discworld-cre":
        if ( strsrch( packet[8], "%^" ) != -1 ) {
           packet[8] = strip_colours( packet[8] );
        }
        break;
  }

  people = filter(users(), (: $1->check_not_ignored($(packet[2])) &&
                            $1->check_not_ignored($(packet[7])) &&
                            $1->check_not_ignored($(packet[7]) + "@" +
                                                  $(packet[2])) :));
  packet[8] = replace(packet[8], ({ sprintf("%c", 7), "!",
                                    sprintf("%c", 27), "ESC" }));
  event(people, "intermud_tell", "", 
        replace_string(packet[8], "$N", packet[7]+"@"+packet[2]), 
        GetLocalChannel((string)packet[6]));
  if ((string)packet[6] == "discworld-chat") {
    things = children(TALKER);
    things -= ({ find_object(TALKER) });
    things->receive("intermud", sprintf("%s@%s", packet[7], packet[2]),
                    ":" + clean_emote_string( packet[8] ) );
  }
/*    CHAT_D->eventSendChannel(packet[7] + "@" + packet[2], packet[6],
           packet[8], 1, 0, 0); */
}

varargs void eventSendChannel(string who, string ch, string msg, int emote,
                              string target, string targmsg) {
  mixed *packet;
  string targpl, where;

  if (emote) {
    if (target && targmsg) {
      if (sscanf(target, "%s@%s", targpl, where) != 2) {
        targpl = target;
      }
      where = mud_name();
    } else {
      targpl = where = targmsg = 0;
    }
    packet = ({ "channel-e", 5, mud_name(), lower_case(who), 0, 0, ch, 
                who, msg });
  } else {
    packet = ({ "channel-m", 5, mud_name(), lower_case(who), 0, 0, ch, 
                who, msg });
  }
  INTERMUD_D->eventExternWrite(packet);
}

void eventSendChannelWhoRequest(string channel, string mud) {
  string pl;

  pl = (string)this_player(1)->query_name();
  INTERMUD_D->eventExternWrite(({ "chan-who-req", 5, mud_name(), pl, mud, 0,
                            channel }));
}

string GetLocalChannel(string channel) {
  switch (channel) {
  case "imud_code":
    return "intercre";
  case "imud_gossip":
    return "intergossip";
  case "discworld-cre":
    return "dwcre";
  case "discworld-chat":
    return "dwchat";
  }
  return 0;
}

void eventRegisterChannels(mapping list) {
  mixed *val;
  string channel, ns, local;

  if (file_name(previous_object()) != INTERMUD_D) {
    return;
  }
  ns = (string)INTERMUD_D->GetNameserver();
  foreach (channel, val in list) {
    if (!val) {
      continue;
    }
    
    local = GetLocalChannel(channel);
    //
    // Don't try registering on channels we don't care about anyway.
    //
    if (!local) {
      //INTERMUD_D->eventExternWrite(({ "channel-listen", 5, mud_name(), 0, ns, 
                                //0, channel, 0 }));
//      log_file("channels", "New channel: " + local + " recognized " +
//         ctime(time()) + "\nValue: " + sprintf("%O", val) + "\n\n");
    } else {
      INTERMUD_D->eventExternWrite(({ "channel-listen", 5, mud_name(), 0, ns,
                                0, channel, 1 }));
    }
  }
}

int eventAdministerChannel(string channel, string *additions, string *subs) {
  if (!((int)master()->high_programmer(geteuid(this_player(1))))) {
    return 0;
  }
  if (member_array(channel, (string *)INTERMUD_D->GetChannels()) == -1) {
    return 0;
  }
  INTERMUD_D->eventExternWrite(({ "channel-admin", 5, mud_name(),
                            (string)this_player(1)->query_cap_name(),
                            (string)INTERMUD_D->GetNameserver(),
                            0, channel, additions, subs }));
  return 1;
}

int AddChannel(string channel, int privee) {
  if (!((int)master()->high_programmer(geteuid(this_player(1))))) {
    return 0;
  }
  if (member_array(channel, (string *)INTERMUD_D->GetChannels()) != -1) {
    return 0;
  }
  INTERMUD_D->eventExternWrite(({ "channel-add", 5, mud_name(),
                            (string)this_player(1)->query_cap_name(),
                            (string)INTERMUD_D->GetNameserver(), 0,
                            channel, privee }));
  return 1;
}

int RemoveChannel(string channel) {
  if (!((int)master()->high_programmer(geteuid(this_player(1))))) {
    return 0;
  }
  if (member_array(channel, (string *)INTERMUD_D->GetChannels()) == -1) {
    return 0;
  }
  INTERMUD_D->eventExternWrite(({ "channel-remove", 5, mud_name(),
                            (string)this_player(1)->query_cap_name(),
                            (string)INTERMUD_D->GetNameserver(), 0,
                            channel }));
  return 1;
}
// --- END [/mnt/home2/grok/lib/net/intermud3/services/channel.c] ---
// --- BEGIN [/mnt/home2/grok/lib/net/intermud3/services/locate.c] ---
// Size:   File: "/mnt/home2/grok/lib/net/intermud3/services/locate.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628669   Available: 13576023
Inodes: Total: 5242880    Free: 4960135
1749 bytes, Last Modified:   File: "/mnt/home2/grok/lib/net/intermud3/services/locate.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628669   Available: 13576023
Inodes: Total: 5242880    Free: 4960135
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*    /daemon/services/locate.c
 *    from the Nightmare IV LPC Library
 *    performs player lookups
 *    created by Descartes of Borg 950624
 *    Modified for Discworld by Turrican 1-11-95
 *    Modified to implement the new protocol by Turrican 11-1-96
 */

#define SERVICE_LOCATE

void eventReceiveLocateRequest(mixed *packet) {
    object ob;
    string status;

    if( file_name(previous_object()) != INTERMUD_D ) return;
    if( !(ob = find_player(packet[6])) || (int)ob->query_invis() ) return;
    if ( ob->query_in_editor() )
        status = "editing";
    if ( !interactive( ob ) )
        status = "link-dead";
    if ( query_idle(ob) > 5*60 ) {
        if ( status )
            status += ", inactive";
        else
            status = "inactive";
    }
    INTERMUD_D->eventExternWrite( ({ "locate-reply", 5, mud_name(), 0, packet[2], 
			       packet[3], mud_name(), 
			       (string)ob->query_cap_name(),
                               query_idle(ob),
                               status }) );
}

void eventReceiveLocateReply(mixed *packet) {
  object ob;

  if( file_name(previous_object()) != INTERMUD_D ) return;
  if( !stringp(packet[5]) || !(ob = find_player(lower_case(packet[5]))) ) 
    return;
  tell_object(ob, packet[7] + " was just located on " + packet[6] + ".\n");
  if ( sizeof(packet) > 8 ) {
    if (packet[8])
      tell_object(ob, packet[7]+" has been idle for "+packet[8]+" seconds.\n");
    if (packet[9] && packet[9] != "")
      tell_object(ob, packet[7]+" is " + packet[9] + ".\n");
  }
}

void eventSendLocateRequest(string who) {
    string pl;

    if( !(pl = (string)this_player(1)->query_name()) ) return;
    INTERMUD_D->eventExternWrite( ({ "locate-req", 5, mud_name(), pl, 0, 0, who }) );
}
// --- END [/mnt/home2/grok/lib/net/intermud3/services/locate.c] ---
// --- BEGIN [/mnt/home2/grok/lib/net/intermud3/services/emoteto.c] ---
// Size:   File: "/mnt/home2/grok/lib/net/intermud3/services/emoteto.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628668   Available: 13576022
Inodes: Total: 5242880    Free: 4960135
1735 bytes, Last Modified:   File: "/mnt/home2/grok/lib/net/intermud3/services/emoteto.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628668   Available: 13576022
Inodes: Total: 5242880    Free: 4960135
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*    /daemon/services/emoteto.c
 *    from the Foundation II Object Library
 *    handles the I3 emoteto service
 *    created by Descartes of Borg 950914
 *    Modified for Discworld by Turrican 1-11-95
 */

#define SERVICE_EMOTETO

void eventReceiveEmote(mixed *packet) {
    object ob;
    string who;

    if( file_name(previous_object()) != INTERMUD_D ) return;
    who = lower_case(packet[5]);
    if( !(ob = find_player(who)) || (int)ob->query_invis() ) {
        INTERMUD_D->eventExternWrite(({ "error", 5, mud_name(), 0, packet[2],
            packet[3], "unk-user", 
            capitalize(packet[5]) + " is nowhere to "
            "be found on " + mud_name() + ".\n",
            packet }));
        return;
    }

    if (!ob->query_creator()) {
        INTERMUD_D->eventExternWrite(({ "error", 5, mud_name(), 0, packet[2],
                                  packet[3], "unk-user",
                                  capitalize(packet[5]) + " is a player "
                                  " and cannot be the target of intermud "
                                  "emotes on " + mud_name() + ".",
                                  packet }));
        return;
    }

    packet[7] = replace_string(packet[7], "$N", packet[6] + "@" + packet[2]);
    ob->event_emote(this_object(), "%^MAGENTA%^"+ packet[7]+ "%^RESET%^\n");
}

void eventSendEmote(string who, string where, string msg) {
    string pl, plc;

    pl = (string)this_player(1)->query_name();
    plc = (string)this_player(1)->query_cap_name();
    where = (string)INTERMUD_D->GetMudName(where);

    if ( !where ) { 
        return;
    }

    INTERMUD_D->eventExternWrite(({ "emoteto", 5, mud_name(), pl, where, 
        lower_case(who), plc, "$N "+msg }));
}
// --- END [/mnt/home2/grok/lib/net/intermud3/services/emoteto.c] ---
// --- BEGIN [/mnt/home2/grok/lib/net/intermud3/services/error.c] ---
// Size:   File: "/mnt/home2/grok/lib/net/intermud3/services/error.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628668   Available: 13576022
Inodes: Total: 5242880    Free: 4960135
1535 bytes, Last Modified:   File: "/mnt/home2/grok/lib/net/intermud3/services/error.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628668   Available: 13576022
Inodes: Total: 5242880    Free: 4960135
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*    /daemon/services/error.c
 *    from the Foundation II LPC Library
 *    error handling for the grand Intermud 3 Protocol
 *    created by Descartes of Borg 950715
 *    Modified for Discworld by Turrican 1-11-95
 */

void eventReceiveError(mixed *packet) {
    object ob;
    string error_code, mud, target, msg;

    if( packet[5] ) {
	target = (string)packet[5];
	if( !(ob = find_player(target)) ) return;
    }
    mud = packet[2];
    error_code = packet[6];
    msg = packet[7];
    packet = packet[8];
    switch(error_code) {
	case "unk-dst": case "not-imp": case "unk-src": case "bad-pkt": case "bad-proto":
	log_file("errors/intermud", error_code + ": " + msg + "\n");
        log_file("errors/intermud", "Name of sending mud: "+mud+"\n");
        if (!packet) return;
        log_file("errors/intermud", "Offending packet: "+
            sprintf("%O\n", packet));
	return;
        case "unk-channel":
        log_file("errors/intermud", error_code + ": " + msg + "\n");
        if (!packet) return;
        log_file("errors/intermud", "Channel name: "+packet[6]+"\n");
	case "unk-type":
    	log_file("errors/intermud", 
            error_code + ": " + msg + "\n");
        log_file("errors/intermud", 
            "Name of sending mud: "+mud+"\n");
        if (!packet) return;
        log_file( "errors/intermud", 
            "Type of offending packet: "+packet[0]+"\n");
	return;
	case "unk-user":
	if( !ob ) return;
	tell_object(ob, (msg ? msg : "Unknown user reported from " + mud +
			   "."));
	return;
    }
}
// --- END [/mnt/home2/grok/lib/net/intermud3/services/error.c] ---
// --- BEGIN [/mnt/home2/grok/lib/net/intermud3/services/who.c] ---
// Size:   File: "/mnt/home2/grok/lib/net/intermud3/services/who.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628667   Available: 13576021
Inodes: Total: 5242880    Free: 4960135
1689 bytes, Last Modified:   File: "/mnt/home2/grok/lib/net/intermud3/services/who.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628667   Available: 13576021
Inodes: Total: 5242880    Free: 4960135
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*    /daemon/services/who.c
 *    from the Nightmare IV LPC Library
 *    handles the Intermud 3 who service
 *    created by Descartes of Borg 950623
 *    Modified for Discworld by Turrican 1-11-95
 */

#define SERVICE_WHO

void eventReceiveWhoReply(mixed *packet) {
  string *list;
  mixed *who;
  object ob;

  if( file_name(previous_object()) != INTERMUD_D ) return;
  if( !packet[5] || !(ob = find_player(packet[5])) ) return;
  list = ({ "Remote who information from " + packet[2] + ":" });
  foreach(who in packet[6]) 
    if (who[1] > 0)
      list += ({ who[0] + " (Idle for " + who[1] + " second"+
                   (who[1]>1?"s":"")+"): " + who[2] });
    else
      list += ({ who[0] + " (Not Idle): " + who[2] });
  ob->more_string(implode(list, "\n")+"\n", "Who");
}

string query_status(object ob) {
  switch((string)ob->query_object_type()) {
  case " ":
    return "Player";
  case "C":
    return "Creator";
  case "p":
    return "Playtester";
  case "S":
    return "Senior Creator";
  case "L":
    return "Lord";
  case "X":
    return "Logging in";
  case "H":
    return "High Lord";
  default:
    return "Unknown";
  }
}

void eventReceiveWhoRequest(mixed *packet) {
    mixed *msg;

    if( file_name(previous_object()) != INTERMUD_D ) return;
    msg = map(filter(users(), (: !((int)$1->query_invis()) :)),
        (: ({ (string)$1->query_cap_name(), query_idle($1), 
                    query_status($1) }) :));
    INTERMUD_D->eventExternWrite(({ "who-reply", 5, mud_name(), 0, packet[2],
            packet[3], msg }));
}

void eventSendWhoRequest(string mud, string who) {
    INTERMUD_D->eventExternWrite(({ "who-req", 5, mud_name(), who, mud, 0 }));
}
// --- END [/mnt/home2/grok/lib/net/intermud3/services/who.c] ---
// --- BEGIN [/mnt/home2/grok/lib/net/intermud3/services/auth.c] ---
// Size:   File: "/mnt/home2/grok/lib/net/intermud3/services/auth.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628666   Available: 13576020
Inodes: Total: 5242880    Free: 4960135
1191 bytes, Last Modified:   File: "/mnt/home2/grok/lib/net/intermud3/services/auth.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628666   Available: 13576020
Inodes: Total: 5242880    Free: 4960135
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* Auth services for the Intermud 3 package.
 * By Turrican@Discworld, 20-3-96
 */

#define SERVICE_AUTH
#define TIMEOUT 10*60

private nosave mapping sessions = ([]);

void eventReceiveAuthRequest(mixed *packet) {
  int key;

  if (file_name(previous_object()) != INTERMUD_D) return;
  if (sizeof(packet) != 6) return;
  key = random(time()); /* XXX - Is this guaranteed to be unique ?? */
  if (!packet[2]) return;
  sessions[packet[2]] = key;
  call_out("eventTimeout", TIMEOUT, packet[2]);
  INTERMUD_D->eventExternWrite(({"auth-mud-reply", 5, mud_name(), 0,
			 packet[2], 0, key}));
}

void eventTimeout(string mudname) {
  if (sessions[mudname])
    map_delete(sessions, mudname);
}

void eventReceiveAuthReply(mixed *packet) {
  if (file_name(previous_object()) != INTERMUD_D) return;
  if (sizeof(packet) != 7) return;
  if (packet[6])
    sessions[mud_name()] = packet[6];
}

void eventSendAuthRequest(string other) {
  if (!other || other == "") return;
  INTERMUD_D->eventExternWrite(({"auth-mud-req", 5, mud_name(), 0, other, 0}));
}

mapping GetKeys() {
  return copy(sessions);
}

int GetKey(string mudname) {
  if (!sessions[mudname]) return 0;
  return sessions[mudname];
}
// --- END [/mnt/home2/grok/lib/net/intermud3/services/auth.c] ---
// --- BEGIN [/mnt/home2/grok/lib/net/intermud3/services/tell.c] ---
// Size:   File: "/mnt/home2/grok/lib/net/intermud3/services/tell.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628666   Available: 13576020
Inodes: Total: 5242880    Free: 4960135
1909 bytes, Last Modified:   File: "/mnt/home2/grok/lib/net/intermud3/services/tell.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628666   Available: 13576020
Inodes: Total: 5242880    Free: 4960135
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*    /daemon/services/tell.c
 *    from the Nightmare IV LPC Library
 *    handles the IMP tell service
 *    created by Descartes of Borg 950507
 *    Modified for Discworld by Turrican 1-11-95
 */

#define SERVICE_TELL

void eventReceiveTell(mixed *packet) {
    object ob;
    string who;
    string from;

    if( file_name(previous_object()) != INTERMUD_D ) return;

    who = lower_case(packet[5]);
    from = packet[6]+"@"+packet[2];

    if( !(ob = find_player(who)) || ( (int)ob->query_invis() && 
        member_array( lower_case( from ), ob->query_allowed() ) == -1 ) ) {
        INTERMUD_D->eventExternWrite(({ "error", 5, mud_name(), 0, packet[2],
                      packet[3], "unk-user", 
                      capitalize(packet[5]) + " is nowhere to "
                        "be found on " + mud_name() + ".",
                      packet }));
    	return;
    }
    if (!ob->query_creator()) {
        INTERMUD_D->eventExternWrite(({ "error", 5, mud_name(), 0, packet[2],
                                  packet[3], "unk-user",
                                  capitalize(packet[5]) + " is a player "
                                  " and cannot be the target of intermud "
                                  "tell s on " + mud_name() + ".",
                                  packet }));
        return;
    }
    ob->event_person_tell(this_object(), from +
                           " tells you: ", packet[7], "common");
    /*ob->SetProperty("reply", packet[6] + "@" + packet[2]); */
} /* eventReceiveTell() */

void eventSendTell(string who, string where, string msg) {
    string pl, plc;
    
    pl = (string)this_player(1)->query_name();
    plc = (string)this_player(1)->query_cap_name();
    where = (string)INTERMUD_D->GetMudName(where);
    INTERMUD_D->eventExternWrite(({ "tell", 5, mud_name(), pl, where, 
			      lower_case(who), plc, msg }));
} /* eventSendTell() */
// --- END [/mnt/home2/grok/lib/net/intermud3/services/tell.c] ---
// --- BEGIN [/mnt/home2/grok/lib/net/intermud3/services/finger.c] ---
// Size:   File: "/mnt/home2/grok/lib/net/intermud3/services/finger.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628665   Available: 13576019
Inodes: Total: 5242880    Free: 4960135
2483 bytes, Last Modified:   File: "/mnt/home2/grok/lib/net/intermud3/services/finger.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628665   Available: 13576019
Inodes: Total: 5242880    Free: 4960135
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*    /daemon/services/finger.c
 *    from the Nightmare IV LPC Library
 *    Intermud 3 finger service implementation
 *    created by Descartes of Borg 950624
 *    Modified for Discworld by Turrican 1-11-95
 */

#define SERVICE_FINGER

private mapping _finger_ids = ([ ]); 

void eventReceiveFingerRequest(mixed *packet) {
    mixed *ret;
    object demon;

    if( !(ret = 
        (mixed *)"/secure/finger"->remote_finger(lower_case(packet[6]))) ) {
        INTERMUD_D->eventExternWrite(({ "error", 5, mud_name(), 0, packet[2],
                                  packet[3], "unk-user",
                                  "No one going by the name of "+
                                  capitalize(packet[6]) + " has ever visited "+
                                  "Discworld.",
				  packet }));
	return;
    }
    demon = clone_object("/net/daemon/chars/in_finger_demon");
    demon->setup_finger(lower_case(packet[6]));
    ret = ({ "finger-reply", 5, mud_name(), 0, packet[2], packet[3] }) + ret;
    INTERMUD_D->eventExternWrite(ret);
}

void eventReceiveFingerReply(mixed *packet) {
    object ob;
    string fing;
    
    if( file_name(previous_object()) != INTERMUD_D ) return;
    
    if( !( ob = find_player( _finger_ids[ lower_case(packet[5]) ] ) ) ) 
        return;

    map_delete( _finger_ids, lower_case( packet[5] ) ); 

    fing = "Finger information on " + packet[6] + " from " + packet[2] + ":\n";
    if( packet[7] && packet[8] ) fing += packet[7] + " (" + packet[8] + ")\n";
    else if( packet[8] ) fing += packet[6] + " (" + packet[8] + ")\n";
    else if( packet[7] ) fing += packet[7] + "\n";
    else fing += packet[6] + "\n";
    fing += "Email: " + (packet[9] ? packet[9] : "Confidential") + "\n";
    fing += ((packet[11] != -1) ? "On since: " + packet[10]  : 
	     "Last logged in: " + packet[10]);
    if( packet[11] != -1 ) fing += " (idle " + packet[11] + " seconds)\n";
    else fing += "\n";
    fing += "Site: " + (packet[12] ? packet[12] : "Confidential") + "\n";
    fing += (packet[14] ? packet[14] : "");
    tell_object(ob, fing);
}

void eventSendFingerRequest(string who, string where) {
    string pl;
    string crname; 
    
    // This is the person who sent the request. 
    if( !(pl = (string)this_player(1)->query_name()) ) return;
    
    crname = lower_case( crypt( pl, 0 ) ); 

    _finger_ids[ crname ] = pl; 

    INTERMUD_D->eventExternWrite( ({ "finger-req", 5, mud_name(), crname, where, 0, 
			       who }) );
}
// --- END [/mnt/home2/grok/lib/net/intermud3/services/finger.c] ---
// --- BEGIN [/mnt/home2/grok/lib/net/intermud3/services/oob.c] ---
// Size:   File: "/mnt/home2/grok/lib/net/intermud3/services/oob.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628664   Available: 13576018
Inodes: Total: 5242880    Free: 4960135
410 bytes, Last Modified:   File: "/mnt/home2/grok/lib/net/intermud3/services/oob.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628664   Available: 13576018
Inodes: Total: 5242880    Free: 4960135
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* OOB service for the Intermud3 protocol. */
 * By Turrican@Discworld, 20-3-96
 */

#define SERVICE_OOB

void eventReceiveOobRequest(mixed *packet) {
  if (file_name(previous_object()) != INTERMUD_D) return;
  if (sizeof(packet) != 6) return;
  if (!packet[2]) return;
  sessions[packet[2]] = -1; /* Special value for non auth services. */
  call_out(eventTimeout, 600, packet[2]);
  OOB_D->eventListen();
}

// --- END [/mnt/home2/grok/lib/net/intermud3/services/oob.c] ---
// --- BEGIN [/mnt/home2/grok/lib/net/intermud3/intermud.c] ---
// Size:   File: "/mnt/home2/grok/lib/net/intermud3/intermud.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628664   Available: 13576018
Inodes: Total: 5242880    Free: 4960135
6095 bytes, Last Modified:   File: "/mnt/home2/grok/lib/net/intermud3/intermud.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628664   Available: 13576018
Inodes: Total: 5242880    Free: 4960135
2009-02-17 16:36:18.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: intermud.c,v 1.16 2003/05/03 07:42:44 ceres Exp $
 */
/*    /daemon/intermud.c
 *    from the Nightmare IV LPC Library
 *    daemon handling the InterMUD-3 Protocol
 *    created by Descartes of Borg 950506
 *    modified for the Discworld mudlib by Turrican 30-10-95
 */

#ifndef __PACKAGE_SOCKETS__
#error You should not try and load /daemon/intermud.c with no sockets package.
#else

#include <network.h>

inherit CLIENT;

#include "intermud.h"

private int Password;
private class list MudList, ChannelList;
private mapping Banned;
nosave private mixed *Nameservers;
private nosave int Connected, Tries, Fd;

protected void create() {
  client::create();
  Connected = 0;
  Password = 0;
  Tries = 0;
  Fd = 0;
  Banned = ([]);
  Nameservers = ({ ({ "*i4", "204.209.44.3 8080" }) });
  MudList = new(class list);
  ChannelList = new(class list);
  MudList->ID = -1;
  MudList->List = ([]);
  ChannelList->ID = -1;
  ChannelList->List = ([]);
  if( file_size( SAVE_INTERMUD __SAVE_EXTENSION__ ) > 0 )
    unguarded((: restore_object, SAVE_INTERMUD, 1 :));
  SetSocketType(MUD);
  SetDestructOnClose(1);
  call_out( (: Setup :), 2);
}

void eventExternWrite( mixed *packet ) {
  return eventWrite(Fd, packet);
}

void eventWrite(int fd, mixed *packet) {
  return client::eventWrite(fd, packet);
}

protected void Setup() {
  string ip;
  int port; 

  if( !Nameservers || !sizeof(Nameservers) ) return;
  sscanf(Nameservers[0][1], "%s %d", ip, port);
  if( (Fd = eventCreateSocket(ip, port)) < 0 ) return;
 eventWrite(Fd, ({ "startup-req-3", 5, mud_name(), 0, Nameservers[0][0], 0,
                      Password, MudList->ID, ChannelList->ID, PORT_MUD,
                      PORT_OOB, 0, MUDLIB_VERSION, 
                      mud_name(), __VERSION__, "LPMud",
                      STATUS, ADMIN_ADDRESS,
                      (mapping)SERVICES_D->GetServices(), 0 }) );
}

protected void eventRead(int fd, mixed *packet) {
  mixed val;
  string cle;

  if( !packet || sizeof(packet) < 6 ) return; /* should send error */
  if( Banned[packet[1]] ) {
    /* build error packet, let them know why they are banned */
    return;
  }
  switch(packet[0]) {
  case "startup-reply":
    if( sizeof(packet) != 8 ) return; /* should send error */
    if( !sizeof(packet[6]) ) return;
    if( packet[6][0][0] == Nameservers[0][0] ) {
      Nameservers = packet[6];
      Connected = 1;
      Password = packet[7];
      unguarded((: save_object, SAVE_INTERMUD, 2 :));
    }
    else {
      Nameservers = packet[6];
      Setup();
    }
    return;
  case "mudlist":
    if( sizeof(packet) != 8 ) return;
    if( packet[6] == MudList->ID ) return; 
    if( packet[2] != Nameservers[0][0] ) return;
    MudList->ID = packet[6];
    foreach(cle, val in packet[7]) {
      if( !val && MudList->List[cle] != 0 ) 
        map_delete(MudList->List, cle);
      else if( val ) MudList->List[cle] = val;
    }
    unguarded((: save_object, SAVE_INTERMUD, 2 :));
    return;
  case "auth-mud-req":
    SERVICES_D->eventReceiveAuthRequest(packet);
    break;
  case "auth-mud-reply":
    SERVICES_D->eventReceiveAuthReply(packet);
    break;
  case "channel-e":
    SERVICES_D->eventReceiveChannelEmote(packet);
    break;
  case "channel-m":
    SERVICES_D->eventReceiveChannelMessage(packet);
    break;
  case "chan-who-reply":
    SERVICES_D->eventReceiveChannelWhoReply(packet);
    break;
  case "chan-who-req":
    SERVICES_D->eventReceiveChannelWhoRequest(packet);
    break;
  case "chan-user-req":
    SERVICES_D->eventReceiveChannelUserRequest(packet);
    break;
  case "chanlist-reply":
    //    if( packet[6] == ChannelList->ID ) return; 
    if( packet[2] != Nameservers[0][0] ) return;
    ChannelList->ID = packet[6];
    foreach(cle, val in packet[7]) { 
      if( !val && ChannelList->List != 0 ) 
        map_delete(ChannelList->List, cle);
      else if( val ) ChannelList->List[cle] = val;
    } 
    unguarded((: save_object, SAVE_INTERMUD, 2 :));
    SERVICES_D->eventRegisterChannels(packet[7]);
    return;
  case "emoteto":
    SERVICES_D->eventReceiveEmote(packet);
    break;
  case "finger-req":
    SERVICES_D->eventReceiveFingerRequest(packet);
    break;
  case "finger-reply":
    SERVICES_D->eventReceiveFingerReply(packet);
    break;
  case "locate-req":
    SERVICES_D->eventReceiveLocateRequest(packet);
    break;
  case "locate-reply":
    SERVICES_D->eventReceiveLocateReply(packet);
    break;
  case "tell":
    SERVICES_D->eventReceiveTell(packet);
    break;
  case "who-req":
    SERVICES_D->eventReceiveWhoRequest(packet);
    break;
  case "who-reply":
    SERVICES_D->eventReceiveWhoReply(packet);
    break;
  case "error":
    SERVICES_D->eventReceiveError(packet);
    break;
  default:
    break;
  }
}

protected void eventSocketClose(int fd) {
  int extra_wait;

  extra_wait = (Tries++) * 20;
  if( extra_wait > 600 ) extra_wait = 600;
  Connected = 0;
  Fd = 0;
  call_out( (: Setup :), 20 + extra_wait);
}

protected void eventConnectionFailure() {
  if( Connected ) return;
  error("Failed to find a useful name server.\n");
}

int SetSocketType(int x) { return client::SetSocketType(MUD); }

int SetDestructOnClose(int x) { return 0; }

string GetMudName(string mud) {
  string *lc, *uc;
  int x;
  
  if( MudList->List[mud] ) return mud;
  lc = map(uc = keys(MudList->List), function(string str) {
    if( !str ) return "";
    else return lower_case(str);
  });
  x = member_array(lower_case(mud), lc);
  if( x < 0 ) return 0;
  else return uc[x];
}

mapping GetMudList() { return copy(MudList->List); }

string *GetMuds() { return keys(MudList->List); }

mapping GetChannelList() { return copy(ChannelList->List); }

string *GetChannels() { return keys(ChannelList->List); }

string *GetMatch(string mud) {
  string *uc, *lc;
  
  mud = lower_case(mud);
  lc = map(uc = keys(MudList->List), (: lower_case :));
  return map(filter(regexp(lc, "^"+mud, 1), (: intp :)), (: $(uc)[$1] :));
}

string GetNameserver() { return Nameservers[0][0]; }

#endif                          /* __PACKAGE_SOCKETS__ */
// --- END [/mnt/home2/grok/lib/net/intermud3/intermud.c] ---
// --- BEGIN [/mnt/home2/grok/lib/net/intermud3/services.c] ---
// Size:   File: "/mnt/home2/grok/lib/net/intermud3/services.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628662   Available: 13576016
Inodes: Total: 5242880    Free: 4960135
2122 bytes, Last Modified:   File: "/mnt/home2/grok/lib/net/intermud3/services.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628662   Available: 13576016
Inodes: Total: 5242880    Free: 4960135
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: services.c,v 1.2 2002/08/18 15:21:50 terano Exp $
 * $Log: services.c,v $
 * Revision 1.2  2002/08/18 15:21:50  terano
 * Fixed a bug in i3.
 *
 * Revision 1.1  1998/01/06 05:19:18  ceres
 * Initial revision
 * 
*/
/*    /daemon/services.c
 *    from the Nightmare IV LPC Library
 *    handles intermud services
 *    created by Descartes of Borg 950523
 *    modified for the Discworld mudlib by Turrican 25-10-95
 */

#ifndef __PACKAGE_SOCKETS__
#error You should not try to load /daemon/services.c without the sockets package
#else

#include <network.h>

mapping GetServices();

protected void create() {
  seteuid(getuid());
}

#include "/net/intermud3/services/auth.c"
#include "/net/intermud3/services/channel.c"
#include "/net/intermud3/services/emoteto.c"
#include "/net/intermud3/services/error.c"
#include "/net/intermud3/services/finger.c"
#include "/net/intermud3/services/locate.c"
#include "/net/intermud3/services/tell.c"
#include "/net/intermud3/services/who.c"

mapping GetServices() {
    return ([
#ifdef whatsthis
	     "amcp" : "1.1",
#endif
#ifdef SERVICE_AUTH
	     "auth" : 1,
#endif
#ifdef SERVICE_CHANNEL
	     "channel" : 1,
#endif
#ifdef SERVICE_EMOTETO
	     "emoteto" : 1,
#endif
#ifdef SERVICE_FILE
	     "file" : 1,
#endif
#ifdef SERVICE_FINGER
	     "finger" : 1,
#endif
#ifdef SERVICE_LOCATE
	     "locate" : 1,
#endif
#ifdef SERVICE_MAIL
	     "mail" : 1,
#endif
#ifdef SERVICE_NEWS
	     "news" : 1,
#endif
#ifdef SERVICE_TELL
	     "tell" : 1,
#endif
#ifdef SERVICE_UCACHE
	     "ucache" : 1,
#endif
#ifdef SERVICE_WHO
	     "who" : 1,
#endif
#ifdef PORT_FTP
	     "ftp" : PORT_FTP,
#endif
#ifdef PORT_HTTP
	     "http" : PORT_HTTP,
#endif
#ifdef PORT_NNTP
	     "nntp" : PORT_NNTP,
#endif
#ifdef PORT_RCP
	     "rcp" : PORT_RCP,
#endif
#ifdef PORT_SMTP
	     "smtp" : PORT_SMTP,
#endif
	     ]);
}

void eventShutdown(int secs) {
  if (file_name(previous_object()) != "/obj/shut")
    return;
  INTERMUD_D->eventWrite( ({ "shutdown", 5, mud_name(), 0, 
      INTERMUD_D->GetNameserver(), 0, secs }) );
}

#endif /* __PACKAGE_SOCKETS__ */
// --- END [/mnt/home2/grok/lib/net/intermud3/services.c] ---
// --- BEGIN [/mnt/home2/grok/lib/net/intermud3/oob_server.c] ---
// Size:   File: "/mnt/home2/grok/lib/net/intermud3/oob_server.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628662   Available: 13576016
Inodes: Total: 5242880    Free: 4960135
2624 bytes, Last Modified:   File: "/mnt/home2/grok/lib/net/intermud3/oob_server.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628662   Available: 13576016
Inodes: Total: 5242880    Free: 4960135
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: oob_server.c,v 1.2 2002/08/18 15:21:50 terano Exp $
 * $Log: oob_server.c,v $
 * Revision 1.2  2002/08/18 15:21:50  terano
 * Fixed a bug in i3.
 *
 * Revision 1.1  1998/01/06 05:19:18  ceres
 * Initial revision
 * 
*/
/* Server for OOB services of the Intermud 3 Protocol.
 * By Turrican@Discworld, 21-3-96. Based on code in the NM lib.
 */

#include <network.h>

inherit SERVER;

#include "oob_server.h"

private nosave int Listening = -1;
private nosave mapping Connections;

protected void create() {
  server::create();
  Connections = ([]);
  SetSocketType(MUD);
  SetDestructOnClose(1);
}

void Setup() {
  int x;

  if (file_name(previous_object()) != SERVICES_D) return;
  remove_call_out("eventTimeout");
  if (Listening != -1) {
    call_out("eventTimeout", TIMEOUT, Listening);
    return;
  }
  if ((x = eventCreateSocket(PORT_OOB)) < 0)
    if (this_object()) destruct(this_object());
  call_out("eventTimeout", TIMEOUT, x);
  Listening = x;
}

protected void eventTimeout(int fd) {
  eventServerAbortCallback(fd);
}

protected void eventSocketClosed(int fd) {
  if (Connections[fd])
    SERVICES_D->eventTimeout(((class connection)Connections[fd])->MudName);
  map_delete(Connections, fd);
}

protected void eventRead(int fd, mixed *packet) {
  if (!packet || sizeof(packet) < 2) return;
  remove_call_out("eventTimeout");
  call_out("eventTimeout", TIMEOUT, fd);
  switch(packet[0]) {
    int key;
  case "oob-begin":
    if (sizeof(packet) != 4) {
      eventTimeout(fd);
      return;
    }
    key = (int)SERVICES_D->GetKey(packet[1]);
    if (!key || (!packet[2] && (key != -1)) || (packet[2] &&
                                                key != packet[3])) {
      eventTimeout(fd);
      return;
    }
    if (!Connections[fd]) {
      class connection tmp;

      tmp = new(class connection);
      tmp->MudName = packet[1];
      Connections[fd] = tmp;
    }
    SERVICES_D->eventTimeout(packet[1]);
    eventWrite(fd, ({"oob-begin", mud_name(), 0, 0}));
    break;
  case "oob-end":
    if (!Connections[fd]) {
      eventTimeout(fd);
      return;
    }
    if (((class connection)Connections[fd])->Buffer)
      eventWrite(fd, ((class connection)Connections[fd])->Buffer);
    eventWrite(fd, ({"oob-end", mud_name()}));
    break;
  case "mail":
    if (!Connections[fd]) {
      eventTimeout(fd);
      return;
    }
    SERVICES_D->eventReceiveMail(packet);
    break;
  case "mail-ack":
    if (!Connections[fd]) {
      eventTimeout(fd);
      return;
    }
    SERVICES_D->eventReceiveMailAck(packet);
    break;
  default:
    break;
  }
}
// --- END [/mnt/home2/grok/lib/net/intermud3/oob_server.c] ---
// --- BEGIN [/mnt/home2/grok/lib/net/snmp/snmp.c] ---
// Size:   File: "/mnt/home2/grok/lib/net/snmp/snmp.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628661   Available: 13576015
Inodes: Total: 5242880    Free: 4960135
4447 bytes, Last Modified:   File: "/mnt/home2/grok/lib/net/snmp/snmp.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628661   Available: 13576015
Inodes: Total: 5242880    Free: 4960135
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*
  SNMP management daemon for the Discworld Mudlib.
  Technically this daemon responds with v1 as it's protocol.
  However it does not support the full MIB-II spec mainly because a lot
  of it is not relevant to the information I wanted to advertise.
  Everything is advertised via the system entity in MIB-II using the
  identifiers 101 and up.  OID 100 is there as a dummy, it returns 0 and is
  for mrtg which requires 2 mibs to graph.
  
  So, for example, number of players on is numPlayers or 1.3.6.1.2.1.1.101

*/

#include "socket.h"
#include "socket_errors.h"
#include "snmp.h"

int s;

class SnmpMessage {
        int version;
        string community;
        string SourceAddress;
        int RequestType;
        int *PacketID;
        int ErrorStatus;
        int ErrorIndex;
        buffer *ObjectData;
        }

void WriteBuffer(string what, buffer tbuf)
{
  string tstr;
  int ti;
  tstr="";
  for(ti=0;ti<sizeof(tbuf);ti++)
  {
    tstr+=sprintf("%X ", tbuf[ti]);
  }
  tell_creator("sojan", "Buffer %s: %s\n", what, tstr);
}

void create()
{
  int tmp;
  s=socket_create(DATAGRAM_BINARY, "ReceiveData");
  tmp=socket_bind(s, LISTEN_PORT);
}

void SendReply(class SnmpMessage Reply)
{
  buffer ReplyBuf, RealReplyBuf, tmpbuf;
  int i,j,k,l,m;
  ReplyBuf=allocate_buffer(500);
  ReplyBuf[0]=SEQUENCE;
  ReplyBuf[1]=0;
  ReplyBuf[2]=INTEGER;
  ReplyBuf[3]=1;
  ReplyBuf[4]=Reply->version;
  ReplyBuf[5]=OCTET_STRING;
  ReplyBuf[6]=sizeof(Reply->community);
  i=write_buffer(ReplyBuf, 7, Reply->community);
  i=sizeof(Reply->community)+7;
  ReplyBuf[i]=Reply->RequestType;
  ReplyBuf[i+1]=0;
  ReplyBuf[i+2]=2;
  ReplyBuf[i+3]=sizeof(Reply->PacketID);
  k=i+4;
  for(j=0;j<sizeof(Reply->PacketID);j++)
  {
    ReplyBuf[k]=Reply->PacketID[j];
    k++;
  }
  ReplyBuf[k]=2;
  ReplyBuf[k+1]=1;
  ReplyBuf[k+2]=0;
  ReplyBuf[k+3]=2;
  ReplyBuf[k+4]=1;
  ReplyBuf[k+5]=0;
  ReplyBuf[k+6]=SEQUENCE;
  ReplyBuf[k+7]=0;
  l=k+8;
  for(j=0;j<sizeof(Reply->ObjectData);j++)
  {
    m=write_buffer(ReplyBuf, l, Reply->ObjectData[j]);
    l=l+sizeof(Reply->ObjectData[j]);
  }
  ReplyBuf[1]=l-2;
  ReplyBuf[k+7]=l-(k+8);
  RealReplyBuf=allocate_buffer(l);
  RealReplyBuf=ReplyBuf[0..l-1];
  RealReplyBuf[i+1]=sizeof(RealReplyBuf)-i-2;
  socket_write(s, RealReplyBuf, Reply->SourceAddress);
  return;
}

void ParseObjects(class SnmpMessage CurrentMessage)
{
  int i,j;
  class SnmpMessage MyReply;
  buffer mibdata;
  MyReply=new(
        class SnmpMessage,
        version:CurrentMessage->version,
        community:CurrentMessage->community,
        RequestType:GETRESPONSEPDU,
        SourceAddress:CurrentMessage->SourceAddress,
        PacketID:CurrentMessage->PacketID,
        ErrorStatus:0,
        ErrorIndex:0,
        ObjectData:({})
        );
  for(i=0;i<sizeof(CurrentMessage->ObjectData);i++)
  {
    j=CurrentMessage->ObjectData[i][1];
    mibdata=SNMPHANDLER->GetData(CurrentMessage->ObjectData[i][2..j+1]);
    if(mibdata[0]==SEQUENCE) MyReply->ObjectData+=({mibdata,}); 
  }
  SendReply(MyReply);
  return;
}



void ReceiveData(int fd, buffer message, string address)
{
  int i,j,k,ss,is,id,es,ei;
  class SnmpMessage NewMessage;
  id=0;
  es=0;
  ei=0;
  is=0;
  ss=0;
  NewMessage=new(
        class SnmpMessage, 
        version:message[4], 
        community:read_buffer(message, 7, message[6]),
        RequestType:message[message[6]+7],
        SourceAddress:address,
        PacketID:({}),
        ErrorStatus:0,
        ErrorIndex:0,
        ObjectData:({})
        );
  for(i=message[6]+9;i<message[1]+2;i++)
  {
    switch(message[i])
    {
      case INTEGER :
        switch(is)
        {
          case ID :
            i++;
            k=i;
            is++;
            for(j=0;j<message[k];j++)
            {
              i++;
              NewMessage->PacketID+=({message[i],});
            }
            break; 
          case ES :
            i++;
            i++;
            is++;
            NewMessage->ErrorStatus=message[i];
            break;
          case EI :
            i++;
            i++;
            is++;
            NewMessage->ErrorIndex=message[i];
            break;
        }  
        break;
      case SEQUENCE :
        if(!ss)
        {
          ss++;
          i++;
          break;
        }
        i++;
        j=message[i];
        i++;
        NewMessage->ObjectData+=({message[i..(i+j-1)],});
        break;
    }
  }
  ParseObjects(NewMessage);          
  return;
}
// --- END [/mnt/home2/grok/lib/net/snmp/snmp.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/monster.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/monster.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628660   Available: 13576014
Inodes: Total: 5242880    Free: 4960135
82309 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/monster.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628660   Available: 13576014
Inodes: Total: 5242880    Free: 4960135
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker: pinkfish $
 * $Id: monster.c,v 1.85 2003/07/28 21:05:41 ceres Exp pinkfish $
 */

/**
 * This file contains all the information relevant to creating an
 * npc (or monster).
 * @author Pinkfish
 */
#include <config.h>
#include <living.h>
#include <map.h>
#include <monster.h>
#include <move_failures.h>
#include <player.h>
#include <skills.h>
#include <wander.h>
#include <route.h>
#include <combat.h>
#define SPELL_INCLUDE_CLASS
#include <top_ten_tables.h>

#define SOUL_OBJECT "/obj/handlers/soul"

inherit "/std/living/mon_actions";
inherit "/std/living/living";
inherit "/std/living/response_mon";
inherit "/global/events";
inherit "/global/guild-race";

nosave string cap_name;
nosave mixed *chat_string;
nosave mixed *achat_string;
private nosave mixed *_combat_actions;
nosave mixed _move_after;
nosave mixed *throw_out;
nosave int chat_chance;
nosave int achat_chance;
nosave int aggressive;
nosave int join_fight_type;
nosave int follow_speed;
nosave int virtual_move;
nosave int moves;
nosave string race;
nosave string guild;
nosave string join_fight_mess;
nosave string true_location;
nosave mixed *enter_commands;
nosave string *move_zones;
private nosave mixed *_queued_commands;
private nosave mixed *doing_story;
nosave object last_attacked;
private nosave string *following_route;
private nosave int added_language;
private nosave function cmd_func = 0;

// This is used to make sure players cannot change an npc's positon with
// souls.
private nosave int cannot_change_position;
private nosave int always_return_to_default_position;

private nosave mapping _spell_actions;

void do_move_after(int running_away);
void do_route_move();
private void _next_queued_command();
void start_attack( object who );

#if !efun_defined(add_action)
protected mixed _process_input(string);
protected mixed command(string);
void command_override(function func);
int drunk_check(string str);
#endif



void create() {
    do_setup++;
    events::create();
    living::create();
    mon_actions::create();
    response_mon::create();
    //p  command::create();
    do_setup--;
    reset_get();
    follow_speed = 3;
    doing_story = ({ ({ }), ({ }) });
    chat_string = ({ 0, ({ }) });
    achat_string = ({ 0, ({ }) });
    move_zones = ({ });
    _spell_actions = ([ ]);
    _combat_actions = ({ });
    enter_commands = ({ });
    known_commands = ({ });
    _queued_commands = ({ });
    following_route = ({ });
    enable_commands();
    living_commands();
    parser_commands();
    communicate_commands();
    command_commands();
    add_property("npc",1);
    set_rows( 24 );
    set_cols( 200 );
    // Default to 5 seconds.
    always_return_to_default_position = 5;
#ifdef OLD_SOUL
    add_action("*", "soul_commqz", -2);
#endif
    /*
      add_action("init_race", "init_race");
      race_guild_commands();
    */
    set_con( 13 );
    set_dex( 13 );
    set_int( 13 );
    set_str( 13 );
    set_wis( 13 );
    set_max_hp( 10000 );
    set_hp( 100000 );
    set_max_gp( 10000 );
    set_gp( 10000 );
    if ( !do_setup )
        this_object()->setup();
    if(clonep())
        call_out(function() {
              if(!environment()) {
                  move(find_object("/room/rubbish"));
              }
          }, 60);
} /* create() */

/**
 * This method sets up a nationality and sets up a region in the
 * nationality for the npc.
 * @param nationality the nationality to set
 * @param region the region in the nationality
 */
void setup_nationality(string nationality, string region) {
   set_nationality(nationality);
   set_nationality_region(region);
   if (!load_object(nationality)) {
      debug_printf("Bad nationality, %O\n", nationality);
   } else {
      if (!nationality->query_region_description(region)) {
         debug_printf("Bad region %O in nationality, %O\n", region,
                      nationality);
      }
      add_language(nationality->query_language());
      set_language(nationality->query_language());
      set_default_language(nationality->query_language());
   }
}

/** @ignore yes */
void dest_me() {
    living::dest_me();
} /* dest_me() */

/** @ignore yes */
int soul_commqz(string str) {
    string verb, bit;

    if (sscanf(str, "%s %s", verb, bit) == 2)
        return (int)SOUL_OBJECT->soul_command(verb, bit);
    return (int)SOUL_OBJECT->soul_command(str, "");
} /* soul_commqz() */

/** @ignore yes */
int query_sp() { return 50; }
/** @ignore yes */
int adjust_sp( int number ) { return 50; }

/**
 * This method returns the current capitalized name of the npc.
 * @return the current capitalized name
 * @see set_cap_name()
 */
string query_cap_name() {
    return cap_name;
} /* query_cap_name() */

/**
 * This method set the current capitalized name of the npc.
 * @param s the capitalized name of the npc
 * @see query_cap_name()
 */
void set_cap_name(string s) { cap_name = s; }

/** @ignore yes */
int soul_com_force(string str) {
    //  string str1,str2;

    if (file_name(previous_object()) != SOUL_OBJECT)
        return 0;
    command(str);
    return 1;
} /* soul_com_force() */

/** @ignore yes */
void set_name(string n) {
    if (query_name() && query_name() != "object")
        return;
    ::set_name(n);
    cap_name = capitalize(query_name());
    add_plural(pluralize(query_name()));
    set_short( query_name() );
    set_long("You see nothing special.\n");
    set_living_name(n);
} /* set_name() */

/** @ignore yes */
string long(string str, int dark) {
    string s;

    if (dark < -1) {
      s = "You can only make out a rough shape in the glare.\n";
    } else if (dark > 1) {
      s = "You can only make out a rough shape in the gloom.\n";
    } else {
       s = query_long();
    }
    if(!dark) {
        s += capitalize(query_pronoun())+" "+health_string()+".\n";
        s += capitalize(query_pronoun()) + " is " +
            this_object()->query_position_short() + ".\n";
        s += calc_extra_look();
        s += query_living_contents(0);
    }
    return s;
} /* long() */

/**
 * This function is deprecated.  Use basic_setup() instead.
 *
 * This method sets the race of the npc.  The race should be one of
 * the races listed in the /std/race.c object.
 * This is used in conjuction with the
 * guild when set_level is called to setup the default
 * attributes for the npc.  This should only be
 * called *before* set_level() is called.
 * @param str the race to set
 * @return always returns 1
 * @example
 * ob = clone_object("/obj/monster");
 * ob->set_race("fish");
 * @example
 * inherit "/obj/monster";
 *
 * void setup() {
 *    ...
 *    set_race("fish");
 *    ...
 *    set_level(12);
 * } /\* setup() *\/
 * @see query_race()
 * @see query_guild()
 * @see set_guild()
 * @see set_level()
 * @see basic_setup()
 */
int set_race(string str) {
    race = str;
    return 1;
} /* set_race() */

/**
 * This method returns the current race of the npc.
 * @return the current race of the object
 * @see set_race()
 * @see query_guild()
 * @see set_level()
 */
string query_race() { return race; }
/**
 * This method returns the current guild of the npc.
 * @return this current guild of the npc
 * @see query_race()
 * @see set_guild()
 * @see set_level()
 */
string query_guild() { return guild; }
/**
 * @ignore yes
 * This method should not be used.  It is 'depreciated'.
 */
string query_class() { return guild; }
/**
 * @ignore yes
 * This method should not be used.  It is 'depreciated'.
 */
string query_profession() { return guild; }

/**
 * @ignore yes
 * This method should not be used.  It is 'depreciated'.
 */
int set_class(string str) {
    guild = str;
} /* set_guild() */

/**
 * This method is deprecated.  Use basic_setup() instead.
 *
 * This method sets the current guild of the npc to the
 * passed in value.  The guild should be one of
 * the guilds listed in the /std/race.c object.
 * This is used in conjuction with the
 * race when set_level is called to setup the default
 * attributes for the npc.  This should only be
 * called *before* set_level() is called.
 * @param str the new guild for the npc
 * @example
 * ob = clone_object("/obj/monster");
 * ob->set_guild("fighter");
 * @example
 * inherit "/obj/monster";
 *
 * void setup() {
 *    ...
 *    set_race("fighter");
 *    ...
 *    set_level(12);
 * } /\* setup() *\/
 * @see query_race()
 * @see query_guild()
 * @see set_guild()
 * @see set_level()
 */
int set_guild(string str) {
    guild = str;
} /* set_guild() */

/**
 * @ignore yes
 * This method should not be used.  It is 'depreciated'.
 */
int set_profession(string str) {
    guild = str;
} /* set_profession() */

/**
 * This method makes the npc initialise all their equipment, like hold
 * it and stuff.
 * @see do_command()
 */
void init_equip() { command("equip"); }

/**
 * This method allows you to control the npc and get it to do
 * actions.  This can be used for npc control and inteligence.
 *
 * Be very careful with this command! This does not go through any
 * command queue like players have and so NPCs can end up doing
 * tons of commands in very short order.
 *
 * If you're trying to make your NPC act like a player use
 * eue_command() instead
 *
 * @param words the action to preform
 * @see init_equip()
 * @see init_command()
 * @example
 * ob = clone_object(NICE_HAIRY_APE);
 * ob->do_command("'I am a hairy ape!");
 * ob->do_command("emote apes around the room.");
 */
int do_command( string words ) {
    if ( this_object()->query_property( PASSED_OUT_PROP ) ) {
        return -1;
    }
    if ( stringp( words ) ) {
        return command( words );
    }
    printf( "Invalid parameter to do_command: %O for monster %O in %O.\n",
      words, this_object(), environment() );
    return -1;
} /* do_command() */

/**
 * This method throws away any queued commands.
 * It doesn't remove the call_out however if no
 * new commands are added there will be no effect.
 * @see init_equip()
 * @see init_command()
 * @see delay_command()
 * @see do_command()
 * @see queue_command()
 */
void delete_queued_commands() {
  _queued_commands = ({ });
}

/**
 * This method returns the queued command list.
 * @see init_equip()
 * @see init_command()
 * @see delay_command()
 * @see do_command()
 * @see queue_command()
 */
mixed *query_queued_commands() {
  return _queued_commands;
}

/** @ignore yes */
private void _next_queued_command() {
  mixed next;

  if (!sizeof(_queued_commands)) return;

  // No actions while casting.
  if(this_object()->query_casting_spell()){
    call_out( (: _next_queued_command :), 2 );
    return;
  }
  
  next = _queued_commands[0];
  if (intp( next )) {
    _queued_commands = _queued_commands[1..];
    if (!sizeof(_queued_commands)) return;
    next = _queued_commands[0];
  }
  while (stringp( next )) {
    if (this_object()->queue_commands()) {
      call_out( (: _next_queued_command :), 2 );
      return;
    }
    do_command( next );
    _queued_commands = _queued_commands[1..];
    if (!sizeof(_queued_commands)) return;
    next = _queued_commands[0];
  }
  call_out( (: _next_queued_command :), next );
} /* _next_queued_command */

/**
 * This method allows you to control the npc and get it to do
 * actions where they are queued as for players.   The command
 * is always delayed by delay even if there are no commands pending
 * unlike queue_command(). This function
 * is 100% compatible with queue_command() and init_command().
 * @param words the action to perform
 * @param interval to wait before the command.
 * @see queue_command()
 * @see query_queued_commands()
 * @see init_command()
 * @see do_command()
 * @example
 * ob = clone_object(NICE_HAIRY_APE);
 * ob->delay_command("'I am a hairy ape!",10);
 * ob->delay_command("emote apes around the room.",2);
 * ob->queue_command("emote get banana.",3);
 * ob->queue_command("emote get apple.");
 * After 10 seconds it says "I am a hariy ape",
 * 2 seconds after that it apes around the room,
 * immediately following that it gets a banana
 * and 3 seconds after that it gets an apple.
 */
int delay_command( string words, int interval ) {
    if ( this_object()->query_property( PASSED_OUT_PROP ) ) {
        return -1;
    }
    if ( stringp( words ) ) {
      if (!sizeof(_queued_commands)) {
        call_out( (: _next_queued_command :), interval );
      }
      _queued_commands = _queued_commands + ({ interval, words });
      return 1;
    }
    printf( "Invalid parameter to delay_command: %O for monster %O in %O.\n",
      words, this_object(), environment() );
    return -1;
} /* delay_command() */

/**
 * This method allows you to control the npc and get it to do
 * actions where they are queued as for players.  If there are no
 * commands pending the command is executed immediately.  This function
 * is 100% compatible with delay_command() and init_command().
 * @param words the action to perform
 * @param interval to wait before processing another command.
 * If omitted defaults to 2 seconds as per players
 * @see delay_command()
 * @see query_queued_commands()
 * @see init_command()
 * @see do_command()
 * @example
 * ob = clone_object(NICE_HAIRY_APE);
 * ob->queue_command("'I am a hairy ape!");
 * ob->queue_command("emote apes around the room.",5);
 * ob->queue_command("get banana",10);
 * ob->delay_command("emote get apple.",3);
 * Right away it says "I am a hairy ape",
 * 2 seconds later it apes around the room,
 * 5 seconds after that it gets a banana
 * and 13 seconds (10+3) after that it gets an apple.
 */
varargs int queue_command( string words, int interval ) {
    if ( this_object()->query_property( PASSED_OUT_PROP ) ) {
        return -1;
    }
    if ( stringp( words ) ) {
      if (undefinedp(interval)) interval=2;
      if (!sizeof(_queued_commands)) {
        _queued_commands = ({ words, interval });
        _next_queued_command();
        return 1;
      }
      _queued_commands = _queued_commands + ({ words, interval });
      return 1;
    }
    printf( "Invalid parameter to queue_command: %O for monster %O in %O.\n",
      words, this_object(), environment() );
    return -1;
} /* queue_command() */

/**
 * This method allows you submit delayed commands to the npc
 * via a call_out.
 * @see do_command()
 * @see queue_command()
 * @see delay_command()
 */
varargs void init_command(string str, int tim) {
    call_out("do_command", tim, str);
} /* init_command() */

/** @ignore yes */
void init() {
  set_heart_beat( 1 );
  if (environment() && aggressive && this_player() &&
      file_name( environment() )[1..4] != "room" &&
      !environment()->no_attack() &&
      this_player()->query_visible(this_object()))
    start_attack(this_player());
}

/**
 * This method check to see if the npc should start attacking someone
 * when they enter the npcs environment.  It is called from inside
 * init().  It will only attack if the agressive is set and the
 * person is visible to be attacked.  The property
 * <pre>"no attack"</pre> can be set on the npc (or player) to
 * stop them being attacked.
 * @param who the person to potentially start attacking
 * @see set_aggressive()
 */
void start_attack( object who ) {
  if(!who || !aggressive ) {
    return;
  }

  if ( !who->query_visible( this_object() ) ||
       who->query_auto_loading() ||
       file_name(who) == DEATH ||
       who->query_property( "guest" ) ||
       ( userp( who ) && !interactive( who ) ) ||
       who->query_property( "no attack" ) ) {
    return;
  }

  /*
   * This uses a call_other() just in case there are shadows.
   */
  if(((aggressive > 1) || interactive(who)) &&
     (!interactive(who) || !who->query_auto_loading()))
    this_object()->attack_ob( who );
}

/** @ignore yes */
varargs int adjust_hp( int number, object attacker, object weapon,
                         string attack ) {
    set_heart_beat( 1 );
    return ::adjust_hp( number, attacker, weapon, attack );
} /* adjust_hp() */

/** @ignore yes */
int adjust_gp( int number ) {
    set_heart_beat( 1 );
    return ::adjust_gp( number );
} /* adjust_gp() */

/**
 * This method checks to see if there are any players in the environment
 * of the npc.  This should be used to determine when chats should
 * be turned off and other things which should only work in the
 * presence of players.
 * @return 1 if there is a player in the room, 0 otherwise
 */
int check_anyone_here() {
    object thing;

    if ( !environment() ) {
        return 0;
    }
    if ( file_name( environment() )[1..4] == "room" ) {
        return 0;
    }
    if ( environment()->query_linked() ) {
        return 1;
    }
    foreach( thing in all_inventory( environment() ) ) {
        if ( interactive( thing ) || thing->query_slave() ) {
            return 1;
        }
    }
    return 0;
} /* check_anyone_here() */

/**
 * This method is used to determine when to throw people out of a
 * room.  This is what detritus uses to throw people out of the
 * mended drum when it gets a bit rowdy.
 * <p>
 * The hps is the level of hps at which the npc will start throwing
 * people out with the chance of it occuring (chance is a percentage).
 * <p>
 * People will be thrown into a random room, if the property
 * <pre>"no throw out"</pre> is specified on the room then they
 * will not be thrown into that room.
 * @param hps the number of hps at which to start throwing people out
 * @param chance the percentage chance of being thrown out
 * @param their_mess the message to show them
 * @param everyone_mess the message to show everyone else
 * @see set_aggressive()
 * @see query_throw_out()
 * @see set_join_fights()
 * @see expand_string()
 */
void set_throw_out( int hps, int chance, string their_mess,
  string everyone_mess ) {
    throw_out = ({ hps, chance, their_mess, everyone_mess });
} /* set_throw_out() */

/**
 * This method returns the current throw out array.
 * The array consists of
 * <pre>({
 *   hps,
 *   chance,
 *   their_mess,
 *   everyone_mess
 * })
 * </pre>The parameters are the same as used in the set_throw_out
 * function.
 * @see set_throw_out()
 * @return the throw out array
 */
mixed *query_throw_out() { return throw_out; }

/**
 * This method is used to make the npc run away.  This will be
 * called by the combat code for wimpy when the npc is bellow the
 * number of points used to trigger the wimpy action.
 * @return 1 if successfuly ran away
 */
int run_away() {
    if ( query_property( "run away" ) == -1 ) {
        return 0;
    }
    // Just to make npcs a bit trickier...
    do_command("lose all");
    become_flummoxed();
    if ( sizeof( following_route ) ) {
        do_route_move();
        return 1;
    }
    if ( query_property( "run away" ) ) {
        this_object()->do_move_after( 1 );
        return 1;
    }
    return ::run_away();
} /* run_away() */

/**
 * This method is used to expand the message strings used in the
 * npc messages.  It is used for chat strings and such things like
 * that.  The strings it expands are of the form:<br>
 * $lname$, $mname$, $aname$, ...<br>
 * The first letter determines the type of object being referenced.
 * They are:
 * <dl>
 * <dt>m
 * <dd>Me!  The npc itself.
 * <dt>l
 * <dt>A living object, choose a random living object in the npcs
 *     environment.
 * <dt>a
 * <dd> Chooses a random attacker from those attacking the npc.
 * <dt>o
 * <dd>Choose a random object in the inventory of the npc.
 * </dl>
 * After the first letter is a type of information being request.
 * <dl>
 * <dt>name
 * <dd>The name of the selected object.
 * <dt>cname
 * <dd>The capitalised name of the selected object.
 * <dt>gender
 * <dd>The gender string of the selected object (male, female, neuter).
 * <dt>poss
 * <dd>The possessive string of the selected object.
 * <dt>obj
 * <dd>The objective string of the selected object.
 * <dt>pronoun
 * <dd>The pronoun string of the selected object.
 * <dt>gtitle
 * <dd>The guild title of the selected object (only useful on livings).
 * <dt>ashort
 * <dd>The a_short() call.
 * <dt>possshort
 * <dd>The poss_short() call.
 * <dt>theshort
 * <dd>The the_short() call.
 * <dt>oneshort
 * <dd>The one_short() call.
 * </dl>
 * @see set_chat_string()
 * @see expand_mon_string()
 * @param in_str the input string
 * @param on the object to use for the 'o' matching
 */
string expand_string(string in_str, object on) {
    string *str, ret;
    int i, add_dollar;
    object liv, *obs, ob;

    in_str = "/global/events"->convert_message( in_str );
    str = explode(in_str, "$");
    ret = "";
    for ( i = 0; i < sizeof( str ); i++ ) {
        if ( i % 2 == 0 ) {
            if (add_dollar) {
                ret += "$";
            }
            ret += str[i];
            add_dollar = 1;
            ob = 0;
        } else switch (str[i][0]) {
        case 'm' :
            ob = this_object();
        case 'l' :
          if(!ob) {
            if(!liv) { /* Changed to not loop badly up when no environment */
              obs = all_inventory(environment()) - ({ this_object() });
              obs = filter_array(obs, (: living($1) &&
                                       $1->query_visible(this_object()) :));
              if (sizeof(obs))
                liv = obs[random(sizeof(obs))];
            }
            if (!liv) { /* No one here to see us blow up anyway ;) */
              break;
            }
            ob = liv;
          }
        case 'a' :
            if ( !ob ) {
                obs = (object *)this_object()->query_attacker_list();
                if ( !sizeof( obs ) )
                    break;
                ob = obs[ random( sizeof( obs ) ) ];
            }
        case 'o' :
            if (!ob) {
                if (!on) {
                    obs = all_inventory(environment());
                    obs = filter_array( obs, (: !living( $1 ) :) );
                    if (sizeof(obs)) {
                        on = obs[random(sizeof(obs))];
                    }
                }
                ob = on;
            }
            switch (str[ i ][ 1 .. ]) {
            case "theshort" :
                ret += (string)ob->the_short();
                add_dollar = 0;
                break;
            case "ashort" :
                ret += (string)ob->a_short();
                add_dollar = 0;
                break;
            case "oneshort":
                ret += (string)ob->one_short();
                add_dollar = 0;
                break;
            case "possshort" :
                ret += (string)ob->poss_short();
                add_dollar = 0;
                break;
            case "name" :
                ret += (string)ob->query_name();
                add_dollar = 0;
                break;
            case "cname" :
                ret += (string)ob->query_cap_name();
                add_dollar = 0;
                break;
            case "gender" :
                ret += (string)ob->query_gender_string();
                add_dollar = 0;
                break;
            case "poss" :
                ret += (string)ob->query_possessive();
                add_dollar = 0;
                break;
            case "obj" :
                ret += (string)ob->query_objective();
                add_dollar = 0;
                break;
            case "gtitle" :
                ret += (string)ob->query_gender_title();
                add_dollar = 0;
                break;
            case "pronoun" :
                ret += (string)ob->query_pronoun();
                add_dollar = 0;
                break;
            default :
                if (add_dollar) {
                    ret += "$";
                }
                ret += str[i];
                add_dollar = 1;
                break;
            }
            ob = 0;
            break;
        default :
            if (add_dollar) {
                ret += "$";
            }
            ret += str[i];
            add_dollar = 1;
            ob = 0;
            break;
        }
    }
    if (strlen(ret) && ret[strlen(ret)-1] == '$') {
        return ret[0..strlen(ret)-2];
    }
    return ret;
} /* expand_string() */

/**
 * This method executes the string passed in.  It handles all the
 * stuff which is needed from the chat_string stuff.
 *
 * If the input is a function pointer then it is evaluated with one
 * parameter, being the npc.
 *
 * If the input is a string then the first letter determines what will
 * be done with it.  All these are passed through expand_string
 * so that exciting things can be done.
 * <ul>
 * <li># - A call_other will be generated.  The parameters are separated by
 * ':'s, so "#frog:bing:fred:chicken" would call<pre>
 * this_object()->bing("fred", "chicken");
 * </pre>.
 * <ul>', ", : - These will generate a 'say', 'lsay' or 'emote'.
 * <ul>@ - This will run the passed in command.  Eg: "@frog" would cause the
 *     soul command frog to be used.
 * <ul>Anything else will be used as a message to be sent to everyone in the
 *     room.
 * </ul>
 * @param str the thing to execute
 * @see expand_string()
 */
void expand_mon_string( mixed str ) {
    string *args;

    if ( functionp( str ) ) {
        evaluate( str, this_object() );
    } else {
        if( !stringp( str ) && environment( this_object() ) ) {
            tell_room(environment(this_object()),
              "%^RED%^"+ this_object()->the_short()+
              " says: please bugreport me, I have a bad load_chat.%^RESET%^\n",
              ({ }) );
        }
        switch ( str[ 0 ] ) {
        case '#' :
            args = explode(str[ 1..], ":");
            switch (sizeof(args)) {
            case 1 :
                call_other( this_object(), args[0] );
                break;
            case 2 :
                call_other( this_object(), args[0], args[1] );
                break;
            case 3 :
                call_other( this_object(), args[0], args[1], args[2] );
                break;
            case 4 :
                call_other( this_object(), args[0], args[1], args[2],
                  args[3] );
                break;
            default :
                call_other( this_object(), args[0], args[1], args[2],
                  args[3], args[4] );
                break;
            }
            break;
        case ':' :
        case '\'' :
        case '"' :
            init_command( expand_string( str, 0 ), 1 );
            break;
        case '@' :
            init_command( expand_string( str[ 1 .. ], 0 ), 1 );
            break;
        default :
            tell_room( environment(), expand_string( str, 0 ) +"\n" );
        }
    }
} /* expand_mon_string() */

/**
 * This method returns 1 if it is ok to turn of the npc's heart beat.
 * THis can be overridden for times when the heart beat needs to be
 * kept on for some reason.
 * @return 1 if the heart beat should go off, 0 if it should stay on
 */
int query_ok_turn_off_heart_beat() {
   return 1;
} /* query_ok_turn_off_heart_beat() */

/** @ignore yes */
void heart_beat() {
  int i, j;
  
  if(base_name(environment()) == "/room/rubbish") {
    set_heart_beat(0);
    return;
  }
  
  ::heart_beat();
  RACE_OB->monster_heart_beat( race, guild, race_ob, guild_ob );
  
  if ( ( hp == max_hp ) && ( gp == max_gp ) ) {
    if (query_ok_turn_off_heart_beat()) {
      if ( !check_anyone_here() ||
           ( !sizeof( achat_string ) && !sizeof( chat_string ) ) ) {
        set_heart_beat( 0 );
        return;
      }
    }
  }
  
  /* These may be obsolete. */
  remove_property( "done follow" );
  this_object()->do_spell_effects( 0 );
  
  if ( check_anyone_here() ) {
    if ( this_object()->query_fighting() ) {
      if ( sizeof( doing_story[ 1 ] ) ) {
        if( !intp(doing_story[ 1 ][ 0 ] ) ) {
          expand_mon_string( doing_story[ 1 ][ 0 ] );
          doing_story[ 1 ] = doing_story[ 1 ][ 1 .. ];
        } else if( random( 1000 ) < doing_story[ 1 ] [ 0 ]) {
          expand_mon_string( doing_story[ 1 ][ 1 ] );
          if ( sizeof( doing_story[ 1 ] ) == 2 ) {
            doing_story[ 1 ] = ({});
          } else {
            doing_story[ 1 ] = ({ doing_story[ 1 ] [ 0 ] }) +
              doing_story[ 1 ][ 2 .. ];
          }
        }
      } else if ( ( random( 1000 ) < achat_chance )
                  && sizeof( achat_string[ 1 ] ) ) {
        i = random( achat_string[ 0 ] + 1 );
        while ( ( i -= achat_string[ 1 ][ j ] ) > 0 )
          j += 2;
        if ( pointerp( achat_string[ 1 ][ j + 1 ] ) ) {
          if( intp(achat_string[ 1 ][ j + 1 ][ 0 ]) ) {
            if( random(1000) < achat_string[ 1 ][ j + 1 ][ 0 ] ) {
              expand_mon_string( achat_string[ 1 ][ j + 1 ][ 1 ] );
              doing_story[ 1 ] = ({ achat_string[ 1 ][ j + 1 ][ 0 ] })+
                achat_string[ 1 ][ j + 1 ][ 2 .. ];
            } else {
              doing_story[ 1 ] = achat_string[ 1 ][ j + 1 ];
            }
          } else {
            expand_mon_string( achat_string[ 1 ][ j + 1 ][ 0 ] );
            doing_story[ 1 ] = achat_string[ 1 ][ j + 1 ][ 1 .. ];
          }
        } else
          expand_mon_string( achat_string[ 1 ][ j + 1 ] );
      }
    } else {
      if ( sizeof( doing_story[ 0 ] ) ) {
        if( !intp( doing_story[ 0 ][ 0 ] ) ) {
          expand_mon_string( doing_story[ 0 ][ 0 ] );
          doing_story[ 0 ] = doing_story[ 0 ][ 1 .. ];
        } else if( random( 1000 ) < doing_story[ 0 ][ 0 ]) {
          expand_mon_string( doing_story[ 0 ][ 1 ] );
          if ( sizeof( doing_story[ 0 ] ) == 2 ) {
            doing_story[ 0 ] = ({});
          } else {
            doing_story[ 0 ] = ({ doing_story[ 0 ] [ 0 ] }) +
              doing_story[ 0 ][ 2 .. ];
          }
        }
      } else if ( ( random( 1000 ) < chat_chance )
                  && sizeof( chat_string[ 1 ] ) ) {
        i = random( chat_string[ 0 ] + 1 );
        while ( ( i -= chat_string[ 1 ][ j ] ) > 0 )
          j += 2;
        if ( pointerp( chat_string[ 1 ][ j + 1 ] ) ) {
          if( intp( chat_string[ 1 ][ j + 1 ][ 0 ]) ) {
            if(random( 1000) < chat_string[ 1 ][ j + 1 ][ 0 ]) {
              expand_mon_string( chat_string[ 1 ][ j + 1 ][ 1 ] );
              doing_story[ 0 ] = ({ chat_string[ 1 ][ j + 1 ][ 0 ] }) +
                chat_string[ 1 ][ j + 1 ][ 2 .. ];
            } else {
              doing_story[ 0 ] = chat_string[ 1 ][ j + 1 ];
            }
          } else {
            expand_mon_string( chat_string[ 1 ][ j + 1 ][ 0 ] );
            doing_story[ 0 ] = chat_string[ 1 ][ j + 1 ][ 1 .. ];
          }
        } else
          expand_mon_string( chat_string[ 1 ][ j + 1 ] );
      }
    }
  }
} /* heart_beat() */

/** @ignore yes */
int clean_up( int parent ) {
  if(query_property("unique") || check_anyone_here())
    return 1;

  if(parent) {
    log_file("CLEANUP", "%s %s cleaned up.\n", ctime(time()),
             file_name(this_object()));
  }
  move( "/room/rubbish" );
  return 1;
}

/**
 * This method generates a random number.  It used to setup the random
 * stats.
 * @param no the number of times to roll the dice
 * @param type the size of the dice
 * @see set_random_stats()
 * @return the randomly generate number
 */
int rand_num(int no, int type) {
    int i, val;

    for (i=0;i<no;i++)
        val = random(type)+1;
    return val;
} /* rand_num() */

/**
 * This method sets the stats for the npc to some exciting random
 * values.
 * @param no the number of times to roll the dice
 * @param type the size of the dice
 * @see rand_num()
 */
void set_random_stats(int no, int type) {
    set_str(rand_num(no, type));
    set_dex(rand_num(no, type));
    set_int(rand_num(no, type));
    set_con(rand_num(no, type));
    set_wis(rand_num(no, type));
} /* set_random_stats() */

/**
 * This method sets up the basic abilities and race of the critter.  It
 * is equivalent to calling set_race(), set_guild(), and then set_level()
 * with the same parameters.  But those latter three functions are
 * deprecated and shouldn't be used.
 * @see set_race()
 * @see set_guild()
 * @see set_level()
 * @param race this is the race of the character.  It should be a
 * race that's understood by the /std/race.c
 * @param guild this is the guild, class, or profession of the NPC.
 * @param level this is the base skill level of the NPC.  The
 * number is used by the race object to set ability scores, and
 * base skills.
 */
void basic_setup(string race, string guild, int level)
{
    this_object()->set_race(race);
    this_object()->set_guild(guild);
    this_object()->set_level(level);
}

/**
 * This function is deprecated.  Use basic_setup() instead.
 *
 * This method sets the level of the npc.  This should only be called
 * *after* the race and guild are set.  If this is called before that
 * the results will be unexpected.
 * @see set_race()
 * @see set_guild()
 * @see basic_setup()
 * @param i the level to set the npc to
 */
void set_level( int i ) { RACE_OB->set_level( i, race, guild ); }

/**
 * This method is used to give some startup money to the npc.
 * @param base the base amount of money to give (fixed)
 * @param rand the random amount of money to give
 * @param type the type of money to give (default: "copper")
 * @example
 * ob = clone_object(CLUCKY_CHICKEN);
 * // This will give the chicken 10 + random(10) royals.
 * // It is a royal chicken
 * ob->give_money(10, 10, "royal");
 * @return the return value of adjust_money()
 * @see /std/living/money.c
 */
int give_money(int base, int rand, string type) {
    if (!type)
        type = "copper";
    return adjust_money(base+random(rand), type);
} /* give_money() */

/**
 * This method loads up the chat strings for the npc.  This will be
 * an array containing pairs of elements, the first pair is the
 * weighting of the chat and the second is the chat to use.
 * <p>
 * All the weights in the array are added up and then a random
 * number is chosen in the weighting.  Then that element is looked
 * up in the array.  This way you can control a chat and make it
 * rare.
 * <p>
 * If the chat string is an array then this a story, the story will be
 * executed one after another and no other chats will be executed
 * in between.  If the first parameter of the story array is a number it
 * will be used as a 1/1000 chance of the next story line being displayed. 
 * Special strings can be used which will replace with
 * object names, see expand_mon_string() for further information.
 * <p>
 * The chat chance is a chance (in 1000) of the chat occuring.  You
 * will need to play with this yourself to see which frequency of
 * chatting you wish for your npcs.
 *
 * @example
 * load_chat(60,
 *    ({
 *       1, "'I am a chicken!",
 *       // Make this one more likely to occur.
 *       2, ":clucks like a chicken."
 *       1, ":pecks at $lpossshort$ foot."
 *     }));
 * @example
 * load_chat(100,
 *    ({
 *       1, "'I am a simple farmer."
 *       1, ":waves $mposs$ pitchfork around."
 *       // A story, they will always occur in this order
 *       1, ({
 *           500,
 *            "'Once upon a time there was a rabbit.",
 *            "'It was a nice rabbit and hung around in bars.",
 *            "'It sung little songs about fruit.",
 *           }),
 *      }));
 * @see expand_mon_string()
 * @param chance the chance in 1000 of a chat working every 2 seconds
 * @param c_s the chat string to use
 * @see load_a_chat()
 * @see query_chat_chance()
 * @see query_chat_string()
 */
void load_chat(int chance, mixed *c_s) {
    int i;
    chat_string = ({ 0, ({ }) });
    for (i=0;i<sizeof(c_s);i+=2) {
        chat_string[1] += ({ c_s[i], c_s[i+1] });
        chat_string[0] += c_s[i];
    }
    chat_chance = chance;
} /* load_chat() */

/**
 * This method sets the current chat chance for messages on the
 * npc.
 * @param i the chat chance
 * @see load_chat()
 * @see query_chat_chance()
 */
void set_chat_chance(int i) { chat_chance = i; }
/**
 * This method returns the current chat chance for messages on
 * the npc
 * @return the current chat chance
 * @see set_chat_chance()
 * @see load_chat()
 */
int query_chat_chance() { return chat_chance; }
/**
 * This method sets the current chat string for messages on the
 * npc.  See load_chat() for a longer description of how the
 * chat string is formatted.
 * @param chat the new chat strings.
 * @see load_chat()
 * @see query_chat_string()
 */
void set_chat_string(string *chat) { chat_string = chat; }
/**
 * This method queries the current chat string for messages on the
 * npc.  See load_chat() for a longer description of how the
 * chat string is formatted.
 * @return the current chat string
 * @see load_chat()
 * @see query_chat_string()
 */
string *query_chat_string() { return chat_string; }

/**
 * This method adds a single chat string into the current list of
 * chat strings.  See load_chat() for a longer description of
 * the chat string.
 * @param weight the weight of the chat
 * @param chat the new chat string
 * @see load_chat()
 * @see remove_chat_string()
 */
void add_chat_string(mixed weight, mixed chat) {
    int i;

    if (pointerp(weight)) {
        for (i=0;i<sizeof(weight);i+=2) {
            add_chat_string(weight[i], weight[i+1]);
        }
    } else {
        if (member_array(chat, chat_string[1]) == -1) {
            chat_string[1] += ({ weight, chat });
            chat_string[0] += weight;
        }
    }
} /* add_chat_string() */

/**
 * This method attempts to remove the given chat string from the
 * current list of chat strings.  The chat message is checked
 * to see if it exists in the array, the weighting of the
 * string is ignored.
 * @param chat the chat string to remove
 * @see add_chat_string()
 * @see load_chat()
 */
void remove_chat_string(mixed chat) {
    int i;

    if (pointerp(chat)) {
        for (i=0;i<sizeof(chat);i++) {
            remove_chat_string(chat[i]);
        }
    } else {
        if ((i = member_array(chat, chat_string[1])) != -1) {
            chat_string[0] -= chat_string[1][i-1];
            chat_string[1] = delete(chat_string[1], i-1, 2);
        }
    }
}  /* remove_chat_string() */

/**
 * This method loads up the set of chat strings to use while in combat.
 * @param chance the chance of the chat occuring
 * @param c_s the chat string to use
 * @see load_chat()
 * @see query_achat_chance()
 * @see query_achat_string()
 */
void load_a_chat(int chance, mixed *c_s) {
    int i;

    achat_string = ({ 0, ({ }) });
    for (i=0;i<sizeof(c_s);i+=2) {
        achat_string[1] += ({ c_s[i], c_s[i+1] });
        achat_string[0] += c_s[i];
    }
    achat_chance = chance;
} /* load_a_chat() */

/**
 * This method sets the current chat chance for attack messages on the
 * npc.
 * @param i the attack message chat chance
 * @see load_chat()
 * @see load_achat()
 * @see query_achat_chance()
 */
void set_achat_chance(int i) { achat_chance = i; }
/**
 * This method returns the current chat chance for attack messages on
 * the npc.
 * @return the current attack message chat chance
 * @see set_achat_chance()
 * @see load_chat()
 * @see load_achat()
 */
int query_achat_chance() { return achat_chance; }
/**
 * This method sets the current chat string for attack messages on the
 * npc.  See load_chat() for a longer description of how the
 * chat string is formatted.
 * @param chat the new chat attack message strings.
 * @see load_chat()
 * @see load_achat()
 * @see query_achat_string()
 */
void set_achat_string(string *chat) { achat_string = chat; }
/**
 * This method queries the current chat string for attack messages on the
 * npc.  See load_chat() for a longer description of how the
 * chat string is formatted.
 * @return the current attack message chat string
 * @see load_chat()
 * @see load_achat()
 * @see set_chat_string()
 */
string *query_achat_string() { return achat_string; }
/**
 * This method adds a single chat string into the current list of
 * attack message chat strings.  See load_chat() for a longer description of
 * the chat string.
 * @param weight the weight of the chat
 * @param chat the new chat string
 * @see load_chat()
 * @see load_achat()
 * @see remove_achat_string()
 */
void add_achat_string(mixed weight, mixed chat) {
    int i;

    if (pointerp(weight))
        for (i=0;i<sizeof(weight);i+=2)
            add_achat_string(weight[i], weight[i+1]);
    else
    if (member_array(chat, achat_string[1]) == -1) {
        achat_string[1] += ({ chat });
        achat_string[0] += weight;
    }
} /* add_achat_string() */

/**
 * This method attempts to remove the given chat string from the
 * current list of attack message chat strings.  The chat message is checked
 * to see if it exists in the array, the weighting of the
 * string is ignored.
 * @param chat the chat string to remove
 * @see add_achat_string()
 * @see load_chat()
 * @see load_achat()
 */
void remove_achat_string(mixed chat) {
    int i;

    if (pointerp(chat))
        for (i=0;i<sizeof(chat);i++)
            remove_achat_string(chat[i]);
    else
    if ((i = member_array(chat, achat_string[1])) != -1) {
        achat_string[0] -= achat_string[1][i-1];
        achat_string[1] = delete(achat_string[1], i-1, 1);
    }
} /* remove_achat_string() */

/**
 * This method adds a move zone onto the npc.  The move zones control
 * which areas the npcs will wander into, a move zone is set on the
 * room and the npcs will only enter rooms which have a matching
 * move zone.  If there is no move zone, then the npc will enter
 * any room.
 * <p>
 * If the parameter is an array each of the elements of the array
 * will be added as a move zone.
 * @param zone the zone(s) to add
 * @see remove_move_zone()
 * @see query_move_zones()
 * @see set_move_after()
 */
void add_move_zone(mixed zone) {
    int i;

    if (pointerp(zone))
        for (i=0;i<sizeof(zone);i++)
            add_move_zone(zone[i]);
    else if (member_array(zone, move_zones) != -1)
        return;
    else
        move_zones += ({ zone });
} /* add_move_zone() */

/** @ignore why is this here? */
void set_move_zones(string *zones) {
    int i;

    for (i=0;i<sizeof(zones);i++)
        add_move_zone(zones[i]);
} /* set_move_zones() */

/**
 * This method removes a move zone from the npc.
 * @param zone the zone to remove
 * @see add_move_zone()
 * @see query_move_zones()
 * @see set_move_after()
 */
void remove_move_zone(mixed zone) {
    int i;

    if (pointerp(zone))
        for (i=0;i<sizeof(zone);i++)
            remove_move_zone(zone[i]);
    else {
        if ((i=member_array(zone, move_zones)) == -1)
            return ;
        move_zones = delete(move_zones, i, 1);
    }
} /* remove_move_zone() */

/**
 * This method returns the current list of move zones on the npc
 * @return the current list of move zones
 * @see add_move_zone()
 * @see remove_move_zones()
 * @see set_move_after()
 */
string *query_move_zones() { return move_zones; }

/**
 * This method sets the speed at which the npc will randomly
 * wander around.  The npc will wander at the speed:<pre>
 * speed = after + random(rand)
 * </pre>This is called every time the npc sets up for its next move.
 * <p>
 * The move zones control
 * which areas the npcs will wander into, a move zone is set on the
 * room and the npcs will only enter rooms which have a matching
 * move zone.  If there is no move zone, then the npc will enter
 * any room.
 * @param after the fixed amount of time
 * @param rand the random amount of time
 * @see remove_move_zone()
 * @see query_move_zones()
 * @see add_move_zone()
 */
void set_move_after(int after, int rand) {
    _move_after = ({ after, rand });
    if (after != 0 && rand != 0) {
        do_move_after(0);
    }
} /* set_move_after() */

/**
 * This method returns the current move after values.
 * It returns an array of the form:<pre>
 *    ({
 *      after,
 *      rand,
 *     })
 * </pre>
 * @return the move after values
 * @see set_move_after()
 */
mixed query_move_after() {
   return copy( _move_after );
} /* query_move_after() */


/**
 * This method adds a command to be called whenever the npc enters
 * a room.  If the command is a string, then it will be executed
 * as if they had typed it.  If it is a function then the function
 * will be evaluated and one argument (the npc itself) will be passed
 * in.
 * @param str the enter commands to add
 * @see reset_enter_commands()
 * @see query_enter_commands()
 */
int add_enter_commands(mixed str) {
    if (stringp(str)) {
        enter_commands += ({ str });
    } else if (pointerp(str)) {
        enter_commands += str;
    } else if (functionp(str)) {
        enter_commands += ({ str });
    }
    return 1;
} /* add_enter_commands() */

/**
 * This method returns the current array of enter commands.
 * @return the current array of enter commands
 * @see reset_enter_commands()
 * @see add_enter_commands()
 */
string *query_enter_commands() { return enter_commands; }

/**
 * This method resets the array of enter commands back to nothing.
 * @see add_enter_commands()
 * @see add_enter_commands()
 */
void reset_enter_commands() { enter_commands = ({ }); }

/** @ignore yes */
varargs int move( mixed dest, string messin, string messout ) {
    int result;
    object before;
    before = environment();
    result = living::move( dest, messin, messout );
    if ( result == MOVE_OK ) {
        me_moveing( before );
        if ( virtual_move )
            true_location = file_name( environment() );
    }
    return result;
} /* move() */

/** @ignore yes */
void room_look() {
    int i;

    ::room_look();
    for ( i = 0; i < sizeof( enter_commands ); i++ ) {
        if ( functionp( enter_commands[ i ] ) ) {
            call_out( enter_commands[ i ], 2 * i + 1, this_object() );
            continue;
        }
        if ( enter_commands[ i ][ 0 .. 0 ] == "#" )
            call_out( enter_commands[ i ][ 1 .. 99 ], 2 * i + 1 );
        else
            init_command( enter_commands[ i ], 2 * i + 1 );
    }
} /* room_look() */

/**
 * This is called when the npc decides it must continue down
 * a certain route.  This will be called by the wander handler
 * and can be used to force the npc to wander along a route
 * faster.
 * @param running_away this is 1 if the npc is running away
 * @see set_move_after()
 */
void do_move_after (int running_away ) {
    if (sizeof(following_route)) {
        do_route_move();
    } else {
        WANDER_HANDLER->move_after( running_away );
    }
} /* do_move_after() */

/**
 * This event is called when a fight is in progress.  It will
 * be used for things like joining into currently running
 * fights and initiating combat with spell casters.
 * @param me the person initiating the attack
 * @param him the person being attacked
 */
void event_fight_in_progress(object me, object him) {
  mixed action;
  int i;

  // Run the combat actions.
  if(sizeof(this_object()->query_attacker_list())) {
    // Do combat actions.
    for(i=0; i<sizeof(_combat_actions); i+= 3) {
      if(_combat_actions[i] > random(100)) {
        action = _combat_actions[i+2];
        if(stringp(action))
          this_object()->do_command(action);
        else if(functionp(action))
          evaluate(action, me, him);
        else if(pointerp(action) && sizeof(action) == 1 && stringp(action[0]))
          call_other(this_object(), action[0], me, him);
        else if(pointerp(action) && sizeof(action) == 2)
          call_other(action[0], action[1], this_object(), me, him);
      }
    }
  }

  if(him == this_object() && this_object()->query_property("see_caster") &&
     !userp(me) &&
     (random(him->query_property("see_caster"))) < (him->query_int()))
    this_object()->attack_ob(me->query_owner());
  
  if(!join_fight_mess || !me || !him)
    return;

  if(him == this_object())
    return;

  /* only attack npcs if fight_type is not 0. */
  if(!join_fight_type && !interactive(him))
    return;

  if(member_array(him, (object *)this_object()->query_attacker_list()) == -1) {
    if(!him->query_property("no attack")) {
      if(join_fight_mess)
        expand_mon_string(join_fight_mess);
      this_object()->attack_ob(him);
    }
  }
} /* event_fight_in_progress() */

/**
 * This method sets the message to use when joining into fights.
 * @param str the message to print when joining a fight
 * @see query_join_fights()
 * @see set_join_fight_type()
 */
void set_join_fights(string str) { join_fight_mess = str; }
/**
 * This method returns the message to use when joining into fights.
 * @return the message to print when joining a fight
 * @see set_join_fights()
 * @see set_join_fight_type()
 */
string query_join_fights() { return join_fight_mess; }

/**
 * This method sets the flag which allows the npc to join into fights.
 * If this is set to a non-zero value then the npc will join into
 * fights in progress using the fight joining message.
 * @param i 1 if the npc is to join fights, 0 if not
 * @see set_join_fights()
 * @see query_join_fight_type()
 */
void set_join_fight_type(int i) { join_fight_type = i; }
/**
 * This method returns the flag which allows the npc to join into fights.
 * @return 1 if the npc is to join fights, 0 if not
 * @see set_join_fights()
 * @see query_join_fight_type()
 */
int query_fight_type() { return join_fight_type; }

/** @ignore yes */
void event_exit( object me, string mess, object to ) {
  mixed *bing;
  int i, j, k;
  string *zones, fname;
  object *attacker_list, ob;
  
  events::event_exit( me, mess, to );
  living::event_exit( me, mess, to );

  if (!_move_after || sizeof(following_route)) /* we dont move :( */
    return ;
  
  /* If we're not going anywhere... */ 
  if ( !to || !me->query_visible(this_object()))
    return; 

  /* follow the suckers. */
  attacker_list = this_object()->query_attacker_list();
  
  if(attacker_list && sizeof(attacker_list)) {
    // If we're not fighting them then don't follow them.
    if (member_array(me, attacker_list) == -1)
      return;
    
    // Remove us. 
    attacker_list -= ({ me }); 
    
    // If there are people still here who we're fighting then don't
    // follow the person who left.
    foreach(ob in attacker_list) {
      if(ob && environment(ob) == environment())
        return;
    }
  } else { 
    /* Not being attacked, let's not follow. */ 
    return;
  }
    
  bing = (mixed *)environment()->query_dest_dir( this_object() );

  if( !bing ) {
    return ; /* lost cause */
  }

  fname = file_name( to );
    
  /* Check to see they're going a valid direction for this room. */ 
  
  if ((i = member_array(fname, bing)) == -1) {
    return ; /* lost cause */
  }
  if (!this_object()->query_property("unrestricted follow")) {
    zones = (string *)to->query_zones();
    if (move_zones && (j = sizeof(move_zones))) {
      while (j--) {
        if (member_array(move_zones[j], zones) != -1) {
          k = 1; /* If we are suppose to wander in move_zones.. dont go */
          break;  /* where we are not supposed to... get stuck */
        }
      }
      if (!k)
        return;
    } else
      return;
  }
  remove_call_out("do_follow_move");
  call_out("do_follow_move", 4 + random(follow_speed), bing[i-1]);
}

/**
 * This method is used to make the npcs follow after attackers when they
 * leave the room.
 * @param dir the dirction to follow them in
 */
void do_follow_move(string dir) {
  if (sizeof(following_route))
    return ;
  // NPCs are following & attacking instantly since they don't have
  // time_left. So, use up actions instead.
  this_object()->adjust_action_defecit((ACTIONS_PER_HB / (COMBAT_SPEED + 1)));
  do_command(dir);
}

/**
 * This method adds a combat action to the npc.  This is an action which
 * has a chance of occuring during combat.  The name is an identifier
 * which can be used to remove the action with later.  The action
 * itself can be a string, then that command will be executed.  If
 * the action is a function pointer then it will be evaluated with
 * two arguments, the first being the attacker, the second being the
 * target.
 * <p>
 * If the action is an array, if it is one element then the function
 * specified will be called on the attacked with the same arguements
 * as above.  If the size of the array is two then the function will
 * be called on the specified object with the arguments as above.
 * @see remove_combat_action()
 * @see query_combat_actions()
 * @see /std/effects/fighting/combat.c
 */
void add_combat_action( int chance, string name, mixed action ) {
    int i;
    i = member_array( name, _combat_actions );
    if ( i == -1 ) {
        _combat_actions += ({ chance, name, action });
    } else {
        _combat_actions[ i - 1 ] = chance;
        _combat_actions[ i + 1 ] = action;
    }
} /* add_combat_action() */

/**
 * This method will remove the combat action with the specified name.
 * @return 1 if it is found and removed, 0 if not
 * @see add_combat_action()
 * @see query_combat_actions()
 * @see /std/effects/fighting/combat.c
 */
int remove_combat_action( string name ) {
    int i;

    i = member_array( name, _combat_actions );
    if ( i == -1 )
        return 0;
    _combat_actions = delete( _combat_actions, i - 1, 3 );
    return 1;
} /* remove_combat_action() */

/**
 * This method returns the current array of combat actions on the
 * npc.
 * <p>
 * The array will have the format of:
 * <pre>
 *    ({
 *        action1_chance,
 *        action1_name,
 *        action1_action,
 *        ...
 *     })
 * </pre>
 * @return the combat action array
 * @see add_combat_action()
 * @see remove_combat_actions()
 * @see /std/effects/fighting/combat.c
 */
mixed *query_combat_actions() { return copy( _combat_actions ); }

/**
 * This method does a combat action.
 * @param target the target of the action
 * @param thing
 */
void do_combat_action( object player,
                       object target,
                       mixed action ) {
   object place;

   if ( !target ) {
      return;
   }
   place = environment( target );
   if ( place != environment( player ) ) {
      return;
   }
   if ( stringp( action ) ) {
      do_command( action );
      return;
   }
   if (functionp(action)) {
      evaluate(action, player, target);
   }
   if ( pointerp(action) && sizeof(action) == 1 && stringp( action[ 0 ] ) ) {
      call_other( this_object(), action[ 0 ], player, target );
      return;
   }
   if (pointerp(action) && sizeof(action) == 2) {
      call_other( action[ 0 ], action[ 1 ], this_object(), player, target );
   }
} /* do_combat_action() */

/**
 * This is the call back from the combat effect to do something
 * wonderful and wild.
 * @param player the player
 * @param target the target
 */
void combat_actions_call_back( object player, object target ) {
  int i;
  object thing;
  object *things;
  mixed *actions;

  if ( !player || !target ) {
    return;
  }
  thing = environment( player );
  if ( thing != environment( target ) ) {
    return;
  }

  things = filter_array( all_inventory( thing ), (: living( $1 ) ==
                                                  !userp( $1 ) :) );
  foreach ( thing in things ) {
    actions = (mixed *)thing->query_combat_actions();
    for(i=0; i<sizeof(actions); i += 3) {
      if(actions[i] > random(100)) {
        call_out( "do_combat_action", 1, player, target, actions[ i + 2 ] );
      }
    }
  }
} /* combat_actions_call_back() */



/**
 * This method adds an action to the npc that will happen if a specified
 * spell is cast.  This is an action which
 * has a chance of occuring when a spell is being cast.
 * The name is an identifier
 * which can be used to remove the action with later.  The action
 * itself can be a string, then that command will be executed.  If
 * the action is a function pointer then it will be evaluated with
 * two arguments, the first being the caster, the second being the
 * target(s) array and the third being the magic arguments class.
 * <p>
 * If the action is an array, if it is one element then the function
 * specified will be called on the attacked with the same arguements
 * as above.  If the size of the array is two then the function will
 * be called on the specified object with an extra first argument being
 * the npc which the effect is being called from.
 * @param spell_object the spell to respond to
 * @param chance the chance of it working
 * @param name the name of the thing
 * @param action the action to preform
 */
void add_spell_action(string spell_object, int chance,
                     string name, mixed action) {
   if (!_spell_actions[spell_object]) {
      _spell_actions[spell_object] = ([ ]);
   }
   _spell_actions[spell_object][name] = ({ chance, action });
} /* add_spell_action() */

/**
 * This method removes the specified spell action.
 * @param name the name of the spell to remove
 * @return 1 if successful, 0 if not
 */
int remove_spell_action(string name) {
   string spell;
   mapping bits;
   int ret;

   foreach (spell, bits in _spell_actions) {
      if (bits[name]) {
         map_delete(bits, name);
         ret = 1;
      }
   }
   return ret;
} /* remove_spell_action() */

/**
 * This method returns the list of spell actions present on the
 * npc.
 * @return the list of spell actions
 */
mapping query_spell_actions() {
   return _spell_actions;
} /* query_spell_actions() */

/**
 * This method does a combat action.
 * @param caster the caster of the spell
 * @param targets the targets of the spell
 * @param action the action to do
 * @param args the spell arguements
 */
void do_spell_action( object caster,
                      object* targets,
                      mixed action,
                      mixed args ) {
   if ( stringp( action ) ) {
      do_command( action );
      return;
   }
   if (functionp(action)) {
      evaluate(action, caster, targets);
   }
   if ( pointerp(action) && sizeof(action) == 1 && stringp( action[ 0 ] ) ) {
      call_other( this_object(), action[ 0 ], caster, targets, args );
      return;
   }
   if (pointerp(action) && sizeof(action) == 2) {
      call_other( action[ 0 ], action[ 1 ], this_object(), caster, targets,
                  args );
   }
} /* do_spell_action() */


/**
 * This returns the race object associated with the npc.
 * @return the race object associated with the npc
 * @see set_race()
 * @see set_race_ob()
 * @see set_level()
 */
mixed query_race_ob() { return race_ob; }
/**
 * This method sets the race object associated with the npc.
 * This will probably not do what you expect and cannot be used
 * in conjucton with set_level to set the race.  It is called
 * by /std/race.c when set_level() is called.
 * @see set_level()
 * @see set_race()
 * @see /std/race.c
 * @param r the new race object
 */
void set_race_ob(mixed r) { race_ob = r; }

/**
 * This returns the guild object associated with the npc.
 * @return the guild object associated with the npc
 * @see set_guild()
 * @see set_guild_ob()
 * @see set_level()
 */
mixed query_guild_ob() { return guild_ob; }
/**
 * This method sets the guild object associated with the npc.
 * This will probably not do what you expect and cannot be used
 * in conjucton with set_level to set the guild.  It is called
 * by /std/race.c when set_level() is called.
 * @see set_level()
 * @see set_guild()
 * @see /std/race.c
 * @param g the new guild object
 */
void set_guild_ob(mixed g) { guild_ob = g; }

/**
 * This method queries the speed at which the npc will follow
 * after a player when they leave combat.
 * @return the current follow speed
 * @see set_follow_speed()
 */
int query_follow_speed() { return follow_speed; }
/**
 * This method sets the speed at which the npc will follow
 * after a player when they leave combat.
 * @return the current follow speed
 * @see set_follow_speed()
 */
void set_follow_speed(int f) { follow_speed = f; }

/**
 * This method returns the current aggressive level of the npc.
 * If the aggressive is set to 1, then the npc will attack all players
 * that enter its environment.  If the aggressive is set to 2 then
 * the npc will attack everything (including other npcs).
 * <p>
 * See the function start_attack() for information about things you
 * can do to stop aggressive npcs attacking things.
 * @return the aggressive level of the npc
 * @see set_aggressive()
 * @see start_attack()
 */
int query_aggressive() { return aggressive; }
/**
 * This method sets the current aggressive level of the npc.
 * If the aggressive is set to 1, then the npc will attack all players
 * that enter its environment.  If the aggressive is set to 2 then
 * the npc will attack everything (including other npcs).
 * <p>
 * See the function start_attack() for information about things you
 * can do to stop aggressive npcs attacking things.
 * @see query_aggressive()
 * @see start_attack()
 * @see set_join_fights()
 * @see set_throw_out()
 * @param a the new aggressive level
 */
void set_aggressive(int a) {
    aggressive = a;

    // this added to make aggressive npcs join in fights if they arent
    // already set that way. This is needed coz otherwise you can sneak
    // into a room and fight the aggressive npcs one at a time -- Ceres 10/97
    if (a && !join_fight_mess) {
        join_fight_mess = this_object()->one_short()+" joins in the fight.\n";
    }
}

/**
 * This method returns the current guild level of the npc.  This is
 * a pass through call to a function on the guild object associated
 * with this npc.
 * @return the current guild level of the object
 * @see set_guild()
 */
int query_level() {
    if (!guild_ob) return 1;
    return (int)guild_ob->query_level(this_object());
} /* query_level() */

/**
 * This method returns the amount of death experiecne that would be
 * gained by killing the npc.
 * @return the amount of death experience for the npc
 */
int query_death_xp() {
    int amount;

    if ( query_property( "dead" ) || query_property( "unique" ) ) {
        return 0;
    }
    amount = (int)TOP_TEN_HANDLER->calculate_rating( this_object() );
    //amount += (int)this_object()->query_max_hp();
    //amount *= 120;
    return amount / 2;
} /* query_death_xp() */

/** @ignore yes */
mixed *stats() {
    mixed *bing;
    int i;
    bing = ({ });
    for (i=0;i<sizeof(move_zones);i++)
        bing += ({ ({ "move zone "+i, move_zones[i] }) });
    if (!query_move_after())
        return ::stats() + ({
          ({ "guild", query_guild() }),
          ({ "guild ob", query_guild_ob() }),
          ({ "race", query_race() }),
          ({ "race ob", query_race_ob() }),
          ({ "join_fights", query_join_fights() }),
          ({ "follow speed", query_follow_speed() }),
          ({ "level", query_level() }),
          ({ "chat chance", query_chat_chance() }),
          ({ "achat chance", query_achat_chance() }),
          ({ "aggressive", query_aggressive() }),
          ({ "route", (sizeof(following_route)?implode(following_route, ", "):
              "not going anywhere") }),
        }) + bing;
    return ::stats() + ({
      ({ "race", query_race() }),
      ({ "race ob", query_race_ob() }),
      ({ "guild", query_guild() }),
      ({ "guild ob", query_guild_ob() }),
      ({ "join fights", query_join_fights() }),
      ({ "follow_speed", query_follow_speed() }),
      ({ "level", query_level() }),
      ({ "chat chance", query_chat_chance() }),
      ({ "achat chance", query_achat_chance() }),
      ({ "aggressive", query_aggressive() }),
      ({ "move after-fix", query_move_after()[0] }),
      ({ "move after-rand", query_move_after()[1] }),
      ({ "route", (sizeof(following_route)?implode(following_route, ", "):
          "not following anyone") }),
    }) + bing;
} /* stats() */

/** @ignore yes */
string expand_nickname(string str) { return str; }

/** @ignore yes */
void event_enter( object dest, string mess, object from ) {
    /* stop massive spam in /room/rubbish and /room/void */
    if( environment( this_object() ) &&
      file_name( environment( this_object() ) )[ 1 .. 4 ] == "room" )
        return;
    if(check_anyone_here() && (moves > 2)){
        moves = 0;
        do_move_after(0);
    }
    living::event_enter( dest, mess, from );
    events::event_enter( dest, mess, from );
} /* event_enter() */

/** @ignore yes */
void event_person_say( object thing, string start, string mess, string lang,
                       string accent) {
    response_mon::event_person_say(thing, start, mess, lang);
} /* event_person_say() */

/** @ignore yes */
void event_whisper( object thing, string start, string mess, object *obs,
  string lang, object me) {
    response_mon::event_whisper( thing, mess, obs, lang, me);
} /* event_whisper() */

/** @ignore yes */
varargs void event_soul( object thing, string mess, mixed avoid, string verb,
  string last, mixed at ) {
    response_mon::event_soul( thing, mess, avoid, verb, last, at );
    events::event_soul( thing, mess, avoid );
} /* event_soul() */

/**
 * This method moves the npc to room it is really supposed to be in.
 * This is used with the virtual moving
 * @param check_room the place where it thinks we are
 * @see query_virtual_move()
 */
void real_room( string check_room ) {
    if ( check_room == true_location ) {
        move_object( true_location );
    }
} /* real_room() */

/**
 * This method returns true if we are currently using the
 * virtual move system.
 * @return 1 if we are virtual moving, 0 if not
 * @see set_virtual_move()
 */
#if !efun_defined(add_action)
int query_virtual_move() { return virtual_move; }
#else
int query_virtual_move() { return 0; }
#endif
/**
 * This method sets the current virual move ability of the npc.
 * NB: This is currently disabled virtual moving is not possible
 * at all.
 * @param number 1 for virtual moving, 0 for not
 * @see query_virtual_move()
 */
void set_virtual_move( int number ) {
    if(virtual_move && !number && file_name(environment()) == "/room/virtual"){
        object ob = load_object(true_location);
        if(ob)
            move(ob);
    }
    virtual_move = number;
    if ( virtual_move && environment() )
        true_location = file_name( environment() );
} /* set_virtual_move() */

/**
 * This method returns the true location of the npc.  This is
 * the real room it is in, not the room it is currently in.
 * @return the true location of the npc
 * @see set_true_location()
 * @see set_virtual_move()
 */
string query_true_location() { return true_location; }

/**
 * This method sets the true location of the npc.  This is
 * the real room it is in, not the room it is currently in.
 * @param word the new true location of the npc
 * @see set_true_location()
 * @see set_virtual_move()
 */
void set_true_location( string word ) {
    if(word == "/room/virtual"){
        if(true_location)
            return;
        //we have to be somewhere!
        word = file_name(environment());
        if(word == "/room/virtual"){
            //something is totally wrong give up on the npc
            move("/room/rubbish");
            true_location = "/room/rubbish";
        }
    }
    true_location = word;
}

int cleaning_room() {
    if ( virtual_move ) {
        true_location = file_name( environment() );
        "/room/virtual"->force_load();
        move_object( "/room/virtual" );
        return 1;
    }
    return 0;
} /* cleaning_room() */

/**
 * This method causes the npc to move in the given direction.
 * @param move the direction to move
 */
void do_move( string move ) {
    if (1 || check_anyone_here()) {
        moves = 0;
    }
    if (moves++ < 3) {
        string tmp;
        command(move);
        tmp = file_name(environment());
        if(tmp == "/room/virtual")
            tmp = true_location; //room didn't let us in.
        true_location = tmp;
    } else {
        WANDER_HANDLER->delete_move_after(this_object());
    }
} /* do_move() */

/* Move along a nice route thingy... */
/**
 * This method gets the next direction to go in the route which is
 * currently being followed.  It will remove this direction off the
 * array.
 * @return the next direction to go down
 * @see query_last_route_direction()
 * @see query_following_route()
 * @see do_route_move()
 */
string get_next_route_direction() {
    string direc;

    if (!sizeof(following_route)) {
        return 0;
    }

    direc = following_route[0];
    following_route = following_route[1..];
    return direc;
} /* get_next_route_direction() */

/**
 * This method tells us if the npc is currently following a route.
 * @return 1 if there are route directions to follow still
 * @see get_next_route_direction()
 * @see query_following_route()
 * @see do_route_move()
 */
int query_last_route_direction() { return ( sizeof(following_route) ? 1 : 0 ); }

/**
 * This method returns the current array of directions we are following
 * as a route.
 * @see get_next_route_direction()
 * @see query_last_route_direction()
 * @see do_route_move()
 */
string *query_following_route() { return following_route; }

/**
 * This method moves the npc one more location along the route it
 * is following.
 * @see query_last_route_direction()
 * @see query_following_route()
 * @see get_next_route_direction()
 */
void do_route_move() {
    if (!sizeof(following_route)) {
        return ;
    }

    do_command(get_next_route_direction());
} /* do_route_move() */

/**
 * This method is called by the move_me_to function after the
 * route handler has successfuly discovered the route to follow.
 * @param route the route to follow
 * @param delay the delay to follow it with
 * @param dest route destination
 * @see move_me_to()
 */
protected void got_the_route(string *route, int delay, string dest) {
    following_route = route;
    if (sizeof(route)) {
        WANDER_HANDLER->move_me_please(delay, dest);
        do_route_move();
    } else {
        this_object()->stopped_route();
    }
} /* got_the_route() */

/**
 * This method will move the npc to the specified destination.  The
 * npc will walk from where they currently are to the destination using
 * the time delay specified between the movements.
 * <p>
 * If the location is reached then the function "stopped_route" will
 * be called on the npc.  The first arguement to the function will
 * be 0 if the npc did not reach its destination and 1 if it did.
 * @param dest the destination to go to
 * @param delay the time delay between each move
 * @example
 * inherit "/obj/monster";
 *
 * void go_home() {
 *    move_me_to(HOME_LOCATION, 2);
 * } /\* go_home() *\/
 *
 * void stopped_route(int success) {
 *    if (success) {
 *       do_command("emote jumps for joy.");
 *    } else {
 *       do_command("emote looks sad and lost.");
 *    }
 * } /\* stopped_route() *\/
 * @see get_next_route_direction()
 * @see got_the_route()
 * @see query_last_route_direction()
 * @see query_following_route()
 * @see do_route_move()
 */
varargs void move_me_to(string dest, int delay) {
    string *dest_dir, *start_dir;

    if (!environment() || !file_name(environment()))
        return ;
    if(!delay)
      delay = 10;
    
    if (!MAP->static_query_short( dest ) ||
      !MAP->static_query_short( file_name(environment()) ) ) {
        //very likely to have no route
       if (!sizeof( dest_dir = dest->query_dest_dir( this_object() ) ) ||
           !sizeof( start_dir = 
               environment()->query_dest_dir( this_object() ) ) )
       {
            //one of the rooms have no exits
            move( dest, "$N wanders in.\n", "$N wanders off.\n" );
        } else {
            //both rooms have exits
            move( dest,
              replace_string( query_msgin(), "$F",
                dest_dir[random(sizeof(dest_dir)/2)*2]),
              replace_string( query_msgout(), "$T",
                start_dir[random(sizeof(start_dir)/2)*2]));
        }
        call_out( "stopped_route", 1 );
        return;
    }

    ROUTE_HANDLER->get_route(dest, file_name(environment()),
      (: got_the_route($1, $(delay), $(dest)) :));
} /* move_me_to() */

/** @ignore yes */
string identify( object thing, object *places ) {
    do_command( "'Please bug me!  I'm using identify()!" );
    return file_name( thing );
} /* identify() */

/** @ignore yes */
int query_time_left() { return 1; }

/** @ignore yes */
int ignore_identifier() { return 1; }

/**
 * This method adds a language to the npc. 
 * <p>
 * After the sun has died away<br>
 * The stars come out and glow<br>
 * Lighting the embers of good intentions<br>
 * Ghostly white, unhappily bright<br>
 * Time lost, the day done
 * @param str the language to add
 */
void add_language(string str) {
    ::add_language(str);
    added_language = 1;
} /* add_language() */

/**
 * This method sets the value of the unable to change position flag.
 * This flag will be checked by the soul, and by anything else which
 * deliberatly changes someones position.
 * @param flag the unable to change position flag
 * @see /std/living/living->set_default_position()
 */
void set_cannot_change_position(int flag) {
    cannot_change_position = flag;
} /* set_cannot_change_position() */

/**
 * This method returns the current value of the unable to change
 * position flag.
 * @return the unable to change position flag
 * @see /std/living/living->set_default_position()
 */
int query_cannot_change_position() {
    return cannot_change_position;
} /* query_cannot_change_position() */

/**
 * This method overrides the position code so that if the position
 * is changed we are changed back to the default position.
 * @param new_pos the new position
 * @ignore yes
 */
void set_position(string new_pos) {
    if (always_return_to_default_position) {
        if (new_pos != query_position() &&
          this_player() != this_object()) {
          // Please, do NOT use function pointers unless it's necessary.
          // Took me ages to find this "function" given that all
          // call_stack could tell me was that it was "<function>"
            call_out("return_to_default_position",
              always_return_to_default_position, 0);
        }
    }
    ::set_position(new_pos);
} /* set_position() */

/**
 * This method sets the status of the flag that makes the npc return
 * to the default position if its position is changed.  The flag
 * specified the length of time to wait before causing the
 * default position to be restored.
 * @param tim the time to wait before the position is restored
 * @see /std/living/living->return_to_default_position()
 * @see query_always_return_to_default_position()
 */
void set_always_return_to_default_position(int tim) {
    always_return_to_default_position = tim;
} /* set_always_return_to_default_position() */

/**
 * This method returns the status of the flag that makes the npc return
 * to the default position if its position is changed.  The flag
 * specified the length of time to wait before causing the
 * default position to be restored.
 * @return the time to wait before the position is restored
 * @see /std/living/living->return_to_default_position()
 * @see set_always_return_to_default_position()
 */
int query_always_return_to_default_position() {
    return always_return_to_default_position;
} /* query_always_return_to_default_position() */

/** @ignore yes */
mapping int_query_static_auto_load() {
    return ([
      "::" : ::int_query_static_auto_load(),
      "cap name" : cap_name,
      "race" : race,
      "guild" : guild,
    ]);
}

/** @ignore yes */
mixed query_static_auto_load() {
    if ( base_name(this_object()) + ".c" == __FILE__ )
        return int_query_static_auto_load();
    return ([ ]);
}

mapping query_dynamic_auto_load() {
    return ([
      "::" : ::query_dynamic_auto_load(),
      "chat string"                       : chat_string,
      "achat string"                      : achat_string,
      "combat actions"                    : _combat_actions,
      "move after"                        : _move_after,
      "throw out"                         : throw_out,
      "chat chance"                       : chat_chance,
      "achat chance"                      : achat_chance,
      "aggressive"                        : aggressive,
      "join fight type"                   : join_fight_type,
      "join fight mess"                   : join_fight_mess,
      "follow speed"                      : follow_speed,
      "virtual move"                      : virtual_move,
      "moves"                             : moves,
      "true location"                     : true_location,
      "enter commands"                    : enter_commands,
      "move zones"                        : move_zones,
      "doing story"                       : doing_story,
      "last attacked"                     : last_attacked,
      "following route"                   : following_route,
      "added language"                    : added_language,
      "cannot change position"            : cannot_change_position,
      "always return to default position" : always_return_to_default_position,
      "level"                             : query_level(),
    ]);
}

void init_static_arg(mapping args) {
    if (args["::"])
        ::init_static_arg(args["::"]);
    if (!undefinedp(args["cap name"]))
        cap_name = args["cap name"];
    if (!undefinedp(args["race"]))
        race = args["race"];
    if (!undefinedp(args["guild"]))
        guild = args["guild"];
}

void init_dynamic_arg( mapping args, object ob ) {
    if (args["::"])
        ::init_static_arg(args["::"]);
    if (!undefinedp(args["chat string"]))
        chat_string = args["chat string"];
    if (!undefinedp(args["achat string"]))
        achat_string = args["achat string"];
    if (!undefinedp(args["combat actions"]))
        _combat_actions = args["combat actions"];
    if (!undefinedp(args["move after"]))
        _move_after = args["move after"];
    if (!undefinedp(args["throw out"]))
        throw_out = args["throw out"];
    if (!undefinedp(args["chat chance"]))
        chat_chance = args["chat chance"];
    if (!undefinedp(args["achat chance"]))
        achat_chance = args["achat chance"];
    if (!undefinedp(args["aggressive"]))
        aggressive = args["aggressive"];
    if (!undefinedp(args["join fight type"]))
        join_fight_type = args["join fight type"];
    if (!undefinedp(args["join fight mess"]))
        join_fight_mess = args["join fight mess"];
    if (!undefinedp(args["follow speed"]))
        follow_speed = args["follow speed"];
    if (!undefinedp(args["virtual move"]))
        virtual_move = args["virtual move"];
    if (!undefinedp(args["moves"]))
        moves = args["moves"];
    if (!undefinedp(args["true location"]))
        true_location = args["true location"];
    if (!undefinedp(args["enter commands"]))
        enter_commands = args["enter commands"];
    if (!undefinedp(args["move zones"]))
        move_zones = args["move zones"];
    if (!undefinedp(args["doing story"]))
        doing_story = args["doing story"];
    if (!undefinedp(args["last attacked"]))
        last_attacked = args["last attacked"];
    if (!undefinedp(args["following route"]))
        following_route = args["following route"];
    if (!undefinedp(args["added language"]))
        added_language = args["added language"];
    if (!undefinedp(args["cannot change position"]))
        cannot_change_position = args["cannot change position"];
    if (!undefinedp(args["always return to default position"]))
        always_return_to_default_position =
        args["always return to default position"];
    if (!undefinedp(args["level"]))
        set_level(args["level"]);
}
/**
 *
 * attack_permission function, added for use by the allow_attack simul.
 * @param object The person performing the action
 * @param object The object being acted on, this object usually.
 * @param string Attack type, this will be one of "combat", "theft", or "magic",
 * this lets you give your NPCs different responses for different attacks. As well
 * as make them immune to theft and magic (as an example)
 * @return int 1 if the action is denied, 0 is it can go through.
 * @see efun::allow_attack()

 */
int attack_permission( object ob1, object ob2, string stringy ) { return 0; }

#if !efun_defined(add_action)
/** @ignore yes */
protected mixed _process_input(string str) {
    object ob = this_player();
    if(str == "")
        return 0;
    _notify_fail(0);
    efun::set_this_player(this_object());
    if(!this_object()->drunk_check(str))
        if(!this_object()->exit_command(str))
            if(!this_object()->cmdAll(str))
                if(!this_object()->new_parser(str))
                    if(!this_object()->lower_check(str)){
                        efun::set_this_player(ob);
                        return 0;
                    }
    efun::set_this_player(ob);
    return "bing";
} /* _process_input() */

int drunk_check(string str) {
   if(cmd_func){
     object owner = function_owner(cmd_func);
     if(owner && owner == environment(this_player())){
       int res = evaluate(cmd_func, str);
       if(res)
         return res;
     } else cmd_func = 0;
   }

   return 0;
} /* drunk_check() */

/**
 * Use this function to set a function that is called with the NPCs input
 * before command() gets it, return 1 from the function if the
 * input needs no further parsing (ie the command is handled)
 *
 * @param func = function in the players environment to call.
 */

void command_override(function func) {
  if(!functionp(func))
    error("command_override needs a function!");
  cmd_func = func;
}


/** @ignore yes */
protected mixed command(string cmd){
  int time = eval_cost();
  if(_process_input(cmd))
    return eval_cost() - time + 1; // on v22.2 eval_cost runs up, reverse for v22.1
  return 0;
}

#endif

/** @ignore yes */
int _living(){return 1;}


/**
 * This event is triggered when hide_invis is added or removed from an
 * object.  In this case it's used to make the NPC attack if someone
 * sneaks into the room and comes out of hiding.
 * @param hider The person who's hiding/unhiding.
 * @param adding 1 if the person is hiding, 0 if they are coming out.
 * @param type The type of hide invis.
 * @param quiet The quiet flag that's passed into remove_hide_invis.
 */
void event_hide_invis( object hider, int adding, string type, int quiet ) {
   if ( aggressive &&
        !adding &&
        environment() &&
        file_name( environment() )[1..4] != "room" )
   {
      start_attack(hider);
   }
} /* event_hide_invis() */
// --- END [/mnt/home2/grok/lib/obj/monster.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/potions/potion.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/potions/potion.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628639   Available: 13575993
Inodes: Total: 5242880    Free: 4960135
5112 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/potions/potion.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628639   Available: 13575993
Inodes: Total: 5242880    Free: 4960135
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*
** potion.c - potion information object
**
** This object will contain the information related to a particular
** potion.  It is intended to be used as a base for virtual objects
** which will be cloned by the potion handler (ie, only one virtual
** object for each potion will exist in the game).  The info on the
** potion will be gotten by querying the potion handler.
**
** Parameters:
**    min_level - minimum aggregate level for success
**    max_level - aggregate level at which success is certain
**    advance_chance - chance of advancing skill(s) when successful
**    backfire_chance - chance of result being other than expected
**    rel_strength - amount of reagent will be
**                   aggregate_sum*rel_strength/min_level
**    skills - array of skills required and weighting
**    reagent_alias - medium alias for resulting reagent (on success)
**    backfire_alias - medium alias for resulting reagent (on backfire)
**    potion_verb - verb expected for this potion (eg, 'mix', 'brew')
**    recipe - the text of the recipe for the potion
**    chant - the chant spoken by the player (optional)
**
** Written by Jeremy, ?/?/95
*/

// I'm wondering if I really need this...
inherit "/std/object";

#include <tasks.h>

#define SKILL_WGT 0
#define SKILL_MAX 1
#define SKILL_LVL 2
#define SKILL_ADV 3
#define REAGENTS "/obj/reagents/"

int min_level, max_level, advance_chance, backfire_chance, rel_strength;
mapping skills = allocate_mapping(1);
string *skill_str, reagent_alias, backfire_alias, potion_verb, recipe;
string chant;

void set_min_level(int l) { min_level = l; }

void set_max_level(int l) { max_level = l; }

int query_min_level() { return min_level; }

int query_max_level() { return max_level; }

void set_advance_chance(int c) { advance_chance = c; }

int query_advance_chance() { return advance_chance; }

void set_backfire_chance(int c) { backfire_chance = c; }

int query_backfire_chance() { return backfire_chance; }

void set_reagent_alias(string s) { reagent_alias = s; }

string query_reagent_alias() { return reagent_alias; }

void set_backfire_alias(string s) { backfire_alias = s; }

string query_backfire_alias() { return backfire_alias; }

void set_rel_strength(int s) { rel_strength = s; }

int query_rel_strength() { return rel_strength; }

void set_potion_verb(string s) { potion_verb = s; }

string query_potion_verb() { return potion_verb; }

void set_recipe(string s) { recipe = s; }

string query_recipe() { return recipe; }

void set_chant(string s) { chant = s; }

string query_chant() { return chant; }

// The final determination of success/failure is a weighted sum of
// one or more skill levels or bonuses.  Each element of 's' is a
// 4-element array: the skill (string), the weight (int), and whether to use
// level or bonus (true=level).  'skills' is a mapping, with the key
// being the skill and the value being a 4-element array: the remaining
// 3 and a flag indicating if the skill should be advanced for this player.

void set_skills(mixed s) {
    int i;

    for (i = 0; i < (sizeof(s)); i++) {
        skills[s[i][0]] = ({s[i][SKILL_WGT+1], s[i][SKILL_MAX+1],
                            s[i][SKILL_LVL+1], 0});
    }
    skill_str = keys(skills);
}

mapping query_skills() { return skills; }

// This is the guts of the potion.  If successful, it'll return an
// object that'll react with the other reagents in the vessel.

object clone_reagent(string given_verb) {
    int result, i, sum, x;
    string s;
    object ob;

    if (potion_verb != given_verb) return 0;
    for (i = 0; i < sizeof(skill_str); i++) {
        s = skill_str[i];
        skills[s][SKILL_ADV] = 0;
        if (skills[s][SKILL_LVL]) {
            if ((x = (int)this_player()->query_skill(s))
                > skills[s][SKILL_MAX]) {
                x = skills[s][SKILL_MAX];
            } else {
                skills[s][SKILL_ADV] = 1;
            }
        } else {
            if ((x = (int)this_player()->query_skill_bonus(s))
                > skills[s][SKILL_MAX]) {
                x = skills[s][SKILL_MAX];
            } else {
                skills[s][SKILL_ADV] = 1;
            }
        }
        sum += x * skills[s][SKILL_WGT];
    }
    //write("sum = " + sum + "\n");
    result = TASKER->attempt_task(min_level, sum, advance_chance,
                          (max_level - min_level));
    if ((result == FAIL) || (result == BARF)) {
        if (random(100) < backfire_chance) {
            // Spell backfired
            ob = clone_object(REAGENTS+"brew_reagent.ob");
            ob->set_medium_alias(backfire_alias);
            ob->set_amount(sum*rel_strength/min_level);
            return ob;
        }           
        return 0;
    }
    if (result == AWARD) {
        for (i = 0; i < sizeof(skill_str); i++) {
            s = skill_str[i];
            if (skills[s][SKILL_ADV]) {
                this_player()->add_skill_level(s, 1, 0);
            }
        }
    }
    ob = clone_object(REAGENTS+"brew_reagent.ob");
    ob->set_medium_alias(reagent_alias);
    ob->set_amount(sum*rel_strength/min_level);
    return ob;
}
// --- END [/mnt/home2/grok/lib/obj/potions/potion.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/gatherable.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/gatherable.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628638   Available: 13575992
Inodes: Total: 5242880    Free: 4960135
1660 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/gatherable.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628638   Available: 13575992
Inodes: Total: 5242880    Free: 4960135
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: gatherable.c,v 1.2 2000/06/23 03:40:56 pinkfish Exp $
 * $Log: gatherable.c,v $
 * Revision 1.2  2000/06/23 03:40:56  pinkfish
 * Fix up the references to find_match.
 *
 * Revision 1.1  1998/01/06 04:58:17  ceres
 * Initial revision
 * 
*/
/*
 * gatherable - a base for adding "gatherable" items to a room.  This object
 *    simply allows the gathering handler to use find_match(), which makes
 *    handling aliases easier.  Generally, these would be hidden
 *    objects in a room, with add_alias() and add_adjective() used to
 *    distinguish between them.  The long() can be changed to something
 *    more descriptive if the item is in plain sight (ie, it doesn't
 *    require skill to find).
 */

#include <parse_command.h>

inherit "/std/object";

string item_name;   // Name in gathering handler
int scarcity;       // percent chance of it being in this room
string get_failure_mess = "Use \"gather\"\n";

void create() {
    ::create();
    reset_get();
}

void set_item_name(string name) { item_name = name; }

string query_item_name() { return item_name; }

void set_scarcity(int s) { scarcity = s; }

int query_scarcity() { return scarcity; }

void set_get_failure_mess(string s) { get_failure_mess = s; }

int do_get() {
    // This is to keep someone from trying to get the hidden gatherable.
    return notify_fail( get_failure_mess );
}

/*
string *parse_command_id_list() {
    // Learned recognition would probably go in here
    return ::parse_command_id_list();
}

object query_parse_id( mixed *args ) {
    //printf("parse_id args = %O\n", args);
    return ::query_parse_id( args );
}
*/
// --- END [/mnt/home2/grok/lib/obj/gatherable.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/virtual_room.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/virtual_room.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628637   Available: 13575991
Inodes: Total: 5242880    Free: 4960135
3745 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/virtual_room.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628637   Available: 13575991
Inodes: Total: 5242880    Free: 4960135
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: virtual_room.c,v 1.1 1998/01/06 04:58:17 ceres Exp $
 * $Log: virtual_room.c,v $
 * Revision 1.1  1998/01/06 04:58:17  ceres
 * Initial revision
 * 
*/
/* Base class for virtual rooms
 * Has additional functions to handle the creation of objects
 * and npc's in the room.
 * 
 * reset_objects is an array of the objects 
 * reset_definitions is an array of the definitions of how these objects
 * should be cloned
 * the value of a reset definition is an array containig the following:
 *   ({ flag, delay, clone_info, entry_mess })
 * flag can be REMOVABLE, FIXED or UNIQUE defining whether a new item
 *   should be cloned if this one is removed from the room, only cloned if
 *   this one is destructed, or as fixed, but it's the master objects that's
 *   put here(mainly for unique npc's with their own file).
 * delay is the delay in seconds between reset being called and the cloning  
 * clone_info can be a string, in which case it's considered to be the
 *   filename of the thing to put here, or a function pointer meaning
 *   it's a function returning the thing.
 * entry_mess is the parameter given to move when moving the item to this 
 *   room.
 */

inherit "/std/room";

#include <virtual_room.h>

nosave mixed  *reset_definitions;
nosave object *reset_objects;

void add_cloned_object( int flag, int delay, mixed clone_info, 
                       string entry_mess ) {
   if ( functionp( clone_info ) )
      clone_info = bind( clone_info, this_object() );
   if ( !sizeof( reset_definitions ) )
      reset_definitions = ({ ({ flag, delay, clone_info, entry_mess }) });
   else
      reset_definitions += ({ ({ flag, delay, clone_info, entry_mess }) });
} /* add_cloned_object() */

mixed *query_cloned_objects() {
   return reset_objects + ({ });
} /* query_cloned_objects() */

mixed *query_cloned_definitions() {
   return reset_definitions + ({ });
} /* query_cloned_definitions() */

private object make_clone( mixed func ) {
   if ( stringp( func ) ) {
      return clone_object( func );
   } else if ( functionp( func ) ) {
      return evaluate( func );
   } else
      return 0;
} /* make_clone() */

protected void make_object( int i ) {
   switch ( reset_definitions[ i ][ FLAG ] ) {
    case REMOVABLE:
    case FIXED:
      reset_objects[ i ] = make_clone( reset_definitions[ i ][ CLONE ] );
      reset_objects[ i ]->move( this_object(),
            reset_definitions[ i ][ MESS ] );
      break;
    case UNIQUE:
      if ( !stringp( reset_definitions[ i ][ CLONE ] ) )
         return;
      reset_definitions[ i ][ CLONE ]->move( this_object(),
            reset_definitions[ i ][ MESS ] );
      reset_objects[ i ] = find_object( reset_definitions[ i ][ CLONE ] );
   }
} /* make_object() */

void reset() {
   int i;
   
   if ( !sizeof( reset_definitions ) )
      return;
   if ( !sizeof( reset_objects ) )
      reset_objects = allocate( sizeof( reset_definitions ) );
   for ( i = sizeof( reset_definitions ); i--; ) {
      switch ( reset_definitions[ i ][ FLAG ] ) {
       case REMOVABLE:
         if ( !reset_objects[ i ] || 
             ( environment( reset_objects[ i ] ) != this_object() ) ) {
            if ( reset_definitions[ i ][ DELAY ] >= 0 ) {
               call_out( "make_object", reset_definitions[ i ][ DELAY ], i );
            } else {
               make_object( i );
            }
         }
         break;
       case FIXED:
       case UNIQUE:
         if ( !reset_objects[ i ] ) {
            if ( reset_definitions[ i ][ DELAY ] >= 0 ) {
               call_out( "make_object", reset_definitions[ i ][ DELAY ], i );
            } else {
               make_object( i );
            }
         }
      }
   }
} /* reset() */
// --- END [/mnt/home2/grok/lib/obj/virtual_room.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/ring.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/ring.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628636   Available: 13575990
Inodes: Total: 5242880    Free: 4960135
3469 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/ring.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628636   Available: 13575990
Inodes: Total: 5242880    Free: 4960135
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: ring.c,v 1.4 2001/06/01 21:14:59 ceres Exp $
 * $Log: ring.c,v $
 * Revision 1.4  2001/06/01 21:14:59  ceres
 * Can't remember
 *
 * Revision 1.3  1999/10/09 19:31:42  taffyd
 * Added jewellery alias.
 *
 * Revision 1.2  1999/04/06 00:28:22  ceres
 * Modified to use perform_task
 *
 * Revision 1.1  1998/01/06 04:58:17  ceres
 * Initial revision
 * 
*/
#include <artifacts.h>
#include <tasks.h>

inherit "/obj/armour";
inherit "/std/basic/artifact";

int query_magic_ring() { return 1; }

void create() {
   ::create();
   set_type( "ring" );
   set_damage_chance( 8 );
   set_artifact_type( "ring" );
   add_property( "shop type", "jewellers" );
   add_alias( "jewellery" );
   add_plural("jewellery");
} /* create() */

void set_weight( int number ) {
   armour::set_weight( number );
   setup_armour( 250 * number );
   add_ac( "blunt", "blunt", 5 * weight );
   add_ac( "sharp", "sharp", 2 * weight );
} /* set_weight() */

string long( int word, int dark ) {
  return artifact::long( word, dark ) + armour::long( word, dark );
} /* long() */

void init() {
  this_player()->add_command( "twist", this_object() );
} /* init() */

int do_twist() {
  int outcome;
  if ( query_worn_by() != this_player() ) {
    this_player()->add_failed_mess( this_object(), "You must be "+
        "wearing $D to $V it.\n", ({ }) );
    return 0;
  }

  outcome = (int)TASKER->perform_task(this_player(), RING_SKILL,
                                      level, TM_FREE);
  if ( outcome == FAIL ) {
    this_player()->add_failed_mess( this_object(), "You failed "+
        "to use $D.\n", ({ }) );
    return 0;
  }
  if ( !charges ) {
    this_player()->add_failed_mess( this_object(), "It appears that there "+
        "are no charges in $D.\n", ({ }) );
    return 0;
  }
  if ( outcome == AWARD ) {
    write( "%^YELLOW%^" +
          ({ "A piece of lore concerning rings becomes clearer for "+
        "you.\n", "You manage to grasp one of the principles of magic "+
        "rings more firmly.\n", "A sudden flash of insight allows you "+
        "to understand the ring a little better.\n" })[ random( 3 ) ] +
          "%^RESET%^");
  }
  charges--;
  if ( random( 100 ) < level / 10 ) {
    if ( !zapper->failed_zap( 0, this_player(), this_object() ) )
      this_player()->add_succeeded_mess( this_object(), "$N $V $D but "+
          "nothing happens!\n", ({ }) );
    return 1;
  }
  zapper->zap( 0, this_player(), this_object() );
  return 1;
} /* do_zap() */

mixed *stats() {
  return armour::stats() + artifact::stats();
} /* stats() */

mapping query_dynamic_auto_load() {
  return ([
    "::" : armour::query_dynamic_auto_load(),
    "artifact" : artifact::query_dynamic_auto_load(),
  ]);
} /* query_dynamic_auto_load() */

mapping query_static_auto_load() {
  if ( explode( file_name( this_object() ), "#" )[ 0 ] != "/obj/ring" )
    return ([ ]);
  return ([
    "::" : int_query_static_auto_load(),
    "artifact" : artifact::query_static_auto_load(),
  ]);
} /* query_static_auto_load() */

void init_dynamic_arg( mapping map ) {
  if ( map[ "::" ] )
    armour::init_dynamic_arg( map[ "::" ] );
  if ( map[ "artifact" ] )
    artifact::init_dynamic_arg( map[ "artifact" ] );
} /* init_dynamic_arg() */

void init_static_arg( mapping map ) {
  if ( map[ "::" ] )
    armour::init_static_arg( map[ "::" ] );
  if ( map[ "artifact" ] )
    artifact::init_static_arg( map[ "artifact" ] );
} /* init_static_arg() */
// --- END [/mnt/home2/grok/lib/obj/ring.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/salve.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/salve.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628635   Available: 13575989
Inodes: Total: 5242880    Free: 4960135
3921 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/salve.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628635   Available: 13575989
Inodes: Total: 5242880    Free: 4960135
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: salve.c,v 1.4 2001/07/07 16:40:40 tannah Exp $
 * $Log: salve.c,v $
 * Revision 1.4  2001/07/07 16:40:40  tannah
 * removed the ([]) argument passed to int_query_static_auto_load() in
 * query_static_auto_load() so that it would compile.
 *
 * Revision 1.3  2001/03/18 17:40:02  tannah
 * changed %D to <direct:object>, %I to <indirect:object>.
 *
 * Revision 1.2  2000/07/14 22:08:51  pinkfish
 * Fix up to not use global variables from inherits
 *
 * Revision 1.1  1998/01/06 04:58:17  ceres
 * Initial revision
 * 
*/
#include <drinks.h>

inherit "/obj/food";

mapping apply_effects;

void create() {
  do_setup++;
  ::create();
  do_setup--;
  apply_effects = ([ ]);
  if ( !do_setup )
    this_object()->setup();
} /* create() */

void init() {
  this_player()->add_command( "apply", this_object(), "<direct:object> to <indirect:object>");
} /* init() */

mapping query_apply_effects() { return apply_effects; }
void set_apply_effects( mapping map ) { apply_effects = map; }

int add_apply_effect( string word, int number ) {
  if ( apply_effects[ word ] )
    apply_effects[ word ] += number;
  else
    apply_effects[ word ] = number;
  return apply_effects[ word ];
} /* add_apply_effect() */

void remove_apply_effect( string word ) {
  if ( !undefinedp( apply_effects[ word ] ) )
    apply_effects = m_delete( apply_effects, word );
} /* remove_apply_effect() */

void being_joined_by( object thing ) {
  int i, that, this;
  string *words;
  mapping new_effects;
  that = (int)thing->query_amount();
  this = query_amount();
  if ( !( this + that ) )
    return;
  new_effects = (mapping)thing->query_apply_effects();
/*
 * If new_effects isn't a mapping, then there's something wrong, so it
 *     should give an error so that someone knows and can get it fixed.
 */
  words = m_indices( apply_effects );
  for ( i = 0; i < sizeof( words ); i++ )
    if ( new_effects[ words[ i ] ] ) {
      new_effects[ words[ i ] ] *= that;
      new_effects[ words[ i ] ] += this * apply_effects[ words[ i ] ];
    } else
      new_effects[ words[ i ] ] = this * apply_effects[ words[ i ] ];
  words = m_indices( new_effects );
  for ( i = 0; i < sizeof( words ); i++ )
    new_effects[ words[ i ] ] /= this + that;
  apply_effects = new_effects;
} /* being_joined_by() */

int do_apply(object *indir, string dir_s, string indir_s, mixed *args) {
    string *words;
    int i;

    if (environment(this_object()) != this_player()) {
        write("You aren't holding the " + dir_s + ".\n");
        return 0;
    }
    if (sizeof(indir) != 1) {
        // Maybe I'll let it do multiple items some day...
        write("You can only " + query_verb() + " to one thing at a time.\n");
        return 0;
    }
    if (living(indir[0])) {
        words = m_indices( apply_effects );
        for (i = 0; i < sizeof(words); i++) {
            indir[0]->add_effect(words[i], apply_effects[words[i]] * query_amount());
        }
    }
    this_player()->add_succeeded(indir[0]);
    move("/room/rubbish");
    return 1;
}

mapping query_static_auto_load() {
  if ( ( explode( file_name( this_object() ), "#" )[ 0 ] != "/obj/salve" )
      && !query_continuous() )
    return 0;
return int_query_static_auto_load();
} /* query_static_auto_load() */

mapping query_dynamic_auto_load() {
  return ([
    "::" : ::query_dynamic_auto_load(),
    "apply_effects" : apply_effects + ([ ]),
  ]);
} /* query_dynamic_auto_load() */

void init_dynamic_arg( mapping map ) {
  if ( map[ "::" ] )
    ::init_dynamic_arg( map[ "::" ] );
  apply_effects = map[ "apply_effects" ];
} /* init_dynamic_arg() */

mixed *stats() {
  int i;
  string *words;
  mixed *args;
  args = ::stats();
  words = m_indices( apply_effects );
  for ( i = 0; i < sizeof( words ); i++ )
    args += ({ ({ "apply effect#"+ i, words[ i ] +" ("+
        apply_effects[ words[ i ] ] +")" }) });
  return args;
} /* stats() */
// --- END [/mnt/home2/grok/lib/obj/salve.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/roommak.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/roommak.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628634   Available: 13575988
Inodes: Total: 5242880    Free: 4960135
1349 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/roommak.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628634   Available: 13575988
Inodes: Total: 5242880    Free: 4960135
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: roommak.c,v 1.1 1998/01/06 04:58:17 ceres Exp $
 * $Log: roommak.c,v $
 * Revision 1.1  1998/01/06 04:58:17  ceres
 * Initial revision
 * 
*/
/*
 * Room maker.  Pinkfish version.
 * Started 2-10-92.
 * Version 0.01
 */
inherit "/std/object";

mixed *exits,
      *items;
string de_long,
       de_short;
int de_light;

void setup() {
  set_name("maker");
  add_adjective("room");
  set_short("Room maker");
  set_long("It is a small wooden rod about 30 centimeters long with deep "+
           "burn marks along the sides.  It has what looks like a small "+
           "lens stuck in the end and three buttons along its length.\n");
}

void init() {
  if (this_player()->query_creator()) {
    add_action("do_new", "new"); /* Creates a new room */
    add_action("do_set", "set");   /* Allows you to seperately set things */
    add_action("do_add", "add");   /* Adds things.  ie doors etc */
    add_action("do_setup", "setup"); /* Sets up a bunch of default things. */
    add_action("do_modify", "modify"); /* Changes things :) */
    add_action("do_map", "map");   /* Draws a nice little map */
  }
}

/*
 * Examples of usage:
 * new bing
 * set short
 * set long
 * add exit
 * modify exit
 */

int do_new(string str) {
  if (!str) {
    notify_fail("Syntax: new <name>\n");
    return 0;
  }
  
}
// --- END [/mnt/home2/grok/lib/obj/roommak.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/fungi/rust_fungus.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/fungi/rust_fungus.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628633   Available: 13575987
Inodes: Total: 5242880    Free: 4960135
642 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/fungi/rust_fungus.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628633   Available: 13575987
Inodes: Total: 5242880    Free: 4960135
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/obj/fungus";

void setup() {
  set_adjs( "rust" );
  set_type( "fungus" );
  set_extra( "It looks like a lump of rust, only soft and a bit squishy." );
  set_messages( ({
    "A small $type$ sprouts on the metal.\n",
    "The $type$ seems to be a bit larger now.\n",
    "The $type$ looks nice and large now.\n",
    "The $type$ silently releases a red dust into the air.\n",
    "The $type$ collapses in on itself and falls apart.\n"
  }) );
} /* setup() */

void next_stage() {
  if ( stage == 8 )
    add_eat_effect( "/std/effects/ingested/strength_boost", 2000 +
        random( 1000 ) );
  ::next_stage();
} /* next_stage() */
// --- END [/mnt/home2/grok/lib/obj/fungi/rust_fungus.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/fungi/glow_toadstool.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/fungi/glow_toadstool.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628633   Available: 13575987
Inodes: Total: 5242880    Free: 4960135
401 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/fungi/glow_toadstool.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628633   Available: 13575987
Inodes: Total: 5242880    Free: 4960135
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/obj/fungus";

void setup() {
  set_adjs( "yellow spotted" );
  set_type( "toadstool" );
  set_extra( 0 );
} /* setup() */

void next_stage() {
  if ( stage == 8 ) {
    tell_room( environment(), "The yellow spots on the toadstool begin to "+
        "glow.\n" );
    set_light( 5 );
    set_long( query_long() +"The yellow spots are glowing.\n" );
  }
  ::next_stage();
} /* next_stage() */
// --- END [/mnt/home2/grok/lib/obj/fungi/glow_toadstool.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/fungi/fire_mushroom.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/fungi/fire_mushroom.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628633   Available: 13575987
Inodes: Total: 5242880    Free: 4960135
1279 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/fungi/fire_mushroom.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628633   Available: 13575987
Inodes: Total: 5242880    Free: 4960135
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/obj/fungus";

void setup() {
  set_adjs( "red stalked" );
  set_type( "mushroom" );
  set_extra( "It seems to be gently smoking." );
  set_messages( ({
    "A small $type$ pushes up through the soil.\n",
    "The $type$ seems to be a bit larger now.\n",
    "The $type$ looks nice and large now.\n",
    "The $type$ swells and suddenly releases a cloud of smoke.\n",
    "There is a flash at the base of the $type$ and with a small roar, it "+
        "rockets into the sky.\n"
  }) );
} /* setup() */

void next_stage() {
  if ( stage == 8 )
    add_eat_effect( "/std/effects/ingested/basic_charging", 20 +
        random( 11 ) );
  ::next_stage();
} /* next_stage() */

int query_charging_power() {
  int denominator, numerator, wholes;
  mapping eat_effects;

  eat_effects = query_eat_effects();
  
  if ( !query_continuous() )
    return eat_effects[ "/std/effects/ingested/basic_charging" ] *
      (int)this_object()->query_weight();
  denominator = query_weight_unit()[ 1 ];
  numerator = eat_effects[ "/std/effects/ingested/basic_charging" ] *
    query_amount() * query_weight_unit()[ 0 ];
  wholes = numerator / denominator;
  numerator %= denominator;
  if ( random( denominator ) < numerator )
    wholes++;
  return wholes;
} /* query_charging_power() */
// --- END [/mnt/home2/grok/lib/obj/fungi/fire_mushroom.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/fungi/magic_mushroom.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/fungi/magic_mushroom.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628632   Available: 13575986
Inodes: Total: 5242880    Free: 4960135
705 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/fungi/magic_mushroom.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628632   Available: 13575986
Inodes: Total: 5242880    Free: 4960135
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/obj/fungus";

void setup() {
  set_adjs( "checkered" );
  set_type( "mushroom" );
  set_extra( "The checks are nice pastel shades of peach and mauve." );
  set_messages( ({
    "A small $type$ pushes up through the soil.\n",
    "The $type$ seems to be a bit larger now.\n",
    "The $type$ looks nice and large now.\n",
    "The $type$ jumps up and down very quickly, and then burps.\n",
    "You hear a small voice say: Goodbye, cruel world!\nThe $type$ "+
        "falls over and disintegrates.\n"
  }) );
} /* setup() */

void next_stage() {
  if ( stage == 8 )
    add_eat_effect( "/std/effects/ingested/hallucination", 150 +
        random( 150 ) );
  ::next_stage();
} /* next_stage() */
// --- END [/mnt/home2/grok/lib/obj/fungi/magic_mushroom.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/fungi/blue_nightcap.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/fungi/blue_nightcap.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628632   Available: 13575986
Inodes: Total: 5242880    Free: 4960135
356 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/fungi/blue_nightcap.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628632   Available: 13575986
Inodes: Total: 5242880    Free: 4960135
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/obj/fungus";

void setup() {
  set_adjs( "blue capped" );
  set_type( "mushroom" );
  set_extra( "The shape of it reminds you of someone wearing a nightcap." );
} /* setup() */

void next_stage() {
  if ( stage == 8 )
    add_eat_effect( "/std/effects/ingested/tranquil_sleep", 60 +
        random( 60 ) );
  ::next_stage();
} /* next_stage() */
// --- END [/mnt/home2/grok/lib/obj/fungi/blue_nightcap.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/implement.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/implement.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628632   Available: 13575986
Inodes: Total: 5242880    Free: 4960135
3603 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/implement.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628632   Available: 13575986
Inodes: Total: 5242880    Free: 4960135
2006-10-07 20:59:56.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Id: weapon.c,v 1.24 2003/03/12 22:15:58 ceres Exp $
 */
inherit "/std/object";
inherit "/std/basic/holdable";

#include "money.h"
#include <move_failures.h>
#include <virtual.h>

/**
 * This is a generic held implement used for cutlery, lockpicks, tissues,
 * basically anything you could hold in your hand but which would not be a
 * weapon. Now of course you could try and fight someone with a dessert
 * spoon but it would be pretty silly so use this instead of a weapon.
 *
 * Best way to use this is via the .imp virtual object.
 *
 * @author Ceres
 * @date April 2003
 */
string *un_modifyable;
mixed *wield_func;

void create() {
   holdable::create();
   object::create();
   add_alias("implement");
   add_alias("utensil");
   add_plural("implements");
   if (!query_property("shop type")) {
      add_property("shop type", "general");
   }
}

/** @ignore yes */
varargs int move( mixed dest, string messin, string messout ) {
   int ret;
   int limb;
   object holder;

   //
   // Make sure we revert back to how we were before the move.  If the
   // move fails we should not be changing our state.
   //
   limb = query_my_limb();
   holder = query_holder();
   ret = holdable::move(dest);
   if (ret != MOVE_OK) {
      return ret;
   }
   ret = object::move( dest, messin, messout );
   if (ret != MOVE_OK && holder) {
      holder->set_hold(this_object(), limb);
   }
   return ret;
} /* move() */

void dest_me() {
  holdable::dest_me();
  object::dest_me();
} /* dest_me() */

void player_wield(int pos) {
  if (!environment()) {
    return;
  }
  this_object()->hold_item( environment(), pos );
} /* player_wield() */

mapping query_static_auto_load() {
   if ( base_name( this_object() ) == "/obj/implement" )
     return int_query_static_auto_load();
   return 0;
} /* query_static_auto_load() */

mapping int_query_static_auto_load() {
  mapping tmp;
  
  tmp = object::int_query_static_auto_load();
  return ([ "::" : tmp,
            "hold" : holdable::query_static_auto_load()
            ]);
} /* int_query_static_auto_load() */

mapping query_dynamic_auto_load() {
  mapping map;
  
  map = ([
          "::" : object::query_dynamic_auto_load(),
          "hold" : holdable::query_dynamic_auto_load(),
          ]);
  return map;
} /* query_dynamic_auto_load() */

void init_static_arg( mapping map ) {
  if ( !mapp( map ) ) return ;
  if ( map[ "::" ] ) {
    object::init_static_arg( map[ "::" ] );
  }
  holdable::init_static_arg(map);
} /* init_static_arg() */

void init_dynamic_arg( mapping map, object ) {
   mapping stat_temp;
   string virt_name, new_name;

   if ( map[ "::" ] )
      object::init_dynamic_arg( map[ "::" ] );

   holdable::init_dynamic_arg(map["hold"], 1);

   if( virt_name = query_property( VIRTUAL_NAME_PROP) ) {
     if( file_size( virt_name ) == -1 ) {
       new_name = ( CLONER )->other_file( virt_name );
       if( stringp( new_name ) && ( new_name != virt_name ) ) {
         add_property( VIRTUAL_NAME_PROP, new_name );
         virt_name = new_name;
       } else {
         if( VIRTUAL_HANDLER->query_forbidden( virt_name ) ) {
           call_out( "replace_me", 1 );
         } else {
           VIRTUAL_HANDLER->add_missing( virt_name );
         }
       }
     }
     if( file_size( virt_name ) != -1 &&
         query_property( "virtual time" ) < stat( virt_name )[1] ) {
       stat_temp = ( VIRTUAL_HANDLER )->new_data( virt_name );
       if( mapp( stat_temp ) ) {
         init_static_arg( stat_temp );
         add_property( "virtual time", time() );
       }
     }
   }
} /* init_dynamic_arg() */
// --- END [/mnt/home2/grok/lib/obj/implement.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/shield.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/shield.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628631   Available: 13575985
Inodes: Total: 5242880    Free: 4960135
3145 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/shield.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628631   Available: 13575985
Inodes: Total: 5242880    Free: 4960135
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Id: shield.c,v 1.1 2003/05/13 20:10:13 ceres Exp $
 */
#include <move_failures.h>
#include <virtual.h>

#define AC_LIMIT 100

#undef INFORM

inherit "/obj/armour";
inherit "/std/basic/holdable";

int no_limbs;
nosave int held_in;

void create() {
   do_setup++;
   armour::create();
   add_alias( ({ "armour", "shield" }) );
   add_plural( ({ "armours", "shields" }) );
   add_help_file("armour");
   if ( !query_property( "shop type" ) )
      add_property( "shop type", "armoury" );
   do_setup--;
   if ( !do_setup )
      this_object()->setup();
} /* create() */

int query_no_limbs() { return no_limbs; }

void set_no_limbs( int number ) { no_limbs = number; }

mixed set_holder( object thing, int number ) {
   if (!::set_holder(thing, number))  return 0;
   if(!thing) {
     worn_by = 0;
     held_in = 0;
   } else {
     worn_by = thing;
     held_in = number;
   }
   return 1;
} /* set_holder() */

int query_wearable() { return 0; }

/**
 * @ignore yes
 */
varargs int move( mixed dest, string messin, string messout ) {
   int flag;
   if ( worn_by && ( worn_by != dest ) )
      if ( !sizeof( (int *)worn_by->set_unhold( this_object() ) ) )
         return MOVE_NO_UNHOLD;
   flag = armour::move( dest, messin, messout );
   if ( ( flag == MOVE_OK ) && worn_by )
      set_worn_by( 0 );
   return flag;
} /* move() */

/**
 * @ignore yes
 */
void dest_me() {
   set_worn_by( 0 );
   armour::dest_me();
} /* dest_me() */

/**
 * @ignore yes
 */
mixed *stats() {
   return armour::stats() + ({ ({ "no_limbs", no_limbs }) });
} /* stat() */

/**
 * @ignore yes
 */
mapping int_query_static_auto_load() {
   return ([
      "::" : armour::int_query_static_auto_load(),
      "no limbs" : no_limbs,
   ]);
} /* query_static_auto_load() */

/**
 * @ignore yes
 */
mapping query_static_auto_load() {
   if ( base_name(this_object()) != __FILE__[0..<3]) {
      return ([ ]);
   }
   return int_query_static_auto_load();
} /* query_static_auto_load() */

/**
 * @ignore yes
 */
mapping query_dynamic_auto_load() {
   mapping map;
   map = ([
      "::" : armour::query_dynamic_auto_load(),
   ]);
   return map;
} /* query_dynamic_auto_load() */

/**
 * @ignore yes
 */
void init_static_arg( mapping map ) {
   if ( !mapp( map ) )
      return;
   if ( map[ "::" ] )
      armour::init_static_arg( map[ "::" ] );
   if ( map[ "no limbs" ] )
      no_limbs = map[ "no limbs" ];

} /* init_static_arg() */

void replace_me(){
  object receipt;

  receipt = clone_object( "/std/object" );
  receipt->set_name( "receipt" );
  receipt->set_short( "destructed item receipt" );
  receipt->add_adjective( ({ "destructed", "item" }) );
  receipt->set_long( "This seems to be a small piece of paper.\n" );
  receipt->set_read_mess( "According to our sources, your "+query_short()+" was not "
                          "allowed to exist.  Have a nice day." );
  receipt->move( environment() );
  receipt->set_weight( 1 );
  destruct( this_object() );
}

/**
 * @ignore yes
 */
void init_dynamic_arg( mapping map, object ) {
   if ( map[ "::" ] )
      armour::init_dynamic_arg( map[ "::" ] );

} /* init_dynamic_arg() */

// --- END [/mnt/home2/grok/lib/obj/shield.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/weapon.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/weapon.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628630   Available: 13575984
Inodes: Total: 5242880    Free: 4960135
10355 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/weapon.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628630   Available: 13575984
Inodes: Total: 5242880    Free: 4960135
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Id: weapon.c,v 1.24 2003/03/12 22:15:58 ceres Exp $
 */
inherit "/std/object";
inherit "/std/weapon_logic";
inherit "/std/basic/condition";
inherit "/std/basic/holdable";

#include "weapon.h"
#include "money.h"
#include <move_failures.h>
#include <virtual.h>

/* ok.... now we start thinking about the strange things...
 *   We have several points we want to implement... 
 *   1)  A much wider range of damages.
 *   2)  A "To hit" and "damage" rolls being seperate things
 *          But are still related.  ie a good hit will do more damage
 *  Implementation...
 *    Ok, here goes.   The being hit players ac is taken based on the
 *    attack type, the ac will be returned as a base (not randomised)
 *    and a randomised amount...  This will be used to calculate the
 *    cute number we need.  Once we have the number we create the
 *    "To hit" role for the weapon.  Subtracting of this from our 
 *    ac number tells us weather or not we hit...  If we have hit
 *    We take the amount we hit by (after subtracting off the
 *    "To hit bonus") and add it too the extra damge that is done
 *    All this is kept in an array, there can be more than one
 *    attack in the array.  They can be connected together in
 *    several ways, 1) follow on after attack one did more that x
 *    points of damage.  2) have a percentage chance of working
 *    each attack.
 *    A standard set of attacks are defined in /std/weapon_handler
 *    please see that file for more details
 *
 * Modified 18/5/93 by Piecemaker to remove octarine descriptions for non
 *                                wizards.
 */
string *un_modifyable;
mixed *wield_func;

void create() {
   set_damage_chance( 25 );
   un_modifyable = ({ });
   weapon_logic::create();
   holdable::create();
   condition::create();
   object::create();
   add_alias("weapon");
   add_plural("weapons");
   if (!query_property("shop type")) {
      add_property("shop type", "armoury");
   }
   add_help_file("weapon");
} /* create() */

/** @ignore yes */
string short(int dark) {
   string str;
   
   str = "";
   return ::short(dark)+str;
} /* short() */

/**
 * This method sets the wield function of the object.  This will be
 * called when the object is wielded and unwielded.
 * @param func the function to call
 * @param ob the object to call the method on
 */
void set_wield_func(string func, mixed ob) {
   if (!func) {
      wield_func = 0;
   } else {
      wield_func = ({ func, ob });
   }
} /* set_wield_func() */

/**
 * This method return true if it is a weapon.
 * @return always returns 1
 */
int query_weapon() { return 1; }

/** @ignore yes */
string long(string s, int dark) {
   return ::long(s, dark)+cond_string();
} /* long() */

/**
 * This method setups the weapon with the new condition.  It sets the
 * maximum and lowest conditions to the specified condition.
 * @param new_condition the condition value of the weapon
 */ 
void new_weapon( int new_condition ) {
   set_cond( new_condition );
   set_max_cond( new_condition );
   set_lowest_cond( new_condition );
} /* new_weapon() */

/** @ignore yes */
int held_this_item(int held, object holder, mixed arg) {
  int weight;
  object weapon;

  // Let them know if they aren't dexterous or strong enough to hold
  // this weapon effectively.
  if(held == 1 && interactive(holder)) {
    weight = this_object()->query_weight();

    foreach(weapon in holder->query_weapons())
      weight += weapon->query_weight();
    weight -= holder->query_str();

    switch(weight) {
    case 76..10000:
      tell_object(holder, "You struggle to hold " +
                  query_multiple_short(holder->query_holding() +
                                       ({ this_object() }) - ({ 0 })) +
                  ".\n");
      break;
    case 50..75:
      tell_object(holder, "You struggle slightly to hold " +
                  query_multiple_short(holder->query_holding() +
                                       ({ this_object() }) - ({ 0 })) +
                  ".\n");
      break;
    default:
    }
  }
  
  if (wield_func) {
    if (!held) {
      /* Unwield first.... */
      return call_other(wield_func[1], wield_func[0], 0);
    } else if (held == 1) {
      return call_other(wield_func[1], wield_func[0], holder);
    }
  }
  
  return 1;
}

/** @ignore yes */
varargs int move( mixed dest, string messin, string messout ) {
   int ret;
   int limb;
   object holder;

   //
   // Make sure we revert back to how we were before the move.  If the
   // move fails we should not be changing our state.
   //
   limb = query_my_limb();
   holder = query_holder();
   ret = holdable::move(dest);
   if (ret != MOVE_OK) {
      return ret;
   }
   ret = object::move( dest, messin, messout );
   if (ret != MOVE_OK && holder) {
      holder->set_hold(this_object(), limb);
   }
   return ret;
} /* move() */

void dest_me() {
  holdable::dest_me();
  object::dest_me();
} /* dest_me() */

int modify_damage(int val, string name) {
  int tmp;
  
  tmp = val + (val * query_enchant()) /
    (query_max_enchant() + query_enchant());
  
  if(member_array(name, un_modifyable) != -1)
    return tmp;

  tmp = ( tmp * query_cond() ) / query_max_cond();
  if(tmp < val / 10)
    return val / 10;
  
  return tmp;
} /* modify_damage() */

void hit_weapon( int amount, string type ) {
   if ( member_array( type, un_modifyable) != -1 )
      return;
   do_damage( type, amount );
} /* hit_weapon() */

/* immune to condtion loss */
int add_immune(string name) {
   if (member_array(name, un_modifyable) != -1)
      return 0;
   un_modifyable += ({ name });
   return 1;
} /* add_immune() */

int remove_immune(string name) {
   int i;
   if ((i = member_array(name, un_modifyable)) == -1)
      return 0;
   un_modifyable = delete(un_modifyable, i, 1);
   return 1;
} /* remove_immune() */

int query_value() {
   return ( ::query_value() * ( 10 + ( 90 * query_cond() ) /
                               query_max_cond() ) ) / 100;
} /* query_value() */

int query_full_value() { return ::query_value(); }

mixed *query_money_array() {
   return (mixed *)MONEY_HAND->create_money_array(query_value());
} /* query_money_array() */

int query_money(string type) {
   int i;
   mixed *m_a;
   
   m_a = (mixed *)MONEY_HAND->create_money_array(query_value());
   if ((i=member_array(type, m_a)) == -1)
      return 0;
   return m_a[i+1];
} /* query_money() */

mixed *stats() {
   return
      object::stats() + 
      condition::stats() +
      weapon_logic::stats();
} /* stats() */

void break_me() {
   if ( query_holder() ) {
      tell_object( query_holder(), "%^RED%^$C$"+ the_short() +" breaks!%^RESET%^\n" );
      tell_room( environment( query_holder() ), poss_short() +
                 " breaks!\n", query_holder() );
      query_holder()->set_unhold( this_object() );
   }
   ::break_me();
} /* break_me() */

void player_wield(int pos) {
  if (!environment()) {
    return;
  }
  this_object()->hold_item( environment(), pos );
} /* player_wield() */

mapping query_static_auto_load() {
   if ( base_name( this_object() ) == "/obj/weapon" )
      return int_query_static_auto_load();
   return 0;
} /* query_static_auto_load() */

mapping int_query_static_auto_load() {
   mapping tmp;

   tmp = object::int_query_static_auto_load();
   return ([ "::" : tmp,
      "attack names" : attack_names,
      "attack data" : attack_data,
      "attack types" : attack_types,
      "hold" : holdable::query_static_auto_load(),
      "condition" : condition::query_static_auto_load()
          ]);
} /* int_query_static_auto_load() */

mapping query_dynamic_auto_load() {
   mapping map;

   map = ([
      "::" : object::query_dynamic_auto_load(),
      "condition" : condition::query_dynamic_auto_load(),
      "hold" : holdable::query_dynamic_auto_load(),
           ]);
   return map;
} /* query_dynamic_auto_load() */

void init_static_arg( mapping map ) {
   if ( !mapp( map ) ) return ;
   if ( map[ "::" ] ) {
      object::init_static_arg( map[ "::" ] );
   }
   if ( map[ "attack names" ] ) {
      attack_names = map[ "attack names" ];
   }
   if ( map[ "attack data" ] ) {
      attack_data = map[ "attack data" ];
   }
   if ( map[ "attack types" ] ) {
      attack_types = map[ "attack types" ];
   }
   if ( !undefinedp( map[ "condition" ] ) ) { 
      condition::init_static_arg( map[ "condition" ] );
   }
   if (map["no limbs"]) {
      //
      // The new method handles it differently.
      //
      holdable::init_static_arg(map);
   } else {
      holdable::init_static_arg(map["hold"]);
   }
} /* init_static_arg() */

void replace_me(){
  object receipt;

  receipt = clone_object( "/std/object" );
  receipt->set_name( "receipt" );
  receipt->set_short( "destructed item receipt" );
  receipt->add_adjective( ({ "destructed", "item" }) );
  receipt->set_long( "This seems to be a small piece of paper.\n" );
  receipt->set_read_mess( "According to our sources, your "+query_short()+" was not "
                          "allowed to exist.  Have a nice day." );
  receipt->move( environment() );
  receipt->set_weight( 1 );
  destruct( this_object() );
} /* replace_me() */

void init_dynamic_arg( mapping map, object ) {
   mapping stat_temp;
   string virt_name, new_name;

   if ( map[ "::" ] )
      object::init_dynamic_arg( map[ "::" ] );
   if ( !undefinedp( map[ "condition" ] ) ) {
      condition::init_dynamic_arg( map[ "condition" ] );
   }

   holdable::init_dynamic_arg(map["hold"], 1);

   if( virt_name = query_property( VIRTUAL_NAME_PROP) ) {
     if( file_size( virt_name ) == -1 ) {
       new_name = ( CLONER )->other_file( virt_name );
       if( stringp( new_name ) && ( new_name != virt_name ) ) {
         add_property( VIRTUAL_NAME_PROP, new_name );
         virt_name = new_name;
       } else {
         if( VIRTUAL_HANDLER->query_forbidden( virt_name ) ) {
           call_out( "replace_me", 1 );
         } else {
           VIRTUAL_HANDLER->add_missing( virt_name );
         }
       }
     }
     if( file_size( virt_name ) != -1 &&
         query_property( "virtual time" ) < stat( virt_name )[1] ) {
       stat_temp = ( VIRTUAL_HANDLER )->new_data( virt_name );
       if( mapp( stat_temp ) ) {
         init_static_arg( stat_temp );
         add_property( "virtual time", time() );
       }
     }
   }

} /* init_dynamic_arg() */
// --- END [/mnt/home2/grok/lib/obj/weapon.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/surf_save.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/surf_save.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628627   Available: 13575981
Inodes: Total: 5242880    Free: 4960135
1404 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/surf_save.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628627   Available: 13575981
Inodes: Total: 5242880    Free: 4960135
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: surf_save.c,v 1.2 2000/07/25 01:00:49 pinkfish Exp $
 * $Log: surf_save.c,v $
 * Revision 1.2  2000/07/25 01:00:49  pinkfish
 * Fix up to work with an inherited auto_load.
 *
 * Revision 1.1  1998/01/06 04:58:17  ceres
 * Initial revision
 * 
*/
inherit "/std/surface";

mapping details;
nosave string save_file;

void do_load() {
   if ( save_file ) {
      all_inventory( this_object() ) -> dest_me();
      if ( file_size( save_file + ".o" ) > 0 ) {
	 unguarded((: restore_object, save_file :));
	 if ( sizeof( details ) ) init_dynamic_arg( details );
      }
   }
} /* do_load() */

void create() {
   save_file = "";
   details = ([ ]);
   ::create();
} /* create() */

int test_remove( object ob, int flag) {
   if ( find_call_out( "do_save" ) == -1 )
      call_out( "do_save", 0 );
   return 1;
} /* test_remove() */

int test_add( object ob, int flag) {
   if ( find_call_out( "do_save" ) == -1 )
      call_out( "do_save", 0 );
   return 1;
} /* test_add() */

void do_save() {
   if ( save_file ) {
      details = ([ ]);
      details = query_dynamic_auto_load();
      unguarded((: save_object, save_file :));
   }
} /* do_save() */

void check_euid() {
   if ( previous_object() )
     seteuid( geteuid( previous_object() ) );
} /* check_euid() */

void set_save_file( string file ) {
   save_file = file;
   do_load();
} /* set_save_file() */
// --- END [/mnt/home2/grok/lib/obj/surf_save.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/reagents/.generic_liquid.ob_virtual_.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/reagents/.generic_liquid.ob_virtual_.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628626   Available: 13575980
Inodes: Total: 5242880    Free: 4960135
1417 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/reagents/.generic_liquid.ob_virtual_.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628626   Available: 13575980
Inodes: Total: 5242880    Free: 4960135
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <virtual.h>

void dest_me() { destruct( this_object() ); }

void create()
{
  seteuid( (string)"/secure/master"->creator_file( file_name( this_object() ) ) );
} /* create() */

object create_virtual_ob() {
   object clone;

  clone = (object)SERVER->create_virtual_object( "/obj/food.c", 1 );
  clone->add_property( VIRTUAL_NAME_PROP, "/obj/reagents/generic_liquid.ob#1" );
  call_other( clone, "add_adjective",  "some"  );
  call_other( clone, "add_alias",  "liquid"  );
  call_other( clone, "set_amount_types",  ([ "drop": ({ 1, "drops" }),              "teaspoon": ({ 20, "teaspoons" }),              "tablespoon": ({ 60, "tablespoons" }),              "ounce": ({ 120, "ounces" }),              "cup": ({ 960, "cups" }),              "pint": ({ 2400, "pints" }),                          "quart": ({ 4800, "quarts" }),                          "gallon": ({ 19200, "gallons" }) ])  );
  call_other( clone, "add_adjective",  ({ "drop", "drops", "teaspoon", "teaspoons", "tablespoon",                "tablespoons", "ounce", "ounces", "cup", "cups", "pint",                "pints", "quart", "quarts", "gallon", "gallons", "of" })  );
  call_other( clone, "set_pile_types",  ({ 50, "small", 100, "medium", "large" })  );
  call_other( clone, "set_continuous",   );
  call_other( clone, "set_liquid",   );
  call_other( clone, "add_property",  "determinate", "" );
   return clone;
} /* create_virtual_ob() */
// --- END [/mnt/home2/grok/lib/obj/reagents/.generic_liquid.ob_virtual_.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/b_day/demon.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/b_day/demon.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628626   Available: 13575980
Inodes: Total: 5242880    Free: 4960135
2355 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/b_day/demon.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628626   Available: 13575980
Inodes: Total: 5242880    Free: 4960135
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* The singing birthday demon */
#define SONG "/obj/b_day/happy"

inherit "/obj/monster";

int line;
object owner;
string owner_name;
string* act_lines = ({
  ":takes a deep breath...",
  "sing \"Happy Birthday to you\"",
  "sing \"Happy Birthday to you\"",
  "sing \"Happy Birthday, dear $N\"",
  ":pauses for breath...",
  "sing \"Happy Birthday to yoooou.\"",
  "sing \"The End!\"",
  "hug $n in a way that only a tiny paper "
    "demon could",
  ":waves a minute pointed hand.",
  ":frowns, then folds itself into nothingness..."
});

void setup()
{
  set_name("demon");

  set_short("origami demon");

  add_adjective("tiny");
  add_adjective("pink");
  add_adjective("paper");
  add_adjective("origami");
  set_main_plural("origami demons");
  add_plural("demons");

  set_long("This is a tiny, pink, paper demon. Looking closely you see "
           "that it has been made by someone with a black belt in "
           "Origami!\n"); 
  set_race("demon");
  set_level(1);
  line = 1;
}

void set_owner(string person_name)
{
  owner = find_living(lower_case(person_name));
  owner_name = person_name;
}


void do_the_act(int i)
{
  string line_to_act;
  
  if(i >= sizeof(act_lines)) {
    dest_me();
    return;
  }

  if(environment(owner) != environment()) {
    tell_room(environment(), "The origami demon rustles after "
              + owner_name + ".\n");
    move(environment(owner));
    tell_room(environment(), "The origami demon rustles in.\n" );
    do_command("'Hey "+owner_name+"! I hadn't finished!\n"); 
    return;
  }   
  line_to_act = act_lines[i];
  line_to_act = replace(line_to_act, ({"$N", owner_name, 
                                       "$n", lower_case(owner_name) }));
  if(!strlen(line_to_act)) {
    set_heart_beat(0);
    dest_me();
    return;
  }
  do_command(line_to_act);
  i++;
  if(owner) {
    call_out("do_the_act", 2, i);
  }
  return; 
}


/*Let's keep this fellow unkillable, thankyouverymuch! Siel*/
void attack_by( object thing ){
  
  if( !thing) return;
  if( environment( thing ) != environment() ) return;
  this_object()->stop_fight (thing); 
  thing->stop_fight (this_object());
  init_command("say Meanie!  Shame on you!  I shall finish what I "
               "started and then I shall be off.  You don't really "
               "deserve this, you know.", 1);
  return;
  
} /* attack_by() */
// --- END [/mnt/home2/grok/lib/obj/b_day/demon.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/b_day/card.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/b_day/card.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628625   Available: 13575979
Inodes: Total: 5242880    Free: 4960135
6163 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/b_day/card.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628625   Available: 13575979
Inodes: Total: 5242880    Free: 4960135
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*
 * A birthday card to give to ppl on their birthday (in real life) 
 */
#define DEMON "/obj/b_day/demon"

#include <player_handler.h>

inherit "/std/object";

int creator_status, is_open = 0;
int opened_before = 0;
string owner_name, owner_language;
string* colour_array = ({
  "%^RED%^", "%^BOLD%^%^RED%^",
  "%^MAGENTA%^", "%^BOLD%^%^MAGENTA%^",
  "%^ORANGE%^", "%^YELLOW%^", 
  "%^GREEN%^", "%^BOLD%^%^GREEN%^",
  "%^WHITE%^", "%^BOLD%^%^WHITE%^", 
  "%^CYAN%^", "%^BOLD%^%^CYAN%^"
  });   

void setup_card(string name, string language, int status);

mapping init_query_static_auto_load() {

  return ([ "::" : ::int_query_static_auto_load(),
          "owner_name":owner_name, 
          "owner_language":owner_language, 
          "is_open":is_open, 
          "opened_before":opened_before]);

}/* mapping init_query_static_auto_load() */


void init_static_arg( mapping map ) {

  if ( map[ "::" ] ) {
    ::init_static_arg( map[ "::" ] );
  }
  if ( !undefinedp( map[ "owner_name" ] ) ) {
    owner_name = map[ "owner_name" ];
  }
  if ( !undefinedp( map[ "owner_language" ] ) ) {
    owner_language = map[ "owner_language" ];
  }
  if ( !undefinedp( map[ "is_open" ] ) ) {
    is_open = map[ "is_open" ];
  }
  if ( !undefinedp( map[ "opened_before" ] ) ) {
    opened_before = map[ "opened_before" ];
  }

}/* void init_static_arg() */


mapping query_static_auto_load() 
{
  if ( explode( file_name( this_object() ), "#" )[ 0 ] ==
       "/obj/b_day/card" ) {             
    return init_query_static_auto_load();
  }
  return 0;

} /* query_static_auto_load() */


mixed *query_read_mess()
{
  if(!is_open) {
    return ({ ({ "The card is addressed to " + owner_name + 
                   ".  Maybe you should open it?  Then again, if "
                   "you're not " + owner_name + ", maybe you "
                   "shouldn't.\n",  
                   0, owner_language, 1 }) });
  }
  return ::query_read_mess();
}


void set_closed_mesg()
{
    set_long("The closed card has been carefully handmade from pink "
        "cardboard. There is a rather vague illustration of a "
        "non-identifiable piece of flora on the front.\n");
}


void set_open_mesg()
{    
    set_long("The open card has been carefully handmade from pink "
        "cardboard.\n");
}


void setup_card(string own_name, string own_language, int cre_status) 
{
  string *wizards, list;
  int i;

  owner_name = own_name;
  owner_language = own_language;
  creator_status = cre_status;
  set_short(owner_name + "'s birthday card");
  add_adjective( ({ owner_name, owner_name + "'s"}) );

  wizards = get_dir("/w/");

  if(creator_status) {
    int start = member_array(lower_case(owner_name), wizards);
    wizards = wizards[0..start-1] + wizards[start+1..];
    list = 
      "\n    Have a wonderful birthday, " + owner_name + "!!!  \n" 
      "    LOVE AND KISSES FROM...                \n\n";
    for(i=0;i<sizeof(wizards);i++) {
      if(PLAYER_HANDLER->test_user(wizards[i])) {
        list += colour_array[random(sizeof(colour_array))] +
          capitalize(wizards[i]); 
        if(i == sizeof(wizards)-1) list += "%^RESET%^.\n\n";
        else if(i == sizeof(wizards)-2) list += "%^RESET%^ and ";
        else list += ",%^RESET%^ ";
      }
    }
    list += "... and thanks for all your work and time, and let's hope "
      "next year will be even more magical and fun, fun, fun!\n";  
  } else {
    
    list = 
      "\n    Have a wonderful birthday, " + owner_name + "!!!  \n" 
        "    LOVE AND KISSES FROM...                \n\n";
    for(i=0;i<sizeof(wizards);i++) {
      if(PLAYER_HANDLER->test_user(wizards[i])) {
        list += capitalize(wizards[i]);
        if(i == sizeof(wizards)-1) list += ".\n";
        else if(i == sizeof(wizards)-2) list += " and ";
        else list += ", ";
      }
    }
  }

  add_read_mess(list, "various hands", owner_language, 1);
  
} /* setup_card() */


void setup()
{
  set_name("card");
  set_short("birthday card");
  add_adjective("birthday");
  set_main_plural("birthday cards");
  add_property("determinate", "");
  add_property("no recycling", 1);
  set_closed_mesg();

  if(owner_name && owner_language) {
    setup_card(owner_name, owner_language, creator_status);
  }
}


void init()
{
    this_player()->add_command("open", this_object());
    this_player()->add_command("close", this_object());
}


int do_open()
{
    object demon;

    if(is_open) {
        write("It is already open.\n");
        return 1;
    }

    if(lower_case(owner_name) != this_player()->query_name()) {
      add_succeeded_mess( ({ 
        "*** POP ***\n"
          "An Origami Demon peers out from the card, sees you're not " 
          + owner_name + ", mutters about that not being very "
          "low-temperature, and vanishes back into the card.\n",
        "*** POP ***\n"
          "An Origami Demon peers out from " + owner_name + "'s "
          "birthday card at " + this_player()->query_cap_name() +
          ", smirks and crawls back into the card.\n"
      }) );
      return 1;
    }

    is_open = 1;
    set_open_mesg();

    if(opened_before) return 1;
    opened_before = 1;

    demon = clone_object(DEMON);
    demon->move(environment(this_player()));
    demon->set_owner(owner_name);
    demon->add_language(owner_language);
    demon->set_language(owner_language);

    /*changed the write/say to add_succeeded_mess, Siel June 2001 */

    add_succeeded_mess( ({ 
      "*** POP ***\n"
        "An Origami Demon explodes from your card as you open it!\n",
      "*** POP ***\n"
        "An Origami Demon explodes from " + owner_name + "'s birthday "
        "card as " + owner_name +" opens it!\n"
    }) );

    call_out("start_demon", 2, demon);
    return 1;
}


void start_demon(object thing) {
  thing->do_the_act(0);
} /* start_demon() */


int do_close()
{
    if(!is_open) {
        write("It is not open for you to close!\n");
        return 1;
    }
    is_open = 0;
    set_closed_mesg();
    return 1;
}


mixed *stats() 
{
  return ::stats() + ({ ({ "owner name",owner_name }), 
                          ({ "owner language",owner_language }), }); 

}/* mixed *stats() */

// --- END [/mnt/home2/grok/lib/obj/b_day/card.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/examples/exa3.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/examples/exa3.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628623   Available: 13575977
Inodes: Total: 5242880    Free: 4960135
4543 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/examples/exa3.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628623   Available: 13575977
Inodes: Total: 5242880    Free: 4960135
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* this is the third template room, introducing 'signs' and 'objects' -- bil */

/* I will not discuss what has already been discussed...revise the older
 * rooms if you have problems.
 */
#include "path.h"

inherit "/std/room";

void setup()
{
  set_short("third simple room");

  set_long("This is the third example room. Will you ever get to the end? " +
           "Directly above your head is a plaque, nailed to the wall.\n");
  
  set_light(90); /* another brightly lit room */

/* >> Signs <<
 * A sign is a special type of item. It can be read and may be visible in the
 * room, but is usually referenced in the long, just like items.
 * arguments are as follows:
 * 1) description, just like the second arg of items.
 * 2) read message.
 * 3) optional short description - if this is 0 then the sign is treated
 *    like an item, otherwise it is an actual object in the room. Either
 *    way it is auto-destructed for you so don't worry about.
 * 4) optional name - if not set it defaults to 'sign'
 */
  add_sign("The plaque is made of bronze.\n",
           "'Don't read me, I'm only an example sign you know!'\n",
           0,
           "plaque");

  add_exit("west", ROOM + "exa2", "door");
  add_exit("east", ROOM + "exa4", "door");

  set_zone("examples");
}

/* >> reset <<
 * OooooOoOoOoOoOOooOoooh, a new function!
 * the reset function is called every so often, and whenever an object is
 * created. It is generally used to restock the game with monsters and objects.
 * It is the equivalent of reset(1) for the LP-2.4.5 people out there.
 */
void reset()
{
/* local variable, just used to reference an object we clone while we set it up
 */
  object bar;
  
/* oooh checking if an item is there...horror stuff.
 * read the help on match_objects_for_existence, sizeof and this_object and come back later *8-)*
 * what we are doing now is checking to see is there is already
 * a bar here, and if so we do not continue with making a new one.
 * Why there would be a new one I haven't a clue, and you should
 * never actually just give away items like this. So why am I doing it?
 * It does teach you some things. Bing!
 */
  if(sizeof(match_objects_for_existence("copper bar", ({ this_object() }) )))
    return;
/* cloning objects - here we clone a standard object ("/std/object") and
 * set the variable 'bar' to point to it.
 */
  bar = clone_object("/std/object");
/* here we initialise the data in the object. We do this by calling functions
 * on the bar, the -> operator means 'call_other'.
 * first we set the most simple name the object is called.
 * names should be ONE word long and in LOWER CASE.
 * everything except short and long should be in LOWER CASE.
 * the name is used so that when someone does 'examine bar' we will
 * know what they are talking about.
 */
  bar->set_name("bar");

/* adding the adjective "copper" to the bar means that both
 * "bar" and "copper bar" can be used to identify the object.
 */
  bar->add_adjective("copper");
/* the main plural replaces the short description when there are multiple
 * objects with the same short description in the same place.
 */
  bar->set_main_plural("copper bars");

/* if there are other ways to identify a group of the objects add it
 * with add_plural. If the argument is an array of strings they are all
 * added as extra plural identifiers.
 */
  bar->add_plural("bars");
/* now a group of the object can be identified as "copper bars" or
 * "bars".
 */
 
/* short and long have already been discussed in first example room
 * with respect to rooms. The short is what you see in your inventory
 * or when the thing is on the ground. You should not use a preceeding
 * 'a' or 'a' or 'the'.
 */
  bar->set_short("copper bar");
  bar->set_long("This is just a treasure thingie to show you how to use " +
                  "such fun things.\n");

/* Weight - this is how much the player is encumbered by the item.
 * it is measured in arbitary units and you can get an idea of how
 * much real weight they corrispond to with 'help weight' eg. bar is 4kg
 */
  bar->set_weight(80);

/* Value - this means the absolute value of the bar is 2000 brass coins
 * or 1 gold coin (200 copper coins) - remember this is the shop
 * price - a player will generally get half this when selling the item.
 * look at the exchange rates in 'help money'.
 */
  bar->set_value(2000);

/* So far the object isn't anywhere, it has no environment. to move it
 * call the move() function in it to move it to this_object() (the room)
 */
  bar->move(this_object());
}
// --- END [/mnt/home2/grok/lib/obj/examples/exa3.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/examples/response_mon.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/examples/response_mon.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628622   Available: 13575976
Inodes: Total: 5242880    Free: 4960135
4152 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/examples/response_mon.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628622   Available: 13575976
Inodes: Total: 5242880    Free: 4960135
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* This file is an example of the way responsive_monster can be used.

   The most important thing is the mapping respond_to_with.

   The index of r_t_w should be an array of element,
         element can be a string, 
         element can be an array of strings
   
   An element of the mapping is matched with the string a player
   says if:
     -the string the player said contains the strings of the array
      (the index of r_t_w) in the SAME order. Also, if an array of
      strings is given instead of a string, the test will be 
      succesful if one of the elements of that array appeared at
      the right place. (readmarks are ignored)

             For Example:
                  Nimmox says: I demand, that you give me attention !
 
             matched :
                  ({ "demand","attention" })          
                or
                  ({ "demand", ({"attention","help" }) })
       
             
             But doesnt match :

                  ({ "attention","demand" });
 
   If one of the indices of the mapping matches a string the player said,
   the monster will respond as is defined in the field of the mapping corres-
   ponding with the matched index.

   This field can be :

          A string : The string will be sent to the room the monster is in 
                     (with a small delay, to cause no weird effects
                      Like the monster responding for the players sees 
                      his/her/it say echo) 

A string with a "#func" format. : the function func will be called with 
                                  this_player() (the player that did the say)
                                  as argument.     

An array of strings: One of the strings is randomly selected, and treated
                     as above.




Also you can set_stop_responding(1) to stop the monster from responding
 (you might want to tell a stroy uninterrupted)

set_stop_responding(0) to allow the monster to respond again.


                          Nimmox (January 1993)
*/



inherit "/w/pinkfish/tmp/response_mon";

object weapc;
string *tale;

void setup() {
    set_name("guard");
    add_adjective(({ "big", "gate" }));
    set_short("Big gate guard");
    set_long("This is one of the common guards of Amber.  "+
     "He looks quite big, maybe you shouldn't upset him...\n");
    set_race("human");
    set_class("fighter");
    set_level(45);
    set_al(250);
    set_gender(1);
    tale = ({ "There once was a frog with 5 legs.\n",
              "This frog was very very unhappy.\n",
              "All other frogs made fun of him.\n",
              "And no lady frog wanted to marry him.\n",
              "One day, a womble appeared, and bit one of his legs off.\n",
              "Since then the frog had 4 legs, and lived happily ever after.\n"
            });


    set_respond_to_with(([ ({ "help", "me" }) : "'I can't help you." ,
                         ({ ({ "hi","hello","greetings" }) }) :
                                      ({ "'Hello $hcname$.",
                                         "emote salutes you." }),
                            ({ ({ "remove","unwield","unhold" }),
                               ({ "axe","weapon" }) }) :
                                       "#remov",
                            ({ ({ "wield","hold" }),
                               ({ "axe","weapon" }) }) :
                                       "#wiel", 
                            ({ "tell" , "story" }) :
                                      "#story" ]));
  weapc = clone_object("/obj/weapons/axe.wep");
  weapc->move(this_object());
  do_equip();
} /* setup() */

int remov() {
  init_command("unhold axe");
} /* remov() */

int wiel() {
 init_command("hold axe");
} /* wiel() */

void story(object tpl) {
  command("'Very well, "+tpl->query_cap_name()+ " I will tell you a story.\n");
  set_stop_responding(1);
  call_out("tell_story",2,0);
} /* story() */

void tell_story(int arg) {
  remove_call_out("tell_story");
  if (arg == sizeof(tale)) { 
    set_stop_responding(0);
    return ;
  }
  command("'"+tale[arg]);
  call_out("tell_story",2,arg+1);
} /* tell_story() */
// --- END [/mnt/home2/grok/lib/obj/examples/response_mon.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/examples/exa2.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/examples/exa2.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628621   Available: 13575975
Inodes: Total: 5242880    Free: 4960135
1980 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/examples/exa2.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628621   Available: 13575975
Inodes: Total: 5242880    Free: 4960135
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* this is the second template room, introducing 'items'-- bil */

/* I will not discuss what has already been discussed...revise the older
 * rooms if you have problems.
 */
#include "path.h"

inherit "/std/room";

void setup()
{
  set_short("second simple room");

  set_long("This is the second example room. It introduces items, and " +
           "aliasing - again use 'more here' to look at it. Over by the " +
           "north wall you can see a table.\n");
  
  set_light(90); /* another brightly lit room */

/* >> Items <<
 * Items grew out of people moaning that they could see a 'table' in the
 * long description, yet 'examine table' declared there was no such thing!
 * So now they can. The first argument refers to the thing the player
 * must examine to see the second argument printed out.
 * eg you can 'examine table' to see "The table is...etc"
 * In general follow the guidelines for set_long(), except an item
 * should be much shorter, 1/2 to 2 lines...remember these are minor
 * things and we only have finite memory resourses.
 */
 add_item("table",
          "The table is one step away from being firewood. Upon it rests " +
          "a blotter.\n");
/* if you want more than one way to examine an item, use an array of
 * strings in the first argument - see 'help array' if this confuses you.
 * eg. 'examine north wall' and 'examine wall' both tell the player
 * "It is very...etc"
 */
 add_item( ({ "north wall", "wall" }),
          "It is very flat and is holding up rather a ricketty table.\n");
/* you can add items to things referenced in other items...clever huh!
 * but don't go mad - don't add a blots item unless they are *important*
 * otherwise it will get silly.
 */
 add_item("blotter",
          "It is covered in random ink blots.\n");

/* >> Exits <<
 * Nothing new here - back to the first example and onwards...
 */
  add_exit("west", ROOM + "exa1", "door");
  add_exit("east", ROOM + "exa3", "door");

  set_zone("examples");
}
// --- END [/mnt/home2/grok/lib/obj/examples/exa2.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/examples/exa1.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/examples/exa1.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628620   Available: 13575974
Inodes: Total: 5242880    Free: 4960135
3424 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/examples/exa1.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628620   Available: 13575974
Inodes: Total: 5242880    Free: 4960135
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* this is the most simple room imaginable -- bil */

/* >> paths <<
 * Always use a path.h file when making a group of rooms. The idea is
 * that the path.h file contains various definitions of paths. eg
 * the path.h refered to here contains:
   #define ROOM "/obj/examples/"
 * this is considered further in exits - below.
 */
#include "path.h"

/* >> inheriting the basic room <<
 * For rooms inside inherit "/std/room", for those outside inherit
 * "/std/outside" - this choice simply controls whether the room gets
 * weather messages, and whether its light (see below) is affected by the
 * time of day.
 */
inherit "/std/room";

/* >> setup <<
 * The setup function is called when a room is created. It should
 * contain all things to initialise the room.
 */
void setup()
{
/* >> Short description <<
 * The first thing to set is the short description for the room.
 * this is seen when a player is in brief mode, types 'glance' or when
 * you take things from the room.
 * As with all shorts it should be in lower case, except where proper names
 * are involved, and there shouldn't be a '.' or '\n' in it. It should
 * really only be a few words but should be vaguely descriptive.
 */
  set_short("first simple room");
  
/* >> Long description <<
 * Next thing is the long, which is seen when moving in verbose mode, or
 * with the 'look' command. This should be from 2 lines long and should
 * describe the location. It shouldn't be more than half a page (12 lines)
 * long except in exceptional circumstances. Here we must use all the
 * punctuation we want. Also, unlike old lpmud rooms there should only be
 * one newline ("\n") and that at the end. The game auto-magically wraps
 * text for you!
 */ 
  set_long("This is a simple room, have fun with it. To read the code " +
           "simply type 'more here'. For help with more, type 'h' in it.\n");
  
/* >> Light level <<
 * All rooms have to be lit. To see what values are reasonable for this
 * look at the help on 'light' - use this function even if you wish the
 * location to be pitch darkness (ie set_light(0)) so it is obvious
 * you have set it dark, rather than just forgotten to set it.
 */
  set_light(90); /* brightly lit room */

/* >> Exits <<
 * Exits are important if you want to be able to move about!
 * ROOM (see #include above) refers to a directory. The reason we
 * use this definition is so we can build rooms in our /w/<myname>
 * directories, before attaching them to the game (in your domain).
 * eg. path.h was first:
   #define ROOM "/w/bil/examples/"
 * when i was writing this in my own directory, the rooms all being held
 * in /w/bil/examples directory. Then when i moved them here I simply
 * changed the path.h file that was with them to:
   #define ROOM "/obj/examples/"
 * You should use a similar method for coding/testing in /w/fish/forest
 * before putting it into /d/sur/forest (for example *8-)* )
 * the first argument is the direction the exit leads, the second the
 * filename of the room you should arrive in if you leave that way and the
 * third the type of exit, here "door" means doorway, not an actual moveable
 * door. This will be discussed further later on.
 */
  add_exit("east", ROOM + "exa2", "door");

/* >> Zone <<
 * All locations are considered to be in a zone, this is used to control
 * the movement of wandering monsters (this will be considered again later)
 */
  set_zone("examples");
}
// --- END [/mnt/home2/grok/lib/obj/examples/exa1.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/clock.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/clock.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628619   Available: 13575973
Inodes: Total: 5242880    Free: 4960135
3086 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/clock.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628619   Available: 13575973
Inodes: Total: 5242880    Free: 4960135
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
#define CREATOR "Ceres"
/*
 * $Locker:  $
 * $Id: clock.c,v 1.6 1999/12/25 21:42:17 presto Exp $
 * $Log: clock.c,v $
 * Revision 1.6  1999/12/25 21:42:17  presto
 * changed hours % 13 to hours % 12
 *
 * Revision 1.5  1999/07/28 20:48:37  ceres
 * More bugs. :(
 *
 * Revision 1.2  1999/07/28 00:44:59  ceres
 * Made some improvements
 *
 * Revision 1.1  1998/01/06 04:58:17  ceres
 * Initial revision
 * 
*/
/**
 * An inheritable clock object. This is used for proper clocks, if you need to
 * create a watch use the watch object instead.
 *
 * @see /obj/watch
 *
 * @author Ceres
 */
#include <am_time.h>

inherit "std/object";

#define HOURS ({"twelve", "one", "two", "three", "four", "five", "six", \
                "seven", "seven plus one", "nine", "ten", "eleven" })
#define CHIME_HANDLER "/obj/handlers/chime_handler"

int show_date;

/** @ignore yes */
void create() {
  do_setup++;
  object::create();
  do_setup--;
  
  if(!do_setup)
    this_object()->setup();
  
  add_extra_look(this_object());
}

/** @ignore yes */
string query_time_string() {
  string mess;
  int minute, hour, *arr;

  minute = (AM_TIME_HANDLER->query_am_minute(time()) % 60);
  hour = AM_TIME_HANDLER->query_am_hour(time());

  if(minute > 30 )
    hour = hour + 1;
  hour = hour % 12;

  mess = "";
  switch(minute) {
  case 53..57:
    mess += "five to " + HOURS[hour]; break;
  case 48..52:
    mess += "ten to " + HOURS[hour]; break;
  case 43..47:
    mess += "quarter to " + HOURS[hour]; break;
  case 38..42:
      mess += "twenty to " + HOURS[hour]; break;
  case 33..37:
    mess += "twenty-five to " + HOURS[hour]; break;
  case 28..32:
    mess += "half past " + HOURS[hour]; break;
  case 23..27:
    mess += "twenty-five past " + HOURS[hour]; break;
  case 18..22:
    mess += "twenty past " + HOURS[hour]; break;
  case 13..17:
    mess += "a quarter past " + HOURS[hour]; break;
  case 8..12:
    mess += "ten past " + HOURS[hour]; break;
  case 3..7:
    mess += "five past " + HOURS[hour]; break;
  default:
    mess += HOURS[hour] + " o'clock";
  }
  
  if(show_date) {
    arr = AM_TIME_HANDLER->query_am_time_array(time());
    mess += " on " +
      AM_TIME_HANDLER->query_day_of_week(arr[AM_TIME_DAY_OF_WEEK]) + " the " +
      ordinal(arr[AM_TIME_DAY_OF_MONTH]) + " of " +
      AM_TIME_HANDLER->query_month(arr[AM_TIME_MONTH]);
  }
  return mess;
}

string extra_look(object thing) {
  return query_time_string() + ".\n";
}

/**
 * Sets this clock to show the date as well as the tme.
 */
void set_show_date() { show_date = 1; }

/**
 * setup chimes for this clock.
 * @param num 1 = every hour, 2 = every half hour, 3 = every quarter hour.
 * @param mess The message to be displayed when the clock chimes.
 */
void set_chimes(int num, string mess) {
  CHIME_HANDLER->register_for_chimes(this_object(), num, mess);
}

/**
 * Function to chime. Overload this if you wish to have your own chime
 * code.
 *
 * @param chime_message the message set with set_chimes.
 * @see set_chimes
 */
void chime(string chime_message, int type) {
  say(chime_message);
}
// --- END [/mnt/home2/grok/lib/obj/clock.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/meltable.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/meltable.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628618   Available: 13575972
Inodes: Total: 5242880    Free: 4960135
14916 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/meltable.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628618   Available: 13575972
Inodes: Total: 5242880    Free: 4960135
2006-10-07 20:59:56.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* 
   Inheritable for melting food
   by Carmine, August 2001
*/

/**
 *
 * <BR>
 * This is an inheritable for frozen food which melts, 
 * based on the temperature of the room environment in 
 * which it finds itself. 
 * <P>
 * It performs just as normal food, apart from the following:
 * <P>
 * - It cannot be cured or dried
 * <P>
 * - It does not decay
 * <P>
 * - It cannot be forced to behave as a liquid
 * <P>
 * - When applied or eaten, it will cause a brief decrease
 * in temperature of the user.
 * <P>
 * It will melt into a liquid, which can be set using 
 * set_melt_result().  This is default at water, and can be 
 * queried using query_melt_result().
 * <P>
 * It's melt level can be checked by query_melt_level().  This
 * starts at a value of ten times the original weight of the 
 * meltable food.
 * <P>
 * It's rate of melting adjusts itself regularly, based on the
 * temperature.  This can be checked with query_melt_rate(), and
 * set temporarily with set_melt_rate.
 * <P>
 * The level of melting is shown in the long and short of the object.
 * These are created using query_short_rotten_adjective and 
 * query_long_decay_level, and are based on the percentage of 
 * object left.
 * 
 * @author Carmine
 * 
 */
 

#include <bits_controller.h>
#include <weather.h>

inherit "/obj/food";

#define CHILL -5        /* By how much eating or applying this will cool you */
#define CHILL_TIME 10  /* For how long eating or applying this will cool you */

#define MELT_RATE_DEFAULT 6  /* The default melt rate, initially corresponding
                                to 60 seconds for something of weight 1 to 
                                melt away to nothing in a 20 deg. C 
                                environment */
                                
#define WATER "/obj/food/beverages/water.food"  /* default melt liquid */

/* This is a lookup table which holds the melt rates dependent on the 
   environment's temperature.  It has values for 1 to 50 C, after which 
   the melt rate is 1 (fast).  Below 1, no melt takes place */
#define _LOOKUP_RATE ({ 60, 57, 54, 51, 48, 42, 36, 30, 27, 24, \
                        20, 18, 16, 14, 12, 10,  9,  8,  7,  6, \
                         6,  6,  6,  5,  5,  5,  4,  4,  4,  3, \
                         3,  3,  3,  3,  3,  3,  3,  3,  3,  2, \
                         2,  2,  2,  2,  2,  2,  2,  2,  2,  1  })


/* GLOBAL VARIABLES */
private int _melt_level;   /* this represents the amount left to melt */

private int _original_melt_level;   /* this stores the original melt level 
                                       at setup */
private int _melt_rate;    /* this is the number of seconds between the melt
                              counter counting up by 1 - it is the number of
                              seconds between liquid being produced by the 
                              melting object
                           */
                           
private int _melt_counter; /* this counts up to 10, and decreases the weight
                              of this object by 1 every time it reaches 10, 
                              whereupon it resets to 0 */
                              
private int _callout_id;   /* the id of the melting call out */

private string _melt_result; /* the path of the liquid result of melting */


/* FUNCTION PROTOTYPES */
void create();
void set_melt_result( string result );
string query_melt_result();
void set_melt_rate( int rate );
int query_melt_rate();
int query_melt_level();
private void setup_callout();
protected void do_melt();

/**
 * @ignore yes
 */
void create() {
   do_setup++;
   ::create();
   do_setup--;
   _melt_rate = MELT_RATE_DEFAULT;
   _melt_counter = 0;
   set_melt_result( WATER );
   set_decay_speed( 1 );
   setup_callout();
   if ( !do_setup ) {
      this_object()->setup();
   }
   _melt_level = ( this_object()->query_weight() ) * 10;
   _original_melt_level = _melt_level;
}/* create() */


/**
 * This function sets the liquid that the melting food melts into.
 * The default value for this is water.
 *
 * @param result The path of the liquid generated when this food melts
 *
 * @see query_melt_result()
 */
void set_melt_result( string result ) {
   _melt_result = result;
} /* set_melt_result */


/**
 * This function returns the liquid that the melting food melts into.
 * The default value for this is water.
 *
 * @return The path of the liquid generated when this food melts.
 *
 * @see set_melt_result()
 */
string query_melt_result() {
   return _melt_result;
} /* query_melt_result */


/**
 * This function sets the current melt rate for the liquid.  This will
 * have no ostensible affect on the melting of the liquid, as the
 * melt rate is recalculated regularly.
 *
 * @param rate The new rate of melting
 *
 * @see query_melt_rate()
 *
 */
void set_melt_rate( int rate ) {
   _melt_rate = rate;
} /* set_melt_rate */


/**
 * This function returns the current rate of melting of the frozen food.
 *
 * @return The current melt rate of the food.
 *
 * @see set_melt_rate()
 *
 */
int query_melt_rate() {
   return _melt_rate;
} /* query_melt_rate */


/**
 * This function returns the current melt level of the food.  This value
 * starts at ten times the original weight of the object, and decreases
 * in time, as the food melts.
 *
 * @return The current melt level of the food.
 */
int query_melt_level() {
   return _melt_level;
} /* query_melt_level */


/**
 * @ignore yes
 */
private void setup_callout() {
   if( _callout_id ) {
      remove_call_out( _callout_id );
   }
   
   _callout_id = call_out( "do_melt", _melt_rate );
} /* setup_callout */


/**
 * @ignore yes
 */
protected void do_melt() {
   object liquid;
   object room, ob;
   int environment_temp, current_weight;

   /* finds the final container of this object - ie
      the room that the object is within, whether it's
      nested in many containers or not */   
   ob = environment( this_object() );
   
   if( !ob ) {
      return;
   }
   
   room = ob;
   while( ob = environment( ob ) ) {
      room = ob;
   }

   /* sets environment_temp to the temperature of the room, 
      in degrees centigrade */   
   if( room->query_property( "location" ) == "outside" ) {
      environment_temp = WEATHER->query_temperature( room );
   }
   else if( room->query_name() == "clone_on_demand-store" ) {
      environment_temp = 0; // Don't melt if you're in a shop's inventory
   }
   else {
      environment_temp = 20 + room->query_property( "warmth" );
   }
      
   /* if temperature is less than 0, no melt. */
   if( environment_temp > 1 ) {
      /* setup the melt rate dependent on environment temp: hotter 
         environment means faster melting call out */
      if( environment_temp > 50 ) {
         _melt_rate = 1;
      }
      else {
         _melt_rate = _LOOKUP_RATE[ environment_temp ];
      }
      
      /* decrease melt level counter and increase melt counter */
      _melt_level = _melt_level - 1;
      _melt_counter = _melt_counter + 1;
   
      /* if the counter has reached 10 yet, make some liquid and 
         remove some weight */
      if ( _melt_counter >= 10 ) {
         liquid = clone_object( _melt_result );
         liquid->set_amount( 20 );
         liquid->move( environment( this_object() ) );
      
         current_weight = this_object()->query_weight();
         if( current_weight <= 1 ) {
            this_object()->move( "/room/rubbish" );
         }
         else {
            this_object()->set_weight( current_weight - 1 );
         }
         _melt_counter = 0;
      }   
   }
   
   _callout_id = call_out( "do_melt", _melt_rate );
} /* do_melt */


/**
 * This function returns the adjective appended to the food's
 * short description, describing how melted it is.
 *
 * @return The adjectives added to the food's short describing its
 * melt status.
 * @see query_long_decay_level()
 */
string query_short_rotten_adjective() {
   string ret;
   int bing;
   
   bing = 100 - ( ( 100 * _melt_level ) / _original_melt_level );

   ret = "";

   switch ( bing ) {
   case 0..1:
      break;
   case 2..20:
      ret = "slightly melted " + ret;
      break;
   case 21..45:
      ret = "partially melted " + ret;
      break;
   case 46..55:
      ret = "half melted " + ret;
      break;
   case 56..80:
      ret = "mostly melted " + ret;
      break;
   case 81..100:
      ret = "almost completely melted " + ret;
      break;
   }

   return ret; 
} /* query_short_rotten_adjective */


/**
 * This function provides words for the food's long description, 
 * showing how melted the object is.
 * 
 * @return The words appended to the food's long, showing its melt status.
 *
 * @see query_short_rotten_adjective()
*/
string query_long_decay_level() {
   string ret;
   int bing;
   
   bing = 100 - ( ( 100 * _melt_level ) / _original_melt_level );

   ret = "";

   switch ( bing ) {
   case 0..1:
     if( query_collective() && query_amount() > 1 )
        ret += "They have not yet begun to melt.\n";
     else
        ret += "It has not yet begun to melt.\n";
     break;
   case 2..20:
      if( query_collective() && query_amount() > 1 )
         ret += "They have melted slightly.\n";
      else
         ret += "It has melted slightly.\n";
      break;
   case 21..45:
      if( query_collective() && query_amount() > 1 )
         ret += "They have partially melted away.\n";
      else
         ret += "It has partially melted away.\n";
      break;
   case 46..55:
      if( query_collective() && query_amount() > 1 )
         ret += "They are half melted away.\n";
      else
         ret += "It is half melted away.\n";
      break;
   case 56..80:
      if( query_collective() && query_amount() > 1 )
         ret += "They have mostly melted away.\n";
      else
         ret += "It has mostly melted away.\n";
      break;
   case 81..100:
      if( query_collective() && query_amount() > 1 )
         ret += "They have almost complete melted away.\n";
      else
         ret += "It has almost completely melted away.\n";
      break;
   }

    return ret; 
} /* query_long_decay_level */


/*
   Make the person chilly for a while when they eat
   the food.  Then inherits normal eat stuff.
*/
/**
 * @ignore yes
 */
varargs int do_eat( int no_mess ) {
   this_player()->add_property( "warmth", CHILL, CHILL_TIME );
   return( ::do_eat( no_mess ) );
} /* do_eat() */


/*
   Make the victim chilly for a while when they apply
   the food.  Then inherits normal apply stuff.
*/
/**
 * @ignore yes
 */
int do_apply( object * things ) {
   int i;
   if( i = ::do_apply( things ) ) {
      things[ 0 ]->add_property( "warmth", CHILL, CHILL_TIME );
   }
   
   return i;
} /* do_apply() */

/**
 * @ignore yes
 */
int do_rub( object * things ) {
   int i;
   if( i = ::do_rub( things ) ) {
      things[ 0 ]->add_property( "warmth", CHILL, CHILL_TIME );
   }
   return i;
} /* do_rub() */


/**
 * @ignore yes
 */
mixed *stats()
{
   mixed *args;
   args =::stats() + ({ ({ "melt level", _melt_level }),
                        ({ "melt result", _melt_result }),
                        ({ "original melt level", _original_melt_level }),
                        ({ "melt rate", _melt_rate }),
                        ({ "melt counter", _melt_counter }), 
                        ({ "callout id", _callout_id }) });
   return args;
}                               /* stats() */



/*
   This section covers all the loading of global variables
*/
/**
 * @ignore yes
 */
mapping int_query_static_auto_load() {
   return ([ "::" : ::int_query_static_auto_load(),
             "melt_level" : _melt_level,
             "melt_result" : _melt_result,
             "original melt level" : _original_melt_level,
             "melt rate" : _melt_rate,
             "melt counter" : _melt_counter,
             "callout id" : _callout_id ]);
} /* int_query_static_auto_load() */


/**
 * @ignore yes
 */
mapping query_static_auto_load()
{
   if ( ( base_name( this_object() ) != "/obj/food" )
       && !query_continuous() ) {
      return 0;
   }
   return int_query_static_auto_load();
} /* query_static_auto_load() */


/**
 * @ignore yes
 */
void init_static_arg( mapping map )
{
   if ( !mapp( map ) ) {
      return;
   }
   
   if ( map[ "::" ] ) {
      ::init_static_arg( map[ "::" ] );
   }
   _melt_level = map[ "melt_level" ];
   _melt_result = map[ "melt_result" ];
   _original_melt_level = map[ "original melt level" ];
   _melt_rate = map[ "melt rate" ];
   _melt_counter = map[ "melt counter" ];
   _callout_id = map[ "callout id" ];
} /* init_static_arg() */


/**
 * @ignore yes
 */
mapping query_dynamic_auto_load()
{
   return ([ "::" : ::query_dynamic_auto_load(),
             "melt_level" : _melt_level,
             "melt_result" : _melt_result,
             "original melt level" : _original_melt_level,
             "melt rate" : _melt_rate,
             "melt counter" : _melt_counter,
             "callout id" : _callout_id ]);
} /* query_dynamic_auto_load() */


/**
 * @ignore yes
 */
void init_dynamic_arg( mapping map, object )
{
   if ( !mapp( map ) ) {
      return;
   }
   if ( map[ "::" ] ) {
      ::init_dynamic_arg( map[ "::" ] );
   }
   _melt_level = map[ "melt_level" ];
   _melt_result = map[ "melt_result" ];
   _original_melt_level = map[ "original melt level" ];
   _melt_rate = map[ "melt rate" ];
   _melt_counter = map[ "melt counter" ];
   _callout_id = map[ "callout id" ];
} /* init_dynamic_arg() */





/*
   This is all masked stuff from /obj/food.c which stops
   frozen foods being liquids, from being dried, 
   from decaying, from being splashed.
*/


/*
   Frozen things are not liquids
*/
/**
 * @ignore yes
 */
int query_liquid() {
   return 0;
} /* query_liquid() */

/**
 * @ignore yes
 */
void set_liquid() {
} /* set_liquid() */


/*
   do_decay is called by the bits_controller, and, as the 
   frozen item won't decay, does nothing.
*/
/**
 * @ignore yes
 */
void do_decay() {
   return;
} /* do_decay */


/*
   This frozen food doesn't decay - it melts
*/
/**
 * @ignore yes
 */
int query_decays() {
   return 0;
} /* query_decays() */

/**
 * @ignore yes
 */
int query_decay_speed() {
   return 0;
} /* query_decay_speed() */

/**
 * @ignore yes
 */
int query_decay_level() {
   return 0;
} /* query_decay_level() */

/**
 * @ignore yes
 */
void set_decay_speed( int decay ) {
  return( ::set_decay_speed( 1 ) );
} /* set_decay_speed() */


/*
  You cannot cure frozen food.
*/
/**
 * @ignore yes
 */
int do_cure() {
   return 0;
}

/**
 * @ignore yes
 */
int query_cured() { 
   return 0;
}

/**
 * @ignore yes
 */
int do_dry() {
   return 0;
}

/**
 * @ignore yes
 */
int query_dried() { 
   return 0; 
}


/*
   The frozen food won't be rotten.
*/ 
/**
 * @ignore yes
 */
int query_rotten() { 
   return 0;
}


/*
  Can't splash it.
*/
/**
 * @ignore yes
 */
void set_splashable() {
   return;
}

// --- END [/mnt/home2/grok/lib/obj/meltable.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/mineral.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/mineral.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628614   Available: 13575968
Inodes: Total: 5242880    Free: 4960135
9599 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/mineral.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628614   Available: 13575968
Inodes: Total: 5242880    Free: 4960135
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: mineral.c,v 1.9 2003/07/09 10:50:11 carmine Exp $
 * $Log: mineral.c,v $
 * Revision 1.9  2003/07/09 10:50:11  carmine
 * Prevented decay level being set
 *
 * Revision 1.8  2001/06/01 21:59:28  ceres
 * Added helpfile
 *
 * Revision 1.6  2000/11/21 03:15:42  ceres
 * Removed ansi colour sequences, they break in too many places.
 *
 * Revision 1.5  2000/05/24 02:33:26  pinkfish
 * Fix up the mineral code.
 *
 * Revision 1.4  2000/04/26 08:15:14  taffyd
 * Multiple bug fixes.
 *
 * Revision 1.3  2000/04/17 10:30:18  shaggy
 *  Forcibly unlocked by taffyd
 *
 * Revision 1.2  1998/10/30 08:36:08  pinkfish
 * Fix up to use set_name refernece.
 *
 * Revision 1.1  1998/01/06 04:58:17  ceres
 * Initial revision
 * 
*/
#include <mineral.h>

#define HANDLER "/obj/handlers/cmr_handler"
#define PRICE_INDEX "/obj/handlers/cpi_handler"
#define DEFAULT_MARKET "Ankh-Morpork"

inherit "/obj/food";

nosave string mineral;

void create() {
   ::create();
   set_decay_speed(0);
   remove_help_file("food");
   add_help_file("mineral");
} /* create() */

varargs void make_mineral( string word, int number, string *inputs ) {
   string adjective, material_adjective, noun, *args;

   mineral = word;
   set_value_info( "material", 1 );
   material_adjective = (string)HANDLER->query_material_adjective( mineral );
   set_weight( number );
   switch( number ) {
      case 0 .. PEBBLE :
         adjective = "small";
         noun = "pebble";
         break;
      case PEBBLE + 1 .. STONE :
         adjective = "medium sized";
         noun = "stone";
         break;
      case STONE + 1 .. ROCK :
         adjective = "large";
         noun = "rock";
         break;
      default:
         adjective = "huge";
         noun = "boulder";
   }
   if ( !pointerp( inputs ) )
      args = allocate( 10 );
   else
      args = inputs + ({ 0, 0, 0, 0, 0 });
   if ( !args[ 0 ] ) {
      set_name( noun );
      add_plural( noun +"s" );
   } else {
      set_name( args[ 0 ] );
      if ( !args[ 3 ] )
         add_plural( pluralize( args[ 0 ] ) );
      else
         add_plural( args[ 3 ] );
   }
   if ( !args[ 1 ] ) {
      set_short(material_adjective +" "+ noun);
      set_main_plural(material_adjective +" "+ pluralize( noun ));
   } else {
      set_short( args[ 1 ] );
      if ( !args[ 4 ] )
         set_main_plural( pluralize( args[ 1 ] ) );
      else
         set_main_plural( args[ 4 ] );
   }
   if ( !args[ 2 ] )
      set_long( "This is "+ add_a( adjective ) +" lump of $mineral$.\n" );
   else
      set_long( args[ 2 ] );
   add_adjective( ({ adjective }) + explode( material_adjective, " " ) );
} /* make_mineral() */

string long( string words, int dark ) {
   return replace( ::long( words, dark ), "$mineral$",
         (string)HANDLER->identify_material( mineral, this_player(), 1 ) );
} /* long() */

string *parse_command_adjectiv_id_list() {
   return explode( (string)HANDLER->identify_material( mineral,
         this_player(), 0 ), " " ) + ::parse_command_adjectiv_id_list();
} /* parse_command_adjectiv_id_list() */

string query_mineral() { return mineral; }

string query_material() { return mineral; }

void init() {
   ::init();
   this_player()->add_command( "pulverise", this_object(),
         "<direct:object> {with|using} <indirect:object>" );
   this_player()->add_command( "chip", this_object(),
         "<direct:object> {with|using} <indirect:object>" );
   this_player()->add_command( "smash", this_object(),
         "<direct:object> {with|using} <indirect:object>" );
   this_player()->add_command( "sprinkle", this_object(),
         "<direct:object:me> [on] <indirect:object>" );
   this_player()->add_command( "sprinkle", this_object(),
         "<direct:object:me>" );
} /* init() */

int do_eat() {
   if ( (string)this_player()->query_race_ob() != "/std/races/troll" ) {
      this_player()->add_failed_mess( this_object(),
            "What do you think you are, a troll?\n", ({ }) );
      return 0;
   }
   return ::do_eat();
} /* do_eat() */

int check_tool( object *tools, string *needed ) {
   string word;

   if ( sizeof( tools ) > 1 ) {
      write( "You only need to use one tool at a time.\n" );
      return 0;
   }
   if ( !sizeof( tools ) ) {
      write( "You need to use a tool of some sort.\n" );
      return 0;
   }
   if ( member_array( tools[ 0 ],
         (object *)this_player()->query_holding() ) == -1 ) {
      write( "You need to use a tool that you are holding.\n" );
      return 0;
   }
   foreach ( word in needed ) {
      if ( tools[ 0 ]->id( word ) )
         return 1;
   }
   write( "You need to use a tool appropriate to the job.\n" );
   return 0;
} /* check_tool() */

int do_pulverise( object *tools ) {
   string material_adjective;

   if ( !check_tool( tools, ({ "hammer" }) ) )
      return 0;
   if ( query_continuous() ) {
      write( "The "+ (string)HANDLER->identify_material( mineral,
            this_player(), 0 ) +" has already been pulverised.\n" );
      return 0;
   }
   if ( query_weight() > PEBBLE ) {
      write( "This piece of "+ (string)HANDLER->identify_material( mineral,
            this_player(), 0 ) +" is too large to pulverise.\n" );
      return 0;
   }
   material_adjective = (string)HANDLER->query_material_adjective( mineral );
   /* Hmmm... Can't use set_name() and an alias would be confusing, so... */
   set_name("powder");
   set_short(material_adjective +" powder");
   set_main_plural(material_adjective +" powder" );
   add_plural( "powder" );
   add_property( "determinate", "some " );
   add_adjective( ({ "some", "pinch", "pinches", "handful",
         "handfuls", "of" }) );
   set_long( "This is $pile_size$ of "+ material_adjective +
         " powder, $amount_size$.\n" );
   set_weight_unit( ({ 1, 50 }) );
   set_medium_alias( "Powdered" + capitalize(mineral) );
   set_amount_types( ([ "pinch": ({ 1, "pinches" }),
         "handful": ({ 50, "handfuls" }) ]) );
   set_pile_types( ({ 50, "small", 100, "medium", "large" }) );
   set_continuous();
   set_amount( roll_MdN( 5, 10 ) * query_weight() );
   remove_property("encoded destination");
   move( environment() );
   this_player()->add_succeeded( tools[ 0 ] );
   return 1;
} /* do_pulverise() */

int do_chip( object *tools ) {
   object chip;

   if ( query_continuous() )
      return 0;
   if ( !check_tool( tools, ({ "pick", "pickaxe", "hammer" }) ) )
      return 0;
   if ( query_weight() == 1 ) {
      write( "This piece of "+ (string)HANDLER->identify_material( mineral,
            this_player(), 0 ) +" is already a chip.\n" );
      return 0;
   }
   set_weight( query_weight() - 1 );
   chip = clone_object( MINERAL );
   chip->make_mineral( mineral, 1 );
   chip->move( environment() );
   this_player()->add_succeeded( tools[ 0 ] );
   return 1;
} /* do_chip() */

int do_smash( object *tools ) {
   int i, j, largest, number, size;
   object debris, remains;

   if ( query_continuous() )
      return 0;
   if ( !check_tool( tools, ({ "pick", "pickaxe" }) ) )
      return 0;
   if ( query_weight() < ROCK / 2 ) {
      write( "This piece of "+ (string)HANDLER->identify_material( mineral,
            this_player(), 0 ) +" is too small to smash.\n" );
      return 0;
   }
   largest = this_player()->query_max_weight();
   if ( largest >= query_weight() )
      largest = query_weight();
   else {
      remains = clone_object( MINERAL );
      remains->make_mineral( mineral, query_weight() - largest );
      remains->move( environment() );
   }
   tools[ 0 ]->hit_weapon( largest, "blunt" );
   number = 2 + random( 4 );
   for ( i = 0; i < 8; i++ ) {
      largest /= number;
      for ( j = 1; j < number; j++ ) {
         size = ( 3 * largest + random( largest ) ) / 4;
         if ( size ) {
            debris = clone_object( MINERAL );
            debris->make_mineral( mineral, size );
            debris->move( environment() );
          }
       }
   }
   this_player()->add_succeeded( tools[0] );
   move( "/room/rubbish" );
   return 1;
} /* do_smash */

int do_sprinkle(object *obs) {
    if (!query_continuous())
      return notify_fail(
        "You should pulverise the stuff before you sprinkle it.\n");

   if (!sizeof(obs)) {
     obs=({ environment(this_player()) });
     this_player()->add_succeeded_mess(this_object(),
       "$N $V $D everywhere.\n",({ }));
   } else {   
     this_player()->add_succeeded_mess(this_object(),
       "$N $V $D on $I.\n",({ obs[0] }));
   }

   obs[0]->add_effect("/std/effects/other/powdered", 
                      (string)HANDLER->query_material_adjective( mineral ) +
                      " powder" );
   call_out("move",0,"/room/rubbish");
   return 1;
} /* do_sprinkle() */

mixed *stats() {
   return ::stats() + ({
      ({ "mineral", mineral, }),
   });
} /* stats() */

mapping int_query_static_auto_load() {
   return ([
      "::" : ::int_query_static_auto_load(),
      "mineral" : mineral,
   ]);
} /* int_query_static_auto_load() */

void init_static_arg( mapping map ) {
   if ( map[ "::" ] )
      ::init_static_arg( map[ "::" ] );
   if ( !undefinedp( map[ "mineral" ] ) )
      mineral = map[ "mineral" ];
   set_decay_speed(0);
} /* init_static_arg() */

mapping query_static_auto_load() {
   if ( ( explode( file_name( this_object() ), "#" )[ 0 ] == "/obj/mineral" )
         || query_continuous() )
      return int_query_static_auto_load();
   return ([ ]);
} /* query_static_auto_load() */


/*
 * This stops the decay level being set - just in case
*/
void set_decay_level( int level ) {
   ::set_decay_level( 0 );
   return;
} /* set_decay_level */

// --- END [/mnt/home2/grok/lib/obj/mineral.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/scabbards/.belt_loop.sca_virtual_.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/scabbards/.belt_loop.sca_virtual_.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628612   Available: 13575966
Inodes: Total: 5242880    Free: 4960135
1128 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/scabbards/.belt_loop.sca_virtual_.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628612   Available: 13575966
Inodes: Total: 5242880    Free: 4960135
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <virtual.h>

void dest_me() { destruct( this_object() ); }

void create()
{
  seteuid( (string)"/secure/master"->creator_file( file_name( this_object() ) ) );
} /* create() */

object create_virtual_ob() {
   object clone;

  clone = (object)SERVER->create_virtual_object( "/obj/scabbard.c", 1 );
  clone->add_property( VIRTUAL_NAME_PROP, "/obj/scabbards/belt_loop.sca#1" );
  call_other( clone, "set_name", "loop"  );
  call_other( clone, "add_adjective", ({ "belt", "belt loop" })  );
  call_other( clone, "add_alias", "belt loop"  );
  call_other( clone, "set_short", "belt loop"  );
  call_other( clone, "set_long", "This loop is made from the finest leather, designed to "         "hold axes or hammers safely.\n"  );
  call_other( clone, "set_weight", 8  );
  call_other( clone, "set_value", 800  );
  call_other( clone, "set_type", "belt scabbard"  );
  call_other( clone, "add_property", "no recycling", 1  );
  call_other( clone, "setup_scabbard", 10000  );
  call_other( clone, "set_damage_chance", 15  );
  call_other( clone, "set_types", ({ "axe","hammer" }) );
   return clone;
} /* create_virtual_ob() */
// --- END [/mnt/home2/grok/lib/obj/scabbards/.belt_loop.sca_virtual_.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/scabbards/.dagger_scabbard.sca_virtual_.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/scabbards/.dagger_scabbard.sca_virtual_.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628611   Available: 13575965
Inodes: Total: 5242880    Free: 4960135
1067 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/scabbards/.dagger_scabbard.sca_virtual_.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628611   Available: 13575965
Inodes: Total: 5242880    Free: 4960135
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <virtual.h>

void dest_me() { destruct( this_object() ); }

void create()
{
  seteuid( (string)"/secure/master"->creator_file( file_name( this_object() ) ) );
} /* create() */

object create_virtual_ob() {
   object clone;

  clone = (object)SERVER->create_virtual_object( "/obj/scabbard.c", 1 );
  clone->add_property( VIRTUAL_NAME_PROP, "/obj/scabbards/dagger_scabbard.sca#1" );
  call_other( clone, "set_name", "scabbard"  );
  call_other( clone, "add_adjective", "dagger"  );
  call_other( clone, "set_short", "dagger scabbard"  );
  call_other( clone, "set_long", "Similar in design to the scabbard made for longer bladed weapons."         "  In fact you could say they were the same, except for the size.\n"  );
  call_other( clone, "set_weight", 3  );
  call_other( clone, "set_value", 30  );
  call_other( clone, "set_type", "small scabbard"  );
  call_other( clone, "setup_scabbard", 10000  );
  call_other( clone, "set_damage_chance", 15  );
  call_other( clone, "set_types", ({ "dagger", "knife" }) );
   return clone;
} /* create_virtual_ob() */
// --- END [/mnt/home2/grok/lib/obj/scabbards/.dagger_scabbard.sca_virtual_.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/holdable.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/holdable.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628611   Available: 13575965
Inodes: Total: 5242880    Free: 4960135
1919 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/holdable.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628611   Available: 13575965
Inodes: Total: 5242880    Free: 4960135
2006-10-07 20:59:56.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: holdable.c,v 1.1 2001/04/18 23:20:37 pinkfish Exp $
 *
 *
 */
/**
 * The holdable inherit.  This is to make something holdable that is not
 * a weapon, for example torches and candles.
 * @author Pinkfish
 * @started Wed Apr 18 16:13:17 PDT 2001
 */

#include <move_failures.h>
inherit "/std/object";
inherit "/std/basic/holdable";

void create() {
   holdable::create();
   object::create();
} /* create() */

/** @ignore yes */ 
void dest_me() {
   holdable::dest_me();
   object::dest_me();
} /* dest_me() */

/** @ignore yes */ 
mixed query_dynamic_auto_load() {
  return ([ "::" : object::query_dynamic_auto_load(),
            "hold" : holdable::query_dynamic_auto_load(),
          ]);
} /* query_dynamic_auto_load() */

/** @ignore yes */ 
void init_dynamic_arg( mapping arg ) {
   if (arg["hold"]) {
      holdable::init_dynamic_arg(arg["hold"], arg["is lit"]);
   }
   ::init_dynamic_arg(arg["::"]);
} /* init_dynamic_arg() */

/** @ignore yes */ 
void init_static_arg( mapping map ) {
   if ( !mapp( map ) ) {
      return ;
   }
   if ( map[ "::" ] ) {
      object::init_static_arg( map[ "::" ] );
   }
   holdable::init_static_arg(map["hold"]);
} /* init_static_arg() */

/** @ignore yes */ 
mapping int_query_static_auto_load() {
   mapping tmp;

   tmp = object::int_query_static_auto_load();
   return ([ "::" : tmp,
      "hold" : holdable::query_static_auto_load(),
          ]);
} /* int_query_static_auto_load() */

/** @ignore yes */ 
mapping query_static_auto_load() {
   if ( base_name( this_object() ) == "/obj/holdable" ) {
      return int_query_static_auto_load();
   }
   return 0;
} /* query_static_auto_load() */

/** @ignore yes */ 
varargs int move( mixed ob, string mess1, string mess2 ) {
   int ret;

   ret = holdable::move(ob);
   if (ret != MOVE_OK) {
      return ret;
   }
   return object::move( ob, mess1, mess2 );
} /* move() */
// --- END [/mnt/home2/grok/lib/obj/holdable.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/baggage.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/baggage.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628610   Available: 13575964
Inodes: Total: 5242880    Free: 4960135
9107 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/baggage.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628610   Available: 13575964
Inodes: Total: 5242880    Free: 4960135
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: baggage.c,v 1.27 2003/01/30 16:43:07 taffyd Exp $
 * $Log: baggage.c,v $
 * Revision 1.27  2003/01/30 16:43:07  taffyd
 * Added parse_command_adjectiv_id_list() method to add adjectives for 'closed' and 'locked' from the close_lock_container inheritable
 *
 * Revision 1.26  2001/11/14 02:50:06  presto
 * Added set_open call in create().  I think this is needed so that the "open" adjective
 * is added by default
 *
 * Revision 1.25  2001/08/25 02:00:44  ceres
 * Removed compile warning
 *
 * Revision 1.23  2001/06/01 22:27:25  ceres
 * Added help file
 *
 * Revision 1.22  2001/04/28 16:15:58  shrike
 * fixed runtiming move()
 *
 * Revision 1.21  2001/04/14 00:48:40  ceres
 * Returned the max item limit. Not sure where it disappeared to.
 *
 * Revision 1.20  2000/07/14 22:03:55  pinkfish
 * Stop it using a global variable from elsewhere.
 *
 * Revision 1.19  2000/04/19 21:13:59  ceres
 * Made it call set_closed() before set_locked() when restoring furniture.
 *
 * Revision 1.18  2000/03/28 04:49:03  ceres
 * Removed the short_status() stuff, it just doesn't work due to the callouts. If they're too short it gives the wrong short one way if its too long it does it the other way. There's no way to win.
 *
 */
/* Copied from /obj/container.c.  The idea is to remove the
 * liquid and potion-space stuff, since it's not needed for chests
 * and sacks.
 * @author Jeremy, Pinkfish, Ember
 * @see /obj/vessel.c
 */

#include <move_failures.h>

inherit "/std/container";
inherit "/std/basic/close_lock_container";
inherit "/std/basic/condition";
inherit "/std/basic/holdable";

void create() {
  do_setup++;
  container::create();
  close_lock_container::create();
  condition::create();
  holdable::create();
// set_max_weight( 5 );
  set_max_cond(400);
  set_cond(400);
  set_damage_chance(20);
  set_can_export_inventory();
  set_opaque();
  set_open();
  do_setup--;
  if ( !do_setup ) {
    this_object()->setup();
  }
  add_help_file("baggage");
} /* create() */

/** @ignore yes */
void init() {
  close_lock_container::init();
} /* init() */

/** @ignore yes */
int add_weight( int n ) {
  if ( !( ::add_weight( n ) ) ) return 0;
  if ( n >= 0 ) {
    remove_call_out( "check_breakages" );
    call_out( "check_breakages", 5 + random( 16 ) );
  }
  return 1;
} /* add_weight() */

/**
 * This method checks to see if any of the things contained in the
 * container should be broken.
 * @see /std/container->add_weight()
 */
void check_breakages() {
/* check loc_weight against fragility of every object and break some
 *   if necessary.  If the container has the "padded" property, adjust
 *   the chance of breakage.
 */
  object *obs, carrier;
  int i, amt, wt;

  // See if it's being carried by a living object
  carrier = environment(this_object());
  while (carrier && (!living(carrier)))
    carrier = environment(carrier);
  if (!carrier)
    return;
  obs = all_inventory();
  wt = query_loc_weight() - (int)query_property("padded");
  for (i=0;i<sizeof(obs);i++)
    if ((amt = obs[i]->query_property("fragile"))) {
      if (wt <= amt || ((wt - amt)*100)/amt <= random(100))
          obs[i] = 0;
    } else
      obs[i] = 0;

  obs = obs - ({ 0 });
  if (sizeof(obs) && environment(carrier)) {
    tell_room(environment(carrier), carrier->the_short()+" breaks "+
          (sizeof(obs)>1?"some things":"one thing")+" in "+
          query_multiple_short(({ this_object() }))+".\n", ({ carrier }));
    tell_object(carrier, "You break "+query_multiple_short(obs)+" in "+
          query_multiple_short(({ this_object() }))+".\n");
    obs->dest_me();
  }
}

/** @ignore yes */
string long( string word, int dark ) {
  string ret;

  ret = ::long( word, dark );
  ret += cond_string();
  if ( query_transparent() || !query_closed() ) {
    if (dark == 2 ||
        dark == -2) {
       if (query_contents() != "") {
          ret += "$C$$the_short:" + file_name(this_object()) + "$ contains "
                 "some items you cannot make out.\n";
       }
    } else {
       ret += query_contents( "$C$$the_short:"+ file_name( this_object() ) +
           "$ contains " );
    }
  }
  ret += long_status();
  return ret;
} /* long() */

/**
 * This method returns true if the object is open and prints a message
 * about the open status of the object.
 * @return 1 if it is open, 0 if not
 */
int ensure_open() {
  if ( query_locked() ) {
      write( "The "+ short( 0 ) +" is locked.\n" );
      return 0;
   }
   if ( query_closed() ) {
      if ( do_open() ) {
         write( "You open the "+ short( 0 ) +".\n" );
         return 1;
      } else {
         write( "You can't open the "+ short( 1 ) +".\n" );
         return 0;
      }
   }
   return 1;
} /* ensure_open() */

/** @ignore yes */
mixed stats() {
   return container::stats() + close_lock_container::stats();
} /* stats() */

/** @ignore yes */
mapping int_query_static_auto_load() {
  return ([
    "::" : container::int_query_static_auto_load(),
    "condition" : condition::query_static_auto_load(),
    "hold" : holdable::query_static_auto_load(),
    "trans" : query_transparent(),
    "difficulty" : query_difficulty(),
    "key" : query_key(),
    "trap open func" : query_open_trap_func(),
    "trap lock func" : query_lock_trap_func(),
    "trap open ob" : query_open_trap_ob(),
    "trap lock ob" : query_lock_trap_ob(),
  ]);
} /* int_query_static_auto_load() */

/** @ignore yes */
mapping query_dynamic_auto_load() {
   return ([
     "::" : container::query_dynamic_auto_load(),
     "condition" : condition::query_dynamic_auto_load(),
     "hold" : holdable::query_dynamic_auto_load(),
     "locked" : query_locked(),
     "stuck" : query_stuck(),
     "closed" : query_closed(),
   ]);
} /* query_dynamic_auto_load() */

/** @ignore yes */
void init_dynamic_arg(mapping map, object) {
  object money;

  if (map["::"]) {
    container::init_dynamic_arg(map["::"]);
  }

  if (map["condition"]) {
    condition::init_dynamic_arg(map["condition"]);
  }
  if (map["hold"]) {
    holdable::init_dynamic_arg(map["hold"]);
  }

  if (sizeof(map["money"])) {
     money = clone_object("/obj/money");
     money->set_money_array(map["money"]);
     money->move(this_object());
  }
  // Note, closed must be done before locked!
  if (map["closed"]) {
     set_closed();
  } else {
     set_open();
  }
  if (map["locked"]) {
     set_locked();
  } else {
     set_unlocked();
  }
  set_stuck(map["stuck"]);
} /* init_dynamic_arg() */

/** @ignore yes */
void init_static_arg(mapping args) {
  if (args["::"]) {
    ::init_static_arg(args["::"]);
  }
  if (args["condition"]) {
    condition::init_static_arg(args["condition"]);
  }
  if (args["hold"]) {
    holdable::init_static_arg(args["hold"]);
  }
  if (!undefinedp(args["trans"])) {
    if (args["trans"]) {
       set_transparent();
    } else {
       set_opaque();
    }
  }
  if (!undefinedp(args["difficulty"])) {
    set_difficulty(args["difficulty"]);
  }
  if (!undefinedp(args["key"])) {
    set_key(args["key"]);
  }
  if (!undefinedp(args["trap open func"])) {
    set_open_trap(args["trap open ob"], args["trap open func"]);
  }
  if (!undefinedp(args["trap lock func"])) {
    set_lock_trap(args["trap lock ob"], args["trap lock func"]);
  }

  //
  // Make sure you cannot have infite capacity bags.
  //
  if (!query_max_weight()) {
     set_max_weight(5);
  }

} /* init_static_arg() */

/** @ignore yes */
mixed query_static_auto_load() {
  if ( !query_name() || ( query_name() == "object" ) ) {
    return 0;
  }
  if ( explode( file_name( this_object() ), "#" )[ 0 ] == "/obj/baggage" ) {
    return int_query_static_auto_load();
  }
  return ([ ]);
} /* query_static_auto_load() */

/** @ignore yes */
int can_find_match_recurse_into(object looker) {
   if (query_closed()) {
      return 0;
   }
   return ::can_find_match_recurse_into(looker);
} /* can_find_match_recurse_into() */

/**
 * @ignore yes
 * Thijs is added so that it acts like a living object and
 * things like non-movable signs cannot be added to it.
 */
int test_add(object ob, int flag) {
  if(flag)
    return 0;
  return ::test_add(ob, flag);
} /* test_add() */

/**
 * @ignore yes
 * Added here to make it expose its inventory upwards when moved.
 */
varargs int move(mixed dest, string mess1, string mess2) {
   object from;
   int result;

   result = holdable::move(dest);
   if (result != MOVE_OK) {
      return result;
   }
   from = environment();
   result = container::move(dest, mess1, mess2);
   if (result == MOVE_OK) {
      we_moved(from, environment());
   }
   return result;
} /* move() */

/**
 * @ignore yes 
 */
string *parse_command_adjectiv_id_list() {
    return container::parse_command_adjectiv_id_list() + 
        close_lock_container::parse_command_adjectiv_id_list();
} /* parse_command_adjectiv_id_list() */ 

/** @ignore yes */
void break_me() {
  all_inventory()->move( environment(), "$N fall$s out of " + a_short() +"." );
  ::break_me();
} /* break_me() */

/** @ignore yes */
void dest_me() {
   close_lock_container::dest_me();
   container::dest_me();
} /* dest_me() */
// --- END [/mnt/home2/grok/lib/obj/baggage.c] ---
