#/obj/handlers/autodoc/autodoc_file.c
public_functions (["set_maximum":({({"int",}),({({"string",}),"board",({"int",}),"max",}),(["main":({"Set the maximum number of message before they start being auto deletedwhen someone posts to the board.",}),"param":({"board the board to set the maximum for","max the maximum number of messages",}),"return":({"0 if it failed and 1 on success",}),]),}),"set_minimum":({({"int",}),({({"string",}),"board",({"int",}),"min",}),(["main":({"Sets the minimum number of message to keep on a board.  If there is lessthan thisnumber then they will not be auto deleted.",}),"param":({"board the board to set the minimum for","min the number of message to keep",}),"return":({"0 on failure and 1 on success",}),]),}),"set_board_order":({({"int",}),({({"string",}),"player",({"string","*",}),"new_order",}),(["main":({"Set the order boards should be shown in for a given player.",}),"param":({"string a players name","string * the list of boards",}),"return":({"1 for success, 0 for failure",}),]),}),"query_idiot":({({"int",}),({({"string",}),"idiot",}),(["main":({"This method returns if they are an idiot and when their period ofidiocy runs out.",}),"param":({"idiot the idiot to check",}),"return":({"0 if not an idiot, the time left otherwise",}),]),}),"test_can_read":({({"int",}),({({"string",}),"board",({"object",}),"previous",({"string",}),"name",}),(["main":({"Check to see if read access is allowed.",}),"param":({"board the board to check","previous the previous object","name the name of the person doing stuff",}),"return":({"1 if it is allowed, 0 if not",}),]),}),"query_timeout":({({"int",}),({({"string",}),"board",}),(["main":({"Return the timeout time of the board.",}),"see":({"set_timeout()",}),"param":({"board the board to get the timeout for",}),"return":({"the timeout in seconds",}),]),}),"query_archive":({({"string",}),({({"string",}),"board",}),(["main":({"Return the archive file location for the board.",}),"param":({"board the board to get the archive location for",}),"return":({"the archive file location, 0 on failure",}),]),}),"save_me":({({"void",}),({}),(["main":({"Saves the state of the object.",}),]),}),"query_killfile":({({"int",}),({({"string",}),"player",({"string",}),"board",}),(["main":({"Find out if a given board is in a player killfile",}),"param":({"string the name of the player","string the name of the board (in lowercase)",}),"return":({"1 if it is, 0 if it isn't",}),]),}),"set_method_access_call":({({"int",}),({({"string",}),"board",({"string",}),"method",({"string",}),"name",}),(["main":({"This method sets the method to call to check for allowed postingsto a board setup as an method controlled post board.",}),"param":({"board the name of the board to setup the method for","method the method to call on the object","name the object to call the method on",}),"return":({"0 if the method failed, 1 if it was successful",}),]),}),"query_boards":({({"string","*",}),({}),(["main":({"Returns the names of all the boards.",}),"return":({"the names of all the boards",}),]),}),"set_newsrc":({({"int",}),({({"string",}),"player",({"mapping",}),"newsrc",}),(["main":({"Set someones newsrc",}),"param":({"string the name of the player","mapping their new newsrc",}),"return":({"1 for success, 0 for failure",}),]),}),"add_message":({({"int",}),({({"string",}),"board",({"string",}),"cap_name",({"string",}),"subject",({"string",}),"body",({"int",}),"reply_to",({"class","reply_type",}),"bing",}),(["main":({"Adds a new message onto the board.  This call can only be done fromverified source, like the bulletin oard objects themselves.  Thenumber used as a reply to should be the message number itself, notthe logical index.  If the reply_to is 0 then it is notreplying to anything at all.",}),"param":({"board the board to add the message to","cap_name the name ofthe person posting","subject the subject of the message","body the main section of the text","reply_to the note the message is replying to",}),"return":({"the note number, or 0 on failure",}),]),}),"query_privilage":({({"int",}),({({"string",}),"board",}),(["main":({"This method returns the current privilage level of the board inquestion.  This should be used for testing only.",}),"return":({"the current privilage level",}),]),}),"query_num":({({"int",}),({}),(["main":({"The current max board number. ",}),]),}),"delete_message":({({"int",}),({({"string",}),"board",({"int",}),"off",({"string",}),"override_name",}),(["main":({"Remove a message from a board.  The offset is the offset into thesubjects array.",}),"param":({"board the board to remove the message from","off the offset to delete","override_name used by the web boards",}),"return":({"0 on failure and 1 on success",}),]),}),"query_maximum":({({"int",}),({({"string",}),"board",}),(["main":({"Return the maximum number of message allowed on the board.",}),"param":({"board the board to get the maximum numbr of message for",}),"return":({"0 on failure, the maximum number of messages on success",}),]),}),"get_subjects":({({"varargs","mixed",}),({({"string",}),"name",({"string",}),"person",}),(["main":({"Get the subjects for the specifed board.  The subjects arereturns in a special array format.  See the include file for thedefines to get at the members of the array.",}),"param":({"name the board name to lookup",}),"see":({"/include/board.h",}),"return":({"the subject array",}),]),}),"query_minimum":({({"int",}),({({"string",}),"board",}),(["main":({"Return the minimum number of message allowed on the board.",}),"param":({"board the board to get the minimum numbr of message for",}),"return":({"0 on failure, the minimum number of messages on success",}),]),}),"add_allowed":({({"int",}),({({"string",}),"board",({"string",}),"name",}),(["main":({"Adds a member into the security array for a board.  This allowscertain people to read boards they may not normaly haveaccess to.",}),"param":({"board the board to change the access on","name the name of the person to add to the array",}),"return":({"0 on failure, 1 on success",}),]),}),"can_delete_message":({({"int",}),({({"string",}),"board",({"int",}),"off",({"string",}),"pname",}),(["main":({"Check to see if the named person can delete the message.",}),"see":({"delete_message()",}),"param":({"pname the player name","board the board name","off the offset to delete",}),]),}),"query_restricted_access":({({"int",}),({({"string",}),"board",}),(["main":({"This method checks to see if the board is in restricted access mode.",}),"param":({"board the name of the board to check",}),"return":({"1 if it is, 0 if it is not",}),]),}),"set_killfile":({({"int",}),({({"string",}),"player",({"string",}),"board",}),(["main":({"Add a board to someones killfile",}),"param":({"string the name of the player","string the name of the board (in lowercase)",}),"return":({"1 for success, 0 for failure",}),]),}),"query_restricted_access_file":({({"int",}),({({"string",}),"board",}),(["main":({"This method checkes to see if the board is in restricted access filemode.",}),"param":({"board the name of the board to check",}),"return":({"1 if it is, 0 if it is not",}),]),}),"query_no_inform":({({"int",}),({({"string",}),"board",}),(["main":({"This method checks to see if the board is in a no inform mode.",}),"param":({"board the name of the board to check",}),"return":({"1 if it is no inform, 0 if not",}),]),}),"create_board":({({"int",}),({({"string",}),"board",({"int",}),"priviliges",({"string",}),"person",}),(["main":({"Create a new board.",}),"param":({"board the name of the board to create","priva is this board only allowed prviliged access?","person the person to add into the security array initialy",}),"return":({"0 on a failure, 1 on success",}),]),}),"delete_board":({({"int",}),({({"string",}),"board",}),(["main":({"Complete erase a board.",}),"param":({"board the board to delete",}),"return":({"0 on failure and 1 on success",}),]),}),"is_idiot":({({"int",}),({({"string",}),"name",}),(["main":({"This method checks to see if the specified person is an idiot ornot.",}),"param":({"name the name to check",}),"return":({"1 if they are an idiot",}),]),}),"get_message":({({"string",}),({({"string",}),"board",({"int",}),"num",({"string",}),"person",}),(["main":({"Get the text of a specific message.  This will look up thetext on a board with the given number and return that to thecaller.  The number is the offset into the subject array inwhich to get the message from.",}),"param":({"board the board name to get the message from","num the message number to use",}),"return":({"the message or 0 if it failed",}),]),}),"stats":({({"mixed","*",}),({}),([]),}),"is_board":({({"int",}),({({"string",}),"board",}),(["main":({"This method tests to see if the board exists.",}),"param":({"board the name of the board to check",}),"return":({"1 if the board exists, 0 if it does not",}),]),}),"query_prevent_shadow":({({"int",}),({}),(["main":({"Prevents the object from being shadowed. ",}),]),}),"query_cache":({({"void",}),({}),([]),}),"test_can_delete":({({"int",}),({({"string",}),"board",({"object",}),"previous",({"string",}),"name",}),(["main":({"Check to see if delete is allowed.",}),"param":({"board the board to check","previous the previous object","name the name of the person doing stuff",}),"return":({"1 if it is allowed, 0 if not",}),]),}),"remove_killfile":({({"int",}),({({"string",}),"player",({"string",}),"board",}),([]),}),"add_idiot":({({"void",}),({({"string",}),"idiot",({"int",}),"length",}),(["main":({"This method adds an idiot to the current list of idiots.",}),"param":({"idiot the idiot to add","length the amount of days to add them for",}),]),}),"query_newsrc":({({"mapping",}),({({"string",}),"player",}),(["main":({"Get someones newsrc",}),"param":({"string the name of the player",}),"return":({"mapping their newsrc",}),]),}),"set_timeout":({({"int",}),({({"string",}),"board",({"int",}),"timeout",}),(["main":({"Change the time before a message automatic gets deleted off aboard.",}),"param":({"board the name of the board to set the timeout for","timeout the timeout (in seconds)",}),"return":({"0 on failure and 1 on success",}),]),}),"list_of_boards":({({"string","*",}),({}),(["main":({"The names of all the boards.",}),"see":({"query_boards()",}),"return":({"the list of all the boards",}),]),}),"set_archive":({({"int",}),({({"string",}),"board",({"string",}),"file",}),(["main":({"Set the archive file location.  This is where all deleted messageswil be stored.",}),"param":({"board the board to set the archive for","file the file name to set it to",}),"return":({"0 on failure and 1 on success",}),]),}),"force_board_method_access_restricted":({({"int",}),({({"string",}),"board",}),(["main":({"This method changes the type of the board to be a method access callaccess restriction, instead of whatever it had before.",}),"param":({"board the name of the board to control the access for",}),]),}),"clean_cache":({({"void",}),({}),([]),}),"query_security":({({"string","*",}),({({"string",}),"board",}),(["main":({"Returns the security array for the given board.",}),"param":({"board the board to get the security array for",}),"return":({"the security array",}),]),}),"list_killfile":({({"string","*",}),({({"string",}),"player",}),(["main":({"Retrieve a players killfile list",}),"param":({"string the players name",}),"return":({"string * the list of boards in their killfile",}),]),}),"remove_allowed":({({"int",}),({({"string",}),"board",({"string",}),"name",}),(["main":({"Remove someone from the allowed array of the board.",}),"param":({"board the board to remove the person from","name the name of the person to remove",}),"return":({"0 on nfailure and 1 on success",}),]),}),"query_board_order":({({"string","*",}),({({"string",}),"player",}),(["main":({"Retrieve someones chosen board order.",}),"param":({"string the players name",}),"return":({"the list of boards, in order",}),]),}),"expire_boards":({({"void",}),({}),(["main":({"This method runs through all the messages and expires any which aretoo old.",}),]),}),"test_can_write":({({"int",}),({({"string",}),"board",({"object",}),"previous",({"string",}),"name",}),(["main":({"Check to see if write access is allowed.",}),"param":({"board the board to check","previous the previous object","name the name of the person doing stuff",}),"return":({"1 if it is allowed, 0 if not",}),]),}),"query_read_only":({({"int",}),({({"string",}),"board",}),(["main":({"This method checks to see if the board is in a read only mode.",}),"param":({"board the name of the board to check",}),"return":({"1 if it is read only, 0 if not",}),]),}),])
protected_functions ([])
inherits ([])
main_docs (["main":({"Keeps track of all the bulletin board notes and related information.",}),"index":({"bulletin",}),"author":({"Pinkfish",}),])
define_docs (["BACKUPS_DIR":([]),"BOARD_HANDLE_VERSION":([]),"T_TIMEOUT":([]),"T_MAX":([]),"ARCHIVE_DIR":([]),"T_MIN":([]),"DEFAULT_TIMEOUT":([]),"NEWSRC_SAVE_DELAY":([]),"MAX_ARCHIVE_SIZE":([]),"CACHE_TIMEOUT":([]),"NEWSRC_SAVE_DIR":([]),"BACKUP_TIME_OUT":([]),"CACHE_SIZE":([]),"DEFAULT_MAX":([]),"DEFAULT_MIN":([]),])
includes (["/include/player_handler.h":1522061544,"/include/am_time.h":1522061544,"/include/board.h":1522061544,"/include/mail.h":1522061544,"/include/clubs.h":1522061544,])
class_docs (["newsrc":({0,({({"cached",({"int",}),}),({"changed",({"int",}),}),({"newsrc",({"mapping",}),}),({"kill",({"string","*",}),}),({"board_order",({"string","*",}),}),}),([]),}),"read_access_cache":({0,({({"read_time",({"int",}),}),({"read_access",({"int",}),}),}),([]),}),])
file_name "/obj/handlers/board_handler.c"
last_changed 1522061544
