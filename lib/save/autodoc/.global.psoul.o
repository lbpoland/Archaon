#/obj/handlers/autodoc/autodoc_file.c
public_functions (["adjust_time_left":({({"int",}),({({"int",}),"i",}),(["main":({"Change the amount of time a player has left.  You call this after a commandhas been executed to make it take more time.",}),"param":({"i the amount of time units to change by",}),"return":({"the amount of time left",}),]),}),"lower_check":({({"int",}),({({"string",}),"str",}),(["main":({"This function will get called when all other commands and actionshave refused to do anything for this input from the user.  Thisfunction adds some extra time for the user, and then returns.<p>This function is registered via add_action() with a priority of -10000.  If you want to bypass it, then use a priorityhigher than that.  If you want to see what strings get dropped by theentire add_action() stack, then use a priority lower.",}),"parms":({"str the user's input",}),"return":({"1 if the user's input is \"stop\", otherwise 0.",}),]),}),"set_interrupt_command":({({"void",}),({({"function",}),"func",}),(["main":({"Fixes a spelling error.   This one only takes a function pointer as aninput.",}),"param":({"func the function pointer to call back with",}),]),}),"query_time_left":({({"int",}),({}),(["main":({"The amount of time units left.  A time unit is 1/40th of a second.",}),]),}),"soul_commands":({({"void",}),({}),(["main":({"This is a setup function that is called by the player object.It is used to register the lower_check() and drunk_check()functions.  Plus it initializes the alias object, thenickname object, and the history object.",}),]),}),"query_queued_commands":({({"int",}),({}),(["main":({"You can use this function to see if there are any commandsqueued for this player.",}),"return":({"the number of queued commands",}),]),}),"soul_com_force":({({"int",}),({({"string",}),"str",}),(["main":({"Some of the soul commands force the target to do something.An example is the 'tickle' soul, which forces the target to'giggle'.  Those soul-forces call this function.  But onlythe soul object can use this function: any other object which callsthis function will be ignored.  This prevents this functionfrom being used to bypass the security checking on the'force' command.",}),"param":({"str the command being forced",}),"return":({"0 if the command was ignored, otherwise 1.",}),]),}),"remove_queue":({({"void",}),({}),(["main":({"This is called by the stop command.  It sets the entire queue back toempty.  It calls the interrupt functions and stuff if they need to becalled.",}),]),}),"interupt_command":({({"void",}),({({"object",}),"interupter",}),(["main":({"This method interupts the current command.",}),"param":({"interupter the person interupting the command",}),]),}),"no_time_left":({({"void",}),({}),(["main":({"Ensure that the player has no more time for executing commands.This will force the next command to be queued.",}),]),}),"bypass_queue":({({"void",}),({}),(["main":({"To make the next single command be executed directly ratherthan being placed in the command queue, call this function.",}),]),}),"command_override":({({"void",}),({({"function",}),"func",}),(["main":({"Use this function to set a function that is called with the players inputbefore the command handlers get to it, return 1 from the function if theinput needs no further parsing (ie the command is handled)",}),"param":({"func = function in the players environment to call.",}),]),}),"query_interupt_command":({({"mixed","*",}),({}),(["main":({"This method returns the current value associated with tine interuptcommand.",}),"return":({"the current interupt command data",}),]),}),"do_soul":({({"void",}),({({"string",}),"str",({"mixed",}),"bing",}),(["main":({"All soul commands eventually call this function to output theirmessages.  This is nothing more than a wrapper for say(), butit provides a convenient name by which a shadow on theplayer object can replace any soul behavior.",}),"prarm":({"bing the avoid array",}),"param":({"str the string being printed",}),]),}),"set_interupt_command":({({"void",}),({({"mixed",}),"func",({"mixed",}),"ob",({"mixed",}),"arg",}),(["main":({"Sets the function to be executed if the command is interrupted.It is also executed if teh command finished.  If it is interruptedthe first arguement to the called function will be the amount of timeit had left to complete.  If it complets successfuly, thisargument will be 0.  If the first argument is a function pointer,this will be used instead.<p>Eg: set_interupt_command(\"frog\", this_object());<p>void frog(int time_left, mixed arg) { <p>... <p>}",}),"param":({"func the function to call back","ob the object to call the function on","arg the argument to pass to the function",}),"example":({"...void frog(int time_left, mixed arg);...set_interupt_commant((: frog :));...void frog(int time_left, mixed arg) {   ...} /* frog() */",}),]),}),])
protected_functions (["process_input":({({"string",}),({({"string",}),"str",}),(["main":({"This is the command called by the driver on a player object everytime a command is executed.  It expands the history comands.",}),"param":({"str the string to expand",}),"return":({"the expanded history string",}),]),}),"flush_queue":({({"void",}),({}),(["main":({"This method flushes all the queued commands.  It increments the time by theROUND_TIME define and checks to see if any of the commands now need to beexecuted.  This should be called each heart beat..",}),"see":({"/global/player->heart_beat()",}),]),}),"drunk_check":({({"int",}),({({"string",}),"str",}),(["main":({"This poorly named function was originally used to affect theplayer's behavior when they are drunk, and to prevent anyplayer from doing anything in the event that they are passedout.  Now the function also is responsible for adding commandsto the player's command queue, for implementing the 'stop'and 'restart' commands, and for ensuring that the player can quitthe game, even when queueing.<p>To see if a player is passed out, it checks the\"passed out\" property.  If that property is nonzero, thenthe player will be prevented from doing the command unlessthat player is also a creator.  By default, it will printa message that says: \"You are unconscious.  You can't doanything.\\n\".  If the function query_passed_out_message() isdefined on the player object (usually by a shadow), andreturns a string, then that string is printed instead.<p>This function is registered withadd_action(\"drunk_check\", \"*\", 10000),so it can be avoided by registering a higher priority add_action.But that is not necessary, because if bypass_queue() hasbeen called, this function will do nothing.  Please note thatyou should not be using add_action.",}),"see":({"/global/new_parse->add_command()",}),"param":({"str the command being executed",}),"return":({"0 if nothing was done, 1 if drunk_check() blockedthe command.",}),]),}),])
inherits (["/global/alias":({}),"/global/nickname":({}),])
main_docs (["changed":({"3 November 1997 -- Sin     Documented the bejeesus out of this thing.","4 Novemebr 1997 - Pinkfish     Updated the documentation and changed the interupt system slightly.","22 Feburary 1998 - Pinkfish     Fixed up the problems with the queueing system.",}),"main":({"This class controls the entire command queue for all playerobjects.  Whenever a player tries to execute a command,it gets placed in a queue here and eventually (during theplayer's heart_beat()), the command will (hopefully) be executed.<p>Since this class is a nexus of control for player commands, itis also the natural place for a number of other utilities andfunctions which also affect the execution of all commands.Among these are things like drunk_check(), do_soul(), etc.",}),"author":({"Pinkfish",}),"see":({"/global/new_parse->add_command()","/global/player->heart_beat()","query_passed_out_message()",}),])
define_docs ([])
includes (["/include/player.h":1522061544,"/include/soul.h":1522061544,"/include/living.h":1522061544,"/include/playtesters.h":1522061544,])
class_docs ([])
file_name "/global/psoul.c"
last_changed 1522302118
