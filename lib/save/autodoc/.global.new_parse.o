#/obj/handlers/autodoc/autodoc_file.c
public_functions (["query_succ_mess_indir":({({"object","*",}),({}),(["main":({"This method returns all the indirect objects used in the successmessages.",}),"return":({"the success message",}),]),}),"query_p_commands":({({"mapping",}),({}),(["main":({"This method returns the current internal set of commands.<p>([ \"command_name\" :<br>({ ({ pattern_weight, pattern_str, nn, object, function }) })<br>])",}),"see":({"query_p_objects()",}),"return":({"the current commands list",}),]),}),"new_parser":({({"nomask","int",}),({({"string",}),"str",}),(["main":({"This method does all the real work for add_command parsing.",}),]),}),"add_failed_mess":({({"void",}),({({"object",}),"dir",({"string",}),"mess",({"mixed","*",}),"in_dir",}),([]),}),"syntax_messages":({({"int",}),({({"string",}),"str",}),([]),}),"query_succ_mess_dir":({({"object","*",}),({}),(["main":({"This method returns the objects which have success messages alreadyattached for.   This allows you to determine which objects already hacea success message available.   This array is added to by both theadd_succeeded_mess and add_failed_mess methods, it disable theautogeneration of these messages.",}),"see":({"add_succeeded_mess()","add_failed_mess()",}),"return":({"the succeeded message objects",}),]),}),"check_if_allowed":({({"int",}),({({"object",}),"ob",}),([]),}),"add_succeeded_mess":({({"int",}),({({"object",}),"dir",({"mixed",}),"incoming_mess",({"object","*",}),"in_dir",}),([]),}),"add_command":({({"varargs","int",}),({({"string",}),"cmd",({"object",}),"ob",({"mixed",}),"format",({"function",}),"funct",}),(["main":({"The id is a useful thingy so that things can remember which pattern was parsed.",}),]),}),"check_if_creator":({({"int",}),({({"object",}),"ob",}),([]),}),"query_p_objects":({({"mapping",}),({}),(["main":({"This method returns the current mapping between objects and commands.<br>([ object : ({ \"cmd1\", \"cmd2\", ... }), ... ])<p>This mapping is used when the object leaves the environment to makethe command updating more efficent.",}),"see":({"query_p_commands()",}),"return":({"the current object/command mapping",}),]),}),"query_word_list":({({"string","*",}),({({"string",}),"list",}),([]),}),"setup_failed_mess":({({"void",}),({({"class","obj_match",}),"failed_match",}),([]),}),"my_find_match":({({"class","obj_match",}),({({"string",}),"pattern",({"object","*",}),"where",({"int",}),"type",}),([]),}),"add_succeeded":({({"int",}),({({"mixed",}),"ob",}),(["main":({"This is called by the object the command is being passed on to findwhether or not it succeeded on the objects it was passed... and whichones. This can be passed an object.. or an array of objects.Share and enjoy.",}),]),}),"get_fail_messages":({({"string",}),({({"string",}),"verb",({"object","*",}),"fail_obs",}),([]),}),"print_special_messages":({({"void",}),({({"string",}),"verb",}),([]),}),"query_parse_command_objects":({({"object","*",}),({({"string",}),"name",}),(["main":({"This method returns the objects associated with the parse command.",}),"param":({"name the command name to return the objects for",}),"return":({"the objects associated with the command",}),]),}),"check_living":({({"int",}),({({"object",}),"ob",}),([]),}),"pattern_match":({({"int","*",}),({({"string","*",}),"bits",({"mixed","*",}),"pattern",}),([]),}),"query_parse_command":({({"mixed","*",}),({({"string",}),"name",}),(["main":({"This method returns the information associated with the specificcommand.  This should only be used for debug.",}),"param":({"name the command name to return info on",}),"return":({"the information associated with the command",}),]),}),"query_failed_message_exists":({({"int",}),({({"object",}),"dir",}),(["main":({"This method checks to see if the given object has already added a failedmessage yet or not.   This is checking for a direct object, not an indirect object.",}),"see":({"add_failed_mess()",}),"param":({"dir the object adding the failed message",}),"return":({"0 if not found, 1 if found",}),]),}),"create_message":({({"varargs","string",}),({({"string","*",}),"bits",({"int","*",}),"matches",({"mixed","*",}),"pattern",({"object","*",}),"dir",({"int",}),"flag",}),([]),}),"remove_object":({({"int",}),({({"mixed",}),"ob",({"int",}),"was_env",}),([]),}),])
protected_functions ([])
inherits (["/global/command":({}),])
main_docs (["main":({"This file contains all the code to support and run the text parsingsystem used by discworld.   This is called 'add_command', please seehelp on add_command for a more detailed listing.",}),"author":({"Pinkfish",}),])
define_docs (["MY_MESS_HEADER":([]),"OTHER_MESS_HEADER":([]),])
includes (["/include/obj_parser.h":1522061544,"/include/command.h":1522061544,"/include/user_parser.h":1522061544,"/include/soul.h":1522061544,"/include/function.h":1522061544,"/include/creator.h":1534615071,])
class_docs (["fail_mess_data":({0,({({"direct",({"object","*",}),}),({"indirect",({"object","*",}),}),({"weight",({"int",}),}),}),([]),}),])
file_name "/global/new_parse.c"
last_changed 1523347626
