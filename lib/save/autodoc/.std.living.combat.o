#/obj/handlers/autodoc/autodoc_file.c
public_functions (["set_tactics":({({"void",}),({({"class","tactics",}),"new_tactics",}),(["main":({"This sets the current attitude to use in combat.",}),"see":({"query_tactics()",}),"param":({"attitude the new combat attitude",}),]),}),"query_combat_mercy":({({"string",}),({}),([]),}),"set_distance":({({"int",}),({({"object",}),"opponent",({"int",}),"distance",}),(["main":({"Set the distance from this object to the given opponent.",}),"param":({"opponent the object to set the distance to.","distance the new distance.",}),]),}),"query_last_action":({({"string",}),({}),(["main":({"This method returns the last (combat) action performed.",}),"return":({"string the action.",}),]),}),"query_unarmed_parry":({({"int",}),({}),([]),}),"query_combat_response":({({"string",}),({}),([]),}),"query_surrender":({({"class","surrender_information",}),({}),([]),}),"calc_armour_protection":({({"class","attack",}),({({"class","attack",}),"att",}),(["main":({"Calculate how much of the damage is saved by the armour.PRE: all information has been filled in except the amount of damagestopped by armour, and which piece of armour did the stopping.POST: The damage stopped and which armour did it is filled in.",}),"param":({"class attack",}),"return":({"class attack",}),]),}),"query_combat_attitude":({({"string",}),({}),([]),}),"register_special":({({"int",}),({({"int",}),"type",({"int",}),"events",({"mixed",}),"callback",({"mixed",}),"data",}),(["main":({"Register a combat special.The combat system maintains a list of combat specials. These specials canbe used to override or alter any facet of a combat attack (or defense).<p>A special must register what type of special it is:<br>T_OFFENSIVE - an offensive special<br>T_DEFENSIVE - a defensive special<br>T_CONTINUOUS - can be used with one of the above to indicate that the               special is continuous and not a one-time event.<br><p>It also indicates which stages of combat it wants to be notified of:<br>E_OPPONENT_SELECTION - selection of an opponent<br>E_DEFENDER_SELECTION - selection of the defender<br>E_ATTACK_SELECTION - selecting which attack the attacker will perform<br>E_DEFENSE_SELECTION - selection of the method of defense<br>E_ATTACK_MODIFIER - calculating the modifier for attack (how easy/hard itis)<br>E_DEFENSE_MODIFIER - doing the same for the defense<br>E_DAMAGE_CALCULATION - calculating how much damage the attack can do<br>E_ARMOUR_CALCULATION - calculating how much damage the armour will stop<br>E_WEAPON_DAMAGE - performing damage to the weapons involved<br>E_WRITE_MESSAGES - writing out the success/failure messages<br>E_AFTER_ATTACK - any post-attack cleanup.<br><p>The special provides the combat system with a callback function to becalled and any additional data the special wants tracked by the combatsystem.<p>Then, when combat reaches one of the stages requested it calls the callbackfunction. This function is passed the stage we're at, all the data for thisattack and also the extra data the special requested.<p>The callback can then modify any aspect of the attack data (it could changethe attack skill, the defensive weapon, the defense modifier, anything atall) and then return back into combat.<p>The return tells the combat system what to do next. The options are:<br>R_CONTINUE - continue as though the special hadn't done anything.<br>R_DONE - treat this step as completed.<br>R_ABORT - abort the attack<br>R_REMOVE_ME - do one of the above and then remove the special.",}),"param":({"type Is this an offensive or defensive special.","events A bitmap of the events this special is interested in.","the function to be called. A mixed array containing an object & afunction string.",}),"example":({"This example registers a special that causes the player to be unable todefend themselves for three rounds.id = player->register_special(T_DEFENSIVE | T_CONTINUOUS,                              E_DEFENSE_SELECTION | E_DAMAGE_CALCULATION,                              ({ base_name(this_object()), \"callback\" }),                              ({ player, 0}));mixed *callback(int stage, class attack att, mixed data) {  // If it's not our player defending we won't do anything.  if(att->defender != data[1])    return ({ R_CONTINUE, att, data });   switch(stage) {   case E_DEFENSE_SELECTION: // We won't let them defend themselves!     att->defense_action = \"none\";     return ({ R_DONE, att, data });   case E_DAMAGE_CALCULATION:     // If they managed to defend themself, turn it into a failure.     if(att->result == DEFWIN || att->result == DEFAWARD)       att->result = OFFWIN;     // By using R_CONTINUE they take 500 hits _plus_ the normal damage.     att->damage = 500;     // The R_REMOVE_ME causes our special to disappear once we've hurt     // them three times.     if(data[1] > 3)       return ({ R_CONTINUE & R_REMOVE_ME, att, data });     data[1]++;     return ({ R_CONTINUE, att, data });   }}",}),"return":({"the id of the special.",}),]),}),"attack_ob":({({"int",}),({({"object",}),"opponent",}),(["main":({"This method is called to make us attack someone else.",}),"see":({"query_attacker_list()","attack_by()",}),"param":({"opponent the person to attack",}),"return":({"0 if we cannot attack them, 1 if we can",}),]),}),"set_combat_focus":({({"void",}),({({"string",}),"focus",}),([]),}),"remove_attacker_list":({({"void",}),({({"object",}),"ob",}),(["main":({"This method removes someone from an attacker/hunting list.",}),"param":({"ob the object to be removed.",}),]),}),"query_last_weapon":({({"object",}),({}),(["main":({"This method returns the last weapon we used for an attack or defense.",}),"return":({"object the weapon.",}),]),}),"set_concentrating":({({"int",}),({({"object",}),"thing",}),([]),}),"remove_defender":({({"int",}),({({"object",}),"defender",}),(["main":({"This method will remove a defender to the current list of defendersfor this living object.",}),"see":({"add_defender()","query_defenders()",}),"param":({"thing the defender to remove",}),"return":({"1 for success, 0 for failure.",}),]),}),"event_surrender":({({"void",}),({({"object",}),"victim",({"object","*",}),"attackers",}),(["main":({"This method tells us what the npc shouuld do in the case that itmight possibly surrender.",}),"param":({"victim the person surrendering","attacker the person beating up the surrenderer",}),]),}),"query_can_attack":({({"int",}),({}),(["main":({"Decide if we will attack this round or not.  This function can beoverloaded if necessary. It also checks for the property \"cannot attack\"on this object. If the property is set the object cannot attack.",}),"return":({"1 if we want to, 0 if we don't.",}),]),}),"choose_defense":({({"class","attack",}),({({"class","attack",}),"att",}),(["main":({"Will the defender defend or not? If so, with what skill and weapon and atwhat action cost?PRE: all attack data and opponent and defender data have been set.POST: defense type, skill and weapon must be set. If defense_actionis \"none\" the defender will have a big negative modifier.",}),"param":({"class attack",}),"return":({"class attack",}),]),}),"add_defender":({({"int",}),({({"object",}),"thing",}),(["main":({"This method will add a defender to the current list of defendersfor this living object.",}),"see":({"remove_defender()","query_defenders()",}),"param":({"thing the defender to add",}),]),}),"query_concentrating":({({"object",}),({}),([]),}),"query_can_defend":({({"int",}),({}),(["main":({"Decide if we are able to defend ourselves this time or not.This function can be overloaded if necessary. It also checks for theproperty \"cannot defend\"on this object. If the property is set the object cannot defend.",}),"return":({"1 if we want to, 0 if we don't.",}),]),}),"stop_hunting":({({"void",}),({({"object",}),"opponent",}),([]),}),"attack_by":({({"int",}),({({"object",}),"opponent",}),(["main":({"This method is called when the living object is attacked by some opponent.",}),"see":({"query_attacker_list()","attack_ob()",}),"param":({"opponent the opponent we are attacked by",}),"return":({"0 if we cannot attack them, 1 if we can",}),]),}),"query_action_defecit":({({"int",}),({}),([]),}),"query_specials":({({"class","combat_special","*",}),({}),(["main":({"List the specials currently registered for this npc/player.",}),"return":({"an array of comba_special classes.",}),]),}),"query_tactics":({({"class","tactics",}),({}),(["main":({"This method returns the current tactics set using the tactics class.",}),"index":({"tactics",}),"see":({"set_tactics()",}),]),}),"query_last_result":({({"int",}),({}),(["main":({"This method returns the result of the last combat round.",}),"return":({"int the result.",}),]),}),"query_combat_focus":({({"string",}),({}),([]),}),"add_protector":({({"int",}),({({"object",}),"thing",}),(["main":({"This method will add a protector to the current list of protectorsfor this living object.",}),"see":({"remove_protector()","query_protectors()",}),"param":({"thing the protector to add",}),]),}),"query_fighting":({({"int",}),({}),(["main":({"Is the player currently fighting anyone.",}),"return":({"1 for yes, 0 for no.",}),]),}),"dont_attack_me":({({"int",}),({}),([]),}),"set_combat_attack":({({"void",}),({({"string",}),"attack",}),([]),}),"query_combat":({({"class","combat_information",}),({}),([]),}),"choose_defender":({({"class","attack",}),({({"class","attack",}),"att",}),(["main":({"This method is used to choose who will defend this attack. Typically thiswill be the person who was attacked, however it could be someone else insome circumstances.PRE: attacker, attack and defender information has been set.POST: defender and person_hit must be set.",}),"param":({"class attack",}),"return":({"class attack",}),]),}),"query_attackable":({({"int",}),({}),(["main":({"Is this object attackable or not?",}),"return":({"1 or 0 for true or false.",}),]),}),"do_surrender":({({"object",}),({({"object",}),"thing",}),(["main":({"This method will be called when we surrender.  This does mean thatthe opponent must have accepted our surrender plea.",}),"param":({"thing the thing which made us surrender",}),"return":({"always returns 0",}),]),}),"remove_protector":({({"int",}),({({"object",}),"protector",}),(["main":({"This method will remove a protector to the current list of protectorsfor this living object.",}),"see":({"add_protector()","query_protectors()",}),"param":({"thing the protector to remove",}),"return":({"1 for success, 0 for failure.",}),]),}),"query_defend":({({"int",}),({}),(["main":({"Is this object prepared to try to defend someone else at this time?",}),"return":({"1 or 0 for true or false.",}),]),}),"adjust_action_defecit":({({"void",}),({({"int",}),"amount",}),([]),}),"reset_defenders":({({"void",}),({}),(["main":({"This method resets the defender array back to being nothing.",}),]),}),"query_combat_attack":({({"string",}),({}),([]),}),"calc_defense_modifier":({({"class","attack",}),({({"class","attack",}),"att",}),(["main":({"This method calculates the modifier to the defense.It will take into account all the basic stuff that makes the defenseharder or easier.PRE: All attack and response data has been filled in.POST: The defensive modifier must be set.",}),"param":({"class attack",}),"return":({"class attack",}),]),}),"do_attack":({({"void",}),({}),(["main":({"This performs the actual attack itself.All attack data, everything we know about the attacker and the defenderis stored in the attack class which is passed into and back by everyfunction at every step of the attack.",}),]),}),"remove_special":({({"int",}),({({"int",}),"id",}),(["main":({"Remove a combat special.",}),"param":({"id The id of the special",}),"return":({"1 for success, 0 for failure",}),]),}),"fight_in_progress":({({"void",}),({({"object",}),"thing",}),(["main":({"This method is called when there is a fight in progress.  It willpropogate the event onto all the objects in the room.",}),"param":({"thing the person fighting",}),]),}),"set_combat_distance":({({"void",}),({({"string",}),"distance",}),([]),}),"recalc_hunting_list":({({"void",}),({}),([]),}),"offered_surrender":({({"void",}),({({"object",}),"victim",}),(["main":({"This method is called when someone offers to surrender to the livingobject.  It will check the current tactics for surrender and thenhandle the response appropriately.",}),"param":({"victim the person surrendering",}),]),}),"set_specials":({({"void",}),({({"class","combat_special","*",}),"specials",}),(["main":({"Directly set the special list. Use with care!",}),"param":({"class combat_special *",}),]),}),"set_combat_parry":({({"void",}),({({"string",}),"parry",}),([]),}),"end_combat":({({"void",}),({}),(["main":({"This method is called when combat ends.  You can overload this functionto make your NPC do things at the end of combat.You do not need to call ::end_combat() since this is just a stub function.",}),]),}),"query_attacker_list":({({"object","*",}),({}),(["main":({"This method returns the current list of people in the attacker liston the object.",}),"return":({"the current attacker array",}),]),}),"query_protect":({({"int",}),({}),(["main":({"Is this object prepared to try to protect someone else at this time?",}),"return":({"1 or 0 for true or false.",}),]),}),"query_distance":({({"int",}),({({"object",}),"opponent",}),(["main":({"Query the distance from this object to the given opponent.",}),"param":({"opponent the object to check",}),]),}),"refused_surrender":({({"void",}),({({"object",}),"attacker",}),(["main":({"This method is called if surrender was refused for the particularperson.",}),"see":({"accepted_surrender()",}),"param":({"attacker the person who is surrendering",}),]),}),"set_combat_response":({({"void",}),({({"string",}),"response",}),([]),}),"start_combat":({({"void",}),({({"object",}),"opponent",}),(["main":({"This method is called when combat starts.  You can overload this functionto make your NPC do things at the start of combat.You do not need to call ::start_combat() since this is just a stub function.",}),"param":({"opponent The first opponent to be attacked.",}),]),}),"query_protectors":({({"object","*",}),({}),(["main":({"This method returns the current array of protectors on the livingobject.  This is the people who are protecting us, so if we are hitmake them attack the hitter.",}),"see":({"add_protector()","remove_protector()",}),"return":({"the current protectors array",}),]),}),"query_defenders":({({"object","*",}),({}),(["main":({"This method returns the current array of defenders on the livingobject.  This is the people who are protecting us, so if we are hitmake them attack the hitter.",}),"see":({"add_protector()","remove_protector()",}),"return":({"the current defenders array",}),]),}),"set_combat_mercy":({({"void",}),({({"string",}),"mercy",}),([]),}),"set_combat_attitude":({({"void",}),({({"string",}),"attitude",}),([]),}),"is_fighting":({({"varargs","int",}),({({"object",}),"ob",({"int",}),"actively",}),(["main":({"This method determines whether or not the object is fighting anotherobject.",}),"param":({"ob the object being tested","actively is the opponent being actively fought at this time?",}),"return":({"1 if it is in combat, 0 if it is not.",}),]),}),"stop_all_fight":({({"void",}),({}),([]),}),"accepted_surrender":({({"void",}),({({"object",}),"attacker",}),(["main":({"This method is called if surrender was accepted for the particularperson.",}),"see":({"refused_surrender()",}),"param":({"attacker the person who is surrendering",}),]),}),"remove_surrenderer":({({"void",}),({({"object",}),"victim",}),(["main":({"This method removes a person surrendering from our current list.",}),"see":({"query_surrenderers()",}),"param":({"victim the person to remove",}),]),}),"query_combat_parry":({({"string",}),({}),([]),}),"stop_fight":({({"void",}),({({"object",}),"opponent",}),([]),}),"query_surrenderers":({({"object","*",}),({}),(["main":({"This method returns the current list of people surrendering to us.",}),"see":({"remove_surrenderer()",}),"return":({"the list of people surrendering",}),]),}),"query_combat_distance":({({"string",}),({}),([]),}),"set_special_data":({({"int",}),({({"int",}),"id",({"mixed",}),"data",}),(["main":({"Update the user data for a specific special.",}),"param":({"id The id of the special","data The data to be set",}),"return":({"True or false for success or failure",}),]),}),"monitor_points":({({"void",}),({}),(["main":({"Display the hitpoint monitor.",}),]),}),"query_last_opponent":({({"object",}),({}),(["main":({"This method returns the last known opponent we attacked or defendedagainst.  It is kept as up to date as the system can manage and so willinclude anyone who is currently attacking us or who we are currentlyattacking.",}),"return":({"object the opponent.",}),]),}),"reset_protectors":({({"void",}),({}),(["main":({"This method resets the protector array back to being nothing.",}),]),}),"stopped_fighting":({({"void",}),({({"object",}),"thing",}),(["main":({"This method is called when the fight has stopped.  It propogates thestopped fighting event onto all the objects in the room.",}),"param":({"thing the thing which stopped fighting?",}),]),}),"set_unarmed_parry":({({"void",}),({({"int",}),"parry",}),([]),}),])
protected_functions (["adjust_actions":({({"void",}),({({"class","attack",}),"att",}),(["main":({"Adjust the time left, combat actions and gp used by this attack.This calls adjust_action_defecit in both the attacker and defenderas appropriate.",}),"param":({"class attack",}),]),}),"after_attack":({({"class","attack",}),({({"class","attack",}),"att",}),(["main":({"This function is called after it's all over and done (just before thecosts are charged). It can be used to do any special outcomes thatwe may decide on.Note that if you override this function in a special be absolutely certainyou know what you're doing if you return R_ABORT or R_DONE. Use of eitherof these two could cause really nasty side-effects.",}),"param":({"class attack",}),"return":({"class attack",}),]),}),"calc_damage":({({"class","attack",}),({({"class","attack",}),"att",}),(["main":({"After a successful attack (or possibly a parried one) calculate theamount of damage done to the opponent.This method must fill in the amount of damage to be done and may adjustthe time taken too.PRE: the outcome of an attack must have been determined.POST: damage must be filled in.",}),]),}),"choose_attack":({({"class","attack",}),({({"class","attack",}),"att",}),(["main":({"Determine which attack they'll use.This picks a weapon, gets the attack data and the weapon skill anddetermines how much the attack will cost.PRE: attacker info, opponent and defender info have been set.POST: attack weapon, attack skill, attack data, and attack_cost mustbe set.",}),"param":({"class attack",}),"return":({"class attack",}),]),}),"calc_attack_modifier":({({"class","attack",}),({({"class","attack",}),"att",}),(["main":({"This method calculates the modifier to the attack.It will take into account all the basic stuff that makes the attackharder or easier.PRE: All attack and response data has been filled in.POST: The offensive modifier must be set.",}),"param":({"class attack",}),"return":({"class attack",}),]),}),"damage_weapon":({({"class","attack",}),({({"class","attack",}),"att",}),(["main":({"Do damage to the attacking & defending weapons.PRE: all information has been filled inPOST: the weapons involved have taken appropriate damage.",}),"param":({"class attack",}),"return":({"class attack",}),]),}),"choose_opponent":({({"class","attack",}),({({"class","attack",}),"att",}),(["main":({"Choose an opponent and attack them.This method must fill in the opponent variable. If no opponent is chosenthe attack will be aborted.PRE: Attacker information has been filled in.POST: opponent must be chosen or the attack will be aborted.",}),"param":({"class attack",}),"return":({"class attack",}),]),}),"write_messages":({({"class","attack",}),({({"class","attack",}),"att",}),(["main":({"Write out the attack/defense messages.PRE: all information has been filled inPOST: the appropriate messages have been written out.",}),"param":({"class attack",}),"return":({"class attack",}),]),}),"perform_movement":({({"class","attack",}),({({"class","attack",}),"att",}),(["main":({"This function is called as part of the post attack processing and performsthe checks to see if someone can move closer or further away from theiropponent.",}),"see":({"after_attack()",}),"param":({"class attack",}),"return":({"class attack",}),]),}),"call_special":({({"mixed","*",}),({({"int",}),"stage",({"class","attack",}),"att",}),(["main":({"Go through the list of the attacker & opponents specials andcall any that have registered for this stage.",}),]),}),"prepare_messages":({({"class","attack",}),({({"class","attack",}),"att",}),(["main":({"Prepare the result messages.This method prepares the attack and defense messages setting up the 5element arrays of att_mess & def_mess. The elements are as follows:0 - the attacker, 1 - the opponent, 2 - everyone else, 3 - the defender4 - the person hitPRE: The attack has been done and the amount of damage done and stoppedhas been calculated.POST: The 5 element att_mess & def_mess arrays are populated.",}),"param":({"class attack",}),]),}),])
inherits (["/std/weapon_logic":({}),"/std/living/corpse":({}),])
main_docs (["main":({"This file contains all the methods and fun things actually run combat.",}),"author":({"CeresTODO: Add offensive & defensive criticals -- broken limbs etc.",}),])
define_docs (["DEBUG":([]),"ABS(n)":([]),])
includes (["/include/combat.h":1522061544,"/include/attack_messages.h":1522061544,"/include/weapon.h":1522061544,"/include/tasks.h":1522061544,"/include/player.h":1522061544,"/include/living.h":1522061544,"/include/playtesters.h":1522061544,])
class_docs ([])
file_name "/std/living/combat.c"
last_changed 1522061544
