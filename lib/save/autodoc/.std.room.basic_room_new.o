#/obj/handlers/autodoc/autodoc_file.c
public_functions (["query_door_open":({({"int",}),({({"string",}),"direc",}),(["main":({"This method checks to see if the door is open.",}),"see":({"modify_exit()",}),"param":({"direc the direction of the door",}),"return":({"-1 on an error, 0 for closed, 1 for open",}),]),}),"add_hidden_object":({({"int",}),({({"object",}),"thing",}),(["main":({"This puts a hidden object into a room. A hidden object is an object thatexists in the room as far as all the find_match calls go. So, for look at'sand so on, but does not actually exist in the room so it does not show upin the inventory when the player does a look. This is the method used forputting signs and doors into rooms, that actually have shorts and you cando things to, but do not show up in the inventory. The function init is alsocalled on these objects when init is called in the room. The only thing youcannot put in your init function is an add_action. You can however defineup bunches of add_commands...<p>If this sounds complicated. Think of it as an object that IS in the room, butyou cannot see it. <p>A word of warning here, the init() function will *not* be called on allthe players when the object is added as hidden.  This means that thecommands on it will not be available until the player re-enters the room.You could get around this by moving everyone out of the room andthen back in again.",}),"param":({"thing the hidden object to add",}),"see":({"query_hidden_object()","remove_hidden_object()",}),"return":({"1 if successful, 0 on a failure",}),"example":({"#include <room.h>sign = clone_object(PATH + SIGN);add_hidden_object(sign);","// Add a hidden object that has actions we want players to be able to// use.add_hidden_object(fluffy_container);players = filter(all_inventory(), (: living($1) :));players->move(ROOM_VOID);// This forces init() to be recalled.  (This is realtivatively icky// way of doing it, but the driver does not give us many alternatives).players->move(this_object());",}),]),}),"calc_short_exit_string":({({"string",}),({}),(["main":({"This method returns the exit string used when in brief mode.",}),"see":({"calc_exit_string()",}),"return":({"the brief exit string",}),]),}),"add_night_item":({({"varargs","int",}),({({"mixed",}),"shorts",({"mixed",}),"desc",({"mixed",}),"no_plural",}),(["main":({"This method sets up an item which will only be displayed during thenight.  All of the standard add_item things are available with thismethod.",}),"see":({"/std/room->add_item()","add_day_item()",}),]),}),"shutdown_situation":({({"void",}),({({"int",}),"call",({"mixed",}),"label",}),(["main":({"Shuts down a situation or set of situations initiated withchange_situation based on the call_out handlereturned by the call to change_situation.",}),"see":({"automate_situation","change_situation",}),"param":({"callout call_out handle.  If 0 then the lastknown handle is used.","label label or array of labels of situations to clean up with end_situation","the_room the room",}),]),}),"query_direc":({({"varargs","string","*",}),({({"object",}),"thing",}),(["main":({"This method just returns all the directions available to leave fromthe room.<p>The thing passed in is used as the basis for the relative directionsif it is an object.  If it is not an object then this is ignoredaltogether.<p><b>Strawberries</b><p>Starting from a above,<br>Working slowly down under.<br>Sliding up the sides<br>Eating a meal, fresh cream and syrup.<br><p>Round and round, and round again<br>Grining micheviously<br>One tongue at play<br>Firm and hard, fresh strawberries today.",}),"param":({"thing used to get the relative directions according to thing",}),"see":({"query_dest_other()","add_exit()",}),"return":({"the array of directions",}),]),}),"set_night_long":({({"void",}),({({"string",}),"str",}),(["main":({"This method sets up the night long for the room.  This will be thelong description displayed at night in the room.",}),"see":({"set_day_long()","query_night_long()",}),"param":({"str the new night long description",}),]),}),"remove_exit":({({"int",}),({({"string",}),"direc",}),(["main":({"This method removes the specified exit from the room.",}),"see":({"add_exit()","modify_exit()",}),]),}),"query_exits":({({"string","*",}),({}),(["main":({"This returns the current array of exits.",}),"see":({"add_exit()","remove_exit()","modify_exit()",}),"return":({"the exits array",}),]),}),"query_look_func":({({"mixed","*",}),({({"string",}),"direc",}),([]),}),"calc_long_exit":({({"void",}),({}),(["main":({"This method creates the long exit description used in the room longdescriptions.",}),"see":({"query_long_exit()",}),]),}),"add_alias":({({"void",}),({({"mixed",}),"names",({"string",}),"word",}),(["main":({"This method adds an exit alias to the room.Aliases are convenient extra forms that can be attached to certainexits. In the above functions, the variable names is either a stringor an array of strings and is, respectively, the alias or aliasesfor the direction passed in word. Since, sometimes, the same aliascould be used for more than one exit, remove_alias() requires bothalias(es) and direction in order to remove the correct alias(es). ",}),"see":({"query_aliases()","remove_alias()",}),"param":({"names the exit names to alias","word the name to alias them too",}),"example":({"add_exit( \"north\", PATH +\"dining_hall\", \"corridor\" );add_alias( ({ \"enter\", \"enter hall\", \"enter dining hall\" }), \"north\" );","add_exit( \"board carriage\", PATH +\"carriage\", \"door\" );add_alias( \"board\", \"board carriage\" );",}),]),}),"query_dynamic_enchant":({({"float",}),({}),(["main":({"This method returns the current dynamic enchantment of the room.",}),"see":({"query_enchant()",}),"return":({"the theft handler of the room",}),]),}),"query_background_enchant":({({"int",}),({}),(["main":({"This method returns the background enchantment of the room.",}),"see":({"query_enchant()",}),"return":({"the theft handler of the room",}),]),}),"remove_item":({({"int",}),({({"string",}),"word",}),(["main":({"This method will attempt to remove the item defined by the given string.This will remove everything associated with that item, verbs, patterns,everything.",}),"see":({"add_item()","query_item()",}),"param":({"word the name of the item to remove",}),"example":({"add_item(\"frog\", \"Cute, green and sitting on a lilly pad.  Yes!\\n\");...remove_item(\"frog\");","add_item(({ \"big bad chicken\", \"clucker\" }),         \"The big bad chicken sits and stares at you.\\n\");...remove_item(\"big bad chicken\");",}),"return":({"1 if successful, 0 on a failure",}),]),}),"set_linker":({({"varargs","int",}),({({"string","*",}),"rooms",({"string",}),"d_prep",({"string",}),"s_prep",({"string",}),"r_name",}),(["main":({"This method sets up a linkage between the current room and othertrooms.  The linkage broadcasts things like says and enter/exitmessages between the rooms.<P>The the dynamic preposition is used when someone enters/exitsthe room, the static preposition is used when someone says somethingin the room.  The dynamic proposition defaults to \"into\" and thestatic preposition defaults to \"in\".",}),"param":({"rooms the rooms to link together","d_prep the dynamic preposition","s_prep the static preposition","r_name the name of the room/area",}),"example":({"set_linker( ({ PATH + \"room1\", PATH + \"room2\", }),            \"into\", \"in\", \"fluffy square\");",}),]),}),"remove_room_chats":({({"void",}),({({"string","*",}),"dead_chats",}),(["main":({"Removes chats from the set of room chatsmanaged by this chatter object.  If there are no chatsleft the chatter is destructed.",}),"see":({"add_room_chats","query_room_chats","/std/room/basic/chatter",}),"param":({"dead_chats an array of chat strings to remove",}),]),}),"add_situation":({({"void",}),({({"mixed",}),"label",({"class","situation",}),"sit",}),(["main":({"Adds a situation to the room.  These situations can beinvoked manually with start_situation or automatically viaautomate_situation.",}),"see":({"start_situation","end_situation","automate_situation","change_situation","add_item","room_chat","add_extra_look","set_situation_changer","make_situation_seed","/include/situation.h","goto learning  search  situation  for working examples",}),"param":({"label string or number labelling the situation","sit a structure (class) containing all the bitsof the situation you want to add.  It should be avariable of class situation.  You should includesituations.h where this class is defined.Every part is optional.eg. start_func  function to be called at start of situation             that might be used to load NPC's or anything            beyond a message.            The start function is passed the label,             a do_start_mess flag and the room object.              If the flag is 1 the situation is starting             rather than being reloaded.  Thus if             do_start_mess is 0 then you should avoid            any obvious start messages and make it look            like the situation is already underway.end_func    function to be called an the end of a situation.              The end function is only            passed the label and the room object.start_mess  message told to the room at start of situationend_mess    message told to the room at end of situationextra_look  extra look string appended to rooms long             during the situationchat_rate   an array of 2 numbers giving the minimum and            maximum delay between chats.  If this is set            then the chats are not merged with the            existing chats but added independently with            their own chat rates as given.chats       an array of chat strings to be active             during the situation add_items   a mixed array of ({ item, item description })             pairs to be active during the situationrandom_words  sets of words to insert into text to replace               the special character #n where n is a number.            The form of the array is ({  #1array, #2array, ... })            where #1array = ({ \"#1word1\",\"#1word2\",... }) etc.            For the duration of the situation one of the strings            in #1array is used to replace all instances of #1            in the extra_look, start_mess, end_mess, chats            and key and the long description part of the add_items.            In a situation compounded of many situations            the same random seed is used for choosing all #1's            for each individual situation for the duration,             and a different seed for all #2's etc. ",}),"example":({"#include <situations.h>class situation frogs;frogs = new(class situation,     start_mess: \"Water seeps out of the ground to form puddles.\",    extra_look: \"There are large puddles on the ground here.\",    chat_rate: ({ 120,180 }),    chats: ({\"A hidden frog croaks quietly.\",             \"There is a blooping sound.\" }),    add_items:({ ({\"puddle\", \"The puddles are dark and murky.  \"                    \"They will probably dry up given time.\" }) }) );add_situation( \"frogs\", frogs );","add_situation( \"ship\", new(class situation,      start_mess: \"A #1 ship hoves into view.\",     extra_look: \"There is a #1 ship forging up the river.\",     chats: ({\"The #1 ship's sails flap in the breeze.\",              \"Shouts of sailors carry over to you from the #1 ship.\" }),     add_items: ({ ({\"ship\", \"The #1 ship, the \\\"#2\\\" is a small \"                   \"sailing vessel that transports cargo up and \"                   \"down the river.\"}) }),     random_words: ({ ({ \"old\",\"waterlogged\",\"heavily laden\" }),                      ({ \"Jemima\", \"Old Sea Dog\", \"Randy Mermaid\" }) })     ) );When the situation is started a random choice (eg. \"old\") replaces #1 and a name (eg. \"Jemima\") replaces #2 in the text strings forthe duration.  ","add_situation( \"frogs\", new(class situation,      start_mess: \"Water seeps out of the ground to form puddles.\",     extra_look: \"There are large puddles on the ground here.\",     chats: ({\"A hidden frog croaks quietly.\",              \"There is a blooping sound.\" }),     add_items: ({ ({\"puddle\", \"The puddles are dark and murky.  \"                      \"They will probably dry up given time.\" }) }) ));","This is an empty situation, useful for making pauses in the action.add_situation( \"pause\", new(class situation) );",}),]),}),"set_background_enchant":({({"void",}),({({"int",}),"number",}),(["main":({"This method sets the background enchantment of the room.",}),"see":({"set_enchant()",}),"return":({"the theft handler of the room",}),]),}),"query_enchant":({({"int",}),({}),(["main":({"Returns the current enchantment level of the room.  The enchanmentlevel controls things like what happens when you flip coins andsome special messages which give wizards some idea about magiclevels.",}),"see":({"set_enchant()",}),"return":({"the current enchantment",}),]),}),"query_keep_room_loaded":({({"int",}),({}),(["main":({"This method returns the status of the keep room loaded flag.  If theyflag is non-0 then the room with not be unloaded.",}),"return":({"the status of the keep room loaded flag",}),]),}),"expand_alias":({({"string",}),({({"string",}),"word",}),([]),}),"modify_exit":({({"int",}),({({"mixed",}),"direc",({"mixed","*",}),"data",}),(["main":({"This method modifies the parameters for the exit.  See the docs in/doc/new/room/modify_exit for more complete information.",}),]),}),"query_dest_dir":({({"varargs","string","*",}),({({"object",}),"thing",}),(["main":({"Returns an array containing just the destinations and directions used toget there. This is useful for monster or whatever that you want to scan aroom for exits to leave out of. The array is of the format. ({ direction1,destination1, direction2, destination2, ... })<p>The thing passed in is used as the basis for the relative directionsif it is an object.  If it is not an object then this is ignoredaltogether.",}),"param":({"thing used to get the relative directions according to thing",}),"see":({"query_dest_other()","add_exit()",}),"return":({"the array of direction, destination pairs",}),]),}),"query_use_internal_objects":({({"object","*",}),({}),(["main":({"This method returns all the current use internal objects available.",}),"return":({"the list of use internal objects here",}),]),}),"query_hidden_objects":({({"object","*",}),({}),(["main":({"This returns the current array of hidden objects.  The hidden objectsare used to allow things to not actually be in the room descriptionbut be able to be manipulated by commands.",}),"see":({"add_hidden_object()","remove_hidden_object()",}),"return":({"the array of hidden objects",}),]),}),"stop_room_chats":({({"void",}),({}),(["main":({"This method stops all the room chats for the room.  It also removesall the room chats, so if you want to have any more you mustadd them again.",}),"see":({"room_chat()",}),]),}),"modify_item":({({"int",}),({({"string",}),"word",({"mixed",}),"new_desc",}),(["main":({"This method will modify certain bits of the specified item.  This willchange only the bits of the pattern that are specified.  If you wish toremove elements a better method would be to remove the item andthen readd it.  The format of the new_desc array is the same as in theadd_item code.",}),"see":({"remove_item()","add_item()",}),"param":({"word the name of the item to change","new_desc the bits of the item to change",}),]),}),"shutdown_all_situations":({({"void",}),({}),(["main":({"Shuts down all current and pending situations.  It also turns off theautomated situation manager so no more are added.  It does notdestruct this object so all the add_situations are still loadedand make be recommenced with automate_situation.  dest_me isthe appropriate call to permanently remove all situations.  Thecall is passed to the situation changer object.  If none existsthen nothing happens.  The situation changer is created whenan add_situation call is performed. ",}),"see":({"add_situation","automate_situation","change_situation",}),]),}),"room_night_chat":({({"void",}),({({"mixed","*",}),"args",}),(["main":({"This method sets up chats for when the room is in the night cycle.",}),"see":({"room_day_chat()","/std/room->room_chat()",}),"param":({"args the chatter arguements",}),]),}),"change_situation":({({"varargs","mixed",}),({({"mixed",}),"label",({"mixed",}),"duration",({"mixed",}),"words",}),(["main":({"Starts one or more situations that will end after aspecified duration.  You can use an array and makefurther situations commence when others end.",}),"see":({"shutdown_situation","add_situation","automate_situation","goto learning  search  situation  for working examples",}),"param":({"label (mixed) label of the situation to start up.  If you pass an array such as ({ \"frog1\", \"frog2\" }) for the label then that set of situations are started one ata time and the total duration is split evenly between them.Label is usually an integer or a string or an array ofintegers and/or strings.If the string is a list of labelsseparated by , then multiple situationsare started using those labels.","duration (int) total time (seconds) the overall situation should last.  You can put an array of durations -- one for eachsituation if the label lists more than one situation and thenthe overall time is the sum of the numbers.-1 is a special duration.  It means that the labelled situation goes onforever (and thus nothing after it in the array will ever go).","words is a list of replacements for #n in the text ORa random number seed to use to choose words from random_words.eg. ({ \"#1\", \"frog\", \"#2\", \"honey\" }) or 22",}),"example":({"handle=change_situation( ({ \"sew1\",\"sew2\" }), ({ 60,60 }) );if (over) shutdown_situation( handle, ({ \"sew1\",\"sew2\" }) );","change_situation( ({ \"background,sew1\",\"background,sew2\" }), 120 );","change_situation( ({ \"building_falling\",\"rubble\" }), ({ 120, -1 }) );","add_situation( \"boat1\",   new(class situation,    start_mess: \"A little fishing boat comes up to the pier.  \"       \"It has the name \\\"#1\\\" painted on the side.\\n\"       \"A fisherman jumps off the boat and ties its painter to a post.\",    chats: ({\"The little boat bobs up and down next to the pier.\",             \"A fisherman hops off the little boat.\" }),    chat_rate: ({ 20, 30 }),    extra_look: \"There is a little boat here.\",    add_items: ({ ({ ({ \"#1\",\"little boat\" }),       \"There is little fishing boat tied up at the pier here.  \"      \"The name \\\"#1\\\" is painted on the side.\"   }) }),    end_mess: \"The fishermen get back on board and \"       \"the little boat moves on.\",    random_words: ({ ({ \"Honey Toad\", \"Piker\", \"Bing\" }) })  ));change_situation( \"boat1\", 120, ({ \"#1\",\"Floating Egg\" }) );",}),"return":({"handle useful for halting the changes later.  It is typicallya small positive integer.",}),]),}),"calc_exits":({({"void",}),({}),(["main":({"This method calculates all the exit strings to be used for this room.",}),]),}),"query_long_exit":({({"string",}),({}),(["main":({"This returns the long exit string.  This is calculated when it isfirst needed by the calc_long_exit function.",}),"see":({"calc_long_exit()","long()",}),"return":({"the long exit string",}),]),}),"query_dest_other":({({"varargs","mixed","*",}),({({"string",}),"direc",}),(["main":({"This returns information about the exits in the room.  This is theinformation set by modify_exit().  The values from this are probablynot very useful for normal coding.",}),"see":({"modify_exit()","query_dest_dir()",}),]),}),"query_default_position":({({"mixed",}),({}),(["main":({"This method returns the current default position asigned to thisroom.",}),"return":({"the current default position",}),]),}),"set_co_ord":({({"void",}),({({"int","*",}),"new_co_ord",}),(["main":({"Sets the current co-ordinates of the room.  The co-ordinates are3d, ({ x, y, z }).  So an array with three elements.",}),"see":({"query_co_ord()","query_co_ord_calculated()",}),"param":({"new_co_ord the new co-ordinates for the room.",}),]),}),"query_exit":({({"int",}),({({"string",}),"direc",}),(["main":({"This method determines if there is an exit in the specified direction.",}),"param":({"direc the exit to test for",}),"return":({"1 if it exists, 0 if it does now",}),]),}),"remove_use_internal_object":({({"void",}),({({"object",}),"thing",}),(["main":({"This method removes an object whose interor bits want to export.",}),"param":({"thing the object to remove",}),]),}),"calc_co_ord":({({"void",}),({}),(["main":({"This method calculates the co-ordinates of this room.  The co-ordinatesare based on the surrounding rooms co-ordinates, if one of those roomsare loaded.",}),"see":({"query_co_ord()","modify_exit()",}),]),}),"query_destination":({({"string",}),({({"string",}),"exit",}),(["main":({"This method returns the destination room for an exit.",}),"see":({"query_dest_dir()",}),"param":({"exit the exit name",}),"example":({"#include <room.h>string dest;dest = room->query_destination(\"south\");if (dest == ROOM_VOID) {   do_error();} else {   do_move(\"south\");}",}),"return":({"the path of the destination room, or ROOM_VOID on error",}),]),}),"query_dark_mess":({({"string",}),({}),(["main":({"This is the message to print instead of the room description when theroom is dark.  It defaults to the message \"It's dark in here isn't it?\".",}),"see":({"set_dark_mess()","long()","query_bright_mess()",}),"return":({"the dark message",}),]),}),"query_room_size_array":({({"int","*",}),({}),(["main":({"This method returns the size of the room as a three element array always.<p>({ north-south size, east-west size, up-down size })<p>The sizes are all radii's so they are half the actual width of the room.",}),"see":({"query_room_size()","set_room_size()",}),"return":({"the size of the room as a three element array",}),]),}),"room_day_chat":({({"void",}),({({"mixed","*",}),"args",}),(["main":({"This method sets up chats for when the room is in the day cycle.",}),"see":({"room_night_chat()","/std/room->room_chat()",}),"param":({"args the chatter arguements",}),]),}),"set_zone":({({"void",}),({({"string",}),"zone",}),(["main":({"This method adds a move zone into the current list of zones.This method is depreciated, add_zone should be used instead.",}),"see":({"add_zone()","query_zones()",}),]),}),"query_linker":({({"object",}),({}),(["main":({"This method returns the current linker object.",}),"return":({"the linker object",}),]),}),"query_item":({({"object",}),({}),(["main":({"This method returns the current item object.",}),"see":({"add_item()",}),"return":({"the current item object",}),]),}),"add_zone":({({"void",}),({({"string",}),"zone",}),(["main":({"This method adds a move zone into the current list of movement zonesfor the room.  The move zones are used by npcs to see which rooms theyare allowed to move into.",}),"see":({"set_zone()","query_zones()","/obj/monster->add_move_zone()",}),]),}),"query_room_chats":({({"mixed","*",}),({}),(["main":({"Returns the set of room chatsmanaged by the chatter object.  ",}),"see":({"add_room_chats","remove_room_chats","room_chat","/std/room/basic/chatter",}),"example":({" ({ 120, 240, ({ \"A frog gimbles the curtains.\",                 \"A truly revolting smell drifts insidiously \"                 \"from the rug.\" }) })",}),"return":({"pointer to the mixed array of chat args",}),]),}),"query_wall":({({"object",}),({}),(["main":({"This method returns the current wall object.",}),"see":({"add_room_chat()",}),"return":({"the wall object",}),]),}),"query_door_control":({({"varargs","mixed",}),({({"string",}),"direc",}),(["main":({"This returns the information about the door in the specified direction.",}),"see":({"modify_exit()",}),"param":({"direc the direction to query the door in",}),"return":({"the door control information",}),]),}),"set_situation_changer":({({"varargs","object",}),({({"mixed",}),"changer",}),(["main":({"Set a situation changer (in place of the default).If there is no argument you get the default:/std/room/basic/situation_changer.You call this before any other situation related functions.If you create your own changer it should inherit one of/std/room/basic/situation_changer or/std/room/basic/multiroom_situation_changer orotherwsie provide the functionality of those objects.",}),"see":({"add_situation","start_situation","automate_situation","change_situation",}),"param":({"changer optional parameter specifying either a path forthe changer object or an existing object to use.",}),"example":({"If you have a special changer object used for more than one roomthen in setup for those rooms you should have:set_situation_changer(load_object(\"/w/me/mychanger\"));Where /w/me/mychanger inherits /std/room/basic/multiroom_situation_changer",}),]),}),"start_situation":({({"void",}),({({"int",}),"label",({"int",}),"do_start_mess",}),(["main":({"Starts a situation previously added to the room.  These situations can beinvoked manually with start_situation or automatically viaautomate_situation.  The call is passed to the situationchanger object.  If there isn't one nothing happens. ",}),"see":({"add_situation","end_situation","automate_situation","change_situation",}),"param":({"label label for the situation as passed to add_situation","do_start_mess 0 to supress the start_mess string       This is to fake it that a situation has been        going for a while when really you just loaded it.",}),]),}),"query_co_ord_calculated":({({"int",}),({}),(["main":({"This tells us if the co-ordinates were set or if they were calculated.If they were set with set_co_ord then the value of this will be 0otherwise it will be 1.",}),"see":({"query_co_ord()","set_co_ord()",}),"return":({"1 if it is calculated, 0 if it is not",}),]),}),"set_enchant":({({"int",}),({({"int",}),"number",}),(["main":({"Sets the current enchantment level of the room.  The enchanmentlevel controls things like what happens when you flip coins andsome special messages which give wizards some idea about magiclevels.When called from the room itself, it sets a background level of enchantment that don't decay, when called from another object itsets the current enchantment which then decays towards the background level.",}),"see":({"query_enchant()",}),"param":({"number the new enchantment level to set",}),]),}),"query_co_ord":({({"int","*",}),({}),(["main":({"Returns the current co-ordinates of the room.  The co-ordinates are3d, ({ x, y, z }).  So an array with three elements.",}),"see":({"set_co_ord()",}),"return":({"the current co-ordinates",}),]),}),"query_night_long":({({"string",}),({}),(["main":({"This method returns the long description of the room at night.  This isused to print out different strings for rooms during the day and duringthe night.",}),"return":({"the night long for the room.",}),]),}),"room_chat":({({"varargs","void",}),({({"mixed","*",}),"args",({"object",}),"chatobj",}),(["main":({"This method sets up the room chats.Room chats are strings which are printed at (semi) random intervalsin rooms.  They are used to add atmosphere to a room. A chat willbe picked at random from the array of chats with a frequencycontrolled by the times min and max. ie. one will be picked every nseconds where is varies between min and max seconds. Please don'tmake the values for min and max too small or the messages justbecome annoying!<p>The argument to the room_chat method is an array of the format:<br>({ int min, int max, ({ string *chats }) }).  In place of a chatstring you may use \"#function_name\" where function_name is afunction that exists on the room object.<p>Repeated calls to this function overwrite the chats forthe default chatter.",}),"see":({"stop_room_chat()","add_room_chats()","remove_room_chats()","set_chat_min_max()",}),"param":({"args the room chat arguments","chatobj chatter object in case the default offends you.               This argument may be omitted in which case you get                /std/room/basic/chatter.c",}),"example":({"room_chat(({ 120, 240, ({ \"A string frog wanders past.\",                          \"#make_soggy_bread\",                          \"A trully revolting smell drifts insidiously \"                               \"from the bakery.\" }) }) );",}),]),}),"set_dark_mess":({({"void",}),({({"string",}),"word",}),(["main":({"This method sets the dark message associated with the room.",}),"see":({"query_dark_mess()","long()",}),"param":({"word the new dark message",}),]),}),"remove_alias":({({"void",}),({({"mixed",}),"names",({"string",}),"word",}),(["main":({"This method removes the exit aliases from the room.Aliases are convenient extra forms that can be attached to certainexits. In the above functions, the variable names is either a stringor an array of strings and is, respectively, the alias or aliasesfor the direction passed in word. Since, sometimes, the same aliascould be used for more than one exit, remove_alias() requires bothalias(es) and direction in order to remove the correct alias(es). ",}),"see":({"add_alias()","query_aliases()",}),"param":({"names the names to remove","word what they were aliased to",}),"example":({"remove_exit( \"board carriage\" );remove_alias( \"board\", \"board carriage\" );",}),]),}),"query_terrain":({({"object",}),({}),(["main":({"This method returns the current terrain object.",}),"see":({"add_room_chat()",}),"return":({"the terrain object",}),]),}),"make_situation_seed":({({"void",}),({({"int",}),"xval",({"int",}),"yval",}),(["main":({"Makes a seed value for the random part of when situations turn on and off.  The two ints should beconstant for a given room -- eg. the coordinates.If this function is not called the seed is generated from the file_name of the object.For this reason, rooms that are clones will produceerratic results unless this function is called.",}),"param":({"xval integer to use to make a seed (eg. x coordinate)","yval integer to use to make a seed (eg. y coordinate)",}),]),}),"query_door":({({"string",}),({({"mixed",}),"dest",}),(["main":({"This method determines if the specified exit is a door or not.",}),"see":({"query_exit()","add_exit()",}),"param":({"dest the destination to check for being a door",}),]),}),"add_sign":({({"varargs","object",}),({({"string",}),"sign_long",({"mixed",}),"sign_read_mess",({"string",}),"sign_short",({"mixed",}),"sign_name",({"string",}),"sign_language",}),(["main":({"This method adds a sign into the room.  Any of these elements canbe set to 0, except the long description.",}),"param":({"sign_long the long description of the sign","sign_read_mess the readable message on the sign","sign_short the short description of the sign","sign_name the name of the sign","sign_language the language the sign is written in",}),"return":({"the object for the sign",}),]),}),"add_day_item":({({"varargs","int",}),({({"mixed",}),"shorts",({"mixed",}),"desc",({"mixed",}),"no_plural",}),(["main":({"This method sets up an item which will only be displayed during theday.  All of the standard add_item things are available with thismethod.",}),"see":({"/std/room->add_item()","add_night_item()",}),]),}),"add_room_chats":({({"void",}),({({"string","*",}),"new_chats",}),(["main":({"Adds more chats to the existing set of room chatsmanaged by this chatter object.",}),"see":({"remove_room_chats","query_room_chats","/std/room/basic/chatter",}),"param":({"new_chats an array of new chat strings",}),]),}),"query_room_size":({({"mixed",}),({}),(["main":({"This method queries the size of the room.  The default size of a roomis 10x10x10.  A room can be any rectangular size, this method will returnan array of three elements if the room is a non-cube.  If it returnsa single number then the room is assumed to be cubic.<p>({ north-south size, east-west size, up-down size })<p>The sizes are all radii's so they are half the actual width of the room.",}),"see":({"set_room_size()","query_room_size_array()",}),"return":({"the size of the room",}),]),}),"query_bright_mess":({({"string",}),({}),(["main":({"This method returns the message to use when it is too bright to see inthe room.  It defaults to: \"It's too bright to see anything!\".",}),"see":({"query_dark_mess()","long()","set_bright_mess()",}),"return":({"the message to print when it is too bright",}),]),}),"automate_situation":({({"varargs","void",}),({({"mixed",}),"label",({"mixed",}),"duration",({"mixed",}),"when",({"mixed",}),"chance",({"mixed",}),"category",}),(["main":({"Automate starting and ending of a situation.These situations can be invoked manually with start_situation.The automated starting and ending is unaffected by the room unloading.  When the room reloads the situation will be restarted unless its duration is up.You must include the file situations.h for the definitionsof the when masks.  The random seed needs to be setconsistently for the situations.  This is probably okunless your rooms are clones (see make_situation_seed). ",}),"see":({"add_situation","start_situation","end_situation","situations.h","set_situation_changer","make_situation_seed","goto learning  search  situation  for working examples",}),"param":({"label (mixed) label of the situation to start  up.  If you pass an array such as ({ \"frog1\", \"frog2\" }) for the label then that set of situations are started one ata time and the total duration is split evenly between them.Label is usually an integer or a string or an array ofintegers and/or strings.If the string is a list of labelsseparated by , then multiple situationsare started using those labels.","duration (int) total time (seconds) the overall situation should last.  You can put an array of durations -- one for eachsituation if the label lists more than one situation and thenthe overall time is the sum of the numbers.-1 is a special duration.  It means that the situaton given thatduration is not part of the set but a special background ordefault situation that occurs all the time except whenthis automated situation is going.","when (int) a time of the day mask.  This limits whenthe situation is allowed to occur.  The mask is composed ofthe allowed hours in AM time ( 24 hours clock, (1<<hour) and combined with | (OR) ).   You can just use thesepredefined masks and ignore how it works: WHEN_WEE_HOURS, WHEN_EARLY_MORNING, WHEN_LATE_MORNING, WHEN_AFTERNOON WHEN_EVENING, WHEN_LATENIGHT, WHEN_MIDDAY, WHEN_MORNING,  WHEN_EARLY_MORNING, WHEN_LATE_MORNING, WHEN_NIGHT, WHEN_DAY WHEN_ANY_TIME    The masks are defined in /include/situations.h.","chance  (int) chance in 1000 of starting the situation This is tested every duration seconds.","category (optional) if you specify a cateory for the situation                then no situations with the same category will overlap.                category would usually be a string eg. \"boats\".",}),"example":({"#include <situations.h> automate_situation( \"frog\", 300, WHEN_ANY_TIME, 200 );This will automatically start the situation labelled \"frog\" at a random time that is any time of the day with a 200/1000chance of it starting per 300 seconds.  It will last for300 seconds (5 minutes).  "," automate_situation( ({\"frog1,pond\",\"frog2,pond\"}), 240,                        WHEN_EVENING|WHEN_NIGHT, 300 );This will automatically start a situation that is a combination of \"frog1\" and \"pond\" followed by \"frog2\" and \"pond\".  They startat a random time but only in the evening or at night.  There will be a 300/1000 chance of it starting per 240 seconds.  Both the \"frog1\" and \"frog2\" situations will get half the total time (as there are two),  120 seconds each, for a total duration of 240 seconds (4 minutes)."," automate_situation( ({\"frog1,pond\",\"frog2,pond\"}), ({ 80,160 }),                        WHEN_EVENING|WHEN_NIGHT, 300 );Same as previous example except the durations of the individualparts are set: \"frog1,pond\" for 80 seconds followed by \"frog2,pond\"for 160 seconds.  The total time is 80+160.",}),]),}),"query_aliases":({({"string","*",}),({}),(["main":({"This method returns the current exit aliases for the room.",}),"see":({"add_alias()","remove_alias()",}),"return":({"the exit aliases of the room",}),]),}),"add_enchant":({({"int",}),({({"int",}),"number",}),(["main":({"Adds number to the current enchantment level of the room.The enchanment level controls things like what happens when youflip coins and some special messages which give wizards some idea about magic levels.",}),"see":({"query_enchant()",}),"param":({"number the new enchantment level to set",}),]),}),"remove_hidden_object":({({"int",}),({({"object",}),"thing",}),(["main":({"This method removes a hidden object.",}),"see":({"add_hidden_object()","query_hidden_objects()",}),"param":({"thing the hidden object to remove",}),"return":({"1 on success, 0 on failure",}),]),}),"find_inv_match":({({"object","*",}),({({"string",}),"words",({"object",}),"looker",}),(["main":({"This method returns all the matchable objects in the room.  This is usedby find_match to determine the group of objects to select from.",}),"param":({"words the words to match on","looker the person doing the pmacthing",}),"return":({"the array of objects to match on",}),]),}),"set_day_long":({({"void",}),({({"string",}),"str",}),(["main":({"This method sets the long description to display during the day time.",}),"see":({"query_day_long()","set_night_long()",}),"param":({"str the new day long description",}),]),}),"set_not_replaceable":({({"void",}),({({"int",}),"replace",}),(["main":({"This method sets a property to make the program replaceable.  A programwill only be replaced if there is only a setup() function in the room.A reset() or a create() will stop the room from being replace and infact any other function existing in there will stop it from beingreplaced as well.",}),"pram":({"replace 1 to make the room not replacable",}),"see":({"query_not_replaceable()",}),]),}),"add_use_internal_object":({({"void",}),({({"object",}),"thing",}),(["main":({"This method adds an object whose interior bits want to be able to exportcommands.  You can use this for tables an so on, so that stuff on a tablecan still be used.",}),"param":({"thing the thing whose inventory bits are to be exported",}),]),}),"add_exit":({({"int",}),({({"string",}),"direc",({"mixed",}),"dest",({"string",}),"type",}),(["main":({"This method adds an exit to the room.   The direction is the direction inwhich the exit should go.  This is something like \"north\" or \"entergate\".  The destination field is where the player will go when theyenter the exit.  The type is a set type that sets a whole bunch ofdefaults for the room.  The destination can be either a strongor an object.<p>The types are controlled by /obj/handlers/room_handler.c and the currenttypes and what this all means are:<dl><dd><dl><dt>road<dd>Wide road.<dt>path<dd>Narrower path<dt>door<dd>And exit with a door.  Defaults to closed but not locked.<dt>secret<dd>A secret door.  Defaults to closed but not locked.<dt>corridor<dd>A corridor (bing).<dt>hidden<dd>A hidden exit without a door</dl></dl><p>The room aliases are used to expand things for exits.  However theydon't expand the entire exit name.  They expand it in bits.  Forinstance, if the exit was \"enter live eel\", you couldadd_alias(\"eel\", \"live eel\"); and add_alias(\"bing\", \"enter\"); toget both of the bits of the exit.  So \"bing eel\", \"enter eel\",\"bing live eel\" etc would work.",}),"see":({"modify_exit()","query_dest_dir()","remove_exit()","/obj/handlers/room_handler",}),"example":({"add_exit(\"north\", PATH + \"market2\", \"road\");add_alias(\"eel\", \"live eel\");add_exit(\"enter live eel\", PATH + \"live_eel\", \"secret\");","object fluffy_room;fluffy_room = clone_object(PATH + \"fluffy_room\");add_exit(\"north\", fluffy_room, \"road\");",}),]),}),"set_bright_mess":({({"void",}),({({"string",}),"word",}),(["main":({"This method sets the bright message associated with the room.",}),"see":({"query_bright_mess()","long()",}),"param":({"word the new bright message",}),]),}),"query_chatter":({({"object",}),({}),(["main":({"This method returns the current chatter object.",}),"see":({"add_room_chat()",}),"return":({"the chatter object",}),]),}),"is_allowed_position":({({"int",}),({({"string",}),"poss",}),(["main":({"This method tells us if the passed i nposition isallowed in this type of room.",}),"param":({"poss the position to check",}),]),}),"query_size":({({"int",}),({({"string",}),"direc",}),(["main":({"This method returns the size of the exit.  This is used to check to makesure that people can enter it.",}),"see":({"modify_exit()",}),"param":({"direc the direction of the exit to check",}),"return":({"the size of the exit",}),]),}),"attack_speed":({({"int",}),({}),(["main":({"This method sets the default attack speed for the room.This defaults to 15.",}),"return":({"the default attack speed",}),]),}),"query_situation_changer":({({"object",}),({}),(["main":({"This method returns the current situation changer object.",}),"see":({"add_situation()","automate_situation()","change_situation",}),"return":({"the situation changer object",}),]),}),"query_relative":({({"int",}),({({"string",}),"direc",}),(["main":({"This method checks to see if the exit is a relative one.",}),"see":({"modify_exit()",}),"param":({"direc the direction to check",}),]),}),"set_keep_room_loaded":({({"void",}),({({"int",}),"flag",}),(["main":({"This method sets the flag that enables or disables the room beingcleaned up.  If they flag is set to 1, then room is never cleaned up.",}),"see":({"query_keep_room_loaded()",}),"param":({"flag the room being cleaned up flag",}),]),}),"set_wall":({({"void",}),({({"mixed","*",}),"args",}),([]),}),"add_item":({({"varargs","int",}),({({"mixed",}),"shorts",({"mixed",}),"desc",({"int",}),"no_plural",}),(["main":({"This method adds an item description to a room.  This allows you toset up objects which do not as such exist, but can be looked at forinstance.  There should be a lot of these in rooms.  The name ofthe item can be multiple word, and the plural for it isautomagicaly added, unless the no_plural flag is set.  If the nameis an array all of the elements in the array respond to thedescription.<p>If the desc is set to an array, you can use this for handlingthings like read messages and so on too.  Every second element inthe array is the description/text to be printed and the otherelement is the command upon which the text should be printed.  Thespecial command 'long' is used to set the long description.<p>The special type 'position' is used to allow people to use thatitem to do positions on, like stand, sit, lie etc.<p>This method also allows you to setup add_command patterns.  If thename after the verb is just a string, then the string will be printedwhen that verb is used.  If it is just a function pointer then thefunction will be evaluated and the return result printed.  If itis an array, then the first element must be a function pointer andthe second optional element is the pattern to use for that method.Multiple patterns and functions may be specified.",}),"see":({"query_item()","remove_item()","modify_item()",}),"param":({"shorts the short description of the item","desc the description of the item","no_plural do not automaticaly add a plural for the item",}),"example":({"add_item(\"green pot plant\", \"It is a nasty green pot plant lurking by \"                            \"the door.\\n\");","add_item(({ \"telephone\", \"red phone\" }),         \"Sitting in the corner is the red phone, it is staring unhappily \"         \"into space thinking of cupcakes and better times.\\n\");","add_item(\"small book\", ({ \"long\", \"A small red book with dots on the                                  \"cover.\\n\",                          \"read\", \"It says 'Rabbit!' in big letters.\\n\" }) );","add_item(\"green leather couch\",         ({ \"long\", \"The green leather couch is wonderful , so comfy!  \"                    \" So... Comfy!\\n\"m            \"position\", \"the green leather couch\" }) );","add_item(\"rotating hologram\", (: query_current_hologram_string() :));","add_item(\"glue stick\",         ({ \"long\", \"The glue stick looks sticky, like you could slime \"                    \"something with it.\\n\",            \"slime\", ({ (: do_slime :),                        \"<indirect:living> with <direct:object>\" }) }) );",}),"return":({"1 if successfully added, 0 if not",}),]),}),"reset_exits":({({"void",}),({}),(["main":({"This method removes all the current exits in the room.",}),"see":({"add_exit()","remove_exit()","modify_exit()",}),]),}),"query_look":({({"string",}),({({"string",}),"direc",}),([]),}),"end_situation":({({"void",}),({({"mixed",}),"label",}),(["main":({"Ends a situation previously added and started on the room.  These situations can be invoked manually with start_situation or automatically via automate_situation. ",}),"see":({"add_situation","start_situation","automate_situation","change_situation",}),"param":({"label label for the situation",}),]),}),"set_room_size":({({"void",}),({({"mixed",}),"number",}),(["main":({"This method sets the rooms principle radii.  If the parameter isa singlenumber then the room is assumed to be cubic and dimension applies inall directions.  If the input is a three element array then the elementsapply to all the directions.<br>({ north-south size, east-west size, up-down size })<p>The sizes are all radii's so they are half the actual width of the room.",}),"see":({"query_room_size()","query_room_size_array()",}),"param":({"number the new size of the room",}),]),}),"query_is_room":({({"int",}),({}),(["main":({"Returns 1 to indicate that this object is a room.",}),"return":({"1 to indicate that this is a room",}),]),}),"query_not_replaceable":({({"int",}),({}),(["main":({"This method checks to see if the program is replaceable.",}),"see":({"set_not_replaceable()",}),"return":({"1 if the program is not replaceable",}),]),}),"query_effects":({({"object",}),({}),(["main":({"This method returns the current effects object.",}),"see":({"add_effect()",}),"return":({"the effects object",}),]),}),"set_terrain":({({"int",}),({({"string",}),"terrain_name",}),([]),}),"set_chat_min_max":({({"void",}),({({"int",}),"min",({"int",}),"max",}),(["main":({"Allows the chat interval to be changed.",}),"param":({"min minimum interval between chats (seconds)","max maximum interval between chats (seconds)",}),]),}),"set_theft_handler":({({"void",}),({({"string",}),"word",}),(["main":({"This method sets the current theft handler for the room.",}),"see":({"query_theft_handler()",}),"param":({"word the new theft handler for the room",}),]),}),"set_default_position":({({"void",}),({({"mixed",}),"stuff",}),(["main":({"This method sets the default position for the room.  Se the setdefault position in the living code for a more completeexample of this.",}),"see":({"/ostd/living/living->set_default_position()",}),"param":({"pos the default position",}),]),}),"query_zones":({({"string","*",}),({}),(["main":({"This method returns the set of move zones for this room.  This is usedby npcs to see which rooms they are allowed to move into.",}),"see":({"add_zone()","/obj/monster->add_move_zone()",}),]),}),"query_short_exit_string":({({"string",}),({}),(["main":({"This method returns the short exit string.  The short exit string is thestring used in 'brief' mode of a players look.",}),"see":({"calc_short_exit_string()","query_exit_string()",}),"return":({"the short exit string",}),]),}),"query_theft_handler":({({"string",}),({}),(["main":({"This method returns the current theft handler for the room.",}),"see":({"set_theft_handler()",}),"return":({"the theft handler of the room",}),]),}),"set_dynamic_enchant":({({"void",}),({({"float",}),"number",}),(["main":({"This method sets the current dynamic enchantment of the room.",}),"see":({"set_enchant()",}),"return":({"the theft handler of the room",}),]),}),])
protected_functions ([])
inherits (["/std/basic/cute_look":({}),"/std/basic/help_files":({}),"/std/basic/property":({}),"/std/basic/light":({}),"/std/basic/extra_look":({}),"/std/basic/export_inventory":({}),"/std/basic/desc":({}),])
main_docs (["main":({"The standard room inheritable.  This contains all the stuff needed toconstruct a standard room.",}),"author":({"Pinkfish",}),"see":({"/std/room/outside.c",}),])
define_docs ([])
includes (["/include/position.h":1522061544,"/include/nroff.h":1522061544,"/include/armoury.h":1522061544,"/include/dirs.h":1522061544,"/include/room.h":1522061544,"/include/situations.h":1522061544,"/include/move_failures.h":1522061544,"/include/twilight.h":1522061544,"/include/door.h":1522061544,])
class_docs ([])
file_name "/std/room/basic_room_new.c"
last_changed 1522061544
