#/obj/handlers/autodoc/autodoc_file.c
public_functions (["query_sittiming":({({"mixed","*",}),({}),(["main":({"returns sittiming class with info about automated situations ",}),"return":({"class sittiming",}),]),}),"start_situation":({({"void",}),({({"mixed",}),"label",({"int",}),"do_start_mess",}),(["main":({"Starts a situation previously added to the roomthat is managed by this object.These situations can be invoked manually with start_situation or automatically viaautomate_situation. ",}),"see":({"add_situation","end_situation","automate_situation",}),"param":({"label string or number labelling the situation","do_start_mess 0 to supress the start_mess string       This is to fake it that a situation has been        going for a while when really you just loaded it.",}),]),}),"shutdown_all_situations":({({"void",}),({}),(["main":({"Shuts down all current and pending situations.  It also turns off theautomated situation manager so no more are added.  It does notdestruct this object so all the add_situations are still loadedand may be recommenced with automate_situation or change_situation.  dest_me is the appropriate call to permanently remove all situations.",}),"see":({"automate_situation","change_situation",}),]),}),"query_possible":({({"int",}),({({"class","situation_timing",}),"sit",({"int",}),"it",({"int",}),"tod",({"int",}),"cnt",}),([]),}),"change_situation":({({"varargs","mixed",}),({({"mixed",}),"label",({"mixed",}),"duration",({"mixed",}),"words",({"mixed",}),"handle",}),(["main":({"Starts one or more situations that will end after aspecified duration.  You can use an array and makefurther situations commence when others end.",}),"see":({"start_situation","end_situation","add_situation","choose_words",}),"param":({"label (mixed) label of the situation to start  up.  If you pass an array such as ({ \"frog1\", \"frog2\" }) for the label then that set of situations are started one ata time and the total duration is split evenly between them.Label is usually an integer or a string or an array ofintegers and/or strings.If the string is a list of labelsseparated by , then multiple situationsare started using those labels.","duration (int) total time (seconds) the overall situation should last.  You can put an array of durations -- one for eachsituation if the label lists more than one situation and thenthe overall time is the sum of the numbers.-1 means indefinite so having any situations aftersomething with -1 duration is pointless.","handle is an internal thing that should only be called with 0unless you really know what you are doing.","words is a list of replacements for #n in the text OR       a random number seed, it is       passed to choose_words.       eg. ({ \"#1\", \"frog\", \"#2\", \"honey\" }) or 22",}),"return":({"call_out that is propogating the changesThis is useful if you want to be able to kill the wholeset without disturbing other situations.",}),]),}),"query_situations":({({"mapping",}),({}),(["main":({"returns mapping of situations. ",}),"return":({"mapping of situations",}),]),}),"check_situations":({({"void",}),({}),(["main":({"Tests for enabling situation managing.If situation managing is already active or turned offit does nothing.",}),"see":({"automate_situation",}),]),}),"shutdown_situation":({({"void",}),({({"int",}),"handle",({"mixed",}),"label",}),(["main":({"Shuts down a change_situation based on the call_out handlereturned by the call to change_situation.",}),"see":({"automate_situation","change_situation",}),"param":({"handle call_out handle.  If 0 then the lastknown handle is used.","label label or array of labels of situations to clean up with end_situation","the_room the room",}),]),}),"make_seed":({({"void",}),({({"int",}),"xval",({"int",}),"yval",}),(["main":({"Makes a seed value for the random part of when situations turn on and off.  The two ints must be constant for a given room -- like the coordinates.",}),"param":({"xval integer to use to make a seed (eg. x coordinate)","yval integer to use to make a seed (eg. y coordinate)",}),]),}),"query_status":({({"int",}),({}),(["main":({"returns status of situation manager.  If it is sleeping it will turn on again if aplayer enters the room.",}),"return":({"status 0 off 1 on 2 sleeping",}),]),}),"set_room":({({"object",}),({({"object",}),"room_o",}),([]),}),"end_situation":({({"void",}),({({"mixed",}),"label",}),(["main":({"Ends a situation previously added and started on the roomthat is managed by this object.These situations can be invoked manually with start_situation or automatically via automate_situation. ",}),"see":({"add_situation","start_situation","automate_situation",}),"param":({"label string or number labelling the situation",}),]),}),"choose_words":({({"void",}),({({"mixed",}),"label",({"mixed",}),"choice",}),(["main":({"This function selects word replacements for #n in the text.",}),"see":({"replace",}),"param":({"label Situation label to choose for","choice A random seed (integer) or              a set of pairs exactly the same as the second              argument to replace.",}),"example":({"     choose_words( \"frog\", ({ \"#1\", \"tadpole\", \"#2\", \"pond\" }));",}),]),}),"query_current_situations":({({"int","*",}),({}),(["main":({"returns situations currently turned on.",}),"return":({"int array of situation labels",}),]),}),"add_situation":({({"void",}),({({"mixed",}),"label",({"class","situation",}),"sit",}),(["main":({"Adds a situation to the room.  These situations can beinvoked manually with start_situation or automatically viaautomate_situation.",}),"see":({"start_situation","automate_situation","add_item","room_chat","add_extra_look",}),"param":({"label string or number labelling the situation","sit a structure (class) containing all the bitsof the situation you want to add.eg. start_func function to be called at start of situation             that might be used to load NPC's or anything            beyond a message.            The start function is passed the label,             a do_start_mess flag and the room object.              If the flag is 1 the situation is starting             rather than being reloaded.  Thus if             do_start_mess is 0 then you should avoid            any obvious start messages and make it look            like the situation is already underway.end_func function to be called an the end of a situation.              The end function is only            passed the label and the room object.start_mess message told to the room at start of situationend_mess message told to the room at end of situationextra_look extra look string appended to rooms long             during the situationchats an array of chat strings to be active             during the situation add_items a mixed array of ({ item, item description })             pairs to be active during the situationrandom_words sets of words of the form ({ ({ \"option1\",\"option2\" }),            ({ \"adjective1\",\"adjective2\" }), ... }).  One of the            the first set replaces #1 in any text above and one of            the second set replaces #2 in any text above and so on.            The random choice is fixed for the duration of any one            situation.",}),"example":({"#include <situations.h>class situation frogs;frogs = new(class situation,     start_mess: \"Water seeps out of the ground to form puddles.\",    extra_look: \"There are large puddles on the ground here.\",    chats: ({\"A hidden frog croaks quietly.\",             \"There is a blooping sound.\" }),    add_items:({ ({\"puddle\", \"The puddles are dark and murky.  \"                    \"They will probably dry up given time.\" }) }) );add_situation( \"frogs\", frogs );","add_situation( \"frogs\", new(class situation,      start_mess: \"Water seeps out of the ground to form puddles.\",     extra_look: \"There are large puddles on the ground here.\",     chats: ({\"A hidden frog croaks quietly.\",              \"There is a blooping sound.\" }),     add_items: ({ ({\"puddle\", \"The puddles are dark and murky.  \"                      \"They will probably dry up given time.\" }) }) ));",}),]),}),"automate_situation":({({"void",}),({({"mixed",}),"label",({"mixed",}),"duration",({"mixed",}),"when",({"mixed",}),"chance",({"mixed",}),"category",}),(["main":({"Automate starting and ending of a situations.These situations can be invoked manually with start_situation.The automated starting and ending is unaffected by the room unloading.  When the room reloads the situation will be restarted unless its duration is up.You must include the file situations.h for the definitionsof the when masks.",}),"see":({"add_situation","start_situation","end_situation","evolvingroom.h",}),"param":({"label (mixed) label of the situation to start  up.  If you pass an array such as ({ \"frog1\", \"frog2\" }) for the label then that set of situations are started one ata time and the total duration is split evenly between them.Label is usually an integer or a string or an array ofintegers and/or strings.If the string is a list of labelsseparated by , then multiple situationsare started using those labels.","duration (int) total time (seconds) the overall situation should last.  If an array is specified for duration eachsituation gets it's own little one.  If -1 is specified asa duration for one part that situation is background complimentarysituation to the rest that is on when the rest are off.","when (int) a time of the day mask.  This limits whenthe situation is allowed to occur.  The mask is composed ofthe allowed hours in AM time ( 24 hours clock, (1<<hour) and combined with | (OR) ).   You can just use thesepredefined masks and ingore how it works: WHEN_WEE_HOURS, WHEN_EARLY_MORNING, WHEN_LATE_MORNING, WHEN_AFTERNOON WHEN_EVENING, WHEN_LATENIGHT, WHEN_MIDDAY, WHEN_MORNING,  WHEN_EARLY_MORNING, WHEN_LATE_MORNING, WHEN_NIGHT, WHEN_DAY WHEN_ANY_TIME    The masks are defined in /include/situations.h.","chance  (int) chance in 1000 of starting the situation This is tested every duration seconds.",}),"example":({"#include <situations.h> automate_situation( \"frog\", 300, WHEN_ANY_TIME, 200 );This will automatically start the situation labelled \"frog\" at a random time that is any time of the day with a 200/1000chance of it starting per 300 seconds.  It will last for300 seconds (5 minutes).  "," automate_situation( ({\"frog1\",\"frog2\"}), 240, WHEN_EVENING|WHEN_NIGHT,, 300 );This will automatically start a situation that is a combination of \"frog1\" followed by \"frog2\" at a random time but only in theevening or at night.  There will be a 300/1000 chance of it starting per 240 seconds.  Both the \"frog1\" and \"frog2\" situations will get half the total time (as there are two),  120 seconds each, for a total duration of 240 seconds (4 minutes).",}),]),}),"extra_look":({({"string",}),({}),([]),}),"insert_words_items":({({"mixed","*",}),({({"class","situation",}),"sit",({"string","*",}),"words",}),(["main":({"Replaces #1 in text with the one of the first array of words in wordlistand #2 with one of the second array of words and so on...For items only the item text is changed, not the key words.",}),]),}),"manage_situations":({({"void",}),({}),(["main":({"Starts and ends situations according to the informationin the sittiming array.  It is called continuously automatically while there are interactives in the room.",}),]),}),"query_room":({({"object",}),({}),([]),}),"insert_words_chats":({({"string","*",}),({({"class","situation",}),"sit",({"string","*",}),"words",}),(["main":({"Replaces #1 in text with the one of the first array of words in wordlistand #2 with one of the second array of words and so on...Each string in the string array is changed.",}),]),}),])
protected_functions ([])
inherits ([])
main_docs (["main":({"situation changer object associated with a room object.",}),])
define_docs (["RANDOM(a,b)":([]),])
includes (["/include/situations.h":1522061544,"/include/am_time.h":1522061544,])
class_docs (["situation_timing":({0,({({"label",({"mixed",}),}),({"duration",({"mixed",}),}),({"when",({"mixed",}),}),({"chance",({"int",}),}),({"endat",({"int","*",}),}),({"background",({"mixed",}),}),({"category",({"mixed",}),}),({"it",({"int",}),}),({"it_data",({"mapping",}),}),}),([]),}),])
file_name "/std/room/basic/situation_changer.c"
last_changed 1522061544
