#/obj/handlers/autodoc/autodoc_file.c
public_functions (["do_show":({({"int",}),({}),(["main":({"This function will show the embedded 'movie' text at regular intervals.",}),"return":({"returns 0 on failure, 1 on success.",}),]),}),"do_read":({({"int",}),({({"string",}),"name",}),(["main":({"This function will take the name of a player and if the interview documentfor that player exists, print it to the screen of this_player().",}),"param":({"name the name of the player.",}),"return":({"0 on failure, 1 on success.",}),]),}),"load":({({"void",}),({}),([]),}),"add_creator":({({"int",}),({({"string",}),"name",}),(["main":({"Entry point to the add creator command.",}),"param":({"name name of the creator to allow",}),"return":({"0 on failure, 1 on success.",}),]),}),"query_confirmation":({({"string",}),({}),(["main":({"Returns the confirmation mail text.",}),"return":({"The confirmation text",}),]),}),"query_lord":({({"string",}),({}),(["main":({"Return the domain's lord.",}),"return":({"the capitalised name of the lord.",}),]),}),"query_interview":({({"int",}),({}),(["main":({"Return whether creator candidates require an interview for this domain.",}),"return":({"0 if an interview is not required.  Anything else if it is.",}),]),}),"query_all_applicants":({({"string","*",}),({}),([]),}),"do_query":({({"int",}),({}),(["main":({"Query the current state of applications.",}),"return":({"0 on failure, 1 on success",}),]),}),"flush":({({"int",}),({}),(["main":({"Flush the candidate, interviewed and submitted lists.",}),"return":({"0 on failure, 1 on success",}),]),}),"add_interviewed":({({"int",}),({({"string",}),"name",}),([]),}),"add_candidate":({({"int",}),({({"string",}),"name",}),(["main":({"Add a candidate to the list.  Will not send part two of the applicationto them.",}),"param":({"name name of the player to add.",}),"return":({"0 on failure, 1 on success",}),]),}),"query_interviewer":({({"string","*",}),({}),([]),}),"event_emote":({({"void",}),({({"object",}),"ob",({"string",}),"mess",}),([]),}),"save":({({"void",}),({}),([]),}),"query_submitted":({({"string","*",}),({}),([]),}),"query_applicants_text":({({"string",}),({}),(["main":({"Return which candidates have been mailed, which have sent in their submission, and which are left to be interviewed or replied to.",}),"return":({"the text to be displayed",}),]),}),"do_confirm":({({"int",}),({({"string",}),"candidate",}),(["main":({"Confirm receipt of a candidate's submission.",}),"param":({"candidate name of the player to add.",}),"return":({"0 on failure, 1 on success",}),]),}),"remove_candidate":({({"int",}),({({"string",}),"candidate",}),(["main":({"Delete a player from the list.  Will search through all three lists foran occurance of the name before deleting it where found.",}),"param":({"candidate the name of the player to remove.",}),"return":({"0 on failure, 1 on success",}),]),}),"add_confirmed":({({"int",}),({({"string",}),"name",}),([]),}),"query_interviewed":({({"string","*",}),({}),([]),}),"set_part_two_required":({({"void",}),({({"int",}),"i",}),([]),}),"query_rejection":({({"string",}),({}),(["main":({"Query the rejection mail text.",}),"return":({"the rejection text",}),]),}),"do_stop":({({"int",}),({}),([]),}),"query_cc":({({"string",}),({}),(["main":({"Query the names cc'd by default.",}),"return":({"an imploded string of cc'd names",}),]),}),"do_interview":({({"varargs","int",}),({({"object",}),"ob",({"string",}),"names",}),(["main":({"This function is the main entry point for the interview code.  It will set the subject of the room, and write an entry in the interviewtext containing who the interview is with, when it was started, andwho conducted the interview.",}),"param":({"ob the object to interview",}),"return":({"0 on failure, 1 on success",}),]),}),"set_cc":({({"void",}),({({"string","*",}),"i",}),(["main":({"Set the names cc'd by default.",}),"param":({"i an array of cc'd names.",}),]),}),"query_acceptance":({({"string",}),({}),(["main":({"Query the acceptance mail text.",}),"return":({"the rejection text",}),]),}),"set_interview":({({"void",}),({({"int",}),"i",}),(["main":({"Set whether an interview is required of creator candidates.",}),"param":({"i the interview state.",}),]),}),"set_domain":({({"void",}),({({"string",}),"dom",}),(["main":({"Set the domain the room exists in.",}),"param":({"dom name of the domain.",}),]),}),"do_list":({({"int",}),({}),([]),}),"set_acceptance":({({"void",}),({({"string",}),"text",}),(["main":({"Set the acceptance mail text.",}),"param":({"text the acceptance mail text",}),]),}),"remove_creator":({({"int",}),({({"string",}),"name",}),(["main":({"The entry point to the remove creator command.",}),"param":({"name name of the creator to remove",}),"return":({"0 on failure, 1 on success.",}),]),}),"do_end":({({"int",}),({}),(["main":({"The function to end the interview.  Will write an entry in the interviewtext containing who the interview was with and when the interview wasended.  It will then add the subject to the list of interviewed names andsave the object.  Finally, it will reset the subject of the room. ",}),"return":({"0 on failure, 1 on success.",}),]),}),"play_movie":({({"void",}),({({"int",}),"i",}),(["main":({"This function does a person_say event on the environmen.  The content of the event is the relevant movie text to be said.",}),"param":({"i the index of the movie to be be played.",}),]),}),"set_movie":({({"void",}),({({"string","*",}),"m",}),(["main":({"Tests to see if a particular creator is permitted to make use of the interview room.  Domain lords and deputies are always permitted.",}),"param":({"name the name of the object attempting to use the room.",}),"return":({"1 if the creator is allowed, 0 if they are not.",}),]),}),"query_part_two":({({"string",}),({}),(["main":({"Return the text for the second part of the application.",}),"return":({"application text.",}),]),}),"query_permitted_creators":({({"string","*",}),({}),(["main":({"Query the creators permitted to use this room.",}),"return":({"an empty array if no creators are permitted.  The array of creators otherwise.",}),]),}),"do_flag":({({"int",}),({({"string",}),"name",({"string",}),"flag",}),(["main":({"Entry point for the flag command.  Sets an application as accepted or rejected, and sends out the appropriate form mail.",}),"param":({"name name of candidate.","flag \"accepted\" or \"rejected\"",}),"return":({"0 on failure, 1 on success.",}),]),}),"do_query_text":({({"int",}),({({"string",}),"flag",}),(["main":({"Entry point for the query command.",}),"return":({"0 on failure, 1 on success.",}),]),}),"query_permitted":({({"int",}),({({"string",}),"name",}),([]),}),"query_subject":({({"string",}),({}),(["main":({"Query the subject of an interview if one is ongoing.",}),"return":({"0 if there is no subject.  The name of the subject if there is.",}),]),}),"set_rejection":({({"void",}),({({"string",}),"text",}),(["main":({"Set the rejection mail text.",}),"param":({"text the rejection mail text",}),]),}),"set_confirmation":({({"void",}),({({"string",}),"text",}),(["main":({"Set the text of the confirmation mail.",}),"param":({"dom name of the domain.",}),]),}),"clear_interviewed":({({"int",}),({}),(["main":({"Clear the list of interviewed players.",}),"return":({"0 on failure, 1 on success",}),]),}),"set_part_two":({({"int",}),({({"string",}),"file",}),(["main":({"Set the filename for the second part of the application.",}),"param":({"file filename of the second part.",}),"return":({"0 on failure, 1 on success.",}),]),}),"remove_interviewed":({({"int",}),({({"string",}),"candidate",}),(["main":({"Remove a player from the interviewed list.",}),"param":({"candidate name of the player to add.",}),"return":({"0 on failure, 1 on success",}),]),}),"do_add":({({"int",}),({({"string",}),"candidate",}),(["main":({"Start off a creator application by sending them out the second part ofthe application procedure.  ",}),"param":({"candidate the name to send the second part of the application to.",}),"return":({"0 on failure, 1 on success",}),]),}),"set_interview_dir":({({"int",}),({({"string",}),"dir",}),(["main":({"Set the directory where interviews are to be stored.",}),"param":({"dir interview directory.",}),"return":({"0 on failure, 1 on success.",}),]),}),"clear_candidates":({({"int",}),({}),(["main":({"Clear the list of player candidates.",}),"return":({"0 on failure, 1 on success",}),]),}),"query_is_interviewer":({({"int",}),({({"string",}),"name",}),([]),}),"query_allowed_creators":({({"int",}),({}),(["main":({"Entry point to the query allowed creators command.",}),"return":({"0 on failure, 1 on success.",}),]),}),"query_part_two_required":({({"int",}),({}),([]),}),"query_domain":({({"string",}),({}),(["main":({"Return the domain the room exists in.",}),"return":({"The name of the domain, or 'unset' if none is set.",}),]),}),"query_interview_dir":({({"string",}),({}),(["main":({"Return the directory where interviews are to be stored.",}),"return":({"interview directory.",}),]),}),])
protected_functions ([])
inherits (["/std/room":({}),])
main_docs (["main":({" Domain Interview Room @author Drakkos @started on 02/12/2000 ",}),])
define_docs (["DEBUG":([]),"SECURE":([]),"LOG":([]),"EVENTS":([]),"SAVE":([]),"LORD":([]),])
includes (["/include/player_handler.h":1522061544,"/include/mail.h":1522061544,])
class_docs ([])
file_name "/std/dom/interview_inherit.c"
last_changed 1522061544
