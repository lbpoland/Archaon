#/obj/handlers/autodoc/autodoc_file.c
public_functions (["end_situation":({({"void",}),({({"int",}),"num",({"object",}),"room",}),(["main":({"Ends a situation previously added and started on the roomthat is managed by this object.These situations can be invoked manually with start_situation or automatically via automate_situations. ",}),"see":({"add_situation","start_situation","automate_situations",}),"param":({"num number labelling the situation","room room to end situation on",}),]),}),"query_rooms":({({"object","*",}),({}),([]),}),"start_situation":({({"void",}),({({"int",}),"num",({"int",}),"do_start_mess",({"object",}),"room",}),(["main":({"Starts a situation previously added for the roomthat is managed by this object.These situations can be invoked manually with start_situation or automatically viaautomate_situations. ",}),"see":({"add_situation","end_situation","automate_situations",}),"param":({"num number labelling the situation","do_start_mess 0 to supress the start_mess string       This is to fake it that a situation has been        going for a while when really you just loaded it.","room room to add situation to",}),]),}),"manage_rooms_situations":({({"void",}),({}),(["main":({"Starts and ends situations according to the informationin the sittiming mapping for each room in the rooms array.  It is called continuously automatically while there are interactives in the room.",}),]),}),"query_current_situations":({({"int","*",}),({({"object",}),"room",}),(["main":({"returns situations currently turned on.",}),"return":({"int array of situation labels",}),]),}),"check_situations":({({"void",}),({({"object",}),"room",}),(["main":({"Tests for enabling situation managing.If situation managing is already active or turned offit does nothing.",}),"see":({"automate_situations",}),"param":({"room the room",}),]),}),"add_situation":({({"void",}),({({"int",}),"num",({"function","*",}),"func",({"string",}),"startmess",({"string",}),"endmess",({"string",}),"extralookstring",({"string","*",}),"chats",({"mixed","*",}),"add_items",}),(["main":({"Adds a situation for the rooms.  These situations can beinvoked manually with start_situation or automatically viaautomate_situations.",}),"see":({"start_situation","automate_situations","add_item","room_chat","add_extra_look",}),"param":({"num number labelling the situation","func function to be called at start of situation             that might be used to load NPC's.  If it is            a set of two function pointers ({ f1, f2 })            the second function is called when the            situation is ended.  The start function is             passed the num label of the room and a            do_start_mess flag.  If the flag is one            the situation is starting rather than            being reloaded.  The end function is only            passed the num label.","startmess message told to the room at start of situation","endmess message told to the room at end of situation","extralooksting extra look string appended to rooms long description during the situation","chats an array of chat strings to be active during the situation ","add_items a mixed array of ({ item, item description }) pairs to be active during the situation",}),"example":({" add_situation( 0, 0, \"Water seeps out of the ground to form puddles.\",     \"\",  \"There are large puddles on the ground here.\",    ({\"A hidden frog croaks quietly.\",      \"There is a blooping sound.\" }),    ({ ({\"puddle\", \"The puddles are dark and murky.  \"                    \"They will probably dry up given time.\" }) }) );",}),]),}),"shutdown_situations":({({"void",}),({({"object",}),"room",}),(["main":({"Shuts down all current and pending situations.  It also turns off theawaked situation manager so no more are added.  It does notdestruct this object so all the add_situations are still loadedand make be recommenced with automate_situations.  dest_me isthe appropriate call to permanently remove all situations.",}),"see":({"automate_situations",}),"param":({"room room to shutdown situations on",}),]),}),"automate_situations":({({"void",}),({({"mixed","*",}),"chatargs",({"int",}),"xval",({"int",}),"yval",({"mixed","*",}),"edata",({"object",}),"room",}),(["main":({"Awakes starting and ending of situations.These situations can be invoked manually with start_situation.The awaked starting and ending is unaffected by the room unloading.  When the room reloads the situation will be restarted unless its duration is up.",}),"see":({"add_situation","start_situation","end_situation","evolvingroom.h",}),"param":({"chatargs same as arguments to room chat:   ({ min, max, ({ chat1, chat2, ... }) })   if you want no non-situational chats just put ({ min, max, ({ }) })   min, max are always needed being the minimum/maximum time   between all chats.  chat1 is a string containing a chat.","xval First random seed number (eg. x coordinate)","yval Second random seed number (eg. y coordinate)","sittiming A mixed array containing the information    about when the situations added by add_situation are    automatically started and ended:   ({ info1, info2, info3, ... }) Each info is a mixed array as follows:   ({ number, duration, when, chance })              -- or --   ({ ({ num0, num1, num2, ..., numN }) , when, duration, percent })number     (int) label of the situation to start            up if number is an array then a set of           situations are started one at a time.           The total duration is divided evenly            between the situations labelled by the            numbers in the array which are started            and ended in the order given.  The            entire set always gets used.duration   (int) time (minutes) situation should last forwhen       (int) a nighttime/daytime mask           This determines when during the day in           Ankh-Morpork time the situation may occur.             The masks are defined in evolvingtime.h           It can be a function pointer in which case it is            expected to return a mask value.chance     (int) 1/1000 chance per period of duration minutes            of getting into the situation",}),"example":({" automate_situations( room, ({ 50,70, ({\"\"}) }),     170,  220,    ({ ({           0, 5, WHEN_ANY_TIME, 200 }),       ({ ({ 1,2,3 }), 6, (WHEN_NIGHT|WHEN_EVENING), 500 }) }) );",}),]),}),"extra_look":({({"string",}),({({"object",}),"room",}),([]),}),"manage_situations":({({"void",}),({({"object",}),"room",}),(["main":({"Starts and ends situations according to the informationin the sittiming mapping.  It is called continuously automatically while there are interactives in the room.",}),]),}),"query_status":({({"int",}),({}),(["main":({"returns status of situation manager.  If it is sleeping it will turn on again if aplayer enters the room.",}),"return":({"status 0 off 1 on 2 sleeping",}),]),}),])
protected_functions ([])
inherits ([])
main_docs (["main":({"situation changer object associated with multiple room objects.It keeps a list of rooms and checks them all in turn. It behaves similarly to the room_handler.  It's main purpose isto avoid duplicating a large chat database for many roomsthat all use it. ",}),])
define_docs (["RANDOM(a,b)":([]),"SECTOCHECK":([]),"MAXROOMS":([]),"INSTALLDELAY":([]),"MIN_DURATION":([]),])
includes (["/include/situations.h":1522061544,"/include/am_time.h":1522061544,])
class_docs ([])
file_name "/std/room/basic/multiroom_situation_changer.c"
last_changed 1522061544
