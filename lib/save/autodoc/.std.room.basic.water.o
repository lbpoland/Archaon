#/obj/handlers/autodoc/autodoc_file.c
public_functions (["query_sinking_mess":({({"string",}),({}),(["main":({"This function returns the position that non-living items will have when theyare sinking in this room.",}),"see":({"set_sinking_mess",}),"return":({"the current position for sinking items",}),]),}),"set_turbidity":({({"void",}),({({"int",}),"how_murky",}),(["main":({"This function is an alternative method of setting the clarity of the water.The turbidity is defined as 100 minus the clarity of the water.  The defaultturbidity is 10.",}),"see":({"set_clarity","query_turbidity",}),"param":({"how_murky the new turbidity of the water",}),]),}),"get_enter_mess":({({"string",}),({({"object",}),"ob",({"string",}),"direc",}),(["main":({"This function returns the appropriate entry message for the specified objectin the specified direction.  If a value has been set by add_enter_mess thenit is returned.  The query_origin function is used to find a replacement forthe \"$F\" token.  It is used automagically by the swim_exit function, but canbe overridden if you feel like it.",}),"see":({"add_enter_mess","add_exit_mess","get_exit_mess","query_origin",}),"param":({"ob the object for which the entry message should be found","direc the direction in which the object is exiting",}),"return":({"the entry message for this object",}),]),}),"query_water_surface_light":({({"int",}),({}),(["main":({"This function returns the amount of light that will filter down to roomsbelow this one that have had set_use_surface_light called in them.  Itsdefault is to return a value based on the light in this room and the clarityof the water.",}),"see":({"set_use_surface_light","set_turbidity","set_clarity",}),"return":({"the amount of light that filters down to rooms below this one",}),]),}),"swim_exit":({({"int",}),({({"string",}),"dir",({"object",}),"ob",({"string",}),"mess",}),(["main":({"This is an exit function set for any exits in a water room.  It finds thedifficulty of swimming through the exit, on the basis of the current throughthat exit, the buoyancy of the object and the extra difficulty that it hasin swimming.  The swimming/immersion effect calculates the latter two withcalc_buoyancy and swim_difficulty respectively.  The object is subjected toa skillcheck in other.movement.swimming to see if it can move through theexit.There is a guildpoint cost equal to 1/20th of the difficulty of theskillcheck.",}),"see":({"modify_exit","exit_function","calc_buoyancy","swim_difficulty","query_water_traction_bonus","perform_task",}),"param":({"dir the direction in which the object is leaving","ob the object that is trying to leave","mess a weird extra string that isn't relevant here",}),"return":({"whether or not the object can move through the exit",}),]),}),"set_bottom":({({"void",}),({({"int",}),"val",}),(["main":({"This function sets whether or not this room has a solid surface or bottom init.  If it does, then items may appear as being on the bottom, and livingobjects are more able to resist currents (as they have something to hold onto).  The parameter of this function can be 1 to make this room have abottom, 0 to make it have no bottom, or -1 (the default) to make it decidewhether or not it has a bottom by checking to see if it has any exits in thecurrent down direction (as set by set_down_dir).",}),"see":({"query_bottom","set_bottom_mess","set_down_dir",}),"param":({"val whether or not the room has a bottom",}),]),}),"query_surface":({({"int",}),({}),(["main":({"This function returns 1 if this is a surface room, and 0 otherwise.",}),"see":({"set_surface","query_underwater",}),"return":({"whether this is a surface room",}),]),}),"update_water_light":({({"void",}),({}),(["main":({"This function updates the amount of light filtering down to this room fromthe rooms above it, if it is necessary to do so.  It is called byquery_light in /std/room/water_inside and /std/room/water_outside.",}),"see":({"set_use_surface_light","set_light","query_water_surface_light","get_water_surface_light",}),]),}),"set_float_out_mess":({({"void",}),({({"string",}),"mess",}),(["main":({"This function sets the message that will be displayed when an object floatsout of this room.  The string \"$up$\" will be replaced by the current updirection for this room (as set by set_up_dir), and the usual other$-expansion for messages will occur.  The default is \"$N float$s $up$.\".",}),"see":({"query_float_out_mess","set_up_dir","query_up_dir",}),"param":({"mess the new exit message for floating objects",}),"example":({"  set_float_out_mess(\"$N float$s $up$ out of the cavern.\");",}),]),}),"delete_flow":({({"void",}),({({"string",}),"dir",}),(["main":({"This function removes a water current through a particular exit.",}),"see":({"add_flow","query_flow","query_flows",}),"param":({"dir the exit for which any water current should be removed",}),]),}),"query_default_search_description":({({"string","*",}),({}),(["main":({"This sets up different search returns for the default 'not there'search result.",}),]),}),"set_sink_in_mess":({({"void",}),({({"string",}),"mess",}),(["main":({"This function sets the message that will be displayed when an object sinksinto this room.  The string \"$down$\" will be replaced by the current downdirection for this room (as set by set_down_dir), and the usual other$-expansion for messages will occur, including the replacement of \"$F\" bythe direction from which they are arriving.  The default is \"$N sink$s$down$ from $F.\".",}),"see":({"query_sink_in_mess","set_down_dir","query_down_dir",}),"param":({"mess the new entry message for sinking objects",}),"example":({"  set_sink_in_mess(\"$N sink$s into the cavern from $F.\");",}),]),}),"query_water":({({"int",}),({}),(["main":({"This function returns 1 to indicate that this is a water room.  It fulfillsthe same purpose as the inherits efun in this case, but may be slightlyeasier to use.",}),"see":({"inherits",}),"return":({"1",}),]),}),"add_flow":({({"void",}),({({"string",}),"dir",({"int",}),"rate",}),(["main":({"This function adds a water current flowing through a particular exit, whichmay sweep objects through it or make it harder for them to swim through.The second argument is the rate of flow.  If this is positive, then waterwill be flowing from this room into the next one.  If it is positive, thenwater will be flowing from the next room into this one.  It is up to thecoder of the specific rooms to ensure that the currents in different roomsmatch one another.",}),"see":({"delete_flow","query_flow","query_flows","drift","swim_exit",}),"param":({"dir the exit through which the current is flowing","rate the strength of the current",}),"example":({"  // There is a current flowing south.  add_flow(\"north\", -80);  add_flow(\"south\", 80);",}),]),}),"query_sweep_out_mess":({({"string",}),({}),(["main":({"This function returns the message that will be displayed when an objectis swept out of this room by a current, with the $-expansion not done.",}),"see":({"set_sweep_in_mess",}),"return":({"the current exit message for objects swept by a current",}),]),}),"set_up_dir":({({"void",}),({({"string",}),"dir",}),(["main":({"This function sets the direction that is considered to be up by this room.This is used by several exit messages, and by the water effect to decidewhich way a panicking player will flee to try to reach the surface.  Forthis reason, it should be set to the name of an exit which leads towards asurface room.  Also, buoyant objects will be inclined to move in thisdirection.  The default, of course, is \"up\".",}),"see":({"query_up_dir","set_float_in_mess","set_float_out_mess","flee_drowning",}),"param":({"mess the new direction to be considered to be up",}),"example":({"  set_up_dir(\"upwest\");",}),]),}),"add_exit_mess":({({"void",}),({({"object",}),"ob",({"string",}),"mess",}),(["main":({"This function sets the next exit message from this room for a particularobject.  It is used automagically by the swim_exit function, but can be usedfor other purposes if you feel like it.",}),"see":({"get_exit_mess","add_enter_mess","get_enter_mess","swim_exit",}),"param":({"ob the object for which the next exit message should be set","mess the next exit message for the object",}),]),}),"query_water_traction_bonus":({({"int",}),({({"object",}),"thing",({"int",}),"buoyancy",}),(["main":({"This function returns the bonus that objects get to move along the bottom orto resist such movement here.  If this should be anything unusual, such asfor a very smooth bottom or one with handles, this function should be maskedto return something different.",}),"see":({"swim_exit","drift","calc_buoyancy",}),"param":({"thing the object that is moving along the bottom","buoyancy the object's relative buoyancy",}),"return":({"the traction bonus on the bottom here",}),]),}),"query_down_dir":({({"string",}),({}),(["main":({"This function returns the direction that is currently considered to be downin this room.",}),"see":({"set_down_dir",}),"return":({"the current direction considered to be down",}),]),}),"set_clarity":({({"void",}),({({"int",}),"how_clear",}),(["main":({"This function sets the clarity of the water as an integer variable between 1and 100.  The main effect of this is to reduce the light levels of the roomto simulate the obscuring effect of turbid water.  The default clarity is90.",}),"see":({"query_clarity","set_turbidity",}),"param":({"how_clear the new clarity of the water",}),]),}),"get_water":({({"object",}),({}),(["main":({"This function returns some appropriate water from the room.  Its appearancewill depend on the clarity and salinity set in the room.  The quantity ofthe water object that it returns is not fixed, and will generally be set bywhatever function called it.",}),"see":({"soak","set_clarity","set_turbidity","set_salinity",}),"return":({"some water from the room",}),]),}),"set_sink_out_mess":({({"void",}),({({"string",}),"mess",}),(["main":({"This function sets the message that will be displayed when an object sinksout of this room.  The string \"$down$\" will be replaced by the current downdirection for this room (as set by set_down_dir), and the usual other$-expansion for messages will occur.  The default is \"$N sink$s $down$.\".",}),"see":({"query_sink_out_mess","set_down_dir","query_down_dir",}),"param":({"mess the new exit message for sinking objects",}),"example":({"  set_sink_out_mess(\"$N sink$s $down$ out of the cavern.\");",}),]),}),"set_use_surface_light":({({"void",}),({({"int",}),"val",}),(["main":({"This function sets whether the room will use the light levels of thesurface to determine its own.  If the function is called with a non-zerovalue, the the current light level in the room will be overridden by a newvalue based on the light of the room found by query_above_room.  If the roomabove is an outside room, with light levels that depend on the time of day,then the light in this room will be updated every time it is queried.  Awater room will default to using this option, but it will be overridden byany calls to adjust_light (including calls to set_light).  It is possible tocall set_water_light to avoid this, but it should not be necessary.  If aseries of rooms with vertical exits between them are all set to use surfacelight, then the effect will be for the light of the room at the top of thestack to filter down through the rest, appropriately attenuated byturbidity.",}),"see":({"query_above_room","query_water_surface_light","update_water_light","set_water_light","set_turbidity","set_clarity",}),"param":({"val whether the room should use light from the surface",}),]),}),"query_underwater":({({"int",}),({}),(["main":({"This function returns 1 if this room is underwater (that is, it is not asurface room), and 0 otherwise.",}),"see":({"query_surface","set_surface",}),"return":({"whether this is an underwater room",}),]),}),"query_flow":({({"int",}),({({"string",}),"dir",}),(["main":({"This function returns the strength of the current flowing through aparticular exit, if any.  A positive value represents a current flowing fromthis room into the next one, and a negative value represents a currentflowing from the next room into this one.",}),"see":({"add_flow","delete_flow","query_flows",}),"param":({"dir the exit which should have its current returned",}),"return":({"the current through this ext",}),]),}),"query_sink_out_mess":({({"string",}),({}),(["main":({"This function returns the message that will be displayed when an objectsinks out of this room, with the usual $-expansion not done.",}),"see":({"set_sink_out_mess",}),"return":({"the current exit message for sinking objects",}),]),}),"set_nonfloat_mess":({({"void",}),({({"string",}),"mess",}),(["main":({"This function sets the position that non-living items will have when theyare neither sinking nor floating in this room.  The default is \"driftingnearby\".",}),"see":({"query_nonfloat_mess",}),"param":({"mess the new position for drifting items",}),"example":({"  set_nonfloat_mess(\"drifting amid the seaweed\");",}),]),}),"query_sink_in_mess":({({"string",}),({}),(["main":({"This function returns the message that will be displayed when an objectsinks into this room, with the usual $-expansion not done.",}),"see":({"set_sink_in_mess",}),"return":({"the current entry message for sinking objects",}),]),}),"query_salinity":({({"int",}),({}),(["main":({"This function returns the current salinity of the water, which is an integervariable between 0 and 100.",}),"see":({"set_salinity",}),"return":({"the current salinity of the water",}),]),}),"get_exit_mess":({({"string",}),({({"object",}),"ob",({"string",}),"direc",}),(["main":({"This function returns the appropriate exit message for the specified objectin the specified direction.  If a value has been set by add_exit_mess thenit is returned.  It is used automagically by the swim_exit function, but canbe overridden if you feel like it.",}),"see":({"add_exit_mess","add_enter_mess","get_enter_mess",}),"param":({"ob the object for which the exit message should be found","direc the direction in which the object is exiting",}),"return":({"the exit message for this object",}),]),}),"add_enter_mess":({({"void",}),({({"object",}),"ob",({"string",}),"mess",}),(["main":({"This function sets the next entry message from this room for a particularobject.  It is used automagically by the swim_exit function, but can be usedfor other purposes if you feel like it.",}),"see":({"get_enter_mess","add_exit_mess","get_exit_mess","swim_exit",}),"param":({"ob the object for which the next entry message should be set","mess the next entry message for the object",}),]),}),"query_origin":({({"string",}),({({"string",}),"dir",}),(["main":({"This function returns the opposite to the direction of a particular exit.This information is normally only accessible within the room handler, but itis cached here in the origins mapping by the add_exit in this file.  If novalue is found, \"elsewhere\" will be returned.  This value is used in exitmessages to correctly display where they are coming from.",}),"see":({"add_exit","room_handler",}),"param":({"dir the exit for which the opposite direction should be found",}),"return":({"the opposite of the specified direction",}),]),}),"query_nonfloat_mess":({({"string",}),({}),(["main":({"This function returns the position that non-living items will have when theyare neither sinking nor floating in this room.",}),"see":({"set_nonfloat_mess",}),"return":({"the current position for drifting items",}),]),}),"query_bottom":({({"int",}),({}),(["main":({"This function returns 1 if this is a bottom room, and 0 otherwise.",}),"see":({"set_bottom",}),"return":({"whether this is a bottom room",}),]),}),"query_turbidity":({({"int",}),({}),(["main":({"This function returns the current turbidity of the water, which is aninteger variable between 1 and 100.  It will be equal to 100 minus thecurrent clarity of the water.",}),"see":({"set_turbidity","query_clarity",}),"return":({"the current turbidity of the water",}),]),}),"set_down_dir":({({"void",}),({({"string",}),"dir",}),(["main":({"This function sets the direction that is considered to be down by this room.This is used by several exit messages.  Also, dense objects will be inclinedto move in this direction.  The default, of course, is \"down\".",}),"see":({"query_down_dir","set_sink_in_mess","set_sink_out_mess",}),"param":({"mes the new direction to be considered to be down",}),"example":({"  set_down_dir(\"downeast\");",}),]),}),"query_bottom_mess":({({"string",}),({}),(["main":({"This function returns the position that non-living items will have when theyare lying on the bottom in this room.",}),"returns":({"the current position for items lying on the bottom",}),"see":({"set_bottom_mess",}),]),}),"do_float":({({"int",}),({}),(["main":({"This function is for the float command, which will allow someone to startfloating freely rather than swimming.  It is identical to the drift command,except for the messages.",}),"see":({"init","do_drift","do_swim",}),"return":({"whether the command succeeded",}),]),}),"set_sweep_in_mess":({({"void",}),({({"string",}),"mess",}),(["main":({"This function sets the message that will be displayed when an object isswept into this room by a current.  The usual $-expansion for messageswill occur.  The default is \"$N $V$0=is,are$V$ swept in from $F by thecurrent.\".",}),"see":({"query_sweep_in_mess",}),"param":({"mess the new entry message for objects swept by a current",}),"example":({"  set_sweep_in_mess(\"$N $V$0=is,are$V$ washed in from $F by the raging \"             \"torrent.\");",}),]),}),"query_surface_room":({({"object",}),({}),(["main":({"This function returns the top room in a vertical stack of water rooms.  Ifthere is a surface water room, it is returned, else, if the top room is notwater, or there is no surface room, 0 is returned.",}),"see":({"query_above_room","query_surface",}),"return":({"the first room above this one to be on the surface",}),]),}),"query_clarity":({({"int",}),({}),(["main":({"This function returns the current clarity of the water, which is an integervariable between 1 and 100.",}),"see":({"set_clarity","query_turbidity",}),"return":({"the current clarity of the water",}),]),}),"query_float_out_mess":({({"string",}),({}),(["main":({"This function returns the message that will be displayed when an objectfloats out of this room, with the usual $-expansion not done.",}),"see":({"set_float_out_mess",}),"return":({"the current entry message for floating objects",}),]),}),"query_death_reason":({({"string",}),({}),(["main":({"With this function here, creators will be able to point and laugh whensomeone dies by drowning in a water room because they'll see the deathreason in an inform.  It will also show up in the death log.  It would be agood idea to mask this function to return a reason more specific to theplace where the drowning may occur (such as \"drowning in the Djel\"), or atleast a humorous one (such as \"failing to realise that scuba gear hasn'tbeen invented yet\") so that creators will have something to laugh at.",}),"see":({"do_death",}),"return":({"the reason for death",}),]),}),"query_above_room":({({"object",}),({}),(["main":({"This function returns the room above this one, in the direction set byset_up_dir.",}),"see":({"set_up_dir","query_surface_room",}),"return":({"the room above this one",}),]),}),"query_sweep_in_mess":({({"string",}),({}),(["main":({"This function returns the message that will be displayed when an objectis swept into this room by a current, with the $-expansion not done.",}),"see":({"set_sweep_in_mess",}),"return":({"the current entry message for objects swept by a current",}),]),}),"set_salinity":({({"void",}),({({"int",}),"how_salty",}),(["main":({"This function sets the salinity of the water as an integer variable between0 and 100.  Higher salinity will have a small positive effect on thebuoyancy of objects in the room.  The default salinity is 0.",}),"see":({"query_salinity","calc_buoyancy",}),"param":({"how_salty the new salinity of the water",}),]),}),"query_up_dir":({({"string",}),({}),(["main":({"This function returns the direction that is currently considered to be up inthis room.",}),"see":({"set_up_dir",}),"return":({"the current direction considered to be up",}),]),}),"lives_in_water":({({"int",}),({({"object",}),"ob",}),([]),}),"set_bottom_mess":({({"void",}),({({"string",}),"mess",}),(["main":({"This function sets the position that non-living items will have when theyare lying on the bottom in this room.  The default is \"lying on the bottom\".",}),"see":({"query_bottom_mess",}),"param":({"mess the new position for items lying on the bottom",}),"example":({"  set_bottom_mess(\"lying in the seaweed\");",}),]),}),"do_swim":({({"int",}),({}),(["main":({"This function is for the swim command, which will allow someone to stopdrifting freely and start swimming and resisting anything that tries to movethem.",}),"see":({"init","do_float","do_drift",}),"return":({"whether the command succeeded",}),]),}),"soak":({({"varargs","void",}),({({"object",}),"ob",({"int",}),"ignore_location",}),(["main":({"This function makes things wet.  Anything entering a water room has thisfunction called on it by event_enter, and will have the wetness effect addedto it if appropriate, as well as to any appropriate objects inside it if itisn't waterproof.  Open containers will also be filled with water.  Thefunction checks to see that the object is indeed inside the room, unless theoptional extra argument is non-zero.",}),"see":({"get_water",}),"param":({"ob the object to be soaked","ignore_location whether the object should be soaked wherever it is",}),]),}),"query_below_room":({({"object",}),({}),(["main":({"This function returns the room below this one, in the direction set byset_down_dir.",}),"see":({"set_down_dir","query_bottom_room",}),"return":({"the room below this one",}),]),}),"query_turbulence":({({"int",}),({}),(["main":({"This function returns the current turbulence of the water, which is anon-negative integer.",}),"see":({"set_turbulence",}),"return":({"the current turbulence of the water",}),]),}),"set_sweep_out_mess":({({"void",}),({({"string",}),"mess",}),(["main":({"This function sets the message that will be displayed when an object isswept out of this room by a current.  The usual $-expansion for messageswill occur, including the replacement of \"$T\" by the direction in which theyare moving.  The default is \"$N $V$0=is,are$V$ swept $T by the current.\".",}),"see":({"query_sweep_out_mess",}),"param":({"mess the new exit message for objects swept by a current",}),"example":({"  set_sweep_out_mess(\"$N $V$0=is,are$V$ washed away $T by the raging \"             \"torrent.\");",}),]),}),"set_sinking_mess":({({"void",}),({({"string",}),"mess",}),(["main":({"This function sets the position that non-living items will have when theyare sinking in this room.  The default is \"sinking nearby\".",}),"see":({"query_sinking_mess",}),"param":({"mess the new position for sinking items",}),"example":({"  set_sinking_mess(\"sinking into the seaweed\");",}),]),}),"query_flows":({({"mapping",}),({}),(["main":({"This function returns a mapping of all the current flows through exits inthis room.  The keys of the mapping are the exits through which the currentsflow, and the values are the rates of flow.",}),"see":({"add_flow","delete_flow","query_flow",}),"return":({"a mapping of the current flows through exits in this room",}),]),}),"set_turbulence":({({"void",}),({({"int",}),"how_turbulent",}),(["main":({"This function sets the turbulence of the water as a non-negative integervariable.  A random number up to the turbulence is added to the difficultyof all skillchecks to leave the room via a water exit with swim_exit as theexit function, except when the exiting object is not moving of its ownaccord (such as when it is being swept along by a current).  The defaultturbulence is 100.",}),"see":({"query_turbulence","swim_exit",}),"param":({"how_turbulent the new turbulence of the water",}),]),}),"set_surface":({({"void",}),({({"int",}),"val",}),(["main":({"This function sets whether or not this room has an interface with air orsurface in it.  If it does, then living objects may breathe here, andturbidity does not effect visibility.  The parameter of this function can be1 to make this room have a surface, 0 to make it have no surface, or -1 (thedefault) to make it decide whether or not it has a surface by checking tosee if it has any exits in the current up direction (as set by set_up_dir).",}),"see":({"query_surface","set_clarity","set_turbidity","set_up_dir",}),"param":({"val whether or not the room has a surface",}),]),}),"get_swim_enum":({({"int",}),({({"object",}),"thing",}),(["main":({"This function returns the effect number of the swimming/immersion effect onthe object specified.  If there isn't one, it adds the effect.",}),"see":({"effects_matching","query_classification",}),"param":({"thing the object for which the swimming effect number should be found",}),"return":({"the swimming effect number",}),]),}),"query_bottom_room":({({"object",}),({}),(["main":({"This function returns the bottom room in a vertical stack of water rooms.If there is a bottom water room, it is returned, else, if the bottom room isnot water, or there is no bottom room, 0 is returned.",}),"see":({"query_below_room","query_bottom",}),"return":({"the first room below this one to be on the bottom",}),]),}),"do_drift":({({"int",}),({}),(["main":({"This function is for the drift command, which will allow someone to startdrifting freely rather than swimming.  It is identical to the float command,except for the messages.",}),"see":({"init","do_float","do_swim",}),"return":({"whether the command succeeded",}),]),}),"query_terrain_map_colour":({({"string",}),({}),([]),}),"set_float_in_mess":({({"void",}),({({"string",}),"mess",}),(["main":({"This function sets the message that will be displayed when an object floatsinto this room.  The string \"$up$\" will be replaced by the current updirection for this room (as set by set_up_dir), and the usual other$-expansion for messages will occur, including the replacement of \"$F\" bythe direction from which they are arriving.  The default is \"$N float$s $up$from $F.\".",}),"see":({"query_float_in_mess","set_up_dir","query_up_dir",}),"param":({"mess the new entry message for floating objects",}),"example":({"  set_float_in_mess(\"$N float$s into the cavern from $F.\");",}),]),}),"get_water_surface_light":({({"int",}),({}),(["main":({"This function returns the amount of light that will filter down to thisroom from those above it if set_use_surface_light has been called.  It isintended to be used only by the update_water_light function, but has beenseparated out to allow it to be masked.",}),"see":({"update_water_light","query_above_room","query_water_surface_light",}),"return":({"the amount of light that filters down from rooms above this one",}),]),}),"query_float_mess":({({"string",}),({}),(["main":({"This function returns the position that non-living items will have when theyare floating in this room.",}),"see":({"set_float_mess",}),"return":({"the current position for floating items",}),]),}),"query_float_in_mess":({({"string",}),({}),(["main":({"This function returns the message that will be displayed when an objectfloats into this room, with the usual $-expansion not done.",}),"see":({"set_float_in_mess",}),"return":({"the current entry message for floating objects",}),]),}),"set_float_mess":({({"void",}),({({"string",}),"mess",}),(["main":({"This function sets the position that non-living items will have when theyare floating in this room.  The default is \"floating nearby\".",}),"see":({"query_float_mess",}),"param":({"mess the new position for floating items",}),"example":({"  set_float_mess(\"floating above the seaweed\");",}),]),}),])
protected_functions ([])
inherits ([])
main_docs (["main":({"This is the co-inheritable for rooms containing water.  It handles addingthe appropriate effects to objects entering the water, skillchecks to seeif they can move around, making their positions appropriate and things likethat.  It also takes care of some miscellaneous stuff like salinity,turbidity, currents etc.  Rather than using this co-inheritable directly, itis recommended that you inherit either /std/room/water_inside.c or/std/room/water_outside.c.When using this file, remember the following: if you mask event_enter youshould call the inherited function, and unforeseen consequences may resultfrom using modify_exit with the \"function\", \"exit mess\" or \"enter mess\"options.  Using \"exit mess\" or \"enter mess\" will only disrupt the tailoredswimming/drifting/floating/sinking exit and entry messages, but changing theexit function will allow people through exits without passing theappropriate swimming skillcheck.  For this reason, it is recommended to maskswim_exit instead, and check that the inherited function returns 1 beforeallowing them to pass.",}),"author":({"Bakhtosh",}),"see":({"/std/room/water_inside","/std/room/water_outside","/std/effects/other/immersed",}),])
define_docs (["LIVES_IN_WATER_PROP":([]),"GILLS_PROP":([]),"ANCHOR_PROP":([]),"SWIMMING_SKILL":([]),"SWIM_EFFECT":([]),"LIVING_WET_EFFECT":([]),"FLOATING_PROP":([]),"OBJECT_WET_EFFECT":([]),])
includes (["/include/tasks.h":1522061544,"/include/position.h":1522061544,"/include/armoury.h":1522061544,"/include/room.h":1522061544,])
class_docs ([])
file_name "/std/room/basic/water.c"
last_changed 1522061544
