#/obj/handlers/autodoc/autodoc_file.c
public_functions (["make_payment":({({"varargs","mixed","*",}),({({"string",}),"type",({"int",}),"value",({"object",}),"thing",({"string",}),"where",}),(["main":({"This method makes a payment of a particular amount in a particularmoney area.   Please note that player or living objects can doubleas money objects in this circumstance.  The first element of thepayment array is the values which should be used to take offthe player, the second element is the change needed to be payedback.",}),"see":({"pay_amount_from()","calc_change()",}),"param":({"type the type of money to pay in (ie: \"Lancre Crown\")","value the number of the type to pay","thing the thing which is doing the payment (money object)","where the money area the payment will occur in",}),"return":({"the payment array",}),]),}),"add_type":({({"void",}),({({"string",}),"where",({"string",}),"type",({"int",}),"value",}),(["main":({"This adds a type of money to the money handler.",}),"see":({"query_values_in()","remove_type()",}),"param":({"where the area in which to add the type of money","type the name of the money to add","value the value of the money",}),]),}),"query_person_payments":({({"mixed","*",}),({({"int",}),"value",({"string",}),"place",({"object",}),"payer",({"object",}),"payee",}),(["main":({"This method makes a payment from one person to another.This method figures out what money should be given to the playerand what should be taken from the other to make a payment of thecorrect value in the correct place.",}),"param":({"value the value to pay","place the place to make the payment in","payer the person the money is payed from","payee the person the money is payed to",}),"return":({"two element array, or 0 if it cannot be done",}),]),}),"remove_symbol":({({"void",}),({({"string",}),"word",}),(["main":({"This method removes the symboliser for the particular money area.",}),"param":({"word the money area to remove the symbol for",}),"see":({"query_symbols()","query_symbol_for()","add_symbol()",}),]),}),"query_symbols":({({"mapping",}),({}),(["main":({"This method returns all the symbols for the current money areas in thehandler.   The return value is mapping with the key being themoney area and the value being the symboliser for the money.The symboliser is called with a value to get the money toprint itself out nicely.   This is used when the quantity ofactual coins is not known and only the value of them isknown.",}),"see":({"query_symbol_for()","add_symbol()","remove_symbol()",}),"return":({"all of the symbols",}),]),}),"query_value":({({"varargs","int",}),({({"string",}),"type",({"string",}),"where",}),(["main":({"This method returns the value of a specified type of money in a certainmoney area.",}),"see":({"query_total_value()",}),"param":({"type the type of money to get the value for","where the money area the money is in",}),"return":({"the integer value of the money",}),]),}),"value_from_string":({({"int",}),({({"string",}),"str",({"string",}),"where",}),(["main":({"This method attempts to find a money value from a string.  It willattempt to do fuzzy matching of the type.  This means it will match onpartial matches, this could lead to somewhat weird behaviour...  So itgoes...",}),"see":({"money_value_string()",}),"param":({"str the string to find the value of",}),"example":({"// This will tell us the integer money value of the string.write(MONEY_HAND->value_from_string(\"1 dollar and 12 pence\",                                    \"Ankh-Morpork\"));",}),]),}),"query_details_for":({({"mixed","*",}),({({"string",}),"word",}),(["main":({"This method returns the details for a specified type of money.It will return an array of the form:<pre>({ \"heads\", \"tails\", \"a head\", \"a tail\", \"brass\", 0 })</pre>The places correspond to:<pre>({ forward short, reverse short,     forward long, reverse long, composition, plural })</pre>",}),"see":({"add_details()",}),"param":({"word the money type to get the type for",}),]),}),"query_adjectives_for":({({"string","*",}),({({"string",}),"type",}),(["main":({"This method returns all the current adjectives for the given typeof money.",}),"see":({"set_adjectives_for()",}),"param":({"type the type of money to get the aliases for",}),"return":({"the adjectives for the money type",}),]),}),"query_total_value":({({"varargs","int",}),({({"mixed",}),"mon_array",({"string",}),"where",}),(["main":({"This method determines the total value of a specified money array.A money array consists of pairs of values ({ type, number })",}),"see":({"query_value()",}),"param":({"mon_array the array to find the value of","where the money area to get the value in",}),"return":({"the total value as an integer",}),]),}),"merge_money_arrays":({({"mixed","*",}),({({"mixed","*",}),"m_array1",({"mixed","*",}),"m_array2",}),(["main":({"This method merges two money arrays together and returns themerged array",}),"param":({"m_array1 the first money array","m_array2 the second money_array",}),"return":({"a money array of m_array1 and m_array2 joined",}),]),}),"smallest_value_in":({({"int",}),({({"string",}),"place",}),(["main":({"This returns the smallest value of currency in this place.",}),"see":({"smallest_in()",}),"param":({"place The place to query.",}),"return":({"the value of the smallest unit of currency",}),]),}),"smallest_in":({({"string",}),({({"string",}),"place",}),(["main":({"This returns the smallest unit of currency in this place.",}),"see":({"smallest_value_in()",}),"param":({"place The place to query.",}),"return":({"A string of the smallest unit of currency",}),]),}),"filter_legal_tender":({({"varargs","object","*",}),({({"object",}),"money",({"string",}),"where",}),(["main":({"This method figures out the legal and illegal tender money fromthe specified money object in the specified money area.   This methodreturns a two element array which consists of the legal and illegaltender for the given money area.   ({ legal, illegal }).  WARNING:This method destructs the money object passed to it.",}),"see":({"parse_money()",}),"param":({"money the money object to get the legal tender from","where the money area the tender is for",}),"return":({"an two element array of objects ({ legal, illegal })",}),]),}),"set_adjectives_for":({({"void",}),({({"string",}),"type",({"string","*",}),"words",}),(["main":({"This method sets the adjectives for the specified money type.",}),"see":({"query_adjectives_for()",}),"param":({"type the type of money to set the adjectives for","words the adjectives for the money","type the type of money to set the adjectives for","words the adjectives for the money",}),]),}),"query_plural_for":({({"string",}),({({"string",}),"type",}),(["main":({"This method returns the short plural description of the money type.This returns just the one word, like 'coins' or 'talons'.",}),"see":({"set_plural_for()","query_main_plural_for()",}),"param":({"type the money type to get the short plural description for",}),"return":({"the short plural description for the money object",}),]),}),"parse_money":({({"varargs","mixed",}),({({"string",}),"words",({"object",}),"player",({"string",}),"place",}),(["main":({"This method determines all the money from the player object and movesit into a container.  It then figured out the legal tender forspecified money area and tells the player if the given money islegal tender for the current area.  It will automatically return theillegal tender and send a message to the player about it.",}),"see":({"filter_legal_tender()",}),"param":({"words the string to match the money on","player the player who is attempting the transaction","place the money area the transaction is taking place",}),"return":({"a money object consisting of the legal tender",}),]),}),"make_new_amount":({({"varargs","object",}),({({"int",}),"value",({"string",}),"where",}),(["main":({"This method creates a money object of a certain value in a certainmoney area.",}),"param":({"value the value to create the new money object with","where the area to create the new money object in",}),"return":({"the new money object",}),]),}),"query_valid_types":({({"string","*",}),({}),(["main":({"This returns a list of valid coin types",}),"return":({"an array of valid coin types",}),]),}),"query_values":({({"mixed","*",}),({}),(["main":({"This method returns the values in the default area.This method returns the array as given in the value above.It contains name, value pairs and is for the \"default\"area.",}),"see":({"query_all_values()","query_values_in()",}),"return":({"the array of values",}),]),}),"set_plural_for":({({"void",}),({({"string",}),"type",({"string",}),"plural",}),(["main":({"This method sets the plural for the specified money type.",}),"see":({"query_plural_for()","query_main_plural_for()",}),"param":({"type the money to set the plural for","plural the new plural for the money",}),]),}),"save_me":({({"void",}),({}),(["main":({"This method saves the current state of the money object.",}),]),}),"query_smallest_value_in":({({"int",}),({({"string",}),"where",}),(["main":({"This returns the smallest value in the specified area.  Used tomake sure we are not charging too little or too much when doingcomparisons.",}),"param":({"where the area to check",}),"return":({"the smallest value in the specified area",}),]),}),"filter_legal_money_array":({({"varargs","object","*",}),({({"mixed","*",}),"m_array",({"string",}),"where",}),(["main":({"This method is identical to filter_legal_tender, except that it takesa money array rather than a money object",}),"see":({"parse_money()","filter_legal_tender()",}),"param":({"m_array the money array to get the legal tender from","where the money area the tender is for",}),"return":({"an two element array of objects ({ legal, illegal })",}),]),}),"remove_type":({({"void",}),({({"string",}),"where",({"string",}),"type",}),(["main":({"This method removes the type of money from the handler.",}),"see":({"add_type()",}),"param":({"where the area to remove it from","type the type to remove",}),]),}),"query_details":({({"mapping",}),({}),(["main":({"This method returns all the details for the current set ofcoins.   The details are information which is shown when the coinis looked at.   Stuff about heads and tails and things.<pre>  ([     \"brass\": ({ \"heads\", \"tails\", \"a head\", \"a tail\", \"brass\", 0 }),     \"copper\": ({ \"heads\", \"tails\", \"a head\", \"a tail\", \"copper\", 0 }),     \"silver\": ({ \"heads\", \"tails\", \"a head\", \"a tail\", \"silver\", 0 }),     \"gold\": ({ \"heads\", \"tails\", \"a head\", \"a tail\", \"gold\", 0 }),     \"platinum\": ({ \"heads\", \"tails\", \"a head\", \"a tail\", \"platinum\", 0 }) ])</pre>The places correspond to:<pre>({ forward short, reverse short,     forward long, reverse long, composition, plural })</pre>",}),"return":({"the details array",}),]),}),"remove_details":({({"void",}),({({"string",}),"word",}),(["main":({"This method removes the specified detail. ",}),"see":({"add_detail()","query_details_for()",}),"param":({"word the type of money to remove the details for",}),]),}),"add_details":({({"void",}),({({"string",}),"word",({"string",}),"hd_sht",({"string",}),"tl_sht",({"string",}),"hd_lng",({"string",}),"tl_lng",({"mixed",}),"composition",({"string",}),"plural",}),(["main":({"This method adds the details for the given coin type into the currentlist.",}),"see":({"query_details_for()","remove_details()",}),"param":({"word the coin type the details are for","hd_sht the heads side short","tl_sht the tail side short","hd_lng the head side long","tl_lnd the tail side long","composition the composition of the money","plural the plural value of the object, if 0 then use default plural",}),]),}),"money_string":({({"string",}),({({"mixed",}),"mon_array",}),(["main":({"This method converts a money array into a string so it can be displayed.",}),"see":({"money_value_string()",}),"param":({"mon_array the money array to convert into a string",}),]),}),"add_symbol":({({"void",}),({({"string",}),"word",({"string",}),"symboliser",}),(["main":({"This method adds in a symboliser for a specified money area.",}),"see":({"query_symbols()","query_symbol_for()","remove_symbol()",}),"param":({"word the money area to add the symbol for","symboliser the path to the symboliser object",}),"example":({"add_symbol(\"Ankh-Morpork\", \"/d/am/money\");","// This is an example of a symboliser objectstring symbolise_value( int value ) {   int dollars, pence;   dollars = value / 400;   pence = ( value % 400 ) / 4;   if ( !pence ) {      return \"A$\"+ dollars;   }   if ( !dollars ) {      return pence +\"p\";   }   if ( pence < 10 ) {      return \"A$\"+ dollars +\".0\"+ pence;   }   return \"A$\"+ dollars +\".\"+ pence;} /* symbolise_value() */",}),]),}),"create_money_array":({({"varargs","mixed","*",}),({({"int",}),"value",({"string",}),"where",}),(["main":({"This method creates a money array from a certain value in a particularmoney area. A money array consists of ({ type, number }) pairs in anarray.   ie: ({ \"brass\", 12, \"copper\", 24 }).",}),"see":({"money_value_string()",}),"param":({"value the value to get the money array for","where the money area to get the value in",}),"return":({"a money array for the value in the area",}),"example":({"place = query_property(\"place\");if (!place) {     place = \"default\";}mon_array = create_money_array( 1000, place);",}),]),}),"query_aliases_for":({({"string","*",}),({({"string",}),"type",}),(["main":({"This method returns all the current aliases for the given typeof money.",}),"see":({"set_aliases_for()",}),"param":({"type the type of money to get the aliases for",}),"return":({"the aliases for the money type",}),]),}),"query_main_plural_for":({({"string",}),({({"string",}),"type",}),(["main":({"This method returns the main short plural description of the money type.This returns the expanded plural version like 'Ankh-Morpork pennies'.",}),"see":({"set_plural_for()","query_plural_for()","query_short_for()",}),"param":({"type the money type to get the short plural description for",}),"return":({"the short plural description for the money object",}),]),}),"query_value_of":({({"int",}),({({"string",}),"type",}),(["main":({"This returns the value of a currency type.",}),"param":({"type currency type",}),"return":({"an int of the currency type's value",}),]),}),"money_value_string":({({"varargs","string",}),({({"int",}),"value",({"string",}),"where",}),(["main":({"This method returns a string which is based on the value ofthe money in a certain money area.",}),"see":({"create_money_array()","money_string()","value_from_string()",}),"param":({"value the value to get the string for","where the place to get the string for",}),"return":({"a string of the money value in the certain money area",}),]),}),"query_all_values":({({"mapping",}),({}),(["main":({"This method returns the mapping containing all the values of thecurrently valid money types.   The mapping has keys of the domainof the money and has a value of an array.   The array containsalternating name, value pairs.<pre>([ \"default\": ({ \"brass\", 1, \"copper\", 10, \"silver\", 100,                                            \"gold\", 2000, \"platinum\", 6000 }) ])</pre>",}),"see":({"query_values()","query_values_in()",}),"return":({"the mapping of values",}),]),}),"make_money_array_payment":({({"mixed","*",}),({({"string",}),"type",({"int",}),"value",({"mixed","*",}),"mon_array",({"string",}),"where",({"int",}),"use_default",}),(["main":({"This method makes a payment from a money array.  It returns thedepleted money array, the amount taken out and the changeneeded.  If the type is not set, then the best fit for the valueis found from the array.<p>The return array is formated as:<br>({ depleted_money_array, change, taken_from })<br>The change is an integer value.",}),"param":({"type the type of money to take out (ie: \"Lancre Crown\")","value the amount of the type to take out","mon_array the money array to use","where the money area","use_default allow the use of the default money type",}),"return":({"the return array as formated above",}),"example":({"ret = make_money_array_payment(\"Lancre Crown\", 2, mon_array, \"Lancre\", 0);",}),]),}),"query_all_places":({({"string","*",}),({}),(["main":({"This method returns the current set of areas in which types canbe found.",}),"return":({"the set of places",}),]),}),"pay_amount_from":({({"varargs","object",}),({({"int",}),"value",({"object",}),"money",({"string",}),"where",}),(["main":({"This method makes a payment from a specified money object.",}),"see":({"make_payment()","calc_change()",}),"param":({"value the amount to pay","money the money object to pay from","where the money area the payment occurs in",}),"return":({"the change object",}),]),}),"calc_change":({({"mixed","*",}),({({"int",}),"value",({"mixed","*",}),"mon_array",}),(["main":({"This method calculates the change of a certain value from agiven money array.   This makes sure that the change does not includemoney that does not actually exist.",}),"see":({"make_payment()","pay_amount_from()",}),"param":({"value the value of the change to calculate","mon_array the money array to determine the change from",}),"return":({"the money array containing the change to use",}),]),}),"query_aliases_of":({({"string","*",}),({({"string",}),"word",}),(["main":({"This converts a currency type's alias (i.e. \"royal\" ) and returnsits 'real' names (i.e. \"Ankh-Morpork royal\"",}),"param":({"word the alias to find the real name of",}),"return":({"an array of real names, or 0 if it's not a real alias",}),]),}),"money_array_from_string":({({"mixed","*",}),({({"string",}),"str",({"string",}),"where",}),(["main":({"This method attempts to find a money value from a string.  It willattempt to do fuzzy matching of the type.  This means it will match onpartial matches, this could lead to somewhat weird behaviour...  So itgoes...  It will return a money array, rather than a value",}),"see":({"money_value_string()",}),"param":({"str the string to find the value of",}),"return":({"a money array of the types matched",}),]),}),"query_short_for":({({"string",}),({({"string",}),"type",}),(["main":({"This method returns the short description of the money type.",}),"see":({"query_main_plural_for()",}),"param":({"type the money type to get the short description for",}),"return":({"the short description for the money object",}),]),}),"set_aliases_for":({({"void",}),({({"string",}),"type",({"string","*",}),"words",}),(["main":({"This method sets the aliases for the specified money type.",}),"see":({"query_aliases_for()",}),"param":({"type the type of money to set the aliases for","words the aliases for the money","type the type of money to set the aliases for","words the aliases for the money",}),]),}),"query_values_in":({({"mixed","*",}),({({"string",}),"where",}),(["main":({"This method returns the values in the specified area.It contains name, value pairs and is for the \"default\"area.",}),"see":({"query_all_values()","query_values()","add_type()","query_mapped_values_in()",}),"param":({"where the area in which to return the values for",}),"return":({"the array of values",}),]),}),"query_mapped_values_in":({({"mapping",}),({({"string",}),"where",}),(["main":({"This method returns the values in the specified area.It contains name, value pairs and is for the \"default\"area.  It is returned as a mapping for easier sorting& manipulation.",}),"see":({"query_all_values()","query_values()","add_type()","query_values_in()",}),"param":({"where the area in which to return the values for",}),]),}),"query_origin_of":({({"string",}),({({"string",}),"type",}),(["main":({"This takes a coin type and returns the place it is associated with.",}),"param":({"type the coin type i.e. \"Ankh-Morpork dollar\"",}),"return":({"the place i.e. \"Ankh-Morpork\"",}),]),}),"query_symbol_for":({({"string",}),({({"string",}),"word",}),(["main":({"This method returns the symboliser for the specified money area.",}),"see":({"query_symbols()","add_symbol()","remove_symbol()",}),"param":({"word the area in which the money is occuring",}),"return":({"the syboliser for the money area",}),]),}),])
protected_functions ([])
inherits ([])
main_docs (["main":({"This handles all the methods for determining values of coins andthe current valid set of coins.   It also handles change calculation.This was written originaly by Pinkfish, reworked significantly byDeutha to add in the multiple currency areas.",}),"author":({"Pinkfish",}),"see":({"/std/living/money.c",}),])
define_docs (["SAVE_FILE":([]),"DEF_VALUE":([]),])
includes (["/include/shops/bank.h":1522061544,"/include/money.h":1522061544,])
class_docs ([])
file_name "/obj/handlers/nmoney_handler.c"
last_changed 1522061544
