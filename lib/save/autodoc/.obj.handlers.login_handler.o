#/obj/handlers/autodoc/autodoc_file.c
public_functions (["query_login_queue":({({"object","*",}),({}),(["main":({"This method returns the current list of people in the loginqueue.",}),"return":({"the objects in the login queue",}),]),}),"query_lockdowns":({({"void",}),({}),([]),}),"query_players_on":({({"string","*",}),({}),(["main":({"This method returns a list of the current players who areonline.",}),"return":({"the string names of the online players",}),]),}),"tidy_players_on":({({"int",}),({({"string",}),"player",}),([]),}),"remove_static_login_call":({({"int",}),({({"string",}),"player",({"mixed",}),"funct",({"mixed",}),"obj",}),(["main":({"This method removes a login call.",}),"see":({"add_static_login_call()","add_dynamic_login_call()",}),"param":({"player the player specifier","funct the funct name","obj the object to call the funct on",}),"return":({"0 on failure and 1 on success",}),]),}),"query_worst":({({"string",}),({}),(["main":({"This returns the player name with the worst alignment.",}),"return":({"player name with the worst alignment",}),]),}),"failed_login":({({"void",}),({({"string",}),"ip_addr",}),([]),}),"get_message":({({"string",}),({({"string",}),"mess_name",}),(["main":({"This function is used to cache the login messages used by /secure/loginit costs a bit in memory but saves us having to re-read the same textfile everytime someone logs in.For security reasons this function will only work with files in /doc",}),"param":({"the filename of the file to be returned",}),"return":({"the text of the file.",}),]),}),"update_players_on":({({"void",}),({({"string",}),"player",}),([]),}),"is_discworld_full":({({"int",}),({({"int",}),"logins",}),(["main":({"Try and figure out if the mud is full or not.  Counts the numberof players and returns a true or false value.",}),"param":({"logins a flag",}),"see":({"/include/login.h#WITHOUT_LOGINS_NOT_IN_QUEUE","/include/login.h#WITHOUT_LOGIN_QUEUE","/include/login.h#WITHOUT_ANY_LOGINS",}),"return":({"1 if the mud is full, 0 if it is not",}),]),}),"query_best":({({"string",}),({}),(["main":({"This returns the player name with the best alignment.",}),"return":({"player name with the best alignment",}),]),}),"int_is_discworld_full":({({"int",}),({({"int",}),"logins",}),([]),}),"clear_messages":({({"void",}),({}),([]),}),"is_compressed_full":({({"int",}),({({"int",}),"logins",}),([]),}),"remove_from_login_queue":({({"void",}),({({"object",}),"ob",}),(["main":({"This method removes an object from the login queue, if they log outor something.",}),"param":({"ob the object to remove from the queue",}),]),}),"write_log":({({"void",}),({({"string",}),"event",({"string",}),"name",({"int",}),"guest",({"string",}),"other",}),(["main":({"This method is used to do delayed logging to the log files.  It willstore a bunch of entries until it is over a maximum size and thensave this to the log.",}),"param":({"event the event generated","name the name of the player the event is for","guest if the person in question is a guest","other other information about the event",}),]),}),"add_dynamic_login_call":({({"int",}),({({"string",}),"player",({"mixed",}),"funct",({"mixed",}),"obj",}),(["main":({"This method adds a funct to be called whenever a player logsin.  The funct and object are stored only for this rebootso they may be object references or funct pointers.",}),"see":({"remove_dynamic_login_call()","add_static_login_call()",}),"param":({"player specfic player to look for \"all\" for everyone","func the funct to call","obj the object to call the funct on",}),"return":({"0 on failure and 1 on success",}),]),}),"pop_from_login_queue":({({"object",}),({}),(["main":({"This method returns the top element of the login queue and removesthem from it.",}),"return":({"the top element of the login queue, 0 if none",}),]),}),"remove_dynamic_login_call":({({"int",}),({({"string",}),"player",({"mixed",}),"funct",({"mixed",}),"obj",}),(["main":({"This method removes a login call.",}),"see":({"add_dynamic_login_call()","add_static_login_call()",}),"param":({"player the player specifier","funct the funct name","obj the object to call the funct on",}),"return":({"0 on failure and 1 on success",}),]),}),"clear_lockdowns":({({"void",}),({({"string",}),"ip",}),([]),}),"can_jump_queue":({({"int",}),({({"object",}),"ob",}),([]),}),"add_static_login_call":({({"int",}),({({"string",}),"player",({"mixed",}),"funct",({"mixed",}),"obj",}),(["main":({"This method adds a funct to be called whenever a player logsin.  The funct and object both need to be strings so thatthey are saved correctly.  This will be saved to the save fileand restored over logins.<p>The function will be called with two parameters, the first is thename of the player and the second is the type of the event.  Theevent types are defined in /include/login.h  The event will be oneof RECONNECT, LOGIN, LOGOUT, NETDEATH.",}),"see":({"remove_static_login_call()","add_dynamic_login_call()",}),"param":({"player specfic player to look for \"all\" for everyone","func the funct to call","obj the object to call the funct on",}),"return":({"0 on failure and 1 on success",}),]),}),"add_to_login_queue":({({"void",}),({({"object",}),"login_ob",}),(["main":({"This method adds an object to the login queue.  This is called frominside /secure/login.c",}),"param":({"login_ob the object to add to the queue",}),"see":({"/secure/login.c",}),]),}),"clean_lockdowns":({({"void",}),({}),([]),}),"site_lockeddown":({({"int",}),({({"string",}),"ip_addr",}),([]),}),"is_uncompressed_full":({({"int",}),({({"int",}),"logins",}),([]),}),])
protected_functions ([])
inherits ([])
main_docs (["main":({"The login handler lets you have a funct called as a player logs in or out.The funct you setup will be called when the player logs in or out.  Theobject will also give you a list of all the people who are logged in. This isa by product of its method of operation rather than anything important. It is quite possibly more useful to call users().<p>The funct which is to be called only needs to be called once asthe objects state is saved.  When a player enters, logsout or goesnet dead the funct will be called on the specified object.  Thefunct will have two parameters, the first will be the playername logging in/out and the last will be a define from /include/login.hspecifying which sort of event has occured.<p>A new temporary method of adding a call back to the login_handler has beenadded.  This will allow you to add a call that is not saved,so you can use an object reference instead of a file name.",}),"author":({"Furball",}),"see":({"/secure/login","efun::users()","/include/login.h",}),])
define_docs (["MAX_UNCOMPRESSED_PLAYERS":([]),"is_compressed_login(x)":([]),"SAVE_TIME":([]),"MAX_FAILURES":([]),"LOCKDOWN_TIME":([]),"COMPRESSED_INTAKE_COUNT":([]),"SAVE_NAME":([]),"NEW_SAVE_TIME":([]),"MAX_PLAYERS":([]),"LOGIN_MAX_COMPRESSED_PLAYERS":([]),"BUFFER_TIME":([]),])
includes (["/include/player_handler.h":1522061544,"/include/login_handler.h":1522061544,"/include/login.h":1522061544,])
class_docs (["login_information":({0,({({"ob",({"mixed",}),}),({"funct",({"string",}),}),}),([]),}),])
file_name "/obj/handlers/login_handler.c"
last_changed 1522061544
