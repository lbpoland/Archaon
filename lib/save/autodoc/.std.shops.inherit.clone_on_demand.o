#/obj/handlers/autodoc/autodoc_file.c
public_functions (["query_object_domain":({({"string",}),({}),(["main":({"This method returns the domain the objects will be created from.",}),"return":({"the domain the objects are created from",}),]),}),"set_object_domain":({({"void",}),({({"string",}),"domain",}),(["main":({"This method sets the domain the objects will be created from.The default objects will always be matched as well.  So settingthis will allow objects from the default of the specified armourydomain.",}),"param":({"domain the domain to try and create from",}),"example":({"set_object_domain(\"cwc\");",}),]),}),"query_number_left":({({"int",}),({({"string",}),"name",}),(["main":({"This function returns the quantity of particular object availableto be cloned on demand. In matching which object is the one inquestion it uses the short name of the object, which is passed asan argument to the function.",}),"param":({"name is the short name of the object you wish to query.",}),"return":({"the number left, returns INFINITE_LEFT if the shop has an infinitenumber, returns -1 if the item isn't stocked.",}),]),}),"query_num_items_left":({({"int",}),({({"object",}),"ob",}),(["main":({"Returns how more times object ob can be duplicated",}),"param":({"ob the object to test",}),"return":({"how many more times",}),]),}),"add_object":({({"varargs","int",}),({({"string",}),"name",({"int",}),"max_per_reset",({"string",}),"display_as",}),(["main":({"This method is used to add an item to the storage.When this method is called, create_object() is called(with the object name as an arg) in the inheriting file.If no object is returned by that function,the name is cloned with clone_object(), and failing thatrequest_item() is called in the armoury against the name.This method makes add_weapon() and add_armour() obsolete.",}),"param":({"name the name of the object to add.","max_per_reset the maximum number of items to be available at any one time","display_as the name that this item is displayed as in shops",}),"return":({"1 if the item was added successfully to the store, 0 if it was not.",}),"example":({"add_object( \"frog\", 1 + random( 3 ) );// This will try and create an object called frog, in the order mentioned// above","add_object( \"/obj/food/apple.food\", 0 );// Add unlimited numbers of apples.",}),]),}),"query_items_left":({({"int","*",}),({({"string","*",}),"names",}),(["main":({"This function can be used to check the quantity left of an arrayof items.  It returns a parallel array of integers.  In other wordsthe array it returns contains the numbers of stock in array positionscorresponding to the array positions of the objects it was passed.",}),"see":({"query_number_left",}),"param":({"names an array of the short names of the items you wish to query",}),"return":({"an array of integers, each one returning like query_number_leftwould for the object in that position of the object array.",}),"example":({"query_items_left( ({ \"banana\" , \"melon\" }) )would return ({ 12 , 6 }) if there were 12 bananas and 6 melons left.",}),]),}),"query_cont":({({"object",}),({}),(["main":({"This method returns the container which is used to keep one copy ofeach items in storage.",}),"return":({"the object container",}),]),}),])
protected_functions (["create_real_object":({({"object",}),({({"object",}),"thing",}),(["main":({"The main point of entry. 'thing' should be an object already placedin the clone_on_demand store container via 'add_object'. Thismethod then duplicates that object, replaces the original copy inthe container with this new one, and returns the original which canbe delt with as normal.",}),"see":({"add_object",}),"param":({"thing an object in the store",}),"return":({"the original object",}),]),}),])
inherits ([])
main_docs (["main":({"This is a inheritable that provides an efficient way of storinglots of items. Only one copy of the item is effectively in storageand everytime one is removed, an exact copy is duplicated andput back in the store. Objects are added to the store viaadd_object(). The actual storage container objectcan be returned by query_cont() and this container should besearched when you want to find what objects the store contains.<p>Any object can inherit this, and methodsshould be put in place in the inheriting file that end up callingcreate_real_object() which will sort out duplicating the itemand returning an object pointer to the one you can deal with.",}),"author":({"Pinkfish Aquilo",}),"see":({"add_object",}),"example":({"inherit \"clone_on_demand\";int do_buy( objects *obs );void setup(){  set_name(\"shop\");  set_short(\"widget shop\");  add_object( \"sprocket\" );}object create_object( string arg ){  if( arg == \"sprocket\" )    return clone_object( \"/path/of/sprocket\" );}void init(){  add_command(\"buy\", \"<indirect:object:\" +                     base_name( query_cont() ) + \">\");}int do_buy( object *obs ){  object ob;  foreach(ob in obs){    widget = create_real_object(ob);    widget->move( this_player() );  }  add_succeeded_mess( \"$N buy$s $I.\\n\", obs );  return 1;}",}),])
define_docs (["REFERENCE":([]),"DISPLAY":([]),"MAX_PROP":([]),"NUM_REMOVED":([]),"INFINITE_LEFT":([]),])
includes (["/include/armoury.h":1522061544,])
class_docs ([])
file_name "/std/shops/inherit/clone_on_demand.c"
last_changed 1522061544
