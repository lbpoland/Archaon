#/obj/handlers/autodoc/autodoc_file.c
public_functions (["query_script_string":({({"string",}),({({"class","scripting","*",}),"script",}),(["main":({"This returns a printable string of the script.",}),"param":({" script the script to turn into a string",}),"return":({"the string version of the script",}),]),}),"insert_script_data_before":({({"int",}),({({"string",}),"name",({"int",}),"pos",({"class","script_data",}),"data",}),(["main":({"This method inserts a data element before the specified position in thescript.  If the position is 0 then the element is inserted at the start,if the position is beyond the end of the array, then the item is inserterat the end.",}),"param":({"name the script name","pos the position to insert before","data the data to replace it with",}),]),}),"set_script_actors":({({"void",}),({({"string",}),"name",({"string","*",}),"actors",}),(["main":({"This method sets the actors associated with the script.",}),"param":({"name the name of the event to set the data for","actors the actors for the script",}),]),}),"repeat_loop":({({"void",}),({}),(["main":({"This function is called by trigger_thingy and by itself.<p>You could mask this if you need to restrict what the npcs are allowedto say.",}),"param":({"this_script the script contents,","num the line number we are up to","who the person we are looking at",}),]),}),"set_script_data_location":({({"int",}),({({"string",}),"name",({"int",}),"pos",({"class","script_data",}),"data",}),(["main":({"This method replaces the script data at the specified location inthe script with a new item.",}),"param":({"name the script name","pos the position to replace","data the data to replace it with",}),"return":({"1 on success, 0 on failure",}),]),}),"delete_script_data_location":({({"int",}),({({"string",}),"name",({"int",}),"pos",}),(["main":({"This method deletes the script data at the specified location.",}),"param":({"name the script name","pos the position to replace",}),"return":({"1 on success, 0 on failure",}),]),}),"trigger_script":({({"void",}),({({"string",}),"event",({"object",}),"who",({"int",}),"override",}),(["main":({"This function is called to activate a script in this object.( Can be left blank, best to use file_name( this_player() ) ).",}),"param":({"event the name of the event to be triggered,","who a reference to the object who triggered the event","override the override for the priority",}),]),}),"query_script":({({"class","script",}),({({"string",}),"name",}),(["main":({"This returns the script associated with the event.",}),"returns":({"*string The content of the script, or an empty array.",}),"param":({"name The name of the script.",}),]),}),"set_script_data":({({"void",}),({({"string",}),"name",({"class","script_data","*",}),"data",}),(["main":({"This method sets the script data.",}),"param":({"name the event to set the data for","data the script data",}),]),}),"set_script":({({"void",}),({({"string",}),"name",({"class","scripting","*",}),"script",}),(["main":({"This sets the specific script to the new value.",}),]),}),])
protected_functions ([])
inherits (["/std/basic/expressions":({}),])
main_docs (["main":({"This is the standard inheritable to enable players to script npcs.<p>All you need to do is inherit this file, make sure you call the ::init,and make sure you have a few functions defined in your context.<p>If you are not using a player shop inherit then you must ensure thatis_allowed( name ) returns 1 if the player is allowed to edit scriptsin this object.<p>You will need to write your own find_npc() function, since this isextremely sensitive to the implementation.  For reference check outthe one which will be written for player controlled shops.<p>It is assumed that a save object will be inherited, if notthen event_save() will need to be defined.",}),"author":({"Nofear",}),"see":({"trigger_thingy(), return_script()",}),"example":({"inherit \"/std/room/scripting\";inherit \"/std/room\";void init(){   scripting::init();   ..}void setup(){   ..   add_help_file( DOCS +\"scripting\" );}",}),])
define_docs (["SCRIPTING_TRIGGER_EVENT":([]),"SCRIPTING_EXPRESSION":([]),"SCRIPTING_COMMAND":([]),"SCRIPTING_WAIT_COMMAND":([]),"SCRIPTING_GOTO":([]),])
includes (["/include/nroff.h":1522061544,"/include/expressions.h":1522061544,])
class_docs (["script_data":({0,({({"type",({"int",}),}),({"actor",({"string",}),}),({"str",({"string",}),}),({"expr",({"class","parse_node","*",}),}),({"number",({"int",}),}),}),(["main":({"This class contains each element of the script itself.",}),"param":({"type if it is a simple string or a complex expression","actor the person doing stuff","action the action to preform","expr the expression","number a number",}),]),}),"running_script":({0,({({"script",({"class","script",}),}),({"position",({"int",}),}),({"who",({"object",}),}),({"who_name",({"string",}),}),({"who_short",({"string",}),}),({"run_priority",({"int",}),}),}),(["main":({"This class contains each element of the script itself.",}),"param":({"type if it is a simple string or a complex expression","actor the person doing stuff","action the action to preform","expr the expression","number a number",}),]),}),"script":({0,({({"valid_actors",({"string","*",}),}),({"data",({"class","script_data","*",}),}),({"priority",({"int",}),}),}),(["main":({"This class contains each element of the script itself.",}),"param":({"type if it is a simple string or a complex expression","actor the person doing stuff","action the action to preform","expr the expression","number a number",}),]),}),])
file_name "/std/room/inherit/scripting.c"
last_changed 1522061544
