#/obj/handlers/autodoc/autodoc_file.c
public_functions (["query_skin":({({"string",}),({}),(["main":({"This method returns the current skin of the living object.",}),"see":({"set_skin()",}),"return":({"the skin of the object",}),]),}),"set_skin":({({"void",}),({({"string",}),"word",}),(["main":({"This method sets the current skin of the living object.  This canbe done by the race object and by specific spells or effects.",}),"see":({"query_skin()",}),"param":({"word the new skin type",}),]),}),"wear_armour":({({"string",}),({({"object",}),"armour",({"int",}),"doing_hold",}),(["main":({"This is the method used to get the living object to wear a piece ofarmour or clothing.  This is called from inside the armour or clothingcode itself.  It will call the function set_worn_by() on thearmour or clothing and if this returns a non-zero result then itwill add it into the current list of worn types.  Assuming thetype of the armour fits into the allowed list.  It will alsocall the functon hold_item on the object if it is required to beheld as well (ie: shield).",}),"see":({"remove_armour()","query_armours()","query_wearing()",}),"param":({"armour the armour to wear","doing_hold if this is called by the hold command",}),"return":({"the failure message, or 0 if ok",}),]),}),"register_armour_callback":({({"int",}),({({"int",}),"level",({"mixed",}),"callback",({"mixed",}),"data",}),(["main":({"Register a callback for magical protection.",}),"example:":({"register_armour_callback(ARM_INNER,                         ({ \"/std/effects/religious/shield\", \"callback\" }),                         ({ \"pishe\" });The callback function will be called as:callback(player, type, amount, zone, ({ \"pishe\" }));",}),"param":({"level How close the protection is to the skin.","callback The object & function to be called.","data Any extra data to be passed.",}),"return":({"an ID to identify this callback.",}),]),}),"query_ac":({({"varargs","int",}),({({"string",}),"type",({"int",}),"amount",({"string",}),"zone",}),(["main":({"This function returns the amount of damage that can be blockedby the armour on a specified zone.  It automaticallydamages the armour, and sets the stopped object to be thethe object (piece of armour) that stopped the blow.",}),"see":({"query_wearing()",}),"param":({"type The type of damage, eg: \"sharp\", \"blunt\", \"pierce\".","amount The amount of damage that is being done.","zone The zone which the damage is being done through, eg: \"head\".",}),"return":({"The amount of damage that will be blocked.",}),]),}),"set_stopped":({({"void",}),({({"mixed",}),"arg",}),(["main":({"This method sets the object which stops the call.  This should beused to do weird stuff.  I have no idea what it should be used forat all and I am just rambling.",}),"param":({"arg the new value of the stopped object",}),]),}),"query_wearing":({({"object","*",}),({}),(["main":({"This method returns all the objects you are currently wearing.",}),"see":({"query_armours()",}),"return":({"the current array of worn objects","the array of worn stuff",}),]),}),"remove_armour":({({"int",}),({({"object",}),"thing",}),(["main":({"This method will remove the armour from the living object.",}),"see":({"wear_armour()","query_armours()","query_wearing()",}),"param":({"thing the armour to remove",}),"return":({"1 if was unsuccessful and 0 if it was successful",}),]),}),"clear_armours":({({"void",}),({}),(["main":({"This method will make sure all the armours are unworn by the livingobject.",}),"see":({"query_wearing()",}),]),}),"remove_armour_callback":({({"int",}),({({"int",}),"level",({"int",}),"id",}),(["main":({"Remove a registered callback, used when the protection ends.",}),"see":({"register_armour_callback()",}),"param":({"level The level of the callback","id The callbacks ID.",}),]),}),"query_armours":({({"object","*",}),({}),(["main":({"This method returns all the armours that the is currently beingworn.  This will always return the same value as query_wearing()",}),"see":({"query_wearing()",}),"return":({"the array of armours",}),]),}),"query_armour_callbacks":({({"mixed","*",}),({}),(["main":({"Query all the callback data. This should typically only be used fordebugging purposes.",}),]),}),"query_stopped":({({"mixed",}),({}),(["main":({"This returns the object which stopped the blow.  This is only validinside and after a query_ac() call.",}),"return":({"the object which stopped the call",}),]),}),"update_armour_callback":({({"int",}),({({"int",}),"level",({"int",}),"id",({"mixed",}),"data",}),(["main":({"Update the data for an armour callback.",}),"see":({"register_armour_callback()",}),"param":({"level The level of the callback","id The callbacks ID.","data The new data.",}),]),}),])
protected_functions (["equivalent_armour_types":({({"int",}),({({"mixed",}),"comp",({"string",}),"type",}),(["main":({"This method checks to see if the two armour types areequivilant or not.",}),"param":({"comp the first type","type the second type",}),]),}),])
inherits (["/std/armour_logic":({}),])
main_docs (["main":({"This file contains all the armour related code for the livingobjects.",}),"author":({"Pinkfish",}),])
define_docs ([])
includes (["/include/race.h":1522061544,"/include/armour.h":1522061544,"/include/function.h":1522061544,"/include/clothing.h":1522061544,])
class_docs ([])
file_name "/std/living/armour.c"
last_changed 1522061544
