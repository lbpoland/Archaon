#/obj/handlers/autodoc/autodoc_file.c
public_functions ([])
protected_functions ([])
inherits ([])
main_docs (["main":({"This is the include file to handler all the basic error handlercode.",}),"started":({"Thu Feb  6 17:40:26 PST 2003",}),"author":({"Pinkfish",}),])
define_docs (["ERROR_ORDER_BY_DIRECTORY":(["main":({"This define is used to order by the directory. ",}),]),"ERROR_ORDER_BY_FILENAME":(["main":({"This define is used to order by the filename. ",}),]),"ERROR_TYPE":(["main":({"This is the list of valid types. ",}),]),"ERROR_CATEGORIES":(["main":({"This is the list of valid categories. ",}),]),"ERROR_HANDLER":(["main":({"This is the path to the error handler.  ",}),]),"ERROR_STATUS":(["main":({"This is the list of valid statuses. ",}),]),"ERROR_STATUS_DENIED":(["main":({"Error status denied.  The bug was not fixed and is marked as not beinga bug ",}),]),"ERROR_STATUS_CONSIDERING":(["main":({"Error status considering the idea, not yet fixed. ",}),]),"ERROR_STATUS_FIXING":(["main":({"Error status fixing, so it is in the middle of being fixed. ",}),]),"ERROR_STATUS_OPEN":(["main":({"Error status open ",}),]),"ERROR_ORDER_BY_REPORTER":(["main":({"This define is used to order by the reporter. ",}),]),"ERROR_BAD_QUERY":(["main":({"This is the return value when the query is bad.",}),]),"ERROR_ASSIGNED_NO_ONE":(["main":({"This is the define for the user name to use for assigned to 'no one'. ",}),]),"ERROR_ORDER_BY_DATE":(["main":({"This define is used to order by the date. ",}),]),"ERROR_STATUS_FIXED":(["main":({"Error status fixed.  The bug has been resolved and closed. ",}),]),])
includes ([])
class_docs (["error_details":({0,({({"summary",({"class","error_summary",}),}),({"fix_date",({"int",}),}),({"fixer",({"string",}),}),({"report",({"string",}),}),({"runtime",({"string",}),}),}),(["main":({"The details of the bug.",}),"member":({"summary the summary class for the basic sumamry details","fix_date the date the bug was fixed","fixer the person who fixed the bug","report the report associated with the bug","runtime the runtime error associated with the bug",}),]),}),"error_summary":({0,({({"id",({"int",}),}),({"entry_date",({"int",}),}),({"filename",({"string",}),}),({"category",({"string",}),}),({"assigned_to",({"string",}),}),({"reporter",({"string",}),}),({"type",({"string",}),}),({"status",({"string",}),}),({"directory",({"string",}),}),}),(["main":({"The summary plus the details is the completeerror.",}),"member":({"id the unique id of the bug","entry_date the date the bug was added","filename the filename the bug was put against","assigned_to who the bug is assigned to","reporter the person who reported the bug","category is one of ROOM | OBJECT etc","type is one of TYPO | BUG | IDEA","status is one of OPEN | CLOSED | etc","directory the directory the bug is in",}),]),}),"error_complete":({0,({({"details",({"class","error_details",}),}),({"comments",({"class","error_comment","*",}),}),({"forwards",({"class","error_forward","*",}),}),({"replies",({"class","error_replies","*",}),}),}),(["main":({"All the details of the error.",}),"member":({"details the details of the error","comments the comments associated with the error","forwards the forwards associated with the error","replies the replies associated with the error",}),]),}),"error_forward":({0,({({"date",({"int",}),}),({"forwarder",({"string",}),}),({"old_directory",({"string",}),}),}),(["main":({"The forwards associated with the bug.",}),"member":({"date the date the forward was done","forwarder the person who forwared the bug","old_directory the old directory of the bug",}),]),}),"error_replies":({0,({({"id",({"int",}),}),({"bug_id",({"int",}),}),({"sender",({"string",}),}),({"recipient",({"string",}),}),({"status",({"string",}),}),({"senddate",({"int",}),}),({"subject",({"string",}),}),({"message",({"string",}),}),}),(["main":({"The reply data for the error.  This is where the bug replies arestored.",}),"member":({"id the id of the bug reply","bug_id the id of the bug","sender who sent the bug reply","recipient the recipient of the bug reply","status the status of the bug reply","senddate when the bug was sent","subject the subject of the reply","message the message associated with the bug",}),]),}),"error_comment":({0,({({"date",({"int",}),}),({"commenter",({"string",}),}),({"comment",({"string",}),}),}),(["main":({"The comments associated with the bug.",}),"member":({"date the date the comment was added","commenter the person who commented on the bug","comment the comment about the bug",}),]),}),"error_query":({0,({({"no_extra_details",({"int",}),}),({"recursive",({"int",}),}),({"id",({"int",}),}),({"bug_offset",({"int",}),}),({"id_list",({"int","*",}),}),({"dir",({"string",}),}),({"assigned_to",({"string",}),}),({"file_name",({"string",}),}),({"reporter",({"string",}),}),({"fixer",({"string",}),}),({"status",({"string","*",}),}),({"category",({"string","*",}),}),({"type",({"string","*",}),}),({"order_by",({"string",}),}),}),(["main":({"This is the class used to generate queries through the error handler.You do not need to fill in all the fields, only the filled in ones willbe used as restrictions on the query.",}),"member":({"no_extra_details this only works with the bug details queries                         and it means that only the main data is fetched,                         not comments etc.","recursive do recursive directory lookups","id look up this id specifically","id_list look up this list of ids, if this is specified it                overrides id","bug_offset the offset to use in the limit command","dir the directory to use","assigned_to who it is assigned to","file_name specific file name to lookup","reporter the reporter to lookup","fixer the person who fixed the bug","status the status of the bug","category the category of the bug","type the type of the bug","order_by one of the ordering methods",}),]),}),])
file_name "/include/error_handler.h"
last_changed 1522061544
