
// --- MUD Extraction File: mud_extraction_part1.c ---
// Generated: 2025-03-07 07:27:40 UTC
// Source Directory: /mnt/home2/grok/lib
// Purpose: Consolidated LPC .c files for analysis and recreation with FluffOS v2019+
//          and Forgotten Realms theming, replicating discworld.starturtle.net:4242
//          with optimizations (UTF-8, JSON, strict typing).
// Note: Each file break is marked with // --- END [file_path] ---
//
// --- BEGIN [/mnt/home2/grok/lib/obj/monster/transport/horse.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/monster/transport/horse.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627911   Available: 13575265
Inodes: Total: 5242880    Free: 4960133
833 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/monster/transport/horse.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627911   Available: 13575265
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <npc/transport.h>
inherit "/obj/monster/transport/horse_base";

void setup() {
   set_race("horse");
   set_level(20);
   set_name("horse");
   set_gender( query_mount_gender() );
   set_long( "A nice dark dashing horse, " + query_pronoun() + " looks "
             "strong and happy as its brown eyes stare into your own.\n" );
   set_inside_long( "You can see the horses hair and ear's flicking at the "
                    "slightest sounds.  The smell of horse is quite "
                    "strong.\n" );

   // 10 royals in value
   set_value(40000 * 10);
   set_maximum_speed(RIDE_GALLOP);
   set_transport_type("horse");
   set_default_mount_difficulty(100);
   set_default_direction_difficulty(100);
   set_wander_time( 40 + random(10) );
   set_transport_speed(2);
   set_maximum_exhaustion(300);
} /* setup() */
// --- END [/mnt/home2/grok/lib/obj/monster/transport/horse.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/monster/transport/camel.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/monster/transport/camel.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627911   Available: 13575265
Inodes: Total: 5242880    Free: 4960133
779 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/monster/transport/camel.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627911   Available: 13575265
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <npc/transport.h>
inherit "/obj/monster/transport/camel_base";

void setup() {
   set_race("camel");
   set_level(20);
   set_name("camel");
   set_long( "A ratty old camel with seemingly more knees than it should "
             "have.\n");
   set_inside_long( "Nothing smells worse than a camel.  Not even something "
                    "from Dibbler's tray.\n");

   // 12 royals in value ( they're exotic )
   set_value(40000 * 12);
   set_maximum_speed(RIDE_GALLOP);
   set_transport_type( "camel" );
   set_default_mount_difficulty(150);
   set_default_direction_difficulty(150);
   set_wander_time( 60 + random(20) );
   set_gender( 1 + random(2) );
   set_transport_speed(1);
   set_maximum_exhaustion(400);
  set_transport_colour("off-yellow");
} /* setup() */
// --- END [/mnt/home2/grok/lib/obj/monster/transport/camel.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/monster/transport/warhorse.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/monster/transport/warhorse.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627911   Available: 13575265
Inodes: Total: 5242880    Free: 4960133
890 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/monster/transport/warhorse.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627911   Available: 13575265
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <npc/transport.h>
inherit "/obj/monster/transport/horse_base";

void setup() {
   set_race("horse");
   set_level(50);
   set_name("horse");
   add_adjective("war");
   set_gender( query_mount_gender() );
   set_long( "This horse has an air of calmness about " + query_objective() + ", "
             + query_pronoun() + " just stands there and looks very calm.\n" );
   set_inside_long( "You can see the horses mane and " + query_objective() + " "
                    "looking calmly as possible into the distance.\n");

   // 10 royals in value
   set_value(40000 * 10);
   set_maximum_speed(RIDE_GALLOP);
   set_transport_type("horse");
   set_default_mount_difficulty(100);
   set_default_direction_difficulty(20);
   set_wander_time( 50 + random(10) );
   set_transport_speed(3);
   set_maximum_exhaustion(600);
   adjust_bonus_str(5);
   adjust_bonus_con(5);
} /* setup() */
// --- END [/mnt/home2/grok/lib/obj/monster/transport/warhorse.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/monster/transport/camel_base.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/monster/transport/camel_base.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627910   Available: 13575264
Inodes: Total: 5242880    Free: 4960133
3980 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/monster/transport/camel_base.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627910   Available: 13575264
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
// Seems to fail when moving sometimes.
#include <npc/transport.h>
#include <broadcaster.h>
inherit TRANSPORT_INHERIT;

private int _quiet;

/**
 * This method sets the quiet flag on the camel.  If they are quiet
 * they will not say anything when they do commands and so on.
 * @param quiet the new value for the quiet flag
 */
void set_quiet( int quiet ) {
   _quiet = quiet;
} /* set_quiet() */

/**
 * This method queries the quiet flag on the camel.  If they are quiet
 * they will not say anything when they do commands and so on.
 * @return the current setting of the quiet flag
 */
int query_quiet() {
   return _quiet;
} /* query_quiet() */

/** @ignore yes */
void hear_name( object player, string mess ) {
   string *bits;
   string str;
   int allowed;

   if ( !player ) {
      return ;
   }

   if ( is_allowed_to_use( player->query_name() ) ) {
      //
      // Ok, lets see if they asked us to do anything...
      //
      bits = explode( mess, " " ) - ({ "" });
      foreach ( str in bits ) {
         switch ( str ) {
         case "follow" :
            do_command( "follow " + player->query_name() );
            break;
         case "stop" :
            do_command( "unfollow " + player->query_name() );
            break;
         case "stay" :
            do_command( "unfollow all" );
            break;
         case "quiet" :
            set_quiet(1);
            break;
         case "speak" :
         case "talk" :
            set_quiet(0);
            break;
         }
      }
      allowed = 1;
   }

   if ( !query_quiet() ) {
      if ( allowed ) {
        if( player->query_visible( this_object() ) )
          do_command( "slook " + player->query_name() );
      }
      switch ( random(3) ) {
      case 0:
         do_command( "spit" );
         break;
      case 1:
         do_command( ":ruminates." );
         break;
      case 2:
         do_command( ":looks thoughtful." );
         break;
      }
   }
} /* hear_name() */

/** @ignore yes */
void event_person_shout( object thing, string start, string mess, string lang,
                         int *co_ord, int range ) {
   if ( !environment() )
      return;
   if ( environment()->query_property( "shout zone" ) !=
        environment( this_player() )->query_property( "shout zone" ) ||
        !thing ) {
      return;
   }
   mess = lower_case( mess );
   if ( is_allowed_to_use( thing->query_name() ) ) {
      if ( strsrch( mess, lower_case( query_transport_name() ) )  != -1 ) {
         if (strsrch( mess, "come here" ) != -1) {
            if ( !query_quiet() ) {
               do_command( "grumble" );
            }
            add_effect( "/std/effects/npc/goto_destination",
                        environment(thing) );
         }
      }
   }
} /* event_person_shout() */

/** @ignore yes */
mapping query_dynamic_auto_load() {
   return ([ "::" : ::query_dynamic_auto_load(),
             "quiet" : query_quiet() ]);
} /* query_dynamic_auto_load() */

/** @ignore yes */
void setup_responses() {
  add_respond_to_with( explode(
                       lower_case( query_transport_base_name() ), " " ),
                       (: hear_name :) );
  BROADCASTER->npc_hear_shouts( this_object() );
} /* setup_responses() */

/** @ignore yes */
void init_dynamic_arg( mapping map ) {
   ::init_dynamic_arg( map["::"] );
   if ( map["quiet"] ) {
      set_quiet( map["quiet"] );
   }
   if ( query_transport_name() ) {
      setup_responses();
      set_short( query_transport_name() );
      add_adjective( explode( lower_case( query_transport_name() ), " " )
                     - ({ "the" }) );
      add_property( "determinate", "" );
      add_alias( explode( lower_case( query_transport_name() ), " " )
                 - ({ "the" }) );
   }
} /* init_dynamic_arg() */

/** @ignore */
int do_name( string name ) {
   if ( ::do_name( name ) ) {
      setup_responses();
      set_short( query_transport_name() );
      return 1;
   }
   return 0;
} /* do_name() */
// --- END [/mnt/home2/grok/lib/obj/monster/transport/camel_base.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/monster/transport/horse_base.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/monster/transport/horse_base.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627909   Available: 13575263
Inodes: Total: 5242880    Free: 4960133
3473 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/monster/transport/horse_base.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627909   Available: 13575263
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <npc/transport.h>
#include <broadcaster.h>
inherit TRANSPORT_INHERIT;

private int _quiet;

/**
 * This method sets the quiet flag on the horse.  If they are quiet
 * they will not say anything when they do commands and so on.
 * @param quiet the new value for the quiet flag
 */
void set_quiet( int quiet ) {
   _quiet = quiet;
} /* set_quiet() */

/**
 * This method sets the quiet flag on the horse.  If they are quiet
 * they will not say anything when they do commands and so on.
 * @return the current setting of the quiet flag
 */
int query_quiet() {
   return _quiet;
} /* query_quiet() */

/** @ignore yes */
void hear_name( object player, string mess ) {
   string *bits;
   string str;
   int allowed;

   if ( !player ) {
      return ;
   }

   if ( is_allowed_to_use( player->query_name() ) ) {
      //
      // Ok, lets see if they asked us to do anything...
      //
      bits = explode( mess, " " ) - ({ "" });
      foreach ( str in bits ) {
         switch ( str ) {
         case "follow" :
            do_command( "follow " + player->query_name() );
            break;
         case "stop" :
            do_command( "unfollow " + player->query_name() );
            break;
         case "stay" :
            do_command( "unfollow all" );
            break;
         case "quiet" :
            set_quiet(1);
            break;
         case "speak" :
         case "talk" :
            set_quiet(0);
            break;
         }
      }
      allowed = 1;
   }

   if ( !query_quiet() ) {
      if ( allowed ) {
         do_command( "nuzzle " + player->query_name() );
      }
      switch ( random(3) ) {
      case 0:
         do_command( "whicker" );
         break;
      case 1:
         do_command( "nicker" );
         break;
      case 2:
         do_command( "whinny" );
         break;
      }
   }
} /* hear_name() */

/** @ignore yes */
void event_person_shout( object thing, string start, string mess, string lang,
                         int *co_ord, int range ) {
   if( !environment() )
    return;

   if ( environment()->query_property( "shout zone" ) !=
        environment( this_player() )->query_property( "shout zone" ) ||
        !thing ) {
      return;
   }
   mess = lower_case( mess );
   if ( is_allowed_to_use( thing->query_name() ) ) {
      if ( strsrch( mess, lower_case( query_transport_name() ) )  != -1 ) {
         if (strsrch( mess, "come here" ) != -1) {
            if ( !query_quiet() ) {
               do_command( "whicker" );
            }
            add_effect( "/std/effects/npc/goto_destination",
                        environment(thing) );
         }
      }
   }
} /* event_person_shout() */

/** @ignore yes */
mapping query_dynamic_auto_load() {
   return ([ "::" : ::query_dynamic_auto_load(),
             "quiet" : query_quiet() ]);
} /* query_dynamic_auto_load() */

/** @ignore yes */
void setup_responses() {
  add_respond_to_with( explode(
                       lower_case( query_transport_base_name() ), " " ),
                       (: hear_name :) );
  BROADCASTER->npc_hear_shouts( this_object() );
} /* setup_responses() */

/** @ignore yes */
void init_dynamic_arg( mapping map, object ob ) {
   ::init_dynamic_arg( map["::"] );
   if ( map["quiet"] ) {
      set_quiet( map["quiet"] );
   }
} /* init_dynamic_arg() */

/** @ignore */
int do_name( string name ) {
   if ( ::do_name( name ) ) {
      setup_responses();
      return 1;
   }
   return 0;
} /* do_name() */


// --- END [/mnt/home2/grok/lib/obj/monster/transport/horse_base.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/service_provider.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/service_provider.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627908   Available: 13575262
Inodes: Total: 5242880    Free: 4960133
7230 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/service_provider.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627908   Available: 13575262
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */

/**
 * The service provider object.  It is designed to be similar to
 * the peddler object, only instead of selling objects, it sells
 * services instead.
 *
 * @author Furcifer
 *
 * March 2000
 **/


#include <armoury.h>
#include <money.h>
#include <move_failures.h>

inherit "/obj/monster";

#define SERVICE  0
#define BROWSE   1
#define FUNCTION 2
#define COST     3
#define ALIASES  4

private int parsing_function( mixed *array , string words );

int _busy;
mixed *_service_array = ({ });

void set_busy()   { _busy = 1; }

void reset_busy() { _busy = 0; }

varargs int check_busy( object player )
{
    if( _busy || sizeof( query_queued_commands() ) )
    {
        if( player ) {
            tell_object( player, query_short() +" is busy at the moment."+
            "  " + capitalize( query_pronoun() )+ " will be with you " +
            "shortly.\n" );
        }
    return 1;
    } else
        return 0;
} /* check_busy */

void create()
{
    do_setup++;
    ::create();
    do_setup--;
    if ( !do_setup ) this_object()->setup();
} /* create() */

/** @ignore yes */
void init()
{
    ::init();
    this_player()->add_command( "inquire", this_object(),
        "[a] <string> {from|of} <direct:living:here>", "do_browse" );
    this_player()->add_command( "browse", this_object(),
        "[a] <string> {from|of} <direct:living:here>" );
    this_player()->add_command( "request", this_object(),
        "[a] <string> from <direct:living:here>" );
    this_player()->add_command( "list", this_object(),
        "services [available] {from|of} <direct:living:here>" );
} /* init() */

/**
 * This method adds a service to the list of services on offer.
 * @param service the name of the service
 * @param cost what it costs
 * @param the function which controls
 * @param *aliases an array of aliases for this service.
 * @return 1 on success, 0 on failure
 */
varargs int add_service( string service , string browse_info ,
    string func, int cost, string *aliases )
{
    string *alias_array;

    /* Does a function exist to define the service */
    if( !service || !browse_info || !func ||
        !function_exists( func , this_object() , 1 ) )
            return 0;

    /* If things get to here, then it obviously does, so... */
    alias_array = !sizeof(aliases) ? ({ }) : aliases ;

    _service_array += ({ ({ service , browse_info , func , cost ,
        alias_array }) });
    return 1;
}

/**
 * This method removes a service.
 * @param string service to be removed
 * @return 1 on successful removal, 0 on failure
 **/
int remove_service( string service )
{
    mixed *things;
    things = filter( _service_array, (: $1[SERVICE]==$(service) :) );
    switch( sizeof(things) ) {
        case 1: _service_array -= things; return 0; break;
        default: return 0; break;
    }
    return 0;
}

/**
 * The main entrance to the browse for things command.
 * @return 1 on success, 0 on failure
 **/
int do_browse( mixed indirect_obs, string dir_match, string indir_match,
    string *words )
{
    string place;
    mixed *things;
    object player;

    /* store the player -- we might need them after a time delay */
    player = this_player();

    /* find out if the provider is busy */
    if ( check_busy( player ) ) return 0;

    /* find out where we are, we'll need that later. */
    place = query_property( "place" );
    if ( !place || ( place == "" ) )
        place = "default";

    things =
        filter( _service_array ,(:parsing_function( $1, $(words)[0]):) );

    if( !sizeof( things ) ) {
        init_command( "say I'm afraid I don't offer that service.", 2 );
    } else {
        init_command("say A " + things[0][SERVICE] + " costs " +
            MONEY_HAND->money_value_string( things[0][COST], place ) +
            ".  " + things[0][1], 2 );
    }
    player->add_succeeded_mess( this_object(), "$N ask$s $D "+
          "about "+ words[ 0 ] +".\n", ({ }) );
    return 1;
} /* do_browse() */

/**
 * The main entrance to the buy things command.
 * @return 1 on success, 0 on failure
 **/
int do_request( mixed indirect_obs, string dir_match, string indir_match,
      string *words )
{
    mixed *things;
    object player;
    int value;
    string place;

    player = this_player();
    place = query_property("place");
    if ( !place || place == "" )
        place = "default";

    if ( check_busy( player ) ) return 0;

    things =
        filter( _service_array , (: parsing_function($1,$(words)[0]) :));

    if ( !sizeof( things ) )
        init_command( "say I'm afraid I don't offer that service.", 2 );
    else {
        value = player->query_value_in("default") +
            ( place == "default" ? 0 : player->query_value_in( place ) );
        if( things[0][COST] > value )
            init_command("say And just how do you propose to pay "+
                "for a "+things[0][SERVICE]+"?" , 2 );
        else {
            init_command("say Certainly, "+
                ( player->query_gender() == 1 ? "Sir" : "Ma'am" )+
                "!");
            tell_object( player , "You hand "+query_short()+" the "+
                "necessary money.\n");
            player->pay_money( MONEY_HAND->
                create_money_array(things[0][COST], place ), place );
            call_out( things[0][FUNCTION] , 4 , player, things[0] );
        }
    }
    player->add_succeeded_mess( this_object(), "$N ask$s $D "+
        "about having a "+ words[ 0 ] +".\n", ({ }) );
   return 1;
} /* do_buy() */

/**
 * The main entrance to the list stuff command.
 * @return 1 on success, 0 on failure
 **/
int do_list()
{
    string place, list;
    int i,number;

    number = sizeof( _service_array );

    place = query_property( "place" );
    if ( !place || ( place == "" ) )
        place = "default";

    list = "I am currently offering the following: ";
    if( number > 3 ) {
        for( i=0 ; i < (number-2) ; i++ ) {
            list += ( "a "+_service_array[i][SERVICE]+" for "+
                MONEY_HAND->money_value_string(
                    _service_array[i][COST], place )+", " );
        }
    }
    if( number > 1 ) {
        list += ( "a " + _service_array[<2][SERVICE] + " for " +
            MONEY_HAND->money_value_string(
                _service_array[<2][COST], place ) +" and " );
    }
    if( number > 0 ) {
        list += ( _service_array[<1][SERVICE] + " for " +
            MONEY_HAND->money_value_string(
                _service_array[<1][COST], place ) +"." );
    }
    if( number == 0 )
        list = "I am not currently offering any services.";

    init_command("say "+ list, 2);

    this_player()->add_succeeded_mess( this_object(), "$N ask$s $D what "+
         "services "+ (string)this_object()->query_pronoun() +" has "+
         "on offer.\n", ({ }) );
   return 1;
} /* do_list() */

/**
 * This function is used in matching strings to elements of the service
 * array.
 **/
private int parsing_function( mixed *array , string word )
{
    /* Does it match the service name? */
    if ( array[SERVICE] == word ) return 1;

    /* Does it match any of the aliases? */
    if ( member_array( word, array[ALIASES] ) != -1 ) return 1;

    /* Well, I guess it doesn't match */
    return 0;
}

// --- END [/mnt/home2/grok/lib/obj/service_provider.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/corpse.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/corpse.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627906   Available: 13575260
Inodes: Total: 5242880    Free: 4960133
21483 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/corpse.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627906   Available: 13575260
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <bit.h>
#include <corpse.h>
#include <move_failures.h>

/* 200/5*30 seconds == 20 minutes */
#define DECAY_BASE 200
#define PLAYER_DECAY_BASE 600
#define RANDOM( x ) x[ random( sizeof( x ) ) ]


inherit "/std/container";
inherit "/std/living/carrying";
inherit "/std/basic/virtual_quit_control";

private int _decay;
private int _corpse_id;
private string _owner;
private string _race_ob;
private string _race_name;
private string *_bits_gone;
private string *_removed;
private string *_permitted;
private object _weapon;
private object *_armours;
private object *_holding;
private string _start_pos;
private string _nationality;

void set_decay_messages();
void remove_creator_corpse( object ob );

void set_race_ob(string _race_ob);
int query_corpse() {
  return 1;
}

/**
 * This method returns the id associated with the corpse.
 * @return the corpse id
 */
int query_corpse_id() {
   return _corpse_id;
}

int query_decay() {
  return _decay;
}
void set_decay(int dec) {
  _decay = dec;
}

string query_owner() {
  return _owner;
}

string *query_permitted() {
  return _permitted;
}
void set_race_name(string str) {
  _race_name = str;
}

string query_race_name() {
  return _race_name;
}

object make_bit(string which_bit);
object *make_bits(string *what_bits);
void give_permission(string);

string query_name() {
  if (!::query_name())
    return "someone";
  return::query_name();
}                               /* query_name() */

string *remove_array_parts(string *a1,
                           string *a2) {
  int i;
  string a;

  if (sizeof(a2))
    foreach(a in a2) {
    for (i = 0; i < sizeof(a1); i++) {
      if (a == a1[i]) {
        a1 = delete(a1, i, 1);
        break;
      }
    }
  }
  return a1;
}

void setup() {
  _bits_gone = ({ });
  _removed = ({ });
  add_property("cureable", 1);
  add_property("determinate", "the ");
  _owner = "noone";
  _race_name = "womble";
  _decay = DECAY_BASE;
  add_plural("corpses");
  add_plural("bodies");
  add_plural("carcasses");
  add_alias(({ "corpse", "body", "carcass" }));
  set_short("corpse");
  set_long("A corpse, it looks dead.\n");
  set_weight(STD_CORPSE_WEIGHT);
  set_race_ob("/std/races/unknown");
  _permitted = ({ });
  _armours = ({ });
  _holding = ({ });
  add_extra_look(this_object());
}                               /* setup() */

/** @ignore yes */
string extra_look() {
  if(sizeof(_removed))
    return "It appears to be missing its " + query_multiple_short(_removed) +
      ".\n";
  return "";
}

void give_permission(string words) {
  _permitted += ({ words });
}


int get(mixed dest) {
  if (query_property("player") && dest) {
    if (!this_player())
      return::get(dest);

    if (member_array((string) this_player()->query_name(), _permitted) ==
        -1)
      return MOVE_INVALID_DEST;
  }
  return::get(dest);
}

/*
 * This checks if someone is removing something from their own, or someone
 * elses corpse. If it's someone elses and they're on the permit list then
 * it allows the removal.
 * If they aren't on the permit list it passes it to /std/container's checks
 * which will prevent removal if one or other is not a PK or allow it if
 * they're both PK and record a theft event.
 *
 */
int test_remove(object thing,
                int flag,
                mixed dest) {
  int i;

  if (base_name(environment()) == "/room/rubbish") {
    return 1;
  }

  if (thing->query_property("my corpse") == this_object()) {
    return 1;
  }

  if (!query_property("player")) {
    return 1;
  }

  if (!sizeof(_permitted) || !this_player()) {
    i =::test_remove(thing, flag, dest);
  } else if (member_array((string) this_player()->query_name(), _permitted) ==
             -1) {
    i =::test_remove(thing, flag, dest);
  } else {
    write((string) thing->the_short() + " $V$0=buzzes,buzz$V$ for a "
          "moment.\n");
    return 1;
  }

  // Record looting of quest weapons. This is useful for tracking purposes.
  if (i && this_player() && thing &&
      sizeof(thing->effects_matching("mudlib.owned.weapon")) &&
      this_player()->query_name() != thing->query_owner() &&
      member_array((string) this_player()->query_name(), _permitted) == -1) {
    log_file("LOOT", "%s %s took %s [%s] from %s.\n",
             ctime(time()), this_player()->query_cap_name(),
             thing->query_short(), thing->query_owner(),
             this_object()->query_owner());
  }

  if (i) {
     CORPSE_HANDLER->save_corpse(this_object());
  }
  return i;
}                               /* test_remove() */

string long(string words,
            int dark) {
  if (dark == 2 || dark == -2) {
    if (query_living_contents(0) != "") {
      return::long(words, dark) + "Carrying, wearing or holding some "
        "things you cannot make out.\n";
    }
  }
  return::long(words, dark) + query_living_contents(0);
}                               /* long() */

/**
 * This method initially sets up the corpse object.  Generally
 * speaking words should be 0 and the 'thing' variable should be
 * set to the object which just died.
 * @param words the owner of the object
 * @param thing the object to get the ownership data from
 */
void set_owner(string words, object thing) {
  string det;
  string *tmp;

  if (stringp(words)) {
    _owner = words;
  } else {
    det = (string) thing->query_property("determinate");
    if (stringp(det)) {
      _owner = det + (string) thing->short();
    } else {
      _owner = add_a((string) thing->short());
    }
  }
  if (thing && thing->query_property("player")) {
    set_decay(PLAYER_DECAY_BASE);
    // the owner should always be permitted.
    give_permission(thing->query_name());
    catch(_corpse_id = CORPSE_HANDLER->query_next_corpse_id());
    _start_pos = thing->query_start_pos();
    set_ownership(thing->query_name());
    add_property("player", 1);
  }

  set_name("corpse");
  set_short("corpse of " + _owner);
  add_adjective(({ "corpse", "of" }));
  tmp = explode(lower_case(_owner), " ");
  if (sizeof(tmp) > 1) {
    add_alias(tmp[<1]);
  }
  add_adjective(tmp);
  add_adjective(tmp[<1] + "'s");

  if (thing) {
     _nationality = thing->query_nationality(); 
    if(userp(thing)) {
      set_main_plural("corpses of " + thing->short());
    } else  if (thing->query_main_plural() && !userp(thing)) {
      set_main_plural("corpses of " + (string) thing->query_main_plural());
    } else {
      set_main_plural("corpses of " + pluralize((string) thing->short()));
    }
  } else {
    set_main_plural("corpses");
  }
  set_long("This is the dead body of " + _owner + ".\n");
  if (thing && thing->query_weight(1)) {
    set_weight((int) thing->query_weight(1));
  } else {
    set_weight(STD_CORPSE_WEIGHT);
  }

  if ( thing && ( thing->query_creator() || 
    thing->query_property( "test character" ) ) ) 
  remove_creator_corpse( thing );
 
  BIT_CONTROLLER->add_bit(this_object());
  if (thing && thing->query_property("player")) {
    catch(CORPSE_HANDLER->register_corpse(this_object()));
  }
}                               /* set_owner() */

//Fun - I think we still do that.
void remove_creator_corpse( object ob ) {
  call_out( (: move( "/room/morgue", "$N lands in the room with a thud. The kind of thud a "
      "sack of steaks dropped from a great height would make.\n", "" ) :), 6 ); 
  
  call_out( (: tell_room( environment( $(ob) ), "squeeek THUMP squeeeek THUMP "
    "squeeek THUMP squeeeek THUMP\n" ) :), 1 );

  call_out( (: tell_room( environment( $(ob) ), "An igor pushing an old and "
    "battered wheelbarrow appears from somewhere.\n" ) :), 2 );

  call_out( (: tell_room( environment( $(ob) ), "%^CYAN%^The igor says \"Well bugger "
    "me. I've been wanting another one "
    "of those. The mathter will be so pleased.\"%^RESET%^\n" ) :), 4 );

  call_out( (: tell_room( environment( $(ob) ), "Igor cuts something off the corpse"
    " and stuffs it in his pocket before throwing the remains of the corpse into "
  "his barrow and shuffling away. \n" ) :), 6 );

  call_out( (: CORPSE_HANDLER->save_corpse(this_object()) :), 8 );  
  return;
}

/**
 * This is called to decay the corpse.  It is done in a continuous
 * call out loop until all of the decay has been completed.
 */
void do_decay() {
  int rate;

  if (!environment()) {
    return;
  }

  rate = 5 + (int) (environment()->query_property("decay rate"));
  if (rate > 0) {
    _decay -= rate;
  }
  set_decay_messages();
  if (_decay > 0) {
    CORPSE_HANDLER->save_corpse(this_object());
  }
}                               /* do_decay() */

/**
 * This method sets up the various 'states; of the corpse to show 
 * how decayed it is.
 */
void set_decay_messages() {
  if (!_race_name) {
    _race_name = (string) _race_ob->query_name();
  }
  switch (_decay) {
  case 101..PLAYER_DECAY_BASE:
    break;
  case 51..100:
    if (!find_player(query_name())) {
      set_short("somewhat decayed remains of " + add_a(query_name()));
      set_main_plural("somewhat decayed remains of " +
                      pluralize(query_name()));
    }
    break;
  case 1..50:
    set_short("decayed remains of " + add_a(_race_name));
    set_main_plural("decayed remains of " + pluralize(_race_name));
    set_long("This is the dead body of " + add_a(_race_name) + ".\n");
    break;
  default:
    CORPSE_HANDLER->deregister_corpse(this_object());
    set_ownership(0);
    all_inventory()->move(environment());
    move("/room/rubbish");
  }
}                               /* do_decay() */

void set_race_ob(string s) {
  _race_ob = s;
}

string query_race_ob() {
  return _race_ob;
}

string query_bit_left(string s) {
  string *bits;

  bits = _race_ob->query_possible_bits(s);
  if (!bits || !sizeof(bits)) {
    return 0;
  }
  bits = remove_array_parts(bits, _bits_gone);

  if (!sizeof(bits)) {
    return 0;
  }

  return bits[0];
}                               /* query_bit_left() */

string *query_bit_left_pl(string s) {
  string *bits;

  bits = _race_ob->query_possible_plural_bits(s);
  if (!bits || !sizeof(bits)) {
    return 0;
  }

  bits = remove_array_parts(bits, _bits_gone);
  if (!sizeof(bits)) {
    return 0;
  }

  return bits;
}                               /* query_bit_left() */

string *query_edible_bits_left() {
  string *bits;
  string *inedible;

  bits = _race_ob->query_possible_bits();
  inedible = _race_ob->query_all_inedible();
  if (!bits || !inedible) {
    return ({ });
  }
  return remove_array_parts(bits, _bits_gone) - inedible;
}                               /* query_edible_bits_left() */

varargs object *find_inv_match(string s,
                               object looker) {
  string bit;
  string *bits;
  object *weap;
  object wep;
  int cut;

  if (undefinedp(s)) {
    return all_inventory();
  }
  bit = query_bit_left(s);
  bits = query_bit_left_pl(s);
  if (!bit && !sizeof(bits)) {
    return all_inventory();
  }
  cut = 0;
  if (looker) {
    weap = looker->query_weapons();
  }
  if (sizeof(weap)) {
    foreach(wep in weap) {
      if (wep->id("dagger") || wep->id("knife")) {
        cut = 1;
      }
    }
  }
  if (bit) {
    if (cut || _race_ob->query_pluckable(bit)) {
      return ({ make_bit(bit) });
    }
    if (sizeof(weap)) {
      tell_object(looker, "You can only cut things from a corpse "
                  "with a knife or dagger.\n");
    } else {
      tell_object(looker, "You can't cut bits from a corpse with your "
                  "bare hands.\n");
    }
    return ({ });
  }
  if (sizeof(bits)) {
    if (cut) {
      if (sizeof(bits) > 5) {
        return make_bits(bits[0..4]);
      } else {
        return make_bits(bits);
      }
    }
    foreach(bit in bits) {
      if (!((string) _race_ob->query_pluckable(bit))) {
        bits -= ({ bit });
      }
    }
    if (sizeof(bits)) {
      if (sizeof(bits) > 5) {
        return make_bits(bits[0..4]);
      } else {
        return make_bits(bits);
      }
    }
    if (sizeof(weap)) {
      tell_object(looker, "You can only cut things from a corpse "
                  "with a knife or dagger.\n");
    } else {
      tell_object(looker, "You can't cut bits from a corpse with your "
                  "bare hands.\n");
    }
    return ({ });
  }
}                               /* find_inv_match() */

object make_bit(string which_bit) {
  mixed *bit;
  object bitobj;

  bit = _race_ob->query_bit(which_bit);
  if ((sizeof(bit[2][2]) > 1) && stringp(bit[2][2][0])) {
    bitobj = clone_object(bit[2][2][0]);
  } else {
    bitobj = clone_object("/std/bit");
  }
  bitobj->set_race_ob(_race_ob);
  if (_race_name) {
    bitobj->set_race_name(_race_name);
  } else {
    bitobj->set_race_name(_race_ob->query_name());
  }
  bitobj->set_corpse_weight(query_weight());
  if (!_race_ob->query_eat(bit[BIT_NAME])) {
    bitobj->set_bit(bit[0], 0);
  } else {
    bitobj->set_bit(bit[0], (_decay * 2) / 3);
  }

  _bits_gone |= bit[BIT_EXTRA][3..] + ({ bit[BIT_NAME] });
  _removed += ({ bit[BIT_NAME] });
  if (which_bit == "head") {
    //set_long(query_long() + "It is decapitated.\n");
    set_short("decapitated corpse of " + _owner);
    add_adjective("decapitated");
  }
  if (bitobj->move(this_object()) != MOVE_OK) {
    if (environment()) {
      bitobj->move(environment());
    }
  }
  bitobj->add_property("my corpse", this_object());
  return bitobj;
}                               /* make_bit() */

object *make_bits(string *what_bits) {
  string bit;
  object *bits = ({
  });

  foreach(bit in what_bits) {
    bits += ({ make_bit(bit) });
  }
  return bits;
}                               /* make_bits() */

string *query_bits_gone() {
  return _bits_gone;
}

mixed *add_bit_gone(string bit) {
  string *poss_bits;
  string tempbit;
  mixed *bit_details;

  poss_bits =
    remove_array_parts(_race_ob->query_possible_bits(bit), _bits_gone);
  if (!sizeof(poss_bits)) {
    return 0;
  }
  bit_details = _race_ob->query_bit(poss_bits[0]);
  _bits_gone += ({ bit_details[BIT_NAME] });
  foreach(tempbit in
          bit_details[BIT_EXTRA][3..sizeof(bit_details[BIT_EXTRA])]) {
    _bits_gone += ({ tempbit });
  }
  return bit_details;
}                               /* add_bit_gone() */

void set_bits_gone(string *bits) {
  int i;

  _bits_gone = ({ });
  for (i = 0; i < sizeof(bits); i++) {
    add_bit_gone(bits[i]);
  }
}                               /* set_bits_gone() */

string *query_bits_left() {
  int i;
  int j;
  string *all_bits;
  mixed *bits;

  bits = _race_ob->query_bits();
  all_bits = ({ });
  for (i = 0; i < sizeof(bits); i += 3) {
    if (bits[i + 2][2]) {
      for (j = 0; j < bits[i + 2][2][1]; j++) {
        all_bits += ({ bits[i] });
      }
    }
  }
  return remove_array_parts(all_bits, _bits_gone);
}                               /* query_bits_left */

/* this for formatting of objects sake */
object *query_armours() {
  int i;

  _armours -= ({ 0 });
  for (i = 0; i < sizeof(_armours); i++) {
    if ((object) _armours[i]->query_worn_by() != this_object()) {
      _armours = delete(_armours, i, 1);
      i--;
    }
  }
  return _armours + ({ });
}                               /* query_armours() */

object *query_wearing() {
  return query_armours();
}

void set_armours(object * things) {
  int i;

  _armours = ({ });
  for (i = 0; i < sizeof(things); i++) {
    if (things[i]->query_no_limbs()) {
      _holding += ({ things[i] });
    } else {
      _armours += ({ things[i] });
    }
  }
}                               /* set_armours() */

void remove_armour(object arm) {
  _armours -= ({ arm });
}

object query_weapon() {
  return _weapon;
}

void set_weapon(object wpn) {
  _weapon = wpn;
}

void unwield_weapon(object wpn) {
  if (_weapon == wpn)
    _weapon = 0;
}

object *query_holding() {
  return _holding;
}

void set_holding(object * hold) {
  _holding += hold;
}

int *set_unhold(object ob) {
  int pos;

  if ((pos = member_array(ob, _holding)) == -1) {
    return ({ });
  }
  if (!ob->set_holder(0)) {
    return ({ });
  }
  _holding = _holding - ({ ob });
  return ({ pos });
}                               /* set_hold() */

int *set_hold(object ob,
              int pos) {
  if (member_array(ob, _holding) != -1) {
    return ({ });
  }
  _holding += ({ ob });
  return ({ pos });
}                               /* set_hold() */

int move_or_destruct(object dest) {
  if (objectp(dest)) {
    move_object(dest);
  } else {
    move("/room/void");
  }
  return 1;
}

/*
 * This was added so that people dont loose stuff just in case it gets
 * dested for weird reasons.
 * Pinkfish 3rd may 1993
 */
void dest_me() {
  mixed *xp;
  object ob;

  // This hands out the rest of the death Xp when the object is destructed
  // hopefully by burial or ventisepelating or whatever.
  xp = query_property("XP");
  if (xp && sizeof(xp) == 2) {
    foreach(ob in xp[0]) {
      if (ob) {
        ob->adjust_xp(xp[1], 1);
      }
    }
  }

  BIT_CONTROLLER->remove_bit(this_object());
  if (environment()) {
    all_inventory()->move(environment());
  }
  ::dest_me();
}                               /* dest_me() */

/*
 * Added in save code - Tue Feb 25 00:57:06 WST 1997
 * to do wombly stuff by Pinkfish.
 * Only does a bit of wombley stuff though.
 */
mapping query_static_auto_load() {
  return int_query_static_auto_load();
}                               /* query_static_auto_load() */

mapping query_dynamic_auto_load() {
  mapping tmp;
  string pos;

  tmp = ([ "::" : ::query_dynamic_auto_load(),
           "decay" : _decay,
           "owner" : _owner,
           "race ob" : _race_ob,
           "id" : _corpse_id,
           "last pos" : pos,
           "start pos" : _start_pos,
           "nationality" : _nationality,
           "ownership" : query_ownership(),
           "race name" : _race_name, "bits gone" : _bits_gone, ]);
  return tmp;
}                               /* query_dynamic_auto_load() */

void init_dynamic_arg(mapping map, object) {
  if (map["::"]) {
    ::init_dynamic_arg(map["::"]);
  }
  if (map["id"]) {
    _corpse_id = map["id"];
  }
  if (map["decay"]) {
    _decay = map["decay"];
  }
  if (map["owner"]) {
    _owner = map["owner"];
  }
  if (map["race ob"]) {
    _race_ob = map["race ob"];
  }
  _nationality = map["nationality"];
  set_ownership(map["ownership"]);
  if (map["race name"]) {
    _race_name = map["race name"];
  }
  if (map["bits gone"]) {
    _bits_gone = map["bits gone"];
  }
  if (map["start pos"]) {
    _start_pos = map["start pos"];
  }
  set_decay_messages();
}                               /* init_dynamic_arg() */

/**
 * This is used by the corpse handler to get the data used to save
 * the corpse.
 */
string query_save_data() {
   string pos;
   object env;

   env = environment();
   while (env && environment(env)) {
      if (living(env) && env->query_property("player")) {
         return CORPSE_IN_PLAYER;
      }
      env = environment(env);
   }
   // First see if we are inside a living or something.
   pos = find_start_pos( this_object(), env );
   return save_variable(({ query_dynamic_auto_load(), query_static_auto_load(), pos }));
}

/**
 * This method is called by the corpse handler to setup the corpse
 * properly after it loads.
 */
void setup_corpse_from_save(string str_data, string name, int id) {
  mixed data;
  int res;

  if (str_data == CORPSE_IN_PLAYER) {
     return ;
  }

  data = restore_variable(str_data);

  // Restore the data.
  init_static_arg(data[1]);
  init_dynamic_arg(data[0], 0);

  // Make sure we have decay called on us
  BIT_CONTROLLER->add_bit(this_object());

  // Move the thing to the right spot.
  res = MOVE_NO_DROP;
  tell_creator("pinkfish", "Trying to restore to location %O [%O]\n", data[2], this_object());
  catch(res = this_object()->move(data[2],
                         "$N looks confused and pops out of the ground.\n",
                         "$N looks confused and pops out of the ground.\n"));
  if (res != MOVE_OK) {
     tell_creator("pinkfish", "Trying to restore to location %O [%O]\n", _start_pos, this_object());
     catch(res = this_object()->move(_start_pos,
                         "$N looks confused and pops out of the ground.\n",
                         "$N looks confused and pops out of the ground.\n"));
  }
  if (res != MOVE_OK) {
     tell_creator("pinkfish", "Trying to restore to location %O [%O]\n", "/room/rubbish", this_object());
     move("/room/rubbish");
  }
}

mixed *stats() {
  return::stats() +
    ({ ({ "decay", _decay, }), ({ "owner", _owner, }),
         ({ "race ob", _race_ob, }), ({ "race name", _race_name, }) });
}                               /* stat() */

/**
 * @ignore yes
 * This is added so that it acts like a living object and
 * things like non-movable signs cannot be added to it.
 */
int test_add(object ob,
             int flag) {
  // Allow bits in at any time...
  if (ob->query_bit_data()) {
    return 1;
  }

  return !flag;
}                               /* test_add() */

/**
 * @ignore yes
 * Stop people form getting stuff out of containers in corpses.
 */
int can_find_match_reference_inside_object(object thing,
                                           object player) {

  if (!query_property("player")) {
    return 1;
  }

  if (member_array(player->query_name(),
                   _permitted + ({ lower_case(_owner) })) == -1)
    {
      return 0;
    }

  return 1;
}                               /* can_find_match_reference_inside_object() */

int can_find_match_recurse_into(object player) {
  return 0;
} /* can_find_match_recurse_into() */

// --- END [/mnt/home2/grok/lib/obj/corpse.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/reactions/blue_water.rcn_dc.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/reactions/blue_water.rcn_dc.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627901   Available: 13575255
Inodes: Total: 5242880    Free: 4960133
42 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/reactions/blue_water.rcn_dc.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627901   Available: 13575255
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
}

mixed data_return() {
  return data;
}
// --- END [/mnt/home2/grok/lib/obj/reactions/blue_water.rcn_dc.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/reactions/base.hdr_dc.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/reactions/base.hdr_dc.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627900   Available: 13575254
Inodes: Total: 5242880    Free: 4960133
2965 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/reactions/base.hdr_dc.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627900   Available: 13575254
Inodes: Total: 5242880    Free: 4960133
2025-03-06 11:53:25.049162215 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <reaction.h>
void dest_me() { destruct( this_object() ); }

class reaction item;
mapping data = ([ ]);

mixed data_return_0() {
  if (!mapp(data["TeaLeaf"])) data["TeaLeaf"] = ([]);
  item = new( class reaction );
  item->ratio = 1.0/100;
  item->result = "/obj/reagents/weak_black_tea.ob";
  item->result_amt = 1.0;
  item->func = ({ });
  data["TeaLeaf"]["Water"] = item;
  if (!mapp(data["BatGuano"])) data["BatGuano"] = ([]);
  item = new( class reaction );
  item->ratio = ({ 0.8, 1.2 });
  item->result = "/obj/reagents/generic_liquid.ob";
  item->result_amt = 1;
  item->func = ({ (:
   $3->set_decay_speed(0),
   $3->set_medium_alias( "GuanoSolution" ),
   $3->set_name( "guano_solution" ),
   $3->add_alias( "sludge" ),
   $3->set_short( "thick brown sludge" ),
   $3->add_adjective( ({ "thick", "brown" }) ),
   $3->set_long( "This is some thick brown sludge, streaked through with "
     "white.  The smell is... prominent.\n" )
:) })
/**
 *  Author Terano
 *  Created 8/07/02
 *  This file prevents the mixing of healing tea and blue water, in
 *  accordance with the prophecy.
 */;
  data["BatGuano"]["Water"] = item;
  if (!mapp(data["BlueHealingWater"])) data["BlueHealingWater"] = ([]);
  item = new( class reaction );
  item->ratio = ({ 1.0, 1.0 });
  item->result = "/obj/reagents/generic_liquid.ob";
  item->result_amt = 1.0;
  item->func = ({
        (: $3->set_name( "ooze" ) :),
        (: $3->add_alias( "green ooze" ) :),
        (: $3->set_short( "thick green ooze" ) :),
        (: $3->set_main_plural( "thick green oozes" ) :),
        (: $3->add_plural( "oozes" ) :),
        (: $3->add_adjective( "green" ) :),
        (: $3->set_long( "This is a thick, green "
                        "mush, $amount_size$.  It smells "
                        "terrible, and is bubbling slightly.\n" ) :),
        (: $3->set_medium_alias( "ThickGreenOoze" ) :),
        (: $3->add_eat_effect( "/std/effects/ingested/drunk", 50 ) :),
    });
  data["BlueHealingWater"]["BrewedComfreyYarrowTea"] = item;
  if (!mapp(data["BlueHealingWater"])) data["BlueHealingWater"] = ([]);
  item = new( class reaction );
  item->ratio = ({ 1.0, 1.0 });
  item->result = "/obj/reagents/generic_liquid.ob";
  item->result_amt = 1.0;
  item->func = ({
        (: $3->set_name( "ooze" ) :),
        (: $3->add_alias( "green ooze" ) :),
        (: $3->set_short( "thick green ooze" ) :),
        (: $3->set_main_plural( "thick green oozes" ) :),
        (: $3->add_plural( "oozes" ) :),
        (: $3->add_adjective( "green" ) :),
        (: $3->set_long( "This is a thick, green "
                        "mush, $amount_size$.  It smells "
                        "terrible, and is bubbling slightly.\n" ) :),
        (: $3->set_medium_alias( "ThickGreenOoze" ) :),
        (: $3->add_eat_effect( "/std/effects/ingested/drunk", 50 ) :),
    });
  data["BlueHealingWater"]["ComfreyYarrowTea"] = item;
}

mixed data_return() {
  data_return_0();
  return data;
}
// --- END [/mnt/home2/grok/lib/obj/reactions/base.hdr_dc.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/fence.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/fence.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627899   Available: 13575253
Inodes: Total: 5242880    Free: 4960133
20040 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/fence.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627899   Available: 13575253
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* A basic fence for thieves and others to sell stolen items to. */

#include <armoury.h>
#include <money.h>
#include <move_failures.h>
#include <thief.h>

inherit "/obj/monster";

#define MAX 500
#define SKILL "other.trading.valueing"
#define PAY_RATES ({ 200, 95, \
                     400, 90, \
                     800, 85, \
                     1600, 80, \
                     3200, 75, \
                     6400, 70, \
                     12800, 65, \
                     60 })

class hist_offer {
  object ob;
  int old_offer;
  int value;
}

class offer {
  object who;
  int amount;
  int offer_time;
  object *objects;
}

class offer this_offer;
object cont;
string *move_data = ({ });
string fence_type;
mapping old_offers = ([ ]);

void whisper( object, string );
void give_back();

object query_cont() {
  return cont;
}

void create() {
  do_setup++;
  ::create();
  do_setup--;
  if( !do_setup )
    this_object()->setup();

  // Give him his bag.
  cont = clone_object( "/std/container" );
  cont->move(this_object());
  cont->reset_drop();
  cont->reset_get();
  cont->set_name( "sack" );
  cont->set_short( "sack" );
  cont->set_long( "This is a large hessian sack.\n" );
  cont->add_property( "nosteal", 1 );

  set_wimpy( 20 );
  basic_setup( "human", "thief", 500 );

  add_respond_to_with( ({ "@say", ({ "yes", "Yes", "ok", "okay" }) }),
    "#do_yes" );
  add_respond_to_with( ({ "@nod", ({ "you" }) }), "#do_yes" );
  add_respond_to_with( ({ "@whisper", ({ "yes", "Yes", "ok", "okay" }) }),
    "#do_yes" );
  add_respond_to_with( ({ "@say", ({ "no", "No" }) }), "#do_no" );
  add_respond_to_with( ({ "@whisper", ({ "no", "No" }) }), "#do_no" );
  add_respond_to_with( ({ "@shake", ({ "you" }) }), "#do_no" );

}

void init() {
  ::init();
  this_player()->add_command( "fence", this_object(),
    "<indirect:object:me> to <direct:object>" );
}

void dest_me() {
  if( cont )
    cont->dest_me();
  ::dest_me();
}

void reset() {
  object ob;

  // Don't dest anything if we're in the middle of dealing with someone.
  if( this_offer )
    return;
  
  foreach( ob in all_inventory( cont ) )
    ob->dest_me();
}

void check_cont() {
  if ( !cont )
    cont = clone_object( "/std/container" );
}

void set_fence_type( string str ) {
  fence_type = str;
}

int query_cost( object thing, object buyer ) {
   return (int)thing->query_value_at( this_object() );
}

string cost_string( object thing, string place, object buyer ) {
  return (string)MONEY_HAND->money_value_string( query_cost( thing, buyer ),
                                                 place );
}

// Determine item type
string query_item_type( object ob ) {
  if( member_array( "weapons", ob->query_plurals()) != -1 )
    return "weapons";
  if( member_array( "jewellery", ob->query_plurals()) != -1 ||
      ob->query_property( "shop type" ) == "jewellers" )
    return "jewellery";
  if( member_array( "armours", ob->query_plurals()) != -1 )
    return "armour";
  if( member_array( "clothes", ob->query_plurals()) != -1 )
    return "armour";
  if( member_array( "gems", ob->query_plurals()) != -1 )
    return "gems";

  return "";
}

// Judge the value of an item
int judge_value( object ob, string type ) {
  int value, variance, skill;
  value = query_cost( ob, this_object() );
  if( type != "" )
    skill = query_skill_bonus( SKILL + "." + type );
  else
    skill = query_skill_bonus( SKILL );

  if( !skill )
    skill = 1;
  
  variance = value / sqrt( skill );

  value += random( variance ) - random( variance );
  
  return value;
}

// Work out where we are (for money strings)  Make the default AM.
string calc_place() {
  string place;
  
  place = environment()->query_property( "place" );
  if( !place || ( place == "" ) )
    place = "Ankh-Morpork";
  return place;
}

// Return an amount of money as a nice string
string cost_str( int amt ) {
  return MONEY_HAND->money_string( MONEY_HAND->create_money_array( amt,
                                   calc_place() ) );
}

// From /std/shop.
int scaled_value( int n ) {
  int *fish, i, tot;

  fish = PAY_RATES;
  if( n < fish[0] ) {
    return n;
  }
  else {
    tot = fish[0];
    n -= fish[0];
  }

  i = 0;
  while( n && ( ( i + 1 ) < sizeof( fish ) ) ) {
    if( n >= fish[i]) {
      tot += fish[i+1] * fish[i] / 100;
      n -= fish[i];
    } else {
      tot += fish[i+1] * n / 100;
      n = 0;
    }
    i += 2;
  }

  if( n ) {
    tot += ( n * fish[sizeof( fish ) - 1] ) / 100;
  }

  return tot;
} /* scaled_value() */

int do_fence( object *in_dir, string direct, string indirect, mixed args,
  string format ) {
  int offer, their_skill, returned, burdened, light;
  string type, skill, zone;
  object ob, *offered, *not_speciality, customer, thing;

  if( !this_player()->query_creator() &&
      !this_player()->query_visible( this_object() ) ) {
    this_object()->do_command( "puzzle" );
    this_object()->do_command( "wonder if someone is trying to be funny" );
    return 0;
  }
  light = environment( this_object() )->query_light();

  if ( ( light < 20 ) || ( light > 100 ) ) {
    if ( light > 100 ) {
      this_object()->do_command( "say I can't see anything in the glare!" );
    } else {
      this_object()->do_command( "say I can't see anything in the gloom!" );
    }
    return 0;
  }

  if( this_offer &&
      this_offer->who &&
      environment( this_offer->who ) == environment( this_object() ) ) {
    if( this_offer->offer_time > time() - 30 ) {
      if( this_offer->who != this_player() )
        whisper( this_player(), "Sorry, I'm already helping " +
          ( this_offer->who )->the_short() + "." );
      else
        whisper( this_player(), "I'm still waiting for a response from you!" );
      this_player()->add_succeeded_mess( this_object(), "", offered );
      return 1;
    } else {
      // Lets return the items coz they didn't answer in time.
      whisper( this_offer->who, "I guess you don't want my offer then." );
      customer = this_offer->who;
      burdened = 0;
      returned = 0;
    
      foreach( thing in this_offer->objects ) {
        // Sometimes the items turn into 0s.
        if( !thing ) {
          whisper( customer, "Seems there is a hole in my sack!" );
          continue;
        }
        if( thing->move( customer ) != MOVE_OK ) {
          burdened = 1;
          thing->move( environment( this_object() ) );
          whisper( customer, "I'll just put the " + thing->short() +
            " down here since you are too burdened to accept it." );
        } else {
          returned = 1;
        }
      }
    
      if( burdened && returned ) {
      tell_object( customer, this_object()->a_short() + " returns the other "
        "items to you.\n" );
      } else {
        if( returned )
          tell_object( customer, this_object()->a_short() + " returns the "
            "items to you.\n" );
      }
      tell_room( environment(), this_object()->a_short() + " returns the "
        "items to " +  customer->a_short() + ".\n", ({ customer }) );
      this_offer = 0;
    }
  }

  not_speciality = ({ });

  if( sizeof( this_object()->query_move_zones() ) ) {
    foreach( zone in this_object()->query_move_zones() ) {
      move_data += ({zone});
      this_object()->remove_move_zone(zone);
    }
    this_object()->add_move_zone( 0 );
  }
  
  this_offer = new( class offer,
                    objects    : ({ }),
                    who        : this_player(),
                    offer_time : time()
                  );
  
  in_dir = filter_array( in_dir, (: !$1->query_keep() :) );

  if( sizeof( in_dir ) < 1 ) {
    whisper( this_player(), "You have nothing to fence that you're not overly "
      "fond of, it seems." );
    this_player()->add_succeeded_mess( this_object(), "", offered );
    this_offer = 0;
    return 1;
  }

  if( sizeof( in_dir ) > 10 ) {
    whisper( this_player(), "Sorry, I can't handle that many items at "
      "once." );
    this_player()->add_succeeded_mess( this_object(), "", offered );
    this_offer = 0;
    return 1;
  }    

  tell_room( environment( this_object() ), this_object()->query_short() +
            " studies " + query_multiple_short( in_dir ) + ".\n" );
  
  foreach( ob in in_dir ) {
    // Player doesn't have item.
    if( environment( ob ) != this_offer->who ) {
      whisper( this_player(), "Do you think I'm blind?  I can see that you "
        "don't have " + strip_colours( ob->the_short()) + "." );
      continue;
    }
    
    if( base_name(ob) == "/obj/money" ) {
        whisper( this_player(), "I don't accept coins, I'm afraid. The market "
          "fluctuates far too much for it to be worthwhile.");
        continue;
    }

    // Can't move to sack.
    if( ob->move( cont ) != MOVE_OK ) {
      whisper( this_player(), "If I can't take an item you can't fence it "
        "so you can't fence " + strip_colours( ob->the_short()) + "." );
      continue;
    }
    
    // Item have do_not_sell on it.
    if( ob->do_not_sell() ) {
      whisper( this_player(), "You can't sell the " +
        strip_colours( ob->the_short() ) + "." );
      if( ob->move( this_player() ) != MOVE_OK ) {
        ob->move( environment( this_object() ) );
        whisper( this_player(), "So I'll just put it down here." );
      }
      else {
        whisper( this_player(), "So you can have it back." );
      }
      continue;
    }
    
    if( ob->query_property( "fenced" ) ) {
      do_command( "' Hang on a sec... this looks awful familiar." );
      do_command( "glare " + this_offer->who->query_name() );
      do_command( "' Just what are you trying to pull here?!" );
      do_command( "' I think I'll hang onto these little trinkets "
                  "until we can establish their correct ownership..." );
      // Annulling the offer effectively confiscates their crap.
      this_offer = 0;
      this_player()->add_failed_mess( this_object(), this_object()->
        the_short() + " confiscates $I.\n", in_dir );
      return 0;
    }

    type = query_item_type( ob );
    offer = judge_value( ob, type );
    
    // Item not worth anything or smaller than a pence.
    if( !offer ||
        offer < 4 ) {
      whisper( this_player(), ob->the_short() + " isn't worth anything." );
      if( ob->move( this_player() ) != MOVE_OK ) {
        ob->move( environment( this_object() ) );
        whisper( this_player(), "So I'll just put it down here." );
      }
      else {
        whisper( this_player(), "So you can have it back." );
      }
      continue;
    }
    
    // Are we a fence for this type of object?
    if( type != fence_type ) {
      offer -= ( offer / 10 );
      not_speciality += ({ ob });
    }
    
    // Now do the profit (just like a shop)
    offer = (int)scaled_value( offer );
    // Remember our previous offers.
    if( !undefinedp( old_offers[ob] ) ) {
      if( !undefinedp( old_offers[ob][ob->query_value()] ) ) {
        // Found it
        offer = old_offers[ob][ob->query_value()];
      } else {
        old_offers[ob][ob->query_value()] = offer;
      }
    } else {
      old_offers[ob] = ([ ob->query_value() : offer ]);
    }
    
    // Now see if we can fleece them
    if( type != "" )
      skill = SKILL + "." + type;
    else
      skill = SKILL;

    their_skill = this_player()->query_skill_bonus( skill );
    if( !their_skill)
      their_skill = 2;

    // Reduce the offer dependant on their valueing skill
    if( sqrt( their_skill ) < 3 )
      offer -= offer / 3;
    else {
      offer -= ( offer ) / sqrt( their_skill );
    }
    
    // Item not worth anything after all the adjustments.
    if( !offer ||
        offer < 4 ) {
      whisper( this_player(), ob->the_short() + " isn't worth anything." );
      if( ob->move( this_player() ) != MOVE_OK ) {
        ob->move( environment( this_object() ) );
        whisper( this_player(), "So I'll just put it down here." );
      }
      else {
        whisper( this_player(), "So you can have it back." );
      }
      continue;
    }

    this_offer->amount += offer;
    this_offer->objects += ({ ob });
  }

  if( sizeof( not_speciality ) == 1 )
    whisper( this_player(), "Well, " +
      strip_colours( query_multiple_short( not_speciality ) ) + " isn't really "
      "my speciality." );
  else
    if( sizeof( not_speciality ) > 1 )
      whisper( this_player(), "Well, " +
        strip_colours( query_multiple_short( not_speciality ) ) + " aren't "
        "really my speciality." );
  
  this_player()->add_succeeded_mess( this_object(), "", offered );

  if( !sizeof( this_offer->objects ) ) {
    whisper( this_player(), "Well, that was a waste of time." );
    this_offer = 0;
    return 1;
  }

  // Tell em how much and wait for their response
  whisper( this_player(), "I'll give you " + cost_str( this_offer->amount ) +
          " for " + strip_colours( query_multiple_short( this_offer->
          objects ) ) + ", what do you think?" );
  return 1;
}

// Now they've given a response either stop or take their goods
// and give them money.
void do_yes( object person ) {
  object money, *selling, ob;
  mixed *m_array;
  string zone;

  if( !this_offer || person != this_offer->who )
    return;

  whisper( person, "You've got a deal." );
  selling = ({ });
  foreach( ob in this_offer->objects ) {
    ob->add_property( "fenced", (string)person->query_name() );
    selling += ({ ob });
  }
  
  m_array = (mixed *)MONEY_HAND->create_money_array( this_offer->amount,
                                                     calc_place() );
  money = clone_object( MONEY_OBJECT );
  money->set_money_array( m_array );

  if( (int)money->move( person ) != MOVE_OK) {
    money->move( environment( this_object() ) );
    whisper( person, "You're too heavily burdened to accept all "
      "that money, so I'll just put it on the floor." );
  } else {
    tell_object( person, this_object()->a_short() + " slips you " +
      cost_str( this_offer->amount ) + ".\n" );
    tell_room( environment(), this_object()->a_short() + " slips some coins "
      "to " + person->a_short() + ".\n", ({person}) );
  }
  this_offer = 0;

  if( sizeof( move_data ) > 0 ) {
    foreach( zone in move_data ) {
      this_object()->add_move_zone( zone );
    }
    this_object()->remove_move_zone( 0 );
    move_data = ({ });
  }
}

void do_no( object player ) {
  string zone;
  object customer, thing;
  int returned, burdened;
    
  if( !this_offer || player != this_offer->who )
    return;

  whisper( player, "Ok, have it your own way then." );
  customer = this_offer->who;
  burdened = 0;
  returned = 0;

  foreach( thing in this_offer->objects ) {
    if( !thing ) {
      whisper( customer, "Seems thare is a hole in my sack!" );
      continue;
    }
    if( thing->move( customer ) != MOVE_OK ) {
      burdened = 1;
      thing->move( environment( this_object() ) );
      whisper( customer, "I'll just put the " + thing->short() +
        " down here since you are too burdened to accept it." );
    } else {
      returned = 1;
    }
  }

  if( burdened && returned ) {
  tell_object( customer, this_object()->a_short() + " returns the other items "
    "to you.\n" );
  } else {
    if( returned )
      tell_object( customer, this_object()->a_short() + " returns the items to "
        "you.\n" );
  }
  tell_room( environment(), this_object()->a_short() + " returns the "
    "items to " +  customer->a_short() + ".\n", ({ customer }) );
  this_offer = 0;

  if( sizeof( move_data ) > 0 ) {
    foreach( zone in move_data ) {
      this_object()->add_move_zone( zone );
    }
    this_object()->remove_move_zone( 0 );
    move_data = ({ });
  }
}

void whisper( object ob, string message ) {
  do_command( "whisper " + message + " to " + ob->query_name() );
}

int busy() {
  if( this_offer )
    return 1;
  return 0;
}

void event_exit( object ob, string message, object to ) {
  object customer, thing;
  int returned, burdened;

  if( this_offer &&
      ob == this_offer->who ) {
    whisper( ob, "Since you're leaving, I'll give your stuff back." );
    customer = this_offer->who;
    burdened = 0;
    returned = 0;
  
    foreach( thing in this_offer->objects ) {
      if( !thing ) {
        whisper( customer, "Seems thare is a hole in my sack!" );
        continue;
      }
      if( thing->move( customer ) != MOVE_OK ) {
        burdened = 1;
        thing->move( environment( this_object() ) );
        whisper( customer, "I'll just put the " + thing->short() +
          " down here since you are too burdened to accept it." );
      } else {
        returned = 1;
      }
    }
  
    if( burdened && returned ) {
    tell_object( customer, this_object()->a_short() + " returns the other "
      "items to you.\n" );
    } else {
      if( returned )
        tell_object( customer, this_object()->a_short() + " returns the items "
          "to you.\n" );
    }
    tell_room( environment(), this_object()->a_short() + " returns the "
      "items to " +  customer->a_short() + ".\n", ({ customer }) );
    this_offer = 0;
  }
}

int attack_by( object ob ) {
  int burdened, returned;
  object customer, thing;
  
  if( this_offer &&
      this_offer->who &&
      environment( this_offer->who ) == environment( this_object() ) &&
      this_offer->offer_time > time() - 60 ) {
    do_command( "say Hey! I'm trying to do business here!" );
    whisper( this_offer->who, "Hey, you'd better take these." );
    customer = this_offer->who;
    burdened = 0;
    returned = 0;
  
    foreach( thing in this_offer->objects ) {
      if( !thing ) {
        whisper( customer, "Seems thare is a hole in my sack!" );
        continue;
      }
      if( thing->move( customer ) != MOVE_OK ) {
        burdened = 1;
        thing->move( environment( this_object() ) );
        whisper( customer, "I'll just put the " + thing->short() +
          " down here since you are too burdened to accept it." );
      } else {
        returned = 1;
      }
    }
  
    if( burdened && returned ) {
    tell_object( customer, this_object()->a_short() + " returns the other "
      "items to you.\n" );
    } else {
      if( returned )
        tell_object( customer, this_object()->a_short() + " returns the items "
                     "to you.\n" );
    }
    tell_room( environment(), this_object()->a_short() + " returns the "
               "items to " +  customer->a_short() + ".\n", ({ customer }) );
    this_offer = 0;
  }
  return ::attack_by(ob);
}

/*void event_person_say( object thing, string start, string mess, string lang) {
  if ( !( thing->query_current_language() == "morporkian" ) ) {
    lang = "morporkian";
  }
  ::event_person_say( thing, start, mess, lang );
}*/

// Called when time's up, being attacked, said no or is leaving.
void give_back() {
  int burdened, returned;
  object customer, thing;

  customer = this_offer->who;
  burdened = 0;
  returned = 0;

  foreach( thing in this_offer->objects ) {
    if( !thing ) {
      whisper( customer, "Seems thare is a hole in my sack!" );
      continue;
    }
    if( thing->move( customer ) != MOVE_OK ) {
      burdened = 1;
      thing->move( environment( this_object() ) );
      whisper( customer, "I'll just put the " + thing->short() + " down here "
        "since you are too burdened to accept it." );
    } else {
      returned = 1;
    }
  }

  if( burdened && returned ) {
  tell_object( customer, this_object()->a_short() + " returns the other items "
    "to you.\n" );
  } else {
    if( returned )
      tell_object( customer, this_object()->a_short() + " returns the items to "
        "you.\n" );
  }
  tell_room( environment(), this_object()->a_short() + " returns the "
    "items to " +  customer->a_short() + ".\n", ({ customer }) );
  this_offer = 0;
}

string query_current_offer() {
  string str;
  
  str = "\nCustomer: " + ( this_offer->who )->short()  + "\n";
  str += "Amount: " + this_offer->amount + "\n";
  str += "Offer time: " + this_offer->offer_time + "\n";
  str += "Objects: " + query_multiple_short( this_offer->objects );
  return str;
}
// --- END [/mnt/home2/grok/lib/obj/fence.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/state_changer.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/state_changer.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627894   Available: 13575248
Inodes: Total: 5242880    Free: 4960133
10061 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/state_changer.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627894   Available: 13575248
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:56.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * State Changer Inheritable!
 * You can use this to write a device which will change the states of
 * things.
 * @author Terano
 * @started 30/9/02
 */

#include <tasks.h>
#include <effect.h>
#define STATE_CHANGE "/obj/handlers/state_change"

inherit "/obj/vessel";

object *add_list = ({ }); //List of cloned objects.

int query_busy();
int do_action( object *obs );
string parse_message( string message );
string query_classification();

string command;
string process;
string start_mess;
string interim_mess;
string end_mess;

int duration;
int base_bonus;
string skill;
string fail_process;
string end_mess_fail;
string end_mess_abort;
string command_mess;

function start_func;
function end_func; 
function fail_func;
int gp_cost;
string gp_type = "other";

string running_inv_mess;

void create() {
    ::create();
    set_stuck( 1 );
    set_leak_rate( 0 );
    set_weight( 100 );
    set_max_weight( 5000 );
    set_max_volume( 5000 );
    set_hide_cond( 1 );
    this_object()->add_extra_look(this_object());
}

//Set command name! Required.
void set_command( string _command ) { command = _command; }

//Set process name! Required.
void set_process( string _process ) { process = _process; }

//Set fail process name! Optional.
void set_fail_process( string _process ) { fail_process = _process; }

//Start, Interim and End messages are required! Fail messages are optional.
void set_start_message( string message ) { start_mess = message; }
void set_interim_message( string message ) { interim_mess = message; }
void set_end_message( string message ) { end_mess = message; }
void set_fail_message( string message ) { end_mess_fail = message; }
void set_abort_message( string message ) { end_mess_abort = message; }

//Duration! Required.
void set_duration( int _duration ) { duration = _duration; }

//Set add_succeeded_mess for command. Optional!
void set_command_mess( string message ) { command_mess = message; }

//Called when we start, return 1 for 'ok to continue'. Optional!
void set_start_func( function f ) { start_func = f; }

//Called when we end, return 1 for 'ok to continue'. Optional!
void set_end_func( function f ) { start_func = f; }

//Called if we fail.
void set_fail_func( function f) { fail_func = f; }

//Set skill and bonus to use! Optional!
void set_skill( string _skill, int _base_bonus ) { 
    skill = _skill;
    base_bonus = _base_bonus;
}

void set_gp_cost( int gp ) { gp_cost = gp; }

void set_gp_type( string type ) { gp_type = type; }

//Set a message to be displayed as the inventory when it is running.
//This can use the tag $inventory$ for dynamicness.
void set_running_inv_mess( string mess ) { running_inv_mess = mess; }

void init() {
  ::init();
  if ( command ) {
    add_command( command, "all in <direct:object>", (: do_action( $1 ) :) );
  }
}

int do_action( object *obs ) {
int *tmp;

  if ( gp_cost ) {
      if ( this_player()->query_specific_gp( gp_type ) < gp_cost ) 
          return notify_fail( "You are too tired to "+ command +" with the "+ this_object()->the_short() + ".\n" );
      this_player()->adjust_gp( -gp_cost );
  }

  if ( sizeof( tmp = this_object()->effects_matching( query_classification() ) ) )
    return notify_fail( this_object()->the_short() + " is already being used by "+ 
      this_object()->arg_of( tmp[0] )->query_short() +"!\n" );

  if ( !sizeof( all_inventory( this_object() ) ) )
    return notify_fail( "There is nothing to "+ command + ".\n" );

  //If there is a 'start_func' which returns 0, then we stop. We are relying
  //on the start func to show a 'fail message' since we can't really get one.
  if ( functionp( start_func ) ) {
    if ( !evaluate( start_func ) ) {
        debug_printf( "Stopped at start_func\n" );
        return notify_fail( "" );
    
    }
  }

  //Start the process.
  this_object()->add_effect( file_name( this_object() ), this_player() );

  if ( stringp( start_mess ) )
      tell_room( environment(), parse_message(start_mess) );

  if ( stringp( command_mess ) ) {
      this_player()->add_succeeded_mess( this_object(), parse_message( command_mess ), 
          all_inventory( this_object() ) );
    debug_printf( "Setting asm to %s.\n", parse_message( command_mess ) );
  }
  else
      this_player()->add_succeeded_mess( this_object(), "$N "+ command +"$s $I "
        "in $D.\n", all_inventory( this_object() ) );
  return 1;
}

/**
 * Some effect stuff to save on call outs.
 */
object beginning(object apparatus, object tp, int id) {
    apparatus->submit_ee(0, duration, EE_REMOVE);
    apparatus->submit_ee("show_message", ({ 30, 30 }), EE_CONTINUOUS);
    return tp;
} /* beginning() */ 

object show_message(object apparatus, object tp, int id) {    
  if ( stringp( interim_mess ) )
      tell_room(environment(), parse_message(interim_mess) );

  //If we have run out of stuff, END IT NOW.
  if ( !sizeof( all_inventory() ) )
    submit_ee( 0, 0, EE_REMOVE );

  return tp;
} /* merge_effect() */

object end(object apparatus, object tp, int id) {
 object ob;
 int temp;
 int l_bonus = base_bonus;

  //If there is a 'start_func' which returns 0, then we stop. We are relying
  //on the start func to show a 'fail message' since we can't really get one.
  if ( functionp( end_func ) ) {
    if ( !evaluate( end_func ) ) {
        debug_printf( "Stopped at start_func\n" );
        return tp;
    }
  }

  //If we run out of stuff to do, abort!
  if ( !sizeof( all_inventory() ) ) {
    debug_printf( "Aborted due to lack of inventory!\n" );
    if ( stringp( end_mess_abort ) )
      tell_room( environment(), parse_message(end_mess_abort) );
    return tp;
  }

  foreach( object i in all_inventory() ) {
      if ( temp = i->query_property( process + " modifier" ) ) {
          l_bonus += temp;
          debug_printf( "%s difficulty will be modified by %d (%O).\n", 
             process, temp, ob );
      }
  }

  if ( skill ) {
      switch( TASKER->perform_task( tp, skill, l_bonus, TM_COMMAND ) ) {
        case AWARD:
          tell_object( tp, "%^YELLOW%^You learn something new about "+ process +"ing!%^RESET%^\n" );
        case SUCCEED:
          tell_room( environment(), parse_message(end_mess) );
          foreach( object i in all_inventory() ) {
            if (!i)
              continue;
        
              ob = STATE_CHANGE->transform( i, process, tp );
              debug_printf( "Transforming: %O to %O.\n", i, ob );
              if ( ob ) {
                add_list += ({ ob });
                i->move( "/room/rubbish" );
                ob->move( this_object() );
              }
           }
           break;
        default:
            if ( stringp( end_mess ) )
                tell_room( environment(), parse_message(end_mess_fail) );

            if ( functionp( fail_func ) )
                evaluate( fail_func );

            foreach( object i in all_inventory() ) {
              if (!i)
                continue;
        
              ob = STATE_CHANGE->transform( i, fail_process, tp );
              debug_printf( "Transforming: %O to %O.\n", i, ob );
              if ( ob ) {
                add_list += ({ ob });
                i->move( "/room/rubbish" );
                ob->move( this_object() );
              }
           }
           break;  
      }
  }
  else {
    if ( stringp( end_mess ) )
        tell_room( environment(), parse_message(end_mess) );
    foreach( object i in all_inventory() ) {
      if (!i)
        continue;
    
      ob = STATE_CHANGE->transform( i, process, tp );
      debug_printf( "Transforming: %O to %O.\n", i, ob );
      if ( ob ) {
        add_list += ({ ob });
        i->move( "/room/rubbish" );
      }
      //Move the objects and clear the ob_list
      add_list->move( this_object() );
      add_list = ({ });
    }
  }

  return tp;
} /* beginning() */

string query_classification() { return "state.changing."+ process; }

/**
 * Something to mask!
 */
string extra_look( object ob ) {
  return "";
}

string parse_message( string message ) {
  message = replace( message, "$inventory$", query_multiple_short( all_inventory() ) );
  debug_printf( "message is: %s.\n" , message );
  return message;
}

int test_add(object ob, int flag) {

    debug_printf( "Testing add of: %O (%O) in state changer.\n", ob, environment( ob ) );

    //If the food has been cloned by this thingy.
    if ( member_array( ob, add_list ) != -1 ) {
       return ::test_add( ob, flag );
    }

    if ( query_busy() ) {
        tell_object( this_player(), "It might not be wise to add anything to "+ 
            this_object()->the_short() + " while it is in use!\n" );
        return 0;
    }
    return ::test_add( ob, flag );
}


int test_remove( object ob, int flag, mixed dest ) {

    if ( dest && base_name( dest ) == "/room/rubbish" )
        ::test_remove( ob, flag, dest );

    debug_printf( "Testing remove of: %O (%O) in state changer.\n", ob, environment( ob ) );

    if ( query_busy() ) {
        tell_object( this_player(), "It might not be wise to take anything from "+ 
            this_object()->the_short() + " while it is in use!\n" );
        return 0;
    }
    return ::test_remove( ob, flag, dest );
}


string long( string word, int dark ) {
  //If it's running!
  if ( query_busy() ) {
    if ( stringp( running_inv_mess ) )
      return query_long() + parse_message( running_inv_mess );
    else
      return ::long( word, dark );
  }
  return ::long( word, dark );
}

int do_empty(object *dest, string me, string him, string prep) {
  if ( query_busy() ) {
    add_failed_mess( "You can't empty "+ this_object()->short() +" while it is being used.\n" );
    return 0;
  }
  return ::do_empty( dest, me, him, prep );
}

int do_fill(object *to, mixed *args_b, mixed *args_a, mixed *args) {

  if ( query_busy() ) {
    add_failed_mess( "You can't fill anything from "+ this_object()->short() 
      +" while it is being used.\n" );
    return 0;
  }
  return  ::do_fill( to, args_b, args_a, args );
}


int query_busy() { return !!sizeof( this_object()->effects_matching( query_classification() ) ); }
// --- END [/mnt/home2/grok/lib/obj/state_changer.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/furnitures/chairs/chintz_chair.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/furnitures/chairs/chintz_chair.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627892   Available: 13575246
Inodes: Total: 5242880    Free: 4960133
615 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/furnitures/chairs/chintz_chair.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627892   Available: 13575246
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
// Rue 1.2000

inherit "/std/room/furniture/basic";

void setup() {
  set_name( "chair" );
  set_short( "overstuffed chintz chair" );
  add_adjective( ({ "overstuffed", "chintz" }) );
  set_long("This is the type of fat, comfortable chair typically found "
    "in the parlours of fat, comfortable ladies.  The fabric covering "
    "it is bright yellow decorated with a rather aggressive-looking "
    "rose and cabbage design.\n");
  set_allowed_positions(({ "sitting", "meditating", "lounging" }));
  set_allowed_room_verbs(([
    "sitting" : "sits",
  ]));
  set_weight(400);
  set_value(6000);
} /* setup() */
// --- END [/mnt/home2/grok/lib/obj/furnitures/chairs/chintz_chair.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/furnitures/cupboards/pine_kitchen_cupboards.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/furnitures/cupboards/pine_kitchen_cupboards.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627891   Available: 13575245
Inodes: Total: 5242880    Free: 4960133
785 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/furnitures/cupboards/pine_kitchen_cupboards.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627891   Available: 13575245
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
//Only for use in Cwc

inherit "/std/room/furniture/storage";

void setup() {
  
    set_name("cupboard");
    set_short("set of white pine kitchen cupboards");
    add_adjective( ({ "set", "of", "white", "pine", "kitchen" }) );
    set_long("This is a set of kitchen cupboards made from white "
        "pine.  Four sets of doors hide the shelves within, and fluted "
        "columns with triple crowned tops make the structure a little "
        "less plain.  A simple design which still "
        "manages to radiate elegance, this set of cupboards is practial "
        "and functional, but still manages to be pleasing to the senses.\n");

    set_weight(250);
    set_max_weight(100);
    set_value(80000);
    set_allowed_room_verbs((["hanging" : "hangs" ]));

} /* setup() */
// --- END [/mnt/home2/grok/lib/obj/furnitures/cupboards/pine_kitchen_cupboards.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/furnitures/sideboards/marquetry_sideboard.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/furnitures/sideboards/marquetry_sideboard.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627891   Available: 13575245
Inodes: Total: 5242880    Free: 4960133
650 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/furnitures/sideboards/marquetry_sideboard.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627891   Available: 13575245
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:56.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/room/furniture/surface";

void setup() {
  set_name( "sideboard" );
  set_short( "marquetry sideboard" );
  add_alias( "table" );
  add_adjective( ({ "marquetry"}) );
  set_long("This is a long table specifically designed to rest "
    "against a wall.  The marquetry effect on the top surface has been "
    "arranged to represent the Assassins' Guild coat of arms. \n");
  set_allowed_positions(({ "sitting", "lying", "squatting", "standing"}));
  set_allowed_room_verbs((["sitting" : "sits", "standing" : "stands"]));
  set_weight(360);
  set_max_weight(200);
  set_value(100000);
  set_allow_use_internals(1);    
} /* setup() */


// --- END [/mnt/home2/grok/lib/obj/furnitures/sideboards/marquetry_sideboard.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/furnitures/commercial/money_changer.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/furnitures/commercial/money_changer.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627891   Available: 13575245
Inodes: Total: 5242880    Free: 4960133
10750 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/furnitures/commercial/money_changer.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627891   Available: 13575245
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
// Pinkfish
// Started Wed May 30 21:37:15 PDT 2001

inherit "/std/room/furniture/commercial";
#include <money.h>
#include <move_failures.h>

private mapping _money;
private int _cut;
private int _cost;

#define BOARD_TAG "money changer"

void setup() {
   set_name( "counter" );
   set_short( "money changer counter" );
   add_adjective( ({ "money", "changer" } ));
   add_alias("changer");
   set_long( "A box with a bunch of holes in it, it looks like it will "
             "change coins into other types of coins.\n");
   set_allowed_positions(({"sitting", "lying", "kneeling", "meditating"}));
   set_allowed_room_verbs((["sitting" : "sits" ]));
   set_weight(2000);
   set_value(240000);
   // Minimum bid $1.

   add_help_file("money_changer");
   set_commercial_size(5);
   _cut = 10;
   _cost = 400;
   _money = ([ ]);
}

/**
 * This method changes the money into a specific type of thing.
 * @param words the money to change
 * @param type what to change it into
 */
int change( string words, string type ) {
   int val_index;
   int value;
   int value_type;
   int value_unit;
   int value_change;
   int value_num;
   int i;
   string place;
   mixed money;
   object changed;
   object *monies;
   mixed *change;
   mixed *values;
   mixed *money_bits;

   place = query_money_place();
   if ( !place || ( place == "" ) ) {
      place = "default";
   }

   values = (mixed *)MONEY_HAND->query_values_in( place );
   MONEY_OBJECT->set_money_array( values );
   val_index = (int)MONEY_OBJECT->find_best_fit( type );
   if ( val_index == -1 ) {
      return notify_fail( "The coin type \""+ type +
            "\" is not legal tender here.\n" );
   }

   money = (mixed)MONEY_HAND->parse_money( words, this_player(), place );
   if ( intp( money ) ) {
      switch( money ) {
         case NO_MATCH :
            return notify_fail( "You do not have \""+ words +"\".\n" );
         case NO_MONEY :
            return notify_fail( "You can only change money here.\n" );
         default :
            return notify_fail( "You can only change legal tender.\n" );
      }
   }

   /* Pull out the provincial coins otherwise the player gets ripped off */
   if (place != "default")  {
      monies = MONEY_HAND->filter_legal_tender(money, "default");
      if (monies[0])  monies[0]->move(this_player());
      if (!monies[1])  {
         return notify_fail( "You can only change legal tender.\n" );
      }
      money = monies[1];
   }

   //
   // The money bits.
   //
   money_bits = money->query_money_array();

   value = (int)money->query_value_in( place );
   //
   // Check and see if they have any of the type of money which we are trying
   // to change to in the money object.
   //
   i = member_array(values[val_index], money->query_money_array());
   if (i != -1) {
      value_type = money->query_money_array()[i + 1] * values[val_index + 1];
   }
   value_unit = (values[val_index + 1] * (100 + _cut)) / 100;
//printf("%O %O %O\n", value_unit, values[val_index + 1], _cut);
   //
   // Figure out the end value.
   //
   value_change = (value - value_type) % value_unit;
   value_num = (value - value_type) / value_unit;
   value = value_num * values[val_index + 1] + value_type;
   if ( value < values[ val_index + 1 ] ) {
      money->move( this_player() );
      return notify_fail( MONEY_HAND->money_string(money->query_money_array(), place) +
                         " is not even worth one "+ values[ val_index ] +
                       ".\n" );
   }

   //
   // Check and see if they have enough type of that sort of money.
   //
   if (_money[values[val_index]] < value_num) {
      money->move( this_player() );
      add_failed_mess("The money changer does not have enough " +
                      MONEY_HAND->query_main_plural_for(values[val_index]) +
                      " to pay you.\n");
      return 0;
   }

   _money[values[val_index]] -= value_num;
   for (i = 0; i < sizeof(money_bits); i += 2) {
      _money[money_bits[i]] += money_bits[i + 1];
   }

   changed = clone_object( MONEY_OBJECT );
   changed->set_money_array( ({ values[ val_index ],
                                value / values[ val_index + 1 ] }));
   change = (mixed *)MONEY_HAND->create_money_array( value_change, place );
   for (i = 0; i < sizeof(changed); i += 2) {
      _money[change[i]] -= change[i + 1];
   }
   this_player()->add_succeeded_mess(this_object(),
    ({ "You changed "+query_multiple_short(money->half_short( 1 ) ) +
         " into "+
         query_multiple_short( changed->half_short( 1 ) ) +".\n",
       "$N $V some money into "+type+".\n" }), ({ }) );
        
   //write( "You get "+ query_multiple_short( (string)money->half_short( 1 ) ) +
         //" changed into "+
         //query_multiple_short( (string)changed->half_short( 1 ) ) +".\n" );
   money->move( "/room/rubbish" );
   if ( sizeof( change ) ) {
      changed->adjust_money( change );
      write( "You were returned "+ (string)MONEY_HAND->money_string( change )
            +" in change.\n" );
   }
   if ( (int)changed->move( this_player() ) != MOVE_OK ) {
      write( "Unfortunately, you're too heavily burdened to accept all that "+
            "money, so it's put on the table for you.\n" );
      changed->move( this_object() );
   }
   return 1;
} /* change() */

string query_main_status(int hint) {
   string type;
   string place;
   int num;
   string str;

   place = query_money_place();
   str = "$I$0=Money Changer:\n";
   str += "$I$6=   Percentage cut " + _cut + "%\n";
/*
   str += "$I$6=   Cost per use " +
          MONEY_HAND->money_value_string(_cost, place) + "\n";
 */
   foreach (type, num in _money) {
      str += "$I$6=   " + num + " " + type + "\n";
   }

   return str;
} /* query_main_status() */

/**
 * This method sets the ante amounts.
 * @param str the amount string
 * @param max_bet if it a max or min bet to set
 */
int do_set_cost(string str) {
   string place;
   int value;

   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to change the paramaters of "
                   "$D.\n");
      return 0;
   }
   place = query_money_place();
   value = MONEY_HAND->value_from_string(str, place);
   if (!value) {
      add_failed_mess("Unable to parse the string " + str + ".\n");
      return 0;
   }
   _cost = value;
   add_succeeded_mess("$N set$s the cost of each use of $D to " +
          MONEY_HAND->money_value_string(value, place) + ".\n");

   return 1;
} /* do_set_cost() */

/**
 * This method sets the ante amounts.
 * @param str the amount string
 * @param max_bet if it a max or min bet to set
 */
int do_set_cut(int number) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to change the paramaters of "
                   "$D.\n");
      return 0;
   }

   if (number < 0) {
      add_failed_mess("You need to set the cut to a number greator than 0.\n");
      return 0;
   }

   if (number > 500) {
      add_failed_mess("You need to set the cut to a number less than 500.\n");
      return 0;
   }

   _cut = number;
   add_succeeded_mess("$N set$s the cut for $D to " + _cut + "%.\n");
   return 1;
} /* do_set_cut() */

/**
 * This method deposits coins into the changer.
 * @param str the amount string
 * @param max_bet if it a max or min bet to set
 */
int do_deposit(int num, string str) {
   mixed* values;
   int i;

   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to change the paramaters of "
                   "$D.\n");
      return 0;
   }

   values = this_player()->query_money_array();
   for (i = 0; i < sizeof(values); i += 2) {
      if (lower_case(values[i]) == lower_case(str)) {
         break;
      }
   }
   //i = member_array(str, values);
   if (i >= sizeof(values)) {
      add_failed_mess("You do not have any " + str + " to deposit.\n");
      return 0;
   }

   if (values[i + 1] < num) {
      add_failed_mess("You do not have " + num + " of " + values[i] +
                      ", you only have " + values[i+1] + ".\n");
      return 0;
   }

   _money[values[i]] += num;
   this_player()->adjust_money(-num, values[i]);

   add_succeeded_mess("$N deposit$s " + num + " of " + str + " in $D.\n");
   return 1;
} /* do_deposit() */

/**
 * This method withdraws money from the changer.
 * @param str the amount string
 * @param max_bet if it a max or min bet to set
 */
int do_withdraw(int num, string str) {
   string tmp;
   int bing;

   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to change the paramaters of "
                   "$D.\n");
      return 0;
   }

   foreach (tmp, bing in _money) {
      if (lower_case(str) == lower_case(tmp)) {
         if (num > bing) {
            add_failed_mess("The $D does not have " +
                            num + " of " + tmp + " it only has " +
                            bing + ".\n");
            str = tmp;
         }
      }
   }

   if (!_money[str]) {
      add_failed_mess("You do not appear to have any " + str + " in $D.\n");
      return 0;
   }

   _money[str] -= num;
   if (!_money[str]) {
      map_delete(_money, str);
   }
   this_player()->adjust_money(num, str);

   add_succeeded_mess("$N withdraw$s " + num + " of " + str + " from $D.\n");
   return 1;
} /* do_deposit() */

void init() {
   commercial::init();
   add_command("change", "<string'money'> into <string'type'> on <direct:object>",
                  (: change($4[0], $4[1]) :));
   if (environment()->is_allowed(this_player()->query_name())) {
      add_command("set", "cut <number'percentage'> on <direct:object>",
                  (: do_set_cut($4[0]) :));
      add_command("deposit", "<number> of <string'type'> on <direct:object>",
                  (: do_deposit($4[0], $4[1]) :));
      add_command("withdraw", "<number> of <string'type'> on <direct:object>",
                  (: do_withdraw($4[0], $4[1]) :));
/*
      add_command("set", "cost of use <string'amount'> on <direct:object>",
                  (: do_set_cost($4[0]) :));
 */
   }
} /* init() */

/** @ignore yes */
mapping query_dynamic_auto_load() {
   mapping map;

   map = commercial::query_dynamic_auto_load();
   add_auto_load_value(map, BOARD_TAG, "cut", _cut);
   add_auto_load_value(map, BOARD_TAG, "money", _money);
   add_auto_load_value(map, BOARD_TAG, "cost", _cost);
   return map;
} /* query_dynamic_auto_load() */

/** @ignore yes */
void init_dynamic_arg(mapping map, object player) {
   commercial::init_dynamic_arg(map, player);

   _cut = query_auto_load_value(map, BOARD_TAG, "cut");
   _money = query_auto_load_value(map, BOARD_TAG, "money");
   _cost = query_auto_load_value(map, BOARD_TAG, "cost");
} /* init_dynamic_arg() */
// --- END [/mnt/home2/grok/lib/obj/furnitures/commercial/money_changer.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/furnitures/commercial/newspaper_archive_box.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/furnitures/commercial/newspaper_archive_box.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627888   Available: 13575242
Inodes: Total: 5242880    Free: 4960133
8309 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/furnitures/commercial/newspaper_archive_box.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627888   Available: 13575242
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * A dispenser for papers.  It will sell papers to people for money!
 * @author Pinkfish
 * @started Thu May 24 15:51:25 PDT 2001
 */
inherit "/std/room/furniture/commercial";
#include <room/newspaper.h>
#include <money.h>
#include <move_failures.h>

#define BOARD_TAG "newspaper box"

private string _paper;
private int _cost;
private int _back_issue_cost;

void setup() {
   set_name("box");
   set_short("newspaper archive box");
   add_adjective(({ "archive", "box" }));
   add_help_file("newspaper_archive_box");
   set_allowed_positions(({"sitting", "lying", "kneeling", "meditating"}));
   set_allowed_room_verbs((["sitting" : "sits", "standing" : "stands" ]));
   set_value(2700);
   set_commercial_size(5);
   reset_get();
} /* setup() */

/**
 * This sets the current paper that will be dispensed.
 * @param paper the paper to dispense
 */
void set_paper(string paper) {
   string place;
   string* bits;

   if (!paper) {
      return ;
   }
   _paper = paper;

   place = query_money_place();
   set_short(_paper + " box");
   set_long("This is a very large battered looking metal box that is full "
            "of old and new copies of " +
            (lower_case(paper)[0..3] == "the "?"":"the ") +
            paper + ".  There is a door on the front you could pull open "
            "beside which is small white writing saying " +
            MONEY_HAND->money_value_string(_cost, place) + " for the current "
            "issue and " +
            MONEY_HAND->money_value_string(_back_issue_cost, place) +
            " for back issues.\n");
   if (lower_case(_paper)[0..3] == "the ") {
      add_property("determinate", "");
   }
   bits = explode(lower_case(_paper), " ");
   add_adjective(bits);
} /* set_paper() */

/** @ignore yes */
int do_buy(int issue) {
   int paper_cost;
   int cost;
   int edition;
   string place;
   object ob;
   int *editions;

   place = query_money_place();
   if (issue == -1) {
      edition = NEWSPAPER_HANDLER->query_last_edition_num(_paper);
      if (!edition) {
         add_failed_mess("There is no edition to buy.\n");
         return 0;
      }
      cost = _cost;
      paper_cost = (NEWSPAPER_HANDLER->query_paper_cost(_paper) * 2) / 3;
   } else {
      edition = NEWSPAPER_HANDLER->query_last_edition_num(_paper);
      if (issue <= 0 || issue > edition) {
         add_failed_mess("The issue numberm ust be between 1 and " +
                         edition + ".\n");
         return 0;
      }
      edition = issue;
      paper_cost = NEWSPAPER_HANDLER->query_paper_cost(_paper) * 2;
      cost = _back_issue_cost;
   }

   if (this_player()->query_value_in(place) < cost) {
      add_failed_mess("You do not have enough money to pay for " +
                      _paper + ", you need " +
                      MONEY_HAND->money_value_string(cost, place) +
                      ".\n");
      return 0;
   }

   this_player()->pay_money(MONEY_HAND->create_money_array(cost, place), place);
   adjust_float(cost - paper_cost);

   ob = clone_object("/obj/misc/newspaper");
   ob->set_paper(_paper);
   ob->set_edition(edition);
   if (ob->move(this_player()) != MOVE_OK) {
      ob->move(environment(this_player()));
      write("Unable to move the paper into your inventory, putting it on "
            "the ground.\n");
   }

   editions = this_player()->query_property("Paper " + _paper);
   if (!editions) {
      editions = ({ });
   }
   if (member_array(edition, editions) == -1) {
      editions += ({ edition });
      this_player()->add_property("Paper " + _paper, editions);
      // We only keep track of unique sales.
      NEWSPAPER_HANDLER->add_edition_paper_sold(_paper, edition,
                        NEWSPAPER_HANDLER->query_paper_cost(_paper));
   } else {
      NEWSPAPER_HANDLER->add_edition_revenue(_paper, edition,
                        NEWSPAPER_HANDLER->query_paper_cost(_paper));
   }

   add_succeeded_mess("$N pull$s a newspaper from $D.\n");
   return 1;
} /* do_buy() */

/** @ignore yes */
string query_main_status(int hints) {
   string ret;
   int paper_cost;
   int back_issue_cost;
   string place;

   place = query_money_place();
   paper_cost = NEWSPAPER_HANDLER->query_paper_cost(_paper);
   back_issue_cost = paper_cost * 2;
   paper_cost = (paper_cost * 2) / 3;
   ret = "$I$0=" + the_short() + ":\n";
   ret +=   "$I$6=   Revenue                        : " +
          MONEY_HAND->money_value_string(query_revenue(), place) +
          "\n$I$6=   Cost from publisher            : " +
          MONEY_HAND->money_value_string(paper_cost, place) +
          "\n$I$6=   Sale price                     : " +
          MONEY_HAND->money_value_string(_cost, place) +
          "\n$I$6=   Back Issue Cost from publisher : " +
          MONEY_HAND->money_value_string(back_issue_cost, place) +
          "\n$I$6=   Back Issue Sale price          : " +
          MONEY_HAND->money_value_string(_back_issue_cost, place) +
          "\n";
   if (hints) {
      ret += "$I$6=      set cost <amount> on <box>\n";
   }
   return ret;
} /* query_main_status() */

/** @ignore yes */
int do_set_cost(string amount, int back_issue) {
   int amt;
   string place;

   place = query_money_place();

   amt = MONEY_HAND->value_from_string(amount, place);
   if (amt <= 0) {
      add_failed_mess("The value " + amount + " is invalid.\n");
      return 0;
   }

   if (back_issue) {
      _back_issue_cost = amt;
   } else {
      _cost = amt;
   }
   set_long("This is a very large battered looking metal box that is full "
            "of old and new copies of " +
            (lower_case(_paper)[0..3] == "the "?"":"the ") +
            _paper + ".  There is a door on the front you could pull open "
            "beside which is small white writing saying " +
            MONEY_HAND->money_value_string(_cost, place) + " for the current "
            "issue and " +
            MONEY_HAND->money_value_string(_back_issue_cost, place) +
            " for back issues.\n");
   if (back_issue) {
      add_succeeded_mess("$N set$s the cost to buy back issue of the paper "
                         "from $D to " +
                         MONEY_HAND->money_value_string(amt, place) + ".\n");
   } else {
      add_succeeded_mess("$N set$s the cost to buy papers from $D to " +
                         MONEY_HAND->money_value_string(amt, place) + ".\n");
   }
   return 1;
} /* do_set_cost() */

void init() {
   add_command("buy", "issue <number> from <direct:object>",
               (: do_buy($4[0]) :));
   add_command("pull", "[door] [on] <direct:object>", (: do_buy(-1) :));
   add_command("pull", "open <direct:object>", (: do_buy(-1) :));

   if (is_allowed(this_player()->query_name())) {
      add_command("set", "cost <string'amount'> on <direct:object>",
                  (: do_set_cost($4[0], 0) :));
      add_command("set", "back issue cost <string'amount'> on <direct:object>",
                  (: do_set_cost($4[0], 1) :));
   }

   ::init();
} /* init() */

/** @ignore yes */
mapping query_commercial_options() {
   mapping ret;
   string paper;

   ret = ([ ]);
   foreach (paper in NEWSPAPER_HANDLER->query_all_papers()) {
      ret[paper] = 0;
   }
   return ([ "paper" : ret ]);
} /* query_commercial_options() */

/** @ignore yes */
void set_commercial_option(string type, string name) {
   switch (type) {
   case "paper" :
      _cost = NEWSPAPER_HANDLER->query_paper_cost(name);
      _back_issue_cost = NEWSPAPER_HANDLER->query_paper_cost(name) * 3;
      call_out("set_paper", 1, name);
      break;
   }
} /* set_commercial_option() */

/** @ignore yes */
mapping query_dynamic_auto_load() {
   mapping map;

   map = commercial::query_dynamic_auto_load();
   add_auto_load_value(map, BOARD_TAG, "cost", _cost);
   add_auto_load_value(map, BOARD_TAG, "paper", _paper);
   add_auto_load_value(map, BOARD_TAG, "back cost", _back_issue_cost);
   return map;
} /* query_dynamic_auto_load() */

/** @ignore yes */
void init_dynamic_arg(mapping map, object player) {
   string name;

   commercial::init_dynamic_arg(map, player);

   _cost = query_auto_load_value(map, BOARD_TAG, "cost");
   _back_issue_cost = query_auto_load_value(map, BOARD_TAG, "back cost");
   name = query_auto_load_value(map, BOARD_TAG, "paper");
   call_out("set_paper", 1, name);
} /* init_dynamic_arg() */
// --- END [/mnt/home2/grok/lib/obj/furnitures/commercial/newspaper_archive_box.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/furnitures/commercial/newspaper_box.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/furnitures/commercial/newspaper_box.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627885   Available: 13575239
Inodes: Total: 5242880    Free: 4960133
6348 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/furnitures/commercial/newspaper_box.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627885   Available: 13575239
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * A dispenser for papers.  It will sell papers to people for money!
 * @author Pinkfish
 * @started Thu May 24 15:51:25 PDT 2001
 */
inherit "/std/room/furniture/commercial";
#include <room/newspaper.h>
#include <money.h>
#include <move_failures.h>

#define BOARD_TAG "newspaper box"

private string _paper;
private int _cost;

void setup() {
   set_name("box");
   set_short("newspaper box");
   add_adjective("box");
   add_help_file("newspaper_box");
   set_allowed_positions(({"sitting", "lying", "kneeling", "meditating"}));
   set_allowed_room_verbs((["sitting" : "sits", "standing" : "stands" ]));
   set_value(900);
   set_commercial_size(1);
   reset_get();
} /* setup() */

/**
 * This sets the current paper that will be dispensed.
 * @param paper the paper to dispense
 */
void set_paper(string paper) {
   string place;
   string* bits;

   if (!paper) {
      return ;
   }
   _paper = paper;

   place = query_money_place();
   set_short(_paper + " box");
   set_long("This is a battered looking metal box that is full of copies of " +
            (lower_case(paper)[0..3] == "the "?"":"the ") +
            paper + ".  There is a door on the front you could pull open "
            "beside which is small white writing saying " +
            MONEY_HAND->money_value_string(_cost, place) + ".\n");
   if (lower_case(_paper)[0..3] == "the ") {
      add_property("determinate", "");
   }
   bits = explode(lower_case(_paper), " ");
   add_adjective(bits);
} /* set_paper() */

/** @ignore yes */
int do_buy() {
   int paper_cost;
   int cost;
   int edition;
   string place;
   object ob;
   int *editions;

   place = query_money_place();
   cost = _cost;
   paper_cost = (NEWSPAPER_HANDLER->query_paper_cost(_paper) * 2) / 3;
   edition = NEWSPAPER_HANDLER->query_last_edition_num(_paper);
   if (!edition) {
      add_failed_mess("There is no edition to buy.\n");
      return 0;
   }

   if (this_player()->query_value_in(place) < cost) {
      add_failed_mess("You do not have enough money to pay for " +
                      _paper + ", you need " +
                      MONEY_HAND->money_value_string(cost, place) +
                      ".\n");
      return 0;
   }

   this_player()->pay_money(MONEY_HAND->create_money_array(cost, place), place);
   adjust_float(cost - paper_cost);

   ob = clone_object("/obj/misc/newspaper");
   ob->set_paper(_paper);
   ob->set_edition(edition);
   if (ob->move(this_player()) != MOVE_OK) {
      ob->move(environment(this_player()));
      write("Unable to move the paper into your inventory, putting it on "
            "the ground.\n");
   }

   editions = this_player()->query_property("Paper " + _paper);
   if (!editions) {
      editions = ({ });
   }
   if (member_array(edition, editions) == -1) {
      editions += ({ edition });
      this_player()->add_property("Paper " + _paper, editions);
      // We only keep track of unique sales.
      NEWSPAPER_HANDLER->add_edition_paper_sold(_paper, edition,
                        NEWSPAPER_HANDLER->query_paper_cost(_paper));
   } else {
      NEWSPAPER_HANDLER->add_edition_revenue(_paper, edition,
                        NEWSPAPER_HANDLER->query_paper_cost(_paper));
   }

   add_succeeded_mess("$N pull$s a newspaper from $D.\n");
   return 1;
} /* do_buy() */

/** @ignore yes */
string query_main_status(int hints) {
   string ret;
   int paper_cost;
   string place;

   place = query_money_place();
   paper_cost = (NEWSPAPER_HANDLER->query_paper_cost(_paper) * 2) / 3;
   ret = the_short() + ":\n";
   ret +=   "$I$6=   Revenue             : " +
          MONEY_HAND->money_value_string(query_revenue(), place) +
          "\n$I$6=   Cost from publisher : " +
          MONEY_HAND->money_value_string(paper_cost, place) +
          "\n$I$6=   Sale price          : " +
          MONEY_HAND->money_value_string(_cost, place) +
          "\n";
   if (hints) {
      ret += "$I$6=      set cost <amount> on <box>\n";
   }
   return ret;
} /* query_main_status() */

/** @ignore yes */
int do_set_cost(string amount) {
   int amt;
   string place;

   place = query_money_place();

   amt = MONEY_HAND->value_from_string(amount, place);
   if (amt <= 0) {
      add_failed_mess("The value " + amount + " is invalid.\n");
      return 0;
   }

   _cost = amt;
   set_long("This is a battered looking metal box that is full of copies of " +
            (lower_case(_paper)[0..3] == "the "?"":"the ") +
            _paper + ".  There is a door on the front you could pull open "
            "beside which is small white writing saying " +
            MONEY_HAND->money_value_string(_cost, place) + ".\n");
   add_succeeded_mess("$N set$s the cost of buy papers from $D to " +
                      MONEY_HAND->money_value_string(amt, place) + ".\n");
   return 1;
} /* do_set_cost() */

void init() {
   add_command("buy", "paper from <direct:object>", (: do_buy() :));
   add_command("pull", "[door] [on] <direct:object>", (: do_buy() :));
   add_command("pull", "open <direct:object>", (: do_buy() :));

   if (is_allowed(this_player()->query_name())) {
      add_command("set", "cost <string'amount'> on <direct:object>",
                  (: do_set_cost($4[0]) :));
   }

   ::init();
} /* init() */

/** @ignore yes */
mapping query_commercial_options() {
   mapping ret;
   string paper;

   ret = ([ ]);
   foreach (paper in NEWSPAPER_HANDLER->query_all_papers()) {
      ret[paper] = 0;
   }
   return ([ "paper" : ret ]);
} /* query_commercial_options() */

/** @ignore yes */
void set_commercial_option(string type, string name) {
   switch (type) {
   case "paper" :
      _cost = NEWSPAPER_HANDLER->query_paper_cost(name);
      call_out("set_paper", 1, name);
      break;
   }
} /* set_commercial_option() */

/** @ignore yes */
mapping query_dynamic_auto_load() {
   mapping map;

   map = commercial::query_dynamic_auto_load();
   add_auto_load_value(map, BOARD_TAG, "cost", _cost);
   add_auto_load_value(map, BOARD_TAG, "paper", _paper);
   return map;
} /* query_dynamic_auto_load() */

/** @ignore yes */
void init_dynamic_arg(mapping map, object player) {
   string name;

   commercial::init_dynamic_arg(map, player);

   _cost = query_auto_load_value(map, BOARD_TAG, "cost");
   name = query_auto_load_value(map, BOARD_TAG, "paper");
   call_out("set_paper", 1, name);
} /* init_dynamic_arg() */
// --- END [/mnt/home2/grok/lib/obj/furnitures/commercial/newspaper_box.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/furnitures/commercial/pickler.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/furnitures/commercial/pickler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627884   Available: 13575238
Inodes: Total: 5242880    Free: 4960133
4587 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/furnitures/commercial/pickler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627884   Available: 13575238
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * @author Pinkfish
 * Started Mon Jun 18 20:15:58 PDT 2001
 */

inherit "/std/room/furniture/commercial";

#include <money.h>

#define FEE_PER_USE 40

#define BOARD_TAG "pickler"

private int _revenue;
private int _cost;

void setup() {
   set_name( "pickler" );
   set_short( "pickler" );
   set_long( "A small wooden box with a handle on it, it has some words "
             "written on it.\n");
   add_read_mess("Pickler, pull for results", 0, "common");
   set_allowed_positions(({"sitting", "lying", "kneeling", "meditating"}));
   set_allowed_room_verbs((["sitting" : "sits" ]));
   set_weight(2000);
   set_value(240000);
   add_help_file("pickler");

   set_commercial_size(2);
   set_commercial_type("utility");
   set_shop_use_types(({ "pickler" }));
   _cost = 80;
}

int do_pickle(object* obs) {
   object* pickleable;
   string place;
   int amt;
   int here_amt;

   if (!is_open_for("pickler", this_player()->query_name())) {
      add_failed_mess("The pickler is not open.\n");
      return 0;
   }

   place = query_money_place();
   pickleable = filter(obs, (: !$1->query_cured() &&
                               ($1->query_property("cureable") ||
                                $1->query_decay_speed()) :));
   if (!sizeof(pickleable)) {
      add_failed_mess("You cannot pickle any of " +
                      query_multiple_short(obs) + ".\n");
      return 0;
   }

   amt = sizeof(pickleable) * _cost;
   here_amt = amt - sizeof(pickleable) * FEE_PER_USE;
   if (here_amt < 0) {
      if (query_float() < -here_amt) {
          add_failed_mess(environment()->the_short() + " does not "
                          "have enough money to pickle anything.\n");
          return 0;
      }
   }

   if (this_player()->query_value_in(place) < amt) {
      add_failed_mess("You do not have the needed " +
                      MONEY_HAND->money_value_string(amt, place) +
                      " to pay for $I to be pickled.\n", pickleable);
      return 0;
   }

   this_player()->pay_money(MONEY_HAND->create_money_array(amt, place), place);
   pickleable->do_cure();
   adjust_float(here_amt);
   _revenue += here_amt;
   add_succeeded_mess("$N pickle$s $I on $D.\n", pickleable);
   return 1;
} /* do_pickle() */

int do_set_cost(string amount) {
   int amt;
   string place;

   place = query_money_place();

   amt = MONEY_HAND->value_from_string(amount, place);
   if (amt <= 0) {
      add_failed_mess("The value " + amount + " is invalid.\n");
      return 0;
   }

   _cost = amt;
   add_succeeded_mess("$N set$s the cost of using $D to " +
                      MONEY_HAND->money_value_string(amt, place) + ".\n");
   return 1;
} /* do_set_cost() */

string query_main_status(int hint) {
   string place;

   place = query_money_place();
   return the_short() + " status:\n"
          "\n$I$6=   Fee Per Use : " +
              MONEY_HAND->money_value_string(FEE_PER_USE, place) + " (fixed)"
          "\n$I$6=   Cost Per Use: " +
              MONEY_HAND->money_value_string(_cost, place) +
          "\n$I$6=   Profit      : " +
             MONEY_HAND->money_value_string(_revenue, place) + "\n";
} /* query_main_status() */

int do_stats() {
   string ret;

   ret = query_main_status(0);
   write(ret);
   add_succeeded_mess("");
   return 1;
} /* do_stats() */

void init() {
   commercial::init();
   add_command("use", "<direct:object> to [pickle] <indirect:object>",
               (: do_pickle :));
   add_command("use", "<direct:object> with <indirect:object>",
               (: do_pickle :));
   add_command("pickle", "<indirect:object> with <direct:object>",
               (: do_pickle :));
   add_command("pull", "[handle] [on] <direct:object> with <indirect:object>",
               (: do_pickle :));
   if (environment()->is_allowed(this_player()->query_name())) {
      add_command("status", "<direct:object>",
                  (: do_stats() :));
      add_command("set", "cost <string'cost'> on <direct:object>",
                  (: do_set_cost($4[0]) :));
   }
} /* init() */

/** @ignore yes */
mapping query_dynamic_auto_load() {
   mapping map;

   map = commercial::query_dynamic_auto_load();
   add_auto_load_value(map, BOARD_TAG, "revenue", _revenue);
   add_auto_load_value(map, BOARD_TAG, "cost", _cost);
   return map;
} /* query_dynamic_auto_load() */

/** @ignore yes */
void init_dynamic_arg(mapping map, object player) {
   commercial::init_dynamic_arg(map, player);

   _revenue = query_auto_load_value(map, BOARD_TAG, "revenue");
   _cost = query_auto_load_value(map, BOARD_TAG, "cost");
} /* init_dynamic_arg() */
// --- END [/mnt/home2/grok/lib/obj/furnitures/commercial/pickler.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/furnitures/commercial/medium_shop.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/furnitures/commercial/medium_shop.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627882   Available: 13575236
Inodes: Total: 5242880    Free: 4960133
568 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/furnitures/commercial/medium_shop.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627882   Available: 13575236
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
// Pinkfish
// Started Wed May 30 21:37:15 PDT 2001

inherit "/std/room/furniture/shop_base";

void setup() {
   set_name( "counter" );
   set_short( "medium shop counter" );
   add_adjective( ({ "medium", "shop" } ));
   set_long( "The smooth polished surface of the medium counter shines and "
             "glows at you.\n");
   set_allowed_positions(({"sitting", "standing" }));
   set_allowed_room_verbs((["sitting" : "sits", "standing" : "stands" ]));
   set_weight(1000);
   set_value(1200000);
   set_maximum_inventory_size(100);
   set_commercial_size(60);
}
// --- END [/mnt/home2/grok/lib/obj/furnitures/commercial/medium_shop.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/furnitures/commercial/postal.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/furnitures/commercial/postal.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627882   Available: 13575236
Inodes: Total: 5242880    Free: 4960133
1734 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/furnitures/commercial/postal.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627882   Available: 13575236
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * @author Pinkfish
 * Started Mon Jun 18 20:15:58 PDT 2001
 */

inherit "/std/room/furniture/commercial";

#include <money.h>
#include <mail.h>

#define BOARD_TAG "postal"

int _num_uses;

void setup() {
   set_name( "counter" );
   set_short( "postal counter" );
   add_adjective("postal");
   set_long( "A wooden counter that looks like a place you could write "
             "and read mail.\n");
   set_allowed_positions(({"sitting", "lying", "kneeling", "meditating"}));
   set_allowed_room_verbs((["sitting" : "sits" ]));
   set_weight(2000);
   set_value(6400000);
   add_help_file("postal");

   set_commercial_size(25);
   set_commercial_type("utility");
   set_shop_use_types(({ "pickler" }));
}

int do_mail(string to) {
   if (MAIL_TRACK->mail(to)) {
      _num_uses++;
      return 1;
   }
   return 0;
} /* do_pickle() */

string query_main_status(int hint) {
   string place;

   place = query_money_place();
   return the_short() + " status:\n"
          "\n$I$6=   Number of  uses : " + _num_uses + "\n";
} /* query_main_status() */

void init() {
   commercial::init();
   add_command("mail", "<string'to'>",
               (: do_mail($4[0]) :));
   add_command("mail", "[handle] [on] <direct:object> with <indirect:object>",
               (: do_mail(0) :));
} /* init() */

/** @ignore yes */
mapping query_dynamic_auto_load() {
   mapping map;

   map = commercial::query_dynamic_auto_load();
   add_auto_load_value(map, BOARD_TAG, "uses", _num_uses);
   return map;
} /* query_dynamic_auto_load() */

/** @ignore yes */
void init_dynamic_arg(mapping map, object player) {
   commercial::init_dynamic_arg(map, player);

   _num_uses = query_auto_load_value(map, BOARD_TAG, "uses");
} /* init_dynamic_arg() */
// --- END [/mnt/home2/grok/lib/obj/furnitures/commercial/postal.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/furnitures/commercial/filing_cabinet.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/furnitures/commercial/filing_cabinet.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627881   Available: 13575235
Inodes: Total: 5242880    Free: 4960133
582 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/furnitures/commercial/filing_cabinet.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627881   Available: 13575235
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/room/furniture/document_handler";

void setup() {
   set_short("filing cabinet");
   set_name("cabinet");
   add_alias("filing");
   set_long("A big grey wooden box with draws that slide in and out.  It "
            "looks like it could hold bunches of documents, nicely order "
            "and available for quick retrieval.");

   set_allowed_positions(({"sitting", "lying", "kneeling", "meditating"}));
   set_allowed_room_verbs((["sitting" : "sits" ]));
   set_weight(2000);
   set_value(240000);

   set_commercial_size(5);
   set_commercial_type("utility");
}
// --- END [/mnt/home2/grok/lib/obj/furnitures/commercial/filing_cabinet.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/furnitures/commercial/blackboard.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/furnitures/commercial/blackboard.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627881   Available: 13575235
Inodes: Total: 5242880    Free: 4960133
4093 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/furnitures/commercial/blackboard.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627881   Available: 13575235
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*
    Warrior's Guild Blackboard
    For The Guildmaster's Shop
    
    Suggested by Lanfear.
    Wrytten by Drakkos Thee Creator
    16/06/2000
*/

#include <language.h>

#define DEFAULT_LANGUAGE "morporkian"
#define BOARD_TAG "blackboard"

inherit "/std/room/furniture/commercial";

int do_write( string language );

void setup() {
    set_name ("blackboard");
    set_short ("blackboard");
    add_alias (({"board", "sign"}));
    set_long ("The residue of faded chalk-dust and long forgotten "
        "doodles lies heavily on the blackboard.  The grain of the "
        "board is worn and slightly mottled with age, hinting at "
        "a long and dignified history of classrooms and university "
        "lecterns.  Or perhaps just hinting at cheap wood and "
        "bad upkeep.\n");
    set_allowed_room_verbs( (["standing" : "stands",
                            "hanging"  : "hangs"]) );
    set_commercial_size(1);
    set_weight(2000);
    set_value(240000);
}

void init() {
    add_command ("write", "[on] <direct:object'blackboard'> in <string'language'>", 
        (: do_write($4[1]) :) );
    add_command ("clean", "<direct:object>");
}    

string query_readable_message(object player, int ignore_labels) {
    if (!sizeof(query_read_mess())) {
        return "A few random letters that escaped cleaning can be seen on "
            "the blackboard";
    }
    
    return ::query_readable_message(player, ignore_labels);    
} /* query_readable_message() */ 


int do_clean() {
    if (!is_allowed (this_player()->query_name())) {
        this_player()->add_failed_mess (this_object(), "You cannot clean " 
            +  capitalize (query_owner()) + "'s blackboard!\n", ({ }));
        return 0;
    }
    
    /* Clear the read mess */ 
    set_read_mess( 0 );
    
    return 1;
}

string find_words( string language ) {
    string words;
    
    words = implode( map( filter( query_read_mess(), 
        (: $1[READ_LANG] == $(language) :) ), (: $1[READ_MESS] :) ), "\n" );
    
    return words;
} /* find_words() */

int do_write(string language)
{
    string existing_text;
    
    if (!is_allowed (this_player()->query_name())) {
        this_player()->add_failed_mess (this_object(), "You cannot write on " 
            +  capitalize (query_owner()) + "'s blackboard!\n", ({ }));
        return 0;
    }
    
    language = lower_case( language ); 
    
    if ( !this_player()->query_skill(
        LANGUAGE_HAND->query_language_written_skill(language)) ) {
        this_player()->add_failed_mess(this_object(), "You can't write in " +
           language + ".\n" );
        return -1;
    }
        
    /* Find all the existing words in the language. */ 
    
    existing_text = find_words( language ); 
                    
    this_player()->do_edit(existing_text, "blackboard_text", 
        this_object(), 0, language);
    
    this_player()->add_succeeded_mess (this_object(), "$N find$s a handy "
        "piece of chalk and start$s to write on the blackboard.\n", ({ }));
    return 1;

}

void blackboard_text(string text, string language)
{

    if (!text)
    {
        tell_room (environment (this_object()), this_player()->one_short()
            + " steps back from the blackboard without making any "
            "changes.\n", this_player());
        tell_object (this_player(), "Okay, nothing has been changed.\n");
        return;
    }
    
    /* Remove the existing text. */ 
    
    set_read_mess( filter( query_read_mess(), 
        (: $1[READ_LANG] != $(language) :) ) );
    
    add_read_mess( text, "chalk", language ); 
    
    tell_room(environment (this_object()), this_player()->one_short() 
            + " finishes writing on the blackboard.\n", this_player());
}

void init_dynamic_arg(mapping map) {
   string my_words;
   
   commercial::init_dynamic_arg(map, player);
   
   my_words = query_auto_load_value(map, BOARD_TAG, "words");
   
   if ( stringp(my_words) ) {
       add_read_mess(my_words, "chalk", DEFAULT_LANGUAGE);
   }
     set_read_mess( filter( query_read_mess(), (: $1[READ_LANG] != "common" :) ) );
}
// --- END [/mnt/home2/grok/lib/obj/furnitures/commercial/blackboard.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/furnitures/commercial/poll_data.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/furnitures/commercial/poll_data.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627880   Available: 13575234
Inodes: Total: 5242880    Free: 4960133
4128 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/furnitures/commercial/poll_data.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627880   Available: 13575234
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
// Pinkfish
// Started Wed May 30 21:37:15 PDT 2001

inherit "/std/room/inherit/voting_room";
inherit "/std/room/furniture/commercial";

#include <money.h>

#define BOARD_TAG "poll data"
#define POLL_DATA_MAXIMUM_RESULTS 10

private int _allow_open_voting;
private string* _finished_votes;

void finish_vote(string type, string description, string* choices,
                 mapping votes, string* voted);


void create() {
   voting_room::create();
   commercial::create();
   _finished_votes = ({ });
} /* create() */

void setup() {
   set_name( "poll" );
   set_short( "opinion poll" );
   add_adjective( ({ "opinion" } ));
   set_long( "A box with a bunch of pieces paper sitting on it.  It seems "
             "to be keeping a tally of something.\n");
   set_allowed_positions(({"sitting", "lying", "kneeling", "meditating"}));
   set_allowed_room_verbs((["sitting" : "sits" ]));
   set_weight(2000);
   set_value(240000);
   set_commercial_size(2);
   set_commercial_type("misc");
   set_shop_use_types(({ "poll add", "poll vote" }));

   set_completion_action((: finish_vote :));
   set_no_elections(1);
   set_vote_conditions((: is_open_for("poll vote", $1->query_name()) :));

   add_help_file("poll_data");
}

/** @ignore yes */
int load_me() {
   if (!query_commercial_id()) {
      setup_new_commercial_id();
   }
   set_save_file(query_save_dir() + query_commercial_id());
   if (!_finished_votes) {
      _finished_votes = ({ });
   }
} /* do_load() */

int do_show_results() {
   string ret;
   string result;

   ret = "";
   foreach (result in _finished_votes) {
      ret += result + "\n\n";
   }
   write("$P$Vote Archive$P$" + ret);
   add_succeeded_mess("");
   return 1;
}

int do_create_vote(string choices) {
   if (!is_open_for("poll add", this_player()->query_name())) {
      add_failed_mess("Unable to add a vote.\n");
      return 0;
   }

  return ::do_create_vote(choices);
} /* do_create_vote() */

void finish_vote(string type, string description, string* choices,
                 int* votes, string* voted)
{
   string ret;
   int i;

   ret = "Vote finished at " + ctime(time()) + ":\n";
   ret += "$I$3=   " + description + "\n\n";
   ret += "$I$0=Results:\n$I$3=   ";
   for (i = 0; i < sizeof(choices); i++) {
      ret += choices[i] + ": " + votes[i] + "\n";
   }
   if (!_finished_votes) {
      _finished_votes = ({ ret });
   } else {
      _finished_votes += ({ ret });
   }
   if (sizeof(_finished_votes) > POLL_DATA_MAXIMUM_RESULTS) {
      _finished_votes = _finished_votes[0..POLL_DATA_MAXIMUM_RESULTS];
   }
   save_room();
}

int do_set_duration(int hours) {
   if (hours <= 0) {
      add_failed_mess("The duration must be positive.\n");
      return 0;
   }

   set_vote_duration(hours * 60 * 60);
   add_succeeded_mess("Set the vote duration to " + hours + " hours.\n");
   return 1;
} /* do_set_duration() */

int do_delete_vote(int id) {
   if (!::delete_vote(id)) {
      add_failed_mess("Cannot delete the vote id #" + id + ".\n");
      return 0;
   }

   add_succeeded_mess("Deleted the vote id#" + id + ".\n");
   return 1;
} /* do_delete_vote() */

int do_end_vote(int id) {
   if ( !query_our_votes()[ id ] ) {
      add_failed_mess("Cannot end the vote id #" + id + ".\n");
      return 0;
   }

   end_vote(id);
   add_succeeded_mess("Finished the vote id#" + id + ".\n");
   return 1;
} /* do_delete_vote() */

string query_main_status() {
   string ret;

   ret = "Vote duration:    " + (query_vote_duration() / (60 * 60)) +
         " hours\n";
   return ret;
} /* query_main_status() */

void init() {
   commercial::init();
   voting_room::init();
   voting_room::init_add_vote();
   add_command("results", "of votes", (: do_show_results() :));
   if (environment()->is_allowed(this_player()->query_name())) {
      add_command("set", "vote duration <number'hours'> on <direct:object>",
                  (: do_set_duration($4[0]) :));
      add_command("delete", "vote <number'vote id'>",
                  (: do_delete_vote($4[0]) :));
      add_command("finish", "vote <number'vote id'>",
                  (: do_end_vote($4[0]) :));
   }
} /* init() */
// --- END [/mnt/home2/grok/lib/obj/furnitures/commercial/poll_data.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/furnitures/commercial/bank_master.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/furnitures/commercial/bank_master.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627879   Available: 13575233
Inodes: Total: 5242880    Free: 4960133
622 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/furnitures/commercial/bank_master.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627879   Available: 13575233
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
// Pinkfish
// Started Wed May 30 21:37:15 PDT 2001

inherit "/std/room/furniture/bank_master";

void setup() {
   set_name( "counter" );
   set_short( "master bank counter" );
   add_alias("bank");
   add_adjective( ({ "master", "bank" } ));
   set_long( "A heavily armoured and hardwood counter "
             "with a safe embedded into the surface.\n");
   set_allowed_positions(({"sitting", "standing" }));
   set_allowed_room_verbs((["sitting" : "sits", "standing" : "stands" ]));
   set_weight(1000);
   set_value(16000000);
   set_commercial_size(91);

   set_shop_use_types(({ "bank", "withdraw", "deposit" }));
}
// --- END [/mnt/home2/grok/lib/obj/furnitures/commercial/bank_master.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/furnitures/commercial/small_shop.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/furnitures/commercial/small_shop.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627878   Available: 13575232
Inodes: Total: 5242880    Free: 4960133
563 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/furnitures/commercial/small_shop.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627878   Available: 13575232
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
// Pinkfish
// Started Wed May 30 21:37:15 PDT 2001

inherit "/std/room/furniture/shop_base";

void setup() {
   set_name( "counter" );
   set_short( "small shop counter" );
   add_adjective( ({ "small", "shop" } ));
   set_long( "The smooth polished surface of the small counter shines and "
             "glows at you.\n");
   set_allowed_positions(({"sitting", "standing" }));
   set_allowed_room_verbs((["sitting" : "sits", "standing" : "stands" ]));
   set_weight(1000);
   set_value(480000);
   set_maximum_inventory_size(50);
   set_commercial_size(40);
}
// --- END [/mnt/home2/grok/lib/obj/furnitures/commercial/small_shop.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/furnitures/commercial/blackjack.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/furnitures/commercial/blackjack.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627878   Available: 13575232
Inodes: Total: 5242880    Free: 4960133
26111 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/furnitures/commercial/blackjack.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627878   Available: 13575232
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
// Pinkfish
// Started Wed May 30 21:37:15 PDT 2001

inherit "/std/room/furniture/games/card_base";
inherit "/std/room/furniture/games/multiplayer_base";
inherit "/std/room/furniture/commercial";

#include <money.h>

#define BLACKJACK_BET 0
#define BLACKJACK_PLAYING 1
#define BLACKJACK_BUST 2
#define BLACKJACK_STAND 3

class player_data {
   class playing_card* hand;
   int starting_bet;
   int state;
}

#define BOARD_TAG "blackjack"

//
// This gives an estimated return on the payment.  For example 50%
// return would mean you get back approximately 50% of your money on
// average
//
private int _cost;
private int _finished;
private int _max_bet;
private int _min_bet;
private int _timeout_call;
private int _timeout_length;
private int _num_decks;
private int _soft_seventeen;
private int _double_on_doubles;
private class playing_card* _dealer_hand;
private class playing_card* _deck;
private class playing_card* _discard;

int query_hand_value(class playing_card* cards);

void create() {
   multiplayer_base::create();
   commercial::create();
} /* create() */

void setup() {
   set_name( "table" );
   set_short( "blackjack table" );
   add_adjective( ({ "blackjack" } ));
   add_alias("blackjack");
   set_long( "The green felt of the table looks nice and soft, there is "
             "a single deck of cards sitting in the middle of the table.  "
             "The table looks like it will seat 4 people.\n");
   set_allowed_positions(({"sitting", "lying", "kneeling", "meditating"}));
   set_allowed_room_verbs((["sitting" : "sits" ]));
   set_weight(2000);
   set_value(240000);
   // Minimum bid $1.
   _timeout_length = 5 * 60;
   _cost = 400;
   _num_decks = 1;

   add_player_id_type("green", 0);
   add_player_id_type("red", 0);
   add_player_id_type("blue", 0);
   add_player_id_type("maroon", 0);

   set_minimum_needed(1);
   add_help_file("blackjack");

   set_commercial_size(15);
   set_commercial_type("gambling");
   set_shop_use_types(({ "blackjack" }));
}

/**
 * This method shows the current status of the cards.
 * @param id the id to show the status for
 * @return the status of the cards
 */
string query_card_status() {
   string id_bing;
   string ret;
   string* not_playing;
   class player_data data;
   class playing_card card;
   string* womble;
   string place;

   ret = "";
   not_playing = ({ });
   womble = query_player_ids();
   place = environment()->query_property("place");
   foreach (id_bing in womble) {
      if (is_person_playing(id_bing) ||
          is_game_started()) {
         ret += capitalize(id_bing) + " (" +
                query_player_cap_name(id_bing) + ")";
         data = query_player_data(id_bing);
         if (data) {
            if (data->starting_bet) {
               ret += "  " + 
                      MONEY_HAND->money_value_string(data->starting_bet, place);
               if (sizeof(data->hand)) {
                  foreach (card in data->hand) {
                     ret += "  " + query_card_string(card);
                  }
               }
               if (data->state == BLACKJACK_STAND) {
                  ret += " (stand)";
               } else if (data->state == BLACKJACK_BUST) {
                  ret += " (bust)";
               }
               ret += "\n";
            } else {
               ret += "  No bet yet.\n";
            }
         } else {
            ret += "\n";
         }
      } else {
         not_playing += ({ id_bing });
      }
   }

   if (sizeof(not_playing)) {
      ret += query_multiple_short(map(not_playing, (: capitalize($1) :))) +
                               " are not playing.\n";
   }

   ret += "\n";
   if (sizeof(_dealer_hand)) {
      ret += "Dealer's cards ";
      if (!_finished) {
         ret += "XXXX";
      }
      foreach (card in _dealer_hand[(_finished?0:1)..]) {
         ret += "  " + query_card_string(card);
      }
      if (query_hand_value(_dealer_hand) > 21) {
         ret += " (bust)";
      }
      ret += "\n";
   }

   return ret;
}
   
/** @ignore yes */
string long(string str, int dark) {
   if (dark) {
      return ::long() +
             "It is too dark to make out the pieces on the board.\n";
   }
   return ::long() + query_card_status();
} /* long() */

/**
 * This method returns the next card from the deck.
 * @return the next card from the deck
 */
class playing_card query_next_card() {
   class playing_card card;

   if (!sizeof(_deck)) {
      if (!sizeof(_discard)) {
         _deck = make_deck(_num_decks, 0);
         _deck = shuffle_deck(_deck);
      } else {
         _deck = make_deck(_num_decks, 0);
         _deck = shuffle_deck(_deck);
         //_deck = shuffle_deck(_discard);
      }
      tell_all_players("The dealer shuffles the deck before the next card "
                       "is dealt.\n");
      _discard = ({});
   }
   card = _deck[0];
   _deck = _deck[1..];
   return card;
} /* query_next_card() */

/**
 * This deals cards to everyone.
 */
void deal_cards(string id) {
   class player_data data;
   string hands;

   if (!sizeof(_dealer_hand)) {
      _dealer_hand = ({ query_next_card(), query_next_card() });
   }
   // Everyone gets one card...
   hands = "";
   //foreach (id in query_currently_playing_ids()) {
      data = query_player_data(id);
      data->hand = ({ query_next_card(), query_next_card() });
      hands += query_player_cap_name(id) + " hand is: "+
                      query_card_string(data->hand[0]) + "  " +
                      query_card_string(data->hand[1]) +
                      "  (total " +
                      query_hand_value(data->hand) + ")\n";
   //}
   hands += "Dealer's cards: XXXX " +
             query_card_string(_dealer_hand[0]) + "\n"
             "You need to stay or hit yourself for more cards.\n";
   tell_all_players(hands);
} /* deal_cards() */

/** @ignore yes */
int start_game() {
   class player_data data;
   string id;

   randomise_player_numbers();
   if (!::start_game()) {
      return 0;
   }
   foreach (id in query_player_ids()) {
      data = new(class player_data);
      data->starting_bet = 0;
      data->hand = ({ });
      data->state = BLACKJACK_BET;
      set_player_data(id, data);
   }
   _dealer_hand = ({ });
   _finished = 0;
   //redeal_cards();
   tell_all_players("Place your starting bets.\n");
   return 1;
} /* reset_game() */

/**
 * This figures out the value of the cards.
 * @param cards the crds to check
 * @return the value of the hand
 */
int query_hand_value(class playing_card* cards) {
   class playing_card bing;
   int value;
   int no_aces;

   foreach (bing in cards) {
      if (bing->number == 1) {
         no_aces++;
      } else if (bing->number >= 10) {
         value +=  10;
      } else {
         value += bing->number;
      }
   }

   if (no_aces > 0) {
      if (no_aces > 1) {
         value += no_aces - 1;
      }
      if (value <= 10) {
         value += 11;
      } else {
         value += 1;
      }
   }

   return value;
} /* query_hand_value() */

/**
 * This figures out if the value is a 'soft' one of the specified type.
 * @param cards the crds to check
 * @return 1 if it is a soft result or not
 */
int is_soft_result(class playing_card* cards) {
   class playing_card bing;
   int value;
   int no_aces;

   foreach (bing in cards) {
      if (bing->number == 1) {
         no_aces++;
      } else if (bing->number >= 10) {
         value +=  10;
      } else {
         value += bing->number;
      }
   }

   if (no_aces > 0) {
      if (no_aces > 1) {
         value += no_aces - 1;
      }
      if (value <= 10) {
         return 1;
      }
   }

   return 0;
} /* query_hand_value() */

/**
 * Checks to see if all the people playing have put in their first
 * bets.
 */
void finish_bet(string id) {
   //string id;
   class player_data data;

   data = query_player_data(id);
   // Move to the next state!
   call_out("deal_cards", 2, id);
} /* check_for_finish_bet() */

void complete_round() {
   int value;
   string stuff;
   object ob;
   int new_value;
   class playing_card card;
   class player_data data;
   string id;
   string place;
   int paid;
   string* winners;
   string* losers;

   remove_call_out(_timeout_call);
   _timeout_call = 0;
   place = environment()->query_property("place");
   value = query_hand_value(_dealer_hand);
   while (value < 17 ||
          (value == 17 && _soft_seventeen && is_soft_result(_dealer_hand))) {
      _dealer_hand += ({ query_next_card() });
      value = query_hand_value(_dealer_hand);
   }


   stuff = "";
   foreach (card in _dealer_hand) {
      stuff += "  " + query_card_string(card);
   }
   if (value > 21) {
      stuff += "  Total " + value + " (bust)\n";
      value = 0;
   } else {
      stuff += "  Total " + value + "\n";
   }
   winners = ({ });
   losers = ({ });
   foreach (id in query_currently_playing_ids()) {
      data = query_player_data(id);
      if (data->state == BLACKJACK_STAND) {
         new_value = query_hand_value(data->hand);
         if (new_value == 21 && sizeof(data->hand) == 2) {
            winners += ({ id });
            // They get a pay out.
            ob = query_player_object(id);
            if (ob) {
               ob->adjust_money(MONEY_HAND->create_money_array((data->starting_bet * 5) / 2,
                                           place), place);
            }
            //_pay_out += (data->starting_bet * 3) / 2;
            //_revenue -= data->starting_bet;
            adjust_float(-(data->starting_bet * 3) / 2);
            if (ob) {
               stuff += ob->query_cap_name();
            } else {
               stuff += id;
            }
            stuff += " gets a payout of " +
                     MONEY_HAND->money_value_string((data->starting_bet * 3) / 2, place) +
                     " (plus their original money back).\n";
            paid = 1;
         } else if (new_value > value) {
            winners += ({ id });
            // They get a pay out.
            ob = query_player_object(id);
            if (ob) {
               ob->adjust_money(MONEY_HAND->create_money_array(data->starting_bet * 2,
                                           place), place);
            }
            //_pay_out += data->starting_bet;
            //_revenue -= data->starting_bet;
            adjust_float(-data->starting_bet);
            if (ob) {
               stuff += ob->the_short();
            } else {
               stuff += id;
            }
            stuff += " gets a payout of " +
                     MONEY_HAND->money_value_string(data->starting_bet, place) +
                     " (plus their original money back).\n";
            paid = 1;
         } else {
            losers += ({ id });
         }
      }
   }
   if (!paid) {
      stuff += "No one gets paid anything.\n";
   }
   // Do the dealer.
   tell_all_players("The dealer reveals their cards as " +
                    stuff);
   if (sizeof(winners)) {
      tell_room(environment(),
                query_multiple_short(winners) + " win" +
                (sizeof(winners) > 1?"":"s") + " the blackjack hand.\n");
   } else {
      tell_room(environment(),  "No one wins the blackjack hand.\n");
   }

   finish_game(0);
   _finished = 1;
} /* complete_round() */

void force_finish() {
   if (is_game_started()) {
      complete_round();
   }
} /* force_finish() */

/**
 * Places your bet.
 */
int do_bet(string str) {
   string place;
   string id;
   int amount;
   class player_data data;

   if (!is_game_started()) {
      add_failed_mess("The game has not started.\n");
      return 0;
   }

   id = find_player_id_of_person(this_player());
   if (!id) {
      add_failed_mess("You are not playing.\n");
      return 0;
   }

   place = environment()->query_property("place");

   amount = MONEY_HAND->value_from_string(str, place);
   if (!amount) {
      add_failed_mess("Invalid bet amount.\n");
      return 0;
   }
   if (this_player()->query_value_in(place) < amount) {
      add_failed_mess("You do not have that much to bid.\n");
      return 0;
   }

   if (amount < _min_bet) {
      add_failed_mess("The minimum bet for $D is " +
         MONEY_HAND->money_value_string(_min_bet, place) + ".\n");
      return 0;
   }
   if (amount > _max_bet) {
      add_failed_mess("The maximum bet for $D is " +
         MONEY_HAND->money_value_string(_max_bet, place) + ".\n");
      return 0;
   }

   data = query_player_data(id);
   if (data->starting_bet) {
      add_failed_mess("You have already bet on $D.\n");
      return 0;
   }
   this_player()->pay_money(MONEY_HAND->create_money_array(amount, place),
                            place);

   //_revenue += amount;
   adjust_float(amount);

   // This is for the starting bet.
   data->starting_bet = amount;
   data->state = BLACKJACK_PLAYING;
   finish_bet(id);
   add_succeeded_mess("$N $V " +
                      MONEY_HAND->money_value_string(amount, place) +
                      " on $D.\n");
   return 1;
} /* do_bet() */

/**
 * This hits you for another card.
 */
int do_hit() {
   int value;
   int not_done;
   string id;
   class player_data data;
   class playing_card card;

   // Get another card.
   if (!is_game_started()) {
      add_failed_mess("The game has not started.\n");
      return 0;
   }

   id = find_player_id_of_person(this_player());
   if (!id) {
      add_failed_mess("You are not playing.\n");
      return 0;
   }

   data = query_player_data(id);

   if (data->state != BLACKJACK_PLAYING) {
      add_failed_mess("You are out of the game and cannot get any more "
                      "cards.\n");
      return 0;
   }

   if (!sizeof(data->hand)) {
      add_failed_mess("You cannot hit before you have been dealt cards.\n");
      return 0;
   }

   card = query_next_card();
   data->hand += ({ card });
   value = query_hand_value(data->hand);
   if (value > 21) {
      add_succeeded_mess("$N $V and get$s " + query_card_string(card) +
                         " giving a total of " + value +
                         " and going bust on $D.\n");
      data->state = BLACKJACK_BUST;
      foreach (id in query_currently_playing_ids()) {
         data = query_player_data(id);
         if (data->state != BLACKJACK_BUST &&
             data->state != BLACKJACK_STAND) {
            not_done = 1;
         }
      }
      if (!not_done) {
          remove_call_out(_timeout_call);
          _timeout_call = call_out("complete_round", 2);
      }
   } else {
      add_succeeded_mess("$N $V and gets " + query_card_string(card) +
                         " giving a total of " + value + " on $D.\n");
   }
   return 1;
} /* do_hit() */

int do_stand() {
   int value;
   string id;
   class player_data data;
   int not_done;

   // Get another card.
   if (!is_game_started()) {
      add_failed_mess("The game has not started.\n");
      return 0;
   }

   id = find_player_id_of_person(this_player());
   if (!id) {
      add_failed_mess("You are not playing.\n");
      return 0;
   }

   data = query_player_data(id);

   if (data->state != BLACKJACK_PLAYING) {
      add_failed_mess("You are not playing and set yourself to stand.\n");
      return 0;
   }

   value = query_hand_value(data->hand);

   data->state = BLACKJACK_STAND;
   foreach (id in query_currently_playing_ids()) {
      data = query_player_data(id);
      if (data->state != BLACKJACK_BUST &&
          data->state != BLACKJACK_STAND) {
         not_done = 1;
      }
   }
   if (!not_done) {
       remove_call_out(_timeout_call);
       _timeout_call = call_out("complete_round", 2);
   }
   add_succeeded_mess("$N $V with a total of " + value +
                      " on $D.\n");
   return 1;
} /* do_stand() */

/**
 * Starts a nice furry game.
 */
int do_start() {
   if (!is_open_for("blackjack", this_player()->query_name())) {
      add_failed_mess("The blackjack table is not open.\n");
      return 0;
   }

   if (_timeout_call) {
      add_failed_mess("Someone is still playing, you cannot start a "
                      "new game yet.\n");
      return 0;
   }

   //
   // There must eb enough money in the float for everyone to bid the max amo
   // amount and win with a blackjack.
   //
   if (query_float() < (_max_bet * 3 * 4) / 2) {
      if (is_allowed(this_player()->query_name())) {
         add_failed_mess("The float is too low for the table to open.\n");
         return 0;
      }
      add_failed_mess("The blackjack table is not open.\n");
      return 0;
   }

   if (!is_playing(this_player())) {
      add_failed_mess("You must be playing the game to start it.\n");
      return 0;
   }

   if (!start_game()) {
      add_failed_mess("You need at least three people to play modern art.\n");
      return 0;
   }

   add_succeeded_mess("$N $V a game on $D.\n");
   remove_call_out(_timeout_call);
   _timeout_call = call_out("force_finish", _timeout_length);
   tell_all_players("Timeout for this game is " + (_timeout_length / 60) +
                    " minutes.\n");
   return 1;
} /* do_start() */

/**
 * If it is finished early...  Oh dear.
 */
int do_finish() {
   string person;

   if (!is_game_started()) {
      add_failed_mess("The game has not started.\n");
      return 0;
   }

   person = find_player_id_of_person(this_player());
   if (!person) {
      add_failed_mess("You must actually be playing to finish the game.\n");
      return 0;
   }

   force_finish();
   return 1;
} /* do_finish() */

string query_main_status(int hint) {
   string place;
   string ret;

   place = query_money_place();
   ret = "$I$0=Blackjack table:\n"
          "$I$6=   Table is " +
             (query_float() >= (_max_bet * 3 * 4) / 2?"open.\n":
              "closed! (Float needed: " +
              MONEY_HAND->money_value_string((_max_bet * 3 * 4) / 2, place) +
              "; current: " +
              MONEY_HAND->money_value_string(query_float(), place) + ")\n") +
          "$I$6=   Timeout length: " + (_timeout_length / 60) + " minutes.\n";
   if (hint) {
      ret += "$I$6=      set timeout <number> on <table>\n";
   }
   ret += "$I$6=   Maximum bet: " +
              MONEY_HAND->money_value_string(_max_bet, place) + "\n";
   if (hint) {
      ret += "$I$6=      set maximum bet <amount> on <table>\n";
   }
   ret += "$I$6=   Minimum bet: " +
              MONEY_HAND->money_value_string(_min_bet, place) + "\n";
   if (hint) {
      ret += "$I$6=      set minimum bet <amount> on <table>\n";
   }
   ret += "$I$6=   Num Decks  : " + _num_decks + "\n";
   if (hint) {
      ret += "$I$6=      set num decks <amount> on <table>\n";
   }
   ret += "$I$6=   Soft 17    : " + (_soft_seventeen?"on":"off") + "\n";
   if (hint) {
      ret += "$I$6=      set hit on soft seventeen {on|off} on <table>\n";
   }
/*
   ret += "$I$6=   Doubles    : " + (_double_on_doubles?"on":"off") + "\n";
   if (hint) {
      ret += "$I$6=      set doubles {on|off} on <table>\n";
   }
 */
   ret += "$I$6=   Float needed: " +
              MONEY_HAND->money_value_string((_max_bet * 3 * 4) / 2, place) +
          " (max players * max bet * 3 / 2)\n$I$6=   Revenue: " +
          MONEY_HAND->money_value_string(query_revenue(), place) +
          "\n\n";
   return ret;
} /* query_main_status() */

/**
 * This method sets the bet boundaries.
 * @param str the amount string
 * @param max_bet if it a max or min bet to set
 */
int do_set_bet(string str, int max_bet) {
   string place;
   int value;

   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to change the paramaters of "
                   "$D.\n");
      return 0;
   }
   place = query_money_place();
   value = MONEY_HAND->value_from_string(str, place);
   if (!value) {
      add_failed_mess("Unable to parse the string " + str + ".\n");
      return 0;
   }
   if (max_bet) {
      _max_bet = value;
      add_succeeded_mess("$N set$s the maximum bet to " +
          MONEY_HAND->money_value_string(value, place) + " on $D.\n");
   } else {
      _min_bet = value;
      add_succeeded_mess("$N set$s the minimum bet to " +
          MONEY_HAND->money_value_string(value, place) + " on $D.\n");
   }

   return 1;
} /* do_set_bet() */

/**
 * This method sets the timeout for the table.
 */
int do_set_timeout(int length) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to change the paramaters of "
                   "$D.\n");
      return 0;
   }

   if (length <= 0) {
      add_failed_mess("The timeout must be greator than 0.\n");
      return 0;
   }
   _timeout_length = length * 60;
   add_succeeded_mess("$N set$s the timeout on $D to " + length + " minutes.\n");
   return 1;
} /* do_set_timeout() */

/**
 * This method sets the soft_seventeen for the table.
 */
int do_set_soft_seventeen(int value) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to change the paramaters of "
                   "$D.\n");
      return 0;
   }

   _soft_seventeen = value;
   add_succeeded_mess("$N set$s the soft seventeen dealer hit on $D " +
                      (value?"on":"off") + ".\n");
   return 1;
} /* do_set_soft_seventeen() */

/**
 * This method sets the soft_seventeen for the table.
 */
int do_set_double_on_doubles(int value) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to change the paramaters of "
                   "$D.\n");
      return 0;
   }

   _double_on_doubles = value;
   add_succeeded_mess("$N set$s the double on doubles on $D " +
                      (value?"on":"off") + ".\n");
   return 1;
} /* do_set_double_on_doubles() */

/**
 * This method sets the timeout for the table.
 */
int do_set_num_decks(int num_decks) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to change the paramaters of "
                   "$D.\n");
      return 0;
   }

   if (num_decks <= 0) {
      add_failed_mess("The timeout must be greator than 0.\n");
      return 0;
   }
   if (num_decks >= 10) {
      add_failed_mess("The number of decks must be less than 10.\n");
      return 0;
   }
   _num_decks = num_decks;
   add_succeeded_mess("$N set$s the number of decks on $D to " + num_decks +
                      ".\n");
   return 1;
} /* do_set_num_decks() */

void init() {
   multiplayer_base::init();
   commercial::init();
   add_command("bet", "<string'amount'> on <direct:object>",
               (: do_bet($4[0]) :));
   add_command("hit", "on <direct:object>",
               (: do_hit() :));
   add_command("stay", "on <direct:object>",
               (: do_stand() :));
/*
   add_command("finish", "game on <direct:object>",
               (: do_finish() :));
 */
   add_command("start", "[new] game on <direct:object>",
               (: do_start() :));

   if (environment()->is_allowed(this_player()->query_name())) {
      add_command("set", "minimum bet <string'amount'> on <direct:object>",
                  (: do_set_bet($4[0], 0) :));
      add_command("set", "maximum bet <string'amount'> on <direct:object>",
                  (: do_set_bet($4[0], 1) :));
      add_command("set", "timeout <number'minutes'> on <direct:object>",
                  (: do_set_timeout($4[0]) :));
      add_command("set", "num decks <number'num decks'> on <direct:object>",
                  (: do_set_num_decks($4[0]) :));
/*
      add_command("set", "double on doubles {on|off} on <direct:object>",
                  (: do_set_double_on_doubles($4[0] == "on") :));
 */
      add_command("set", "hit on soft seventeen {on|off} on <direct:object>",
                  (: do_set_soft_seventeen($4[0] == "on") :));
   }
} /* init() */

/** @ignore yes */
mapping query_dynamic_auto_load() {
   mapping map;

   map = commercial::query_dynamic_auto_load();
   multiplayer_base::query_dynamic_auto_load(map);
   //add_auto_load_value(map, BOARD_TAG, "return", _return);
   add_auto_load_value(map, BOARD_TAG, "cost", _cost);
   //add_auto_load_value(map, BOARD_TAG, "pay out", _pay_out);
   //add_auto_load_value(map, BOARD_TAG, "revenue", _revenue);
   add_auto_load_value(map, BOARD_TAG, "dealer hand", _dealer_hand);
   add_auto_load_value(map, BOARD_TAG, "deck", _deck);
   add_auto_load_value(map, BOARD_TAG, "discard", _discard);
   add_auto_load_value(map, BOARD_TAG, "finished", _finished);
   add_auto_load_value(map, BOARD_TAG, "max bet", _max_bet);
   add_auto_load_value(map, BOARD_TAG, "min bet ", _min_bet);
   add_auto_load_value(map, BOARD_TAG, "timeout", _timeout_length);
   add_auto_load_value(map, BOARD_TAG, "num decks", _num_decks);
   add_auto_load_value(map, BOARD_TAG, "soft seventeen", _soft_seventeen);
   add_auto_load_value(map, BOARD_TAG, "double on doublet", _double_on_doubles);
   return map;
} /* query_dynamic_auto_load() */

/** @ignore yes */
void init_dynamic_arg(mapping map, object player) {
   commercial::init_dynamic_arg(map, player);
   multiplayer_base::init_dynamic_arg(map, player);

   //_return = query_auto_load_value(map, BOARD_TAG, "return");
   _cost = query_auto_load_value(map, BOARD_TAG, "cost");
   //_pay_out = query_auto_load_value(map, BOARD_TAG, "pay out");
   //_revenue = query_auto_load_value(map, BOARD_TAG, "revenue");
   _dealer_hand = query_auto_load_value(map, BOARD_TAG, "dealer hand");
   _deck = query_auto_load_value(map, BOARD_TAG, "deck");
   _discard = query_auto_load_value(map, BOARD_TAG, "discard");
   _finished = query_auto_load_value(map, BOARD_TAG, "finished");
   _min_bet = query_auto_load_value(map, BOARD_TAG, "min bet");
   _max_bet = query_auto_load_value(map, BOARD_TAG, "max bet");
   _timeout_length = query_auto_load_value(map, BOARD_TAG, "timeout");
   _num_decks = query_auto_load_value(map, BOARD_TAG, "num decks");
   _soft_seventeen = query_auto_load_value(map, BOARD_TAG, "soft seventeen");
   _double_on_doubles = query_auto_load_value(map, BOARD_TAG, "double on doublet");

   if (!_num_decks) {
      _num_decks = 1;
   }

   if (is_game_started()) {
      remove_call_out(_timeout_call);
      _timeout_call = call_out("force_finish", _timeout_length);
   }
} /* init_dynamic_arg() */
// --- END [/mnt/home2/grok/lib/obj/furnitures/commercial/blackjack.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/furnitures/commercial/bank_franchise_small.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/furnitures/commercial/bank_franchise_small.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627871   Available: 13575225
Inodes: Total: 5242880    Free: 4960133
601 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/furnitures/commercial/bank_franchise_small.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627871   Available: 13575225
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
// Pinkfish
// Started Wed May 30 21:37:15 PDT 2001

inherit "/std/room/furniture/bank_franchise";

void setup() {
   set_name( "counter" );
   set_short( "small bank counter" );
   add_alias("bank");
   add_adjective( ({ "small", "bank" } ));
   set_long( "A heavily armoured and hardwood counter "
             "with a safe embedded into the surface.\n");
   set_allowed_positions(({"sitting", "standing" }));
   set_allowed_room_verbs((["sitting" : "sits", "standing" : "stands" ]));
   set_weight(1000);
   set_value(400000);
   set_commercial_size(10);
   set_maximum_total_difference(200000);
}
// --- END [/mnt/home2/grok/lib/obj/furnitures/commercial/bank_franchise_small.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/furnitures/artwork/mountain_painting.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/furnitures/artwork/mountain_painting.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627871   Available: 13575225
Inodes: Total: 5242880    Free: 4960133
962 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/furnitures/artwork/mountain_painting.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627871   Available: 13575225
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
// Una
// For use in Cwc

inherit "/std/room/furniture/basic";

void setup() {
    set_name( "painting" );
    set_short( "painting of a misty mountain range" );
    add_adjective( ({ "of", "a", "misty", "mountain", "range" }) );
    set_long( "This is a watercolour painting of a range of "
        "mountains skirting a misty lake.  Fiery red trees "
        "border the indescript water's edge, snaking their "
        "branches out horizontally more than vertically.  "
        "The mountains have been painted complementing "
        "shades of steel grey and persian blue, while the "
        "water itself is a strangely creamy white.\n" );
    set_weight( 40 );
    set_value( 46775 );
    set_allowed_positions( ({"hanging"}) );
    set_allowed_room_verbs((["hanging" : "hangs",
                             "sitting" : "sits",
                             "dangling" : "dangles",
                             "standing" : "stands" ]));
} /* setup() */
// --- END [/mnt/home2/grok/lib/obj/furnitures/artwork/mountain_painting.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/furnitures/fake_plants/silk_cabbage_plant.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/furnitures/fake_plants/silk_cabbage_plant.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627870   Available: 13575224
Inodes: Total: 5242880    Free: 4960133
960 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/furnitures/fake_plants/silk_cabbage_plant.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627870   Available: 13575224
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
// Una
// For use in Cwc

inherit "/std/room/furniture/basic";

void setup () {
  
    set_name( "plant" );
    add_adjective( ({ "silk", "potted", "cabbage" }) );
    set_short( "potted silk cabbage plant" );
    add_alias( "cabbage" );
    set_main_plural ( "potted silk cabbage plants" );
    add_property( "determinate", "a " );

    set_long( "Rare and magnificent!  Strange and exotic!  Potted in a "
        "subtley plain pot, this fine silk-leafed brassica has been "
        "created in Sum Dim by none other than Brown Fingers Dibbler, "
        "purveyor of the finest silken forn plants.  Its leaves even look "
        "as though they have been nibbled slightly by a caterpillar, "
        "for the authentic touch.\n" );
    set_value( 35000 );
    set_weight( 150 );
  
    set_allowed_room_verbs(([ "sitting" : "sits", 
                              "standing" : "stands",
                              "lying" : "lies" ]));

} /*setup*/

   
// --- END [/mnt/home2/grok/lib/obj/furnitures/fake_plants/silk_cabbage_plant.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/furnitures/safes/small_safe.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/furnitures/safes/small_safe.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627870   Available: 13575224
Inodes: Total: 5242880    Free: 4960133
1413 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/furnitures/safes/small_safe.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627870   Available: 13575224
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:56.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/room/furniture/storage";

void setup() {
  set_name("safe");
  set_short("small iron safe");
  add_adjective(({"small", "iron"}));
  set_long("This is a small iron safe.  It bears the logo of "
           "Joseph Thighbiter a renowned safe maker.  It appears "
           "to feature one of his patented locks.\n");

  add_drawer("top", 50);
  add_drawer("middle", 25);
  add_drawer("bottom", 25);

  // the drawers are inside and not visible if the door is shut.
  set_drawers_inside(1);
  
  set_weight(900);
  set_value(120000);

  set_allowed_room_verbs((["squatting" : "squats" ]));
  set_pick_skill("covert.lockpick.safes");
  set_difficulty(4);

  setup_trap(300, "pick",
             "Hidden inside the lock is a small ampule which, if touched by "
             "an unwary tool would trigger a puff of poisonous gas.",
             ({"A small cloud of gas puffs out of the safe.\n",
                 "A small cloud of gas puffs out of the safe.\n"}),
             ({"/std/effects/poisons/poison_gas", 600}));
}

void init() {
  string key_id;
  object key;
  
  if(!query_key()) {
    key_id = "safe"+random(10000); 
    set_key(key_id);
    
    key = clone_object("/std/key");
    key->set_key("small iron", key_id);
    key->set_long("This small, yet sturdy, key looks like it is for a "
                  "safe.\n");
    key->move(this_object());
    set_closed();
  }
  

  ::init();
}
// --- END [/mnt/home2/grok/lib/obj/furnitures/safes/small_safe.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/furnitures/chests/pine_chest_of_drawers.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/furnitures/chests/pine_chest_of_drawers.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627869   Available: 13575223
Inodes: Total: 5242880    Free: 4960133
1437 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/furnitures/chests/pine_chest_of_drawers.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627869   Available: 13575223
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
// Only for use within CWC

inherit "/std/room/furniture/storage";

void setup() {

    set_name("chest");
    set_short("Agatean pine chest of drawers");
    add_adjective(({"agatean", "pine", "chest", "of", "drawers"}));
    add_alias("chest of drawers");
    set_long("A simple chest of drawers formed of genuine Agatean pine, "
        "sturdy and functional.  The grain of the wood is a little "
        "mismatched testifying to the desire of the manufacturer to "
        "create something functional rather than beautiful.  Five drawers "
        "are set into the front each bearing two knobs of the same "
        "material. Very slight ornamentation has been added in the form "
        "of gentle curves deliniating the edges and unornamented top.\n");

    set_weight(900);
    set_max_weight(400);
    set_value(200000);

    set_allowed_room_verbs((["squatting" : "squats" ]));
    set_pick_skill("covert.lockpick.doors");
    set_difficulty(4);
   
} /* setup() */

void init() {
    string key_id;
    object key;
  
    if(!query_key()) {
        key_id = "furniture_lock_"+random(1000); 
        set_key(key_id);
    
        key = clone_object("/std/key");
        key->set_key("small iron", key_id);
        key->set_long("This small, yet sturdy, key looks like it is for a "
                  "piece of furniture.\n");
        key->move(this_object());
        set_closed();
    }
  

  ::init();
  
} /* init() */
// --- END [/mnt/home2/grok/lib/obj/furnitures/chests/pine_chest_of_drawers.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/furnitures/chests/pumpkin_chest.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/furnitures/chests/pumpkin_chest.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627869   Available: 13575223
Inodes: Total: 5242880    Free: 4960133
728 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/furnitures/chests/pumpkin_chest.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627869   Available: 13575223
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* A pumpkin chest.
 * by Ptoink
 *  - 05/02/2003
*/

inherit "/std/room/furniture/storage";

void setup() {

  set_name("chest");
  set_short("pumpkin chest");
  add_adjective(({"pumpkin","fairytale"}));

  set_long(
    "Shaped and painted like a perfectly ripe pumpkin, this chest is "
    "held just off the ground by four sturdy wooden wheels.  "
    "Unfortunately, these appear to be merely decorative in nature, and "
    "don't actually turn.  A deep green stem has been attached to the "
    "top of the chest to act as a handle.\n");
    
  set_weight(1200);
  set_max_weight(200);
  set_value(590000);
  set_allowed_room_verbs((["squatting" : "squats", 
                               "sitting" : "sits"
  ]));    
}// --- END [/mnt/home2/grok/lib/obj/furnitures/chests/pumpkin_chest.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/furnitures/outdoor/bird_bath.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/furnitures/outdoor/bird_bath.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627869   Available: 13575223
Inodes: Total: 5242880    Free: 4960133
673 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/furnitures/outdoor/bird_bath.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627869   Available: 13575223
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:56.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
// Rue 2.2000

inherit "/std/room/furniture/basic";

void setup() {
  set_name( "birdbath" );
  set_short( "stone bird bath" );
  add_adjective( ({ "stone", "bird", "bath" }) );
  add_alias( ({ "bath", "bird bath" }) );
  set_long( "This is a block of stone that has been chiseled and hacked into "
   "a vaguely bird bath shape.  It is really quite ugly.  Fortunately, birds "
   "don't seem to be art critics.  The base of the bird bath is made of some "
   "sort of porous stone that resembles Dwarf Bread in texture.\n" );
  set_allowed_positions(({"sitting","standing"}));
  set_allowed_room_verbs((["standing" : "stands" ]));
  set_weight(200);
  set_value(4000);
}

// --- END [/mnt/home2/grok/lib/obj/furnitures/outdoor/bird_bath.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/furnitures/cushions/frog_cushion.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/furnitures/cushions/frog_cushion.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627868   Available: 13575222
Inodes: Total: 5242880    Free: 4960133
594 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/furnitures/cushions/frog_cushion.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627868   Available: 13575222
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
// Rue 1.2000

inherit "/std/room/furniture/basic";

void setup() {
  set_name( "cushion" );
  set_short( "frog cushion" );
  add_adjective( ({ "frog", "green" }) );
  add_alias( "pillow" );
  set_long( "This is a cushion that is the approximate shape of a "
    "frog that has been flattened by a cart.  It is covered in vivid "
    "green cordueroy.\n" );
  set_allowed_positions(({"sitting", "lying", "kneeling", "meditating",
                            "crouching", "standing"}));
  set_allowed_room_verbs((["lying" : "lays", "hanging" : "hangs"]));
  set_weight(2);
  set_value(8000);
}

// --- END [/mnt/home2/grok/lib/obj/furnitures/cushions/frog_cushion.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/furnitures/shelves/pine_nightstand.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/furnitures/shelves/pine_nightstand.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627868   Available: 13575222
Inodes: Total: 5242880    Free: 4960133
1286 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/furnitures/shelves/pine_nightstand.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627868   Available: 13575222
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:56.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
// Triana Mar.2000, modified from white_plank_cabinet by
// Rue 1.2000

inherit "/std/room/furniture/storage";

void setup() {
  set_name( "nightstand" );
  set_short( "pine nightstand" );
  add_adjective( ({ "pine", "bedside" }) );
  add_alias("cabinet");
  set_long( "This is a small bedside cabinet, made of thick hublandish "
            "pine planks.  The wood is oiled, to bring out the characteristic "
            "colour, and the stripes and knots texture in it.  It's just the "
            "kind of thing that is thought to have a rustic look, by "
            "people who don't have much of a clue what rustic is.\n" );

  add_drawer( "top", 50 );
  
  // 15 pounds sounds to me like more than enough for a small cabinet :)
  set_weight(135);
  set_value(10000);

  set_allowed_positions(({"sitting"}));
  set_allowed_room_verbs((["sitting" : "sits" ]));
}

void init() {
    string key_id;
  object key;
  
  if(!query_key()) {
    key_id = "nightstand_"+random(100); 
    set_key(key_id);
    set_difficulty(1);
    
    key = clone_object("/std/key");
    key->set_key("small", key_id);
    key->set_long("This small key looks like it is probably for a piece of "
                  "furniture.\n");
    key->move(this_object());
    
    set_closed();
  }

  ::init();
}
// --- END [/mnt/home2/grok/lib/obj/furnitures/shelves/pine_nightstand.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/furnitures/crockery/happiness_jar.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/furnitures/crockery/happiness_jar.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627867   Available: 13575221
Inodes: Total: 5242880    Free: 4960133
917 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/furnitures/crockery/happiness_jar.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627867   Available: 13575221
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
// Una
// For use in Cwc

inherit "/std/room/furniture/storage";

void setup(){

    set_name( "happiness" );
    set_short( "jar of double happiness" );
    add_adjective( ({ "jar", "of", "double" }) );
    set_long("In Agatea, this elegant blue and white porcelain jar is "
        "often presented as a wedding gift.  The pictogram for happiness "
        "is drawn twice in parallel to make the Double Happiness sign, "
        "which is used in wedding decorations.  With a tight lid, this "
        "porcelain jar is excellent for storing anything you wish.\n");
    set_weight( 140 );
    set_max_weight(27);
    set_value( 25000 );
    set_allowed_room_verbs(([ "sitting" : "sits",
                              "standing" : "stands",
                              "leaning" : "leans", 
                              "lying" : "lies",
                              "squatting" : "squats" ]));
} /* setup() */
// --- END [/mnt/home2/grok/lib/obj/furnitures/crockery/happiness_jar.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/furnitures/mirrors/jasmine_mirror.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/furnitures/mirrors/jasmine_mirror.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627867   Available: 13575221
Inodes: Total: 5242880    Free: 4960133
647 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/furnitures/mirrors/jasmine_mirror.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627867   Available: 13575221
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: jasmine_mirror.c,v 1.1 2002/03/02 04:56:14 saffra Exp $
 *
 *
 */

// Rue 1.2000

inherit "/std/room/furniture/mirror";

string reflect();

void setup(){

  set_name( "mirror" );
  set_short( "jasmine mirror" );
  add_adjective( ({ "jasmine", "flower", "oval" }) );
  set_long("Delicately carved jasmine flowers and bead trim surround this "
           "oval mirror.  The flowers are so detailed that they almost "
           "appear to be real.\n");

  set_allowed_room_verbs( (["hanging" : "hangs", 
                            "gracing"  : "graces"   ]) );
  set_weight(60);
  set_value(50000);

}
// --- END [/mnt/home2/grok/lib/obj/furnitures/mirrors/jasmine_mirror.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/furnitures/cabinets/rose_display_cabinet.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/furnitures/cabinets/rose_display_cabinet.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627866   Available: 13575220
Inodes: Total: 5242880    Free: 4960133
693 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/furnitures/cabinets/rose_display_cabinet.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627866   Available: 13575220
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
//Una
//Only for use in Cwc

inherit "/std/room/furniture/storage";

void setup() {
    set_name("cabinet");
    set_short("rosewood display cabinet");
    add_adjective( ({ "rosewood", "display" }) );
    set_long("This is a tall rosewood display cabinet that has a glass "
        "front to ensure that its contents are well protected.  Supported "
        "by various delicate geometric shelves on the inside, the outside "
        "is inlaid with mother of pearl that has been shaped into "
        "blossoming cherry trees.\n");
    set_transparent();
    set_weight(1200);
    set_max_weight(200);
    set_value(590000);
    set_allowed_room_verbs((["squatting" : "squats" ]));
    
}


// --- END [/mnt/home2/grok/lib/obj/furnitures/cabinets/rose_display_cabinet.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/furnitures/tables/pedestal_table.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/furnitures/tables/pedestal_table.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627866   Available: 13575220
Inodes: Total: 5242880    Free: 4960133
798 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/furnitures/tables/pedestal_table.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627866   Available: 13575220
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:56.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
//Una
//Only for use in CWC

inherit "/std/room/furniture/surface";

void setup() {
    set_name( "table" );
    set_short( "pedestal table" );
    add_adjective( "pedestal" );
    set_long("Finished in warm antique hues, this pedestal table is a "
        "roughly triangular object which ends abruptly in a flat plateau "
        "which looks to be the ideal place for placing a few books or "
        "a reading lantern.  Rising along its height are a series of "
        "drawers with brass handles, which narrow in width with the table "
        "as it rises.\n");
    set_allowed_positions( ({ "on" }) );
    set_allowed_room_verbs( ([ "standing" : "stands" ]) );
    set_weight( 250 );
    set_max_weight( 50 );
    set_value( 88000 );
    set_allow_use_internals( 1 );
} /* void setup() */
// --- END [/mnt/home2/grok/lib/obj/furnitures/tables/pedestal_table.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/furnitures/misc/burnt_bamboo_screen.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/furnitures/misc/burnt_bamboo_screen.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627866   Available: 13575220
Inodes: Total: 5242880    Free: 4960133
816 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/furnitures/misc/burnt_bamboo_screen.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627866   Available: 13575220
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:56.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
// Una
// For use in Cwc

inherit "/std/room/furniture/basic";

void setup() {
    
    set_name( "screen" );
    set_short( "burnt bamboo screen" );
    add_adjective( ({ "burnt", "bamboo" }) );
    set_long( "This screen has been constructed by "
        "weaving hundreds of lashes of bamboo together to form a tight "
        "mesh that blocks out any chance of peeking through to see what's "
        "on the other side.  The bamboo, lovely in differing shades of "
        "tan through to chocolate brown, is supported by long poles which "
        "make up the frame and hinge the entire structure together.\n");
    set_allowed_positions( ({ "standing", "sitting" }) );
    set_allowed_room_verbs((["standing" : "stands", "sitting" : "sits" ]) );
    set_weight(150);
    set_value(400000);

} /* setup() */
// --- END [/mnt/home2/grok/lib/obj/furnitures/misc/burnt_bamboo_screen.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/furnitures/misc/brass_gong.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/furnitures/misc/brass_gong.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627865   Available: 13575219
Inodes: Total: 5242880    Free: 4960133
1201 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/furnitures/misc/brass_gong.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627865   Available: 13575219
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:56.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
// Una
// For use in Cwc

inherit "/std/room/furniture/basic";

void setup() {

    set_name("gong");
    set_short("brass gong");
    add_adjective( "brass" );
    set_long("This is a medium-sized brass gong, hanging from a brass "
        "frame.  Lazy pandas roll around the surface of the gong, "
        "the occasional one actually doing something other than "
        "eating or chewing on a stalk of bamboo.  The gong can be hit "
        "to make a loud ringing sound and annoy everyone in the room.\n");
    set_weight( 60 );
    set_value( 10000 );
    set_material( "brass" );
    set_allowed_positions( ({"hanging"}) );
    set_allowed_room_verbs((["hanging" : "hangs",
                             "sitting" : "sits",
                             "dangling" : "dangles",
                             "standing" : "stands" ]));    
} /* setup() */

void init() {
    this_player()->add_command( "hit", this_object(), "<direct:object:me>" );
} /* init() */

int do_hit(){

    this_player()->add_succeeded_mess(this_object(), "$N $V $p "
        +this_object()->short()+" loudly, filling the room with a "
        "deafening ringing sound.\n", ({ }));    
    return 1;

} /* do_hit() */

// --- END [/mnt/home2/grok/lib/obj/furnitures/misc/brass_gong.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/furnitures/misc/antique_food_basket.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/furnitures/misc/antique_food_basket.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627865   Available: 13575219
Inodes: Total: 5242880    Free: 4960133
938 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/furnitures/misc/antique_food_basket.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627865   Available: 13575219
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
// Una
// For use in Cwc

inherit "/std/room/furniture/storage";

void setup(){

    set_name( "basket" );
    set_short( "antique food basket" );
    add_adjective( ({ "antique", "food", "basket" }) );
    set_long("Used for carrying food in the older times, now refurbished, "
        "this antique food basket is now a curious ornament to a "
        "contemporary eye.  Still usable for storage, if not for food, the "
        "handle is made of bamboo that has been bent into shape.  "
        "Retrieved from the Sum Dim countryside, no two of these baskets "
        "are alike.\n");
    set_weight( 60 );
    set_max_weight(38);
    set_value( 62000 );
    set_allowed_room_verbs(([ "sitting" : "sits",
                              "standing" : "stands",
                              "leaning" : "leans", 
                              "lying" : "lies",
                              "squatting" : "squats" ]));
} /* setup() */
// --- END [/mnt/home2/grok/lib/obj/furnitures/misc/antique_food_basket.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/furnitures/misc/crane_umbrella_stand.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/furnitures/misc/crane_umbrella_stand.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627864   Available: 13575218
Inodes: Total: 5242880    Free: 4960133
954 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/furnitures/misc/crane_umbrella_stand.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627864   Available: 13575218
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
//Una
//Only for use in Cwc

inherit "/std/room/furniture/storage";

void setup() {
    set_name("stand");
    set_short("lacquered umbrella stand");
    add_adjective( ({ "lacquered", "umbrella" }) );
    set_long("This is a conical umbrella stand that raises in an eight-sided "
        "cylinder.  Often placed by front doors to house the clothing "
        "accessories that are most-loathed, this particular stand is "
        "especially peculiar and eye-catching.  Lacquered with several "
        "shades of beige, green, and brown enamel, its faces boast an "
        "elegant crane taking off from a marshy landscape.\n");
    set_open();
    set_stuck(1);
    set_weight(90);
    set_max_weight(55);
    set_value(40000);
    set_allowed_room_verbs( ([ "squatting" : "squats",
                               "resting" : "rests",
                               "sitting" : "sits",
                               "standing" : "stands" ]) );
}


// --- END [/mnt/home2/grok/lib/obj/furnitures/misc/crane_umbrella_stand.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/furnitures/misc/small_stove.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/furnitures/misc/small_stove.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627864   Available: 13575218
Inodes: Total: 5242880    Free: 4960133
333 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/furnitures/misc/small_stove.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627864   Available: 13575218
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/room/furniture/surface";

void setup() {
  set_name("stove");
  set_short("small stove");
  add_adjective("small");
  set_long("This is a small stove.\n");
  set_allowed_room_verbs(([
    "sitting" : "sits",
    "squatting" : "squats",
  ]));
  set_weight(495);
  set_max_weight(45);
  set_value(8000);
} /* setup() */
// --- END [/mnt/home2/grok/lib/obj/furnitures/misc/small_stove.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/furnitures/misc/bamboo_screen.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/furnitures/misc/bamboo_screen.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627864   Available: 13575218
Inodes: Total: 5242880    Free: 4960133
766 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/furnitures/misc/bamboo_screen.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627864   Available: 13575218
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
// Only for use within CWC - Una 07.02.02

inherit "/std/room/furniture/basic";

void setup() {
    
    set_name( "screen" );
    set_short( "bamboo matchstick screen" );
    add_adjective( ({ "bamboo", "matchstick" }) );
    set_long( "This double-sided screen has been constructed by "
        "lashing long bamboo poles together so that "
        "four distinct interconnected panels are hinged "
        "together when it is standing.  A lovely tan colour, "
        "the texture is rough and the knots in the wood give it "
        "a rustic minimalist look.\n");
    set_allowed_positions( ({ "standing", "sitting" }) );
    set_allowed_room_verbs((["standing" : "stands", "sitting" : "sits" ]) );
    set_weight(20);
    set_value(400000);

} /* setup() */

// --- END [/mnt/home2/grok/lib/obj/furnitures/misc/bamboo_screen.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/furnitures/misc/samurai_screen.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/furnitures/misc/samurai_screen.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627863   Available: 13575217
Inodes: Total: 5242880    Free: 4960133
841 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/furnitures/misc/samurai_screen.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627863   Available: 13575217
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:56.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
// Una
// For use in Cwc

inherit "/std/room/furniture/basic";

void setup() {
    
    set_name( "screen" );
    set_short( "rice paper samurai screen" );
    add_adjective( ({ "rice", "paper", "samurai" }) );
    set_long("This is a simple screen that would fit in most traditional "
        "homes.  A stoic samurai in full traditional Agatean armour and "
        "dress storms across the panelling, hand-drawn in shades of orange, "
        "blue, brown, cream and black.  The frame is made "
        "of a strange combination of walnut and spruce woods, their "
        "differing colours blending well with the shades of the panels.\n");
    set_allowed_positions( ({ "standing", "sitting" }) );
    set_allowed_room_verbs((["standing" : "stands", "sitting" : "sits" ]) );
    set_weight(150);
    set_value(329000);

} /* setup() */
// --- END [/mnt/home2/grok/lib/obj/furnitures/misc/samurai_screen.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/furnitures/misc/dragon_umbrella_stand.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/furnitures/misc/dragon_umbrella_stand.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627863   Available: 13575217
Inodes: Total: 5242880    Free: 4960133
1054 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/furnitures/misc/dragon_umbrella_stand.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627863   Available: 13575217
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
//Una
//Only for use in Cwc

inherit "/std/room/furniture/storage";

void setup() {
    set_name("stand");
    set_short("enamelled umbrella stand");
    add_adjective( ({ "enamelled", "umbrella" }) );
    set_long("To keep the floors clean on rainy days, this hexagonal "
        "decorative umbrella stand suits that purpose perfectly.  A "
        "tin liner sits inside its base to catch inevitable drips and to "
        "protect its wood.  Handpainted with in blacks, golds and reds with "
        "a ferocious looking dragon design, it boasts a brass handle on "
        "each side for ease of lifting.\n");
    add_read_mess("\nMade in Sum Dim.", "tiny golden lettering around the "
        "base", "agatean");
    set_open();
    set_stuck(1);
    set_weight(90);
    set_max_weight(55);
    set_value(44000);
    set_allowed_room_verbs( ([ "squatting" : "squats",
                               "resting" : "rests",
                               "sitting" : "sits",
                               "standing" : "stands" ]) );
} /* setup() */


// --- END [/mnt/home2/grok/lib/obj/furnitures/misc/dragon_umbrella_stand.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/furnitures/misc/crackled_fishbowl.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/furnitures/misc/crackled_fishbowl.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627862   Available: 13575216
Inodes: Total: 5242880    Free: 4960133
1450 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/furnitures/misc/crackled_fishbowl.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627862   Available: 13575216
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:56.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
// Una
// For use in Cwc

inherit "/std/room/furniture/basic";

void setup() {

    set_name( "fishbowl" );
    set_short( "fishbowl with crackled blue enamel" );
    add_adjective( ({ "with", "crackled", "blue", "enamel" }) );
    add_alias("bowl");
    add_plural( ({ "bowls", "fishbowls" }) );
    set_main_plural("fishbowls with cracked blue enamel");
    set_long("Peace and serenity, the foundation for a good life considered "
        "in Agatean philosophy, are reflected in this 16-inch blue and "
        "white porcelain fishbowl.  A special pottery heating technique is "
        "applied in this product.  Looking closely one can see the small "
        "crackles throughout the entire fishbowl, which is more interesting "
        "to the eye than just a plain surface.  The interior is an "
        "underwater scene of gold fish swimming in circular along the edge "
        "of the bowl.  Resting on a beautiful hand-polished cherry wood "
        "base, the shapes of several goldfish can be seen swishing back and "
        "forth beneath the water it holds.\n" );
    set_weight( 120 );
    set_value( 46000 );
    set_allowed_positions(({"sitting"}));
    set_allowed_room_verbs(([ "sitting" : "sits",
                              "standing" : "stands",
                              "leaning" : "leans", 
                              "lying" : "lies",
                              "squatting" : "squats" ]));
} /* setup() */
// --- END [/mnt/home2/grok/lib/obj/furnitures/misc/crackled_fishbowl.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/furnitures/misc/silver_gong.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/furnitures/misc/silver_gong.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627862   Available: 13575216
Inodes: Total: 5242880    Free: 4960133
1162 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/furnitures/misc/silver_gong.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627862   Available: 13575216
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:56.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
// Una
// For use in Cwc

inherit "/std/room/furniture/basic";

void setup() {

    set_name("gong");
    set_short("silver gong");
    add_adjective( "silver" );
    set_long("This is a smallish silver gong, hanging from a silver "
        "frame.  Tiny goldfish swim around each other on the "
        "surface of the disc, nipping each others' tails as they "
        "go.  The gong can be hit to make a loud ringing "
        "sound and annoy everyone in the room.\n");
    set_weight( 40 );
    set_value( 22000 );
    set_material( "silver" );
    set_allowed_positions( ({"hanging"}) );
    set_allowed_room_verbs((["hanging" : "hangs",
                             "sitting" : "sits",
                             "dangling" : "dangles",
                             "standing" : "stands" ]));    
} /* setup() */

void init() {
    this_player()->add_command( "hit", this_object(), "<direct:object:me>" );
} /* init() */

int do_hit(){

    this_player()->add_succeeded_mess(this_object(), "$N $V $p "
        +this_object()->short()+" loudly, filling the room with a "
        "deafening ringing sound.\n", ({ }));    
    return 1;

} /* do_hit() */

// --- END [/mnt/home2/grok/lib/obj/furnitures/misc/silver_gong.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/furnitures/misc/huge_gong.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/furnitures/misc/huge_gong.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627861   Available: 13575215
Inodes: Total: 5242880    Free: 4960133
1261 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/furnitures/misc/huge_gong.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627861   Available: 13575215
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:56.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
// Una
// For use in Cwc

inherit "/std/room/furniture/basic";

void setup() {

    set_name("gong");
    set_short("huge brass gong");
    add_adjective( ({ "huge", "brass" }) );
    set_long("This is a huge brass gong, which hangs from an equally "
        "huge frame.  Prancing peacocks strut around each other on the "
        "surface of the disc, ruffling their tails as they "
        "stretch.  The gong can be hit to make a loud ringing "
        "sound and annoy everyone in the room.\n");
    set_weight( 100 );
    set_value( 42000 );
    set_material( "brass" );
    set_allowed_positions( ({"hanging"}) );
    set_allowed_room_verbs((["hanging" : "hangs",
                             "sitting" : "sits",
                             "dangling" : "dangles",
                             "standing" : "stands" ]));    
} /* setup() */


void init() {
    this_player()->add_command( "hit", this_object(), "<direct:object:me>" );
} /* init() */


int do_hit(){

    this_player()->add_succeeded_mess(this_object(), "$N $V $p "
        +this_object()->short()+" loudly, filling the room with a "
        "deafening crashing ring which reverberates for a few "
        "moments before finally fading away.\n", ({ }));    return 1;

} /* do_hit() */

// --- END [/mnt/home2/grok/lib/obj/furnitures/misc/huge_gong.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/furnitures/misc/newspaper_box.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/furnitures/misc/newspaper_box.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627861   Available: 13575215
Inodes: Total: 5242880    Free: 4960133
8533 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/furnitures/misc/newspaper_box.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627861   Available: 13575215
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*
 *
 *$Id: newspaper_box.c,v 1.5 2003/03/21 01:44:16 ceres Exp $
 *
 */

/**
 * Newspaper box furniture object.
 * This object has to be set to a specific paper and only works for a certain
 * number of issues.  It only works for the owner of the house it is placed in,
 * and only when it is actually placed.
 * It checks for a new release every hour until it's depleted.
 * @author Wirble
 * @started August 2001
 */


inherit "/std/room/furniture/storage";


/* includes */
#include <room/newspaper.h>
#include <move_failures.h>
#include <housing.h>
#include <player_handler.h>

/* functions */
void check_for_new_papers();
void set_paper( string _paper );
void set_issues_left( int _issues );
void set_international( int value );
void set_last_issue( int _issue );

mapping query_dynamic_auto_load();
varargs void init_dynamic_arg( mapping map, object thing );

int query_last_issue();
int query_international();
int query_issues_left();
string query_paper();


/* variables */
private string _paper = "a given newspaper";
private int _last_issue = 0;
private int _issues_left = 1;
private int _international = 0;


/** @ignore */
void setup() {

   set_name( "box" );
   set_short( "newspaper box" );
   add_adjective( "newspaper" );
   set_long( "It's a large box impregnated with an oil designed to attract "
             "delivery-imps.\n" );
   set_allowed_positions( ({ "hanging", "standing" }) );
   set_allowed_room_verbs( ([ "standing": "stands", "hanging": "hangs" ]) );
   add_extra_look( this_object() );
   set_weight( 100 );
   set_max_weight( 300 );
   set_value( 10000 );
   set_open();
   set_stuck( 1 );
   call_out( "check_for_new_papers", 5 );

} /* void setup() */


/** @ignore */
string extra_look() {
   if( !_paper || _paper == "a given newspaper" ) {
      return "The variables of this newspaper box are broken.  Please ask a "
             "creator to re-set them.\n";
   };
   return "This particular one works for " + _paper + ".\n";
} /* string query_box_long() */


/**
 * This function is called after the box loads and then again every hour.
 * If any new issues of the newspaper are available while the box is placed,
 * the necessary property is added to the house's owner and the
 * newspaper-object is put into the box.
 * Once all issues are delivered, the call-out won't reoccur.
 */
void check_for_new_papers() {

   object newspaper;
   object room = environment( this_object() );
   int i, x, latest_issue;
   int* editions_bought;
   string name;

   if( !is_placed() && _issues_left > 0 ) {
      call_out( "check_for_new_papers", 3600 );
      return;
   };
   /* If the box isn't international and the is placed within the newspaper's
    * area OR
    * if it is international and the newspaper exists... */
   if( ( _international == 0 &&
         member_array( _paper, NEWSPAPER_HANDLER->query_papers_in_area(
           HOUSING->query_region( file_name( room ) ) ) ) != -1 ) ||
       ( _international == 1 &&
         member_array( _paper, NEWSPAPER_HANDLER->query_all_papers() ) != -1 ) ){

      latest_issue = NEWSPAPER_HANDLER->query_last_edition_num( _paper );
      name = environment( this_object() )->query_owner();
      if( latest_issue > _last_issue ) {
         tell_room( room,
                    "A " + ({"red", "green", "purple", "blue", "yellow",
                             "drunk", "smelly", "large", "tiny"})[random(9)] +
                    " imp rushes in with some newpapers in its hands and "
                      "disappears in the box.\n" );
         x = latest_issue - _last_issue;
         /* ...all undelivered issues are created and moved to the box... */
         for( i = 0; i < x; i++ ) {
            newspaper = clone_object( NEWSPAPER_OB );
            newspaper->set_paper( _paper );
            newspaper->set_edition( _last_issue + 1 );
            if( !newspaper->move( this_object() ) == MOVE_OK ) {
               tell_room( room,
                          "Something in the box curses and a newspaper is "
                          "thrown to the floor from inside it.\n" );
               newspaper->move( room );
            };
            _last_issue++;
            _issues_left--;
            editions_bought = PLAYER_HANDLER->test_property( name, "Paper " +
                                                              _paper );
            if( !editions_bought ) {
               editions_bought = ({ });
            };
            /* ... and the paper-bought property is added to the player so
             * the web-newspaper-pages become available.
             * Also the newspaper gets paid. */
            if( member_array( _last_issue + 1, editions_bought ) == -1 ) {
               editions_bought += ({ _last_issue });
               PLAYER_HANDLER->special_add_property( name,
                 "Paper " + _paper, editions_bought );
               NEWSPAPER_HANDLER->add_edition_paper_sold( _paper,
                  _last_issue + 1,
                  NEWSPAPER_HANDLER->query_paper_cost( _paper ) );
            } else {
               NEWSPAPER_HANDLER->add_edition_revenue( _paper, _last_issue + 1,
                  NEWSPAPER_HANDLER->query_paper_cost( _paper ) );
            };
            tell_room( room,
                       "You hear some " + ({"giggling", "ranting", "quacking",
                                            "thumping", "cursing", "swearing",
                                            "snickering"})[random(7)] +
                       " emerging, the imp jumps out and runs off again.\n" );
         };
      };
   };

   if( _issues_left == 0 ) {
      set_long( query_long() +
                "It appears the imp-bait is no longer working.\n" );
   } else {
      call_out( "check_for_new_papers", 3600 );
   };

} /* void check_for_new_papers() */


/**
 * This sets the newspaper the box is dedicated to.
 * @param new_paper The newspaper
 */
void set_paper( string new_paper ) {

   _paper = new_paper;

} /* void set_paper() */


/**
 * This sets the number of issues the box will handle.  This shouldn't be
 * used after the initial creation of the box.
 * @param _issues The new number of issues
 */
void set_issues_left( int _issues ) {

   _issues_left = _issues;

} /* void set_issues_left() */


/**
 * This sets the last issue that was delivered.  Since it should only be called
 * when the box is created, it makes sure that the player doesn't get issues
 * that have been published before the box was purchased.
 * @param _issue The latest issue at the time of purchase
 */
void set_last_issue( int _issue ) {

   _last_issue = _issue;

} /* void set_last_issue() */


/** @ignore */
mapping query_dynamic_auto_load() {

   return ([
            "::": ::query_dynamic_auto_load(),
            "_paper": _paper,
            "_issues_left": _issues_left,
            "_last_issue": _last_issue,
            "_international": _international
        ]);
} /* mapping query_dynamic_auto_load() */


/** @ignore */
varargs void init_dynamic_arg( mapping map, object thing ) {

   if( map[ "::" ] && thing ) {
      ::init_dynamic_arg( map[ "::" ], thing );
   } else if( map[ "::" ] ) {
      ::init_dynamic_arg( map[ "::" ] );
   };
   if( map[ "_paper" ] ) {
      set_paper( map[ "_paper" ] );
   };
   if( map[ "_issues_left" ] ) {
      set_issues_left( map[ "_issues_left" ] );
   };
      if( map[ "_last_issue" ] ) {
      set_last_issue( map[ "_last_issue" ] );
   };
      if( map[ "_international" ] ) {
      set_international( map[ "_international" ] );
   };

} /* varargs void init_dynamic_arg() */


/**
 * This queries the last issue of the paper.
 * @return the number of the last delivered issue
 */
int query_last_issue() {
   return _last_issue;
} /* int query_last_issue() */


/**
 * This queries how many issues are left before the box is used up.
 * @return the number of issues left
 */
int query_issues_left() {
   return _issues_left;
} /* int query_issues_left() */


/**
 * This queries if the box will work if it's in a house outside the newspaper's
 * region.
 * @return 1 if international, 0 if not
 */
int query_international() {
   return _international;
} /* int query_international() */


/**
 * This queries what paper the box is set to.
 * @return the name of the paper
 */
string query_paper() {
   return _paper;
} /* string query_paper() */


/**
 * This sets the box to international or not.
 * @param i 1 for international, 0 for not.
 */
void set_international( int i ) {
   _international = i;
} /* void set_international() */


// --- END [/mnt/home2/grok/lib/obj/furnitures/misc/newspaper_box.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/furnitures/misc/garden_fishbowl.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/furnitures/misc/garden_fishbowl.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627858   Available: 13575212
Inodes: Total: 5242880    Free: 4960133
1393 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/furnitures/misc/garden_fishbowl.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627858   Available: 13575212
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:56.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
// Una
// For use in Cwc

inherit "/std/room/furniture/basic";

void setup(){

    set_name( "fishbowl" );
    set_short( "gold-leafed garden fishbowl" );
    add_adjective( ({ "gold", "leafed", "leaf", "gold-leaf", "gold-leafed", 
        "garden" }) );
    add_alias("bowl");
    add_plural( ({ "bowls", "fishbowls" }) );
    set_long("Reading a story that is visualized on an art object is a "
        "particular kind of enjoyment.  A scene from the Agatean classic, "
        "'The Dream of Red Chamber' is hand-painted on this sixteen-inch "
        "fishbowl, in which the heroine expresses forbidden love in her "
        "poetry.  In this scene one also has a glimpse of traditional "
        "Agatean house garden.  The colorful scenery is painted over "
        "multi-layered gold leaf which has been carefully applied by hand.  "
        "Resting on a beautiful hand-polished rosewood base, "
        "the shapes of several goldfish can be seen swishing back and "
        "forth beneath the water it holds.\n" );
    set_weight( 110 );
    set_value( 52000 );
    set_allowed_positions(({"sitting"}));
    set_allowed_room_verbs(([ "sitting" : "sits",
                              "standing" : "stands",
                              "leaning" : "leans", 
                              "lying" : "lies",
                              "squatting" : "squats" ]));
} /* setup() */
// --- END [/mnt/home2/grok/lib/obj/furnitures/misc/garden_fishbowl.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/furnitures/misc/cherryblossom_screen.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/furnitures/misc/cherryblossom_screen.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627858   Available: 13575212
Inodes: Total: 5242880    Free: 4960133
783 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/furnitures/misc/cherryblossom_screen.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627858   Available: 13575212
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
// Only for use within CWC - Una 07.02.02

inherit "/std/room/furniture/basic";

void setup() {

    set_name( "screen" );
    set_short( "cherry blossom shoji screen" );
    add_adjective( ({ "cherry", "blossom", "shoji" }) );
    set_long( "A stunning cherry blossom tree adorns the "
        "silk panelling of this double-sided shoji "
        "screen.  Four panels with black wooden trim fold "
        "out to make this screen stand tall, its blossoms "
        "painted on with the most precise hand, the thickness "
        "of the paint still showing on the silk panels.\n");
    set_allowed_positions( ({ "standing", "sitting" }) );
    set_allowed_room_verbs((["standing" : "stands", "sitting" : "sits" ]) );
    set_weight(20);
    set_value(400000);

} /* setup() */

	
// --- END [/mnt/home2/grok/lib/obj/furnitures/misc/cherryblossom_screen.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/furnitures/misc/calligraphy_fishbowl.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/furnitures/misc/calligraphy_fishbowl.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627858   Available: 13575212
Inodes: Total: 5242880    Free: 4960133
1088 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/furnitures/misc/calligraphy_fishbowl.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627858   Available: 13575212
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:56.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
// Una
// For use in Cwc

inherit "/std/room/furniture/basic";

void setup() {

    set_name( "fishbowl" );
    set_short( "calligraphised fishbowl" );
    add_adjective( ({ "calligraphised", "fish" }) );
    add_alias("bowl");
    add_plural( ({ "bowls", "fishbowls" }) );
    set_long("Calligraphy is the soul of Agatean culture.  On this 16-inch "
        "fishbowl a Zing Dynasty poem is strikingly carved in "
        "and then gold leafed against an equally striking black background.  "
        "The black lacquer is hand-painted over porcelain to create a matte "
        "effect.  A matching solid wood stand holds the bowl's weight, "
        "and several goldfish swim quietly beneath the water it holds.\n" );
    set_weight( 110 );
    set_value( 48000 );
    set_allowed_positions(({"sitting"}));
    set_allowed_room_verbs(([ "sitting" : "sits",
                              "standing" : "stands",
                              "leaning" : "leans", 
                              "lying" : "lies",
                              "squatting" : "squats" ]));
} /* setup() */
// --- END [/mnt/home2/grok/lib/obj/furnitures/misc/calligraphy_fishbowl.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/furnitures/misc/muslin_screen.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/furnitures/misc/muslin_screen.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627857   Available: 13575211
Inodes: Total: 5242880    Free: 4960133
764 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/furnitures/misc/muslin_screen.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627857   Available: 13575211
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:56.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
// Una
// For use in Cwc

inherit "/std/room/furniture/basic";

void setup() {
    
    set_name( "screen" );
    set_short( "muslin screen" );
    add_adjective( "muslin" );
    set_long( "This is a simple and traditional double-hinged "
        "screen, its panels filled in with a long sheet of roughly "
        "textured cream-coloured muslin fabric.  A lightly coloured "
        "construction, the material has been gathered at the top "
        "and bottom ends to produce a eye-pleasing loosely pleated "
        "effect which continues down its length.\n");
    set_allowed_positions( ({ "standing", "sitting" }) );
    set_allowed_room_verbs((["standing" : "stands", "sitting" : "sits" ]) );
    set_weight(150);
    set_value(225000);

} /* setup() */
// --- END [/mnt/home2/grok/lib/obj/furnitures/misc/muslin_screen.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/furnitures/misc/large_gong.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/furnitures/misc/large_gong.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627857   Available: 13575211
Inodes: Total: 5242880    Free: 4960133
1184 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/furnitures/misc/large_gong.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627857   Available: 13575211
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:56.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
// Una
// For use in Cwc

inherit "/std/room/furniture/basic";

void setup() {

    set_name("gong");
    set_short("large brass gong");
    add_adjective( ({ "large", "brass" }) );
    set_long("This is a large brass gong, which hangs from an equally "
        "large frame.  Tiny dragons writhe around each other on the "
        "surface of the disc, nipping each others' tails as they "
        "stretch.  The gong can be hit to make a loud ringing "
        "sound and annoy everyone in the room.\n");
    set_weight( 80 );
    set_value( 38000 );
    set_material( "brass" );
    set_allowed_positions( ({"hanging"}) );
    set_allowed_room_verbs((["hanging" : "hangs",
                             "sitting" : "sits",
                             "dangling" : "dangles",
                             "standing" : "stands" ]));    
} /* setup() */

void init() {
    this_player()->add_command( "hit", this_object(), "<direct:object:me>" );
} /* init() */

int do_hit(){

    this_player()->add_succeeded_mess(this_object(), "$N $V $p "
        +this_object()->short()+" loudly, filling the room with a "
        "loud crashing ring.\n", ({ }));    return 1;

} /* do_hit() */

// --- END [/mnt/home2/grok/lib/obj/furnitures/misc/large_gong.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/furnitures/misc/hatstand.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/furnitures/misc/hatstand.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627856   Available: 13575210
Inodes: Total: 5242880    Free: 4960133
855 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/furnitures/misc/hatstand.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627856   Available: 13575210
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
// Aquilo //

inherit "/std/room/furniture/surface";

void setup(){
  set_name("stand");
  set_short("tall hat stand");
  add_adjective( ({"tall", "hat"}) );
  add_alias( "hatstand" );
  add_plural("tall hat stands");
  set_long("This is a tall, serious looking hatstand.  It is made of "
    "dark sturdy teak wood and stands proud on four lavishly decorated "
    "legs.  The top has been carved into the grand shape of A'Tuin, "
    "upon which the elephants and the Disc have been elaborately "
    "sculpted, capturing the true beauty of the scene.  The turtle's "
    "flippers extend outwards and are where the coats and hats "
    "are hung.\n");
  set_weight(150);
  set_max_weight(200);
  set_allowed_room_verbs((["standing" : "stands",
                           "looming"  : "looms"  ]));
	set_put_aliases(({"hang"}));
  set_value(75000);

}

// --- END [/mnt/home2/grok/lib/obj/furnitures/misc/hatstand.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/furnitures/misc/flint.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/furnitures/misc/flint.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627856   Available: 13575210
Inodes: Total: 5242880    Free: 4960133
313 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/furnitures/misc/flint.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627856   Available: 13575210
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
// Aquilo //

inherit "/std/object";

void setup(){
  set_name("flint");
  set_short("flint stone");
  set_long("This is a flint stone.  It looks slightly worn and chipped "
    "but it's still keen enough to serve its purpose.\n");
  add_property("no recycling", 1);
  add_alias("stone");
  set_value( 600 );
}

// --- END [/mnt/home2/grok/lib/obj/furnitures/misc/flint.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/furnitures/misc/satsuma_fishbowl.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/furnitures/misc/satsuma_fishbowl.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627855   Available: 13575209
Inodes: Total: 5242880    Free: 4960133
1454 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/furnitures/misc/satsuma_fishbowl.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627855   Available: 13575209
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:56.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
// Una
// For use in Cwc

inherit "/std/room/furniture/basic";

void setup() {

    set_name( "fishbowl" );
    set_short( "satsuma fishbowl" );
    add_adjective( ({ "satsuma" }) );
    add_alias("bowl");
    add_plural( ({ "bowls", "fishbowls" }) );
    set_long("Learning is regarded the highest virtue in Agatean "
        "culture.  The picture on this "
        "fishbowl depicts a group of scholars in a session of discussion.  "
        "This fishbowl is made of porcelain and hand-painted with dark-green "
        "lacquer.  On top of the lacquer gold threads are woven in "
        "decorative design.  One intriguing detail about this particular  "
        "fishbowl is that thousands of tiny dots are meticulously painted "
        "one by one over the entire 16-inch fishbowl.  The interior is an "
        "underwater scene of gold fish swimming in circular along the edge "
        "of the bowl.  Resting on a beautiful hand-polished mahogany base, "
        "the shapes of several goldfish can be seen swishing back and "
        "forth beneath the water it holds.\n" );
    set_weight( 110 );
    set_value( 56000 );
    set_allowed_positions(({"sitting"}));
    set_allowed_room_verbs(([ "sitting" : "sits",
                              "standing" : "stands",
                              "leaning" : "leans", 
                              "lying" : "lies",
                              "squatting" : "squats" ]));
} /* setup() */
// --- END [/mnt/home2/grok/lib/obj/furnitures/misc/satsuma_fishbowl.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/furnitures/misc/latticed_screen.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/furnitures/misc/latticed_screen.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627855   Available: 13575209
Inodes: Total: 5242880    Free: 4960133
757 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/furnitures/misc/latticed_screen.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627855   Available: 13575209
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
// Only for use within CWC - Una 07.02.02

inherit "/std/room/furniture/basic";

void setup() {
    
    set_name( "screen" );
    set_short( "latticed shoji screen" );
    add_adjective( ({ "latticed", "shoji" }) );
    set_long( "This double-sided shoji screen has a latticed "
        "wood pattern made of ramin hardwood.  A lovely honey "
        "oak colour, the panelling is broken up by rice paper "
        "dividers which checker the screen from the top all "
        "the way down to the solid kick panel which runs along "
        "the bottom.\n");
    set_allowed_positions( ({ "standing", "sitting" }) );
    set_allowed_room_verbs((["standing" : "stands", "sitting" : "sits" ]) );
    set_weight(20);
    set_value(400000);

} /* setup() */

// --- END [/mnt/home2/grok/lib/obj/furnitures/misc/latticed_screen.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/furnitures/misc/tiny_gong.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/furnitures/misc/tiny_gong.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627854   Available: 13575208
Inodes: Total: 5242880    Free: 4960133
1177 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/furnitures/misc/tiny_gong.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627854   Available: 13575208
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:56.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
// Una
// For use in Cwc

inherit "/std/room/furniture/basic";

void setup() {

    set_name("gong");
    set_short("tiny brass gong");
    add_adjective( ({ "tiny", "brass" }) );
    set_long("This is a tiny brass gong, which hangs from an equally "
        "tiny frame.  Fluttering butterflies flit around each other on the "
        "disc, flying aimlessly across its smooth "
        "surface.  The gong can be hit to make a loud ringing "
        "sound and annoy everyone in the room.\n");
    set_weight( 20 );
    set_value( 15000 );
    set_material( "brass" );
    set_allowed_positions( ({"hanging"}) );
    set_allowed_room_verbs((["hanging" : "hangs",
                             "sitting" : "sits",
                             "dangling" : "dangles",
                             "standing" : "stands" ]));    
} /* setup() */

void init() {
    this_player()->add_command( "hit", this_object(), "<direct:object:me>" );
} /* init() */

int do_hit(){

    this_player()->add_succeeded_mess(this_object(), "$N $V $p "
        +this_object()->short()+" loudly, filling the room with a"
        " tiny tinkling chime.\n", ({ }));
    return 1;

} /* do_hit() */



// --- END [/mnt/home2/grok/lib/obj/furnitures/misc/tiny_gong.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/furnitures/misc/mandarin_fan_screen.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/furnitures/misc/mandarin_fan_screen.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627854   Available: 13575208
Inodes: Total: 5242880    Free: 4960133
902 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/furnitures/misc/mandarin_fan_screen.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627854   Available: 13575208
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:56.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
// Una
// For use in Cwc

inherit "/std/room/furniture/basic";

void setup() {
    
    set_name( "screen" );
    set_short( "mandarin fan screen" );
    add_adjective( ({ "mandarin", "fan", "hana" }) );
    set_long( "This beautiful screen has a lovely walnut oak frame which "
        "pales in comparison to the panelling it holds.  Three smooth silk "
        "panels, each divided into eighteen square segments, sit "
        "in the hinged frame, each one handpainted in brilliant mandarin, "
        "lilac, cream and peridot watercolours with a mandarin orange "
        "hana fan design.  The frame is double-hinged so it can bend both "
        "backwards and forward to suit its placement.\n");
    set_allowed_positions( ({ "standing", "sitting" }) );
    set_allowed_room_verbs((["standing" : "stands", "sitting" : "sits" ]) );
    set_weight(150);
    set_value(395000);

} /* setup() */
// --- END [/mnt/home2/grok/lib/obj/furnitures/misc/mandarin_fan_screen.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/furnitures/misc/sung_umbrella_stand.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/furnitures/misc/sung_umbrella_stand.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627854   Available: 13575208
Inodes: Total: 5242880    Free: 4960133
1151 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/furnitures/misc/sung_umbrella_stand.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627854   Available: 13575208
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:56.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
//Una
//Only for use in Cwc

inherit "/std/room/furniture/storage";

void setup() {
    set_name("stand");
    set_short("Sung umbrella stand");
    add_adjective( ({ "Sung", "umbrella" }) );
    set_long("This is a conical umbrella stand that raises itself up in an "
        "smooth-sided cylinder.  Often placed by front doors to house the "
        "clothing accessories that are most-loathed, this particular "
        "stand has been lacquered with several shades of gold, red, blue, "
        "green and cream and depicts the Sung Estate as it is seen from the "
        "banks of the Pearl River in the Sum Bing district of Bes Pelargic.  "
        "Several white ceramic lions border the estate, guarding it and "
        "bestowing several thousand years of good luck upon its "
        "inhabitants.\n");
    set_open();
    set_stuck(1);
    set_weight(90);
    set_max_weight(55);
    set_value(51000);
    set_allowed_room_verbs( ([ "squatting" : "squats",
                               "resting" : "rests",
                               "sitting" : "sits",
                               "standing" : "stands" ]) );
} /* setup() */


// --- END [/mnt/home2/grok/lib/obj/furnitures/misc/sung_umbrella_stand.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/furnitures/misc/landscape_screen.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/furnitures/misc/landscape_screen.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627853   Available: 13575207
Inodes: Total: 5242880    Free: 4960133
960 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/furnitures/misc/landscape_screen.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627853   Available: 13575207
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:56.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
// Una
// For use in Cwc

inherit "/std/room/furniture/basic";

void setup() {
    
    set_name( "screen" );
    set_short( "watercolour landscape screen" );
    add_adjective( ({ "watercolour", "landscape" }) );
    set_long( "This beautiful screen has a lovely honey rosewood frame that "
        "pales in comparison to the panelling it holds.  Three rice "
        "paper panels sit in the hinged frame, each one handpainted in "
        "watercolours and depicting "
        "one third of a Agatean mountain landscape.  The frame is "
        "double-hinged so it can bend both backwards and forward to suit "
        "its placement, and the rice paper panelling has been ribbed with "
        "matchstick-like strings of wood to give it more support. \n");
    set_allowed_positions( ({ "standing", "sitting" }) );
    set_allowed_room_verbs((["standing" : "stands", "sitting" : "sits" ]) );
    set_weight(150);
    set_value(400000);

} /* setup() */
// --- END [/mnt/home2/grok/lib/obj/furnitures/misc/landscape_screen.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/furnitures/misc/peony_fishbowl.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/furnitures/misc/peony_fishbowl.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627853   Available: 13575207
Inodes: Total: 5242880    Free: 4960133
1227 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/furnitures/misc/peony_fishbowl.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627853   Available: 13575207
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:56.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
// Una
// For use in Cwc

inherit "/std/room/furniture/basic";

void setup() {

    set_name( "fishbowl" );
    set_short( "gold-leafed peony fishbowl" );
    add_adjective( ({ "gold", "leafed", "leaf", "gold-leaf", "gold-leafed", 
        "peony" }) );
    add_plural( ({ "bowls", "fishbowls" }) );
    add_alias("bowl");
    set_long( "Richly designed with blooming peonies, the flower that "
        "symbolizes peace and prosperity in Agatean culture, this grand "
        "16-inch fishbowl is carefully hand-layered with gold leaf over "
        "porcelain and hand-painted in exuberant colors.  This fishbowl "
        "matches any kind of foliage or simply stands alone as an art "
        "object.  Resting on a beautiful hand-polished rosewood base, "
        "the shapes of several goldfish can be seen swishing back and "
        "forth beneath the water it holds.\n" );
  set_weight( 110 );
  set_value( 51000 );
  set_allowed_positions(({"sitting"}));
  set_allowed_room_verbs((["sitting" : "sits",
                           "standing" : "stands",
                           "leaning" : "leans", 
                           "lying" : "lies",
                           "squatting" : "squats" ]));
} /* setup() */
// --- END [/mnt/home2/grok/lib/obj/furnitures/misc/peony_fishbowl.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/furnitures/misc/blackboard.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/furnitures/misc/blackboard.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627852   Available: 13575206
Inodes: Total: 5242880    Free: 4960133
3560 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/furnitures/misc/blackboard.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627852   Available: 13575206
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 *
 *  Simple Blackboard For Simple Houses
 *
 *  Suggested by Lanfear.
 *  @author Drakkos
 *  @started 16/06/2000
 *
 */

inherit "/std/room/furniture/basic";


int query_allowed (string);

string read_stuff();
string query_words();

string _owner = "";
string _words = "";

void setup() {
    
  set_name ("blackboard");
  set_short ("blackboard");
  add_alias (({"board", "sign"}));
  set_long ("The residue of faded chalk-dust and long forgotten "
      "doodles lies heavily on the blackboard.  The grain of the "
      "board is worn and slightly mottled with age, hinting at "
      "a long and dignified history of classrooms and university "
      "lecterns.  Or perhaps just hinting at cheap wood and "
      "bad upkeep.\n");
  set_read_mess ((: read_stuff :));    
  set_allowed_room_verbs( (["standing" : "stands",
                          "hanging"  : "hangs"]) );
  set_value(0);
}

void init() {
  this_player()->add_command ("write", this_object(), "[on] <direct:object>");
  this_player()->add_command ("clean", this_object(), "<direct:object>");
}    

void set_words (string bing) {
    _words = bing;
}

string query_words () {
    return _words;
}
            
string read_stuff() {
    string bing = "";
    
    if (sizeof (query_words())) {
        bing += query_words();            
    }
    
    if (!sizeof (bing)) {
        bing = "A few random letters that escaped cleaning can be seen on "
            "the blackboard.";
    }
    
    return bing;
}

int do_clean() {
    if (!query_allowed (this_player()->query_name())) {
        this_player()->add_failed_mess (this_object(), "You cannot clean " 
            "the blackboard!\n", ({ }));
        return 0;
    }
    
    set_words ("");
    return 1;
}

int do_write() {
    string bean;
    if (!query_allowed (this_player()->query_name())) {
        this_player()->add_failed_mess (this_object(), "You cannot write on " 
            "the blackboard!\n", ({ }));
        return 0;
    }
                
    bean = query_words();
                    
    this_player()->do_edit(bean, "blackboard_text", this_object());
    
    this_player()->add_succeeded_mess (this_object(), "$N find$s a handy "
        "piece of chalk and start$s to write on the blackboard.\n", ({ }));
    return 1;

}

void blackboard_text(string text) {

    if (!text) {
      tell_room (environment (this_object()), this_player()->one_short()
          + " steps back from the blackboard without making any "
          "changes.\n", this_player());
      tell_object (this_player(), "Okay, nothing has been changed.\n");
      return;
    }

    set_words (text);
                
    tell_room(environment (this_object()), this_player()->one_short() 
      + " finishes writing on the blackboard.\n", this_player());
}


int query_allowed (string name) {

    if (function_exists ("query_owner", environment (this_object()))) {
      if (name == environment (this_object())->query_owner()) {
        return 1;
      }
    }
        
    if (function_exists ("query_allowed", environment (this_object()))) {
      if (member_array (name, environment(this_object())->query_allowed())
          != -1) {
        return 1;
      }
      else {
        return 0;
      }
      
    }    
    return 1;
}


mapping query_dynamic_auto_load() {
   return ([
     "::" : ::query_dynamic_auto_load(),
      "words" : query_words(),
   ]);

} 

void init_dynamic_arg( mapping map ) {
   ::init_dynamic_arg( map[ "::" ] );
   set_words (map["words"]);
   
   set_read_mess ((: read_stuff :));    
}


// --- END [/mnt/home2/grok/lib/obj/furnitures/misc/blackboard.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/furnitures/misc/mado_screen.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/furnitures/misc/mado_screen.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627851   Available: 13575205
Inodes: Total: 5242880    Free: 4960133
649 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/furnitures/misc/mado_screen.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627851   Available: 13575205
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:56.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
// Una
// For use in Cwc

inherit "/std/room/furniture/basic";

void setup() {
    
    set_name( "screen" );
    set_short( "mado screen" );
    add_adjective( "mado" );
    set_long( "This traditional mado screen has a double-sided "
        "latticework frame made of lacquered red cedar.  Between "
        "the two sides of the frame lies a large sheet of smooth "
        "white rice paper that looks quite delicate and "
        "fragile.  \n");
    set_allowed_positions( ({ "standing", "sitting" }) );
    set_allowed_room_verbs((["standing" : "stands", "sitting" : "sits" ]) );
    set_weight(150);
    set_value(350000);

} /* setup() */
// --- END [/mnt/home2/grok/lib/obj/furnitures/misc/mado_screen.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/furnitures/misc/fine_fireplace.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/furnitures/misc/fine_fireplace.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627851   Available: 13575205
Inodes: Total: 5242880    Free: 4960133
709 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/furnitures/misc/fine_fireplace.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627851   Available: 13575205
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
// Aquilo //
/* This fireplace uses all the default settings in the inherit as 
   those are pretty nifty
*/

inherit "/std/room/furniture/fireplace";

void setup(){
  /* Functions below can be called in the setup of the inheriting 
     fireplace to over-ride these and modify its appearance.
     See help on each function for further info.
   */
  set_allowed_positions(({"sitting"}));
  set_allowed_room_verbs((["sitting" : "sits" ]));
  set_weight(700);
  set_max_weight(100); // About 4 logs worth

  set_short("finely crafted fireplace");
  set_long("This fireplace is surrounded by an ornately carved mahogany "
     "framework and has a beautifully finished brass hearth.\n");
  set_value(900000);
}
// --- END [/mnt/home2/grok/lib/obj/furnitures/misc/fine_fireplace.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/furnitures/misc/hunghungese_screen.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/furnitures/misc/hunghungese_screen.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627850   Available: 13575204
Inodes: Total: 5242880    Free: 4960133
982 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/furnitures/misc/hunghungese_screen.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627850   Available: 13575204
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:56.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
// Una
// For use in Cwc

inherit "/std/room/furniture/basic";

void setup() {
    
    set_name( "screen" );
    set_short( "HungHungese screen" );
    add_adjective( ({ "hunghungese", "HungHungese", "hunghung", 
        "HungHung" }) );
    set_long( "This is a contemporary double-sided screen for the home.  "
        "Framed in a light spruce, the panels of the screen have been "
        "included in the main construction of the frame and form a "
        "checkerboard pattern across its length.  Inside the "
        "checkerboard are long panels of cotton that have depictions "
        "of life in a hectic HungHung market.  There are several "
        "ducks, a few sheep, some dried fish and a lot of people "
        "that look like they are shouting at one another.\n");
    set_allowed_positions( ({ "standing", "sitting" }) );
    set_allowed_room_verbs((["standing" : "stands", "sitting" : "sits" ]) );
    set_weight(150);
    set_value(325000);

} /* setup() */
// --- END [/mnt/home2/grok/lib/obj/furnitures/misc/hunghungese_screen.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/furnitures/misc/waterbuffalo_dung.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/furnitures/misc/waterbuffalo_dung.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627850   Available: 13575204
Inodes: Total: 5242880    Free: 4960133
754 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/furnitures/misc/waterbuffalo_dung.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627850   Available: 13575204
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:56.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming

inherit "/std/room/furniture/fuel_inherit";

void setup() {

  set_name("dung");
  set_shorts( ({ "small lump of dried waterbuffalo dung",
                 "slightly burnt lump of waterbuffalo dung",
                 "blackened lump of waterbuffalo dung",
                 "black, charred lump of dung" }) );

  set_longs( ({ 
    "This is a small lump of dried waterbuffalo dung.  It looks as "
        "though it would burn well.\n",
    "This is a small lump of dried waterbuffalo dung.  It has been "
        "charred around the edges but would still burn for a while yet.\n",
    "This is a black lump of charred dung, which is barely able to still "
        "hold itself together.\n" }) );

  set_weight( 9 );
  set_value( 200 );

} /* setup() */
// --- END [/mnt/home2/grok/lib/obj/furnitures/misc/waterbuffalo_dung.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/furnitures/misc/log.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/furnitures/misc/log.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627849   Available: 13575203
Inodes: Total: 5242880    Free: 4960133
640 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/furnitures/misc/log.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627849   Available: 13575203
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
// Aquilo //

#define WEIGHT 25

inherit "/std/room/furniture/fuel_inherit";

void setup(){

  set_name("log");
  set_shorts( ({ "small log",
                 "slightly burnt log",
                 "blackened log",
                 "black, charred log" }) );

  set_longs( ({ 
    "This is a small dumpy log.  It looks as though it would burn well.\n",
    "This is a small dumpy log.  It has been charred around the edges "
      "but would still burn for a while yet.\n",
    "This is a black lump of charred wood, which is just about holding "
      "its shape together as a log.\n" }) );

  set_weight( WEIGHT );
  set_value( 400 );

}
// --- END [/mnt/home2/grok/lib/obj/furnitures/misc/log.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/furnitures/misc/textured_leaf_screen.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/furnitures/misc/textured_leaf_screen.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627849   Available: 13575203
Inodes: Total: 5242880    Free: 4960133
958 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/furnitures/misc/textured_leaf_screen.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627849   Available: 13575203
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:56.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
// Una
// For use in Cwc

inherit "/std/room/furniture/basic";

void setup() {
    
    set_name( "screen" );
    set_short( "textured leaf screen" );
    add_adjective( ({ "textured", "leaf" }) );
    set_long( "This beautiful screen has a lovely honey oak frame which "
        "pales in comparison to the panelling it holds.  Three textured rice "
        "paper panels, each divided into six vertical segments, sit "
        "in the hinged frame, each one handpainted in "
        "watercolours with a tan leaf design.  The frame is "
        "double-hinged so it can bend both backwards and forward to suit "
        "its placement, and the rice paper panelling has been ribbed with "
        "matchstick-like strings of wood to give it more support. \n");
    set_allowed_positions( ({ "standing", "sitting" }) );
    set_allowed_room_verbs((["standing" : "stands", "sitting" : "sits" ]) );
    set_weight(150);
    set_value(290000);

} /* setup() */
// --- END [/mnt/home2/grok/lib/obj/furnitures/misc/textured_leaf_screen.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/furnitures/misc/spruce_screen.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/furnitures/misc/spruce_screen.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627849   Available: 13575203
Inodes: Total: 5242880    Free: 4960133
866 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/furnitures/misc/spruce_screen.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627849   Available: 13575203
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:56.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
// Una
// For use in Cwc

inherit "/std/room/furniture/basic";

void setup() {
    
    set_name( "screen" );
    set_short( "double cross spruce screen" );
    add_adjective( ({ "double", "cross", "spruce" }) );
    set_long( "This double-sided screen has been constructed by "
        "lashing pairs of long spruce strips together so that "
        "three distinct interconnected panels are hinged "
        "together when it is standing.  The frame, decorated with "
        "criss-crossed pairs of spruce poles, is covered by a "
        "thin layer of rice paper that breaks up light and "
        "sheds a warm glow on a room when a lamp is placed behind it.\n");
    set_allowed_positions( ({ "standing", "sitting" }) );
    set_allowed_room_verbs((["standing" : "stands", "sitting" : "sits" ]) );
    set_weight(150);
    set_value(400000);

} /* setup() */
// --- END [/mnt/home2/grok/lib/obj/furnitures/misc/spruce_screen.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/furnitures/misc/lava_lamp.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/furnitures/misc/lava_lamp.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627848   Available: 13575202
Inodes: Total: 5242880    Free: 4960133
1497 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/furnitures/misc/lava_lamp.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627848   Available: 13575202
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#define CREATOR "Rue"
// Rue, 5.2000 - lava lamp; special effects by Tannah

inherit "/std/room/furniture/basic";
#define MEDITATION "/std/effects/other/meditate_effect"

void setup() {
    set_name("lamp");
    set_short("lava lamp");
    set_light(25);
    add_adjective( ({ "lava", "red" }) );
    add_alias( ({ "lamp" }) );
    set_long( "This is an odd looking lamp, roughly the shape of an "
        "hourglass, with a brass base.  It is filled with murky pink "
        "liquid and large blobs of red goo that ooze this way and that.  "
        "The exact nature of the red goo is a mystery.  Some say it is "
        "a primitive type of troll that is still in its magma stage.  "
        "Others reckon it is something that got away from the Alchemists' "
        "Guild.  It gives off a faint light.\n" );
  
    item_chat( ({ 120, 360, ({
        "A rather disgusting wet popping noise comes from the lava lamp.",
        "A strange sucking noise seems to be coming from the lava lamp."
  
    }) }) );
  
    set_allowed_positions(({"sitting","standing"}));
    set_allowed_room_verbs((["sitting" : "sits", "standing" : "stands" ]));
    set_weight(82);
    set_value(20500);
    
} /* setup() */

void init() {
    ::init();
    add_command( "stare", "at <direct:object'lamp'>" );
} /* init() */

int do_stare() {
    call_out( (: $(this_player())->add_effect( MEDITATION ) :), 1 );
    add_succeeded_mess( "$N $V dreamily at $D and zone$s out.\n");
    return 1;
} /* do_stare() */

// --- END [/mnt/home2/grok/lib/obj/furnitures/misc/lava_lamp.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/furnitures/misc/lectern.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/furnitures/misc/lectern.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627848   Available: 13575202
Inodes: Total: 5242880    Free: 4960133
444 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/furnitures/misc/lectern.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627848   Available: 13575202
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/room/furniture/surface";

void setup() {
  set_name("lectern");
  set_short("oak lectern");
  add_adjective(({"oak", "ornate"}));
  set_long("The lectern has a heavy wooden base carved with"
					 " twining leaves and a flat top perfect for a book.\n");
  set_allowed_positions(({"sitting"}));
  set_allowed_room_verbs((["sitting" : "sits", "standing" : "stands" ]));
  set_weight(350);
  set_max_weight(50);
  set_value(1400);
}
// --- END [/mnt/home2/grok/lib/obj/furnitures/misc/lectern.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/furnitures/misc/geisha_screen.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/furnitures/misc/geisha_screen.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627847   Available: 13575201
Inodes: Total: 5242880    Free: 4960133
890 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/furnitures/misc/geisha_screen.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627847   Available: 13575201
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:56.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
// Una
// For use in Cwc

inherit "/std/room/furniture/basic";

void setup() {
    
    set_name( "screen" );
    set_short( "rice paper geisha screen" );
    add_adjective( ({ "rice", "paper", "geisha" }) );
    set_long("This is a simple screen that would fit in most traditional "
        "homes.  Quiet geishas relax on "
        "its rice paper panelling, hand-drawn on a bamboo balcony, "
        "they sit and sip tea in peace and solitude or play mandolin-like "
        "instruments which sit silently in their laps.  The frame is made "
        "of a strange combination of walnut and spruce woods, their "
        "differing colours blending well with the shades of the panels.\n");
    set_allowed_positions( ({ "standing", "sitting" }) );
    set_allowed_room_verbs((["standing" : "stands", "sitting" : "sits" ]) );
    set_weight(150);
    set_value(320000);

} /* setup() */
// --- END [/mnt/home2/grok/lib/obj/furnitures/misc/geisha_screen.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/furnitures/misc/platinum_gong.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/furnitures/misc/platinum_gong.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627847   Available: 13575201
Inodes: Total: 5242880    Free: 4960133
1188 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/furnitures/misc/platinum_gong.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627847   Available: 13575201
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:56.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
// Una
// For use in Cwc

inherit "/std/room/furniture/basic";

void setup() {

    set_name("gong");
    set_short("platinum gong");
    add_adjective( "platinum" );
    set_long("This is a smallish platinum gong, hanging from a platinum "
        "frame.  Leaping lions writhe around each other on the "
        "surface of the disc, showing their teeth as they "
        "run across the etchings.  The gong can be hit to make a "
        "loud ringing sound and annoy everyone in the room.\n");
    set_weight( 30 );
    set_value( 28000 );
    set_material( "platinum" );
    set_allowed_positions( ({"hanging"}) );
    set_allowed_room_verbs((["hanging" : "hangs",
                             "sitting" : "sits",
                             "dangling" : "dangles",
                             "standing" : "stands" ]));    
} /* setup() */

void init() {
    this_player()->add_command( "hit", this_object(), "<direct:object:me>" );
} /* init() */

int do_hit(){

    this_player()->add_succeeded_mess(this_object(), "$N $V $p "
        +this_object()->short()+" loudly, filling the room with a "
        "deafening ringing sound.\n", ({ }));    
    return 1;

} /* do_hit() */

// --- END [/mnt/home2/grok/lib/obj/furnitures/misc/platinum_gong.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/furnitures/misc/iron_hatstand.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/furnitures/misc/iron_hatstand.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627846   Available: 13575200
Inodes: Total: 5242880    Free: 4960133
710 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/furnitures/misc/iron_hatstand.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627846   Available: 13575200
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
// Rue - with help from Aquilo, 4.2000 //

inherit "/std/room/furniture/surface";

void setup(){
  set_name( "stand" );
  set_short( "wrought iron hat stand" );
  add_adjective( ({ "wrought", "iron", "hat" }) );
  add_alias( ({ "hatstand", "rack", "hat rack", "hatrack" }) );
  add_plural( "wrought iron hat stands" );
  set_long("This is a solid hat stand made of gracefully designed "
    "wrought iron.  It rests on four clawed feet, while the base "
    "of the stand wraps around itself in a spiral.  There are "
    "plenty of hooks at the top.\n");
  set_weight(250);
  set_max_weight(200);
  set_allowed_room_verbs(([ "standing" : "stands" ]));
	set_put_aliases( ({ "hang" }) );
  set_value(9000);

}

// --- END [/mnt/home2/grok/lib/obj/furnitures/misc/iron_hatstand.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/furnitures/lamps/teahouse_stone_lamp.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/furnitures/lamps/teahouse_stone_lamp.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627846   Available: 13575200
Inodes: Total: 5242880    Free: 4960133
6283 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/furnitures/lamps/teahouse_stone_lamp.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627846   Available: 13575200
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
// Only for use within CWC - Una 07.02.02


inherit "/std/room/furniture/basic";

#define BRIGHTNESS      60
#define FUEL_PER_TICK  FUEL_TIME

int     fuel_left;
int     is_lit;
int     has_tealight;
mapping vars = (["is lit": 0, "fuel left": 20, "has tealight" : 1 ]);
void    dest_me();
int     do_dowse();
int     do_extinguish();
int     do_light();
void    init();
void    init_arg( mixed arg );
void    out_of_fuel();
string  pretty_plural(string str);
mixed   query_auto_load();
void    setup();
string  short( int i );
int     do_replace();
 
void setup() {

    fuel_left = 3600;
    is_lit    = 0;
    has_tealight = 0;
    
    set_name("lamp");
    set_short("stone teahouse lamp");
    set_weight( 40 );
    set_value( 50000 );
    add_adjective( ({ "stone", "teahouse" }) );
    add_alias( ({ "teahouse lamp", "stone lamp" }) );
    
    set_long( function() {
    string str;
    str = "Shaped like an Agatean teahouse, this lantern creates "
        "a peaceful ambiance of Auriental tradition in your home as "
        "it casts a beautiful soft glow through its calligraphed rice "
        "paper windows.  Exquisitely handcrafted in the shape of an "
        "Agatean teahouse, the front door of the lantern swings open "
        "to reveal the tealight inside.  ";
        
        if(has_tealight && is_lit) {
            fuel_left = find_call_out("out_of_fuel");
            return str + "The tealight is burning with a steady yellow "             
                "light.";
        }
    
        if(has_tealight) {
            return str + "An unlit tealight is sitting in the base.";
        }
    
        if(!fuel_left) {
            return str + "The tealight has burned itself out.";
        }
    
        else {
            return str + "There is no tealight in the lamp.";
        
        } 
    } );   
    
    set_allowed_positions(({"sitting","standing"}));
    set_allowed_room_verbs((["sitting" : "sits", "standing" : "stands" ]));
    set_weight(9);
    set_value(20500);
        
    init_dynamic_arg( query_dynamic_auto_load() );
  
} /* setup() */


void init() {
    
    add_command("replace", "tealight in <direct:object:me>");
    this_player()->add_command("light", this_object());
    this_player()->add_command("extinguish", this_object());
} /* init() */


void dest_me() {
    set_light( 0 );
    ::dest_me();
} /* set_light() */
 
 
int do_extinguish() {

    if ( !has_tealight ) {
        this_player()->add_failed_mess( this_object(), "There is no "
            "tealight in $D\n", ({ }) );
        return 0;
    }
    
    if ( !is_lit ) {
        this_player()->add_failed_mess( this_object(), "$D is not "
        "lit.\n", ({ }));
        return 0;
    }
   
    this_player()->add_succeeded_mess( this_object(), "$N $V the "
        "remnants of the tealight in the $De.\n");
    fuel_left = remove_call_out( "out_of_fuel" );
    is_lit = 0;
    has_tealight = 1;
    set_light( 0 );
    return 1;
} /* do_extinguish() */

int do_light() {

    if ( is_lit ) {
        this_player()->add_failed_mess( this_object(), "$D is already "
            "lit.\n", ({ }) );
        return 0;
    }
   
    if( !has_tealight && fuel_left <= 0 ) {
        return this_player()->add_failed_mess( this_object(), "The "
            "tealight has burned itself out and needs to be replaced.\n",
            ({ }) );
        return 0;
    }
    
    if( !has_tealight ) {
        this_player()->add_failed_mess( this_object(), "There is no tealight "
            "in $D.\n", ({ }) );
        return 0;
    }
 
    call_out( "out_of_fuel" , fuel_left );
    is_lit = 1;
    has_tealight = 1;
    set_light( BRIGHTNESS );
    return 1;
    
} /* do_light() */
 
int do_replace() {
    int i;
    object *things;
    things = all_inventory( this_player() );
    for( i = 0; i < sizeof( things ); i++ ){
        if( !has_tealight && things[ i ]->query_name() == "tealight" ) {
            fuel_left = 3600;
            is_lit = 0;
            has_tealight = 1;
            destruct( things[ i ] );
            this_player()->add_succeeded_mess( this_object(), "$N $V the "
                "tealight in the $D.\n", ({ }) );
            return 1;
        }
        
        if( has_tealight && things [ i ]->query_name() == "tealight" ) {
            return this_player()->add_failed_mess( this_object(), "There is "
                "already a tealight in $D.\n", ({ }) );
            return 1;
        }
    }        
    return notify_fail( "You do not have a tealight to put in the lamp.\n" );
}

mapping query_dynamic_auto_load() {
    /*
    if (is_lit) {
        fuel_left = find_call_out("out_of_fuel");
        return ([ "::" : ::query_dynamic_auto_load(),
            "fuel left" : fuel_left,
            "is lit" : is_lit,
            "has tealight" : has_tealight
        ]);
    }
    else if (has_tealight) {
        return ([ "::" : ::query_dynamic_auto_load(),
            "fuel left" : fuel_left,
            "is lit" : is_lit,
            "has tealight" : has_tealight
        ]);
    }
    */
    return ([ "::" : ::query_dynamic_auto_load(),
            "fuel left" : fuel_left,
            "is lit" : is_lit,
            "has tealight" : has_tealight
        ]);
       
} /* query_dynamic_auto_load() */

void init_dynamic_arg(mapping arg) {

    if (arg["::"]) ::init_dynamic_arg(arg["::"]);

    if (arg["fuel left"]) {
        fuel_left = arg["fuel left"];
    }
    else {
        fuel_left = 0;
    }
    
    if (arg["is lit"]) {
        call_out("out_of_fuel", fuel_left);
        is_lit = 1;
        set_light(BRIGHTNESS);
    }   
    if (arg["has tealight"]) { 
        has_tealight = 1;
        set_light(0);
    }    
    else {
        has_tealight = 0;
        is_lit = 0;
    }

} /* init_dynamic_arg() */   
 
void out_of_fuel() {
    object env;
    env = environment(this_object());
    
    is_lit = 0;
    has_tealight = 0;
    fuel_left = 0;
    set_light( 45 );
    tell_room(env, "The tealight in the lamp burns out.\n" );
    
} /* out_of_fuel() */
 
string pretty_plural(object str) {
    if ( is_lit )
        return ::pretty_plural( str) + " (lit)";
    return ::pretty_plural( str);
}

string short( int i ) {
    if ( is_lit )
        return ::short( 0 ) + " (lit)";
    return ::short( 0 );
}

// --- END [/mnt/home2/grok/lib/obj/furnitures/lamps/teahouse_stone_lamp.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/furnitures/clocks/owl_clock.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/furnitures/clocks/owl_clock.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627844   Available: 13575198
Inodes: Total: 5242880    Free: 4960133
1189 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/furnitures/clocks/owl_clock.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627844   Available: 13575198
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
// Rue 5.2000 from Nassar's idea

inherit "/std/room/furniture/clock";

void setup() {
  set_name("clock");
  set_short("owl clock");
  add_adjective("owl");
  set_long("This is a wooden clock carved roughly into the shape of an owl.  "
    "The tail twitches back and forth, somewhat like a pendulum, and the owl's "
    "eyes roll cheerfully left and right with each tick of the clock.  A small "
    "set of tiles, strung on a metal rod and affixed to the owl's feet, tells "
    "the date.\n"+
    "According to the clock it is ");
  set_allowed_positions(({}));
  set_allowed_room_verbs((["hanging" : "hangs" ]));
  set_weight(50);
  set_value(42000);
  add_property("no recycling", 1); 
  set_chimes(2, "The owl clock opens its beak and hoots twice.\n");
  set_chimes(1, "The owl clock opens its beak and hoots once.\n");
  set_show_date();
}

void chime(string mess) {
  int *co_ords;

  if(environment(this_object())) {

    co_ords = (int *)environment(this_object())->query_co_ord();
    
    "/obj/handlers/broadcaster"->broadcast_event(users(), co_ords,
                                                 mess, 20, 1, 0 );
    tell_room(environment(this_object()), mess);
  }
}

// --- END [/mnt/home2/grok/lib/obj/furnitures/clocks/owl_clock.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/furnitures/bathroom/bath.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/furnitures/bathroom/bath.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627844   Available: 13575198
Inodes: Total: 5242880    Free: 4960133
541 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/furnitures/bathroom/bath.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627844   Available: 13575198
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/room/furniture/bath";

void setup() {
  set_name("bathtub");
  set_short("cast iron bathtub");
  add_adjective(({"cast", "iron"}));
  add_alias( ({ "tub", "bath" }) );
  set_long("The white porcelain sparkles on this cast iron bathtub, it looks "
           "heavy but large enough for a couple of people to have a nice "
           "bath in.\n");
  set_allowed_positions( ({"sitting", "standing", "lying" }) );
  set_allowed_room_verbs((["sitting" : "sits", "standing" : "stands" ]));
  set_weight(350);
  set_value(14000);
}
// --- END [/mnt/home2/grok/lib/obj/furnitures/bathroom/bath.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/furnitures/sofas/red_futon.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/furnitures/sofas/red_futon.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627843   Available: 13575197
Inodes: Total: 5242880    Free: 4960133
1940 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/furnitures/sofas/red_futon.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627843   Available: 13575197
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:56.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
// Only for use within CWC - Una 07.02.02


inherit "/std/room/furniture/basic";

int folded;

int do_unfold(object ob);
int do_fold(object ob);

void setup() {

    folded = 0;
    set_name( "futon" );
    set_short( "traditional red futon" );
    add_adjective( ({ "traditional", "red" } ));
    add_alias( "couch" );
    add_alias( "sofa" );
    set_long( "This red mattressed futon is made of a pad of tufted "
        "cotton batting covered with red cotton cloth, set in a "
        "lacquered oaken frame.  The frame allows the futon to rest "
        "comfortably a few inches above the ground, its hard mattress "
        "a must for those craving a little punishment combined with "
        "a good night's sleep.  It looks comfortable and is the perfect "
        "thing to have if you are into the whole minimalistic trend "
        "for your home.\n");
    set_allowed_positions(({"sitting", "lying", "kneeling", "meditating"}));
    set_allowed_room_verbs((["sitting" : "sits" ]));
    set_weight(150);
    set_value(650000);
    add_extra_look( this_object() );

} /* setup() */

void init() {

    add_command("unfold", "<indirect:object'futon'>" );
    add_command("fold", "<indirect:object'futon'>" );
  
    ::init();
  
} /* init() */

int do_unfold(object ob) {
   
    if(folded ) {
        add_failed_mess("$D is already folded.\n", ({ }) );
        return 0;
    }

    add_succeeded_mess("$N $V $D back into a sofa.\n", ({ }) );
    folded = 1;
    return 1;
    
} /* do_unfold() */

int do_fold(object ob) {
	
    if(!folded) {
        add_failed_mess("$D is already folded.\n", ({ }) );
	    return 0;
    }
    
    add_succeeded_mess("$N $V $D out into a bed.\n", ({ }) );
    folded = 0; 
    return 1;
    
} /* do_fold */

string extra_look() {

    if(!folded) {
        return "The futon has been folded out into a bed.\n";
    }
    return "The futon is folded into a sofa.\n";
    
} /* extra_look() */
// --- END [/mnt/home2/grok/lib/obj/furnitures/sofas/red_futon.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/furnitures/beds/foot_bed.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/furnitures/beds/foot_bed.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627843   Available: 13575197
Inodes: Total: 5242880    Free: 4960133
773 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/furnitures/beds/foot_bed.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627843   Available: 13575197
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* A nice bed, with duck feet.
 * by Ptoink
 *  -01/02/2003
*/

#include <forn.h>

inherit "/std/room/furniture/basic";

void setup(){

  set_name("bed");
  set_short ("duck-footed bed");
  add_alias ("duck-footed");

  set_long(
    "A fairly solid timber bed, with intricate scrollwork around the "
    "headboard.  It is supported by four duck's feet, presumably made from "
    "painted wood.  The dark wood that form its sides is inset with short "
    "strips made from a lighter wood, creating an interestingly random "
    "pattern.\n");

  set_weight( 800 );
  set_value( 100000 );

  set_allowed_positions(({"sitting", "meditating", "lying", "standing", 
                          "kneeling", "crouching"}));
 
  set_allowed_room_verbs((["sitting" : "sits" ]));
}// --- END [/mnt/home2/grok/lib/obj/furnitures/beds/foot_bed.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/furnitures/stoves/large_wood_stove.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/furnitures/stoves/large_wood_stove.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627842   Available: 13575196
Inodes: Total: 5242880    Free: 4960133
1087 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/furnitures/stoves/large_wood_stove.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627842   Available: 13575196
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:56.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
// Una
// Only for use in Cwc

inherit "/std/room/furniture/fireplace";

void setup() {

    set_name("oven");
    set_short("large wood oven");
    add_adjective( ({ "large", "wood" }) );
    set_long("A tastefully decorated door bears the name 'Wun Chi Puffin' "
        "and a temperature gauge monitors the large wood oven.  "
        "Resting on a smooth base, this range has a thirty-two inch cook "
        "surface and carries six burners and a water reservoir.  A top "
        "mounted nickel trimmed shelf on the back of the stove is "
        "complemented by dual warming shelves.  Subtle and sophisticated, "
        "this stovetop would compliment most tasteful homes.\n");
    set_allowed_room_verbs(([
                            "sitting" : "sits", 
                            "squatting" : "squats",
                            "crouching" : "crouches",
                            "resting" : "rests",
                            "lying" : "lies"
                          ]));
    set_weight(495);
    set_max_weight(100);
    set_value(120000);
  
} /* setup() */
// --- END [/mnt/home2/grok/lib/obj/furnitures/stoves/large_wood_stove.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/furnitures/wardrobes/golden_ebony_wardrobe.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/furnitures/wardrobes/golden_ebony_wardrobe.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627842   Available: 13575196
Inodes: Total: 5242880    Free: 4960133
1414 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/furnitures/wardrobes/golden_ebony_wardrobe.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627842   Available: 13575196
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:56.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/room/furniture/storage";

void setup() {
    set_name("wardrobe");
    set_short("golden ebony wood wardrobe");
    add_adjective(({"golden", "ebony", "wood"}));
    set_long("Tall and imposing this wardrobe looms towards the ceiling.  "
        "The crafter obviously gave a great deal of thought to its "
        "construction in selecting different woods to present constrasts "
        "and blends.  The darkest of ebony seems to swallow the light "
        "highlighting minature scrollwork picked out in gold across its "
        "surface, giving way to dusky madrona the spirals and knots give "
        "the impression of smoke curling slowly around the borders of "
        "the doors and around the brass handles.\n");

    set_weight(900);
    set_max_weight(500);
    set_value(740000);

    set_allowed_room_verbs((["squatting" : "squats" ]));
    set_pick_skill("covert.lockpick.doors");
    set_difficulty(4);
} /* setup() */

void init() {
    string key_id;
    object key;
  
    if(!query_key()) {
        key_id = "furniture_lock_"+random(1000); 
        set_key(key_id);
    
        key = clone_object("/std/key");
        key->set_key("small iron", key_id);
        key->set_long("This small, yet sturdy, key looks like it is for a "
                  "piece of furniture.\n");
        key->move(this_object());
        set_closed();
    }
  
    ::init();
    
} /* init() */
// --- END [/mnt/home2/grok/lib/obj/furnitures/wardrobes/golden_ebony_wardrobe.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/cont_medium.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/cont_medium.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627841   Available: 13575195
Inodes: Total: 5242880    Free: 4960133
30223 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/cont_medium.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627841   Available: 13575195
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: cont_medium.c,v 1.28 2003/04/12 03:52:48 starr Exp $
*/
/**
 * Continuous Medium Object.
 *
 * amount: current quantity of medium in arbitrary units
 *
 * continuous: 1 for continuous (default), reset to 0 for normal
 *             object behaviour
 *
 * collective: 1 for collective, 0 for normal behaviour.
 *
 * weight_unit: ({ a, b }) means that b units have weight a
 *
 * value_scale (float): if set & continuous, value is ::query_value() * amount
 *                      * value_scale; else value is ::query_value()
 *
 * medium_alias: used for identification - choose something with
 *               capitals (e.g. "ChalkDust") so players can't
 *               use it as a valid alias by accident
 *
 * pile_name: "pile", "collection", "puddle", etc.
 *
 * amount_types: ([ "pinch": ({ 1, "pinches" }),
 *                  "handful": ({ 50, "handfuls" }) ])
 *
 * pile_types: ({ 50, "small", 100, "medium", 150, "large", "huge" });
 *
 * Added by Jeremy, 4-Nov-95:
 *
 * ground, longs, shorts, medium_aliases
 *
 * The above were removed by Jeremy, 18-Jun-97.  Hopefully no one will
 * miss them.
 * @author Jeremy
 *
 * Additions for collective objects:
 * Since "a" and "an" will be replaced with the number of objects, 
 * "$a" and "$an" can be used if there should be a non-changing "a" or "an"
 * in the long.
 * For verbs you can use $V<singular-verb>$<plural-verb>. Example: $Vglows$glow
 * If there are any words which should be pluralized, place a $P in front of it,
 * like $Pleaf or $Pword
 * Finally you can use $A<word> if you want "a word" in for one object and
 * "words" for more than one.
 */

#include <move_failures.h>
#include <parse_command.h>
#include <obj_parser.h>

inherit "/std/object";

private int amount;
private int continuous;
private int collective;

private nosave string my_filename;
private int *weight_unit;
private nosave int no_join;
private float value_scale;
private string medium_alias;
private string pile_name;
private string *_sorted_amount_names;
private mapping amount_types;
private mixed *pile_types;
private nosave mixed _short_name;

object make_medium_clone( int number );

void create() {
  int junk;

  do_setup++;
  ::create();
  do_setup--;
  continuous = 0;
  collective = 0;
  weight_unit = ({ 1, 200 });
  pile_name = "pile";
  if ( !do_setup )
    this_object()->setup();
  if( !clonep( this_object() ) )
    return;
  sscanf( file_name( this_object() ), "%s#%d", my_filename, junk );
  amount = 1;
}

/** @ignore yes */
void set_name( string word ) {
  ::set_name( word );
  if ( continuous )
    add_plural( word );
} /* set_name() */

/**
 * This method returns the amount of the stuff there is.  This is a
 * volume measurement.
 * @return the amount of stuff
 */
int query_amount() { return amount; }

/**
 * This method sets the amount of the stuff there is.
 * @param number the amount to set it to
 */
void set_amount( int number ) {
  if(environment() && continuous)
    environment()->add_volume(number - amount);

  amount = number;
  if(continuous || collective)
    set_weight((amount * weight_unit[ 0 ] ) / weight_unit[ 1 ]);
}


/**
 * This method changes the amount of stuff.
 * @param number the amount to change it by
 */
void adjust_amount(int number) {
  if(environment() && continuous)
    environment()->add_volume(number);

  amount += number;
  if(amount < 1) {
    no_join = 1;
    move( "/room/rubbish" );
    return;
  }
  if(continuous || collective)
    set_weight((amount * weight_unit[0]) / weight_unit[1]);
}

/**
 * This method tests to see if this object is continuous or not.
 * @return 1 if it is continuous, 0 if not
 */
int query_continuous() { return continuous; }

/**
 * This method tests to see if this object is a collective or not.
 * @return 1 if it is continuous, 0 if not.
 */
int query_collective() { return collective; }

/**
 * This method returns 1 if the object is available for mergin.
 * @return 1 if we can merge
 */
int query_merger() { return 1; }

/**
 * This method makes the object continuous.
 */
void set_continuous() {
  collective = 0;
  if (continuous) {
    return;
  }
  if ( environment() ) {
    environment()->add_volume( -200*query_weight() );
  }
  continuous = 1;
  if(environment()) {
    environment()->add_volume( amount );
  }
} /* set_continuous() */

/**
 * This method removes the continuous property from the object.
 */
void reset_continuous() {
  if (!continuous) {
    return;
  }
  continuous = 0;
  if ( environment() ) {
    environment()->add_volume( -amount );
  }
} /* reset_continuous() */

/*
 * This method makes the object a collective.
 */
void set_collective() {
  collective = 1;
  continuous = 0;
  add_property( "determinate", "" );
}

/**
 * This method removes the collective property from the object.
 */
void reset_collective() {
  collective = 0;
}

/**
 * This method returns the weight units used for this type
 * of unit.  The weight unit is an array ({ a, b }) which means
 * that b units of stuff have weight a.
 * @return the weight array
 */
int *query_weight_unit() { return weight_unit; }

/**
 * This method sets the weight units used for this type
 * of stuff.  The weight unit is an array ({ a, b }) which means
 * that b units of stuff have weight a.
 * @param numbers the new weight unit
 */
void set_weight_unit( int *numbers ) { weight_unit = numbers; }

/**
 * This method checks to see if we are allowed to join with other
 * objects when we encounter them.  A join will occur if we end up in
 * same environment and the medium aliases match.
 * @return 1 if they cannot join, 0 if they can
 */
int query_no_join() { return no_join; }

/**
 * This method stops this object joining with other
 * objects when we encounter them.  A join will occur if we end up in
 * same environment and the medium aliases match.
 */
void set_no_join() { no_join = 1; }

/**
 * This method lets this object joining with other
 * objects when we encounter them.  A join will occur if we end up in
 * same environment and the medium aliases match.
 */
void reset_no_join() { no_join = 0; }

/**
 * This method returns the medium alias.  This should be a unique alias
 * for the medium, it is used when joining to see if we can join or not
 * It it used for identification - choose something with
 * capitals (e.g. "ChalkDust") so players can't
 * use it as a valid alias by accident.
 * @return the medium alias
 */
string query_medium_alias() { return medium_alias; }

/**
 * This method sets the medium alias for the object.
 * This should be a unique alias
 * for the medium, it is used when joining to see if we can join or not
 * It it used for identification - choose something with
 * capitals (e.g. "ChalkDust") so players can't
 * use it as a valid alias by accident.
 & @param word the medium alias
 */
void set_medium_alias( string word ) {
   medium_alias = word;
   add_alias( medium_alias );
} /* set_medium_alias() */

/**
 * This method returns the name we give the piles of this stuff.  This
 * is the name given to piles of the object.
 * @return the name of the pile
 */
string query_pile_name() { return pile_name; }

/**
 * This method returns the name we give the piles of this stuff.
 * @example
 * set_pile_name("puddle");
 * @param word the name of the pile
 */
void set_pile_name( string word ) { pile_name = word; }

/**
 * This method returns the types of the different amounts.
 * argument is a mapping which contains the name of the pile and
 * value is an array, the first element is the amount needed for
 * the name and the second element is the plural of the pile name.
 * @return the amount types mapping
 */
mapping query_amount_types() { return amount_types; }

/**
 * This method sets the sizes of the piles and their names.  The
 * argument is a mapping which contains the name of the pile and
 * value is an array, the first element is the amount needed for
 * the name and the second element is the plural of the pile name.
 * @example
 * set_amount_types( ([ "pinch": ({ 1, "pinches" }),
 *                  "handful": ({ 50, "handfuls" }) ]));
 * @param map the amount types mapping
 */
void set_amount_types( mapping map ) {
  amount_types = map;
  // This is for efficiency in amount_size() and amount_size_short()
  _sorted_amount_names = sort_array(m_indices( amount_types ),
      (: amount_types[$1][0] - amount_types[$2][0] :));
}

/**
 * This method returns the array of pile types.
 * The pile types array starts with a number, the number is the
 * cut off amount to get the size name in the next array element.
 * The numbers and strings alternate and the last element is the
 * the default size.
 * @return the array of pile types
 */
mixed query_pile_types() { return pile_types; }

/**
 * This method sets the name of the piles given the different
 * amounts of piles available.  The last pile type in the list is
 * the size to use for anything larger.  The pile sizes must be in
 * order.
 * @example
 * set_pile_types(({ 50, "small", 100, "medium", 150, "large", "huge" }));
 * @param args the pile types
 */
void set_pile_types( mixed *args ) { pile_types = args; }

/**
 * This method returns the maximum number of piles of the
 * object that can be seen.  Any more than this turns into 'many'.
 * @return the maximum number of piles that can be seen
 */
int query_max_seen() { return 12; }

/**
 * This method returns the value of the object.  If the object is
 * not continuous, or the value_scale has not been set, the value is
 * the value set with set_value(), as usual.  Otherwise, the value is
 * scaled by value_scale and multiplied by the current amount.
 * @return the value of the object
 * @see set_value()
 * @see set_value_scale()
 * @see query_value_scale()
 */
int query_value() {

  if (!floatp(value_scale) || !continuous) {
    if(collective)
      return (amount * ::query_value() );
    return ::query_value();
  }
  return to_int(::query_value() * value_scale * amount);
} /* query_value() */

/**
 * This method sets the amount by which to scale the value of a
 * continuous object.  If not set, the value will be that set with
 * set_value().
 * @param f the value scale
 * @see query_value_scale()
 * @see query_value()
 */
void set_value_scale(float f) { value_scale = f; }

/**
 * This method returns the current value scale.
 * @return the value scale
 * @see set_value_scale()
 * @see query_value()
 */
float query_value_scale() { return value_scale; }

/**
 * This returns as an integer 'how many' we have of a particular
 * type.
 * @return int representing the amount of a particular pile.
 */
int query_how_many() {
  int biggest_amount;
  int how_many;
  string size;
  string biggest_size;

  if(!amount)
    return 0;

  if(!m_sizeof(amount_types)) {
    if(collective)
//      Wrong! Wrong! -- Terribly wrong!
//      return query_num(amount);
        return amount;
    return 0;
  }

  biggest_size = _sorted_amount_names[0];
  foreach (size in _sorted_amount_names) {
    if (amount < amount_types[size][0]) {
      break;
    }

    biggest_size = size;
  }

  biggest_amount = amount_types[biggest_size][0];

  how_many = ( amount + biggest_amount / 2 ) / biggest_amount;

  return how_many;
}

/**
 * This method returns a string which tells us how much stuff we
 * have.
 * @return string representing the amount of stuff we have
 */
varargs string amount_size(int exact) {
   int biggest_amount;
   int how_many;
   string size;
   string biggest_size;
   string biggest_plural;

   if ( !amount ) {
      return "none at all";
   }
   if ( !m_sizeof( amount_types ) ) {
      return "minus one Cornish pint";
   }
   biggest_size = _sorted_amount_names[0];
   foreach (size in _sorted_amount_names) {
     if (amount < amount_types[size][0]) {
       break;
     }
     biggest_size = size;
   }
   biggest_amount = amount_types[biggest_size][0];
   biggest_plural = amount_types[biggest_size][1];
   how_many = ( amount + biggest_amount / 2 ) / biggest_amount;
   if ( !how_many ) {
      return "apparently not containing any "+ biggest_plural;
   }
   if ( how_many == 1 ) {
      return "about one "+ biggest_size;
   }
   if ( !exact  &&  how_many > query_max_seen() ) {
      return "more "+ biggest_plural +" than you can count";
   }
   return "about "+ query_num( how_many ) +" "+ biggest_plural;
} /* amount_size() */

/**
 * This method returns a string which tells us how much stuff we
 * have.
 * @return string representing the amount of stuff we have
 */
string amount_size_short() {
   int biggest_amount;
   int how_many;
   string size;
   string biggest_size;
   string ret;
   string biggest_plural;

   if ( !amount || !sizeof( amount_types ) ||
        (query_property("determinate") == "some ") ) {
     if(collective)
       return query_num(amount, 20) + " ";
     return "";
   }
   if (_short_name && _short_name[0] == amount) {
      return _short_name[1];
   }
   biggest_size = _sorted_amount_names[0];
   foreach (size in _sorted_amount_names) {
     if (amount < amount_types[size][0]) {
       break;
     }
     biggest_size = size;
   }
   biggest_amount = amount_types[biggest_size][0];
   biggest_plural = amount_types[biggest_size][1];
   how_many = ( amount + biggest_amount / 2 ) / biggest_amount;

   if(!how_many) {
     if(collective)
       ret = query_num(amount) + " ";
     else
       ret = "a smidgeon of ";
   } else if(collective && amount < biggest_amount) {
     ret = query_num(amount) + " ";
   } else if(how_many == 1) {
     ret = "one "+ biggest_size + " of ";
   } else {
     ret = query_num( how_many, query_max_seen()) +" "+ biggest_plural +
       " of ";
   }
   _short_name = ({ amount, ret });
   return ret;
} /* amount_size_short() */

/**
 * This method returns a string describing how big the pile is.
 * @return the size of this pile of stuff
 */
string pile_size() {
   int i;

   if ( !sizeof( pile_types ) ) {
      return "a surreal "+ pile_name;
   }
   for ( i = 0; i < ( sizeof( pile_types ) - 1 ); i += 2 ) {
      if ( amount <= pile_types[ i ] ) {
         return add_a( pile_types[ i + 1 ] ) +" "+ pile_name;
      }
   }
   return add_a( pile_types[ sizeof( pile_types ) - 1 ] ) +" "+ pile_name;
} /* pile_size() */

/** @ignore yes */
varargs string pretty_short( object thing ) {
  if(collective) {
    if(amount > 1)
      return pretty_plural(thing);
    else
      return add_a(::pretty_short(thing));
  }
  return amount_size_short() + ::pretty_short( thing );
} /* pretty_short() */

/** @ignore yes */
varargs string pretty_plural( object thing ) {
  if(amount > 1)
    return amount_size_short() + ::pretty_plural( thing );
  return ::pretty_plural(thing);
}

#ifdef 0
/** @ignore yes */
string short(int dark) {
  string ret;

  ret = ::short( dark );

  if(!ret || ret == "something" || !collective)
    return(ret);

  if(amount == 1)
    return add_a(ret);

  return( query_num(amount, 9999 ) + " " + query_main_plural());
}
#endif

/** @ignore yes */
string long(string words, int dark ) {
  int i;
  string ret;
  string *bits;

  if(continuous)
    return replace( ::long( words, dark ),
                    ({ "$amount_size$", amount_size(),
                         "$pile_size$", pile_size() }) );

  ret = replace( ::long( words, dark ), "$N", short( dark ) );

  if(collective && amount > 1) {
    ret = replace( ret, ",$", "$comma_dollar$" );
    ret = replace( ret, ({ ",", " $spaced_comma$", ";", " $spaced_semi$",
        ":", " $spaced_colon$", ".", " $spaced_period$" }) ); 
    ret = replace( ret, "$comma_dollar$", ",$");
    bits = explode(ret, " ");
    for(i = 0; i < sizeof(bits); i++) {
        switch( bits[ i ] ) {
        case "This":
          bits[i] = "These";
          break;
        case "this":
          bits[i] = "these";
          break;
        case "is":
          bits[i] = "are";
          break;
        case "a":
        case "an":
          bits[i] = amount_size_short();
          bits[i] = bits[i][0..<2];
          break;
        case "it":
           bits[i] = "they";
           break;
        case "It":          
           bits[i] = "They";
           break;
        case "its":
           bits[i] = "their";
           break;
        case "Its":
           bits[i] = "Their";
           break;
        case "$a":
        case "$an":
           bits[i] = bits[i][1..];
           break;
        default:
           // handling verbs
           if( bits[i][0..1] == "$V" ) {
              bits[i] = replace_string( bits[i], "$V", "" );
              bits[i] = explode( bits[i], "$" )[1];
           };
           // handling manual pluralization
           if( bits[i][0..1] == "$P" ) {
              bits[i] = replace_string( bits[i], "$P", "" );
              bits[i] = pluralize( bits[i] );
           };
           // handling disappearing "a"s
           if( bits[i][0..1] == "$A" ) {
              bits[i] = replace_string( bits[i], "$A", "" );
              bits[i] = pluralize( bits[i] );
           };
           // was there before
           if(strsrch(bits[i], query_plural(dark)) == -1)
               bits[i] = replace(bits[i], short(dark), query_plural(dark));
        }
      }
    ret = implode(bits, " ");
    ret = replace(ret, ({ " $spaced_comma$", ",", " $spaced_semi$", ";",
        " $spaced_colon$", ":", " $spaced_period$", "." })  ); 
  // added for removing tags
  } else if( collective && amount == 1 ) {
     bits = explode(ret, " ");
     for(i = 0; i < sizeof(bits); i++) {
        if( bits[i][0..1] == "$V" ) {
           bits[i] = replace_string( bits[i], "$V", "" );
           bits[i] = explode( bits[i], "$" )[0];
        };
        if( bits[i][0..1] == "$P" ) {
           bits[i] = replace_string( bits[i], "$P", "" );
        };
        if( bits[i] == "$a" || bits[i] == "$an" ) {
           bits[i] = bits[i][1..];
        };
        if( bits[i][0..1] == "$A" ) {
           bits[i] = replace_string( bits[i], "$A", "" );
           bits[i] = add_a( bits[i] );
        };
     };
     ret = implode( bits, " " );
  };
  return ret;
}

/** @ignore yes */
string query_long(string words, int dark)  {
   return long(words, dark);
}

object new_collective(int number) {
  object ob;
  object place;

  ob = make_medium_clone(number);
  adjust_amount(-number);
  ob->set_no_join();
  if(environment()) {
    place = (object)environment()->query_property( "medium dest" );
    if(!place)
      place = environment();
    ob->move(place);
  }
  ob->reset_no_join();
  ob->call_out("merge", 1);
  return ob;
}

/*
 * This is a separate function so that things that inherit this can
 * redefine it to meet their requirements.
 */
int merge_criteria(object ob) {
  return medium_alias == ob->query_medium_alias();
}

void merge() {
  object *obs;

  if(environment())
     obs = filter(all_inventory(environment()) - ({ this_object() }),
                  "merge_criteria", this_object());

  if(sizeof(obs) && objectp(obs[0])) {
    no_join = 1;
    move("/room/rubbish");
    obs[0]->adjust_amount(amount);
  }
  return;
}

/** @ignore yes */
varargs int move( mixed dest, string messin, string messout ) {
  int check;

  if((check = ::move(dest, messin, messout)) != MOVE_OK)
    return check;

  if(no_join || !medium_alias || (!continuous && !collective))
    return MOVE_OK;

  call_out("merge", 0);
  return MOVE_OK;
}

/**
 * This method makes a duplicate of ourselves at a different size.
 * @param number the new size of the object
 * @return the new object
 */
object make_medium_clone( int number ) {
   object medium;
   mapping map;
   
   medium = clone_object( explode( file_name( this_object() ), "#" )[ 0 ] );
   map = (mapping)this_object()->query_dynamic_auto_load();
   medium->init_dynamic_arg( map );
   map = (mapping)this_object()->query_static_auto_load();
   if ( map ) {
      medium->init_static_arg( map );
   }

   medium->set_amount( number );

   //
   // Scale the enchantmant.
   //
   medium->set_enchant( query_enchant() * medium->query_max_enchant() /
                        query_max_enchant() );
   return medium;
} /* make_medium_clone() */


/** @ignore yes */
object cont_query_parse_id( mixed *args ) {
   int i;
   string *sizes;
   object medium, place;

   if ( args[ P_THING ] < 0 ) {
      args[ P_THING ]++;
      if ( args[ P_THING ] ) {
         return 0;
      }
      args[ P_THING ] = -99999;
      return this_object();
   }
   sizes = m_indices( amount_types );
   if ( args[ P_THING ] == 1 ) {
      for ( i = 0; i < sizeof( sizes ); i++ ) {
         if ( member_array( sizes[ i ], explode( args[ P_STR ], " " ) ) !=
               -1 ) {
            if ( amount_types[ sizes[ i ] ][ 0 ] > amount ) {
               return 0;
            }
            medium = make_medium_clone( amount_types[ sizes[ i ] ][ 0 ] );
            place = (object)environment()->query_property( "medium dest" );
            if ( !place ) {
               place = environment();
            } else {
               remove_call_out( "no_env_move" );
               call_out( "dest_old_env", 1, environment() );
            }
            adjust_amount( -amount_types[ sizes[ i ] ][ 0 ] );
            this_object()->set_no_env_move( place );
            medium->move( place );
            args[ P_THING ] = -99999;
            return medium;
         }
      }
      args[ P_THING ] = -99999;
      return this_object();
   }
   for ( i = 0; i < sizeof( sizes ); i++ ) {
      if ( member_array( amount_types[ sizes[ i ] ][ 1 ],
            explode( args[ P_STR ], " " ) ) != -1 ) {
         if ( amount_types[ sizes[ i ] ][ 0 ] * args[ P_THING ] > amount ) {
               return 0;
         }
         medium = make_medium_clone( amount_types[ sizes[ i ] ][ 0 ] *
                args[ P_THING ] );
         place = (object)environment()->query_property( "medium dest" );
         if ( !place ) {
            place = environment();
         } else {
            remove_call_out( "no_env_move" );
            call_out( "dest_old_env", 1, environment() );
         }
         adjust_amount( -amount_types[ sizes[ i ] ][ 0 ] * args[ 0 ] );
         this_object()->set_no_env_move( place );
         medium->move( place );
         args[ P_THING ] = -99999;
         return medium;
      }
   }
   return 0;
}

/** @ignore yes */
object coll_query_parse_id( mixed *arr ) {
   string *bits;

   if((arr[0] < 0)) {
     return 0;
   }
   if(arr[0] == 0) {
     bits = explode( arr[ 1 ], " " );
     if(sizeof(bits) == 1) {
       if(bits[0] == query_main_plural()) {
         return this_object();
       }
     }
     if(member_array(bits[sizeof(bits) - 1 ], query_plurals()) == -1) {
       return this_object();
     }
     return 0; /// ????
   }

   if(id(arr[1])) {
     return new_collective(amount - arr[0]);
   }
}

object query_parse_id( mixed *args ) {
  if(continuous)
    return cont_query_parse_id(args);

  return coll_query_parse_id(args);
}

/** @ignore yes */
mixed* cont_parse_match_object(string* input, object player,
                               class obj_match_context context) {
   int result;
   string size;
   mixed* amt;
   int make_amt;
   int smallest;
   int num;
   object medium;
   object place;

   result = ::is_matching_object(input, player, context);
   if (!continuous || !result) {
      if (result) {
         if (update_parse_match_context(context, 1, result)) {
            return ({ result, ({ this_object() }) });
         }
      }
      return 0;
   }


   smallest = amount;
   foreach (size, amt in amount_types) {
      if ( member_array( size, input) != -1) {
         if ( amt[ 0 ] > amount ) {
            return 0;
         }
         make_amt = amt[0];
      } else if ( member_array( amt[1], input ) != -1 ) {
         if ( amt[ 0 ] > amount ) {
            return 0;
         }
         make_amt = amt[0];
      }
      if (smallest > amt[0]) {
         smallest = amt[0];
      }
   }

   if (!make_amt) {
     if(!amount)
       make_amt = 1;
     else
       make_amt = amount;
   }

   num = update_parse_match_context(context, (amount / make_amt), result);
   if (!num) {
      return 0;
   }

   make_amt *= num;

   if (context->fraction) {
      make_amt = (make_amt * context->fraction[0]) / context->fraction[1];
   }

   if (make_amt < smallest) {
      make_amt = smallest;
   }

   if (make_amt < amount) {
      medium = make_medium_clone( make_amt );
      place = (object)environment()->query_property( "medium dest" );
      if ( !place ) {
         place = environment();
      } else {
         remove_call_out( "no_env_move" );
         call_out( "dest_old_env", 1, environment() );
      }
      adjust_amount( -make_amt );
      this_object()->set_no_env_move( place );
      medium->move( place );
      return ({ result, ({ medium }) });
   }
   return ({ result, ({ this_object() }) });
}

/** @ignore yes */
mixed* coll_parse_match_object(string* input, object viewer,
                               class obj_match_context context) {
  int ret;
  int num;
  int make_amt;
  string size;
  mixed *amt;
  int smallest;

  ret = ::is_matching_object(input, viewer, context);
  if (!ret) {
    return 0;
  }

  if (sizeof(input) == 1 &&
      !context->number_included &&
      !context->ordinal &&
      (member_array(input[<1], query_plurals()) != -1 ||
       input[<1] == "all" || input[<1] == "thing")) {
    return ({ OBJ_PARSER_MATCH_PLURAL, ({ this_object() }) });
  }

  if(amount_types) {
    smallest = amount;
    foreach (size, amt in amount_types) {
      if(member_array( size, input) != -1) {
        if(amt[0] > amount) {
          return 0;
        }
        make_amt = amt[0];
        ret = OBJ_PARSER_MATCH_SINGULAR;
      } else if(member_array( amt[1], input ) != -1) {
        if(amt[ 0 ] > amount) {
          return 0;
        }
        make_amt = amt[0];
        ret = OBJ_PARSER_MATCH_PLURAL;
      }
      if (smallest > amt[0]) {
        smallest = amt[0];
      }
    }
  }
  if(!make_amt)
    make_amt = 1;

  num = update_parse_match_context(context, to_int(amount / make_amt), ret);

  if (!num)
    return 0;

  num *= make_amt;

  if (context->fraction) {
    num = (num  * context->fraction[0]) / context->fraction[1];
  }

  if(num < amount) {
    new_collective(amount - num);
    return ({ ret, ({ this_object() }) });
  }
  return ({ ret, ({ this_object() }) });
}

/** @ignore yes */
mixed *parse_match_object(string *input, object player,
                          class obj_match_context context) {
  if(continuous)
    return cont_parse_match_object(input, player, context);

  return coll_parse_match_object(input, player, context);
}


/**
 * This method is for dealing with the object when bits are shaved off.
 * If it is split up by someone referencing it we are moved into a
 * special environment so we do not interfer with the old pile.  The
 * property "medium dest" will be used as the place to go, otherwise
 * the environment will be used.  This method sticks it into a special
 * on the fly created container.
 * @param dest the place to move too  (this will be the "medium dest" or
 * the environment()
 */
void set_no_env_move( object dest ) {
   object place;

   if ( file_name( environment() ) == "/room/rubbish" ) {
      return;
   }
   place = clone_object( "/std/container" );
   place->add_property( "medium dest", dest );
   move( place );
   call_out( "no_env_move", 0, dest, place );
} /* set_no_env_move() */

/**
 * This method checks to see if we are still in our silly little container
 * and if we are, moves us back.  We always dest the old container
 * @param dest where we are going to
 * @param place the temporary container
 */
void no_env_move( object dest, object place ) {
   if ( environment() == place ) {
      move( dest );
   }
   call_out( "dest_old_env", 1, place );
} /* no_env_move() */

/**
 * This method destructs the temporary container.
 * @param place the object to destroy
 */
void dest_old_env( object place ) {
   if ( place ) {
      place->dest_me();
   }
} /* dest_old_env() */

/** @ignore yes */
mapping query_dynamic_auto_load() {
   return ([
      "::": ::query_dynamic_auto_load(),
      "continuous": continuous,
      "collective": collective,
      "amount": amount,
   ]);
} /* query_dynamic_auto_load() */

/** @ignore yes */
void init_dynamic_arg( mapping map, object ) {
  if ( !mapp( map ) )
    return;
  if ( map[ "::" ] )
    ::init_dynamic_arg( map[ "::" ]);
  if ( map[ "amount" ] )
    set_amount( map[ "amount" ] );
  /* This ensures that volumes are set properly in vessels */
  if ( !undefinedp( map[ "continuous" ] ) )
    if ( map[ "continuous" ] ) {
      set_continuous();
    } else {
      reset_continuous();
    }
  if(!undefinedp(map["collective"]))
    collective = map["collective"];
}

/** @ignore yes */
mapping int_query_static_auto_load() {
   return ([
      "::": ::int_query_static_auto_load(),
      "weight_unit": weight_unit,
      "medium_alias": medium_alias,
      "pile_name": pile_name,
      "amount_types": amount_types,
      "pile_types": pile_types,
      "value_scale": value_scale,
   ]);
}

/** @ignore yes */
mapping query_static_auto_load() {
  if ( base_name(this_object()) + ".c" == __FILE__ )
      return int_query_static_auto_load();
   return 0;
} /* query_static_auto_load() */

/** @ignore yes */
void init_static_arg( mapping map ) {
   if ( !mapp( map ) )
      return;
   if ( map[ "::" ] )
      ::init_static_arg( map[ "::" ] );
   if ( !undefinedp( map[ "medium_alias" ] ) )
      medium_alias = map[ "medium_alias" ];
   if ( pointerp( map[ "weight_unit" ] ) )
      weight_unit = map[ "weight_unit" ];
   if ( stringp( map[ "pile_name" ] ) )
      pile_name = map[ "pile_name" ];
   if ( mapp( map[ "amount_types" ] ) )
      set_amount_types(map[ "amount_types" ]);
   if ( pointerp( map[ "pile_types" ] ) )
      pile_types = map[ "pile_types" ];
   if ( floatp( map[ "value_scale" ] ) )
      value_scale = map[ "value_scale" ];
} /* init_static_arg() */

/** @ignore yes */
mixed *stats() {
   return ::stats() + ({
      ({ "amount", amount }),
      ({ "medium alias", medium_alias }),
      ({ "continuous", continuous }),
      ({ "collective", collective }),
      ({ "value scale", value_scale }),
   });
} /* stats() */
// --- END [/mnt/home2/grok/lib/obj/cont_medium.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/money.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/money.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627834   Available: 13575188
Inodes: Total: 5242880    Free: 4960133
17091 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/money.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627834   Available: 13575188
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <money.h>
#include <move_failures.h>
#include <obj_parser.h>

#define COIN_WEIGHT 10

#define DEF_VALUE 1
//#undef USE_VAULT
#define USE_VAULT DEF_VALUE
//#define DEBUGGER "presto"

inherit "/std/object";

private nosave int no_join;
private nosave int _already_joined;
private mixed *money_array;
private nosave string _long;

int query_value_in(string where);

void create() {
   ::create();
   set_name( "coin" );
   add_alias( MONEY_ALIAS );
   add_plural( "coins" );
   set_main_plural( "coins" );
   add_property( "determinate", "" );
   add_property( "no one", 1 );
   add_property( "money", 1 );
   money_array = ({ });
} /* create() */

/** @ignore yes
 * Money is a collective object.
 */
int query_collective() { return 1; }

mapping query_dynamic_auto_load() {
   if (!_already_joined) {
      return ([
         "::" : ::query_dynamic_auto_load(),
         "money array" : money_array,
      ]);
   }
   add_alias(MONEY_ALIAS);
} /* query_dynamic_auto_load() */

void init_dynamic_arg( mapping map, object ) {
   ::init_dynamic_arg( map[ "::" ] );
   money_array = map[ "money array" ];
   if (sizeof(money_array) < 2)  call_out("dest_me", 0);
   short_d = _long = 0;
   if ( find_call_out( "check_adjectives" ) == -1 ) {
      call_out( "check_adjectives", 0 );
   }
} /* init_dynamic_arg() */

int query_merger() { return 1; }

int query_no_join() { return no_join; }

int query_already_joined() { return _already_joined; }
void reset_already_joined() { _already_joined = 0; }
void set_already_joined() { _already_joined = 1; }

void set_no_join() {
#ifdef DEBUGGER
   if (find_player(DEBUGGER) == this_player())
      tell_creator(DEBUGGER, "Called set_no_join\n");
#endif

   no_join = 1;
   call_out( "merge_coins", 0 );
} /* set_no_join() */


void force_no_join()  { no_join = 1; }
void reset_no_join() { no_join = 0; }

/**
 * This method returns the number of coins in the object.
 * @return the number of coins
 */
int query_number_coins() {
   int i;
   int tot;

   if (_already_joined) {
      return 0;
   }
   for ( i = 1; i < sizeof( money_array ); i += 2 ) {
      tot += money_array[ i ];
   }
   return tot;
} /* query_number_coins() */

/**
 * This method fixes up the weight of the money object to be what it should
 * be.
 */
void fixup_money_weight() {
   set_weight( 1 + query_number_coins() / COIN_WEIGHT );
} /* fixup_money_weight() */
   

int group_object() { return ( query_number_coins() > 1 ); }

/**
 * This method goes through the coins and sets up all the adjectives
 * and plurals it needs to.
 */
void check_adjectives() {
   int i;
   string* bits;

   set_adjectives( ({ }) );
   set_aliases( ({ }) );
   set_plurals( ({ }) );
   if ( !sizeof( money_array )) {
     if(file_name(environment()) != MONEY_VAULT) {
       _already_joined = 0;
#ifdef DEBUGGER
      if (find_player(DEBUGGER) == this_player())
          tell_creator(DEBUGGER, "MOVING %O to rubbish room\n", this_object());
#endif
#ifdef USE_VAULT
       MONEY_VAULT->add_to_list(this_object());
#else
       move("/room/rubbish");
#endif
     }
     return;
   }
   add_alias( MONEY_ALIAS );
   add_plural( "coins" );
   add_plural("money");
   for ( i = 0; i < sizeof( money_array ); i += 2 ) {
      bits = explode(lower_case(money_array[ i ]), " ");
      if (sizeof(bits) > 1) {
         add_adjective(bits[0..<2] );
      } else {
         add_adjective(bits);
      }
      if (MONEY_HAND->query_origin_of(money_array[i]) == "default")
         add_adjective(({ "provincial", "default" }));
      add_alias(MONEY_HAND->query_aliases_for(money_array[i]));
      add_adjective(MONEY_HAND->query_adjectives_for(money_array[i]));
      add_plural( (string)MONEY_HAND->query_plural_for( money_array[ i ] ) );
   }
   fixup_money_weight();
} /* check_adjectives() */

mixed *query_money_array() {
   if (!_already_joined) {
      return money_array;
   }
   return ({ });
} /* query_money_array() */

varargs int adjust_money( mixed amount, string type ) {
   int i;
   int ret;

   if ( pointerp( amount ) ) {
      for ( i = 0; i < sizeof( amount ); i += 2 ) {
         adjust_money( amount[ i + 1 ], amount[ i ] );
      }
      fixup_money_weight();
      return 1;
   }
   if ( !stringp( type ) || !intp( amount ) || _already_joined) {
      return 0;
   }
   short_d = _long = 0;
   if ( ( i = member_array( type, money_array ) ) == -1 ) {
      money_array += ({ type, amount });
      ret = 1;
   } else {
      money_array[ i + 1 ] += amount;
      if ( money_array[ i + 1 ] <= 0 ) {
         money_array = delete( money_array, i, 2 );
         ret = 0;
      } else {
         ret = 1;
      }
   }
   if ( find_call_out( "check_adjectives" ) == -1 ) {
      call_out( "check_adjectives", 0 );
   }
   fixup_money_weight();
   if (ret) {
      return money_array[ i + 1 ];
   }
   return 0;
} /* adjust_money() */

void set_money_array( mixed *new_array ) {
   short_d = _long = 0;
   money_array = new_array;
   if ( find_call_out( "check_adjectives" ) == -1 ) {
      call_out( "check_adjectives", 0 );
   }
   fixup_money_weight();
} /* set_money_array() */


/** @ignore yes */
string *half_symbol_short()  {
   int i;
   int value;
   string *retval;
   string *zones = ({ });

   for (i = 0; i < sizeof(money_array); i += 2)
      zones |= ({ MONEY_HAND->query_origin_of(money_array[i]) });

   retval = allocate(sizeof(zones));
   for (i = 0; i < sizeof(zones); i++)  {
      value = query_value_in(zones[i]);
      retval[i] = MONEY_HAND->money_value_string(value, zones[i]);
   }
   return retval;
}


/** @ignore yes */
string *half_short( int full ) {
   int i;
   string *retval;

   retval = ({ });
   for ( i = 0; i < sizeof( money_array ); i += 2 ) {
      if ( money_array[ i + 1 ] < 1 ) {
         continue;
      }
      if ( !full && ( money_array[ i + 1 ] > 12 ) ) {
         retval += ({ "some "+ (string)MONEY_HAND->query_main_plural_for(
               money_array[ i ] ) });
         continue;
      }
      if ( money_array[ i + 1 ] == 1 ) {
         retval += ({ "one "+
               (string)MONEY_HAND->query_short_for( money_array[ i ] ) });
         continue;
      }
      retval += ({ money_array[ i + 1 ] +" "+
            (string)MONEY_HAND->query_main_plural_for( money_array[ i ] ) });
   }
   return retval;
} /* half_short() */

/** @ignore yes */
string short( int dark ) {
   string *retval;

   if ( short_d ) {
      return short_d;
   }
   retval = half_short( 0 );
   if ( !sizeof( retval ) ) {
      return 0;
   }
   if ( sizeof( retval ) == 1 ) {
      short_d = retval[ 0 ];
   } else {
      short_d = query_multiple_short( retval );
   }
   return short_d;
} /* short() */

/** @ignore yes */
string long( string word, int dark ) {
   int i;
   mixed *details;

   if (dark < -1 || dark > 1) {
      return "It is too dark to see anything about the coins.\n";
   }

   if ( _long ) {
      return _long;
   }
   if ( !sizeof( money_array ) ) {
      return "This is some money that isn't money.\n";
   }
   _long = "";
   for ( i = 0; i < sizeof( money_array ); i += 2 ) {
      details = (mixed *)MONEY_HAND->query_details_for( money_array[ i ] );
      if ( money_array[ i + 1 ] == 1 ) {
         _long += "The "+ (string)MONEY_HAND->query_short_for(
               money_array[ i ] ) +" shows ";
      } else {
         _long += "The "+ (string)MONEY_HAND->query_main_plural_for(
               money_array[ i ] ) +" show ";
      }
      _long += details[ 2 ] +" on the reverse, and "+ details[ 3 ] +
            " on the obverse.\n";
   }
   return _long;
} /* long() */

/** @ignore yes */
string query_long_details( string word, int dark, object looker) {
   if (dark < -1 || dark > 1) {
      return "It is too dark to see anything about the coins.\n";
   }
   return long(word, dark);
} /* query_long_details() */

/**
 * This method creates a new money object from the current object.  It uses
 * the current objects values to make the money and removes the avlues from
 * the coins.
 * @param number the number of coins to remove
 * @param type the type of coins to remove
 * @return the new money object
 */
object new_money_object(mixed number, string type) {
   int i;
   object money;
   object env;
   object per;

#ifdef DEBUGGER
   if (find_player(DEBUGGER) == this_player())
      tell_creator(DEBUGGER, "Creating new money object from %O\n", this_object());
#endif

   if (!sizeof(money_array) || _already_joined) {
      return 0;
   }

   if (pointerp(number))  {
#ifdef USE_VAULT
      money = MONEY_VAULT->get_money_ob();
#else
      money = clone_object(MONEY_OBJECT);
#endif
      money->set_no_join();
      money->adjust_money(number);
      for (i = 1; i < sizeof(number); i += 2)
         number[i] = -number[i];
      adjust_money(number);
   }
   else  {
      if (!type || type == "") {
         return 0;
      }
      if ((i = member_array(type, money_array)) == -1) {
         return 0;
      }
      if (number > money_array[i + 1]) {
         return 0;
      }
#ifdef USE_VAULT
      money = MONEY_VAULT->get_money_ob();
#else
      money = clone_object(MONEY_OBJECT);
#endif
      money->set_no_join();
      money->adjust_money(number, type);
      adjust_money(-number, type);
   }

   // Make sure we do this after the weights are correct.
   if (money->move(environment()) != MOVE_OK) {
      env = environment();
      do {
        env = environment(env);
      } while (env && money->move(env) != MOVE_OK);
      per = environment();
      while (per && !living(per)) {
         per = environment(per);
      }

      if (money && env)
        tell_object(per, "Oops, the money " + money->the_short() +
                    " has found life in your inventory too heavy and "
                    "has gone to " + env->the_short() + ".\n");
   }
   return money;
} /* new_money_object() */

/**
 * This method merges two coin object together.  Or attempts to anyway.
 * This will occur whenever a coin object moves.
 * @return the merged coin object
 */
object merge_coins() {
   object money;
   
   if (_already_joined)   return this_object();

   remove_alias( MONEY_ALIAS );
   if(environment()) {
     money = present( MONEY_ALIAS, environment() );
   }
   add_alias( MONEY_ALIAS );
   
   if ( objectp( money ) &&
        money != this_object())
   {
#ifdef USE_VAULT
      MONEY_VAULT->add_to_list(this_object());
#else
      move("/room/rubbish");
#endif
      money->adjust_money( money_array );
      money->fixup_money_weight();
      //
      // Zap the money array, this should stop money duplication.
      //
      _already_joined = 1;

#ifdef DEBUGGER
      if (find_player(DEBUGGER) == this_player())
         tell_creator(DEBUGGER, "Merging %O and %O\n", this_object(), money);
#endif
      return money;
   }

#ifdef DEBUGGER
   if (find_player(DEBUGGER) == this_player())
      tell_creator(DEBUGGER, "Merge coins returning %O\n", this_object());
#endif
   return this_object();
} /* merge_coins() */

/** @ignore yes */
varargs int move( mixed dest, string messin, string messout ) {
   int i;
   
   if (_already_joined)
     return MOVE_INVALID_DEST;

   // Prevent people putting money into containers.
   if(objectp(dest) && environment(dest) && !living(dest) &&
      !dest->query_corpse() && !dest->query_accept_money())
     return MOVE_INVALID_DEST;
   
   i = ::move( dest, messin, messout );
   if ( i != MOVE_OK ) {
      return i;
   }

   if((file_name(environment()) == MONEY_VAULT))
     return MOVE_OK;

   if ( ( file_name( environment() ) == "/room/rubbish" ) || no_join ) {
      reset_no_join();
      return MOVE_OK;
   }

   merge_coins();
   return MOVE_OK;
} /* move() */

public int find_best_fit( mixed word ) {
   int i;
   int best;
   int best_rating;
   int rating;
   string against;
   string *words;

   if ( !word || ( word == "" ) ) {
      return 0;
   }
   if (stringp(word)) {
      words = explode( lower_case( word ), " " ) - ({ "coin", "coins" });
   } else {
      words = word;
   }
   best = -1;
   for ( i = 0; i < sizeof( money_array ); i += 2 ) {
      rating = 0;
      against = "X "+ replace( money_array[ i ] +" "+
            (string)MONEY_HAND->query_plural_for( money_array[ i ] ),
            " coins", "" ) +" X";
      foreach( word in words ) {
         if ( sscanf( against, "%*s "+ word +" %*s" ) == 2 ) {
            rating++;
         }
      }
      if ( rating > best_rating ) {
         best_rating = rating;
         best = i;
      }
   }
   return best;
} /* find_best_fit() */

/** @ignore yes */
object query_parse_id( mixed *arr ) {
   int i;
   string *bits;
   object money;

#ifdef DEBUG
   debug_printf("%O", arr );
#endif
   if ( ( arr[ 0 ] < 0 ) || !sizeof( money_array ) ) {
      return 0;
   }
   if ( arr[ 0 ] == 0 ) {
      bits = explode( arr[ 1 ], " " );
      if ( sizeof( bits ) == 1 ) {
         if ( bits[ 0 ] == "coins" ) {
            return this_object();
         }
      }
      if ( member_array( bits[ sizeof( bits ) - 1 ], query_plurals() ) == -1 ) {
         return this_object();
      }
      i = find_best_fit( arr[ 1 ] );
      if ( i == -1 ) {
         return 0;
      }
      money = new_money_object( money_array[ i + 1 ], money_array[ i ] );
      return money;
   }
   i = find_best_fit( arr[ 1 ] );
   /* Not very satisfactory... */
   if ( i == -1 ) {
      i = 0;
   }
   if ( arr[ 0 ] > money_array[ i + 1 ] ) {
      return 0;
   }
   money = new_money_object( arr[ 0 ], money_array[ i ] );
   return money;
} /* query_parse_id() */

/** @ignore yes */
mixed* parse_match_object(string* input, object viewer,
                          class obj_match_context context) {
   int ret;
   int found;
   int num;
   int i;
   int j;
   int success;
   object money;
   mixed *matched;
   string where;
   string *bits;
   string name;

   if (!sizeof(money_array)) {
      return 0;
   }

   ret = ::is_matching_object(input, viewer, context);
   if (!ret) {
      return 0;
   }

   if (sizeof(input) == 1 &&
       !context->number_included &&
       !context->ordinal &&
       (input[<1] == "coins" || input[<1] == "money" ||
        input[<1] == "all" || input[<1] == "thing" ||
        input[<1] == "one")) {
      return ({ OBJ_PARSER_MATCH_PLURAL, ({ this_object() }) });
   }
   else if (sizeof(input) >= 2  &&
            member_array(input[0], query_adjectives()) > -1  &&
            (input[<1] == "coins"  ||  input[<1] == "money"))
   {
      success = 0;
      name = lower_case(input[0]);
      if (name == "provincial"  ||  name == "default")  {
         success = 1;
         where = "default";
      }
      else for (i = 0; i < sizeof(money_array); i += 2)  {
         bits = explode(lower_case(money_array[i]), " ");
         /*
          * Find area that matches adjective....
          * ie, adjective 'djelian' == area 'Djelibeybi'
          */
         if (member_array(name, bits) > -1)  {
            /* OK, where does this money type come from... */
            where = MONEY_HAND->query_origin_of(money_array[i]);
            if (!where)
               return 0;

            if (where != "default")
               success = 1;
            break;
         }
      }
      if (success)  {
         /* Separate the money from the desired area */
         matched = MONEY_HAND->filter_legal_money_to_array(money_array,
                                                           where);
         if (sizeof(matched[0]) == 0)
            return 0;

         /* Count the number of coins */
         for (j = 1; j < sizeof(matched[0]); j+= 2)
           num += matched[0][j];

         if (!update_parse_match_context(context, num, ret))
            return 0;

         /* Split off a new money object from this one */
         money = new_money_object(matched[0], "");
         if (!money)
            return 0;

         return ({ ret, ({ money }) });
      }
   }

   found = find_best_fit(input);
//printf("CHecking %O found %O\n", input, found);
   if (found == -1) {
      return 0;
   }

   //
   // Lets see how many we have...
   //
   num = money_array[found + 1];
//if (this_player()->query_name() == "pinkfish") {
//printf("%O %O\n", num, ret);
//}
   num = update_parse_match_context(context, num, ret);
   if (!num) {
      return 0;
   }

   money = new_money_object( num, money_array[found]);
   if (!money) {
      return 0;
   }
   return ({ ret, ({ money }) });
} /* parse_match_object() */

/** @ignore yes */
int do_not_sell() { return 1; }

/** @ignore yes */
int query_value() { return 0; }

/** @ignore yes */
int query_value_in( string where ) {
   return (int)MONEY_HAND->query_total_value( money_array, where );
} /* query_value_in() */

/**
 * This method returns the amount of type of money there is in the array.
 * @param type the type of money to check
 * @return the number of coins of that type
 */
int query_money( string type ){
   int i;

   i = member_array( type, money_array );
   if (i == -1 ) {
      return 0;
   }
   return money_array[i + 1];
} /* query_money () */

mixed *stats() {
  return ::stats() +
    ({ ({ "value" , query_multiple_short(half_short(1)) }) });
}
// --- END [/mnt/home2/grok/lib/obj/money.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/cure_wand.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/cure_wand.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627829   Available: 13575183
Inodes: Total: 5242880    Free: 4960133
432 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/cure_wand.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627829   Available: 13575183
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: cure_wand.c,v 1.1 1998/01/06 04:58:17 ceres Exp $
 * $Log: cure_wand.c,v $
 * Revision 1.1  1998/01/06 04:58:17  ceres
 * Initial revision
 * 
*/
/* -*- LPC -*-
 */
inherit "/std/effects/healing/basic_cure";
inherit "/obj/wand";

void create() {
   do_setup++;
   wand::create();
   basic_cure::create();
   do_setup--;
   if ( do_setup )
      this_object()->setup();
} /* create() */
// --- END [/mnt/home2/grok/lib/obj/cure_wand.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/armour.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/armour.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627829   Available: 13575183
Inodes: Total: 5242880    Free: 4960133
6134 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/armour.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627829   Available: 13575183
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Id: armour.c,v 1.20 2003/01/09 10:51:14 taffyd Exp $
 */
#include <move_failures.h>
#include <virtual.h>

#define AC_LIMIT 100

#undef INFORM

inherit "/std/object";
inherit "/std/basic/wearable";
inherit "/std/armour_logic";


void create() {
   do_setup++;
   object::create();
   armour_logic::create();
   wearable::create();
   add_alias( "armour" );
   add_plural( "armours" );
   add_help_file("armour");
   if ( !query_property( "shop type" ) )
      add_property( "shop type", "armoury" );
   do_setup--;
   if ( !do_setup )
      this_object()->setup();
} /* create() */

int query_armour() { return 1; }

string long( string word, int dark ) {
   return object::long( word, dark ) + wearable::long( word, dark );
} /* long() */

varargs int query_ac( string type, int amount, string zone ) {
   int a_class, tmp;

#ifdef INFORM
   string message;
#endif
   a_class = armour_logic::query_ac( type, amount, zone );

#ifdef INFORM
   message = query_short() +": striking " + zone + ", basic value "+ a_class;
#endif

   if ( a_class > AC_LIMIT )
      a_class = AC_LIMIT;
   a_class += ( a_class * query_enchant() ) / query_max_enchant() + query_enchant();

#ifdef INFORM
   message += "; after enchant "+ a_class;
   if ( objectp( worn_by ) )
      event( environment( worn_by ), "inform", message, "combat" );
#endif

   do_damage( type, amount );
   a_class = ( a_class * query_cond() ) / query_max_cond();

   // damage may get through depending on how good the armour is.
   switch(random(a_class)) {
   case 0:
     return 0;
   case 1:
     return a_class / 2;
   case 2..3:
     return a_class * 2 / 3;
   default:
     // they'll always take a small amount of damage.
     if(a_class > amount)
       tmp = amount - (amount / (5 + random(10)));
     else
       tmp = a_class - (amount / (5 + random(10)));

     if(tmp < a_class / 2)
       tmp = a_class / 2;
     return tmp;
   }
} /* query_ac() */

void setup_armour( int number ) {
   set_max_cond( number );
   set_cond( number );
   set_lowest_cond( number );
} /* setup_armour() */

int query_value() {
   return modify_value( object::query_value() );
} /* query_value() */

int query_full_value() { return object::query_value(); }

/**
 * This function is called on an object and causes it to be worn
 * if it can be by it's environment(), i.e the player carrying it.
 */
void player_wear() {
   if ( !environment() )
      return;
   wearable::player_wear();
} /* player_wear() */

/**
 * @ignore yes
 */
int drop(mixed dest) {
   if ( worn_by && living(worn_by))
      return 1;
   return object::drop(dest);
} /* drop() */

/**
 * @ignore yes
 */
varargs int move( mixed dest, string messin, string messout ) {
   int flag;
   flag = object::move( dest, messin, messout );
   if ( ( flag == MOVE_OK ) && worn_by )
      set_worn_by( 0 );
   return flag;
} /* move() */

/**
 * @ignore yes
 */
void dest_me() {
   set_worn_by( 0 );
   object::dest_me();
} /* dest_me() */

/**
 * @ignore yes
 */
mixed *stats() {
   return object::stats() + armour_logic::stats() + wearable::stats() +
          ({ ({ "max ac", AC_LIMIT }) });
} /* stat() */

/**
 * @ignore yes
 */
mapping int_query_static_auto_load() {
   return ([
      "::" : object::int_query_static_auto_load(),
      "ac" : ac,
      "armour types" : armour_types,
   ]) + wearable::query_static_auto_load();
} /* query_static_auto_load() */

/**
 * @ignore yes
 */
mapping query_static_auto_load() {
   if ( base_name(this_object()) != __FILE__[0..<3]) {
      return ([ ]);
   }
   return int_query_static_auto_load();
} /* query_static_auto_load() */

/**
 * @ignore yes
 */
mapping query_dynamic_auto_load() {
   mapping map;
   map = ([
      "::" : object::query_dynamic_auto_load(),
   ]) + wearable::query_dynamic_auto_load();
   return map;
} /* query_dynamic_auto_load() */

/**
 * @ignore yes
 */
void init_static_arg( mapping map ) {
   if ( !mapp( map ) )
      return;
   if ( map[ "::" ] )
      object::init_static_arg( map[ "::" ] );
   wearable::init_static_arg( map );
   if ( map[ "ac" ] )
      ac = map[ "ac" ];

   if (pointerp(ac)) {
     int i;
     mixed *tmp;

     /* Change them to the new system */
     tmp = (mixed *)ac;
     ac = ([ ]);
     for (i=0;i<sizeof(tmp);i+=2)
       add_ac(tmp[0], tmp[1][1], tmp[1][0]);
   } else if ( map[ "armour types" ] )
      armour_types = map[ "armour types" ];

   /* Set up the max ac levels correctly. */
   set_type( query_type() );
} /* init_static_arg() */

void replace_me(){
  object receipt;

  receipt = clone_object( "/std/object" );
  receipt->set_name( "receipt" );
  receipt->set_short( "destructed item receipt" );
  receipt->add_adjective( ({ "destructed", "item" }) );
  receipt->set_long( "This seems to be a small piece of paper.\n" );
  receipt->set_read_mess( "According to our sources, your "+query_short()+" was not "
                          "allowed to exist.  Have a nice day." );
  receipt->move( environment() );
  receipt->set_weight( 1 );
  destruct( this_object() );
}

/**
 * @ignore yes
 */
void init_dynamic_arg( mapping map, object ) {
   mapping stat_temp;
   string virt_name, new_name;

   if ( map[ "::" ] )
      object::init_dynamic_arg( map[ "::" ] );
   wearable::init_dynamic_arg( map );

   if( virt_name = query_property( VIRTUAL_NAME_PROP ) ) {
     if( file_size( virt_name ) == -1 ) {
       new_name = ( CLONER )->other_file( virt_name );
       if( stringp( new_name ) && ( new_name != virt_name ) ) {
         add_property( VIRTUAL_NAME_PROP, new_name );
         virt_name = new_name;
       } else {
         if( VIRTUAL_HANDLER->query_forbidden( virt_name ) ) {
           call_out( "replace_me", 1 );
         } else {
           VIRTUAL_HANDLER->add_missing( virt_name );
         }
       }
     }
     if( file_size( virt_name ) != -1 &&
         query_property( "virtual time" ) < stat( virt_name )[1] ) {
       stat_temp = ( VIRTUAL_HANDLER )->new_data( virt_name );
       if( mapp( stat_temp ) ) {
         init_static_arg( stat_temp );
         add_property( "virtual time", time() );
       }
     }
   }

} /* init_dynamic_arg() */

// --- END [/mnt/home2/grok/lib/obj/armour.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/cont_save.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/cont_save.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627827   Available: 13575181
Inodes: Total: 5242880    Free: 4960133
3621 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/cont_save.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627827   Available: 13575181
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: cont_save.c,v 1.10 2001/08/25 02:00:52 ceres Exp $
 * 
*/
/**
 * A container that will save it's contents in a nice happy way.  The
 * container will not allow stuff in or out until it has finished loading.
 * @author Ceres
 */
inherit "/obj/baggage";

private mapping details;
private nosave string _save_file;
private object _loading;
private nosave int _can_recurse;

/**
 * Loads the data for the saved container from the save file.
 * @param thing the person to report errors to
 */
varargs void do_load( object thing ) {
   if ( _save_file ) {
      all_inventory( this_object() ) -> dest_me();
      if ( file_size( _save_file + ".o" ) > 0 ) {
         unguarded((: restore_object, _save_file :));
         if ( thing ) {
            set_player( thing );
         }
         if ( sizeof( details ) ) {
            init_dynamic_arg( details, 0 );
         }
      }
   }
} /* do_load() */

void create() {
   _save_file = "";
   details = ([ ]);
   _can_recurse = 0;
   ::create();
} /* create() */

/**
 * @ignore yes
 * Over ridden to allow stuff being restored to be added.
 */
protected int handle_restore_inventory(object ob) {
   _loading = ob;
   return ::handle_restore_inventory(ob);
} /* handle_restore_inventory() */

/** @ignore yes */
string query_long_details(string arg, int dark, object looker) {
   string ret;

   ret = ::query_long_details(arg, dark, looker);
   if (query_auto_loading()) {
      return ret + the_short() + " contents is still being generated.\n";
   }
   return ret;
} /* query_long_details() */

/** @ignore yes */
int test_remove( object thing, int flag, mixed dest ) {
   if (!query_auto_loading()) {
      remove_call_out( "do_save" );
      if ( find_call_out( "do_save" ) == -1 ) {
         call_out( "do_save", 1 );
      }
      return ::test_remove( thing, flag, dest );
   } else if (_loading == thing) {
      return ::test_remove( thing, flag, dest );
   } else {
      return 0;
   }
} /* test_remove() */

/** @ignore yes */
int test_add( object ob, int flag) {
   if (!query_auto_loading()) {
      remove_call_out( "do_save" );
      if ( find_call_out( "do_save" ) == -1 ) {
         call_out( "do_save", 1 );
      }
      return 1;
   } else if (_loading == ob) {
      return ::test_add( ob, flag );
   } else {
      return 0;
   }
} /* test_add() */

/**
 * This method saves the data to the save file.
 */
void do_save() {
   if ( _save_file && _save_file != "" &&
        !query_auto_loading()) {
      details = ([ ]);
      details = query_dynamic_auto_load();
      unguarded((: save_object, _save_file :));
   }
} /* do_save() */

/** @ignore yes */
void check_euid() {   
   if ( previous_object() ) {
      seteuid( geteuid( previous_object() ) );
   }
} /* check_euid() */

/**
 * This method sets the save file for the item and then does a load.
 * @param file the file name to set the save object to
 * @param thing the thing to set as the person to report errors to
 */
varargs void set_save_file( string file, object thing ) {
   _save_file = file;
   call_out( "do_load", 0, thing );
} /* set_save_file() */

/**
 * This method returns the current save file for the object.
 * @return the current save file
 */
string query_save_file() {
   return _save_file;
} /* query_save_file() */


void set_can_recurse(int recurse_flag) { _can_recurse = recurse_flag; }

int query_can_recurse() { return _can_recurse; }


int can_find_match_recurse_into(object looker) {
   if (query_closed()) {
      return 0;
   }
   if (!_can_recurse)
      return ::can_find_match_recurse_into(looker);
   return 1;
}
// --- END [/mnt/home2/grok/lib/obj/cont_save.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/bottle.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/bottle.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627826   Available: 13575180
Inodes: Total: 5242880    Free: 4960133
2913 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/bottle.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627826   Available: 13575180
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: bottle.c,v 1.4 2003/07/09 11:26:29 carmine Exp $
 * $Log: bottle.c,v $
 * Revision 1.4  2003/07/09 11:26:29  carmine
 * Gave bottles vague sizes and a material
 *
 * Revision 1.3  2001/01/16 02:41:28  presto
 * Changed mass to be a float
 *
 * Revision 1.2  1999/10/25 23:05:21  pinkfish
 * Fix up a few elements of things.
 *
 * Revision 1.1  1998/01/06 04:58:17  ceres
 * Initial revision
 * 
*/
#define PHIAL 150
#define BOTTLE 1000
#define QUIRM 2500
#define DEMIJOHN 50000

inherit "/obj/vessel";

nosave string glass;

void make_bottle( string word, int number ) {
   float mass;
   string adjective, noun;
   glass = word;

   set_max_volume(number*4);
   mass = number / 100.0;
   if ( !mass ) mass = 1;
   set_leak_rate( 0 );
   set_value( to_int(mass * 25 + random( mass * 10 )) );
   set_weight( to_int(mass + random( mass * 10 ) / 10 ));
   set_max_weight( to_int(mass * 2 ));
   add_property( "fragile", to_int(mass * 20 + random( mass * 5 )) );
   switch( number ) {
      case 0..PHIAL:
         adjective = "small";
         noun = "phial";
         set_length( 2 );
         set_width( 1 );
         break;
      case PHIAL+1..BOTTLE:
         adjective = "medium sized";
         noun = "bottle";
         set_length( 12 );
         set_width( 6 );
         break;
      case BOTTLE+1..QUIRM:
         adjective = "large";
         noun = "Quirm";
         set_length( 24 );
         set_width( 12 );
         break;
      case QUIRM+1..DEMIJOHN:
         adjective = "very large";
         noun = "demijohn";
         set_length( 48 );
         set_width( 24 );
         break;
      default:
         adjective = "huge";
         noun = "tank";
         set_length( 88 );
         set_width( 48 );
   }
   set_name( lower_case( noun ) );
   set_short( adjective +" "+ glass +" "+ noun );
   set_long( "This is a "+ adjective +" "+ glass +" glass "+ noun +".\n" );
   add_alias( "bottle" );
   add_adjective( ({ adjective, glass }) );
   set_main_plural( adjective +" "+ glass +" "+ noun +"s" );
   add_plural( lower_case( noun ) +"s" );
   set_material( ({ "glass" }) );
} /* make_bottle() */

string query_glass() { return glass; }
int query_number() { return (int)query_property( "number" ); }

mixed *stats() {
   return ::stats() + ({
      ({ "glass", glass, }),
   });
} /* stats() */

mapping int_query_static_auto_load() {
   return ([
      "::" : ::int_query_static_auto_load(),
      "glass" : glass,
   ]);
} /* int_query_static_auto_load() */

void init_static_arg( mapping map ) {
   if ( map["::"] )
      ::init_static_arg( map["::"] );
   if ( !undefinedp( map["glass"] ) )
      glass = map["glass"];
} /* init_static_arg() */

mixed query_static_auto_load() {
   if ( explode( file_name( this_object() ), "#" )[ 0 ] == "/obj/bottle" )
      return int_query_static_auto_load();
   return ([ ]);
} /* query_static_auto_load() */
// --- END [/mnt/home2/grok/lib/obj/bottle.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/weapons/knives/.chisel.wep_virtual_.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/weapons/knives/.chisel.wep_virtual_.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627825   Available: 13575179
Inodes: Total: 5242880    Free: 4960133
1136 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/weapons/knives/.chisel.wep_virtual_.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627825   Available: 13575179
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <virtual.h>

void dest_me() { destruct( this_object() ); }

void create()
{
  seteuid( (string)"/secure/master"->creator_file( file_name( this_object() ) ) );
} /* create() */

object create_virtual_ob() {
   object clone;

  clone = (object)SERVER->create_virtual_object( "/obj/weapon.c", 1 );
  clone->add_property( VIRTUAL_NAME_PROP, "/obj/weapons/knives/chisel.wep#1" );
  call_other( clone, "set_name", "chisel"  );
  call_other( clone, "set_short", "chisel"  );
  call_other( clone, "set_long", "This is a tool with a sharp edge which is used to shape and cut metal, wood, or stone.\n"  );
  call_other( clone, "set_weight", 11  );
  call_other( clone, "set_length", 6  );
  call_other( clone, "set_width", 3  );
  call_other( clone, "set_material",  "steel"  );
  call_other( clone, "set_value", 300  );
  call_other( clone, "new_weapon", 19200  );
  call_other( clone, "set_damage_chance", 5  );
  call_other( clone, "add_attack", "slash", 30, ({ 10, 3, 10 }), "sharp", "sharp", 0  );
  call_other( clone, "add_attack", "stab", 30, ({ 10, 3, 10 }), "pierce", "pierce", 0 );
   return clone;
} /* create_virtual_ob() */
// --- END [/mnt/home2/grok/lib/obj/weapons/knives/.chisel.wep_virtual_.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/weapons/knives/.sharp_butter_knife.wep_virtual_.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/weapons/knives/.sharp_butter_knife.wep_virtual_.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627825   Available: 13575179
Inodes: Total: 5242880    Free: 4960133
1316 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/weapons/knives/.sharp_butter_knife.wep_virtual_.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627825   Available: 13575179
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <virtual.h>

void dest_me() { destruct( this_object() ); }

void create()
{
  seteuid( (string)"/secure/master"->creator_file( file_name( this_object() ) ) );
} /* create() */

object create_virtual_ob() {
   object clone;

  clone = (object)SERVER->create_virtual_object( "/obj/weapon.c", 1 );
  clone->add_property( VIRTUAL_NAME_PROP, "/obj/weapons/knives/sharp_butter_knife.wep#1" );
  call_other( clone, "set_name", "knife"  );
  call_other( clone, "set_short", "sharp butter knife"  );
  call_other( clone, "set_main_plural", "sharp butter knives"  );
  call_other( clone, "add_adjective", ({ "sharp", "butter" })  );
  call_other( clone, "add_alias", ({ "utensil" })  );
  call_other( clone, "add_plural", "knives"  );
  call_other( clone, "set_long",  "This is a butter knife that has been sharpened a bit.\n"  );
  call_other( clone, "set_weight",  3  );
  call_other( clone, "set_length",  6  );
  call_other( clone, "set_width",  1  );
  call_other( clone, "set_material",  "steel"  );
  call_other( clone, "set_value",  75  );
  call_other( clone, "new_weapon",  500  );
  call_other( clone, "add_attack",  "slash", 70, ({ 15, 2, 20 }), "sharp", "sharp", 0  );
  call_other( clone, "add_attack",  "stab", 40, ({ 20, 2, 30 }), "pierce", "pierce", 0 );
   return clone;
} /* create_virtual_ob() */
// --- END [/mnt/home2/grok/lib/obj/weapons/knives/.sharp_butter_knife.wep_virtual_.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/weapons/knives/.black_handled_ceremonial_bronze_knife.wep_virtual_.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/weapons/knives/.black_handled_ceremonial_bronze_knife.wep_virtual_.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627824   Available: 13575178
Inodes: Total: 5242880    Free: 4960133
1438 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/weapons/knives/.black_handled_ceremonial_bronze_knife.wep_virtual_.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627824   Available: 13575178
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <virtual.h>

void dest_me() { destruct( this_object() ); }

void create()
{
  seteuid( (string)"/secure/master"->creator_file( file_name( this_object() ) ) );
} /* create() */

object create_virtual_ob() {
   object clone;

  clone = (object)SERVER->create_virtual_object( "/obj/weapon.c", 1 );
  clone->add_property( VIRTUAL_NAME_PROP, "/obj/weapons/knives/black_handled_ceremonial_bronze_knife.wep#1" );
  call_other( clone, "set_name", "knife"  );
  call_other( clone, "set_short", "black handled ceremonial bronze knife"  );
  call_other( clone, "add_adjective", ({ "black", "handled", "ceremonial", "bronze" })  );
  call_other( clone, "set_main_plural", "black handled ceremonial bronze knives"  );
  call_other( clone, "add_plural", "knives"  );
  call_other( clone, "set_long", "This is a ceremonial knife, for use in magic rituals.  Its ornate handle is made of ebony and its long bronze blade has been carved with mystic runes.\n"  );
  call_other( clone, "set_weight", 11  );
  call_other( clone, "set_length", 13  );
  call_other( clone, "set_width", 4  );
  call_other( clone, "set_material", "copper"  );
  call_other( clone, "set_value", 1000  );
  call_other( clone, "new_weapon", 2000  );
  call_other( clone, "add_attack", "slash", 70, ({ 10, 2, 20 }), "sharp", "sharp", 0  );
  call_other( clone, "add_attack", "stab", 40, ({ 20, 2, 60 }), "pierce", "pierce", 0 );
   return clone;
} /* create_virtual_ob() */
// --- END [/mnt/home2/grok/lib/obj/weapons/knives/.black_handled_ceremonial_bronze_knife.wep_virtual_.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/weapons/knives/.letter_opener.wep_virtual_.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/weapons/knives/.letter_opener.wep_virtual_.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627824   Available: 13575178
Inodes: Total: 5242880    Free: 4960133
1262 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/weapons/knives/.letter_opener.wep_virtual_.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627824   Available: 13575178
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <virtual.h>

void dest_me() { destruct( this_object() ); }

void create()
{
  seteuid( (string)"/secure/master"->creator_file( file_name( this_object() ) ) );
} /* create() */

object create_virtual_ob() {
   object clone;

  clone = (object)SERVER->create_virtual_object( "/obj/weapon.c", 1 );
  clone->add_property( VIRTUAL_NAME_PROP, "/obj/weapons/knives/letter_opener.wep#1" );
  call_other( clone, "set_name", "opener"  );
  call_other( clone, "set_short", "pearl-handled letter opener"  );
  call_other( clone, "add_adjective", ({ "pearl-handled", "pearl", "handled", "letter" })  );
  call_other( clone, "set_main_plural", "pearl-handled letter openers"  );
  call_other( clone, "set_long", "This letter opener has a lovely pearl handle.  It has a pointy blade that could come in handy in a crunch.\n"  );
  call_other( clone, "set_weight", 4  );
  call_other( clone, "set_length", 8  );
  call_other( clone, "set_width", 1  );
  call_other( clone, "set_material", "steel"  );
  call_other( clone, "set_value", 5000  );
  call_other( clone, "new_weapon", 1600  );
  call_other( clone, "set_damage_chance", 8  );
  call_other( clone, "add_attack", "stab", 40, ({ 30, 3, 10 }), "pierce", "pierce", 0 );
   return clone;
} /* create_virtual_ob() */
// --- END [/mnt/home2/grok/lib/obj/weapons/knives/.letter_opener.wep_virtual_.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/weapons/knives/.tanto.wep_virtual_.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/weapons/knives/.tanto.wep_virtual_.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627823   Available: 13575177
Inodes: Total: 5242880    Free: 4960133
1333 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/weapons/knives/.tanto.wep_virtual_.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627823   Available: 13575177
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <virtual.h>

void dest_me() { destruct( this_object() ); }

void create()
{
  seteuid( (string)"/secure/master"->creator_file( file_name( this_object() ) ) );
} /* create() */

object create_virtual_ob() {
   object clone;

  clone = (object)SERVER->create_virtual_object( "/obj/weapon.c", 1 );
  clone->add_property( VIRTUAL_NAME_PROP, "/obj/weapons/knives/tanto.wep#1" );
  call_other( clone, "set_name", "tanto"  );
  call_other( clone, "set_short", "tanto"  );
  call_other( clone, "add_alias", "dagger"  );
  call_other( clone, "add_plural", ({"daggers","tantos"})  );
  call_other( clone, "set_main_plural", "tantos"  );
  call_other( clone, "set_long", "This large auriental dagger is an excellent weapon for close-in fighting.  It is short, well crafted and looks pretty durable.\n"  );
  call_other( clone, "set_weight", 9  );
  call_other( clone, "set_length", 10  );
  call_other( clone, "set_width", 3  );
  call_other( clone, "set_material", "steel"  );
  call_other( clone, "set_value", 4000  );
  call_other( clone, "new_weapon", 50000  );
  call_other( clone, "set_damage_chance", 2  );
  call_other( clone, "add_attack", "slash", 75, ({ 0, 2, 40 }), "sharp", "sharp", 0  );
  call_other( clone, "add_attack", "stab", 50, ({ 9, 4, 30 }), "pierce", "pierce", 0 );
   return clone;
} /* create_virtual_ob() */
// --- END [/mnt/home2/grok/lib/obj/weapons/knives/.tanto.wep_virtual_.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/weapons/knives/.stiletto.wep_virtual_.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/weapons/knives/.stiletto.wep_virtual_.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627823   Available: 13575177
Inodes: Total: 5242880    Free: 4960133
1430 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/weapons/knives/.stiletto.wep_virtual_.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627823   Available: 13575177
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <virtual.h>

void dest_me() { destruct( this_object() ); }

void create()
{
  seteuid( (string)"/secure/master"->creator_file( file_name( this_object() ) ) );
} /* create() */

object create_virtual_ob() {
   object clone;

  clone = (object)SERVER->create_virtual_object( "/obj/weapon.c", 1 );
  clone->add_property( VIRTUAL_NAME_PROP, "/obj/weapons/knives/stiletto.wep#1" );
  call_other( clone, "set_name", "stiletto"  );
  call_other( clone, "set_short", "stiletto"  );
  call_other( clone, "add_alias", "knife"  );
  call_other( clone, "add_adjective", "slender"  );
  call_other( clone, "set_main_plural", "stilettoes"  );
  call_other( clone, "add_plural", "knives"  );
  call_other( clone, "set_long", "This is a slender knife with a dark steel blade, and sharp tip.  "         "It's perfect for slipping between someone's ribs.\n"  );
  call_other( clone, "set_weight", 7  );
  call_other( clone, "set_length", 10  );
  call_other( clone, "set_width", 1  );
  call_other( clone, "set_material",  "steel"  );
  call_other( clone, "set_value", 2000  );
  call_other( clone, "new_weapon",  5000  );
  call_other( clone, "set_damage_chance",  5  );
  call_other( clone, "add_attack",  "stab", 70, ({ 40, 4, 20 }), "pierce", "pierce"  );
  call_other( clone, "add_attack",  "stabstab", 70, ({ 40, 4, 20 }), "pierce", "pierce"  );
  call_other( clone, "set_no_limbs", 1 );
   return clone;
} /* create_virtual_ob() */
// --- END [/mnt/home2/grok/lib/obj/weapons/knives/.stiletto.wep_virtual_.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/weapons/knives/.small_knife.wep_virtual_.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/weapons/knives/.small_knife.wep_virtual_.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627822   Available: 13575176
Inodes: Total: 5242880    Free: 4960133
1333 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/weapons/knives/.small_knife.wep_virtual_.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627822   Available: 13575176
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <virtual.h>

void dest_me() { destruct( this_object() ); }

void create()
{
  seteuid( (string)"/secure/master"->creator_file( file_name( this_object() ) ) );
} /* create() */

object create_virtual_ob() {
   object clone;

  clone = (object)SERVER->create_virtual_object( "/obj/weapon.c", 1 );
  clone->add_property( VIRTUAL_NAME_PROP, "/obj/weapons/knives/small_knife.wep#1" );
  call_other( clone, "set_name", "knife"  );
  call_other( clone, "set_short", "small knife"  );
  call_other( clone, "add_adjective", ({ "small" })  );
  call_other( clone, "add_alias", "utensil"  );
  call_other( clone, "add_plural", "utensils"  );
  call_other( clone, "set_long", "This small knife might be the sort of thing " "you'd use to peel an apple, slice carrots or " "stab in someone's kidney.  You could say " "that it's a multi-purpose utensil.\n"  );
  call_other( clone, "set_weight", 6  );
  call_other( clone, "set_length", 7  );
  call_other( clone, "set_width", 1  );
  call_other( clone, "set_material",  "steel"  );
  call_other( clone, "set_value", 50  );
  call_other( clone, "new_weapon", 500  );
  call_other( clone, "add_attack", "slash", 70, ({ 5, 2, 20 }), "sharp", "sharp", 0  );
  call_other( clone, "add_attack", "stab", 40, ({ 10, 2, 30 }), "pierce", "pierce", 0 );
   return clone;
} /* create_virtual_ob() */
// --- END [/mnt/home2/grok/lib/obj/weapons/knives/.small_knife.wep_virtual_.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/weapons/knives/.small_copper_knife.wep_virtual_.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/weapons/knives/.small_copper_knife.wep_virtual_.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627822   Available: 13575176
Inodes: Total: 5242880    Free: 4960133
1259 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/weapons/knives/.small_copper_knife.wep_virtual_.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627822   Available: 13575176
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <virtual.h>

void dest_me() { destruct( this_object() ); }

void create()
{
  seteuid( (string)"/secure/master"->creator_file( file_name( this_object() ) ) );
} /* create() */

object create_virtual_ob() {
   object clone;

  clone = (object)SERVER->create_virtual_object( "/obj/weapon.c", 1 );
  clone->add_property( VIRTUAL_NAME_PROP, "/obj/weapons/knives/small_copper_knife.wep#1" );
  call_other( clone, "set_name", "knife"  );
  call_other( clone, "set_short", "small copper knife"  );
  call_other( clone, "set_main_plural", "small copper knives"  );
  call_other( clone, "add_adjective", ({ "small", "copper" })  );
  call_other( clone, "set_long", "This is a small, Djelian, copper knife.  Its straight blade and hilt are undecorated, clean and functional.\n"  );
  call_other( clone, "set_weight", 5  );
  call_other( clone, "set_length", 8  );
  call_other( clone, "set_width", 3  );
  call_other( clone, "set_material",  "copper"  );
  call_other( clone, "set_value", 100  );
  call_other( clone, "new_weapon", 16000  );
  call_other( clone, "add_attack", "slash", 100, ({ 10, 5, 10 }), "sharp", "sharp"  );
  call_other( clone, "add_attack", "stab", 50, ({ 10, 2, 15 }), "pierce", "pierce" );
   return clone;
} /* create_virtual_ob() */
// --- END [/mnt/home2/grok/lib/obj/weapons/knives/.small_copper_knife.wep_virtual_.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/weapons/knives/.dagger.wep_virtual_.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/weapons/knives/.dagger.wep_virtual_.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627821   Available: 13575175
Inodes: Total: 5242880    Free: 4960133
1225 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/weapons/knives/.dagger.wep_virtual_.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627821   Available: 13575175
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <virtual.h>

void dest_me() { destruct( this_object() ); }

void create()
{
  seteuid( (string)"/secure/master"->creator_file( file_name( this_object() ) ) );
} /* create() */

object create_virtual_ob() {
   object clone;

  clone = (object)SERVER->create_virtual_object( "/obj/weapon.c", 1 );
  clone->add_property( VIRTUAL_NAME_PROP, "/obj/weapons/knives/dagger.wep#1" );
  call_other( clone, "set_name", "dagger"  );
  call_other( clone, "set_short", "dagger"  );
  call_other( clone, "add_adjective", ({ })  );
  call_other( clone, "add_alias", ({ })  );
  call_other( clone, "add_plural", ({ "daggers" })  );
  call_other( clone, "set_long",  "This is a largish looking knife.\n"  );
  call_other( clone, "set_material", "steel"  );
  call_other( clone, "set_weight", 10  );
  call_other( clone, "set_length", 11  );
  call_other( clone, "set_width", 2  );
  call_other( clone, "set_value",  200  );
  call_other( clone, "new_weapon", 12800  );
  call_other( clone, "set_damage_chance", 5  );
  call_other( clone, "add_attack", "slash", 75, ({ 10, 5, 15 }), "sharp", "sharp"  );
  call_other( clone, "add_attack", "stab", 50, ({ 10, 2, 25 }), "pierce", "pierce" );
   return clone;
} /* create_virtual_ob() */
// --- END [/mnt/home2/grok/lib/obj/weapons/knives/.dagger.wep_virtual_.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/weapons/knives/.white_handled_ceremonial_bronze_knife.wep_virtual_.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/weapons/knives/.white_handled_ceremonial_bronze_knife.wep_virtual_.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627821   Available: 13575175
Inodes: Total: 5242880    Free: 4960133
1439 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/weapons/knives/.white_handled_ceremonial_bronze_knife.wep_virtual_.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627821   Available: 13575175
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <virtual.h>

void dest_me() { destruct( this_object() ); }

void create()
{
  seteuid( (string)"/secure/master"->creator_file( file_name( this_object() ) ) );
} /* create() */

object create_virtual_ob() {
   object clone;

  clone = (object)SERVER->create_virtual_object( "/obj/weapon.c", 1 );
  clone->add_property( VIRTUAL_NAME_PROP, "/obj/weapons/knives/white_handled_ceremonial_bronze_knife.wep#1" );
  call_other( clone, "set_name", "knife"  );
  call_other( clone, "set_short", "white handled ceremonial bronze knife"  );
  call_other( clone, "add_adjective", ({ "white", "handled", "ceremonial", "bronze" })  );
  call_other( clone, "set_main_plural", "white handled ceremonial bronze knives"  );
  call_other( clone, "add_plural", "knives"  );
  call_other( clone, "set_long", "This is a ceremonial knife, for use in magic rituals.  Its ornate handle is made of ivory and its long bronze blade has been carved with mystic runes.\n"  );
  call_other( clone, "set_weight", 11  );
  call_other( clone, "set_length", 18  );
  call_other( clone, "set_width", 3  );
  call_other( clone, "set_material",  "bronze"  );
  call_other( clone, "set_value", 1000  );
  call_other( clone, "new_weapon", 2000  );
  call_other( clone, "add_attack", "slash", 70, ({ 10, 2, 20 }), "sharp", "sharp", 0  );
  call_other( clone, "add_attack", "stab", 40, ({ 20, 2, 60 }), "pierce", "pierce", 0 );
   return clone;
} /* create_virtual_ob() */
// --- END [/mnt/home2/grok/lib/obj/weapons/knives/.white_handled_ceremonial_bronze_knife.wep_virtual_.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/weapons/knives/.copper_fighting_knife.wep_virtual_.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/weapons/knives/.copper_fighting_knife.wep_virtual_.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627820   Available: 13575174
Inodes: Total: 5242880    Free: 4960133
1283 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/weapons/knives/.copper_fighting_knife.wep_virtual_.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627820   Available: 13575174
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <virtual.h>

void dest_me() { destruct( this_object() ); }

void create()
{
  seteuid( (string)"/secure/master"->creator_file( file_name( this_object() ) ) );
} /* create() */

object create_virtual_ob() {
   object clone;

  clone = (object)SERVER->create_virtual_object( "/obj/weapon.c", 1 );
  clone->add_property( VIRTUAL_NAME_PROP, "/obj/weapons/knives/copper_fighting_knife.wep#1" );
  call_other( clone, "set_name", "knife"  );
  call_other( clone, "set_short", "copper fighting knife"  );
  call_other( clone, "set_main_plural", "copper fighting knives"  );
  call_other( clone, "add_adjective", ({ "copper", "fighting" })  );
  call_other( clone, "set_long", "This Djelian copper knife is designed for fighting.  Its straight blade and hilt are undecorated, clean and functional.\n"  );
  call_other( clone, "set_weight", 9  );
  call_other( clone, "set_length", 10  );
  call_other( clone, "set_width", 2  );
  call_other( clone, "set_material", "copper"  );
  call_other( clone, "set_value", 180  );
  call_other( clone, "new_weapon", 32000  );
  call_other( clone, "add_attack", "slash", 100, ({ 10, 5, 15 }), "sharp", "sharp"  );
  call_other( clone, "add_attack", "stab", 50, ({ 10, 2, 20 }), "pierce", "pierce" );
   return clone;
} /* create_virtual_ob() */
// --- END [/mnt/home2/grok/lib/obj/weapons/knives/.copper_fighting_knife.wep_virtual_.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/weapons/knives/.klatchian_steel_dirk.wep_virtual_.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/weapons/knives/.klatchian_steel_dirk.wep_virtual_.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627820   Available: 13575174
Inodes: Total: 5242880    Free: 4960133
1330 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/weapons/knives/.klatchian_steel_dirk.wep_virtual_.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627820   Available: 13575174
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <virtual.h>

void dest_me() { destruct( this_object() ); }

void create()
{
  seteuid( (string)"/secure/master"->creator_file( file_name( this_object() ) ) );
} /* create() */

object create_virtual_ob() {
   object clone;

  clone = (object)SERVER->create_virtual_object( "/obj/weapon.c", 1 );
  clone->add_property( VIRTUAL_NAME_PROP, "/obj/weapons/knives/klatchian_steel_dirk.wep#1" );
  call_other( clone, "set_name", "dirk"  );
  call_other( clone, "set_short", "Klatchian steel dirk"  );
  call_other( clone, "add_adjective", ({ "klatchian", "steel" })  );
  call_other( clone, "add_alias", "dagger"  );
  call_other( clone, "add_plural", "daggers"  );
  call_other( clone, "set_long", "This is a very long, curving knife with a wickedly sharp point.  It is made of Klatchian steel.\n"  );
  call_other( clone, "set_weight", 12  );
  call_other( clone, "set_length", 18  );
  call_other( clone, "set_width", 3  );
  call_other( clone, "set_material", "steel"  );
  call_other( clone, "set_value", 400  );
  call_other( clone, "new_weapon", 32000  );
  call_other( clone, "set_damage_chance", 5  );
  call_other( clone, "add_attack", "slash", 75, ({ 10, 5, 20 }), "sharp", "sharp"  );
  call_other( clone, "add_attack", "stab", 50, ({ 10, 2, 27 }), "pierce", "pierce" );
   return clone;
} /* create_virtual_ob() */
// --- END [/mnt/home2/grok/lib/obj/weapons/knives/.klatchian_steel_dirk.wep_virtual_.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/weapons/knives/.meat_cleaver.wep_virtual_.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/weapons/knives/.meat_cleaver.wep_virtual_.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627819   Available: 13575173
Inodes: Total: 5242880    Free: 4960133
1434 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/weapons/knives/.meat_cleaver.wep_virtual_.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627819   Available: 13575173
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <virtual.h>

void dest_me() { destruct( this_object() ); }

void create()
{
  seteuid( (string)"/secure/master"->creator_file( file_name( this_object() ) ) );
} /* create() */

object create_virtual_ob() {
   object clone;

  clone = (object)SERVER->create_virtual_object( "/obj/weapon.c", 1 );
  clone->add_property( VIRTUAL_NAME_PROP, "/obj/weapons/knives/meat_cleaver.wep#1" );
  call_other( clone, "set_name", "cleaver"  );
  call_other( clone, "set_short", "meat cleaver"  );
  call_other( clone, "add_alias", ({ "utensil", "knife" })  );
  call_other( clone, "add_adjective", "meat"  );
  call_other( clone, "set_main_plural", "meat cleavers"  );
  call_other( clone, "add_plural", ({ "utensils", "knives" })  );
  call_other( clone, "set_long", "This is a butcher's implement for cutting animal carcasses into joints or pieces.  It is a large, rectangular knife and is quite heavy.\n"  );
  call_other( clone, "set_weight", 16  );
  call_other( clone, "set_length",  11  );
  call_other( clone, "set_width", 5  );
  call_other( clone, "set_material",  "steel"  );
  call_other( clone, "set_value", 400  );
  call_other( clone, "new_weapon", 750  );
  call_other( clone, "set_damage_chance", 5  );
  call_other( clone, "add_attack", "slash", 50, ({ 10, 4, 10 }), "sharp", "sharp", 0  );
  call_other( clone, "add_attack", "hack", 90, ({ 20, 3, 20 }), "sharp", "sharp", 0 );
   return clone;
} /* create_virtual_ob() */
// --- END [/mnt/home2/grok/lib/obj/weapons/knives/.meat_cleaver.wep_virtual_.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/weapons/knives/.howondalandish_throwing_knife.wep_virtual_.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/weapons/knives/.howondalandish_throwing_knife.wep_virtual_.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627818   Available: 13575172
Inodes: Total: 5242880    Free: 4960133
1489 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/weapons/knives/.howondalandish_throwing_knife.wep_virtual_.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627818   Available: 13575172
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <virtual.h>

void dest_me() { destruct( this_object() ); }

void create()
{
  seteuid( (string)"/secure/master"->creator_file( file_name( this_object() ) ) );
} /* create() */

object create_virtual_ob() {
   object clone;

  clone = (object)SERVER->create_virtual_object( "/obj/weapon.c", 1 );
  clone->add_property( VIRTUAL_NAME_PROP, "/obj/weapons/knives/howondalandish_throwing_knife.wep#1" );
  call_other( clone, "set_name", "knife"  );
  call_other( clone, "add_adjective", ({ "howondalandish", "throwing" })  );
  call_other( clone, "set_short", "howondalandish throwing knife"  );
  call_other( clone, "set_main_plural", "howondalandish throwing knives"  );
  call_other( clone, "set_long", "From one of the more remote Howondalandish tribes, this knife "   "doesn't look throwable, much less a knife.  From a short handle, "   "spiky steel blades jut out at all angles, sure to deliver a nasty "   "shock to whoever gets hit with it.\n"  );
  call_other( clone, "set_weight", 9  );
  call_other( clone, "set_length", 9  );
  call_other( clone, "set_width", 3  );
  call_other( clone, "set_material", "steel"  );
  call_other( clone, "new_weapon", 200  );
  call_other( clone, "set_damage_chance", 10  );
  call_other( clone, "add_attack", "stab", 60, ({ 40, 3, 30 }), "pierce", "pierce", 0  );
  call_other( clone, "add_attack", "slash", 60, ({ 25, 5, 30 }), "sharp", "sharp", 0  );
  call_other( clone, "set_value", 7000 );
   return clone;
} /* create_virtual_ob() */
// --- END [/mnt/home2/grok/lib/obj/weapons/knives/.howondalandish_throwing_knife.wep_virtual_.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/weapons/knives/.carving_knife.wep_virtual_.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/weapons/knives/.carving_knife.wep_virtual_.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627818   Available: 13575172
Inodes: Total: 5242880    Free: 4960133
1335 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/weapons/knives/.carving_knife.wep_virtual_.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627818   Available: 13575172
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <virtual.h>

void dest_me() { destruct( this_object() ); }

void create()
{
  seteuid( (string)"/secure/master"->creator_file( file_name( this_object() ) ) );
} /* create() */

object create_virtual_ob() {
   object clone;

  clone = (object)SERVER->create_virtual_object( "/obj/weapon.c", 1 );
  clone->add_property( VIRTUAL_NAME_PROP, "/obj/weapons/knives/carving_knife.wep#1" );
  call_other( clone, "set_name", "knife"  );
  call_other( clone, "set_short", "carving knife"  );
  call_other( clone, "add_adjective", ({ "carving" })  );
  call_other( clone, "add_alias", "utensil"  );
  call_other( clone, "add_plural", "utensils"  );
  call_other( clone, "set_long", "This is a knife such as you might use to carve up your Octeday roast, and then use to substantiate your arguments with your spouse as to who should do the washing up.\n"  );
  call_other( clone, "set_weight", 9  );
  call_other( clone, "set_length", 12  );
  call_other( clone, "set_width", 2  );
  call_other( clone, "set_material", "steel"  );
  call_other( clone, "set_value", 500  );
  call_other( clone, "new_weapon", 2000  );
  call_other( clone, "add_attack", "slash", 70, ({ 10, 2, 20 }), "sharp", "sharp", 0  );
  call_other( clone, "add_attack", "stab", 40, ({ 20, 2, 60 }), "pierce", "pierce", 0 );
   return clone;
} /* create_virtual_ob() */
// --- END [/mnt/home2/grok/lib/obj/weapons/knives/.carving_knife.wep_virtual_.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/weapons/knives/.silver_sickle.wep_virtual_.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/weapons/knives/.silver_sickle.wep_virtual_.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627817   Available: 13575171
Inodes: Total: 5242880    Free: 4960133
1177 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/weapons/knives/.silver_sickle.wep_virtual_.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627817   Available: 13575171
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <virtual.h>

void dest_me() { destruct( this_object() ); }

void create()
{
  seteuid( (string)"/secure/master"->creator_file( file_name( this_object() ) ) );
} /* create() */

object create_virtual_ob() {
   object clone;

  clone = (object)SERVER->create_virtual_object( "/obj/weapon.c", 1 );
  clone->add_property( VIRTUAL_NAME_PROP, "/obj/weapons/knives/silver_sickle.wep#1" );
  call_other( clone, "set_name", "sickle"  );
  call_other( clone, "set_short", "silver sickle"  );
  call_other( clone, "add_adjective", "silver"  );
  call_other( clone, "set_long", "This is a dagger with a crescent shaped blade cast from silver.\n"  );
  call_other( clone, "set_weight", 9  );
  call_other( clone, "set_length", 12  );
  call_other( clone, "set_width", 8  );
  call_other( clone, "set_material",  "silver"  );
  call_other( clone, "set_value",  2000  );
  call_other( clone, "new_weapon", 12800  );
  call_other( clone, "set_damage_chance", 5  );
  call_other( clone, "add_attack",  "slash", 75, ({ 10, 5, 15 }), "sharp", "sharp"  );
  call_other( clone, "add_attack",  "stab", 50, ({ 10, 2, 25 }), "pierce", "pierce" );
   return clone;
} /* create_virtual_ob() */
// --- END [/mnt/home2/grok/lib/obj/weapons/knives/.silver_sickle.wep_virtual_.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/weapons/knives/.knife.wep_virtual_.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/weapons/knives/.knife.wep_virtual_.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627817   Available: 13575171
Inodes: Total: 5242880    Free: 4960133
1305 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/weapons/knives/.knife.wep_virtual_.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627817   Available: 13575171
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <virtual.h>

void dest_me() { destruct( this_object() ); }

void create()
{
  seteuid( (string)"/secure/master"->creator_file( file_name( this_object() ) ) );
} /* create() */

object create_virtual_ob() {
   object clone;

  clone = (object)SERVER->create_virtual_object( "/obj/weapon.c", 1 );
  clone->add_property( VIRTUAL_NAME_PROP, "/obj/weapons/knives/knife.wep#1" );
  call_other( clone, "set_name", "knife"  );
  call_other( clone, "set_short", "knife"  );
  call_other( clone, "add_adjective", ({ "medium-sized", "medium" })  );
  call_other( clone, "set_main_plural", "knives"  );
  call_other( clone, "set_long", "This is a medium-sized knife, the sort of thing someone might keep in a boot to ward off a would-be attacker.  You just have to hope that it's not then used to prepare your dinner.\n"  );
  call_other( clone, "set_weight", 8  );
  call_other( clone, "set_length", 7  );
  call_other( clone, "set_width", 2  );
  call_other( clone, "set_material",  "steel"  );
  call_other( clone, "set_value", 100  );
  call_other( clone, "new_weapon", 9000  );
  call_other( clone, "add_attack",  "slash", 70, ({ 10, 3, 20 }), "sharp", "sharp", 0  );
  call_other( clone, "add_attack",  "stab", 40, ({ 15, 3, 30 }), "pierce", "pierce", 0 );
   return clone;
} /* create_virtual_ob() */
// --- END [/mnt/home2/grok/lib/obj/weapons/knives/.knife.wep_virtual_.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/food.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/food.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627816   Available: 13575170
Inodes: Total: 5242880    Free: 4960133
59626 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/food.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627816   Available: 13575170
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Id: food.c,v 1.51 2003/03/03 06:33:01 terano Exp tilly $
 */
/**
 * <BR>
 * This is the main inheritable for food objects.  It allows you to
 * create food and drink.  Virtual files may also be coded if given
 * the *.food extention.  There are many examples of these virtual
 * food files in the /obj/food directory.  Food does the following
 * things.
 * <BR><BR>
 *   - It can be eaten or drunk.
 * <BR>
 *   - Food can be changed from solid to liquid with set_liquid(),
 * and changed from liquid to solid with reset_liquid().
 * <BR>
 *   - The weight of each bite can be set with set_weight_per_bite().
 * <BR>
 *   - Effects can be added to the player when they are splashed with the food,
 * get food rubbed on them, or get food applied to them with
 * add_external_effect.
 * <BR>
 *   - Splashing, applying, and rubbing can be pk-checked with
 * set_external_pk_check()
 * <BR>
 *   - Splashing can be activated with set_splashable()
 * <BR>
 *   - Splashing can be deactivated with unset_splashable()
 * <BR>
 *   - Applying can be activated with set_applicable()
 * <BR>
 *   - Applying can be deactivated with unset_applicable()
 * <BR>
 *   - Effects can be added to the player when they consume the food
 * with add_eat_effect().
 * <BR>
 *   - Functions can be added to be carried out when the food is
 * consumed with add_eat_func().  This function can be stored
 * on another object if the set_eat_object() is used.
 * <BR>
 *   - An eat message can be set with set_eat_mess().
 * <BR>
 *   - Food can be cut up into pieces with sharp weapons.
 * <BR>
 *   - The description of the new 'pieces' can be set using
 * set_piece_description(), set_piece_short(), set_piece_plural(),
 * and set_piece_substance().
 * <BR>
 *   - Non-liquid food decays and will eventually crumble to dust.
 * <BR>
 *   - The decay speed can be set with set_decay_speed().
 * <BR>
 *   - Food can be 'pickled' to prevent decay using do_cure().
 */

#include <bits_controller.h>
#include <drinks.h>
#include <weapon.h>
#include <move_failures.h>
#include <playtesters.h>

inherit "/obj/cont_medium";
inherit "/std/basic/virtual_update";

#define DEFAULT_DECAY 7200      // Two hours for something to decay.
#define STATE_CHANGE ("/obj/handlers/state_change")

private int _liquid;
private int _dried, _cured;
private int _bites_gone;
private int _weight_per_bite;
private int _in_pieces;
private int _decay_level;
private int _decay_speed;
private int _splashable;
private int _applicable;
private int _external_pk_check;

private float _divisor = to_float(DEFAULT_DECAY) / to_float(6 * TIME_OUT);
// TIME_OUT is defined in /include/bits_controller.h

private mixed _eat_mess;

private string _eat_object;
private string _eat_func;
private string _piece_desc;
private string _piece_short;
private string _piece_plural;
private string _piece_substance;

/* These have been changed from string to mixed as they can either be 
 * a standard string or an array of strings.  
 */ 
private mixed _eat_piece_mess;
private mixed _eat_amt_mess;
private mixed _eat_last_mess;

private mapping _eat_effects = ([ ]);
private mapping _external_effects = ([ ]);


varargs int do_cut(int num);
varargs int do_eat(int no_mess);

int do_mince();
void set_decay_speed(int decay);
int check_for_container();

void create()
{
   do_setup++;
   ::create();
   do_setup--;
   reset_continuous();
   _eat_effects = ([ ]);
   set_decay_speed(DEFAULT_DECAY);
   add_help_file("food");
   if (!do_setup) {
      this_object()->setup();
   }
}                               /* create() */


/**
 * This function returns one if the food is a liquid.
 *
 * @return Return 1 if the food is a liquid, and return 0 if it is not.
 */
int query_liquid()
{
   return _liquid;
}                               /* query_liquid() */

/**
 * This tells us if the food is edible (ie. can be
 * consumed using 'eat' instead of 'drink'.  If it is
 * edible then it is not a liquid.
 *
 * @return Return 1 if the food is a liquid, and return 0 if it is not.
 *
 * @see set_liquid()
 * @see query_liquid()
 */
int query_edible()
{
   return !_liquid;
}                               /* query_edible() */

/**
 * This changes the food object into a liquid.  Liquids are
 * automatically a 'continuous' medium, which means it will
 * combine with other liquids of the same type.
 * <p>
 * This will automatically set the decay speed to 0.  Liquids
 * do not decay.
 *
 * @see reset_liquid()
 * @see set_decay_speed()
 * @see /obj/cont_medium->set_continuous()
 */
void set_liquid()
{
   set_continuous();
   _liquid = 1;
   if (environment()) {
      environment()->calc_liquid();
   }
   set_decay_speed(0);
}                               /* set_liquid() */

/**
 * This changes the food object into a solid.  Solids are not
 * 'continuous' and the decay speed will be set back to the
 * default.
 *
 * @see set_liquid()
 * @see set_decay_speed()
 */
void reset_liquid()
{
   reset_continuous();
   _liquid = 0;
   if (environment())
      environment()->calc_liquid();
   set_decay_speed(DEFAULT_DECAY);
   _divisor = to_float(DEFAULT_DECAY) / to_float(6 * TIME_OUT);
}                               /* reset_liquid() */

/**
 * This method returns 1 if the item is a food object.
 * @return 1 when it is a food object
 */
int query_food_object()
{
   return 1;
}                               /* query_food_object() */

/**
 * @ignore yes
 */
void init()
{
   if (query_continuous()) {
      add_command("rub", "<direct:object> <preposition> <indirect:living>");
      add_command("apply", "<direct:object> <preposition> <indirect:living>");
   }
   if (_liquid) {
      add_command("drink", "<direct:object>");
      add_command("quaff", "<direct:object>");
      add_command("splash",
                  "<direct:object> <preposition> <indirect:living>");
   } else {
      add_command("eat", "<direct:object>", (: do_eat(0) :));
      add_command("cut",
                  "<direct:object> into <number'number, eg: 3'> pieces",
                  (: do_cut($4[1]) :));
      add_command("cut", "<direct:object>", (: do_cut() :));
      add_command("slice", "<direct:object>", (: do_cut() :));
      add_command("mince", "<direct:object>", (: do_mince() :));
   }
}                               /* init() */

/**
 * This query tells us whether the food decays.  All objects
 * which decay should have this function on them.
 *
 * @return Return 1 if the object decays.
 * @see set_decay_speed()
 */
int query_decays()
{
   return _decay_speed != 0;
}                               /* query_decays() */

/**
 * This returns the number of bites that have been taken out
 * of the food object.
 *
 * @return The number of bites which have been taken from
 * the object.
 * @see set_bites_gone()
 * @see set_weight_per_bite()
 */
int query_bites_gone()
{
   return _bites_gone;
}                               /* query_bits_gone() */

/**
 * This sets the weight of each bite of the food object.
 * This is used along with the total weight of the object
 * to calculate how many bites of the food can be taken.
 *
 * @see /std/basic/misc->set_weight()
 * @see set_weight_per_bite()
 * @see weight
 * @return The weight of each bite.
 */
int query_weight_per_bite()
{
   return _weight_per_bite;
}                               /* query_weight_per_bite() */

/**
 * This returns the eat object on which the eat function
 * of the food of the food is stored.
 *
 * @see set_eat_object()
 * @see set_eat_func()
 * @see set_eat_mess()
 * @return A string which is the the name of the eat object.
 */
string query_eat_object()
{
   return _eat_object;
}                               /* query_eat_object() */

/**
 * This returns the name of the eat function to carry out
 * when the object is eaten.
 *
 * @see set_eat_object()
 * @see set_eat_func()
 * @see set_eat_mess()
 * @return A string which is the name of the eat function.
 */
string query_eat_func()
{
   return _eat_func;
}                               /* query_eat_func() */

/**
 * This returns the eat message of the object.
 *
 * @see set_eat_object()
 * @see set_eat_func()
 * @see set_eat_mess()
 * @return A string of text which is the eat message.
 */
string query_eat_mess()
{
   return _eat_mess;
}                               /* query_eat_mess() */

/**
 * This returns the long description of the food object when
 * it is cut up into pieces.
 *
 * @see set_piece_description()
 * @see query_in_pieces()
 * @return A string of text which is the piece description.
 */
string query_piece_description()
{
   return _piece_desc;
}                               /* query_piece_description() */

/**
 * If the food has been cut up (using the 'cut' command)
 * then this will return true.
 *
 * @see do_cut()
 * @return Return 1 if it is in pieces, and return 0 otherwise.
 */
int query_in_pieces()
{
   return _in_pieces;
}                               /* query_in_pieces() */

/**
 * This returns the decay speed.  If this is 0 then the object
 * is not decaying.  This is the length of time it takes
 * for the whole object to decay.
 *
 * @see set_decay_speed()
 * @return The decay speed.
 */
int query_decay_speed()
{
   return _decay_speed;
}                               /* query_decay_speed() */

/**
 * This returns the level of the decay.  This will be a number
 * between 1 and 6.
 *
 * @see set_decay_speed()
 * @return The level of decay, which is between 1 and 6.
 */
int query_decay_level() {
   return _decay_level;
}                               /* query_decay_level() */

/**
 * This sets the number of bites gone.  This helps determine
 * the total weight of the object.
 *
 * @see set_weight_per_bite()
 * @param number The number of bites gone.
 */
void set_bites_gone(int number)
{
   _bites_gone = number;
}                               /* set_bites_gone() */

/**
 * This sets weight of each bite of the food object.  This is
 * used along with the total weight of the object to calculate
 * how many bites of the food can be taken.
 *
 * @see /std/basic/misc->set_weight()
 * @see weight
 * @param number The weight each bite should be.
 */
void set_weight_per_bite(int number)
{
   _weight_per_bite = number;
}                               /* set_weight_per_bite() */

/**
 * This sets the object on which the eat function is stored.
 * <p>
 * If the eat object is set, then the eat function needs to
 * be set as well.  If the function is not set then setting
 * the object has no effect.
 * <p>
 * The function will be called with two parameters, the first
 * being the object being eaten and the second being the
 * person eating the object.
 *
 * @see set_eat_object()
 * @see set_eat_mess()
 * @param word The object containing the eat function.
 * @example
 * void create_food() {
 *   object food;
 *   food = clone_object("/obj/food/apple.food");
 *   food->set_eat_object(this_object());
 *   food->set_eat_func("eat_apple");
 * } /\* create_food() *\/
 *
 * void eat_apple(object food, object eater) {
 *   /\* Do something wonderful! *\/
 * } /\* eat_rabbit() *\/
 */
void set_eat_object(string word)
{
   _eat_object = word;
}                               /* set_eat_object() */

/**
 * This sets the eat function of the food.  This is called when
 * the food is eaten.
 * <p>
 * If the eat object is set, then the eat function needs to be
 * set as well. If the function is not set then setting the
 * object has no effect.
 * <p>
 * The function will be called with two parameters, the first being the
 * object being eaten and the second being the person eating the object.
 *
 * @see set_eat_object()
 * @see set_eat_mess()
 * @param word The function to set as the eat function.
 * @example
 * See the example for set_eat_object()
 */
void set_eat_func(string word)
{
   _eat_func = word;
}                               /* set_eat_func() */

/**
 * This sets the eat function of the food.  The function is
 * carried out when the food is consumed.  The eat message,
 * set with set_eat_mess(), is displayed when this function
 * is carried out.
 * <p>
 * The eat mess should be treated exactly the same as a
 * add_succeeded_mess(), as it is processed later as
 * add_succeeded_mess(eat_mess, ({ }));
 *
 * @see set_eat_object()
 * @see set_eat_func()
 * @see /global/new_parse->add_succeeded_mess()
 * @param word The string or array to be used as
 * the add_succeeded_mess() when eating the food.
 */
void set_eat_mess(mixed word)
{
   _eat_mess = word;
}                               /* set_eat_mess() */

/**
 * This sets up the eat messages for pieces and stuff.  The amount message
 * will replace the $amt$ string in the message with the amount_string().  
 * @param piece the eat piece message. This can be either a string or an
 * array, it is passed to add_succeeded_mess().
 * @param amt the amount messages
 * @param last the message to print out when the last bit gets eaten
 */
void setup_eat_piece_messages(mixed piece,
                              mixed amt,
                              mixed last) {
   _eat_piece_mess = piece;
   _eat_amt_mess = amt;
   _eat_last_mess = last;
}                               /* setup_eat_piece_message() */

/**
 * This sets the long description of the food when it is has
 * 'cut' into pieces.
 * <p>
 * If this is set then the short of the object is changed
 * to 'piece of cake'.  If the piece description is not
 * set the short description of the object is not changed.
 *
 * @param word The long description to use when cut into pieces.
 * @see query_in_pieces()
 * @see set_piece_short()
 * @see set_piece_plural()
 * @see set_piece_substance()
 * @example
 * set_piece_description("The brown, soft, moist cake looks "
 *   "totally wonderful.\n");
 */
void set_piece_description(string word) {
   _piece_desc = word;
}                               /* set_piece_description() */

/**
 * This is the description used in the short for the pieces.
 * When the object is cut up this is used as part of the
 * short description.  For example, it can change
 * 'piece of cake' to 'slice of cake', 'piece of chocolate'
 * to 'square of chocolate', and so on.  If this the piece
 * short has not been set it is set to the default which is
 * simply "piece".
 *
 * @param word The short to use for the 'piece' when cut into
 * pieces.
 * @see query_in_pieces()
 * @see set_piece_description()
 * @see set_piece_plural()
 * @see set_piece_substance()
 * @example
 * set_piece_short("slice");
 */
void set_piece_short(string short) {
   _piece_short = short;
}                               /* set_piece_short() */

/**
 * This plural description used for the pieces.  It is only
 * really of use if the piece short pluralises in an unusual
 * manner.  If it is not set the piece plural is set to what
 * the pice short has been set to with an "s" stuck on the
 * end, for example, slice to slices.
 *
 * @param word The plural used for the 'pieces' when cut into
 * pieces.
 * @see query_in_pieces()
 * @see set_piece_description()
 * @see set_piece_short()
 * @see set_piece_substance()
 * @example
 * set_piece_plural("slices");
 */
void set_piece_plural(string plural) {
   _piece_plural = plural;
}                               /* set_piece_plural() */

/**
 * This sets a new description for what there are pieces of.
 * For example, if you want the short of the food before it
 * is cut up to be 'bar of chocolate', without the piece
 * substance being set, when it is cut up it will become
 * 'a piece of bar of chocolate'.  If you set this in enables
 * you to change that unwieldly description to 'a piece of
 * chocolate'.
 *
 * @param word The description of what the 'piece' is of.
 * @see query_in_pieces()
 * @see set_piece_description()
 * @see set_piece_short()
 * @see set_piece_plural()
 * @example
 * set_piece_substance("goat cheese");
 */
void set_piece_substance(string substance) {
   _piece_substance = substance;
}                               /* set_piece_substance() */

/**
 * This sets the in_pieces flag.  This allows you to make the
 * food seem as though it has already been cut into pieces.
 *
 * @param number The number of pieces.
 * @see query_in_pieces()
 * @see set_piece_description()
 * @see set_piece_short()
 * @see set_piece_plural()
 * @see set_piece_substance()
 */
void set_in_pieces(int number) {
   int p;
   _in_pieces = p;
}                               /* set_in_pieces() */

/**
 * This sets the decay level.  This should be anumber
 * between 1 and 6.  It lets you make a food object seem
 * as though it is already decaying.
 *
 * @see query_decay_level()
 * @see set_decay_speed()
 * @param level The new decay level.
 */
void set_decay_level(int level) {
   _decay_level = level;
}                               /* set_decay_level() */

/**
 * This sets the speed at which a food object decays.  The
 * speed is set in seconds and is the total amount of time
 * before the food decays.
 * <p>
 * If the decay speed is set to 0, then the object will never decay.
 *
 * @param speed The speed at which the object will decays.
 * @see set_decay_level()
 * @see query_decay_speed()
 * @example
 * /\* This will make the object decay totaly in 30 minutes *\/
 * set_decay_speed(1800);
 *
 * /\* This will stop the object from ever decsaying *\/
 * set_decay_speed(0);
 */
void set_decay_speed(int decay) {
   float tmp;

   if(decay != _decay_speed && !_dried && !_cured) {
      BITS_CONTROLLER->remove_bit(this_object());
      _decay_speed = decay;
      if (decay && !_dried && !_cured) {
         tmp = _divisor;
         _divisor = to_float(decay) / to_float(6 * TIME_OUT);
         _decay_level = to_int(_decay_level * _divisor / tmp);
         BITS_CONTROLLER->add_bit(this_object());
      }
   }
}                               /* set_decay_speed() */

/**
 * @ignore yes
 * This is called by the bits controller.
 */
void do_decay() {
  if(_dried || _cured) {
    BITS_CONTROLLER->remove_bit(this_object());
    return;
  }

  if ( environment() && environment()->query_property( "no decay" ) )
    return;

  _decay_level++;

  if (_decay_level > (2 * _divisor) -1 ) {
    remove_adjective( "fresh" );
  }

  if (_decay_level > 6 * _divisor) {
    tell_room(environment(this_object()),
              capitalize(the_short()) + " crumbles to dust.\n");
    move("/room/rubbish");
  }
}

/**
 * @ignore yes
 */
int query_weight() {
  if (query_liquid())
    return 0;

  return ::query_weight() - _bites_gone * _weight_per_bite;
}

/** 
 * This method returns the current rotten adjective that's used 
 * in the short description for decaying objects.
 * @return a string like slightly rotten, mostly rotten, etc.
 */ 
string query_short_rotten_adjective() {
    string ret;

    ret = "";

    switch (to_int(_decay_level / _divisor)) {
    case 2:
      ret = "slightly rotten ";
      break;
    case 3:
      ret = "half rotten ";
      break;
    case 4:
      ret = "mostly rotten "; 
      break;
    case 5:
      ret = "almost rotten ";
      break;
    case 6:
      ret = "rotten ";
      break;
    }

    return ret; 
} /* query_short_rotten_adjective() */

/**
 * @ignore yes
 */
string short(int dark) {
  string ret;

  ret = ::short(dark);

  if (_decay_speed) {
     ret = query_short_rotten_adjective() + ret; 
  }
  return ret;
  
}

/** 
 * This method returns how much of the item has been nibbled on. 
 * @return a string used in long().
 */ 
string query_long_eat_level() { 
   int twelfths;
   string ret; 

    twelfths = (_bites_gone * _weight_per_bite * 12) / ::query_weight();

    switch (twelfths) {
        case 0..1:
            ret = "It has just been nibbled on.\n";
        break;
        
        case 2:
            ret = "It is about one sixth gone.\n";
        break;
        
        case 3:
            ret = "It is about one quarter gone.\n";
        break;
        
        case 4:
            ret = "It is about one third gone.\n";
        break;
        
        case 5:
            ret = "It is just under half gone.\n";
        break;
        
        case 6:
            ret = "It is about half gone.\n";
        break;
        
        case 7:
            ret = "It is just over half gone.\n";
        break;
        
        case 8:
            ret = "It is about two thirds gone.\n";
        break;
        
        case 9:
            ret = "It is about three quarters gone.\n";
        break;
        
        case 10:
            ret = "It is about five sixths gone.\n";
        break;

        case 11:   
            ret = "It is almost all gone.\n";
        break;

        default:
            ret = "Schroedinger's cat has been at it.\n";
        break;
    }

    return ret; 
} /* query_eat_decay_level() */ 

/** 
 * This method returns the decay level for the object as a string, 
 * it is used in the long() function.
 */ 
string query_long_decay_level() {
    string ret;

    ret = "";

    switch (to_int(_decay_level / _divisor)) {
    case 0..1:
      if(query_collective() && query_amount() > 1)
        ret += "They look nice and fresh.\n";
      else
       ret += "It looks nice and fresh.\n";
      break;
    case 2:
      if(query_collective() && query_amount() > 1)
        ret += "They look a bit rotten.\n";
      else
        ret += "It looks a bit rotten.\n";
      break;
    case 3:
      if(query_collective() && query_amount() > 1)
        ret += "They are half rotten.\n";
      else
        ret += "It is half rotten.\n";
      break;
    case 4:
      if(query_collective() && query_amount() > 1)
        ret += "They are mostly rotten.\n";
      else
        ret += "It is mostly rotten.\n";
      break;
    case 5:
      if(query_collective() && query_amount() > 1)
        ret += "They are almost completely rotten.\n";
      else
        ret += "It is almost completely rotten.\n";
       break;
    case 6:
      if(query_collective() && query_amount() > 1)
        ret += "They are completely rotten.\n";
      else
        ret += "It is completely rotten.\n";
      break;
    }

    return ret; 
} /* query_long_decay_level() */


/**
 * @ignore yes
 */
string long(string words, int dark) {
   string ret;

   ret =::long(words, dark);

   if (_liquid) {
      return ret;
   }
   if (_weight_per_bite && _bites_gone) {
       ret += query_long_eat_level(); 
   }
   if (_decay_speed) {
       ret += query_long_decay_level(); 
   } 
   else {
       if(_dried) {
           if(query_collective() && query_amount() > 1) {
              ret += "They are all dry and shrivelled up.\n";
           }
           else {
              ret += "It is all dry and shrivelled up.\n";
           }
        } 
        else { 
            if(_cured) {
                if(query_collective() && query_amount() > 1) { 
                    ret += "They seem to have been pickled.\n";
                }
                else {
                    ret += "It seems to have been pickled.\n";
                }
            }
        }
   }
   return ret;
}

/**
 * This sets up the eat object and function.  This is used when
 * the food is eaten.  The eat function is called on the eat
 * object.  If successful the eat message is added to the player.
 *
 * @see set_eat_object()
 * @see set_eat_func()
 * @param ob The object to use.
 * @param func The function to use.
 */
void setup_eat(string ob, string func) {
   _eat_object = ob;
   _eat_func = func;
}                               /* setup_eat() */

/**
 * The eat effects of the food.  The mapping contains a set of
 * strings (the effect) and a number associated with the
 * effect.
 *
 * @see add_eat_effect()
 * @return A mapping containing the eat effects.
 */
mapping query_eat_effects() {
   if (undefinedp(_eat_effects)) {
      _eat_effects = ([ ]);
   }
   return copy( _eat_effects );
}                               /* query_eat_effects() */

/**
 * This sets all the eat effects.  This function should NOT
 * be used.  Please use add_eat_effect.
 *
 * @param map The eat effects mapping.
 */
void set_eat_effects(mapping map) {
   if (mapp(map)) {
      _eat_effects = map;
   }
}                               /* set_eat_effects() */

/**
 * This adds an eat effect to the food.  This will be added to
 * the player or NPC when the food is eaten.
 * <p>
 * The effect is added with a number as the argument.  The number
 * is based on the amount which is eaten (in weight units), and
 * usually represents the strength of the effect.
 * If the object is continuous, the weight is calculated from
 * the amount and weight_unit array...
 * <p>
 * <br>
 * <code>
 * eff_num = (amount * number * weight_unit[0]) / weight_unit[1]
 * </code>
 * <p>
 * ...where the number is passed into the add_eat_effect() function.
 * If the effect already exists, then the number is added onto
 * the existing number.
 *
 * @see /obj/cont_medium->set_weight_unit()
 * @see remove_eat_effect()
 * @param word The file name of the effect to add.
 * @param number The number to set to the effect to.
 * @return The current value of the effect in the mapping
 */
int add_eat_effect(mixed word,
                   int number)
{
   if (undefinedp(_eat_effects)) {
      _eat_effects = ([ ]);
   }

   if (mapp(word)) {
      int num;
      string name;

      foreach(name, number in word) {
         num += add_eat_effect(name, number);
      }
      return num;
   }

   if (_eat_effects[word]) {
      _eat_effects[word] += number;
   } else {
      _eat_effects[word] = number;
   }
   return _eat_effects[word];
}                               /* add_eat_effect() */

/**
 * This removes the eat effect of the given name.
 *
 * @param word The name of the effect to delete.
 * @see add_eat_effect()
 */
void remove_eat_effect(string word)
{
   if (!undefinedp(_eat_effects[word])) {
      _eat_effects = m_delete(_eat_effects, word);
   }
}                               /* remove_eat_effect() */

/**
 * This makes the external effects pk checked.
 * @see add_external_effect(), set_applicable(), set_splashable()
 * @see unset_external_pk_check()
 */
void set_external_pk_check()
{
   _external_pk_check = 1;
}

/**
 * This makes the external effects not pk checked.
 * @see add_external_effect(), set_applicable(), set_splashable()
 * @see set_external_pk_check()
 */
void unset_external_pk_check()
{
   _external_pk_check = 0;
}


/**
 * The external (splash,apply,rub) effects of the food.  The
 * mapping contains a set of strings (the effect) and a number
 * associated with the effect.
 *
 * @see set_splashable(), set_applicable()
 * @return A mapping containing the external effects.
 */
mapping query_external_effects()
{
   if (undefinedp(_external_effects))
      _external_effects = ([ ]);
   return _external_effects + ([ ]);
}                               /* query_external_effects() */

/**
 * This sets all the external effects.  This function should NOT
 * be used.  Please use add_external_effect.
 *
 * @param map The external effects mapping.
 */
void set_external_effects(mapping map)
{
   _external_effects = map;
}                               /* set_splash_effects() */

/**
 * This adds an external effect to the food.  This will be added to
 * the player or NPC when the liquid is splashed, applied, or rubbed on them.
 * <p>
 * The effect is added with a number as the argument.  The number
 * is based on the amount which is splashed (in weight units), and
 * usually represents the strength of the effect.
 * If the object is continuous, the weight is calculated from
 * the amount and weight_unit array...
 * <p>
 * <br>
 * <code>
 * eff_num = (amount * number * weight_unit[0]) / weight_unit[1]
 * </code>
 * <p>
 * ...where the number is passed into the add_external_effect() function.
 * If the effect already exists, then the number is added onto
 * the existing number.
 *
 * @see /obj/cont_medium->set_weight_unit()
 * @see set_splashable()
 * @see unset_splashable()
 * @see set_applicable()
 * @see unset_applicable
 * @see remove_external_effect()
 * @see set_external_pk_check()
 * @param word The file name of the effect to add.
 * @param number The number to set to the effect to.
 * @return The current value of the effect in the mapping
 */
int add_external_effect(string word,
                        int number)
{
   if (undefinedp(_external_effects))
      _external_effects = ([ ]);
   if (_external_effects[word])
      _external_effects[word] += number;
   else
      _external_effects[word] = number;
   return _external_effects[word];
}                               /* add_external_effect() */

/**
 * This removes the external effect of the given name.
 *
 * @param word The name of the effect to delete.
 * @see add_external_effect()
 */
void remove_external_effect(string word)
{
   if (!undefinedp(_external_effects[word])) {
      _external_effects = m_delete(_external_effects, word);
   }
}                               /* remove_external_effect() */

/**
 * This sets it so the food can be splashed.
 * Note that the food can only be splashed when liquid in any case.
 * Note this is NOT the default case.
 * @see unset_splashable(), set_applicable(), unset_applicable(),
 * add_external_effect()
 */
void set_splashable()
{
   _splashable = 1;
}

/**
 * This sets it so the food cannot be splashed.
 * Note that the food can only be splashed when liquid in any case.
 * @see set_splashable()
 */
void unset_splashable()
{
   _splashable = 0;
}

/**
 * This queries splashability of the food.
 * Note that the food can only be splashed when liquid and when
 * set_splashable() has been called
 * @param splasher - Who splashes.
 * @param splashee - Who is splashed.
 * @return 1 if it can splash, 0 if it can't
 * @see set_splashable(), unset_splashable(), set_liquid(),
 * set_external_pk_check()
 */
int query_splashable(object splasher,
                     object splashee)
{
   if (splasher == splashee || !_external_pk_check) {
      return (_splashable && _liquid);
   }
   return (_splashable && _liquid && !(pk_check(splasher, splashee)));
}



/**
 * This sets it so the food can be applied.
 * Note this is the default case.
 * @see unset_applicable()
 */
void set_applicable()
{
   _applicable = 1;
}

/**
 * This sets it so the food cannot be applied.
 * @see set_applicable()
 */
void unset_applicable()
{
   _applicable = 0;
}

/**
 * This queries applicability of the food. (rubbing on someone)
 * Note that the food can only be applied when
 * set_applicable() has been called
 * @param applier - Who applies it
 * @param appliee - Who it is applied to.
 * @return 1 if it can be applied, 0 if it can't
 * @see set_applicable(), unset_applicable(), set_external_pk_check()
 */
int query_applicable(object applier,
                     object appliee)
{
   if (applier == appliee || !_external_pk_check) {
      return _applicable;
   }
   return (_applicable && !(pk_check(applier, appliee)));
}




/**
 * @ignore yes
 */
void being_joined_by(object thing)
{
   int i,
     that,
     this;
   string *words;
   mapping new_effects;
   that = (int) thing->query_amount();
   this = query_amount();
   if (!(this + that))
      return;
   if (thing->query_splashable(0, 0) && !_splashable)
      set_splashable();
   if (thing->query_applicable(0, 0) && !_applicable)
      set_applicable();
   if (thing->query_external_pk_check() && !_external_pk_check)
      set_external_pk_check();
   new_effects = (mapping) thing->query_eat_effects();
   // If new_effects isn't a mapping, then there's something
   // wrong, so it should give an error so that someone knows
   // and can get it fixed.
   words = m_indices(_eat_effects);
   for (i = 0; i < sizeof(words); i++) {
      if (new_effects[words[i]]) {
         new_effects[words[i]] *= that;
         new_effects[words[i]] += this * _eat_effects[words[i]];
      } else {
         new_effects[words[i]] = this * _eat_effects[words[i]];
      }
   }
   words = m_indices(new_effects);
   for (i = 0; i < sizeof(words); i++) {
      new_effects[words[i]] /= this + that;
   }
   _eat_effects = new_effects;

   new_effects = (mapping) thing->query_external_effects();
   // If new_effects isn't a mapping, then there's something
   // wrong, so it should give an error so that someone knows
   // and can get it fixed.
   words = m_indices(_external_effects);
   for (i = 0; i < sizeof(words); i++) {
      if (_external_effects[words[i]]) {
         new_effects[words[i]] *= that;
         new_effects[words[i]] += this * _external_effects[words[i]];
      } else {
         new_effects[words[i]] = this * _external_effects[words[i]];
      }
   }
   words = m_indices(new_effects);
   for (i = 0; i < sizeof(words); i++) {
      new_effects[words[i]] /= this + that;
   }
   _external_effects = new_effects;

}                               /* being_joined_by() */

/**
 * This consumes some of the food.
 *
 * @param consumer The person doing the consumption.
 * @param amount The amount being consumed.
 * @param type Use "splash" or "apply" or "external" to use external
 *  effects, anything else for eat effects.
 *
 */
varargs void consume(object consumer, int amount, string type) {
  int i, denominator, numerator, wholes;
  string *words;
  
  switch (type) {
  case "splash":
  case "apply":
  case "external":
    words = m_indices(_external_effects);
    break;
  default:
    words = m_indices(_eat_effects);
    break;
  }
  if (!amount && query_continuous()) {
    amount = query_amount();
  }
  if (amount) {
    // Make sure we don't take more of it than there is.
    if (query_continuous() && (amount > query_amount()))
      amount = query_amount();
    numerator = amount * query_weight_unit()[0];
    denominator = query_weight_unit()[1];
    if (type != "apply" && type != "splash" && type != "external") {
      if (_liquid) {
        consumer->adjust_volume(D_DRINK, (50 * numerator) / denominator);
      } else {
        consumer->adjust_volume(D_FOOD, (50 * numerator) / denominator);
      }
    }
    if (!this_object()->query_property("playtester") ||
        PLAYTESTER_HAND->query_playtester(consumer->query_name()) ||
        consumer->query_creator()) {
      for (i = 0; i < sizeof(words); i++) {
        switch (type) {
        case "splash":
        case "apply":
        case "external":
          numerator = _external_effects[words[i]] * amount *
            query_weight_unit()[0];
          break;
        default:
          numerator = _eat_effects[words[i]] * amount *
            query_weight_unit()[0];
          break;
        }
        wholes = numerator / denominator;
        numerator %= denominator;
        if (random(denominator) < numerator) {
          wholes++;
        }
        consumer->add_effect(words[i], wholes);
      }
    }
    adjust_amount(-amount);
  } else {
    if (_weight_per_bite) {
      _bites_gone++;
      if (type != "apply" && type != "splash" && type != "external") {
        consumer->adjust_volume(D_FOOD, 50 * _weight_per_bite);
      }
      if (!this_object()->query_property("playtester") ||
          PLAYTESTER_HAND->query_playtester(consumer->query_name()) ||
          consumer->query_creator()) {
        for (i = 0; i < sizeof(words); i++) {
          switch (type) {
          case "splash":
          case "apply":
          case "external":
            this_player()->add_effect(words[i],
                                      _external_effects[words[i]] *
                                      _weight_per_bite);
            break;
          default:
            this_player()->add_effect(words[i], _eat_effects[words[i]] *
                                      _weight_per_bite);
            break;
          }
        }
      }
    } else {
      consumer->adjust_volume(D_FOOD, 50 * weight);
      if (!this_object()->query_property("playtester") ||
          PLAYTESTER_HAND->query_playtester(consumer->query_name()) ||
          consumer->query_creator()) {
        for (i = 0; i < sizeof(words); i++) {
          switch (type) {
          case "apply":
          case "splash":
          case "external":
            consumer->add_effect(words[i],
                                 _external_effects[words[i]] * weight);
            break;
          default:
            consumer->add_effect(words[i],
                                 _eat_effects[words[i]] * weight);
            break;
          }
        }
      }
    }
  }
  if (type != "apply" && type != "splash" && type != "external") {
    if (_eat_func) {
      if (_eat_object) {
        call_other(_eat_object, _eat_func, this_object(), consumer);
      } else {
        call_other(this_object(), _eat_func, this_object(), consumer);
      }
    }
  }
}

/**
 * This is the eat command call.  This is setup with add_command()
 * and does the actual eating.
 * @param no_mess don't use success messages
 * @return Return 1 on success, 2 on success + last bit eaten and return 0 on failure.
 * @see /global/new_parse->add_command()
 * @see /global/new_parse->add_succeeded_mess()
 * @see set_eat_mess()
 */
varargs int do_eat(int no_mess) {
   int ret;

   
   if ((weight <= 0) && !query_continuous()) {
      if (_eat_mess && !no_mess) {
         add_succeeded_mess(_eat_mess, ({ }));
      }
      move("/room/rubbish");
      return 1;
   }
   if ((weight <= (_bites_gone + 1) * _weight_per_bite) || !_weight_per_bite) {
      if (!no_mess) {
         if (!query_continuous()) {
            if (_weight_per_bite) {
               if (_eat_last_mess) {
                  add_succeeded_mess(_eat_last_mess, ({ }));
               } else {
                  add_succeeded_mess("$N $V the last of $D.\n", ({ }));
               }
            } else if (_eat_mess) {
               // This only gets done if the whole thing is eaten.
               add_succeeded_mess(_eat_mess, ({ }));
            }
         } else {
            if (_eat_amt_mess) {
               add_succeeded_mess(replace_string(_eat_amt_mess, "$amt$",
                                                 amount_size() ), ({ }));
            } else {
               add_succeeded_mess("$N $V " + amount_size() + " of $D.\n",
                                  ({ }));
            }
         }
      }
      ret = 2;
      move("/room/rubbish");
   } else {
      if (!no_mess) {
         if (_eat_piece_mess) {
            add_succeeded_mess(_eat_piece_mess, ({ }));
         } else {
            add_succeeded_mess("$N $V a piece of $D.\n", ({ }));
         }
      }
      ret = 1;
   }
   consume(this_player(), 0);
   return ret;
}                               /* do_eat() */

/**
 * This checks to see if a weapon is sharp.  This is used later
 * to determine whather an object can be cut up with the weapon.
 *
 * @param weapon The weapon to check to see if it is sharp.
 * @return Return 1 if it is sharp, or 0 otherwise.
 */
int check_sharp(object weapon)
{
   mixed *data;
   int i;
   if (!weapon) {
      return 0;
   }
   data = weapon->query_attack_data();
   for (i = W_TYPE; i < sizeof(data); i += W_ARRAY_SIZE) {
      if (data[i] == "sharp") {
         return 1;
      }
   }
   return 0;
}                               /* check_sharp() */

/**
 * This cuts the food up into bits.  This is the command called
 * with add_command() and does the actual cutting up into bits.  If
 * the num_pieces parameter is undefined, the food is cut in half.
 * If the food is continuous, the cutting is handled by
 * the state_change handler (all continuous objects must be cut this
 * way).
 *
 * @see set_piece_description()
 * @see query_in_pieces()
 * @see query_piece_short()
 * @see query_piece_plural()
 * @see query_piece_substance()
 * @param num_pieces The number of pieces to cut the food into.
 * @return 1 if it succeeded, 0 if not.
 */
varargs int do_cut(int num_pieces) {
  object bing, *obs, with;
  string name, *exploded_short;
  int i, j, k, size_of_each, gone;
  int portion_of_whole;
  int portion_of_parent;
  string temp_short, temp_plural;
  mixed rabbit;
  
  if (query_liquid()) {
    add_failed_mess("You cannot $V $D.\n");
    return -1;
  }

  // First, check to see if they have a sharp weapon.
  obs = this_player()->query_holding();
  for (i = 0; i < sizeof(obs); i++) {
    if (check_sharp(obs[i])) {
      if (!with || (with && with->query_weight() > obs[i]->query_weight())) {
        with = obs[i];
      }
    }
  }

  if (!with) {
    add_failed_mess("You have to be holding a sharp object to $V $D.\n");
    return -1;
  }

  if (undefinedp(num_pieces))
    num_pieces = 2;
  
  if (query_continuous())
    return (do_mince());
  
  if (num_pieces <= 1 || !_weight_per_bite) {
    add_failed_mess("$D cannot be cut up.\n");
    return -1;
  } else if (num_pieces >
             ((query_weight() / _weight_per_bite) - _bites_gone)) {
    
    if (num_pieces == 2 || ((query_weight() / _weight_per_bite) -
                            _bites_gone) < 2) {
      add_failed_mess("$D cannot be cut up.\n");
    } else
      add_failed_mess("You can't $V $D into that many pieces.\n");
    return -1;
  }

  // Now, do the cutting.
  name = file_name(this_object());
  sscanf(name, "%s#%*d", name);
  size_of_each = (query_weight() - _weight_per_bite * _bites_gone) /
    num_pieces;
  gone = (::query_weight() - size_of_each) / _weight_per_bite;
  for (i = 0; i < num_pieces; i++) {
    // Duplicate ourselves.
    bing = clone_object(name);
    bing->init_static_arg(query_static_auto_load());
    bing->init_dynamic_arg(query_dynamic_auto_load());
    bing->set_weight(size_of_each);
    bing->set_value(0);
    
    bing->add_property("whole:weight", query_property("whole:weight")
                       || query_weight());
    bing->add_property("whole:short", query_property("whole:short")
                       || this_player()->convert_message(a_short()));
    
    portion_of_whole = bing->query_property("whole:weight") / size_of_each;
    
    portion_of_parent = query_weight() / size_of_each;
    
    if (!_in_pieces) {        // is _in_pieces *ever* not 0??
      
      if (_piece_desc) {
        bing->set_long(_piece_desc);
        if (!_in_pieces) {  //  redundant check?
          if (!_piece_short) {
            if (portion_of_whole == 1)
              temp_short = "piece";
            else if (portion_of_whole == 2)
              temp_short = "half";
            else if (portion_of_whole == 4)
              temp_short = "quarter";
            else
              temp_short = word_ordinal(portion_of_whole);
          }
          
          if (!_piece_plural) {
            if (_piece_short)
              _piece_plural = _piece_short + "s";
            else {
              if (temp_short == "half")
                temp_plural = "halves";
              else
                temp_plural = temp_short + "s";
            }
          }
          
          if (_piece_substance)
            rabbit = _piece_substance;
          else
            rabbit = bing->query_property("whole:short");
          bing->set_short((_piece_short || temp_short) +
                          " of " + rabbit);
          bing->set_main_plural((_piece_plural || temp_plural) +
                                " of " + rabbit);
        }
      }
    } else {     // Is this ever evaluated?  _in_pieces is always 0!
      bing->set_bites_gone(gone);
    }
    
    /* These next two might not be valid if _in_pieces isn't 0.  Good
     * thing it always is! */
    
    bing->add_alias(_piece_short || temp_short);
    bing->add_plural(_piece_plural || temp_plural);
    
    exploded_short = explode(bing->query_short(), " ");
    j = sizeof(exploded_short);
    bing->set_name(exploded_short[j - 1]);
    for (k = 0; k < sizeof(exploded_short) - 1; k++) {
      bing->add_adjective(exploded_short[k]);
    }
    
    bing->set_in_pieces(1);   // This doesn't do anything!
    if (bing->move(environment((this_object())))!= MOVE_OK ) {
      bing->move(environment(this_player()));
    }
  }

  move("/room/rubbish");
  
  // Use the default message.
  
  if (with->query_weight() < 20) {
    add_succeeded_mess(({ sprintf("$N $V $D into %s pieces with %s%s.\n",
                                  query_num(num_pieces), with->poss_short(),
                                  (num_pieces * size_of_each) <
                                  query_weight()?
                                  ", carelessly dribbling a bit while you do "
                                  "so" : ""),
                            sprintf("$N $V $D into %s pieces with %s.\n",
                                    query_num(num_pieces),
                                    with->poss_short()) }));
    
  } else {
    add_succeeded_mess(({sprintf("$N stand back and hack $D into %s pieces "
                                 "with %s%s.\n", query_num(num_pieces),
                                 with->poss_short(),
                                 (num_pieces * size_of_each) < query_weight()?
                                 ", carelessly obliterating a bit when you do "
                                 "so" : ""),
                           sprintf("$N stands back and hacks $D into %s "
                                   "pieces with %s.\n",
                                   query_num(num_pieces),
                                   with->poss_short()) }));
    
  }
  return 1;
}

varargs int do_mince()
{
   object *obs,
     with,
     transformed;
   int i,
     rem_pieces;

   if (query_liquid()) {
      add_failed_mess("You cannot $V $D.\n");
      return -1;
   }
   // First, check to see if they have a sharp weapon.
   obs = this_player()->query_holding();
   for (i = 0; i < sizeof(obs); i++) {
      if (check_sharp(obs[i])) {
         if (!with || (with && with->query_weight() > obs[i]->query_weight())) {
            with = obs[i];
         }
      }
   }
   if (!with) {
      add_failed_mess("You have to be holding a sharp object to $V " "$D.\n");
      return -1;
   }

   transformed = STATE_CHANGE->transform(this_object(), "slice");

   // if it doesn't mince, cut into the remaining number of pieces

   if (!objectp(transformed)) {
      if (query_continuous()) {
         add_failed_mess("$D cannot be cut up any further.\n");
         return -1;
      }
      if (_weight_per_bite) {
         rem_pieces = (query_weight() / _weight_per_bite) - _bites_gone;
         return (do_cut(rem_pieces));
      }
      return -1;
   }

   this_object()->move("/room/rubbish");

   if (transformed->move(this_player()) != MOVE_OK) {
      call_out("tell_object", 0, this_player(), "You drop " +
               transformed->the_short() + ".\n");
      call_out("tell_room", 0, environment(this_player()),
               this_player()->the_short() + " drops " +
               transformed->the_short() + ".\n");
      transformed->move(environment(this_player()));
   }
   add_succeeded_mess("$N $V $D with " + with->the_short() +
                      " into $I.\n", ({ transformed }));
   return 1;
}

/**
 * This gives the appropriate message for drinking things.
 *
 * @see do_eat()
 * @see consume(*)
 * @see set_liquid()
 * @return Return 1 if it succeeded, or return 0 if it failed.
 */
int do_drink()
{

   if (!check_for_container()) {
      add_failed_mess("You go to try and $V $D, but it suddenly "
                      "remembers what happens when it is not in a "
                      "container and drains away to dust.\n");
      move("/room/rubbish");
      return 0;
   }

   this_player()->add_succeeded_mess(this_object(), "$N $V " +
                                     amount_size() + " of $D.\n", ({ }));
   consume(this_player(), 0);
   return 1;
}                               /* do_drink() */

/**
 * This gives the appropriate message for quaffing things. Its
 * rather like drinking but a lot of it gets splashed on you.
 *
 * @see do_eat()
 * @see consume(*)
 * @see set_liquid()
 * @return Return 1 if it succeeded, or return 0 if it failed.
 */
int do_quaff()
{

   if (!check_for_container()) {
      add_failed_mess("You go to try and $V $D, but it suddenly "
                      "remembers what happens when it is not in a "
                      "container and drains away to dust.\n");
      move("/room/rubbish");
      return 0;
   }

   this_player()->add_succeeded_mess(this_object(), "$N $V " +
                                     amount_size() +
                                     " of $D spilling most of "
                                     "it of course.\n", ({ }));

   consume(this_player(), query_amount() * 6 / 10, "splash");
   consume(this_player(), query_amount() * 4 / 10);

   return 1;
}                               /* do_quaff() */

/**
 * This handles applying things
 *
 * @see set_applicable()
 * @see consume(*)
 * @return Return 1 if it succeeded, or return 0 if it failed.
 */
int do_apply(object * things)
{
   if (sizeof(things) > 1) {
      add_failed_mess("You must $V $D to one person alone.\n", ({ }));
      return 0;
   }
   if (!_applicable) {
      add_failed_mess("You cannot $V $D to anybody.\n");
      return 0;
   }
   if (_external_pk_check && pk_check(this_player(), things[0])) {
      add_failed_mess("You feel it would be wrong to rub $D on $I.\n",
                      things);
      return 0;
   }
   this_player()->add_succeeded_mess(this_object(), "$N $V " +
                                     amount_size() + " of $D to $I.\n",
                                     ({ things[0] }));
   consume(things[0], 0, "apply");
   return 1;
}                               /* do_apply() */

/**
 * @ignore yes
 */
int do_rub(object * things)
{
   /*identical to do_apply, except for one little syntax thing =) */
   if (sizeof(things) > 1) {
      add_failed_mess("You must $V $D on one person alone.\n", ({ }));
      return 0;
   }
   if (!_applicable) {
      add_failed_mess("You cannot $V $D on anybody.\n");
      return 0;
   }
   if (_external_pk_check && pk_check(this_player(), things[0])) {
      add_failed_mess("You feel it would be wrong to rub $D on $I.\n",
                      things);
      return 0;
   }

   this_player()->add_succeeded_mess(this_object(), "$N $V " +
                                     amount_size() + " of $D on $I.\n",
                                     ({ things[0] }));
   consume(things[0], 0, "apply");
   return 1;
}                               /* do_rub() */

int do_splash(object * things)
{
   if (sizeof(things) > 1) {
      add_failed_mess("You must $V $D on one person alone.\n", ({ }));
      return 0;
   }
   if (!_splashable || !_liquid) {
      add_failed_mess("You cannot $V $D on anybody.\n", ({ }));
      return 0;
   }
   if (_external_pk_check && pk_check(this_player(), things[0])) {
      add_failed_mess("You feel it would be wrong to splash $D on $I.\n",
                      things);
      return 0;
   }
   this_player()->add_succeeded_mess(this_object(), "$N $V " +
                                     amount_size() + " of $D on $I.\n",
                                     ({ things[0] }));
   consume(things[0], 0, "splash");
   return 1;
}                               /* do_splash() */


/**
 * @ignore yes
 */
mapping int_query_static_auto_load() {
   return ([ "::" : ::int_query_static_auto_load(),
             "liquid" : _liquid,
             "weight_per_bite" : _weight_per_bite,
             "eat_object" : _eat_object,
             "eat_func" : _eat_func,
             "eat_mess" : _eat_mess,
             "splashable" : _splashable,
             "applicable" : _applicable,
             "external_pk_check" : _external_pk_check ]);
}                               /* int_query_static_auto_load() */

/**
 * @ignore yes
 */
mapping query_static_auto_load()
{
   if ((explode(file_name(this_object()), "#")[0] != "/obj/food")
       && !query_continuous()) {
      return 0;
   }
   return int_query_static_auto_load();
}                               /* query_static_auto_load() */

/**
 * @ignore yes
 */
void init_static_arg(mapping map)
{
   if (!mapp(map)) {
      return;
   }
   if (map["::"]) {
      ::init_static_arg(map["::"]);
   }
   _liquid = map["liquid"];

   _weight_per_bite = map["weight_per_bite"];
   _eat_object = map["eat_object"];
   _eat_func = map["eat_func"];
   _eat_mess = map["eat_mess"];
   _splashable = map["splashable"];
   _applicable = map["applicable"];
   _external_pk_check = map["external_pk_check"];
}                               /* init_static_arg() */

/**
 * @ignore yes
 */
mapping query_dynamic_auto_load()
{
   return ([ "::" : ::query_dynamic_auto_load(),
             "bites_gone" : _bites_gone,
             "eat_effects" : _eat_effects,
             "external_effects" : _external_effects,
             "in pieces" : _in_pieces,
             "piece desc" : _piece_desc,
             "piece short" : _piece_short,
             "piece plural" : _piece_plural,
             "piece substance" : _piece_substance,
             "decay speed" : _decay_speed,
             "decay level" : _decay_level,
             "dried" : _dried,
             "cured" : _cured,
             "divisor" : _divisor, ]);
}                               /* query_dynamic_auto_load() */

/**
 * @ignore yes
 */
void init_dynamic_arg(mapping map, object)
{
   if (!mapp(map)) {
      return;
   }
   if (map["::"]) {
      ::init_dynamic_arg(map["::"]);
   }
   _bites_gone = map["bites_gone"];
   if (undefinedp(_eat_effects)) {
      _eat_effects = ([ ]);
   } else {
      if (mapp(map["eat_effects"])) {
         _eat_effects = map["eat_effects"];
      }
   }
   if (undefinedp(_external_effects)) {
      _external_effects = ([ ]);
   } else {
      _external_effects = map["external_effects"];
   }
   _in_pieces = map["in pieces"];
   _piece_desc = map["piece desc"];
   _piece_short = map["piece short"];
   _piece_plural = map["piece plural"];
   _piece_substance = map["piece substance"];
   if (_in_pieces && _piece_desc) {
      set_long(_piece_desc);
   }
   set_decay_speed(map["decay speed"]);
   _decay_level = map["decay level"];
   _divisor = map["divisor"];
   _dried = map["dried"];
   _cured = map["cured"];
   
   init_virtual_object();
}                               /* init_dynamic_arg() */

/**
 * @ignore yes
 */
mixed *stats()
{
   int i;
   string *words;
   mixed *args;
   args =::stats() + ({ ({ "liquid", _liquid }),
                        ({ "bites gone", _bites_gone }),
                        ({ "weight per bite", _weight_per_bite }),
                        ({ "eat object", _eat_object }),
                        ({ "eat function", _eat_func }),
                        ({ "eat message", _eat_mess }),
                        ({ "in pieces", _in_pieces }),
                        ({ "decay speed", _decay_speed }),
                        ({ "decay level", _decay_level }),
                        ({ "dried", _dried }),
                        ({ "cured", _cured }) });
   words = m_indices(_eat_effects);
   for (i = 0; i < sizeof(words); i++) {
      args += ({ ({ "eat effect#" + i, words[i] + " (" +
                    _eat_effects[words[i]] + ")" }) });
   }
   args += ({ ({ "applicable", _applicable }) });
   args += ({ ({ "splashable", _splashable }) });
   if (_splashable && !_liquid) {
      args += ({ ({ "***not splashable***", "because not a liquid" }) });
   }
   args += ({ ({ "external_pk_check", _external_pk_check }) });
   if (_external_effects) {
      words = keys(_external_effects);
      for (i = 0; i < sizeof(words); i++) {
         args += ({ ({ "external effect#" + i, words[i] + " (" +
                       _external_effects[words[i]] + ")" }) });
      }
   }
   return args;
}                               /* stats() */

/**
 * This checks the outside of us for a container and then destroys ourselves
 * if it is not a container.
 */
int check_for_container()
{
   if (query_liquid()) {
      if (!environment()->query_max_volume() || living(environment())) {
         return 0;
      }
   }
   return 1;
}                               /* check_for_container() */

private void move_check_for_container()
{
   if (!check_for_container()) {
      //
      // Opps, not a container.  Destroy ourselves.
      //
      tell_room(environment(),
                the_short() + " dribbles all over the place and disappears "
                "into the dust.\n");
      if(move("/room/rubbish") != MOVE_OK) {
        debug_printf("Oops, failed to move us to the rubbish room.\n");
      }
   }
}                               /* check_for_container() */

/** Check to see if the thing outside us can handle liquids...
 * @ignore yes
 */
varargs int move(mixed dest, string mess1, string mess2) {
   int ret;

   ret =::move(dest, mess1, mess2);
   if (ret == MOVE_OK && dest != "/room/rubbish" && query_liquid()) {
      move_check_for_container();
   }
   return ret;
}                               /* move() */

/** This tells us if the food has started to rot
 *
 * @return Return 1 if the food has started to rot, 0 otherwise.
 *
 * @see set_decay_speed()
 * @see query_decay_speed()
 * @see set_decay_level()
 * @see query_decay_level()
 * @see query_decay_divisor()
 */ 
int query_rotten() { 
    if ( _divisor ) { 
        return to_int( _decay_level / _divisor ) > 1; 
    }

    return 0; 
} /* query_rotten() */

/** Add the "rotten" adjective if appropriate
 * @ignore yes
 */
 
string *query_adjectives() {
  if( query_rotten() ) {
    return ::query_adjectives() + ({ "rotten" });
  }
  return ::query_adjectives();
}

/** This tells us the current divisor used to determine decay.  This can
 *  be modified with set_decay_speed.
 * 
 * @return float the divisor
 * @see set_decay_speed()
 * @see query_decay_speed()
 * @see set_decay_level()
 * @see query_decay_level()
 */
 
float query_decay_divisor() { return _divisor; }

/**
 * This is called by the pickling stick.  It stops the food
 * object decaying.
 *
 * @see set_decay_speed()
 * @return returns 1 for suceess and 0 for failure.
 */
int do_cure() {
  if(_dried || _liquid || _cured)
    return 0;

  _decay_speed = 0;
  _decay_level = 0;
  BITS_CONTROLLER->remove_bit(this_object());
  set_main_plural( "cured " + query_plural() );
  set_short( "cured " + query_short());
  add_adjective("cured");
  remove_adjective("fresh");
  _cured = 1;

  if( query_collective() ) {
    merge();
  }

  return 1;
}

/**
 * This returns the cured state of the bit.
 *
 * @return 1 if it is cured, 0 if not
 */
int query_cured() { return _cured; }

/**
 * This method dries the food.  Dried food no longer decays.
 *
 * @see set_decay_speed()
 * @return returns 1 for suceess and 0 for failure.
 */
int do_dry() {
  int new_weight;

  if(_dried || _liquid || _cured)
    return 0;

  _decay_speed = 0;
  _decay_level = 0;
  BITS_CONTROLLER->remove_bit( this_object() );
  set_main_plural("dried " + query_plural(0));
  set_short( "dried " + query_short());
  add_adjective("dried");
  remove_adjective("fresh");

  new_weight = ::query_weight() / 10;

  if ( new_weight ) { 
    set_weight( new_weight );
  }
  else {
    set_weight( 1 );
  }

  if( query_collective() ) {
    merge();
  }

  _dried = 1;
  return 1;
}

/**
 * This returns the dried state of the bit.
 *
 * @return 1 if it is dried, 0 if not
 */
int query_dried() { return _dried; }

/** @ignore yes.
 *
 * Define some food-specific merge criteria for collective food objects.
 */
int merge_criteria(object ob) {
  return ::merge_criteria(ob) &&
    _decay_speed == ob->query_decay_speed() &&
    _bites_gone == ob->query_bites_gone() &&
    ((to_int(_decay_level / _divisor) < 2 &&
     to_int(ob->query_decay_level() / ob->query_decay_divisor()) < 2) ||
     to_int(_decay_level / _divisor) ==
     to_int(ob->query_decay_level() / ob->query_decay_divisor()));
}
// --- END [/mnt/home2/grok/lib/obj/food.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/clothing.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/clothing.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627801   Available: 13575155
Inodes: Total: 5242880    Free: 4960133
13370 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/clothing.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627801   Available: 13575155
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Id: clothing.c,v 1.22 2003/05/07 23:13:12 ceres Exp $
 */
/**
 * This is the clothing file.  COntains everything you need to
 * make some nice clothing.
 */
#include <move_failures.h>
#include <virtual.h>

inherit "/std/container";
inherit "/std/basic/wearable";
inherit "/std/basic/close_lock";

string pocket_mess;
mixed *pockets;
nosave int biggest;
int _is_pair = 0;

/** @ignore yes */
void create() {
   do_setup++;
   container::create();
   wearable::create();
   close_lock::create();
   set_stuck(1);
   set_can_export_inventory();
   pocket_mess = "a pocket in $ob_short$";
   pockets = ({ });
   add_alias( "clothing" );
   add_plural( "clothes" );
   add_immune_to( "blunt" );
   add_help_file("clothing");
   set_opaque();
   set_open();
   if ( !query_property( "shop type" ) ) {
      add_property( "shop type", "haberdashery" );
   }
   do_setup--;
   if ( !do_setup ) {
      this_object()->setup();
   }
} /* create() */

/**
 * This method will return true if the item is an item of clothing.
 * @return always returns true
 */
int query_clothing() { return 1; }

string query_pronoun()  {
   if (!_is_pair)
      return "it";
   return "they";
}


string query_objective()  {
   if (!_is_pair)
      return "it";
   return "them";
}


void set_is_pair(int comes_in_pairs)  {
   _is_pair = comes_in_pairs;
   if (_is_pair)
      add_adjective(({ "pair", "of" }));
}

int query_is_pair() { return _is_pair; }

/** @ignore yes */
string long( string word, int dark ) {
   int i;
   string ret, *sizes;
   mapping types;

   ret = container::long( word, dark );
   if ( sizeof( pockets ) && !dark ) {
      types = ([ ]);
      for ( i = 0; i < sizeof( pockets ); i += 2 ) {
         types[ pockets[ i ] ]++;
      }
      sizes = m_indices( types );
      for ( i = 0; i < sizeof( sizes ); i++ ) {
         sizes[ i ] = query_num( types[ sizes[ i ] ] ) +" "+ sizes[ i ] +
               " pocket"+ ( types[ sizes[ i ] ] > 1 ? "s" : "" );
      }
      ret += "$C$"+ the_short() +" has "+ query_multiple_short( sizes ) +".\n"+
            query_contents( "It contains: " );
      ret += close_lock::long_status();
   }
   return ret + wearable::long( word, dark );
} /* long() */

/** @ignore yes */
varargs string pretty_short( object thing ) {
   mixed pshort = ::pretty_short( thing );
   string short_stat = close_lock::short_status();

   if( arrayp( pshort ) ) {
      for( int i = 0; i < sizeof( pshort ); ++i ) {
         pshort[i] = short_stat + pshort[i];
      }
   } else {
      pshort = short_stat + pshort;
   }

   return pshort;
} /* pretty_short() */

/** @ignore yes */
varargs string pretty_plural( object thing ) {
   mixed plural = ::pretty_plural( thing );
   string short_stat = close_lock::short_status();

   if( arrayp( plural ) ) {
      for( int i = 0; i < sizeof( plural ); ++i ) {
         plural[i] = short_stat + plural[i];
      }
   } else {
      plural = short_stat + plural;
   }

   return plural;
} /* pretty_plural() */

/**
 * This method returns the message associated with the pocket.
 * @return the message associated with the pocket
 * @see set_pocket_mess()
 * @see query_pockets()
 * @see add_pocket()
 * @see remove_pockets()
 */
string query_pocket_mess() { return pocket_mess; }

/**
 * This method sets the message associated with the pocket.
 * @param words the message associated with the pocket
 * @see query_pocket_mess()
 * @see add_pocket()
 * @see remove_pockets()
 */
void set_pocket_mess( string words ) { pocket_mess = words; }

/**
 * This method returns all the pockets on the object.
 * @return all the pockets on the object
 * @see add_pocket()
 * @see remove_pockets()
 */
mixed *query_pockets() { return pockets; }

/**
 * This method removes all pockets from the clothing.
 * @see add_pocket()
 * @see query_pockets()
 */
void remove_pockets() {
  for( int i = 0; i < sizeof( pockets ); i+=2 ) {
    set_max_weight( query_max_weight() - pockets[ i+1 ] );
  }

  pockets = ({ });
}

/**
 * This method adds a pocket onto the clothing.
 * <p>
 * When setting the amount a pocket can hold
 * use the following guide:
 * <pre>
 * o==================o==============o========o
 * | Type of Clothing | example type | amount |
 * o==================o==============o========o
 * |   Aprons         |    front     |  8-10  |
 * |------------------+--------------+--------|
 * |   Coats          |     side     |  6-7   |
 * |                  |    inside    |   5    |
 * |------------------+--------------+--------|
 * |   Corsets        |   cleavage   |   2    |
 * |------------------+--------------+--------|
 * |   Dresses        |     side     |  2-3   |
 * |------------------+--------------+--------|
 * |   Hats           |    inside    |  2-6   |
 * |------------------+--------------+--------|
 * |   Jackets        |     side     |  2-3   |
 * |                  |    inside    |  2-3   |
 * |------------------+--------------+--------|
 * |   Robes          |     side     |   5    |
 * |                  |    sleeve    |   2    |
 * |------------------+--------------+--------|
 * |   Shirts         |    breast    |  2-3   |
 * |------------------+--------------+--------|
 * |   Skirts         |     side     |   4    |
 * |------------------+--------------+--------|
 * |   Trousers       |     side     |   4    |
 * |                  |     back     |   2    |
 * |------------------+--------------+--------|
 * |   Underwear      |    front     |  1-2   |
 * |                  |    breast    |  1-2   |
 * |                  |   cleavage   |   2    |
 * o==================o==============o========o
 * </pre>
 * @param type the type of pocket
 * @param amount the amount the pocket can hold
 * @see query_pockets()
 * @see remove_pockets()
 * @see set_pocket_mess()
 * @see query_pocket_mess()
 */
void add_pocket( string type, int amount ) {
   if ( !type || ( type == "" ) || ( amount < 1 ) ) {
      return;
   }
   pockets += ({ type, amount });
   set_max_weight(query_max_weight() + amount);
   if ( amount > biggest ) {
      biggest = amount;
   }
} /* add_pocket() */

/** @ignore yes */
int test_add( object thing, int flag ) {
   int i;

   if ( !sizeof( pockets )  || flag ) {
      return 0;
   }
   if ( !environment( thing ) ) {
      return 1;
   }
   if ( !biggest ) {
      for ( i = 0; i < sizeof( pockets ); i+= 2 ) {
         if ( pockets[ i + 1 ] > biggest ) {
            biggest = pockets[ i + 1 ];
         }
      }
   }
   if ( (int)thing->query_complete_weight() > biggest ) {
      return write( (string)thing->the_short() +" is too big "+
            "to fit in any of "+ the_short() +"'s pockets.\n" );
   }
   return ::test_add(thing, flag);
} /* test_add() */

/** @ignore yes */
int can_find_match_recurse_into(object looker) {
   if (query_closed()) {
      return 0;
   }
   return ::can_find_match_recurse_into(looker);
} /* can_find_match_recurse_into() */

/** @ignore yes */
int query_ac( string type, int amount ) {
   do_damage( type, amount );
   return 0;
} /* query_ac() */

/**
 * This method sets up the condition for the clothing.
 * @param number the maximum condition for the clothing
 */
void setup_clothing( int number ) {
   set_max_cond( number );
   set_cond( number );
   set_lowest_cond( number );
} /* setup_clothing() */

/** @ignore yes */
int query_value() {
   return modify_value( container::query_value() );
} /* query_value() */

/** @ignore yes */
int query_full_value() { return container::query_value(); }

/** @ignore yes */
int drop(mixed stuff) {
   if ( worn_by ) {
      if ( living( worn_by ) ) {
         return 1;
      }
   }
   return container::drop(stuff);
} /* drop() */

/** @ignore yes */
varargs int move( mixed dest, string messin, string messout ) {
   int flag;
   object from;

   from = environment();
   flag = container::move( dest, messin, messout );
   if ( ( flag == MOVE_OK ) && worn_by ) {
      set_worn_by( 0 );
      if (from) {
         from->remove_inventory_container(this_object());
      }
      if (environment()) {
         environment()->add_inventory_container(this_object());
      }
   }
   return flag;
} /* move() */

/**
 * @ignore yes
 */
string *parse_command_adjectiv_id_list() {
    return container::parse_command_adjectiv_id_list() +
        close_lock::parse_command_adjectiv_id_list();
} /* parse_command_adjectiv_id_list() */


/** @ignore yes */
void dest_me() {
   set_worn_by( 0 );
   container::dest_me();
} /* dest_me() */

/**
 * This method causes the object to be broken.
 */
void break_me() {
   if ( worn_by ) {
      all_inventory()->move( environment( worn_by ), "$N fall$s from "+
            a_short() +"." );
   } else {
      all_inventory()->move( environment(), "$N fall$s out of "+
            a_short() +"." );
   }
   ::break_me();
} /* break_me() */

/** @ignore yes */
mixed *stats() {
   int i;
   mixed *ret;
   ret = container::stats() + wearable::stats();
   for ( i = 0; i < sizeof( pockets ); i += 2 ) {
      ret += ({ ({ pockets[ i ] +" pocket", pockets[ i + 1 ] }) });
   }
   return ret;
} /* stats() */

/** @ignore yes */
mapping int_query_static_auto_load() {
   return ([
      "::" : container::int_query_static_auto_load(),
      "wear" : wearable::query_static_auto_load(),
      "pocket mess" : pocket_mess,
      "pockets" : pockets,
      "trans" : query_transparent(),
      "difficulty" : query_difficulty(),
      "key" : query_key(),
      "trap open func" : query_open_trap_func(),
      "trap lock func" : query_lock_trap_func(),
      "trap open ob" : query_open_trap_ob(),
      "trap lock ob" : query_lock_trap_ob(),
      "stuck" : query_stuck(),
      "pair" : _is_pair
   ]);
} /* query_static_auto_load() */

/** @ignore yes */
mapping query_static_auto_load() {
   if ( base_name(this_object()) != __FILE__[0..<3]) {
      return ([ ]);
   }
   return int_query_static_auto_load();
} /* query_static_auto_load() */

/** @ignore yes */
mapping query_dynamic_auto_load() {
   return ([
      "::" : container::query_dynamic_auto_load(),
      "wear" : wearable::query_dynamic_auto_load(),
      "locked" : query_locked(),
      "closed" : query_closed(),
   ]);
} /* query_dynamic_auto_load() */

/** @ignore yes */
void init_static_arg( mapping map ) {
   if ( !mapp( map ) ) {
      return;
   }
   if ( map[ "::" ] ) {
      container::init_static_arg( map[ "::" ] );
   }
   if ( map[ "wear" ] ) {
      wearable::init_static_arg( map[ "wear" ] );
   }
   if ( !undefinedp( map[ "pocket mess" ] ) ) {
      pocket_mess = map[ "pocket mess" ];
   }
   if ( !undefinedp( map[ "pockets" ] ) ) {
      pockets = map[ "pockets" ];
   }

   if (!undefinedp(map["pair"]))
      _is_pair = map["pair"];

   if (!undefinedp(map["trans"])) {
      if (map["trans"]) {
         set_transparent();
      } else {
         set_opaque();
      }
   }
   if (!undefinedp(map["difficulty"])) {
      set_difficulty(map["difficulty"]);
   }
   if (!undefinedp(map["key"])) {
      set_key(map["key"]);
   }
   if (!undefinedp(map["trap open func"])) {
      set_open_trap(map["trap open ob"], map["trap open func"]);
   }
   if (!undefinedp(map["trap lock func"])) {
      set_lock_trap(map["trap lock ob"], map["trap lock func"]);
   }
   if ( !undefinedp( map[ "stuck" ] ) ) {
      set_stuck(map["stuck"]);
   }

} /* init_static_arg() */

void replace_me(){
  object receipt;

  receipt = clone_object( "/std/object" );
  receipt->set_name( "receipt" );
  receipt->set_short( "destructed item receipt" );
  receipt->add_adjective( ({ "destructed", "item" }) );
  receipt->set_long( "This seems to be a small piece of paper.\n" );
  receipt->set_read_mess( "According to our sources, your "+query_short()+" was not "
                          "allowed to exist.  Have a nice day." );
  receipt->move( environment() );
  receipt->set_weight( 1 );
  destruct( this_object() );
}

/** @ignore yes */
void init_dynamic_arg( mapping map, object ob ) {
   mapping stat_temp;
   string virt_name, new_name;

   if ( map[ "::" ] ) {
      container::init_dynamic_arg( map[ "::" ], ob );
   }
   if ( map[ "wear" ] ) {
      wearable::init_dynamic_arg( map[ "wear" ], ob );
   }

   if ( !undefinedp( map[ "locked" ] ) ) {
      if ( map[ "locked" ] ) {
         set_locked();
      } else {
         set_unlocked();
      }
   }
   if ( !undefinedp( map[ "closed" ] ) ) {
      if (map["closed"]) {
         set_closed();
      } else {
         set_open();
      }
   }

   if( virt_name = query_property( VIRTUAL_NAME_PROP ) ) {
      if( file_size( virt_name ) == -1 ) {
         new_name = ( CLONER )->other_file( virt_name );
         if( stringp( new_name ) && ( new_name != virt_name ) ) {
            add_property( VIRTUAL_NAME_PROP, new_name );
            virt_name = new_name;
         } else {
            if( VIRTUAL_HANDLER->query_forbidden( virt_name ) ) {
               call_out( "replace_me", 1 );
            } else {
               VIRTUAL_HANDLER->add_missing( virt_name );
            }
         }
      }

      if( file_size( virt_name ) != -1 &&
          query_property( "virtual time" ) < stat( virt_name )[1] ) {
         stat_temp = ( VIRTUAL_HANDLER )->new_data( virt_name );
         if( mapp( stat_temp ) ) {
            init_static_arg( stat_temp );
            add_property( "virtual time", time() );
         }
      }
   }
} /* init_dynamic_arg() */
// --- END [/mnt/home2/grok/lib/obj/clothing.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/key.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/key.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627798   Available: 13575152
Inodes: Total: 5242880    Free: 4960133
800 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/key.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627798   Available: 13575152
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: key.c,v 1.3 2002/06/03 14:58:57 ohdamn Exp $
 * $Log: key.c,v $
 * Revision 1.3  2002/06/03 14:58:57  ohdamn
 * Fixed typo
 *
 * Revision 1.2  1999/10/28 02:24:03  ceres
 * Standardised
 * **S
 *
 * Revision 1.1  1998/01/06 04:58:17  ceres
 * Initial revision
 * 
*/
inherit "std/object";

string type;

void set_type(string str) {
  remove_adjective(type);
  type = str;
  add_adjective(type);
  set_main_plural(type + " keys");
  set_short(type + " key");
}
string query_type() {
  return type;
}

void create() {
  ::create();
  set_name("key");
  set_main_plural("normal keys");
  add_plural("keys");
  type = "normal";
  set_short(query_type() + " key");
  set_long("A key.  Wonder where it fits?\n");
  set_weight(1);
  adjust_money(1, "brass");
}
// --- END [/mnt/home2/grok/lib/obj/key.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/state_change/base.hdr_dc.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/state_change/base.hdr_dc.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627798   Available: 13575152
Inodes: Total: 5242880    Free: 4960133
71266 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/state_change/base.hdr_dc.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627798   Available: 13575152
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <state_change.h>
void dest_me() { destruct( this_object() ); }

class state_change item;
mapping data = ([ ]);

mixed data_return_0() {
  item = new( class state_change );
  item->result = "/obj/reagents/water.ob";
  item->factor = 0.0;
  item->func = ({});
  data["witchesbrew:Water"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/water.ob";
  item->factor = 0.0;
  item->func = ({});
  data["ruinedbrew:Water"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/brewed_healing_tea.ob";
  item->factor = 1.0;
  item->func = ({
    (: $2->add_eat_effect( "/std/effects/ingested/basic_healing",
       to_int( $1->query_eat_effects()[
              "/std/effects/ingested/basic_healing" ] *
           ( 4 + $1->query_property( "brew bonus" ) ) ) ) :),
  });
  data["witchesbrew:UnbrewedComfreyYarrowTea"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/burnt_tea.ob";
  item->factor = 1.0;
  item->func = ({});
  data["ruinedbrew:UnbrewedComfreyYarrowTea"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/brewed_antidote_elixir";
  item->factor = 1.0;
  item->func = ({
    (: $2->add_eat_effect( "/std/effects/ingested/poison_antidote",
       to_int( $1->query_eat_effects()[
           "/std/effects/ingested/poison_antidote"] *
       ( 4 + $1->query_property( "brew bonus" ) ) ) ) :)
  });
  data["witchesbrew:UnbrewedBasilFennelSpiderTea"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/burnt_tea.ob";
  item->factor = 1.0;
  item->func = ({});
  data["ruinedbrew:BasilFennelSpiderTea"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/brewed_intelligence_tea.ob";
  item->factor = 1.0;
  item->func = ({
    (: $2->add_eat_effect( "/std/effects/ingested/int_bonus",
       to_int( this_player()->query_skill_bonus(
             "magic.methods.physical.brewing" ) /
       ( 10 - $1->query_property( "brew bonus" ) ) ) ) :),
    });
  data["witchesbrew:UnbrewedSageIntPotion"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/burnt_tea.ob";
  item->factor = 1.0;
  item->func = ({});
  data["ruinedbrew:UnbrewedSageIntPotion"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_liquid.ob";
  item->factor = 1.0;
  item->func = ({
        (: $2->set_name("liquid") :),
        (: $2->set_short("milky white liquid") :),
        (: $2->add_adjective( "milky", "white"  ) :),
        (: $2->set_long("This is a milky white liquid, $pile_size$.") :),
        (: $2->set_medium_alias("BrewedEyebrightCarrotBunnyEyeballTea") :),
        (: $2->add_eat_effect("/std/effects/ingested/blind_protect",
               to_int( this_player()->query_skill_bonus(
               "magic.methods.physical.brewing" ) /
               ( 10 - $1->query_property( "brew bonus" ) ) ) ) :),
    });
  data["witchesbrew:EyebrightCarrotBunnyEyeballTea"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/burnt_tea.ob";
  item->factor = 1.0;
  item->func = ({});
  data["ruinedbrew:EyebrightCarrotBunnyEyeballTea"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/brewed_cold_cure.ob";
  item->factor = 1.0;
  item->func = ({
     (: $2->add_eat_effect("/std/effects/ingested/cold_cure",
        to_int( $1->query_eat_effects()["/std/effects/ingested/cold_cure"] *
               ( 4 + $1->query_property( "brew bonus" ) ) ) ) :),
     (: $2->add_eat_effect("/std/effects/ingested/garlic_breath",
        $1->query_eat_effects()["/std/effects/ingested/garlic_breath"] ) :),
   });
  data["witchesbrew:ColdCureSyrup"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/burnt_cold_cure.ob";
  item->factor = 0.25;
  item->func = ({});
  data["ruinedbrew:ColdCureSyrup"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/black_tea.ob";
  item->factor = 1.0;
  item->func = ({ });
  data["witchesbrew:UnbrewedBlackTea"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/burnt_tea.ob";
  item->factor = 1.0;
  item->func = ({});
  data["ruinedbrew:UnbrewedBlackTea"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/burnt_tea.ob";
  item->factor = 1.0;
  item->func = ({ });
  data["witchesbrew:BlackTea"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/burnt_tea.ob";
  item->factor = 1.0;
  item->func = ({});
  data["ruinedbrew:BlackTea"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/water.ob";
  item->factor = 1.0;
  item->func = ({});
  data["burn:Water"] = item;
  item = new( class state_change );
  item->factor = 1.0;
  item->result = "/obj/reagents/blackened_mess.ob";
  item->func = ({ (: $2->add_eat_effect( "/std/effects/ingested/poison", 400 ) :) });
  data["burn:UnheatedAchorionPurple"] = item;
  item = new( class state_change );
  item->factor = 1.0;
  item->result = "/obj/reagents/blackened_mess.ob";
  item->func = ({ (: $2->add_eat_effect( "/std/effects/ingested/poison", 400 ) :) });
  data["burn:UndistilledAchorionPurple"] = item;
  item = new( class state_change );
  item->factor = 1.0;
  item->result = "/obj/reagents/blackened_mess.ob";
  item->func = ({ (: $2->add_eat_effect( "/std/effects/ingested/poison", 400 ) :) });
  data["burn:UndistilledFightClubPoison"] = item;
  item = new( class state_change );
  item->factor = 1.0;
  item->result = "/obj/reagents/blackened_mess.ob";
  item->func = ({ (: $2->add_eat_effect( "/std/effects/ingested/poison", 400 ) :) });
  data["burn:UndistilledHallucinogenPoison"] = item;
  item = new( class state_change );
  item->factor = 1.0;
  item->result = "/obj/reagents/blackened_mess.ob";
  item->func = ({ (: $2->add_eat_effect( "/std/effects/ingested/poison", 400 ) :) });
  data["burn:UndistilledSpiderPoison"] = item;
  item = new( class state_change );
  item->factor = 1.0;
  item->result = "/obj/reagents/blackened_mess.ob";
  item->func = ({ (: $2->add_eat_effect( "/std/effects/ingested/poison", 400 ) :) });
  data["burn:UndistilledBlowfishPoison"] = item;
  item = new( class state_change );
  item->factor = 1.0;
  item->result = "/obj/reagents/blackened_mess.ob";
  item->func = ({ (: $2->add_eat_effect( "/std/effects/ingested/poison", 400 ) :) });
  data["burn:UnheatedWeakConPoison"] = item;
  item = new( class state_change );
  item->factor = 1.0;
  item->result = "/obj/reagents/blackened_mess.ob";
  item->func = ({ (: $2->add_eat_effect( "/std/effects/ingested/poison", 400 ) :) });
  data["burn:UnheatedConPoison"] = item;
  item = new( class state_change );
  item->factor = 1.0;
  item->result = "/obj/reagents/blackened_mess.ob";
  item->func = ({ (: $2->add_eat_effect( "/std/effects/ingested/poison", 400 ) :) });
  data["burn:UnheatedConfusePoison"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/water.ob";
  item->factor = 1.0;
  item->func = ({});
  data["distill:Water"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/achorion_purple.ob";
  item->factor = 0.01;
  item->func = ({ (: $2->add_eat_effect( "/std/effects/poisons/hp_new",
    to_int( $3->query_skill_bonus( "covert.items.poisons" ) ) ) :) });
  data["distill:UndistilledAchorionPurple"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/achorion_purple.ob";
  item->factor = 0.01;
  item->func = ({ (: $2->add_eat_effect( "/std/effects/poisons/hp_new",
    to_int( $3->query_skill_bonus( "covert.items.poisons" ) / 5 ) ) :) });
  data["distill:UnheatedAchorionPurple"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/angry_poison.ob";
  item->factor = 0.01;
  item->func = ({ (: $2->add_eat_effect( "/std/effects/poisons/angry",
    to_int( $3->query_skill_bonus( "covert.items.poisons" ) ) ) :) });
  data["distill:UndistilledFightClubPoison"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/hallucinogen_poison.ob";
  item->factor = 0.01;
  item->func = ({ (: $2->add_eat_effect( "/std/effects/ingested/hallucination",
    to_int( $3->query_skill_bonus( "covert.items.poisons" ) * 10 ) ) :) });
  data["distill:UndistilledHallucinogenPoison"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/spider_poison.ob";
  item->factor = 0.5;
  item->func = ({ (: $2->add_eat_effect( "/std/effects/poisons/spider_venom",
    to_int( $3->query_skill_bonus( "covert.items.poisons" ) * 10 ) ) :) });
  data["distill:UndistilledSpiderPoison"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/bloat.ob";
  item->factor = 0.5;
  item->func = ({ (: $2->add_eat_effect( "/std/effects/poisons/bloat",
    to_int( $3->query_skill_bonus( "covert.items.poisons" ) * 1.5 ) ) :) });
  data["distill:UndistilledBlowfishPoison"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_liquid.ob";
  item->factor = 1.0;
  item->func = ({
      (: $2->set_name( "snake_poison" ) :),
      (: $2->set_short( "thick white liquid" ) :),
      (: $2->add_adjective( ({ "thick", "white", "liquid" }) ) :),
      (: $2->set_long( "This is $amount_size$ of some thick white liquid.\n" ) :),
      (: $2->set_medium_alias( "DistilledSnakePoison" ) :),
    });
  data["distill:UndistilledSnakePoison"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_solid.ob";
  item->factor = 15.0;
  item->func = ({
      (: $2->set_name( "mess" ) :),
      (: $2->set_short( "nasty fibrous mess" ) :),
      (: $2->add_alias( "wheat" ) :),
      (: $2->add_adjective( ({ "nasty", "fibrous" }) ) :),
      (: $2->set_long("This is $pile_size$ of a nasty, "
                      "fibrous mess.  Some of it looks "
                      "a bit like flour.\n") :),
      (: $2->set_medium_alias( "WheatMess" ) :),
      (: $2->set_decay_speed( 0 ) :)
   });
  data["grind:Wheat"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_solid.ob";
  item->factor = 10.0;
  item->func = ({
      (: $2->set_name( "wheat" ) :),
      (: $2->set_short( "wheat flour" ) :),
      (: $2->add_alias( "flour" ) :),
      (: $2->add_adjective( "ground" ) :),
      (: $2->set_long("This is $pile_size$ of soft, brown "
                      "flour, $amount_size$.  Perhaps you "
                      "could make bread with it?\n") :),
      (: $2->set_medium_alias( "WheatFlour" ) :),
      (: $2->set_decay_speed( 0 ) :)
   });
  data["grind:WheatBerries"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_solid.ob";
  item->factor = 50.0;
  item->func = ({
      (: $2->set_name( "clover" ) :),
      (: $2->set_short( "ground clover" ) :),
      (: $2->add_alias( "plant" ) :),
      (: $2->add_plural( "plants" ) :),
      (: $2->add_adjective( "ground" ) :),
      (: $2->set_long( "This is $pile_size$ of ground plant, "
            "$amount_size$.  It looks "
            "like it might have been clover.\n" ) :),
      (: $2->set_medium_alias( "GroundClover" ) :),
      (: $2->set_decay_speed( 0 ) :)
   });
  data["grind:Clover"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/coffee.ob";
  item->factor = 5.0;
  item->func = ({ });
  data["grind:CoffeeBean"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_solid.ob";
  item->factor = 50.0;
  item->func = ({
        (: $2->set_name("yarrow") :),
        (: $2->set_short("ground yarrow") :),
        (: $2->add_alias("plant") :),
        (: $2->add_plural( "plants" ) :),
        (: $2->add_adjective("ground") :),
        (: $2->set_long( "This is $pile_size$ of ground plant, "
            "$amount_size$.  It looks "
                    "like it might've been yarrow.\n") :),
        (: $2->set_medium_alias("GroundYarrow") :),
        (: $2->add_eat_effect("/std/effects/ingested/cum_poison", 12) :),
        (: $2->add_eat_effect("/std/effects/ingested/basic_healing", 2) :),
        (: $2->set_decay_speed(0) :)
    });
  data["grind:Yarrow"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_solid.ob";
  item->factor = 50.0;
  item->func = ({
        (: $2->set_name("comfrey") :),
        (: $2->set_short("ground comfrey") :),
        (: $2->add_alias("plant") :),
        (: $2->add_plural( "plants" ) :),
        (: $2->add_adjective("ground") :),
        (: $2->set_long( "This is $pile_size$ of ground plant, "
                    "$amount_size$.  It looks "
                    "like it might've been comfrey.\n") :),
        (: $2->set_medium_alias("GroundComfrey") :),
        (: $2->add_eat_effect("/std/effects/ingested/cum_poison", 16) :),
        (: $2->add_eat_effect("/std/effects/ingested/basic_healing", 4) :),
        (: $2->set_decay_speed(0) :)
    });
  data["grind:Comfrey"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_solid.ob";
  item->factor = 1.0;
  item->func = ({
   (: $2->set_name( "mushroom" ) :),
   (: $2->set_short( "ground mushroom" ) :),
   (: $2->add_alias( "madman" ) :),
   (: $2->add_adjective( "ground" ) :),
        (: $2->set_long( "This is $pile_size$ of ground plant, "
                    "$amount_size$.  Judging from the "
          "green tint, it looks like it might've been Floppy Madman.\n" ) :),
   (: $2->set_medium_alias( "GroundFloppyMadman" ) :)
   });
  data["grind:FloppyMadman"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_solid.ob";
  item->factor = 50.0;
  item->func = ({
        (: $2->set_name("fleabane") :),
        (: $2->set_short("ground fleabane") :),
        (: $2->add_alias("plant") :),
        (: $2->add_plural( "plants" ) :),
        (: $2->add_adjective("ground") :),
        (: $2->set_long( "This is $pile_size$ of ground plant, "
                    "$amount_size$.  It looks "
                    "like it might've been Klatchian fleabane.\n") :),
        (: $2->set_medium_alias("GroundKlatchianFleabane") :),
        (: $2->set_decay_speed(0) :)
    });
  data["grind:KlatchianFleabane"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_solid.ob";
  item->factor = 1.2;
  item->func = ({
        (: $2->set_name("fleabane") :),
        (: $2->set_short("powdered fleabane") :),
        (: $2->add_alias("plant") :),
        (: $2->add_plural( "plants" ) :),
        (: $2->add_adjective(({"powdered"})) :),
        (: $2->set_long( "This is $pile_size$ of ground plant, "
                    "$amount_size$.  It looks "
                    "a slight lavender hue with specs of orange.\n") :),
        (: $2->set_medium_alias("PowderedKlatchianFleabane") :),
        (: $2->set_decay_speed(0) :)
    });
  data["grind:GroundKlatchianFleabane"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_solid.ob";
  item->factor = 50.0;
  item->func = ({
        (: $2->set_name("mayweed") :),
        (: $2->set_short("ground mayweed") :),
        (: $2->add_alias("plant") :),
        (: $2->add_adjective("ground") :),
        (: $2->set_long( "This is $pile_size$ of ground plant, "
                    "$amount_size$.  It looks "
                    "like it might've been stinking mayweed.\n") :),
        (: $2->set_medium_alias("GroundStinkingMayweed") :),
        (: $2->set_decay_speed(0) :)
    });
  data["grind:StinkingMayweed"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_solid.ob";
  item->factor = 1.2;
  item->func = ({
        (: $2->set_name("mayweed") :),
        (: $2->set_short("powdered mayweed") :),
        (: $2->add_alias("plant") :),
        (: $2->add_plural( "plants" ) :),
        (: $2->add_adjective(({"powdered"})) :),
        (: $2->set_long( "This is $pile_size$ of ground plant, "
                    "$amount_size$.  It looks "
                    "a brownish green color, as well as a very strong "
                    "odor.\n") :),
        (: $2->set_medium_alias("PowderedStinkingMayweed") :),
        (: $2->set_decay_speed(0) :)
    });
  data["grind:GroundStinkingMayweed"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_solid.ob";
  item->factor = 50.0;
  item->func = ({
      (: $2->set_name( "walnut" ) :),
      (: $2->set_short( "ground walnut" ) :),
      (: $2->add_adjective( "ground" ) :),
      (: $2->add_plural( "walnuts" ) :),
      (: $2->set_long( "This is a pile of ground walnut.\n" ) :),
      (: $2->set_medium_alias( "GroundWalnut" ) :),
   });
  data["grind:Walnut"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_solid.ob";
  item->factor = 0.04;
  item->func = ({
      (: $2->set_name( "garlic" ) :),
      (: $2->set_short( "ground garlic" ) :),
      (: $2->add_alias( "garlic" ) :),
      (: $2->add_adjective( ({ "wild", "ground" }) ) :),
      (: $2->set_long( "This is $pile_size$ of ground plant, "
                    "$amount_size$.  Judging from the "
         "smell, it must have been garlic.\n" ) :),
       (: $2->set_medium_alias( "GroundGarlic" ) :),
      (: $2->add_eat_effect("/std/effects/ingested/garlic_breath", 200) :),
      (: $2->set_decay_speed(0) :)
   });
  data["grind:WildGarlic"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_solid.ob";
  item->factor = 0.04;
  item->func = ({
      (: $2->set_name( "garlic" ) :),
      (: $2->set_short( "ground garlic" ) :),
      (: $2->add_alias( "garlic" ) :),
      (: $2->add_adjective( "ground" ) :),
      (: $2->set_long( "This is $pile_size$ of ground plant, "
                    "$amount_size$.  Judging from the "
         "smell, it must have been garlic.\n" ) :),
       (: $2->set_medium_alias( "GroundGarlic" ) :),
      (: $2->add_eat_effect("/std/effects/ingested/garlic_breath", 200) :),
      (: $2->set_decay_speed(0) :)
    });
  data["grind:GarLic"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_solid.ob";
  item->factor = 50.0;
  item->func = ({
        (: $2->set_name("parsley") :),
        (: $2->set_short("ground parsley") :),
        (: $2->add_alias("plant") :),
        (: $2->add_plural( "plants" ) :),
        (: $2->add_adjective("ground") :),
        (: $2->set_long( "This is $pile_size$ of ground plant, "
                    "$amount_size$.  It smells "
                    "like it might've been parsley.\n") :),
        (: $2->set_medium_alias("GroundParsley") :),
        (: $2->add_eat_effect("/std/effects/ingested/breath_fresh", 2) :),
        (: $2->set_decay_speed(0) :)
    });
  data["grind:Parsley"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_solid.ob";
  item->factor = 50.0;
  item->func = ({
        (: $2->set_name("sage") :),
        (: $2->set_short("ground sage") :),
        (: $2->add_alias("plant") :),
        (: $2->add_plural( "plants" ) :),
        (: $2->add_adjective("ground") :),
        (: $2->set_long( "This is $pile_size$ of ground plant, "
                    "$amount_size$.  It smells "
                    "like it might've been sage.\n") :),
        (: $2->set_medium_alias("GroundSage") :),
        (: $2->set_decay_speed(0) :)
    });
  data["grind:Sage"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_solid.ob";
  item->factor = 50.0;
  item->func = ({
        (: $2->set_name("rosemary") :),
        (: $2->set_short("ground rosemary") :),
        (: $2->add_alias("plant") :),
        (: $2->add_plural( "plants" ) :),
        (: $2->add_adjective("ground") :),
        (: $2->set_long( "This is $pile_size$ of ground plant, "
                    "$amount_size$.  It smells "
                    "like it might've been rosemary.\n") :),
        (: $2->set_medium_alias("GroundRosemary") :),
        (: $2->set_decay_speed(0) :)
    });
  data["grind:Rosemary"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_solid.ob";
  item->factor = 50.0;
  item->func = ({
        (: $2->set_name("thyme") :),
        (: $2->set_short("ground thyme") :),
        (: $2->add_alias("plant") :),
        (: $2->add_plural( "plants" ) :),
        (: $2->add_adjective("ground") :),
        (: $2->set_long( "This is $pile_size$ of ground plant, "
                    "$amount_size$.  It smells "
                    "like it might've been thyme.\n") :),
        (: $2->set_medium_alias("GroundThyme") :),
        (: $2->set_decay_speed(0) :)
    });
  data["grind:Thyme"] = item;
}

mixed data_return_1() {
  item = new( class state_change );
  item->result = "/obj/reagents/generic_solid.ob";
  item->factor = 50.0;
  item->func = ({
        (: $2->set_name("basil") :),
        (: $2->set_short("ground basil") :),
        (: $2->add_alias("plant") :),
        (: $2->add_plural( "plants" ) :),
        (: $2->add_adjective("ground") :),
        (: $2->set_long( "This is $pile_size$ of ground plant, "
                    "$amount_size$.  It smells "
                    "like it might've been basil.\n") :),
        (: $2->set_medium_alias("GroundBasil") :),
        (: $2->set_decay_speed(0) :)
    });
  data["grind:Basil"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_solid.ob";
  item->factor = 50.0;
  item->func = ({
        (: $2->set_name("eyebright") :),
        (: $2->set_short("ground eyebright") :),
        (: $2->add_alias("plant") :),
        (: $2->add_plural( "plants" ) :),
        (: $2->add_adjective("ground") :),
        (: $2->set_long( "This is $pile_size$ of ground plant, "
                    "$amount_size$.  It smells "
                    "like it might've been eyebright.\n") :),
        (: $2->set_medium_alias("GroundEyebright") :),
        (: $2->set_decay_speed(0) :)
    });
  data["grind:Eyebright"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_solid.ob";
  item->factor = 0.05;
  item->func = ({
        (: $2->set_name("spider") :),
        (: $2->set_short("ground arachnid") :),
        (: $2->add_alias("arachnid") :),
        (: $2->add_adjective("ground") :),
        (: $2->set_long( "This is $pile_size$ of ground arachnid, "
                    "$amount_size$.  It looks "
                    "very chitinous.\n") :),
        (: $2->set_medium_alias("GroundSpider") :),
        (: $2->set_decay_speed(0) :)
    });
  data["grind:Spider"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_solid.ob";
  item->factor = 50.0;
  item->func = ({
        (: $2->set_name("fennel") :),
        (: $2->set_short("ground fennel") :),
        (: $2->add_alias(({"seed", "seeds"})) :),
        (: $2->add_adjective("ground") :),
        (: $2->set_long( "This is $pile_size$ of ground plant, "
                    "$amount_size$.  It looks "
                    "like it might've been fennel.\n") :),
        (: $2->set_medium_alias("GroundFennel") :),
        (: $2->set_decay_speed(0) :)
    });
  data["grind:Fennel"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_solid.ob";
  item->factor = 50.0;
  item->func = ({
        (: $2->set_name("carrot") :),
        (: $2->set_short("ground carrot") :),
        (: $2->add_adjective("ground") :),
        (: $2->set_long( "This is $pile_size$ of ground plant, "
                    "$amount_size$.  It looks "
                    "very orange.\n") :),
        (: $2->set_medium_alias("GroundCarrot") :),
        (: $2->set_decay_speed(0) :)
    });
  data["grind:CarRot"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_solid.ob";
  item->factor = 10.0;
  item->func = ({
        (: $2->set_name("eye") :),
          (: $2->add_alias("eyes") :),
        (: $2->set_short("ground eyes") :),
        (: $2->add_adjective("ground") :),
        (: $2->set_long( "This is $pile_size$ of ground plant, "
                    "$amount_size$.  It looks "
                    "very bloody.\n") :),
        (: $2->set_medium_alias("GroundBunnyEyeball") :),
        (: $2->set_decay_speed(0) :)
    });
  data["grind:BunnyEyeball"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_solid.ob";
  item->factor = 20.0;
  item->func = ({
        (: $2->set_name("crumbs") :),
        (: $2->set_short("molasses cookie crumbs") :),
        (: $2->add_adjective(({"molasses", "cookie"})) :),
        (: $2->set_long("This is some cookie crumbs.  Yum.\n") :),
        (: $2->set_medium_alias("GroundMolassesCookie") :),
        (: $2->set_decay_speed(0) :)
    });
  data["grind:MolassesCookie"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_solid.ob";
  item->factor = 10.0;
  item->func = ({
        (: $2->set_name("radish") :),
        (: $2->set_short("ground radish") :),
        (: $2->add_adjective("ground") :),
        (: $2->set_long( "This is $pile_size$ of ground plant, "
                    "$amount_size$.  It looks "
                    "very orange.\n") :),
        (: $2->set_medium_alias("GroundRadish") :),
        (: $2->set_decay_speed(0) :)
    });
  data["grind:Radish"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_solid.ob";
  item->factor = 10.0;
  item->func = ({
        (: $2->set_name("parsnip") :),
        (: $2->set_short("ground parsnip") :),
        (: $2->add_adjective("ground") :),
        (: $2->set_long( "This is $pile_size$ of ground plant, "
                    "$amount_size$.  It looks "
                    "a bit like a pile of pine sawdust.\n") :),
        (: $2->set_medium_alias("GroundParsnip") :),
        (: $2->set_decay_speed(0) :)
    });
  data["grind:Parsnip"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_solid.ob";
  item->factor = 50.0;
  item->func = ({
        (: $2->set_name("oregano") :),
        (: $2->set_short("ground oregano") :),
        (: $2->add_adjective("ground") :),
        (: $2->set_long( "This is $pile_size$ of ground plant, "
                    "$amount_size$.  It looks "
                    "very Genuan.\n") :),
        (: $2->set_medium_alias("GroundOregano") :),
        (: $2->set_decay_speed(0) :)
    });
  data["grind:Oregano"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_solid.ob";
  item->factor = 10.0;
  item->func = ({
        (: $2->set_name("foxglove") :),
        (: $2->set_short("ground foxglove") :),
        (: $2->add_adjective("ground") :),
        (: $2->add_alias( "plant" ) :),
        (: $2->add_plural( "plants" ) :),
        (: $2->set_long( "This is $pile_size$ of ground plant, "
          "$amount_size$.  You can tell it used to be foxglove by the "
          "little purple flowers scattered in with the green stuff.\n") :),
        (: $2->set_medium_alias("GroundFoxglove") :),
        (: $2->add_eat_effect( "/std/effects/ingested/cum_poison", 12 ) :),
        (: $2->set_decay_speed(0) :)
    });
  data["grind:Foxglove"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_solid.ob";
  item->factor = 50.0;
  item->func = ({
        (: $2->set_name("violet") :),
        (: $2->set_short("ground violet") :),
        (: $2->add_adjective("ground") :),
        (: $2->set_long( "This is $pile_size$ of ground plant, "
                    "$amount_size$.  It looks "
             "very, well, violet.\n") :),
        (: $2->set_medium_alias("GroundViolet") :),
        (: $2->set_decay_speed(0) :)
    });
  data["grind:Violet"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_solid.ob";
  item->factor = 10.0;
  item->func = ({
        (: $2->set_name("cabbage") :),
        (: $2->set_short("shredded cabbage") :),
        (: $2->add_adjective("shredded") :),
        (: $2->set_long( "This is $pile_size$ of shredded cabbage, "
                    "$amount_size$.  "
             "Hopefully, not a sentinent one.\n") :),
        (: $2->set_medium_alias("GroundCabbage") :),
        (: $2->set_decay_speed(0) :)
    });
  data["grind:Cabbage"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_solid.ob";
  item->factor = 50.0;
  item->func = ({
        (: $2->set_name( "peel" ) :),
        (: $2->set_short( "ground orange peel" ) :),
        (: $2->add_adjective( ({ "ground", "orange" }) ) :),
        (: $2->set_long( "This is $pile_size$ of ground orange peel, "
            "$amount_siuze$.  It is still "
            "a vibrant orange, the citric acid preserving both the colour "
            "and smell of the orange peel.\n" ) :),
        (: $2->set_medium_alias( "GroundOrangePeel" ) :),
        (: $2->set_decay_speed( 0 ) :)
    });
  data["grind:OrangePeel"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_solid.ob";
  item->factor = 1.0;
  item->func = ({
        (: $2->set_name( "belladonna" ) :),
        (: $2->set_short( "ground belladonna" ) :),
        (: $2->add_adjective( "ground" ) :),
        (: $2->add_alias( "plant" ) :),
        (: $2->add_plural( "plants" ) :),
        (: $2->set_long( "This is $pile_size$ of ground plant, "
            "$amount_size$.  It looks like it might've been belladonna.\n" ) :),
        (: $2->set_medium_alias( "GroundBelladonna" ) :),
        (: $2->add_eat_effect( "/std/effects/ingested/cum_poison", 12 ) :),
        (: $2->set_decay_speed( 0 ) :)
    });
  data["grind:Belladonna"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_solid.ob";
  item->factor = 1.0;
  item->func = ({
        (: $2->set_name( "hemlock" ) :),
        (: $2->set_short( "ground hemlock" ) :),
        (: $2->add_adjective( "ground" ) :),
        (: $2->add_alias( "plant" ) :),
        (: $2->add_plural( "plants" ) :),
        (: $2->set_long( "This is $pile_size$ of ground plant, "
            "$amount_size$.  It looks like it might've been hemlock.\n" ) :),
        (: $2->set_medium_alias( "GroundHemlock" ) :),
        (: $2->add_eat_effect( "/std/effects/ingested/cum_poison", 12 ) :),
        (: $2->set_decay_speed( 0 ) :)
    });
  data["grind:Hemlock"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_solid.ob";
  item->factor = 1.0;
  item->func = ({
        (: $2->set_name( "monkshood" ) :),
        (: $2->set_short( "ground monkshood" ) :),
        (: $2->add_adjective( "ground" ) :),
        (: $2->add_alias( "plant" ) :),
        (: $2->add_plural( "plants" ) :),
        (: $2->set_long( "This is $pile_size$ of ground plant, "
            "$amount_size$.  It looks like it might've been monkshood.\n" ) :),
        (: $2->set_medium_alias( "GroundMonkshood" ) :),
        (: $2->add_eat_effect( "/std/effects/ingested/cum_poison", 12 ) :),
        (: $2->set_decay_speed( 0 ) :)
    });
  data["grind:Monkshood"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_solid.ob";
  item->factor = 1.0;
  item->func = ({
        (: $2->set_name( "wormwood" ) :),
        (: $2->set_short( "ground wormwood" ) :),
        (: $2->add_adjective( "ground" ) :),
        (: $2->add_alias( "plant" ) :),
        (: $2->add_plural( "plants" ) :),
        (: $2->set_long( "This is $pile_size$ of ground plant, "
            "$amount_size$.  It looks like it might've been wormwood.\n") :),
        (: $2->set_medium_alias( "GroundWormwood" ) :),
        (: $2->add_eat_effect( "/std/effects/ingested/cum_poison", 12 ) :),
        (: $2->set_decay_speed( 0 ) :)
    });
  data["grind:Wormwood"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_solid.ob";
  item->factor = 1.0;
  item->func = ({
        (: $2->set_name( "bryony" ) :),
        (: $2->set_short( "ground bryony" ) :),
        (: $2->add_adjective( "ground" ) :),
        (: $2->add_alias( "plant" ) :),
        (: $2->add_plural( "plants" ) :),
        (: $2->set_long( "This is $pile_size$ of ground plant, "
            "$amount_size$.  It looks like it might've been bryony.\n" ) :),
        (: $2->set_medium_alias( "GroundBryony" ) :),
        (: $2->add_eat_effect( "/std/effects/ingested/cum_poison", 12 ) :),
        (: $2->set_decay_speed( 0 ) :)
    });
  data["grind:Bryony"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_solid.ob";
  item->factor = 1.0;
  item->func = ({
        (: $2->set_name( "achorion" ) :),
        (: $2->set_short( "ground achorion mould" ) :),
        (: $2->add_adjective( ({ "ground", "mould" }) ) :),
        (: $2->add_alias( "mould" ) :),
        (: $2->add_alias( "plant" ) :),
        (: $2->add_plural( "plants" ) :),
        (: $2->set_long( "This is $pile_size$ of ground plant, "
            "$amount_size$.  It looks like it might've been achorion mould.\n") :),
        (: $2->set_medium_alias( "GroundAchorionMould" ) :),
        (: $2->add_eat_effect( "/std/effects/ingested/cum_poison", 12 ) :),
        (: $2->set_decay_speed( 0 ) :)
    });
  data["grind:AchorionMould"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_solid.ob";
  item->factor = 1.0;
  item->func = ({
        (: $2->set_name( "trumpet" ) :),
        (: $2->set_short( "ground angel's trumpet" ) :),
        (: $2->add_adjective( ({ "ground", "angel's" }) ) :),
        (: $2->add_alias( "angel's" ) :),
        (: $2->add_alias( "plant" ) :),
        (: $2->add_plural( "plants" ) :),
        (: $2->set_long( "This is $pile_size$ of ground plant, "
            "$amount_size$.  It looks like it might've been angel's trumpet.\n") :),
        (: $2->set_medium_alias( "GroundAngelsTrumpet" ) :),
        (: $2->add_eat_effect( "/std/effects/ingested/cum_poison", 12 ) :),
        (: $2->set_decay_speed( 0 ) :)
    });
  data["grind:AngelsTrumpet"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_solid.ob";
  item->factor = 1.0;
  item->func = ({
        (: $2->set_name( "cereus" ) :),
        (: $2->set_short( "ground cereus" ) :),
        (: $2->add_adjective( "ground" ) :),
        (: $2->add_alias( "plant" ) :),
        (: $2->add_plural( "plants" ) :),
        (: $2->set_long( "This is $pile_size$ of ground plant, "
            "$amount_size$.  It looks like it might've been cereus.\n") :),
        (: $2->set_medium_alias( "GroundCereus" ) :),
        (: $2->add_eat_effect( "/std/effects/ingested/cum_poison", 12 ) :),
        (: $2->set_decay_speed( 0 ) :)
    });
  data["grind:Cereus"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_solid.ob";
  item->factor = 1.0;
  item->func = ({
        (: $2->set_name( "skullcap" ) :),
        (: $2->set_short( "ground skullcap" ) :),
        (: $2->add_adjective( "ground" ) :),
        (: $2->add_alias( "plant" ) :),
        (: $2->add_plural( "plants" ) :),
        (: $2->set_long( "This is $pile_size$ of ground plant, "
            "$amount_size$.  It looks like it might've been skullcap.\n") :),
        (: $2->set_medium_alias( "GroundSkullcap" ) :),
        (: $2->add_eat_effect( "/std/effects/ingested/cum_poison", 12 ) :),
        (: $2->set_decay_speed( 0 ) :)
    });
  data["grind:Skullcap"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_solid.ob";
  item->factor = 1.0;
  item->func = ({
        (: $2->set_name( "weed" ) :),
        (: $2->set_short( "ground tyler weed" ) :),
        (: $2->add_adjective( ({ "ground", "tyler" }) ) :),
        (: $2->add_alias( "tyler" ) :),
        (: $2->add_alias( "plant" ) :),
        (: $2->add_plural( "plants" ) :),
        (: $2->set_long( "This is $pile_size$ of ground plant, "
            "$amount_size$.  It looks like it might've been tyler weed.\n") :),
        (: $2->set_medium_alias( "GroundTylerWeed" ) :),
        (: $2->add_eat_effect( "/std/effects/ingested/cum_poison", 12 ) :),
        (: $2->set_decay_speed( 0 ) :)
    });
  data["grind:TylerWeed"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_solid.ob";
  item->factor = 1.0;
  item->func = ({
        (: $2->set_name( "skullcap" ) :),
        (: $2->set_short( "ground skullcap" ) :),
        (: $2->add_adjective( "ground" ) :),
        (: $2->add_alias( "plant" ) :),
        (: $2->add_plural( "plants" ) :),
        (: $2->set_long( "This is $pile_size$ of ground plant, "
            "$amount_size$.  It looks like it might've been skullcap.\n") :),
        (: $2->set_medium_alias( "GroundSkullcap" ) :),
        (: $2->add_eat_effect( "/std/effects/ingested/cum_poison", 12 ) :),
        (: $2->set_decay_speed( 0 ) :)
    });
  data["grind:Skullcap"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_solid.ob";
  item->factor = 1.0;
  item->func = ({
        (: $2->set_name( "skin" ) :),
        (: $2->set_short( "ground toad skin" ) :),
        (: $2->add_adjective( ({ "ground", "toad" }) ) :),
        (: $2->add_plural( "skins" ) :),
        (: $2->set_long( "This is $pile_size$ of ground skin, "
            "$amount_size$.  It looks like it might've originally belonged "
            "to a toad.\n") :),
        (: $2->set_medium_alias( "GroundToadSkin" ) :),
        (: $2->set_decay_speed( 0 ) :)
    });
  data["grind:SkinOfToad"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_solid.ob";
  item->factor = 0.5;
  item->func = ({
        (: $2->set_name( "duct" ) :),
        (: $2->set_short( "ground lion bile duct" ) :),
        (: $2->add_adjective( ({ "ground", "lion", "bile" }) ) :),
        (: $2->add_palias( "bile" ) :),
        (: $2->add_plural( "ducts" ) :),
        (: $2->set_long( "This is $pile_size$ of ground bile duct, "
            "$amount_size$.  It looks like it might've originally belonged "
            "to a lion.\n") :),
        (: $2->set_medium_alias( "GroundLionBileDuct" ) :),
        (: $2->set_decay_speed( 0 ) :)
    });
  data["grind:BileDuctOfLion"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_solid.ob";
  item->factor = 1.0;
  item->func = ({
        (: $2->set_name( "heart" ) :),
        (: $2->set_short( "ground wolf heart" ) :),
        (: $2->add_adjective( ({ "ground", "wolf" }) ) :),
        (: $2->add_plural( "hearts" ) :),
        (: $2->set_long( "This is $pile_size$ of ground heart, "
            "$amount_size$.  It looks like it might've originally belonged "
            "to a wolf.\n") :),
        (: $2->set_medium_alias( "GroundWolfHeart" ) :),
        (: $2->set_decay_speed( 0 ) :)
    });
  data["grind:HeartOfWolf"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_solid.ob";
  item->factor = 1.0;
  item->func = ({
        (: $2->set_name( "brain" ) :),
        (: $2->set_short( "ground bird brain" ) :),
        (: $2->add_adjective( ({ "ground", "bird" }) ) :),
        (: $2->add_plural( "brains" ) :),
        (: $2->set_long( "This is $pile_size$ of ground brain, "
            "$amount_size$.  It looks like it might've originally belonged "
            "to a bird.\n") :),
        (: $2->set_medium_alias( "GroundBirdBrain" ) :),
        (: $2->set_decay_speed( 0 ) :)
    });
  data["grind:BrainOfBird"] = item;
}

mixed data_return_2() {
  item = new( class state_change );
  item->result = "/obj/reagents/generic_solid.ob";
  item->factor = 1.0;
  item->func = ({
        (: $2->set_name( "brain" ) :),
        (: $2->set_short( "ground bird brain" ) :),
        (: $2->add_adjective( ({ "ground", "bird" }) ) :),
        (: $2->add_plural( "brains" ) :),
        (: $2->set_long( "This is $pile_size$ of ground brain, "
            "$amount_size$.  It looks like it might've originally belonged "
            "to a bird.\n") :),
        (: $2->set_medium_alias( "GroundBirdBrain" ) :),
        (: $2->set_decay_speed( 0 ) :)
    });
  data["grind:BrainOfChicken"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_solid.ob";
  item->factor = 1.0;
  item->func = ({
        (: $2->set_name( "brain" ) :),
        (: $2->set_short( "ground bird brain" ) :),
        (: $2->add_adjective( ({ "ground", "bird" }) ) :),
        (: $2->add_plural( "brains" ) :),
        (: $2->set_long( "This is $pile_size$ of ground brain, "
            "$amount_size$.  It looks like it might've originally belonged "
            "to a bird.\n") :),
        (: $2->set_medium_alias( "GroundBirdBrain" ) :),
        (: $2->set_decay_speed( 0 ) :)
    });
  data["grind:BrainOfDuck"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_solid.ob";
  item->factor = 0.5;
  item->func = ({
        (: $2->set_name( "brain" ) :),
        (: $2->set_short( "ground bird brain" ) :),
        (: $2->add_adjective( ({ "ground", "bird" }) ) :),
        (: $2->add_plural( "brains" ) :),
        (: $2->set_long( "This is $pile_size$ of ground brain, "
            "$amount_size$.  It looks like it might've originally belonged "
            "to a bird.\n") :),
        (: $2->set_medium_alias( "GroundBirdBrain" ) :),
        (: $2->set_decay_speed( 0 ) :)
    });
  data["grind:BrainOfDuckling"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_solid.ob";
  item->factor = 1.0;
  item->func = ({
        (: $2->set_name( "brain" ) :),
        (: $2->set_short( "ground bird brain" ) :),
        (: $2->add_adjective( ({ "ground", "bird" }) ) :),
        (: $2->add_plural( "brains" ) :),
        (: $2->set_long( "This is $pile_size$ of ground brain, "
            "$amount_size$.  It looks like it might've originally belonged "
            "to a bird.\n") :),
        (: $2->set_medium_alias( "GroundBirdBrain" ) :),
        (: $2->set_decay_speed( 0 ) :)
    });
  data["grind:BrainOfParrot"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_solid.ob";
  item->factor = 1.0;
  item->func = ({
        (: $2->set_name( "brain" ) :),
        (: $2->set_short( "ground bird brain" ) :),
        (: $2->add_adjective( ({ "ground", "bird" }) ) :),
        (: $2->add_plural( "brains" ) :),
        (: $2->set_long( "This is $pile_size$ of ground brain, "
            "$amount_size$.  It looks like it might've originally belonged "
            "to a bird.\n") :),
        (: $2->set_medium_alias( "GroundBirdBrain" ) :),
        (: $2->set_decay_speed( 0 ) :)
    });
  data["grind:BrainOfPeacock"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_solid.ob";
  item->factor = 1.0;
  item->func = ({
        (: $2->set_name( "brain" ) :),
        (: $2->set_short( "ground bird brain" ) :),
        (: $2->add_adjective( ({ "ground", "bird" }) ) :),
        (: $2->add_plural( "brains" ) :),
        (: $2->set_long( "This is $pile_size$ of ground brain, "
            "$amount_size$.  It looks like it might've originally belonged "
            "to a bird.\n") :),
        (: $2->set_medium_alias( "GroundBirdBrain" ) :),
        (: $2->set_decay_speed( 0 ) :)
    });
  data["grind:BrainOfVulture"] = item;
  item = new( class state_change );
  item->result = "/obj/food/sweets/sugar.food";
  item->factor = 5.0;
  item->func = ({ });
  data["grind:SugarCube"] = item;
  item = new( class state_change );
  item->result = "/obj/food/sweets/brown_sugar.food";
  item->factor = 5.0;
  item->func = ({ });
  data["grind:SugarLump"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_solid.ob";
  item->factor = 0.25;
  item->func = ({
        (: $2->set_name( "powder" ) :),
        (: $2->set_short( "grainy orange powder" ) :),
        (: $2->add_adjective( ({ "grainy", "orange" }) ) :),
        (: $2->add_plural( "powders" ) :),
        (: $2->set_long( "This is $pile_size$ of grainy orange powder, "
            "$amount_size$.  It looks like it might've originally been "
            "solid drain cleaner.\n") :),
        (: $2->set_medium_alias( "GroundDrainCleaner" ) :),
        (: $2->set_decay_speed( 0 ) :)
    });
  data["grind:DrainCleaner"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/water.ob";
  item->factor = 1.0;
  item->func = ({});
  data["heat:Water"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_liquid.ob";
  item->factor = 0.5;
  item->func = ({
      (: $2->set_name( "steeped_achorion" ) :),
      (: $2->set_short( "purple-grey liquid" ) :),
      (: $2->add_adjective( ({ "purple-grey", "liquid" }) ) :),
      (: $2->set_long( "This is $amount_size$ of some purple-grey liquid.\n" ) :),
      (: $2->set_medium_alias( "UndistilledAchorionPurple" ) :),
    });
  data["heat:UnheatedAchorionPurple"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/con_poison.ob";
  item->factor = 0.1;
  item->func = ({ (: $2->add_eat_effect( "/std/effects/poisons/con_new",
    to_int( $3->query_skill_bonus( "covert.items.poisons" ) ) ) :) });
  data["heat:UnheatedWeakConPoison"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/con_poison.ob";
  item->factor = 0.1;
  item->func = ({ (: $2->add_eat_effect( "/std/effects/poisons/con_new",
    to_int( $3->query_skill_bonus( "covert.items.poisons" ) * 10 ) ) :) });
  data["heat:UnheatedConPoison"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/confuse_poison.ob";
  item->factor = 0.1;
  item->func = ({ (: $2->add_eat_effect( "/std/effects/poisons/confuse",
    to_int( $3->query_skill_bonus( "covert.items.poisons" ) * 10 ) ) :) });
  data["heat:UnheatedConfusePoison"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/smokebomb.ob";
  item->factor = 0.5;
  item->func = ({ (: $2->add_eat_effect( "/std/effects/poisons/smokebomb",
    to_int( $3->query_skill_bonus( "covert.items.poisons" ) ) ) :) });
  data["heat:UnheatedSmokeBomb"] = item;
  item = new( class state_change );
  item->result = "/w/taffyd/reagents/caramelised_sugar.food";
  item->factor = 6.4;
  item->func = ({});
  item->playtester = 1;
  data["heat:SuGar"] = item;
  item = new( class state_change );
  item->result = "/w/taffyd/reagents/disgusting_brown_lump.food";
  item->factor = 0.15625;
  item->func = ({ });
  item->playtester = 1;
  data["heat:CaramelisedSugar"] = item;
  item = new( class state_change );
  item->result = "/obj/food/sweets/toffee.food";
  item->factor = 1.0;
  item->func = ({});
  item->playtester = 1;
  data["heat:BrownSugar"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_liquid.ob";
  item->factor = 0.5;
  item->func = ({
  (: $2->set_name("liquid") :),
  (: $2->set_short("cloudy yellowish liquid") :),
  (: $2->set_long("This is a cloudy, yellowish liquid, with faint "
      "traces of red swirls.\n") :),
  (: $2->add_adjective(({ "cloudy", "yellowish", "yellow" })) :)
});
  data["juice:snake left eye"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_liquid.ob";
  item->factor = 0.5;
  item->func = ({
  (: $2->set_name( "juice" ) :),
  (: $2->set_short( "jelly orange juice" ) :),
  (: $2->add_adjective( ({ "jelly", "orange" }) ) :),
  (: $2->set_long( "This is a delicious looking juice that "
      "appears to have been made from juicing up a jelly orange.\n" ) :),
  (: $2->set_medium_alias( "JellyOrangeJuice" ) :),
});
  data["juice:JellyOrange"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_liquid.ob";
  item->factor = 1.0;
  item->func = ({
  (: $2->set_name( "juice" ) :),
  (: $2->set_short( "apple juice" ) :),
        (: $2->set_main_plural( "apple juices" ) :),
        (: $2->add_plural( "juices" ) :),
  (: $2->add_adjective( "apple" ) :),
  (: $2->set_long( "This is some transparent golden-brown "
                  "juice made from apples, "
                  "$amount_size$.\n" ) :),
  (: $2->set_medium_alias( "AppleJuice" ) :),
});
  data["juice:Apple"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_liquid.ob";
  item->factor = 1.0;
  item->func = ({
        (: $2->set_name( "blackheart_juice" ) :),
        (: $2->set_short( "apple juice" ) :),
        (: $2->set_main_plural( "apple juices" ) :),
        (: $2->add_plural( "juices" ) :),
        (: $2->add_alias( "juice" ) :),
        (: $2->add_adjective( "apple" ) :),
        (: $2->set_long( "This is some dark, treacly, "
                        "sweet-smelling apple juice, "
                        "$amount_size$.\n" ) :),
        (: $2->set_medium_alias( "BlackheartJuice" ) :),
});
  data["juice:LancreBlackheart"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_liquid.ob";
  item->factor = 1.0;
  item->func = ({
        (: $2->set_name( "disagreeable_juice" ) :),
        (: $2->set_short( "apple juice" ) :),
        (: $2->set_main_plural( "apple juices" ) :),
        (: $2->add_plural( "juices" ) :),
        (: $2->add_alias( "juice" ) :),
        (: $2->add_adjective( "apple" ) :),
        (: $2->set_long( "This is some thin and watery "
                        "sour-smelling apple juice, "
                        "$amount_size$.\n" ) :),
        (: $2->set_medium_alias( "DisagreeableJuice" ) :),
});
  data["juice:GoldenDisagreeable"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_liquid.ob";
  item->factor = 1.0;
  item->func = ({
        (: $2->set_name( "billet_juice" ) :),
        (: $2->set_short( "apple juice" ) :),
        (: $2->set_main_plural( "apple juices" ) :),
        (: $2->add_plural( "juices" ) :),
        (: $2->add_alias( "juice" ) :),
        (: $2->add_adjective( "apple" ) :),
        (: $2->set_long( "This is some evil coloured, "
                        "bitter-smelling apple juice, "
                        "$amount_size$.\n" ) :),
        (: $2->set_medium_alias( "BilletJuice" ) :),
        (: $2->add_eat_effect( "/std/effects/ingested/nausea", 50 ) :),
});
  data["juice:GreenBillet"] = item;
  item = new( class state_change );
  item->result = "/std/object";
  item->factor = 1.1;
  item->func = ({
        (: $2->set_name("ice") :),
        (: $2->set_short("ice") :),
        (: $2->set_long("This is a chunk of ice.\n") :)
    });
  data["freeze:Water"] = item;
  item = new( class state_change );
  item->result = "/obj/food";
  item->factor = 0.9;
  item->func = ({
      (: $2->set_name( "potato" ) :),
      (: $2->set_short( "peeled potato" ) :),
      (: $2->add_adjective("peeled") :),
      (: $2->set_long( "This is a raw, peeled potato, ready for what next you do.\n" ) :),
      (: $2->set_medium_alias( "PeeledPotato" ) :),
      (: $2->set_decay_speed( 0 ) :)
   });
  data["peel:Potato"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_liquid.ob";
  item->factor = 0.1;
  item->func = ({
      (: $2->set_name( "spider_poison" ) :),
      (: $2->set_short( "pale red liquid" ) :),
      (: $2->add_adjective( ({ "pale", "red", "liquid" }) ) :),
      (: $2->set_long( "This is $amount_size$ of some pale red liquid.\n" ) :),
      (: $2->set_medium_alias( "UndistilledSpiderPoison" ) :),
      (: $2->add_eat_effect( "/std/effects/poisons/spider_venom",
        to_int( $3->query_skill_bonus( "covert.items.poisons" ) / 10 ) ) :),
    });
  data["press:PoisonGlandOfSpider"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_liquid.ob";
  item->factor = 0.1;
  item->func = ({
      (: $2->set_name( "blowfish_poison" ) :),
      (: $2->set_short( "pale brown liquid" ) :),
      (: $2->add_adjective( ({ "pale", "brown", "liquid" }) ) :),
      (: $2->set_long( "This is $amount_size$ of some pale brown liquid.\n" ) :),
      (: $2->set_medium_alias( "UndistilledBlowfishPoison" ) :),
      (: $2->add_eat_effect( "/std/effects/poisons/bloat",
        to_int( $3->query_skill_bonus( "covert.items.poisons" ) / 10 ) ) :),
    });
  data["press:PoisonSacOfBlowfish"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_liquid.ob";
  item->factor = 0.1;
  item->func = ({
      (: $2->set_name( "snake_poison" ) :),
      (: $2->set_short( "thin white liquid" ) :),
      (: $2->add_adjective( ({ "thin", "white", "liquid" }) ) :),
      (: $2->set_long( "This is $amount_size$ of some thin white liquid.\n" ) :),
      (: $2->set_medium_alias( "UndistilledSnakePoison" ) :),
      (: $2->add_eat_effect( "/std/effects/ingested/poison",
        to_int( $3->query_skill_bonus( "covert.items.poisons" ) ) ) :),
    });
  data["press:PoisonSacOfSnake"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_solid.ob";
  item->factor = 50.0;
  item->func = ({
      (: $2->set_name( "venom" ) :),
      (: $2->set_short( "yellow powder" ) :),
      (: $2->add_alias( "powder" ) :),
      (: $2->add_adjective( "yellow" ) :),
      (: $2->set_long( "This is some yellow powder.\n" ) :),
      (: $2->set_medium_alias( "PoisonVenom" ) :),
      (: $2->add_eat_effect("/std/effects/ingested/cum_poison", 16) :),
      (: $2->add_eat_effect("/std/effects/ingested/basic_healing", 4) :),
      (: $2->set_decay_speed( 0 ) :)
   });
  data["pulverise:Venom"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_solid.ob";
  item->factor = 50.0;
  item->func = ({
        (: $2->set_name("Catalyst") :),
        (: $2->set_short("white powder") :),
        (: $2->add_alias("powder") :),
        (: $2->add_adjective("white") :),
        (: $2->set_long("This is some white powder.\n") :),
        (: $2->set_medium_alias("PoisonCatalyst") :),
        (: $2->add_eat_effect("/std/effects/ingested/cum_poison", 12) :),
        (: $2->add_eat_effect("/std/effects/ingested/basic_healing", 2) :),
        (: $2->set_decay_speed(0) :)
    });
  data["pulverise:Catalyst"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_solid.ob";
  item->factor = 50.0;
  item->func = ({
        (: $2->set_name("fang") :),
        (: $2->set_short("black powder") :),
        (: $2->add_alias("powder") :),
        (: $2->add_adjective("black") :),
        (: $2->set_long("This is some black powder.\n") :),
        (: $2->set_medium_alias("PoisonFang") :),
        (: $2->set_decay_speed(0) :)
    });
  data["pulverise:Fang"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_solid.ob";
  item->factor = 50.0;
  item->func = ({
        (: $2->set_name("leaf") :),
        (: $2->set_short("green powder") :),
        (: $2->add_alias("powder") :),
        (: $2->add_adjective("green") :),
        (: $2->set_long("This is some green powder.\n") :),
        (: $2->set_medium_alias("PoisonLeaf") :),
        (: $2->set_decay_speed(0) :)
    });
  data["pulverise:Leaf"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/sulphur_powder.ob";
  item->factor = 10.0;
  item->func = ({});
  data["pulverise:SulphurBlock"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_liquid.ob";
  item->factor = 1.0;
  item->func = ({
   (: $2->set_name("alexander") :),
   (: $2->set_short("brandy Alexander") :),
   (: $2->add_adjective( "brandy" ) :),
   (: $2->add_alias( ({ "brandy", "cocktail" }) ) :),
   (: $2->set_long("A creamy brandy Alexander cocktail, full "
             "of brandy, cream and chocolate liqueur goodness.  "
             "It looks perfect.\n") :),
   (: $2->add_eat_effect( "/std/effects/ingested/drunk", 800 ) :),
   (: $2->set_medium_alias( "BrandyAlexander" ) :)
});
  data["shake:UnshakenBrandyAlexander"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_liquid.ob";
  item->factor = 1.0;
  item->func = ({
   (: $2->set_name( "cosmopilitian" ) :),
   (: $2->set_short( "Cosmopilitian" ) :),
   (: $2->add_alias( "cocktail" ) :),
   (: $2->set_long( "The perfect Cosmopilitian cocktail.  For "
             "is it not written, \"Things always look better "
             "through the bottom of an empty glass.\"?\n" ) :),
   (: $2->add_eat_effect( "/std/effects/ingested/drunk", 800 ) :),
   (: $2->set_medium_alias( "Cosmopilitian" ) :),
});
  data["shake:UnshakenCosmopilitian"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_liquid.ob";
  item->factor = 1.0;
  item->func = ({
   (: $2->set_name( "morporkian" ) :),
   (: $2->set_short( "Morporkian" ) :),
   (: $2->add_alias( "cocktail" ) :),
   (: $2->set_long( "The perfect Morporkian, in drink form.  "
             "This drink does not contain blood, vomit or "
             "sharp knives.\n" ) :),
   (: $2->add_eat_effect( "/std/effects/ingested/drunk", 800 ) :),
   (: $2->set_medium_alias( "Morporkian" ) :),
});
  data["shake:UnshakenMorporkian"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_liquid.ob";
  item->factor = 1.0;
  item->func = ({
   (: $2->set_name( "carriage" ) :),
   (: $2->set_short( "Sidecarriage" ) :),
   (: $2->add_alias( "cocktail" ) :),
   (: $2->add_adjective( "side" ) :),
   (: $2->set_long( "A Sidecarriage cocktail, just "
             "the drink for a smooth ride.\n" ) :),
   (: $2->add_eat_effect( "/std/effects/ingested/drunk", 800 ) :),
   (: $2->set_medium_alias( "SideCarriage" ) :),
});
  data["shake:UnshakenSideCarriage"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_liquid.ob";
  item->factor = 1.0;
  item->func = ({
   (: $2->set_name( "daiquiri" ) :),
   (: $2->set_short( "Bananana Daiquiri" ) :),
   (: $2->add_alias( "cocktail" ) :),
   (: $2->add_adjective( "bananana" ) :),
   (: $2->set_long( "Mmm, full of mon... ape-y goodness.\n" ) :),
   (: $2->add_eat_effect( "/std/effects/ingested/drunk", 800 ) :),
   (: $2->set_medium_alias( "BananaDaiquiri" ) :),
});
  data["shake:UnshakenBananaDaiquiri"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_liquid.ob";
  item->factor = 1.0;
  item->func = ({
   (: $2->set_name( "lady" ) :),
   (: $2->set_short( "Shady Lady" ) :),
   (: $2->add_alias( "cocktail" ) :),
   (: $2->add_adjective( "shady" ) :),
   (: $2->set_long( "An Shady Lady.  For some reason, this "
                  "cocktail seems a little... distasteful, even though "
                  "it smells delicious.\n" ) :),
   (: $2->add_eat_effect( "/std/effects/ingested/drunk", 800 ) :),
   (: $2->set_medium_alias( "ShadyLady" ) :),
});
  data["shake:UnshakenShadyLady"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_liquid.ob";
  item->factor = 1.0;
  item->func = ({
   (: $2->set_name( "dwarf" ) :),
   (: $2->set_short( "Well Greased Dwarf" ) :),
   (: $2->add_alias( "cocktail" ) :),
   (: $2->add_adjective( ({ "well", "greased" }) ) :),
   (: $2->set_long( "An Well Greased Dwarf.  The cocktail "
                  "seems short, dark and likely to put you in a vile "
                  "temper.\n" ) :),
   (: $2->add_eat_effect( "/std/effects/ingested/drunk", 800 ) :),
   (: $2->set_medium_alias( "WellGreasedDwarf" ) :),
});
  data["shake:UnshakenWellGreasedDwarf"] = item;
}

mixed data_return_3() {
  item = new( class state_change );
  item->result = "/obj/reagents/generic_solid.ob";
  item->factor = 1.0;
  item->func = ({
      (: $2->set_name( "carrot" ) :),
      (: $2->set_short( "sliced carrot" ) :),
      (: $2->add_adjective( "sliced" ) :),
      (: $2->set_long( "This is some sliced carrots, little "
            "orange rings around lighter orange circles.\n" ) :),
      (: $2->set_medium_alias( "SlicedCarrot" ) :),
      (: $2->set_decay_speed( 0 ) :)
   });
  data["slice:Carrot"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_solid.ob";
  item->factor = 1.0;
  item->func = ({
        (: $2->set_name("cabbage") :),
        (: $2->set_short("shredded cabbage") :),
        (: $2->add_adjective("shredded") :),
        (: $2->set_long("This is some shredded cabbage.  "
             "Hopefully, not a sentinent one.\n") :),
        (: $2->set_medium_alias("GroundCabbage") :),
        (: $2->set_decay_speed(0) :)
    });
  data["slice:Cabbage"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_solid.ob";
  item->factor = 1.0;
  item->func = ({
      (: $2->set_name( "rhubarb" ) :),
      (: $2->set_short( "sliced rhubarb" ) :),
      (: $2->add_adjective( "sliced" ) :),
      (: $2->set_long( "This is some sliced rhubarb, sweet little chunks "
          "perfect for a nice pie.\n" ) :),
      (: $2->set_medium_alias( "SlicedRhubarb" ) :),
      (: $2->set_decay_speed( 0 ) :)
   });
  data["slice:Rhubarb"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_solid.ob";
  item->factor = 1.0;
  item->func = ({
      (: $2->set_name( "onion" ) :),
      (: $2->set_short( "sliced onion" ) :),
      (: $2->add_adjective( "sliced" ) :),
      (: $2->set_long( "This is some finely sliced onions.  How very sad...  "
             "could make a bloke break down and sob...\n" ) :),
      (: $2->set_medium_alias( "SlicedOnion" ) :),
      (: $2->set_decay_speed( 0 ) :)
   });
  data["slice:Onion"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_solid.ob";
  item->factor = 1.0;
  item->func = ({
      (: $2->set_name( "parsnip" ) :),
      (: $2->set_short( "sliced parsnip" ) :),
      (: $2->add_adjective( "sliced" ) :),
      (: $2->set_long( "This is some parsnip slices, white and hot.\n" ) :),
      (: $2->set_medium_alias( "SlicedParsnip" ) :),
      (: $2->set_decay_speed( 0 ) :)
   });
  data["slice:Parsnip"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_solid.ob";
  item->factor = 1.0;
  item->func = ({
      (: $2->set_name( "tomato" ) :),
      (: $2->set_short( "sliced tomato" ) :),
      (: $2->add_adjective( "sliced" ) :),
      (: $2->set_long( "This is some sliced tomato, perfect for a sandwich, "
          "but needing more slicing for other purposes.\n" ) :),
      (: $2->set_medium_alias( "SlicedTomato" ) :),
      (: $2->set_decay_speed( 0 ) :)
   });
  data["slice:Tomato"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_solid.ob";
  item->factor = 1.0;
  item->func = ({
      (: $2->set_name( "tomato" ) :),
      (: $2->set_short( "chopped tomato" ) :),
      (: $2->add_adjective( "chopped" ) :),
      (: $2->set_long( "This is some chopped tomato, suitable for cooking.\n" ) :),
      (: $2->set_medium_alias( "ChoppedTomato" ) :),
      (: $2->set_decay_speed( 0 ) :)
   });
  data["slice:SlicedTomato"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_solid.ob";
  item->factor = 1.0;
  item->func = ({
      (: $2->set_name( "potato" ) :),
      (: $2->set_short( "potato chunks" ) :),
      (: $2->add_alias(({"potato chunks", "potato chunk", "chunk", "chunks"})) :),
      (: $2->set_long( "These are some potato chunks.  They could do with "
          "some cooking ere they are eaten.\n" ) :),
      (: $2->set_medium_alias( "PotatoChunks" ) :),
      (: $2->set_decay_speed( 0 ) :)
   });
  data["slice:PeeledPotato"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_solid.ob";
  item->factor = 1.0;
  item->func = ({
      (: $2->set_name( "celery" ) :),
      (: $2->set_short( "sliced celery" ) :),
      (: $2->add_adjective( "sliced" ) :),
      (: $2->set_long( "This is some sliced celery, perfect for a nice "
          "soup or stew.\n" ) :),
      (: $2->set_medium_alias( "SlicedCelery" ) :),
      (: $2->set_decay_speed( 0 ) :)
   });
  data["slice:Celery"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_solid.ob";
  item->factor = 1.0;
  item->func = ({
      (: $2->set_name( "radish" ) :),
      (: $2->set_short( "sliced radish" ) :),
      (: $2->add_adjective( "sliced" ) :),
      (: $2->set_long( "This is some sliced radish, the decorative vegetable.\n" ) :),
      (: $2->set_medium_alias( "SlicedRadish" ) :),
      (: $2->set_decay_speed( 0 ) :)
   });
  data["slice:Radish"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_solid.ob";
  item->factor = 1.0;
  item->func = ({
      (: $2->set_name( "cucumber" ) :),
      (: $2->set_short( "cucumber slices" ) :),
      (: $2->add_alias(({"cucumber slices", "cucumber slice", "slice", "slices"})) :),
      (: $2->add_adjective( "sliced" ) :),
      (: $2->set_long( "These are the remains of a once mighty cucumber, now sliced.  "
          "Tis a great pity.\n" ) :),
      (: $2->set_medium_alias( "SlicedCucumber" ) :),
      (: $2->set_decay_speed( 0 ) :)
   });
  data["slice:Cucumber"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_solid.ob";
  item->factor = 1.0;
  item->func = ({
      (: $2->set_name( "apple" ) :),
      (: $2->set_short( "sliced apple" ) :),
      (: $2->add_adjective( "sliced" ) :),
      (: $2->set_long( "This is some sliced apple, sweet and delicious.\n" ) :),
      (: $2->set_medium_alias( "SlicedApple" ) :),
      (: $2->set_decay_speed( 0 ) :)
   });
  data["slice:Apple"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_solid.ob";
  item->factor = 1.0;
  item->func = ({
      (: $2->set_name( "banana" ) :),
      (: $2->set_short( "sliced banana" ) :),
      (: $2->add_adjective( "sliced" ) :),
      (: $2->set_long( "This is some sliced banana.  It would go "
           "down a treat on buttered toast.\n" ) :),
      (: $2->set_medium_alias( "SlicedBanana" ) :),
      (: $2->set_decay_speed( 0 ) :)
   });
  data["slice:Banana"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_ore.ob";
  item->factor = 0.75;
  item->func = ({
        (: $2->set_name("ore") :),
        (: $2->set_short("refined iron ore") :),
        (: $2->add_adjective(({"refined", "iron"})) :),
        (: $2->set_long("This is $pile_size$ of refined iron ore, "
                        "$amount_size$.\n" ) :),
        (: $2->set_material("refined iron ore") :),
        (: $2->set_material("refined iron ore") :),
        (: $2->set_medium_alias("RefinedIronOre") :)
    });
  data["smelt:RedHotRawIronOre"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_ore.ob";
  item->factor = 0.75;
  item->func = ({
        (: $2->set_name("bloom") :),
        (: $2->set_short("pig of iron bloom") :),
        (: $2->add_adjective(({"pig", "of", "iron"})) :),
        (: $2->add_property("determinate", "a ") :),
        (: $2->add_alias("pig") :),
        (: $2->add_alias("iron") :),
        (: $2->set_material("iron bloom") :),
        (: $2->set_long("This is a lump of crude iron.\n") :),
        (: $2->set_medium_alias("IronBloom") :),
        (: $2->reset_continuous() :)
    });
  data["smelt:RedHotRefinedIronOre"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_ore.ob";
  item->factor = 0.5;
  item->func = ({
        (: $2->set_name("ingot") :),
        (: $2->set_short("wrought iron ingot") :),
        (: $2->add_adjective(({"wrought", "iron"})) :),
        (: $2->add_property("determinate", "a ") :),
        (: $2->add_alias("iron") :),
        (: $2->set_material("wrought iron") :),
        (: $2->set_long("This is an ingot of wrought iron.\n") :),
        (: $2->set_medium_alias("WroughtIron") :),
        (: $2->reset_continuous() :)
    });
  data["hammer:RedHotIronBloom"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_solid.ob";
  item->factor = 1.0;
  item->func = ({ (:
   $2->set_decay_speed(0),
   $2->set_medium_alias( "SmokeCrystals" ),
   $2->set_name( "smoke_crystal" ),
   $2->set_short( "tiny gray crystals" ),
   $2->set_main_plural( "tiny gray crystals" ),
   $2->set_weight_unit( ({ 1, 50 }) ),
   $2->add_alias( ({ "crystal", "crystals" }) ),
   $2->add_adjective( ({ "tiny", "gray" }) ),
   $2->set_long( "This is $pile_size$ of tiny, dark gray crystals, "
     "$amount_size$.  The individual crystals catch the light on "
     "their facets, and the pile seems to swirl, like smoke.\n" )
:) });
  data["grind:SmokeRock"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_solid.ob";
  item->factor = 1.0;
  item->func = ({ (:
   $2->set_decay_speed(0),
   $2->set_medium_alias( "CoatedSmokeCrystals" ),
   $2->set_name( "coated_smoke_crystals" ),
   $2->add_alias( "crystals" ),
   $2->set_short( "powdery black crystals" ),
   $2->add_adjective( ({ "powdery", "black" }) ),
   $2->set_long( "This is $pile_size$ of black crystals, about "
     "$amount_size$.  The crystals are covered in fine black powder.\n" )
:) });
  data["air-dry:DampCoatedSmokeCrystals"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_solid.ob";
  item->factor = 1.0;
  item->func = ({ (:
   $2->set_decay_speed(0),
   $2->set_medium_alias( "InertSmokeCrystals" ),
   $2->set_name( "inert_smoke_crystals" ),
   $2->add_alias( "crystals" ),
   $2->set_short( "powdery black crystals" ),
   $2->add_adjective( ({ "powdery", "black" }) ),
   $2->set_long( "This is $pile_size$ of black crystals, about "
     "$amount_size$.  The crystals are covered in fine black powder.\n" )
:) });
  data["air-dry:DampInertSmokeCrystals"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/water.ob";
  item->factor = 1.0;
  item->func = ({});
  data["steep:Water"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_liquid.ob";
  item->factor = 1.0;
  item->func = ({
      (: $2->set_name( "liquid" ) :),
      (: $2->set_short( "darker milky acrid liquid" ) :),
      (: $2->add_adjective( ({ "darker", "milky", "acrid", "liquid" }) ) :),
      (: $2->set_long( "This is $amount_size$ of some darker milky acrid liquid.\n" ) :),
      (: $2->set_medium_alias( "SteepedCereus" ) :),
    });
  data["steep:CereusTea"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/generic_liquid.ob";
  item->factor = 1.0;
  item->func = ({
      (: $2->set_name( "liquid" ) :),
      (: $2->set_short( "dark azure liquid" ) :),
      (: $2->add_adjective( ({ "dark", "azure", "liquid" }) ) :),
      (: $2->set_long( "This is $amount_size$ of some dark azure liquid.\n" ) :),
      (: $2->set_medium_alias( "SteepedSkullcap" ) :),
    });
  data["steep:SkullcapTea"] = item;
  item = new( class state_change );
  item->result = "/obj/reagents/intelligence_tea.ob";
  item->factor = 0.8;
  item->func = ({
    (: $2->add_eat_effect( "/std/effects/ingested/int_bonus" ) :)
  });
  data["featherstir:SageTea"] = item;
  item = new( class state_change );
  item->result = "/obj/food/grains/wheat_berry.food";
  item->factor = 8;
  item->func = ({ });
  data["thresh:Wheat"] = item;
}

mixed data_return() {
  data_return_0();
  data_return_1();
  data_return_2();
  data_return_3();
  return data;
}
// --- END [/mnt/home2/grok/lib/obj/state_change/base.hdr_dc.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/search.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/search.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627780   Available: 13575134
Inodes: Total: 5242880    Free: 4960133
1939 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/search.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627780   Available: 13575134
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h"
inherit "/std/room/basic_room";

string *keywords;

void setup() {
   mixed search_result;
   string word;
   
   set_short( "primary search room" );
   add_property( "determinate", "the " );
   set_long( "Welcome to the first room for doing keyword searches.  "
            "Take an exit to narrow the search to that keyword.  If less than "
            "five rooms or objects fit the keywords there will also be exits "
            "directly to them.\n" );
   /* set_light sets the amount of light the room has.  See help light
    * for a list of what the number means:)
    */
   set_light( 50 );

   search_result = SEARCH->get_keywords( ({ }) );
   keywords = search_result[ 0 ];
   foreach( word in keywords ) { 
      add_exit( word, "??", "path" );
   }
   add_exit( "exit", ENTRANCE, "door" );

   /* add_property is used to add a value to an object, that can later be
    * queried for with query_property.
    * The "commented functions" and "keywords" properties are specific for 
    * rooms in the learning domain and is used to make it possible to search
    * for subjects. 
    * See /d/learning/handlers/search.c for the way this is done.
    */
   add_property( "commented functions", 
                ({ "add_exit", "set_destination" }) );
   add_property( "keywords", ({ "virtual", "room" }) );
   /* Do not try to add this room to the map_handler
    */
   add_property( "no map", 1 );
} /* setup() */

/* set_destination is called whenever an exit is checked.  
 * The search handler will see if there's already a room defined by the 
 * keywords, and if not, it'll make one.
 */
void set_destination( string keyword ) {
   if( member_array( keyword, ({ "exit", "back", "a", "b", "c", "d", "e" }) ) != -1 )
      /* the exit is not to a keyword, and don't need recalculation */
      return; 
   modify_exit( keyword, ({ "dest", SEARCH->find_room( ({ keyword }) ) }) );
} /* set_destination() */

// --- END [/mnt/home2/grok/lib/d/learning/search.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/master.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/master.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627779   Available: 13575133
Inodes: Total: 5242880    Free: 4960133
2398 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/master.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627779   Available: 13575133
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#define LORD "taffyd"
#define DOMAIN "learning"

/*
 * Beware editing this file.
 * Make sure you know what you are doing.  Stuffing this up could be
 * fatal in some ways.
 */

inherit "/std/dom/base_master";

string info = "";

string query_lord() {
  return LORD;
}

string author_file(string *path) {
  return capitalize(DOMAIN);
}

int check_permission(string euid, string *path, int mask) {
  if (euid == query_lord())
    return 1;
  return ::check_permission(euid, path, mask);
}

/* Allow ftp downloads and copies with only read permission */
int copy_with_read(string path, string euid, string func) {
  return 1;
}

/*
 * By default, use the valid_read()/valid_write() functions defined in the
 * inherited file /std/dom/base_master.c.
 * These default to reading allowed for everyone, writing only allowed
 * for independent creators and the domain lord.
 * This is all overridden by the check_permission() function
 * which is called first, which should be used instead.

int valid_read(string *path, string euid, string funct);

int valid_write(string *path, string euid, string funct) {
  if ((sizeof(path) >= 3) && (path[2] == "master.c" || path[2] == "master.o" ||
                              path[2] == "master")){
    return 0;
  }
  
  if(path[2] == "cutnpaste" && master()->query_senior(euid)){
    return 1;
  }
  
  return (members[euid] != 0);
}
*/

/*
 * By default only the lord of the domain can add/remove members, or
 * change the projects of the members.
 * This is a bit contrictive, but handy as a default.
 * Change this if you want.
 */
int add_member(string name) {
  if (geteuid(this_player(1)) != query_lord())
    return 0;
  return ::add_member(name);
}

int remove_member(string name) {
  if (geteuid(this_player(1)) != query_lord())
    return 0;
  return ::remove_member(name);
}

int set_project(string name, string pro) {
  if (geteuid(this_player(1)) != query_lord())
    return 0;
  return ::set_project(name, pro);
}

int query_member(string name) {
  return !undefinedp(members[name]) || name == LORD;
} /* query_member() */

string log_who(string where) {
   return LORD;
} /* log_who() */

/* Please change this to a text describing the domain, it will be used
   on the WWW pages and in finger info. */

void set_info( string words ) {
  info = words;
  save_me();
} /* query_info() */

string query_info() {
  return info;
} /* query_info() */
// --- END [/mnt/home2/grok/lib/d/learning/master.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/search_room.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/search_room.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627779   Available: 13575133
Inodes: Total: 5242880    Free: 4960133
5120 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/search_room.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627779   Available: 13575133
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h"
#include <map.h>

inherit "/std/room/basic_room";

string marker, *keywords, *exits;

void setup() {
   set_short( "uninitialised search room" );
   set_long( "You are in an uninitialized search room.  "
            "This is an example of a room that gets cloned and configured "
            "afterwards.  In this room, it's the function set_marker that's " 
            "used to define its look, and most if the exits as well.  And "
            "the function set_destination that is used to find, possibly "
            "clone and configure, the rooms that fit the keywords you search "
            "for.  The handler called SEARCH in the code, is \""+
            SEARCH +"\" and the one called QUIT_HANDLER, is \""+ 
            QUIT_HANDLER +"\".\n" );
   add_property( "no map", 1 );
   /* set_light sets the amount of light the room has.  See help light
    * for a list of what the number means:)
    */
   set_light( 50 );

   add_exit( "exit", LEARNING +"search", "path" );
   /* add_property is used to add a value to an object, that can later be
    * queried for with query_property.
    * The "commented functions" and "keywords" properties are specific for 
    * rooms in the learning domain and is used to make it possible to search
    * for subjects. 
    * See /d/learning/handlers/search.c for the way this is done.
    */
   add_property( "commented functions", 
                ({ "set_destination", "query_quit_handler", 
                   "query_cloning_info" }) );
   add_property( "keywords", ({ "room", "virtual" }) );
} /* setup() */

string query_marker() {
   return marker;
} /* query_marker() */ 

string *query_keywords() {
   if( !keywords ) {
      return ({ });
   }
   return keywords;
} /* query_keywords() */ 

void set_marker( string word, string *words ) {
   mixed search_result;
   string description, exit;
   int i;
   
   set_short( "\""+ word +"\" search room" );
   add_property( "determinate", "the " );
   marker = word;
   keywords = words;
   description ="You are in one of the search rooms of the learning domain "
                "and you have chosen the word"+
                ({ " \"", "s \"" })[ sizeof( words ) > 1 ] + word +"\" so far.";
   search_result = SEARCH->get_keywords( words );
   exits = search_result[ 0 ];
   if( sizeof( exits ) ) {
      description += "  Take one of the keyword exits to narrow the search to "
                     "include that keyword.";
      foreach( word in exits ) { 
         add_exit( word, "/??", "path" );
      }
   }
   description += "\n";
   if( sizeof( search_result[ 1 ] ) < 6 ) {
      description += "$I$5=Take one of the numbered exits to go to that room.";
      for( i = 0; i < sizeof( search_result[ 1 ] ); i++ ) {
         exit = sprintf( "%s: %s", ({ "1", "2", "3", "4", "5" })[ i ],
                        MAP->query_short( search_result[ 1 ][ i ] ) );
         add_exit( ({ "1", "2", "3", "4", "5" })[ i ],
                  search_result[ 1 ][ i ], "path" );
         description += "\n$C$"+ exit +".";
      }
      description += "$I$0=\n";
   }
   set_long( description );
} /* set_marker() */ 

/* set_destination is called whenever an exit is looked through or walked 
 * though.
 * The search handler will see if there's already a room defined by the 
 * keywords, and if not, it'll make one.
 */
void set_destination( string keyword ) {
   if( member_array( keyword, exits ) != -1 ) {
      /* the exit is a keyword, and need recalculation 
       */
      modify_exit( keyword, ({ "dest", 
         SEARCH->find_room( keywords + ({ keyword }) ) }) );
   }
   if ( find_call_out( "check_empty" ) == -1 )
      call_out( "check_empty", 10 );
} /* set_destination() */

/* This is for cleanup, it's called 10 seconds after something left, and if
 * nothing is in the room it's removed.
 */
void check_empty() {
   if ( sizeof( all_inventory( this_object() ) ) )
      return;
   dest_me();
} /* check_empty() */

/* query_quit_handler() is a function called by the player to get the filename
 * of the quit_handler. 
 * When quitting, the function player_quitting() is called in the quit_handler
 * which will save the
 */
string query_quit_handler() { return QUIT_HANDLER; }

/* query_cloning_info() is called by things that need to be able to remare
 * this room.
 * It it an array of three or four elements, the first of which is the
 * object, the second is a function called in it, with the third and if it's
 * there, the fourth element as arguments.
 */
mixed *query_cloning_info() {
   return ({ SEARCH, "find_room", keywords });
} /* query_cloning_info() */

/* This is for cleaning up the information saved by the quit_handler, to
 * make sure that the players name is removed from the lists.
 * 
 * event_exit is generally called whenever someone leaves the room.
 */
void event_exit( object thing, string mess, object to ) {
   string handler;
   
   if ( file_name( to ) == "/room/departures" )
      return;
   handler = query_quit_handler();
   if ( (string)to->query_quit_handler() != handler )
      handler->remove_from_list( thing );
} /* event_exit() */

// --- END [/mnt/home2/grok/lib/d/learning/search_room.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/functions.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/functions.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627777   Available: 13575131
Inodes: Total: 5242880    Free: 4960133
3175 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/functions.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627777   Available: 13575131
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h"
#include <learning.h>
#define PATH LEARNING

inherit "/std/room/basic_room";

string *functions;
int do_list();
int word();

void setup() {
   string word;
   /* The following two lines define the description of the room when you 
    * glance at it, or enter it in brief mode.
    * It should be something that will make the sentence:
    * "This room is <determinate>+<short>." correct.
    * eg. here it would make: "This room is the entrance to learning."
    * This is also a useful test to see if you've used capital letters
    * correctly.
    */
   set_short( "room of function examples" );
   add_property( "determinate", "the " );
   /* The next command define the description you see when you look at it,
    * and when you enter it in verbose mode.
    * It should consist of complete sentences.  For normal rooms it should be
    * a description of the things the player can see.  
    * Remember to use two spaces beween sentences.
    */
   set_long( "This is the room that might lead you to better understanding "
            "of how to use some of the functions we have here.\n"
            "Try \"list functions\" to get a list of the functions known by "
            "the room, "
            "take the exit named by the function to get to a room with exits "
            "to the examples.\n" 
            "If you have something you'd like to see here, "
            "mail "+ CURRENT_LORD +" and suggest it.\n" );
   /* set_light sets the amount of light the room has.  See help light
    * for a list of what the number means:)
    */
   set_light( 50 );
   /* This adds the exits, you'd never have guessed
    */
   functions = SEARCH->query_functions();
   foreach( word in functions ) {
      add_exit( word, "??", "path" );
      modify_exit( word, ({ "obvious", 0 }) );
   }
   add_exit( "exit", ENTRANCE, "door" );
   /* add_property is used to add a value to an object, that can later be
    * queried for with query_property.
    * The "commented functions" and "keywords" properties are specific for 
    * rooms in the learning domain and is used to make it possible to search
    * for subjects. 
    * See /d/learning/handlers/search.c for the way this is done.
    */
   add_property( "commented functions", 
                ({ "set_long", "set_short", "add_property", "set_light" }) );
   add_property( "keywords", ({ }) );
} /* setup() */

void init() {
//  string cmd;
  ::init();
  add_command( "list","functions");

/*  foreach(cmd in functions){
    add_command(cmd,"");
  }
*/

} /* init() */

int do_list() {
   write( sprintf( "The following functions have examples of use:\n%#-*s\n",
                  75, implode( functions, "\n" ) ) );
   return 1;
} /* do_list() */

/* set_destination is called whenever an exit is looked through or walked 
 * though.
 * The search handler will see if there's already a room defined by the 
 * function, and if not, it'll make one.
 */
void set_destination( string word ) {
   if( word != "exit" ) {
      /* the exit is a function, and need recalculation 
       */
      modify_exit( word, ({ "dest", SEARCH->find_function_room( word ) }) );
   }
} /* set_destination() */

// --- END [/mnt/home2/grok/lib/d/learning/functions.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/bad_init.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/bad_init.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627776   Available: 13575130
Inodes: Total: 5242880    Free: 4960133
82 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/bad_init.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627776   Available: 13575130
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
int x += 1;

/* You can only use = to initialise a variable while defining it
 */
// --- END [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/bad_init.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/div_zero.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/div_zero.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627776   Available: 13575130
Inodes: Total: 5242880    Free: 4960133
61 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/div_zero.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627776   Available: 13575130
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
void bing(mixed x) {
    switch(x) {
    case 1 / 0:
    }
}
// --- END [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/div_zero.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/void_member.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/void_member.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627776   Available: 13575130
Inodes: Total: 5242880    Free: 4960133
27 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/void_member.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627776   Available: 13575130
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
class bing {
    void x;
}
// --- END [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/void_member.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/div_zero3.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/div_zero3.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627775   Available: 13575129
Inodes: Total: 5242880    Free: 4960133
33 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/div_zero3.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627775   Available: 13575129
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
int bing() {
    return 1/0.0;
}
// --- END [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/div_zero3.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/redef_function.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/redef_function.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627775   Available: 13575129
Inodes: Total: 5242880    Free: 4960133
33 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/redef_function.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627775   Available: 13575129
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
void bing() {
}

void bing() {
}
// --- END [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/redef_function.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/eof_in_comment.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/eof_in_comment.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627775   Available: 13575129
Inodes: Total: 5242880    Free: 4960133
42 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/eof_in_comment.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627775   Available: 13575129
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* Comments have to stop as well as start
// --- END [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/eof_in_comment.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/two_default.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/two_default.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627775   Available: 13575129
Inodes: Total: 5242880    Free: 4960133
65 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/two_default.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627775   Available: 13575129
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
void bing() {
    switch (1) {
    default:
    default:
    }
}
// --- END [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/two_default.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/mixed_case.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/mixed_case.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627775   Available: 13575129
Inodes: Total: 5242880    Free: 4960133
73 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/mixed_case.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627775   Available: 13575129
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
void bing(mixed x) {
    switch (x) {
    case 1:
    case "hi":
    }
}
// --- END [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/mixed_case.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/local_redef.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/local_redef.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627774   Available: 13575128
Inodes: Total: 5242880    Free: 4960133
32 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/local_redef.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627774   Available: 13575128
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
void bing(int x) {
    int x;
}
// --- END [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/local_redef.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/no_ret_type.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/no_ret_type.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627774   Available: 13575128
Inodes: Total: 5242880    Free: 4960133
33 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/no_ret_type.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627774   Available: 13575128
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#pragma strict_types

bing() {
}
// --- END [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/no_ret_type.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/static_local.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/static_local.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627774   Available: 13575128
Inodes: Total: 5242880    Free: 4960133
38 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/static_local.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627774   Available: 13575128
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
void main() {
    nosave int x = 5;
}
// --- END [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/static_local.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/void_arg2.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/void_arg2.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627774   Available: 13575128
Inodes: Total: 5242880    Free: 4960133
17 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/void_arg2.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627774   Available: 13575128
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
void bing(void);
// --- END [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/void_arg2.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/bad_local_init2.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/bad_local_init2.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627773   Available: 13575127
Inodes: Total: 5242880    Free: 4960133
34 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/bad_local_init2.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627773   Available: 13575127
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
void bing() {
    int x = "hi";
}
// --- END [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/bad_local_init2.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/arr_index.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/arr_index.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627773   Available: 13575127
Inodes: Total: 5242880    Free: 4960133
99 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/arr_index.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627773   Available: 13575127
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
void bing() {
    ({ })[1];
}

/* This is a constant array that are indexed outside the bounds
 */
// --- END [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/arr_index.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/bad_param.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/bad_param.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627773   Available: 13575127
Inodes: Total: 5242880    Free: 4960133
31 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/bad_param.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627773   Available: 13575127
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
void bing() {
    (: $-1 :);
}
// --- END [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/bad_param.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/bad_local_init.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/bad_local_init.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627773   Available: 13575127
Inodes: Total: 5242880    Free: 4960133
32 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/bad_local_init.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627773   Available: 13575127
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
void bing() {
    int x += 1;
}
// --- END [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/bad_local_init.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/bad_break.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/bad_break.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627772   Available: 13575126
Inodes: Total: 5242880    Free: 4960133
133 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/bad_break.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627772   Available: 13575126
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
void bing() {
    break;
}

/* break belongs in case statements of switch, and in for,
 * foreach and while loops, not by itself
 */
// --- END [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/bad_break.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/bad_param2.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/bad_param2.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627772   Available: 13575126
Inodes: Total: 5242880    Free: 4960133
33 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/bad_param2.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627772   Available: 13575126
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
void bing() {
    (: $1000 :);
}
// --- END [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/bad_param2.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/arg_missing_type.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/arg_missing_type.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627772   Available: 13575126
Inodes: Total: 5242880    Free: 4960133
74 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/arg_missing_type.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627772   Available: 13575126
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
void bing(int) {
}

/* This is a function with a type but no argument
 */
// --- END [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/arg_missing_type.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/predef.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/predef.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627772   Available: 13575126
Inodes: Total: 5242880    Free: 4960133
19 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/predef.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627772   Available: 13575126
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#undef __VERSION__
// --- END [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/predef.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/missing_arg_type.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/missing_arg_type.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627771   Available: 13575125
Inodes: Total: 5242880    Free: 4960133
17 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/missing_arg_type.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627771   Available: 13575125
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
void bing(x) {
}
// --- END [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/missing_arg_type.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/void_local.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/void_local.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627771   Available: 13575125
Inodes: Total: 5242880    Free: 4960133
28 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/void_local.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627771   Available: 13575125
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
void bing() {
    void x;
}
// --- END [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/void_local.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/missing_endif.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/missing_endif.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627771   Available: 13575125
Inodes: Total: 5242880    Free: 4960133
6 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/missing_endif.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627771   Available: 13575125
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#if 1
// --- END [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/missing_endif.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/mod_zero.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/mod_zero.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627771   Available: 13575125
Inodes: Total: 5242880    Free: 4960133
61 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/mod_zero.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627771   Available: 13575125
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
void bing(mixed x) {
    switch(x) {
    case 1 % 0:
    }
}
// --- END [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/mod_zero.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/lvar_func2.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/lvar_func2.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627771   Available: 13575125
Inodes: Total: 5242880    Free: 4960133
44 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/lvar_func2.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627771   Available: 13575125
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
void bing() {
    int x;
    (: x + 1 :);
}
// --- END [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/lvar_func2.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/void_arg.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/void_arg.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627770   Available: 13575124
Inodes: Total: 5242880    Free: 4960133
22 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/void_arg.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627770   Available: 13575124
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
void bing(void x) {
}
// --- END [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/void_arg.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/bad_continue.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/bad_continue.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627770   Available: 13575124
Inodes: Total: 5242880    Free: 4960133
102 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/bad_continue.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627770   Available: 13575124
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
void bing() {
    continue;
}

/* continue belongs in for, foreach and while loops, not by itself
 */
// --- END [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/bad_continue.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/bad_type_init.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/bad_type_init.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627770   Available: 13575124
Inodes: Total: 5242880    Free: 4960133
14 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/bad_type_init.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627770   Available: 13575124
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
int x = "hi";
// --- END [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/bad_type_init.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/void_for_var.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/void_for_var.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627770   Available: 13575124
Inodes: Total: 5242880    Free: 4960133
43 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/void_for_var.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627770   Available: 13575124
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
void bing() {
    for (void x = 1; ; ) ;
}
// --- END [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/void_for_var.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/bad_return2.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/bad_return2.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627769   Available: 13575123
Inodes: Total: 5242880    Free: 4960133
32 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/bad_return2.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627769   Available: 13575123
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
int bing() {
    return "hi";
}
// --- END [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/bad_return2.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/var_to_nonvar.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/var_to_nonvar.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627769   Available: 13575123
Inodes: Total: 5242880    Free: 4960133
58 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/var_to_nonvar.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627769   Available: 13575123
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
void bing(int x) {
}

void bar() {
    bing( ({ })...);
}
// --- END [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/var_to_nonvar.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/no_member.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/no_member.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627769   Available: 13575123
Inodes: Total: 5242880    Free: 4960133
65 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/no_member.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627769   Available: 13575123
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
class bing {
    int x;
}

void bing() {
    bing y;
    y->z;
}
// --- END [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/no_member.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/local_redef2.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/local_redef2.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627769   Available: 13575123
Inodes: Total: 5242880    Free: 4960133
47 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/local_redef2.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627769   Available: 13575123
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
void bing() {
    int x;
    {
	int x;
    }
}
// --- END [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/local_redef2.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/class_redef.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/class_redef.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627768   Available: 13575122
Inodes: Total: 5242880    Free: 4960133
31 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/class_redef.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627768   Available: 13575122
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
class bing {
}

class bing {
}
// --- END [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/class_redef.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/bad_for_init.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/bad_for_init.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627768   Available: 13575122
Inodes: Total: 5242880    Free: 4960133
48 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/bad_for_init.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627768   Available: 13575122
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
void bing() {
    for (int x += 1; ; ) ;
}
    
// --- END [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/bad_for_init.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/string_case.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/string_case.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627768   Available: 13575122
Inodes: Total: 5242880    Free: 4960133
66 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/string_case.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627768   Available: 13575122
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
void bing() {
    switch ("hi") {
    case "bing".."bar":
    }
}
// --- END [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/string_case.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/eof_in_string.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/eof_in_string.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627768   Available: 13575122
Inodes: Total: 5242880    Free: 4960133
81 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/eof_in_string.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627768   Available: 13575122
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
void create() {
    "
}
/* You have to stop strings as well as start them:)
 */

// --- END [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/eof_in_string.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/lvar_func.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/lvar_func.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627767   Available: 13575121
Inodes: Total: 5242880    Free: 4960133
40 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/lvar_func.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627767   Available: 13575121
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
void bing() {
    int x;
    (: x :);
}
// --- END [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/lvar_func.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/no_such_class.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/no_such_class.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627767   Available: 13575121
Inodes: Total: 5242880    Free: 4960133
37 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/no_such_class.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627767   Available: 13575121
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
void bing() {
    new(class bing);
}
// --- END [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/no_such_class.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/undef_class.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/undef_class.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627767   Available: 13575121
Inodes: Total: 5242880    Free: 4960133
14 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/undef_class.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627767   Available: 13575121
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
class bing x;
// --- END [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/undef_class.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/void_global.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/void_global.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627767   Available: 13575121
Inodes: Total: 5242880    Free: 4960133
8 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/void_global.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627767   Available: 13575121
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
void x;
// --- END [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/void_global.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/missing_type.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/missing_type.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627767   Available: 13575121
Inodes: Total: 5242880    Free: 4960133
6 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/missing_type.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627767   Available: 13575121
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
bing;
// --- END [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/missing_type.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/bad_return.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/bad_return.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627766   Available: 13575120
Inodes: Total: 5242880    Free: 4960133
30 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/bad_return.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627766   Available: 13575120
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
void bing() {
    return 1;
}
// --- END [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/bad_return.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/bad_foreach.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/bad_foreach.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627766   Available: 13575120
Inodes: Total: 5242880    Free: 4960133
95 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/error_messages/bad_foreach.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627766   Available: 13575120
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
void bing() {
    foreach (x in ({})) ;
}
/* x needs to be declared before it can be used
 */

// --- END [/mnt/home2/grok/lib/d/learning/help_topics/error_messages/bad_foreach.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/npcs/make_person.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/npcs/make_person.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627766   Available: 13575120
Inodes: Total: 5242880    Free: 4960133
3715 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/npcs/make_person.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627766   Available: 13575120
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h";
inherit "/std/room";

object red_demon;

void setup() {
   /* The following two lines define the description of the room when you 
    * glance at it, or enter it in brief mode.
    * It should be something that will make the sentence:
    * "This room is <determinate><short>." correct.
    * eg. here it would make: "This room is the room telling about adding
    * NPC's."
    * This is also a useful test to see if you've used capital letters
    * correctly.
    */
   set_short( "room telling about adding NPC's" );
   add_property( "determinate", "the " );
   /* The next command define the description you see when you look at it,
    * and when you enter it in verbose mode.
    * It should consist of complete sentences.  For normal rooms it should be
    * a description of the things the player can see.  
    * Remember to use two spaces beween sentences, to end the sentences with
    * "." and to put "\n" at the end.
    */
   set_long( "This is a room showing how to add a stationary NPC to a room.  "
            "If you try to \"update here\" you will see that it waits a few "
            "seconds after loading the room before adding the NPC and, that "
            "when it appears there are a message notifying the player about "
            "it.\n" );
   /* set_light() defines the amount of light in the room. 
    * Without it you wouldn't be able to see:)
    * See help light for examples of what the values mean.
    */
   set_light( 60 );
   
   add_exit( "exit", ENTRANCE, "path" );
   
   /* add_property is used to add a value to an object, that can later be
    * queried for with query_property.
    * The "commented functions" and "keywords" properties are specific for 
    * rooms in the learning domain and is used to make it possible to search
    * for subjects. 
    * See /d/learning/handlers/search.c for the way this is done.
    */
   add_property( "commented functions", 
                ({ "set_long", "set_short", "add_property", 
                   "set_light", "reset" }) );
   add_property( "keywords", ({ "npc", "clone", "permanent", "make" }) );
} /* setup() */

/* reset() is called when the room is created, and every 15-30 minutes after
 * that.
 * Note the use of call_out to make the npc appear a bit after reset is 
 * called.  This has two purposes since it both helps to prevent "Too deep
 * recursion" errors, and it makes for a more dynamic room since people 
 * actually see when the npc appear.  The number is
 * how many second to wait before calling the function.
 */
void reset() {
   if ( !red_demon ) {
      call_out( "make_demon", 5 );
   }
} /* reset() */

/* This function is an example of how to make a complete npc, without
 * having to make a new file for it.  This works well, as long as you don't
 * want it to be able to do anything more than hang around and be 
 * slaughtered:)
 */
void make_demon() {
   red_demon = clone_object( "/obj/monster" );
   red_demon->set_name( "imp" );
   red_demon->set_short( "small red imp" );
   red_demon->add_adjective( ({ "small", "red" }) );
   red_demon->set_long( "This is a small red imp who has agreed to be used "
                       "as an example.\n" );
   red_demon->set_base_weight( 10 );
   red_demon->set_height( 17 );
   red_demon->set_race( "imp" );
   red_demon->set_level( 1 );
   /* I use a second parameter to move here, so people in the room will be 
    * told that the demon entered.
    * Note the use of $s to make sure the verb is conjugated correctly if 
    * the same message is used for more than one thing entering at the same
    * time.
    */
   red_demon->move( this_object(), "$N materialize$s with a small *POP*." );
} /* make_demon() */

// --- END [/mnt/home2/grok/lib/d/learning/help_topics/npcs/make_person.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/rooms/terrains/grassyfield.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/rooms/terrains/grassyfield.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627765   Available: 13575119
Inodes: Total: 5242880    Free: 4960133
301 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/rooms/terrains/grassyfield.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627765   Available: 13575119
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* -*- LPC -*- */
#include "path.h"

inherit "/std/outside";

void setup() {
   set_terrain("tutorial_grassy_field");
   set_short("grassy field");
   set_long("This field is covered with nicely mowed grass.\n");
   add_item("grass", "It's grass.  There isn't much to say about it.");
} /* setup() */
// --- END [/mnt/home2/grok/lib/d/learning/help_topics/rooms/terrains/grassyfield.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/rooms/terrains/foyer.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/rooms/terrains/foyer.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627764   Available: 13575118
Inodes: Total: 5242880    Free: 4960133
4104 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/rooms/terrains/foyer.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627764   Available: 13575118
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* -*- LPC -*- */
#include "path.h"

inherit "/std/room";

object teacher;
object sign;

void setup() {
   set_short( "foyer of the terrain school" );
   add_property( "determinate", "the " );
   set_long( "This is the foyer to the terrain teacher's school.  "
      "The walls here are hung with beautiful landscapes of complex tracts "
      "of land, and beneath each landscape is a map of some kind.  "
      "An intricate chandelier hangs from the ceiling, casting an even "
      "glow on all the landscapes.  "
      "Comfortable benches line the walls here, with small tables "
      "between them.  "
      "The floor is covered with a plush green carpet, which would be nice "
      "if not for the heavy mud stains across it.\n" );
   add_item( "landscape",
      "The landscapes show mountains, jungles, forests, "
      "oceans, rivers... all sorts of different terrains, including a "
      "city and a village." );
   add_item( "map",
      "Beneath each landscape hangs a single topographical "
      "map which appears to be a detailed representation of the landscape "
      "above it." );
   add_item( "chandelier",
      "Crystal teardrops scatter the light of a dozen "
      "candles around the room, casting an easy, comfortable light by which "
      "you can see.", 1 );
   add_item( "crystal teardrop", 
      "The candlelight makes it too hard to see "
      "the crystals clearly." );
   add_item( "candle", 
      "Nestled into the midst of the chandelier, the twelve "
      "candles provide all the light in this room.");
   add_item( "bench",
     ({ "long", "These wooden benches have comfortable leather cushions "
           "firmly attached.",
        "position", "a wooden bench",
     }) );
   add_item( "table",
     ({ "long", "These tables are covered with magazines talking "
           "about far away places and exotic architecture.",
        "position", "a table",
     }) );
   add_item( "plush green carpet",
      "This deep pile carpet was once a rich evergreen colour, but "
      "years of muddy footprints have stained much of it a deep, "
      "ugly brown." );
   add_item( "mud stains",
      "Someone has b een walking on this formerly beautiful carpet with "
      "muddy boots." );
   add_item( "cushions",
      "Thick leather cushions, stuffed with something very soft, and "
      "affixed quite securely to the benches." );
   add_item( "magazines",
     ({ "long", "Architectural and travel magazines sit on the "
           "various tables around the room.",
        "read", "\"Ruins of The Temple of Offler!\", "
           "\"Beautiful Ankh-Morpork!\", \"Design of the Tower of Art\", "
           "and \"Scenic Ramtops Vacations!\" are just the most visible "
           "of the titles that scream up at you.  Hopefully the "
           "magazines are kept just for their pictures, which seem far "
           "more interesting than their text.",
     }) );
   set_light( 60 );

   add_exit( "grassyfield", PATH "grassystep", "hidden" );
   add_exit( "desert", PATH "sandtent", "hidden" );
   add_exit( "mountaintop", PATH "mountaincabin", "hidden" );
   add_exit( "back", LEARNING +"search", "path" );
   add_exit( "exit", ENTRANCE, "path" );
   /* The "commented functions" and "keywords" properties are specific for 
    * rooms in the learning domain and is used to make it possible to search
    * for subjects. 
    * See /d/learning/handlers/search.c for the way this is done.
    */
   add_property( "commented functions", 
                ({  }) );
   add_property( "keywords", 
                ({ "terrain" }) );

   sign = add_sign(
      "A cardboard sign, with text scrawled messily across the front.\n",
      "Awye FRoM TH OFFICe",
      "cardboard sign",
      "sign",
      "common" );
   if (sign) sign->set_get();
} /* setup() */

void init() {
   if ( !this_player() )
      return;
   if ( !interactive( this_player() ) )
      return;
   if (!teacher) {
      teacher = load_object( CHARS "terrain_teacher" );
   } /* setup() */   if ( teacher ) {
      teacher->pupil_arrived( this_object() );
   }
} /* init() */
// --- END [/mnt/home2/grok/lib/d/learning/help_topics/rooms/terrains/foyer.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/rooms/terrains/mountaintree.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/rooms/terrains/mountaintree.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627763   Available: 13575117
Inodes: Total: 5242880    Free: 4960133
628 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/rooms/terrains/mountaintree.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627763   Available: 13575117
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* -*- LPC -*- */
#include "path.h"

#include <terrain.h>

inherit "/std/outside";

void setup() {
   set_room_size( 20 );
   set_terrain( "tutorial_mountain" );
   set_short( "tree in the mountains" );
   set_long( "This tree has defied all the odds, and grows straight and "
            "tall in the blustery wastes." );
   add_extra_look( this_object() );
   
   add_property( "climate", ({ -40, 50, 40 }) );
} /* setup() */

string extra_look() {
   if ( co_ord[ 2 ] < 800200 )
      return "\n";
   else
      return "  You can just make out a cabin in the snows to your "
             "northeast.\n";
} /* extra_look() */
// --- END [/mnt/home2/grok/lib/d/learning/help_topics/rooms/terrains/mountaintree.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/rooms/terrains/mountainsnows.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/rooms/terrains/mountainsnows.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627763   Available: 13575117
Inodes: Total: 5242880    Free: 4960133
460 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/rooms/terrains/mountainsnows.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627763   Available: 13575117
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* -*- LPC -*- */
#include "path.h"

inherit "/std/outside";

void setup() {
   set_terrain( "tutorial_mountain" );
   set_short( "the snowy wastes" );
   add_property( "determinate", "" );
   set_long( "This snow covered land is swept by strong winds night and "
            "day.  No trees can stand the harsh climate.\n" );
   add_item( "tree", "No, I said there _weren't_ any trees." );
   
   add_property( "climate", ({ -40, 50, 40 }) );
} /* setup() */
// --- END [/mnt/home2/grok/lib/d/learning/help_topics/rooms/terrains/mountainsnows.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/rooms/terrains/sandoasis.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/rooms/terrains/sandoasis.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627763   Available: 13575117
Inodes: Total: 5242880    Free: 4960133
626 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/rooms/terrains/sandoasis.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627763   Available: 13575117
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* -*- LPC -*- */
#include "path.h"

inherit "/std/outside";

void setup() {
   set_terrain( "tutorial_desert" );
   set_short( "desert oasis" );
   set_long( "The trees in this oasis provide welcome relief from the harsh "
            "sunlight of the desert.\n" );
   add_item( "sand", 
      "It's sand.  There isn't much to say about it other than "
      "that it's much moister here than elsewhere in the desert." );
   add_item( "tree", 
      "The palm trees grow majestically all around you, "
      "providing all the shade you could want." );
   
   add_property( "climate", ({ 10, -100, -100 }) );
} /* setup() */
// --- END [/mnt/home2/grok/lib/d/learning/help_topics/rooms/terrains/sandoasis.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/rooms/terrains/sanddunes.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/rooms/terrains/sanddunes.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627762   Available: 13575116
Inodes: Total: 5242880    Free: 4960133
396 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/rooms/terrains/sanddunes.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627762   Available: 13575116
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* -*- LPC -*- */
#include "path.h"

inherit "/std/outside";

void setup() {
   set_terrain( "tutorial_desert" );
   set_short( "sandy wasteland" );
   set_long( "This is just one small section of an endless "
            "expanse of sand.\n" );
   add_item( "sand", 
      "It's sand.  There isn't much to say about it.");
   
   add_property( "climate", ({ 40, -100, -100 }) );
} /* setup() */
// --- END [/mnt/home2/grok/lib/d/learning/help_topics/rooms/terrains/sanddunes.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/rooms/terrains/mountainbedroom.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/rooms/terrains/mountainbedroom.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627762   Available: 13575116
Inodes: Total: 5242880    Free: 4960133
664 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/rooms/terrains/mountainbedroom.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627762   Available: 13575116
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* -*- LPC -*- */
#include "path.h"

inherit "/std/room";

void setup() {
   set_terrain( "tutorial_mountain" );
   set_short( "mountain cabin attic" );
   set_long( "This is the second floor of a comfortable mountain cabin.  "
            "The bed occupying most of this room would seem to indicate "
            "that this is a bedroom.\n" );
   add_item( "bed", ({
      "long", "A big king-sized bed with a nice, thick, comforter on top.",
      "position", "the bed" }), 0 );
   add_item( "comforter",
      "This thick quilted comforter is made of some "
      "soft cotton fabric sandwiching a thick layer of down.");
   
   set_light( 50 );
} /* setup() */// --- END [/mnt/home2/grok/lib/d/learning/help_topics/rooms/terrains/mountainbedroom.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/rooms/terrains/grassystep.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/rooms/terrains/grassystep.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627761   Available: 13575115
Inodes: Total: 5242880    Free: 4960133
570 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/rooms/terrains/grassystep.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627761   Available: 13575115
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* -*- LPC -*- */
#include "path.h"

inherit "/std/outside";

void setup() {
   set_terrain( "tutorial_grassy_field" );
   set_short( "doorstep");
   set_long( "This is the doorstep to a small cottage.  All around "
            "here is a field covered with nicely cut grass.\n" );
   add_item( "grass", "It's grass.  There isn't much to say about it." );
   add_item( "cottage", "A plain, one-room cottage, painted white, "
            "with pink shutters on both the windows.  *hack* *cough*" );
   
   add_exit( "cottage", PATH "foyer", "corridor" );
} /* setup() */
// --- END [/mnt/home2/grok/lib/d/learning/help_topics/rooms/terrains/grassystep.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/rooms/terrains/sandtent.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/rooms/terrains/sandtent.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627761   Available: 13575115
Inodes: Total: 5242880    Free: 4960133
684 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/rooms/terrains/sandtent.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627761   Available: 13575115
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* -*- LPC -*- */
#include "path.h"

inherit "/std/outside";

void setup() {
   set_terrain( "tutorial_desert" );
   set_short( "outside tent" );
   set_long( "This is just outside the front flap of a canvas tent, set "
      "in the middle of a huge desert waste.  Nothing but sand as far "
      "as the eye can see.\n" );
   add_item( "sand", 
      "It's sand.  There isn't much to say about it." );
   add_item( "tent", 
      "This is a plain, white canvas tent, that reflects the harsh "
      "glare of the sun harmlessly away from its occupants." );
   
   add_exit( "tent", PATH "foyer", "corridor" );
   
   add_property( "climate", ({ 40, -100, -100 }) );
} /* setup() */
// --- END [/mnt/home2/grok/lib/d/learning/help_topics/rooms/terrains/sandtent.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/rooms/terrains/mountaincabin.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/rooms/terrains/mountaincabin.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627761   Available: 13575115
Inodes: Total: 5242880    Free: 4960133
1590 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/rooms/terrains/mountaincabin.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627761   Available: 13575115
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* -*- LPC -*- */
#include "path.h"

inherit "/std/room";

void setup() {
   set_terrain( "tutorial_mountain" );
   set_short( "rustic mountain cabin" );
   set_long( "This is the ground floor of a comfortable mountain cabin, "
      "complete with walls made of chinked logs, a bearskin rug, "
      "a huge, comfy sofa, and a bare lumber staircase leading "
      "up and down.  Unfortunately, since someone forgot to put a "
      "front door on this place, it's damned cold in here.\n" );
   add_item( ({ "log", "wall" }), 
      "Formed of whole logs, sanded to a satin "
      "finish, laid together, and with the gaps chinked with mud." );
   add_item( "bearskin rug", ({
      "long", "Looks like a large blackbear gave his life that you can be "
         "comfortable lying before the fire.",
      "position", "the rug" }), 0 );
   add_item( "comfy sofa", ({
      "long", "Not very sophisticated, but it sure looks comfortable.",
      "position", "the sofa" }), 0 );
   
   set_light( 50 );

   room_chat( ({ 100, 300,
      ({ "A chill wind blows some snow in through the open doorway.",
         "A sudden shiver runs down your spine.",
         "Maybe you should have packed some cold weather gear?",
         "Oh, a mug of hot cocoa would about hit the spot right now."
      }) }) );

   add_exit( "down", PATH "foyer", "stair" );
} /* setup() */

string query_exit_type( string direc, string dest) {
   if (direc == "up" || direc == "down")
      return "stair";
   else if (direc == "west")
      return "corridor";
   else
      return "none";
} /* query_exit_type() */
// --- END [/mnt/home2/grok/lib/d/learning/help_topics/rooms/terrains/mountaincabin.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/rooms/add_item/func_arguments.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/rooms/add_item/func_arguments.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627760   Available: 13575114
Inodes: Total: 5242880    Free: 4960133
2935 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/rooms/add_item/func_arguments.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627760   Available: 13575114
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h"

inherit "/std/room";

void setup() {
   set_short( "'add_item' room telling about the arguments of the function" );
   set_light( 100 );
   add_property( "determinate", "the " );

   set_long( "This is a room telling about the arguments passed to the "
            "do_<verb>() function.  Go east for examples of using the "
            "arguments, west for something else:).\n"
            "Here goes:\n"
            "  int do_<verb>( string command, object *indir, string dir_match,\n" 
            "                 string indir_match, mixed *args, string pattern );\n"
            "$I$12=command     is a string, it is the name of the verb "
             "used.$I$0=\n"
            "$I$12=indir       is an array of objects.  If any indirect "
             "objects are requested for, then they will be in this array."
             "$I$0=\n"
            "$I$12=dir_match   is a string, it is the name of the direct "
             "object.$I$0=\n"
            "$I$12=indir_match is a string, it is the name of the indirect "
             "object.$I$0=\n"
            "$I$12=args        is a mixed array of strings and numbers.  For "
             "each <> thingie you have in the pattern, it has a member.  So "
             "if you have <direct:object>, it has the name of the direct "
             "object, if you have <number> then it will have a number also, "
             "if <indirect:object>, the indirect object's name, and so on.  "
             "They are in the same order as in the pattern.$I$0=\n"
            "$I$12=pattern     is a string containing the pattern. It is "
             "useful to know which pattern has been caught since multiple "
             "patterns are allowed per function.$I$0=\n\n"
            "All do_<verb> functions in the learning domain will write their "
            "arguments, to help you figure out how to use them.\n"
            "A pool you can jump into is here.\n" );
   
   add_item( "large pool", ({
      "long", "It looks like you can jump into it.",
      "jump", ({ this_object(), "do_jump", "[into|in] <direct:object>" })
   }) );
   add_exit( "east", PATH +"args_integer", "path" );
   add_exit( "west", PATH +"verb_patterns", "path" );
   add_exit( "start", MAIN, "path" );
   add_exit( "exit", LEARNING +"search", "path" );
} /* setup() */

int do_jump( string command, object *indir, string dir_match, 
            string indir_match, mixed *args, string pattern ) {
   tell_object( this_player(), 
               sprintf( "$I$2=do_jump called:\ncommand=%O\nindir=%O\n"
                       "dir_match=%O\nindir_match=%O\nargs=%O\n"
                       "pattern=%O$I$0=\n",
                       command, indir, dir_match, 
                       indir_match, args, pattern ) );
      
   this_player()->add_succeeded_mess( previous_object(),
                                     "$N $V into a pool!\n", ({ }) );
   return 1;
} /* do_jump() */
// --- END [/mnt/home2/grok/lib/d/learning/help_topics/rooms/add_item/func_arguments.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/rooms/add_item/args_string.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/rooms/add_item/args_string.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627759   Available: 13575113
Inodes: Total: 5242880    Free: 4960133
1638 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/rooms/add_item/args_string.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627759   Available: 13575113
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h"

inherit "/std/room";

void setup() {
   set_short( "'add_item' room telling about getting string arguments" );
   set_light( 100 );
   add_property( "determinate", "the " );
   
   set_long( "This is the room telling about getting string arguments from a "
            "command defined with add_item.  Go east to see about getting "
            "object arguments, west to see about integer arguments.\n"
            "There is a large stone in the middle of the room.  It looks as "
            "if you can engrave your name onto it.\n");
   add_item( "large stone", 
            ({ "long", "It can be engraved.",
               "engrave", ({ this_object(), "do_engrave", 
                  "[the text] <string> [into] [the] <direct:object>" })
            }) );
   add_exit( "east", PATH +"args_object", "path");
   add_exit( "west", PATH +"args_integer", "path");
   add_exit( "start", MAIN, "path" );
   add_exit( "exit", LEARNING +"search", "path" );
} /* setup() */

int do_engrave( string command, object *indir, string dir_match, 
               string indir_match, mixed *args, string pattern ) {
   string mess;
   
   tell_object( this_player(), 
               sprintf( "$I$2=do_engrave called:\ncommand=%O\nindir=%O\n"
                       "dir_match=%O\nindir_match=%O\nargs=%O\n"
                       "pattern=%O$I$0=\n",
                       command, indir, dir_match, 
                       indir_match, args, pattern ) );
   
   mess =  "$N $V \""+ args[ 0 ] +"\" into "+ dir_match +".\n";
   this_player()->add_succeeded_mess( previous_object(), mess, ({ }) );
   return 1;
} /* do_engrave() */
// --- END [/mnt/home2/grok/lib/d/learning/help_topics/rooms/add_item/args_string.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/rooms/add_item/action_verbs.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/rooms/add_item/action_verbs.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627759   Available: 13575113
Inodes: Total: 5242880    Free: 4960133
2275 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/rooms/add_item/action_verbs.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627759   Available: 13575113
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h"

inherit "/std/room";

void setup() {
   set_short( "'add_item' room telling about making verbs do stuff" );
   set_light(100);
   
   set_long( "This is the room telling about making verbs do stuff.\n"
            "Let's say you have a rat in a room and randomly (let's say one "
            "out of two times) want to let players touch it.\n"
            "Read the ratnote to get an explanation of what happens when "
            "you touch the rat.\n"
            "There is a rat on the floor and a ratnote on the wall.\n");   
   
   add_item( "large filthy rat", ({
      "long", "It looks like it wants to be touched.",
      "touch", ({ this_object(), "do_touch" }) }) );

   add_item( "ratnote", ({
      "long", "It can be read.",
      "read", "When the rat is touched, do_touch() is called.  The do_touch() "
         "function must return an integer - If the touch was successful it "
         "returns a 1, if the touch failed the function should return a 0.\n"
         "Note also that a success message is given to all in the room.  But, "
         "if the person fails, the add_item code looks for more matches - "
         "thinking that the function do_touch is the wrong one.  If there is "
         "no other function found that defines touching rats and that returns "
         "a 1, then the game returns the message 'You fail to touch a rat'.\n"
         "The this_object() reference tells the add_item code what object is "
         "the direct object of the verb.  Just trust me, and leave it in your "
         "code without asking why for now.  It is one of those things that "
         "can give you more flexibility later on.\n" }) );

   add_exit( "east", PATH +"verb_failure", "path" );
   add_exit( "west", PATH +"many_verbs", "path" );
   add_exit( "start", MAIN, "path" );
   add_exit( "exit", LEARNING +"search", "path" );
} /* setup() */

int do_touch() {
   if( random(2) ) {
      /* Code to infect this_player() */
      tell_object( this_player(), "\n ****  You feel deathly sick. ****\n"
                  " (this is a tell_object(this_player(),...))\n" );
      tell_object( this_player(),
                  "do_touch is returning a 0, indicating failure!\n" );
      return 0;
   }
   return 1;
} /* do_touch() */
// --- END [/mnt/home2/grok/lib/d/learning/help_topics/rooms/add_item/action_verbs.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/rooms/add_item/main.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/rooms/add_item/main.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627758   Available: 13575112
Inodes: Total: 5242880    Free: 4960133
1129 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/rooms/add_item/main.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627758   Available: 13575112
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h"

inherit "/std/room";

void setup() {
   set_short( "primary room for \"add_item\"" );
   add_property( "determinate", "the " );
   set_light( 100 );
   set_long( "This is the start room for the examples for add_item.  "
            "Essentially boring, since it's only here to start you on your "
            "way:)\n" );   
   add_exit( "start", PATH +"intro", "path" );
   add_exit( "failure", PATH +"verb_failure", "path" );
   add_exit( "success", PATH +"verb_success", "path" );
   add_exit( "patterns", PATH +"verb_patterns", "path" );
   add_exit( "arguments", PATH +"func_arguments", "path" );
   add_exit( "args_int", PATH +"args_integer", "path" );
   add_exit( "args_string", PATH +"args_string", "path" );
   add_exit( "args_object", PATH +"args_object", "path" );
   add_exit( "helper", PATH +"item_helper", "path" );
   add_exit( "exit", LEARNING + "search", "path" );
   
   /* the normal add_property() calls for the learning domain
    */
   add_property( "commented functions", ({ "add_item" }) );
   add_property( "keywords", ({ "room", "add_item", "action", "command" }) );
} /* setup() */
// --- END [/mnt/home2/grok/lib/d/learning/help_topics/rooms/add_item/main.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/rooms/add_item/verb_patterns.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/rooms/add_item/verb_patterns.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627757   Available: 13575111
Inodes: Total: 5242880    Free: 4960133
3285 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/rooms/add_item/verb_patterns.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627757   Available: 13575111
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h"

inherit "/std/room";

void setup() {
   set_short("add_item room #9, verb patterns ");
   set_light(100);

   set_long("add_item room #9, verb patterns\n"
            +"Outdated! see man add_command for patterns\n "
            +"As you guessed I am still holding out on you.  There is, "
            +"unfortunately, tons more!  Most things take the form: VERB "
            +"DIRECT_OBJECT or $V $D.  Add item has a limited number of "
            +"patterns that it can recognize, the first limitation is that "
            +"the verb must come first.  ie VERB PATTERN.  The default "
            +"pattern we have been using to date is %D.  We can change the "
            +"pattern!\nReference sheet.\nLarge pool.\nNote.\n");
   
   add_item("reference sheet",
            "Pattern: Is the add_command pattern( parse_command): \n"
            +"Example string = \" 'get' / 'take' %i \" \n"
            +"Syntax:\n"
            +"  'word'          obligatory text     \n"
            +"  [word]          optional text       \n"
            +"  /               Alternative marker  \n"
            +"  %o              Single item, object \n"
            +"  %l              Living objects      \n"
            +"  %s              Any text            \n"
            +"  %w              Any word            \n"
            +"  %p              One of a list (prepositions)  \n"
            +"  %i              Any items                     \n"
            +"  %d              Number 0- or tx(0-99)         \n"
            +"Things from add_command                         \n"
            +"  %D              Direct Object                 \n"
            +"  %I              Indirect object               \n\n"
            +"Currently %s and %w behave a bit erradically... \n"
            +"If you put 'text' before and after them it might help.\n"
            +"Hope this helps!\n" );
   
   add_item("note", ({ "long", "It can be read.",
      "read", "Here is the code for the pool:\n"
      +"  add_item(\"large pool\", ({  \n"
      +"       \"long\",\n"
      +"                   \"It looks like you can jump into it!\"\n"
      +"	,\"jump\",\n"
      +"		   ({ this_object(), \"do_jump\", \n"
      +"			\" 'into' / 'in' %D \"  })  \n"
      +"	 )} );\n\n"
      +"Ok. Not much different, just one more argument.  Look at the "
      +"reference sheet.  Looks complicated hunh?  The most useful ones "
      +"are %D, %I, %d, [text], 'text', and /.  I will demonstrate how to "
      +"use %d and %I in a few rooms.  I have also changed the succeed "
      +"mess, otherwise it would say: \"You jump into / in a large pool.\"  "
      +"Not good huh? *smile* Oh well on to the next room!\n" }));
   
   
   add_item( "large pool", ({
      "long", "It looks like you can jump into it!",
      "jump", ({ this_object(), "do_jump", " [into|in] <direct:object>" })
   }) );
   
   add_exit( "east", PATH +"func_arguments", "path");
   add_exit( "west", PATH +"verb_success", "path");
   add_exit( "start", MAIN, "path" );
   add_exit( "exit", LEARNING +"search", "path" );
} /* setup() */

int do_jump() {
   this_player()->add_succeeded_mess(previous_object(),
                                     "$N $V into a pool!\n",  ({}));
   return 1;
} /* do_jump() */
// --- END [/mnt/home2/grok/lib/d/learning/help_topics/rooms/add_item/verb_patterns.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/rooms/add_item/verbs.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/rooms/add_item/verbs.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627756   Available: 13575110
Inodes: Total: 5242880    Free: 4960133
2932 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/rooms/add_item/verbs.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627756   Available: 13575110
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/****** This room is made my Mithal, learn and enjoy  ***/

#include "path.h"

inherit "/std/room";

void setup() {
   set_short("add_item room #3, verbs ");
   set_light(100);

   set_long("add_item room #3, verbs \n"
            "As you know, things can be read, kicked, etc... in DiscWorld.  "
            "Therefore we need to make our items respond to actions.  The "
            "old way to do this is through add_action.  Unless you are "
            "experienced, you should not use this function.  add_item "
            "provides many facilities to do this which are much better to "
            "write, easier to understand, and have less chance of 'bugging' "
            "out on you.\nA large oak.\nA note.\n\n");
   
   
   add_item("note", ({ "long", "It can be read.",
      "read", "As you can see, this note can be read, "
      "this is our first introduction to verbs.  "
      "The code that does this:\n"
      "      add_item(\"note\", ({ \"long\", \"It can be read.\" \n"
      "                          \"read\", \"As you can see ... \" }) );\n"
      "This uses a mixed variable in the description part of the "
      "add_item.  The members of the mixed variables are strings which "
      "come in pairs.  Notice that \"long\" is not \"look\" this is just "
      "a simple way to specify a whole range of verbs that return this "
      "description, namely:  look, examine, ... \n"
      "After printing out the message the add_item program prints out to "
      "the person reading the note: \"You read a note.\"  More generally:  "
      "\"You <verb> <indefinate artical> <item>.\"  Similarly everyone "
      "else in the room sees:  \"Fred reads a note.\"\n\nA description of "
      "the tree can be found in treenote.\n" }));
   

   add_item("treenote", ({ "long", "Read it nim wit!",
      "read", "Here is the add_item for the oak:\n"
      " add_item( ({\"large oak tree\",\"large oak\"}) , ({  \n"
      "      \"long\",\"It looks like it can be climbed and cut.\"\n"
      "      \"climb\",\"You get half way up, and climb back down.\\n\"\n"
      "      \"cut\",\"You cannot hurt this tree!\\n\"  })); \n\n"
      "Oh joy.  Notice that it always prints out:\n"
      "   \"You <verb> a large oak.\" \n"
      "It picks the first description of the item from the mixed array.\n"
      "Some times you can interfere with item commands or soul commands "
      "by installing these actions. But, the interference would be more "
      "if you used add_action!.\n" }));
   
   add_item( ({ "large oak tree", "large oak" }) , ({
      "long", "It looks like it can be climbed and cut.",
      "climb", "You get half way up, and climb back down.\n",
      "cut", "You cannot hurt this tree!\n" }) );
   add_exit( "east", PATH +"many_verbs", "path" );
   add_exit( "west", PATH +"many_names", "path" );
   add_exit( "start", MAIN, "path" );
   add_exit( "exit", LEARNING +"search", "path" );
}

// --- END [/mnt/home2/grok/lib/d/learning/help_topics/rooms/add_item/verbs.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/rooms/add_item/many_verbs.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/rooms/add_item/many_verbs.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627755   Available: 13575109
Inodes: Total: 5242880    Free: 4960133
1864 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/rooms/add_item/many_verbs.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627755   Available: 13575109
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/****** This room is made my Mithal, learn and enjoy  ***/

#include "path.h"

inherit "/std/room";

void setup() {
   set_short("add_item room #4, many verbs ");
   set_light(100);

   set_long( "add_item room #4, many verbs \n"
            "Sometimes you have two or more identical verbs - or at least "
            "identical in how you want to treat them.  Take our oak tree "
            "we can cut it, slice it, saw it, etc...  Now all of these have "
            "the same meaning. How do we do this?\n"
            "A large oak.\nA note.\n");
   
   add_item("note", ({ "long", "It can be read.",
      "read", "Here is the code for the tree:\n"
      "    add_item(\"large oak tree\", ({\n"
      "      \"long\",\n"
      "              \"It looks like it is very well protected.\"\n"
      "      ({\"cut\",\"slice\",\"saw\",\"destroy\",\"kill\" }),\n"
      "              \"It seems to have no effect.\\n\"       }});\n\n"
      "Pretty obvious hunh?  Note that kill probably does not work( I "
      "say probably cuz things might change)  That is beacuse user commands "
      "have precidence over object actions in rooms.  Also be aware that a "
      "add_action on an item that a person is holding will most likely stop "
      "your verbs from being used (unless it's coded right:).  Soul commands "
      "do not have precedence, however.  So verbs like \"pick\" which would "
      "normally say \"You pick your nose\" can be trapped appropriately.\n" 
   }) );
   
   add_item("large oak", ({
      "long", "It looks like it is very well protected.",
      ({ "cut", "slice", "saw", "destroy", "kill" }),
        "It seems to have no effect.\n" }) );

   add_exit( "east", PATH +"action_verbs", "path");
   add_exit( "west", PATH +"verbs", "path");
   add_exit( "start", MAIN, "path" );
   add_exit( "exit", LEARNING +"search", "path" );
}
// --- END [/mnt/home2/grok/lib/d/learning/help_topics/rooms/add_item/many_verbs.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/rooms/add_item/item_helper.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/rooms/add_item/item_helper.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627755   Available: 13575109
Inodes: Total: 5242880    Free: 4960133
4163 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/rooms/add_item/item_helper.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627755   Available: 13575109
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/****** This room is made my Mithal, learn and enjoy  ***/

#include "path.h"

inherit "/std/room";

string pattern;
string verb;

void setup() {
   set_short("add_item room #15, Testing and creating a form ");
   set_light(100);

   set_long("add_item room #15, Testing and creating a form "
            +"This item is ment to help in the formulation of items."
	    +"it provides a way to use add_item without coding.  I "
	    +"will try to explain it.  *sigh* You can change the pattern and "
	    +"name of the verb construct seperately. And you can add items to "
	    +"this room.  The 'add an object named XXXX' command creates an "
	    +"object with the name XXXX useing the current verb and pattern.  "
	    +"Once you have added the item, you can look at it, and use the "
	    +"defined verb on it.  The verb will spit out all of the "
	    +"arguments to the function, like room 12.  In this way you can "
	    +"test verb patterns - since many of them don't work - without "
	    +"any coding.  It should help you get an idea how it all works.  "
	    +"\nA reference sheet.\nA stupid object.\n");

   add_exit("west",PATH+"item_conflicts","path");
   add_exit("north",MAIN,"path" );

      add_item("reference sheet",
	    "Pattern: Is the add_command pattern( parse_command): \n"
	    +"Example string = \" 'get' / 'take' %i \" \n"
	    +"Syntax:\n"
	    +"  'word'          obligatory text     \n"
	    +"  [word]          optional text       \n"
	    +"  /               Alternative marker  \n"
	    +"  %o              Single item, object \n"
	    +"  %l              Living objects      \n"
	    +"  %s              Any text            \n"
	    +"  %w              Any word            \n"
	    +"  %p              One of a list (prepositions)  \n"
	    +"  %i              Any items                     \n"
	    +"  %d              Number 0- or tx(0-99)         \n"
	    +"Things from add_command                         \n"
	    +"  %D              Direct Object                 \n"
            +"  %I              Indirect object               \n\n"
	    +"Currently %s and %w behave a bit erradically... \n"
	    +"If you put 'text' before and after them it might help.\n"
	    +"Hope this helps!\n" );

   pattern = "%D";
   verb    = "use";
   
   add_item("stupid object"
      ,({
            "long",       "This object is used to create items in the room!\n"
            +" set object pattern to <pattern> \n"
	    +" name object verb to <verb> \n"
            +" query object  ( returns the current pattern and verb ) \n"
            +" add an object named <item>\n"
            ,"set"      ,({this_object(),"do_set","%D 'pattern' 'to' %s" })
	    ,"name"     ,({this_object(),"do_name","%D 'verb' 'to' %s" })
            ,"query"    ,"@@do_query:"+file_name(this_object())+"@@\n"
            ,"add"      ,({this_object(),"do_add","'an' %D 'named' %s" })
            
        }));
   
   /************ END OF SETUP ***********************/
}

/************** COMMANDS ****************************************/

int do_set(mixed a1,mixed a2,mixed a3,mixed a4, mixed a5, mixed a6)
{
   pattern = (string) a5[1];
   return 1;
}

int do_name(mixed a1,mixed a2,mixed a3,mixed a4, mixed a5, mixed a6)
{
   verb = (string) a5[1];
   return 1;
}

int do_add(mixed a1,mixed a2,mixed a3,mixed a4, mixed a5, mixed a6)
{
   object *obs;

  add_item( a5[1]
      ,({
            "long",
	       "This object's name is: "+a5[1]
	        +"\nAnd it can be used with the pattern:"+pattern
		+":\nAnd verb:"+verb+":\n\n"
            ,verb      ,({this_object(),"do_use",pattern })     
        }));
   
   obs = all_inventory(this_object());
   obs->move("/room/void");
    obs->move(this_object());
   this_player()->move(this_object());
   return 1;
}

string do_query()
{ return "\nPattern:"+pattern+":Verb:"+verb+":\n"; }

int  do_use(mixed a1, mixed a2, mixed a3, mixed a4, mixed a5, mixed a6)
{

  printf("\nThe Verb:(A1):  %O\nThe Objects(A2):\n%O\nDirect Object(A3):  %O\nIndirect Object(A4):  %O\nReturn Array(A5):\n%O\nPattern(A6):  %O\n\n",a1,a2,a3,a4,a5,a6);
  
  tell_object(this_player(),"Hope that worked...\n");
  
  return 1;
}
    
// --- END [/mnt/home2/grok/lib/d/learning/help_topics/rooms/add_item/item_helper.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/rooms/add_item/args_object.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/rooms/add_item/args_object.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627753   Available: 13575107
Inodes: Total: 5242880    Free: 4960133
2604 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/rooms/add_item/args_object.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627753   Available: 13575107
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/****** This room is made my Mithal, learn and enjoy  ***/

#include "path.h"

inherit "/std/room";
object key;

void setup() {
   set_short( "'add_item' room telling about getting the object as argument" );
   set_light(100);
   add_property( "determinate", "the " );

   set_long( "This is the room telling about getting string arguments from a "
            "command defined with add_item.  Go east to see about getting "
            "string arguments, west to see about item conflicts.\n"
            "There is a large stone in the middle of the room.  It looks as "
            "if you can unlock it if you have the correct key.\n" );
   
   add_item( "large stone", ({
      "long","It can be unlocked.",
      "unlock", ({ this_object(), "do_unlock", 
         "<direct:object> [with] <indirect:object>" })
   }) );
   add_exit( "east", PATH +"item_conflicts", "path" );
   add_exit( "west", PATH +"args_string", "path" );
   add_exit( "start", MAIN, "path" );
   add_exit( "exit", LEARNING +"search", "path" );
} /* setup() */

int do_unlock( string command, object *indir, string dir_match, 
               string indir_match, mixed *args, string pattern ) {
   object ob;
   
   tell_object( this_player(), 
               sprintf( "$I$2=do_unlock called:\ncommand=%O\nindir=%O\n"
                       "dir_match=%O\nindir_match=%O\nargs=%O\n"
                       "pattern=%O$I$0=\n",
                       command, indir, dir_match, 
                       indir_match, args, pattern ) );
   this_player()->add_failed_mess( previous_object(),
                                  "You don't have the correct key.\n", ({ }) );
   /* Note that the pattern guarantees that there is an indir */
   ob = indir[ 0 ];
   if( (int) ob->query_property( "Mithal" ) != 1 ) { 
      write( "wrong key\n" ); 
      return 0; 
   }
   /* for every object you succeed to perform the verb with, you
    * must have these calls
    */
   this_player()->add_succeeded( ob );   
   this_player()->add_succeeded_mess( previous_object(),
                                     "$N $V the stone with $I.\n",
                                     ({ ob }));
   write( "You succeeded!\n" );
   return 1;
} /* do_unlock() */

void reset() {
   call_out( "check_key", 2 );
} /* reset() */

void check_key() {
   if( !key ) {
      key = clone_object( "std/object" );
      key->set_name( "key" );
      key->set_short( "Mithal's key" );
      key->add_property( "Mithal", 1 );
      key->move( this_object(), "Mithal sneaks through the room, "
                "dropping $N in the process." );
   }
} /* check_key() */

// --- END [/mnt/home2/grok/lib/d/learning/help_topics/rooms/add_item/args_object.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/rooms/add_item/verb_failure.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/rooms/add_item/verb_failure.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627753   Available: 13575107
Inodes: Total: 5242880    Free: 4960133
2539 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/rooms/add_item/verb_failure.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627753   Available: 13575107
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/****** This room is made my Mithal, learn and enjoy  ***/

#include "path.h"

inherit "/std/room";

void setup() {
   set_short("add_item room #7, verb failure messages ");
   set_light(100);

   set_long("add_item room #7, verb failure messages\n"
            +"Let us continue with our rat.  Sometimes the general failure "
            +"message just dosn't cut it.  When the player fails to  "
            +"touch our rat, the mud should tell him/her nicely and not "
            +"let them think they messed up.  This rat does just that.  "
            +"Notice that, unlike success messages, failure messages go only "
            +"to the player - not to everyone in the room.  *smile* \n"
            +"A filthy rat.\nA note.\n");
   
   
   add_item("note", ({ "long", "It can be read.",
		       "read", "Here is the code for the do_touch:\n"
	     +"int  do_touch()\n"
             +"{\n"
	     +"   if(!random(2)) {\n"
	     +"       this_player()->add_failed_mess(previous_object(),\n"
	     +"                       \"You miss the rat!\\n\",\n"
	     +"                       ({})); \n"
	     +"        return 0;\n"
	     +"    }\n"
	     +"    return 1;\n"
	     +"}\n\n"
	     +"The add_failed_mess is a pretty complicated fella.  The first "
	     +"argument I beleve is the object that the verb failed on, ie "
	     +"the rat.  The second argument is the failure message. Since "
	     +"it is going only to the player, it is really simple to "
	     +"understand.  The third argument is the set of indirect "
	     +"that were used in the failing attempt.  I think you can "
	     +"reference there name in the message as %I.  But don't quote "
	     +"me on that.  Similarly %D can be used as a substution for the "
	     +"direct object, ie previous_object().  It is complicated.  "
	     +"If you stick to this form, you shouldn't have any problems.  "
	     +"If all else fails, read the help file on it. *giggle* \n" }));
   
   add_item( "large filthy rat", ({
      "long", "It looks like it wants to be touched.",
      "touch", ({ this_object(), "do_touch" }) }));
   
   add_exit( "east", PATH +"verb_success", "path" );
   add_exit( "west", PATH +"action_verbs", "path" );
   add_exit( "start", MAIN, "path" );
   add_exit( "exit", LEARNING +"search", "path" );
}

int do_touch() {
   if(!random(2)) {
      this_player()->add_failed_mess(previous_object(),
                                     "You miss the rat!\n",
                                     ({}));
      return 0;
   }
   return 1;
}
    
   

// --- END [/mnt/home2/grok/lib/d/learning/help_topics/rooms/add_item/verb_failure.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/rooms/add_item/args_char.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/rooms/add_item/args_char.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627752   Available: 13575106
Inodes: Total: 5242880    Free: 4960133
1878 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/rooms/add_item/args_char.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627752   Available: 13575106
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/****** This room is made my Mithal, learn and enjoy  ***/

#include "path.h"

inherit "/std/room";

void setup() {
   set_short("add_item room #12, Getting character arguments ");
   set_light(100);

   set_long("add_item room #12, Getting character arguments\n"
	    +"There is a large stone in the middle of the room.  It looks as "
	    +"if you can engrave your name onto it.\nSource code.\n");

   			 
   add_item("large stone", ({
	        "long",
	                   "It can be engraved."
		,"engrave",
			   ({ this_object(), "do_engrave",
				"'into' %D 'the' text' %s"  })
	}));

   

   add_item("source code", ({ "long",  
         "It looks like some source code."
         ,"read", 
         "The source code:\n"
+"\n"
+"   add_item(\"large stone\", ({\n"
+"	        \"long\",\n"
+"	                   \"It can be engraved.\"\n"
+"		,\"engrave\",\n"
+"			   ({ this_object(), \"do_engrave\",\n"
+"				\"'into' %D 'the' text' %s\"  })\n"
+"	}));\n"
+"\n\nRead also:  do_engrave\n" }));

   add_item("do_engrave", ({ "long",  
         "It looks like some source code."
         ,"read", 
         "The source code:\n"
+"int do_engrave(mixed a1,mixed a2,mixed a3,mixed a4, mixed a5, mixed a6)\n"
+"{\n"
+"     string mess;\n"
+"        mess =  \"$N $V \"+a5[1]+\" into \"+a3+\".\\n\";\n"
+"        this_player()->add_succeeded_mess(previous_object(),\n"
+"					        mess,\n"
+"					        ({}));\n"
+"        return 1;\n"
+"}\n"
+"\n" }));

   add_exit("east",ROOM+"args_object","door");
   add_exit("west",ROOM+"args_integer","door");
   add_exit("north",MAIN,"door" );

 }
						     
int do_engrave(mixed a1,mixed a2,mixed a3,mixed a4, mixed a5, mixed a6)
{
     string mess;
        mess =  "$N $V "+a5[1]+" into "+a3+".\n";
        this_player()->add_succeeded_mess(previous_object(),
					        mess,
					        ({}));
        return 1;
}

    
   

// --- END [/mnt/home2/grok/lib/d/learning/help_topics/rooms/add_item/args_char.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/rooms/add_item/args_integer.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/rooms/add_item/args_integer.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627751   Available: 13575105
Inodes: Total: 5242880    Free: 4960133
1773 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/rooms/add_item/args_integer.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627751   Available: 13575105
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h"

inherit "/std/room";

void setup() {
   set_short( "'add_item' room telling about getting integer arguments" );
   set_light( 100 );
   add_property( "determinate", "the " );

   set_long( "This is the room telling about getting integer arguments from a "
            "command defined with add_item.  Go east to learn about getting "
            "string arguments, west to learn about the arguments passed "
            "to the function called when you do the command.\n"
            "This room is filled with an uncountable number of rats.  They "
            "all have numbers branded into them.  You can dissolve a rat if "
            "you know its number.\n" );
   
   add_item( "large filthy rat", ({
      "long", "The rats look vile.",
      "dissolve", ({ this_object(), "do_dissolve",
         "<direct:object> [no|number] <number>" })
   }) );
   add_exit( "east", PATH +"args_string", "path");
   add_exit( "west", PATH +"func_arguments", "path");
   add_exit( "start", MAIN, "path" );
   add_exit( "exit", LEARNING +"search", "path" );
} /* setup() */

int do_dissolve( string command, object *indir, string dir_match, 
                string indir_match, mixed *args, string pattern ) {
   string mess;
   
   tell_object( this_player(), 
               sprintf( "$I$2=do_dissolve called:\ncommand=%O\nindir=%O\n"
                       "dir_match=%O\nindir_match=%O\nargs=%O\n"
                       "pattern=%O$I$0=\n",
                       command, indir, dir_match, 
                       indir_match, args, pattern ) );
   
   mess =  "$N $V "+ dir_match +" number "+ args[ 1 ] +".\n";
   this_player()->add_succeeded_mess( previous_object(),
                                      mess, ({ }) );
   return 1;
} /* do_dissolve() */
// --- END [/mnt/home2/grok/lib/d/learning/help_topics/rooms/add_item/args_integer.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/rooms/add_item/verb_success.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/rooms/add_item/verb_success.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627750   Available: 13575104
Inodes: Total: 5242880    Free: 4960133
2865 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/rooms/add_item/verb_success.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627750   Available: 13575104
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/****** This room is made my Mithal, learn and enjoy  ***/

#include "path.h"

inherit "/std/room";

void setup() {
   set_short("add_item room #8, verb success messages ");
   set_light(100);

   set_long("add_item room #8, verb success messages\n"
	    "Let us continue with our rat.  Suppose now that we want the "
	    "player to succeed - but that the default message is really "
	    "inappropriate.  What we want to do is change the succeed "
	    "message!  Let's say when the player goes to touch the rat "
	    "it tells him - As you touch the rat, it snarls. - "
	    "Unfortunately succeed messages are much more complicated "
	    "beacuse your message is going to two parties, the player and "
	    "other players in the room. So you can't put the words \"You\" and "
	    "\"touch\" directly into code, because \"Fred\" and \"touches\" are the "
	    "appropriate substitutions to be used for the audience.  "
	    "Furthermore, if you are useing "
	    "multiple verbs, how do you know what verb the person used? "
	    "The solution is to use $V for verb and $N for player name.\n"
	    "A filthy rat.\nA note.\n");

   
   add_item("note", ({ "long", "It can be read.",
		       "read", "Here is the code for the do_touch:\n"
	     "int  do_touch()\n"
             "{\n"
             "      this_player()->add_succeeded_mess(previous_object(),\n"
	     "        \"As $N $V $D, it snarls.\\n\",  ({}));\n"
	     "    return 1;\n"
	     "}\n\n"
	     "The only difference between add_failed_mess and this one is "
	     "the message: When the message is processed for the player, "
	     "\"You\" is substituted for $N and \"touch\" for $V.  Likewise, when "
	     "the message is processed for others: \"Fred\" is substituted for $N "
	     "and \"touches\" is substituted for $V.  If you were using multiple "
	     "verbs, the appropriate verb would be used.  There might be "
	     "other $ stuff in the docs( namely $D and $I if you have an "
	     "indirect object list.)  There might be ones for pronouns and "
	     "possessives also.  At last "
	     "resort, you can always make this string a null string! And "
	     "insert tell_other and tell_room call's directly in your code."
	     "Of course add_failed_mess and this one can be used together in "
	     "the same code...\n" }));

   
   add_item("large filthy rat", ({
	        "long",
	                   "It looks like it wants to be touched.",
		"touch",
                           ({ this_object(), "do_touch" }) }));

   add_exit("west",PATH+"verb_failure","path");
   add_exit("east",PATH+"verb_patterns","path");
   add_exit( "start", MAIN, "path" );
   add_exit( "exit", LEARNING +"search", "path" );
} /* setup() */

int  do_touch()
{
  this_player()->add_succeeded_mess(previous_object(),
	            "As $N $V $D, it snarls.\n",  ({}));
    return 1;
} /* do_touch() */
// --- END [/mnt/home2/grok/lib/d/learning/help_topics/rooms/add_item/verb_success.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/rooms/add_item/changing_descs.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/rooms/add_item/changing_descs.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627749   Available: 13575103
Inodes: Total: 5242880    Free: 4960133
2259 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/rooms/add_item/changing_descs.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627749   Available: 13575103
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h"

inherit "/std/room";

int open;

void setup() {
   set_short("add_item room #5b, item descriptions that change with time");
   set_light(100);

   set_long("add_item room #5b, item description that change with time\n"
            "*BEEEP* *BEEEP* WARNING! WARNING! *BEEEP* *BEEEP*\n"
            "This room is crap, and uses a non longer valid way of changing "
            "descriptions, if you see anything like this, be sure to bug "
            "report it.\nAlso note that \"I\" is Mithal:)\n"
	    +"There are a few other uses for the pasting function. One of "
	    +"them is to provide descriptions that change depending on "
	    +"certan variables.  In this room there is a chest.  Every other "
	    +"time you look at it, it is open.  In the code there is a "
	    +"global variable 'open' that is switched between 1 and 0 every "
	    +"time 'look_chest' is called.  The function returns 'The chest "
	    +"is open' if open == 1, else 'The chest is closed'. "
	    +"Unfortunately, the exact code cannot be put here... since the "
	    +"pasting function would work as you read the help text. *smile* "
	    +"Thus & is used in place of @ in the example code.\n"
	    +"A chest.\nA note.\n");

   
   add_item("note", ({ "long", "It can be read.",
		       "read", "Here is the code for the chest:\n"
       +"   add_item(\"chest\",\"The Chest is \"+\n"
      +"        \"&&look_chest:\"+file_name(this_object())+\"&&\\n\");\n\n"
     +"Again, the & signs are used to represent @ signs.\n"
     +"The code for look_chest:\n\n"
     +"   string do_chest() { \n"
       +"      if( open ) { open = 0; return \"Open.\"; } \n"
       +"      open = 1;  return \"Closed!\";  } \n\n"
     +"  I think this is a much better way to deal with stuff than the famous "
     +" modify_item.\nUse and be happy!\n" }));

      add_item("chest","The chest is "+
               "@@look_chest:"+file_name(this_object())+"@@\n");
   
   open = 0;
   add_exit("east",PATH+"action_verbs2","path");
   add_exit("west",PATH+"action_verbs","path");
   add_exit( "start", MAIN, "path" );
   add_exit( "exit", LEARNING +"search", "path" );
}

string look_chest() {
   if(open) { open = 0; return "Open."; }
   open = 1; return "Closed!";  
}
    
   

// --- END [/mnt/home2/grok/lib/d/learning/help_topics/rooms/add_item/changing_descs.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/rooms/add_item/action_verbs2.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/rooms/add_item/action_verbs2.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627749   Available: 13575103
Inodes: Total: 5242880    Free: 4960133
3536 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/rooms/add_item/action_verbs2.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627749   Available: 13575103
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/****** This room is made my Mithal, learn and enjoy  ***/

#include "path.h"

inherit "/std/room";

void setup() {
   set_short("add_item room #6, making verbs do stuff, better version ");
   set_light(100);

   set_long("add_item room #6, making verbs do stuff, better version\n"
	    +"There are two ways to call a function if a verb is used.  "
	    +"This room demonstrates the second one.  "
       	    +"Lets say you have a rat in a room and randomly ( one out of "
	    +"two times lets say ) want to let players touch it. "
	    +"This is how you could do it.\n"
	    +"A filthy rat and a can.\nA ratnote and a cannote.\n");

   
   add_item("ratnote", ({ "long", "It can be read.",
		       "read", "Here is the code for the rat:\n"
     +"   add_item(\"large filthy rat\", ({\n"
     +"        \"long\",\n"
     +"           \"It looks like it wants to be touched.\\n\"\n"
     +"         ,\"touch\",\n"
     +"           ({ this_object(), \"do_touch\" }) }) );  \n"
     +"When the rat is touched, do_touch() is called.  The do_touch() func "
     +"must return an integer - If the touch was successful it returns a 1, "
     +"if the touch failed the function should return a 0.  Note that a "
     +"success message is given to all in the room.  But, if the person fails "
     +"the add_item code looks for more matches - thinking that the func "
     +"do_touch is the wrong one.  If there is no other function found that "
     +"defines touching rats and that returns a 1, then the game returns the "
     +"message 'You fail to touch a rat'.\n"
     +"The this_object() refrence tells the add_item code what object is "
     +"the direct object of the verb.  Just trust me, and leave it in your "
     +"code without asking why for now.  It is one of those things that can "
     +"give you more flexibility later on.\n" }));
   

   add_item("dirty can", ({
	        "long",
	                   "It looks like it wants to be touched."
		,"touch",
                             ({ this_object(), "always_fail" })
                   }));

      
   add_item("cannote", ({ "long", "It can be read.",
		          "read", "Here is the code for the can:\n"
     +"   add_item(\"dirty can\", ({\n"
     +"        \"long\",\n"
     +"           \"It looks like it wants to be touched.\\n\"\n"
     +"         ,\"touch\",\n"
     +"           ({ this_object(), \"always_fail\" }) }) );  \n"
     +"When the can is touched, always_fail() is called.  This function "
     +"looks like this:\n int always_fail() { return 0; }\n"
     +"in this way if you want a person to be able to use a verb on an "
     +"object, but want to be lazy - and don't want the action to succeed "
     +"( such as a door that can't be broken down ) this is the way to do "
     +"it.\nPlease read ratnote also, if you havn't.\n" }));

   

   add_item("large filthy rat", ({
	        "long",
	                   "It looks like it wants to be touched."
		,"touch",
                             ({ this_object(), "do_touch" })
                   }));

   add_exit("east",ROOM+"verb_failure","door");
   add_exit("west",ROOM+"changing_descs","door");
   add_exit("north",MAIN,"door" );

 }

int  do_touch()
{
  if( random(2) ) {
      /* Code to infect this_player() */
      tell_object(this_player(),"\n ****  You feel deathly sick. ****\n  "
		              "(this is a tell_object(this_player(),...)) \n");
      tell_object(this_player(),
		  "do_touch is returning a 0, indicating failure!\n");
      return 0;
    }

    return 1;
}
    
   

// --- END [/mnt/home2/grok/lib/d/learning/help_topics/rooms/add_item/action_verbs2.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/rooms/add_item/item_conflicts.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/rooms/add_item/item_conflicts.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627748   Available: 13575102
Inodes: Total: 5242880    Free: 4960133
4136 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/rooms/add_item/item_conflicts.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627748   Available: 13575102
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/****** This room is made my Mithal, learn and enjoy  ***/

#include "path.h"

inherit "/std/room";
object key;

void setup() {
   set_short( "'add_item' room telling about resolving item conflicts" );
   set_light( 100 );

   set_long( "This is the room telling about resolving item conflicts in "
            "items defined with add_item.\n"
            "This room still has some basic problems, and shouldn't be used "
            "as an example.\n"
            "Inside, add_item creates one "
            "object per room for its use and assigns an alias to each item "
            "pointing to this object.  Therefore it is likely that "
            "if you have multiple add_items with verbs that call functions "
            "you can run into problems.  In this room there is a fountain and "
            "a pool.  Both of these define 'toss'.  If the wrong function is "
            "called, then your function must return a 0 in order for the "
            "correct function to be called.  Otherwise you will have a bug!  "
            "Please look at this code and notice how each function checks to "
            "make sure that the appropriate pattern is used.  If this code "
            "were removed, then funny things would start to happen.:)\n" );
   
   add_item( "small fountain", 
            ({ "long",
               "You can see a few platinum coins in the water.",
               "toss", ({ this_object(), "do_throw_fount",
                  "<number> platinum [coins|coin] into <direct:object>" })
            }) );
   add_item( "small pool",
            ({ "long", "You can see some silver coins lying around in the "
                       "pool.",
               "toss", ({  this_object(),"do_throw_pool",
                  "<number> silver [coins|coin] into <direct:object>" })
            }) );
   
/*   add_exit( "east", PATH + "item_helper", "path" ); */
   add_exit( "west", PATH + "args_object", "path" );
   add_exit( "start", MAIN, "path" );
   add_exit( "exit", LEARNING +"search", "path" );
} /* setup() */

int do_success_thing( int pool, int silver, int no ) {
   /* This function generates the success message! */
   /* pool and silver are boolean */
   string coinstr, poolstr, nocoins;
   
   if( no < 0 ) return 0;
   
   if( silver ) coinstr = "silver";
   else coinstr = "platinum";
   
   if( pool ) poolstr = "pool";
   else poolstr = "fountain";
   
   nocoins = no+" "+coinstr+" coins";
   if( no == 1 ) nocoins = "one "+coinstr+" coin";
   this_player()->add_succeeded_mess( previous_object(),
           "$N $V "+ nocoins +" into a "+ poolstr +".\n", ({ }) ); 
   return 1;
} /* do_success_thing() */

int do_throw_pool( string command, object *indir, string dir_match, 
                  string indir_match, mixed *args, string pattern ) {
   string nocoins;
   int no;

   tell_object( this_player(), 
               sprintf( "$I$2=do_throw_pool called:\ncommand=%O\n"
                       "dir_match=%O\nargs=%O\n"
                       "pattern=%O$I$0=\n",
                       command, dir_match, 
                       args, pattern ) );
   no = args[ 0 ];
   if( pattern != "<number> silver [coins|coin] into <direct:object>" )
      return do_success_thing( 1, 0, no );

   if( !do_success_thing( 1, 1, no ) ) return 0;
   
   tell_object( this_player(), "You throw coins!\n");

   return 1;
} /* do_throw_pool() */

int do_throw_fount( string command, object *indir, string dir_match, 
                   string indir_match, mixed *args, string pattern ) {
   int no, stored, ran;
   
   tell_object( this_player(), 
               sprintf( "$I$2=do_throw_fount called:\ncommand=%O\n"
                       "dir_match=%O\nargs=%O\n"
                       "pattern=%O$I$0=\n",
                       command, dir_match, 
                       args, pattern ) );
   no = args[ 0 ];
   if( pattern != "<number> platinum [coins|coin] into <direct:object>" )
      return do_success_thing( 0, 1, no );
   if( !do_success_thing( 0, 0, no ) ) return 0; 
   
   tell_object( this_player(),  "*giggle*\n");
   
   return 1;                          
} /* do_throw_fount( )*/
// --- END [/mnt/home2/grok/lib/d/learning/help_topics/rooms/add_item/item_conflicts.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/rooms/add_item/intro.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/rooms/add_item/intro.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627746   Available: 13575100
Inodes: Total: 5242880    Free: 4960133
1737 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/rooms/add_item/intro.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627746   Available: 13575100
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h"

inherit "/std/room";

void setup() {
   set_short( "'add_item' room telling about simple items" );
   set_light( 100 );
   add_property( "determinate", "the " );

   set_long( "This is the first room about add_item(), covering simple items.\n"
            "Go east to see how to make items that can be refered to in more "
            "complicated ways.\n"
            "In your course of describing a room you often mention quite "
            "a few nouns.  In this mud we try to give every noun mentioned a "
            "description a description.  We do this with the function "
            "add_item.  For more information read the note.\n" );
   
   add_item( "noun", "Nouns should have descriptions." );
   add_item( "description", "Descriptions should be witty wherever reasonable." );
   add_item( "discworld", "The mud you are learning to code for." );
   add_item( "information", "See the note." );
   add_sign( "This is a note with some information, perhaps you should read "
                "it.\n",
             "For simple items like 'room' the corresponding code "
               "to represent that item is relatively easy:\n\n"
               "   add_item( \"room\", \"It is a big room.\" );  \n\n"
               "Notice that there is no newline in the description.  "
               "The mudlib adds newline when necessary.  Also "
               "notice that this is not true with set_long where a \\n is "
               "necessary at the end of the description.",
             "note", "note" );
   add_item( "room", "It is a big room." );

   add_exit( "east", PATH +"many_names", "path" );
   add_exit( "start", MAIN, "path" );
   add_exit( "exit", LEARNING +"search", "path" );
} /* setup() */
// --- END [/mnt/home2/grok/lib/d/learning/help_topics/rooms/add_item/intro.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/rooms/add_item/many_names.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/rooms/add_item/many_names.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627746   Available: 13575100
Inodes: Total: 5242880    Free: 4960133
2810 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/rooms/add_item/many_names.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627746   Available: 13575100
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h"

inherit "/std/room";

void setup() {
   set_short( "'add_item' room telling about simple items with many names" );
   set_light( 100 );

   set_long( "This is the room telling about making simple items with many "
            "names.  To help as examples it's been filled with several items "
            "including a small note, candles and some chairs.  Look at the "
            "note to learn more.  Go east to learn about adding verbs to the "
            "items, and west to go to a simpler example.\n" );
   add_item( "small note",
            "Ok things get more complicated here.\n"
            "First of all, the mudlib adds the plural forms of an "
            "item you add to a room.  Thus, \n"
            "  add_item( \"candle\", \"Very nice.\" );\n"
            "will take care of both \"look at candle\" and \"look at "
            "candles\".\n"
            "Secondly, the code:\n"
            "  add_item( \"small note\", \"Ok things ... \n"
            "will take care of both \"look at note\" and \"look at small "
            "note\"\n"
            "And finally, the code:\n"
            "  add_item( ({ \"corridor\", \"long hallway\" }), "
            "\"It is long.\" );\n"
            "will take care of \"look at corridor\", \"look at hallway\", "
            "\"look at long hallway\" and even \"look at long hallways\".\n"
            "If you look at the hallways you'll see the message you get is "
            "not very good as it refers to a single hallway.  To make a "
            "different description when you look at a single "
            "item and all of them, you can use the optional third parameter "
            "to tell the mudlib it shouldn't try to add the plural form. "
            "Thus:\n"
            "  add_item( \"chair\", \"This chair looks about ready to fall "
            "over.\", 1 );\n"
            "  add_item( \"chairs\", \"The chairs look ready to fall "
            "over.\", 1 );\n"
            "Oh, one last thing when listing things in this manner as a rule "
            "of thumb, put the best description first.\n" );
   add_item( "candle", "Very nice." );
   /* Warning, look at the note to see why this is not a good example */
   add_item( ({ "corridor", "long hallway" }), "It is long." );
   add_item( "chair", "This chair looks about ready to fall over", 1 );
   add_item( "chairs", "The chairs look ready to fall over", 1 );

   add_item( "item", "You don't see any since noone coded one yet!" );
   add_item( "reference", "Like one that you would find in a theusaures." );
   add_item( "room", "It is a big room." );

   add_exit( "east", PATH +"verbs", "path");
   add_exit( "west", PATH +"intro", "path");
   add_exit( "start", MAIN, "path" );
   add_exit( "exit", LEARNING +"search", "path" );
} /* setup() */
// --- END [/mnt/home2/grok/lib/d/learning/help_topics/rooms/add_item/many_names.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/rooms/situations/sitroom4.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/rooms/situations/sitroom4.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627745   Available: 13575099
Inodes: Total: 5242880    Free: 4960133
4130 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/rooms/situations/sitroom4.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627745   Available: 13575099
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* Basic situation room  - Shaggy */
#include <situations.h>
#include "path.h"

inherit "/std/outside";

void setup() {
   /* The "commented functions" and "keywords" properties are specific for 
    * rooms in the learning domain and is used to make it possible to search
    * for subjects. 
    * See /d/learning/handlers/search.c for the way this is done.
    */
  add_property( "commented functions", 
                ({  }) );
  add_property( "keywords", 
                ({ "situation" }) );
  
  set_short("Exclusion and random words situations example room");
  set_light(100);
  set_long("This is a of situations example that is automated "
           "and makes use of random words and exclusion.  "
           "It is at a pier where one ship may dock at a time.  "
           "Exclusion means one situation (or set of them) "
           "prevents another from happenning at the same time "
           "and vice versa.  "
           "Random words mean that the text changes each time.  "
           "Just wait to experience the situations within a minute or so.  "
           "Please more here to see how it is done.\n"
           "%^CYAN%^Functions shown:%^RESET%^\n"
           "%^YELLOW%^add_situation,  automate_situation.%^RESET%^\n");
  
  add_exit( "back", LEARNING +"search", "path" );
  add_exit( "next", SIT+"sitroom5", "path" );
  add_exit( "exit", ENTRANCE, "path" );
  
  add_item( "pier", "There is small pier here." );

  /* This is the first "boat" situation */
  add_situation( "boat1", 
    new(class situation,
      start_mess: "A little fishing boat comes up to the pier.  "
         "It has the name \"#1\" painted on the side.\n"
         "A fisherman jumps off the boat and ties its painter to a post.",
      chats: ({"The little boat bobs up and down next to the pier.",
               "A fisherman hops off the little boat." }),
      chat_rate: ({ 20, 30 }),
      extra_look: "There is a little boat here.",
      add_items: ({ ({ ({ "#1","little boat" }), 
        "There is little fishing boat tied up at the pier here.  "
        "The name \"#1\" is painted on the side."   }) }),
      end_mess: "The fishermen get back on board and "
         "the little boat moves on.",
      random_words: ({ ({ "Honey Toad", "Piker", "Bing" }) })
    )
  );

  /* This is the other "boat" situation */
  add_situation( "boat2", 
    new(class situation,
      start_mess: "A fat trading vessel comes up to the pier.  "
         "It has the name \"#1\" painted on the prow.\n"
         "A sailor jumps off and ties the vessel to a post.",
      chats: ({"The trading vessel thumps against the pier.",
               "A sailor comes ashore.",
               "#2 is unloaded from the vessel.",
               "#3 is loaded onto the vessel." }),
      chat_rate: ({ 10, 20 }),
      extra_look: "There is a trading vessel docked here.",
      add_items: ({ ({ ({ "#1","fat vessel","ship" }), 
        "There is a trading vessel docked at the pier here.  "
          "The name \"#1\" is painted on the prow." }) }),
      end_mess: "The sailors get back on board and "
         "the trading vessel departs.",
      random_words: ({ ({ "Fat Cat", "Scumbag", "Cap Pig" }), 
          ({ "A pair of slaves", "A bale of wool", "A bolt of cloth" }), 
          ({ "A stock option", "A cage of frogs", "A wooden crate" }), })
    )
  );

  /* This makes the set of situations above occur automatically and randomly
     through the day.  WHEN_ANY_TIME specifies that it can happen
     at any time of day.   more /include/situations.h to get the list
     of possible times of day filters.  300 is the chance out of 1000
     that the situation is started every 61 seconds.  Note that the
     situation will not wait for a player to enter -- it may be part
     way through when the room first loads. */

  /* boat2 automated: categorized a "boat" */
  automate_situation( "boat2", 61, WHEN_ANY_TIME, 300, "boat" );
  /* boat1 automated: categorized a "boat" */
  automate_situation( "boat1", 50, WHEN_ANY_TIME, 200, "boat" );
  /* No boat situations will get activated at the same time */

} /* setup() */

// --- END [/mnt/home2/grok/lib/d/learning/help_topics/rooms/situations/sitroom4.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/rooms/situations/sitroom1.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/rooms/situations/sitroom1.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627744   Available: 13575098
Inodes: Total: 5242880    Free: 4960133
2359 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/rooms/situations/sitroom1.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627744   Available: 13575098
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* situation room  - Shaggy */
#include <situations.h>
#include "path.h"

inherit "/std/room";

void setup() {
   /* The "commented functions" and "keywords" properties are specific for 
    * rooms in the learning domain and is used to make it possible to search
    * for subjects. 
    * See /d/learning/handlers/search.c for the way this is done.
    */
  add_property( "commented functions", 
                ({  }) );
  add_property( "keywords", 
                ({ "situation" }) );
  
  set_short("Basic situation example room");
  set_light(100);
  set_long("This is a very simple situation example.  "
           "To start it \"press\" the button.  "
           "Please more here to see how it is done.\n"
           "%^CYAN%^Functions shown:%^RESET%^\n"
           "%^YELLOW%^add_situation,  change_situation.%^RESET%^\n");
  
  add_exit( "next", SIT+"sitroom2", "path" );
  add_exit( "back", LEARNING +"search", "path" );
  add_exit( "exit", ENTRANCE, "path" );
  
  add_item( "button", "There is a button on the wall you might \"press\".");

  /* add a situation called frog about a little frog.
     Note that the chat_rate is the minimum and maximum delay 
     between chats.  Any other chats on the room are unaffected
     and independent. */
  add_situation( "frog", 
    new(class situation, 
        start_mess: "A little frog appears from nowhere.\n",
        extra_look: "There is a little frog here.",
        add_items: ({ ({ "frog", "The frog is small but happy." }) }),
        chat_rate: ({ 10, 30 }),
        chats: ({"The little frog hops on the spot.",
                 "The little frog says:  Ribbit." }) ,
        end_mess: "The little frog disappears into thin air."
    )
  );

} /* setup() */

/* press button */
int do_press() 
{
  tell_object(this_player(),"You press the button.\n");

  tell_object(this_player(),"%^YELLOW%^You just started the frog situation.  "
              "It will go for 60 seconds.  It adds an add_item ( look frog ), "
              "an extra_look to the room ( look ) and some chats.%^RESET%^\n");

  /* start the situation called frog and have it go for 60 seconds */
  change_situation( "frog", 60 );

  return 1;

} /* do_press() */

/* The init() function just sets up the button */
void init()
{
  this_player()->add_command( "press", this_object(), "button" );
  ::init();

}/* init() */
// --- END [/mnt/home2/grok/lib/d/learning/help_topics/rooms/situations/sitroom1.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/rooms/situations/sitroom2.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/rooms/situations/sitroom2.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627742   Available: 13575096
Inodes: Total: 5242880    Free: 4960133
3586 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/rooms/situations/sitroom2.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627742   Available: 13575096
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* situation room  - Shaggy */
#include <situations.h>
#include "path.h"

inherit "/std/outside";

void setup() {
   /* The "commented functions" and "keywords" properties are specific for 
    * rooms in the learning domain and is used to make it possible to search
    * for subjects. 
    * See /d/learning/handlers/search.c for the way this is done.
    */
  add_property( "commented functions", 
                ({  }) );
  add_property( "keywords", 
                ({ "situation" }) );
  
  set_short("Combination of situations example room");
  set_light(40);
  set_long("This is a combination of situations example.  "
           "It is outside in a dark neighbourhood.  "
           "To start a combination of situations \"press\" the button.  "
           "Please more here to see how it is done.\n"
           "%^CYAN%^Functions shown:%^RESET%^\n"
           "%^YELLOW%^add_situation,  change_situation.%^RESET%^\n");
  
  add_exit( "next", SIT+"sitroom3", "path" );
  add_exit( "back", LEARNING +"search", "path" );
  add_exit( "exit", ENTRANCE, "path" );
  
  add_item( "button", "There is a button on the wall you might \"press\".");

  add_item( "house", "There are old wooden houses here.");

  /* add a situation called house about a house */
  add_situation( "house", 
    new(class situation,
      add_items: ({ 
        ({ "nearby house", "The wooden house has thin walls so you can "
             "easily hear what goes on inside." }),
        ({ "voice", "There are voices coming from a nearby house here." }) 
            }),
      end_mess: "You hear running footsteps in the alley on the other side "
             "of the house.\nThe nearby wooden house falls eerily silent."
    )
  );
  /* add a situation called argue about an argument in the house */
  add_situation( "argue", 
    new(class situation,
      chats:({"A man yells shrilly, something that sounds like an accusation.",
        "A man with a deep voice threatens loudly.",
        "A woman's voice calls for calm." }),
      chat_rate: ({ 10, 30 })
   )    
  );  
  /* add a situation called murder about a nasty conclusion */
  add_situation( "murder", 
    new(class situation,
      start_mess:"There is a loud bang, as if something fell over or "
        "was struck solidly within the wooden house here.", 
      chats:({"A man says something in shocked voice.",
              "A woman's voice hisses for silence.",
              "There is the sound of something heavy being moved inside the "
              "wooden house here." }),
      chat_rate: ({ 5, 15 })
    )
  );

} /* setup() */

/* press button */
int do_press() 
{
  tell_object(this_player(),"You press the button.\n");

  tell_object(this_player(),"%^YELLOW%^You just started the argue and house "                "situations.  It will go for 80 seconds and then the murder "
              "and house situations will replace it for 40 more seconds.  "
              "As house follows itself immediately it just continues without "
              "being changed and its end message is given only at the very " 
              "end.%^RESET%^\n");

  /* start the situation called argue and house together for 80 seconds 
     and then murder and house together for 40 seconds.  You can
     specify as many situations as you need in the comma separated list. */
  change_situation( ({ "argue,house", "murder,house" }), ({ 80, 40 }) );

  return 1;

} /* do_press() */

/* The init() function just sets up the button */
void init()
{
  this_player()->add_command( "press", this_object(), "button" );
  ::init();

}/* init() */
// --- END [/mnt/home2/grok/lib/d/learning/help_topics/rooms/situations/sitroom2.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/rooms/situations/sitroom5.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/rooms/situations/sitroom5.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627741   Available: 13575095
Inodes: Total: 5242880    Free: 4960133
3071 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/rooms/situations/sitroom5.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627741   Available: 13575095
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* Basic situation room  - Shaggy */
#include <situations.h>
#include "path.h"

inherit "/std/outside";

void setup() {
   /* The "commented functions" and "keywords" properties are specific for 
    * rooms in the learning domain and is used to make it possible to search
    * for subjects. 
    * See /d/learning/handlers/search.c for the way this is done.
    */
  add_property( "commented functions", 
                ({  }) );
  add_property( "keywords", 
                ({ "situation" }) );
  
  set_short("Situation with a background state example room");
  set_light(100);
  set_long("This is a situations example that is automated "
           "and makes use of a background situation.  "
           "This means that when the automated manager has not "
           "fired up the labelled automated situations you specified "
           "there is another situation that goes by default the rest "
           "of the time.  It is marked in the list by having -1 "
           "for its duration.  "
           "Please more here to see how it is done.\n"
           "%^CYAN%^Functions shown:%^RESET%^\n"
           "%^YELLOW%^add_situation,  automate_situation.%^RESET%^\n");
  
  add_exit( "back", LEARNING +"search", "path" );
  add_exit( "exit", ENTRANCE, "path" );
  
  /* This is the background for the tramp */
  add_situation( "tramp_sleeping", 
    new(class situation,
      chats: ({"The tramp snores." }),
      chat_rate: ({ 60,120 }),
      extra_look: "There is a tramp sleeping here.",
      add_items: ({ ({ "tramp", 
        "There is dusty and fairly dirty tramp curled up and sleeping "
        "at one side of the road."   }) })
    )
  );

  /* This is the tramp awake */
  add_situation( "tramp_awake", 
    new(class situation,
      start_mess: "The tramp leaps to his feet, instantly alert.",
      chats: ({"The tramp produces some brightly coloured balls and juggles "
                 "them.",
               "The tramp does a handstand.",
               "The tramp leaps into the air and touches his toes.",
               "The tramp does a little dance.",
               "Dust billows from the frenetic tramp's clothes."
             }),
      chat_rate: ({ 20,30 }),
      extra_look: "There is a tramp bouncing around here.",
      add_items: ({ ({ "tramp", 
        "The dusty tramp is bright eyed and very awake."  }) }),
      end_mess: "The tramp flops to the ground and slowly curls into a ball."
    )
  );

  /* This makes the "tramp_awake' situation above occur automatically and 
     randomly through the day.  WHEN_ANY_TIME specifies that it can happen
     at any time of day.   more /include/situations.h to get the list
     of possible times of day filters.  300 is the chance out of 1000
     that the situation is started every 61 seconds.  The "tramp_sleeping"
     is not part of the set because it has -1 for a duration.  It 
     occurs whenever "tramp_awake" is off.  */

  automate_situation( ({ "tramp_sleeping", "tramp_awake" }), 
                      ({ -1, 61 }) , WHEN_ANY_TIME, 300 );

} /* setup() */

// --- END [/mnt/home2/grok/lib/d/learning/help_topics/rooms/situations/sitroom5.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/rooms/situations/sitroom3.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/rooms/situations/sitroom3.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627740   Available: 13575094
Inodes: Total: 5242880    Free: 4960133
3427 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/rooms/situations/sitroom3.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627740   Available: 13575094
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* Basic situation room  - Shaggy */
#include <situations.h>
#include "path.h"

inherit "/std/outside";

object warrior;

void setup() {
   /* The "commented functions" and "keywords" properties are specific for 
    * rooms in the learning domain and is used to make it possible to search
    * for subjects. 
    * See /d/learning/handlers/search.c for the way this is done.
    */
  add_property( "commented functions", 
                ({  }) );
  add_property( "keywords", 
                ({ "situation" }) );
  
  set_short("Automated situations (with function pointers) example room");
  set_light(40);
  set_long("This is a combination of situations example that is automated "
           "and makes use of function pointers.  "
           "It is outside in a run down neighbourhood.  "
           "Just wait to experience the situations within a minute or so.  "
           "Please more here to see how it is done.\n"
           "%^CYAN%^Functions shown:%^RESET%^\n"
           "%^YELLOW%^add_situation,  automate_situation.%^RESET%^\n");
  
  add_exit( "next", SIT+"sitroom4", "path" );
  add_exit( "back", LEARNING +"search", "path" );
  add_exit( "exit", ENTRANCE, "path" );
  
  add_item( "window", "There is window up high with maroon curtains." );
  add_item( "curtain", "That is all you can see, sorry." );

  /* This is the first part of "seamstress" at work */
  add_situation( "sew1", 
    new(class situation,
      chats: ({"There is a distinct giggle.",
        "A woman's giggle drifts down from an upstairs window.",
        "A man murmurs something upstairs." }),
      chat_rate: ({ 10, 15 })
    )
  );
  /* This is the second part of "seamstress" at work 
     The end_func is a function to call at the end to do something
     a bit special. */

  add_situation( "sew2", 
    new(class situation, 
      start_mess: "There is a whump like something landing on a matress "
         "above.", 
      chats:({
        "A high-pitched giggle reaches the street from above.",
        "There is the creak of complaining coils from an upstairs window.",
        "You can make out a muffled voice from above." }),
      chat_rate: ({ 10, 15 }),
      end_mess: "The upstairs noises stop.\nYou hear the clink of coinage.",
      end_func: (: call_out("make_warrior",5) :)
    )    
  );
  /* This is an empty "pause" situation */
  add_situation( "pause", new(class situation) );

  /* This makes the set of situations above occur automatically and randomly
     through the day.  WHEN_ANY_TIME specifies that it can happen
     at any time of day.   more /include/situations.h to get the list
     of possible times of day filters.  500 is the chance out of 1000
     that this situation is started every 80 seconds.  Note that the
     situation will not wait for a player to enter -- it may be part
     way through when the room first loads. */

  automate_situation( ({ "sew1","sew2","pause" }), ({ 25,35,20 }), 
    WHEN_ANY_TIME, 500 );

} /* setup() */

/* This function makes warriors */
void make_warrior() 
{
  if (warrior) 
    call_out( (: $1->move( "/room/rubbish", 
     "", $1->the_short()+" races off to kill something.") :), 5, warrior );

  warrior = clone_object( "/d/am/chars/am_warrior_human" );
  warrior->move(this_object(),warrior->the_short()+
    " enters the street from a building nearby looking pleased with "
    +warrior->query_objective()+"self.");

} /* make_warrior() */
// --- END [/mnt/home2/grok/lib/d/learning/help_topics/rooms/situations/sitroom3.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/rooms/crowd/am_poor_beggar.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/rooms/crowd/am_poor_beggar.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627739   Available: 13575093
Inodes: Total: 5242880    Free: 4960133
5534 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/rooms/crowd/am_poor_beggar.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627739   Available: 13575093
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
inherit "/obj/monster";

#include "/d/am/chars/path.h"
#include <money.h>

int going;
string from;
string spouse;
int start_money;

void initial_chats() {
   load_chat( 15, ({
      1, "'Money for the poor.",
      1, "'Please give me some money.",
      1, ":pulls on your leg.",
      1, ":rattles "+query_possessive()+" tin.",
      1, ":mutters something about a "+spouse+" and 7 children.",
      1, ":looks at you with big brown eyes.",
      1, "'Who will help me?",
      1, ":looks down at the ground and sobs.",
      1, "#do_gossip_say:Did you know $name$ said $mess$?",
      1, "@open door",
   }) );
}

void fix_gender( int gender ) {
   set_gender( gender );
   set_long( "This is a poor beggar.  Perhaps you should give "+
            (string)query_objective() +" some money.\n" );
/* Added so that the chat about spouse and 7 children is correct for gender */
   spouse = (query_gender()==1) ? "wife" : "husband" ;
}

void setup() {
   set_name("beggar");
   set_short( "poor beggar" );
   set_main_plural( "poor beggars" );
   add_adjective("poor");
   add_alias("beggar");
   set_race("human");
   set_level( 3 + random( 10 ) );
   set_wimpy( 80 );
   set_al( HOSPITAL->pick_al() / 10 );
   fix_gender(1+random(2));
   add_move_zone("docks");
   add_move_zone("underdocks");
   start_money = 3 + random( 300 );
   adjust_money( start_money, "Ankh-Morpork pence" );

   initial_chats();
        
   add_effect( "/std/effects/npc/gossip", 5 );
   add_effect( "/std/effects/npc/given", ({ this_object(), "given_thing" }));
//   add_effect( "/std/effects/npc/they_died", ({ this_object(), 
//        "loot_coins" }) );
} /* setup() */

/*
 * At the bank.  Dump all but some start money.
 */
void done_everything() {
   going = 0;
} /* done_everything() */

void at_pub() {
   mixed *stuff;
   string dest;

   /* Ok.  Get them to start buy stuff until they cannot any more */
   stuff = environment()->query_menu_items();
   if (!stuff) {
      /* Not at a pub yet? */
      /* Darn!  try again... */
      dest = PUBS[random(sizeof(PUBS))];
      /* Take them to a pub.  Drink their money */
      add_effect( "/std/effects/npc/goto_destination",
                  ({ dest, ({ this_object(), "at_pub" }), 20 }) );
   } else {
      /* Add the drink silly effect... */
      add_effect( "/std/effects/npc/drink_silly",
                  ({ this_object(), "done_drinking" }) );
   }
} /* at_pub() */

void hassle_opposite_gender() {
  object *things;
  string action;

  things=filter(all_inventory(environment()),
      (: $1->query_gender()==3-($2->query_gender()) :), this_object() );

  if (sizeof(things)) {
     action=({ ":leers at TARGET.",
        ":pats TARGET on the bum.",
        "say How's it going sweetheart?",
        ":grins at TARGET.",
        ":wolf whistles at TARGET." })[random(5)];
     do_command(replace(action,"TARGET",
        things[random(sizeof(things))]->the_short() ));
     return;
  }
  do_command( ({ ":cracks a rude joke.",
                "drool",
                "laugh out loud",
                "say So where are the babes?",
                "burp loudly" })[random(5)] );
}

void done_drinking() {
   /* load abusive chats */
   load_chat( 60, ({
      1, "'You rich prats never give me any respect.",
      1, "'Give me some money for booze.",
      5, "#hassle_opposite_gender",
      1, ":ponders "+query_possessive()+" empty tin.",
      1, ":chuckles something about a "+spouse+" and 7 children.",
      1, ":grins toothily at you.",
      1, "@burp",
      1, "#do_gossip_say:Do you even care that $name$ said $mess$?"
   }) );
   
   call_out( function() { this_object()->initial_chats(); 
               this_object()->add_effect( "/std/effects/npc/goto_destination",
               ({ from, ({ this_object(), "done_everything" }), 5 }) ); },
             random(300)+300 );

} /* done_drinking() */

void given_thing(object player, object ob, string mess) {
   string dest;

   if (ob->id(MONEY_ALIAS)) {
      if (!going) {
         if(ob->query_value_in("Ankh-Morpork") > 300) {
            this_player()->adjust_al( -5 );
         }
         dest = PUBS[random(sizeof(PUBS))];
         add_effect( "/std/effects/npc/no_follow", 0 );
         /* Take them to a pub.  Drink their money */
         add_effect( "/std/effects/npc/goto_destination",
                     ({ dest, ({ this_object(), "at_pub" }), 20 }) );
      }
      return ;
   }

   if (!ob->query_value()) {
      init_command("drop "+implode(ob->query_adjectives(), " ")+
                           " "+ob->query_name());
      return ;
   }

   if (!going) {
      from = file_name(environment());
      this_player()->adjust_al( -5 );
      going = 1;
      from = file_name(environment());
      init_command("'Thanks!  I always wanted "+
                   ob->a_short());
      init_command("womble");
      dest = SHOPS[random(sizeof(SHOPS))];
      add_effect( "/std/effects/npc/no_follow", 0 );
      /* Take them to a shop.  Sell everything. */
      add_effect( "/std/effects/npc/goto_destination",
                  ({ dest, "sell", 20 }) );
      dest = PUBS[random(sizeof(PUBS))];
      /* Take them to a pub.  Drink their money */
      add_effect( "/std/effects/npc/goto_destination",
                  ({ dest, ({ this_object(), "at_pub" }), 20 }) );
   }
} /* given_thing() */

void loot_coins() {
   call_out( (: do_command(":looks around nervously.") :), 2 );
   call_out( (: do_command("get coins from corpse") :), 5+random(10) );
} /* loot_coins() */







// --- END [/mnt/home2/grok/lib/d/learning/help_topics/rooms/crowd/am_poor_beggar.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/rooms/crowd/crowd_merge_shadow.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/rooms/crowd/crowd_merge_shadow.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627737   Available: 13575091
Inodes: Total: 5242880    Free: 4960133
1628 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/rooms/crowd/crowd_merge_shadow.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627737   Available: 13575091
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
#include <move_failures.h>

inherit "/std/effect_shadow";

int actually_attacked=0;

varargs void crowd_merge() {
  object crowd,thing;
  object *list;

  /* Original crowd may be gone -- kill this effect if that is so */
  crowd=(arg())[0];
  if (!crowd) {
    int *effs=player->effects_matching("npc.crowd.merge");
    player->delete_effect(effs[0]);
    return; 
  }

//  tell_creator("shaggy","hmm: %O %O\n",player,player->query_attacker_list());

  if (sizeof(player->query_attacker_list()) ||
     (player->query_hp()<player->query_max_hp())) {
    call_out( "crowd_merge", 60 );
    return;
  }

  if (actually_attacked) {
    foreach( thing in filter(all_inventory(environment(player)), 
          (: living($1) :) )) {
      if ( (list = thing->query_attacker_list())
           && member_array(player,list) != -1 ) {
        call_out( "crowd_merge", 60 );
        return;
      }
    }
  }
        
  if ( environment(player) == environment(crowd) ) {
    crowd->merge_crowd_member( player );
    return;      
  }
  player->add_effect( "/std/effects/npc/goto_destination",
    ({ file_name(environment(crowd)), 
       ({ this_object(), "crowd_merge" }), 1 }) );
} /* crowd_merge() */

int attack_by( object thing ) {
//  tell_creator("shaggy","%O attacked by %O\n",player,thing);
  actually_attacked=1;
  return player->attack_by( thing );
}

object crowd_object( ) { return (arg())[0]; }

object crowd_number() { return (arg())[1]; }

/** @ignore yes */
object do_death( object thing) {
   if ((arg())[0]) ((arg())[0])->crowd_member_died();
   return player->do_death( thing );
} /* dest_me() */// --- END [/mnt/home2/grok/lib/d/learning/help_topics/rooms/crowd/crowd_merge_shadow.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/rooms/crowd/am_crippled_beggar.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/rooms/crowd/am_crippled_beggar.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627736   Available: 13575090
Inodes: Total: 5242880    Free: 4960133
5568 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/rooms/crowd/am_crippled_beggar.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627736   Available: 13575090
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
inherit "/obj/monster";

#include "/d/am/chars/path.h"
#include <money.h>

int going;
string from;
string spouse;
int start_money;

void initial_chats() {
   load_chat( 15, ({
      1, "'Money for the crippled.",
      1, "'Please give me some money.",
      1, ":pulls on your leg.",
      1, ":rattles "+query_possessive()+" tin.",
      1, ":mutters something about a "+spouse+" and 7 children.",
      1, ":looks at you with big brown eyes.",
      1, "'Who will help me?",
      1, ":hobbles around pathetically.",
      1, "#do_gossip_say:Did you know $name$ said $mess$?",
      1, "@open door",
   }) );
}

void fix_gender( int gender ) {
   set_gender( gender );
   set_long( "This is a crippled beggar.  "
     "One of "+query_possessive()+
     " legs has wasted so that it ressembles a gnarled branch.\n" );
/* Added so that the chat about spouse and 7 children is correct for gender */
   spouse = (query_gender()==1) ? "wife" : "husband" ;
}

void setup() {
   set_name("beggar");
   set_short( "crippled beggar" );
   set_main_plural( "crippled beggars" );
   add_adjective("crippled");
   add_alias("beggar");
   set_race("human");
   set_level( 3 + random( 10 ) );
   set_wimpy( 80 );
   set_al( HOSPITAL->pick_al() / 10 );
   fix_gender(1+random(2));
   add_move_zone("docks");
   add_move_zone("underdocks");
   start_money = 3 + random( 300 );
   adjust_money( start_money, "Ankh-Morpork pence" );

   initial_chats();
        
   add_effect( "/std/effects/npc/gossip", 5 );
   add_effect( "/std/effects/npc/given", ({ this_object(), "given_thing" }));
//   add_effect( "/std/effects/npc/they_died", ({ this_object(), 
//        "loot_coins" }) );
} /* setup() */

/*
 * At the bank.  Dump all but some start money.
 */
void done_everything() {
   going = 0;
} /* done_everything() */

void at_pub() {
   mixed *stuff;
   string dest;

   /* Ok.  Get them to start buy stuff until they cannot any more */
   stuff = environment()->query_menu_items();
   if (!stuff) {
      /* Not at a pub yet? */
      /* Darn!  try again... */
      dest = PUBS[random(sizeof(PUBS))];
      /* Take them to a pub.  Drink their money */
      add_effect( "/std/effects/npc/goto_destination",
                  ({ dest, ({ this_object(), "at_pub" }), 20 }) );
   } else {
      /* Add the drink silly effect... */
      add_effect( "/std/effects/npc/drink_silly",
                  ({ this_object(), "done_drinking" }) );
   }
} /* at_pub() */

void hassle_opposite_gender() {
  object *things;
  string action;

  things=filter(all_inventory(environment()),
      (: $1->query_gender()==3-($2->query_gender()) :), this_object() );

  if (sizeof(things)) {
     action=({ ":leers at TARGET.",
        ":pats TARGET on the bum.",
        "say How's it going sweetheart?",
        ":grins at TARGET.",
        ":wolf whistles at TARGET." })[random(5)];
     do_command(replace(action,"TARGET",
        things[random(sizeof(things))]->the_short() ));
     return;
  }
  do_command( ({ ":cracks a rude joke.",
                "drool",
                "laugh out loud",
                "say So where are the babes?",
                "burp loudly" })[random(5)] );
}

void done_drinking() {
   /* load abusive chats */
   load_chat( 60, ({
      1, "'You rich prats never give me any respect.",
      1, "'Give me some money for booze.",
      5, "#hassle_opposite_gender",
      1, ":ponders "+query_possessive()+" empty tin.",
      1, ":chuckles something about a "+spouse+" and 7 children.",
      1, ":grins toothily at you.",
      1, "@burp",
      1, "#do_gossip_say:Do you even care that $name$ said $mess$?"
   }) );
   
   call_out( function() { this_object()->initial_chats(); 
               this_object()->add_effect( "/std/effects/npc/goto_destination",
               ({ from, ({ this_object(), "done_everything" }), 5 }) ); },
             random(300)+300 );

} /* done_drinking() */

void given_thing(object player, object ob, string mess) {
   string dest;

   if (ob->id(MONEY_ALIAS)) {
      if (!going) {
         if(ob->query_value_in("Ankh-Morpork") > 300) {
            this_player()->adjust_al( -5 );
         }
         dest = PUBS[random(sizeof(PUBS))];
         add_effect( "/std/effects/npc/no_follow", 0 );
         /* Take them to a pub.  Drink their money */
         add_effect( "/std/effects/npc/goto_destination",
                     ({ dest, ({ this_object(), "at_pub" }), 20 }) );
      }
      return ;
   }

   if (!ob->query_value()) {
      init_command("drop "+implode(ob->query_adjectives(), " ")+
                           " "+ob->query_name());
      return ;
   }

   if (!going) {
      from = file_name(environment());
      this_player()->adjust_al( -5 );
      going = 1;
      from = file_name(environment());
      init_command("'Thanks!  I always wanted "+
                   ob->a_short());
      init_command("womble");
      dest = SHOPS[random(sizeof(SHOPS))];
      add_effect( "/std/effects/npc/no_follow", 0 );
      /* Take them to a shop.  Sell everything. */
      add_effect( "/std/effects/npc/goto_destination",
                  ({ dest, "sell", 20 }) );
      dest = PUBS[random(sizeof(PUBS))];
      /* Take them to a pub.  Drink their money */
      add_effect( "/std/effects/npc/goto_destination",
                  ({ dest, ({ this_object(), "at_pub" }), 20 }) );
   }
} /* given_thing() */

void loot_coins() {
   call_out( (: do_command(":looks around nervously.") :), 2 );
   call_out( (: do_command("get coins from corpse") :), 5+random(10) );
} /* loot_coins() */







// --- END [/mnt/home2/grok/lib/d/learning/help_topics/rooms/crowd/am_crippled_beggar.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/rooms/crowd/am_diseased_beggar.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/rooms/crowd/am_diseased_beggar.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627735   Available: 13575089
Inodes: Total: 5242880    Free: 4960133
5562 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/rooms/crowd/am_diseased_beggar.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627735   Available: 13575089
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
inherit "/obj/monster";

#include "/d/am/chars/path.h"
#include <money.h>

int going;
string from;
string spouse;
int start_money;

void initial_chats() {
   load_chat( 15, ({
      1, "'Money for the diseased.",
      1, "'Please give me some money.",
      1, ":pulls on your leg.",
      1, ":rattles "+query_possessive()+" tin.",
      1, ":mutters something about a "+spouse+" and 7 children.",
      1, ":looks at you with big brown eyes.",
      1, "'Who will help me?",
      1, ":picks at some sores.",
      1, "#do_gossip_say:Did you know $name$ said $mess$?",
      1, "@open door",
   }) );
}

void fix_gender( int gender ) {
   set_gender( gender );
   set_long( "This is a diseased beggar.  "
     "Looking at the running sores covering "+query_possessive()+
     " body makes your skin crawl.\n");
/* Added so that the chat about spouse and 7 children is correct for gender */
   spouse = (query_gender()==1) ? "wife" : "husband" ;
}

void setup() {
   set_name("beggar");
   set_short( "diseased beggar" );
   set_main_plural( "diseased beggars" );
   add_adjective("diseased");
   add_alias("beggar");
   set_race("human");
   set_level( 3 + random( 10 ) );
   set_wimpy( 80 );
   set_al( HOSPITAL->pick_al() / 10 );
   fix_gender(1+random(2));
   add_move_zone("docks");
   add_move_zone("underdocks");
   start_money = 3 + random( 300 );
   adjust_money( start_money, "Ankh-Morpork pence" );

   initial_chats();
        
   add_effect( "/std/effects/npc/gossip", 5 );
   add_effect( "/std/effects/npc/given", ({ this_object(), "given_thing" }));
//   add_effect( "/std/effects/npc/they_died", ({ this_object(), 
//        "loot_coins" }) );
} /* setup() */

/*
 * At the bank.  Dump all but some start money.
 */
void done_everything() {
   going = 0;
} /* done_everything() */

void at_pub() {
   mixed *stuff;
   string dest;

   /* Ok.  Get them to start buy stuff until they cannot any more */
   stuff = environment()->query_menu_items();
   if (!stuff) {
      /* Not at a pub yet? */
      /* Darn!  try again... */
      dest = PUBS[random(sizeof(PUBS))];
      /* Take them to a pub.  Drink their money */
      add_effect( "/std/effects/npc/goto_destination",
                  ({ dest, ({ this_object(), "at_pub" }), 20 }) );
   } else {
      /* Add the drink silly effect... */
      add_effect( "/std/effects/npc/drink_silly",
                  ({ this_object(), "done_drinking" }) );
   }
} /* at_pub() */

void hassle_opposite_gender() {
  object *things;
  string action;

  things=filter(all_inventory(environment()),
      (: $1->query_gender()==3-($2->query_gender()) :), this_object() );

  if (sizeof(things)) {
     action=({ ":leers at TARGET.",
        ":pats TARGET on the bum.",
        "say How's it going sweetheart?",
        ":grins at TARGET.",
        ":wolf whistles at TARGET." })[random(5)];
     do_command(replace(action,"TARGET",
        things[random(sizeof(things))]->the_short() ));
     return;
  }
  do_command( ({ ":cracks a rude joke.",
                "drool",
                "laugh out loud",
                "say So where are the babes?",
                "burp loudly" })[random(5)] );
}

void done_drinking() {
   /* load abusive chats */
   load_chat( 60, ({
      1, "'You rich prats never give me any respect.",
      1, "'Give me some money for booze.",
      5, "#hassle_opposite_gender",
      1, ":ponders "+query_possessive()+" empty tin.",
      1, ":chuckles something about a "+spouse+" and 7 children.",
      1, ":grins toothily at you.",
      1, "@burp",
      1, "#do_gossip_say:Do you even care that $name$ said $mess$?"
   }) );
   
   call_out( function() { this_object()->initial_chats(); 
               this_object()->add_effect( "/std/effects/npc/goto_destination",
               ({ from, ({ this_object(), "done_everything" }), 5 }) ); },
             random(300)+300 );

} /* done_drinking() */

void given_thing(object player, object ob, string mess) {
   string dest;

   if (ob->id(MONEY_ALIAS)) {
      if (!going) {
         if(ob->query_value_in("Ankh-Morpork") > 300) {
            this_player()->adjust_al( -5 );
         }
         dest = PUBS[random(sizeof(PUBS))];
         add_effect( "/std/effects/npc/no_follow", 0 );
         /* Take them to a pub.  Drink their money */
         add_effect( "/std/effects/npc/goto_destination",
                     ({ dest, ({ this_object(), "at_pub" }), 20 }) );
      }
      return ;
   }

   if (!ob->query_value()) {
      init_command("drop "+implode(ob->query_adjectives(), " ")+
                           " "+ob->query_name());
      return ;
   }

   if (!going) {
      from = file_name(environment());
      this_player()->adjust_al( -5 );
      going = 1;
      from = file_name(environment());
      init_command("'Thanks!  I always wanted "+
                   ob->a_short());
      init_command("womble");
      dest = SHOPS[random(sizeof(SHOPS))];
      add_effect( "/std/effects/npc/no_follow", 0 );
      /* Take them to a shop.  Sell everything. */
      add_effect( "/std/effects/npc/goto_destination",
                  ({ dest, "sell", 20 }) );
      dest = PUBS[random(sizeof(PUBS))];
      /* Take them to a pub.  Drink their money */
      add_effect( "/std/effects/npc/goto_destination",
                  ({ dest, ({ this_object(), "at_pub" }), 20 }) );
   }
} /* given_thing() */

void loot_coins() {
   call_out( (: do_command(":looks around nervously.") :), 2 );
   call_out( (: do_command("get coins from corpse") :), 5+random(10) );
} /* loot_coins() */







// --- END [/mnt/home2/grok/lib/d/learning/help_topics/rooms/crowd/am_diseased_beggar.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/rooms/crowd/crowd_merge_effect.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/rooms/crowd/crowd_merge_effect.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627733   Available: 13575087
Inodes: Total: 5242880    Free: 4960133
1060 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/rooms/crowd/crowd_merge_effect.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627733   Available: 13575087
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: no_follow.c,v 1.1 1998/01/06 04:16:50 ceres Exp $
 * $Log: no_follow.c,v $
 * Revision 1.1  1998/01/06 04:16:50  ceres
 * Initial revision
 * 
*/
/**
 * This is the effect skelton docs.  This effect
 * has a classification of "npc.follow.guard_duty".
 * <p>
 * Describe the arguments in here.
 * <p>
 * This effect has a shadow associated with it.
 * @classification npc.follow.guard_duty
 * @see help::effects
 */
#include <effect.h>

#include "path.h"
#define SHADOWS  CROWD

/*
 * This effect will make npcs return to the crowd
 * arg() My home object
 */

/** @ignore yes */
mixed beginning( object player, mixed arg, int id ) {
  call_out( (: $1->crowd_merge() :), 5, player );
} /* beginning() */

/** @ignore yes */
mixed merge_effect( object player, mixed oldarg, mixed newarg, int id ) {
   return newarg;
} /* merge_effect() */
 
/** @ignore yes */
string query_classification() { return "npc.crowd.merge"; }

/** @ignore yes */
string query_shadow_ob() { return SHADOWS + "crowd_merge_shadow"; }







// --- END [/mnt/home2/grok/lib/d/learning/help_topics/rooms/crowd/crowd_merge_effect.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/rooms/crowd/crowd.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/rooms/crowd/crowd.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627733   Available: 13575087
Inodes: Total: 5242880    Free: 4960133
13792 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/rooms/crowd/crowd.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627733   Available: 13575087
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * Crowd object
 */
#include <parse_command.h>
#include "path.h"

#define MAXATONCE 6

inherit "/std/object";

class member {
  string file;
  string short;
  string *adjectives;
  string *names;
  string *plurals;
  string long;
  int *original_number;
}

int n_alive, n_crowd, n_selection, n_cloned, n_here, n_max=MAXATONCE;

/* This stores ints  
    member type in members array: (int>>2)   
    gender: int&3
*/
int *crowd,*selection;
mixed *here;

mixed *_m_names;
mixed *_m_plurals;
mixed *_m_adjectives;

mixed store=({});
int cnt=0;
mixed query_store() { return ({ store, cnt }); }

int lookflag=0;
int lastmatch=0;
int i_member=0;

mixed *members = ({ 
  new(class member, 
     file : CROWD+"am_poor_beggar", 
     short : "poor beggar", 
     long : "This is a poor beggar.  "
     "Perhaps you should give $OBJ$ some money.\n"
     "$PRO$ is in good shape.\n"
     "$PRO$ is standing.\n",
     original_number : ({ 0,13,15 }) ),
  new(class member, 
     file : CROWD+"am_diseased_beggar", 
     short : "diseased beggar",
     long : "This is a diseased beggar.  "
     "Looking at the running sores covering $POSS$ body makes your skin crawl.\n"
     "$PRO$ is in good shape, considering.\n"
     "$PRO$ is standing.\n",
     original_number : ({ 0,17,2 }) ),
  new(class member, 
     file : CROWD+"am_crippled_beggar", 
     short : "crippled beggar",
     long : "This is a crippled beggar.  "
     "One of $POSS$ legs has wasted so that it ressembles a gnarled branch.\n"
     "$PRO$ is in good shape.\n"
     "$PRO$ is standing awkwardly.\n", 
     original_number : ({ 0,6,11 }) )
});

int *query_crowd() { return ({ selection, crowd }); }

int query_n_crowd() { return n_crowd; }

int query_visible() { return n_crowd; }

int group_object() { return n_crowd-1; }

string include_gender( string long, int gender ) {
  switch ( gender ) {
  case 2:
    return 
      replace( long, ({ "$POSS$","her","$OBJ$","her","$PRO$","She" }) );
  default:
    return
      replace( long, ({ "$POSS$","his","$OBJ$","him","$PRO$","He" }) );
  }
} /* include_gender() */

string long(string word, int dark) {
  int i;
  string ret="";

//  tell_creator("shaggy","flags: %O %O %O %O %O %O %O %O %O %O\n",word,dark,lookflag,lastmatch,query_verb(),sizeof(crowd),previous_object(), previous_object(1), previous_object(2), previous_object(3));

  if ( !lookflag ) {
    foreach (i in crowd) ret += include_gender( (members[i>>2])->long, i&3 );
    return ret;
  }
  else if ( lastmatch ==  0 ) { 
    foreach (i in selection ) 
      ret += include_gender( (members[i>>2])->long, i&3 );
    return ret;
  }
  else if ( lastmatch > 0 ) { 
    foreach (i in selection[0..(lastmatch-1)] ) 
      ret += include_gender( (members[i>>2])->long, i&3 );
    return ret;
  }
  else if (-lastmatch <= sizeof(selection)) { /* lastmatch < 0 */
    i = selection[-lastmatch-1];
    return include_gender( members[i>>2]->long, i&3 );
  }
  return ret;
} /* long() */

string a_short() {
  string ret="";
  int i,n_match;
  string prev=file_name(previous_object(1));

//  tell_creator("shaggy","flags: %O %O %O %O %O %O %O\n",lookflag,lastmatch,query_verb(),previous_object(), previous_object(1), previous_object(2), previous_object(3));

  /* We need to make sure they are looking at the beggar(s)
     rather than just the room -- different cases */
  if ( prev == "/cmds/living/glance" ||
       prev == "/cmds/living/l_ook" ) {
    lookflag = 0;
    i_member = 0;
    selection = crowd;
    n_selection = n_crowd;
  }
  else if ( file_name(previous_object()) != "/cmds/living/glance" ) {
    lookflag = 0;
  }

  n_match = n_selection;
  if (lookflag && lastmatch && lastmatch < n_match) 
    n_match = (lastmatch > 0 ? lastmatch : 1);

  for (i=i_member;i<n_match;i++) { 
    ret+="$a_short:"+ file_name(load_object(members[selection[i]>>2]->file)) +"$";
  }
  if (lookflag) { ret = "$M$" + ret + "$M$"; }
//  tell_creator("shaggy",ret+"\n");
//  printf(ret+"\n");
  return ret;
}

string the_short() {
  string ret="";
  int i;
//  tell_creator("shaggy","It called the_short! Arg! %O %O \n",previous_object(),previous_object(1),previous_object(2));
  for (i=0;i<n_crowd;i++) 
    ret+="$the_short:"+ file_name( this_object() ) +"$";
  return ret;
}

string one_short() {
  string ret="";
  int i;
//  tell_creator("shaggy","It called one_short! Arg! %O %O \n",previous_object(),previous_object(1),previous_object(2));
  for (i=0;i<n_crowd;i++) 
    ret+="$one_short:"+ file_name( this_object() ) +"$";
  return ret;
}

string poss_short() {
//  tell_creator("shaggy","It called poss_short! Arg! %O %O \n",previous_object(),previous_object(1),previous_object(2));
  return a_short();
}

varargs string short(int dark) {
//  tell_creator("shaggy","It called short! Arg! %O %O \n",previous_object(),previous_object(1),previous_object(2));
//  tell_creator("shaggy","i_member: %O %O\n",i_member,(members[crowd[i_member]>>2])->short);
//  if (i_member<0 || i_member>=sizeof(crowd)) i_member=0;
//  return (members[crowd[i_member++]>>2])->short;
  return "crowd";
} /* short() */

void create() {
  class member p;
  int i,j,k;
  string *tmp;
  string *adjs = ({});
  string *names = ({});

  ::create();
/* Make it a living */

  set_name("beggar");
  set_short("crowd of crowd.");
  set_long("This is a crowd of people.");
  enable_commands();	
 
  crowd = ({ });
  for (j=0; j<sizeof(members);j++) {
    p = members[j];
    tmp = explode(p->short," ");
    p->names = ({ tmp[<1] });
    p->plurals = ({ pluralize(tmp[<1]) });
    names += ({ tmp[<1] });
    p->adjectives = tmp[0..<2];
    adjs += tmp[0..<2];
    for (k=0;k<sizeof(p->original_number);k++) 
      for (i=0; i<(p->original_number)[k]; i++) crowd += ({ (j<<2)+k });
  }
  crowd = shuffle(shuffle(crowd)); /* shuffle is crap */
  n_crowd = sizeof(crowd);
  n_alive = sizeof(crowd);
  n_cloned = 0;
  here = ({ });
  n_here = 0;

  _m_names = ({});
  _m_plurals = ({});
  while(sizeof(names)) {
    _m_names += ({ names[0] });
    _m_plurals += ({ pluralize(names[0]) });
    names-= ({ names[0] });
  }
  _m_adjectives = ({});
  while(sizeof(adjs)) {
    _m_adjectives += ({ adjs[0] }); 
    adjs-= ({ adjs[0] });
  }
} /* create() */

void crowd_member_died( ) {
  n_alive--;
  n_cloned--;
  if (!n_alive) dest_me();
}

void merge_crowd_member( object member ) {
//  tell_creator("shaggy","%O is returning to the fold (%O)\n", member, this_object());
  tell_room(environment(),"%^YELLOW%^"+sprintf("%O reabsorbed into %O", member, this_object())+"%^RESET%^\n");
  if (member && environment(member)==environment() ) {
    int i;

    for (i=0;i<sizeof(members);i++) {
      if ( base_name(member) == members[i]->file ) {
        n_cloned--;
        n_crowd++;
        n_here--;
        here -= ({ member->crowd_number() });
        n_max = MAXATONCE - ((n_here + n_cloned) >> 2);
        if ( n_max < 1 ) n_max = 1;
        crowd = ({ (i<<2)+member->query_gender() }) + crowd;
        member->dest_me();
      }
    }
  }
//  tell_creator("shaggy","Don't want %O\n", member );
} /* merge_crowd_member() */

object make_member() { 
  object frog; 
  int i,j;

  if (i_member<0 || i_member>=sizeof(selection)) i_member=0;
  i = selection[i_member];
  j = member_array( i, crowd );

//  tell_creator("shaggy","crowd: %O %O %O\n",sizeof(selection),i,n_crowd);
    
  frog = clone_object(members[i>>2]->file);
  if (frog) {
    n_crowd--;	
    n_cloned++;
    n_here++;
    n_max = (n_max+1)>>1;
    n_selection--;
    crowd = crowd[0..j-1] + crowd[j+1..<1];
    selection = selection[0..i_member-1]+selection[i_member+1..<1];
    crowd = crowd[0..j-1] + crowd[j+1..<1];
    here += ({ i });
    tell_room(environment(),"%^YELLOW%^"+sprintf("Cloned %O : %i of %i selected (%i remaining)",frog,i_member+1,sizeof(selection)+1,n_crowd)+"%^RESET%^\n");
    frog->fix_gender( i&3 );
    frog->add_effect( CROWD+"crowd_merge_effect", ({ this_object(), i }) );
//  tell_creator("shaggy","New one: %O %O %O %O %O %O %O %O\n", frog, previous_object(), previous_object(2), previous_object(3), previous_object(4), previous_object(5), previous_object(6), query_verb() );
    frog->move( environment(this_object()) );
  }
  return frog;
} /* make_member() */

/** @ignore yes */
string *parse_command_id_list() { 
//  tell_creator("shaggy","id_list\n");
  return _m_names; 
}
/** @ignore yes */
string *parse_command_plural_id_list() { 
//  tell_creator("shaggy","plural_list\n");
  return _m_plurals; 
}
/** @ignore yes */
string *parse_command_adjectiv_id_list() { 
//  tell_creator("shaggy","adj_list\n");
  return _m_adjectives; 
}

/** @ignore yes */
/* Find match uses this to decide if it is a match or note.
   parse_command uses the above functions.
   If test is the output from parse_command
   param arr = ({ num, str, 0, sizeof(array[i+1]), top, bot }) );
   num = test[0]; 
        if numeral > 0 then three, four, five etc were matched
        if numeral < 0 then second, twentyfirst etc were matched
        if numeral == 0 then 'all' or a generic plural form such as
                        'apples' were matched.
   str = the string to be matched to objects

   These seem to be absent some of the time, only there for frac matches:
   0
   array = some past objects referrable to as it, them, her, him 
   top = top of fraction
   bot = bottom of fraction

#define P_THING 0
#define P_STR 1
#define P_CUR_NUM 2
#define P_MAX_NUM 3
#define P_TOP 4
#define P_BOT 5
*/
mixed query_parse_id(mixed *arr) {
   string *bits, bat;
   int i;

//   tell_creator("shaggy","parse: %O %O %O %O %O %O\n",arr,query_verb(),previous_object(), previous_object(1), previous_object(2), previous_object(3));

   selection = ({ });
   i_member = 0;

   if (!n_crowd) return 0;

   lastmatch=arr[P_THING];
   switch (query_verb()) {
   case 0:
   case "look":
   case "glance":
   case "destruct":
   case "lose":
   case "trans":
     lookflag=1;
     break;
   default:
     lookflag=0; 
   }
   
   bits = explode(arr[P_STR]," ");
   bat = bits[<1];

   selection = copy(crowd);
   if ( member_array( bat, _m_names ) != -1 ) {
     for (i=0;i<sizeof(members);i++) {
       if ( member_array( bat, members[i]->names ) == -1) 
         selection -= ({ (i<<2)+1, (i<<2)+2 });
     }
     while (sizeof(bits = bits[0..<2])) {
       bat = bits[<1];
       if ( member_array( bat, _m_adjectives ) != -1 ) {
         for (i=0;i<sizeof(members);i++) {
           if ( member_array( bat, members[i]->adjectives ) == -1) 
             selection -= ({ (i<<2)+1, (i<<2)+2 });
         }
       }
     }
   }
   else if ( member_array( bat, _m_plurals ) != -1 ) {
     for (i=0;i<sizeof(members);i++) {
       if ( member_array( bat, members[i]->plurals ) == -1) 
         selection-= ({ (i<<2)+1, (i<<2)+2 });
     }
     while (sizeof(bits = bits[0..<2])) {
       bat = bits[<1];
       if ( member_array( bat, _m_adjectives ) != -1 ) {
         for (i=0;i<sizeof(members);i++) {
           if ( member_array( bat, members[i]->adjectives ) == -1) 
             selection -= ({ (i<<2)+1, (i<<2)+2 });
         }
       }
     }
   }
//   tell_creator("shaggy","Selection: %O\n",selection);
   
   if (!(n_selection = sizeof(selection))) return 0;

   if (lookflag) {
     if (lastmatch < 0) i_member = -lastmatch-1;
     /* everything case */
     if (arr[P_THING] == 0) return this_object();
     if (arr[P_THING] < 0) { /* specific object case */
        arr[P_THING]+=n_selection;
        if (arr[P_THING] <0) {
          return 0;
        }
        arr[P_THING] = -10321;
        return this_object();
     }
     /* specific number of objects case */
     if (arr[P_THING] != 1) {
       i=arr[P_THING];
       if (i>n_selection) i = n_selection;
       arr[P_THING]-=i;
       if (!arr[P_THING]) arr[P_THING] = -10101;
       return this_object();
     } 
     arr[P_THING] = -10101;
     return this_object();
   }

   /* everything case */
   if (arr[P_THING] == 0) {
      object *things=({ });
      i = n_max;
      if (i>n_selection) i = n_selection;
      while (i--) things += ({ make_member() });
      return things;
   }
   if (arr[P_THING] < 0) { /* specific object case */
      i_member = -arr[P_THING]-1;
      arr[P_THING]+=n_selection;
      if (arr[P_THING] <0) {
         return 0;
      }
      arr[P_THING] = -10321;
      return make_member();
   }
   /* specific number of objects case */
   if (arr[P_THING] != 1) {
      object *things=({ });
      i=arr[P_THING];
      if (i>n_selection) i = n_selection;
      if (i>n_max) i = n_max;
      while (i--) {
         arr[P_THING]--;
	 things += ({ make_member() });
      }
      if (!arr[P_THING]) arr[P_THING] = -10101;
      return things;
   } 
   arr[P_THING] = -10101;
   return make_member();
} /* query_parse_id() */

void event_enter( object ob, string message, object from ) {
  if (from) {
    object *things;
    n_here = sizeof( things = filter(all_inventory( environment() ), 
      (: $1->crowd_object() == this_object() :) ));
    here = ({ });
    if ( n_here ) here = map( things, (: $1->crowd_number() :) );
    n_max = MAXATONCE - ((n_here + n_cloned) >> 2);
    if ( n_max < 1 ) n_max = 1;
    tell_creator("shaggy","ENTER %O: n_here: %i n_cloned: %i n_alive: %i n_crowd:%i n_max: %i %O\n",from,n_here,n_cloned,n_alive,n_crowd,n_max, here);
  }
}

void event_exit( object ob, string message, object to ) {
  object *things;
  n_here = sizeof( things = filter(all_inventory( environment() ), 
     (: $1->crowd_object() == this_object() :) ));
  here = ({ });
  if ( n_here ) here = map( things, (: $1->crowd_number() :) );
  n_max = MAXATONCE - ((n_here + n_cloned) >> 2);
  if ( n_max < 1 ) n_max = 1;
  tell_creator("shaggy","EXIT: n_here: %i n_cloned: %i n_alive: %i n_crowd:%i n_max: %i %O\n",n_here,n_cloned,n_alive,n_crowd,n_max, here);
}// --- END [/mnt/home2/grok/lib/d/learning/help_topics/rooms/crowd/crowd.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/rooms/crowd/crowdroom.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/rooms/crowd/crowdroom.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627729   Available: 13575083
Inodes: Total: 5242880    Free: 4960133
1607 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/rooms/crowd/crowdroom.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627729   Available: 13575083
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h"

inherit "/std/room";

object crowd;

void setup() {
   /* The "commented functions" and "keywords" properties are specific for 
    * rooms in the learning domain and is used to make it possible to search
    * for subjects. 
    * See /d/learning/handlers/search.c for the way this is done.
    */
  add_property( "commented functions", 
                ({  }) );
  add_property( "keywords", 
                ({ "crowd" }) );
  
  set_short("crowd demonstration room");
  set_light(100);
  set_long("This is a room to contain a crowd of NPC's.  "
           "It is intend to be a venue to test and try out "
           "the crowd NPC object and related files:\n"
           "%^YELLOW%^/d/am/learning/help_topics/crowd/crowd.c\n"
           "/d/am/learning/help_topics/crowd/crowd_merge_effect.c\n"
           "/d/am/learning/help_topics/crowd/crowd_merge_shadow.c"
           "%^RESET%^\n"
           "You can %^CYAN%^inv here%^RESET%^ to see objects present.  "
           "You can also attack the beggars as NPCs may not use the exits.\n");
  
  //  add_exit( "next", SIT+"crowdroom2", "path" );
  add_exit( "back", LEARNING +"search", "path" );
  add_exit( "exit", ENTRANCE, "path" );

  //  modify_exit( "next", ({ "function", (: interactive($2) :) }) );
  modify_exit( "back", ({ "function", (: interactive($2) :) }) );
  modify_exit( "exit", ({ "function", (: interactive($2) :) }) );

} /* setup() */

void reset() {
 
  if (!crowd) {
    crowd=clone_object( CROWD+"crowd" );
    crowd->move( this_object() );
    // call_out( (: $1->move($2) :), 2, crowd, this_object() );
  }
}
// --- END [/mnt/home2/grok/lib/d/learning/help_topics/rooms/crowd/crowdroom.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/objects/container_save.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/objects/container_save.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627729   Available: 13575083
Inodes: Total: 5242880    Free: 4960133
4021 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/objects/container_save.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627729   Available: 13575083
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h"
/*
 * Example room for using /obj/surf_save and /obj/cont_save.
 */

inherit "/std/room";

object shelf, wardrobe;

void setup() {
   set_short("room of shelf and wardrobe examples");
   add_property( "determinate", "the " );
   set_long( "This room gives some simple examples of how to make shelves, "
            "wardrobes and such that'll save the content for you.\n"
            "To make a shelf, which is characterized by having a surface "
            "you can put things on, you make a clone of /obj/surf_save, "
            "configure it like all cloned objects, and call set_save_file( "
            "file_name ) do tell what file should be used to save the "
            "objects that are put on it.  If the savefile isn't in /save/ "
            "you should call check_euid() on the shelf before calling "
            "set_save_file().\n"
            "Making a wardrobe, you do the same, except you that it is "
            "/obj/cont_save you should clone.\n"
            "Note that since these are fixed parts of the room, and not "
            "something that is put here, I clone them directly in reset() "
            "instead of doing a call_out() to a function that makes them.\n" );
   set_light( 100 );
   add_exit( "back", LEARNING +"search", "path" );
   add_exit( "exit", ENTRANCE, "path" );
   /* The "commented functions" and "keywords" properties are specific for 
    * rooms in the learning domain and is used to make it possible to search
    * for subjects. 
    * See /d/learning/handlers/search.c for the way this is done.
    */
   add_property( "commented functions", 
                ({ "check_euid", "set_save_file" }) );
   add_property( "keywords", 
                ({ "shelf", "wardrobe", "save" }) );
} /* setup() */

void reset() {
   if (!shelf) {
      /* The first parts of making a shelf it covered elsewhere, it's 
       * basically a matter of cloning the object and make it look like 
       * it should
       */
      shelf = clone_object("/obj/surf_save"); 
      shelf->set_name( "shelf" );
      shelf->set_short( "oaken shelf" );
      shelf->add_adjective( "wooden" );
      shelf->add_adjective( "oak" );
      shelf->add_adjective( "oaken" );
      shelf->add_property( "there", "hanging from the wall" );
      shelf->set_long( "This shelf is made from oak and "
                      "varnished to bring out the glow.\n" );
      shelf->set_weight( 2000 );
      shelf->set_max_weight( 2000 );
      shelf->reset_get();
      /* This call will allow the shelf to write the  savefile in the same
       * domain as the room is in, if you don't do this call, the savefile
       * will have to be somewhere in /save/ 
       */
      shelf->check_euid(); 
      /* This call tells the shelf what file should be used to save the stuff
       * placed on it.
       */
      shelf->set_save_file( SAVEPATH+"/oak_shelf" );
      /* end by putting the shelf in the room */
      shelf->move( this_object() );
   }
   if (!wardrobe) {
      wardrobe = clone_object("/obj/cont_save");
      wardrobe->set_name( "wardrobe" );
      wardrobe->set_short( "oaken wardrobe" );
      wardrobe->add_adjective( "wooden" );
      wardrobe->add_adjective( "oaken" );
      wardrobe->add_adjective( "oak" );
      wardrobe->set_long( "This wardrobe is made from oak and "
                         "varnished to bring out the glow.\n" );
      wardrobe->set_weight( 2000 );
      wardrobe->set_max_weight( 2000 );
      wardrobe->reset_get();
      /* This call will allow the wardrobe to write the savefile in the same
       * domain as the room is in, if you don't do this call, the savefile
       * will have to be somewhere in /save/ 
       */
      wardrobe->check_euid();
      /* This call tells the wardrobe what file should be used to save the
       * stuff placed in it.
       */
      wardrobe->set_save_file( SAVEPATH+"/wardrobe" );
      /* end by putting the wardrobe in the room */
      wardrobe->move( this_object() );
   }
} /* reset() */
// --- END [/mnt/home2/grok/lib/d/learning/help_topics/objects/container_save.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/help_topics/objects/vessel.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/help_topics/objects/vessel.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627727   Available: 13575081
Inodes: Total: 5242880    Free: 4960133
7931 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/help_topics/objects/vessel.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627727   Available: 13575081
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h"
/*
 * Example room for using vessels.
 */

inherit "/std/room";

object wine_bottle, glass, cup;

void setup() {
   set_short("room of vessel and liquid examples");
   add_property( "determinate", "the " );
   set_long( "This room gives some simple examples of using vessels.  "
            "There should be a wine bottle, a wine glass, and a "
            "coffee cup in here.  There are also a few usage notes "
            "on the wall (\"read note1\", \"read note2\", etc).\n" );
   set_light( 100 );
   add_item( "note1",
            ({ "long", "This note describes how to use the vessels.",
               "read", "The vessels all have the following commands: "
                   "pour, fill, drink, empty.  There are a few others, "
                  "but they're mainly carry-overs from the old "
                  "container code, and probably don't work correctly.  "
                  "Try pouring from one object to another, drinking, etc.  "
                  "Try mixing equal parts of wine and Klatchian coffee.  "
                  "Use the \"stat\" command to check on the volumes (eg, "
                  "\"stat bottle\", \"stat all in cup\").  If you want " 
                  "to start over with a fresh vessel, dest it and " 
                  "\"call reset() here\".\n"
            }) );
   add_item( "note2",
            ({ "long", "This is a little note on liquid units of measure.",
               "read", "The base unit for a liquid is the drop.  Four "
                  "drops is roughly 1 cc, and 200 drops of water weighs "
                  "one Discworld weight unit.  Here are some common "
                  "amounts (I believe these are all British measures, "
                  "but I could have made an error):\n"
                  "    1 teaspoon =      20 drops\n"
                  "    1 tablespoon =    60 drops\n"
                  "    1 ounce =        120 drops\n"
                  "    1 cup =          960 drops\n"
                  "    1 pint =        2400 drops\n"
                  "    1 quart =       4800 drops\n"
                  "    1 gallon =     19200 drops\n"
            }) );
   add_item( "note3",
            ({ "long", "This is a note on adding effects to food, "
                  "especially liquids.",
               "read", "To add an effect to food so that it will be "
                  "applied to the player when consumed, use "
                  "add_eat_effect(<effect>, <arg>).  <arg> (which "
                  "should be an integer) is multiplied by the weight "
                  "of the amount consumed; for liquids, this is generally "
                  "200 drops per weight unit.\n\n"
                  "For example, the wine in the wine bottle adds the "
                  "drunk effect; a final <arg> of 3900 for this effect "
                  "will last 10 minutes on a player with constitution 13 "
                  "(trust me on this).  If we want one pint (2400 drops) "
                  "of wine to have this effect, the <arg> to "
                  "add_eat_effect() should be 3900/(2400/200), or "
                  "325.\n"
            }) );
   add_item( "note4",
            ({ "long", "This is a note on using continuous objects.",
               "read", "Continuous objects (those derived from "
                  "/obj/cont_medium, such as /obj/food) are a way "
                  "to have multiple identical instances of an item "
                  "without having to have a clone for each one.  Each "
                  "unique continuous object is identified by its "
                  "\"medium alias\".  The medium alias must be a single "
                  "word without embedded spaces; by convention, it is "
                  "made by concatenating a series of capitalized words "
                  "that describe it, such as \"RedWine\" or "
                  "\"GroundPurpleMushroom\".  All objects with a common "
                  "medium alias in the same environment are combined "
                  "into a single object.  Also, the reaction handler "
                  "uses the medium alias to identify objects that "
                  "react with one another.\n"
            }) );
   add_exit( "back", LEARNING +"search", "path" );
   add_exit( "exit", ENTRANCE, "path" );
   /* The "commented functions" and "keywords" properties are specific for 
    * rooms in the learning domain and is used to make it possible to search
    * for subjects. 
    * See /d/learning/handlers/search.c for the way this is done.
    */
   add_property( "commented functions", 
                ({ "make_bottle", "add_eat_effect", "set_medium_alias",
                   "set_max_weight", "set_max_volume" }) );
   add_property( "keywords", 
                ({ "bottle", "vessel", "liquid" }) );
} /* setup() */

void reset() {
   call_out( "check_vessels", 3 );
} /* reset() */

void check_vessels() {
   object wine, coffee;
   
   /* each of these if's check if the vessel has been dest'ed or moved out of 
    * the room
    */
   if ( !wine_bottle || ( environment( wine_bottle ) != this_object() ) ) {
      /* The bottle is gone, make a new one
       */
      wine_bottle = clone_object( "/obj/bottle" );
      /* For backwards compatibility, make_bottle() expects the
       * volume to be cubic centimeters (or at least that's the way
       * it worked out).
       */
      wine_bottle->make_bottle( "green", 600 );
      wine_bottle->move( this_object(), "Jeremy walks into the room and "
                        "leaves $N before walking out again." );
      /* I only fill the bottle when a new one is cloned, to avoid
       * confusing people.
       */
      wine = clone_object( "/obj/reagents/generic_liquid.ob" );
      wine->set_name( "wine" );
      wine->set_short( "red wine" );
      wine->set_long( "This is a deep red wine, $amount_size$.\n");
      wine->set_medium_alias( "RedWine" );
      wine->add_adjective( "red" );
      wine->add_eat_effect( "/std/effects/ingested/drunk", 325 );
      /* This will completely fill the bottle
       */
      wine->set_amount( 2400 );
      wine->move( wine_bottle );
   }
   if ( !glass || ( environment( glass ) != this_object() ) ) {
      glass = clone_object( "/obj/vessel" );
      glass->set_name( "glass" );
      glass->set_short( "wine glass" );
      glass->set_long( "This is a fine crystal wine glass.\n" );
      glass->set_weight( 4 );
      glass->set_max_weight( 8 );
      // Make it hold about half a cup
      glass->set_max_volume( 480 );
      glass->add_adjective( ({ "crystal", "wine" }));
      glass->move( this_object(), "Jeremy walks into the room and "
                        "leaves $N before walking out again.");
   }
   if ( !cup || ( environment( cup ) != this_object() ) ) {
      cup = clone_object( "/obj/vessel" );
      cup->set_name( "cup" );
      cup->set_short( "coffee cup" );
      cup->set_long( "This is a delicate china coffee cup.  The intricate "
                    "artwork on the side depicts some sort of sexual "
                    "orgy.  Why it's on a coffee cup is beyond me.\n" );
      cup->set_weight( 4 );
      cup->set_max_weight( 8 );
      cup->set_max_volume( 960 );
      cup->add_adjective( ({ "china", "coffee" }) );
      cup->move( this_object(), "Jeremy walks into the room and "
                "leaves $N before walking out again." );
      coffee = clone_object( "/obj/reagents/generic_liquid.ob" );
      coffee->set_name( "coffee" );
      coffee->set_short( "coffee" );
      coffee->set_long( "This is some Klatchian coffee, $amount_size$.  "
                       "It is very dark and aromatic.\n" );
      coffee->set_medium_alias( "KlatchianCoffee" );
      coffee->add_adjective( "klatchian" );
      coffee->add_eat_effect( "/std/effects/ingested/knurd", 325 );
      coffee->set_amount( 960 );
      coffee->move( cup );
   }
} /* check_vessels() */

// --- END [/mnt/home2/grok/lib/d/learning/help_topics/objects/vessel.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/function_room.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/function_room.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627725   Available: 13575079
Inodes: Total: 5242880    Free: 4960133
4003 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/function_room.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627725   Available: 13575079
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h"
#include <map.h>

inherit "/std/room/basic_room";

string function_chosen;

void setup() {
   set_short( "uninitialised search room for functions" );
   set_long( "You are in an uninitialized search room.  "
            "This is an example of a room that gets cloned and configured "
            "afterwards.  In this room, it's the function set_marker that's " 
            "used to define its look, and most if the exits as well.  And "
            "the function set_destination that is used to find, possibly "
            "clone and configure, the rooms that fit the keywords you search "
            "for.  The handler called SEARCH in the code, is \""+
            SEARCH +"\" and the one called QUIT_HANDLER, is \""+ 
            QUIT_HANDLER +"\".\n" );
   add_property( "no map", 1 );
   /* set_light sets the amount of light the room has.  See help light
    * for a list of what the number means:)
    */
   set_light( 50 );

   add_exit( "exit", PATH +"functions", "path" );
   /* add_property is used to add a value to an object, that can later be
    * queried for with query_property.
    * The "commented functions" and "keywords" properties are specific for 
    * rooms in the learning domain and is used to make it possible to search
    * for subjects. 
    * See /d/learning/handlers/search.c for the way this is done.
    */
   add_property( "commented functions", 
                ({ "set_destination", "query_quit_handler", 
                   "query_cloning_info" }) );
   add_property( "keywords", ({ "room", "virtual" }) );
} /* setup() */

string query_marker() {
   return function_chosen;
} /* query_marker() */ 

void set_marker( string word ) {
   string description, exit_letter, exit_room, exit;
   
   set_short( "\""+ word +"\" search room" );
   add_property( "determinate", "the " );
   function_chosen = word;
   description = "You have chosen to see the rooms describing the use of the "
         "function "+ function_chosen +".";
   description += "$I$5=Take one of the lettered exits to go to that room.";
   exit_letter = "a";
   foreach( exit_room in (string *)SEARCH->query_rooms_with_function( word ) ) {
      exit = sprintf( "%s: %s", 
                     exit_letter, 
                     (string)MAP->query_short( exit_room ) );
      add_exit( exit_letter, exit_room, "path" );
      description += "\n$C$"+ exit +".";
      exit_letter[ 0 ]++;
   }
   description += "$I$0=\n";
   set_long( description );
} /* set_marker() */ 

/* This is for cleanup, it's called 10 seconds after something left, and if
 * nothing is in the room it's removed.
 */
void check_empty() {
   if ( sizeof( all_inventory( this_object() ) ) )
      return;
   dest_me();
} /* check_empty() */

/* query_quit_handler() is a function called by the player to get the filename
 * of the quit_handler. 
 * When quitting, the function player_quitting() is called in the quit_handler
 * which will save the
 */
string query_quit_handler() { return QUIT_HANDLER; }

/* query_cloning_info() is called by things that need to be able to remare
 * this room.
 * It it an array of three or four elements, the first of which is the
 * object, the second is a function called in it, with the third and if it's
 * there, the fourth element as arguments.
 */
mixed *query_cloning_info() {
   return ({ SEARCH, "find_function_room", function_chosen });
} /* query_cloning_info() */

/* This is for cleaning up the information saved by the quit_handler, to
 * make sure that the players name is removed from the lists.
 * event_exit is generally called whenever someone leaves the room.
 */
void event_exit( object thing, string mess, object to ) {
   string handler;
   
   if ( find_call_out( "check_empty" ) == -1 )
      call_out( "check_empty", 10 );
   if ( file_name( to ) == "/room/departures" )
      return;
   handler = query_quit_handler();
   if ( (string)to->query_quit_handler() != handler )
      handler->remove_from_list( thing );
} /* event_exit() */

// --- END [/mnt/home2/grok/lib/d/learning/function_room.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/TinyTown/roads/womble01.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/TinyTown/roads/womble01.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627724   Available: 13575078
Inodes: Total: 5242880    Free: 4960133
1468 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/TinyTown/roads/womble01.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627724   Available: 13575078
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h"

inherit "/std/room/outside";

void setup() {
  add_property( "determinate", "the " );
  set_short( "southwestern corner of Womble square" );
  set_long("This is the western edge of Tiny Town, a small "
           "town built as an example for new creators who might want to see "
           "how to make rooms, npc's and such without the complexity of "
           "the \"real\" domains.\n");
   
  set_zone( "Tiny Town");

  // This links the other square rooms to this one so people can see
  // movement across the square.
  set_linker(({ PATH +"womble02", PATH +"womble03", PATH +"womble04", }),
             "into", "", "Womble Square" );
  
  add_exit( "north", PATH +"womble03", "road" );  
  add_exit( "northeast", PATH +"womble04", "hidden" );
  add_exit( "east", PATH +"womble02", "road" );
  add_exit( "south", TTOWNBUILDINGS +"item-shop", "door" );

  modify_exit( "south", ({
    "exit mess", "$N leave$s through the door to the south.",
      "enter mess", ({ 
        1,
          "Chimes start playing as $N enters.",
          "Chimes start playing as $N enter." }),
      "move mess", "Chimes start playing as you enter the shop.\n"
      }));

  // Add a climable wall up to a ledge outside the window of the shop.
  // parameters are: direction, difficulty, destination, message
  set_wall( ({ "move", ({ "up", 100, TTOWNBUILDINGS + "shop-ledge",
                            "$N climb$s up from below." }) }) );
} /* setup() */

// --- END [/mnt/home2/grok/lib/d/learning/TinyTown/roads/womble01.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/TinyTown/roads/womble03.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/TinyTown/roads/womble03.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627723   Available: 13575077
Inodes: Total: 5242880    Free: 4960133
823 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/TinyTown/roads/womble03.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627723   Available: 13575077
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h"

inherit "/std/room/outside";

void setup() {
  add_property( "determinate", "the " );
  set_short( "northwestern corner of Womble square" );
  set_long("This is the western edge of Tiny Town, a small "
           "town built as an example for new creators who might want to see "
           "how to make rooms, npc's and such without the complexity of "
           "the \"real\" domains.\n");
   
  set_zone( "Tiny Town");

  // This links the other square rooms to this one so people can see
  // movement across the square.
  set_linker(({ PATH +"womble01", PATH +"womble03", PATH +"womble04", }),
             "into", "", "Womble Square" );
  
  add_exit( "south", PATH +"womble01", "road" );  
  add_exit( "southeast", PATH +"womble02", "hidden" );
  add_exit( "east", PATH +"womble04", "road" );
}

// --- END [/mnt/home2/grok/lib/d/learning/TinyTown/roads/womble03.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/TinyTown/roads/womble04.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/TinyTown/roads/womble04.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627723   Available: 13575077
Inodes: Total: 5242880    Free: 4960133
823 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/TinyTown/roads/womble04.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627723   Available: 13575077
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h"

inherit "/std/room/outside";

void setup() {
  add_property( "determinate", "the " );
  set_short( "northeastern corner of Womble square" );
  set_long("This is the eastern edge of Tiny Town, a small "
           "town built as an example for new creators who might want to see "
           "how to make rooms, npc's and such without the complexity of "
           "the \"real\" domains.\n");
   
  set_zone( "Tiny Town");

  // This links the other square rooms to this one so people can see
  // movement across the square.
  set_linker(({ PATH +"womble03", PATH +"womble01", PATH +"womble02", }),
             "into", "", "Womble Square" );
  
  add_exit( "south", PATH +"womble02", "road" );  
  add_exit( "southwest", PATH +"womble01", "hidden" );
  add_exit( "west", PATH +"womble03", "road" );
}

// --- END [/mnt/home2/grok/lib/d/learning/TinyTown/roads/womble04.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/TinyTown/roads/womble02.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/TinyTown/roads/womble02.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627723   Available: 13575077
Inodes: Total: 5242880    Free: 4960133
823 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/TinyTown/roads/womble02.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627723   Available: 13575077
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h"

inherit "/std/room/outside";

void setup() {
  add_property( "determinate", "the " );
  set_short( "southeastern corner of Womble square" );
  set_long("This is the eastern edge of Tiny Town, a small "
           "town built as an example for new creators who might want to see "
           "how to make rooms, npc's and such without the complexity of "
           "the \"real\" domains.\n");
   
  set_zone( "Tiny Town");

  // This links the other square rooms to this one so people can see
  // movement across the square.
  set_linker(({ PATH +"womble01", PATH +"womble03", PATH +"womble04", }),
             "into", "", "Womble Square" );
  
  add_exit( "north", PATH +"womble04", "road" );  
  add_exit( "northwest", PATH +"womble03", "hidden" );
  add_exit( "west", PATH +"womble01", "road" );
}

// --- END [/mnt/home2/grok/lib/d/learning/TinyTown/roads/womble02.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/TinyTown/buildings/shop-ledge.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/TinyTown/buildings/shop-ledge.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627722   Available: 13575076
Inodes: Total: 5242880    Free: 4960133
1550 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/TinyTown/buildings/shop-ledge.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627722   Available: 13575076
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h"

inherit "/std/room/rooftop";

void setup() {
  set_short( "small ledge" );
  set_long( "This is a small ledge just outside the upstairs window of "
						"the item shop.\n");

  // This is usually calculated for you and only needed if you want the room
  // to be bigger than normal.
  set_room_size( 10 ); 

	// Set the slope of this ledge. Parameters: gradient, name, destination
	set_slope(60, "ledge", TTOWNROADS + "womble01");

	// Set the messages to be shown if a player falls off the ledge due
	// to excessive weight.
	set_weak_messages("The ledge crumbles under your weight.\n",
										"$short$ falls from the crumbling ledge.",
										"$short$ comes crashing to the ground.",
                                                                                "The ledge makes a strange sound.");
	
	// make the ledge weak and crumbly. Parameters: weight, destination
	set_weak_roof(2500, TTOWNROADS + "womble01");

	/*
	 * lots of add_items are needed here to describe all the things in the
	 * room.
	 */


	add_exit("window", PATH+"shop-upstairs", "window");

	/*
	 * This sets up a wall exit so that people can climb down from here.
	 */
	// set the bottom of the wall, and a modifier to the damage taken
	// if you fall.
	set_wall( ({ "bottom", ({ TTOWNROADS + "womble01", 200 }), }) );

	/*
	 * set the parameters for a climb they are:
	 * direction, base difficulty, destination, message
	 */
	set_wall( ({ "move", ({ "down", 30, TTOWNROADS + "womble01",
														"$N climb$s down from above." }) }) );
}

// --- END [/mnt/home2/grok/lib/d/learning/TinyTown/buildings/shop-ledge.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/TinyTown/buildings/item-shop.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/TinyTown/buildings/item-shop.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627722   Available: 13575076
Inodes: Total: 5242880    Free: 4960133
1020 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/TinyTown/buildings/item-shop.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627722   Available: 13575076
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h"

inherit "/std/shops/item_shop";

void setup() {
  // make sure that the short says "A simple item shop" rather than "The ..."
  add_property( "determinate", "A " );
  
  set_short( "simple item shop" );
  set_long( "This is a nice looking shop.  Obviously your shop would have "
            "a much more interesting description.\n");
  
  set_light( 60 );

  // This is usually calculated for you and only needed if you want the room
  // to be bigger than normal.
  set_room_size( 10 ); 

  // set the movement zone.
  set_zone( "Tiny Town");

  add_exit( "north", TTOWNROADS +"womble01", "door" );
  modify_exit( "nouth", ({
    "exit mess", "Chimes start playing as $N "
      "leave$s through the north door.",
      "enter mess", ({ 
        1,
          "$N enters from the south.",
          "$N enter from the south." }),
      "move mess", "Chimes start playing as you leave the shop.\n"
      }));

  add_exit("up", PATH+"shop-upstairs", "stair");
  modify_exit("up", ({"upgrade", 9 }));
}

// --- END [/mnt/home2/grok/lib/d/learning/TinyTown/buildings/item-shop.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/TinyTown/buildings/shop-upstairs.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/TinyTown/buildings/shop-upstairs.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627720   Available: 13575074
Inodes: Total: 5242880    Free: 4960133
726 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/TinyTown/buildings/shop-upstairs.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627720   Available: 13575074
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h"

inherit "/std/room/basic_room";

void setup() {
  set_short( "bedroom" );
  set_long( "This is a small bedroom above the shop.  There is a window "
            "in the north wall.\n");
  
  set_light( 60 );

  // This is usually calculated for you and only needed if you want the room
  // to be bigger than normal.
  set_room_size( 10 ); 

  // set the movement zone.
  set_zone( "Tiny Town");

  /*
   * lots of add_items are needed here to describe all the things in the
   * room.
   */


  add_exit("window", PATH+"shop-ledge", "window");
  add_exit("down", PATH +"item-shop", "stair" );

  // make them move downwards 9feet when they go down the stairs
  modify_exit("down", ({ "downgrade", 9 }));
}

// --- END [/mnt/home2/grok/lib/d/learning/TinyTown/buildings/shop-upstairs.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/functions/function_room.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/functions/function_room.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627720   Available: 13575074
Inodes: Total: 5242880    Free: 4960133
4002 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/functions/function_room.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627720   Available: 13575074
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h"
#include <map.h>

inherit "/std/room/basic_room";

string function_chosen;

void setup() {
   set_short( "uninitialised search room for functions" );
   set_long( "You are in an uninitialized search room.  "
            "This is an example of a room that gets cloned and configured "
            "afterwards.  In this room, it's the function set_marker that's " 
            "used to define its look, and most if the exits as well.  And "
            "the function set_destination that is used to find, possibly "
            "clone and configure, the rooms that fit the keywords you search "
            "for.  The handler called SEARCH in the code, is \""+
            SEARCH +"\" and the one called QUIT_HANDLER, is \""+ 
            QUIT_HANDLER +"\".\n" );
   add_property( "no map", 1 );
   /* set_light sets the amount of light the room has.  See help light
    * for a list of what the number means:)
    */
   set_light( 50 );

   add_exit( "exit", PATH +"functions", "path" );
   /* add_property is used to add a value to an object, that can later be
    * queried for with query_property.
    * The "commented functions" and "keywords" properties are specific for 
    * rooms in the learning domain and is used to make it possible to search
    * for subjects. 
    * See /d/learning/handlers/search.c for the way this is done.
    */
   add_property( "commented functions", 
                ({ "set_destination", "query_quit_handler", 
                   "query_cloning_info" }) );
   add_property( "keywords", ({ "room", "virtual" }) );
} /* setup() */

string query_marker() {
   return function_chosen;
} /* query_marker() */ 

void set_marker( string word ) {
   string description, exit_letter, exit_room, exit;
   
   set_short( "\""+ word +"\" search room" );
   add_property( "determinate", "the " );
   function_chosen = word;
   description = "You have chosen to see the rooms describing the use of the "
         "function "+ function_chosen +".";
   description += "$I$5=Take one of the lettered exits to go to that room.";
   exit_letter = "a";
   foreach( exit_room in (string *)SEARCH->query_rooms_with_function( word ) ) {
      exit = sprintf( "%s: %s", 
                     exit_letter, 
                     (string)MAP->query_short( exit_room ) );
      add_exit( exit_letter, exit_room, "path" );
      description += "\n$C$"+ exit +".";
      exit_letter[ 0 ]++;
   }
   description += "$I$0=\n";
   set_long( description );
} /* set_marker() */ 

/* This is for cleanup, it's called 10 seconds after something left, and if
 * nothing is in the room it's removed.
 */
void check_empty() {
   if ( sizeof( all_inventory( this_object() ) ) )
      return;
   dest_me();
} /* check_empty() */

/* query_quit_handler() is a function called by the player to get the filename
 * of the quit_handler. 
 * When quitting, the function player_quitting() is called in the quit_handler
 * which will save the
 */
string query_quit_handler() { return QUIT_HANDLER; }

/* query_cloning_info() is called by things that need to be able to remare
 * this room.
 * It it an array of three or four elements, the first of which is the
 * object, the second is a function called in it, with the third and if it's
 * there, the fourth element as arguments.
 */
mixed *query_cloning_info() {
   return ({ SEARCH, "find_function_room", function_chosen });
} /* query_cloning_info() */

/* This is for cleaning up the information saved by the quit_handler, to
 * make sure that the players name is removed from the lists.
 * event_exit is generally called whenever someone leaves the room.
 */
void event_exit( object thing, string mess, object to ) {
   string handler;
   
   if ( find_call_out( "check_empty" ) == -1 )
      call_out( "check_empty", 10 );
   if ( file_name( to ) == "/room/departures" )
      return;
   handler = query_quit_handler();
   if ( (string)to->query_quit_handler() != handler )
      handler->remove_from_list( thing );
} /* event_exit() */
// --- END [/mnt/home2/grok/lib/d/learning/functions/function_room.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/main.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/main.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627719   Available: 13575073
Inodes: Total: 5242880    Free: 4960133
3466 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/main.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627719   Available: 13575073
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h"
inherit "/std/room/basic_room";

void setup() {
   /* The following two lines define the description of the room when you 
    * glance at it, or enter it in brief mode.
    * It should be something that will make the sentence:
    * "This room is <determinate>+<short>." correct.
    * eg. here it would make: "This room is the entrance to learning."
    * This is also a useful test to see if you've used capital letters
    * correctly.
    */
   set_short( "entrance to learning" );
   add_property( "determinate", "the " );
   /* The next command define the description you see when you look at it,
    * and when you enter it in verbose mode.
    * It should consist of complete sentences.  For normal rooms it should be
    * a description of the things the player can see.  
    * Remember to use two spaces beween sentences, to end the sentences with
    * "." and to put "\n" at the end.
    */
   set_long( "Welcome to the entrance room of the learning domain.  "
            "The purpose of this domain is to help beginning creators, by "
            "giving examples of the way to use the different functions that "
            "are available, and show ways to solve common problems.\n"
            "To see the code used in a room or an object you can use the "
            "commands \"more here\" and \"more <object name>\" "
            "respectively.  If you have something you'd like to see here, "
            "mail "+ CURRENT_LORD +" and suggest it.\n"
            "The search exit will take you to a special room with exits "
            "for each of the keywords defined in the different files in the "
            "domain, this will enable you to search for examples by "
            "selecting keywords, and is also an example of the use of "
            "virtual or cloned rooms.\n"
            "If you want to find examples of how to use specific functions, "
            "use the functions exit.\n"
            );
   /* set_light sets the amount of light the room has.  See help light
    * for a list of what the number means:)
    */
   set_light( 50 );
   /* set_co_ord Sets the current co-ordinates of the room.
    * they are ({ n-s, e-w, u-d })
    */
   set_co_ord( ({ 30, 0, 40 }) ); /* 30 feet south and 40 feet above the drum */
   /* add_exit is used to add exits (you'd never have guessed:)
    * Note the use of PROBLEMS, FUNCTIONS and ENTRANCE that are all defined
    * by path.h to make it easy to move the file without having to change it.
    * For a list of the different values you can use for the third parameter,
    * check "man add_exit"
    */
   add_exit( "search", PATH + "search", "door" );
   add_exit( "functions", PATH + "functions", "door" );
   add_exit( "common", "/w/common", "door" );
   /* this adds an exit back to this room from the common room
    */
   "/w/common"->add_exit( "learning", ENTRANCE, "door" );

   /* add_property is used to add a value to an object, that can later be
    * queried for with query_property.
    * The "commented functions" and "keywords" properties are specific for 
    * rooms in the learning domain and is used to make it possible to search
    * for subjects. 
    * See /d/learning/handlers/search.c for the way this is done.
    */
   add_property( "commented functions", 
                ({ "set_long", "set_short", "add_property", "set_light",
                   "add_exit" }) );
   add_property( "keywords", ({ "room" }) );
} /* setup() */

// --- END [/mnt/home2/grok/lib/d/learning/main.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/examples/player_houses/npcs/surface_decorator.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/examples/player_houses/npcs/surface_decorator.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627718   Available: 13575072
Inodes: Total: 5242880    Free: 4960133
7793 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/examples/player_houses/npcs/surface_decorator.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627718   Available: 13575072
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 *  This is an example file for the Learning domain.
 *
 *  In this file you should learn everything you need to know to put together 
 *  an NPC that will decorate the surfaces of player housing. 
 *
 *  There are a lot of comments in this particular file, but the basic things 
 *  you will need to add don't amount to much.
 *
 *  @author Una
 *  @September 20, 2002
 *
 **/

// This is the inherit you will need to use
inherit "/std/npc/surface_decorator";

void setup() {

    set_name( "worker" );
    // The big burly sort that does cat calls
    set_short( "construction worker" );
    add_property( "determinate", "a " );
    add_adjective( "construction" );
    add_property( "unique", 1 );
    setup_nationality( "/std/nationality/agatean", "Bes Pelargic" );    
    basic_setup( "human", "warrior", 30 );
    set_gender( 1 );
    
    set_long("This is a construction worker.  You can use him to "
        "decorate surfaces in player housing to the exact specifications "
        "that you will set later in this file.  He is slightly grubby, "
        "is covered in dust and paint, and likes to do wolf whistles.\n");
    
    // Adding the place property ensures that the decorator will
    // charge the correct currency when the player needs to pay.
    // If you don't add a place property, the default currency 
    // will be provincial.
    
    add_property( "place", "Counterweight Continent" );
       
   
   
    // Add_allowed_surface() adds surfaces to the NPC that they are allowed to
    // decorate.  You can decorate floors, ceilings and walls.
    
    // Note that just adding "wall" will include all of the walls in the 
    // room (north, south, east and west).  
    
    add_allowed_surface( "floor" ); 
    add_allowed_surface( "wall" );  
        
    
    
    // The following bit is what adds items to the NPC's stock list.  
    
    // The first argument in add_fitted_surface() is the short description 
    // of the decoration that you want to add.  This could be 
    // "wood panelling", "rough wooden beams", "neon yellow carpet",
    // or any other type of decoration that would make sense with the 
    // surfaces you've described above in add_allowed_surface().
    
    // The second argument is the long description that will be installed in
    // the room itself.  For example, the room would look like: The floor is         
    // covered with plush yellow carpet and the other surfaces are blah blah 
    // blah.
    
    // The third argument is the cost of the decoration and its installation.  
    // The type of currency the player is charged in is determined by the 
    // "add_property( "place", <location> );" that you defined above.  In 
    // this example, the player will be charged in Rhinu since the 
    // place is the Counterweight Continent.
        
    add_fitted_surface( "plush green carpet", "covered with plush "
        "green carpet", 1000 );
    add_fitted_surface( "plush red carpet", "covered with plush "
        "red carpet", 1000 );
    add_fitted_surface( "plush yellow carpet", "covered with plush "
        "yellow carpet", 1000 );
    add_fitted_surface( "plush blue carpet", "covered with plush "
        "blue carpet", 1000 );
    
    
        
    // The following function defines what the surface will look like while 
    // it is being decorated.  Note that if the worker is killed in the middle
    // of his job, the surface will retain this message until the player hires
    // him again and he completes the work.  The default message is:
    // "covered in dust and dirt".
    
    set_under_construction_mess( "covered in dust, plaster and carpet bits" );


    
    // This adds a domain which the NPC will freely wander around.  
    
    // In this example, if the file name of the room is anywhere 
    // in /w/una or anywhere in /d/cwc/Bes_Pelargic, the NPC will happily 
    // follow a player around.  
    
    // However, if they follow a player out of this file structure into 
    // another area,  (say they are in Bes Pelargic and walk onto 
    // the T-shop, which is in /d/underworld), the NPC will be moved
    // to the rubbish room and will then attempt to move themselves 
    // to the "good room" they were in.  If they can't move themselves 
    // into the last "good room" within a few seconds, they will be 
    // dested in the rubbish room.
    
    add_allowed_domain( "/w/una" );
    add_allowed_domain( "/d/cwc/Bes_Pelargic" );
    
    
    
    // You need to set some customised responses for the NPC so they don't 
    // sound like they have a stick up their arse, too. :)  In this example,
    // we will continue with the carpet theme used above and add a spicy 
    // Morporkian spicy pirate flavour to his new custom responses!
    
    set_responses( ({
        
        // This is what he will say if the player requests a type of 
        // surface you haven't added in add_allowed_surface().
        "'I don't fit those kinds of surfaces matey!",
        
        // This is what he will say if the player requests a type of 
        // carpet short that you have not listed in add_fitted_surface().
        "'I've never heard of those sort of carpets, arrrrr.",
        
        // This is what he will say if the player is not the owner of 
        // (or allowed by the owner) the house they are asking the worker
        // to decorate.
        "'Arr, you don't own this place, mister!",
        
        // This is what he will say if the room he is in when the player
        // asks him to decorate is not a player-housing room with decoratable
        // surfaces.
        "'I can't be decoratin' these here surfaces, shogun!  You should "
        "take me to a house!",
        
        // This is what he will say if something goes bizarrely wrong and 
        // the code needs to bail before he decorates the room.
        "'Arr matey, something went horribly wrong!",
        
        // This is what he will say when he is done the job.
        "'Arrrr matey, all done!",
        
        // This is what he will say if the player doesn't have enough money 
        // to pay for the decoration they have requested.  Leave in $decor$
        // and $amount$ - they are already replaced in the inherit by 
        // what the player has chosen and its price.
        "'You don't have enough money to pay for the $decor$!  It "
        "will cost you $amount$, guv!",
        
        // This is what he will say when you ask him to list his goods.
        "'I can fit $allowed$ with any of the following:",
        
        // This is what he will say if he hasn't got any stock.
        "'Cor blimey mister, I haven't got any stock.",
        
        // This is what he will say when he starts the job.
        "'Okey doke, I'll have it done in a jiffy guv'nor!",
        
        // This is what he will say if he can't see the person that's speaking
        // to him.
        "'What?  Who sed dat?",
        
        // This is what he will say if he's already following someone and 
        // another person tries to hire him.  $employer$ is replaced by the 
        //person who has hired him.
        "'I've already got this great job with $employer$, mate!",
        
        // This is what he will say when you hire his services.
        "'Righty-o, you just take me to the room you want spiffied "
        "up and ask me to fit something!",
        
        // This is what he will say if you try to take him out of an area he 
        // is not allowed to go out of.  You set this area with         
        // add_allowed_domain(), as shown above.
        "'Sorry matey, bad karma over that way."
        
    }) );  

        // That's all.  Easy peasy.  Enjoy and have fun. :)

} /* setup() */
// --- END [/mnt/home2/grok/lib/d/learning/examples/player_houses/npcs/surface_decorator.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/examples/terrain_map/basic/field.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/examples/terrain_map/basic/field.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627715   Available: 13575069
Inodes: Total: 5242880    Free: 4960133
425 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/examples/terrain_map/basic/field.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627715   Available: 13575069
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <terrain_map.h>

inherit TERRAIN_MAP_OUTSIDE_BASE;

// Important that we return the pathname to our handler.
string query_handler_path() { return __DIR__ + "field_handler"; }

// A standard room setup.
void setup()

{
  set_short("grassy field");
  set_long("This is a large grassy field.\n");

  add_item("field", "Large and grassy.");
  add_item("grass", "It's green, which should come as no surprise at all.");
}
// --- END [/mnt/home2/grok/lib/d/learning/examples/terrain_map/basic/field.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/examples/terrain_map/basic/field_handler.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/examples/terrain_map/basic/field_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627715   Available: 13575069
Inodes: Total: 5242880    Free: 4960133
1923 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/examples/terrain_map/basic/field_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627715   Available: 13575069
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <terrain_map.h>

inherit TERRAIN_MAP_HANDLER_BASE;

// For the purposes of this example, the map is called 'field.map',
// and is located in the same directory as this file.
string query_map_file() { return __DIR__ + "field"; }

void  setup_handler()

{
   // Setup our 'obstacle'. We put in the description to be seen in
   // adjacent locations, and an add_item to make it consistent.
   add_obstacle_type("*", "A tall fence blocks your way to the $D.",
                "fence", "A tall, unclimable wooden fence.");
   
   // Setup the standard field room - simply maps the '.' characters
   // onto the filename.
   add_room_type(".", __DIR__ + "field");
   
   // Setup the standard field road - maps the ',' characters
   // onto the filename. We also need the description to be seen in
   // adjacent locations, and details for an add_item entry in
   // said adjacent locations.
   add_road_type(",", __DIR__ + "path",
            "The path meanders $D.",
            "A small path meanders its way across the field to the $D.",
            "path",
            "The path has been trampled down by the hooves of time.");
   
   // To make this a little more interesting, let's add a feature.
   add_feature("bigtree", 4, 1, 1, 1, 4, 
                ({ "A giant tree towers over you to the $D.",
                   "A little way to the $D, you can see a huge tree.",
                   "You can just make out a large tree, a way off in an "
                   "$Derly direction." }), 
                   "tree", "A fairly large, and quite beautiful tree." );

   // And to make it even more interesting, let's give the tree some chats.
   set_feature_chats("bigtree", 
                     ({ "The branches on the tree to the $D "
                        "sway slightly in the breeze." }) );

   // Finally, we add our exit from the terrain map
   add_exit_at(2, 0, "south", __DIR__ + "entrance", "road");
}
// --- END [/mnt/home2/grok/lib/d/learning/examples/terrain_map/basic/field_handler.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/examples/terrain_map/basic/entrance.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/examples/terrain_map/basic/entrance.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627714   Available: 13575068
Inodes: Total: 5242880    Free: 4960133
558 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/examples/terrain_map/basic/entrance.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627714   Available: 13575068
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <terrain_map.h>

inherit TERRAIN_MAP_OUTSIDE_BASE;

// Important that we return the pathname to our handler.
string query_handler_path() { return __DIR__ + "field_handler"; }

// A standard room setup.
void setup()

{
  set_short("field entrance");
  set_long("You are at the entrance to a large grassy field.\n");

  add_item("path", "Trampled down by the hooves of time.");
  add_item("field", "Large and grassy.");
  add_item("grass", "It's green, which should come as no surprise at all.");

  add_exit("north", __DIR__ + "path:2:0", "road");
}
// --- END [/mnt/home2/grok/lib/d/learning/examples/terrain_map/basic/entrance.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/examples/terrain_map/basic/path.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/examples/terrain_map/basic/path.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627714   Available: 13575068
Inodes: Total: 5242880    Free: 4960133
505 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/examples/terrain_map/basic/path.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627714   Available: 13575068
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <terrain_map.h>

inherit TERRAIN_MAP_OUTSIDE_BASE;

// Important that we return the pathname to our handler.
string query_handler_path() { return __DIR__ + "field_handler"; }

// A standard room setup.
void setup()

{
  set_short("trampled path");
  set_long("This path meanders through a large grassy field.\n");

  add_item("path", "Trampled down by the hooves of time.");
  add_item("field", "Large and grassy.");
  add_item("grass", "It's green, which should come as no surprise at all.");
}
// --- END [/mnt/home2/grok/lib/d/learning/examples/terrain_map/basic/path.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/examples/npcs/cuthbert.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/examples/npcs/cuthbert.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627714   Available: 13575068
Inodes: Total: 5242880    Free: 4960133
3073 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/examples/npcs/cuthbert.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627714   Available: 13575068
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* Cuthbert requires more than the average NPC. He wants 
*cutting edge fashion.  If items are going to be truly 
*unique, add them this way, otherwise, add them to the armoury
*for all to share.  Don't make weapons unless you know what you are
*doing.
*/

#include <armoury.h>

#define TO this_object()
inherit "/obj/monster";

//We need to give him some items
object cape, trousers;




void setup() {

    set_name( "cuthbert" );
    set_short( "Cuthbert" );
    add_property("determinate", "");
    add_alias( ({"npc", "warrior", "man"}) );
    set_long("Cuthbert is a fashion victim.  Not content with off the peg "
    "stuff, he wants clothing unique to him.  Fair enough, let's give him"
    " some.\n"); 
    basic_setup ("human", "warrior", 50);
    set_gender( 1 );

    add_language( "common" );
    set_language( "common" );
    load_chat( 50, ({
                  1, ":checks his equipment.",
                  1, ":feels all snuggly and warm in his new clothes."                  
               }) );
    load_a_chat( 150, ({
                    1, "'Oof!",
                    1, ":is happy to die so you can learn.",
                    1, "You feel Someone is waiting in the wings."}) );
                    
         ARMOURY->request_item( "short sword",
         70+random(30))->move( TO );
         ARMOURY->request_item( "baggy leather loincloth",
         70+random(30))->move( TO );
         ARMOURY->request_item( "metal helmet",
         70+random(30))->move( TO );
         
         //Clone some clothes, make them trousers, give them all normal
         //properties, add some pockets, and some factors for condition
         //and resistance.
   trousers = clone_object( "/obj/clothing" );
   trousers->set_name( "britches" );
   trousers->add_adjective(({"pair", "of"}));
   trousers->set_short( "pair of britches" );
   trousers->add_alias("trousers");
   trousers->set_long( "These are funky purple flaired britches, made of camel"
   "skin with beaver fur lining.\n" );
   trousers->set_value( 100 );
   trousers->set_weight( 7 );
   //All clothing must have a type. Type
   //exec return m_indices("/obj/handlers/clothing_handler"
   //->query_all_clothing_types());
   //for a list of possibilities.
   trousers->set_type( "trousers" );
   trousers->add_pocket( "side", 100 );
   trousers->add_pocket( "side", 100 );
   trousers->set_damage_chance( 10 );
   trousers->set_max_cond( 800 );
   trousers->set_cond( 600 + random( 200 ) );
   trousers->move( TO );
         
         cape = clone_object( "/obj/clothing" );
   cape->set_name( "cape" );
   cape->set_short( "orange cape" );
   cape->add_adjective("orange");
   cape->set_long( "Orange velvet has been made into a large cape.  It is bright "
   "and garish.\n" );
   cape->set_value( 100 );
   cape->set_weight( 7 );
   cape->set_type( "cape" );
   cape->set_damage_chance( 10 );
   cape->set_max_cond( 800 );
   cape->set_cond( 600 + random( 200 ) );
   cape->move( TO );
      init_equip(); 
      
         give_money( 10, 30, "Ankh-Morpork pence" );

} /* ends setup() */
// --- END [/mnt/home2/grok/lib/d/learning/examples/npcs/cuthbert.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/examples/npcs/room2.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/examples/npcs/room2.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627713   Available: 13575067
Inodes: Total: 5242880    Free: 4960133
703 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/examples/npcs/room2.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627713   Available: 13575067
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h"
inherit "/std/room";

object npc;


void setup() {
    
    set_light(70);
    set_short( "seperate file NPC room" );
    add_property( "determinate", "the " );
    set_long( "The NPC in here is cloned from another file, and brought here."
    "  This method means the same NPC can easily be loaded into a variety "
    "of locations, without the need to repeat much code.  The npc file is "
    "in /d/learning/examples/npcs/pugh2.c.\n");
    
    add_exit("backwards", PATH +"room1", "door");
    add_exit("onwards", PATH +"room3", "door");
    }

void reset(){
        
        
        if (!npc){
    npc = clone_object( PATH +"pugh2" );
    npc->move( this_object() );
    }
    }// --- END [/mnt/home2/grok/lib/d/learning/examples/npcs/room2.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/examples/npcs/pugh2.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/examples/npcs/pugh2.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627712   Available: 13575066
Inodes: Total: 5242880    Free: 4960133
568 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/examples/npcs/pugh2.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627712   Available: 13575066
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming

/* Essentially, exactly the same data as in room1, but kept
*in a different file, for ease of mulitple use.
*/


inherit "/obj/monster";


void setup() {

    set_name( "pugh" );
    set_short( "Pugh" );
    add_property("determinate", "");
    add_alias( ({"npc", "warrior", "man"}) );
    set_long("This is Pugh.  He exists in a separate file, so can easily be "
    "loaded in a variety of locations at once.  Essentially, he is identical"
    " to Pugh in the other room.\n"); 
    basic_setup ("human", "warrior", 10);
    set_gender( 1 );

} /* ends setup() */
// --- END [/mnt/home2/grok/lib/d/learning/examples/npcs/pugh2.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/examples/npcs/room3.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/examples/npcs/room3.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627712   Available: 13575066
Inodes: Total: 5242880    Free: 4960133
666 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/examples/npcs/room3.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627712   Available: 13575066
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h"
inherit "/std/room";

object npc;


void setup() {
    
    set_light(70);
    set_short( "variable NPC room" );
    add_property( "determinate", "the " );
    set_long( "This room clones an NPC from a single file.  However, the NPC"
    " has built in variety.  Its description changes randomly.  Typing "
    "update will bring a new version of the NPC here, each time it"
    " will be different.\n");
    
    add_exit("backwards", PATH +"room2", "door");
    add_exit("onwards", PATH +"room4", "door");
    }

void reset(){
        
        
        if (!npc){
    npc = clone_object( PATH +"rat" );
    npc->move( this_object() );
    }
    }// --- END [/mnt/home2/grok/lib/d/learning/examples/npcs/room3.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/examples/npcs/barley.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/examples/npcs/barley.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627712   Available: 13575066
Inodes: Total: 5242880    Free: 4960133
1932 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/examples/npcs/barley.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627712   Available: 13575066
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* Barley is a chatty NPC.  If you try to kill him, he'll say
*something else, too.  He can say things, and emote things.
*/


inherit "/obj/monster";


void setup() {

    set_name( "barley" );
    set_short( "Barley" );
    add_property("determinate", "");
    add_alias( ({"npc", "warrior", "man"}) );
    set_long("Barley is a friendly, talkative NPC.  He chats and emotes."
    "  Also, he will occasionally give out quest hints.  If you try and"
    " kill him, he will become more animated.\n"); 
    basic_setup ("human", "warrior", 50);
    set_gender( 1 );
    
        //Educate your NPCs! Give them a language, and make them use it.
        //add() as many as you wish, but set() to only one.
    add_language( "common" );
    set_language( "common" );
    
    //The numbers control the frequency of chats.  The first number is 
    //the probability in 1000 a chat will occur every 2 seconds.  eg, 
    //100 = a one in ten chance of a chat happening every 2 secs, 
    //One chat per 20 seconds.  You will need to tweak figures to make these
   // appear at the right intervals.
   // The second number controls how likely the chat is to be chosen.  The 
   //higher the number, the more common the chat.
    load_chat( 50, ({
                  3, "'I say this quite often.",
                  3, ":does this quite often.",
                  3, "Chats can appear without the NPC name in them.",
                  1, "'I only give out quest hints 10% of the time."
               }) );
               
        //load__a_chats are combat chats, triggered by attacking the NPC
        //The numbers are the same, but it's an idea to make them appear more
        //often, as combat can be quick and furious.
    load_a_chat( 150, ({
                    1, "'Oof!",
                    1, ":is happy to die so you can learn.",
                    1, "You feel Someone is waiting in the wings."}) );

} /* ends setup() */
// --- END [/mnt/home2/grok/lib/d/learning/examples/npcs/barley.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/examples/npcs/rat.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/examples/npcs/rat.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627711   Available: 13575065
Inodes: Total: 5242880    Free: 4960133
1210 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/examples/npcs/rat.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627711   Available: 13575065
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 *We're going to make a rat, with a different description 
 *each time.  Also, their sex and level will be random.
 *The long() will reflect this.
 */

inherit "/obj/monster";

void setup() {
        
        //A list of possible adjectives to use and select from.
    string *name_adjectives = ({ "furry", "manky", 
      "flea-ridden", "obnoxious", "sharp-toothed", "stinky", "dirty, stinking",
      "brown", "beady-eyed", "corpse-eating" });
    string adjective;

    adjective = name_adjectives[random(sizeof(name_adjectives))];


        //Normal basic information, short() uses a random adjective.
    set_name("rat");
    add_alias("rodent");
        //Gender = 1 + (zero or one)
    set_gender(1 + random(2));    
    set_short(adjective + " rat");
    add_adjective(adjective);
        //Note the query_possessive() in the long() to get his, or her right
    set_long("The learning domain is full of rats.  This one appears "
    "not to have eaten for some hours and has a look"
    " of hunger in " + query_possessive()
      + " eyes.\n");

        //Level 2 plus a random figure upto and including 4 (including 0)
    basic_setup ("rat", "fighter", 2 + random(5));
    
  
} /* setup() */


// --- END [/mnt/home2/grok/lib/d/learning/examples/npcs/rat.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/examples/npcs/room4.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/examples/npcs/room4.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627711   Available: 13575065
Inodes: Total: 5242880    Free: 4960133
629 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/examples/npcs/room4.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627711   Available: 13575065
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h"
inherit "/std/room";

object npc;


void setup() {
    
    set_light(70);
    set_short( "chatting NPC room" );
    add_property( "determinate", "the " );
    set_long( "The NPC in here gets to talk a little bit.  He has both random"
    " chats, and chats for use in combat which make him more entertaining.  "
    "Some chats appear more often than others.\n");
    
    add_exit("backwards", PATH +"room3", "door");
    add_exit("onwards", PATH +"room5", "door");
    }

void reset(){
        
        
        if (!npc){
    npc = clone_object( PATH +"barley" );
    npc->move( this_object() );
    }
    }// --- END [/mnt/home2/grok/lib/d/learning/examples/npcs/room4.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/examples/npcs/macgrew.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/examples/npcs/macgrew.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627710   Available: 13575064
Inodes: Total: 5242880    Free: 4960133
1988 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/examples/npcs/macgrew.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627710   Available: 13575064
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* Macgrew is not naked, and has equipment.
*We use the armoury to get stuff which already exists.
*/


//Tell the file we're going to use the armoury
#include <armoury.h>

//We'll call this_object() TO, and will use this in the armoury stuff
#define TO this_object()

inherit "/obj/monster";


void setup() {

    set_name( "macgrew" );
    set_short( "MacGrew" );
    add_property("determinate", "");
    add_alias( ({"npc", "warrior", "man"}) );
    set_long("MacGrew is a warm, armed NPC.  He models some of the latest "
    "fashions, but beware of mentioning them in the long() because he may "
    "have them stolen, or broken.  Let players look at him.\n"); 
    basic_setup ("human", "warrior", 50);
    set_gender( 1 );

    add_language( "common" );
    set_language( "common" );
    load_chat( 50, ({
                  1, ":checks his equipment.",
                  1, ":feels all snuggly and warm in his new clothes."                  
               }) );
    load_a_chat( 150, ({
                    1, "'Oof!",
                    1, ":is happy to die so you can learn.",
                    1, "You feel Someone is waiting in the wings."}) );


        //We'll request_item() to get an item from any of the following sources
        // /obj/armours/
        // /obj/clothes/
        // /obj/jewellery/
        // /obj/weapons/
        // /obj/scabbards/
        //We then give the item a condition, and move it to the npc.
         ARMOURY->request_item( "short sword",
         70+random(30))->move(this_object());
         ARMOURY->request_item( "baggy leather loincloth",
         70+random(30))->move(this_object());
         ARMOURY->request_item( "metal helmet",
         70+random(30))->move(this_object());
         
         //Then we need to make the NPC equip the stuff.  
         //No point carrying armour.
         init_equip();
         
         //And let's give him some money.
         give_money( 10, 30, "Ankh-Morpork pence" );

} /* ends setup() */
// --- END [/mnt/home2/grok/lib/d/learning/examples/npcs/macgrew.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/examples/npcs/room1.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/examples/npcs/room1.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627709   Available: 13575063
Inodes: Total: 5242880    Free: 4960133
1624 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/examples/npcs/room1.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627709   Available: 13575063
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h"
inherit "/std/room";

//The next line tells the MUD to expect an object to 
//be placed in this object (room).  We'll call it npc
object npc;


void setup() {
    
    set_light(70);
    set_short( "cloned NPC room" );
    add_property( "determinate", "the " );
    set_long( "This room holds a very simple NPC.  He is a fighter.  His "
    "code is within the room code.  If he's not here, type update, and"
    ", like magic, he should appear.  If he doesn't, panic.\n");
    
    add_exit("onwards", PATH +"room2", "door");
    }

void reset(){
        
        
        if (!npc){
        //When we need the object npc, we clone one, and make it a 
        //simple monster base.
    npc = clone_object( "/obj/monster" );
    
        //Give him a name, and short
    npc -> set_name("pugh");
    npc -> set_short("Pugh");
    
        //Make sure he is Pugh, not The Pugh
    npc -> add_property("determinate", "");
    
        //Add aliases, so players can call him what they like
    npc -> add_alias( ({"npc", "warrior", "man"}) );
    
        //Add a long description of him
    npc -> set_long("This is Pugh.  He was cloned here, and "
    "this is his world.  Welcome to it.\n");
    
        //Basic_setup allows us to define race, class and level
        //You must include these three things. Race and class
        //come from /std/race.c
    npc -> basic_setup("human", "warrior", 10);
    
        //gender 1 = male, 2 = female, 0 = neuter
    npc -> set_gender( 1 );
    
        //And finally, having made the object, we bring it to the room
    npc->move( this_object() );
    }
    }// --- END [/mnt/home2/grok/lib/d/learning/examples/npcs/room1.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/examples/npcs/room6.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/examples/npcs/room6.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627709   Available: 13575063
Inodes: Total: 5242880    Free: 4960133
652 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/examples/npcs/room6.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627709   Available: 13575063
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h"
inherit "/std/room";

object npc;


void setup() {
    
    set_light(70);
    set_short( "room with a fashion-victim NPC" );
    add_property( "determinate", "the " );
    set_long( "The NPC is here is not content with last year's fashion.  "
    "He wants new, exciting clothes, to be unique to him.  He has some "
    "standard stuff, but he has things which are unique to him.\n");
    
    add_exit("backwards", PATH +"room5", "door");
    add_exit("onwards", PATH +"room7", "door");
    }

void reset(){
        
        
        if (!npc){
    npc = clone_object( PATH +"cuthbert" );
    npc->move( this_object() );
    }
    }// --- END [/mnt/home2/grok/lib/d/learning/examples/npcs/room6.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/examples/npcs/room5.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/examples/npcs/room5.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627708   Available: 13575062
Inodes: Total: 5242880    Free: 4960133
684 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/examples/npcs/room5.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627708   Available: 13575062
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h"
inherit "/std/room";

object npc;


void setup() {
    
    set_light(70);
    set_short( "room with a non-naked NPC" );
    add_property( "determinate", "the " );
    set_long( "We ought to clothe our NPCs and give them weapons, else how "
    "will the poor darlings survive the winter, and fend off attackers?  "
    "The easiest way is to give them items which already exist on the MUD"
    " via the armoury.\n");
    
    add_exit("backwards", PATH +"room4", "door");
    add_exit("onwards", PATH +"room6", "door");
    }

void reset(){
        
        
        if (!npc){
    npc = clone_object( PATH +"macgrew" );
    npc->move( this_object() );
    }
    }// --- END [/mnt/home2/grok/lib/d/learning/examples/npcs/room5.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/common.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/common.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627708   Available: 13575062
Inodes: Total: 5242880    Free: 4960133
7149 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/common.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627708   Available: 13575062
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <config.h>
#include "path.h"

/* inherit "/std/dom/cmn_mas"; 
 * being a common room, this should inherit the previous, but since that's 
 * basically a piece of shit, I won't have it contaminate my nice room:)
 */
inherit "/std/room/basic_room";

#define HANDLER (LEARNING +"handlers/request")

object board;
object *chairs; /* people sitting */
int do_claim(int);
int do_remove(int);
int do_request(string, string);
int do_sit( string command, object *indir, string dir_match, 
           string indir_match, mixed *args, string pattern );

void setup() {
   set_light( 100 );
   set_short( "somewhat boring commonroom of the learning domain" );
   add_property( "determinate", "the " );
   set_long( "This is the common room of the domain of learning, the place "
            "where creators come to learn.  It is a somewhat boring room "
            "except for some chairs strewn around the place which happen to "
            "be an example of having commands defined in add_items, and some "
            "sort of list hanging on the wall which is an example of using "
            "add_command in rooms.\n" );
   add_item( "chair", ({ 
      "long", "This chair looks comfortable, perhaps you can sit in it.",
      "sit", ({ (: do_sit :), "[in] <direct:object>" })
   }), 1 );
   add_item( "chairs", ({ 
      "long", "These chairs look comfortable, "
              "perhaps you can sit in one of them.",
      "sit", ({ (: do_sit :),  "[in] <direct:object>" })
   }), 1 );
   add_item( "list", 
            "This list has several actions associated with it:\n"
            "\"show list\" will show the current requests.\n" 
            "\"request documentation\" will ask for "
            "documentation on something.\n" 
            "\"request example\" will ask for an example of "
            "something to be coded.\n" 
            "\"claim <number>\" is use to claim a request, thereby attempting "
            "to make sure that only one creator is writing the documentation/"
            "coding the examples." );
   add_exit( "entrance", PATH +"main", "path" );
   add_exit( "drum", CONFIG_START_LOCATION, "path" );

   /* make all chairs empty */
   chairs = ({ });
   /* calling this result in the function extra_look() being called whenever
    * people look at the room */
   add_extra_look( this_object() );
   /* the normal add_property() calls for the learning domain */
   add_property( "commented functions", ({ "add_extra_look", "extra_look",
      "remove_extra_look", "add_command" }) );
   add_property( "keywords", ({ "room", "add_item", "action" }) );
   /*make a copy of the domain's board */
   board = clone_object( "/obj/misc/board" );
   board->set_datafile( DOMAIN );
   board->move( this_object() );
} /* setup() */

void init() {
   ::init();
   add_command( "show", "list" );
   add_command( "claim", "<number>", (:do_claim( $4[0] ):) );
   add_command( "request", "{documentation|example} <string'subject'>",
                (:do_request( $4[0], $4[1] ):));
   add_command( "remove", "<number>", (:do_remove( $4[0] ):) );
} /* init() */

int do_show() {
   write( HANDLER->query_list() );
   return 1;
} /* do_show() */

int do_claim( int i ) {
  if ( HANDLER->claim_request( this_player()->query_name(), i ) ) {
    add_succeeded_mess("$N $V a request.\n", ({}));
  } else {
    return notify_fail( "Illegal request number.\n" );
  }
  return 1;
} /* do_claim() */

int do_remove( int i ) {
  if ( HANDLER->remove_request( this_player()->query_name(), i ) ) {
    add_succeeded_mess("$N $V a request.\n", ({}));
  } else {
    return notify_fail( "You can't remove that request.\n" );
  }
  return 1;
} /* do_remove() */

int do_request( string option, string words ) {
  if ( option == "documentation" ){
      HANDLER->add_request( this_player()->query_name(),
                           "documentation for "+ words );
      write( "You request some documentation.\n");
      say( this_player()->the_short() +" requests some documentation.\n");
      return 1;
   }
  if ( option == "example") {
      HANDLER->add_request( this_player()->query_name(),
                           "examples of "+ words );
      write( "You request some example.\n");
      say( this_player()->the_short() +" requests some example.\n");
      return 1;
   }
   return 0;   
} /* do_request() */

int do_sit( string command, object *indir, string dir_match, 
           string indir_match, mixed *args, string pattern ) {
   /* Note!  I use add_succeeded_mess even though the command failed, 
    * because it fails for another reason than being the wrong object.
    * This make it work even though there is a "sit" soul.
    */
   if ( dir_match == "chairs" ) {
      this_player()->add_succeeded_mess( previous_object(), 
             "How can you sit on more than one chair at the same time?\n", 
             ({ }) );
      return 1;
   }
   if ( member_array( this_player(), chairs ) != -1 ) {
      this_player()->add_succeeded_mess( previous_object(), 
             "You are already sitting in a chair.\n", ({ }) );
      return 1;
   }
   /* add the player to the list of people in the chairs */
   chairs += ({ this_player() });
   /* calling add_extra_look() result in the function extra_look being     
    * called whenever people look at the person */
   this_player()->add_extra_look( this_object() );
   this_player()->add_succeeded_mess( previous_object(), 
           "$N $V in a "+ dir_match +".\n", ({ }) );
   return 1;
} /* do_sit() */

string extra_look( object thing ) {
   if ( thing == this_object() ) { /* we're looking at the room */
      /* remove people who have logged out */
      chairs = filter_array( chairs, (: $1 != 0 :) );
      /* and those who have left */
      chairs = filter_array( chairs, 
                            (: environment( $1 ) == this_object() :) );
      if ( !sizeof( chairs ) ) { /* none left sitting */
         return "";
      } else {
         if ( sizeof( chairs ) == 1 ) {           /* only one left */
            if ( chairs[ 0 ] == this_player() ) { /* and it's you */
               return "You are sitting in one of the chairs.\n";
            } else {                              /* and it's someone else */
               return (string)chairs[ 0 ]->the_short() 
                      +" is sitting in one of the chairs.\n";
            }
         } else {
            return query_multiple_short( chairs, "the" ) 
              +" are sitting in the chairs.\n";
         }
      }
   } else if ( member_array( thing, chairs ) != -1 ) {
      /* we're looking at someone who might be sitting */
      if ( environment( thing ) == this_object() ) { /* sitting and here */
         if ( thing == this_player() ) { /*looking at yourself */
            return "You are sitting in a chair looking lazy.\n";
         } else {
            return thing->query_pronoun() +" is lazing around in a chair.\n";
         }
      }
   }
   /* calling remove_extra_look() stop extra_look() being     
    * called whenever people look at the thing */
   thing->remove_extra_look( this_object() );
   /* show nothing */
   return "";
} /* extra_look() */
// --- END [/mnt/home2/grok/lib/d/learning/common.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/handlers/search.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/handlers/search.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627706   Available: 13575060
Inodes: Total: 5242880    Free: 4960133
8796 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/handlers/search.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627706   Available: 13575060
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <learning.h>

#define SAVE SAVEPATH +"search"

mapping rooms,       /* rooms[ keyword ] = array of rooms with this keyword
                      */
        objects,     /* objects[ keyword ] = array of objects with this keyword
                      */
        keywords,    /* keywords[ filename ] = array of keywords defined
                      * by file
                      */
        functions;   /* functions[ filename ] = array of functions defined 
                      * by object filename
                      */
string *directories; /* Array holding the directories that still need
                      * checking.  
                      * Used only while collecting information from 
                      * rooms in the domain.
                      */
nosave string word;

/* create() is the first function called in any object when it is 
 * cloned.
 */
void create() {
   /* seteuid is needed for the save_object and restore_object calls 
    */
   seteuid( (string)master()->get_bb_uid() );
   /* restore the saved values for the 
    */
   unguarded( (: restore_object, SAVE :) );
} /* create() */

/* Given words keywords chosen so far,
 * return ({ ({ keywords }), ({ rooms }), ({ objects }) }),
 * where keywords are all keywords that are in at least one of the rooms
 * or objects, objects are all objects having all words defined
 * and rooms are all rooms having all words defined.
 */
mixed get_keywords( string *words ) {   
   string *found_words, *found_rooms, *found_objects, key, *value;
   
   if( sizeof( words ) ) {
      /* all files known */
      found_objects = keys( keywords );    
      foreach( word in words ) {
         /* remove all files that haven't defined the keyword */
         if( objects[ word ] ) {
            found_objects = filter_array( found_objects, 
                (: member_array( $1, objects[ word ] ) != -1 :) ); 
         } else {
            found_objects = ({ });
         }
      }
      /* all files known */
      found_rooms = keys( keywords );    
      foreach( word in words ) {
         /* remove all files that haven't defined the keyword */
         if( rooms[ word ] ) {
            found_rooms = filter_array( found_rooms, 
                (: member_array( $1, rooms[ word ] ) != -1 :) );
         } else {
            found_rooms = ({ });
         }
      }
      found_words = ({ });
      foreach( word in found_rooms ) {
         found_words -= keywords[ word ]; /* remove duplicates */
         found_words += keywords[ word ]; /* add new ones */
      }
      foreach( word in found_objects ) {
         found_words -= keywords[ word ]; /* remove duplicates */
         found_words += keywords[ word ]; /* add new ones */
      }
      found_words -= words; /* remove those found already */
   } else {
      found_rooms = ({ });
      foreach( key, value in rooms ) {
         found_rooms -= value; /* remove duplicates */
         found_rooms += value; /* add new ones */
      }
      found_objects = ({ });
      foreach( key, value in objects ) {
         found_objects -= value; /* remove duplicates */
         found_objects += value; /* add new ones */
      }
      found_words = keys( rooms );
      found_words -= keys( objects );
      found_words += keys( objects );
   }
   return ({ found_words, found_rooms, found_objects });
} /* get_keyword() */

/* Get information for specific file.
 */
void update_info_for( string file ) {
   string *words, word;
   object obj;

   if( !catch( file->force_load() ) ) {
      obj = find_object( file );
      words = obj->query_property( "commented functions" );
      if( words ) {
         functions[ file ] = words;
      }
      words = obj->query_property( "keywords" );
      if( words ) {
         keywords[ file ] = words;
         if( function_exists( "add_exit", obj ) ) { /* it's a room */
            foreach ( word in words ) {
               if( rooms[ word ] ) {
                  rooms[ word ] -= ({ file }); /* remove previous definition */
                  rooms[ word ] += ({ file }); /* add new */
               } else {
                  rooms[ word ] = ({ file });
               }
            }
         } else {
            foreach ( word in words ) {
               if( objects[ word ] ) {
                  objects[ word ] -= ({ file }); /* remove previous definition */
                  objects[ word ] += ({ file }); /* add new */
               } else {
                  objects[ word ] = ({ file });
               }
            }
         }
      }
      if( !directories ) { /* This is a single room so save the new info */
         unguarded( (: save_object, SAVE :) );
      }
   }
} /* update_info_for() */

/* This function does the same as the update command used on the room
 * Basically, it moves all users in the room, to the void, destructs the room
 * loads it again, and moves prople back again.
 */
void update_search( string room ) {
   object *obs;
   int i;

   obs = all_inventory( find_object( room ) );
   i = sizeof( obs );
   while( i--  ) {
      if ( userp( obs[ i ] ) ) {
         obs[ i ]->move( "/room/void" );
      } else {
         obs = delete( obs, i, 1 );
      }
   }
   room->dest_me();
   room->force_load();
   obs->move( room );
} /* update_search() */

/* collects the information from the next directory in line, adding new
 * subdirectories when found.
 */
void collect_one() {
   string dir, file, *funcs;
   mixed dirs, file_info;
   
   dir = directories[ 0 ];
   dirs = get_dir( dir, -1 );
   if( dirs ) {
      foreach ( file_info in dirs ) {
         if( file_info[ 1 ] == -2 ) { /* it's a directory */
            if( file_info[ 0 ] != "old" ) { /* ignore the files in the old dir */
               directories = directories + ({ dir + file_info[ 0 ] +"/" });
            }
         } else { /* it's a file */
            if( ( sizeof( file_info[ 0 ] ) > 2 ) && 
                ( file_info[ 0 ][ <2 .. <1 ] == ".c" ) ) {
               update_info_for( dir + file_info[ 0 ][ 0 .. <3 ] );
            }
         }
      }
   }
   directories = directories[ 1 .. <1 ]; /* remove the dir that where just checked*/
   if( find_call_out( "collect_one" ) == -1 && sizeof( directories ) ) {
      call_out( "collect_one", 3 );
   } else if( !sizeof( directories ) ) { /* we are done so save */
      /* tell me it's done */
      tell_object( find_living( "olorin" ), "Collect finished.\n" ); 
      directories = 0;
      /* and save it */
      unguarded( (: save_object, SAVE :) );
      /* this call is to restore all the keyword and function exits 
       * to the first search and function rooms
       */
      update_search( LEARNING +"search" );
      update_search( LEARNING +"functions" );
   }
} /* collect_one */

void collect() {
   /* This function will start a run through all files in the subdirectories of
    * "/d/learning" and collect the needed information.
    */
   rooms=([ ]);
   objects=([ ]);
   functions=([ ]);
   keywords=([ ]);
   directories=({ "/d/learning/" });
   collect_one();
} /* collect() */

int query_collecting() {
   if( directories ) {
      return 1;
   } else { 
      return 0;
   }
} /* query_collecting() */

string find_room( string *words ) {
   object thing, *things;
   string word_mark;

   if( !sizeof( words ) )
     return LEARNING +"search";
   word_mark = implode( sort_array( words, 1 ), ", " );
   things = children( SEARCH_ROOM ) - ({ find_object( SEARCH_ROOM ) });
   foreach ( thing in things ) {
      if ( (string)thing->query_marker() == word_mark )
        return file_name( thing );
   }
   thing = clone_object( SEARCH_ROOM );
   thing->set_marker( word_mark, words );
   return file_name( thing );
} /* find_room() */

string find_function_room( string word ) {
   object thing, *things;

   if( !word )
     return LEARNING +"functions";
   things = children( FUNCTION_ROOM ) - ({ find_object( FUNCTION_ROOM ) });
   foreach ( thing in things ) {
      if ( (string)thing->query_marker() == word )
        return file_name( thing );
   }
   thing = clone_object( FUNCTION_ROOM );
   thing->set_marker( word );
   return file_name( thing );
} /* find_function_room() */

string *query_functions() {
   string *functions_found, key, *value;
   
   functions_found = ({ });
   foreach ( key, value in functions ) {
      functions_found -= value; /* remove duplicates */
      functions_found += value;
   }
   return sort_array( functions_found, 1 );
} /* query_functions() */

string *query_rooms_with_function( string word ) {
   string *rooms_found, key, *value;
   
   rooms_found = ({ });
   foreach ( key, value in functions ) {
      if ( member_array( word, value ) != -1 )
        rooms_found += ({ key });
   }
   return uniq_array(rooms_found);
} /* query_rooms_with_function() */

// --- END [/mnt/home2/grok/lib/d/learning/handlers/search.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/handlers/request.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/handlers/request.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627704   Available: 13575058
Inodes: Total: 5242880    Free: 4960133
1785 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/handlers/request.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627704   Available: 13575058
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <learning.h>
#define SAVE SAVEPATH +"request"

mixed *requests;   /* values are each ({ poster, clainmant, request }) */

void create() {
   /* seteuid is needed for the save_object and restore_object calls */
   seteuid( (string)master()->get_bb_uid() );
   /* restore the saved values for this  */
   unguarded( (: restore_object, SAVE :) );
   if( !requests ) requests = ({ });
} /* create() */

void save_me() {
   unguarded( (: save_object, SAVE :) );
} /* save_me() */

string query_list() {
   int i;
   string ret;
   mixed request;
   
   if ( !sizeof( requests ) ) {
      return "There are no requests at the moment.\n";
   } 
   ret = "$P$Requests$P$The following requests have been made:\n";
   foreach( request in requests ) {
      if ( !request[ 1 ] ) {
         ret += sprintf( "%4d. $C$%s asked for %s.\n", i,
                        request[ 0 ], request[ 2 ] );
      } else {
         ret += sprintf( "%4d. $C$%s asked for %s.\n       Claimed by $C$%s\n", i,
                        request[ 0 ], request[ 2 ],
                        request[ 1 ]);
      }
   }
   return ret;
} /* query_list() */

void add_request( string name, string words ) {
   requests += ({ ({ name, 0, words }) });
   save_me();
} /* add_request() */

int claim_request( string name, int number ) {
   if ( number >= 0 && number < sizeof( requests ) ) {
      requests[ number ][ 1 ] = name;
      save_me();
      return 1;
   }
   return 0;
} /* add_request() */

int remove_request( string name, int number ) {
   if ( number >= 0 && number < sizeof( requests ) ) {
      if ( requests[ number ][ 0 ] == name || name == CURRENT_LORD ) {
         requests = delete( requests, number, 1 );
         save_me();
         return 1;
      }
   }
   return 0;
} /* add_request() */

// --- END [/mnt/home2/grok/lib/d/learning/handlers/request.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/handlers/quit.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/handlers/quit.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627703   Available: 13575057
Inodes: Total: 5242880    Free: 4960133
3049 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/handlers/quit.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627703   Available: 13575057
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <learning.h>

#define SAVE_FILE SAVEPATH +"search_quit"

inherit "/std/room/basic_room";

mapping locations;

void setup() {
   set_short( "quit handler of the search rooms" );
   set_light( 50 );
   set_long( "You are in the quit_handler of the search rooms of the learning "
            "domain.  In normal use, people only end up in the quit_handler "
            "if something goes wrong, since the event_enter() function will "
            "send them on to the correct place immediately.\n" );
   add_exit( "back", ENTRANCE, "path" );
   locations = ([ ]);
   if ( file_size( SAVE_FILE +".o" ) )
      unguarded( (: restore_object, SAVE_FILE :) );
   call_out( "check_names", 2 );
} /* setup() */

/* This one saves the locations of players handled by it.
 */
void save_this() { unguarded( (: save_object, SAVE_FILE :) ); }

/* This one will run through the saved people to check if they are still 
 * playing here
 */
void check_names() {
   string word;
   foreach ( word in keys( locations ) )
      if ( !"/secure/login"->test_user( word ) )
         locations = m_delete( locations, word );
   save_this();
} /* check_names() */

/* This is called by the quit command, with the quitting player and 
 * the place quitted in as parameters
 */
void player_quitting( object player, object place ) {
   if ( player->query_property( "guest" ) )
      return;
   locations[ (string)player->query_name() ] =
         (string *)place->query_keywords();
   /* if query_keywords are undefined, it's in the function search
    */
   if ( !locations[ (string)player->query_name() ] ) {   
      locations[ (string)player->query_name() ] =
          (string)place->query_marker();   
   }
   save_this();
} /* player_quitting() */

/* This is called by an event_exit in the rooms handled
 */
void remove_from_list( object player ) {
   string word;
   
   word = (string)player->query_name();
   if ( locations[ word ] )
      locations = m_delete( locations, word );
   save_this();
} /* remove_from_list() */

/* This is the room people are put in when logging on after
 * logging out from a room handled by this handler, so normally
 * it's made to dump the players their default starting position
 * if they can't be put in the right room, but since I'm such a 
 * nice guy I'll let them look around a bit.
 */
void event_enter( object player, string words, object from ) {
   string location, word;
   
   if( from ) {
      /*  Player entered from another room, to it's ok to stay
       */
      return;
   }
   word = (string)player->query_name();
   if ( !locations[ word ] ) {
      player->move( (string)player->query_start_pos(),
            "$N enter$s the game." );
      return;
   }
   if ( pointerp( locations[ word ] ) ) { /* it's one of the search rooms */
      location = (string)SEARCH->find_room( locations[ word ] );
   } else { /* it's one of the function rooms */
      location = (string)SEARCH->find_function_room( locations[ word ] );
   }
   player->move( location, "$N enter$s the game." );
} /* event_enter() */
// --- END [/mnt/home2/grok/lib/d/learning/handlers/quit.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/newbie/introduction/examples/advanced_item_1.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/newbie/introduction/examples/advanced_item_1.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627702   Available: 13575056
Inodes: Total: 5242880    Free: 4960133
706 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/newbie/introduction/examples/advanced_item_1.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627702   Available: 13575056
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*
    This is a container,
    For containing fings.
    
    Wrytten by Drakkos Thee Creator.
    20/10/2000
*/

inherit "/obj/baggage";

void setup() {
    set_name("bag");
    set_short("little green bag");
    set_long("This is a little green bag.\n");
    add_adjective(({"little", "green"}));
    set_weight(5);
    set_max_weight(20);
}

int test_add(object ob, int flag) {
    if(this_player()->query_name() != "drakkos") {
        return 0;
    } 
    else {
        return ::test_add(ob, flag);
    }
}

int test_remove(object ob, int flag, mixed dest) {
    if(this_player()->query_name() != "drakkos") {
        return 0;
    } 
    else {
        return ::test_remove(ob, flag, dest);
    }
}// --- END [/mnt/home2/grok/lib/d/learning/newbie/introduction/examples/advanced_item_1.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/newbie/introduction/examples/.simple_weapon.wep_virtual_.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/newbie/introduction/examples/.simple_weapon.wep_virtual_.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627702   Available: 13575056
Inodes: Total: 5242880    Free: 4960133
991 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/newbie/introduction/examples/.simple_weapon.wep_virtual_.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627702   Available: 13575056
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <virtual.h>

void dest_me() { destruct( this_object() ); }

void create()
{
  seteuid( (string)"/secure/master"->creator_file( file_name( this_object() ) ) );
} /* create() */

object create_virtual_ob() {
   object clone;

  clone = (object)SERVER->create_virtual_object( "/obj/weapon.c", 1 );
  clone->add_property( "virtual name", "/d/learning/newbie/introduction/examples/simple_weapon.wep#1" );
  call_other( clone, "set_name",  "mop"  );
  call_other( clone, "set_short",  "dirty mop"  );
  call_other( clone, "set_long",  "This is a dirty mop, dripping with ooze.\n"  );
  call_other( clone, "add_adjective",  "dirty"  );
  call_other( clone, "set_weight",  20  );
  call_other( clone, "set_value",  2000  );
  call_other( clone, "new_weapon", 10000  );
  call_other( clone, "add_attack",  "prod", 50, ({ 5, 6, 6 }), "blunt", "blunt", 0  );
  call_other( clone, "add_attack",  "whack", 50, ({ 10, 10, 5 }), "blunt", "blunt", 0 );
   return clone;
} /* create_virtual_ob() */
// --- END [/mnt/home2/grok/lib/d/learning/newbie/introduction/examples/.simple_weapon.wep_virtual_.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/newbie/introduction/examples/.advanced_item_4.food_virtual_.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/newbie/introduction/examples/.advanced_item_4.food_virtual_.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627701   Available: 13575055
Inodes: Total: 5242880    Free: 4960133
874 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/newbie/introduction/examples/.advanced_item_4.food_virtual_.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627701   Available: 13575055
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <virtual.h>

void dest_me() { destruct( this_object() ); }

void create()
{
  seteuid( (string)"/secure/master"->creator_file( file_name( this_object() ) ) );
} /* create() */

object create_virtual_ob() {
   object clone;

  clone = (object)SERVER->create_virtual_object( "/obj/food.c", 1 );
  clone->add_property( "virtual name", "/d/learning/newbie/introduction/examples/advanced_item_4.food#1" );
  call_other( clone, "set_name", "sandwich"  );
  call_other( clone, "set_short", "monkey sandwich"  );
  call_other( clone, "add_adjective", ({ "monkey" })  );
  call_other( clone, "set_value", 0  );
  call_other( clone, "set_weight", 1  );
  call_other( clone, "set_long", "This is a monkey sandwich.  Made from real monkey.  Mmm!\n"  );
  call_other( clone, "add_eat_effect",  "/std/effects/ingested/poison", 600 );
   return clone;
} /* create_virtual_ob() */
// --- END [/mnt/home2/grok/lib/d/learning/newbie/introduction/examples/.advanced_item_4.food_virtual_.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/newbie/introduction/examples/.simple_object.clo_virtual_.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/newbie/introduction/examples/.simple_object.clo_virtual_.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627701   Available: 13575055
Inodes: Total: 5242880    Free: 4960133
952 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/newbie/introduction/examples/.simple_object.clo_virtual_.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627701   Available: 13575055
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <virtual.h>

void dest_me() { destruct( this_object() ); }

void create()
{
  seteuid( (string)"/secure/master"->creator_file( file_name( this_object() ) ) );
} /* create() */

object create_virtual_ob() {
   object clone;

  clone = (object)SERVER->create_virtual_object( "/obj/clothing.c", 1 );
  clone->add_property( "virtual name", "/d/learning/newbie/introduction/examples/simple_object.clo#1" );
  call_other( clone, "set_name",  "dungarees"  );
  call_other( clone, "set_short",  "pair of waterproof dungarees"  );
  call_other( clone, "set_long",  "This is a pair of waterproof dungarees.  Luckily they "     "are also ooze proof.\n"  );
  call_other( clone, "add_adjective",  ({"pair of", "waterproof"})  );
  call_other( clone, "set_weight",  45  );
  call_other( clone, "set_value",  4000  );
  call_other( clone, "setup_clothing",  50000  );
  call_other( clone, "set_type",  "robe" );
   return clone;
} /* create_virtual_ob() */
// --- END [/mnt/home2/grok/lib/d/learning/newbie/introduction/examples/.simple_object.clo_virtual_.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/newbie/introduction/examples/simple_object.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/newbie/introduction/examples/simple_object.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627700   Available: 13575054
Inodes: Total: 5242880    Free: 4960133
488 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/newbie/introduction/examples/simple_object.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627700   Available: 13575054
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*
    This is a basic object!
    Written by Drakkos.
    
    04/10/2000
*/  

inherit "/obj/clothing";

void setup() {
    set_name("dungarees");
    set_short("pair of waterproof dungarees");
    add_adjective(({"pair of", "waterproof"}));
    set_long("This is a pair of waterproof dungarees.  Luckily they "
        "are also ooze proof.\n");
    add_adjective(({"pair of", "waterproof"}));
    set_weight(45);
    set_value(4000);
    setup_clothing(50000);
    set_type("robe");
}// --- END [/mnt/home2/grok/lib/d/learning/newbie/introduction/examples/simple_object.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/newbie/introduction/examples/simple_room.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/newbie/introduction/examples/simple_room.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627700   Available: 13575054
Inodes: Total: 5242880    Free: 4960133
2706 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/newbie/introduction/examples/simple_room.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627700   Available: 13575054
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*
    This is a basic room!
    Written by Drakkos.
    
    29/09/2000
*/  

#include "path.h"

inherit "/std/room";

void setup() {
    set_short("blobby lair");
    set_long("This is where the grey blob lives.  All around lie "
        "frogs, and wombles, and strange oozy things.  It's a "
        "very nice lair, as lairs go.\n");
    add_property("determinate", "a ");
    set_light(50);

    add_item(({"frog", "pinkfish", "toad"}),({"long", "The frogs are very "
        "nice.  Very froggy.", "position", "one of the poor leetle "
        "frogs."}));
    add_item(({"womble", "uncle bulgaria"}),({"long", "It's Uncle "
        "Bulgaria!", "pet", "You pet Uncle Bulgaria.  He growls and "
        "chews the nails off your hand.\n", "snuggle", "Uncle Bulgaria gnaws "
        "on your teeth.\n"}));    
    add_item("strange oozy things", "Ewww!");
    
    add_zone("my rooms");
    
    add_sign("This is a nice sign.\n", "Do Notte Feed Thee Blob!",
        "nice sign", "sign", "common");
    
    room_chat(({120,240,({
        "A thick blob of goo oozes over one of the frogs.",
        "The womble bings quietly.",
        "The frogs ribbit in abstract contemplation.",
    })}));    

    add_exit("east", PATH + "advanced_room_1", "road");

}        

void reset() {
    call_out("after_reset", 3);
}

void after_reset() {

    object ob = find_object
        (PATH + "simple_npc");    

    // if(!ob) will return true if ob is 0... in other words, it
    // didn't find an object with find_object().
    
    if(!ob) {
    
        // There's no object with that filename loaded, so we load it
        // and then move it into this_object()... which in the case of
        // this example, is the room we just coded.  
        
        ob=load_object(PATH + "simple_npc");
        
        // For information on how the move() function works, you 
        // can check out 'help move'.  But briefly, the first argument
        // is where the object is to be moved to... the second is the
        // message that objects in the destination get when the object
        // enters.  $N will be replaced with the short of the object.
        // 'appear$s' is a pluralisation code... it will change to 
        // 'appear' when more than one object enters at the same time,
        // and 'appears' when only one enters.
        
        ob->move(this_object(), "$N appear$s with a wet squelch.\n");
    }
    
    // if(!environment(ob)) will return true if ob returns 0 for 
    // environment... in other words, it's loaded, but located in 
    // null-space.
    
    else if(!environment(ob)) {
        ob->move(this_object(), "$N appear$s with a wet squelch.\n");
    }
        
}  // --- END [/mnt/home2/grok/lib/d/learning/newbie/introduction/examples/simple_room.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/newbie/introduction/examples/advanced_room_1.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/newbie/introduction/examples/advanced_room_1.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627699   Available: 13575053
Inodes: Total: 5242880    Free: 4960133
3553 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/newbie/introduction/examples/advanced_room_1.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627699   Available: 13575053
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*
    This is a cleverer room
    Written by Drakkos.
    
    15/10/2000
*/    
#include "path.h"
inherit "/std/outside";

void setup() {
    set_short("market square");
    set_day_long("This is a lovely market square, where people mill about "
        "doing the kind of things you would expect people to do in a lovely "
        "market square.  Brightly coloured stalls stand in the corners of "
        "the market.  They seem to do good business judging by the steady "
        "stream of consumers ducking under the flaps.\n");
    set_night_long("The darkness settles on this market square like a thick "
        "black blanket.  The stalls, undoubtedly merry and brightly coloured "
        "during the day, lie dormant and unusued.  The silence is "
        "deafening.\n");
        
    add_property("climate",({20, 20, 10}));
        
    set_light(80);
    add_zone("my rooms");
    set_linker(({PATH + "advanced_room_2", PATH + "advanced_room_3"}),
        "onto", "on", "the newbie creator marketplace");
    
    
    add_day_item(({"people", "consumers"}), "The people mill around happily, "
        "browsing the goods and talking with the stallowners.");
    add_night_item(({"people", "consumers"}), "They're all tucked up in "
        "bed.  Only crazed retrobrates like you are awake at this time of "
        "night.");
    add_day_item("stall", "The stalls are brightly coloured and really "
        "quite merry.");
    add_night_item("stall", "The stalls lie dormant in the night.  Creepy!");

    room_day_chat(({120,240,({
        "People mill around happily.",
        "The brightly coloured stalls attract the eye.",
    })}));
    
    room_night_chat(({120,240,({
        "The only sound is the chirping of the crickets.",
        "The stalls loom ominously in the darkness.",
    })}));

    add_exit("north", PATH + "advanced_room_3", "road");        
    add_exit("south", PATH + "advanced_room_2", "road");       
    add_exit("east", "/w/drakkos/workroom", "road");
    add_exit("west", PATH + "simple_room", "road");
    
    
    modify_exit("east",({"look", "You get the feeling that peeking into a "
        "creator's workroom is very rude!", "function", "test_creator"}));

}

int do_search(string str) {

    // If there is no sizeof the variable str, then it means they're not
    // searching anything in particular, 
    
    if(!sizeof(str)) {
        return -1;
    }

    // If str is equal to "shards", they're searching the right thing.  There
    // are better and more flexible ways to check if the player is searching
    // the right thing, but this is sufficient for the example.
    
    if(str == "shards") {
        tell_object(this_player(), "You search through the shards, but "
            "succeed only in cutting your hand slightly.  Ouch!\n");
        this_player()->adjust_hp(-100);
        if(this_player()->query_hp() < 0) {
            this_player()->attack_by(this_object());
        }
            
    return 1;
    }

    else {
        notify_fail("Try searching something else, perhaps?\n");
        return 0;
    }
}

string query_death_reason() {
    return "a nasty cut in the newbie creator tutorial room";
}

int test_creator(string str, object ob, string special_mess) {
    if(!ob->query_creator()) {
        notify_fail ("");
        tell_object (ob, "You are not a creator!  You may not pass!\n");
        return 0;
    }
    else {
        tell_object(ob, "You feel a tingle down your spine as you take the "
            "exit.\n");        
        return 1;
    }
}// --- END [/mnt/home2/grok/lib/d/learning/newbie/introduction/examples/advanced_room_1.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/newbie/introduction/examples/advanced_room_3.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/newbie/introduction/examples/advanced_room_3.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627698   Available: 13575052
Inodes: Total: 5242880    Free: 4960133
713 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/newbie/introduction/examples/advanced_room_3.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627698   Available: 13575052
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*
    This is a filler room!
    Written by Drakkos.
    
    15/10/2000
*/    

#include "path.h"

inherit "/std/outside";

void setup() {
    set_short("road to the market");
    add_property("determinate", "the ");
    set_day_long("This is a quiet road.  Absolutely nothing of interest is "
        "here..\n");
    set_night_long("This is a quiet road.  But at night!.\n");

    set_linker(({PATH + "advanced_room_1", PATH + "advanced_room_2"}),
        "onto", "on", "the newbie creator marketplace");
        
    set_light(80);
    add_zone("my rooms");

    add_item("road", "I *said*, there's nothing interesting at all here.");    
    
    add_exit("south", PATH + "advanced_room_1", "road");    

}
// --- END [/mnt/home2/grok/lib/d/learning/newbie/introduction/examples/advanced_room_3.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/newbie/introduction/examples/advanced_room_2.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/newbie/introduction/examples/advanced_room_2.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627698   Available: 13575052
Inodes: Total: 5242880    Free: 4960133
713 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/newbie/introduction/examples/advanced_room_2.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627698   Available: 13575052
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*
    This is a filler room!
    Written by Drakkos.
    
    15/10/2000
*/    

#include "path.h"

inherit "/std/outside";

void setup() {
    set_short("road to the market");
    add_property("determinate", "the ");
    set_day_long("This is a quiet road.  Absolutely nothing of interest is "
        "here..\n");
    set_night_long("This is a quiet road.  But at night!.\n");

    set_linker(({PATH + "advanced_room_1", PATH + "advanced_room_3"}),
        "onto", "on", "the newbie creator marketplace");
        
    set_light(80);
    add_zone("my rooms");

    add_item("road", "I *said*, there's nothing interesting at all here.");    
    
    add_exit("north", PATH + "advanced_room_1", "road");    

}
// --- END [/mnt/home2/grok/lib/d/learning/newbie/introduction/examples/advanced_room_2.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/newbie/introduction/examples/advanced_item_3.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/newbie/introduction/examples/advanced_item_3.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627697   Available: 13575051
Inodes: Total: 5242880    Free: 4960133
1806 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/newbie/introduction/examples/advanced_item_3.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627697   Available: 13575051
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*
    Ruler Of Death +2
    Wrytten by Drakkos Thee Creator
        
    21/10/2000
*/
    
inherit "/obj/weapon";
    
void setup() {
    set_name("ruler");
    set_short("wooden ruler");
    add_adjective("wooden");
    set_long("This is a thick, wooden ruler, with the inches "
        "inked out in black.\n");
    set_weight(1);
    set_value(0);
    new_weapon(5000);
    add_attack("rap", 50,({ 25, 10, 5 }), "blunt", "blunt", "do_shame");
    add_attack_message( "rap", "blunt", 
   ({
    0,({ "You rap $hcname$ smartly across the knuckles with your "
        "ruler.\n",
        "$mcname$ raps you smartly across the knuckles with $mposs$ "
            "ruler.\n",
        "$mcname$ raps $hcname$ smartly across the knuckles with "
            "$mposs$ ruler.\n"})
    }));
    set_wield_func( "test_creator", base_name( this_object() ) );     
}

int test_creator(object ob)  {

    // In case the function is called when there's no object to
    // be passed in.
    if(!ob) {
        return 1;
    }    
        
    // In case the object calling the function is a corpse attempting to
    // rehold the weapon after death.
    if(ob->query_corpse()) {
        return 1;           
    }
        
    // And now the test creator bit itself.
    if(ob->query_creator()) {
        tell_object(ob, "You have been deemed worthy, leetle creator!\n");
        return 1;
    }
    else {
        tell_object(ob, "You have been deemed unworthy, leetle player!\n");        
        return 0;
    }
}

void do_shame( int damage, object attack_ob, object attack_by, string
    type, string name ) {
        
    tell_object(attack_ob, "Your knuckles %^BOLD%^sting!%^RESET%^\n");
    tell_object(attack_by, "You feel strangely satisfied as " + 
        attack_ob->one_short() + " whimpers in pain!\n");
}// --- END [/mnt/home2/grok/lib/d/learning/newbie/introduction/examples/advanced_item_3.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/newbie/introduction/examples/simple_npc.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/newbie/introduction/examples/simple_npc.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627697   Available: 13575051
Inodes: Total: 5242880    Free: 4960133
1234 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/newbie/introduction/examples/simple_npc.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627697   Available: 13575051
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*
    This is a basic NPC!
    Written by Drakkos.
    
    26/09/2000
*/

inherit "/obj/monster";

void setup() {

  set_name("blob");    
  set_short("grey blob");
  set_long("This is a grey blob.  It is grey.  It is also quite "
      "blobby.\n");
  basic_setup("human", "warrior", 10);
  set_gender("male");
  add_adjective(({"oozing", "grey"}));
  set_main_plural("grey blobses");
  add_alias("porridge");

  add_respond_to_with(({ "@say",({"blob", "grey"}),
      }), "say Yes, I am a grey blob.");
  add_respond_to_with(({ "@say",({"ooze", "blue", "cardboard"}),
     ({"porridge", "bing", "womble"}),
      }), "' Yes, I'm oozing quite nicely, like grey "
          "blobs do.  Like porridge!");     
  add_respond_to_with(({ "@thank", ({ "you", "blob" }) }),
      "' Aw, shucks. T'weren't nuthin'.");
  add_respond_to_with(({ ({"@gnaw", "@bite", "@chew"}), ({ "you", 
    "blob" }) }),
      ({"' What did you do that for?!",  "scream", "cry", "weep"}));


  load_chat(20,({ 2, ": oozes around.",
      1, "' I'm very grey.",
      2 , "' I'm a blob.",
      2 , "@bing",
  }) );

  load_a_chat(20,({ 2, ": oozes all over you.",
      1, "' Lemme alone!.",
      2 , ": sobs bitter, slimy tears.",
  }) );
        
}

    // --- END [/mnt/home2/grok/lib/d/learning/newbie/introduction/examples/simple_npc.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/newbie/introduction/examples/advanced_item_2.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/newbie/introduction/examples/advanced_item_2.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627696   Available: 13575050
Inodes: Total: 5242880    Free: 4960133
1449 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/newbie/introduction/examples/advanced_item_2.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627696   Available: 13575050
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*
    Flourescent Flared Trousers
   (Pink!)
    Wrytten by Drakkos Thee Creator
    21/10/2000
*/

inherit "/obj/clothing";

void setup() {
    set_name("trousers");
    set_short("pair of flourescent pink flared trousers");
    add_adjective(({"pair of", "flourescent", "pink", "flared"}));
    set_long("This is a pair of extremely stylish, extremely "
    "tasteful, flourescent pink flared trousers.\n");
    set_weight(10);
    set_value(0);
    set_type("trousers");
    add_alias("flares");
    set_main_plural("pairs of flourescent pink flared trousers");
    add_plural("trousers");
    setup_clothing(10000);
    add_pocket("left", 20);
    add_pocket("right", 20);
    set_wear_remove_func(base_name(this_object()), "do_wear_stuff");
}

void do_wear_stuff(object ob) {
    if(this_player()->query_name() != "drakkos") {
        if(!ob) {
            tell_object(this_player(), "You heave a sigh of relief as "
                "you remove the ghastly garment.\n");
        }
        else {
            tell_object(this_player(), "Ye gods, are you really going "
            "to wear those hideous things?!\n");
        }
    }
    else {
        if(!ob) {
            tell_object(this_player(), "Awww, why are you taking off your "
                "super-cool slacks?\n");
        }
        else {
            tell_object(this_player(), "You feel Real Cool as you slip "
                "into your fabulous flares!\n");
        }
    }
}// --- END [/mnt/home2/grok/lib/d/learning/newbie/introduction/examples/advanced_item_2.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/newbie/introduction/examples/advanced_npc.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/newbie/introduction/examples/advanced_npc.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627696   Available: 13575050
Inodes: Total: 5242880    Free: 4960133
4382 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/newbie/introduction/examples/advanced_npc.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627696   Available: 13575050
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*
    The Laughing Gnome!
    With teefs and spells!
        
    Wrytten by Drakkos Thee Creator
    18/10/2000
*/

#include <armoury.h>

inherit "/obj/monster";

void do_bunny(object, object);
void do_maintain(object, object);
    
void setup() {
    set_name("gnome");
    set_short("laughing gnome");
    set_long("This is a little, friendly looking gnome.  Well... "
        "friendly looking aside from the vicious sharp teefs and the "
        "wicked razor-like claws.  He has laughter lines all over "
        "his face, tho', so he can't be all bad.\n");
    add_property("unique", 1);
    basic_setup("gnome", "wizard", 50);
    set_gender("male");
        
    set_int(23);
    set_str(18);
    set_wis(18);
        
    add_skill_level("magic", 100);
    add_skill_level("fighting", 50);

    load_chat(20,({ 
        1, "' Ha ha ha!.",
        1, "' He he he!.",
        2 , "' I'm the laughing gnome, and you can't catch me!",
        1 , "#charm_women",
    }) );

    load_a_chat(20,({ 
        2, ": bares his teeth.",
        1, "' I'll get my brother Fred onto you!.",
        2 , "' I'll call out the Gnome Guard!",
    }) );
    
    add_spell("bunnies", "/obj/spells/fire_bunny", "cast_spell");
    add_spell("flowers", "/obj/spells/flowers", "cast_spell");
    add_spell("shield", "/obj/spells/small_shield", "cast_spell");    

    add_combat_action(25, "bunny_them",(: do_bunny :));
    add_combat_action(25, "maintain_me",(: do_maintain :));
    
    add_attack( "claws", 88,({ 10, 8, 20 }), "sharp", "sharp", 0 );
    add_attack( "teeth", 88,({ 5, 5, 25 }), "pierce", "pierce", 0 );
    
    add_attack_message( "claws", "sharp", 
   ({
    100, 
       ({ "You slice $hcname$ with your claws.\n",
            "$mcname$ slices you with $mposs$ claws.\n",
            "$mcname$ slices $hcname$ with $mposs$ claws.\n"}),
    200,
       ({ "You rip $hcname$ apart with your claws.\n",
            "$mcname$ rips you apart with $mposs$ claws.\n",
            "$mcname$ rips $hcname$ apart with $mposs$ claws.\n"}),
    0, // The default message set.
       ({ "You scratch $hcname$ viciously with your claws.\n",
            "$mcname$ scratches you viciously with $mposs$ claws.\n",
            "$mcname$ scratches $hcname$ viciously with $mposs$ claws.\n"})
    }));      
    
    add_attack_message( "teeth", "pierce", 
   ({
    100, 
       ({ "You nibble $hcname$ with your teeth.\n",
            "$mcname$ nibbles you with $mposs$ teeth.\n",
            "$mcname$ nibbles $hcname$ with $mposs$ teeth.\n"}),
    200,
       ({ "You chew on $hcname$ with your teeth.\n",
            "$mcname$ chews on you with $mposs$ teeth.\n",
            "$mcname$ chews on $hcname$ with $mposs$ teeth.\n"}),
    0, // The default message set.
       ({ "You sink your teeth into $hcname$.\n",
            "$mcname$ sinks $mposs$ teeth into you.\n",
            "$mcname$ sinks $mposs$ teeth into $hcname$.\n"})
    }));       
        
}    


void charm_women() {        
    object player;
        
    foreach(player in all_inventory(environment(this_object()))) {
        if(interactive(player) && player->query_gender() == 2) {
            queue_command("cast flowers");
            queue_command("give flowers to " + player->query_name());
            queue_command("bow with a flourish");
            return;
        }
    }
}

void do_bunny(object attacker, object target) {
        
    object carrot,torch;
        
    if(target != this_object() ) {
        
        if(!sizeof(match_objects_for_existence("carrot", this_object()))) {
                
            carrot =ARMOURY->request_item ("carrot");
            carrot->move(this_object());
        }
            
        if(!sizeof(match_objects_for_existence("torch", this_object()))) {
            torch = ARMOURY->request_item ("torch");
            torch->move(this_object());
        }
            
        do_command("cast bunnies on " + target->query_name());
    }
}

void do_maintain(object attacker, object target) {
    
    object temp;
    
    if(!sizeof(match_objects_for_existence("shields", this_object()))) {
        temp = ARMOURY->request_item("wooden djelian shield", 100);    
        temp->move(this_object());                        
    }
                    
    do_command("cast shield on " + this_object()->query_name());
}

void adjust_hp(int number) {
    return;
}// --- END [/mnt/home2/grok/lib/d/learning/newbie/introduction/examples/advanced_npc.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/cutnpaste/kess.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/cutnpaste/kess.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627694   Available: 13575048
Inodes: Total: 5242880    Free: 4960133
9186 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/cutnpaste/kess.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627694   Available: 13575048
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:47.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: kess.c,v 1.2 2000/07/02 18:39:00 sasquatch Exp $
 *
 * $Log: kess.c,v $
 * Revision 1.2  2000/07/02 18:39:00  sasquatch
 * Fixed her up so that she can use all of her rituals, calm, paralysis, fear
 * etc.  Also gave her rage as an option in her combat options.
 * In this change, I made her hauberk a holy amulet, needed for a few rituals.
 *
 * Revision 1.1  1998/01/22 13:49:06  gerbil
 * Initial revision
 *
*/
#define CREATOR "Ceres"
/*
 * This is Kess, the Archcardinal of Pishe. Another attempt by me to
 * create an interesting female npc.
 *
 * Kess has several interesting features:
 *   She joins fights
 *   She cuts hearts from corpses and eats them
 *   She uses rituals and her yellow rod
 *   She runs off it people hit her for too much damage in one go
*/
#include <armoury.h>
inherit "/obj/monster";

object rod;

// This function is called when Kess is loaded and does all her basic setup.
void setup() {
  object chain;

  // Give her a name, short and long
  set_name("kess");
  set_short("Kess of Sek");
  set_main_plural("Kesses of Sek");
  set_long( "This is Kess, an Archcardinal of Sek.  She is a young woman, "+
           "and beautiful in a twisted kind of way.  She seems fairly "+
           "innocuous until you notice her eyes and see the vicious look in "+
           "them.\n" );
  // by setting these adjective words any of them can be used in conjunction
  // with her name to identify her.
  add_adjective(({"archcardinal", "of", "sek"}));

  // other names that can be used to identify kess
  add_alias(({"priestess", "archcardinal", "cardinal"}));

  add_property("determinate","");   // dont put a the or a in front of her name
  add_property("unique", 1);        // mark her as unique
  set_gender("female");             // shes female

  // the race, class and level must be in the following order
  set_race("human");
  set_class("priest");
  set_deity("sek");
  set_level(260);

  // height and weight are optional, but used here
  set_height(140);
  set_weight(1000);
  set_al(2000);         // shes a priestess of sek so make her very bad

  // shes a pretty special npc so lets mess with her stats
  adjust_str(2);
  adjust_con(2);
  adjust_wis(5);
  adjust_int(-6);
  adjust_dex(-3);

  // making her a level 260 priest will have given her a bunch of skills
  // but here we make a few tweaks
  add_skill_level( "faith.items.rod", 250, 0 );
  add_skill_level( "fighting.combat.melee.blunt", 200, 0 );
  add_skill_level( "fighting.combat.parry.held", 200, 0 );

  // Give her the 'kick' command
  add_known_command("kick");

  // Give her some rituals. (spell name, spell file, function to call)
  add_spell( "paralysis", "/obj/rituals/paralysis",
            "cast_spell" );
  add_spell( "fear", "/obj/rituals/fear",
            "cast_spell" );
  add_spell("cure medium wounds", "/obj/rituals/curemedium",
            "cast_spell" );
  add_spell("calm", "/obj/rituals/calm",
            "cast_spell" );   
  add_spell( "rage", "/obj/rituals/rage",
            "cast_spell" );                 

  // This makes kess join in fights which are going on in the room shes in
  set_join_fights( "Blood-lust glows in Kess' eyes as she dives "+
                   "into the melee.\n" );
  set_join_fight_type(1);

  // Now give her some equipment
  chain = ARMOURY->request_armour("chainmail", 100);
  chain->add_ac("magic", "magic", 60);
  chain->add_ac("fire", "fire" , 60);
  chain->add_ac("cold", "cold", 60);
  chain->move(this_object());
  chain->add_property("holy amulet", "sek");
  chain->add_property("sek", 1);

  ARMOURY->request_armour("blood red cloak", 100)->move(this_object());
  ARMOURY->request_armour("rope belt", 100)->move(this_object());
  ARMOURY->request_armour("soft leather shoes", 100)->move(this_object());

  // This creates a cleric rod. Calling whichone(6) makes it a yellow rod
  rod = ARMOURY->request_weapon( "cleric rod", 100 );
  rod->whichone(6);           // make the rod a yellow one
  rod->set_enchant(8);        // give it a little enchantment (radiance)
  rod->move(this_object());   // move it to kess

  // her holy symbol which she needs for her rituals
  clone_object("/obj/faith/sek_symbol.arm")->move(this_object());

  init_equip();   // make her hold and wear her equipment

  // request a dagger from the armoury and give it to her all in one go.
  // the second parameter in request_weapon is it's condition (100%)
  ((object)ARMOURY->request_weapon("dagger", 100))->move(this_object());

  // setup her combat tactics
  do_command("tactics response parry");
  do_command("tactics parry both");
  do_command("tactics attitude offensive");

  // normal chats
  load_chat(20, ({2, ":smiles viciously.",
                  1, "@glare $lname$",
                  1, "@smirk",
                }));

  // chats given while in combat
  load_a_chat(20, ({1, "'Do you know who I am?",
                    1, "'Die unbeliever!",
                    1, "'You fight me, Sek will rip your heart out!"}) );

  set_virtual_move(1);           // allow her to move virtually
  set_move_after(30, 120);       // move after 30+random(120) seconds
  add_move_zone("Ankh-Morpork"); // move around AM 
  add_move_zone("sek");          // and the temple of sek

  // this calls the function get_heart() whenever she enters a room
  // see later for more details
  add_enter_commands("#get_heart");

  // Combat actions are called during combat by the combat system.  It is an
  // easy way to have an npc react suitably or do things while fighting.
  // The format is: likelihood, name, action.
  // You'll find maintain_self, fighting_stuff and reequip are functions
  // further down.
  add_combat_action(100, "maintenance", ({ "maintain_self" }) );
  add_combat_action(70, "fighting_stuff", ({ "fighting_stuff" }) );
  add_combat_action(50, "reequip", ({ "reequip" }));
}

// The following functions are combat actions

// if kess isn't holding her rod, then get the rod and hold it.
void reequip(object thing1, object thing2) {
  if(this_object()->query_holding()[0] != rod) {
    do_command( "get yellow rod" );
    do_command( "hold yellow rod" );
  }
}

// Perform a variety of actions to make her combat more interesting
void fighting_stuff(object thing1, object thing2) {
  if(thing2 != this_object())
    return;

  // don't do something every round.
  switch(random(6)) {
  case 5:
    do_command("cast rage on "+thing1->query_name());
    break;       
  case 4:
    do_command("cast fear on "+thing1->query_name());
    break;
  case 3:
    do_command("cast paralysis on "+thing1->query_name());
    break;
  case 2:
    do_command("use rod to cast dustdevil");
    break;
  case 1:
    do_command("use rod to cast barrier");
    break;
  default:
    do_command("concentrate on "+thing1->query_name());
    do_command("kick "+thing1->query_name());
    break;
  }
}

// healing actions 
void maintain_self( object thing1, object thing2 ) {
   if ( thing2 != this_object() )
      return;

   // we increase her guild points if they need it. Otherwise she'll
   // just runout.
   if ( query_gp() < 200 )
      adjust_gp( 200 );

   // the following commands are performed when she reaches a percentage
   // of her maximum hit points
   if ( query_hp() < query_max_hp() / 4 )
     do_command( "use rod to cast sanctuary" );
   
   if ( query_hp() < query_max_hp() / 2 )
     do_command( "cast calm on "+thing1->query_name());

   if ( query_hp() < query_max_hp() )
     do_command( "cast cure medium wounds on kess" );

   
}

// This function is called when someone or something dies in the room.
void event_death(object thing) {
  if(thing != this_object()) {      // it it wasn't us who died
    call_out("get_heart", 3);       // call the get_heart function in 3 seconds
  }
}

// This function is called either when someone dies (see above) or when
// kess enters a room (see the setup function)
void get_heart() {
  object corpse;

  // search the room we're in for objects which respond to the name
  // 'corpse' if we find one then do the commands listed
  if(find_match("corpse", environment()) != ({})) {
    do_command("hold dagger");
    do_command("get heart from corpse");
    do_command("eat heart");
    do_command("hold rod");
  }
}

// Every npc has an adjust_hp() function. It is what is used to reduce
// and replace an npcs hit points. We are 'overloading' it here. Because
// we define adjust_hp() this is the one that will get called.
int adjust_hp(int hp, object attacker) {
  // first call adjust_hp() in our parent object since we still want the
  // normal adjust_hp() things to happen.
  ::adjust_hp(hp, attacker);

  // If we took more than 300 hits in a single go then...
  if(hp < -300) {
    // init_command() makes the command be performed in about 2 seconds
    init_command("cast cure medium wounds on kess");
    // we might also choose to run away. we have to do it as a callout
    // otherwise kess will runoff in the middle of an ambush.
    if(!random(3))
      call_out("eek", 0);
  }
}

// Lose everyone, then run away. run_away() is a standard npc function.
void eek() {
  do_command("lose all");
  run_away();
}
// --- END [/mnt/home2/grok/lib/d/learning/cutnpaste/kess.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/cutnpaste/althea.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/cutnpaste/althea.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627692   Available: 13575046
Inodes: Total: 5242880    Free: 4960133
9921 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/cutnpaste/althea.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627692   Available: 13575046
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:47.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*
 * $Locker:  $
 * $Id: althea.c,v 1.8 2000/10/27 02:13:48 twiggy Exp $
 *
 * $Log: althea.c,v $
 * Revision 1.8  2000/10/27 02:13:48  twiggy
 * Adjusted her to use queue_command instead of do_command when she drops or fumbles her flail, to make her a little more realistic.
 *
 * Revision 1.7  2000/10/17 05:57:39  taffyd
 * Whatever changes Taffyd made in 1999.
 *
 * Revision 1.6  1999/07/13 05:42:56  furcifer
 * fixed typo.
 *
 * Revision 1.5  1999/05/16 17:47:26  taffyd
 * Fixes!
 *
 * Revision 1.1  1998/02/08 08:44:56  terano
 * Initial revision
 *
*/
#define CREATOR "Ceres"
/*
 * This is Althea, the Archcardinal of Pishe. Another attempt by me to
 * create an interesting female npc.
*/
#include <armoury.h>
inherit "/obj/monster";

#define HEAL_COST 30
object flail;
int dickens_warned;

void do_heal(object);
void check_injured();
void maintain_self(object, object);
void fighting_stuff(object, object);
void ritual_stuff(object, object);

void setup() {
    set_name("althea");
    set_short("Althea of Pishe");
    set_main_plural("Altheas of Pishe");
    set_long("This is Althea, an Archcardinal of Pishe.  She is a beautiful, "
      "middle-aged woman with a kind face.  She almost seems to glow "
      "with a gentle power.\n");
    add_adjective(({"arch", "cardinal", "of", "pishe"}));
    add_alias(({"priestess", "archcardinal", "cardinal"}));
    add_property("determinate","");
    add_property("unique", 1);
    set_gender("female");
    set_race("human");
    set_guild("priest");
    set_deity("pishe");
    set_level(400);

    set_height(140);
    set_weight(1000);
    set_al(-2000 - random(501)); /* Max alignment is -2500 */
    set_con(15);
    set_dex(13);
    set_int(12);
    set_str(15);
    set_wis(20);

    add_skill_level("fighting", 300, 0);
    add_skill_level("fighting.combat.melee.blunt", 150, 0);
    add_skill_level("faith", 200);
    add_skill_level("faith.rituals.misc.area", 300);

    add_skill_level("other.perception", 400, 0);
    add_skill_level("other.health", 200, 0);
    add_known_command("strike");
    add_known_command("crush");

    add_spell("cure light wounds", "/obj/rituals/curelight", "cast_spell");
    add_spell("cure serious wounds", "/obj/rituals/cureserious", "cast_spell");
    add_spell("cure critical wounds", "/obj/rituals/curecritical", "cast_spell");
    add_spell("minor shield", "/obj/rituals/minorshield", "cast_spell");
    add_spell("dust devil", "/obj/rituals/dustdevil", "cast_spell");

    add_combat_action(100, "maintenance", (: maintain_self :)) ;
    add_combat_action(70, "fighting_stuff", (: fighting_stuff :));
    add_combat_action(50, "ritual_stuff", (: ritual_stuff :));

    ARMOURY->request_item("white cotton tunic", 100)->move(this_object());
    ARMOURY->request_item("rope belt", 100)->move(this_object());
    ARMOURY->request_item("soft leather shoes", 100)->move(this_object());
    clone_object("/obj/faith/pishe_symbol.ob")->move(this_object());

    do_command("tactics response parry");
    do_command("tactics attitude defensive");

    load_chat(20, ({ 2, ":smiles kindly.",
        1, "'May the countenance of Pishe rain upon you.",
        2, ":smiles serenely." }));

    load_a_chat(20, ({ 1, "'Do you know who I am?",
        1, "'May the power of Pishe strike you down.",
        1, "'Die unbeliever!",
        1, "'You fight me, you fight Pishe herself",
        1, "'Pishe! Aid your loyal servant!" }));

    set_virtual_move(1);
    set_move_after(30, 120);
    add_move_zone("Ankh-Morpork");
    add_move_zone("Temple");
    set_wimpy(10);

    add_respond_to_with(({ "@say",
        ({ ({ "heal", "healing" }), "please" }) }), (: do_heal :));
    add_respond_to_with(({ "@say",
        ({ "please", "heal", "me" }) }), (: do_heal :));

    add_respond_to_with(({ "@smile", "althea" }), "smile $hname$");
    add_respond_to_with(({ ({ "@bow", "@curtsey" }), "althea" }),
      "curtsey $hname$");

    add_enter_commands((: check_injured :));


    flail = ARMOURY->request_item("cleric rod", 100);
    flail->set_enchant(flail->query_max_enchant() / 2);
    flail->whichone(7);
    flail->move(this_object());
    call_out((: init_equip :), 2);

    move("/d/guilds/priests/Ankh-Morpork/small-gods/old/PriestGardenStatue", "$N walk$s into the "
      "room, smiling serenely.");
} /* setup() */

// A couple of things Althea does during fights just to spice her up a bit

void maintain_self(object thing1, object thing2) {
    if (thing2 != this_object())
        return;

    /* Try and pick up our flail if we've been disarmed. */
    if (member_array(flail, query_holding()) == -1) {
        queue_command("get flail");
        queue_command("hold flail");
    }

    /* Althea always has enough guild points to cast her healing and
       defensive rituals */

    if (query_gp() < 200)
        adjust_gp(200);

    if (query_hp() < query_max_hp() / 2) {
        do_command("cast cure serious wounds on althea");
    }

/*
    if (query_hp() < query_max_hp() / 4) {
        do_command("use flail to cast sanctuary");
    } */

    if(query_hp() < query_max_hp() - 1000) {
        do_command("cast dust devil on althea");
    }

    if (query_hp() < query_max_hp() - 500) {
        do_command("cast minor shield on althea");
    }

    if (query_hp() < query_max_hp() - 250) {
        do_command("cast cure light wounds on althea");
    } 
} /* maintain_self() */

void fighting_stuff(object thing1, object thing2) {
    if (thing2 != this_object())
        return;

    if ( random( 10 ) )
        return;
   do_command("concentrate " + thing1->query_name());
    do_command("tactics attitude offensive" );
    do_command("crush "+ thing1->query_name() + " with flail");
}

void ritual_stuff(object thing1, object thing2) {
    if (thing2 != this_object())
        return;

    switch (random(6)) {
    case 0..1:
        do_command( "cast minor shield on althea" );
        break;
/*    case 2 :
        do_command( "use flail to cast barrier" );
        break; */

    case 2 .. 4 :
        do_command("cast dust devil on althea");
        do_command("cast dust devil on althea");
        do_command("cast dust devil on althea");
        break;

    case 5 :
        do_command("use flail to cast fear on " + thing1->query_name());
        break;

    }
    do_command("tactics attitude defensive");
} /* ritual_stuff() */

void do_heal(object victim) {
    if (member_array(victim, query_attacker_list()) != -1) {
        do_command("say I'm not going to heal you!");
        return;
    }

    if (victim->query_hp() > (victim->query_max_hp() / 2)) {
        do_command("say You don't need healing from me, " + 
          victim->short()+".");
        return;
    }

    if (victim->query_gp() < HEAL_COST) {
        do_command("say Sorry you're not strong enough for me to "
          "heal at the moment.\n");
        return;
    }

    if (victim->query_guild_ob() == "/std/guilds/wizard") {
        do_command("say I thought wizards didn't believe in gods?");
        do_command("smirk");
        return;
    }

    if (victim->query_al() > random(300)) {
        do_command("say You are far too wicked for Pishe's healing.");
        return;
    }

    do_command("say May the power of Pishe heal you.");
    tell_room(environment(), "Althea places her hands upon " +
      victim->the_short() + " and starts to pray softly.\n");

    tell_room(environment(), "As she does so her hands start to glow with a "
      "gentle silver light.\nThe light gradually intensifies until "
      "everything is bathed in it.\n");

    tell_object(victim, "As Althea prays you feel warmth spreading from her "
      "hands throughout your body.\n");
    tell_room(environment(), "Gradually the light fades.\n");
    tell_object(victim, "You feel much better.\n");
    tell_room(environment(), victim->the_short()+" looks much better.\n",
      victim);
    victim->set_hp(victim->query_max_hp());
    victim->adjust_gp(-HEAL_COST);
} /* do_heal() */


void check_injured() {
    object *people, person;

    people = filter(all_inventory(environment()), (: living($1) &&
        ($1->query_hp() < ($1->query_max_hp() / 2)) &&
        $1->query_al() < -300 :));

    people -= ({ this_object() });

    if (!sizeof(people))
        return;

    person = people[random(sizeof(people))];    

    do_command("say Oh my, " + person->short()+ " you don't look so good.");
    do_command("say Allow me to heal you.");
    call_out((: do_heal($1) :), 1, person);
} /* check_injured() */

void event_fight_in_progress(object attacker, object victim) {

    if ( attacker != this_object() && victim->query_name() == "dickens" ) {
        if ( !dickens_warned ) {
            do_command( "say Fear not, Dickens, Pishe"
                " shall protect you!" );
            dickens_warned = 1;
            do_command( "protect dickens" );
            attack_ob( attacker );
        }
    }

    ::event_fight_in_progress( attacker, victim );
} /* event_fight_in_progress() */
     
int adjust_hp(int hp, object attacker) {
    int result;

    result = ::adjust_hp(hp, attacker);

    if(hp < -1500)
        call_out("eek", 0);

    return result;
} /* adjust_hp() */

void eek() {
    init_command("use flail to cast sanctuary", 1);
    init_command("cast cure critical wounds on althea", 2);
    run_away();
} /* eek() */

void check_fumble( object ob ) {
    if ( environment( ob ) == environment() ) {
        do_command( "say Whoops, I must have dropped my precious flail!" );
        do_command( "get " + file_name( ob ) );
        do_command( "hold " + file_name( ob ) );
    }
} /* check_fumble() */
        
void event_enter( object ob, string mess, object from ) {
    ::event_enter( ob, mess, from );

    if ( environment( ob ) == environment() && 
        ob->id( "flail" ) && ob->query_cloned_by() == "althea" ) {
        call_out( (: check_fumble :), 1, ob );
    }
}  /* event_enter() */
// --- END [/mnt/home2/grok/lib/d/learning/cutnpaste/althea.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/items/matcher.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/items/matcher.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627689   Available: 13575043
Inodes: Total: 5242880    Free: 4960133
2943 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/items/matcher.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627689   Available: 13575043
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/object";

#define CMD 0
#define PAT 1


void add_cmds( object player );
int do_add( string command, string pattern );
int do_remove( int i );
int do_match( object *indirect_obs, string dir_match, 
    string *indirect_match, mixed args, string pattern );
string read_msg();

string *cmds = ({});

void setup() {
  set_name( "matcher" );
  set_short( "Tannah's pattern matcher" );
  add_property( "determinate", "" );
  add_alias( "pattern matcher" );
  set_long(
    "This is a very handy wossname, useful for testing patterns you "
    "might like to use in an add_command.\n"
  );
  add_adjective( ({ "handy", "patterned" }) );
  set_weight( 1 );
  set_value( 0 );
  add_property( "no recycling", 1 );
}

void init() {
  add_cmds( this_player() );
}

void add_cmds( object player ) {
  set_read_mess( (: read_msg :) );
  player->add_command( "add", this_object(), "command <word'command'> "
      "with pattern <string:quoted'pattern'>",
      (: do_add( $4[0], $4[1] ) :) );
  player->add_command( "remove", this_object(), "command <number>", 
      (: do_remove( $4[0] ) :) );

  if( sizeof( cmds ) ) {
    for( int i = 0; i < sizeof( cmds ); i++ )
      player->add_command( cmds[i][CMD], this_object(), cmds[i][PAT], 
          (: do_match :) );
  }
}

int do_add( string command, string pattern ) {
  cmds += ({ ({ command, pattern }) });
  this_player()->remove_object( this_object(), 1 );
  add_cmds( this_player() );
  printf( "You add the command \"%s\" with the pattern \"%s\" to the "
      "pattern matcher.\n", command, pattern );
  return 1;
}

int do_remove( int i ) {
  if( i >= sizeof( cmds ) || i < 0 ) {
    printf( "Invalid command number.\n" );
    return 0;
  }
  printf( "You remove the command \"%s\" with the pattern \"%s\" from "
      "the pattern matcher.\n", cmds[i][CMD], cmds[i][PAT] );
  cmds = cmds[0..i-1] + cmds[i+1..];
  this_player()->remove_object( this_object(), 1 );
  add_cmds( this_player() );
  return 1;
}  

int do_match( object *indirect_obs, string dir_match, 
    string *indirect_match, mixed args, string pattern ) {
  printf( "Indirect objects: %O\n", indirect_obs );
  printf( "Direct match: %s\n", dir_match );
  printf( "Indirect match: %O\n", indirect_match );
  printf( "Args: %O\n", args );
  printf( "Pattern: \"%s\"\n", pattern );
  return 1;
}

string read_msg() {
  int i;
  string msg;

  msg = "The pattern matcher is currently set to test the following "
        "commands and patterns:\n";
  if( !sizeof( cmds ) ) msg += "  None.\n";
  else for( i = 0; i < sizeof( cmds ); i++ ) {
    msg += sprintf( "[%d] \"%s\", \"%s\"\n", i, cmds[i][CMD], 
           cmds[i][PAT] );
  }
  msg += "See 'syntax add' and 'syntax remove' to modify the list.";
  return msg;
  msg += "For further [nearly accurate] information on add_command, "
    "see the files in /w/tannah/learning/add_cmd.\n";
}

void list_cmds() {
  printf( "Commands and patterns added:\n%O\n", cmds );
}
// --- END [/mnt/home2/grok/lib/d/learning/items/matcher.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/chars/terrain_teacher.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/chars/terrain_teacher.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627687   Available: 13575041
Inodes: Total: 5242880    Free: 4960133
35723 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/chars/terrain_teacher.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627687   Available: 13575041
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* -*- LPC -*- */
#include <armoury.h>

#include "path.h"

inherit "/obj/monster";

#define TERRAIN_CONTROL "/d/admin/room/terrain"
#define PROPERTY "terrain lesson stage"
#define CROSS_IMPATIENCE 100
#define TAPS_IMPATIENCE 200
#define MAX_IMPATIENCE 300
#define COSTUME_NORMAL 0
#define COSTUME_DESERT 1
#define COSTUME_WET 2
#define COSTUME_COLD 3

int costume_normal();
int costume_desert();
int costume_wet();
int costume_cold();
protected void to_terrain();
protected void from_terrain(string to);

object hq;
object pupil;
int impatience;
int costume;
int lesson_step;
int speeching;

mixed *lessons =
({
   /* For each lesson, we give:
    * string for exit name from foyer
    * integer for costume
    * array of commands for lesson text.  These commands can be strings
    *    which will be fed to init_command(), function pointers which will
    *    be fed to call_out(), or 0 (which makes the teacher pause).
    * string for exit name back to foyer
    */
   /* Lesson #0: floating vs. fixed rooms, the set_terrain() function */
   ({ "grassyfield", COSTUME_NORMAL,
      ({
         "emote sniffs the air.",
         "smile",
         "'This is a very simple terrain.  Take a little time to look around "
            "at it, wander around, read some of the code.  There isn't a whole "
            "lot to it.  When you feel you know what's here, come back and tell "
            "me you're ready.  I'll wait until you say \"ok\" or "
            "\"ready\" where I can hear you.  If you accidentally wander back to "
            "the foyer, type 'grassyfield' to return here.",
         0,
         "'You should have noticed that there are two different rooms in this "
            "area: the room in which we stand now, with this quaint cottage "
            "behind me, and the rooms of the field.",
         "'All the rooms are very simple.  You should have read the code for "
            "them.  If you haven't, do it now.  I'll wait until you're ready.",
         0,
         "'I assume that you have written rooms, both indoors and outdoors, "
            "before.  You should have noticed two strange features to the files "
            "that make up this area: first that they both have a call to a "
            "function called set_terrain(), and second that they both are "
            "remarkably lacking in add_exit() calls!",
         "'In fact, excepting this one 'cottage' exit behind me, the files "
            "have no exits at all.  Nevertheless, you were able to walk around "
            "quite freely.",
         "'That is the primary purpose to the terrain handler: it manages your "
            "exits for you.",
         "'The call to set_terrain(), then is simply the means by which you "
            "can tell the terrain handler that it needs to manage this room.",
         0,
         "'There are two types of rooms that the terrain handler can manage: "
            "fixed rooms and floating rooms.  The code for both looks the same, "
            "but the terrain handler treats them very differently.",
         "'In order for the terrain handler to know how to handle each room, "
            "you have to tell it.  That's done in the terrain handler control "
            "room: /d/admin/room/terrain.  You can get there from the commonroom "
            "by walking one east then one southeast.  Personally, I prefer to "
            "use an alias.",
         "'We'll go to the terrain control room in a moment, so you can see "
            "how to use it.  For the moment, suffice to say that every room "
            "that has a call to set_terrain() also needs to be registered in "
            "the terrain control room.",
         0,
         "'In this terrain, we have the doorstep (a fixed room) and all the "
            "rooms of the field (floating).  The primary difference between "
            "floating and fixed rooms is that you can only have one of each "
            "fixed room in a terrain, but you can have any number of floating "
            "rooms.",
         "'In fact, you probably noticed that this area is a 3x3 grid.  We're "
            "in the center of the southern edge of that grid right now, at the "
            "doorstep.",
         "'When I created this terrain, I just said that the field should "
            "cover the entire 3x3 area.  Then I plopped the fixed room down here, "
            "and it automatically took the place of the field room that would "
            "have been here.",
         "'This is an important concept: floating rooms cover predefined "
            "regions, while fixed rooms are in one place.  When a particular "
            "location is in the region of a floating room _and_ is the location "
            "of a fixed room, the fixed room wins.",
         "'This makes it so you can define huge sweeping areas of the floating "
            "rooms, and just plop down your fixed rooms in strategic areas.",
         0,
         "'Now, when I say 'location', what I'm referring to is the coordinates "
            "of the room.  As a creator, you can look at a room, and the "
            "coordinates (or \"unset\") appear just before the description.  "
            "As you work on terrains, you'll find yourself looking at those "
            "coordinates a lot.",
         "'Walk around a bit, and see how the coordinates change as you move "
            "in the different directions.  You will see the first number "
            "increase when you walk north, and decrease when you walk south.  "
            "The second increases when you walk east, and the third increases "
            "whenever you go up.",
         "'So that's ( north, east, up ).",
         0,
         "'Ok, let's show you the terrain control room now.",
         (: this_object()->to_terrain() :),
         "'Ok, here we are in the terrain control room.",
         "'Feel free to look at the room here before I explain everything "
            "to you.  Well, not quite everything: that green box is an advanced "
            "device for a later lesson.",
         0,
         "'The first thing you need to do before using the terrain room is "
            "always, always, always, set the terrain name.  Do that with the "
            "\"terrain\" command.",
         "'Type \"terrain tutorial_grassy_field\".  Be very careful about "
            "the spelling, you have to get it exactly right.",
         "'If you're worried, just type \"terrain\" and the room will "
            "show you the current terrain",
         0,
         "'Now that you've set the terrain, you can list the rooms that I "
            "have set here.  Use \"list floating\" to see all the floating "
            "rooms, and \"list fixed\" to see all the fixed rooms.",
         "'As I've mentioned before, this terrain only has one fixed and "
            "one floating room.",
         0,
         "'When it lists the floating room, it tells you the name of the "
            "file, the coordinates of two opposite corners of the region, and "
            "one final number.  That last number is a priority.  We'll talk "
            "about that in the second lesson.  For now, ignore it.",
         "'In this terrain, we have the field room in the whole area where "
            "the first coordinate is between -100 and 100 (inclusive), the "
            "second coordinate is between -100 and 100 (inclusive), and "
            "the third coordinate is equal to 800000.",
         "'The only reason for that strange third coordinate was that I wanted "
            "to keep these rooms far away from the player areas.",
         "shrug",
         "'That number before the file name is just an index in the list of "
            "floating rooms.  Since we only have one floating room, it isn't "
            "very useful to us.",
         0,
         "'Both of our rooms inherit /std/room/outside.  That makes the rooms 100 "
            "units wide in each direction.  So in that range of coordinates, we "
            "can have 3 rooms: -100, 0, and 100 for each of the first two "
            "coordinates.  So the whole terrain is a 3x3 block.",
         0,
         "'Now looking at the fixed room, it gives you the name of the file "
            "and _one_ set of coordinates.  That's it.  There's only the one set "
            "of coordinates, because each fixed room can only be in one location.",
         "'If you try to add another fixed room with the same file, the "
            "terrain control room will gripe at you and refuse to do it.  You'll "
            "have to remove the old room first.  You do that with the \"remove\" "
            "command, but we'll get to that later.",
         0,
         "'Notice that the fixed room is at (-100, 0, 800000).  That is inside "
            "the range of coordinates that we have set for the floating rooms: "
            "the first and second coordinates are between -100 and 100, and the "
            "last coordinate is 800000.  But this is a fixed room, so it wins the "
            "fight for that location.",
         "'This is what I was talking about earlier, when I mentioned putting "
            "the doorstep in the middle of the southern edge of the square: -100 "
            "is the southernmost edge of the square, while 0 is in the middle of "
            "that edge.",
         0,
         (: this_object()->from_terrain(TERRAIN_TUTORIAL "grassystep") :),
         "'And here we are back at the field.",
         "'That's it for the basic terrain lesson.  Wander around a bit more "
            "to look at the things I have mentioned, and come back here when "
            "you're ready to finish this lesson up.",
         "'There are more lessons available to you, so if you're up to it, "
            "talk to me when we get back to the foyer, and I'll continue to teach "
            "you.",
         "smile",
         "'You've been an excellent pupil.",
         0,
         "'Good",
      }),
      "cottage"
   }),
   /* Lesson #1: Multiple levels of floating rooms.   The 'nothing' room */
   ({ "desert", COSTUME_DESERT,
      ({
         "stretch",
         "emote starts to sweat",
         "'Ah, the desert!",
         "'As in the field, take a moment to wander around here.  Use what you "
            "learned in the first lesson, and look a bit more closely at the rooms "
            "in this area.",
         0,
         "'You should have noticed that there are three different areas in this "
            "terrain: this spot here next to the tent, the desert, and an oasis.  "
            "If you didn't notice, look at it now.",
         0,
         "'Once again, we have a largely square area, this time 6 squares east "
            "and west, and 5 squares north and south.  As you might have guessed, "
            "I created this area by covering the whole square with the desert "
            "room, and then plopped down this room in the corner.  But the oasis "
            "squares are interesting.  Let's go to the terrain control room and "
            "see.",
         (: this_object()->to_terrain() :),
         0,
         "'Ok, set the terrain to \"tutorial_desert\".  If you've forgotten, "
            "that's \"terrain tutorial_desert\".",
         "'When you've done that, list the floating rooms to see some nifty "
            "stuff.",
         0,
         "'Notice how I've got two rooms here: sanddunes and sandoasis.",
         "'Look carefully at the coordinates for the rooms, and you'll see that "
            "the sandoasis rooms overlap the sanddunes rooms.\n",
         "'The important difference is that last number.  Sanddunes says that "
            "it is \"level 0\", while sandoasis says it is \"level 1\".",
         "'The level is a kind of priority: when two or more floating rooms are "
            "at the same coordinates, the one with the highest level wins, and "
            "will be the room that the terrain handler actually puts down.",
         "'So in this terrain, the far northwest corner (that's at "
            "200, 1000, 800000) is in both the sanddunes and the sandoasis "
            "areas.  But since sandoasis has a higher level, that location "
            "is an oasis.",
         0,
         "'This little wrinkle lets you overlay lots of different rooms, "
            "stacking them up, to get very complex shapes without having to "
            "plop down rooms one by one.",
         "'For example, suppose one room covers (-200, -200, 0) to "
            "(200, 200, 0), at level 0.  Then we put a second room from "
            "(-100, -100, 0) to (100, 100, 0) at level 1.  The first room "
            "makes a 5 by 5 ring around the second area, which is 3 by 3.",
         "'We can make that more complex by putting more of the first "
            "room down, from (0, 0, 0) to (0, 100, 0) at level 2.  Now the "
            "center area, instead of being a 3 by 3 square, is a kind of "
            "'C' shape.  It might be helpful to draw that out on a piece "
            "of graph paper, so you can see it better.",
         0,
         "'Using these levels, you can even make it so that a terrain has "
            "holes in it.  That's convenient when you want to force people "
            "to walk around something.  Just add a floating room with a high "
            "level, and use the special file name \"nothing\".",
         0,
         "'Well, that's it for this lesson.",
         (: this_object()->from_terrain(TERRAIN_TUTORIAL "sandtent") :),
         "'Come back again, and we'll talk about some of the pitfalls "
            "involved in designing terrains.",
         0,
      }),
      "tent"
   }),
   /* Lesson #2: Making sure the coordinates line up.  set_room_size() */
   ({ "mountaintop", COSTUME_COLD,
      ({ "rub hands",
         "shiver",
         "'Sorry about the cold, I never got around to putting a door on "
            "this cabin.",
         "frown",
         "shrug",
         "'Oh well.",
         "'This time, I don't want you to wander freely around the terrain: "
            "it's much more complex than the others you've explored, and I want "
            "to do this one one step at a time.",
         0,
         "'This room right here is a fixed room.  We have one more fixed room "
            "upstairs, and both are connected by the staircase behind me.  That "
            "exit was added automatically by the terrain handler, just as in "
            "the case of floating rooms, but here we have two fixed rooms whose "
            "exits are being managed.",
         "'We'll go to the terrain control room in a moment, but first I want "
            "to show you a few things.",
         "'Look at the coordinates for this room.  If you didn't see the "
            "coordinates when you came in to this room, 'look' now.",
         0,
         "up",
         "'Now compare the coordinates of this room to the room we were just "
            "in.",
         0,
         "'Previously, whenever you moved from one room to another, the "
            "coordinates changed by 100.  This time, they only changed by 20.",
         "'Previously, all our rooms were 100 units across.  These two "
            "rooms, however, are only 20.  That's because our previous rooms "
            "all inherited /std/room/outside, while these two cabin rooms inherit "
            "/std/room/basic_room.  The code assumes that indoor rooms tend to be smaller "
            "than the great outdoors.",
         "'One side effect of that is that you have to be careful when "
            "lining up rooms in the terrain control room.  Be sure to check "
            "that the positions you give your rooms line up right, so the "
            "terrain handler can generate the correct exits.",
         "'In this case, I had to make sure that I planted this attic "
            "exactly 20 units above the other room.",
         0,
         "'This gets a little bit hairy when you have an indoor room "
            "meeting an outdoor room.  Let's look at that now.",
         "down",
         "'Here's an indoor room",
         0,
         "west",
         "lsay And here's an outdoor room",
         0,
         "lsay This time the coordinates changed by 60.",
         "lsay \"60?!  Where'd 60 come from?\" I bet you ask?",
         "lsay I've already said that outside rooms are 100 units across, and "
            "indoor rooms are 20 units across.  So from the center of an outside "
            "room, the walls are all 50 units from you.  From the center of an "
            "indoor room, the walls are 10 units from you.  Normally, when you go "
            "from the center of one outdoor room to another, that's 50 units in "
            "the first room, and another 50 units in the destination room: 100 "
            "units total",
         "lsay Likewise, in an indoor room, you go 10 units in the first room, "
            "and another 10 units in the second room: 20 units total.",
         "lsay So the 60 units we just moved is 10 units in the indoor room "
            "where we started, plus another 50 units in the outdoor room where "
            "we ended up.",
         "lsay Of course, I had to take that into account in the terrain "
            "control room when I lined up these rooms.",
         0,
         "lsay Now, there's one more thing that I want to show you before "
           "we go to the terrain room.",
         "sw",
         "s",
         "lsay Here's a tree that I planted a few years ago.  We can climb "
            "it.",
         "up",
         0,
         "lsay Did you notice the change in coordinates this time?  70.",
         0,
         "lsay Now this tree that we're hanging from is an outdoor room, as "
            "you can tell by all the weather we're having.  However, it's not "
            "the usual size.",
         "lsay Do 'find -d setup() here', to read the setup function for this "
            "room.  Notice how I have a call to set_room_size() just before "
            "the call to set_terrain().  That set_room_size() controls how far "
            "the walls are from the center of the room.  So this room is twice "
            "that width: 40 units across and 40 units tall.",
         "lsay That should account for the coordinates changing by 70 when "
            "we climbed the tree: 50 as we left the lower room, and 20 coming in "
            "to this room.",
         0,
         "lsay You can change the size of any room you want this way, but "
            "make absolutely sure that you call set_room_size() _before_ "
            "you call set_terrain().  That is critically important, and all "
            "sorts of subtle bugs can happen, generally involving the wrong "
            "exits showing up, if you get that wrong.",
         "lsay Also, set_room_size() can take an array of 3 coordinates to "
            "control the size of the room separately in all three dimensions.",
         "lsay Unfortunately, the terrain handler doesn't understand that "
            "level of complexity, so don't ever do it with rooms you expect to "
            "have managed by the terrain handler.",
         0,
         "lsay ok, let's go to the terrain control room, and you can look "
            "at my work.",
         (: this_object()->to_terrain() :),
         "lsay Here we...",
         "blush",
         "' Heh.  Got so used to yelling over the wind...",
         "smile",
         "'Here we are in the terrain room.  Set the terrain to "
            "tutorial_mountain and list out the fixed rooms.",
         0,
         "'Notice the last coordinates on both.  That's what I mentioned "
            "before, that I had set the two 20 units apart.",
         "'Now list the floating rooms.",
         0,
         "'Here I've done something different.  The mountainsnows room "
            "makes a big square, 5 by 5.  In the very center of that square, "
            "there is a 'nothing' room.  You should remember from the last "
            "lesson, that when the filename of a floating room is 'nothing', "
            "the terrain handler puts no room at that location.  So here we "
            "have the floating terrain with a hole in the middle.",
         "'Inside that hole, I plopped down the cabin.  How it's not "
            "centered in that hole, it's actually to the west of the center.",
         "'That's because I needed to ensure that, with the differente "
            "sizes of the outside vs. inside rooms, things would still line up.",
         "'So when you walk out of the cabin, you walk west.  When you walk "
            "around it, the terrain handler doesn't give you any extra entrances "
            "to the cabin.",
         0,
         "'There's one extra thing I had to do to get the cabin to work right, "
            "and I'll show you that soon, but first notice the mountaintree "
            "rooms.  There shouldn't be any suprises with that, just remember "
            "that the tree rooms are a different size.",
         0,
         "'Ok, back to the cabin.",
         (: this_object()->from_terrain(TERRAIN_TUTORIAL "mountaincabin") :),
         "'Here we are, back in the ground floor of the mountain cabin.",
         "'Notice how we have 3 exits here: up, down, and west.  Obviously, "
            "there's no north, east, or south exits, because we have that "
            "'nothing' room right here.",
         "lsay Wrong!",
         "grin",
         "'That 'nothing' trick only works with floating rooms.  In order to "
            "ensure that this room doesn't have the north, east, and south exits, "
            "I had to add a special function to the room.",
         "'Type 'find -d query_exit_type() here'",
         0,
         "'In any room that is managed by the terrain handler, whether than "
            "room is a floating room or a fixed room, the terrain handler checks "
            "a function called query_exit_type() to see what type of exit it "
            "should create in each direction.",
         "'The arguments are a string for the direction of the exit (north, "
            "west, south, northeast, etc.) and a string containing the file name "
            "of the destination room.  These are both just like you would use "
            "in a call to add_exit().",
         "'The function returns a string for an exit type, just like the "
            "third argument to add_exit().",
         "'There is, of course, a wrinkle: if query_exit_type() returns "
            "\"none\", then that exit isn't created at all.",
         0,
         "'If the room doesn't have a function called query_exit_type(), "
            "then some default values are used.  Those defaults are in an array "
            "at the beginning of /obj/handlers/terrain_handler.  It's real "
            "easy to find.",
         "'There are a lot of things that can be done to modify the exits "
            "that the terrain handler builds, but that'll be the subject for the "
            "next lesson.",
         "'For now, wander around if you feel like it, and come back to me "
            "when you're ready to finish this up.",
         0,
      }),
      "down"
   }),
   /* Lesson #3: Changing the exit types. */
   ({ "grassyfield", COSTUME_NORMAL,
      ({ "laugh",
         "'In spite of dragging you out here like this, Sin hasn't actually "
            "scripted this lesson yet.  Sorry.  This would've been the fourth "
            "lesson, in which I talk about how you can modify the exits that "
            "the terrain handler makes for you.",
         "shrug",
      }),
      "cottage"
   }),
});

void setup() {
   object obj;
   object backpack;
   
   set_name("terrain teacher");
   add_alias("teacher");
   set_short("terrain teacher");
   add_property("determinate", "the ");
   add_property("unique", 1);
   set_long("This man is middle aged, and apparently human.  That's about "
            "all you can really see, because he's soaking wet, his hair is caked "
            "with leaves and mud, his clothes are torn, and his boots are caked "
            "with dirt.\n");
   set_race("human");
   set_guild("monk");
   set_level(50);
   set_gender(1);
   
   add_effect("/std/effects/other/wetness", 10000);

   set_respond_to_with( ({
      ({ "@say", "teach", "please" }), "#new_pupil",
      ({ "@say", "please", "teach" }), "#new_pupil",
      ({ "@say", "teach" }), "#new_rude_pupil",
      ({ "@say", ({ "ok", "ready" }) }), "#next_speech",
   }) );
   
   backpack = ARMOURY->request_item("large backpack", 80);
   if (!backpack) backpack = ARMOURY->request_item("black leather backpack", 80);
   if (!backpack) backpack = ARMOURY->request_item("small backpack", 80);
   if (backpack) backpack->move(this_object());
   
   obj = ARMOURY->request_item("large leather boots", 20);
   if (obj) obj->move(this_object());
   
   obj = ARMOURY->request_item("thermal underwear", 10);
   if (obj) obj->move(this_object());
   
   obj = ARMOURY->request_item("fawn cotton trousers", 50);
   if (obj) obj->move(this_object());
   
   obj = ARMOURY->request_item("leather belt", 50);
   if (obj) obj->move(this_object());
   
   obj = ARMOURY->request_item("black wool socks", 40);
   if (obj) obj->move(this_object());
   
   obj = ARMOURY->request_item("gaudy shirt", 35);
   if (obj) obj->move(this_object());
   
   obj = ARMOURY->request_item("brown felt hat", 10);
   if (obj) obj->move(this_object());
   
   obj = ARMOURY->request_item("white cotton toga", 80);
   if (obj) obj->move(backpack);
   
   obj = ARMOURY->request_item("yellow raincoat", 60);
   if (obj) obj->move(backpack);
   
   obj = ARMOURY->request_item("old black cloak", 72);
   if (obj) obj->move(backpack);
   
   obj = ARMOURY->request_item("amusing earmuffs", 100);
   if (obj) obj->move(backpack);
   
   init_equip();
   
   costume = COSTUME_NORMAL;
   hq = find_object(TERRAIN_TUTORIAL "foyer");
   impatience = 0;
   lesson_step = 0;
   speeching = 0;
} /* setup() */

int check_anyone_here() {
   if (pupil) return 1;
   else return ::check_anyone_here();
} /* check_anyone_here() */

void heart_beat() {
   ::heart_beat();
   
   if (!pupil) return;
   ++impatience;
   if (impatience == CROSS_IMPATIENCE) {
      init_command("emote is beginning to look a bit impatient.", 1);
   } else if (impatience == TAPS_IMPATIENCE) {
      init_command("emote begins tapping his foot.", 1);
   } else if (impatience == MAX_IMPATIENCE) {
      init_command("'That's it, you clearly don't really want to learn.  "
                   "I give up on you, " + pupil->short(), 1);
      call_out("come", 3 + costume_normal(), hq);
      pupil = 0;
      impatience = 0;
   }
} /* heart_beat() */

int add_follower( object who ) {
   if (who == pupil) {
      int lesson;
      
      impatience = 0;
      lesson = pupil->query_property(PROPERTY);
      if (lesson < 0 || lesson >= sizeof(lessons)) {
         init_command("think", 1);
         init_command("'Odd, you seem to have done more lessons than I know.", 2);
         init_command("'I'm afraid I have nothing to teach you.", 3);
         pupil->remove_property(PROPERTY);
         pupil = 0;
         return 0;
      } else if (::add_follower(who)) {
         int delay;
         
         switch (lessons[lesson][1]) {
          case COSTUME_NORMAL: delay = costume_normal(); break;
          case COSTUME_DESERT: delay = costume_desert(); break;
          case COSTUME_WET: delay = costume_wet(); break;
          case COSTUME_COLD: delay = costume_cold(); break;
         }
         init_command(lessons[lesson][0], delay + 2);
         lesson_step = 0;
         call_out("speech", delay + 10);
         return 1;
      } else {
         return 0;
      }
   } else {
      init_command("'For what reason do you want to follow me, " +
                   who->short() + "?  I'm not teaching you.", 0);
      return 0;
   }
} /* add_follower() */

void coming( object where ) {
   tell_room( where,
      "%^CYAN%^Someone says: One moment!  I'll be right down!%^RESET%^\n",
             ({ this_object() }) );
} /* coming() */

void annoyed_coming( object where ) {
  tell_room( where,
    "%^CYAN%^An annoyed someone says: I said I'm coming!  "
    "Jeez!%^RESET%^\n",
    ({ this_object() }) );
} /* annoyed_coming() */

void come( object where ) {
   hq = where;
   if (where != environment())
      move( where, this_object()->a_short() + " arrives",
           this_object()->a_short() + " stomps away" );
   init_command( "emote looks around", 1 );
   init_command( "sigh", 4 );
   init_command( "get sign", 7 );
   init_command( "emote looks at the sign", 9 );
   init_command( "sit on bench", 10 );
   init_command( "'What can I do for you?", 12 );
} /* come() */

void done() {
   int delay = costume_normal();
   int lesson;
   
   lesson = pupil->query_property(PROPERTY) + 1;
   if (lesson == sizeof(lessons)) {
      init_command("'congratulations, " + pupil->short() + ", you have "
                   "completed all the terrain handler lessons.", ++delay);
      pupil->remove_property(PROPERTY);
   } else
      pupil->add_property(PROPERTY, lesson);
   
   init_command("emote looks around", delay + 1);
   init_command("sigh", delay + 4);
   init_command("get sign", delay + 7);
   init_command("emote looks at the sign", delay + 9);
   init_command("sit on bench", delay + 10);
   
   pupil = 0;
   impatience = 0;
   speeching = 0;
} /* done() */

void speech() {
   int lesson = pupil->query_property(PROPERTY);
   int delay;
   
   delay = 0;
   speeching = 1;
   if (lesson_step == sizeof(lessons[lesson][2])) {
      init_command(lessons[lesson][3], delay + 3);
      call_out("done", delay + 4);
      call_out( (: speeching = 0 :), delay + 5);
      return;
   }
   do {
      if (functionp(lessons[lesson][2][lesson_step])) {
         call_out(lessons[lesson][2][lesson_step], ++delay);
      } else if (stringp(lessons[lesson][2][lesson_step])) {
         init_command(lessons[lesson][2][lesson_step], ++delay);
      }
      if (++lesson_step == sizeof(lessons[lesson][2])) {
         init_command(lessons[lesson][3], delay + 3);
         call_out("done", delay + 4);
         call_out( (: speeching = 0 :), delay + 5);
         return;
      }
   } while (lessons[lesson][2][lesson_step]);
   lesson_step++;
   init_command("emote waits for " + pupil->a_short(), ++delay);
   call_out( (: speeching = 0 :), ++delay);
} /* speech() */

void pupil_arrived( object where ) {
   if (pupil) return;
   if (!environment()) {
      if (find_call_out("come") != -1)
         call_out("annoyed_coming", 0, where);
      else {
         call_out("come", 10, where);
         if (find_call_out("coming") == -1)
            call_out("coming", 2, where);
      }
   } else if (environment() == where) {
      init_command("'Oh, a pupil!", 2);
   }
} /* pupil_arrived() */

protected void to_terrain() {
   move(TERRAIN_CONTROL, "The terrain teacher appears",
        "The terrain teacher snaps his fingers and vanishes");
   tell_object(pupil, "Something snags you through space\n");
   pupil->move_with_look(TERRAIN_CONTROL, pupil->short() + " appears",
                         pupil->short() + " looks surprised and disappears.");
} /* to_terrain() */

protected void from_terrain( string to ) {
   move(to, "The terrain teacher appears",
        "The terrain teacher snaps his fingers and vanishes");
   tell_object(pupil, "Something snags you through space\n");
   pupil->move_with_look(to, pupil->short() + " appears",
                         pupil->short() + " looks surprised and disappears.");
} /* from_terrain() */

protected int modesty() {
   int num;
   
   num = sizeof(filter_array(all_inventory(environment()),
            (: living($1) && $1->query_gender() != 1 :) ));
   if (num) {
      if (num > 1)
         init_command("'Ladies, would you please turn around for a "
                      "moment?", 1);
      else
         init_command("'Ma'am, would you please turn around for a "
                      "moment?", 1);
      return 10;
   } else return 0;
} /* modesty() */

int costume_normal() {
   int i;
   
   if (costume == COSTUME_NORMAL) return 0;
   i = modesty();
   init_command("remove backpack", ++i);
   init_command("remove toga, raincoat, cloak, earmuffs", ++i);
   init_command("put toga, raincoat, cloak, earmuffs in backpack", ++i);
   init_command("get trousers, belt, shirt, hat from backpack", ++i);
   init_command("equip", ++i);
   costume = COSTUME_NORMAL;
   return i;
} /* costume_normal() */

int costume_desert() {
   int i;
   
   if (costume == COSTUME_DESERT) return 0;
   i = modesty();
   init_command("remove backpack", ++i);
   init_command("remove raincoat, cloak, earmuffs", ++i);
   init_command("remove belt, hat, shirt", ++i);
   init_command("remove trousers", ++i);
   init_command("put trousers, belt, shirt, hat, raincoat, cloak, "
                "earmuffs in backpack", ++i);
   init_command("get toga from backpack", ++i);
   init_command("equip", ++i);
   costume = COSTUME_DESERT;
   return i;
} /* costume_desert() */

int costume_wet() {
   int i;
   
   if (costume == COSTUME_WET) return 0;
   i = modesty();
   init_command("remove backpack", ++i);
   init_command("remove toga, cloak, earmuffs", ++i);
   init_command("put toga, cloak, earmuffs in backpack", ++i);
   init_command("get trousers, belt, shirt, hat, raincoat from "
                "backpack", ++i);
   init_command("equip", ++i);
   costume = COSTUME_WET;
   return i;
} /* costume_wet() */

int costume_cold() {
  int i;
   
   if (costume == COSTUME_COLD) return 0;
   i = modesty();
   init_command("remove backpack", ++i);
   init_command("remove toga, raincoat, hat", ++i);
   init_command("put toga, raincoat, hat in backpack", ++i);
   init_command("get trousers, belt, shirt, cloak, earmuffs "
                "from backpack", ++i);
   init_command("equip", ++i);
   costume = COSTUME_COLD;
   return i;
} /* costume_cold() */

void next_speech( object who, string message ) {
   if (who != pupil) return;
   if (speeching) return;
   
   impatience = 0;
   call_out("speech", 1);
} /* next_speech() */

void new_pupil( object who, string message ) {
   if ( pupil ) {
      if ( pupil == who ) {
         impatience = 0;
         init_command("pat " + who->short(), 1);
         init_command("'That's alright.  I understand you can get "
                      "excited at times like this.  Be assured that I am going "
                      "to teach you, " + who->short(), 3);
      } else {
         init_command("'sorry, " + who->short() + ", but I am teaching " +
                      pupil->short() + " right now.", 1);
      }
   } else {
      pupil = who;
      set_heart_beat(1);
      init_command("'Yes, " + pupil->short() +
                   ", I would be happy to teach you.", 1);
      init_command("drop sign", 3);
      init_command("stand", 4);
      init_command("'follow me, if you will", 6);
      impatience = 0;
   }
} /* new_pupil() */

void new_rude_pupil( object who, string message ) {
   if (!pupil) {
      init_command("emote hums quietly to himself.", 2);
      init_command("mumble rude pupils", 5);
   }
} /* new_rude_pupil() */

mixed *stats() {
   return ::stats() +
      ({
         ({ "pupil", pupil ? pupil->query_name() : "no pupil" }),
         ({ "impatience", impatience }),
         ({ "costume", (costume == COSTUME_NORMAL) ? "normal" :
            ((costume == COSTUME_DESERT) ? "desert" :
             ((costume == COSTUME_WET) ? "wet" :
              ((costume == COSTUME_COLD) ? "cold" : "???"))) }),
         ({ "lesson step", lesson_step }),
      });
} /* stats() */
// --- END [/mnt/home2/grok/lib/d/learning/chars/terrain_teacher.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/learning/chars/npc_example.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/learning/chars/npc_example.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627678   Available: 13575032
Inodes: Total: 5242880    Free: 4960133
8509 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/learning/chars/npc_example.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627678   Available: 13575032
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* Example of an basic NPC, 
 * written and updated by Hobbes */

inherit "/obj/monster";
    /* /obj/monster is a large but needed file and holds the advanced npc 
     * handling stuff which you don't have to think about. Inheriting this 
     * saves memory and you don't have to write it again for your npc. 
     * (Why invent the wheel twice?)   
     */
#include <armoury.h>
     /* This file is needed if you want to add clothes, weapons and armoury 
      * from /obj/clothes, /obj/weapons and /obj/armoury respectively. 
      */
object comb;
     /* If you want to equip your NPC from other directories, you need to
      * define the objects and clone them sepererately.  See below.
      */
void setup() {

   set_name( "ralph" ); 
     /* set_name() is the name the npc will be refered with.  It's almost 
      * always a noun or a name from the short.  It's always in lowercase. 
      */
   set_short( "Ralph the spotted giraffe" );
     /* set_short() is what the player will see when the npc is in the 
      * same room.
      */
   add_property( "determinate", "" );  
    /* This property also helps giving nice outputs.  Determinates such as 
     * "a" and "an" are handled automatically without the property.  The  
     * line above sets the determinate to none.  Unique npcs with names 
     * should have the none determinate, while npcs like the librarian 
     * should have "the " (note the space).
     */
   add_adjective( "spotted" );
     /* All relevant adjectives should be given using add_adjective.  
      * Adjectives in the short _must_ be given since the player ought at 
      * least be able to reference an object by its short, e.g. - , - , 
      * "old", "green", "blue", ({ "wooden", "wood" }), ({ "chocolate", 
      * "choc" }), "short", "shiny".
      */
   set_main_plural("Ralph the spotted giraffes"); 
     /* This sets what you see when there are more than one of them in the 
      * room.
      */
   add_plural(( { "ralphs", "giraffes" } ));
     /* Sets the plural which you can call them by.  Note that the system 
      * automatically adds one plural for you: the plural of the name once 
      * you have called set_name(). 
      * This may look weird in some cases though. A prime example for items 
      * are the plural of "key" is found to be "keies", so the correct 
      * plural must be given, e.g. add_plural( "keys" );
      */
   add_alias(( { "giraffe", "Ralph" } )); 
     /* This is simply another name which you can refer the NPC with.  
      * Players can type "look ralph" as well as "look Ralph". 
      */
   set_long( "This is Ralph the spotted giraffe.  He is just an example in "
             "this file so I won't describe him although I should.  Well, "
             "okay then... He's like any normal giraffe except for his cool " 
             "black specs and mop fringe.  He is coolnes personified.\n" );
     /* The set_long() is what you see when you look at the NPC.  It should
      * be detailed and interesting.  Don't just describe what they are.
      * Describe what they look like as well. 
      */
   add_property( "unique", 1 );
     /* The unique property does the following. First it lets you set the
      * NPCs own stats.  If you don't include this, it will use the race 
      * object's numbers.  Second, an unique NPC gives reduced exp when killed 
      * (it will be logged in /log/DEATHS, and be informed to the creators).  
      * Third, the NPC will be on the bounty system. 
      */
   set_race( "horse" );
     /* Sets the race.  We'll use horse as there are no giraffe race at the 
      * moment :P Look in /std/races/ for possible races to choose from.  The 
      * race handles bits like attacks, stats and body parts.  A crocodile has 
      * a tail while a a dwarf has not, for example.  The race object should 
      * be set before the the level and the stats.
      */
   set_guild("wizard");
     /* This sets which class or guild they belong to.  It is looked up in a 
      * table on the /std/race.c object when set_level is called.  This gives 
      * the guild object and sets up various things accordingly.  If the guild 
      * name does not exist in the race object they are given a default guild 
      * object. 
      */
   set_height( 300 );
     /* Height in centimeters.
      */
   set_weight( 1600 );
     /* 1 unit of weight is about equal to 50 grams or 1/9lb for all you hairy 
      * wombles out there...
      */
   set_gender( 1 );
     /* Sets the gender. 0 = it, 1 = male, 2 = female
      */
   set_al( -500 );
     /* Sets the alignment of the NPC.  0 is neutral, the more positive number, 
      * the more evil the NPC is.  Ralph is a really nice guy, so we set his al 
      * to a negative number.  
      */
     set_level( 15 );
     /* This sets the default experience of the monster up and also calls 
      * functions on both the race and guild objects to set up the race and 
      * guild specific details.  This should give a rough estimation of how 
      * good the NPC is. 
      */ 
   set_con(18);
   set_dex(18);
   set_str(16);
   set_wis(15);
   set_int(15);
      /* Well, this is the way to set the stats manually.  It will be the race's
       * default if you doesn't include these and the unique property.
       */
   add_move_zone( "Short" );
   add_move_zone( "Filigree" );
      /* This defines where Ralph is allowed to walk.  Short- and Filigree Street 
       * have these 'set_zones()' respectively.
       */
   set_move_after( 50, 60 );
      /* This sets the time delay in seconds between when the monster wanders, in 
       * this case: sometime between 50 and 60 seconds.    
       */
   set_virtual_move(1);
      /* This allows the NPC to "walk" between rooms that are not loaded.  To 
       * save memory, the NPC is located in the void till it gets to a loaded room. 
       */
   load_chat( 90, ({
      3, "@grin",
      3, "@high5 $lname$",
      2, "@bless $lname$",
      1, "@moonwalk",
      1, "'Far out man.",
      1, ({
         "'Hey, if it isn't $lname$!",
         "'You're looking cool as usual!"
      }),
      1, ":tells you: Hey my man!  Watcha up to?",
      1, "'That's cool.",
      1, "'Chillin' out here, are we?",
      1, "@ruffle $lname$",
      1, "@wink $lname$",
      2, ":does a really complicated tap dance manoeuvre.",
      1, "'Let's do something wild and crazy...",
      1, ({
         "'Yoho, how's it hangin'?",
         "'I'm in a darn good mood today!"
      }),
      1, ":tells you: Ouch man, where the heck did you find those clothes?"
   }) );
     /* This loads up the default chat messages.  The chance is the chance in 
      * 1000 that one of the messages will show up every heart_beat whilst not 
      * in combat.  The number infront of the chat is designed to allow you to 
      * make some messages much more likely to be said than others.
      * The character the chat begins with defines the following:
      * @         Soul command
      * '         Say.
      * "         Loud say.
      * :         Emote.
      * default   echo.      
      * $lname$   is a random player in the room.
      */
   load_a_chat( 100, ({
     1, "'Wait till Hobbes hears about this!",
     1, "'It's SO uncool to fight!",
     1, "@scream",
     1, "You can't believe you're fighting such a nice creature as Ralph.",
     1, ":seems to wish he was somewhere else."
     }) );
    /* Load_a_chat is just the same as load_chat above, except this is used
     * when the NPC is in combat.
     */
   ARMOURY->request_weapon("meat cleaver", 80+random(20))->move(this_object());
   ARMOURY->request_armour("gigantic dog collar", 100)->move(this_object());
   ARMOURY->request_armour("straw hat", 80)->move(this_object());
   /* These lines automatically clones and equips stuff from the /obj/ 
    * directories.  You must have <armoury.h> included (see above).
    * The number sets the condition (percentage) of the object.
    * Notice that you don't need the underscores in the names and clothes
    * is requested with "armour" too.
    */
   comb=clone_object("/d/am/items/comb"); 
   comb->move( this_object() ); 
    /* And this clones and moves the the object we defined at the top of the
     * file.
     */
   init_equip();
    /* This is what makes the NPC autoload the armoury.
     */
} /* setup() */

    /* Most of the functions are explained further in "man" files, do 
     * "man load_chat" for example.  See also "help setup".
     */
// --- END [/mnt/home2/grok/lib/d/learning/chars/npc_example.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/master.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/master.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627676   Available: 13575030
Inodes: Total: 5242880    Free: 4960133
1457 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/master.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627676   Available: 13575030
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#define LORD "pinkfish"
#define DOMAIN "dist"
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: master.c,v 1.1 1998/01/06 04:03:45 ceres Exp $
 * $Log: master.c,v $
 * Revision 1.1  1998/01/06 04:03:45  ceres
 * Initial revision
 * 
*/
/*
 * Beware editing this file.
 * Make sure you know what you are doing.  Stuffing this up could be
 * fatal in some ways.
 */

inherit "/std/dom/base_master";

string query_lord() {
  return LORD;
}

string author_file(string *path) {
  return capitalize(DOMAIN);
}

int check_permission(string euid, string *path, int mask) {
  if (euid == query_lord())
    return 1;
  return ::check_permission(euid, path, mask);
}

/*
 * By default, use the valid_read()/valid_write() functions defined in the
 * inherited file /std/dom/base_master.c.
 * These default to reading allowed for everyone, writing only allowed
 * for independent creators and the domain lord.
 * This is all overridden by the check_permission() function
 * which is called first, which should be used instead.
 */
int valid_read(string *path, string euid, string funct);

int valid_write(string *path, string euid, string funct);

int query_member(string name) {
  return !undefinedp(members[name]) || name == LORD;
} /* query_member() */

string log_who(string where) {
  return LORD;
} /* log_who() */

/* Please change this to a text describing the domain, it will be used
   on the WWW pages and in finger info. */

string query_info() {
  return "";
}
// --- END [/mnt/home2/grok/lib/d/dist/master.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/mtf/mtf2.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/mtf/mtf2.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627675   Available: 13575029
Inodes: Total: 5242880    Free: 4960133
11656 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/mtf/mtf2.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627675   Available: 13575029
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* MTF v1.0 Rywfol 990910 */

#include "mtfincl.h";

mixed *map;
mapping key_data;

class map_class {
  string filename;
  int counter;
  string inheritname;
  string basename;
  string short;
  string long;
  mapping exits;
}

class exit {
  string dest;
  int ypos;
  int xpos;
}

/*
 * Find how the rooms interconnect.
 * We look in a square around the item for + & - chars.
 * If we find one we've found an exit.
 */
mapping get_exits(int ypos, int xpos) {
  int x, y;
  class map_class data;
  mapping exits = ([ ]);
  
  if(!classp(map[ypos][xpos]))
    return ([ ]);

  // check the rooms either side of this one.
  for(y = -1; y < 2; y++) {
    if((y*2)+ypos < 0)
      continue;
    if((y*2)+ypos >= sizeof(map))
      continue;
    
    for(x = -1; x < 2; x++) {
      if((x*2)+xpos < 0)
        continue;
      if((x*2)+xpos >= sizeof(map[(y*2)+ypos]))
        continue;
      
      if(!x && !y)
        continue;

      if(classp(map[(y*2)+ypos][(x*2)+xpos])) {
        data = map[(y*2)+ypos][(x*2)+xpos];

        if((map[y+ypos][x+xpos] == '*') ||
           (map[y+ypos][x+xpos] == '+' && (y == 0 || x == 0)) ||
           (map[y+ypos][x+xpos] == 'x' && (y != 0 && x != 0)) ||
           (map[y+ypos][x+xpos] == '|' && y != 0 && x == 0) ||
           (map[y+ypos][x+xpos] == '-' && y == 0 && x != 0) ||
           (map[y+ypos][x+xpos] == '\\' && y == -1 && x == -1) ||
           (map[y+ypos][x+xpos] == '\\' && y == 1 && x == 1) ||
           (map[y+ypos][x+xpos] == '/' && y == 1 && x == -1) ||
           (map[y+ypos][x+xpos] == '/' && y == -1 && x == 1)) {
          exits[DIRECTIONS[y+1][x+1]] = new(class exit,
                                            dest : upper_case(data->basename)+
                                            " + \"" + data->filename + "\"",
                                            ypos : y+ypos,
                                            xpos : x+xpos);
        } else if(map[y+ypos][x+xpos] != ' ') {
          debug_printf("Unknown direction char: %O (%c), %d - %d, %d - %d %O %s",
                       map[y+ypos][x+xpos], map[y+ypos][x+xpos], x, xpos, y, ypos,
                       map[ypos][xpos],
                       data->basename);
        }
      }
    }
  }

  //  debug_printf("%0", exits);

  return exits;
}

#ifdef 0
/*
 *
 */
mixed *find_nearby(int ypos, int xpos, int distance, int direc) {
  string *dirs;
  int ny, nx;
  class exit tmp;

  if(distance > 4)
    return 0;
  
  if(!classp(map[ypos][xpos]))
    return 0;

  dirs = keys(map[ypos][xpos]->exits);
  if(direc >= sizeof(dirs))
    return 0;

  tmp = map[ypos][xpos]->exits;
  ny = tmp[]->ypos;
  nx = tmp[]->xpos;
  if(nx == xpos && ny == ypos) {
    if(direc == sizeof(dirs) -1)
      return 0;
    else
      direc++;
  }

  if(!find_nearby(ny, nx, ++distance);
  
}
#endif
     
/*
 * This is a lot like get_exits except that it goes further along the road.
 */
string calc_long(int ypos, int xpos) {
  int x, y, sameroad;
  class map_class data;
  string *exits = ({ });
  string *junctions = ({ });
  string long_str;

  mixed *nearby;
  
  if(!classp(map[ypos][xpos]))
    return "";

  /*
   * First we'll see how many exits we have that lead to this road.
   * 0 == end of the road
   * 1 == nothing special
   * 2 == fork
   */
  sameroad = 0;
  for(y = -1; y < 2; y++) {
    if((y*2)+ypos < 0)
      continue;
    if((y*2)+ypos >= sizeof(map))
      continue;
    
    for(x = -1; x < 2; x++) {
      if((x*2)+xpos < 0)
        continue;
      if((x*2)+xpos >= sizeof(map[(y*2)+ypos]))
        continue;
      
      if(!x && !y)
        continue;

      if(classp(map[(y*2)+ypos][(x*2)+xpos])) {
        data = map[(y*2)+ypos][(x*2)+xpos];
        
        // Do we have another room in this road?
        if(map[y+ypos][x+xpos] == '+' &&
           map[ypos][xpos]->basename ==
           map[(y*2)+ypos][(x*2)+xpos]->basename) {
          sameroad++;
          exits += ({ DIRECTIONS[y+1][x+1] });
        }
      }
    }
  }

  // check the rooms either side of this one to see if this is a junction.
  for(y = -1; y < 2; y++) {
    if((y*2)+ypos < 0)
      continue;
    if((y*2)+ypos >= sizeof(map))
      continue;
    
    for(x = -1; x < 2; x++) {
      if((x*2)+xpos < 0)
        continue;
      if((x*2)+xpos >= sizeof(map[(y*2)+ypos]))
        continue;
      
      if(!x && !y)
        continue;

      if(classp(map[(y*2)+ypos][(x*2)+xpos])) {
        data = map[(y*2)+ypos][(x*2)+xpos];
        
        // Do we have a junction?
        if(((map[y+ypos][x+xpos] == '*') ||
            (map[y+ypos][x+xpos] == '+' && (y == 0 || x == 0)) ||
            (map[y+ypos][x+xpos] == 'x' && (y != 0 && x != 0)) ||
            (map[y+ypos][x+xpos] == '|' && y != 0 && x == 0) ||
            (map[y+ypos][x+xpos] == '-' && y == 0 && x != 0) ||
            (map[y+ypos][x+xpos] == '\\' && y == -1 && x == -1) ||
            (map[y+ypos][x+xpos] == '\\' && y == 1 && x == 1) ||
            (map[y+ypos][x+xpos] == '/' && y == 1 && x == -1) ||
            (map[y+ypos][x+xpos] == '/' && y == -1 && x == 1)) && 
           map[ypos][xpos]->basename !=
           map[(y*2)+ypos][(x*2)+xpos]->basename) {
          if(member_array(map[(y*2)+ypos][(x*2)+xpos]->short, junctions) == -1)
            junctions += ({ map[(y*2)+ypos][(x*2)+xpos]->short });
        }
      }
    }
  }

#ifdef 0
  // Not a junction so lets start looking for junctions nearby.
  if(!sizeof(junctions)) {
    nearby = find_nearby(ypos, xpos);
  }
#endif
  
  /*
   * Build the long desc using priorities of things.
   */
  long_str = "This is ";
  if(sizeof(junctions)) {
    long_str += map[ypos][xpos]->short + " at the junction with " +
      query_multiple_short(junctions) +
      ".\n";
  } else if(sameroad == 0) {
    long_str += "the end of " + map[ypos][xpos]->short;
  } else if(sameroad == 1) {
    long_str += "a fork in " + map[ypos][xpos]->short +
      " where it splits heading " +
      query_multiple_short(exits);
  } else {
    long_str += map[ypos][xpos]->short;
  }
  

  //  debug_printf("%O", exits);
  return long_str;
}

/*
 * Write the file out.
 */
int write_this_file(string fdir, int ypos, int xpos) {
  class map_class room;
  string str, tmp, exit;
  mapping exits;
  int i;

  room = map[ypos][xpos];
  
  str = "#include \"path.h\";\n\n";
  str += "inherit " + room->inheritname + ";\n";
  str += "\n";
  str += "void setup() {\n";
  str += "  set_short(\"" + room->short + "\");\n";
  str += "  set_long(\"" + room->long + "\\n\");\n";
  str += "  set_light( 80 );\n";

  // Build the exits into the string
  exits = room->exits;

  foreach(exit in keys(exits)) {
    /*
     * A little wizardry.
     * ne,se,sw,nw are all odd numbered in the array.
     * so, if we have an odd numbered exit and the exits on either side of it
     * also exist then make it secret. This stops courtyards getting
     * overcrowded with exits.
     */
    i = member_array(exit, DIRECTIONS);
    if(i % 2 == 1 &&
       exits[DIRECTIONS[i-1]] &&
       exits[DIRECTIONS[(i+1) % sizeof(DIRECTIONS)]])
      str += sprintf("  add_exit(\"%s\", %s, \"secret\");\n",
                     exit, exits[exit]->dest);
    else
      str += sprintf("  add_exit(\"%s\", %s, \"road\");\n",
                     exit, exits[exit]->dest);
  }
  
  str += "}\n";
  
  // Create the directory if necessary and a path.h to go in it.
  if(file_size(fdir + "/" + room->basename) != -2) {
    mkdir(fdir + "/" + room->basename);
    tmp = "#include \"../path.h\"\n";
    tmp += "#undef PATH\n";
    tmp += "#define PATH __DIR__\n";
    write_file(fdir + "/" + room->basename + "/path.h", tmp, 1);
  }

  //  debug_printf("Str: %s", str);
  return write_file( fdir + "/" + room->basename + "/" + room->filename + ".c",
                     str, 1 );
}

/**
 * Read the map into a mixed array (be better if it was a class.
 */
mixed *read_map(string mapfile) {
  int i, j;
  mixed *temp_map;
  string *lines;
  
  lines = explode(read_file(mapfile), "\n");
  temp_map = allocate(sizeof(lines));

  for(i=0; i<sizeof(lines); i++) {
    temp_map[i] = allocate(strlen(lines[i]));
    for(j=0; j<strlen(lines[i]); j++) {
      if(key_data[lines[i][j]]) {
        // inc the room count.
        //        debug_printf("%c:%s", lines[i][j], key_data[lines[i][j]][2]);
        key_data[lines[i][j]][0] = to_int(key_data[lines[i][j]][0]) + 1;

        if(sizeof(key_data[lines[i][j]]) < 4)
          debug_printf("Key data too small: %O", key_data[lines[i][j]]);
        temp_map[i][j] = new(class map_class,
                             filename : key_data[lines[i][j]][2] +
                             key_data[lines[i][j]][0],
                             counter : key_data[lines[i][j]][0],
                             inheritname : key_data[lines[i][j]][1],
                             basename : key_data[lines[i][j]][2],
                             short : key_data[lines[i][j]][3]);
      } else
        temp_map[i][j] = lines[i][j];
    }
  }

  return temp_map;
}

/* Read the key file into a mapping.
 * The mapping is indexed by key character and contains
 * ({ counter, inheritname, filename, name })
 * counter is the start value for the counter (so we can start a street at some
 * value if we've already got rooms for it from another map).
 * inheritname is the name of the file to be inherited
 * filename is the base filename for the room eg. short
 * name is the name of the street eg. Short Street.
 */
mapping read_keys(string keyfile) {
  mapping key_data;
  string line, *lines;
  
  key_data = ([ ]);
  lines = explode(read_file(keyfile), "\n");
  foreach(line in lines) {
    key_data[line[0]] = explode(line[1..], "\t");
    //debug_printf("%c: %s", line[0], key_data[line[0]][2]);
  }

  return key_data;
}

/* Do the actual mapping */
int map_to_files( string mapfile, string fdir, string keyfile ) {
  int tot;
  string *file_tmp;
  string pstr;
  int x, y;
  
  if(!mapfile || mapfile == "")
    return NO_MAP_FILE;

  file_tmp = this_player()->get_files(mapfile);

  if(!file_tmp || sizeof(file_tmp) != 1 || file_size(file_tmp[0]) < 1)
    return NO_MAP_FILE;
  else
    mapfile = file_tmp[0];

  if(!fdir || fdir == "")
    file_tmp = ({ this_player()->query_path() });
  else
    file_tmp = this_player()->get_files(fdir);

  if(!file_tmp || sizeof(file_tmp) != 1 || file_size(file_tmp[0]) != -2)
    return NO_FILE_DIR;
  else
    fdir = file_tmp[0];
  
  if(!keyfile || keyfile == "" )
    keyfile = DEFAULT_KEYS;

  file_tmp = this_player()->get_files(keyfile);

  if(sizeof(file_tmp) != 1 || file_size(file_tmp[0]) < 1)
    return NO_KEY_FILE;
  else
    keyfile = file_tmp[0];

  key_data = read_keys(keyfile);
  map = read_map(mapfile);

  //  debug_printf("Map read %O", map);
  // go through the map line by line.
  for(y = 0; y < sizeof(map); y++)
    for(x = 0; x < sizeof(map[ y ]); x++)
      if(classp(map[y][x])) {
        map[y][x]->exits = get_exits(y, x);
      }

  reset_eval_cost();
  for(y = 0; y < sizeof(map); y++)
    for(x = 0; x < sizeof(map[ y ]); x++)
      if(classp(map[y][x]))
        map[y][x]->long = calc_long(y, x);

  reset_eval_cost();
  for(y = 0; y < sizeof(map); y++)
    for(x = 0; x < sizeof(map[ y ]); x++)
      if(classp(map[y][x]))
        tot += write_this_file(fdir, y, x);
  
  pstr = "/* Created at " + ctime( time() ) + " */\n";
  pstr += "#define CITYROOM \"/d/am/cityroom\"\n";
  pstr += "#undef CITY\n";
  pstr += "#define CITY \"" + fdir + "/\"\n";

  foreach(x in keys(key_data))
    pstr += "#define " + upper_case(key_data[x][2]) + " CITY + \"" + key_data[x][2] +
      "/\"\n";
  tot += write_file( fdir+ "/path.h", pstr, 1 );
  return tot;
}
// --- END [/mnt/home2/grok/lib/d/dist/mtf/mtf2.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/mtf/mtf.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/mtf/mtf.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627672   Available: 13575026
Inodes: Total: 5242880    Free: 4960133
5298 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/mtf/mtf.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627672   Available: 13575026
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* MTF v1.0 Rywfol 990910 */

#include "mtfincl.h";

mapping get_exits(int ypos, int xpos, mixed *map, mapping keys) {
  int x, y;
  mapping exits = ([ ]);
  string *keylist, room;

  keylist = keys(keys);

  room = map[ypos][xpos][0];
  // check the rooms either side of this one.
  for(y = -1; y < 2; y++) {
    if(y+ypos < 0)
      continue;
    if(y+ypos >= sizeof(map))
      continue;
    
    for(x = -1; x < 2; x++) {
      if(x+xpos < 0)
        continue;
      if(x+xpos >= sizeof(map[y+ypos]))
        continue;
      
      if(!x && !y)
        continue;

      if(map[y+ypos][x+xpos] != 0) {
        //debug_printf("Room %s has exit to %d,%d [%d,%d]", room, x+xpos,y+ypos, x, y);
        exits[DIRECTIONS[y+1][x+1]] = upper_case(map[y+ypos][x+xpos][3]) +
          " + \"" + map[y+ypos][x+xpos][0] + "\"";
      }
    }
  }
  //  debug_printf("%O", exits);
  return exits;
}

int write_this_file(string istring, string dir, string fname, string sname,
                    mapping exits) {
  string str, tmp, exit;
  int i;
  
  //  debug_printf("Creating %s", fname);
  
  str = "#include \"path.h\";\n\n";
  str += "inherit " + istring + ";\n";
  str += "\n";
  str += "void setup() {\n";
  str += "  set_short(\"" + sname + "\");\n";
  str += "  set_long(\"This is " + sname + " it hasn't had its long \"\n";
  str += "           \"description set yet.\\n\");\n";
  str += "  set_light( 80 );\n";

  // Remove extra exits.
  for(i=0; i<sizeof(LIST); i++) {
    if(exits[LIST[i]] &&
       exits[LIST[(i+1) % sizeof(LIST)]] &&
       exits[LIST[(i+2) % sizeof(LIST)]]) {
      /*      debug_printf("Removing %s[%d] and %s[%d], keeping %s[%d]",
                   LIST[(i) % sizeof(LIST)], i,
                   LIST[(i+2) % sizeof(LIST)], i+2,
                   LIST[(i+1) %sizeof(LIST)], i+1);
      */
      map_delete(exits, LIST[(i)]);
      map_delete(exits, LIST[(i+2) % sizeof(LIST)]);
    }
  }

  foreach(exit in keys(exits)) {
    str += sprintf("  add_exit(\"%s\", %s, \"road\");\n",
                   exit, exits[exit]);
  }
  
  str += "}\n";

  if(file_size(dir) != -2) {
    //    debug_printf("Creating directory %s", dir);
    mkdir(dir);
    tmp = "#include \"../path.h\"\n";
    tmp += "#undef PATH\n";
    tmp += "#define PATH __DIR__\n";
    write_file(dir + "/path.h", tmp, 1);
  }
    
  return write_file( dir + "/" + fname + ".c", str, 1 );
}

mixed *read_map(string mapfile, mapping keys) {
  int i, j;
  mixed *map;
  string *lines;
  
  lines = explode(read_file(mapfile), "\n");
  map = allocate(sizeof(lines));

  for(i=0; i<sizeof(lines); i++) {
    map[i] = allocate(strlen(lines[i]));
    for(j=0; j<strlen(lines[i]); j++) {
      if(keys[lines[i][j]]) {
        // inc the room count.
        keys[lines[i][j]][0] = to_int(keys[lines[i][j]][0]) + 1;
        // then give this room a filename.
        map[i][j] = ({ keys[lines[i][j]][2] + keys[lines[i][j]][0] }) + 
                         keys[lines[i][j]];
      } else {
        map[i][j] = 0;
      }
    }
  }

  log_file("/w/ceres/tmp.log", "%O", map);
  return map;
}

// Read the key file into a mapping.
mapping read_keys(string keyfile) {
  mapping keys;
  string line, *lines;
  
  keys = ([ ]);
  lines = explode(read_file(keyfile), "\n");
  foreach(line in lines)
    keys[line[0]] = explode(line[1..], "\t");

  return keys;
}

int map_to_files( string mapfile, string fdir, string keyfile ) {
  int tot;
  string *file_tmp;
  string pstr;
  int x, y;
  mapping keys;
  mixed *temp_map, temp_exits;
  
  if(!mapfile || mapfile == "")
    return NO_MAP_FILE;

  file_tmp = this_player()->get_files(mapfile);

  if(!file_tmp || sizeof(file_tmp) != 1 || file_size(file_tmp[0]) < 1)
    return NO_MAP_FILE;
  else
    mapfile = file_tmp[0];

  if(!fdir || fdir == "")
    file_tmp = ({ this_player()->query_path() });
  else
    file_tmp = this_player()->get_files(fdir);

  if(!file_tmp || sizeof(file_tmp) != 1 || file_size(file_tmp[0]) != -2)
    return NO_FILE_DIR;
  else
    fdir = file_tmp[0];
  
  if(!keyfile || keyfile == "" )
    keyfile = DEFAULT_KEYS;

  file_tmp = this_player()->get_files(keyfile);

  if(sizeof(file_tmp) != 1 || file_size(file_tmp[0]) < 1)
    return NO_KEY_FILE;
  else
    keyfile = file_tmp[0];

  keys = read_keys(keyfile);
  temp_map = read_map(mapfile, keys);

  //  debug_printf("Map read %O", temp_map);
  // go through the map line by line.
  for(y = 0; y < sizeof(temp_map); y++) {
    reset_eval_cost();
    for(x = 0; x < sizeof(temp_map[ y ]); x++) {
      if(temp_map[y][x] != 0) {
        temp_exits = get_exits(y, x, temp_map, keys);
        if(sizeof(temp_map[y][x]) < 5) {
          //          debug_printf("%O", temp_map[y][x]);
          return;
        }
        tot += write_this_file(temp_map[y][x][2],
                               fdir + "/" + temp_map[y][x][3],
                               temp_map[y][x][0], temp_map[y][x][4],
                               temp_exits);
      }
    }
  }

  //debug_printf("finished with files.");
  
  pstr = "/* Created at " + ctime( time() ) + " */\n";
  pstr += "#define CITY \"" + fdir + "/\"\n";

  foreach(x in keys(keys))
    pstr += "#define " + upper_case(keys[x][2]) + " CITY + \"" + keys[x][2] +
      "/\"\n";
  tot += write_file( fdir+ "/path.h", pstr, 1 );
  return tot;
}
// --- END [/mnt/home2/grok/lib/d/dist/mtf/mtf.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/mtf/key_deft.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/mtf/key_deft.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627671   Available: 13575025
Inodes: Total: 5242880    Free: 4960133
17 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/mtf/key_deft.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627671   Available: 13575025
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
# "/std/outside"
// --- END [/mnt/home2/grok/lib/d/dist/mtf/key_deft.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/common.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/common.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627671   Available: 13575025
Inodes: Total: 5242880    Free: 4960133
3289 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/common.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627671   Available: 13575025
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#define DOM_TITLE "the domain of dist"
#define LORD "pinkfish"
#define DOMAIN "dist"
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: common.c,v 1.1 1998/01/06 04:03:45 ceres Exp $
 * $Log: common.c,v $
 * Revision 1.1  1998/01/06 04:03:45  ceres
 * Initial revision
 * 
*/
/* PLEASE re-describe me */
inherit "/std/dom/cmn_mas";
object board;

void setup() {
  set_dom(DOMAIN);
  set_light(100);
  add_exit("drum", "/d/am/am/mendeddrum", "door");
  set_short("Common room of "+DOM_TITLE);
  set_long("Large relaxing chairs addorn the room.  The walls are covered "+
           "with strange motifs from different lands and the little shelf "+
           "above the fireplace is chocker block full of strange figurines "+
           "and bits of cloth.  It appears to be the common room of "+
           DOM_TITLE+" the large red letters on the wall were the " +
           "give away.\n");
  add_alias("chairs", "chair");
  add_alias("cloths", "cloth");
  add_alias("motifs", "motif");
  add_alias("figurines", "figurine");
  add_item("chair", "The chairs are lazing around the room relaxing it looks "+
                    "like they come here after a hard days working in "+
                    DOM_TITLE+".\n");
  add_item("fireplace", "A nice little fire place with a cheery fire burning "+
                        "in it keeping every one warm.\n");
  add_item("figurine", "Small figurines, they look strangely familiar "+
                         "until you realise they are the members of "+
                         DOM_TITLE+".\n");
  add_item("cloth", "Strange coloured bits of cloth strewn over the "+
                    "mantlepice for no readily apparent reason.\n");
  add_item("motif", "The motifs on close inspection look like stylised "+
                     "signatures of all the members of "+DOM_TITLE+
                     ".  Some of them are very strange, in fact there "+
                     "seem to be more than there are members of the house.  "+
                     "perhaps it is the members of the future.\n");
  add_item("shelf", "A nice normal sort of shelf thing.  It is like all "+
                    "those ones you see in houses all over the place, "+
                    "execpt... the way it has been burnt... hmm it does "+
                    "not look like the fire did it.\n");
  add_item("fire", "There is a fire happily burning away in the fireplace "+
                   "spluttering and crackling to itself.  The flames almost "+
                   "seem afraid of something.  Looking closer you notice a "+
                   "picture tacked to the side of the fire place.\n");
  add_item("picture", "Tacked to the inside wall of the fire thingy, you "+
                      "know the hole bit at the bottom, is a small picture "+
                      "it looks like it was taken with the best of demon "+
                      "photography.  It is a picture of a person holding "+
                      "a small staff, you think it might be "+LORD+
                      " but you are not sure as the fire light sparkles "+
                      "in your eyes.\n");
  board = clone_object("/obj/misc/board");
  board->set_datafile(DOMAIN);
  board->move(this_object());
}

void dest_me()
{
  if(board) board->dest_me();
  ::dest_me();
}
// --- END [/mnt/home2/grok/lib/d/dist/common.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/loader.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/loader.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627670   Available: 13575024
Inodes: Total: 5242880    Free: 4960133
1213 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/loader.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627670   Available: 13575024
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#define DOMAIN "dist"
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: loader.c,v 1.1 1998/01/06 04:03:45 ceres Exp $
 * $Log: loader.c,v $
 * Revision 1.1  1998/01/06 04:03:45  ceres
 * Initial revision
 * 
*/
/* this is the file you use to preload things...
 * It will be added to the preload list on the maste object automaticly
 */

string *pre_load;

void create() {
  int i;

  seteuid((string)"/secure/master"->creator_file(file_name()));
  unguarded((: restore_object, file_name(this_object()) :));
  if (!pre_load)
    pre_load = ({ });
  for (i=0;i<sizeof(pre_load);i++) {
    printf(DOMAIN+" pre_loading "+pre_load[i]+".\n");
    if (catch(call_other(pre_load[i], "??")))
      call_out("do_load", 0, pre_load[i]);
  }
}

/* this is so the errors get done... ;) */
void do_load(string str) {
  call_other(str, "??");
}

int add_pre_load(string str) {
  if (member_array(str, pre_load) == -1)
    pre_load += ({ str });
  save_object(file_name(this_object()));
  return 1;
}

int remove_pre_load(string str) {
  int i;

  if ((i=member_array(str, pre_load)) == -1)
    return 0;
  pre_load = delete(pre_load, i, 1);
  save_object(file_name(this_object()));
}

string *query_pre_load() { return pre_load; }
// --- END [/mnt/home2/grok/lib/d/dist/loader.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/start/entrance.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/start/entrance.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627669   Available: 13575023
Inodes: Total: 5242880    Free: 4960133
347 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/start/entrance.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627669   Available: 13575023
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <config.h>

inherit "/std/room/basic_room";

void setup() {
   set_short("entrance");
   set_long("You are standing at the entrance to a big wide, well quite small, "
            "area.  Welcome to the Discworld mud distribution lib entrance.\n");
   set_light(70);

   add_exit("pumpkin", CONFIG_START_LOCATION, "road");
} /* setup() */
// --- END [/mnt/home2/grok/lib/d/dist/start/entrance.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/crumpt/parcel_post.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/crumpt/parcel_post.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627669   Available: 13575023
Inodes: Total: 5242880    Free: 4960133
403 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/crumpt/parcel_post.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627669   Available: 13575023
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h"

inherit "/std/room/parcel_inherit";

void setup() {
   set_short("Parcel Post");
   set_long(
"Livid orange strips criss cross the room contrasting just beautifully "
"against the black background.  The walls almost seem to be pulsing with "
"colour.\n");
   set_light(70);

   add_exit("south", CRUMPT + "post_office", "south");

   add_property("place", "Pumpkin");
} /* setup() */
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/crumpt/parcel_post.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/crumpt/bank.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/crumpt/bank.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627669   Available: 13575023
Inodes: Total: 5242880    Free: 4960133
867 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/crumpt/bank.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627669   Available: 13575023
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h"

inherit "/std/shops/bank";

void setup() {
   set_short("Pumpkin's Bank");
   set_long(
"The room is full of pumpkins with little dollar signs carved in the side.  "
"There is a wooden counter running across the room with some telers peering "
"through the wooden grill into the main room.\n");

   add_item("counter", ({ "long", "It is wooden and has a grill on top to "
            "seperate the tellers from the unwashed masses.",
            "position", "the counter" }));
   add_item("teller", "They peer out at through the grill wondering who has "
            "come to give them money.\n");
   add_item("pumpkin", "There are little pumpkins everywhere in the room.");

   set_light(70);

   set_percentage(95);
   set_place("Pumpkin");

   add_exit("south", CRUMPT + "crumpt7", "door");

   add_property("place", "Pumpkin");
} /* setup() */
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/crumpt/bank.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/crumpt/club_office.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/crumpt/club_office.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627668   Available: 13575022
Inodes: Total: 5242880    Free: 4960133
1303 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/crumpt/club_office.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627668   Available: 13575022
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h"
#include <clubs.h>

inherit "/std/room/club_control_room";

void setup() {
   set_light(70);
   set_club_control_type(CLUB_ROOM_CLUB_ONLY);
   set_short("Club control room");
   set_long("This is a small cosy room with a nice comradely atmosphere "
            "about it.  There is a nice sofa and a desk with little club "
            "ornaments all over it.\n");

   add_item("sofa", ({ "long",
                      "The sofa looks nice and comfortable, just the spot "
                      "after a hard days hacking people into small bits.\n",
               "position", "the comfy sofa" }));
   add_item("desk",
            ({ "long",
                   "The brown leather covered desk looks really nice "
                   "and comforable sitting in the middle of the room like "
                   "that.  It is covered in small club shaped ornaments.\n",
               "position", "the large black desk" }));
   add_item("club ordanment",
            "The desk is covered in them, 'Real genuine minature babarian "
            "clubs'.  Looks like someone has a club fetish.\n");

   set_not_replaceable(1);

   clone_object("/obj/misc/top_clubs")->move(this_object());

   add_exit("south", PATH + "crumpt6", "door");

   add_property("place", "Pumpkin");
} /* setup() */
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/crumpt/club_office.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/crumpt/crumpt3.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/crumpt/crumpt3.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627668   Available: 13575022
Inodes: Total: 5242880    Free: 4960133
284 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/crumpt/crumpt3.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627668   Available: 13575022
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h";

inherit CITYROOM;

void setup() {
  set_short("Crumpet Circle");
  set_long("This is the end of Crumpet Circle\n");
  set_light( 80 );
  add_exit("north", CRUMPT + "crumpt1", "road");
  add_exit("south", CRUMPT + "crumpt5", "road");

  set_monster( 1, "city" );
}
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/crumpt/crumpt3.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/crumpt/crumpt1.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/crumpt/crumpt1.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627668   Available: 13575022
Inodes: Total: 5242880    Free: 4960133
367 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/crumpt/crumpt1.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627668   Available: 13575022
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h";

inherit CITYROOM;

void setup() {
  set_short("Crumpet Circle");
  set_long("This is Crumpet Circle at the junction with Pumpkin Way.
\n");
  set_light( 80 );
  add_exit("northeast", PUMPKIN + "pumpkin1", "road");
  add_exit("southwest", CRUMPT + "crumpt2", "road");
  add_exit("south", CRUMPT + "crumpt3", "road");

  set_monster( 1, "city" );
}
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/crumpt/crumpt1.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/crumpt/crumpt5.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/crumpt/crumpt5.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627667   Available: 13575021
Inodes: Total: 5242880    Free: 4960133
288 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/crumpt/crumpt5.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627667   Available: 13575021
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h";

inherit CITYROOM;

void setup() {
  set_short("Crumpet Circle");
  set_long("This is the end of Crumpet Circle\n");
  set_light( 80 );
  add_exit("southwest", CRUMPT + "crumpt7", "road");
  add_exit("north", CRUMPT + "crumpt3", "road");

  set_monster( 1, "city" );
}
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/crumpt/crumpt5.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/crumpt/crumpt6.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/crumpt/crumpt6.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627667   Available: 13575021
Inodes: Total: 5242880    Free: 4960133
339 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/crumpt/crumpt6.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627667   Available: 13575021
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h";

inherit CITYROOM;

void setup() {
  set_short("Crumpet Circle");
  set_long("This is the end of Crumpet Circle\n");
  set_light( 80 );
  add_exit("northeast", CRUMPT + "crumpt4", "road");
  add_exit("south", CRUMPT + "crumpt8", "road");
  add_exit("north", PATH + "club_office", "door");

  set_monster( 1, "city" );
}
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/crumpt/crumpt6.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/crumpt/crumpt4.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/crumpt/crumpt4.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627667   Available: 13575021
Inodes: Total: 5242880    Free: 4960133
347 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/crumpt/crumpt4.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627667   Available: 13575021
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h";

inherit CITYROOM;

void setup() {
  set_short("Crumpet Circle");
  set_long("This is the end of Crumpet Circle\n");
  set_light( 80 );
  add_exit("northeast", CRUMPT + "crumpt2", "road");
  add_exit("southwest", CRUMPT + "crumpt6", "road");
  add_exit("north", CRUMPT + "family_office", "door");

  set_monster( 1, "city" );
}
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/crumpt/crumpt4.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/crumpt/crumpt7.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/crumpt/crumpt7.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627665   Available: 13575019
Inodes: Total: 5242880    Free: 4960133
338 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/crumpt/crumpt7.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627665   Available: 13575019
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h";

inherit CITYROOM;

void setup() {
  set_short("Crumpet Circle");
  set_long("This is the end of Crumpet Circle\n");
  set_light( 80 );
  add_exit("northeast", CRUMPT + "crumpt5", "road");
  add_exit("southwest", CRUMPT + "crumpt9", "road");
  add_exit("north", CRUMPT + "bank", "door");

  set_monster( 1, "city" );
}
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/crumpt/crumpt7.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/crumpt/post_office.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/crumpt/post_office.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627665   Available: 13575019
Inodes: Total: 5242880    Free: 4960133
1657 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/crumpt/post_office.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627665   Available: 13575019
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h"
#include <mail.h>

inherit "/std/room/basic_room";

int do_mail( string words );

private nosave object _dictionary;

void setup() {
   add_help_file("mail_room");
   set_short("Post Office");
   set_light(70);
   set_long(
"Black and orange colours seem to dominate the room, you can see a counter "
"or something in amongst all the clashing colours.\n");

   add_item("counter", ({ "long",
            "There are some envelopes and bits of paper strewn "
            "about on the counter.",
            "position", "the counter" }));

   add_exit("southeast", CRUMPT + "crumpt2", "door");
   add_exit("north", CRUMPT + "parcel_post", "corridor");

   add_property("place", "Pumpkin");
} /* setup() */

void reset() {
   if ( !_dictionary ) {
      _dictionary = clone_object( "/net/obj/dict" );
      _dictionary->add_property( "there", "attached to the counter" );
      _dictionary->reset_get();
      _dictionary->move( this_object() );
   }
} /* reset() */

void init() {
   ::init();
   add_command("mail", "<string>", (: do_mail($4[0]) :));
   add_command("mail", "", (: do_mail(0) :));
} /* init() */

int do_mail( string words ) {
   return (int)MAIL_TRACK->mail( words );
} /* do_mail() */

int send_message( string from, int parcel ) {
#if 0
   object thing;

   thing = clone_object( CHARS +"post_et" );
   thing->set_home( file_name( this_object() ) );
   thing->move( this_object(), "$N pop$s out of the counter and grab$s the mail." );
   if ( find_player( recipient ) ) {
      thing->goto_player( recipient, from );
   } else {
      thing->goto_dest( COMM_ROOM, from );
   }
   return 1;
#endif
} /* send_message() */

// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/crumpt/post_office.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/crumpt/crumpt2.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/crumpt/crumpt2.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627664   Available: 13575018
Inodes: Total: 5242880    Free: 4960133
349 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/crumpt/crumpt2.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627664   Available: 13575018
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h";

inherit CITYROOM;

void setup() {
  set_short("Crumpet Circle");
  set_long("This is the end of Crumpet Circle\n");
  set_light( 80 );
  add_exit("northeast", CRUMPT + "crumpt1", "road");
  add_exit("southwest", CRUMPT + "crumpt4", "road");
  add_exit("northwest", CRUMPT + "post_office", "door");

  set_monster( 1, "city" );
}
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/crumpt/crumpt2.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/crumpt/crumpt9.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/crumpt/crumpt9.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627664   Available: 13575018
Inodes: Total: 5242880    Free: 4960133
288 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/crumpt/crumpt9.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627664   Available: 13575018
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h";

inherit CITYROOM;

void setup() {
  set_short("Crumpet Circle");
  set_long("This is the end of Crumpet Circle\n");
  set_light( 80 );
  add_exit("northeast", CRUMPT + "crumpt7", "road");
  add_exit("west", CRUMPT + "crumpt8", "road");

  set_monster( 1, "city" );

}
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/crumpt/crumpt9.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/crumpt/crumpt8.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/crumpt/crumpt8.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627664   Available: 13575018
Inodes: Total: 5242880    Free: 4960133
365 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/crumpt/crumpt8.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627664   Available: 13575018
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h";

inherit CITYROOM;

void setup() {
  set_short("Crumpet Circle");
  set_long("This is Crumpet Circle at the junction with Fruitbat Avenue.
\n");
  set_light( 80 );
  add_exit("east", CRUMPT + "crumpt9", "road");
  add_exit("north", CRUMPT + "crumpt6", "road");
  add_exit("south", FRUITBAT + "fruitbat1", "road");

  set_monster( 1, "city" );

}
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/crumpt/crumpt8.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/crumpt/family_office.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/crumpt/family_office.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627664   Available: 13575018
Inodes: Total: 5242880    Free: 4960133
2451 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/crumpt/family_office.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627664   Available: 13575018
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h"
#include <clubs.h>

inherit "/std/room/club_control_room";

int check_playtester(string str, object ob, string special_mess);

void setup() {
   object table;

   set_light(100);
   set_club_control_type(CLUB_ROOM_FAMILY_ONLY);
   set_short("Family control room");
   set_long("White boards cover the walls of the room, in the middle of "
            "the boards is a large black desk.  Scribblings and weird lines "
            "joining squiggly blobs to other squiggly blobs cover the white "
            "boards.\n");
   add_sign("A large imposing 'read me' type sign.\n",
            (: query_club_warning_message() :),
            "sign");

   add_item("white board", "They are everywhere, the drawings all look "
                   "somewhat meaningless, although perhaps they are "
                   "trying to convey some sort of family tree feeling.  "
                   "All the drawings look rather old, odd really.  "
                   "A singular lack of white board markers or erasers "
                   "could be the reason behind it.\n");
   add_item("white board eraser",
                   "There are none of them here, not one, not even...  No "
                   "none at all.\n");
   add_item("white board marker",
                   "Looking around the place, there is a singular lack of "
                   "white board markers.\n");
   add_item("large black desk",
            ({ "long",
                   "The desk looks imposing in its bulk and girth.  It "
                   "looks a bit unused, although there is a register "
                   "sitting on top of the desk which seems to contain the "
                   "list of all the current clubs in Ankh-Morpork.\n",
               "position", "the large black desk" }));
   add_item("squiggly blob",
                   "It appears to be joined to another squiggly blob.\n");
   add_item("weird line",
                   "This line darts across the board at an angle that "
                   "is hard to determine, you guess 16.123678 degrees.\n");
   add_item("scribblings",
                   "They are not recognisably words, they just look like they "
                   "could be words until you take a closer look.\n");
   set_not_replaceable(1);

   add_exit("south", PATH + "crumpt4", "door");

   table = clone_object("/obj/misc/top_families");
   table->move(this_object());

   add_property("place", "Pumpkin");
} /* setup() */
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/crumpt/family_office.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/inherit/cityroom.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/inherit/cityroom.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627663   Available: 13575017
Inodes: Total: 5242880    Free: 4960133
8486 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/inherit/cityroom.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627663   Available: 13575017
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: cityroom.c,v 1.3 1999/10/12 20:07:31 ceres Exp $
 *
 * $Log: cityroom.c,v $
 * Revision 1.3  1999/10/12 20:07:31  ceres
 * Missed an unneeded callout
 *
 * Revision 1.2  1999/10/04 22:49:46  ceres
 * Modified to seriously simplify the guttering code. (Basically deleted most of it :)
 *
 * Revision 1.1  1998/02/11 04:13:54  terano
 * Initial revision
 *
*/
#include <armoury.h>
#include <hospital.h>
#include <move_failures.h>
#include <weather.h>
#include "path.h"

#define CREVICE ({ "a crevice", "a pothole", "a gutter" })[ random( 3 ) ]
#define LOG_FILE LOG +"city_log"

inherit "/std/room/outside";

int *crowd;
string type, *froms;
object *monsters;
int last_found;

int query_cityroom() { return 1; }
int *query_crowd() { return crowd; }
object *query_monsters() { return monsters; }

void announce_entry( object thing ) {
  string word;
  if ( !froms ) {
    froms = ({ });
    foreach ( word in query_direc() ) {
      if ( member_array( word, ({ "north", "south", "east", "west",
                                    "northeast", "southwest", "southeast",
                                    "northwest" }) ) == -1 )
        continue;
      if ( call_door( word, "query_closed" ) )
        continue;
      froms += ({ "the "+ word });
    }
  }  
  if ( !sizeof( froms ) )
    tell_room( this_object(), "$a_short:"+ file_name( thing ) +
               "$ $V$0=arrives,arrive$V$ from elsewhere.\n" );
  else
    tell_room( this_object(), "$a_short:"+ file_name( thing ) +
               "$ $V$0=arrives,arrive$V$ from "+
               froms[ random( sizeof( froms ) ) ] +".\n" );
} /* announce_entry() */

void make_citymonster( int number ) {
  if(!(int)HOSPITAL->ok_to_clone()) {
    HOSPITAL->add_empty( this_object() );
    return;
  }
  
  if ( !monsters[ number ] ) {
    monsters[ number ] = (object)( HOSPITAL )->get_monster( type );
    monsters[ number ]->add_property( "start location", this_object() );
    this_object()->do_zoning( monsters[ number ] );
    monsters[ number ]->move( this_object() );
    announce_entry( monsters[ number ] );
  }
  number++;
  if ( number >= sizeof( monsters ) )
    return;
  
  if((int)HOSPITAL->ok_to_clone())
    call_out( "make_citymonster", 5 + random( 5 ), number );
} /* make_citymonster() */

void set_monster( mixed number, string word ) {
  if ( intp( number ) ) {
    crowd = ({ number });
  } else {
    crowd = number;
  }
  number = crowd[ 0 ];
  crowd += ({ number });
  if ( number > 3 ) {
    number = 3;
  }
  monsters = allocate( random( 1 + number ) );
  type = word;
} /* set_monster() */

void create() {
  crowd = ({ 0, 0 });
  type = "unknown";
  monsters = ({ });
  do_setup++;
  ::create();
  do_setup--;
  add_property( "room size", 20 );
  add_property( "room zone", ({ "Pumpkin" }) );
  add_extra_look( this_object() );
  if ( !do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }
} /* create() */

void reset() {
  if ( sizeof( monsters ) ) {
    call_out( "make_citymonster", 5 + random( 5 ), 0 );
  }
} /* reset() */

void dest_me() {
  ::dest_me();
} /* dest_me() */

int clean_up( int parent ) {
  if ( base_name( this_object() )[0..<3] == __FILE__) {
    return 0;
  }
  return ::clean_up( 0 );
} /* clean_up() */

mixed *stats() {
  return ::stats() + ({
    ({ "crowd", array_to_string( crowd[ 0 .. <2 ] ) }),
      });
} /* stats() */

int do_search( string words ) {
  object found;

  if ( query_property( "no scavenging" ) ) {
    return -1;
  }
  if ( this_player()->query_property( "dead" ) ) {
    return -1;
  }
  if ( words ) {
    if ( ( strsrch( words, "ground" ) == -1 ) &&
         ( strsrch( words, "crevice" ) == -1 ) &&
         ( strsrch( words, "pothole" ) == -1 ) &&
         ( strsrch( words, "gutter" ) == -1 ) &&
         ( strsrch( words, "cobble" ) == -1 ) ) {
      return -1;
    }
  }
  switch ( random( 21 ) ) {
  case 0 .. 6 :
    found = clone_object( "/obj/money" );
    if ( random( 80 ) ) {
      found->adjust_money( 1, "Pumpkin cent" );
    } else {
      if ( random( 80 ) ) {
        found->adjust_money( 1, "Pumpkin dollar" );
      } else {
        found->adjust_money( 10, "Pumpkin dollar" );
      }
    }
    break;
  case 7 .. 16 :
    if((time() - last_found) > random(360)) {
      found = (object)ARMOURY->choose_small_item();
      if(objectp(found)) {
        found->set_percentage(5 + random(30));
      } else {
        found = 0;
      }
      last_found = time();
    }
    break;
  case 17 .. 18 :
    if(sizeof(match_objects_for_existence("cockroach", this_object())) > 3) {
      return -1;
    }
    
    found = (object)HOSPITAL->get_monster( "cockroach" );
    found->move( this_object(), "$N scuttle$s out of "+
                 CREVICE +"." );
    return -1;
  case 19 :
    if(sizeof(match_objects_for_existence("rodent", this_object())) > 3) {
      return -1;
    }
    
    found = (object)HOSPITAL->get_monster( "rodent" );
    found->move( this_object(), "$N slink$s out of "+
                 CREVICE +"." );
    return -1;
  default :
    write( "You have a good look at the ground and spotting "
           "something, pick it up.  It's only a lump of rotting "
           "rubbish, though, which you throw away quickly.\n" );
    say( (string)this_player()->a_short() +" looks closely at "
         "the ground.  Seeing something, "+
         (string)this_player()->query_pronoun() +" picks it up, "
         "but finds that it's only a lump of rotting rubbish, so "+
         (string)this_player()->query_pronoun() +" throws it away.\n" );
    this_player()->add_effect( "/std/effects/other/rubbish_smell",
                               roll_MdN( 5, 60 ) );
    return 1;
  }
  if ( !found ) {
    return -1;
  }
  write( "You have a good look at the ground and scavenge "+
         (string)found->a_short() +" from "+ CREVICE +".\n" );
  say( (string)this_player()->a_short() +" looks closely at the ground.\n" );
  if ( (int)found->move( this_player() ) == MOVE_OK ) {
    write( "You pick it up.\n" );
    say( (string)this_player()->query_pronoun() +" picks something up.\n" );
  } else {
    write("Unfortunately you cannot pick it up and it disappears down "+
          CREVICE+".\n");
  }
  
  return 1;
} /* do_search() */

void add_monster( object old_thing, object new_thing ) {
  int i;

  i = member_array( old_thing, monsters );
  if ( i != -1 ) {
    monsters[ i ] = new_thing;
    return;
  }
  i = member_array( 0, monsters );
  if ( i != -1 ) {
    monsters[ i ] = new_thing;
    return;
  }
  monsters += ({ new_thing });
} /* add_monster() */

/* Temporary measure until NPCs clean up the streets themselves. */
void event_dest_me() {
  if ( find_call_out( "check_stuff" ) == -1 ) {
    call_out( "check_stuff", 30 );
  }
} /* event_dest_me() */

void check_stuff() {
  object thing, *things;

  things = all_inventory( this_object() );
  foreach( thing in things ) {
    if ( userp( thing ) ) {
      call_out( "check_stuff", 30 );
      return;
    }
    if ( living( thing ) || thing->query_corpse() ) {
      things -= ({ thing });
      continue;
    }
    if ( thing->do_not_sell() || !thing->query_value() ) {
      thing->move( "/room/rubbish" );
      things -= ({ thing });
      continue;
    }
  }
  if ( sizeof( things ) ) {
    things->move( "/d/am/filigree/general_store" );
  }
} /* check_stuff() */

int query_crowd_now() {
  return crowd[ ( (int)WEATHER->minute_number() *
                  sizeof( crowd ) - 720 ) / 1440 ];
} /* query_crowd_now() */

string extra_look( object thing ) {
  switch ( query_crowd_now() ) {
  case 0 :
    return "";
  case 1 :
    return "With few people about, this seems to be a quiet "
      "part of the city, perfect for getting mugged.\n";
  case 2 :
    return "A number of people pass by as they go about their "
      "lives (or in some cases, existences).\n";
  case 3 :
    return "Quite a few people, some in small groups, walk, "
      "trot and lurch along the street.\n";
  case 4 :
    return "This seems to be a busy part of the city, with "
      "many people hurrying to various destinations.\n";
  case 5 :
    return "All around you, crowds teem as Pumpkin moves "
      "turbulently through its hectic day.\n";
  case 6 :
    return "Crowds of people jostle you constantly, so keep "
      "an eye on your pockets...\n";
  default :
    return "The densely packed crowds make it difficult to "
      "move, and unpleasant to breathe.\n";
  }
} /* extra_look() */
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/inherit/cityroom.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/inherit/hospital.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/inherit/hospital.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627661   Available: 13575015
Inodes: Total: 5242880    Free: 4960133
19983 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/inherit/hospital.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627661   Available: 13575015
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * @main
 * This is the hospital inheritable for Counterweight Continent, it handles the 
 * creation of NPC's (and other nicities.)
 * <p>
 * The CWC hospital object works differently to many hospitals used in 
 * other domains, because it allows certain methods to be redefined and
 * the hospital "customized".  This allows different NPC zones and 
 * configurations, and even different logging options all based on the
 * same code.
 * <p>
 * @author Taffyd
 * @started December 3, 1998.
 * @index cwc_hospital
 */

#include <armoury.h>
#include <hospital.h>
#include "path.h"
#include HOSPITAL_INC

/* Comment this out if you want to disable hospital generation
   of NPC's through the new data compiler system. */    
#define CREATE_NPCS 1

#define REGEN_TIME 1 * 60 * 60
#define DEFAULT_LOG_DIRECTORY "/d/cwc/log"
#define DEFAULT_POPULATION 3
#define MINIMUM_DEATH_REGEN 3

inherit "/std/room";

class regenerated_npc {
    string type;
    string load_position;
}

protected void load_file();
protected void save_file();
protected void set_save_file(string new_save);
protected void restore_default_npcs();
protected void set_max_living(int new_living);
protected void set_hospital_type(string new_type);
protected object *make_monster(string type);
public object *get_monster(string type);
public void hospital_log_file(string file, string format, mixed *args ...);
public int get_item(object destination, string *items);
public string query_save_file();
public int query_max_living();
public int *query_npcs();
public mapping query_hospital_npcs();
public void add_npc_type(string type, string *data);
public void regen_after_death( object dead_npc );

private nosave string _save_file, _hospital_type;
private nosave int _max_living;
private nosave mixed *_regenerated_npcs;
private nosave int _hospital_call_id;
private nosave mapping _log_file_info;
private nosave string _hospital_log_directory;

public mapping _unique_npcs;
public mapping _hospital_npcs;

public int _last_npc_check, _zone_npcs;

private nosave mapping _npc_groups;
private nosave mapping _npc_info;

/** @ignore yes */
void create() {
    seteuid(master()->creator_file(file_name(this_object())));
    
    do_setup++;
    ::create();
    do_setup--;

    if (_save_file) {
        load_file();
    
        if (!_hospital_npcs) {
            restore_default_npcs();
        }
        
        if (!_unique_npcs) {
            _unique_npcs = ([ ]);    
        }               
        
        save_file();                
    }
    
    if (!_npc_groups)
        _npc_groups = ([ ]);
        
    if (!_npc_groups)
        _npc_info = ([ ]);

    _regenerated_npcs = ({ });
    _log_file_info = ([ ]);
    
    if (!do_setup) {
        set_short("Counterweight Continent Hospital");
        set_long("All around you NPC's wait in neat little lines, "
            "ready to be sent on a massive journey that will ultimately "
            "lead to their deaths.  Some of them stand by a small window "
            "in the far wall, looking out at freedom.\n");
        add_property("determinate", "the ");
        set_light(60);
    }
} /* create() */

/** 
 * This function provides an interface to the armoury, selecting 
 * an item at random from the 'items' array and attempting to
 * clone it.
 * <p>
 * Any items of jewellery, clothing, weapons, armour or scabbards
 * that are available in the armoury can be accessed using this 
 * function.
 * <p>
 * @param destination where to place the item that is fetched 
 * from the armoury.
 * @param items an array of items, of which one will be selected, 
 * cloned, and then moved to destination.
 * <p>
 * @see /obj/handlers/armoury
 * @return 1 if the item was successfully created, 0 if it was not.
 */
public int get_item(object destination, string *items) {
    int i;
    object item;
    
    if (!objectp(destination)) {        
        return 0;        
    }            
    
    while (!item) {
        i = random(sizeof(items));
        item = ARMOURY->request_item(items[i], 80 + random(21));
        
        if (!objectp(item)) {
            items = items[0..i-1] + items[i+1..];
            continue;
        }
        
        if (!sizeof(items)) {
            hospital_log_file("BROKEN_ITEMS", "Unable to select any items "
                "for %s in the CWC hospital.\n", previous_object()->short());
            break;            
        }
    }    

    if (objectp(item)) {
        item->move(destination);    
        return 1;
    }
    
    return 0;    
} /* get_item() */

/** @ignore yes */
protected void load_file() {
    if (file_size(_save_file + ".o") > -1) {
        unguarded((: restore_object, _save_file :));
    }
} /* load_file() */

/** @ignore yes */
protected void save_file() {
    unguarded((: save_object, _save_file :));
} /* save_file() */

/** 
 * This method is used to set the save file for the hospital.  This 
 * file is where all of the hospitals NPC data is stored while it is
 * not active and in between reboots.  
 * <p>
 * If this file does not exist when the hospital is loaded, then the 
 * variables will be initialised to their defaults and 
 * <b>restore_default_npcs()</b> called.
 * <p>
 * @param new_save the file name to save the hospital data in
 */
protected void set_save_file(string new_save) {
    _save_file = new_save;
} /* set_save_file() */

/** 
 * This returns the location where hospital data will be stored.
 */
public string query_save_file() {
    return _save_file;
} /* query_save_file() */

/** 
 * This method returns whether or not it is time to regenerate a
 * unique NPC. The regeneration time is controlled by the REGEN_TIME
 * #define.
 * <p>
 * @param who this is the name or object reference of the NPC which is trying 
 * to be cloned. Now that I think about it, having an object reference
 * is pretty useless but I'm sure there was a very good reason for it.
 * <p>
 * @return 1 if it is time to make the unique NPC, or 0 if it is not.
 */
public int make_unique(mixed who) {
    if (!_unique_npcs)
        return 0;
        
    if (objectp(who))    
        who = who->query_name();
        
    if ( _unique_npcs[who] > time() )
        return 0;        
        
    _unique_npcs[who] = time() + REGEN_TIME;
    save_file();
} /* make_unique() */

/** 
 * This method is used to query how long until it is time for the
 * NPC to regenerate.
 * <p>
 * @param who the name or object reference of the NPC to test.
 * @return the time at which this NPC will regenerate.
 */
public int query_regen_time(mixed who) {
    if (objectp(who))    
        who = who->query_name();
        
    if (!_unique_npcs)        
        return 0;
    
    return _unique_npcs[who];    
} /* query_regen_time() */

/** 
 * This sets the maximum number of NPC's to be cloned by the 
 * hospital.  If this is not set then no NPC's will ever be 
 * made by the hospital, and if it is too high then the streets
 * will be overflowing with NPC's. 
 * <p>
 * @param new_living the new maximum number of NPC's to clone
 * @see ok_to_clone()
 */
protected void set_max_living(int new_living) {
    _max_living = new_living;    
} /* set_max_living() */

/** 
 * @return the maximum number of NPC's that can be cloned by 
 * the hospital.
 * @see set_max_living()
 */
public int query_max_living() {
    return _max_living;
} /* query_max_living() */

/** 
 * This method is used to restore the hospital NPC's mapping if the 
 * save file cannot be restored.  This should be masked in localised
 * hospitals so that their unique region settings can be automatically
 * setup.
 * <p>
 * If this function is overloaded, then ::restore_default_npcs() should
 * not be called, otherwise they will be cleared.
 */
protected void restore_default_npcs() {
    _hospital_npcs = ([ ]);    
} /* restore_default_npcs() */

/** 
 * This method is used to determine whether or not it is ok to create 
 * a new NPC.  It calculates the number of NPC's that exist in the
 * area controlled by the hospital, and checks this against the maximum
 * number of living objects allowed in this area.
 * <p>
 * @see set_max_living()
 * @see /d/cwc/city_inherit
 */
public int ok_to_clone(string where) {   
    if (time() > _last_npc_check + 300) {
        _last_npc_check = time();
                
        _zone_npcs = sizeof(filter(named_livings(), (: environment($1) && 
            base_name(environment($1))[0..(sizeof(CWC) + sizeof($(where)) - 1)] == 
                (CWC + $(where)) :)));            
    }        

    return _zone_npcs < _max_living;
} /* ok_to_clone() */

/** 
 * This method is used to return statistical information about the hospital.
 * @return an array containing the number of NPC's in the zone, and the
 * time at which this number was last calculated.
 */
public int *query_npcs() {
    return ({ _zone_npcs, _last_npc_check });
} /* query_npcs() */

/**
 * This method can be used to add a new type of NPC to the hospital, or
 * to extend the NPC's in an existing zone.
 * <p>
 * @param type the zone in which the NPC's will be created
 * @param data an array of NPC's to create in the zone.
 */
public void add_npc_type(string type, string *data) {
    if (undefinedp(_hospital_npcs[type])) {
        _hospital_npcs[type] = copy(data);
    }
    else { 
        if (arrayp(_hospital_npcs[type])) {
            _hospital_npcs[type] += data;        
        }
    }
                    
    save_file();
} /* add_npc_type() */

/** 
 * This method returns all of the hospital zones and NPC data. It 
 * is fairly useless.
 * <p>
 * @return a mapping containing hospital zone and NPC data information.
 */ 
public mapping query_hospital_npcs() {
    return copy(_hospital_npcs);
} /* query_hospital_npcs() */

/** 
 * This method is used to create an NPC of a specific name or of a 
 * hospital type.
 * <p>
 * @param type the type of NPC to create. This can either be a specific
 * name (such as 'sailor') or a zone (such as 'docks'). Valid zones
 * must be defined in the hospital for this to work correctly.
 * @return the NPC's made by the hospital
 */
public object *get_monster(string type) {
    object *monsters, monster;

    if (_hospital_npcs[type]) {
        tell_creator("taffyd", "Attempting to create a %s NPC.\n", type);
        monsters = make_monster(_hospital_npcs[type][random(sizeof(_hospital_npcs[type]))]);
        tell_creator("taffyd", "Monsters are now %O.\n", monsters);
    }
    else {
        monsters = make_monster(type);
    }
    
    // Now do the stuff that is common for all npcs
    
    foreach (monster in monsters) {
        monster->add_property("monster_type", type);
        monster->add_effect("/std/effects/npc/i_died", 
            (: regen_after_death :) );
    }
    
    return monsters;
} /* get_monster() */

/**
 * This method is used to clone a monster. It is called by get_monster() and 
 * should be redefined in your localised hospital zone to add support for 
 * new monsters.
 * <p>
 * Note that if you to redefine this function, you do not need to call the
 * precursor. Otherwise your hospital will start producing 'hospital 
 * accidents'. (The default NPC for an unconfigured NPC).
 * <p>
 * @param type the type of NPC to generate.
 * @return the object reference of the NPC or NPC's made by the hospital.
 */
protected object *make_monster(string type) {
    object monster;
    
    monster = clone_object("/obj/monster");
    monster->set_name("failure");
    monster->set_short("hospital accident");
    monster->set_race("human");
    monster->set_guild("warrior");
    monster->set_level(1);           
                       
    return ({ monster });
} /* make_monster() */

/**
 * This method is called by the npc.death effect after an NPC that is handled
 * by the hospital has died. It tells the room where it was generated to 
 * make a new NPC and to all sorts of funky things.
 * <p>
 * This is not fully implemented yet.
 */
public void regen_after_death( object dead_npc ) {
    object *monsters, destination;
    class regenerated_npc new_npc;
    int i, max;
  
    if ( !dead_npc )
        return;
                
    _regenerated_npcs += ({ new( class regenerated_npc,
        type : dead_npc->query_property("monster_type"), 
        load_position : previous_object()->query_property("start location") ) });

    if ( !ok_to_clone(_hospital_type) || sizeof(_regenerated_npcs) < MINIMUM_DEATH_REGEN )
        return;

    new_npc = _regenerated_npcs[0];
    
    if ( !classp( new_npc ) )
        return;
        
    _regenerated_npcs = _regenerated_npcs[1..];

    if (!new_npc->load_position || !new_npc->type );
        return;
    
    max = random(5);

    for ( i = 0; i < max; i++ ){
        destination = find_object( new_npc->load_position );
        
        if ( !objectp( destination ) )
            return;

        monsters = get_monster(new_npc->type);
        destination->replace_monster(previous_object(), monsters);

        call_out((: $1->announce_entry($2) :), 8 + random(6), destination, 
            monsters);
    }
} /* regen_after_death() */

/**
 * This method is used to set the hospital type.  This is actually used to
 * set the geographical region that the hospital controls.
 * <p>
 * @example
 * // Only NPC's in /d/cwc/Bes_Pelargic will be managed by this hospital.
 * set_hospital_type("Bes_Pelargic");
 * @example
 * // Only NPC's in the Aarrgh forest will be managed by this hospital.
 * set_hospital_type("Forests/Aarrgh");
 * @param new_type the type and geographical region managed by this hospital
 */
protected void set_hospital_type(string new_type) {
    _hospital_type = new_type;
} /* set_hospital_type() */

/** 
 * This method provides log_file() functionality but for /d/cwc/log 
 * instead.  You should use this method to record errors and whatever 
 * that are domain specific instead of using log_file().
 * @example
 * hospital_log_file("BAD_HOSPITAL_NPC", "%s: Bad NPC hospital data, %O.\n", 
 * ctime(time()), _regenerated_npcs);
 * // This would log to /d/cwc/log/BAD_HOSPITAL_NPC.
 * @param file the file name to log to. This will have /d/cwc/log/ inserted 
 * before it.
 * @param format the text to log, can contain sprintf() format specifiers.
 * @param args the arguments for any sprintf format thingies
 */
public void hospital_log_file(string file, string format, mixed *args ...) {
    string filename;
    
    filename = _hospital_log_directory;
    
    /* We are restricted to logging in our domain, let's be neat about it. */
    
    if (file[0] == '/') {
        file = file[ strsrch( file, "/", -1 ) + 1 .. ];
    }
    
    /* Link to sefun */
    
    log_file( _hospital_log_directory + "/" + file, format, args ...);
} /* hospital_log_file() */

/** 
 * This method sets the directory in to which hospital_log_file will
 * log by default. If the directory does not exist, then it is set to
 * DEFAULT_LOG_DIRECTORY.
 * @param new_dir the directory to log to.
 * @example
 * set_log_directory( "/d/cwc/Bes_Pelargic/log" );
 * // log directory is now /d/cwc/Bes_Pelargic/log
 * @example
 * // (cre) MacChirton: ithinkmykeyboardisbroken
 * set_log_directory( "/d/cWc/BeS_pelarGic/lrg" );
 * // Displays: "/d/cwc/hospital/bes_pelargic: Invalid log 
 * // directory, defaulting to /d/cwc/log"
 */
protected void set_log_directory(string new_dir) {
    
    if (file_size(new_dir) != -2) {
        tell_creator( previous_object( 1 ), "%s: Invalid "
            "log directory -- defaulting to %s.\n",
            file_name( this_object() ), DEFAULT_LOG_DIRECTORY );
            
        new_dir = DEFAULT_LOG_DIRECTORY;
    }

    _hospital_log_directory = new_dir;
} /* set_log_directory() */

protected void set_npc_groups(mapping x) {
    _npc_groups = x;
} /* set_npc_groups() */

protected void set_npc_info(mapping x) {
    _npc_info = x;
} /* set_npc_info() */

public object data_get_npc(string npc_name) {
    class npc_info info;
    object npc;
    function func;
    
    if ( undefinedp(_npc_info[npc_name]) )
        return 0;
    
    info = _npc_info[npc_name];
    
    if (stringp(info->base))
        npc = clone_object(info->base);
    else
        return 0;
    
    if (arrayp(info->functions)) {
        foreach (func in info->functions) {
            evaluate(func, npc, previous_object());
        }
    }
    
    return npc;
} /* data_get_npc() */

object *data_get_group(string group_name) {
    class npc_group group;
    function func;
    int population, quantity, i;
    object *npcs, npc;
    
    if ( undefinedp(_npc_groups[group_name]) )
        return 0;
        
    group = _npc_groups[group_name];

    /* Determine the population from the class, if this is undefined
     * then we make set it to DEFAULT_POPULATION.
     */
         
    if (functionp(group->population))
        population = evaluate(group->population);
    else {
        population = DEFAULT_POPULATION;
    }

    if (!group->storage) {
        group->storage = ({ });
    }
    else {
        group->storage = filter(group->storage, (: objectp($1) :));
        
        /* 
         * If we have more NPC's than the population, then stop right now.
         */
        if (sizeof(group->storage) >= population)
            return 0;
    }
    
    if (functionp(group->quantity)) {
        quantity = evaluate(group->quantity);        
    }
    else {
        quantity = 1;
    }
    
    if (stringp(group->npc)) {
        npcs = allocate(quantity);
        
        for (i = 0; i < quantity; i++) {
            npcs[i] = data_get_npc(group->npc);
        }
        
        npcs = filter(npcs, (: objectp($1) :));
        group->storage += npcs;
    }
    
    foreach (npc in npcs) {
        if (arrayp(group->functions)) {
            foreach (func in group->functions) {
                evaluate(func, npc, previous_object());
            }
        }
        
    }
    
    return npcs;
} /* data_get_group() */

/*
 * I stole this function straight out of Jeremy's sur hospital.
 * It does weird and wonderful things.
 * <p>
 * This is a utility function for the rooms.  It's easier on the
 * programmer to make the weights non-cumulative, but it's inefficient
 * for the code.  The room can call this in setup() (or in a callout
 * if time is critical) to make the npc array cumulative.  Note that
 * the original array isn't modified.  This allows the original array to be
 * dynamically changed and recalculated.
 * <p>
 * @param a an array of NPC's to generate, in the format 
 * ({ ({ "name", chance }), ... })
 */
mixed accumulate_npc_array( mixed a ) {
    int cum, i;
    mixed choices;

    choices = copy(a);
    cum = 0;
    for (i = 0; i < sizeof(choices); i++) {
        cum += choices[i][0];
        choices[i][0] = cum;
    }
    return choices;
} /* accumulate_npc_array() */

/**
 * I stole this one as well.
 * <p>
 * This method randomly selects an NPC or a group of NPC's from 
 * the list of defined NPC's for the room/region.
 * @param choices if this is passed, then the array is used to 
 * select NPC's from.  This array must be a cumulative array. (see example)
 * @return an 
 * Returns a group of NPCs randomly selected.  "choices" is an array
 * of 2-element arrays giving the cumulative chance of the NPC group
 * and the group name, e.g.:
 * ({ ({ 5, "wolves" }), ({ 10, "trolls" }), ({ 20, "bandits" }) })
 * This would clone wolves 25% of the time, trolls 25% of the time, and
 * bandits 50% of the time.  If this is too confusing, see
 * accumulate_npc_array().
 */
varargs mixed get_random_npcs(mixed *choices) {
    int i;
    int chance;
    
    if (!choices)
        choices = previous_object()->query_npcs();

    if (!arrayp(choices) || !sizeof(choices))
        return 0;
    
    chance = random(choices[<1][0]);
       
    for (i = 0; i < sizeof( choices ); i++) {
        if ( choices[ i ][ 0 ] > chance ) {
            return data_get_group( choices[ i ][ 1 ]);        
        }
    }
    
    return 0;
} /* get_random_npcs() */
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/inherit/hospital.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/gumboot/gumboot2.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/gumboot/gumboot2.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627655   Available: 13575009
Inodes: Total: 5242880    Free: 4960133
336 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/gumboot/gumboot2.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627655   Available: 13575009
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h";

inherit CITYROOM;

void setup() {
  set_short("Gumboot Road");
  set_long("This is the middle of Gumboot Road\n");
  set_light( 80 );
  add_exit("north", GUMBOOT + "gumboot1", "road");
  add_exit("south", GUMBOOT + "gumboot3", "road");
  add_exit("west", PATH + "clothes_shop", "door");

  set_monster(1, "city");
}
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/gumboot/gumboot2.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/gumboot/gumboot5.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/gumboot/gumboot5.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627655   Available: 13575009
Inodes: Total: 5242880    Free: 4960133
319 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/gumboot/gumboot5.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627655   Available: 13575009
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h";

inherit CITYROOM;

void setup() {
  set_short("Gumboot Road");
  set_long("This is end of Gumboot Road at the edge of the city of Pumpkin.\n");
  set_light( 80 );
  add_exit("east", TERRAIN_HANDLER + ":0:1:0", "road");
  add_exit("north", GUMBOOT + "gumboot4", "road");

  set_monster(1, "city");
}
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/gumboot/gumboot5.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/gumboot/gumboot4.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/gumboot/gumboot4.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627655   Available: 13575009
Inodes: Total: 5242880    Free: 4960133
335 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/gumboot/gumboot4.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627655   Available: 13575009
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h";

inherit CITYROOM;

void setup() {
  set_short("Gumboot Road");
  set_long("This is the middle of Gumboot Road\n");
  set_light( 80 );
  add_exit("north", GUMBOOT + "gumboot3", "road");
  add_exit("south", GUMBOOT + "gumboot5", "road");
  add_exit("west", PATH + "weapon_shop", "door");

  set_monster(1, "city");
}
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/gumboot/gumboot4.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/gumboot/weapon_shop.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/gumboot/weapon_shop.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627655   Available: 13575009
Inodes: Total: 5242880    Free: 4960133
1222 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/gumboot/weapon_shop.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627655   Available: 13575009
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h"
inherit "/std/shops/item_shop";

void setup() {
   set_short("Pointy's Weapon Shop");
   set_long(
"Racks of weapons line the room, don't touch, they look sharp.\n");
   set_light(70);

   add_exit("east", PATH + "gumboot4", "door");

   add_object("morning star", 1 + random(20));
   add_object("black handled ceremonial bronze knife", 1 + random(20));
   add_object("carving knife", 1 + random(20));
   add_object("chisel", 1 + random(20));
   add_object("copper fighting knife", 1 + random(20));
   add_object("dagger", 1 + random(20));
   add_object("howondalandish throwing knife", 1 + random(20));
   add_object("klatchian steel dirk", 1 + random(20));
   add_object("knife", 1 + random(20));
   add_object("letter opener", 1 + random(20));
   add_object("meat cleaver", 1 + random(20));
   add_object("sharp butter knife", 1 + random(20));
   add_object("silver sickle", 1 + random(20));
   add_object("small copper knife", 1 + random(20));
   add_object("small knife", 1 + random(20));
   add_object("stiletto", 1 + random(20));
   add_object("tanto", 1 + random(20));
   add_object("white handled ceremonial bronze knife", 1 + random(20));


   add_property("place", "Pumpkin");
} /* setup() */
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/gumboot/weapon_shop.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/gumboot/gumboot1.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/gumboot/gumboot1.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627654   Available: 13575008
Inodes: Total: 5242880    Free: 4960133
318 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/gumboot/gumboot1.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627654   Available: 13575008
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h";

inherit CITYROOM;

void setup() {
  set_short("Gumboot Road");
  set_long("This is north end of Gumboot Road at the junction with Squash Square.\n");
  set_light( 80 );
  add_exit("north", SQUASH + "squash8", "road");
  add_exit("south", GUMBOOT + "gumboot2", "road");

  set_monster(1, "city");
}
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/gumboot/gumboot1.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/gumboot/gumboot3.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/gumboot/gumboot3.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627654   Available: 13575008
Inodes: Total: 5242880    Free: 4960133
335 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/gumboot/gumboot3.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627654   Available: 13575008
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h";

inherit CITYROOM;

void setup() {
  set_short("Gumboot Road");
  set_long("This is the middle of Gumboot Road\n");
  set_light( 80 );
  add_exit("north", GUMBOOT + "gumboot2", "road");
  add_exit("south", GUMBOOT + "gumboot4", "road");
  add_exit("east", PATH + "armour_shop", "door");

  set_monster(1, "city");
}
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/gumboot/gumboot3.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/gumboot/armour_shop.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/gumboot/armour_shop.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627654   Available: 13575008
Inodes: Total: 5242880    Free: 4960133
804 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/gumboot/armour_shop.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627654   Available: 13575008
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h"
inherit "/std/shops/item_shop";

void setup() {
   set_short("Smashers Armour Store");
   set_long(
"The room is filled with the smell of leather and oil, you can see racks "
"some suits of armour in various stages of being made around the store.\n");
   set_light(70);

   add_exit("west", PATH + "gumboot3", "door");

   add_object("brigandine armour", 1 + random(4));
   add_object("hardened leather breastplate", 1 + random(4));
   add_object("jazerant armour", 1 + random(2));
   add_object("leather boxer shorts", 1 + random(2));
   add_object("leather hat", 1 + random(2));
   add_object("leather jerkin", 1 + random(2));
   add_object("padded aketon", 1 + random(2));
   add_object("studded leather jerkin", 1 + random(2));

   add_property("place", "Pumpkin");
} /* setup() */
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/gumboot/armour_shop.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/gumboot/clothes_shop.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/gumboot/clothes_shop.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627653   Available: 13575007
Inodes: Total: 5242880    Free: 4960133
1528 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/gumboot/clothes_shop.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627653   Available: 13575007
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h"

inherit "/std/shops/item_shop";

void setup() {
   set_short("Squiggles Clothing Store");
   set_long(
"You are standing in a veritable forest of clothes, they hang off racks "
"and almost completely hide the floor.  Unfortunately they seem to be "
"reall limited in the type clothes they sell, obviously they belive in "
"volume rather than breadth of stock.\n");
   set_light(70);

   add_exit("east", PATH + "gumboot2", "door");

   add_object("green bathrobe", 1 + random(10));
   add_object("green cloak", 1 + random(10));
   add_object("green pants", 1 + random(10));
   add_object("green peaked hat", 1 + random(10));
   add_object("green silk sash", 1 + random(10));
   add_object("green wool shirt", 1 + random(10));
   add_object("white apron", 1 + random(10));
   add_object("white burnous", 1 + random(10));
   add_object("white cotton bodice", 1 + random(10));
   add_object("white cotton robe", 1 + random(10));
   add_object("white cotton shirt", 1 + random(10));
   add_object("white cotton toga", 1 + random(10));
   add_object("white cotton tunic", 1 + random(10));
   add_object("white linen tunic", 1 + random(10));
   add_object("white linen skirt", 1 + random(10));
   add_object("white short-sleeved shirt", 1 + random(10));
   add_object("white silk lace bodice", 1 + random(10));
   add_object("white silk pinafore", 1 + random(10));
   add_object("white silk sash", 1 + random(10));
   add_object("white socks", 1 + random(10));

   add_property("place", "Pumpkin");
} /* setup() */
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/gumboot/clothes_shop.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/plain/plain2.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/plain/plain2.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627653   Available: 13575007
Inodes: Total: 5242880    Free: 4960133
246 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/plain/plain2.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627653   Available: 13575007
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h";

inherit "/std/outsides/plain";

void setup() {
  set_short("Plains");
  set_long("This is the end of Plains\n");
  set_light( 80 );
  add_exit("east", PLAIN + "plain3", "road");
  add_exit("west", PLAIN + "plain1", "road");
}
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/plain/plain2.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/plain/plain10.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/plain/plain10.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627652   Available: 13575006
Inodes: Total: 5242880    Free: 4960133
248 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/plain/plain10.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627652   Available: 13575006
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h";

inherit "/std/outsides/desert";

void setup() {
  set_short("Forest");
  set_long("This is the end of Forest\n");
  set_light( 80 );
  add_exit("west", PLAIN + "plain9", "road");
  add_exit("north", PLAIN + "plain5", "road");
}
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/plain/plain10.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/plain/plain3.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/plain/plain3.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627652   Available: 13575006
Inodes: Total: 5242880    Free: 4960133
246 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/plain/plain3.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627652   Available: 13575006
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h";

inherit "/std/outsides/plain";

void setup() {
  set_short("Plains");
  set_long("This is the end of Plains\n");
  set_light( 80 );
  add_exit("east", PLAIN + "plain4", "road");
  add_exit("west", PLAIN + "plain2", "road");
}
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/plain/plain3.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/plain/plain1.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/plain/plain1.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627652   Available: 13575006
Inodes: Total: 5242880    Free: 4960133
272 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/plain/plain1.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627652   Available: 13575006
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h";

inherit "/std/outsides/plain";

void setup() {
  set_short("Plains");
  set_long("This is Plains at the junction with Rabbit Lane.
\n");
  set_light( 80 );
  add_exit("east", PLAIN + "plain2", "road");
  add_exit("west", RABBIT + "rabbit4", "road");
}
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/plain/plain1.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/plain/plain4.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/plain/plain4.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627651   Available: 13575005
Inodes: Total: 5242880    Free: 4960133
246 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/plain/plain4.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627651   Available: 13575005
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h";

inherit "/std/outsides/plain";

void setup() {
  set_short("Plains");
  set_long("This is the end of Plains\n");
  set_light( 80 );
  add_exit("east", PLAIN + "plain5", "road");
  add_exit("west", PLAIN + "plain3", "road");
}
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/plain/plain4.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/plain/plain5.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/plain/plain5.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627651   Available: 13575005
Inodes: Total: 5242880    Free: 4960133
265 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/plain/plain5.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627651   Available: 13575005
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h";

inherit "/std/outsides/plain";

void setup() {
  set_short("Plains");
  set_long("This is Plains at the junction with Woods.
\n");
  set_light( 80 );
  add_exit("west", PLAIN + "plain4", "road");
  add_exit("south", WOODS + "woods1", "road");
}
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/plain/plain5.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/desert/desert4.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/desert/desert4.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627651   Available: 13575005
Inodes: Total: 5242880    Free: 4960133
251 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/desert/desert4.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627651   Available: 13575005
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h";

inherit "/std/outsides/desert";

void setup() {
  set_short("Desert");
  set_long("This is the end of Desert\n");
  set_light( 80 );
  add_exit("east", DESERT + "desert5", "road");
  add_exit("west", DESERT + "desert3", "road");
}
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/desert/desert4.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/desert/desert5.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/desert/desert5.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627651   Available: 13575005
Inodes: Total: 5242880    Free: 4960133
251 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/desert/desert5.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627651   Available: 13575005
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h";

inherit "/std/outsides/desert";

void setup() {
  set_short("Desert");
  set_long("This is the end of Desert\n");
  set_light( 80 );
  add_exit("east", DESERT + "desert6", "road");
  add_exit("west", DESERT + "desert4", "road");
}
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/desert/desert5.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/desert/desert1.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/desert/desert1.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627650   Available: 13575004
Inodes: Total: 5242880    Free: 4960133
278 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/desert/desert1.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627650   Available: 13575004
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h";

inherit "/std/outsides/desert";

void setup() {
  set_short("Desert");
  set_long("This is Desert at the junction with Gumboot Road.
\n");
  set_light( 80 );
  add_exit("east", DESERT + "desert2", "road");
  add_exit("west", GUMBOOT + "gumboot5", "road");
}
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/desert/desert1.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/desert/desert8.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/desert/desert8.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627650   Available: 13575004
Inodes: Total: 5242880    Free: 4960133
251 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/desert/desert8.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627650   Available: 13575004
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h";

inherit "/std/outsides/desert";

void setup() {
  set_short("Desert");
  set_long("This is the end of Desert\n");
  set_light( 80 );
  add_exit("east", DESERT + "desert9", "road");
  add_exit("west", DESERT + "desert7", "road");
}
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/desert/desert8.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/desert/desert9.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/desert/desert9.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627650   Available: 13575004
Inodes: Total: 5242880    Free: 4960133
252 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/desert/desert9.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627650   Available: 13575004
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h";

inherit "/std/outsides/desert";

void setup() {
  set_short("Desert");
  set_long("This is the end of Desert\n");
  set_light( 80 );
  add_exit("east", DESERT + "desert10", "road");
  add_exit("west", DESERT + "desert8", "road");
}
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/desert/desert9.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/desert/desert6.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/desert/desert6.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627649   Available: 13575003
Inodes: Total: 5242880    Free: 4960133
251 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/desert/desert6.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627649   Available: 13575003
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h";

inherit "/std/outsides/desert";

void setup() {
  set_short("Desert");
  set_long("This is the end of Desert\n");
  set_light( 80 );
  add_exit("east", DESERT + "desert7", "road");
  add_exit("west", DESERT + "desert5", "road");
}
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/desert/desert6.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/desert/desert3.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/desert/desert3.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627648   Available: 13575002
Inodes: Total: 5242880    Free: 4960133
251 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/desert/desert3.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627648   Available: 13575002
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h";

inherit "/std/outsides/desert";

void setup() {
  set_short("Desert");
  set_long("This is the end of Desert\n");
  set_light( 80 );
  add_exit("east", DESERT + "desert4", "road");
  add_exit("west", DESERT + "desert2", "road");
}
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/desert/desert3.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/desert/desert10.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/desert/desert10.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627648   Available: 13575002
Inodes: Total: 5242880    Free: 4960133
268 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/desert/desert10.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627648   Available: 13575002
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h";

inherit "/std/outsides/desert";

void setup() {
  set_short("Desert");
  set_long("This is Desert at the junction with Woods.
\n");
  set_light( 80 );
  add_exit("west", DESERT + "desert9", "road");
  add_exit("north", WOODS + "woods5", "road");
}
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/desert/desert10.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/desert/desert7.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/desert/desert7.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627648   Available: 13575002
Inodes: Total: 5242880    Free: 4960133
251 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/desert/desert7.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627648   Available: 13575002
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h";

inherit "/std/outsides/desert";

void setup() {
  set_short("Desert");
  set_long("This is the end of Desert\n");
  set_light( 80 );
  add_exit("east", DESERT + "desert8", "road");
  add_exit("west", DESERT + "desert6", "road");
}
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/desert/desert7.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/desert/desert2.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/desert/desert2.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627648   Available: 13575002
Inodes: Total: 5242880    Free: 4960133
251 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/desert/desert2.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627648   Available: 13575002
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h";

inherit "/std/outsides/desert";

void setup() {
  set_short("Desert");
  set_long("This is the end of Desert\n");
  set_light( 80 );
  add_exit("east", DESERT + "desert3", "road");
  add_exit("west", DESERT + "desert1", "road");
}
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/desert/desert2.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/rabbit/rabbit4.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/rabbit/rabbit4.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627647   Available: 13575001
Inodes: Total: 5242880    Free: 4960133
341 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/rabbit/rabbit4.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627647   Available: 13575001
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h";

inherit CITYROOM;

void setup() {
  set_short("Rabbit Lane");
  set_long("This is end of Rabbit Lane at the exit of the city of Pumpkin.\n");
  set_light( 80 );
  add_exit("east", TERRAIN_HANDLER + ":0:18:0", "road");
  add_exit("west", RABBIT + "rabbit3", "road");
  add_exit("north", RABBIT + "potion_shop", "door");
}
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/rabbit/rabbit4.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/rabbit/rabbit3.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/rabbit/rabbit3.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627647   Available: 13575001
Inodes: Total: 5242880    Free: 4960133
308 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/rabbit/rabbit3.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627647   Available: 13575001
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h";

inherit CITYROOM;

void setup() {
  set_short("Rabbit Lane");
  set_long("This is the middle of Rabbit Lane\n");
  set_light( 80 );
  add_exit("east", RABBIT + "rabbit4", "road");
  add_exit("west", RABBIT + "rabbit2", "road");
  add_exit("north", RABBIT + "print_shop_foyer", "door");
}
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/rabbit/rabbit3.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/rabbit/bookshop.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/rabbit/bookshop.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627647   Available: 13575001
Inodes: Total: 5242880    Free: 4960133
541 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/rabbit/bookshop.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627647   Available: 13575001
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h"

inherit "/std/shops/book_shop";

void setup() {
   set_short("Bugs Bookstore");
   set_long(
"The distinctly carroty atmosphere of the store makes you feel like "
"saying 'Whats up doc?'\n");
   add_exit("south", RABBIT + "rabbit2", "door");
   set_light(70);

   set_cut(10);

   set_when_sold_function( (: $1->set_open_page(0) :) );
   set_allowed_to_sell( (: $1->query_book() || $1->query_paper() :) );
   set_minimum_cost(400);
   set_save_dir(SAVE + "bookshop");

   add_property("place", "Pumpkin");
} /* setup() */
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/rabbit/bookshop.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/rabbit/rabbit2.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/rabbit/rabbit2.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627646   Available: 13575000
Inodes: Total: 5242880    Free: 4960133
360 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/rabbit/rabbit2.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627646   Available: 13575000
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h";

inherit CITYROOM;

void setup() {
  set_short("Rabbit Lane");
  set_long("This is the middle of Rabbit Lane where a bunch of "
           "books and things seem to be.\n");
  set_light( 80 );
  add_exit("east", RABBIT + "rabbit3", "road");
  add_exit("west", RABBIT + "rabbit1", "road");
  add_exit("north", RABBIT + "bookshop", "door");
}
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/rabbit/rabbit2.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/rabbit/print_shop_office.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/rabbit/print_shop_office.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627646   Available: 13575000
Inodes: Total: 5242880    Free: 4960133
6585 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/rabbit/print_shop_office.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627646   Available: 13575000
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h"
#include <armoury.h>

inherit "/std/shops/print_shop";

nosave object goatberger;

int is_office_open(object *obs);

void setup() {
   set_light(70);
   set_room_size(5);
   set_short("print shop's office");
   add_property("determinate", "the ");
   set_long(
"A big impressive table dominates the room, contrasting sharply to the "
"bare undecorated walls and single bookcase on the back wall.  "
"The soft squooshy carpet covers the floor "
"in a soft cuddly way, licking up against the walls of the room.  "
"The room gives the impression of opulence by its starkness.\n");

   add_item("impressive table",
({ "long", "The table is almost bare except for a blotting pad and a nice "
"set of gold plated quills.  It is a deep shiny maroon colour "
"and the finish glistens softly in the light.  Nestled in behind the "
"table is a wonderful looking chair.",
"position", "the impressive table" }));
   add_item("chair",
({ "long", "The chair is one of those amazing office executive chairs.  "
"It has bits that wobble, bits that zip around and generally looks "
"pretty exciting.",
"position", "the chair" }) );
   add_item("gold plated quill",
"The gold plated quills rest on a quill holder on the table, slightly "
"askew from the blotting paper.  They look hardly used.");
   add_item("bare undecorated wall",
"The walls are bare and undecorated, but nicely finished with a "
"coat of some sort of timber varnish.\n");
   add_item( ({ "blotting paper", "blotting pad" }),
"The blotting paper is bright white, it looks like it has never seen "
"anything remotely resembling ink.  Scribbled just on the corner of "
"the wonderful white paper is a small note saying, 'Please note we can "
"\"print\" books and allow you to \"claim\" copyright here.'");
   add_item("quill holder",
"Resting on the hand engraved silver quill holder are two gold plated "
"quills.");
   add_item("soft squooshy carpet",
"The light brown carpet decorates the room perfectly, running from "
"wall to wall, gently fading into the floor and not being too obtrusive.");
   add_item("bookcase",
"It is sparsely populated with a couple of new looking leather bound "
"books.  They are titled 'Two nights in a closet', 'The Joye of Snacks' "
"and 'A few bedtime poems'.\n");
   add_item(({ "two nights in a closet", "book" }),
({ "long", "The red leather cover looks posh and gorgeous in your "
"hands.  You can see the title 'Two nights in a closet' etched "
"into the cover.\n"
"It appears to have something written on it.",
"read",
"This is a long winding book about a monster having to temporarily "
"relocate from a nice cellar in which it used to live.  The cellar "
"is undergoing refurbishment and is unavailable for monster "
"habitation, so it moved to a closet in a childs bedroom.  The "
"mother of the child refuses to believe that there is a monster "
"in the closet despite the loud protestations of the child.  The "
"monster peers out at the child every night, when it leaves it "
"eats the childs favorite toy and the mother eventually agrees "
"to look in the closet.  But it is empty.\n" }));
   add_item(({ "the joye of snacks", "book" }),
({ "long", "Wonderful bright red alluring cover with an interesting "
"picture of two people, naked, embracing in a shower with a "
"coffee table lurking in the foreground.  The caption 'Joye of "
"snacks' can be seen on the binder.\n"
"It appears to have something written on it.",
"read", "The first page has 'Demo copy only' written on it in "
"big black letters.  Sounds like a really interesting book though.\n" }) );
   add_item(({ "a few bedtime poems", "book" }),
({ "long", "The mate black cover of this book hardly even gleams at "
"all, the straight time Roman lettering saying 'A few bedtime poems "
"by a small colourful fish'.\n"
"It appears to have something written on it.",
"read",
"Strawberries\n"
"------------\n"
"\n"
"Starting from a above,\n"
"Working slowly down under.\n"
"Sliding up the sides\n"
"Eating a meal, fresh cream and syrup.\n"
"\n"
"Round and round, and round again\n"
"Grinning mischeviously\n"
"One tongue at play\n"
"Firm and hard, fresh strawberries today.\n"
"\n"
"\n"
"Flirting\n"
"--------\n"
"\n"
"A sidelong glance,\n"
"A funny remark!\n"
"Glittering eyes\n"
"Meeting in the dark.\n"
"\n"
"Fear of whats to come\n"
"Glad of what is here.\n"
"Hoping, wishing, believing\n"
"We will be as one.\n"
"\n"
"\n"
"Bewitched by the highlands\n"
"--------------------------\n"
 "\n"
"Scotland reminds me\n"
"Of heather and song\n"
"Of bagpipes and dancing\n"
"Never a witch\n"
 "\n"
"Then she bewitched me\n"
"Her eyes were brown\n"
"Her hair was like satin\n"
"Skin of pure honey\n"
 "\n"
"We talked for hours\n"
"Talking of the times\n"
"Strawberries and cream\n"
"Staring at her eyes\n"
 "\n"
"We laughed and sighed\n"
"Talked far and wide\n"
"Feeling a glow inside\n"
"Hands touching in my mind\n"
 "\n"
"Many more times we met\n"
"Laughed and had fun\n"
"Flirting with abandon\n"
"More happy than ever before\n"
 "\n"
"Now Scotland and witches\n"
"Are inextricably linked\n"
"With joy and happiness\n"
"In my dreams at night\n"
 }) );

   /* Make this just the office. */
   set_no_collection(1);
   set_open_func((: is_office_open($1) :));
   set_default_language("common");
   add_translation_cost("djelian", 130);
   set_save_dir("/d/am/save/printing/");

   add_exit("east", PATH + "print_shop_foyer", "door");

   add_property("place", "Pumpkin");
} /* setup() */

void reset() {
   if (!goatberger) {
      goatberger = clone_object("/obj/monster");
      goatberger->set_name("goatberger");
      goatberger->set_short("Mr. Goatberger");
      goatberger->set_long(
"He is smartly dressed in an expensive looking imported suit, a slight smile "
"just playing on his lips.  A gold fob watch peeks out of the lapels "
"of his suit.\n");
      goatberger->set_race("human");
      goatberger->set_level(10);
      goatberger->set_gender("male");
      goatberger->add_property("determinate", "");
      ARMOURY->request_item("white linen tunic", 90)->move(goatberger);
      ARMOURY->request_item("green pants", 90)->move(goatberger);
      goatberger->set_default_position( (: goatberger->do_command("sit on chair") :) );
      goatberger->do_command("equip");
      goatberger->move(this_object(), "$N arrives from the west.\n");
      goatberger->return_to_default_position(0);
   }
} /* reset() */

int is_office_open(object *obs) {
   if (!goatberger) {
      add_failed_mess("There is no one here to serve you.\n", obs);
      return 0;
   }
   return 1;
} /* is_office_open() */
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/rabbit/print_shop_office.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/rabbit/print_shop.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/rabbit/print_shop.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627644   Available: 13574998
Inodes: Total: 5242880    Free: 4960133
736 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/rabbit/print_shop.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627644   Available: 13574998
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h"

inherit "/std/shops/print_shop";

void setup() {
   set_short("Flopsies Print Shop");
   set_long(
"This place appears to have been made into a shrine for a rabbit, you "
"can see a small altar and carrot covered cloth on the counter.\n");
   add_item("counter", ({ "long", "The counter runs across the "
            "front of the room and there is a small altar set up "
            "on the edge of it.",
            "position", "the counter" }) );
   add_item("altar", ({ "long", "A nice altar with a little sign "
            "under it.",
            "read", "In memory of 'Mopsy'.\n" }) );
   set_light(70);

   add_exit("north", RABBIT + "rabbit3", "door");

   add_property("place", "Pumpkin");
} /* setup() */
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/rabbit/print_shop.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/rabbit/print_shop_foyer.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/rabbit/print_shop_foyer.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627644   Available: 13574998
Inodes: Total: 5242880    Free: 4960133
2358 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/rabbit/print_shop_foyer.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627644   Available: 13574998
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h"

inherit "/std/room/basic_room";

void setup() {
   set_light(70);
   set_room_size(5);
   set_short("print shop's foyer");
   add_property("determinate", "the ");
   set_long(
"A busy room full of people running around carrying trays full of moving "
"type and ink.  There is a coffee table in the middle of the chaos with "
"a chair sitting beside it.  To the west there is a door with a "
"brass plaque attached to it.\n");
   add_item("coffee table",
({ "long", "The coffee table is old and very coffee and tea stained, you are "
"not sure just how undisturbed you would be sitting at the table, the whole "
"place looks a little busy.",
"position", "the coffee table" }) );
   add_item("rickety chair",
({ "long", "The rickety chair sits beside the coffee table, it looks "
"pretty precarious about its role in life.  Sitting on it might be a "
"dangerous occupation.",
"position", "the rickety chair" }) );
   add_item("moving type",
"Lots of little letters placed in rows on boards, or heaped in buckets.  "
"They don't actually appear to move, but is hard to tell because no one "
"with them ever stops long enough for you to look.");
   add_item("ink",
"Large pots of ink, small pots of ink, ink!  All colours of ink, black, "
"red, green, although mostly black, are being carted around.  You are sure "
"there is a purpose to all the movement even if it is a little unclear.");
   add_item("people",
"They are all in a hurry, they look determined and stressed as if they "
"could never manage to get to whatever their destination is fast enough.  "
"Most of them do not appear to really know where their destination is, "
"they rush in and out of the room carrying the same items, look around "
"wildly and dash out again.");
   add_item("brass plaque",
({ "long", "It is a nice polished brass plaque on a surprisingly nice "
"looking door.\nIt appears to have something written on it.",
"read", "Office.\n" }) );

   add_exit("west", PATH + "print_shop_office", "door");
   add_exit("east", PATH + "print_shop_press", "corridor");
   add_exit("south", PATH + "rabbit3", "door");

   room_chat( ({ 120, 240, ({
       "Someone rushes into the room, looks around wildly and rushes back "
       "out again.",
         "You hear a CLANK, WHAM, HISS from the east",
    }) }) );

   add_property("place", "Pumpkin");
} /* setup() */
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/rabbit/print_shop_foyer.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/rabbit/potion_shop.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/rabbit/potion_shop.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627643   Available: 13574997
Inodes: Total: 5242880    Free: 4960133
354 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/rabbit/potion_shop.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627643   Available: 13574997
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h"

inherit "/std/shops/potion_shop";

void setup() {
   set_short("Carrot's Potion Store");
   set_long(
"This is a bright orange room with a green ceiling.\n");
   set_light(70);
 
   add_exit("south", RABBIT + "rabbit4", "door");

   set_save_dir(SAVE + "potions");
   set_cut(10);

   add_property("place", "Pumpkin");
} /* setup() */
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/rabbit/potion_shop.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/rabbit/rabbit1.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/rabbit/rabbit1.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627643   Available: 13574997
Inodes: Total: 5242880    Free: 4960133
272 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/rabbit/rabbit1.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627643   Available: 13574997
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h";

inherit CITYROOM;

void setup() {
  set_short("Rabbit Lane");
  set_long("This is Rabbit Lane at the junction with Squash Square.\n");
  set_light( 80 );
  add_exit("east", RABBIT + "rabbit2", "road");
  add_exit("west", SQUASH + "squash6", "road");
}
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/rabbit/rabbit1.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/rabbit/print_shop_binding.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/rabbit/print_shop_binding.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627643   Available: 13574997
Inodes: Total: 5242880    Free: 4960133
1956 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/rabbit/print_shop_binding.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627643   Available: 13574997
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h"
#include <armoury.h>

inherit "/std/shops/print_shop";

int is_room_open();

void setup() {
   set_light(70);
   set_room_size(5);
   set_short("print shop's binding room");
   add_property("determinate", "the ");
   set_long(
"Several tables are laid out in this room, people sit at the tables "
"placing the pages which come in from the printing press into the "
"final bound editions of the books.  This looks like the place where "
"the completed books are stored until taken away by their owners, judging "
"by the huge piles of books scattered around on the floor.\n");

   add_item("table",
({ "long", "Several tables house the equipment used to bind the books into "
"completed volumes are scattered around the room.  All the space not used by "
"the tables is covered in piles of completed, bound books.",
"position", "a binding table",
"position multiple", 1 }) );
   add_item(({ "edition", "volume", }),
"The uncompleted, or soon to be completed volumes of work are sitting "
"on the tables, when they get put on the ground they suddenly turn "
"into books.");
   add_item("people",
"They are binding the books, placing each page into (hopefully) the "
"correct place and creating a final, probably exact output.");
   add_item("book",
({ "long", "There are books all over the floor, in piles and stacks.  Some "
"of the stacks look a little precarious.",
"position", "a pile of books",
"position multiple", 1 }) );
   add_item("page",
"The pages are stacked up on the tables, somewhat neatly, beside the "
"workers as they place them into the bound copies.");

   add_exit("south", PATH + "print_shop_press", "corridor");

   /* Things to do with the print shop. */
   set_office_room(PATH + "print_shop_office");
   set_open_func((: is_room_open :));
   set_print_shop_name("Goatbergers printing shop, Pumpkin");

   add_property("place", "Pumpkin");
} /* setup() */

int is_room_open() {
   return 1;
} /* is_room_open() */
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/rabbit/print_shop_binding.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/rabbit/print_shop_press.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/rabbit/print_shop_press.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627642   Available: 13574996
Inodes: Total: 5242880    Free: 4960133
2821 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/rabbit/print_shop_press.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627642   Available: 13574996
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h"

inherit "/std/room/basic_room";

void setup() {
   set_light(70);
   set_room_size(5);
   set_short("print shop's machinery room");
   add_property("determinate", "the ");
   set_long(
"Big huge black machines, belching steam and exciting noises, completely cover "
"the floor of the room.  People scurry back and forth, carrying single "
"pages, bound books and trays of moving type.  The floor is covered in "
"spilled ink, both new and old, and little bits of metal, forgotten "
"bits of moving type and the odd rat.\n");

   add_item(({ "big huge black machine", "press", "machines" }),
"The machines are big presses that squish the moving type down onto "
"bits of paper which are then shuffled off to the binding department.  Steam "
"and unnecessary noise appear to be vital components of the printing "
"process.");
   add_item(({ "metal bit", "metal" }),
"There are a number of small bits of metal scattered over the floor, they "
"appear to be broken bits of moving type and things shaved off the "
"industriously working machines.");
   add_item("floor",
"The floor is covered in spilled ink, both new and old, and little bits of "
"metal,  forgotten bits of moving type and the odd rat.");
   add_item("people",
"There are people scurrying around in a hurry, moving pages from the "
"press into the binding room and swapping the moving type.  In a corner "
"there are a group of people arranging the type onto the trays from an "
"original book.");
   add_item("bound book",
"You have no idea why people would be walking around with bound books here, "
"especially since they seem to be reading the books and then blushing bright "
"red.  The title of the books appears to be 'The Joye of Snacks'.");
   add_item("spilled ink",
"The ink is all over the floor in a thick layer, caking everything in a "
"fine dust.");
   add_item("rat",
"The rat looks kind of, well very, covered in ink.  It sniffs around the "
"place industriously, perhaps it is a spy rat?");
   add_item("single page",
"The pages are single pages from books, they are not particularly ordered "
"from what you can tell.  You wonder how the books make it out alive.");
   add_item(({ "tray", "tray of moving type" }),
"Trays of moveable type to be inserted into the machines, they then print "
"the pages which get placed into the final book.");

   add_exit("west", PATH + "print_shop_foyer", "corridor");
   add_exit("north", PATH + "print_shop_binding", "corridor");

   room_chat( ({ 120, 240, ({
      "Someone reading a book blushes bright red and drops a tray of "
      "moving type.",
      "WHUMP!",
      "HISS!",
      "A machine clanks alarmingly.",
      "Someone wanders off with a bunch of pages to be bound to the binding "
      "room."
    }) }) );

   add_property("place", "Pumpkin");
} /* setup() */
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/rabbit/print_shop_press.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/money_symboliser.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/money_symboliser.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627641   Available: 13574995
Inodes: Total: 5242880    Free: 4960133
2417 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/money_symboliser.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627641   Available: 13574995
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: money.c,v 1.6 1998/12/02 07:27:55 pinkfish Exp $
 *
 * $Log: money.c,v $
 * Revision 1.6  1998/12/02 07:27:55  pinkfish
 * Make it handle -ve numbers.
 *
 * Revision 1.5  1998/09/10 19:46:51  pinkfish
 * Fix it up to handle the pence shortening as well.
 *
 * Revision 1.4  1998/08/18 23:12:06  pinkfish
 * Fix a spelling mistake.
 *
 * Revision 1.3  1998/08/18 20:08:16  pinkfish
 * Get it to handle a$ as well as just $
 *
 * Revision 1.2  1998/08/14 10:30:44  pinkfish
 * aAdd in code to turn a string back into a bvalue.
 *
 * Revision 1.1  1998/02/11 04:13:54  terano
 * Initial revision
 *
*/
/*
 * Symboliser for Pumpkin money.
 */

/**
 * This method turns a number into a string.  This is callec by the
 * money handler when it wants to create a nice string for the money
 * you have.
 * @param value the cost of the item to turn into a string
 * @return the value as a string
 * @see unsymbolise_string()
 * @see /obj/handlers/money_handler
 */
string symbolise_value( int value ) {
   int dollars;
   int pence;
   string s;

   if (value < 0) {
      s = "-";
      value = - value;
   } else {
      s = "";
   }
   dollars = value / 100;
   pence = ( value % 100 );
   if ( !pence ) {
      return "P$"+ s + dollars;
   }
   if ( !dollars ) {
      return s + pence +"p";
   }
   if ( pence < 10 ) {
      return "P$"+ s + dollars +".0"+ pence;
   }
   return "P$" + s + dollars + "." + pence;
} /* symbolise_value() */

/**
 * This method turns a string into a number.  This is called by the money
 * handler when it wishes to change a string into value.  This should
 * handle reversing the string, exactly as handled above.
 * @param str the string to turn into a value
 * @return the value, 0 if unable to decode
 * @see symbolise_value()
 * @see /obj/handlers/money_handler
 */
int unsymbolise_string( string str ) {
  int dollars;
  int pence;

  if (strlen(str) < 2) {
    return 0;
  }
  if (str[0] == '$' ||
      lower_case(str[0..1]) == "p$") {
     if (str[0] == 'p') {
       str = str[1..];
     }
     if (sscanf(str, "$%d.%d", dollars, pence) == 2) {
        return dollars * 100 + pence;
     } else if (sscanf(str, "$%d", dollars) == 1) {
        return dollars * 100;
     }
  } else if (lower_case(str[<1..<1]) == "p") {
     if (sscanf(str, "%dp", pence) == 1) {
       return pence;
     }
  }
  return 0;
} /* unsymbolise_string() */
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/money_symboliser.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/hospital.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/hospital.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627640   Available: 13574994
Inodes: Total: 5242880    Free: 4960133
15278 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/hospital.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627640   Available: 13574994
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: hospital.c,v 1.20 2000/01/30 06:26:43 terano Exp $
 *
*/

#include <armoury.h>
#include <hospital.h>
#include <living.h>
#include <map.h>
#include <money.h>
#include <move_failures.h>
#include <route.h>
#include <wander.h>
#include "path.h"

#define MAX_HEAVIES 10
#define DAY 8 * 60 * 60
#define INTERVAL 20 * 60                 /* a divisor of DAY */
#define MUD_TO_REAL 3
#define BLOCK 5
#define MAX_EMPTIES 12
#define MAX_MOVERS 60
#define SAVE_FILE SAVE +"hospital"

inherit "/std/room/basic_room";

nosave int alchemists, update, *alignments;
mapping uniques;
nosave int *al_data;
nosave string *city;
nosave object *empties;
nosave mapping blockages;
nosave mixed *movers;

// used for checking numbers of npcs
nosave int am_npcs, last_check;
int ok_to_clone();

void get_weapon(object ob, string *items);
void get_armour(object ob, string *items);
void get_jewellery(object ob, string *items);

void setup() {
   set_keep_room_loaded(1);
   update = time();
   alignments = allocate( 50 );
   uniques = ([ ]);
   if ( file_size( SAVE_FILE +".o" ) > 0 ) {
      unguarded( (: restore_object, SAVE_FILE :) );
   }
   alchemists++;
   unguarded( (: save_object, SAVE_FILE :) );
   city = ({
      "child", "rodent", "cockroach", "dog"
   });
   empties = ({ });
   blockages = ([ ]);
   movers = allocate( MAX_MOVERS );
   call_out( "check_movers", 10 );
   call_out( "housekeeping", INTERVAL );
} /* setup() */


int *query_al_data() { return al_data; }

mapping query_uniques() { return uniques; }

object *query_empties() { return empties; }

mapping query_blockages() { return blockages; }

int query_blockage( string this, string other, int number ) {
   if ( undefinedp( blockages[ this ] ) ) {
      if ( random( 100 ) >= BLOCK )
         number = -1;
      blockages[ this ] = blockages[ other ] = number;
   }
   return blockages[ this ];
} /* query_blockage() */

mixed *query_movers() { return movers; }

void housekeeping() {
   object thing;
   update = time();
   foreach( thing in users() ) {
/* ignore creators */
      if ( thing->query_creator() )
         continue;
/* sample alignments */
      alignments[ random( sizeof( alignments ) ) ] =
            (int)thing->query_al();
   }
   al_data = 0;
   unguarded( (: save_object, SAVE_FILE :) );
   call_out( "housekeeping", INTERVAL );
} /* housekeeping() */

int pick_al() {
   int one, *stats;
   if ( !al_data ) {
      al_data = allocate( 3 );
      stats = allocate( 4 );
      foreach( one in alignments ) {
         stats[ 0 ] += one;
         stats[ 1 ] += one * one;
         if ( one > stats[ 2 ] )
            stats[ 2 ] = one;
         if ( one < stats[ 3 ] )
            stats[ 3 ] = one;
      }
      stats[ 0 ] /= sizeof( alignments );
      stats[ 1 ] /= sizeof( alignments );
      stats[ 1 ] -= stats[ 0 ] * stats[ 0 ];
      stats[ 1 ] /= 10;
      if ( stats[ 1 ] < 50 )
         stats[ 1 ] = 50;
      stats[ 2 ] -= stats[ 3 ];
      if ( stats[ 2 ] < 2 )
         stats[ 2 ] = 2;
      al_data[ 0 ] = stats[ 0 ] - stats[ 2 ] / 2;
      al_data[ 1 ] = ( stats[ 2 ] * stats[ 2 ] ) / ( 12 * stats[ 1 ] );
      if ( al_data[ 1 ] < 5 )
         al_data[ 1 ] = 5;
      al_data[ 2 ] = ( 12 * stats[ 1 ] ) / stats[ 2 ];
      if ( al_data[ 2 ] < 25 )
         al_data[ 2 ] = 25;
   }
   return al_data[ 0 ] + roll_MdN( al_data[ 1 ], al_data[ 2 ] );
} /* pick_al() */

int make_unique( string word ) {
   if ( uniques[ word ] > time() )
      return 0;
/* Don't let them reappear for three hours. */
    uniques[ word ] = time() + 1 * 60 * 60;
   unguarded( (: save_object, SAVE_FILE :) );
   return 1;
} /* make_unique() */

void add_mover( object thing ) {
   int number;

   /* Fact Gathering Done by Terano */
   /* This generates WAY too much log traffic... the log wraps more then
      once an hour - Turrican.
   log_file("HOSPITAL_DATA", "Hospital: add_mover called with %O.\n", thing );
   */

   number = MAX_MOVERS / 2 + random( MAX_MOVERS / 2 );
   if ( !pointerp( movers[ number ] ) )
      movers[ number ] = ({ thing });
   else
      movers[ number ] += ({ thing });
} /* add_mover() */

object get_monster( string type ) {
   object thing;
   object ob;

   switch( type ) {
/* First the zones that there are: */
      case "city" :
      case "pumpkin" :
         thing = get_monster( city[ random( sizeof( city ) ) ] );
         thing->add_property( "monster type", type +":"+
               (string)thing->query_property( "monster type" ) );
         thing->add_move_zone( "Pumpkin" );
         add_mover( thing );
         return thing;
/* Now the specific types of NPC: */
      case "dog":
         thing = clone_object( CHARS + "dog" );
         if ( random( 4 ) )
            thing->set_type( "small" );
         else
            thing->set_type( "large" );
         thing->add_effect( "/std/effects/npc/i_died",
               ({ HOSPITAL, "regen_after_death" }));
         thing->add_effect( "/std/effects/npc/eat_edible" );
         thing->add_effect( "/std/effects/npc/savage_corpse" );
         thing->add_property( "monster type", type );
         thing->add_property("animal type", type);
         return thing;
      case "child":
         thing = clone_object( CHARS + "child_human" );
         return thing;
/* And now for all the nasty old ones... */
    case "cityguard":
      ob = clone_object(MONSTER);
      ob->add_property("monster type", type);
      ob->set_name("guard");
      ob->add_adjective("city");
      ob->set_main_plural( "city guards" );
      ob->set_short("city guard");
      ob->set_long("This is a city guard. He is supposed to protect the " +
        "city from undesirables. Sadly, Pumpkin isn't very fussy.\n");
      ob->set_race("human");
      ob->set_gender("male");
      ob->set_guild("fighter");
      ob->set_level(8);
      ob->set_al( pick_al() / 5 );
      ob->adjust_money( 5 + random( 10 ), "Pumpkin pence" );
      ob->load_chat(10, ({
          3, "@grumble bitterly",
          1, "@daydream",
          1, "@sigh heavily"
          }) );
      ob->load_a_chat(50, ({
          1, "'Ouch!",
          1, "'Come on! I don't need this.",
          1, "'Be on your way!",
          }) );
      ARMOURY->request_weapon("long sword", 40+random(40))->move(ob);
      if(random(2))
        ARMOURY->request_armour("hard leather cap", 70 + random(30))->move(ob);
      ob->init_equip();
      return ob;
    case "mercenary":
      ob = clone_object(MONSTER);
      ob->set_name("mercenary");
      ob->set_main_plural( "mercenaries" );
      ob->add_plural( "mercenaries" );
      ob->add_adjective("tough");
      ob->set_race("human");
      ob->set_class("fighter");
      ob->set_level( 50 + roll_MdN( 5, 50 ) );
      ob->set_al( pick_al() );
      ob->set_gender(random(2) + 1);
      ob->set_long("A tough battle scarred mercenary.  There are better "
                   "ways of filling in an afternoon than messing with the "
                   "likes of "+ob->query_objective()+".\n");
      ob->adjust_money( 5 + random( 50 ), "Ankh-Morpork pence" );
      ob->adjust_money( 1 + random( 5 ), "Ankh-Morpork dollar" );
      ob->load_chat(3, ({
        1, "'Anyone you don't like?",
        1, "'I'll do anything if the price is right?",
        1, "'Don't get me angry.  You won't like me when I'm angry."
      }));
      ob->load_a_chat(30, ({
        1, "'I'll show you who's boss.",
        1, "'You think you're so tough.",
        1, "The crowd runs in terror as the mercenary kills someone by "+
           "accident."
      }));
      get_weapon(ob, ({"bastard sword", "long sword", "morning star",
       "two-handed axe"}));
      get_armour(ob, ({"chainmail", "splintmail", "ringmail"}));
      ob->add_property("monster type", type);
      ob->init_equip();
      return ob;
    case "rodent":
      ob = clone_object(MONSTER);
      ob->set_name("rat");
      ob->set_short("rat");
      ob->set_race("rat");
      ob->set_level( random( 1 + random( 3 ) ) );
      ob->add_alias("city rat");
      ob->set_main_plural("rats");
      ob->add_adjective("dirty");
      ob->add_adjective("city");
      ob->set_long("This is a large rat.  It appears to have done well "+
       "living in the city.\n"+
       "The pollution must not affect it too much.\n" );
      ob->load_chat( 5, ({
         1, ":squeaks.",
         1, ":sniffs the air, whiskers twitching.",
         1, ":checks for dwarves."
      }) );
      ob->set_wimpy( 10 );
      ob->load_a_chat( 50, ({
         1, ":squeals in pain.",
         1, ":twitches fearfully."
      }) );
      ob->add_effect("/std/effects/npc/i_died",
                     ({ HOSPITAL, "regen_after_death" }));
      ob->add_effect( "/std/effects/npc/eat_edible" );
      ob->add_effect( "/std/effects/npc/savage_corpse" );
      ob->add_property("monster type", type);
      ob->add_property("animal type", type);
      return ob;
    case "cockroach":
      ob = clone_object(MONSTER);
      ob->set_name("cockroach");
      ob->set_short("cockroach");
      ob->set_race("cockroach");
      ob->set_level( random( 1 + random( 3 ) ) );
      ob->set_main_plural("cockroaches");
      ob->add_adjective("dirty");
      ob->add_alias("roach");
      ob->set_long( "This is a huge dirty great big cockroach, the size of "
             "your hand at least.  It waves its feelers at you and looks "
             "horrible and black.  Not only can cockroaches survive fires, "
             "plagues, earthquakes and miscellaneous acts of supernatural "
             "beings, they can survive in Ankh-Morpork!\n" );
      ob->load_chat( 5, ({
         10, ":scuttles around a bit.",
         10, ":cleans its feelers.",
         10, ":rushes around in circles.",
         1,  ":jerks off in a strange direction.",
      }) );
      ob->set_wimpy( 30 );
      ob->load_a_chat( 50, ({
         1, ":oozes horrible white stuff.",
         1, ":makes a sort of scraping noise."
      }) );
      ob->add_effect("/std/effects/npc/i_died", 
                      ({ HOSPITAL, "regen_after_death" }));
      ob->add_property("monster type", type);
      ob->add_property("animal type", type);
      return ob;
    default:
      ob = clone_object(MONSTER);
      ob->set_name("failure");
      ob->set_short("failure");
      ob->set_long( "Please inform a creator about this object.\n"+
          "Type is "+ type +" from "+ file_name( previous_object() ) +".\n" );
      ob->add_property( "monster type", "failure:"+ type );
      return ob;
  }
} /* get_monster() */

void get_armour(object ob, string *items) {
  ARMOURY->request_armour(items[random(sizeof(items))], 50+random(50))->
    move(ob);
} /* get_armour() */

void get_jewellery(object ob, string *items) {
  ARMOURY->request_armour(items[random(sizeof(items))], 20+random(80))->
    move(ob);
} /* get_jewellery() */

void get_weapon(object ob, string *items) {
  ARMOURY->request_weapon(items[random(sizeof(items))], 50+random(50))->
    move(ob);
} /* get_weapon() */

void regen_after_death(object player) {
  object ob, dest;
  string nam;

  if (!player)
    return ;
  nam = (string)player->query_property("monster type");
  dest = (object)player->query_property("start location");
  if ( !nam )
    return;
  if ( !dest )
    return;
  if(!ok_to_clone())
    return;
  
  ob = get_monster( explode( nam, ":" )[ 0 ] );
  dest->add_monster(player, ob);
  call_out("do_move", 10, ({ ob, dest }) );
} /* regen_after_death() */

void do_move(mixed *junk) {
  junk[0]->move(junk[1]);
} /* do_move() */

string change_to_name(object ob) {
  return implode((string *)ob->query_adjectives(), " ")+
         (string)ob->query_name();
} /* change_to_name() */

void do_run(object ob) {
  if (ob)
    ob -> run_away();
} /* do_run() */

void fight_check(object ob, object ob1) {
  if (ob->query_property(previous_object()->query_name()))
    previous_object()->attack_ob(ob1);
} /* fight_check() */

void do_grin_laugh(object ob) {
  ob->add_respond_to_with(({ "@grin", ob->query_name() }), 
                          "laugh man at $hname$");
} /* do_grin_laugh() */

void add_empty( object thing ) {
   empties -= ({ 0 });
   empties += ({ thing });
   if ( sizeof( empties ) > MAX_EMPTIES )
      empties = shuffle( empties )[ 0 .. MAX_EMPTIES - 1 ];
} /* add_empty() */

void move_monster( object thing ) {
   int i;
   string dest, direc, zone, *movez, *roomz;
   object place;

   /* Fact Gathering Done by Terano */
   /* See above comment - Turrican
   log_file("HOSPITAL_DATA", "Hospital: move_monster called with %O.\n", thing );
   */

   if ( !thing )
      return;
   if ( (int)thing->query_hp() < 0 )
      return;
   if ( thing->query_property( PASSED_OUT ) || thing->query_fighting() ) {
      add_mover( thing );
      return;
   }
   movez = (string *)thing->query_move_zones();
   empties -= ({ 0 });
   if ( sizeof( empties ) && !thing->check_anyone_here() )
      foreach ( place in empties ) {
         roomz = (string *)place->query_zones();
         if ( !sizeof( roomz ) ) {
            empties -= ({ place });
            continue;
         }
         foreach ( zone in roomz ) {
            i = member_array( zone, movez );
            if ( i != -1 )
               break;
         }
         if ( i == -1 )
            continue;
         thing->move( place );
         place->add_monster( 0, thing );
         place->announce_entry( thing );
         empties -= ({ place });
         add_mover( thing );
         return;
      }
   place = environment( thing );
   if ( !place )
      return;
   add_mover( thing );
   foreach ( direc in shuffle( (string *)place->query_direc() ) ) {
      place->set_destination( direc );
      dest = (string)place->query_destination( direc );
      if ( !stringp( dest ) )
         continue;
      if ( !thing->check_anyone_here() && !find_object( dest ) )
         continue;
      if ( find_object( dest ) )
         roomz = (string *)dest->query_zones();
      else
         roomz = (string *)MAP->query_zones( dest );
      if ( !sizeof( roomz ) )
         continue;
      foreach ( zone in roomz ) {
         i = member_array( zone, movez );
         if ( i != -1 )
            break;
      }
      if ( i == -1 )
         continue;
      if ( place->query_relative( direc ) )
         direc = (string)thing->find_rel( direc, 0 );
      if ( thing->do_command( direc ) )
         return;
   }
} /* move_monster() */

void check_movers() {
   int when;
   object thing, *things;

   /* Fact Gathering Done by Terano */


   things = movers[ 0 ];
   movers[ 0 .. MAX_MOVERS - 2 ] = movers[ 1 .. ];
   movers[ MAX_MOVERS - 1 ] = 0;
   call_out( "check_movers", 10 );
   if ( !pointerp( things ) )
      return;
   foreach ( thing in things ) {
      if ( objectp( thing ) ) {
         when += 2;
         call_out( "move_monster", when, thing );
      }
   }
} /* check_movers() */


// This function returns 1 if its ok to clone some more npcs and
// false if not.
int ok_to_clone() {
  if(time() > last_check + 300) {
    last_check = time();
    am_npcs = sizeof( filter( named_livings(),
      (: environment( $1 ) && base_name( environment( $1
       ) )[0..4] == "/d/am" :) ) );
  }
  return ( am_npcs < MAX_AM_LIVING );
}


int *query_npcs() {
  return ({ am_npcs, last_check });
}

// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/hospital.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/woods/woods1.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/woods/woods1.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627636   Available: 13574990
Inodes: Total: 5242880    Free: 4960133
268 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/woods/woods1.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627636   Available: 13574990
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h";

inherit "/std/outsides/woodland";

void setup() {
  set_short("Woods");
  set_long("This is Woods at the junction with Plains.
\n");
  set_light( 80 );
  add_exit("north", PLAIN + "plain5", "road");
  add_exit("south", WOODS + "woods2", "road");
}
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/woods/woods1.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/woods/woods4.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/woods/woods4.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627636   Available: 13574990
Inodes: Total: 5242880    Free: 4960133
249 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/woods/woods4.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627636   Available: 13574990
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h";

inherit "/std/outsides/woodland";

void setup() {
  set_short("Woods");
  set_long("This is the end of Woods\n");
  set_light( 80 );
  add_exit("north", WOODS + "woods3", "road");
  add_exit("south", WOODS + "woods5", "road");
}
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/woods/woods4.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/woods/woods3.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/woods/woods3.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627636   Available: 13574990
Inodes: Total: 5242880    Free: 4960133
249 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/woods/woods3.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627636   Available: 13574990
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h";

inherit "/std/outsides/woodland";

void setup() {
  set_short("Woods");
  set_long("This is the end of Woods\n");
  set_light( 80 );
  add_exit("north", WOODS + "woods2", "road");
  add_exit("south", WOODS + "woods4", "road");
}
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/woods/woods3.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/woods/woods5.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/woods/woods5.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627635   Available: 13574989
Inodes: Total: 5242880    Free: 4960133
271 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/woods/woods5.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627635   Available: 13574989
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h";

inherit "/std/outsides/woodland";

void setup() {
  set_short("Woods");
  set_long("This is Woods at the junction with Desert.
\n");
  set_light( 80 );
  add_exit("north", WOODS + "woods4", "road");
  add_exit("south", DESERT + "desert10", "road");
}
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/woods/woods5.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/woods/woods2.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/woods/woods2.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627635   Available: 13574989
Inodes: Total: 5242880    Free: 4960133
249 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/woods/woods2.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627635   Available: 13574989
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h";

inherit "/std/outsides/woodland";

void setup() {
  set_short("Woods");
  set_long("This is the end of Woods\n");
  set_light( 80 );
  add_exit("north", WOODS + "woods1", "road");
  add_exit("south", WOODS + "woods3", "road");
}
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/woods/woods2.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/hospital/hospital.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/hospital/hospital.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627635   Available: 13574989
Inodes: Total: 5242880    Free: 4960133
527 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/hospital/hospital.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627635   Available: 13574989
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h"

inherit CITY "inherit/hospital";

void create() {
   set_hospital_type("Pumpkin");
   set_save_file("/d/dist/dist/pumpkin_hospital");
   set_max_living(100);
   set_log_directory("/d/dist/log");

   do_setup++;
   ::create();
   do_setup--;

   
   if (!do_setup) {
      set_short("Pumpkin Hospital");
      set_light(60);
   }

   set_npc_groups(DATA->compile_data( ({ HOSPITAL_DIR "bes_pelargic_group" }) ));
   set_npc_info(DATA->compile_data( ({ HOSPITAL_DIR "bes_pelargic_info" }) ));
} /* create() */
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/hospital/hospital.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/squash/squash9.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/squash/squash9.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627635   Available: 13574989
Inodes: Total: 5242880    Free: 4960133
594 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/squash/squash9.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627635   Available: 13574989
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h";

inherit CITYROOM;

void setup() {
  set_short("south east corner of Squash Square");
  set_long("This is the south east corner Squash Square.\n");
  set_light( 80 );
  add_exit("west", SQUASH + "squash8", "road");
  add_exit("north", SQUASH + "squash6", "road");
  add_exit("northwest", SQUASH + "squash5", "hidden");
  add_exit("east", PATH + "beer_bar", "door");

  add_property( "los", "open" );

  set_linker(({ PATH + "squash8", PATH + "squash6", PATH + "squash5" }),
             "to a point", "", "Squash Square");

  set_zone("pumpkin");
  set_monster(1, "city");
}
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/squash/squash9.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/squash/squash6.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/squash/squash6.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627634   Available: 13574988
Inodes: Total: 5242880    Free: 4960133
774 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/squash/squash6.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627634   Available: 13574988
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h";

inherit CITYROOM;

void setup() {
  set_short("east edge of Squash Square");
  set_long("This is east side of Squash Square at the junction "
           "with Rabbit Lane.\n");
  set_light( 80 );
  add_exit("east", RABBIT + "rabbit1", "road");
  add_exit("west", SQUASH + "squash5", "road");
  add_exit("north", SQUASH + "squash3", "road");
  add_exit("south", SQUASH + "squash9", "road");
  add_exit("northwest", SQUASH + "squash2", "hidden");
  add_exit("southwest", SQUASH + "squash8", "hidden");

  add_property( "los", "open" );
  set_linker(({ PATH + "squash5", PATH + "squash3", PATH + "squash9",
                PATH + "squash2", PATH + "squahs8" }),
             "into", "", "Squash Square");

  set_zone("pumpkin");
  set_monster(1, "city");
}
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/squash/squash6.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/squash/squash4.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/squash/squash4.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627634   Available: 13574988
Inodes: Total: 5242880    Free: 4960133
789 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/squash/squash4.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627634   Available: 13574988
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h";

inherit CITYROOM;

void setup() {
  set_short("west edge of Squash Square");
  set_long("This is the west side of Squash Square at the junction "
           "with Fruitbat Avenue.\n");
  set_light( 80 );
  add_exit("east", SQUASH + "squash5", "road");
  add_exit("west", FRUITBAT + "fruitbat4", "road");
  add_exit("north", SQUASH + "squash1", "road");
  add_exit("south", SQUASH + "squash7", "road");
  add_exit("northeast", SQUASH + "squash2", "hidden");
  add_exit("southeast", SQUASH + "squash8", "hidden");

  add_property( "los", "open" );

  set_linker(({ PATH + "squash5", PATH + "squash1", PATH + "squash7",
                 PATH + "squash2", PATH + "squash8" }),
              "into", "", "Squash Square");

  set_zone("pumpkin");
  set_monster(1, "city");
}
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/squash/squash4.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/squash/squash1.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/squash/squash1.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627633   Available: 13574987
Inodes: Total: 5242880    Free: 4960133
548 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/squash/squash1.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627633   Available: 13574987
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h";

inherit CITYROOM;

void setup() {

  set_short("northwest corner of Squash Square");
  set_long("This is the north west corner of Squash Square\n");
  set_light( 80 );
  add_exit("east", SQUASH + "squash2", "road");
  add_exit("south", SQUASH + "squash4", "road");
  add_exit("southeast", SQUASH + "squash5", "hidden");

  add_property( "los", "open" );
  set_linker(({ PATH + "squash2", PATH + "squash4", PATH + "squash5" }),
             "to a point", "", "Squash Square");
  set_zone("pumpkin");

  set_monster(1, "city");
}
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/squash/squash1.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/squash/beer_bar.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/squash/beer_bar.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627633   Available: 13574987
Inodes: Total: 5242880    Free: 4960133
23351 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/squash/beer_bar.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627633   Available: 13574987
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h"
#include <armoury.h>
#include <shops/pub_shop.h>

inherit "/std/shops/pub_shop";

object *drunkards;
object bartender, barmaid;

int do_sit(string str);
int ref_to_serve(object player, int type);
void setup() {
   set_short("beer room");
   set_room_size(5);
   add_property( "place", "Pumpkin");
   set_light(60);
   set_theft_handler( HOSPITAL );
   set_zone("Flaming Cabbage");
   set_open_function( (: ref_to_serve :) );

   set_long("This is a beer bar.  Hence, all the bottles, signs and glasses "
      "are related to beer.  Maybe it could be possible to get something "
      "else, but most likely, beer (and of course the sort of healthy, "
      "nutritious food that goes along with beer) is all they sell here.  "
      "The customers, sitting on chairs around the tables, are all drinking "
      "beer and chatting merrily.  At one of the more secluded tables, "
      "some seedy-looking characters are whispering less merrily.  Of course, "
      "they too are enjoying a tasty beer.  A menu is tacked to the "
      "wall behind the counter.\n");

   add_item("floor", "The floor is sticky, and it seems like it'd be hard "
      "to walk out of here.  That could explain why some of the clientele "
      "here seem to have been drinking for days.");
   add_item("sign","There are a number of signs in this bar.  Most of "
      "them are tacky, sticky old cardboard signs pointing out the "
      "special benefits of drinking beer X or ale Y.");
   add_item("bottle","There are a vast amount of bottles on the wall "
      "behind the counter.  They all seem to be the same sort, and quite "
      "a few of them seem to be empty.  At least they catch the seedy "
      "light in a very pretty way.");
   add_item("glass","Beer glasses (the empty kind which are not overly dirty "
      "on the inside) are flooding the bar behind the counter.  Considering "
      "how empty, used glasses seem to disappear altogether, it is probably "
      "necessary to have quite a few glasses around."); 
   add_item(({"customer","clientele"}), "The people in here seem to be "
      "mainly concerned with the intake of beer.  They all look rather red "
      "around their noses and, for some reason, they all look rather "
      "happy.  All except those who wouldn't be caught dead doing something "
      "as silly as looking happy, of course.");
   add_item(({"seedy-looking character","character","corner"}), "In a "
      "corner of the bar, some people (who seem to melt in extraordinarily "
      "well into the dark shadows) are quietly drinking some beer, keeping "
      "a watchful eye on everything that happens");
   add_item(({"bar","counter"}), "The counter runs along one wall of the "
      "room.  All empty glasses put on it seem to disappear to some other "
      "dimension.  Only Dogbolter, the God of Empty Beer Pints, knows "
      "where that is.");
   add_item("wall", "The walls are sticky with dried in beer.  Somehow it "
      "has ended up on the walls, but there is nothing here to explain how.  "
      "On one of the walls there's a sign - it appears to be stuck there "
      "without the aid of a pin or anything...");
   add_item("ceiling", "The ceiling is sticky.  They must have had quite a "
      "party here recently.  Or maybe they had a party a long time ago and "
      "just haven't washed the ceiling since?");
   add_item( "wooden table", ({"long", "This is a rather nice wooden "
      "table.  At least it could be, somewhere underneath all that "
      "sticky beer.",
      "position","the wooden table"}));
   add_item( "small table", ({"long", "This table is made of wood, but a "
      "lot smaller than the other tables here.",
      "position","the small table"}));
   add_item( "sticky table", ({"long", "This large table is a lot stickier " 
      "than anything else in here, and that means it's pretty darn sticky!",
      "position","the sticky table"}));
   add_item( "old chair",
         ({ "long", "The chairs around the wooden table are old and worn.",
            "position","the wooden table"
         }) );   
   add_item( "small chair",
         ({ "long", "The chairs around the wooden table are old and worn.",
            "position","a chair at the wooden table"
         }) );   
   add_item("sticky beer", "It's just about everywhere.");

   add_menu_item("Spicy sausage", PUB_APPETISER, 396, "spicy sausage");
   add_menu_alias("sausage", "Spicy sausage");
   add_menu_item("Salad", PUB_MAINCOURSE, 796, "salad",
                 PUB_STD_SIDEPLATE);
   add_menu_item("Fish'n'chips", PUB_MAINCOURSE, 1196, "fish'n'chips",
                 PUB_STD_DINNERPLATE);
   add_menu_item("Ribs", PUB_MAINCOURSE, 1304, "ribs",
                 PUB_STD_DINNERPLATE);
   add_menu_item("Hot chicken sandwich", PUB_MAINCOURSE, 796, 
      "chicken sandwich");
   add_menu_alias("chicken sandwich", "Hot chicken sandwich");
   add_menu_item("Ham'n'cheese sandwich", PUB_MAINCOURSE, 796, "ham sandwich");
   add_menu_alias("ham sandwich", "Ham'n'cheese sandwich");
   add_menu_item("Unnameable liquid", PUB_ALCOHOL, 1704, "unnameable",
                 PUB_STD_PINT, 0, 1);
   add_menu_alias("unnameable", "Unnameable liquid");
   add_menu_item("CMOTD's Finest Brew", PUB_ALCOHOL, 1704, "finest brew",
                 PUB_STD_PINT, 0, 1);
   add_menu_alias("brew", "CMOTD's Finest Brew");
   add_menu_alias("cmotd", "CMOTD's Finest Brew");
   add_menu_item("Pumpkine Ale", PUB_ALCOHOL, 1838, "/obj/food/ale.food",
                 PUB_STD_PINT, 0, 1);
   add_menu_alias("ale", "Pumpkine Ale");
   add_menu_item("Troll Beer", PUB_ALCOHOL, 1838, "troll beer",
                 PUB_STD_PINT, 0, 3);
   add_menu_alias("beer", "Troll Beer");
   add_menu_item("Schlorg Beer", PUB_ALCOHOL, 1838, "schlorg beer",
                 "schlorg bottle", 0, 2);
   add_menu_alias("schlorg", "Schlorg Beer");

   add_exit("west", PATH + "squash9", "corridor");

} /* setup() */

object create_item( string word ) {
   object thing, thang;

   switch ( word ) {
 
   case "spicy sausage" :
      thing = clone_object( "/obj/food" );        
      thing->set_weight_per_bite(1);
      thing->set_name("sausage");
      thing->set_short("spicy sausage");
      thing->set_long( "The sausage, of a very questionable origin, seems "
         "to be designed to increase the thirst of whomever eats it.\n" );
      thing->set_value( 396 );
      thing->set_weight(5);
      /* thing->add_eat_effect( "SOMETHING THAT MAKES YOU THIRSTY", 120 ); *
       * so... I'd have to make a thirst effect :P */
      return thing;
   case "unnameable liquid" :
      thang = clone_object( "/obj/reagents/generic_liquid.ob" );
      thang->set_medium_alias("beer");          
      thang->set_name("unnameable");
      thang->set_short( "unnameable liquid" );
      thang->set_long( "This sludge is definitely better off without a "
           "name.  If someone was to try to give it a name, it'd have to be "
           "something along the lines of \"Stinking Mud\", \"Utterly "
           "Disgusting and Undrinkable Slush\" or maybe just \"Yuck!\".\n" );
      thang->add_eat_effect( "/std/effects/ingested/drunk", 40 );
      thang->add_eat_effect("/std/effects/ingested/nausea", 100);       
      thang->set_amount( 2000 );
      return thang;
   case "finest brew" :
      thang = clone_object( "/obj/reagents/generic_liquid.ob" );
      thang->set_name("brew");
      thang->set_medium_alias("beer");        
      thang->set_short( "CMOTD's Finest Brew" );
      thang->add_alias(({"finest brew","CMOTD's finest","CMOTD's brew"}));
      thang->set_long( "CMOT Dibbler has produced an amazing beer from "
           "Pumpkin, weird spices and possibly some more things.  Being "
           "Dibbler, he has of course made sure that the pint is rather "
           "a small one.\n" );
      thang->add_eat_effect( "/std/effects/ingested/drunk", 50 );
      thang->set_amount( 980 );
      return thang;
   case "troll beer" :
      thang = clone_object( "/obj/reagents/generic_liquid.ob" );
      thang->add_alias("beer");        
      thang->set_name("beer");
      thang->set_short("troll beer");
      thang->add_adjective("pint");
      thang->set_long("This is trollish beer.  You suspect a human "
            "shouldn't really be drinking this stuff.\n" );
      thang->add_alias( "trollbeer" );
      thang->add_adjective("troll");
      thang->add_eat_effect("/std/effects/ingested/drunk", 70);
      thang->set_amount( 2000 );
      return thang;
   case "schlorg" :
      /* the stuff that goes in the bottle */
      thang = clone_object( "/obj/reagents/generic_liquid.ob" );
      thang->set_name("schlorg");
      thang->set_short("Schlorg");
      thang->set_medium_alias("beer");
      thang->set_long("This beer must be \"forn\".  It has none of the "
           "characteristic muddiness that all beer brewed from Pumpkin water "
           "possesses.\n" );
      thang->add_eat_effect("/std/effects/ingested/drunk", 180);
      thang->set_amount(3900);
      thang->move(thing);
      thing->do_close();
      return thing;
      break;
   case "salad" :
      thing = clone_object( "/obj/food" );
      thing->set_name("salad");
      thing->add_property("food", 1);
      thing->set_short( "green salad" );
      thing->set_long( "This green salad is at least partially green, "
         "with interesting bits and thingies in it.\n" );
      thing->add_eat_effect("/std/effects/ingested/nausea", 10);        
      thing->set_value( 796 );
      thing->set_amount( 2000 );
      return thing;
   case "fish'n'chips" :
      thing = clone_object( "/obj/food" );
      thing->add_alias(({"fish","chips"}));
      thing->add_property("food", 1);          
      thing->set_name("cod");
      thing->set_short( "fish'n'chips" );
      thing->set_long( "It's hard to tell what is the fish and which of "
         "the small, sloppy pieces that are supposed to be the chips.  "
         "They all taste the same anyway.\n" );
      thing->add_eat_effect("/std/effects/ingested/nausea", 10);        
      thing->set_value( 1196 );
      thing->set_amount( 2000 );
      return thing;
   case "ribs" :
      thing = clone_object( "/obj/food" );
      thing->set_name("ribs");
      thing->add_property("food", 1);
      thing->set_short( "ribs" );
      thing->set_main_plural("ribs");
      thing->set_long( "These are ribs.  What animal(s) they come from is "
         "not of any interest, rest assured...  They are quite a lot smaller "
         "than the Real Pork Ribs that you can get in the posh restaurants "
         "in any case.\n" );
      thing->set_value( 1304 );
      thing->set_amount( 2000 );
      return thing;
   case "chicken sandwich" :
      thing = clone_object( "/obj/food" );
      thing->add_alias("sandwich");          
      thing->add_property("food", 1);
      thing->set_name("chicken");
      thing->set_short( "hot chicken sandwich" );
      thing->set_long( "The chicken on this sandwich is of the green sort.  "
         "It smells funny, moves funny and even sounds a bit funny.  The "
         "only nice thing to say about this sandwich is that it is indeed "
         "hot.  It should probably be eaten with caution, though.\n" );
      thing->add_eat_effect("/std/effects/ingested/nausea", 40);        
      thing->set_value( 796 );
      thing->set_amount( 2000 );
      return thing;
   case "ham sandwich" :
      thing = clone_object( "/obj/food" );
      thing->add_alias("sandwich");
      thing->add_property("food", 1);
      thing->set_name("ham");
      thing->set_short( "ham'n'cheese sandwich" );
      thing->set_long( "This sandwich has some ham and some cheese on it, "
         "which is why it is called a ham and cheese sandwich.  It has been "
         "baked in an oven.  A long time ago.  It is rather cold an clammy "
         "now.\n" );
      thing->set_value( 796 );
      thing->set_amount( 2000 );
      return thing;
   }

} /* create_object() */

object create_container(string name) {
   object thing;

   switch (name) {
   case "schlorg" :
     /* the bottle */
      thing = clone_object( "/obj/bottle" );
      thing->make_bottle("green", 1000);
      thing->set_value(1596);
      thing->set_long( (string)thing->query_long() + "This bottle has a "
               "slightly odd-looking porcelain cap, and no label at all, "
               "in the ordinary fashion of Schlorg-bottles discwide.\n");
      return thing;
   }
} /* create_container() */

void reset() {
   int i, j, x, y, z;

   string *kinds = ({"jolly","burly","fat","happy","drunk","very drunk", 
      "silly"});

   j = 5 + random(2);

   if (sizeof(drunkards) < 3) {
      drunkards = allocate(j);
   }
   for (i=0;i<(sizeof(drunkards));i++) {
      if (!drunkards[i]) {
         x = random(sizeof(kinds));
         y = random(4);
         drunkards[i] = clone_object("/obj/monster");
         drunkards[i]->set_name("drunkard");
         drunkards[i]->add_alias(kinds[x]+"drunkard");
         drunkards[i]->add_alias(kinds[x]+" drunkard");
         drunkards[i]->add_property("emote",1);
         drunkards[i]->add_move_zone("Flaming Cabbage");
         drunkards[i]->set_short(kinds[x]+" drunkard");
         drunkards[i]->set_main_plural(kinds[x]+" drunkards");
         drunkards[i]->add_plural("drunkards");
         drunkards[i]->add_plural(kinds[x]+" drunkards");
         drunkards[i]->set_gender(1+random(1));

         drunkards[i]->set_long("This "+kinds[x]+" drunkard seems very "
            "content with sitting here, chugging down beer after beer.  Who "
            "can blame " + drunkards[i]->query_objective() + ", really?\n");

         drunkards[i]->set_race("human");
         drunkards[i]->set_al(-300 + random(600));
         drunkards[i]->set_guild("fighters");
         drunkards[i]->set_class("fighter");
         drunkards[i]->adjust_con(10);
         drunkards[i]->adjust_str(5);
         drunkards[i]->adjust_dex(-1);
         drunkards[i]->set_level(75 + random(25));
         drunkards[i]->add_skill_level( "other.health", 50 );
         drunkards[i]->add_skill_level("fighting.combat.melee",
                                       20+random(20));
         drunkards[i]->add_skill_level("fighting.combat.special",30);
         drunkards[i]->adjust_money(0 + random(1),"Pumpkin dollar");
         drunkards[i]->adjust_money(10+ random(20),"Pumpkin pence");
         switch(y) {
            case 0:
            ((object)ARMOURY->request_item("dagger",30 +
                    random(30)))->move(drunkards[i]);
/*
            ((object)ARMOURY->request_item("cloth robe",30 +
                    random(30)))->move(drunkards[i]);
 */
            drunkards[i]->init_equip();
            drunkards[i]->do_command("tactics response parry");
            drunkards[i]->add_skill_level("fighting.combat.parry.held",
                                          50+random(100));
            break;
            case 1:
               ((object)ARMOURY->request_item("knife",70 +
                                              random(20)))->move(drunkards[i]);
               ((object)ARMOURY->request_item("green pants",70 +
                                              random(20)))->move(drunkards[i]);
               drunkards[i]->init_equip();
               drunkards[i]->do_command("tactics response parry");
               drunkards[i]->add_skill_level("fighting.combat.parry.held",
                                             50+random(20));
               break;
            default:
               ((object)ARMOURY->request_item("knife",30 +
                                           random(30)))->move(drunkards[i]);
               ((object)ARMOURY->request_item("green pants",70 +
                                              random(20)))->move(drunkards[i]);
               drunkards[i]->init_equip();
               drunkards[i]->add_property("emote", 1);
               drunkards[i]->do_command("tactics response parry");
               drunkards[i]->add_skill_level("fighting.combat.parry.held",
                                             20+random(20));
               drunkards[i]->load_chat(2,({
                  1, "'I need another beer.",
                  1, "'Bring me some beer, will you?",
                  1, "'I jolly well need beer!  Hurry up!"
                    }));
         }
         drunkards[i]->move("/room/void");
         y = random(4);
         z = 40 + random(90);
         call_out("make_drunk", z, drunkards[i], y, kinds[x]);
      }
   }
   if (!bartender) {
      bartender = clone_object( "/obj/monster" );
      bartender->set_name("bartender");
      bartender->set_short("sympathetic bartender");
      bartender->add_property("determinate","a ");
      bartender->set_long("This bartender looks just like you would "
         "expect in a place like this.  He has a huge red beard and seems "
         "to be laughing and smiling in a friendly manner at everyone all "
         "the time.\n");
      bartender->set_race("human");
      bartender->set_gender( 1 );
      bartender->set_al( -350 );
      bartender->set_class("fighter");
      bartender->set_level(100);
      bartender->do_command("tactics attitude offensive");
      bartender->do_command("tactics response parry");
      bartender->adjust_con(6);
      bartender->adjust_str(6);
      bartender->adjust_dex(3);
      bartender->add_skill_level( "other.health",55);
      bartender->add_skill_level("fighting.combat.melee.sharp",100);
      bartender->add_skill_level("fighting.combat.special",50); 
      ((object)ARMOURY->request_item("dagger",100))->move(bartender);
      ((object)ARMOURY->request_item("dagger",85))->move(bartender);
      ((object)ARMOURY->request_item("leather undershirt",80))->
         move(bartender);
      ((object)ARMOURY->request_item("leather breeches",80))->move(bartender);
      ((object)ARMOURY->request_item("white apron",80))->move(bartender);
      bartender->add_respond_to_with( ({({"@spank"}),"bartender"}),
         "thank $hname$ profusely");
      bartender->load_chat(25,({
                  1, ":brings some beer out to his thirsty customers.",
                  1, "@wink barmaid",
                  1, "@beam brightly",
                  1, "@hum",
                  1, "@laugh",
                  1, ":laughs pleasantly.",
                  1, "'Well, well - what have we here?",
                  1, "'Bring you another beer, shall I?"
                    }));
      bartender->init_equip();
      
      barmaid = clone_object( "/obj/monster" );
      barmaid->set_name("barmaid");
      barmaid->set_short("lovely barmaid");
      barmaid->set_long("This barmaid looks happy with her work.  She smiles "
         "a lot and has a noticeable tendency to flutter her eye-lashes at "
         "the bartender.\n");
      barmaid->set_race("human");
      barmaid->set_class("fighter");
      barmaid->set_level(50);
      barmaid->set_gender(2);
      ((object)ARMOURY->request_item("white linen skirt",80))->move(barmaid);
      ((object)ARMOURY->request_item("white apron",80))->move(barmaid);
      barmaid->init_equip();

      call_out("make_bart", 20, bartender, barmaid);
   }

} /* reset */

void make_drunk(object ob, int y, string str) {

   int a = random(2);
   string adj, adv;

   adv = ({ "not at all", "very", "quite", "extremely", "rather" })
     [ random(5) ];

   ob->move(this_object(), "A "+  str + " drunkard comes in, looking " + adv +
          " thirsty.");
   
   switch (y) {
   case 0:
      adj = "small";
      break;
   case 1:
   case 2:
      adj = "wooden";
      break;
   case 3:
      adj = "sticky";
      break;
   }

   if (a)
      ob->do_command("sit at "+adj+" table");

   y = 5 + random(50);
   call_out("buy_new", y, ob);

} /* make_drunk() */

void make_bart(object ob, object obette) {
   ob->move(this_object(), "The bartender pops up from behind the counter "
          "with a wide grin on his face.");
   call_out("make_barm", 5, obette);
} /* make_bart() */

void make_barm(object ob) {
   ob->move(this_object(), "The barmaid appears from behind the counter and "
          "tries to look innocent.  She desperately tries to sort out her "
          "hair which is a bit unordered.");
} /* make_barm() */

void buy_new(object ob) {
   int tim;

   if (!undefinedp(ob)) {
      if (environment(ob) == this_object()) {
         int z;
         string beer;
         beer = ({ "troll beer", "brew", "brew", 
                      "unnameable liquid" })[ random(4) ];
         ob->adjust_money(5, "Pumpkin dollar");
         ob->do_command("buy " + beer );
         ob->do_command("hold glass in left hand");
         z = 120 + random(120);
         //
         // Make them take a sip every ten seconds or so...
         /* No! Way too spammy! I'll go for > 30 seconds though... *
          *  Danbala, feb 2000                                     */
         //
         tim = 20 + random(20);
         while (tim < z) {
            call_out("sip_beer", tim, ob);
            tim += 30 + random(20);
         }
         call_out("drink_beer", z, ob);
      }
   }
} /* buy_new() */

void sip_beer(object ob) {
   if (ob &&
       environment(ob) == this_object()) {
      ob->do_command("drink 1/3rd of glass");
   }
} /* sip_beer() */

void drink_beer(object ob) {
   if (!undefinedp(ob)) {
      ob->do_command("drink glass");
      ob->do_command("'Ha!  Nice beer, this.");
      call_out("no_litter",3,ob);
   }
} /* drink_beer() */

void no_litter(object ob) {         
   object pint, *obinv;
   int z;
   int a = random(2);

   if (!ob) {
      return ;
   } 
   obinv = deep_inventory(ob); 
   if (sizeof(obinv)) {
      foreach( pint in obinv ) {
	 if (pint->query_max_volume()) {
            switch (a) {
            case 0:
               ob->do_command("'Ah.  An empty pint.  Now what would I "
                       "want that for?");
               break;
            case 1:
               ob->do_command("'Bugger.  It's all empty.  Now I'm sad.");
               break;
            case 2:
               ob->do_command("'No more beer.  What has the world come to?");
               break;
	    }
            ob->do_command("put " + pint->query_name() + " on counter");
         }
      }
   }
   if (a) {
      z = 120 + random(240);
      call_out("buy_new", z, ob);
   } else {
      ob->do_command("north");
   }
} /* no_litter() */

int ref_to_serve(object player, int type) {
   int clock, servtime; 

   clock = (time()%(3600*24)); 

   servtime = ((clock > 35000) && (clock < 60000)); 

   /* Because we all know pubs don't really serve food when they say     *
    * they should, but at other mysterious times, when noone wants food  *
    * anyway.                                                            */

   if((!servtime) && (type == PUB_MAINCOURSE)) { 
      add_failed_mess("Unfortunately, this pub doesn't serve food at the "
         "moment.  Try to change your order, please.\n"); 
      return 2; 
   } 
} /* ref_to_serve() */ 

void event_enter(object ob, string str, object from) {

   if (ob->query_name() == "drunkard") {
      if( sizeof( match_objects_for_existence( "pint", ob ))) {
         ob->do_command("'Time for another beer for me.");
         call_out("buy_new",5 + random(50),ob);
      }
   }  
} /* event_enter() */
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/squash/beer_bar.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/squash/squash5.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/squash/squash5.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627627   Available: 13574981
Inodes: Total: 5242880    Free: 4960133
947 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/squash/squash5.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627627   Available: 13574981
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h"; 
inherit CITYROOM;

void setup() {
  set_short("in the middle of Squash Square");
  set_long("This is the middle of Squash Square\n");
  set_light( 80 );
  add_exit("east", SQUASH + "squash6", "road");
  add_exit("west", SQUASH + "squash4", "road");
  add_exit("north", SQUASH + "squash2", "road");
  add_exit("south", SQUASH + "squash8", "road");
  add_exit("northeast", SQUASH + "squash3", "hidden");
  add_exit("northwest", SQUASH + "squash1", "hidden");
  add_exit("southeast", SQUASH + "squash9", "hidden");
  add_exit("northwest", SQUASH + "squash7", "hidden");

  add_property( "los", "open" );
  set_linker(({ PATH + "squash6", PATH + "squash4", PATH + "squash2",
                PATH + "squash8", PATH + "squash3", PATH + "squash1",
                PATH + "squash9", PATH + "squash7" }),
             "to a point", "", "Squash Square");

  set_monster(1, "city");

  set_zone("pumpkin");
  set_co_ord(({ 0, 0, 0 }));
}
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/squash/squash5.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/squash/squash8.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/squash/squash8.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627627   Available: 13574981
Inodes: Total: 5242880    Free: 4960133
781 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/squash/squash8.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627627   Available: 13574981
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h";

inherit CITYROOM;

void setup() {
  set_short("south edge of Squash Square");
  set_long("This is south side of Squash Square at the "
           "junction with Gumboot Road.\n");
  set_light( 80 );
  add_exit("east", SQUASH + "squash9", "road");
  add_exit("west", SQUASH + "squash7", "road");
  add_exit("north", SQUASH + "squash5", "road");
  add_exit("south", GUMBOOT + "gumboot1", "road");
  add_exit("northwest", SQUASH + "squash4", "hidden");
  add_exit("northeast", SQUASH + "squash6", "hidden");

  add_property( "los", "open" );
  set_linker( ({ PATH + "squash9", PATH + "squash7", PATH + "squash5",
                 PATH + "squash4", PATH + "squash6" }),
             "into", "", "Squash Square");

  set_zone("pumpkin");
  set_monster(1, "city");
}
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/squash/squash8.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/squash/squash2.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/squash/squash2.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627625   Available: 13574979
Inodes: Total: 5242880    Free: 4960133
744 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/squash/squash2.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627625   Available: 13574979
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h";

inherit CITYROOM;

void setup() {
  set_short("north edge of Squash Square");
  set_long("This is the north of Squash Square at the "
           "junction with Pumpkin Way.\n");
  set_light( 80 );
  add_exit("east", SQUASH + "squash3", "road");
  add_exit("west", SQUASH + "squash1", "road");
  add_exit("north", PUMPKIN + "pumpkin6", "road");
  add_exit("south", SQUASH + "squash5", "road");
  add_exit("southwest", SQUASH + "squash4", "hidden");
  add_exit("southeast", SQUASH + "squash6", "hidden");

  set_linker(({ PATH + "squash3", PATH + "squash1", PATH + "squash5",
                PATH + "squash4", PATH + "squash6" }),
             "into", "", "Squash Square");

  set_zone("pumpkin");
  set_monster(1, "city");
}
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/squash/squash2.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/squash/squash3.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/squash/squash3.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627625   Available: 13574979
Inodes: Total: 5242880    Free: 4960133
548 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/squash/squash3.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627625   Available: 13574979
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h";

inherit CITYROOM;

void setup() {
  set_short("north east corner of Squash Square");
  set_long("This is the north east corner of Squash Square\n");
  set_light( 80 );
  add_exit("west", SQUASH + "squash2", "road");
  add_exit("south", SQUASH + "squash6", "road");
  add_exit("southwest", SQUASH + "squash5", "hidden");

  add_property( "los", "open" );
  set_linker(({ PATH + "squash2", PATH + "squash6", PATH + "squash5" }),
             "to a point", "", "Squash Square");

  set_zone("pumpkin");
  set_monster(1, "city");
}
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/squash/squash3.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/squash/squash7.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/squash/squash7.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627625   Available: 13574979
Inodes: Total: 5242880    Free: 4960133
545 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/squash/squash7.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627625   Available: 13574979
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h";

inherit CITYROOM;

void setup() {
  set_short("south west corner of Squash Square");
  set_long("This is the south west corner Squash Square\n");
  set_light( 80 );
  add_exit("east", SQUASH + "squash8", "road");
  add_exit("north", SQUASH + "squash4", "road");
  add_exit("northeast", SQUASH + "squash3", "hidden");

  add_property( "los", "open" );
  set_linker(({ PATH + "squash8", PATH + "squash4", PATH + "squash3" }),
             "to a point", "", "Squash Square");

  set_zone("pumpkin");
  set_monster(1, "city");
}
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/squash/squash7.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/terrain/desertpath.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/terrain/desertpath.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627624   Available: 13574978
Inodes: Total: 5242880    Free: 4960133
146 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/terrain/desertpath.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627624   Available: 13574978
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/outsides/road";

void setup() {
   set_short("Road through desert");
   set_long("A road through the desert.");
   set_light(80);
}
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/terrain/desertpath.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/terrain/plains.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/terrain/plains.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627624   Available: 13574978
Inodes: Total: 5242880    Free: 4960133
145 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/terrain/plains.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627624   Available: 13574978
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h";

inherit "/std/outsides/plain";

void setup() {
  set_short("Plains");
  set_long("A bunch of plains.");
  set_light( 80 );
}
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/terrain/plains.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/terrain/desert.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/terrain/desert.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627624   Available: 13574978
Inodes: Total: 5242880    Free: 4960133
144 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/terrain/desert.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627624   Available: 13574978
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h";

inherit "/std/outsides/desert";

void setup() {
  set_short("Desert");
  set_long("A bunch of sand.");
  set_light( 80 );
}
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/terrain/desert.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/terrain/woodspath.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/terrain/woodspath.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627624   Available: 13574978
Inodes: Total: 5242880    Free: 4960133
144 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/terrain/woodspath.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627624   Available: 13574978
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/outsides/road";

void setup() {
   set_short("Road through woods");
   set_long("A road through the woods.");
   set_light(80);
}
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/terrain/woodspath.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/terrain/plainpath.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/terrain/plainpath.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627623   Available: 13574977
Inodes: Total: 5242880    Free: 4960133
144 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/terrain/plainpath.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627623   Available: 13574977
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/outsides/road";

void setup() {
   set_short("Road through plain");
   set_long("A road through the plain.");
   set_light(80);
}
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/terrain/plainpath.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/terrain/woods.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/terrain/woods.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627623   Available: 13574977
Inodes: Total: 5242880    Free: 4960133
150 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/terrain/woods.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627623   Available: 13574977
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h";

inherit "/std/outsides/woodland";

void setup() {
  set_short("Woodlands");
  set_long("A bunch of trees.");
  set_light( 80 );
}
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/terrain/woods.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/terrain/terrain_handler.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/terrain/terrain_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627623   Available: 13574977
Inodes: Total: 5242880    Free: 4960133
3085 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/terrain/terrain_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627623   Available: 13574977
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <terrain_map.h>
#include "path.h"

inherit TERRAIN_MAP_HANDLER_BASE;

string query_map_file() {
    return __DIR__ + "terrain";
}

void setup_handler() {
    set_newline_mode(0);
   // The visible distance is the basic distance things should be visible
   // using the 'map' command.
   set_visible_distance(5);

   // This sets up an obstacle for all the 'H's in the map.  They will be a
   // hedge and the rooms beside will be able to look at the hedge, the last
   // two parameters is an item name and a description.
   // The second parameter is the description that will be used in the room
   // when beside the room.  If this description has a $D in it, it will be
   // expanded with a list of the directions the obstacle lies in.
   add_obstacle_type("H", "a lush, thick hedge surrounds the small garden",
     "hedge", "The hedge surrounds the garden, stretching thick and "
     "impenetrable towards the sky, protecting anyone in the garden from the "
     "gawking eyes of passers-by.");
   add_obstacle_type("*", "s big high lump that you cannot avoid looking at",
     "lump", "The lump is very lumpy.");

   // Add in a feature for the lump obstacle so people can see the lump
   // from a distance.
   add_feature("lump",
               16, 3, // bottom left of the bounding box.
               1, 1, // width, height of the bounding box
               15, // Distance at which the feature can be seen.
               ({ // Day descs.
                  "a lump towers above you to the $D",
                }),
               // Item you can look at
               "lump", "A lumpy thing that lumps around.",
               ({ // Night descs
                  "a lump at night to the $D",
                }),
               // Night item.
               "It looks just like a lump, even though it is dark.");

   // A road is an item that you can walk on.  It follows roughly the same
   // pattern as an obstacle, the second is a continuation direction, saying
   // where the path continues too, the third is the adjecent description,
   // which can be expanded with $D, the fourth and fifth are the items.
   add_road_type("=", __DIR__ "plainpath",
     "", "a nice sandy path leads through the plains.");
   add_road_type("+", __DIR__ "woodpath",
     "", "a nice sandy path leads through the woods.");

   // To give an example of a road that skips locations, here is a road that
   // allows you to zip along a few locations at a time.
   add_road_special_type("-", __DIR__ "desertpath",
     3, // Skip three with each movement
     1, // Road follwing turned on.
     0, // Base height of the room (0).
     "", "a nice sandy path leads through the woods.");

   add_room_type("L", __DIR__ "plains");
   add_room_type("W", __DIR__ "woods");
   add_room_type("d", __DIR__ "desert");

   // This is a fixed position exit in the terrain.  Gives the x,y co-ordinates
   // of the exit, where it leads do and the direction it takes.
   add_exit_at(0, 1, "west", GUMBOOT + "gumboot5", "road");
   add_exit_at(0, 18, "west", RABBIT + "rabbit4", "road");
}
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/terrain/terrain_handler.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/pumpkin/pumpkin3.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/pumpkin/pumpkin3.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627622   Available: 13574976
Inodes: Total: 5242880    Free: 4960133
310 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/pumpkin/pumpkin3.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627622   Available: 13574976
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h";

inherit CITYROOM;

void setup() {
  set_short("Pumpkin Way");
  set_long("This is the middle of Pumpkin Way north of Squash Square.\n");
  set_light( 80 );
  add_exit("north", PUMPKIN + "pumpkin2", "road");
  add_exit("south", PUMPKIN + "pumpkin4", "road");

  set_monster(2, "pumpkin");
}
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/pumpkin/pumpkin3.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/pumpkin/pumpkin6.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/pumpkin/pumpkin6.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627622   Available: 13574976
Inodes: Total: 5242880    Free: 4960133
331 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/pumpkin/pumpkin6.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627622   Available: 13574976
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h";

inherit CITYROOM;

void setup() {
  set_short("Pumpkin Way");
  set_long("This is the end of Pumpkin Way at the junction with "
           "Squash Square.\n");
  set_light( 80 );
  add_exit("north", PUMPKIN + "pumpkin5", "road");
  add_exit("south", SQUASH + "squash2", "road");

  set_monster(2, "pumpkin");
}
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/pumpkin/pumpkin6.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/pumpkin/pumpkin4.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/pumpkin/pumpkin4.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627621   Available: 13574975
Inodes: Total: 5242880    Free: 4960133
396 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/pumpkin/pumpkin4.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627621   Available: 13574975
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h";

inherit CITYROOM;

void setup() {
  set_short("Pumpkin Way");
  set_long("This is the middle of Pumpkin Way you can just see Squash Square "
           "to the south.\n");
  set_light( 80 );
  add_exit("north", PUMPKIN + "pumpkin3", "road");
  add_exit("south", PUMPKIN + "pumpkin5", "road");
  add_exit("west", PATH + "stable_entry", "gate");

  set_monster(2, "pumpkin");
}
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/pumpkin/pumpkin4.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/pumpkin/stable_entry.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/pumpkin/stable_entry.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627621   Available: 13574975
Inodes: Total: 5242880    Free: 4960133
2043 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/pumpkin/stable_entry.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627621   Available: 13574975
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h"
#include <armoury.h>

inherit "/std/room/stable";

void setup() {
   set_light(60);
   set_theft_handler( HOSPITAL );
   set_short( "stables" );
   add_property("determinate", "the ");
   set_long( "These are the Pumpkin Street stables, an ornate gate to the "+
      "north opening onto the street.  There are many stalls here, "+
           "and some of them even have horses in them. Against one wall "+
           "is a pile of hay and hanging on the walls are saddles and "+
           "other horse riding equipment.\n");
 
   add_exit( "east", PATH +"pumpkin4", "gate" );
 
   add_item(({"horse", "horses"}), "There are a few horses here, but "+
              "most of them seem to be in the carthorse mold, rather "+
              "than being fine chargers.\n");
   add_item(({"hay", "pile"}), "A big pile of hay (that's dead grass to you and me).\n");
   add_item(({"saddle", "saddles", "riding equipment", "equipment"}),
              "Hanging on one wall are saddles, bridles, bits and other "+
              "things that help you ride a horse.\n");
   add_item("stalls", "Boxes where horses live!\n");
   add_item("gate", "A large gate, made of wrought iron bent into intricate "+
                    "shapes. On the other side you can see Filigree Street.\n");
   add_item(({"shape", "shapes"}), "There are many shapes and patterns "+
              "to be found in the twists and turns of the iron gates, "+
              "but you can't find any meaning in them. Maybe it's "+
              "meant to be abstract?\n");
 
   room_chat( ({ 50, 50, ({
 		  "A horseman rides through the gates and dismounts. "+
             "A stable boy rushes forward and leads the horse to a stall "+
             "while the rider leaves.",
             "One of the horses rears up in its stall, but can't "+
             "force the door open."
   }) }) );
 
   set_zone("pumpkin stables");

   set_save_directory("/d/dist/pumpkin/save/stables/");
   add_stable_type("horse");
   add_property("place", "Pumpkin");
} /* setup() */
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/pumpkin/stable_entry.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/pumpkin/hospital.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/pumpkin/hospital.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627620   Available: 13574974
Inodes: Total: 5242880    Free: 4960133
15278 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/pumpkin/hospital.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627620   Available: 13574974
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: hospital.c,v 1.20 2000/01/30 06:26:43 terano Exp $
 *
*/

#include <armoury.h>
#include <hospital.h>
#include <living.h>
#include <map.h>
#include <money.h>
#include <move_failures.h>
#include <route.h>
#include <wander.h>
#include "path.h"

#define MAX_HEAVIES 10
#define DAY 8 * 60 * 60
#define INTERVAL 20 * 60                 /* a divisor of DAY */
#define MUD_TO_REAL 3
#define BLOCK 5
#define MAX_EMPTIES 12
#define MAX_MOVERS 60
#define SAVE_FILE SAVE +"hospital"

inherit "/std/room/basic_room";

nosave int alchemists, update, *alignments;
mapping uniques;
nosave int *al_data;
nosave string *city;
nosave object *empties;
nosave mapping blockages;
nosave mixed *movers;

// used for checking numbers of npcs
nosave int am_npcs, last_check;
int ok_to_clone();

void get_weapon(object ob, string *items);
void get_armour(object ob, string *items);
void get_jewellery(object ob, string *items);

void setup() {
   set_keep_room_loaded(1);
   update = time();
   alignments = allocate( 50 );
   uniques = ([ ]);
   if ( file_size( SAVE_FILE +".o" ) > 0 ) {
      unguarded( (: restore_object, SAVE_FILE :) );
   }
   alchemists++;
   unguarded( (: save_object, SAVE_FILE :) );
   city = ({
      "child", "rodent", "cockroach", "dog"
   });
   empties = ({ });
   blockages = ([ ]);
   movers = allocate( MAX_MOVERS );
   call_out( "check_movers", 10 );
   call_out( "housekeeping", INTERVAL );
} /* setup() */


int *query_al_data() { return al_data; }

mapping query_uniques() { return uniques; }

object *query_empties() { return empties; }

mapping query_blockages() { return blockages; }

int query_blockage( string this, string other, int number ) {
   if ( undefinedp( blockages[ this ] ) ) {
      if ( random( 100 ) >= BLOCK )
         number = -1;
      blockages[ this ] = blockages[ other ] = number;
   }
   return blockages[ this ];
} /* query_blockage() */

mixed *query_movers() { return movers; }

void housekeeping() {
   object thing;
   update = time();
   foreach( thing in users() ) {
/* ignore creators */
      if ( thing->query_creator() )
         continue;
/* sample alignments */
      alignments[ random( sizeof( alignments ) ) ] =
            (int)thing->query_al();
   }
   al_data = 0;
   unguarded( (: save_object, SAVE_FILE :) );
   call_out( "housekeeping", INTERVAL );
} /* housekeeping() */

int pick_al() {
   int one, *stats;
   if ( !al_data ) {
      al_data = allocate( 3 );
      stats = allocate( 4 );
      foreach( one in alignments ) {
         stats[ 0 ] += one;
         stats[ 1 ] += one * one;
         if ( one > stats[ 2 ] )
            stats[ 2 ] = one;
         if ( one < stats[ 3 ] )
            stats[ 3 ] = one;
      }
      stats[ 0 ] /= sizeof( alignments );
      stats[ 1 ] /= sizeof( alignments );
      stats[ 1 ] -= stats[ 0 ] * stats[ 0 ];
      stats[ 1 ] /= 10;
      if ( stats[ 1 ] < 50 )
         stats[ 1 ] = 50;
      stats[ 2 ] -= stats[ 3 ];
      if ( stats[ 2 ] < 2 )
         stats[ 2 ] = 2;
      al_data[ 0 ] = stats[ 0 ] - stats[ 2 ] / 2;
      al_data[ 1 ] = ( stats[ 2 ] * stats[ 2 ] ) / ( 12 * stats[ 1 ] );
      if ( al_data[ 1 ] < 5 )
         al_data[ 1 ] = 5;
      al_data[ 2 ] = ( 12 * stats[ 1 ] ) / stats[ 2 ];
      if ( al_data[ 2 ] < 25 )
         al_data[ 2 ] = 25;
   }
   return al_data[ 0 ] + roll_MdN( al_data[ 1 ], al_data[ 2 ] );
} /* pick_al() */

int make_unique( string word ) {
   if ( uniques[ word ] > time() )
      return 0;
/* Don't let them reappear for three hours. */
    uniques[ word ] = time() + 1 * 60 * 60;
   unguarded( (: save_object, SAVE_FILE :) );
   return 1;
} /* make_unique() */

void add_mover( object thing ) {
   int number;

   /* Fact Gathering Done by Terano */
   /* This generates WAY too much log traffic... the log wraps more then
      once an hour - Turrican.
   log_file("HOSPITAL_DATA", "Hospital: add_mover called with %O.\n", thing );
   */

   number = MAX_MOVERS / 2 + random( MAX_MOVERS / 2 );
   if ( !pointerp( movers[ number ] ) )
      movers[ number ] = ({ thing });
   else
      movers[ number ] += ({ thing });
} /* add_mover() */

object get_monster( string type ) {
   object thing;
   object ob;

   switch( type ) {
/* First the zones that there are: */
      case "city" :
      case "pumpkin" :
         thing = get_monster( city[ random( sizeof( city ) ) ] );
         thing->add_property( "monster type", type +":"+
               (string)thing->query_property( "monster type" ) );
         thing->add_move_zone( "Pumpkin" );
         add_mover( thing );
         return thing;
/* Now the specific types of NPC: */
      case "dog":
         thing = clone_object( CHARS + "dog" );
         if ( random( 4 ) )
            thing->set_type( "small" );
         else
            thing->set_type( "large" );
         thing->add_effect( "/std/effects/npc/i_died",
               ({ HOSPITAL, "regen_after_death" }));
         thing->add_effect( "/std/effects/npc/eat_edible" );
         thing->add_effect( "/std/effects/npc/savage_corpse" );
         thing->add_property( "monster type", type );
         thing->add_property("animal type", type);
         return thing;
      case "child":
         thing = clone_object( CHARS + "child_human" );
         return thing;
/* And now for all the nasty old ones... */
    case "cityguard":
      ob = clone_object(MONSTER);
      ob->add_property("monster type", type);
      ob->set_name("guard");
      ob->add_adjective("city");
      ob->set_main_plural( "city guards" );
      ob->set_short("city guard");
      ob->set_long("This is a city guard. He is supposed to protect the " +
        "city from undesirables. Sadly, Pumpkin isn't very fussy.\n");
      ob->set_race("human");
      ob->set_gender("male");
      ob->set_guild("fighter");
      ob->set_level(8);
      ob->set_al( pick_al() / 5 );
      ob->adjust_money( 5 + random( 10 ), "Pumpkin pence" );
      ob->load_chat(10, ({
          3, "@grumble bitterly",
          1, "@daydream",
          1, "@sigh heavily"
          }) );
      ob->load_a_chat(50, ({
          1, "'Ouch!",
          1, "'Come on! I don't need this.",
          1, "'Be on your way!",
          }) );
      ARMOURY->request_weapon("long sword", 40+random(40))->move(ob);
      if(random(2))
        ARMOURY->request_armour("hard leather cap", 70 + random(30))->move(ob);
      ob->init_equip();
      return ob;
    case "mercenary":
      ob = clone_object(MONSTER);
      ob->set_name("mercenary");
      ob->set_main_plural( "mercenaries" );
      ob->add_plural( "mercenaries" );
      ob->add_adjective("tough");
      ob->set_race("human");
      ob->set_class("fighter");
      ob->set_level( 50 + roll_MdN( 5, 50 ) );
      ob->set_al( pick_al() );
      ob->set_gender(random(2) + 1);
      ob->set_long("A tough battle scarred mercenary.  There are better "
                   "ways of filling in an afternoon than messing with the "
                   "likes of "+ob->query_objective()+".\n");
      ob->adjust_money( 5 + random( 50 ), "Ankh-Morpork pence" );
      ob->adjust_money( 1 + random( 5 ), "Ankh-Morpork dollar" );
      ob->load_chat(3, ({
        1, "'Anyone you don't like?",
        1, "'I'll do anything if the price is right?",
        1, "'Don't get me angry.  You won't like me when I'm angry."
      }));
      ob->load_a_chat(30, ({
        1, "'I'll show you who's boss.",
        1, "'You think you're so tough.",
        1, "The crowd runs in terror as the mercenary kills someone by "+
           "accident."
      }));
      get_weapon(ob, ({"bastard sword", "long sword", "morning star",
       "two-handed axe"}));
      get_armour(ob, ({"chainmail", "splintmail", "ringmail"}));
      ob->add_property("monster type", type);
      ob->init_equip();
      return ob;
    case "rodent":
      ob = clone_object(MONSTER);
      ob->set_name("rat");
      ob->set_short("rat");
      ob->set_race("rat");
      ob->set_level( random( 1 + random( 3 ) ) );
      ob->add_alias("city rat");
      ob->set_main_plural("rats");
      ob->add_adjective("dirty");
      ob->add_adjective("city");
      ob->set_long("This is a large rat.  It appears to have done well "+
       "living in the city.\n"+
       "The pollution must not affect it too much.\n" );
      ob->load_chat( 5, ({
         1, ":squeaks.",
         1, ":sniffs the air, whiskers twitching.",
         1, ":checks for dwarves."
      }) );
      ob->set_wimpy( 10 );
      ob->load_a_chat( 50, ({
         1, ":squeals in pain.",
         1, ":twitches fearfully."
      }) );
      ob->add_effect("/std/effects/npc/i_died",
                     ({ HOSPITAL, "regen_after_death" }));
      ob->add_effect( "/std/effects/npc/eat_edible" );
      ob->add_effect( "/std/effects/npc/savage_corpse" );
      ob->add_property("monster type", type);
      ob->add_property("animal type", type);
      return ob;
    case "cockroach":
      ob = clone_object(MONSTER);
      ob->set_name("cockroach");
      ob->set_short("cockroach");
      ob->set_race("cockroach");
      ob->set_level( random( 1 + random( 3 ) ) );
      ob->set_main_plural("cockroaches");
      ob->add_adjective("dirty");
      ob->add_alias("roach");
      ob->set_long( "This is a huge dirty great big cockroach, the size of "
             "your hand at least.  It waves its feelers at you and looks "
             "horrible and black.  Not only can cockroaches survive fires, "
             "plagues, earthquakes and miscellaneous acts of supernatural "
             "beings, they can survive in Ankh-Morpork!\n" );
      ob->load_chat( 5, ({
         10, ":scuttles around a bit.",
         10, ":cleans its feelers.",
         10, ":rushes around in circles.",
         1,  ":jerks off in a strange direction.",
      }) );
      ob->set_wimpy( 30 );
      ob->load_a_chat( 50, ({
         1, ":oozes horrible white stuff.",
         1, ":makes a sort of scraping noise."
      }) );
      ob->add_effect("/std/effects/npc/i_died", 
                      ({ HOSPITAL, "regen_after_death" }));
      ob->add_property("monster type", type);
      ob->add_property("animal type", type);
      return ob;
    default:
      ob = clone_object(MONSTER);
      ob->set_name("failure");
      ob->set_short("failure");
      ob->set_long( "Please inform a creator about this object.\n"+
          "Type is "+ type +" from "+ file_name( previous_object() ) +".\n" );
      ob->add_property( "monster type", "failure:"+ type );
      return ob;
  }
} /* get_monster() */

void get_armour(object ob, string *items) {
  ARMOURY->request_armour(items[random(sizeof(items))], 50+random(50))->
    move(ob);
} /* get_armour() */

void get_jewellery(object ob, string *items) {
  ARMOURY->request_armour(items[random(sizeof(items))], 20+random(80))->
    move(ob);
} /* get_jewellery() */

void get_weapon(object ob, string *items) {
  ARMOURY->request_weapon(items[random(sizeof(items))], 50+random(50))->
    move(ob);
} /* get_weapon() */

void regen_after_death(object player) {
  object ob, dest;
  string nam;

  if (!player)
    return ;
  nam = (string)player->query_property("monster type");
  dest = (object)player->query_property("start location");
  if ( !nam )
    return;
  if ( !dest )
    return;
  if(!ok_to_clone())
    return;
  
  ob = get_monster( explode( nam, ":" )[ 0 ] );
  dest->add_monster(player, ob);
  call_out("do_move", 10, ({ ob, dest }) );
} /* regen_after_death() */

void do_move(mixed *junk) {
  junk[0]->move(junk[1]);
} /* do_move() */

string change_to_name(object ob) {
  return implode((string *)ob->query_adjectives(), " ")+
         (string)ob->query_name();
} /* change_to_name() */

void do_run(object ob) {
  if (ob)
    ob -> run_away();
} /* do_run() */

void fight_check(object ob, object ob1) {
  if (ob->query_property(previous_object()->query_name()))
    previous_object()->attack_ob(ob1);
} /* fight_check() */

void do_grin_laugh(object ob) {
  ob->add_respond_to_with(({ "@grin", ob->query_name() }), 
                          "laugh man at $hname$");
} /* do_grin_laugh() */

void add_empty( object thing ) {
   empties -= ({ 0 });
   empties += ({ thing });
   if ( sizeof( empties ) > MAX_EMPTIES )
      empties = shuffle( empties )[ 0 .. MAX_EMPTIES - 1 ];
} /* add_empty() */

void move_monster( object thing ) {
   int i;
   string dest, direc, zone, *movez, *roomz;
   object place;

   /* Fact Gathering Done by Terano */
   /* See above comment - Turrican
   log_file("HOSPITAL_DATA", "Hospital: move_monster called with %O.\n", thing );
   */

   if ( !thing )
      return;
   if ( (int)thing->query_hp() < 0 )
      return;
   if ( thing->query_property( PASSED_OUT ) || thing->query_fighting() ) {
      add_mover( thing );
      return;
   }
   movez = (string *)thing->query_move_zones();
   empties -= ({ 0 });
   if ( sizeof( empties ) && !thing->check_anyone_here() )
      foreach ( place in empties ) {
         roomz = (string *)place->query_zones();
         if ( !sizeof( roomz ) ) {
            empties -= ({ place });
            continue;
         }
         foreach ( zone in roomz ) {
            i = member_array( zone, movez );
            if ( i != -1 )
               break;
         }
         if ( i == -1 )
            continue;
         thing->move( place );
         place->add_monster( 0, thing );
         place->announce_entry( thing );
         empties -= ({ place });
         add_mover( thing );
         return;
      }
   place = environment( thing );
   if ( !place )
      return;
   add_mover( thing );
   foreach ( direc in shuffle( (string *)place->query_direc() ) ) {
      place->set_destination( direc );
      dest = (string)place->query_destination( direc );
      if ( !stringp( dest ) )
         continue;
      if ( !thing->check_anyone_here() && !find_object( dest ) )
         continue;
      if ( find_object( dest ) )
         roomz = (string *)dest->query_zones();
      else
         roomz = (string *)MAP->query_zones( dest );
      if ( !sizeof( roomz ) )
         continue;
      foreach ( zone in roomz ) {
         i = member_array( zone, movez );
         if ( i != -1 )
            break;
      }
      if ( i == -1 )
         continue;
      if ( place->query_relative( direc ) )
         direc = (string)thing->find_rel( direc, 0 );
      if ( thing->do_command( direc ) )
         return;
   }
} /* move_monster() */

void check_movers() {
   int when;
   object thing, *things;

   /* Fact Gathering Done by Terano */


   things = movers[ 0 ];
   movers[ 0 .. MAX_MOVERS - 2 ] = movers[ 1 .. ];
   movers[ MAX_MOVERS - 1 ] = 0;
   call_out( "check_movers", 10 );
   if ( !pointerp( things ) )
      return;
   foreach ( thing in things ) {
      if ( objectp( thing ) ) {
         when += 2;
         call_out( "move_monster", when, thing );
      }
   }
} /* check_movers() */


// This function returns 1 if its ok to clone some more npcs and
// false if not.
int ok_to_clone() {
  if(time() > last_check + 300) {
    last_check = time();
    am_npcs = sizeof( filter( named_livings(),
      (: environment( $1 ) && base_name( environment( $1
       ) )[0..4] == "/d/am" :) ) );
  }
  return ( am_npcs < MAX_AM_LIVING );
}


int *query_npcs() {
  return ({ am_npcs, last_check });
}

// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/pumpkin/hospital.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/pumpkin/pumpkin1.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/pumpkin/pumpkin1.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627616   Available: 13574970
Inodes: Total: 5242880    Free: 4960133
317 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/pumpkin/pumpkin1.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627616   Available: 13574970
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h";

inherit CITYROOM;

void setup() {
  set_short("Pumpkin Way");
  set_long("This is end of Pumpkin Way at the junction with Crumpet Circle.\n");
  set_light( 80 );
  add_exit("east", PUMPKIN + "pumpkin2", "road");
  add_exit("southwest", CRUMPT + "crumpt1", "road");

  set_monster(2, "pumpkin");
}
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/pumpkin/pumpkin1.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/pumpkin/pumpkin2.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/pumpkin/pumpkin2.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627616   Available: 13574970
Inodes: Total: 5242880    Free: 4960133
310 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/pumpkin/pumpkin2.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627616   Available: 13574970
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h";

inherit CITYROOM;

void setup() {
  set_short("Pumpkin Way");
  set_long("This is middle of Pumpkin Way just north of Crumpt Circle.\n");
  set_light( 80 );
  add_exit("west", PUMPKIN + "pumpkin1", "road");
  add_exit("south", PUMPKIN + "pumpkin3", "road");

  set_monster(2, "pumpkin");
}
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/pumpkin/pumpkin2.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/pumpkin/pumpkin5.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/pumpkin/pumpkin5.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627616   Available: 13574970
Inodes: Total: 5242880    Free: 4960133
414 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/pumpkin/pumpkin5.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627616   Available: 13574970
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h";

inherit CITYROOM;

void setup() {
  set_short("Pumpkin Way");
  set_long("This is the middle of Pumpkin Way, quite close to the junction "
           "with Squash Square to the south.\n");
  set_light( 80 );
  add_exit("north", PUMPKIN + "pumpkin4", "road");
  add_exit("south", PUMPKIN + "pumpkin6", "road");
  //add_exit("east", PATH + "stable_shop", "gate");

  set_monster(2, "pumpkin");
}
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/pumpkin/pumpkin5.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/pumpkin/stable_shop.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/pumpkin/stable_shop.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627615   Available: 13574969
Inodes: Total: 5242880    Free: 4960133
1740 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/pumpkin/stable_shop.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627615   Available: 13574969
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h"

inherit "/std/shops/item_shop";

void setup() {
   set_short("Stable shop");
   set_long(
"You are in the stable shop, it is completely full of various weird things "
"like bits, bridles and other obscure looking bits of leather.\n");

   add_exit("west", PATH + "pumpkin5", "gate");
   set_light(70);

   // Add some inventory.
   //add_object("/obj/clothes/transport/horse/bit.trans");
   //add_object("/obj/clothes/transport/horse/bridle.trans");
   //add_object("/obj/clothes/transport/horse/saddle.trans");
   //add_object("/obj/clothes/transport/horse/reins.trans");
   //add_object("/obj/clothes/transport/horse/blinkers.trans");

   // Make some horses...
   add_object("pale grey horse");
   add_object("painted grey horse");
   add_object("plaid horse");
   add_object("dappled brown horse");
   add_object("light brown horse");
   add_object("dark brown horse");
   add_object("dark red horse");

   add_object("black warhorse");

   add_property("place", "Pumpkin");
} /* setup() */

object create_object(string thing) {
   object horse;
   object bing;

   if (strlen(thing) > 8 && thing[<8..] == "warhorse") {
      horse = clone_object("/obj/monster/transport/warhorse");
      horse->set_colour(thing[0..<10]);
      horse->set_value(8);
      horse->add_property("cost here", 8);
      return horse;
   } else if (strlen(thing) > 5 && thing[<5..] == "horse") {
      horse = clone_object("/obj/monster/transport/horse");
      horse->set_colour(thing[0..<7]);
      horse->set_value(8);
      horse->add_property("cost here", 8);
      return horse;
   } else {
      bing = clone_object(thing);
      bing->setup_clothing(1000);
      bing->set_value(8);
      return bing;
   }
} /* create_object() */
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/pumpkin/stable_shop.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/chars/child_human.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/chars/child_human.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627615   Available: 13574969
Inodes: Total: 5242880    Free: 4960133
2254 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/chars/child_human.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627615   Available: 13574969
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
#include "path.h"

inherit "/obj/monster";

void respond_to_soul(object play);

void setup() {
   int i;
   string *types = ({ "playful", "quiet", "thin", "fat", "noisy",
         "thoughtful", "happy", "sad", "boring", "interesting" });
   set_name( "child" );
   i = random( sizeof( types ) );
   set_short( types[ i ] +" child" );
   add_adjective( types[ i ] );
   set_main_plural( types[ i ] +" children" );
   set_race( "human" );
   set_gender( 1 + random( 2 ) );
/* Some sort of "young" property for the race object to check? */
   i = (int)"/std/races/human"->query_weight();
   i += (int)"/std/races/human"->modifier( weight );
   set_base_weight( ( 3 * i ) / ( 4 + random( 6 ) ) );
   i = (int)"/std/races/human"->query_height();
   i += (int)"/std/races/human"->modifier( height );
   set_height( ( 2 * i ) / ( 3 + random( 4 ) ) );
   set_con( ( 2 * query_con() ) / ( 3 + random( 4 ) ) );
   set_dex( ( 2 * query_dex() ) / ( 3 + random( 4 ) ) );
   set_str( ( 2 * query_str() ) / ( 3 + random( 4 ) ) );
   set_al( -50 + (int)HOSPITAL->pick_al() / 10 );
   set_level( random( 5 ) );
   set_wimpy( 90 );
   set_long( "This is one of the inhabitants of Pumpkin.\n" );
   add_effect( "/std/effects/npc/gossip", 5);
   load_chat(40, ({ 1, "#do_gossip_say:$mess$" }));

   add_respond_to_with(({ ({ "@skick", "@spunch", "@jump", "@push",
                             "@shove", "@knee" }) }),
                       (: respond_to_soul :));
} /* setup() */

void respond_to_soul(object play) {
   switch (random(6)) {
   case 0:
      do_command("'Thats not very nice!");
      break;
   case 1:
      do_command("'Pick on someone your own size.");
      do_command("glare " + player->query_name());
      break;
   case 2:
      do_command("cry");
      do_command("accuse " + player->query_name() + " of child abuse");
      break;
   case 3:
      do_command("spunch " + player->query_name());
      do_command("'Take that!  and that!");
      do_command("skick " + player->query_name());
      break;
   case 4:
      do_command("accuse " + player->query_name() + " of child abuse");
      break;
   case 5:
      do_command("'I will tell my brother!");
      break;
   }
   call_out("run_away", 2);
} /* respond_to_soul() */
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/chars/child_human.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/chars/dog.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/chars/dog.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627614   Available: 13574968
Inodes: Total: 5242880    Free: 4960133
8229 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/chars/dog.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627614   Available: 13574968
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: am_dog.c,v 1.3 2000/01/09 00:52:03 rue Exp $
 *
 * $Log: am_dog.c,v $
 * Revision 1.3  2000/01/09 00:52:03  rue
 * Added gender
 *
 * Revision 1.2  1999/04/11 21:50:06  ranma
 * typo.
 *
 * Revision 1.1  1998/02/08 08:44:56  terano
 * Initial revision
 *
*/
/* -*- LPC -*-
 */
inherit "/obj/monster";

#include "path.h"

string colour, type;

/* predefs */
void check_for_hidden();
void test_rabid_attack();
void test_urinate();
void pat_me( object per );
void sic_em( object per, string mess );

string query_colour() { return colour; }

void setup() {
   colour = ({ "light brown", "black", "grey", "mottled", "white", "patched",
         "dark brown", "black and white", "fluorescent yellow" })[ random( 9 ) ];
  set_name("dog");
  set_race("dog");
  set_gender(1 + random(2));
  set_level( 1 + random( 1 + random( 3 ) ) );
  add_adjective("hairy");
  add_adjective(explode(colour, " "));
} /* setup() */

void set_type(string type) {
   set_short( type +" "+ colour +" dog" );
   set_main_plural( type +" "+ colour +" dogs" );
   add_adjective( type );
   if ( type == "small" ) {
      set_long("The small "+colour+" dog is very hairy.  It looks a "
                 "bit sad and lost in the streets of Pumpkin.  "
                 "You are sure it would prefer a cat flap and a nice "
                 "hot meal every night, or is that you?\n");
   } else {
      add_skill_level( "fighting", random( 10 + random( 30 ) ) );
      add_skill_level( "other.health", random( 10 + random( 30 ) ) );
      set_main_plural("large "+colour+" dogs");
      add_adjective("large");
      set_long("The large "+colour+" dog confidently walks the streets, "
                 "insolently not moving aside for the warriors and heroes "
                 "stalking the streets.\n");
   }
  /* Make them bark at hiding people */
   add_enter_commands( "#check_for_hidden" );

   if ( !random( 3 ) )
     add_effect( "/std/effects/disease/flea_infestation", 10000 );

  if (!random(6)) {
    /* A rabid dog... */
    set_wimpy(10);
    load_chat( 10, ({
       1, "@froth",
       1, "@roll eye",
       1, "@growl",
       1, "#test_rabid_attack",
    }) );
    load_a_chat( 10, ({
       1, "@froth",
       1, "@roll eye",
       1, "@growl" }) );
    add_respond_to_with( ({ ({ "@pat", "@stroke", "@hug" }),
                             query_name() }), "bite $hname$");
  } else {
    set_wimpy( 70 );
    load_chat( 5, ({
       1, (type=="small"?":whines pathetically.":"@growl"),
       1, (type=="small"?"@stare hungrily at $lname":
                             "@stare int at $lname"),
       1, (type=="small"?"@bite $lname ankles":"@stare rud at $lname"),
       1, "#test_urinate",
    }) );
    load_a_chat( 50, ({
       1, "@bite $aname ?",
       1, "@growl",
       1, "@bark",
    }) );
    add_respond_to_with( ({ ({ "@pat", "@stroke", "@hug" }),
                                query_name() }), "#pat_me" );
    add_respond_to_with( ({ "@say", ({ "get", "sic" }), }), "#sic_em" );
  }

  add_effect("/std/effects/npc/eat_edible", 0);

  add_effect("/std/effects/npc/i_died", ({ HOSPITAL, "regen_after_death" }));
  //add_triggered_action("regen", "death", HOSPITAL, "regen_after_death");
  add_property("monster_type", type);
  add_property("animal type", type);
} /* setup() */

void bark_at_hidden(object per) {
  mapping hide_invis;
 
  if (per) {
    hide_invis = per->query_hide_invis();
    if (environment(per) == environment() &&
        hide_invis["hiding"]) {
      do_command("bark loudly");
      if (!random(4))
        do_command("bark loudly at "+
                 per->query_name());
      else
        do_command("bark loudly");
      call_out("bark_at_hidden", 2, per);
    }
  }
} /* bark_at_hidden() */

void check_for_hidden() {
  object *obs, mine;
  int i;
  mapping hide_invis;
  function fun;

  mine = query_property("following");
  obs = all_inventory(environment(this_object()));
  for (i=0;i<sizeof(obs);i++) {
    hide_invis = query_hide_invis();
    if (living(obs[i]) && hide_invis["hiding"] &&
        obs[i] != mine && obs[i]->query_visible(this_object())) {
      call_out("bark_at_hidden", 0, obs[i]);
      break;
    }
  }
} /* check_for_hidden() */

void test_rabid_attack() {
  int i;
  object *obs;

  obs = filter_array(all_inventory(environment()),
                     (: living($1) && $1 != $2 &&
                        (!$1->query_property("player") ||
                         $1->query_level() > 5) :),
                      this_object());
  if (sizeof(obs))
    attack_ob(obs[0]);
} /* test_rabid_attack() */

void test_urinate() {
  object *obs, *liv, blue, mine;
  int i;
  
  liv = ({ });
  mine = query_property("following");
  obs = all_inventory(environment());

  /* Recheck for hidding people. */
  check_for_hidden();

  /* Track down those living objects */
  for (i=0;i<sizeof(obs);i++) {
    if (living(obs[i]) && obs[i] != mine &&
        obs[i] != this_object()) {
      liv += obs[i..i];
    }
  }

  /* Ok, found someone.  Lets do it! */
  if (sizeof(liv)) {
    blue = liv[random(sizeof(liv))];
    tell_room(environment(),
              the_short() + " urinates on " + blue->the_short() + "'s leg.\n",
              ({ blue }));
    tell_object(blue, capitalize(the_short()) + " urinates on your leg.\n");
    blue->add_effect("/std/effects/other/dog_urinate", 120);
  }
} /* test_urinate() */

void i_like_them(object them) {
  if(!them || environment() != environment(them))
    return ;

  call_out("i_like_them", 60+random(240), them);
  if (query_property("excited")) {
    do_command("bounce excit");
  } else switch (random(5)) {
    case 0 :
      do_command("nuzzle "+them->query_name());
      break;
    case 1 :
      do_command("stare pitifully at "+them->query_name());
      break;
    case 2 :
      do_command("smile "+them->query_name());
      break;
    case 3 :
      do_command("eye "+them->query_name());
      break;
    case 4 :
      do_command("drool "+them->query_name());
      break;
  }
} /* i_like_them() */

void pat_me(object per) {
  object ob;

  ob = query_property("following");
  if (objectp(ob) &&
      environment(ob) == environment()) {
    init_command("nuzzle "+per->query_name());
  } else if (environment() == environment(per) &&
   (query_property("monster type") == "small dog" ||
   !random(5))) {
    init_command("follow "+per->query_name());
    init_command("protect "+per->query_name());
    add_property("following", per);
    call_out("i_like_them", 60+random(240), per);
  } else {
    init_command("ignore "+per->query_name());
  }
} /* pat_me() */

void periodic_excited() {
  if (query_property("excited")) {
    if (query_property("excited") > 1) {
      switch (random(4)) {
        case 0 :
          do_command("growl");
          break;
        case 1 :
          do_command("bark");
          break;
        case 2 :
          do_command("caper");
          break;
        case 3 :
          do_command("bounce excit");
          break;
      }
    } else if (!random(2))
      do_command("bounce excit");
    else
      do_command("caper");
    call_out("periodic_excited", 10+random(10));
  }
} /* periodic_excited() */

void sic_em(object per, string mess) {
   string *bing;
   object mine;
   object *obs;
   int lvl;
   
   bing = explode(replace(mess, "!", ""), " ");
   mine = query_property("following");
   if (bing[0] == "get" && per == mine) {
      obs = match_objects_for_existence(bing[1], environment());
      obs = filter_array(obs, (: living($1) :));
      if ( sizeof( obs ) ) {
	 lvl = query_property( "excited" );
	 add_property( "excited", lvl+1 );
	 call_out( function( object npc ) {
	    int lvl;
	    
	    lvl = npc->query_property("excited");
	    if (lvl > 0)
	       npc->add_property("excited", lvl - 1);
	    else
	       npc->remove_property("excited");
	 }, 120, this_object());
	 if (!lvl) {
	    call_out("periodic_excited", 10+random(10));
	 }
	 switch (lvl) {
	  case 0 :
	    init_command("bounce excit");
	    break;
	  case 1 :
	    init_command("growl "+obs[0]->query_name());
	    break;
	  default :
	    call_out((: attack_ob($2) :), 0, obs[0]);
	    break;
	 }
      }
   }
} /* sic_em() */
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/chars/dog.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/fruitbat/fruitbat1.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/fruitbat/fruitbat1.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627612   Available: 13574966
Inodes: Total: 5242880    Free: 4960133
313 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/fruitbat/fruitbat1.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627612   Available: 13574966
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h";

inherit CITYROOM;

void setup() {
  set_short("Fruitbat Avenue");
  set_long("This is Fruitbat Avenue at the junction with Crumpet Circle.\n");
  set_light( 80 );
  add_exit("east", FRUITBAT + "fruitbat2", "road");
  add_exit("north", CRUMPT + "crumpt8", "road");

  set_monster(1, "city");
}
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/fruitbat/fruitbat1.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/fruitbat/fruitbat2.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/fruitbat/fruitbat2.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627612   Available: 13574966
Inodes: Total: 5242880    Free: 4960133
392 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/fruitbat/fruitbat2.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627612   Available: 13574966
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h";

inherit CITYROOM;

void setup() {
  set_short("Fruitbat Avenue");
  set_long("This is the middle of Fruitbat Avenue just west of "
           "Crumpt Circle.\n");
  set_light( 80 );
  add_exit("east", FRUITBAT + "fruitbat3", "road");
  add_exit("west", FRUITBAT + "fruitbat1", "road");
  add_exit("south", FRUITBAT + "general_store", "door");

  set_monster(1, "city");
}
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/fruitbat/fruitbat2.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/fruitbat/fruitbat4.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/fruitbat/fruitbat4.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627611   Available: 13574965
Inodes: Total: 5242880    Free: 4960133
337 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/fruitbat/fruitbat4.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627611   Available: 13574965
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h";

inherit CITYROOM;

void setup() {
  set_short("Fruitbat Avenue");
  set_long("This is east end of Fruitbat Avenue at the junction "
           "with Squash Square.\n");
  set_light( 80 );
  add_exit("east", SQUASH + "squash4", "road");
  add_exit("west", FRUITBAT + "fruitbat3", "road");

  set_monster(1, "city");
}
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/fruitbat/fruitbat4.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/fruitbat/general_store.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/fruitbat/general_store.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627610   Available: 13574964
Inodes: Total: 5242880    Free: 4960133
416 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/fruitbat/general_store.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627610   Available: 13574964
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h"
inherit "/std/shops/general_shop";

void setup() {
   set_short("Elephant's Stamp");
   set_long(
"A huge picture of an elephant covers tha back room of the shop.  You can "
"see the elephant guarding a huge pile of goods.\n");

   add_exit("north", FRUITBAT + "fruitbat2", "door");
   set_light(70);
   set_store_room(FRUITBAT + "storeroom");

   add_property("place", "Pumpkin");
} /* setup() */
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/fruitbat/general_store.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/fruitbat/fruitbat3.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/fruitbat/fruitbat3.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627610   Available: 13574964
Inodes: Total: 5242880    Free: 4960133
394 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/fruitbat/fruitbat3.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627610   Available: 13574964
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h";

inherit CITYROOM;

void setup() {
  set_short("Fruitbat Avenue");
  set_long("This is the middle of Fruitbat Avenue just south of the "
           "vault.\n");
  set_light( 80 );
  add_exit("east", FRUITBAT + "fruitbat4", "road");
  add_exit("west", FRUITBAT + "fruitbat2", "road");
  add_exit("north", FRUITBAT + "walrus_vault_entry", "door");

  set_monster(1, "city");
}
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/fruitbat/fruitbat3.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/fruitbat/storeroom.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/fruitbat/storeroom.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627609   Available: 13574963
Inodes: Total: 5242880    Free: 4960133
161 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/fruitbat/storeroom.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627609   Available: 13574963
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/shops/storeroom";

void setup() {
   set_short("Elephant's Storeroom");
   set_light(70);
   set_long("Lots of stored stuff.\n");
 } /* setup() */
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/fruitbat/storeroom.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/fruitbat/walrus_vault_entry.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/fruitbat/walrus_vault_entry.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627609   Available: 13574963
Inodes: Total: 5242880    Free: 4960133
552 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/fruitbat/walrus_vault_entry.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627609   Available: 13574963
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h"
inherit "/std/shops/vault_entry";

object _npc;

void setup() {
   set_short("Wulrus's vault");
   set_long(
"A big picture of a nice friendly looking walrus looks down on you "
"with a nice happy smile.\n");

   set_light(70);

   set_vault_name("walrus");
   set_visit_cost(400);
   set_open_cost(4000);

   add_exit("south", FRUITBAT + "fruitbat3", "door");
   set_vault_exit("north", FRUITBAT + "walrus_vault", "door");
   add_property("place", "Pumpkin");
} /* setup() */

void reset() {
   set_proprietor(_npc);
} /* reset() */
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/fruitbat/walrus_vault_entry.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/dist/pumpkin/fruitbat/walrus_vault.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/fruitbat/walrus_vault.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627609   Available: 13574963
Inodes: Total: 5242880    Free: 4960133
379 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/dist/pumpkin/fruitbat/walrus_vault.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627609   Available: 13574963
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h"
inherit "/std/shops/vault";

void setup() {
   set_short("Wulrus's vault");
   set_long(
"A big picture of a nice friendly looking walrus looks down on you "
"with a nice happy smile.\n");

   set_light(70);

   set_vault_name("walrus");

   set_vault_exit("south", FRUITBAT + "walrus_vault_entry", "door");
   add_property("place", "Pumpkin");
} /* setup() */
// --- END [/mnt/home2/grok/lib/d/dist/pumpkin/fruitbat/walrus_vault.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/admin/master.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/admin/master.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627609   Available: 13574963
Inodes: Total: 5242880    Free: 4960133
3005 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/admin/master.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627609   Available: 13574963
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#define LORD "pinkfish"
#define DOMAIN "admin"
#define LOGS "/d/admin/log/"
#define BACKUP_COUNT 9

/*
 * Beware editing this file.
 * Make sure you know what you are doing.  Stuffing this up could be
 * fatal in some ways.
 */

inherit "/std/dom/base_master";

void create() {
   string file;
   int i;
   
   ::create();
   foreach ( file in unguarded( (: get_dir, LOGS +"*.log" :) ) ) {
     if( ( unguarded( (: file_size, LOGS + file :) ) > 1024000) ||
         ( file != "ENTER.log" &&
           unguarded( (: file_size, LOGS + file :) ) > 64000 ) ) {
       file = explode( file, "." )[ 0 ];

       // delete the last one if necessary.
       if(file_size(LOGS+file+"."+BACKUP_COUNT) > 0)
         unguarded( (: rm, LOGS + file +"."+ BACKUP_COUNT :) );

       // rename those down to the first.
       for(i=(BACKUP_COUNT-1); i>0; i--)
         if(file_size(LOGS+file+"."+i) > 0)
           unguarded( (: rename, LOGS+file+"."+i, LOGS+file+"."+(i+1) :) );

       // rename the .log one to .1
       unguarded( (: rename, LOGS+file+".log", LOGS+file+"."+"1" :) );
     }
   } 
} /* create() */

string query_lord() {
  return LORD;
}

string author_file(string *path) {
  return capitalize(DOMAIN);
}

int check_permission(string euid, string *path, int mask) {
  if (euid == query_lord())
    return 1;
  return ::check_permission(euid, path, mask);
}

/*
 * By default, use the valid_read()/valid_write() functions defined in the
 * inherited file /std/dom/base_master.c.
 * These default to reading allowed for everyone, writing only allowed
 * for independent creators and the domain lord.
 * This is all overridden by the check_permission() function
 * which is called first, which should be used instead.
 */
int valid_read(string *path, string euid, string funct);

int valid_write(string *path, string euid, string funct);

/*
 * By default only the lord of the domain can add/remove members, or
 * change the projects of the members.
 * This is a bit contrictive, but handy as a default.
 * Change this if you want.
 */
int add_member(string name) {
  if (geteuid(this_player(1)) != query_lord())
    return 0;
  return ::add_member(name);
}

int remove_member(string name) {
  if (geteuid(this_player(1)) != query_lord())
    return 0;
  return ::remove_member(name);
}

int set_project(string name, string pro) {
  if (geteuid(this_player(1)) != query_lord())
    return 0;
  return ::set_project(name, pro);
}

int query_member(string name) {
  return !undefinedp(members[name]) || name == LORD;
} /* query_member() */

string log_who(string where) {
  return LORD;
} /* log_who() */

/* Please change this to a text describing the domain, it will be used
   on the WWW pages and in finger info. */

string query_info() {
  return "\nThe admin domain is made up of the active Trustees of "
    "Discworld.  Their role is to ensure the smooth running of the game.  "
    "They carry the ultimate responsibility for Discworld, how it operates "
    "and its policies and rules.\n\n";
}
// --- END [/mnt/home2/grok/lib/d/admin/master.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/admin/common.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/admin/common.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627608   Available: 13574962
Inodes: Total: 5242880    Free: 4960133
3100 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/admin/common.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627608   Available: 13574962
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <config.h>
#define DOM_TITLE "the domain of admin"
#define LORD "pinkfish"
#define DOMAIN "admin"
/* PLEASE re-describe me */
inherit "/std/dom/cmn_mas";
object board;

void setup() {
  set_dom(DOMAIN);
  set_light(100);
  add_exit("drum", CONFIG_START_ROOM, "door");
  modify_exit( "drum", ({ "one way", 1 }) );
  set_short("Common room of "+DOM_TITLE);
  set_long("Large relaxing chairs adorn the room.  The walls are covered "+
           "with strange motifs from different lands and the little shelf "+
           "above the fireplace is chocker block full of strange figurines "+
           "and bits of cloth.  It appears to be the common room of "+
           DOM_TITLE+" the large red letters on the wall were the " +
           "give away.\n");
  add_alias("chairs", "chair");
  add_alias("cloths", "cloth");
  add_alias("motifs", "motif");
  add_alias("figurines", "figurine");
  add_item("chair", "The chairs are lazing around the room relaxing it looks "+
                    "like they come here after a hard days working in "+
                    DOM_TITLE+".\n");
  add_item("fireplace", "A nice little fire place with a cheery fire burning "+
                        "in it keeping every one warm.\n");
  add_item("figurine", "Small figurines, they look strangely familiar "+
                         "until you realise they are the members of "+
                         DOM_TITLE+".\n");
  add_item("cloth", "Strange coloured bits of cloth strewn over the "+
                    "mantlepice for no readily apparent reason.\n");
  add_item("motif", "The motifs on close inspection look like stylised "+
                     "signatures of all the members of "+DOM_TITLE+
                     ".  Some of them are very strange, in fact there "+
                     "seem to be more than there are members of the house.  "+
                     "perhaps it is the members of the future.\n");
  add_item("shelf", "A nice normal sort of shelf thing.  It is like all "+
                    "those ones you see in houses all over the place, "+
                    "execpt... the way it has been burnt... hmm it does "+
                    "not look like the fire did it.\n");
  add_item("fire", "There is a fire happily burning away in the fireplace "+
                   "spluttering and crackling to itself.  The flames almost "+
                   "seem afraid of something.  Looking closer you notice a "+
                   "picture tacked to the side of the fire place.\n");
  add_item("picture", "Tacked to the inside wall of the fire thingy, you "+
                      "know the hole bit at the bottom, is a small picture "+
                      "it looks like it was taken with the best of demon "+
                      "photography.  It is a picture of a person holding "+
                      "a small staff, you think it might be "+LORD+
                      " but you are not sure as the fire light sparkles "+
                      "in your eyes.\n");
  board = clone_object("/obj/misc/board");
  board->set_datafile(DOMAIN);
  board->move(this_object());
}
// --- END [/mnt/home2/grok/lib/d/admin/common.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/admin/room/cloner_control.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/admin/room/cloner_control.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627607   Available: 13574961
Inodes: Total: 5242880    Free: 4960133
1590 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/admin/room/cloner_control.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627607   Available: 13574961
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*  cloner_control.c

  This room is used to add or list filename mappings for the cloner.

    Change log:

  15/3/96 - Created by Ceres

*/
#include "path.h"

inherit "/std/room/basic_room";

#define CLONER "/global/cloner"


int do_add(string from, string to);
int do_remove(string from);
int do_list(string matching);

void setup() {
  set_light(100);
  set_short("Cloner Room");
  set_long("This room is used to look at or add filename mappings for the "+
     "cloner object.  It's a very, very, very, very boring room.\n\n"+
     "  add <from> <to> - adds a mapping.\n"+
     "  remove <from> - removes a mapping.\n"+
     "  list [str] - lists mappings which contain the optional string "+
     "str.\n");
  add_exit("southwest" , ROOM+"development" , "door");
}

void init() {
  ::init();

  if (!this_player()) return;

  this_player()->add_command("add", this_object(),
    "<string:small'from object'> <string:small'to object'>",
    (: do_add($4[0], $4[1]) :)
    );
  this_player()->add_command("remove", this_object(),
    "<string:small'from object'>",
    (: do_remove($4[0]) :)
    );
  this_player()->add_command("list", this_object(),
    "<string:small'matching'>",
    (: do_list($4[0]) :)
    );
  this_player()->add_command("list", this_object(),
    "",
    (: do_list("") :)
    );
}

int do_add(string from, string to) {
  CLONER->add_mapping(from, to);
  return 1;
}

int do_remove(string str) {
  CLONER->remove_mapping(str);
  return 1;
}

int do_list(string from) {
  this_player()->more_string(CLONER->list_mappings(from));
  return 1;
}
// --- END [/mnt/home2/grok/lib/d/admin/room/cloner_control.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/admin/room/quest_room.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/admin/room/quest_room.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627606   Available: 13574960
Inodes: Total: 5242880    Free: 4960133
6859 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/admin/room/quest_room.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627606   Available: 13574960
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  quest_room.c

  This room is used to add, list, and remove quests.

  This file was constructed by Godot (Marshall Buhl).  If you
  make any changes to it, please leave comments in the code
  detailing the changes and let him know about them.  This file
  is not the original, so it is important that he be informed.
  If not, he may unknowingly throw away your changes by
  uploading an new version.

    Change log:

  12/05/92 - Created by Godot.

*/
#include "quest_handler.h"
#include "path.h"

inherit "/std/room/basic_room";

/*
    Global variables.
*/
int level;
string  old_quest;
string  story;
string  title;

/*
    Function prototypes.
*/
int do_create( string quest );
int do_delete( string quest );
int do_help( string what );
int do_level( string new_level );
int do_list();
int do_name( string new_name );
int do_story( string new_story );
int do_title( string new_title );
void  remove_quest( string answer );
void  init();
void  setup();

/*
    Functions.
*/
int
do_create( string quest )
{
/*
  Create the quest.
*/
    if ( !quest )
    {
  write( "Syntax is: create <quest>, where <quest> will be the name of "
       + "the new quest.\n" );
  return 1;
    }
    if ( !level )
    {
  write( "You must set the quest level first.\n" );
  return 1;
    }
    if ( !story )
    {
  write( "You must set the quest story first.\n" );
  return 1;
    }
    if ( !title )
    {
  write( "You must set the quest title first.\n" );
  return 1;
    }
    if ( QUEST_HANDLER->add_quest( quest , level , title , story ) )
    {
  tell_room( this_object() , "Quest \"" + quest + "\" added.\n" );

  level = 0;
  story = 0;
  title = 0;
    }
    else
  tell_room( this_object() , "Quest failed to add.\n" );

    return 1;
}

int
do_delete( string quest )
{
    string  *quests;

    if(!"/secure/master"->query_lord( geteuid( this_player() ) ))
      return 1;
    
      quests = (mixed*) QUEST_HANDLER->query_quest_names();

    if ( quest )
    {
        if ( member_array( quest, quests ) == -1 )
  {
      write( "Quest not found.\n" );
      return 1;
  }
  old_quest = quest;

  write( "\nYou should not remove someone else's quest!!!\n\n"
       + "Are your sure you want to remove this quest? (y/n) > " );
  input_to( "remove_quest" );
  return 1;
    }
    write( "Syntax: remove <quest>, where <quest> is the name of an "
   + "existing quest.\n" );
    return 1;
}

int
do_help( string what )
{
    if ( what != "room" )  return 0;

    write( "Quest room help:\n\n"
   + "  create <string> - Use current settings to create a new quest\n"
   + "                    whose name is <string>.\n"
   + "  delete <string> - Delete the quest whose name is <string>.\n"
   + "                    This option available only to Lords.\n"
   + "  help room       - Generate this help screen.\n"
   + "  level <int>     - Set the level of difficulty to <int>.\n"
   + "  list            - List the current quests.\n"
   + "  story <string>  - Set the quest story to <string>.\n"
   + "  title <string>  - Set the string that is added to the player's\n"
   + "                    title to <string>.\n"
   );
    return 1;
}

int
do_level( string new_level )
{
    if ( new_level )
    {
  sscanf( new_level , "%d" , level );

  tell_room( this_object() , "Quest level set to " + level + ".\n" );
    }
    else
  write( "Syntax: level <new_level>, where new_level is an integer "
       + "indicating how difficult the quest is.\n" );
    return 1;
}

int do_list() {
  int i;
  string list;
  mixed *names;

  if(!"/secure/master"->query_lord( geteuid( this_player() ) ))
    return 1;

  list = "These are the Discworld quests:\n\n";
  names = (mixed *)QUEST_HANDLER->query_quest_names();
  for ( i = 0; i < sizeof( names ); i++ ) {
    list += "Quest "+ ( i + 1 ) +"  \""+ names[ i ] +"\", level "+
        (int)QUEST_HANDLER->query_quest_level( names[ i ] ) +"\n    title: "+
        (string)QUEST_HANDLER->query_quest_title( names[ i ] ) +"\n    story: "+
        (string)QUEST_HANDLER->query_quest_story( names[ i ] ) +"\n";
    if ( i < sizeof( names ) - 1 )
      list += "\n";
   }
  reset_eval_cost();
  this_player()->more_string( list, "Quest List", 1 );
  return 1;
} /* do_list() */

int
do_story( string new_story )
{
    if ( new_story )
    {
  story = new_story;
  tell_room( this_object() , "Quest story set to:\n" + story + "\n" );
    }
    else
  write( "Syntax: story <new_story>, where new_story is a string that "
       + "describes the quest.\n" );
    return 1;
}

int
do_title( string new_title )
{
    if ( new_title )
    {
  title = new_title;
  tell_room( this_object() , "Quest title set to \"" + title + "\".\n" );
    }
    else
  write( "Syntax: title <new_title>, where new_title is the title that "
       + "is appended to the players name for \"who\".\n" );
    return 1;
}

void
init()
{
#ifdef 0
/*
  Make it so only bigwigs can use this object.
*/
    string  euid;
    object  tp;

    tp   = this_player();
    euid = geteuid( tp );

    if ( ( "/secure/master"->god( euid )             )
      || ( "/secure/master"->high_programmer( euid ) )
      || ( "/secure/master"->query_lord( euid )      )
      || ( tp->query_creator()                       )
      || ( tp->query_app_creator()                   ) )
    {
  add_action( "do_create" , "create" );
  add_action( "do_help"   , "help"   );
  add_action( "do_level"  , "level"  );
  add_action( "do_story"  , "story"  );
  add_action( "do_title"  , "title"  );

  if ( ( "/secure/master"->god( euid )             )
    || ( "/secure/master"->high_programmer( euid ) )
    || ( "/secure/master"->query_lord( euid )      ) )
  {
      add_action( "do_delete" , "delete" );
      add_action( "do_list"   , "list"   );
  }
/*
      Reinitialize settings.
*/
  level = 0;
  story = 0;
  title = 0;

  do_help( "room" );

  tell_room( this_object() , "\nQuest settings have been reset to "
         + "nulls by init().\n\n" );
    }
    ::init();
#endif
}

void remove_quest( string answer ) {
/*
  This function is called by input_to() in do_remove().
*/
    answer = lower_case( answer );

    if ( answer == "y" )
    {
  if ( QUEST_HANDLER->delete_quest( old_quest ) )
      tell_room( this_object() , "Quest \"" + old_quest
             + "\" deleted.\n" );
  else
      tell_room( this_object() , "Quest \"" + old_quest + "\" was not "
             + "deleted.\n" );
  return;
    }
    tell_room( this_object() , "Quest \"" + old_quest
           + "\" was not deleted.\n" );
    return;
}

void
setup()
{
    set_short( "Quest Room" );
    //    set_long( "This room is used to create, list, and remove quests.\n"
    //    );
    set_long("Don't use this room, get a lord to use the quests command instead. This room will break the quests!\n");
    set_light( 100 );
    add_exit( "west" , ROOM+"development" , "corridor" );
}

/* EOF */
// --- END [/mnt/home2/grok/lib/d/admin/room/quest_room.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/admin/room/site_control.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/admin/room/site_control.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627604   Available: 13574958
Inodes: Total: 5242880    Free: 4960133
4486 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/admin/room/site_control.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627604   Available: 13574958
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h"
/* domain administration room */
#include "access.h"
inherit "/std/room/basic_room";
#define MASTER "/secure/master"

int do_banish(string);
int do_access(); /* Show the current access list. */
int do_suspend(string);
int do_unsuspend(string);


void setup() {
//  string *doms, com;
//  int i;
  
  set_light(100);
  set_short("site-access control room");
  add_property("determinate", "the ");
  set_long(
    "In front of you teem hundreds of small packages.  They rush around "+
    "yelling out strange numbers and get directed into various parts "+
    "of the maze by large mice with red flags.  Everything happens at "+
    "break neck speed.  Every now and then one of the packages "+
    "spontaneously combusts.\n"+
"Available commands:\n"+
"  ban       :  Ban a site.\n"+
"  access    :  Show the current access of various sites.\n"+
"  suspend   :  Suspend someones access.\n"+
"  unsuspend :  Unsuspend someones access.\n");

  seteuid("Admin");

  add_exit("north", ROOM+"domain_control", "corridor");
} /* setup() */

#if efun_defined(add_action)
#define NUM
#else
#define NUM 1
#endif

void init() {
  ::init();
  if (!interactive(previous_object(NUM))) return 0;
  if ("/secure/master"->query_lord(geteuid(previous_object(NUM))))
    add_command("ban", "<string>", (:do_banish($4[0]):));
  add_command("access", "", (:do_access():));
  add_command("suspend", "<string'person'>", (:do_suspend($4[0]):));
  add_command("unsuspend", "<string'person'>", (:do_unsuspend($4[0]):));
} /* init() */

int print_access(string bit, mapping bing, int depth, int cols) {
  mixed *bits;
  int i;

  if (this_player() != this_player(1))
    return 0;
  bits = m_indices(bing);
  if (depth == 4) {
/* Do the ident printing... */
    for (i=0;i<sizeof(bits);i++)
      switch (bing[bits[i]][0]) {
        case NO_NEW :
          printf("%s@%-=*s", bits[i], cols - strlen(bits[i]), bit +
                             " set to no new characters.\n");
          break;
        case NO_ACCESS :
          printf("%s@%-=*s", bits[i], cols - strlen(bits[i]), bit +
                             " set to no characters.\n");
          break;
        case ACCESS :
          printf("%s@%-=*s", bits[i], cols - strlen(bits[i]), bit +
                             " set to normal access.\n");
          break;
    }
    return 1;
  }
  for (i=0;i<sizeof(bits);i++)
    print_access(bit+"."+bits[i], bing[bits[i]], depth+1, cols);
  return 1;
} /* print_access() */

int do_access() {
  mixed bing;

  if (this_player() != this_player(1))
    return 0;
  bing = (mixed)"/secure/bastards"->query_all_access();
  if (!m_sizeof(bing)) {
    notify_fail("No access control defined.\n");
    return 0;
  }

  write("Current access list:\n");
  print_access("", bing, 0, (int)this_player()->query_cols());
  return 1;
} /* do_access() */

int do_banish(string str) {
  string ip, ident, reason;
  int level;

  if (this_player() != this_player(1))
    return 0;
  if (!"/secure/master"->high_programmer(geteuid(previous_object())))
    return 0;
  notify_fail("Syntax: banish <ip number> <ident> <level> <reason>\n"+
              "        <level> := 0 delete ident, 1 normal access,\n"+
              "                   2 no new players, 3 No access.\n");
  if (!str)
    return 0;
  if (sscanf(str, "%s %s %d %s", ip, ident, level, reason) != 4)
    return 0;

  if (!"/secure/bastards"->change_access(explode(ip, "."), ident, level,
                                         reason))
    return 0;
  write("Access permisions changed.\n");
  return 1;
} /* do_banish() */

int do_suspend(string str) {
  string reason;
  string name;
  int tim;

  if (this_player() != this_player(1))
    return 0;
  if (!"/secure/master"->query_lord(geteuid(previous_object())))
    return 0;
  if (!str || sscanf(str, "%s %d %s", name, tim, reason) != 3) {
    notify_fail("Syntax: suspend <name> <time> <reason>\nWhere time is in hours.\n");
    return 0;
  }
  notify_fail("We failed!\n");
  if (!"/secure/bastards"->suspend_person(name, tim*60*60, reason))
    return 0;
  write(name+" suspended until "+ctime(time()+tim*60*60)+"\n");
  return 1;
} /* do_suspend() */

int do_unsuspend(string str) {
  if (this_player() != this_player(1))
    return 0;
  if (!"/secure/master"->query_lord(geteuid(previous_object())))
    return 0;
  notify_fail("We failed!\n");
  if (!"/secure/bastards"->unsuspend_person(str))
    return 0;
  write(str+" unsuspended.\n");
  return 1;
} /* do_unsuspend() */
// --- END [/mnt/home2/grok/lib/d/admin/room/site_control.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/admin/room/access_control.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/admin/room/access_control.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627603   Available: 13574957
Inodes: Total: 5242880    Free: 4960133
13519 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/admin/room/access_control.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627603   Available: 13574957
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* file access control room */

#include <access.h>
#include "path.h"

inherit "/std/room/basic_room";

#define LOGIN "/secure/login"
#define READ_MASK 1
#define WRITE_MASK 2
#define GRANT_MASK 4
#define LOCK_MASK 8

int do_read(string euid, string path);
int do_write(string euid, string path);
int do_grant(string euid, string path);
int do_lock(string path);
int do_noread(string euid, string path);
int do_nowrite(string euid, string path);
int do_nogrant(string euid, string path);
int do_unlock(string path);
int do_summary(string str);
int do_tidy();

void setup() {
  set_light(100);
  set_short("file-access control room");
  add_property("determinate", "the ");
  set_long(
    "You are in a room full of filing cabinets.  There are filing "
    "cabinets everywhere, they are all packed full of papers and look "
    "in a horrible mess.\n"
"Available commands:\n"
"  read    <euid> <path>     : add read permission to the path.\n"
"  write   <euid> <path>     : add write permission to the path.\n"
"  grant   <euid> <path>     : add granting privileges to the path.\n"
"  lock           <path>     : restrict access to the path.\n"
"  noread  <euid> <path>     : remove read permission from the path.\n"
"  nowrite <euid> <path>     : remove write permission from the path.\n"
"  nogrant <euid> <path>     : remove granting privileges to the path.\n"
"  unlock         <path>     : remove restrictions to path.\n"
"  summary [path|euid]       : give a list of all the read/write perms.\n"
"  tidy                      : tidy away unnecessary perms.\n" );
  add_exit("east", ROOM+"domain_control", "corridor");
} /* setup() */

void init() {
  ::init();
  this_player()->add_command("read",    this_object(),
    "<string'euid'> <string'path'>", (: do_read($4[0], $4[1]) :) );
  this_player()->add_command("write",   this_object(), 
    "<string'euid'> <string'path'>", (: do_write($4[0], $4[1]) :) );
  this_player()->add_command("grant",   this_object(), 
    "<string'euid'> <string'path'>", (: do_grant($4[0], $4[1]) :) );
  this_player()->add_command("lock",    this_object(),
    "<string'path'>",                (: do_lock($4[0]) :) );
  this_player()->add_command("noread",  this_object(),
    "<string'euid'> <string'path'>", (: do_noread($4[0], $4[1]) :) );
  this_player()->add_command("nowrite", this_object(),
    "<string'euid'> <string'path'>", (: do_nowrite($4[0], $4[1]) :) );
  this_player()->add_command("nogrant", this_object(),
    "<string'euid'> <string'path'>", (: do_nogrant($4[0], $4[1]) :) );
  this_player()->add_command("unlock",  this_object(),
    "<string'path'>",                (: do_unlock($4[0]) :) );
  this_player()->add_command("summary", this_object(),
    "<string'path or euid'>",        (: do_summary($4[0]) :) );
  this_player()->add_command("tidy",    this_object(),
    "",                              (: do_tidy() :) );
} /* init() */

int do_read(string euid, string path) {
  if (!sizeof(filter(previous_object(-1), (: interactive($1) :)))) {
    event(users(), "inform", "Illegal attempt to call do_read("+euid+", "+path+") by "+
          this_player()->one_short(), "cheat");
    unguarded((: write_file, "/log/CHEAT", ctime(time())+": Illegal attempt "
               "to call do_read("+euid+", "+path+").\nBacktrace: "+ back_trace() :));
    return 0;
  }
  path = (string)this_player()->get_path(path);
  if (!master()->high_programmer(previous_object(-1)) &&
      !master()->valid_grant(previous_object(), path, READ_MASK)) {
    notify_fail("You do not have permission to add read access.\n");
    return 0;
  }
  notify_fail("Something went wrong.\n");
  return (int)master()->add_read_permission(euid, path);
} /* do_read() */

int do_write(string euid, string path) {
  if (!sizeof(filter(previous_object(-1), (: interactive($1) :)))) {
    event(users(), "inform", "Illegal attempt to call do_write("+euid+", "+path+") by "+
          this_player()->one_short(), "cheat");
    unguarded((: write_file, "/log/CHEAT", ctime(time())+": Illegal attempt "
               "to call do_write("+euid+", "+path+").\nBacktrace: "+ back_trace() :));
    return 0;
  }
  path = (string)this_player()->get_path(path);
  if (!master()->high_programmer(previous_object(-1)) &&
      !master()->valid_grant(previous_object(), path, WRITE_MASK)) {
    notify_fail("You do not have permission to add write access.\n");
    return 0;
  }
  notify_fail("Something went wrong.\n");
  return (int)master()->add_write_permission(euid, path);
} /* do_write() */

int do_grant(string euid, string path) {
  if (!sizeof(filter(previous_object(-1), (: interactive($1) :)))) {
    event(users(), "inform", "Illegal attempt to call do_grant("+euid+", "+path+") by "+
          this_player()->one_short(), "cheat");
    unguarded((: write_file, "/log/CHEAT", ctime(time())+": Illegal attempt "
                 "to call do_grant("+euid+", "+path+").\nBacktrace: "+ back_trace() :));
    return 0;
  }
  path = (string)this_player()->get_path(path);
  if (!master()->high_programmer(previous_object(-1)) &&
      !master()->valid_grant(previous_object(), path, GRANT_MASK)) {
    notify_fail("You do not have permission to add grant access.\n");
    return 0;
  }
  notify_fail("Something went wrong.\n");
  return (int)master()->add_grant_permission(euid, path);
} /* do_grant() */

int do_lock(string path) {
  if (!sizeof(filter(previous_object(-1), (: interactive($1) :)))) {
    event(users(), "inform", "Illegal attempt to call do_lock("+path+") by "+
          this_player()->one_short(), "cheat");
    unguarded((: write_file, "/log/CHEAT", ctime(time())+": Illegal attempt "
                 "to call do_lock("+path+").\nBacktrace: "+ back_trace() :));
    return 0;
  }
  if (!path)
    return notify_fail("Syntax: "+query_verb()+" <path>\n");
  if (!master()->query_lord(previous_object(-1)))
    return notify_fail("You don't have permission to lock paths.\n");
  if ((path[0..2] != "/d/") &&
      !master()->high_programmer(previous_object(-1)))
    return notify_fail("You don't have permission to lock paths there.\n");
  notify_fail("Something went wrong.\n");
  return (int)master()->lock_path(path);
}

int do_noread(string euid, string path) {
  if (!sizeof(filter(previous_object(-1), (: interactive($1) :)))) {
    event(users(), "inform", "Illegal attempt to call do_noread("+euid+", "+path+") by "+
          this_player()->one_short(), "cheat");
    unguarded((: write_file, "/log/CHEAT", ctime(time())+": Illegal attempt "
                 "to call do_noread("+euid+", "+path+").\nBacktrace: "+ back_trace() :));
    return 0;
  }
  path = (string)this_player()->get_path(path);
  if (!master()->high_programmer(previous_object(-1)) &&
      !master()->valid_grant(previous_object(), path, READ_MASK)) {
    notify_fail("You do not have permission to remove read access.\n");
    return 0;
  }
  notify_fail("Something went wrong.\n");
  return (int)master()->remove_read_permission(euid, path);
} /* do_noread() */

int do_nowrite(string euid, string path) {
  if (!sizeof(filter(previous_object(-1), (: interactive($1) :)))) {
    event(users(), "inform", "Illegal attempt to call do_nowrite("+euid+", "+path+") by "+
          this_player()->one_short(), "cheat");
    unguarded((: write_file, "/log/CHEAT", ctime(time())+": Illegal attempt "
                 "to call do_nowrite("+euid+", "+path+").\nBacktrace: "+ back_trace() :));
    return 0;
  }
  path = (string)this_player()->get_path(path);
  if (!master()->high_programmer(previous_object(-1)) &&
      !master()->valid_grant(previous_object(), path, WRITE_MASK)) {
    notify_fail("You do not have permission to remove write access.\n");
    return 0;
  }
  notify_fail("Something went wrong.\n");
  return (int)master()->remove_write_permission(euid, path);
} /* do_nowrite() */

int do_nogrant(string euid, string path) {
  if (!sizeof(filter(previous_object(-1), (: interactive($1) :)))) {
    event(users(), "inform", "Illegal attempt to call do_nogrant("+euid+", "+path+") by "+
          this_player()->one_short(), "cheat");
    unguarded((: write_file, "/log/CHEAT", ctime(time())+": Illegal attempt "
               "to call do_nogrant("+euid+", "+path+").\nBacktrace: "+ back_trace() :));
    return 0;
  }
  path = (string)this_player()->get_path(path);
  if (!master()->high_programmer(previous_object(-1)) &&
      !master()->valid_grant(previous_object(), path, GRANT_MASK)) {
    notify_fail("You do not have permission to remove grant access.\n");
    return 0;
  }
  notify_fail("Something went wrong.\n");
  return (int)master()->remove_grant_permission(euid, path);
} /* do_nogrant() */

int do_unlock(string path) {
  if (!sizeof(filter(previous_object(-1), (: interactive($1) :)))) {
    event(users(), "inform", "Illegal attempt to call do_unlock("+path+") by "+
          this_player()->one_short(), "cheat");
    unguarded((: write_file, "/log/CHEAT", ctime(time())+": Illegal attempt "
               "to call do_unlock("+path+").\nBacktrace: "+ back_trace() :));
    return 0;
  }
  if (!path)
    return notify_fail("Syntax: "+query_verb()+" <path>\n");
  if (!master()->query_lord(previous_object(-1)))
    return notify_fail("You don't have permission to lock paths.\n");
  if ((path[0..2] != "/d/") &&
      !master()->high_programmer(previous_object(-1)))
    return notify_fail("You don't have permission to lock paths there.\n");
  notify_fail("Something went wrong.\n");
  return (int)master()->unlock_path(path);
}

int list_before( string first, string second ) {
   if ( first < second )
      return -1;
   if ( first > second )
      return 1;
   return 0;
} /* list_before() */

int do_summary(string str) {
  mapping perms;
  string *paths, *euids, ret, creator;
  int i, j, k;
   
  perms = (mapping)master()->query_permissions();
  if (str) {
    if (!perms[str]) {
      if (!LOGIN->test_user(str) && !master()->valid_euid(str)) {
        write("There are no permissions for "+str+".\n");
        return 1;
      } else {
        creator = str; 
      }
    } else {
      perms = ([ str : perms[str] ]);
    }
  }
  paths = sort_array( m_indices( perms ), "list_before", this_object() );
  if (!sizeof(paths))
    ret = "No permissions set.\n";
  else
    ret = sprintf("%11-s    Path\n", "Euid");
  for (i=0;i<sizeof(paths);i++) {
    euids = m_indices(perms[paths[i]]);
    for (j=0;j<sizeof(euids);j++) {
      if (!creator || (euids[j] == creator ) ) {
        k = perms[paths[i]][euids[j]];
        if (k & LOCK_MASK)
          ret += sprintf("%11-s LCK %s\n", euids[j], paths[i]);
        else
          ret += sprintf("%11-s %c%c%c %s\n", euids[j],(k & READ_MASK?'R':' '),
                         (k & WRITE_MASK?'W':' '), (k & GRANT_MASK?'G':' '),
                         paths[i]);
      }
    }
  }
  this_player()->more_string( ret, "Permissions", 1 );
  return 1;
} /* do_summary() */

int do_tidy() {
   int i, j, perm, same;
   string path, creator, *bits;
   mapping perms, euids, others;

   if (!sizeof(filter(previous_object(-1), (: interactive($1) :)))) {
      event( users(), "inform", "illegal attempt to call do_tidy() by "+
            (string)this_player()->query_name(), "cheat" );
      unguarded((: write_file, "/log/CHEAT", ctime( time() ) +": illegal "
                   "attempt to call do_tidy() by "+
                   (string)this_player()->query_name() +"\n" :));
      return notify_fail( "Failed.\n" );
   }
   perms = (mapping)master()->query_permissions();
   foreach( path in keys( perms ) ) {
      euids = perms[ path ];
      foreach( creator in keys( euids ) ) {
         perm = euids[ creator ];
         if ( !LOGIN->test_creator( creator ) &&
              !master()->valid_euid( creator ) ) {
            write( "No creator: "+ creator +".\n" );
            if ( perm & READ_MASK )
               master()->remove_read_permission( creator, path );
            if ( perm & WRITE_MASK )
               master()->remove_write_permission( creator, path );
            if ( perm & GRANT_MASK )
               master()->remove_grant_permission( creator, path );
            continue;
         }
         if ( path == "/" )
            continue;
         same = perms[ "/" ][ creator ] & perm;
         if ( same ) {
            write( "Access to / supercedes "+ path +" for "+ creator +".\n" );
            if ( same & READ_MASK )
               master()->remove_read_permission( creator, path );
            if ( same & WRITE_MASK )
               master()->remove_write_permission( creator, path );
            if ( same & GRANT_MASK )
               master()->remove_grant_permission( creator, path );
            continue;
         }
         bits = explode( path, "/" );
         j = sizeof( bits ) - 1;
         for ( i = 0; i < j; i++ ) {
            others = perms[ "/"+ implode( bits[ 0 .. i ], "/" ) ];
            if ( !others )
               continue;
            same = others[ creator ] & perm;
            if ( same ) {
               write( "Access to /"+ implode( bits[ 0 .. i ], "/" ) +
                     " supercedes "+ path +" for "+ creator +".\n" );
               if ( same & READ_MASK )
                  master()->remove_read_permission( creator, path );
               if ( same & WRITE_MASK )
                  master()->remove_write_permission( creator, path );
               if ( same & GRANT_MASK )
                  master()->remove_grant_permission( creator, path );
               break;
            }
         }
      }
   }
   return 1;
} /* do_tidy() */
// --- END [/mnt/home2/grok/lib/d/admin/room/access_control.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/admin/room/playroom.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/admin/room/playroom.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627599   Available: 13574953
Inodes: Total: 5242880    Free: 4960133
1438 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/admin/room/playroom.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627599   Available: 13574953
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <config.h>

inherit "/std/room/basic_room";

object board;

void reset() {
  if(!board) {
    board = clone_object("obj/misc/board");
    board->set_datafile("playerhelp");
    board->move(this_object());
  }
}

void setup() {
  set_light(60);
  set_short("Player Help Room");
  set_long(
"You are in a strange room with hundreds of frozen statues in the likenesses "+
"of many players on the DiscWorld.  They all seem to be begging, and "+
"looking at you with mournful eyes.\n");
  add_item(({"player","statue"}),
"They all look as if they are asking you questions, but without "+
"moving their lips.  Some of them look genuinly hopeless, but most "+
"have the look of treachery and deceit.  Quite a few of them have many "+
"faces looking in several directions.  Beware them all.\n");
  add_exit("east", "/w/common", "door");
}

void dest_me() {
  if (board)
    board->dest_me();
  ::dest_me();
}

void event_enter(object ob) {
  if (!ob->query_creator() && !ob->query_property("demon")) {
      tell_object(ob, "Whoops!  You don't seem to be a creator.\n");
      call_out("do_move", 2, ob);
   }
} /* event_enter() */

void do_move(object ob) {
   tell_object( ob, "A trap door opens in the floor and you fall through!\n" );
   ob->move_with_look( "/d/am/am/mendeddrum", "$N fall$s through a trap "+
         "door in the ceiling.", "A trap door opens in the floor and "+
         "$N fall$s through." );
} /* do_move() */
// --- END [/mnt/home2/grok/lib/d/admin/room/playroom.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/admin/room/mail_room.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/admin/room/mail_room.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627599   Available: 13574953
Inodes: Total: 5242880    Free: 4960133
6642 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/admin/room/mail_room.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627599   Available: 13574953
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/room/basic_room";

#include "path.h"
#include <mail.h>

#define NAME (string)this_player()->query_name()
#define HIGHLORD() (master()->high_programmer(NAME))

int do_add(string list, string name);
varargs int do_list(string str);
int do_create(string str);
int do_remove(string list, string names);

void setup() {
  set_short("Mail control room");
  set_long(
"This is the mail control room.  You can see several frogs hopping around "
"looking important, sorting mail into nice little boxes, putting them in "
"their backpacks and hopping off into the distance.  Over to the west of "
"the room is a small control panel, with odd levers and lots of strange "
"buttons.\n");
  set_light(100);

  add_exit("south", ROOM + "development", "door"); 

  add_item("important looking post office frog",
           "They are rushing around in a seemless unending hurry.  They are "
           "all wearing nice little hats that have the post office symbol on "
           "them.");
  add_item("box",
           "There are several nice boxes around the room.  They all appear "
           "to be labeled in some arcane script.  If you squint at them they "
           "form interesting patterns.");
  add_item("backpack",
           "Every frog has its own backback.  Some are full, some are empty, "
           "but they all have them.  The regulation backback is about big "
           "enough to contain over a hundred letters.  Some of them look "
           "battered and worn as if they have seen many years of service.");
  add_item("control panel",
           "It is covered with odd levers and buttons.  Some of them are "
           "labeled in a readable script.  They are \"add\", \"list\", "
           "\"listcreate\" and \"remove\".");
} /* setup() */

void init() {
  ::init();

  if (!this_player()) return;

  this_player()->add_command(
    "add", this_object(),
    "<string:small'list'> <string:long'names'>",
    (: do_add($4[0], $4[1]) :) );
  this_player()->add_command(
    "list", this_object(),
    "<string:small'list'>",
    (: do_list($4[0]) :) );
  this_player()->add_command(
    "list", this_object(),
    "",
    (: do_list() :) );
  this_player()->add_command(
    "remove", this_object(),
    "<string:small'list'> <string:long'names'>",
    (: do_remove($4[0], $4[1]) :) );
  this_player()->add_command(
    "listcreate", this_object(),
    "<string:small'list'>",
    (: do_create($4[0]) :) );
} /* init() */

int do_add(string list, string name) {
  string *names;

  if (!MAIL_TRACK->query_list(list)) {
    notify_fail("The mailing list \"" + list + "\" does not exist.\n");
    return 0;
  }
  if (!(MAIL_TRACK->query_controller(list, NAME) || HIGHLORD())) {
    notify_fail("You have to be a controller of a list to be able to add a "
                "member.\n");
    return 0;
  }
  names = explode(replace(lower_case(name), " ", ","), ",") - ({ "" });
  if (!sizeof(names)) {
    notify_fail("It helps if you tell me who to add.\n");
    return 0;
  }
  foreach (name in names) {
    if (name[0] == '*') {
      /* They are trying to add a controller. */
      name = name[1..];
      if (!"/secure/login"->test_user(name)) {
        write("The player \"" + name + "\" does not exist.\n");
      } else if (MAIL_TRACK->add_controller(list, name)) {
        write("Added " + name + " as a controller of \"" + list + "\".\n");
      } else {
        write("Failed to add " + name + " as a controller of \"" +
              list + "\".\n");
      }
    } else if (!"/secure/login"->test_user(name) &&
               !MAIL_TRACK->query_list(name)) {
      write("The player \"" + name + "\" does not exist.\n");
    } else if (MAIL_TRACK->add_member(list, name)) {
      write("Added " + name + " to the mailing list.\n");
    } else {
      write("Failed to add " + name + " to the mailing list.\n");
    }
  }
  return 1;
} /* do_add() */

varargs int do_list(string str) {
  string *strs, *cont, creator;

  if (!str) {
    strs = MAIL_TRACK->query_mailing_lists();
    write("$I$5=Current mailing lists: " + query_multiple_short(strs) + ".\n");
  } else {
    strs = MAIL_TRACK->query_members(str);
    cont = MAIL_TRACK->query_controllers(str);
    if (!sizeof(strs)) {
      notify_fail("The mailing list \""+str+"\" does not exist.\n");
      return 0;
    }
    if ((creator = MAIL_TRACK->query_creator(str))) {
      write("The list \"" + str + "\" was created by " + creator + ".\n");
    }
    if (sizeof(cont)) {
      write("$I$5=Controllers of list \"" + str + "\": " +
            query_multiple_short(cont) + ".\n");
    }
    write("$I$5=Members of list \"" + str + "\": " +
          query_multiple_short(strs) + ".\n");
  }
  return 1;
} /* do_list() */

int do_remove(string list, string name) {
  string *names;

  if (!MAIL_TRACK->query_list(list)) {
    notify_fail("The mailing list \""+list+"\" does not exist.\n");
    return 0;
  }
  if (!(MAIL_TRACK->query_controller(list, NAME) || HIGHLORD())) {
    notify_fail("You have to be a controller of a list to be able to "+
                "remove a member.\n");
    return 0;
  }
  names = explode(replace(lower_case(name), " ", ","), ",") - ({ "" });
  if (!sizeof(names)) {
    notify_fail("It helps if you tell me who to remove.\n");
    return 0;
  }
  foreach (name in names) {
    if (name[0] == '*') {
      /* They are trying to remove a controller. */
      name = name[1..];
      if (MAIL_TRACK->remove_controller(list, name)) {
        write("Removed " + name + " as a controller of \"" + list + "\".\n");
      } else {
        write("Failed to remove " + name + " as a controller of \"" +
              list + "\".\n");
      }
    } else if (MAIL_TRACK->query_controller(list, name) && (name != NAME)) {
      write("Could not remove " + name + ", because " + name + " is a "
            "controller of \"" + list + "\".\n");
    } else if (MAIL_TRACK->remove_member(list, name)) {
      write("Removed " + name + " from the mailing list.\n");
    } else {
      write("Could not remove " + name + " from the mailing list.\n");
    }
  }
  return 1;
} /* do_remove() */

int do_create(string str) {
  if (MAIL_TRACK->query_list(str)) {
    notify_fail("The list \"" + str + "\" already exists.\n");
    return 0;
  }
  if (sscanf(str, "%*s %*s") == 2 || sscanf(str, "%*s,%*s")) {
    notify_fail("The mailing list name cannot have spaces or commas in it.\n");
    return 0;
  }
  if (MAIL_TRACK->create_list(str, this_player()->query_name())) {
    write("Created the mailing list \""+str+"\".\n");
    return 1;
  }
  notify_fail("Failed to create the mailing list.\n");
  return 0;
} /* do_create() */
// --- END [/mnt/home2/grok/lib/d/admin/room/mail_room.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/admin/room/we_care/main_club_room.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/admin/room/we_care/main_club_room.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627597   Available: 13574951
Inodes: Total: 5242880    Free: 4960133
290 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/admin/room/we_care/main_club_room.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627597   Available: 13574951
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h"

inherit "/std/room/club_room";

void setup() {
   set_short("main club room");
   set_long("The main club room.\n");
   set_club_controller(CONTROLLER);
   set_light(70);
   set_leave_exit("south");

   add_exit("south", "/d/admin/room/meeting", "door");
} /* setup() */
// --- END [/mnt/home2/grok/lib/d/admin/room/we_care/main_club_room.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/admin/room/we_care/owned_room1.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/admin/room/we_care/owned_room1.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627597   Available: 13574951
Inodes: Total: 5242880    Free: 4960133
252 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/admin/room/we_care/owned_room1.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627597   Available: 13574951
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/room/inherit/club_owned_room";
#include "path.h"

void setup() {
   set_short("The first owned room");
   set_long("A room that is owned.\n");

   set_club_controller(CLUB_CONTROLLER);
   set_club_owned_id("main office");
} /* setup() */
// --- END [/mnt/home2/grok/lib/d/admin/room/we_care/owned_room1.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/admin/room/we_care/club_room_controller.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/admin/room/we_care/club_room_controller.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627596   Available: 13574950
Inodes: Total: 5242880    Free: 4960133
439 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/admin/room/we_care/club_room_controller.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627596   Available: 13574950
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <clubs.h>
inherit "/std/room/controller/club_room_controller";
#include <room/club_room.h>

void setup() {
   set_save_file("/d/admin/save/club_room");
   set_board_associated(1);
   add_controlled_ownership("main room",
                            CLUB_ROOM_CONTROLLER_DISCUSSED,
                            CLUB_ROOM_OWNED_POSITION,
                            (: CLUB_HANDLER->query_president_position($2) :));
} /* setup() */
// --- END [/mnt/home2/grok/lib/d/admin/room/we_care/club_room_controller.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/admin/room/domain_control.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/admin/room/domain_control.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627596   Available: 13574950
Inodes: Total: 5242880    Free: 4960133
8627 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/admin/room/domain_control.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627596   Available: 13574950
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* domain administration room */
#include "access.h"
#include "path.h"
inherit "/std/room/basic_room";
#define MASTER "/secure/master"

int do_list(string arg);
int do_create(string dom, string lord);
int do_list_all();
int do_deputy(string cre, string dom);
int do_undeputy(string cre, string dom);
int do_create(string dom, string lord);
int do_project(string cre, string dom, string project);
int do_add(string cre, string dom);
int do_delete(string cre, string dom);

void setup() {
//  string *doms, com;
//  int i;
  
  set_light(100);
  set_short("domain-control room");
  add_property("determinate", "the ");
  set_long("You float in nothingness, before a vast turtle, its shell pocked "
    "by asteroid craters. In all directions stars twinkle in the black " 
    "curtain of space.\n" 
"Available commands:\n"
"  list                         : list all domains.\n"
"  list <domain>                : list members of a domain.\n"
"  create <domain>              : create a domain (you are lord).\n"
"  create <domain> <lord>       : create a domain for someone else.\n" 
"  add <creator> <domain>       : add a creator to a domain you own.\n" 
"  delete <creator> <domain>    : remove a creator from a domain you own.\n" 
"  project <cre> <dom> <proj>   : Set the creators project.\n"
"  deputy <cre> <dom>           : Appoint creator as a deputy.\n"
"  undeputy <cre> <dom>         : Remove creator as a deputy.\n"
);

  add_item("turtle", "On its back you can see four elephants, and they bear " +
    "the weight of the disc upon their wide backs.\n");
  add_item("elephants", "The four great elephants labour endlessly in the " +
    "task of turning the disc upon their backs.\n");
  add_item("disc", "The whole discworld, from hub to rim, rides upon the " +
    "elephant's backs.\n");
  add_alias("elephant", "elephants");
  add_exit("north", ROOM+"development", "corridor");
  add_exit("south", ROOM+"site_control", "corridor");
  add_exit("west", ROOM+"access_control", "corridor");
  seteuid("Admin");
} /* setup() */

void init() {
  ::init();
/*
  add_action("list", "list", 10);
  add_action("create_domain", "create", 10);
  add_action("add_creator", "add", 10);
  add_action("delete_creator", "delete", 10);
  add_action("do_project", "project", 10);
 */
  add_command("list", "", (: do_list_all() :) );
  add_command("list", "<word>", (: do_list($4[0]) :) );
  add_command("create", "<word>", (: do_create($4[0], 0) :) );
  add_command("create", "<word> <word>", (: do_create($4[0], $4[1]) :) );
  add_command("add", "<word> <word>", (: do_add($4[0], $4[1]) :) );
  add_command("delete", "<word> <word>", (: do_delete($4[0], $4[1]) :) );
  add_command("project", "<word> <word> <string>",
                         (: do_project($4[0], $4[1], $4[2]) :) );
  add_command("deputy", "<word> <word>", (: do_deputy($4[0], $4[1]) :) );
  add_command("undeputy", "<word> <word>", (: do_undeputy($4[0], $4[1]) :) );
} /* init() */

int do_list_all() {
  int i, num;
  string *members, *domains, mast;

  if (this_player() != this_player(1))
    return 0;

  domains = "/secure/master"->query_domains();
  if(!sizeof(domains)) {
    notify_fail("No domains exist.\n");
    return 0;
  }

  write("Current domains:\n");
  for(i=0; i<sizeof(domains); i++) {
    mast = "/d/" + domains[i] + "/master";
    members = (string *)mast->query_members();
    printf( "%15s has %2d %-7s and is owned by %s.\n", domains[ i ],
      num = sizeof( (string *)mast->query_members() ),
      ( ( num == 1 ) ? "member" : "members" ),
      capitalize( (string)mast->query_lord() ) );
  }
  return 1;
} /* list() */

int do_list(string arg) {
  int i, cols;
  string *members, *domains, mast;

  if (this_player() != this_player(1))
    return 0;

  domains = "/secure/master"->query_domains();
  if(!sizeof(domains)) {
    notify_fail("No domains exist.\n");
    return 0;
  }

  if(member_array(arg, domains) == -1) {
    notify_fail("No such domain as " + arg + ".\n");
    return 0;
  } else {
    mast = "/d/" + arg + "/master";
    write(capitalize((string)mast->query_lord()) + " is the lord of " +
      arg + ".\nMembers         Project\n");
    members = (string *)mast->query_members();
    cols = (int)this_player()->query_cols();
    for (i=0;i<sizeof(members);i++)
      printf("%-15s %*-=s\n", members[i], cols-16,
                             mast->query_project(members[i]) +
             (mast->query_deputy(members[i])?" (deputy)":""));
  }
  return 1;
} /* do_list() */

int do_create(string dom, string lord) {
  if (this_player() != this_player(1))
    return 0;

  if(!MASTER->high_programmer(geteuid(previous_object()))) {
    notify_fail("You lack the Power of Change on this scale!\n");
    return 0;
  }
  if (!lord) {
    lord = (string)this_player()->query_name();
  }

  if (!MASTER->create_domain(dom, lord)) {
    notify_fail("Failed to create domain " + dom + " with the lord " + lord
                + ".\n");
    return 0;
  }

  write("You create the domain " + dom + " with " + capitalize(lord) +
    " as its lord.\n");
  return 1;
} /* do_create() */

int do_add(string cre, string dom) {
  string mast;
  
  if (this_player() != this_player(1))
    return 0;

  if(file_size("/d/" + dom) != -2) {
    notify_fail("No such domain as " + dom + ".\n");
    return 0;
  }

  cre = (string)this_player()->expand_nickname(cre);
  mast = "/d/" + dom + "/master";
/* Move this checking into the master object of the domain... */
/*
  if ( !"/secure/master"->query_lord( geteuid( previous_object() ) ) ) {
    notify_fail( "You are not a Lord.\n" );
    return 0;
  }
 */

  if (!mast->add_member(cre)) {
    notify_fail("Failed to add " + capitalize(cre) + " to domain " +
      dom + ".\n");
    return 0;
  }

  write("Creator " + capitalize(cre) + " now added to domain " + dom + ".\n");
  return 1;
} /* do_add() */

int do_delete(string cre, string dom) {
  string mast;

  if (this_player() != this_player(1))
    return 0;

  if(file_size("/d/" + dom) != -2) {
    notify_fail("No such domain as " + dom + ".\n");
    return 0;
  }

  cre = (string)this_player()->expand_nickname(cre);
  mast = "d/" + dom + "/master";
/* Move this checking into the master object of the domain... */
/*
  if ( !"/secure/master"->query_lord( geteuid( previous_object() ) ) ) {
    notify_fail( "You are not a Lord.\n" );
    return 0;
  }
 */

  if (!mast->remove_member(cre)) {
    notify_fail("Failed to remove " + capitalize(cre) + " from domain " +
       dom + "\n");
    return 0;
  }

  write("Member " + capitalize(cre) + " removed from domain " + dom + ".\n");
  return 1;
} /* delete_creator() */

int do_project(string cre, string dom, string project) {
  string mast;

  if (this_player() != this_player(1))
    return 0;

  if(file_size("/d/" + dom) != -2) {
    notify_fail("No such domain as " + dom + ".\n");
    return 0;
  }
  cre = (string)this_player()->expand_nickname(cre);
  mast = "/d/" + dom + "/master";
/*
  if ( !"/secure/master"->query_lord( geteuid( previous_object() ) ) ) {
    notify_fail( "You are not a Lord.\n" );
    return 0;
  }
 */

  if (!mast->set_project(cre, project)) {
    notify_fail("Failed to set the project " + project + " for " +
                capitalize(cre) + " in the domain " + dom + "\n");
    return 0;
  }

  write("Project for " + capitalize(cre) + " set to " + project + 
        " in the domain " + dom + ".\n");
  return 1;
} /* do_project() */

int do_deputy(string cre, string dom) {
  string mast;

  if (this_player() != this_player(1))
    return 0;

  if(file_size("/d/" + dom) != -2) {
    notify_fail("No such domain as " + dom + ".\n");
    return 0;
  }
  cre = (string)this_player()->expand_nickname(cre);
  mast = "d/" + dom + "/master";

  if (!mast->add_deputy(cre)) {
    notify_fail("Failed to add the deputy " +
                capitalize(cre) + " to the domain " + dom + "\n");
    return 0;
  }

  write("Deputy " + capitalize(cre) + " added to "
        "the domain " + dom + ".\n");
  return 1;
} /* do_deputy() */

int do_undeputy(string cre, string dom) {
  string mast;

  if (this_player() != this_player(1))
    return 0;

  if(file_size("/d/" + dom) != -2) {
    notify_fail("No such domain as " + dom + ".\n");
    return 0;
  }
  cre = (string)this_player()->expand_nickname(cre);
  mast = "d/" + dom + "/master";

  if (!mast->remove_deputy(cre)) {
    notify_fail("Failed to remove the deputy " +
                capitalize(cre) + " from the domain " + dom + "\n");
    return 0;
  }

  write("Deputy " + capitalize(cre) + " removed from "
        "the domain " + dom + ".\n");
  return 1;
} /* do_undeputy() */
// --- END [/mnt/home2/grok/lib/d/admin/room/domain_control.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/admin/room/meeting.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/admin/room/meeting.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627594   Available: 13574948
Inodes: Total: 5242880    Free: 4960133
4650 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/admin/room/meeting.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627594   Available: 13574948
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h"
inherit "/std/room/basic_room";

object floor, sign;
string log_bing, chair;

void setup() {
  set_short("Meeting room");
  set_long(
"A large oak table dominates this room.  There are some heavy ornate "+
"looking candle sticks in the center of the table.  The table is "+
"sourounded by large expensive looking teak chairs, at one end of the "+
"table are some larger more expensive looking ones.  There is a small "+
"hammer sitting in the middle of the room.  You can see a small sign on "+
"the wall.\n");
  set_light(70);

  add_item("oak table",
           "A large heavy looking oak table.  It was built to last. "+
           "It looks very old, you can tell by all the worn marks "+
           "at the places around the table where people sit.\n");
  add_item("teak chair",
           "The chairs are overly ornate and obviously in a very good "+
           "condition for their age.  The large chairs at the end are "+
           "obviously not well used (you can tell, all the dust).\n");
  add_item("candle stick",
           "The candle sticks are made of silver, however if you try "+
           "and take them, you notice they are attached to the table "+
           "somehow.  The candles seemed to have been carved into the "+
           "shape of a small chicken holding a torch.\n");
  add_item(({ "hammer", "gavel" }),
           "The gavel looks like ones fo those things so common in "+
           "meeting rooms.  You could bang it around a little maybe, "+
           "it might help if you had it though.\n");
  log_bing = 0;
  sign = add_sign("A small sign with not much written on it.\n",
                  "There is no current chair of the meeting.\n");
}

void reset() {
  if (floor)
    return ;
  floor = clone_object("/std/object");
  floor->set_name("floor");
  floor->set_short( "floor" );
  floor->add_property( "determinate", "the " );
  floor->set_long(
"This is the floor of the meeting.  It gives you the right to speak "+
"during the meeting.  Please give this to the next person to speak "+
"after you have finished.\n");
  floor->move(this_object());
}

void init() {
  string str;

  ::init();
/* So I just banged my gavel.
 * You did what?
 * I banged my gavel and did the "order in the court thing"
 */
  str = previous_object()->query_name();
  if (interactive(previous_object()) && (previous_object()->query_lord()
      || str == chair)) {
    add_action("appoint", "appoint");
    add_action("bang", "bang");
    add_action("recover", "recover"); /* recovers the floor in case of
                                       * loss */
    add_action("do_log", "log");
  }
}

int appoint(string str) {
  object ob;

  if (chair && (string)this_player()->query_name() != chair) {
    notify_fail("The chair has already been apointed.\n");
    return 0;
  }
  if (!(ob = find_player(str))) {
    notify_fail("Sorry, cannot find "+str+" to be the chair.\n");
    return 0;
  }
  chair = str;
  say(this_player()->one_short()+" just appointed "+str+" as the "+
        "chair of the meeting.\n", ob);
  write("Ok, "+str+" is now the chair of the meeting.\n");
  tell_object(ob, this_player()->one_short()+
        " just appointed you the chair of the meeting.\n");
  if (environment(ob) == this_object())
    ob->move(this_object());
  sign->set_read_mess("The chair of the meeting is "+str+".\n");
  return 1;
}

int bang(string str) {
  if ((string)this_player()->query_name() != chair) {
    notify_fail("Only the chair can bang the gavel.\n");
    return 0;
  }
  tell_room(this_object(),
            this_player()->one_short()+" bangs the gavel loudly.  STOP "+
            "STOP!\n");
  return 1;
}

int recover() {
  if (!floor)
    reset();
  floor->move(this_player());
  write("Floor recovered.\n");
  say(this_player()->one_short()+" has recovered the floor.\n");
  return 1;
}

int do_log(string str) {
  if (log_bing && !str) {
    write("Stopped logging.\n");
    log_bing = str;
    return 1;
  }
  if (!str) {
    notify_fail("Syntax: log <file_name>\n"+
                "        log by itself to stop logging.\n");
    return 0;
  }
  if (log_bing)
    write("Stopped loggin to "+log_bing+" and started logging to "+str+".\n");
  else
    write("Logging to "+str+".\n");
  log_bing = str;
  return 1;
}

void event_person_say(object ob, string start, string rest) {
  if (log_bing)
    log_file(log_bing, start+rest+"\n");
}

void event_say(object ob, string rest) {
  if (log_bing)
    log_file(log_bing, rest);
}

void event_soul(object ob, string rest) {
  if (log_bing)
    log_file(log_bing, rest);
}

void dest_me() {
  if (floor)
    floor->dest_me();
  ::dest_me();
}
// --- END [/mnt/home2/grok/lib/d/admin/room/meeting.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/admin/room/terrain.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/admin/room/terrain.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627593   Available: 13574947
Inodes: Total: 5242880    Free: 4960133
13323 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/admin/room/terrain.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627593   Available: 13574947
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h"
#include <terrain.h>

#define COLS (int)this_player()->query_cols()


inherit "/std/room/basic_room";

int do_help();
int do_terrain(string name);
int do_list(string what);
int do_member(string type, string params);
int do_clear();
int do_add(int floating, string file, int x1, int y1, int z1,
	   int x2, int y2, int z2, int level);
int do_remove(int floating, string file, int x1, int y1, int z1,
	   int x2, int y2, int z2);

string terrain_name;
object generator;

void setup() {
   set_short( "terrain-maker room" );
   add_property( "determinate", "the " );
   set_light( 100 );
   set_long( "This room is quite bare, save a notice that has been "
         "taped on the door but its walls have been painted with "
         "scenes of deserts and forests, oceans and mountains, caves and "
         "swamps, and all manner of other types of terrain.\n"
         "Use \"help room\" to list the room's commands.\n" );
   add_exit( "northwest", ROOM +"development", "door" );
   add_sign("The large notice has furled corners and has been taped "
           "and re-taped to the door.\n",
           "Due to the incomprehensible help in this room, this \n"
           "notice was put up to help with the confusion.\n"
           "\n"
           "1.  To get information on a certain terrain, you\n"
           "    need to select that terrain by typing \n"
           "    \"terrain <terrain_name>\".\n"
           "\n"
           "2.  To remove floating or fixed locations within the terrain,\n"
           "    type \"list floating\" or \"list fixed\".\n"
           "\n"
           "    remove floating <path of terrain> <all 6 co ordinates> <level>\n"
           "\n"
           "    remove fixed <path of room>\n"
           "\n"
           "3.  To add a floating location, same as above, only use add.\n"
           "    For both removing and adding, no commas and no .c at the end\n"
           "    of path names.  When removing/adding fixed locations, all\n"
           "    locations must be done one by one.\n", 0, "notice");
} /* setup() */

void reset() {
   if ( !generator ) {
      generator = clone_object( "/obj/handlers/terrain_things/dungeon_maker" );
      generator->move( this_object() );
   }
} /* reset() */

void init() {
  ::init();
  add_command("help", "room", (: do_help() :) );
  add_command("terrain", "<string>", (: do_terrain($4[0]) :) );
  add_command("list", "fixed", (: do_list("fixed") :) );
  add_command("list", "floating", (: do_list("floating") :) );
  add_command("member", "", (: do_member(0,0) :) );
  add_command("member", "fixed <string>",
    (: do_member("fixed", $4[0]) :) );
  add_command("member", "floating <string>",
    (: do_member("floating", $4[0]) :) );
  add_command("add",
    "fixed <word'file'> <number'x'> <number'y'> <number'z'>",
    (: do_add(0, $4[0], $4[1], $4[2], $4[3], 0, 0, 0, 0) :) );
  add_command("add",
    "floating <word'file'> <number'x1'> <number'y1'> <number'z1'> "
      "<number'x2'> <number'y2'> <number'z2'> <number'level'>",
    (: do_add(1, $4[0], $4[1], $4[2], $4[3],
                        $4[4], $4[5], $4[6],
                 $4[7]) :) );
  add_command("add",
    "floating <word'file'> <number'x'> <number'y'> <number'z'> "
      "<number'level'>",
    (: do_add(2, $4[0], $4[1], $4[2], $4[3],
                        0, 0, 0,
                 $4[4]) :) );
  add_command("remove",
    "fixed <word'file'>",
    (: do_remove(0, $4[0], 0, 0, 0, 0, 0, 0) :) );
  add_command("remove",
    "floating <word'file'> <number'x1'> <number'y1'> <number'z1'> "
      "<number'x2'> <number'y2'> <number'z2'>",
    (: do_remove(1, $4[0], $4[1], $4[2], $4[3],
		 $4[4], $4[5], $4[6]) :) );
  add_command("remove",
    "floating <word'file'> <number'x'> <number'y'> <number'z'>",
    (: do_remove(2, $4[0], $4[1], $4[2], $4[3],
		 0, 0, 0 ) :) );
  add_command("clear", "", (: do_clear() :) );
} /* init() */

int do_help () {
  write( "Available commands are:\n\n"+
      "     terrain  -  set terrain name\n"+
      "     list     -  list locations in current terrain\n"+
      "     member   -  find locations matching coordinates\n"+
      "     add      -  add a new location\n"+
      "     remove   -  remove an old location\n"+
      "     clear    -  clear all clones and connections\n" );
  return 1;
} /* do_help() */

int do_terrain( string name ) {
  if ( !name ) {
    if ( stringp( terrain_name ) )
      write( "Terrain name is "+ terrain_name +".\n" );
    else
      write( "There is no terrain name set.\n" );
    return 1;
  }
  write( "Terrain name set to "+ name +".\n" );
  terrain_name = name;
  return 1;
} /* do_terrain() */

int do_list( string word ) {
  int i, size;
  string list;
  mapping locations;
  mixed indeces, values;
  if ( ( word != "fixed" ) && ( word != "floating" ) ) {
    write( "List what? Options are \"fixed\" and \"floating\".\n" );
    return 1;
  }
  if ( !terrain_name ) {
    write( "There is no current terrain name.\n" );
    return 1;
  }
  if ( !( (int)TERRAIN_MAP->get_data_file( terrain_name ) ) ) {
    write( "There are no locations in the terrain "+ terrain_name +".\n" );
    return 1;
  }
  if ( word == "fixed" ) {
    locations = (mapping)TERRAIN_MAP->query_fixed_locations( terrain_name );
    size = m_sizeof( locations );
    indeces = m_indices( locations );
    values = m_values( locations );
    if ( !size ) {
      write( "There are no fixed locations in the terrain "+ terrain_name
                +".\n" );
      return 1;
    }
    list = "The terrain "+ terrain_name +" has the following fixed location"+
              ( size == 1 ? "" : "s" ) +":\n";
    for ( i = 0; i < size; i++ )
      list += sprintf( "% 5d - %-=*s\n", i + 1, COLS - 9, indeces[ i ] +
          " at ("+ values[ i ][ 0 ] +", "+ values[ i ][ 1 ] +", "+
          values[ i ][ 2 ] +")" );
    this_player()->more_string( list, "Fixed" );
    return 1;
  }
  locations = (mapping)TERRAIN_MAP->query_floating_locations( terrain_name );
  size = sizeof( locations );
  if ( !size ) {
    write( "There are no floating locations in the terrain "+ terrain_name
              +".\n" );
    return 1;
  }
  list = "The terrain "+ terrain_name +" has the following floating "+
      "location"+ ( size == 1 ? "" : "s" ) +":\n";
  for ( i = 0; i < size; i++ )
    if ( sizeof( locations[ i ][ 1 ] ) == 3 )
      list += sprintf( "% 5d - %-=*s\n", i + 1, COLS - 9, locations[ i ][ 0 ] +
          " at ("+ locations[ i ][ 1 ][ 0 ] +", "+ locations[ i ][ 1 ][ 1 ] +
          ", "+ locations[ i ][ 1 ][ 2 ] +"), level "+ locations[ i ][ 2 ] );
    else
      list += sprintf( "% 5d - %-=*s\n", i + 1, COLS - 9, locations[ i ][ 0 ] +
          " from ("+ locations[ i ][ 1 ][ 0 ] +", "+ locations[ i ][ 1 ][ 1 ] +
          ", "+ locations[ i ][ 1 ][ 2 ] +") to ("+ locations[ i ][ 1 ][ 3 ] +
          ", "+ locations[ i ][ 1 ][ 4 ] +", "+ locations[ i ][ 1 ][ 5 ] +
          "), level "+ locations[ i ][ 2 ] );
  this_player()->more_string( list, "Floating" );
  return 1;
} /* do_list() */

int do_member( string type, string parameters ) {
  int i, size, *co_ords;
  string list, location;
  mixed *locations;
  if (!type || !parameters) {
    write( "Syntax: member <fixed|floating> <coord1> ...\n" );
    return 1;
  }
  if ( ( type != "fixed" ) && ( type != "floating" ) ) {
    write( "Syntax: member <fixed|floating> ...\n" );
    return 1;
  }
  if ( !terrain_name ) {
    write( "There is no current terrain name.\n" );
    return 1;
  }
  co_ords = allocate( 3 );
  if ( type == "fixed" ) {
    if ( sscanf( parameters, "%d %d %d", co_ords[ 0 ], co_ords[ 1 ],
        co_ords[ 2 ] ) != 3 ) {
      write( "Syntax: member fixed <coord1> <coord2> <coord3>\n" );
      return 1;
    }
    TERRAIN_MAP->get_data_file( terrain_name );
    location = (string)TERRAIN_MAP->member_fixed_locations( co_ords );
    if ( !location ) {
      write( "There is no fixed location in the terrain "+ terrain_name +
          " at ("+ co_ords[ 0 ] +", "+ co_ords[ 1 ] +", "+ co_ords[ 2 ] +
          ").\n" );
      return 1;
    }
    write( "The terrain "+ terrain_name +" has "+ location +" as a fixed "+
        "location at ("+ co_ords[ 0 ] +", "+ co_ords[ 1 ] +", "+ co_ords[ 2 ] +
        ").\n" );
    return 1;
  }
  if ( sscanf( parameters, "%d %d %d", co_ords[ 0 ], co_ords[ 1 ], co_ords[ 2 ] )
      != 3 ) {
    write( "Syntax: member floating <coord1> <coord2> <coord3>\n" );
    return 1;
  }
  TERRAIN_MAP->get_data_file( terrain_name );
  locations = (mixed *)TERRAIN_MAP->member_floating_locations( co_ords );
  size = sizeof( locations ) / 2;
  if ( !size ) {
    write( "There are no floating locations in the terrain "+ terrain_name +
        " at ("+ co_ords[ 0 ] +", "+ co_ords[ 1 ] +", "+ co_ords[ 2 ] +
        ").\n" );
    return 1;
  }
  list = "There "+ ( size == 1 ? "is one floating location" : "are "+
      query_num( size ) +" floating locations " ) +" in the terrain "+
      terrain_name +" at ("+ co_ords[ 0 ] +", "+ co_ords[ 1 ] +", "+
      co_ords[ 2 ] +"):\n";
  for ( i = 0; i < size; i++ )
    list += sprintf( "% 5d - %-=*s\n", i + 1, COLS - 9, locations[ 2 * i ] +
        ", level "+ locations[ 2 * i + 1 ] );
  this_player()->more_string( list, "Member" );
  return 1;
} /* do_member() */

int do_add(int floating,
	   string file, int x1, int y1, int z1,
	   int x2, int y2, int z2, int level)
{
  int *co_ords;

  if ( !terrain_name ) {
    write( "There is no current terrain name.\n" );
    return 1;
  }
  if (floating == 0 || floating == 2) {
    co_ords = allocate(3);
    co_ords[0] = x1;
    co_ords[1] = y1;
    co_ords[2] = z1;
  } else {
    co_ords = allocate(6);
    co_ords[0] = x1;
    co_ords[1] = y1;
    co_ords[2] = z1;
    co_ords[3] = x2;
    co_ords[4] = y2;
    co_ords[5] = z2;
  }
  if (floating == 0) {
    if ( !TERRAIN_MAP->add_fixed_location( terrain_name, file, co_ords ) ) {
      write( "The fixed location "+ file +" in the terrain "+ terrain_name
                +" already exists.\n" );
      return 1;
    }
    write( "The fixed location "+ file +" has been added to the terrain "+
        terrain_name +" at coordinates ("+ co_ords[ 0 ] +", "+ co_ords[ 1 ] +
        ", "+ co_ords[ 2 ] +").\n" );
    return 1;
  }
  TERRAIN_MAP->add_floating_location( terrain_name, file, co_ords, level );
  if ( sizeof( co_ords ) == 6 )
    write( "A floating location using "+ file +" has been added to the "+
        "terrain "+ terrain_name +" from coordinates ("+ co_ords[ 0 ] +", "+
        co_ords[ 1 ] +", "+ co_ords[ 2 ] +") to coordinates ("+ co_ords[ 3 ] +
        ", "+ co_ords[ 4 ] +", "+ co_ords[ 5 ] +") at level "+ level +".\n" );
  else
    write( "A floating location using "+ file +" has been added to the "+
        "terrain "+ terrain_name +" at coordinates ("+ co_ords[ 0 ] +", "+
        co_ords[ 1 ] +", "+ co_ords[ 2 ] +") and level "+ level +".\n" );
  return 1;
} /* do_add() */

int do_remove(int floating,
	   string file, int x1, int y1, int z1,
	   int x2, int y2, int z2)
{
  int *co_ords;
  if ( !terrain_name ) {
    write( "There is no current terrain name.\n" );
    return 1;
  }
  if (floating == 2) {
    co_ords = allocate(3);
    co_ords[0] = x1;
    co_ords[1] = y1;
    co_ords[2] = z1;
  } else if (floating == 1) {
    co_ords = allocate(6);
    co_ords[0] = x1;
    co_ords[1] = y1;
    co_ords[2] = z1;
    co_ords[3] = x2;
    co_ords[4] = y2;
    co_ords[5] = z2;
  }
  if ( floating == 0 ) {
    if ( !TERRAIN_MAP->delete_fixed_location( terrain_name, file ) ) {
      write( "There is no fixed location "+ file +" in the terrain "+
          terrain_name +" to remove.\n" );
      return 1;
    }
    write( "The fixed location "+ file +" has been removed from the terrain "+
        terrain_name +".\n" );
    return 1;
  }
  if ( !TERRAIN_MAP->delete_floating_location( terrain_name, file, co_ords ) ) {
    if ( sizeof( co_ords ) == 6 )
      write( "There is no floating location using "+ file +" in the terrain "+
          terrain_name +" from coordinates ("+ co_ords[ 0 ] +", "+
          co_ords[ 1 ] +", "+ co_ords[ 2 ] +") to coordinates ("+ co_ords[ 3 ] +
          ", "+ co_ords[ 4 ] +", "+ co_ords[ 5 ] +") to remove.\n" );
    else
      write( "There is no floating location using "+ file +" in the terrain "+
          terrain_name +" at coordinates ("+ co_ords[ 0 ] +", "+ co_ords[ 1 ] +
          ", "+ co_ords[ 2 ] +") to remove.\n" );
    return 1;
  }
  if ( sizeof( co_ords ) == 6 )
    write( "The floating location using "+ file +" in the terrain "+
        terrain_name +" from coordinates ("+ co_ords[ 0 ] +", "+ co_ords[ 1 ] +
        ", "+ co_ords[ 2 ] +") to coordinates ("+ co_ords[ 3 ] +", "+
        co_ords[ 4 ] +", "+ co_ords[ 5 ] +") has been removed.\n" );
  else
    write( "The floating location using "+ file +" in the terrain "+
      terrain_name +" at coordinates ("+ co_ords[ 0 ] +", "+ co_ords[ 1 ] +
      ", "+ co_ords[ 2 ] +") has been removed.\n" );
  return 1;
} /* do_remove() */

int do_clear() {
  if ( !terrain_name ) {
    write( "There is no current terrain name.\n" );
    return 1;
  }
  TERRAIN_MAP->clear_cloned_locations( terrain_name );
  TERRAIN_MAP->clear_connections( terrain_name );
  write( "Clones and connections cleared for the terrain "+ terrain_name +
      ".\n" );
  return 1;
} /* do_clear() */
// --- END [/mnt/home2/grok/lib/d/admin/room/terrain.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/admin/room/development.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/admin/room/development.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627589   Available: 13574943
Inodes: Total: 5242880    Free: 4960133
1119 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/admin/room/development.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627589   Available: 13574943
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h"
inherit "/std/room/basic_room";

object board;

void reset() {
  if(!board) {
    board = clone_object("obj/misc/board");
    board->set_datafile("development");
    board->move(this_object());
  }
}

void setup() {
  set_light(80);
  set_short("Mud Development Office");
  set_long(
    "You are in the Development Office of the mud. Maps and charts of the "+
    "world adorn the panelled walls. Forms sit on a table near the door "+
    "for registration of new projects. A few bored looking clerks rustle "+
    "some papers and try to look busy.\n");
  add_item("clerk", "They seem more interested in coffee than work.\n");
  add_item("map", "Type 'list' to see available maps, and 'read' to look "+
           "at one.\n");
  add_exit("west", "w/common", "door");
  add_exit("east", ROOM+"quest_room", "door");
  add_exit("north", ROOM+"mail_room", "door");
  add_exit("south", ROOM+"domain_control", "corridor");
  add_exit("northeast", ROOM+"cloner_control", "door");
   add_exit( "southeast", ROOM +"terrain", "door" );
}

void dest_me() {
  if (board)
    board->dest_me();
  ::dest_me();
}
// --- END [/mnt/home2/grok/lib/d/admin/room/development.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/admin/obj/check.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/admin/obj/check.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627589   Available: 13574943
Inodes: Total: 5242880    Free: 4960133
2797 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/admin/obj/check.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627589   Available: 13574943
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*

 Inventory checker made by Funtime to periodically check players inventories
 17/5/1994
 
*/

#define SAVE_FILE "/d/admin/log/"

string *paths, *cloned_by;
int *times;
mapping illegal;

void dest_me()
{
   destruct(this_object());
}

void create()
{
   illegal = ([ ]);
   paths = ({ });
   cloned_by = ({ });
}

void log_file()
{
   int p;
   string *person, *filename;

   filename=m_indices(illegal);
   person=values(illegal);
   
   if(sizeof(illegal)>0) {
      unguarded((: write_file, SAVE_FILE+"illegal.txt",
                 "\nSearch carried out on "+ctime(time())+" from here.\n" :));
      
      for(p=0;p<sizeof(illegal);p++) {
         unguarded((: write_file, SAVE_FILE+"illegal.txt",
                    filename[p]+"  -  on player "+person[p]+" - cloned by "+
                    cloned_by[p]+"\n" :));
      }
   }
}

void check_sub_inv(object *things, object owner)
{
int q, r, check;
string *pre_filename, filename, *switcher;
mixed info;

   for(q=0;q<sizeof(things);q++)
   {  
      pre_filename=explode(file_name(things[q]),"#");
      
      filename=pre_filename[0];
                  
      switcher=explode(filename,"/");

      if( (switcher[0]=="w") && (!owner->query_creator() ) )
      {
         illegal=illegal+([filename:owner->query_name()]);

/* Find out who the object was cloned by */

         info = things[q]->stats();

         for(r=0; r<sizeof(info);r++)
         {
            if(info[r][0] == "cloned by")
            {
               cloned_by = cloned_by + ({ info[r][1] });
            }
         }

         /*
         Remove comment here if you want it dested.
         */
         
           destruct(things[q]);
/*
         things[q]->dest_me();
     */
       }
     
      if ( (!owner->query_creator()) && (sizeof(switcher)>2) && (switcher[0]=="obj") && (switcher[1]=="misc") )
      {
         /*
         Remove comment here if you want it dested.
         */
         switch(switcher[2]){
         
         case "mailer_ob":
         case "board_mas":
            info = things[q]->stats();

            for(r=0; r<sizeof(info);r++)
            {

               if(info[r][0] == "cloned by")
               {

                  cloned_by = cloned_by + ({ info[r][1] });
               }
            }

            illegal=illegal+([filename:owner->query_name()]);

             destruct(things[q]);

            break;
         }
      }   
   }
}

void check_inv(object player)
{
int q;
object *things, *contents, owner;

   things=deep_inventory(player);
   
   owner=player;
   check_sub_inv(things, player);
}

do_seek()
{
   int p;
   object *everyone_on;

   seteuid("Admin");

   everyone_on = users();
   
   for(p=0;p<sizeof(everyone_on);p++)
   {
      check_inv(everyone_on[p]);
   }

   log_file();

   return 1;
}
// --- END [/mnt/home2/grok/lib/d/admin/obj/check.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/admin/obj/bingle.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/admin/obj/bingle.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627588   Available: 13574942
Inodes: Total: 5242880    Free: 4960133
2323 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/admin/obj/bingle.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627588   Available: 13574942
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:45.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/object";

void setup() {
  set_name("domainer");
  set_long(
"This object shows you all of the creators who are in each domain and those "+
"that don't have directorys, are not cretors and ones who are not in a "+
"domain at all.\nThe command to view all this is \"info\".\n");
} /* setup() */

void init() {
  add_action("do_info", "info");
} /* init() */

int do_info(string str) {
  string *creators,
         *domains,
         *mem,
         *cre_not,
         bit;
  mapping no_dir, not_creator;
  int i, j, cols;

  cols = (int)this_player()->query_cols();
  creators = get_dir("/w/");
  domains = get_dir("/d/");
  no_dir = ([ ]);
  not_creator = ([ ]);
  cre_not = ({ });
  for (i=0;i<sizeof(creators);i++)
    if (file_size("/w/"+creators[i]) != -2) {
      creators = delete(creators, i, 1);
      i--;
    } else if (!"/secure/login"->test_creator(creators[i])) {
      cre_not += ({ creators[i] });
      creators = delete(creators, i, 1);
      i--;
    }
  for (i=0;i<sizeof(domains);i++) {
    mem = (string *)("/d/"+domains[i]+"/master")->query_members() +
          ({ (string *)("/d/"+domains[i]+"/master")->query_lord() });
/* remove the members from the creators domain. */
    creators -= mem;
/* Check each one... */
    for (j=0;j<sizeof(mem);j++) {
      if (file_size("/w/"+mem[j]) != -2)
        no_dir[mem[j]] = domains[i];
      if (!"/secure/login"->test_creator(mem[j]))
        not_creator[mem[j]] = domains[i];
    }
/* Ok...  print the membership list. */
    bit = "Members of "+domains[i]+" are: ";
    printf("%s%-=*s\n", bit, cols-strlen(bit), implode(mem, ", ")+".");
  }
  if (sizeof(no_dir)) {
    write("These creators are in domains but do not have a directory:\n");
    printf("    %-=*s", cols-5, implode(keys(no_dir), ", ")+".\n");
  }
  if (sizeof(not_creator)) {
    write("These creators are in domains but are not actually creators:\n");
    printf("    %-=*s", cols-5, implode(keys(not_creator), ", ")+".\n");
  }
  if (sizeof(creators)) {
    write("These creators are not in any domain:\n");
    printf("    %-=*s", cols-5, implode(creators, ", ")+".\n");
  }
  if (sizeof(cre_not)) {
    write("These creators have a directory, but are not creators...:\n");
    printf("    %-=*s", cols-5, implode(cre_not, ", ")+".\n");
  }
  return 1;
} /* do_info() */
// --- END [/mnt/home2/grok/lib/d/admin/obj/bingle.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/admin/obj/inv_check.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/admin/obj/inv_check.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627587   Available: 13574941
Inodes: Total: 5242880    Free: 4960133
8641 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/admin/obj/inv_check.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627587   Available: 13574941
Inodes: Total: 5242880    Free: 4960133
2025-03-06 12:07:43.811365079 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*
 * Inventory checker made by Funtime to periodically check players inventories
 * 5/5/1994
 * heavily rewritten by Olorin to actually remove the illegal objects
 * Modified so it runs independantly, starting the inv checking process in create() and calling itself out 
 * Terano, 18/1/98
 */

#include <playtesters.h>
#include <move_failures.h>
#define FILENAME "/save/inv_check"

int do_seek();

nosave string to_log;
string *forbidden = ({ });

void save_me() {
  unguarded ((: save_object (FILENAME) :));
}

void dest_me() {
   destruct( this_object() );
   save_me();
} /* dest_me() */


void create() {
  seteuid( "Admin" );
//  unguarded ((: restore_object (FILENAME) :));
  do_seek();
} /* create() */

void log_it() {
   if( sizeof( to_log ) > 0 ) {
      log_file( "ILLEGAL_OBJECT",
               "Illegal objects removed %s\n%s\n", 
               ctime( time() ), 
               to_log );
   }
} /* log_it() */

void check_sub_inv( object *things, string owner, object owner_ob ) {
   string *pre_filename, filename, *switcher;
   object *obs, thing;
   object *contents, *fragile;
   string mess = "";
   object bag;
   
   obs = ({ });
   foreach ( thing in things ) {
     if ( thing->query_property( "virtual name" ) ) {
       filename = thing->query_property( "virtual name" );
     } else {      
       pre_filename = explode( file_name( thing ),"#" );
       filename = pre_filename[ 0 ];
     }
      
      switcher = explode( filename, "/" );
      
      if( ( switcher[0]=="w" ) &&
          ( !"/obj/handlers/playtesters"->query_playtester( owner ) ) ) {
         to_log += sprintf("%s in %s, cloned by %s\n",
                           filename, owner,
                           (string)thing->query_cloned_by() );
         obs += ({ thing });   
      }
      
      if ( ( sizeof( switcher ) > 2 ) && 
          ( switcher[ 0 ] == "obj" ) && 
          ( switcher[ 1 ] == "misc" ) ) {
         switch(switcher[2]){
          case "mailer_ob":
            if ( !"/obj/handlers/playtesters"->query_playtester( owner ) &&
                 ( !owner_ob->query_property("allowed mailer")) ) {
               to_log += sprintf("%s in %s, cloned by %s\n",
                                 filename, owner,
                                 (string)thing->query_cloned_by() );
               obs += ({ thing });   
            }
            break;
          case "board_mas":
            to_log += sprintf("%s in %s, cloned by %s\n",
                              filename, owner,
                              (string)thing->query_cloned_by() );
            obs += ({ thing });  
            break;
         }
         
      }
      if (sizeof (switcher) ==4 &&
        switcher [0] == "d" &&
        switcher [1] == "liaison" &&
        switcher [2] == "items") {  
           to_log += sprintf("%s in %s, cloned by %s\n",
                             filename, owner,
                             (string)thing->query_cloned_by() );
           obs += ({ thing });   
      }
      reset_eval_cost();
      if (member_array (filename, forbidden) != -1) {            
            to_log += sprintf("%s in %s, cloned by %s\n",
                              filename, owner,
                              (string)thing->query_cloned_by() );            
            obs += ({ thing });  
            thing->add_property ("no recycling", 1);
            if (function_exists ("query_max_weight", thing)) {
              contents = all_inventory (thing);
            }
      }       
      
   }
   if ( sizeof( obs ) ) {
      tell_object (owner_ob, owner_ob->colour_event ("say", "%^CYAN%^") + 
        "A small official looking dwarf walks up to you and says: In "
        "accordance with paragraph 5, sub-paragraph 7 of the Domestic "
        "& Domesticated Animals (Care & Protection) Act, 1673, I hereby "
        "remove from you: "+ (string)query_multiple_short( obs, "one" ) 
        + ".%^RESET%^");
      
      if (sizeof (contents)) {
        mess += "\nThe dwarf removes all the inventory from the confiscated "
          "items.";
           
        fragile = filter (contents, (: $1->query_property("fragile") :));
        
        if (sizeof (fragile)) {
          mess += "\nHe hands " + query_multiple_short (fragile) + " to "
            "you.\n";          
          contents -= fragile;
          fragile->move (owner_ob);

        }
        if (sizeof (contents)) {
          bag = clone_object ("/obj/baggage");
          bag->set_name ("bag");
          bag->set_short ("brown paper bag");
          bag->add_adjective (({"brown", "paper"}));
          bag->set_weight(5);
          bag->set_max_weight (implode (map (contents, 
            (: $1->query_complete_weight() :)),(: $1 + $2 :)) + 1);
          bag->set_value (0);
          bag->set_long ("This is a plain, brown, paper bag... the kind grubby "
            "old men are often found in possession of after leaving their "
            "local newsagent.\n");
          contents->move (bag);                
          if (bag->move (owner_ob) == MOVE_TOO_HEAVY) {
            mess +=  "He sticks " + query_multiple_short (contents) + " in a "
              "brown paper bag and leaves it on the ground.";
          }
          else {
            mess +=  "He sticks " + query_multiple_short (contents) + " in a "
              "brown paper bag and hands it to you.";
          }            
        }        
      }
            
      mess += "\nHe scribbles something on a clipboard, then walks away.\n";      
      tell_object (owner_ob, mess);
      obs->move( "/room/rubbish" );
      call_out( "check_obs", 7, obs ); /* dest them soonest */
   } 
} /* check_sub_inv() */

void check_obs( object* obs ) {
   object thing;
   foreach( thing in obs ) {
      if( thing ) {
   thing->dest_me();
      }
   }
} /* check_obs() */

void check_inv( object player ) {
   object *things;
   
   things = deep_inventory( player );
   check_sub_inv( things, (string)player->query_name(), player );
} /* check_inv() */

int do_seek() {
  object user;
  
  to_log = "";
  foreach ( user in users() ) {
    
    if( user && !user->query_property( "guest" ) &&
       !user->query_creator() &&
       !PLAYTESTER_HAND->query_tester (user) &&
       !user->query_property ("test character") ) {
      check_inv( user );
    }
  }
  log_it();
 
  call_out( "do_seek", 300 ); //Every 5 minutes
  return 1;
} /* do_seek() */
 
int query_theft_command() { return -1; }

string parse_filename (string str) {

  if (strsrch (str, ".wep") != -1 ||
      strsrch (str, ".clo") != -1 ||
      strsrch (str, ".ob") != -1 ||
      strsrch (str, ".arm") != -1 ||
      strsrch (str, ".food") != -1 ||
      strsrch (str, ".sca") != -1) {
        if (file_size(str) <= 0) {
          return 0;
        }
        else {
          return str;
        }
  }
  else {
    str = explode (str, ".c")[0];
    
    if (file_size(str + ".c") <= 0 ) {
      return 0;
    }
    else {
      return str;
    }
  }
}
                       
int ban_object(string filename) {
  
  if (!master()->query_lord(previous_object(-1))) {
    printf ("Please get a lord to ban your object for you.\n");
    return 0;
  }    
  
  filename = parse_filename (filename);
  
  if (filename == 0) {
    printf ("No file with that filename.\n", filename);
    return 0;
  }
  else {
    if (member_array (filename, forbidden) == -1) {
      forbidden += ({ filename });
      printf ("%s added to the list of banned objects.\n", filename);
      save_me();
    }
    else {
      printf ("%s already banned.\n", filename);
    }
  }
  return 1;
}

int unban_object(string filename) {
  
  if (!master()->query_lord(previous_object(-1))) {
    printf ("Please get a lord to unban your object for you.\n");
    return 0;
  }    
        
  filename = parse_filename (filename);
  
  if (filename == 0) {
    printf ("No file with that filename.\n", filename);
    return 0;
  }
  else {
    if (member_array (filename, forbidden) != -1) {
      forbidden -= ({ filename });
      printf ("%s removed from the list of banned objects.\n", filename);
      save_me();
    }
    else {
      printf ("%s not currently banned.\n", filename);
    }
  }
  return 1;
}

string list_banned() {
  if (sizeof (forbidden)) {    
    return sprintf ("Objects cloned from the following filenames "
      "will be confiscated by the dwarves:\n%s\n", 
      implode (forbidden, "\n"));
  }
  else {
    return "There are no objects currently forbidden.\n";
  }    
}


mixed stats()
{
  return ({
    ({ "Time until next tick", query_num (find_call_out ("do_seek")) 
      + " seconds"}),
  });
}    
// --- END [/mnt/home2/grok/lib/d/admin/obj/inv_check.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/liaison/master.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/liaison/master.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627585   Available: 13574939
Inodes: Total: 5242880    Free: 4960133
4560 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/liaison/master.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627585   Available: 13574939
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#define LORD "wyvyrn"
#define DOMAIN "liaison"
/*
 * Beware editing this file.
 * Make sure you know what you are doing.  Stuffing this up could be
 * fatal in some ways.
 */
#include <liaison.h>

inherit "/std/dom/base_master";

mapping member_alias;
nosave string* member_cache = 0;

string query_lord() {
  return LORD;
}

string author_file(string *path) {
  return capitalize(DOMAIN);
}

int check_permission(string euid, string *path, int mask) {
  if (euid == query_lord())
    return 1;
  return ::check_permission(euid, path, mask);
}

/*
 * By default, use the valid_read()/valid_write() functions defined in the
 * inherited file /std/dom/base_master.c.
 * These default to reading allowed for everyone, writing only allowed
 * for independent creators and the domain lord.
 * This is all overridden by the check_permission() function
 * which is called first, which should be used instead.
 */
int valid_read(string *path, string euid, string funct);

int valid_write(string *path, string euid, string funct);

/*
 * By default only the lord of the domain can add/remove members, or
 * change the projects of the members.
 * This is a bit contrictive, but handy as a default.
 * Change this if you want.
 */
  /*
int add_member(string name) {
  if (geteuid(this_player(1)) != query_lord())
    return 0;
  return ::add_member(name);
}

int remove_member(string name) {
  if (geteuid(this_player(1)) != query_lord())
    return 0;
  return ::remove_member(name);
}

int set_project(string name, string pro) {
  if (geteuid(this_player(1)) != query_lord())
    return 0;
  return ::set_project(name, pro);
}

  */

int query_member(string name) {
  return !undefinedp(members[name]) || name == LORD;
} /* query_member() */

string log_who(string where) {
  return "eron";
} /* log_who() */

/* Please change this to a text describing the domain, it will be used
   on the WWW pages and in finger info. */

string query_info() {
  if (file_size(LIAISON_DOMAIN_INFO) < 0) {
    return "\nFor information on this domain, please visit "
           "http://discworld.imaginary.com:5678/~Liaison/\n";
  }
  return "\n"+ unguarded((: read_file(LIAISON_DOMAIN_INFO) :)) +"\n";
}

string *member_alias( string name ) {
   int i;
   
   if ( !member_alias )
      member_alias = ([ ]);
   if ( undefinedp( members[ name ] ) ) {
      map_delete(member_alias, name);
      return 0;
   }
   if ( !member_alias[ name ] )
      member_alias[ name ] = ({ });
   i = sizeof( member_alias[ name ] );
   while ( i-- )
      member_alias[ name ][ i ] = lower_case( member_alias[ name ][ i ] );
   return member_alias[ name ] + ({ });
} /* member_alias() */

int add_member_alias( string name, string alias ) {
   if ( !members[ name ] )
      return 0;
   if ( !"/secure/login"->test_user( alias ) )
      return 0;
   if ( !member_alias )
      member_alias = ([ ]);
   if ( !member_alias[ name ])
      member_alias[ name ] = ({ });
   member_alias[ name ] -= ({ alias }); // remove duplicates
   member_alias[ name ] += ({ alias });
   save_me();
   return 1;
} /* add_member_alias() */

int delete_member_alias( string name, string alias ) {
   if ( !members[ name ] )
      return 0;
   if ( !member_alias )
      member_alias = ([ ]);
   if ( !member_alias[ name ])
      member_alias[ name ] = ({ });
   member_alias[ name ] -= ({ alias }); // remove duplicates
   save_me();
   return 1;
} /* delete_member_alias() */

string *query_unsorted_members() {
    return ::query_members();
} /* query_unsorted_members() */

string *query_members() {
    string* temporary_array = ({});
    string* first = ({});
    string* seniors = ({});
    string* newbies = ({});

    if (!member_cache) {

        first = ({ query_lord() })   +
                sort_array(query_deputies(),1);

        temporary_array = ::query_members() - first;
        
        temporary_array = sort_array( temporary_array, 1 );       
        
        
        foreach ( string person in temporary_array ) {
          if ( master()->query_senior(person) ) {
              seniors += ({ person });
          }
        }
        temporary_array -= seniors;


        foreach ( string person in temporary_array ) {
          if ( regexp( members[ person ], "^(N|n)ewbie$" ) ) {
              newbies += ({ person });
          }
        }
        temporary_array -= newbies;

        member_cache = first + seniors + temporary_array + newbies;
    }
    return copy(member_cache);
    
} /* query_members() */

string *query_projects() {
    return values(members);
} /* query_projects() */

// --- END [/mnt/home2/grok/lib/d/liaison/master.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/liaison/cre_corridor.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/liaison/cre_corridor.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627583   Available: 13574937
Inodes: Total: 5242880    Free: 4960133
6229 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/liaison/cre_corridor.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627583   Available: 13574937
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*
Liaison hall room - people can add exits here - see the sign.
This is designed so people don't add to the commonroom, add here instead.
Lucifer, 10 January 2002 at 2am, the ungodly hour.
Thank you to Drakkos for the mirror code...
*/


inherit "/std/room/basic_room";

string do_mirror();

void setup() {
    set_short("Liaison hallway");
    set_light(100);
    add_property("determinate", "the ");
    set_long("This is the homely corridor of the Liaison Domain.  There are "
             "a lot of doors leading off here, hopefully taking the plucky "
             "entrant a-wandering into Liaison workrooms.  Exercise caution "
             "as some Creators prefer you to ask or at least knock first.  "
             "Apart from the doors here there are some paintings of various "
             "people, as well as a large floor to ceiling mirror. Taking "
             "pride of place on one of the walls, however, is an ancient "
             "looking scroll housed in a picture frame.  There is "
             "also a sign here.\n");
    add_item("doors", "Lots of doors.  Tall doors, short doors, red doors, "
             "blue doors, green doors, thin doors, wide doors, old doors, "
             "grimy doors, wooden doors, metal doors and even a padded "
             "red linonium door - kinky.  However, you can only go through "
             "the doors marked in the exits, sorry.");
    add_item("paintings", "Paintings of people who have been important to "
             "the domain.  There's one of Ohdamn, Moonchild, Olorin, Shalla, "
             "Kaea, Nevvyn, Wyvyrn and - strangely enough - You.");
    add_item("painting of ohdamn", "The painting of Ohdamn shows a very "
             "tall man with reddish blond hair.  He appears to be carrying "
             "a box of chocolates and looks to be in the middle of a rousing "
             "love song, which may have something to do with the bottle of "
             "rum in his other hand.");
    add_item(({"mission", "scroll", "statement"}), "It's the liaison "
             "statement of mission!\n"
             "Or mission statement, if you would prefer.\n\n"
             "Our mission in the Liaison Domain is to give continuous "
             "support to the creator and player bases and facilitate "
             "communcation between them.\n"
             "Through a diverse range of activities, we aim to maintain "
             "Discworld MUD as an enjoyable, interesting, in-theme and "
             "safe virtual space.\n"
             "We seek to contribute to Discworld MUD as a visible and helpful "
             "helpful first point of creator contact for players.  Additionally, "
             "we will work within assigned creator areas to assist in the "
             "development and implementation of concepts.\n\n"
             "Impressive, huh?");
    add_alias("mission", "statement");
    
    add_item("frame", "It's just a frame holding a large scroll in place.");
    add_item("hair", "It's hair.  It's reddish blond and it's Ohdamn's.");
    add_item("rum", "It's rum.  Held very securely by Ohdamn.");
    add_item("chocolates", "They are chocolates.  On Ohdamn's painting.");
    add_item("painting of moonchild", "The painting of Moonchild shows a "
             "looming lady with a big whip and an evil grin.  She appears "
             "to be half in shadows.");
    add_item("whip", "A fearsome looking whip that seems to fit well in "
             "Moonchild's hand.");
    add_item("painting of olorin", "Olorin's picture appears to be only "
             "half done - as if the artist didn't have time to finish it.");
    add_item("painting of shalla", "Shalla's painting depicts a pretty "
             "lady and although she is fully clothed, your attention is "
             "drawn to her socks.  Strange.");
    add_item("socks", "Stop looking - that's illegal in some countries!");
    add_item("painting of kaea", "Kaea's painting shows a young lady with a "
             "silly looking grin on her face and giggling.  Seems to say it "
             "all really...");
    add_item("painting of nevvyn", "The painting of Nevvyn shows a man with a "
             "pint hefted in a salute and a cheeky looking grin on his face.");
    add_item("pint", "A half empty pint in Nevvyn's hand.  Says it all!");
    add_item("painting of wyvyrn", "Wyvyrn's painting depicts a ... well, a "
             "Wyvyrn.  He looks a bit like a dragon and has green wings - but "
             "seems to have the distinct disadvantage of looking cute.");
    add_item("wings", "Wings.  On Wyvyrn.");
    add_alias("painting of me", "painting of you");
    add_item("painting of you", "The painting of you is ... well, blank with the "
             "words 'Your Name Here' on it.  You get the feeling its a rather "
             "cheesy way of saying everyone is important!  If it wasn't so "
             "cheesy it might make you feel better.");                    
    add_sign("This is an important sign, for viewing along with the "
             "paintings.\n",
             "If you are having problems seeing the paintings, look at "
             "painting of <person>.  "
             "Please note: These paintings are done on collective images.  "
             "Basically, if you don't like your portrait, don't beat Luci "
             "up.  Thanks!");                                             
    add_item("mirror", (: do_mirror() :));
    
    add_exit("common", "/d/liaison/common", "door");
    add_exit("drum", "/d/am/am/mendeddrum", "path");
    
/* Please add exits to this room from your commonroom using this line
   of code:
   "/d/liaison/cre_corrdior"->add_exit(CREATOR, "workroom path", "door");
   Thanks!
*/
}

string do_mirror() {  
  string text;
  
 
  text = "The mirror is a full length floor to ceiling job, a full length "
    "mirror in the true sense of the word.  It's here to make sure you look "
    "you look your best.  Good job you are checking!\n\n";
  text += this_player()->long(this_player());
  tell_room (this_object(), this_player()->short() + " checks " + 
    this_player()->query_objective() + "self in the big mirror.  Poser.\n",
    this_player());
  return text;
}

// --- END [/mnt/home2/grok/lib/d/liaison/cre_corridor.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/liaison/NEWBIE/newbie_book.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/liaison/NEWBIE/newbie_book.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627582   Available: 13574936
Inodes: Total: 5242880    Free: 4960133
3583 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/liaison/NEWBIE/newbie_book.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627582   Available: 13574936
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: newbie_book.c,v 1.4 2002/08/14 09:02:14 wyvyrn Exp $
 *
 * $Log: newbie_book.c,v $
 * Revision 1.4  2002/08/14 09:02:14  wyvyrn
 * Added general language
 *
 * Revision 1.3  2002/08/14 07:09:14  pinkfish
 *  Forcibly unlocked by wyvyrn
 *
 * Revision 1.2  2000/03/09 01:40:03  ceres
 * Made it valueless so the newbie shop doesn't end up full of them.
 *
 * Revision 1.1  2000/03/01 06:06:45  ceres
 * Initial revision
 *
 * Revision 1.1  1998/01/16 02:18:32  arby
 * Initial revision
 *
*/
/* Yikes!  Please don't read the code, as it has no punctation 
   whatsoever :) (I blame the colours)
   This newbie brochure is *completly* rewritten from the
   old /d/am/am/items/colourful brochure, found in the tray in the Mended
   Drum.
   
   Hobbes, July 96 

   Rewritten as a book in Mars 97
                                                     */

#include "path.h"

#define NEWBIE_SAVE "/d/liaison/NEWBIE/save/"

inherit "/std/book_dir";



void setup() {
  set_name( "book" );
  set_short( "newbie guide book");
  set_main_plural( "newbie guide books" );
  add_adjective( ({"newbie", "guide"}) );
  add_alias( "newbiebook" );
  set_weight( 2 );
  set_value( 0 );
  set_long( "This is a guide book for the newbies who rushed through the "
            "newbie foyer too fast or are just absent-minded in general.  "
            "It contains valuable information on the commands, guilds "
            "and the city of Ankh-Morpork.\n\n"
            "You may 'open book', 'read newbie book', 'turn page of "
            "newbie book' or 'open newbie book to page #'.\n" );
  set_book_language( "general" );
  set_book_dir( NEWBIE_SAVE + "newbie_book_page" );
  set_read_mess("\n"
"                          _______   nn   _______                      \n"
"                          \\____ _\\ [@@] / _____/                       \n"
"                             \\__ _\\/\\/\\/ ___/                        \n"
"                               \\__| [] |__/                            \n"
"                  ___              \\__/              ___             \n"
"                 / ..\\             /__\\             /.. \\          \n"
"               _/ \\___\\            (())            /___/ \\_        \n"
"             _/@  /V /V   _________=||=________    V\\ V\\  @\\_      \n"
"             \\   |_n_n    \\         ||        /     n_n_|   /          \n"
"              |   ____|    |                 |     |____   |           \n"
"              |-----|_____ |       The       | _____|------|           \n"
"             / __    \\ ___)|      NEWBIE     |(___ /     __ \\          \n"
"            | /  \\___ |    |    Guide book   |    | ____/  \\ |         \n"
"            | \\______)|    |      f o r      |    |(_______/ |         \n"
"            |         |    |    Discworld    |    |          |         \n"
"            |        /      \\    Mudders    /      \\         |         \n"
"             \\   _  /        \\_           _/        \\   _   /         \n"
"              | | | |          \\_       _/           | | | |           \n"
"              |_| |_|            \\_____/             |_| |_|           \n"
"       ____________________________________________________________     \n"
"   ___|  Syntaxes: 'open book' 'read book' 'turn a page of book'   |___  \n"
"   \\  |____________        'open book to page #'       ____________|  /  \n"
"   /____/          \\__________________________________/          \\____\\ ",
"general");

            /* Artwork by Gototh, modified and 'transformed' by me */
}

// --- END [/mnt/home2/grok/lib/d/liaison/NEWBIE/newbie_book.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/liaison/NEWBIE/help.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/liaison/NEWBIE/help.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627581   Available: 13574935
Inodes: Total: 5242880    Free: 4960133
6060 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/liaison/NEWBIE/help.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627581   Available: 13574935
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: help.c,v 1.9 2003/02/19 06:54:24 ceres Exp $
 */
#include "path.h"
#include <library.h>

inherit PATH+"inside";

object womble;

 
void setup() {
  set_zone( "Newbie" );
  set_short( "Help Room" );
  set_light( 75 );
  set_long("This room looks like a library.  There are shelves around the "
           "room crammed with reference books.  Around the room are a "
           "number of signs.\n"
           "The signs are labelled 'helpme', 'newbie', 'problems', "
           "'etiquette' and 'quit'.\n");

  add_item("floor", "The floor is made of polished marble so smooth that "
           "you can see your face in it - yeuch!\n");
  
  add_item("wall", "The walls are hidden behind row upon row of shelves.\n");
  add_item(({ "shelves", "shelf" }), "The shelves are filled with books.\n");
  add_item("book", "There are many, many reference books here, most are "
           "weighty tomes in black leather bindings.\n");
  
  add_sign("This is a simple white sign marked 'helpme'.\n",
           FOYER->format_sign(
                 "The Discworld help system is divided into two parts: "
                 "concept help which explains discworld concepts such as "
                 "magic and command help which explains how to use specific "
                 "commands.\n\nPerhaps the single most useful command is "
                 "'help concepts'.  This command will provide a list of "
                 "concepts for which there is an overview.  These overviews "
                 "will help you understand how things work and also what "
                 "commands to use to do things.\n\nTo see the list of "
                 "commands type 'help command_list'.  In addition, the "
                 "'essentials' help file covers all the basic commands "
                 "you're likely to need to get you started."),
           "sign marked 'helpme'",
           "helpme", "general");
  
   add_sign("This is a simple white sign marked 'problems'.\n",
            FOYER->format_sign(
            "If you have problems getting started or understanding help "
            "files, you can talk to a newbiehelper (type 'helpers' for "
            "a list of online newbiehelpers) or use the newbie channel.  "
            "If you have any problems with the mud not working as you "
            "expect, liaisons are available for giving help and for "
            "answering questions.  They can't provide quest details but "
            "will try to help you if they can.\n\n"
            "To see if any creators are logged on, and to get a list "
            "of all players logged on, use the command 'finger': "
            "Creators are marked by having a C next to their name.  "
            "Senior creators are marked with an S next to their name.  "
            "Directors are marked by having an D next to their name.  "
            "Trustees are marked by having an T next to their name.\n\n"
            "To find out which creators are in the liaison domain "
            "type 'finger liaison', and to see which of those are "
            "currently online, type 'liaisons'.  "
            "To report any bugs or typos that you may encounter, please "
            "make a report out for them. Please read 'help bug' or "
            "'help typo' for information on making reports."),
            "sign marked 'problems'",
            "problems", "general" );

   add_sign("This is a simple white sign marked 'newbie'.\n", 
            FOYER->format_sign(
            "This is part of the newbie area on Discworld, "
            "written to help you get acquainted with the game.  "
            "Please enter each room and find out about what "
            "each of Discworld's guilds has to offer.\n\n"
            "If you have any questions that aren't answered by the "
            "signs, first try 'help <subject>' if that doesn't work "
            "use 'newbie <question>' and hopefully someone will "
            "answer your question and 'hnewbie' to view the past couple "
            "of questions.\n\n"
            "Once you have visited each room you may " 
            "leave the newbie area to enter Discworld proper.  "
            "Before reaching the Disc, you'll be given the choice of "
            "which city you wish to start in.  Information is given about "
            "each region and city at that time."),
            "sign marked 'newbie'",
            "newbie", "general" );

   add_sign("This is a simple white sign marked 'etiquette'.\n",
            FOYER->format_sign(
            "Discworld is a very friendly mud and there are "
            "few written rules. The bottom line is be nice "
            "and don't cheat.  In particular: \n\n"
            "The use of foul language in shouting and the "
            "broadcasting of quest information are frowned upon.  "
            "Creators will remind you of this if provoked, and "
            "will take appropriate action if necessary. Playing "
            "more than one character at once is not permitted.\n\n"
            "If you wish to play more than one character you must "
            "never have them both logged on at the same time.  "
            "Harassment of other players, sexual or otherwise, "
            "is not acceptable and may lead to banishment."), 
            "sign marked 'etiquette'",
            "etiquette", "general" );

   add_sign("This is a simple white sign marked 'quit'.\n", 
            FOYER->format_sign(
            "To leave Discworld at any time, "
            "type 'quit' at the prompt.  Your "
            "player file will automatically be "
            "saved with all your equipment.  The only exception is if "
            "you are under 30 minutes old, in which case you won't save."),
            "sign marked 'quit'",
            "quit", "general" );
   
   add_exit( "foyer", PATH +"foyer", "door");
   add_alias( "southeast", "foyer");
   
  /* Make it so you cannot godmother out of here */
  add_property("no godmother", 1);
} /* setup() */

// --- END [/mnt/home2/grok/lib/d/liaison/NEWBIE/help.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/liaison/NEWBIE/hints.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/liaison/NEWBIE/hints.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627579   Available: 13574933
Inodes: Total: 5242880    Free: 4960133
9678 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/liaison/NEWBIE/hints.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627579   Available: 13574933
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: hints.c,v 1.11 2003/02/19 06:54:24 ceres Exp $
 *
 */
/*  Added search function to find wombles brooch.
    Talonia, Nov. '95
*/
/* Addded set_shorts to signs so they are still hidden, but you get a */
/* better message indicating what sign was read-Eron Mar. 21 1996     */
/* Added no teleport property- 26-06-98- Shalla */

#include "path.h"

inherit PATH+"inside";

object sign;

void setup() {
  set_zone( "Newbie" );
  set_short("Hints Room" );
  set_light( 75 );
  add_property("no teleport", 1);

  set_long( "You are in a small, dark room.  The only illumination seems to "
            "come from the crack under the door.  The walls are covered "
            "with handwritten notices, most of which you cannot read in this "
            "half-light, however a few catch your eye.  One is entitled "
            "'statistics', another 'navigation', another "
            "'advancement', a fourth 'assistance', yet another 'skills'"
            ", and a final one is marked 'dying'.  Something in the "
            "corner catches your eye.\n");

   add_item( ({ "something", "corner" }), 
             "There's something in the corner.  Maybe you could 'search' "
             "the corner and find out what's there." );
  add_item( "floor", 
            "You can barely make out the floor.  It appears to be made of "
            "stone");
  add_item( "wall", 
            "The walls (what you can see of them under the notices) are made "
            "of grey stone.");
  add_item(({"notice"}), "The walls are covered with handwritten notices.  In "
           "the half-light it's hard to pick them out, but you can make "
           "out a few of them.  One is entitled "
           "'statistics', another 'navigation', another "
           "'advancement', a fourth 'assistance', yet another 'skills'"
           ", and a final one is marked 'dying'.");
  
  sign=add_sign("A handwritten notice marked 'statistics'.\n",
                FOYER->format_sign(
           "Once you enter Discworld, you can rearrange your stats.  This "
           "should be done to improve your combination of constitution, "
           "dexterity, intelligence, strength and wisdom (your stats) once "
           "you have chosen a guild.  Use the command 'rearrange' to do "
           "this, but consider it well, as you can only rearrange your stats "
           "once.  You can view them using 'score stats'.  See 'help "
           "score'.\n"), 0, "statistics", "general");
  sign->set_short("sign marked 'statistics'");

  sign=add_sign("A handwritten notice marked 'combat'.\n",
                FOYER->format_sign(
           "Combat is a fairly important part of Discworld.  The combat "
           "system is quite advanced.  You should type 'help fighting' "
           "and 'help tactics' to find out more about how to modify "
           "the way in which you fight.\n"),
           0, "combat", "general");
  sign->set_short("sign marked 'combat'");

  sign=add_sign("A handwritten notice marked 'navigation'.\n",
                FOYER->format_sign(
           "Exploring a new area can be quite exciting.  There are lots of "
           "things to look at, and maps to make.  If you get lost, though, "
           "you might appreciate some maps.  In some areas, typing 'map' will "
           "show you a map of your immediate surroundings.  You may also find "
           "the maps some players have made useful - follow the 'Mud Atlas' "
           "link on our homepage.  See 'help maps'.\n"),
           0, "navigation", "general");
  sign->set_short("sign marked 'navigation'");

  sign=add_sign("A handwritten notice marked 'assistance'.\n",
      FOYER->format_sign(
      "Liaison creators are available for giving help and for "
      "answering questions; they cannot provide quest information, "
      "however.  You can find which liaisons are logged on at the moment "
      "using the 'liaisons' command.  "
      "To see if any creators are logged on, and to get a "
      "list of all players logged on, use the command 'finger':\n"
      " - creators are marked by having a C next to their name.\n"
      " - senior creators are marked by having an S next to their name\n"
      " - directors (domain leaders) are marked by having a D next to their "
      "name.\n"
      " - trustees (administrators) are marked by having a T next to their "
      "name.\n\n"
      "To report any bugs or typos that you may encounter, please "
      "make a report out for them.  To do this, please type "
      "'bug' and make out your report.  Please include the error, if "
      "any, that you get, the room that it is occuring in, and what "
      "you were doing to get the error.  Use the 'typo' command and "
      "the same guidelines when you report a typo.\n"), 0, "assistance", "general");
  sign->set_short("sign marked 'assistance'");

  sign=add_sign("A handwritten notice marked 'skills'.\n",
                FOYER->format_sign(
           "To check your skill levels, use the command 'skills', and "
           "to see various statistics about yourself, use 'score'.  Your "
           "stats can also be reviewed using 'score stats'.  The command "
           "'help' will give you a variety of other topics with useful "
           "information."), 0, "skills", "general");
  sign->set_short("sign marked 'skills'");

  sign=add_sign("A handwritten notice marked 'advancement'.\n",
                FOYER->format_sign(
           "Skills can be advanced in a variety of ways on Discworld.  "
           "The guild you join will allow you to advance your skills "
           "for a certain number of experience points and a small fee.  "
           "When you reach the proper skill level your guild will "
           "teach you the commands that you will need to carry out "
           "your guild duties.\n\n"
           "You may also have another player teach you skills if they have "
           "a higher skill level than you, or you may teach yourself.  Both "
           "of these methods cost experience points, and it is generally more "
           "expensive to teach yourself.\n\n"
           "Finally, many of your skills can be advanced simply by performing "
           "tasks that make use of those skills.  For example, your fighting "
           "skills will get better as you participate in more fights.  For "
           "more information on this system, type " 
           "'help taskmaster'.\n"),0, "advancement", "general");
  sign->set_short("sign marked 'advancement'");

  sign=add_sign("A handwritten notice marked 'dying'.\n",
                FOYER->format_sign(
           "At some point you will inevitably end up dying on Discworld, but "
           "fear not for you are given 7+1 lives.  When you die you need to "
           "go and visit Harry in the Temple of Small Gods who will raise "
           "you.\n"), 0, "dying", "general");
  sign->set_short("sign marked 'dying'");

/* Make it so you cannot godmother out of here */
  add_property("no godmother", 1);

  add_exit( "foyer", PATH + "foyer", "door" );
  add_alias( "northwest", "foyer");

  room_chat(({10, 40, ({"A voice whispers something that you can't quite "
                         "make out.",
                        "You think you hear someone whispering.",
                        "A voice whispers: Use 'chfn' to change your "+
                         "finger information.",
                        "A voice whispers: 'consider' will tell you how "
                         "tough an opponent is.",
                        "A voice whispers: You can re-execute your last "
                         "command by using '.' or the last command "+
                         "beginning xxx with '.xxx'.",
                        "A voice whispers: You can set up aliases for "
                         "sequences of commands that you use frequently.",
                        "A voice whispers: You can give your friends easier-"
                         "to-type nicknames.",
                        "A voice whispers: Use 'wimpy' to automatically "
                         "run away before you "
                         "die, or 'monitor' to keep a track of how hurt "
                         "you are getting.",
                        "A voice whispers: 'who' will provide a list of "
                         "the current players on Discworld.",
                        "If it's too noisy you can use 'earmuffs' to "
                         "quiet things down a bit.",
                        "A voice whispers: The street urchins can take you "
                         "to various places around Ankh-Morpork.  Just "
                         "say where you want to go and if they know it "
                         "they'll take you there."
                              })}));
} /* setup() */

int do_search()
{
  object ob;

  /* This is done so that brooches can be found at any time
     to an infinite number. Can't expect newbies to
     hang around waiting for resets so they can enter the game
     now can we? */

  tell_object( this_player(), "You examine the floor more "
              "closely and find a brooch lying in the corner.\n");
  tell_object(this_player(), "You pick up the brooch.\n");
  say(this_player()->one_short()+" searches the room "
      "and finds something in the corner.\n");
  ob = clone_object( PATH + "womble_brooch" );
  ob->move( this_player() );
  return 1;
}
// --- END [/mnt/home2/grok/lib/d/liaison/NEWBIE/hints.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/liaison/NEWBIE/newbie_book_old.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/liaison/NEWBIE/newbie_book_old.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627576   Available: 13574930
Inodes: Total: 5242880    Free: 4960133
11372 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/liaison/NEWBIE/newbie_book_old.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627576   Available: 13574930
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: newbie_book.c,v 1.4 2002/08/14 09:02:14 wyvyrn Exp $
 *
 * $Log: newbie_book.c,v $
 * Revision 1.4  2002/08/14 09:02:14  wyvyrn
 * Added general language
 *
 * Revision 1.3  2002/08/14 07:09:14  pinkfish
 *  Forcibly unlocked by wyvyrn
 *
 * Revision 1.2  2000/03/09 01:40:03  ceres
 * Made it valueless so the newbie shop doesn't end up full of them.
 *
 * Revision 1.1  2000/03/01 06:06:45  ceres
 * Initial revision
 *
 * Revision 1.1  1998/01/16 02:18:32  arby
 * Initial revision
 *
*/
/* Yikes!  Please don't read the code, as it has no punctation 
   whatsoever :) (I blame the colours)
   This newbie brochure is *completly* rewritten from the
   old /d/am/am/items/colourful brochure, found in the tray in the Mended
   Drum.
   
   Hobbes, July 96 

   Rewritten as a book in Mars 97
                                                     */

#include "path.h"
#define PAGES    8
inherit "/std/book";

void setup() {
  set_name( "book" );
  set_short( "newbie guide book");
  set_main_plural( "newbie guide books" );
  add_adjective( ( {"newbie", "guide"} ) );
  set_weight( 2 );
  set_value( 0 );
  set_no_pages( PAGES );
  set_long( "This is a guide book for the newbies who rushed through the "
            "newbie foyer too fast or are just absent-minded in general.  "
            "It contains valuable information on the commands, guilds "
            "and the city.  "
            "You may <read newbie book>, <open newbie book to page #> and "
            "<turn a page of newbie book>.\n" );
  set_read_mess("\n"
"                          _______   nn   _______                      \n"
"                          \\____ _\\ [@@] / _____/                       \n"
"                             \\__ _\\/\\/\\/ ___/                        \n"
"                               \\__| [] |__/                            \n"
"                  ___              \\__/              ___             \n"
"                 / ..\\             /__\\             /.. \\          \n"
"               _/ \\___\\            (())            /___/ \\_        \n"
"             _/@  /V /V   _________=||=________    V\\ V\\  @\\_      \n"
"             \\   |_n_n    \\         ||        /     n_n_|   /          \n"
"              |   ____|    |                 |     |____   |           \n"
"              |-----|_____ |       The       | _____|------|           \n"
"             / __    \\ ___)|      NEWBIE     |(___ /     __ \\          \n"
"            | /  \\___ |    |    Guide book   |    | ____/  \\ |         \n"
"            | \\______)|    |      f o r      |    |(_______/ |         \n"
"            |         |    |    Discworld    |    |          |         \n"
"            |        /      \\    Mudders    /      \\         |         \n"
"             \\   _  /        \\_           _/        \\   _   /         \n"
"              | | | |          \\_       _/           | | | |           \n"
"              |_| |_|            \\_____/             |_| |_|           \n"
"       ____________________________________________________________     \n"
"   ___|  Syntaxes: <open book> <read book> <turn a page of book>   |___  \n"
"   \\  |____________        <open book to page #>       ____________|  /  \n"
"   /____/          \\__________________________________/          \\____\\ ",
"general");

            /* Artwork by Gototh, modified and 'transformed' by me */

  set_open_page( 1 );
  set_read_mess( "                                                \n"
 "                                                                \n"     
"                            %^B_RED%^TABLE OF CONTENTS%^RESET%^                        Page 1\n"
 "                    .o0o.o0o.o0o.o0o.o0o.o0o.o0o.o0o.       \n"
 "                                            \n"
 "         General information.....................................2-3\n"
 "         Commands................................................4-5\n"
 "         Guilds..................................................6-7\n"
 "         The lands around Ankh-Morpork.............................8\n"
 "\n\n"
 " %^B_RED%^NOTE:%^RESET%^ If you haven't played MUD's before, we advise you"
 " to read any of\n"
 " the FAQ's around (Frequently Asked Questions).  To read the "
 "Discworld FAQ,\n"
 " type 'help FAQ' or point your http browser at \n"
 " <http://discworld.imaginary.com/> and click on the \n"
 " 'Frequently Asked Questions' link.",
 "general", 100 );

  set_open_page( 2 );
  set_read_mess( "\n"
 "                            GENERAL INFORMATION                     Page 2\n"
 "                           -=-=-=-=-=-=-=-=-=-=-                 \n"
 "\n"
 " At any time during the course of playing you can get HELP on various \n"
 " topics by typing  '%^B_RED%^help concepts%^RESET%^' "
 "and  '%^B_RED%^help command_list%^RESET%^'. \n"
 " If you need to ask something else, or have problems of any kind, \n"
 " the LIAISON creators will kindly help you out, if you ask nicely. \n"
 " To see if any are logged on, simply type  '%^B_RED%^liaisons%^RESET%^'.\n"
 " Also, most of the players are usually very helpful when it comes to \n"
 " answering questions.                                \n"
 "\n"
 " As soon as you have made a choice you should join a GUILD where you can \n"
 " advance your skills (take a look at page 5 in this brochure for more \n"
 " information on the different guilds).  But while deciding, you can \n"
 " simply teach yourself.  Type  '%^B_RED%^help level%^RESET%^'  and "
 " '%^B_RED%^help teach%^RESET%^' \n"
 " to find out more.\n"
 "\n"
 " CONTINUES ON NEXT PAGE.",
 "general", 100 );
  
  set_open_page( 3 );
  set_read_mess( "\n"
 "                        MORE GENERAL INFORMATION                   Page 3\n"
 "                       -=-=-=-=-=-=-=-=-=-=-=-=- \n"
 "\n" 
 " In Ankh-Morpork there are GUIDES wandering around that can take you to \n"
 " certain destinations.  These are often waiting by the guilds or in the \n"
 " Mended Drum.  To use one you say in the same room as one, for example: \n"
 " 'take me to wizards guild please'.  \n"
 " Other places they can take you to, besides the guilds, are \n"
 " 'the post office',  'the bank',  'least gate' and  'hubwards gate'.\n"
 "                                                    \n"
 " You start off with a total of eight lives.  If you should happen to die,\n"
 " Harry at the Temple of Small Gods, can RAISE you from the dead and you \n"
 " are then set to go again (one life shorter).  Some player Priests also \n" 
 " have the ability to resurrect.\n"
" And please BUG report bugs and typos you see.  Do  '%^B_RED%^help bug%^RESET%^' "
 " and \n"
 " '%^B_RED%^help typo%^RESET%^'  for more information.", 
 "general", 100 );

  set_open_page( 4 );
  set_read_mess( " \n"
  "                                  COMMANDS                         Page 4\n"
  "                                -=-=-=-=-=-\n"
  "\n"
  " '%^B_RED%^who%^RESET%^' or '%^B_RED%^finger%^RESET%^'"
  "  Will show the people logged on.  \n"
  "                    You can also 'finger <playername>'\n"
  " '%^B_RED%^rearrange%^RESET%^'        Allows you to set your stats"
  " (You can only do this once).\n"
  " '%^B_RED%^score%^RESET%^'            Will show statistics.\n"
  " '%^B_RED%^score stats%^RESET%^'      More statistics.\n"
  " '%^B_RED%^i%^RESET%^'                Will show you your inventory.\n"
  " '%^B_RED%^skills%^RESET%^'           Will list your skills.\n"
  " '%^B_RED%^wimpy < % >%^RESET%^'      To automatically run away before "
  "you die.\n"
  " '%^B_RED%^monitor on%^RESET%^'       Will help you keep track of Hit"
  " and Guild points.\n"
  " '%^B_RED%^inform logon on/off%^RESET%^'    Gives you info on logon/out-"
  "events (once you've \n                    joined a guild).\n"
  " '%^B_RED%^.%^RESET%^'                Will repeat your last command.\n"
  "\n"
  " CONTINUES ON NEXT PAGE.",
  "general", 100 );  

  set_open_page( 5 );
  set_read_mess("\n"
  "                              MORE COMMANDS                        Page 5\n"
  "                             -=-=-=-=-=-=-=-\n"
  "\n"
  " '%^B_RED%^tactics%^RESET%^'         Will show your combat tactics.  Read\n"
  "                  'help tactics' for information on how to use it.\n"
  "\n"
  " Other commands worth checking out, or read the help files for, are: \n"
  " '%^B_RED%^alias%^RESET%^',  '%^B_RED%^earmuff%^RESET%^', "
  " '%^B_RED%^commands%^RESET%^', "
  "'%^B_RED%^nickname%^RESET%^',  '%^B_RED%^consider%^RESET%^'\n"
  " '%^B_RED%^gp%^RESET%^' and  '%^B_RED%^playerkilling%^RESET%^'.",
  "general", 100 );  

  set_open_page( 6 );
  set_read_mess( "\n"
 "                               THE GUILDS                           Page 6\n"
 "                             -=-=-=-=-=-=-\n"
 "\n"
 " Each player will usually join a guild so that they can learn skills\n"
 " and commands and so advance their abilities.   Being in a guild also \n"
 " adds character to your character.  These guilds are currently available:\n"
 " WIZARDS GUILD is located west of Sator Square.  To join you have to look\n"
 " around in the Great Hall and find a staircase.\n"
 " THIEVES GUILD is at the beginning of Alchemist street.\n"
 " FIGHTERS GUILD is on Filigree Street, just a stone's throw from Mended \n"
 " Drum.\n"
 " PRIESTS GUILD with its various Gods is located on Small Gods Street.\n"
 " The Gods are: Hat, Pishe, Fish, Sek, Gapp, Gufnork and Sandelfon.\n"
 " For more information, type 'info' in their guild rooms.\n"
 "\n"
 " CONTINUES ON NEXT PAGE.",
 "general", 100 );

 set_open_page( 7 );
 set_read_mess( "\n"
 "                               THE GUILDS                           Page 7\n"
 "                             -=-=-=-=-=-=-\n"
 "\n"
 " ASSASSINS GUILD is located at the eastern end of Filigree Street.  Fill \n"
 " in an application and give it to the secretary in the guild office.\n"
 " WITCHES GUILD is located at Granny Weatherwax' cottage in Lancre. \n"
 " See Gennie Applebottom at Dione Street in Ankh-Morpork if you have \n"
 " trouble finding the place.",
 "general", 100 );

  set_open_page( 8 );
  set_read_mess( "\n"
 "                        THE LANDS OUTSIDE ANKH-MORPORK              Page 8\n"
 "                       -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-                \n"
 "\n"
 " The lands around the city can sometimes be strange and dangerous \n"
 " places.  Through the northeastern (Least) gate is the path that goes \n"
 " through the plains, some small villages, and finally up to the \n"
 " mountains, also known as the Ramtops.\n"
 " The southeastern (Hubwards) gate takes you into the vast forest where \n"
 " innocent people are terrorised by wolves and other strange creatures \n"
 " that roam unfettered.  It's also a more direct route to the Ramtops\n"
 " (Carriages from Ankh-Morpork are a nice alternative to tired feet for \n"
 " travelling to and from the towns in the Sto Plains and Ramtops).\n"
 " Holywood is a great place for newbies venturing out of the city.  You \n"
 " get there via the Brass Bridge.\n"
 " The tour operator at Sator Square is ready to send you to the warm \n"
 " and distant continent of Klatch, if you have enough money.\n"
 " '%^B_RED%^help map%^RESET%^'  will give you a nice map of Discworld and "
 "there are more \n"
 " fantastic and exciting places to come.",
 "general", 100 );   
  set_open_page( 0 );

}

// --- END [/mnt/home2/grok/lib/d/liaison/NEWBIE/newbie_book_old.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/liaison/NEWBIE/combat_room3.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/liaison/NEWBIE/combat_room3.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627573   Available: 13574927
Inodes: Total: 5242880    Free: 4960133
3051 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/liaison/NEWBIE/combat_room3.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627573   Available: 13574927
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
//swiped from the Thieves' Guild room with modifications - Rue
/*combat classroom*/

#include "path.h"
#define MAX 100;

inherit PATH + "inside";

string *arr0;
object sign, dummy, trainer;

void setup() {
  //set_zone( "Newbie" );
  set_short("John's Boot Camp");
  add_property("determinate", "");
  set_light( 75 );
  add_property("no teleport", 1);
  
  set_long("This is a small training room, designed to help the new "
           "adventurer get off to a good start on Discworld.  The air is "
           "stale with the combined stench of sweat, beer, and old "
           "warriors.  Off to one side is a rather unusual training "
           "dummy above which is a small plaque.\n");
  add_item( "face", "As you stare at it, squinting and turning your head "
            "side to side, you realise it looks rather like your old maths "
            "teacher!\n");
  add_item( "floor", "The floor is made of flagstones, cemented together "
            "with centuries of accumulated muck.\n");
  add_item( "wall", "The walls are marked with mysterious stains that may or "
            "may not be blood.  But surely training dummies don't bleed.\n");
  add_item( "ceiling", "The ceiling appears to be dingy patches of plaster "
            "stuck between old oak rafters that have turned black with "
            "age.\n");
/* Make it so you cannot godmother out of here */
  add_property("no godmother", 1);

  add_exit( "combat", PATH + "combat", "door" );
  add_alias( "southeast", "foyer");
}/*setup*/

void reset() {
  if(!sign) {
    sign=add_sign("This is a plaque that seems to describe how to have "
                   "your combat skills assessed.\n", "To assess your "
                   "skills, attack the dummy with the weapon you want to "
                   "test your proficiency in.  Each time you hit the "
                   "dummy, the instructor will comment on your "
                   "performance.  After a number of rounds, the "
                   "instructor will stop you and give you an overall "
                   "performance rating.\n\n"
                   "Don't forget to hold your weapon of choice before "
                   "attacking the training dummy!\n",
                   "small plaque", "plaque", "general");
    sign->add_property("there", "on the wall");
  }
  if(!dummy)
    dummy = clone_object(PATH + "dummy");
  dummy->move(this_object());
  
  call_out("get_trainer", 1);
}/*reset*/

void dest_me() {
  if(sign)
    sign->dest_me();
  if(dummy)
    dummy->dest_me();
  if(trainer)
    trainer->dest_me();
  ::dest_me();
}

void get_trainer() {
  if(!trainer)
    trainer = clone_object(PATH +"trainer");
  
  if (trainer) {
    trainer->whichone("john");
    trainer->move( this_object(), "$N hobble$s toward you on his straw-filled stumps." );
    dummy->set_trainer(trainer);
  }
}/*get_trainer*/

void stop_them(object who) {
  if(trainer && dummy)
    trainer->stop_them(who, dummy);
}


string query_quit_handler() {
  return "/d/liaison/NEWBIE/combat";
} /* query_quit_handler() */

// --- END [/mnt/home2/grok/lib/d/liaison/NEWBIE/combat_room3.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/liaison/NEWBIE/combat_room1.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/liaison/NEWBIE/combat_room1.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627572   Available: 13574926
Inodes: Total: 5242880    Free: 4960133
3022 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/liaison/NEWBIE/combat_room1.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627572   Available: 13574926
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
//swiped from the Thieves' Guild room with modifications - Rue
/*combat classroom*/

#include "path.h"
#define MAX 100;

inherit PATH + "inside";

string *arr0;
object sign, dummy, trainer;

void setup() {
  set_short("Xrazzicaz' Boot Camp");
  add_property("determinate", "");
  set_light( 75 );
  add_property("no teleport", 1);
  
  set_long("This is a small training room, designed to help the new "
           "adventurer get off to a good start on Discworld.  The air is "
           "stale with the combined stench of sweat, beer, and old "
           "warriors.  Off to one side is a rather unusual training "
           "dummy above which is a small plaque.\n");
  add_item( "face", "As you stare at it, squinting and turning your head "
            "side to side, you realise it looks rather like your old maths "
            "teacher!\n");
  add_item( "floor", "The floor is made of flagstones, cemented together "
            "with centuries of accumulated muck.\n");
  add_item( "wall", "The walls are marked with mysterious stains that may or "
            "may not be blood.  But surely training dummies don't bleed.\n");
  add_item( "ceiling", "The ceiling appears to be dingy patches of plaster "
            "stuck between old oak rafters that have turned black with "
            "age.\n");
/* Make it so you cannot godmother out of here */
  add_property("no godmother", 1);

  add_exit( "combat", PATH + "combat", "door" );
  add_alias( "southeast", "foyer");
}/*setup*/

void reset() {
  if(!sign) {
    sign=add_sign("This is a plaque that seems to describe how to have "
                  "your combat skills assessed.\n", "To assess your "
                  "skills, attack the dummy with the weapon you want to "
                  "test your proficiency in.  Each time you hit the "
                  "dummy, the instructor will comment on your "
                  "performance.  After a number of rounds, the "
                  "instructor will stop you and give you an overall "
                  "performance rating.\n\n"
                  "Don't forget to hold your weapon of choice before "
                  "attacking the training dummy!\n",
                  "small plaque", "plaque", "general");
    sign->add_property("there", "on the wall");
  }
  if(!dummy)
    dummy = clone_object(PATH + "dummy");
  dummy->move(this_object());
  
  call_out("get_trainer", 1);
}/*reset*/

void dest_me() {
  if(sign)
    sign->dest_me();
  if(dummy)
    dummy->dest_me();
  if(trainer)
    trainer->dest_me();
  ::dest_me();
}

void get_trainer() {
  if(!trainer)
    trainer = clone_object(PATH +"trainer");
  
  if (trainer) {
    trainer->whichone("xrazzicaz");
    trainer->move( this_object(), "$N hobble$s toward you on his straw-filled stumps." );
    dummy->set_trainer(trainer);
  }
}/*get_trainer*/

void stop_them(object who) {
  if(trainer && dummy)
    trainer->stop_them(who, dummy);
}

string query_quit_handler() {
  return "/d/liaison/NEWBIE/combat";
} /* query_quit_handler() */
// --- END [/mnt/home2/grok/lib/d/liaison/NEWBIE/combat_room1.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/liaison/NEWBIE/guilds_foyer.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/liaison/NEWBIE/guilds_foyer.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627571   Available: 13574925
Inodes: Total: 5242880    Free: 4960133
8000 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/liaison/NEWBIE/guilds_foyer.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627571   Available: 13574925
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: guilds_foyer.c,v 1.8 2003/02/19 06:54:24 ceres Exp $
 *
 */
/* Added no teleport property- 26-06-98- Shalla */

#include "path.h"


inherit PATH+"outside";

void setup() {
  set_zone( "Newbie" );
  set_short( "Garden of Guilds" );
  set_light( 100 );
  add_property("no teleport", 1);

  set_day_long( "This is a pleasant garden with trees, shrubs and flowers.  "
                "There are six gazebos in the garden each with a wrought "
                "iron gate with a coat of arms on it.  Each "
                "gazebo is dedicated to one of the Discworld guilds, which "
                "are "+ GUILDS +".  "
                "To look at the gates themselves - use "
                "'look wizard' or 'look witch' or to enter one of the "
                "gazebos, use 'wizard', 'witch' or whichever is appropriate.\n"
                "There is also a sign attached to a post in the centre of the "
                "garden.\n" );
  
  set_night_long("This is an octagonal garden with a fence around it.  "
                 "Someone has placed braziers around the garden to provide "
                 "light.  There "
                 "are six gazebos in the garden each with a wrought iron gate "
                 "with a coat of arms on it.  Each "
                 "gazebo is dedicated to one of the Discworld guilds, which "
                 "are "+ GUILDS +".  "
                 "To look at the gates themselves - use "
                 "'look wizard' or 'look witch' or to enter one of the "
                 "gazebos, use 'wizard', 'witch' or whichever is "
                 "appropriate.\n"
                 "There is also a sign attached to a post in the centre of "
                 "the garden.\n" );

  add_item("gazebo", "There are a number of gazebos here each dedicated to "
           "a different guild.");
  
  add_sign("This is a simple white sign attached to a post.\n",
      FOYER->format_sign("Each player will usually join a guild so that "
      "they can learn skills and commands and so advance their abilities.  "
      "Being in a guild also gives character to your character.  To find "
      "out more about the different guilds take each of the guild gates "
      "from this garden.  When you are in Ankh-Morpork you will find that "
      "each guild has a headquarters where you may join.\n\nTake care with "
      "your choice of guild since you will not be able to change it.\n")
      , 0, "sign", "general" );

/* Make it so you cannot godmother out of here */
  add_property("no godmother", 1);

  add_exit( "foyer", PATH + "foyer", "gate" );
#ifndef __DISTRIBUTION_LIB__
  add_exit( "witch", PATH +"witches", "gate" );
  add_exit( "wizard", PATH +"wizards", "gate" );
  add_exit( "thief", PATH +"thieves", "gate" );
  add_exit( "assassin", PATH + "assassins", "gate" );
  add_exit( "warrior", PATH +"fighters", "gate" );
  add_exit( "priest", PATH +"priests", "gate" );
  add_alias( "north", "communication");

  modify_exit("witch",
              ({ "look", "It's too dark to see inside the gazebo."}));
  modify_exit("wizard",
              ({ "look", "It's too dark to see inside the gazebo."}));
  modify_exit("thief",
              ({ "look", "It's too dark to see inside the gazebo."}));
  modify_exit("assassin",
              ({ "look", "It's too dark to see inside the gazebo."}));
  modify_exit("warrior",
              ({ "look", "It's too dark to see inside the gazebo."}));
  modify_exit("priest",
              ({ "look", "It's too dark to see inside the gazebo."}));

  modify_exit("witch", ({ "closed", 1}));
  modify_exit("wizard", ({ "closed", 1}));
  modify_exit("thief", ({ "closed", 1}));
  modify_exit("assassin", ({ "closed", 1}));
  modify_exit("warrior", ({ "closed", 1}));
  modify_exit("priest", ({ "closed", 1}));
  
  modify_exit( "witch", ({
      "door long", "Over the gate to the Witch room "
      "is the burned-in image of a broomstick with a cat clinging on "
      "to the bristles for dear life.  The gate itself has a little "
      "window in it, but all that you can see through it is darkness.  "
      "To enter here type 'witch'.\n"}) );
  
  modify_exit( "wizard", ({ "door long", "The gate into the Wizard room "
         "has the crest of Unseen University on it: this shows a large "
         "pointy hat with stars, above it an open book with the words "
         "'Nunc Id Vides, Nunc Ne Vides'. "
         "To enter here type 'wizard'.\n"}) );

  modify_exit( "thief", ({ "door long", "On the Thieves' gate you see "
      "their crest. It has a slashed purse with change falling from a "
        "hole in the bottom and the words ACVTVS ID VERBERAT below. "
          "To enter this gate type \"thief\".\n"}) );
   
  modify_exit( "assassin", ({ "door long", "On the Assassins' gate you see "
         "their crest.  A cloak and a dagger in the top left and two gold "
           "crosses in the bottom right. Their motto reads: \"Nil Mortifi "
             "Sine Lucre.\"  "
               "To enter this gate type \"assassin\".\n"}) );

  modify_exit( "warrior", ({ "door long", "On the Warriors' gate "
         "they have a strange crest.  A skull and scythe with blood "
         "dripping from it.  Their motto reads: \"If It Moves Kill It. "
         "If It Doesn't Move, Wait For It To Move, Then Kill It.\"  "
         "To enter here type \"warrior\".\n"}) );

  modify_exit( "priest", ({ "door long", "On the Priest's gate you "
         "see an odd crest.  Many unusual symbols, everything from a jar "
         "of fluff to a puddle of water, even an obscure breed of monkey. "
         "To enter here type \"priest\".\n"}) );
#endif

  add_night_item("brazier", "Basically this is a torch on a pole.\n");
  
  add_room_chats(({"An elderly man dressed in a blue robe and wearing "
                     "a large pointy hat enters from the wizards "
                     "gazebo and leaves south.\n",
                     "An elderly man dressed in a blue robe and wearing "
                     "a large pointy hat enters from the south "
                     "and leaves for the wizards gazebo.\n",
                     "A small woman dressed in a black cloak and wearing "
                     "a large pointy hat enters from the witches "
                     "gazebo and leaves south.\n",
                     "A small woman dressed in a black cloak and wearing "
                     "a large pointy hat enters from the south "
                     "and leaves for the witches gazebo.\n",
                     "A burly man dressed head to toe in armour and "
                     "carrying a large sword enters from the warriors "
                     "gazebo and leaves south.\n",
                     "A burly man dressed head to toe in armour and "
                     "carrying a large sword enters from the north "
                     "and leaves for the warriors gazebo.\n",
                     "A saintly looking woman walks in from the north, "
                     "smiles benevolently at you, and leaves for the "
                     "priests gazebo.\n",
                     "A saintly looking woman enters from the priests "
                     "gazebo, smiles benevolently at you, and leaves "
                     "south.\n",
                     "A shadowy figure enters from the assassins "
                     "gazebo and leaves for the foyer.\n",
                     "A shadowy figure enters from the foyer "
                     "and leaves for the assassins gazebo.\n",
                     "A weaselly, furtive man sneaks in from the foyer "
                     "and leaves for the thieves gazebo.\n",
                     "A weaselly, furtive man sneaks in from the thieves "
                     "gazebo and leaves for the foyer.\n"}));

} /* setup() */

// Dont ever let it get too dark here.
int query_light() {
  int light;

  light = ::query_light();
  if(light < 40)
    light = 40;

  return light;
}
// --- END [/mnt/home2/grok/lib/d/liaison/NEWBIE/guilds_foyer.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/liaison/NEWBIE/foyer.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/liaison/NEWBIE/foyer.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627569   Available: 13574923
Inodes: Total: 5242880    Free: 4960133
6798 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/liaison/NEWBIE/foyer.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627569   Available: 13574923
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: foyer.c,v 1.19 2003/02/19 06:54:24 ceres Exp $
 */
#include "path.h"
#include <library.h>
#include <config.h>

inherit PATH+"inside";

object womble;

string format_sign(string message);

void setup() {
  add_property("no teleport", 1);
  set_zone( "Newbie" );
  set_short( "Discworld foyer" );
  set_light( 75 );
  set_long("This is a cavernous, circular room that echoes the shape of "
           "the Discworld itself.  At its centre is a large round table upon "
           "which is what appears to be a map of Discworld, complete with "
           "Great A'Tuin swimming slowly through space carrying Berilia, "
           "Tubul, Great T'Phon and Jerakeen, the four giant elephants upon "
           "whose shoulders the disc of the world rests.  The walls are "
           "decorated with murals showing scenes from the disc.  Dark doorways "
           "ring the perimeter of the room, leading away in all directions.\n"
           "There is a large white sign on one wall labelled 'Discworld'.  "
           "You may 'look' at a sign or 'read' a sign.\n");

  add_item(({ "map", "disc", "Disc" }), "Upon closer examination you are not "
           "quite so certain that this is just a map of the Disc.  "
           "The detail is incredible, from the sharp spire of Cori "
           "Celesti at the centre, to the surrounding Circle Sea, "
           "the deserts of Klatch, the watery world of Krull, and the "
           "mysterious Counterweight Continent.  A spectacular rimbow "
           "sparkles where the seas pour over the edge of the Disc.  As "
           "you study the map's details, you are sure you saw one of the "
           "elephants move.");

  add_item("rimbow", "It's like a rainbow except that it's caused by the "
           "water pouring off the edge of the disc.");
  
  add_item("elephant", "These are the four elephants that bear the weight"
           " of the Disc.");

  add_item( "table", "The table is made of a single piece of green granite, "
           "heavily carved with small figures.  The top of the table is "
           "mostly covered by the map of Discworld, although you can see "
           "a few squares of black and white marble underneath, rather "
           "like a chessboard.");

//  add_item(({ "writing", "words", "scratches" }), "The faint, spidery "
//           "writing says: \"Offler has bad breath!\".");

  add_item(({ "figure", "carving" }), "The tiny, carved figures are "
           "extremely detailed.  You can make out what appears to be "
           "some trolls, a handful of dwarfs, three witches, and what "
           "surely must be the ugliest cat ever.  Looking at the cat "
           "carving, you are sure you catch a whiff of something vile, "
           "much like fermented carpets.");
  
  add_item("floor", "The floor is made of polished marble so smooth that "
           "you can see your face in it - yeuch!");
  
  add_item("wall", "The walls are covered in murals showing scenes from "
           "the disc.");

  add_item( "ceiling", "The ceiling, if there is one, disappears into the "
           "lofty gloom overhead.");

  add_item(({ "doorway", "door" }), "The doorways are dark, yet somehow "
           "inviting.  Or at least not threatening.");

  add_item("mural", "On one wall there is a painting of a seedy looking inn "
           "with a sign of a drum hanging outside.  On another a small castle "
           "set high in a mountainous region where the peaks are snow-"
           "capped.  You can almost feel the biting wind.  On another an "
           "oasis in an otherwise hot, dry desert.  The final one is the "
           "most peculiar being a strange bone covered landscape with a "
           "massive sphinx in the centre.");
  
   add_sign("This is a simple white sign marked \"Discworld\".\n",
            format_sign("This mud is based on the books written by Terry "
                        "Pratchett.  While it is not necessary to have read "
                        "the Discworld books you may find it helpful for some "
                        "of the quests and in knowing more about the "
                        "characters and places in the game."),
            0, ({ "sign","discworld","Discworld" }), "general" )->add_property(
            "determinate","the ");

   room_chat(({60, 120, ({"There is a sound like the rattle and fall of a "
                         "pair of dice.",
                         "You hear a hushed chuckle far above your head.",
                         "A pleasant voice says: Another game?"
                         })}));

   add_exit("helpme", PATH+"help", "door");
   add_exit("communication", PATH +"communication", "door");
   add_exit("hints", PATH +"hints", "door");
   add_exit("guilds", PATH+"guilds_foyer", "door");
   add_exit("commerce", PATH+"shop", "door");
   add_exit("align", PATH+"align", "door");
   add_exit("advancement", PATH+"advancement", "door");
   add_exit("combat", PATH+"combat","door");
   /*
   add_alias("east", "communication");
   add_alias("southeast", "hints");
   add_alias("south", "guilds");
   add_alias("southwest", "commerce");
   add_alias("west", "align");
   add_alias("northwest", "helpme");
   add_alias("north", "advancement");
   add_alias("northeast", "combat");
   */
   
  /* Make it so you cannot godmother out of here */
  add_property("no godmother", 1);

   add_exit("out", PATH + "choose_land", "path" );
   modify_exit( "out", ({ "function", "check_allow" }) );
} /* setup() */

int check_allow( string str, object ob, string special_mess ) {
  if(ob->query_property("womble's brooch")) {
    ob->set_language("general");
    return 1;
  }
  
  tell_object( ob,
               "You haven't completed the womble's quest yet.\n"
               "Complete that quest and you can enter the game.\n"
               "HINT: Find the womble's brooch and give it to her.\n");
  return notify_fail( "" );
} /* check_allow() */

void init() {
   ::init();
   womble = find_object( PATH +"womble" );
   if ( !womble || !environment( womble ) )
      ( PATH +"womble" )->move( this_object(), "$N womble$s in." );
} /* init() */


/* Function to prettily format a sign. */
string format_sign(string message) {
  int i;
  string *bits;
  string ret = "", bit;

  bits = explode(sprintf("%-="+(SIGN_WIDTH-2)+"s", message), "\n");
  ret += "\n     _";
  for(i=0; i<SIGN_WIDTH - 1; i++)
    ret += "_";
  ret += "\n";
  ret +="   //";
  for(i=0; i<SIGN_WIDTH; i++)
    ret += " ";
  ret += "\\\n";
  foreach(bit in bits) {
    ret += "   || " + bit;
    for(i=sizeof(bit); i<SIGN_WIDTH-1; i++)
      ret += " ";
    ret += "|\n";
  }
  ret += "   \\\\";
  for(i=0; i<SIGN_WIDTH; i++)
    ret += "_";
  ret += "/\n";
  return ret;
}
// --- END [/mnt/home2/grok/lib/d/liaison/NEWBIE/foyer.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/liaison/NEWBIE/assassins.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/liaison/NEWBIE/assassins.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627567   Available: 13574921
Inodes: Total: 5242880    Free: 4960133
2740 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/liaison/NEWBIE/assassins.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627567   Available: 13574921
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: assassins.c,v 1.5 2003/02/19 06:54:24 ceres Exp $
 *
*/
/* Added no teleport property- 26-06-98- Shalla */

#include "path.h"

inherit PATH + "inside";

void setup() {

   set_short( "Assassins' gazebo" );
   set_light( 80 );
   add_property("no teleport", 1);

   set_long("This is a very comfortably furnished gazebo.  Obviously assassins "+
            "have excellent taste.  There is no sign at all of anything even "
            "remotely dangerous or threatening.  There is a large plaque on "
            "the wall explaining more about this rather enigmatic "
            "profession. You can view it by typing 'read sign'.\n"
            "A small, black, and elegant looking notice states that this is not "
            "where you actually join this guild.\n" );

   set_zone( "Newbie" );
   add_item("notice", "A small, black, and elegant looking notice that "
            "states that this is not where you actually join the guild.");
   add_item( ({ "furnishing" }), "The room is furnished in an expensive, "
            "although tasteful manner.  On the walls are a variety of "
            "quality oil paintings and the floor is covered with a thick "
            "carpet.  Against one wall is a chaise longue and in a corner "
            "is a well stocked drinks cabinet.");
   add_item("carpet", "A well-made carpet, thick and luxurious.");
   add_item("painting", "A variety of landscapes from some of the Disc's "
            "more notable painters.");
   add_item(({"chaise longue", "chaise", "longue"}),
            "Upholstered in the softest leather "
            "it looks very comfortable.");
   add_item(({"drink", "cabinet"}), "Its most notable feature is that it "
            "is locked.  Behind the glass door you can see a variety of "+
            "bottles, crystal decanters and glasses.");

   add_sign("A plaque entitled 'Guild of Assassins'\n",
            "The guild of assassins provides an excellent all-round "
            "education.  Graduates of the guild (graduation is by "+
            "competitive examination) will be skilled in a wide variety of "
            "subjects and able to move in all social circles.\n"
            "All assassins automatically become player killers (see "
            "'help playerkilling') on graduation.  This is not "+
            "a guild for the faint-hearted.  Becoming an assassin is a "
            "challenge.  Assassins are a proud guild, neither giving nor"
            " asking for information on how to join.\n", 0, 0, "general");
         
/* Make it so you cannot godmother out of here */
   add_property("no godmother", 1);

   add_exit( "garden", PATH +"guilds_foyer", "gate" );

} /* setup() */

// --- END [/mnt/home2/grok/lib/d/liaison/NEWBIE/assassins.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/liaison/NEWBIE/choose_land.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/liaison/NEWBIE/choose_land.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627567   Available: 13574921
Inodes: Total: 5242880    Free: 4960133
11955 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/liaison/NEWBIE/choose_land.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627567   Available: 13574921
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/**
 * This is the room in which the newbie chooses which land they wish to
 * start in.
 * @author Pinkfish
 * @started Thu May 23 11:55:41 PDT 2002
 */

#include "path.h"
#include <config.h>
#include <language.h>
#include <money.h>

inherit PATH+"inside";

#define DEBUG 1
#define LOG PATH + "save/CHOICE"

private mapping _nationalities;
private object _sign;

void setup() {
   string name;
   string nationality;
   string region;

  _nationalities = ([
       "pumpkin" : "/std/nationality/pumpkin"
     ]);
  add_property("no teleport", 1);
  add_property("determinate", "");
/* Make it so you cannot godmother out of here */
  add_property("no godmother", 1);
  set_zone( "Newbie" );
  set_short( "Discworld's realm of choice" );
  set_light( 75 );
  set_long("You are on a huge open-air platform far, far above the Disc itself.  "
           "Down below, the water tumbles and falls off the rim of the disc "
           "spilling down and out into a spray of mist over the elephants and "
           "the back of A'tuin, the great star turtle.  There are several "
           "sets of stairs leading down off the platform to the unknown and "
           "a large dial sits in the middle of the room.  A large sign "
           "shimmers and hangs in the air in the middle of the platform.\n");

  add_item(({ "disc", "Disc", "discworld"}),
           "You can see from the sharp spire of Cori "
           "Celesti at the centre, to the surrounding Circle Sea, "
           "the deserts of Klatch, the watery world of Krull, and the "
           "mysterious Counterweight Continent.  A spectacular rimbow "
           "sparkles where the seas pour over the edge of the Disc.  As "
           "you study the map's details, you are sure you saw one of the "
           "elephants move.");

  add_item("rimbow", "It's like a rainbow except that it's caused by the "
           "water pouring off the edge of the disc.");
  
  add_item("elephant", "These are the four elephants that bear the weight"
           " of the Disc.");

  add_item(({ "floor", "platform" }),
           "The floor is made of some weird black stone that is "
           "semi-transparent, allowing the Disc below you to be "
           "seen through it.");
  
  add_item(({ "stairs", "stairways" }), "Stairs leading down to the "
           "dark unknown.  They all appear to be crafted of some thin, "
           "spidery metal.");

  add_item("dial", "The dial is a huge heavy looking stone dial, with some "
                   "arrows and numbers carved into the surface.  They say "
                   "'Klatch 4000 miles', 'Ankh-Morpork 3000 miles', "
                   "'Lancre 3500 miles', 'Bes Pelargic 3000 miles'.");

   _sign = add_sign("A huge shimmering sign, the letters are transparent "
      "and it is possible to walk through it.\n", 
      FOYER->format_sign(
      "Travellers choose your destination!  Which parts of the world "
      "do you want to explore?\n\n"
      "Look carefully at each of the lands "
      "before you make your choice - it determines the language you "
      "start with and your local accent, as well as where you start.\n\n"
      "The current list of available start nationalities is: " +
      query_multiple_short(keys(_nationalities)) + ".\n\n"
      "You can get 'info' on each nationality, and each region within "
      "a nationality.\n\n"
      "You choose your nationality with 'choose <nationality> <region>'; "
      "for example 'choose morpork Ankh-Morpork'.\n\n"
      "Use 'help here' for more help on 'info' and 'choose'.\n"),
      "shimmering sign", "sign", "general");

   foreach (name, nationality in _nationalities) {
      if (file_size(nationality + ".c") > 0) {
         add_item(name, nationality->query_information());
         foreach (region in nationality->query_regions()) {
            //add_exit("choose " + name + " " + lower_case(region), nationality->query_region_start_location(region), "stairs");
            //modify_exit("choose " + name + " " + lower_case(region), ({ "function", "setup_nationality" }) );
            add_item(name + " " + lower_case(region), nationality->query_region_description(region));
         }
      } else {
         printf("Bad nationality %O\n", nationality);
      }
   }

   add_help_file(PATH + "doc/choose_land");
} /* setup() */

string find_region(string nationality, string region) {
   string tmp;

   foreach (tmp in nationality->query_regions()) {
      if (lower_case(tmp) == lower_case(region)) {
         return tmp;
      }
   }
   return 0;
}

void change_nationality(object person, string nationality, string region) {
   string old_nationality;
   int old_speak;
   int old_write;
   int new_speak;
   int new_write;
   string skill_speak;
   string skill_write;
   string lang;
   string guild;
   mixed newbie;

   // Find out what their old nationality is.
   nationality = _nationalities[nationality];
   old_nationality = this_player()->query_nationality();
#ifdef DEBUG
   debug_printf("Old nationality was %O, new nationality is %O.\n", old_nationality, nationality);
#endif
   // Move around the skills.
   lang = nationality->query_language();
   skill_speak = LANGUAGE_HAND->query_language_spoken_skill(lang);
   skill_write = LANGUAGE_HAND->query_language_written_skill(lang);
   old_speak = this_player()->query_skill(skill_speak);
   old_write = this_player()->query_skill(skill_write);
   if (old_speak > 100) {
      old_speak = 100;
   }
   this_player()->add_skill_level(skill_speak, 100 - old_speak); 
   if (old_write > 100) {
      old_write = 100;
   }
   this_player()->add_skill_level(skill_write, 100 - old_write);

   if (old_nationality &&
       old_nationality->query_language() != nationality->query_language()) {
      // Put the levels we removed into the old language. 
      lang = old_nationality->query_language();
      skill_speak = LANGUAGE_HAND->query_language_spoken_skill(lang);
      skill_write = LANGUAGE_HAND->query_language_written_skill(lang);
      new_speak = this_player()->query_skill(skill_speak);
      new_write = this_player()->query_skill(skill_write);
      if (new_speak > 100) {
         new_speak = 100;
      }
      this_player()->add_skill_level(skill_speak, old_speak - new_speak);
      if (new_write > 100) {
         new_write = 100;
      }
      this_player()->add_skill_level(skill_write, old_write - new_write);
   }
   this_player()->set_nationality(nationality);
   this_player()->set_nationality_region(find_region(nationality, region));
   lang = nationality->query_language();
   // Setup the default language correctly.
   this_player()->set_default_language(lang);
   this_player()->set_language(lang);

   guild = this_player()->query_guild_ob();
   newbie = this_player()->query_property("not real newbie");

   log_file( LOG , "%s:\n   %s the %s%s chose %s (%s)\n",
      ctime(time()),
      this_player()->query_short(), 
      guild ? capitalize(guild[12..<1]) : "Adventurer",
      newbie ? "" : " (newbie)",
      capitalize(this_player()->query_nationality_region()),
      capitalize(this_player()->query_nationality()[17..<1]));

   // mess with money.
   if (!this_player()->query_property("not real newbie")) {
      int value;
      string currency_area = "";
      mixed* array;

      value = this_player()->query_value_in("Newbie Area");
      currency_area = this_player()->query_nationality()->query_currency_area();
      // Hack to correct Sto Lat money from AM to Provincial
      if (this_player()->query_nationality_region() == "Sto Lat" ) {
         currency_area = "default";
      }
      tell_creator( "wyvyrn" ,
         "[ %s the %s%s picked %s and got money for %s ]\n",
         this_player()->query_short(), 
         guild ? capitalize(guild->query_name()[0..<2]) : "Adventurer",
         newbie ? "" : " (newbie)",
         this_player()->query_nationality_region(),
         currency_area);

      array = MONEY_HAND->create_money_array(value, currency_area);
      this_player()->set_money_array(array);
   } else {
      object ob;

      foreach (ob in all_inventory()) {
         if (!living(ob) && ob->query_short() != "shimmering sign") {
            ob->move(nationality->query_region_start_location(region));
         }
      }
      tell_creator( "wyvyrn" ,
         "[ %s the %s%s picked %s and kept their money ]\n",
         this_player()->query_short(), 
         guild ? capitalize(guild->query_name()[0..<2]) : "Adventurer",
         newbie ? "" : " (newbie)",
         this_player()->query_nationality_region());
   }
}

int setup_nationality(string direction, object person) {
   string* bits;

   bits = explode(direction, " ");
   change_nationality(person, bits[1], implode(bits[2..], " "));
   return 1;
}

int do_choose(string nat, string region) {
   string region_new;
   string nationality;
   string loc;

   nationality = lower_case(nat);
   if (!_nationalities[nationality]) {
      add_failed_mess("There is no nationality " + nationality + ".\n");
      return 0;
   }
   nat = nationality;
   nationality = _nationalities[nationality];
   region_new = find_region(nationality, region);
   if (!region_new) {
      add_failed_mess("Cannot find the region " + region +
                      " in the nationality " + nat + ".  It must be "
                      "one of " +
                      query_multiple_short(nationality->query_regions()) + ".\n");
      return 0;
   }

   // Try and find the region.
#ifdef DEBUG
   debug_printf("Nationality is %O, region is %O, player is %O.\n", 
      nationality, region_new, this_player()->query_short());
#endif
   change_nationality(this_player(), nat, region_new);
   loc = nationality->query_region_start_location(region_new);
   this_player()->move_with_look(loc, "$N arrive$s into the world.",
                                 "$N disappears to a better life.");
   this_player()->remove_property("not real newbie");
   if (clonep(this_object())) {
      call_out((: dest_me :), 10);
      if (_sign) {
         _sign->dest_me();
      }
   }
   return 1;
}

int do_info(string nat, string region) {
   string region_new;
   string nationality;

   nationality = lower_case(nat);
   if (!_nationalities[nationality]) {
      add_failed_mess("There is no nationality " + nationality + ".\n");
      return 0;
   }
   nationality = _nationalities[nationality];
   region_new = find_region(nationality, region);
   if (!region_new) {
      add_failed_mess("Cannot find the region " + region +
                      " in the nationality " + nat + ".  It must be "
                      "one of " +
                      query_multiple_short(nationality->query_regions()) + ".\n");
      return 0;
   }

   // Try and find the region.
#ifdef DEBUG
   debug_printf("Nationality is %O, region is %O, player is %O.\n", 
      nationality, region_new, this_player()->query_short());
#endif
   write(nationality->query_region_description(region_new) + "\n");
   return 1;
}

int do_nationality_info(string nationality) {
   string ret;
   string region;

   nationality = lower_case(nationality);
   if (!_nationalities[nationality]) {
      add_failed_mess("There is no nationality " + nationality + ".\n");
      return 0;
   }

   nationality = _nationalities[nationality];

   ret = nationality->query_information() +
         "Regions you can choose:\n";
   foreach (region in nationality->query_regions()) {
      ret += "  * " + region + "\n";
   }
   write(ret);
   return 1;
}

void init() {
  add_command("info", "<word'nation'>", (: do_nationality_info($4[0]) :));
  add_command("info", "<word'nation'> <string'region'>", (: do_info($4[0], $4[1]) :));
  add_command("choose", "<word'nationality'> <string'region'>", (: do_choose($4[0], $4[1]) :));
}

void fixup_player(object player) {
   object ob;

   ob = clone_object(__FILE__);
   player->move_with_look(ob);
}

string query_quit_handler() {
   return __FILE__;
}
// --- END [/mnt/home2/grok/lib/d/liaison/NEWBIE/choose_land.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/liaison/NEWBIE/inside.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/liaison/NEWBIE/inside.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627563   Available: 13574917
Inodes: Total: 5242880    Free: 4960133
531 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/liaison/NEWBIE/inside.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627563   Available: 13574917
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker: ceres $
 * $Id: align.c,v 1.10 2002/09/11 04:25:30 pinkfish Exp ceres $
 *
 *
 */
#include "path.h"
inherit "/std/room/basic_room";
inherit PATH + "common";

void create() {
  do_setup++;
  ::create();
  do_setup--;
  
  if ( !do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }
}

void init() {
  ::init();
  this_player()->add_command("speak", this_object(), "<string'language'>" );
}

int do_speak(string str) {
  write("Sorry, you cannot do that here.\n");
  return 1;
}
// --- END [/mnt/home2/grok/lib/d/liaison/NEWBIE/inside.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/liaison/NEWBIE/align.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/liaison/NEWBIE/align.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627563   Available: 13574917
Inodes: Total: 5242880    Free: 4960133
5047 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/liaison/NEWBIE/align.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627563   Available: 13574917
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: align.c,v 1.10 2002/09/11 04:25:30 pinkfish Exp $
 *
 *
 */
/* Added no teleport property- 26-06-98- Shalla */
/* New room to allow new players to set their alignment when they start the
   game. Ceres
 */

#include "path.h"
inherit "/std/room/basic_room";
inherit PATH+"common";

object _wlever;
object _blever;
object _glever;
int do_pull(object lever);

void setup() {
  object sign;

  set_zone("Newbie");
  set_short("alignment room" );
  set_light( 75 );
  add_property("no teleport", 1);
  set_long( "This is a small, bare room that is quite empty apart from "
            "a lever stuck onto each of three walls and a small wooden "
            "sign placed in the centre of the room.\n"
            "A door to the east leads back to the foyer.\n"); 

  add_item(({"west wall", "south wall", "east wall"}),
           "A plain, flat wall with a lever sticking out of it.");
  
  sign=add_sign("A sign marked 'alignment'.\n",
                FOYER->format_sign(
           "Alignment is how good or evil you are.  This changes gradually "
           "depending on the things you do.  Because it changes so slowly "
           "you can choose to start out with a good, neutral or evil "
           "alignment.  To become evil, pull the black lever, to become "
           "good pull the white lever, and to stay neutral don't pull "
           "either lever, or pull the grey lever if you have already pulled "
           "one of the other ones.\n"),0,"sign","general");
  sign->set_short("sign");
  sign->add_adjective("wooden");

  /* Make it so you cannot godmother out of here */
  add_property("no godmother", 1);

  add_exit( "foyer", PATH + "foyer", "door");
  add_alias( "east", "foyer");

  room_chat(({10, 40, ({"A voice which seems to come from the black lever "
                        "says: Don't be a goody-goody, pull me!",
                        "A voice which seems to come from the white lever "
                        "says: You should be nice, pull me!",
                        "A voice which seems to come from the grey lever "
                        "says: It's all about balance in the end."})}));
}

void init() {
  if (_wlever) {
     this_player()->add_command("pull", _wlever, "<direct:object>",
                              (: do_pull(_wlever) :));
  }
  if (_blever) {
     this_player()->add_command("pull", _blever, "<direct:object>",
                              (: do_pull(_blever) :));
  }
  if (_glever) {
     this_player()->add_command("pull", _glever, "<direct:object>",
                              (: do_pull(_glever) :));
  }
  ::init();
}

void reset() {
  if(!_wlever) {
    _wlever = clone_object("/std/object");
    _wlever->set_name("lever");
      _wlever->add_adjective("white");
    _wlever->set_short("white lever");
    _wlever->set_long("This is a lever which is set into the wall.  It "
                     "radiates a soft white glow.  The closer you stand "
                     "to it the more peaceful you feel.\n");
    _wlever->reset_get();
    _wlever->add_property("there", "on the east wall");
    _wlever->move(this_object());
  }
  if(!_blever) {
    _blever = clone_object("/std/object");
    _blever->set_name("lever");
    _blever->add_adjective("black");
    _blever->set_short("black lever");
    _blever->set_long("This is a lever which is set into the wall.  It "
                     "is pure black and emanates a deep, blood-red glow.  "
                     "The closer you get to it the more angry and hateful "
                     "you feel.\n");
    _blever->reset_get();
    _blever->add_property("there", "on the west wall");
    _blever->move(this_object());
  }
  if(!_glever) {
    _glever = clone_object("/std/object");
    _glever->set_name("lever");
    _glever->add_adjective("grey");
    _glever->set_short("grey lever");
    _glever->set_long("This is a lever which is set into the wall.  It "
                     "is a dull grey and very boring.\n");
    _glever->reset_get();
    _glever->add_property("there", "on the south wall");
    _glever->move(this_object());
  }
}

int do_pull(object lever) {
  int align;
  
  if(lever == _glever) {
    add_succeeded_mess(({ "$N $V $I and feel an overwhelming urge to do "
          "absolutely nothing about the world's problems.\n",
          "$N $V $I and suddenly looks very apathetic.\n" }),
          ({ _glever }));
    this_player()->set_al(0);
    return 1;
  }
  
  align = 300 + random(400);

  if(lever == _wlever) {
    align = -align;
  }

  this_player()->set_al(align);

  if(lever == _wlever) {
    add_succeeded_mess(({ "$N $V $I and suddenly feel$s like hugging "
          "everyone.\n",
          "$N $V $I and looks bright and cheery.\n" }),
          ({ _wlever }));
  } else {
    add_succeeded_mess(({ "$N $V $I and get a sudden urge to pull the "
          "wings off butterflies and torture small furry creatures.\n",
          "$N $V $I and a dark scowl crosses $p face.\n" }),
          ({ _blever }));
  }
  return 1;
}
// --- END [/mnt/home2/grok/lib/d/liaison/NEWBIE/align.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/liaison/NEWBIE/womble.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/liaison/NEWBIE/womble.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627562   Available: 13574916
Inodes: Total: 5242880    Free: 4960133
4086 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/liaison/NEWBIE/womble.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627562   Available: 13574916
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* Coded by Talonia, Nov., '95*/
/* Modified to expound on multiplaying by Arby, June 16, 1998 */

#include "path.h"
#include <library.h>

inherit "/obj/monster";

void setup() {
  set_name("womble");
  set_short("womble");
  set_long("This is a small, furry womble.  She is about four feet "
           "tall and looks very cuddly.  She also looks very sad and "
           "is sobbing loudly.\n");
  add_property( "unique", 1 );
  set_gender(2);
  add_plural("wombles");
  set_race("human");
  set_level(100);
  set_language("general");
  add_move_zone("Newbie");
  set_move_after(30, 30);
  set_response_mon_understand_anything(1);
  set_respond_to_with(({
    ({"@comfort", "womble"}),
      "'Thank you, will you find my brooch for me?",
    ({({"@kick", "@punch"}), "womble"}),
      "cry"}));

  add_respond_to_with(({ ({ "hello", "hi", "gday", }),
                     ({ "womble", "all" }) }), ({ "'Hello $hcname$",
                                                    "greet $hname$" }));
  add_respond_to_with(
                           ({ ({"good day", "greetings"}), 
         ({ "womble", "all" }) }), ({ "'Hello $hcname$",
                                        "bow deep $hname$" }));
  add_respond_to_with(
   ({ "fuck", ({ "off", "you" }) }), ({ "'Same to you!", "skick $hname$" }));
  add_respond_to_with(({ "fuck" }), "waggle $hname$");
  add_respond_to_with(
                      ({ "@smile", "womble" }), "smile $hname$");
  add_respond_to_with(
     ({ ({ "@skick", "@spunch", "@jump", "@pat", "@slap" }),
          "womble" }), "glare $hname$");
  add_respond_to_with(
                      ({ ({ "@poke", "@glare", "@point" }),
                           "womble" }), "peer sus at $hname$");
  add_respond_to_with(
                      ({ "@grin", "womble" }), "grin $hname$");
  add_respond_to_with(
                ({ ({ "@caress", "@snuggle", "@nestle", "@love", "@throw" }),
                     "womble" }), "waggle $hname$");
  add_respond_to_with(
                      ({ ({ "@kiss", "@french", }),
                           "womble" }), "slap $hname$");
  add_respond_to_with(({ ({ "@bing", "@womble", }),
                           "womble" }), "smile bri $hname$");

  load_chat(50, ({
    1, ":sobs loudly.",
    1, "'Boo Hoo!  I've lost my brooch!",
    1, "@weep",
    1, "'I really loved that brooch.",
    1, "@cry",
    1, "'Oh I wish someone would find it for me.",
    2, "'Please find my brooch for me.",
    2, "'I lost my brooch in one of the rooms while I was reading all "+
       "the wonderful information here."}) );
} /* setup() */

void event_enter(object obj, string mess, object from) {
  if( (obj->query_property("wombles brooch")) &&
      (obj->query_name() == "brooch") &&
      (environment(obj) == this_object()) ) {
    call_out("brooch", 1, ({ this_player() }) );
  }
} /* event_enter() */

void brooch(mixed arg) {
  object item, tp;
  tp = arg[0];
  if(tp->query_property("womble's brooch")) {
    do_command("'Thank you for returning my brooch again.");
  } else {
    tp->add_property("womble's brooch", 1, 86400);
    tp->adjust_xp(10000);
    do_command("'Wow!  My brooch!");
    do_command("'Thank you very much!");
  }

  do_command("'You may now enter the game by typing \"out\" in the foyer.");
  do_command("'Good Luck!");
  do_command("huggle "+(string)tp->query_short());
  do_command("emote sets the brooch down, and quickly forgets where she left it.");
  foreach(item in all_inventory()) {
    item->dest_me();
  }
} /* brooch() */

int attack_by(object thing) {
  write("The womble smacks you round the head with her paw sending you "
  "flying across the room.\n");
  write("You bash your head against the wall and the world starts "
  "spinning.\n");
  do_command("'Hey, that's not nice!\n");
  thing->add_effect("/std/effects/ingested/tranquil_sleep", 120);
  this_object()->stop_fight(thing);
  thing->stop_fight(this_object());
  return 0;
} /* attack_by() */

int attack_ob(object thing) {
  this_object()->stop_fight(thing);
  thing->stop_fight(this_object());
  return 0;
} /* attack_ob() */

// --- END [/mnt/home2/grok/lib/d/liaison/NEWBIE/womble.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/liaison/NEWBIE/newbie_brochure.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/liaison/NEWBIE/newbie_brochure.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627560   Available: 13574914
Inodes: Total: 5242880    Free: 4960133
9638 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/liaison/NEWBIE/newbie_brochure.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627560   Available: 13574914
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: newbie_brochure.c,v 1.2 2002/09/11 04:25:30 pinkfish Exp $
 *
 * $Log: newbie_brochure.c,v $
 * Revision 1.2  2002/09/11 04:25:30  pinkfish
 * Fix up for the changeover.
 *
 * Revision 1.1  2000/03/01 06:06:45  ceres
 * Initial revision
 *
 * Revision 1.1  1998/01/16 02:18:32  arby
 * Initial revision
 *
*/
/* Please, oh please, don't read the code, as it has no punctation 
   whatsoever :) (I blame the colours)
   This newbie brochure is *completly* rewritten from the
   old /d/am/am/items/colourful brochure found in the tray in the Mended
   Drum.
   
   Hobbes, July 96                                                   */

#include "path.h"
#define PAGES    6
inherit "/std/leaflet";

void setup() {
  set_name( "brochure" );
  set_short( "newbie brochure");
  set_main_plural( "brochures" );
  add_alias ( ( {"brochure", "pamphlet", "newbie brochure"} ) );
  set_weight( 0 );
  set_value( 400 );
  set_no_pages( PAGES );
  set_long( "This is a pamphlet for the newbies who rushed through the "
            "newbie foyer too fast or are just absent-minded in general.  "
            "It contains valuable information on the commands, guilds "
            "and the city.  "
            "You may <read brochure>, and "
            "<turn a page of brochure>.\n" );
  set_open_page( 1 );
  set_read_mess( "                                                \n"
 "                                                                \n"     
"                            %^B_RED%^TABLE OF CONTENTS%^RESET%^                        Page 1\n"
 "                    .o0o.o0o.o0o.o0o.o0o.o0o.o0o.o0o.       \n"
 "                                            \n"
 "         General information.....................................2-3\n"
 "         Commands..................................................4\n"
 "         Guilds....................................................5\n"
 "         The lands around Ankh-Morpork.............................6\n"
 "                                                                  "
 "                                                                  "
 "                                                                  "
 "%^B_RED%^ NOTE:%^RESET%^ If you haven't played MUD's before, we advise you"
 " to read any of the \n"
 " FAQ's around (Frequently Asked Questions).  To read the Discworld FAQ,\n"
 " type 'help FAQ' or point your http browser at: \n"
 " http://www.imaginary.com/LPMud/lpmud_faq.html\n",

 "general", 100 );
  set_open_page( 2 );

  set_read_mess( "                                                        \n"
 "                            GENERAL INFORMATION                     Page 2\n"
 "                           -=-=-=-=-=-=-=-=-=-=-                 \n"
        "                                                \n"
 " At any time during the course of playing you can get HELP on various \n"
 " topics by typing  '%^B_RED%^help concepts%^RESET%^' "
 "and  '%^B_RED%^help command_list%^RESET%^'. \n"
 " If you need to ask something else, or have problems of any kind, \n"
 " the LIAISON people will kindly help you out, if you ask nicely. \n"
 " To see if any are logged on, simply type  '%^B_RED%^liaisons%^RESET%^'.\n"
 " Also, most of the players are usually very helpful when it comes to \n"
 " answering questions.                                \n"
 "                                                                        \n"
 " As soon as you have made a choice you should join a GUILD where you can \n"
 " advance your skills (take a look at page 5 in this brochure for more \n"
 " information on the different guilds).  But while deciding, you can \n"
 " simply teach yourself.  Type  '%^B_RED%^help level%^RESET%^' and "
 " '%^B_RED%^help teach%^RESET%^' \n"
 " to find out more.\n"
 "                                 \n"
 " CONTINUES ON NEXT PAGE.\n",
 "general", 100 );
  set_open_page( 3 );
  set_read_mess( "                                                  \n"
 "                                                                   Page 3\n" 
 " In Ankh-Morpork there are GUIDES wandering around that can take you to \n"
 " certain destinations.  These are often waiting by the guilds or in the \n"
 " Mended Drum.  To use one you say in the same room as one, for example: \n"
 " 'take me to wizards guild please'.  \n"
 " Other places they can take you to, besides the guilds, are \n"
 " 'the post office',  'the bank',  'least gate' and  'hubwards gate'.\n"
 "                                                    \n"
 " You start off with a total of eight lives.  If you should happen to die,\n"
 " Harry at the Temple of Small Gods, can RAISE you from the dead and you \n"
 " are then set to go again (one life shorter).  Player Priests also have \n" 
 " the ability to resurrect.\n"
" And please BUG report bugs and typos you see.  Do  '%^B_RED%^help bug%^RESET%^' "
 " and \n"
 " '%^B_RED%^help typo%^RESET%^' for more information.\n", 
 "general", 100 );
  set_open_page( 4 );
  set_read_mess( "                                                       \n"
 "                                   COMMANDS                        Page 4\n"
 "                                 -=-=-=-=-=-\n"
 "                                                                  \n"
  " '%^B_RED%^who%^RESET%^' or '%^B_RED%^finger%^RESET%^'"
  "  Will show the people logged on.  \n"
  "                    You can also 'finger <playername>'\n"
  " '%^B_RED%^rearrange%^RESET%^'        Allows you to set your stats"
  " (You can only do this once).\n"
  " '%^B_RED%^score%^RESET%^'            Will show statistics.\n"
  " '%^B_RED%^i%^RESET%^'                Will show you your inventory.\n"
  " '%^B_RED%^skills%^RESET%^'           Will list your skills.\n"
  " '%^B_RED%^wimpy < % >%^RESET%^'      To automatically run away before "
  "you die.\n"
  " '%^B_RED%^monitor on%^RESET%^'       Will help you keep track of Hit"
  " and Guild points.\n"
  " '%^B_RED%^inform logon on/off%^RESET%^'    Gives you info on logon/out-"
  "events (once you've \n                    joined a guild).\n"
  " '%^B_RED%^help map%^RESET%^'         Gives you a map of Ankh-Morpork  "
  "(Try also \n"
  "                   'help ankh-morpork'.)\n"
 " '%^B_RED%^.%^RESET%^'                Will repeat your last command.\n"
  " Other commands "
  "worth checking out, or read the help files for, are: \n"
  " '%^B_RED%^alias%^RESET%^',  '%^B_RED%^earmuff%^RESET%^', "
  " '%^B_RED%^commands%^RESET%^', '%^B_RED%^score stats%^RESET%^',  "
  "'%^B_RED%^nickname%^RESET%^',  '%^B_RED%^consider%^RESET%^'\n"
  " '%^B_RED%^gp%^RESET%^' and  '%^B_RED%^playerkilling%^RESET%^'.\n",
  "general", 100 );  
  set_open_page( 5 );
  set_read_mess( "                                                   \n"
 "                               THE GUILDS                           Page 5\n"
 "                             -=-=-=-=-=-=-\n"
       "                                                  \n"
 " Each player will usually join a guild so that they can learn skills\n"
 " and commands and so advance their abilities.   Being in a guild also \n"
 " adds character to your character.  These guilds are currently available:\n"
 " WIZARDS GUILD is located west of Sator Square.  To join you have to look\n"
 " around in the Great Hall and find a staircase.\n"
 " THIEVES GUILD is at the beginning of Alchemist street.\n"
 " FIGHTERS GUILD is on Filigree Street, just a stone's throw from Mended \n"
 " Drum.\n"
 " PRIESTS GUILD with its various Gods is located on Small Gods Street.\n"
 " The Gods are: Hat, Pishe, Fish, Sek, Gapp, Gufnork and Sandelfon.\n"
 " For more information, type 'info' in their guild rooms.\n"
 " ASSASSINS GUILD is located at the eastern end of Filigree Street.  Fill \n"
 " in an application and give it to the secretary in the guild office.\n"
 " WITCHES GUILD is located at Granny Weatherwax' cottage in Lancre. \n"
 " See Gennie Applebottom at Dione Street in Ankh-\n"
 " Morpork if you have trouble finding the place.\n",
 "general", 100 );
  set_open_page( 6 );
  set_read_mess( "                                                    \n"
 "                        THE LANDS OUTSIDE ANKH-MORPORK              Page 6\n"
 "                       -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-                \n"
 "                                                           \n"
 " The lands around the city can sometimes be strange and dangerous \n"
 " places.  Through the northeastern (Least) gate is the path that goes \n"
 " through the plains, some small villages, and finally up to the \n"
 " mountains, also known as the Ramtops.\n"
 " The southeastern (Hubwards) gate takes you into the vast forest where \n"
 " innocent people are terrorised by wolves and other strange creatures \n"
 " that roam unfettered.  It's also a more direct route to the Ramtops\n"
 " (Carriages from Ankh-Morpork are a nice alternative to tired feet for \n"
 " travelling to and from the towns in the Sto Plains and Ramtops).\n"
 " The tour operator at Sator Square is ready to send you to the warm \n"
 " and distant continent of Klatch, if you have enough money.\n"
 " There are more fantastic and exciting places to come.\n",
 "general", 100 );   
  set_open_page( 1 );
}

/*
void init() {
   this_player()->add_command( "scan", this_object(), "'page' %d 'of' %D" );
}   

mixed do_scan( object *indir, string id_match, string ind_match,
         mixed *args, string pattern ) {
   int pg;

   if( !args || !sizeof( args ) )
     return ::do_read();
   
   pg = args[ 0 ];
   if( pg > PAGES || pg < 1 )
      return 0;
   set_open_page( pg );
   return ::do_read();

}
*/
// --- END [/mnt/home2/grok/lib/d/liaison/NEWBIE/newbie_brochure.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/liaison/NEWBIE/common.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/liaison/NEWBIE/common.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627558   Available: 13574912
Inodes: Total: 5242880    Free: 4960133
523 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/liaison/NEWBIE/common.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627558   Available: 13574912
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming

void dest_money(object coins) {
  if(coins->query_number_coins() > 1)
    tell_room(this_object(), "As the coins hit the ground they "
              "slip between the cracks and disappear.\n");
  else
    tell_room(this_object(), "As the coin hits the ground it "
              "slips between the cracks and disappears.\n");

  coins->move("/room/rubbish");
}
#ifdef 0
void event_enter(object ob, string mess, object from) {
  if(base_name(ob) == "/obj/money") {
    call_out("dest_money", 0, ob);
  }
  return;
}
#endif

// --- END [/mnt/home2/grok/lib/d/liaison/NEWBIE/common.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/liaison/NEWBIE/greg.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/liaison/NEWBIE/greg.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627558   Available: 13574912
Inodes: Total: 5242880    Free: 4960133
8516 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/liaison/NEWBIE/greg.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627558   Available: 13574912
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
#include "path.h"
#include <armoury.h>

inherit "/obj/monster";

#define THROW_OUT 300

#define RPATHS ({ PATH + "combat_room1", PATH + "combat_room2", PATH + "combat_room3"})
#define RNAMES ({ "one", "two", "three" })

object *queue = ({ }); // the queue of people waiting to use a room.
object *offered = ({ }); // offered.
object *in_use = ({ 0, 0, 0 }); // who is using the rooms.
object combat_room;
mapping callouts;

void setup() {
  add_property("determinate", "");
  set_name( "greg" );
  set_short("Greg" );
  set_main_plural("Gregs" );
  set_race( "human" );
  set_response_mon_understand_anything(1);
  set_gender( 1 );
  set_al(-500 );
  set_class( "fighter" );
  set_language( "general" );
  set_level( 100 + random( 100 ) );
  set_long( "This is Greg the combat instructor.  He looks pretty mean, but "
            "don't let appearances deceive you, he's a softy at heart.\n" );
  adjust_money( 10 + random( 40 ), "Ankh-Morpork pence" );
  load_chat( 25, ({
    1, ":grunts.",
      1, "'Ug.",
      1, "'I am great.",
      1, "@flex",
      1, "'Look at my cool muscles.",
      }) );

  add_respond_to_with(({ "yes" }), ({ "#yes" }));
  add_respond_to_with(({ "no" }), ({ "#no" }));

  add_respond_to_with(({ ({ "can", "may" }),
                         ({ "practise", "practice", "train"}),
                         ({ "please" }) }),
                      ({ "#request" }) );

  add_respond_to_with(({ ({ "hello", "hi", "gday", }),
                           ({ "womble", "all" }) }), ({ "'Hello $hcname$",
                                                          "bow ? $hname$" }));

  add_respond_to_with(({ "fuck", ({ "off", "you" }) }), ({ "'Same to you!",
                                                             "skick $hname$"
                                                             }));
  add_respond_to_with(({ "fuck" }), "waggle $hname$");
  add_respond_to_with(
                      ({ "@smile", "womble" }), "smile $hname$");
  add_respond_to_with(
     ({ ({ "@skick", "@spunch", "@jump", "@pat", "@slap" }),
          "womble" }), "glare $hname$");
  add_respond_to_with(
                      ({ ({ "@poke", "@glare", "@point" }),
                           "womble" }), "peer sus at $hname$");
  add_respond_to_with(
                      ({ "@grin", "womble" }), "grin $hname$");
  add_respond_to_with(
                ({ ({ "@caress", "@snuggle", "@nestle", "@love", "@throw" }),
                     "womble" }), "waggle $hname$");

  add_respond_to_with(
                      ({ ({ "@kiss", "@french", }),
                           "womble" }), "slap $hname$");
  add_respond_to_with(({ ({ "@bing", "@womble", }),
                           "womble" }), "smile bri $hname$");

  add_skill_level( "other.health", 50 + random( 50 ) );
  (ARMOURY->request_weapon("long sword", 75))->move(this_object());
  (ARMOURY->request_armour("ringmail", 80))->move(this_object());
  (ARMOURY->request_armour("metal clad boots", 80))->move(this_object());
//  (ARMOURY->request_armour("metal helmet", 80))->move(this_object());
  (ARMOURY->request_armour("metal gauntlets", 80))->move(this_object());
  init_equip();
  callouts = ([ ]);
}

void event_enter(object ob, string message, object from) {
  if(environment() == find_object("/room/rubbish")) {
    return ::event_enter(ob, message, from);
  }
  if(ob->query_property("dead")) {
    return ::event_enter(ob, message, from);
  }
  if(!ob->query_visible(this_object())) {
    return ::event_enter(ob, message, from);
  }
  if(!userp(ob)) {
    return ::event_enter(ob, message, from);
  }
  if(callouts && callouts[ob]) {
    remove_call_out(callouts[ob]);
    map_delete(callouts, ob);
  }

  call_out("do_greeting", 1, ob, from);
}

int attack_by(object thing) {
  tell_room(environment(), "Greg lifts a hand and slaps " + thing->one_short()
            + " sending " + thing->query_objective() + " flying across "
            "the room.\n", thing);
  write("Greg lifts a hand, almost as large as your head, and gives you a "
        "slap that sends you flying across the room.\n");
  write("You bash your head against the wall and the world starts "
        "spinning.\n");
  do_command("'Hey, that's not nice!");
  thing->add_effect("/std/effects/ingested/tranquil_sleep", 120);
  this_object()->stop_fight(thing);
  thing->stop_fight(this_object());
  return 0;
}

// Check if there is a room free and if this person is at the top of the
// queue.
void check_room() {
  int room;
  object ob;

  queue = filter_array(queue,
                       (: environment($1) == environment(this_object()) :));

  // When we just want to shuffle someone off the queue we call this function
  // with ob of 0 and then just take the first person in line.
  if(sizeof(queue))
    ob = queue[0];

  if(member_array(ob, queue) == -1)
    return;

  room = member_array(0, in_use);

  if(room == -1) {
    do_command("'Ok " + ob->one_short() + ", unfortunately all the rooms are "
               "busy right now, but "
               "if you don't mind waiting a minute one will become free.");
    return;
  }

  do_command("'Ok " + ob->one_short() + ", you can use room " +
             RNAMES[room] + ".");
  tell_object(ob, "Greg leads you into room " +
              RNAMES[room] + ".\n");
  ob->move_with_look(RPATHS[room], "$N is propelled into the room.",
                     "$N is led out of the room.");
  in_use[room] = ob;
  queue -= ({ ob });

  callouts[ob] = call_out("throw_out", THROW_OUT, ob);
  combat_room = environment();
}

// Called when someone says yes to training
void yes(object ob) {
  if(member_array(ob, offered) == -1 || member_array(ob, queue) != -1)
    return;

  queue += ({ ob });
  check_room();
}

void no(object ob) {
  if(member_array(ob, offered) == -1)
    return;
  offered -= ({ ob });
  if ( environment(ob) == environment(this_object()) ) {
    do_command("'Okay.  Well, come back if you feel like having a go later.");
    do_command("smile " + ob->query_name());
  }
}

// Someone wants to practice.
void request(object ob) {
  do_command("'Would you like to try out your skills " + ob->one_short() +
             "?");
  if(!sizeof(filter_array(ob->query_holding(), (: $1 && $1->query_weapon()
                                                :))))
    do_command("'You may want to buy a weapon at the shop before trying out "
               "your skills.");
  if(!offered)
    offered = ({ });
  offered += ({ ob });
}

// find out who is using a particular room, this is called by the combat
// rooms exit function.
object query_using(int room) {
  return in_use[room];
}

// Throw people out of the room if they've been in there too long.
void throw_out(object ob) {
  int room;

  room = member_array(ob, in_use);

  if(room != -1) {
    if(base_name(environment(ob)) == RPATHS[room]) {
      do_command(RNAMES[room]);
      call_out("tell_them", 2, ob, room);
    } else {
      in_use[room] = 0;
    }
  }
}

void tell_them(object ob, int room) {
  if(!ob) {
    do_command("combat");
    return;
  }

  do_command("'Ok " + ob->one_short() + ", time's up.");
  do_command("'Come with me.");
  environment()->stop_them(ob);
  tell_object(ob, "Greg leads you out of the room.\n");
  do_command("combat");
  ob->move_with_look(combat_room, "$N is propelled into the room.",
                     "$N is pushed out of the room.");
}

// Welcome them and see if they want to do some combat training.
void do_greeting(object ob) {
  int room;

  if(!ob || !interactive(ob) || member_array(ob, queue) != -1)
    return;

  room = member_array(ob, in_use);

  // If they haven't just used a room, and are not marked as using a
  // room say hello.
  if(room == -1) {
    do_command("'Hello " + ob->one_short() + ", welcome to the combat "
               "training area.");
    do_command("'Would you like to try out your skills?");

    if(!sizeof(filter_array(ob->query_holding(), (: $1 && $1->query_weapon()
                                                  :))))
      do_command("'You may want to buy a weapon at the shop before trying out "
                 "your skills.");

  } else {
    do_command("'I hope you had a productive time.  Would you like to have "
               "another go?");

    // If they're still marked as using a room then mark that room as
    // available and check for someone new needing it.
    if(room != -1) {
      in_use[room] = 0;
      check_room();
    }
  }

  if(!offered)
    offered = ({ });
  offered += ({ ob });
}
// --- END [/mnt/home2/grok/lib/d/liaison/NEWBIE/greg.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/liaison/NEWBIE/trainer.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/liaison/NEWBIE/trainer.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627555   Available: 13574909
Inodes: Total: 5242880    Free: 4960133
3610 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/liaison/NEWBIE/trainer.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627555   Available: 13574909
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <weapon.h>
#include <armoury.h>

inherit "/obj/monster";

object *greeters = ({ });

#define GREETINGS ({ \
   "Welcome to Combat Boot Camp, $name$.",\
   "This here course is set up to teach you the basics of fighting.",\
   "You can attack this here dummy and I'll tell ya how well ya done.",\
   "Arr!  You have the look of a fine fighter, $name$." \
})

void setup() {
  //setup_nationality( "/std/nationality/morpork", "Ankh-Morpork" );
  set_language( "general" );
  basic_setup( "human", "warrior", 100 );
  set_gender( 1 );
  
  ARMOURY->request_item("leather jerkin", 30)->move( this_object() );
  ARMOURY->request_item("leather breeches", 30)->move( this_object() );
  ARMOURY->request_item("hard leather boots", 30)->move( this_object() ); 
   
  init_equip();

  
} /* setup() */

void whichone(string name) {
  switch(name) {
  case "xrazzicaz":
    set_name( "xrazzicaz" );
    add_alias( "xraz" );
    add_property( "determinate", "" );
    set_short( "Xrazzicaz" );
    set_long( "This is the former Warriors' Guild dummy.  After being replaced by "
              "the newer mechanical dummy, Xrazzicaz decided to stay on as an "
              "instructor.\n");
    break;
  case "zazzifraz":
  set_name( "zazzifraz" );
  add_alias( "zazz" );
  add_property( "determinate", "" );
  set_short( "Zazzifraz" );
  set_long( "This is Xrazzicaz' brother, a former Warriors' Guild dummy.  After "
            "being replaced by the newer mechanical dummy, Zazzifraz, like "
            "his brother, decided to stay on as an instructor.\n");
  break;
  case "john":
    set_name( "john" );
    add_property( "determinate", "" );
    set_short( "John" );
    set_long( "This is Xrazzicaz' other brother, John.  He was the Warriors' "
              "Guild dummy in Ohulan Cutash until he was replaced by a "
              "mechanical dummy.  Like Xrazzicaz and Zazzifraz he got a "
              "job teaching after retirement.\n");
  }
}

int attack_by(object thing) {
  write(this_object()->the_short() + " glares at you before swiftly knocking "
    "you to the ground.\n");
  this_object()->stop_fight(thing);
  thing->stop_fight(this_object());
  return 0;
} /* attack_by() */

int attack_ob(object thing) {
  this_object()->stop_fight(thing);
  thing->stop_fight(this_object());
  return 0;
} /* attack_ob() */

void init() {
  if(!this_player()) {
    return;
  }
  if(environment() == find_object("/room/rubbish")) {
    return;
  }
  if(this_player()->query_property("dead")) {
    return;
  }
  if(!this_player()->query_visible(this_object())) {
    return;
  }
  if(!userp(this_player())) {
    return;
  }
  if(this_player()->query_property("player")) {
    greeters += ({this_player()});
    call_out("do_greeting", 1, this_player());
  }
} /* init() */

void do_greeting() {
  string str;
  
  if(!sizeof(greeters)) {
    return;
  }
  greeters = filter(greeters, 
    (: $1 && environment($1) == environment(this_object()) &&
     $1->query_visible(this_object()) :));
  uniq_array(greeters);
  foreach(str in GREETINGS) {
    str = replace(str, "$name$", query_multiple_short(greeters));
    do_command("'" + str);
  }
  greeters = ({ });
} /* do_greeting() */

void stop_them( object attacker, object dummy ) {
  tell_object( attacker, one_short() +" stops you attacking "+
               (string)dummy->the_short() +".\n" );
  tell_room( environment(), one_short() +" stops "+
             (string)attacker->the_short() +" attacking "+
             (string)dummy->the_short() +".\n", attacker );
  attacker->stop_fight( dummy );
  dummy->stop_all_fight();
} /* stop_them() */
// --- END [/mnt/home2/grok/lib/d/liaison/NEWBIE/trainer.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/liaison/NEWBIE/combat_room2.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/liaison/NEWBIE/combat_room2.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627554   Available: 13574908
Inodes: Total: 5242880    Free: 4960133
3050 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/liaison/NEWBIE/combat_room2.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627554   Available: 13574908
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
//swiped from the Thieves' Guild room with modifications - Rue
/*combat classroom*/

#include "path.h"
#define MAX 100;

inherit PATH + "inside";

string *arr0;
object sign, dummy, trainer;

void setup() {
  //set_zone( "Newbie" );
  set_short("Zazzifraz' Boot Camp");
  add_property("determinate", "");
  set_light( 75 );
  add_property("no teleport", 1);
  
  set_long("This is a small training room, designed to help the new "
           "adventurer get off to a good start on Discworld.  The air is "
           "stale with the combined stench of sweat, beer, and old "
           "warriors.  Off to one side is a rather unusual training "
           "dummy above which is a small plaque.\n");
  add_item( "face", "As you stare at it, squinting and turning your head "
            "side to side, you realise it looks rather like your old maths "
            "teacher!\n");
  add_item( "floor", "The floor is made of flagstones, cemented together "
            "with centuries of accumulated muck.\n");
  add_item( "wall", "The walls are marked with mysterious stains that may or "
            "may not be blood.  But surely training dummies don't bleed.\n");
  add_item( "ceiling", "The ceiling appears to be dingy patches of plaster "
            "stuck between old oak rafters that have turned black with "
            "age.\n");
/* Make it so you cannot godmother out of here */
  add_property("no godmother", 1);

  add_exit( "combat", PATH + "combat", "door" );
  add_alias( "northwest", "combat");
}/*setup*/

void reset() {
  if(!sign) {
    sign=add_sign("This is a plaque that seems to describe how to have "
                  "your combat skills assessed.\n", "To assess your "
                  "skills, attack the dummy with the weapon you want to "
                  "test your proficiency in.  Each time you hit the "
                  "dummy, the instructor will comment on your "
                  "performance.  After a number of rounds, the "
                  "instructor will stop you and give you an overall "
                  "performance rating.\n\n"
                  "Don't forget to hold your weapon of choice before "
                  "attacking the training dummy!\n",
                  "small plaque", "plaque", "general");
    sign->add_property("there", "on the wall");
  }
  if(!dummy)
    dummy = clone_object(PATH + "dummy");
  dummy->move(this_object());
  
  call_out("get_trainer", 1);
}/*reset*/

void dest_me() {
  if(sign)
    sign->dest_me();
  if(dummy)
    dummy->dest_me();
  if(trainer)
    trainer->dest_me();
  ::dest_me();
}

void get_trainer() {
  if(!trainer)
    trainer = clone_object(PATH +"trainer");
  
  if (trainer) {
    trainer->whichone("zazzifraz");
    trainer->move( this_object(), "$N hobble$s toward you on his straw-filled stumps." );
    dummy->set_trainer(trainer);
  }
}/*get_trainer*/

void stop_them(object who) {
  if(trainer && dummy)
    trainer->stop_them(who, dummy);
}


string query_quit_handler() {
  return "/d/liaison/NEWBIE/combat";
} /* query_quit_handler() */
// --- END [/mnt/home2/grok/lib/d/liaison/NEWBIE/combat_room2.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/liaison/NEWBIE/outside.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/liaison/NEWBIE/outside.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627553   Available: 13574907
Inodes: Total: 5242880    Free: 4960133
523 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/liaison/NEWBIE/outside.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627553   Available: 13574907
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker: ceres $
 * $Id: align.c,v 1.10 2002/09/11 04:25:30 pinkfish Exp ceres $
 *
 *
 */
#include "path.h"
inherit "/std/outside";
inherit PATH + "common";

void create() {
  do_setup++;
  ::create();
  do_setup--;
  
  if ( !do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }
}

void init() {
  ::init();
  this_player()->add_command("speak", this_object(), "<string'language'>" );
}

int do_speak(string str) {
  write("Sorry, you cannot do that here.\n");
  return 1;
}
// --- END [/mnt/home2/grok/lib/d/liaison/NEWBIE/outside.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/liaison/NEWBIE/womble_brooch.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/liaison/NEWBIE/womble_brooch.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627553   Available: 13574907
Inodes: Total: 5242880    Free: 4960133
1007 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/liaison/NEWBIE/womble_brooch.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627553   Available: 13574907
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: womble_brooch.c,v 1.2 2000/06/27 17:33:59 ceres Exp $
 *
 * $Log: womble_brooch.c,v $
 * Revision 1.2  2000/06/27 17:33:59  ceres
 * Modified to have the correct jewellery info
 *
 * Revision 1.1  2000/03/01 06:06:45  ceres
 * Initial revision
 *
 * Revision 1.2  1998/10/17 17:37:30  aragorn
 * Made the brooch compatible with the jewlery blorpler spell.
 *
 * Revision 1.1  1998/01/16 02:18:32  arby
 * Initial revision
 *
*/
/* Coded by Talonia for newbie area womble quest.
   Nov. '95
*/

#include "path.h"
inherit "/obj/armour";

void setup()
{
  set_name("brooch");
  add_adjective( ({ "womble", "brass" }) );
  set_short("womble brooch");
  set_long("A brass brooch with a womble engraved "
    "upon it.\n");
  add_alias("jewellery");
  add_plural("jewellery");
  set_type("badge");
  setup_armour(1000);
  set_percentage(100);
  set_damage_chance(0);
  set_weight(2);
  add_property("wombles brooch", 1);
  add_property( "shop type", "jewellers" );
}
// --- END [/mnt/home2/grok/lib/d/liaison/NEWBIE/womble_brooch.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/liaison/NEWBIE/fighters.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/liaison/NEWBIE/fighters.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627553   Available: 13574907
Inodes: Total: 5242880    Free: 4960133
2042 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/liaison/NEWBIE/fighters.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627553   Available: 13574907
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: fighters.c,v 1.5 2003/02/19 06:54:24 ceres Exp $
 *
*/

#include "path.h"
inherit PATH + "inside";

void setup() {
   set_short( "Warriors' gazebo" );
   set_light( 75 );
   add_property("no teleport", 1);
   set_long( "As you enter this gazebo, you are overwhelmed with a smell of "
             "decaying limbs and dried blood.  A sign catches your eye and you "
             "notice it's the only non-blood covered item in the room.  Maybe "
             "if you 'read sign' you'll get some information about this "
             "deadly guild.\n"
             "A small notice pinned to the wall with a sword states that this "
             "is not the place where you actually join the guild.  The rest "
             "of the note is too torn to read.\n" );

   set_zone( "Newbie" );

   add_item( ({ "armour" }),
             "There are many items around the room, but their function is "
             "beyond you for the most part." );
   add_item( ({ "notice" }),
             "This notice was probably pinned to the wall during combat "
             "practice, and is therefore more or less unreadable after the "
             "battering it got during the session.\n" );

   add_sign( "This sign seems to cower in the corner of the room "
             "unsure of it's place here.\n", "In this deadly guild, "
             "the fine art of killing and berserking is taught.  Learn how "
             "to be deadly with accuracy and lots of pain!  To be a warrior "
             "you must endure lots of pain, practice as much as you can, have "
             "a strong stomach, and have the ability to kill without batting "
             "an eye.  Remember to always keep your guild motto with you: 'If "
             "It Moves Kill It.  If It Doesn't Move, Wait For It To Move, "
             "Then Kill It.'", 0, 0, "general" ); 

/* Make it so you cannot godmother out of here */
   add_property("no godmother", 1);

   add_exit( "garden", PATH +"guilds_foyer", "gate" );
} /* setup() */
// --- END [/mnt/home2/grok/lib/d/liaison/NEWBIE/fighters.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/liaison/NEWBIE/advancement.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/liaison/NEWBIE/advancement.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627552   Available: 13574906
Inodes: Total: 5242880    Free: 4960133
8055 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/liaison/NEWBIE/advancement.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627552   Available: 13574906
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h"


inherit PATH + "inside";

object sign;

void setup() {
  set_zone( "Newbie" );
  set_short("Advancement Room" );
  set_light( 75 );
  add_property("no teleport", 1);

  set_long( "This is a rather cosy room designed to encourage visitors to "
            "linger a while and read a few of the notices pinned to the "
            "walls.  The air is thick and overly warm, and there is a "
            "pervasive odour of stale tea, mothballs, and elderly ladies who "
            "collect rather more cats and string than they can properly "
            "handle.  "
            "Several overstuffed sofas have been grouped in the centre "
            "of the room along with wobbly occasional tables.  There is "
            "a small cage holding an odd-looking creature in one corner, "
            "and an immense ball of yarn in the other.  A door to the south "
            "leads back to the foyer.\n");

  add_item(({ "floor", "ground" }), "The floor is scuffed, dusty wood.  It "
           "was probably nice at some point.");
  add_item( "wall", "The walls (what can be seen of them under the notices) "
            "have been covered with a gaudy floral paper.");
  add_item(({ "paper", "wallpaper", "floral", "flower" }), "The wallpaper has "
            "a dark, muddy background covered with enormous fantasy flowers "
            "in red, blue, and yellow.");
  add_item( "door", "The plain wooden door has been propped open in an effort "
            "to let some of the stale air out.");
  add_item( "cage", "The cage is a small, rickety bamboo affair with a tiny "
            "door tied closed with a strand of wire.  It contains a strange "
            "creature.");
  add_item( "creature", "The creature is a pale, translucent colour.  It has "
            "long, spindly legs, big teeth, and eyes that glow like lamps "
            "when it is awake.  Even though it is small, you sense it would "
            "not be wise to disturb it.  It is holding a small card.");
  add_item( "wire", "The wire holding the cage door shut is a hopelessly "
            "twisted mass of spun octiron, the magical metal of Discworld.");
  add_item( "card", "The card is stamped 'Demon Local 45, Holywood' in "
            "fading ink.");
  add_item(({"ball", "yarn"}), "A large ball of string.");
  add_item("notice",
           ({ "long", "There are many of these pinned to the walls of the "
                "room.  Several catch your eye including ones marked "
                "'statistics', 'guildpoints', 'hitpoints', "
                "'skills' and 'advancement'.\n",
                "read", "There are many of these pinned to the walls of the "
                "room.  Several catch your eye including ones marked "
                "'statistics', 'guildpoints', 'hitpoints', "
                "'skills' and 'advancement'.\n"}));
  add_item("sofa", ({"long", "Several well-stuffed and well-worn sofas with "
                       "rather dirty, brown upholstery.",
                       "position", "a sofa",
                       "position multiple", 1 }));
  add_item("table", "A number of wobbly occasional tables made from "
           "some indeterminable kind of wood have been placed near the "
           "sofas.");
  sign=add_sign("A handwritten notice marked 'Statistics and Rearrange'.\n",
                "On Discworld your skill bonus typically determines your "
                "ability to perform a task.  Skill bonus is calculated "
                "from your skill level and your statistics.  Different "
                "stats affect different skills.\n"
                "Once you enter Discworld, you may rearrange your stats.  "
                "This should be done to improve your combination of "
                "constitution, dexterity, intelligence, strength and wisdom "
                "(your stats), but you are advised to wait until you have "
                "chosen a guild and have asked other guild members for "
                "advice.  Use the command 'rearrange' to do this, but "
                "consider it well, as you can only rearrange your stats "
                "once.\n", 0, "statistics", "general" );
  sign->add_property("determinate","the ");
  sign->set_short("sign marked 'statistics and rearrange'");

  sign=add_sign("A handwritten notice marked 'Guildpoints'.\n",
           "Guildpoints are a measure of your capability to perform guild "
           "commands such as stealing, fighting, casting spells or rituals, "
           "etc.  When you have used all your guild points, you will have to "
           "rest to allow them to regenerate.  For more information, type "
           "in 'help guildpoints'.\n", 0, "guildpoints", "general");
  
  sign->add_property("determinate","the ");
  sign->set_short("sign marked 'guild points'");
  sign=add_sign("A handwritten notice marked 'Experience'.\n",
           "In addition to the direct skill advances provided by the "
           "taskmaster, quest completion, using your guild commands "
           "and by doing certain tasks, you are rewarded with "
           "experience points or XP.  These may be spent in advancing skills "
                "from your guild or by learning from other players.\n", 0,
                "experience", "general");
  sign->add_property("determinate","the ");
  sign->set_short("sign marked 'experience'");

  sign=add_sign("A handwritten notice marked 'Hitpoints'.\n",
           "Hitpoints, or HP determine how much damage you can take in "
           "combat before you die.  The number of hit points you have is "
           "dependent upon your stats (mostly Con) and on your levels of "
           "other.health.  Hitpoints regenerate gradually over time.  "
           "There are also a variety of other ways to be healed.  You "
           "can use 'monitor' to keep track of your hitpoints.  See also "
           "'help wimpy'.\n", 0, "hitpoints", "general");
  sign->add_property("determinate","the ");
  sign->set_short("sign marked 'hitpoints'");

  sign=add_sign("A handwritten notice marked 'Skills'.\n",
           "To check your skill levels, use the command 'skills', and "
           "to see various statistics about yourself, use 'score'.  Your "
           "stats can also be reviewed using 'score stats'.  The command "
           "'help' will give you a variety of other topics with useful "
           "information.", 0, "skills", "general");
  sign->add_property("determinate","the ");
  sign->set_short("sign marked 'skills'");

  sign=add_sign("A handwritten notice marked 'advancement'.\n\n",
           "Skills can be advanced in a variety of ways on Discworld.  "
           "The guild you join will allow you to advance your skills "
           "for a certain number of experience points and a small fee.  "
           "When you reach the proper skill level your guild will "
           "teach you the commands that you will need to carry out "
           "your guild duties.\n"
           "You may also have another player teach you skills if they have "
           "a higher skill level than you, or you may teach yourself.  Both "
           "of these methods cost experience points, and it is generally more "
           "expensive to teach yourself.\n"
           "Finally, many of your skills can be advanced simply by performing "
           "tasks that make use of those skills.  For example, your fighting "
           "skills will get better as you participate in more fights.  For "
           "more information on this system, type " 
           "'help taskmaster'.\n",0, "advancement", "general");
  sign->add_property("determinate","the ");
  sign->set_short("sign marked 'advancement'");

  /* Make it so you cannot godmother out of here */
  add_property("no godmother", 1);

  add_exit( "foyer", PATH + "foyer", "door" );
  add_alias( "south", "foyer");
  /*
  room_chat(({10, 40, ({"A voice whispers something that you can't quite "
                         "make out."
                              })}));
  */
} /* setup() */
// --- END [/mnt/home2/grok/lib/d/liaison/NEWBIE/advancement.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/liaison/NEWBIE/combat.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/liaison/NEWBIE/combat.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627550   Available: 13574904
Inodes: Total: 5242880    Free: 4960133
3456 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/liaison/NEWBIE/combat.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627550   Available: 13574904
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*
 * $Id: combat.c,v 1.11 2003/02/19 06:54:24 ceres Exp $
 */

//swiped from the Thieves' Guild room with modifications - Rue
/*combat classroom*/

/*
 * This is the central combat room. Newbies enter here and are then escorted
 * to a training room to practise on the dummy.  Greg controls who gets
 * put in which room. To add more rooms, just create them and then add them to
 * gregs arrays of available rooms.
 */
#include "path.h"
#define MAX 100;

inherit PATH+"inside";

object instructor;
object sign;

void setup() {
  set_zone( "Newbie" );
  set_short("Combat Training Room");
  add_property("determinate", "");
  set_light( 75 );
  add_property("no teleport", 1);
  
  set_long("This is a small training room, designed to help the new "
           "adventurer get off to a good start on Discworld.  The air is "
           "stale with the combined stench of sweat, beer, and old "
           "warriors.  There is a small sign attached to the wall.\n");
  add_item( "floor", "The floor is made of flagstones, cemented together "
            "with centuries of accumulated muck.\n");
  add_item( "wall", "The walls are marked with mysterious stains that may or "
            "may not be blood.  But surely training dummies don't bleed.\n");
  add_item( "ceiling", "The ceiling appears to be dingy patches of plaster "
            "stuck between old oak rafters that have turned black with "
            "age.\n");

  /* Make it so you cannot godmother out of here */
  add_property("no godmother", 1);

  add_exit( "foyer", PATH + "foyer", "door" );
  add_alias( "southwest", "foyer");

  add_exit("one", PATH + "combat_room1", "door");
  add_exit("two", PATH+"combat_room2", "door");
  add_exit("three", PATH+"combat_room3", "door");

  modify_exit("one", ({"function", "check_room", "closed", 1,
                         "look", "It is the door to training room one.\n"}));
  modify_exit("two", ({"function", "check_room", "closed", 1,
                         "look", "It is the door to training room two.\n"}));
  modify_exit("three", ({"function", "check_room", "closed", 1,
                         "look", "It is the door to training room three.\n"}));
  
}

void reset() {
  if(!sign) {
    sign=add_sign("This is a sign stuck to the wall.  It contains "
                  "instructions on how to use this room.\n",
                  "Welcome to the newbie combat area!  If you would like "
                  "to practise your combat skills just ask Greg.  To do "
                  "this say \"can I practise please\".",
                  0, "sign", "general");
  }
}
void dest_me() {
  if(sign)
    sign->dest_me();
  
  if(instructor)
    instructor->dest_me();
  ::dest_me();
}

void init() {
  call_out("get_instructor", 0);
}

void get_instructor() {
  if(!instructor)
    instructor = load_object(PATH +"greg");
  
  if(instructor && environment(instructor) != this_object()) {
    instructor->move( this_object(), "$N marches in from another room.");
  }
}/*get_instructor*/

int check_room(string str, object ob, string special_mess) {
  int room;

  switch(str) {
  case "one":
    room = 0;
    break;
  case "two":
    room = 1;
    break;
  case "three":
    room = 2;
  }

  if(ob == instructor)
    return 1;
  
  if(!instructor || instructor->query_using(room) != ob) {
    tell_object(ob, "The door slams closed in your face.\n");
    modify_exit("one", ({ "closed", 1}));
    return notify_fail("");
  }

  return 1;
}
// --- END [/mnt/home2/grok/lib/d/liaison/NEWBIE/combat.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/liaison/NEWBIE/priests.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/liaison/NEWBIE/priests.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627549   Available: 13574903
Inodes: Total: 5242880    Free: 4960133
2985 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/liaison/NEWBIE/priests.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627549   Available: 13574903
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: priests.c,v 1.8 2003/02/19 06:54:24 ceres Exp $
 */

#include "path.h"

inherit PATH + "inside";

string list_deities();

void setup() {
  set_short( "Priests' Gazebo" );
  set_light( 75 );
  add_property("no teleport", 1);
  set_long( "As you enter this blessed and holy gazebo, a warm feeling of "
            "peace and calmness overwhelms you.  You get the feeling that "
            "this must be what it's like to be a priest.  Around the room "
            "you can see items of priesthood: jars of fluff, holy symbols "
            "and coloured rods.  A small sign with a green aura sits in the "
            "corner. If you 'read sign' you can get some information "
            "about the priests.\n"
            "A small notice, blessed into oblivion, states that this is not "
            "the place where you actually join the guild.\n" );

   set_zone( "Newbie" ); 

   add_item( ({ "jar", "jar of fluff", "jars of fluff", "fluff", 
             "holy symbol", "coloured rod", "relic", "symbol", "rod" }), 
             "There are many items around the room, but their function is "
             "beyond you for the most part." );
   add_item( "notice",
             "This blessed notice rests peacefully against a holy relic." );

   add_sign( "The sign is covered in a soothing green aura, and sits "
             "in the corner of the room.\n", 
             FOYER->format_sign("This holy guild, and its many "
             "gods, is based at the Temple of Small Gods in Ankh-Morpork.  "
             "You may learn how to heal and resurrect, shield with the " 
             "power of your faith, and many other holy powers.  Some gods "
             "shun healing almost completely, preferring to concentrate on "
             "causing strife and mayhem among the citizens of Discworld.  Ask"
             " some of the other priests in the city about finding a god "
             "that will suit your needs, and help back you up.\n"
             "The following gods are desirous of priests: " + list_deities() +
             ".  Many gods require particular alignments.  Use 'finger "
             "<deity>' to find out a particular deities alignment "
             "requirements and visit the alignment room to get yours "
             "adjusted if you wish.\n"), 0, 0, "general");


   /* Make it so you cannot godmother out of here */
   add_property("no godmother", 1);
   
   add_exit( "garden", PATH +"guilds_foyer", "gate" );
}

string list_deities() {
  string *deities;
  int i;
  
  deities = unguarded((: get_dir("/save/deities/") :));
  deities -= ({ ".", ".." });

  for(i=0; i<sizeof(deities); i++) {
    deities[i] = replace(deities[i], ".o", "");
    deities[i] = replace(deities[i], ".gz", "");
  }
  deities = map (filter(deities,
                   (: "/obj/handlers/deity_handler"->query_want_priests($1)
                    :)), (: capitalize ($1) :));
  
  return query_multiple_short(deities);
}
// --- END [/mnt/home2/grok/lib/d/liaison/NEWBIE/priests.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/liaison/NEWBIE/witches.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/liaison/NEWBIE/witches.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627548   Available: 13574902
Inodes: Total: 5242880    Free: 4960133
2799 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/liaison/NEWBIE/witches.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627548   Available: 13574902
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: witches.c,v 1.6 2003/02/19 06:54:24 ceres Exp $
 *
 */
#include "path.h"

inherit PATH + "inside";

void setup() {

   set_short( "Witches' Gazebo" );
   set_light( 75 );
   add_property("no teleport", 1);

   set_long( "As you wander in through the small gate to this little room, "
             "you are overwhelmed by an array of smells.  Of course, you "
             "can't identify any of these smells nor any of the items that "
             "are strewn about haphazardly.  The only thing you can identify "
             "is a nicely embroidered sign hanging on the wall.  Maybe if you "
             "'read sign' you'll learn a bit about the Witches' Guild.\n"
             "A small notice, which seems to have been used as a teabag, "
             "states that this is not actually the place where you join this "
             "guild.\n" );

   set_zone( "Newbie" );

   add_item( ({ "item" }), "There "
             "are several items of inexplicable function scattered around the "
             "room.  Some of these may be the source of the smells, but you "
             "wisely hesitate to test this possibility." );

   add_item( ({ "notice" }),
             "This small, tea stained notice is casually leaned against a "
             "strange item." );

   add_sign( "The sign is beautifully embroidered and somehow makes the "
             "room brighter and darker at the same time.\n", 
             FOYER->format_sign("This guild "
             "is very unusual in that it only accepts those of the "
             "*female* persuasion.  It is "
             "a magical guild, but not the magic of wizards and mages.  "
             "Witch magic is the magic of herbs, cursing, flying around, "
             "and most importantly, headology.\n\n"
             "The prominent witches of the Discworld will be "
             "able to tell you more about headology.  Granny Weatherwax, "
             "whom you must see to join the guild, will be particularly "
             "helpful.  So, if you think you have what it takes to learn "
             "how to know what is real, what is not, and how to tell the "
             "difference, then give the Witches' Guild a go!  Granny, "
             "Nanny Ogg, and Magrat Garlick will be there to greet you.  "
             "Oh, and if you need help getting there, just go see good old "
             "Gennie Applebottom in Ankh-Morpork.  She'll help you out, as "
             "will almost any witch!  "
             "And don't forget, Witches prefer to use the back door "
             "to enter a house.\n"), 0, 0, "general");

/* Make it so you cannot godmother out of here */
   add_property("no godmother", 1);

   add_exit( "garden", PATH +"guilds_foyer", "gate" );
} /* setup() */
// --- END [/mnt/home2/grok/lib/d/liaison/NEWBIE/witches.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/liaison/NEWBIE/communication.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/liaison/NEWBIE/communication.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627547   Available: 13574901
Inodes: Total: 5242880    Free: 4960133
5464 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/liaison/NEWBIE/communication.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627547   Available: 13574901
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: communication.c,v 1.8 2003/02/19 06:39:05 ceres Exp $
 *
*/
/* Added no teleport property- 26-06-98- Shalla */

#include "path.h"
inherit PATH + "inside";

object sign;

void setup() {
  set_zone( "Newbie" );
  set_short( "Communication room" );
  set_light( 75 );
  add_property("no teleport", 1);

  set_long("This small room seems to be filled with frogs which are bouncing "
           "around, wombling on and chattering away like crazy.  Around the "
           "walls are a number of posters that describe various aspects of "
           "communication on Discworld.  There are posters on 'general', "
           "'speaking', 'expression', 'emote', 'newbie' and "
           "'mail'.\n");
  
  add_item("frog", "There are small green frogs everywhere.  They seem very "
           "excited and are moshing, sniggering, hugging,... you name it, "
           "they are doing it.");
  add_item("poster", "There are several of these around the room.  To look "
           "at a particular poster type 'look' and the name of the "
           "poster.");
  add_item("wall", "It is hard to make out much of the walls behind the "
           "posters, but what you can see is painted a subtle sunflower "
           "yellow.");
  add_item("floor", "The floor is composed of stone slabs and covered "
           "with frogs.");

  sign=add_sign("A poster entitled 'What Do You Mean?'\n",
           "If you are new to online communication you may be surprised how "
           "easy it is to misunderstand and to be misunderstood when you "
           "only have typed words to go on.  So please take care in how you "
           "word things and also be prepared to seek clarification before "
           "getting upset with someone, they may not have meant it how you "
           "read it!", 0, "general", "general");
  sign->set_short("sign marked 'general'");
  sign->add_property("determinate","the ");
  
  sign=add_sign("A poster entitled 'It's Good To Talk'\n",
           "There are a number of ways to communicate verbally.\n"
           "To speak to everyone in the same room as yourself use the "
           "command 'say', 'lsay' (loud say).  To speak to an individual "
           "you may use 'whisper' if they are in the same room, or "
           "'tell' if they are elsewhere on the disc.  You may also "
           "'shout' which will be heard by everyone who is nearby, however "
           "shouting uses up social points which will regenerate slowly.\n",
           0, "speaking", "general");
  sign->set_short("sign marked 'speaking'");
  sign->add_property("determinate","the ");

  sign=add_sign("A poster entitled 'Womble On'\n",
           "Discworld also has a soul which allows you some emotional "
           "expression, thus you can 'laugh' or 'cry'.  There are "
           "approximately 550 soul commands so they are not listed here.  "
           "Use 'help soul' and 'look soul' to find out more about "
           "them.\n", 0, "expression", "general");
  sign->set_short("sign marked 'expression'");
  sign->add_property("determinate","the ");

  sign=add_sign("A poster entitled 'Laugh In An Old Fashioned Way'\n",
           "Emote allows free expression.  If Jim used 'emote jumps around "
           "in a slightly artistic manner' everyone in the room would see "
           "him do just that.  Initially you will not be able to emote, you "
           "must learn that skill.", 0, "emote", "general");
  sign->set_short("sign marked 'emote'");
  sign->add_property("determinate","the ");

  sign=add_sign("A poster entitled 'What Do You Mean?'\n",
           "For the first day of your time on Discworld you will have access "
           "to the newbie chat channel which is listened to by most creators "
           "and many of the players.  You may use this channel to ask for "
           "help and advice.  To use the channel type 'newbie <message>'"
           ", and to see the last few messages type 'hnewbie'.\n",
           0, "newbie", "general");
  sign->set_short("sign marked 'newbie'");
  sign->add_property("determinate","the ");

  sign=add_sign("A poster entitled 'But You're Not There'\n",
           "Discworld provides a mail system which allows you to send "
           "messages to players who are not currently logged in.  You must "
           "go to the post office to read or send mail.\n"
           "There are also a number of bulletin boards around the place on "
           "which people can place public messages.  The frog board is in "
           "the Mended Drum and the newspaper board is in the offices of "
           "the Ankh-Morpork Daily Times.  Your guild will also have a "
           "board located somewhere in the guildhouse.\n", 0, "mail", "general");
  sign->set_short("sign marked 'mail'");
  sign->add_property("determinate","the ");

  
  /* Make it so you cannot godmother out of here */
  add_property("no godmother", 1);

  room_chat(({120, 240, ({"A small frog bumps into you, apologises "
                            "profusely, and hops off.",
                            "A frog leaps up and down excitedly.",
                            "A frog wombles around you happily.",
                            "A frog bingles happily.",
                            "A frog parps wryly at you."})}));
                        
  add_exit( "foyer", PATH + "foyer", "door" );
  add_alias( "west", "foyer" );
} /* setup() */

// --- END [/mnt/home2/grok/lib/d/liaison/NEWBIE/communication.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/liaison/NEWBIE/shop.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/liaison/NEWBIE/shop.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627545   Available: 13574899
Inodes: Total: 5242880    Free: 4960133
2413 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/liaison/NEWBIE/shop.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627545   Available: 13574899
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h"

inherit "/std/shops/general_shop";
inherit PATH+"common";

void setup() {
  
  set_zone("Newbie");
  set_light( 75 );
  add_property("no teleport", 1);
  add_property("place", "Newbie Area");
  
  set_short("Commerce room");
  set_room_size( 5 );
  set_long( "This room is dedicated to trade and commerce.  There is a "
            "shiny counter, behind which is a shopkeeper.\n"
            "Type 'list' to get a list of the "
            "items, 'browse' to examine an item before buying it, "
            "'value' to value your items before you 'sell' them and, "
            "of course, 'buy' to buy an object from the shop.\n"
            "There is a brightly coloured sign here marked 'commerce'.\n");
  
  add_item( "shiny counter", "That's a display counter for the wares of the "+
            "shop.  Use the command 'list' to get a list of them." );
  add_item( ({ "object", "item", "ware" }), "Use 'list' to get a list of the "+
  "items for sale here." );
  add_item("shopkeeper", "The shopkeeper is a small man apparently in his "
           "mid-thirties.  He seems to be ready to serve you.");
  
  add_sign("a brightly coloured sign marked 'commerce'.\n",
           "/d/liaison/NEWBIE/foyer"->format_sign(
           "On Discworld different regions use different types of money.  "
           "Type 'help currency' for a list of conversion rates.  Money is "
           "needed to buy equipment, to learn at your guild and for a "
           "variety of other purposes.\n\n"
           "Making money can be difficult.  You can loot the corpses of "
           "your victims of course, but you can also scavenge money using "
           "the 'search' command and make money performing services for your "
           "fellow players.\n\n"
           "Spending money is the fun part.  This shop has instructions "
           "on how to use it.  Take a few minutes to buy yourself some "
           "equipment with the money you were given on login.\n"), 0,
           ({"commerce", "sign"}), "general" )->add_property("determinate","the ");
  add_exit( "foyer", PATH +"foyer", "door" );
  set_store_room( PATH +"store" );
  set_min_amount(1);
  set_max_inventory(200);
} /* setup() */

void init() {
  ::init();
  this_player()->add_command("speak", this_object(), "<string'language'>" );
}

int do_speak(string str) {
  write("Sorry, you cannot do that here.\n");
  return 1;
}
// --- END [/mnt/home2/grok/lib/d/liaison/NEWBIE/shop.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/liaison/NEWBIE/store.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/liaison/NEWBIE/store.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627544   Available: 13574898
Inodes: Total: 5242880    Free: 4960133
3131 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/liaison/NEWBIE/store.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627544   Available: 13574898
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "path.h"
#include <armoury.h>

inherit "/std/shops/storeroom";

nosave string *weapons = ({"dagger", "knife", "small knife", "short sword",
   "foil", "rapier", "cudgel", "crowbar", "knobbly mace","long sword",
   "chain", "morning star", "axe", "two-handed axe"});

nosave string *armours = ({"hard leather cap", "heavy cotton breeches",
   "ringmail", "leather breeches", "bone helm", 
   "brass breastplate", "leather breastplate", "bone mail",
   "bone shield", "medium wooden shield", "small metal shield",
   "hard leather boots", "metal clad boots", "leather gloves",
   "metal gauntlets", "metal helm", "iron breastplate"});

nosave string *clothes = ({"brown linen shirt", "white linen skirt",
   "white linen tunic", "black cotton dress", "white cotton robe",
   "black leather shoes", "soft leather shoes", "grey worsted trousers",
   "fawn cotton trousers", "discreet black trousers", "black wool socks",
   "socks", "black leather shoes", "soft leather shoes", "green cloak",
   "red-brown tunic", "nightshirt", "thermal underwear", "lacy underwear",
   "jester costume", "wide brimmed hat", "soft leather gloves"});

void setup() {
  set_short( "storeroom" );
  add_property( "determinate", "the " );
  set_long( "This is a storeroom.\n" );
  set_light( 100 );
} /* setup() */

void reset() { call_out( "restock", 0 ); }

void restock() {
  int i, size;
  object thing;
  object new_item;

  i = sizeof( match_objects_for_existence( "buckets", this_object() ) );
  for ( ; i < 3; i ++ ) {
    thing = clone_object( "/obj/vessel" );
    if (thing) {
      size = random( 3 );
      thing->set_leak_rate( 0 );
      thing->set_max_volume( 1000 + size * 2000 );
      thing->set_max_weight( 20 + size * 40 );
      thing->set_full_weight( 20 + size * 40 );
      thing->set_stuck( 1 );
      thing->set_name( "bucket" );
      thing->set_short( ({ "small", "medium", "large" })[ size ]
                        +" bucket" );
      thing->set_main_plural( ({ "small", "medium", "large" })[ size ]
                              +" buckets" );
      thing->add_adjective( ({ "small", "medium", "large" })[ size ] );
      thing->set_value( 60 + size * 25 );
      thing->set_long( "This is a metal thing.  It is not very shiny.\n" );
      thing->set_weight( 10 + size * 10 );
      thing->move( this_object() );
    }
  }

  i = sizeof( match_objects_for_existence( "torches", this_object() ) );
  for ( ; i < 6; i++ ) {
    new_item = ( ARMOURY->request_item("torch", 100) );
    if (new_item) new_item->move( this_object() );
  }
  
  
  for(i=0; i<30; i++) {
    new_item = ( ARMOURY->request_weapon( weapons[random(sizeof(weapons))],
                   95 ) );
    if (new_item) new_item->move( this_object() );
  }

  for(i=0; i<25; i++) {
    new_item = ( ARMOURY->request_armour( armours[random(sizeof(armours))],
                   95 ) );
    if (new_item) new_item->move( this_object() );
  }
  
  for(i=0; i<30; i++) {
    new_item = ( ARMOURY->request_clothing( clothes[random(sizeof(clothes))],
                   95 ) );
    if (new_item) new_item->move( this_object() );
  }     
} /* restock() */

// --- END [/mnt/home2/grok/lib/d/liaison/NEWBIE/store.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/liaison/NEWBIE/wizards.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/liaison/NEWBIE/wizards.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627544   Available: 13574898
Inodes: Total: 5242880    Free: 4960133
2085 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/liaison/NEWBIE/wizards.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627544   Available: 13574898
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: wizards.c,v 1.4 2003/02/19 06:54:24 ceres Exp $
 */
/* Added no teleport property- 26-06-98- Shalla */

#include "path.h"

inherit PATH + "inside";

void setup() {

   set_short( "Wizards' Gazebo" );
   set_light( 75 );
   add_property("no teleport", 1);

   set_long( "As you enter this gazebo, it is obvious that it is the room "
             "of a mage.  Strewn around are pointy hats, wands and other "
             "items of wizardly paraphernalia.  A small sign catches your "
             "eye.  Maybe if you 'read sign' you'll find something out "
             "about this magical guild.\n"
             "A small notice that, for some reason, is extremely fat, wearing "
             "a pointy hat and winking at you, states that this is not the "
             "place where you actually join the guild.\n" );

   set_zone( "Newbies" );

   add_item( ({ "pointy hat", "wand", "item", "paraphernalia" }), 
             "There are many items around the room, but their function is "
             "beyond you for the most part." );
   add_item( "notice",
             "This notice is extremely fat, wears a pointy hat and winks at "
             "you -- that's magic for you." );
 
   add_sign( "The sign is floating, apparently unsupported, in the "
         "centre of the room.\n", "In this magical guild, based at "
         "Unseen University in Ankh-Morpork, you can learn many "
         "wonderful and exciting spells.  Learn how to tickle an "
         "enemy with a feather, create cabbage pets for your friends "
         "and hold your own against muggers using a carrot "
         "and a torch, or even a human eye!  The Library at the Unseen "
         "University (U.U.) is extensive, with many books in which to "
         "search for that special spell.  You'll learn all this and more "
         "if you decide to follow the Higher Art.", 0, 0, "general" );

/* Make it so you cannot godmother out of here */
   add_property("no godmother", 1);

   add_exit( "garden", PATH +"guilds_foyer", "gate" );
} /* setup() */
// --- END [/mnt/home2/grok/lib/d/liaison/NEWBIE/wizards.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/liaison/NEWBIE/thieves.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/liaison/NEWBIE/thieves.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627543   Available: 13574897
Inodes: Total: 5242880    Free: 4960133
2089 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/liaison/NEWBIE/thieves.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627543   Available: 13574897
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: thieves.c,v 1.6 2003/02/19 06:54:24 ceres Exp $
 *
 *
*/
/* Added no teleport property- 26-06-98- Shalla */

#include "path.h"

inherit PATH + "inside";

void setup() {
  set_short( "Thieves' Gazebo" );
  set_light( 75 );
  add_property("no teleport", 1);
  
  set_long( "You carefully sneak into this small gazebo.  You're not "
            "really sure why, but you don't feel comfortable in here.  You "
            "hope to make it out, without anyone noticing you.  Sneaking a "
            "quick glance around here you see piles of stolen items from the "
            "citizens of Ankh-Morpork.  There is a small sign cowering in "
            "a corner.  If you 'read sign' maybe you'll be able to find "
            "out a bit more about this dangerous profession.\n"
            "A small notice resembling the backside of a receipt states that "
            "this is not actually the place where you join the guild.\n" );

  set_zone( "Newbie" );
  
  add_item( ({ "item" }), "There "
            "are many items around the room, but their function is beyond "
            "you for the most part." );
  add_item( ({ "notice" }),
            "This small notice looks like the backside of a receipt of some "
            "kind.\n" );
  
  add_sign( "This poor sign sits huddled in a dark corner of this "
            "foreboding room.\n", "This guild specializes in stealing all "
            "they can from the citizens and player killers of Ankh-Morpork.  They "
            "will teach you the fine art of thieving - how to steal from your "
            "friends and enemies.  Not only is this a dangerous profession, "
            "but it is also a great way to get some pocket change.  Picking "
            "pockets is just one of the things you will get to learn from "
            "this bunch of Authorized Income Redistributors.",
            0, 0, "general"); 

/* Make it so you cannot godmother out of here */
  add_property("no godmother", 1);

  add_exit( "garden", PATH +"guilds_foyer", "gate" );

} /* setup() */
     
// --- END [/mnt/home2/grok/lib/d/liaison/NEWBIE/thieves.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/liaison/NEWBIE/dummy.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/liaison/NEWBIE/dummy.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627542   Available: 13574896
Inodes: Total: 5242880    Free: 4960133
13883 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/liaison/NEWBIE/dummy.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627542   Available: 13574896
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/obj/monster";

#include <armoury.h>
#include <weapon.h>
#include <tasks.h>
#include <combat.h>

int told_attack, told_parry, ability;
string *misc;
object trainer, trainee;

#define DODGE "fighting.combat.dodging.melee"
#define PARRY "fighting.combat.parry.melee"

#define PERSON_DODGE_FAILURE "As the dummy spins around, an arm swings towards you and hits you before you can dodge out of the way!\n"
#define ROOM_DODGE_FAILURE " isn't fast enough to dodge a spinning arm!  Ouch!\n"
#define PERSON_DODGE_SUCESS "As the dummy spins around, an arm swings towards you but you see it in time and dodge it.\n"
#define ROOM_DODGE_SUCESS " dodges the arm of the wooden training dummy.\n"
#define PERSON_PARRY_FAILURE "As the dummy spins around, an arm swings towards you but you are unable to block it!\n"
#define ROOM_PARRY_FAILURE " isn't fast enough to avoid the training dummy! Ouch!\n"
#define PERSON_PARRY_SUCCESS "As the dummy spins around, an arm swings towards you but you see it in time and block it.\n"
#define ROOM_PARRY_SUCCESS " parries the training dummy.\n"

#define MISC_MESSAGES ({ "Generally, heavier weapons are harder to attack and "\
  "parry with but their attacks are harder to parry.", \
  "Being burdened in combat, by carrying lots of things or wearing lots of " \
  "armour, reduces your effectiveness.  This is especially true for dodging.", \
  "When injured it is harder to fight, so watch your health closely.", \
  "Holding a two-handed weapon in one hand can be useful when using a shield "\
  "but is hard to do unless you have high strength.", \
  "You can focus on specific parts of your opponents body to take advantage " \
  "of weaknesses in their armour but this is harder to do than attacking " \
  "normally."})
#define DIFF 15
#define MOD 10

int assault_dummy();
mixed *callback(int stage, class attack att, mixed data);
void failed_defense( object );
void failed_attack( object );
void tell_misc( object );
void spin_arm( object, object );

object query_trainer() {
  return trainer;
}

object reset_trainer() {
  trainer = 0;
}

object set_trainer( object thing ) {
  return trainer = thing;
}

object query_trainee() {
  return trainee;
}

object reset_trainee() {
  trainee = 0;
}

object set_trainee( object thing ) {
  return trainee = thing;
}

int query_skill_bonus( string words ) {
  return 10;
}

void setup() {
  set_name( "dummy" );
  add_adjective( ({ "wood", "wooden", "training" }) );
  //  add_property( "determinate", "A" );
  set_short( "training dummy" );
  set_long( "A fighters dummy.  It is looking pretty worn from having "+
    "all the stuffing knocked out of it all day.\n");
  basic_setup( "human", "warrior", 10 );
  set_gender( 0 );
  add_property( "run away", -1 );
  set_dex(6);
  set_str(6);
  set_con(18);
  set_int(6);
  set_wis(6);
  remove_ac( "sharp" );
  remove_ac( "pierce" );
  remove_ac( "blunt" );
  remove_ac( "unarmed" );
  add_skill_level( "other.health", 1000 );
  add_combat_action( 100, "spin_arm", (: spin_arm :) );

  ARMOURY->request_item( "dirty rags", 30 )->move( this_object() );

} /* setup() */

// Don't let the dummy attack;
int attack_this_time() {
  return 0;
}

void init() {
  if( this_player() ) {
    this_player()->add_command( "kill", this_object(), "{dummy}",
      (: assault_dummy() :) );
    this_player()->add_command( "attack", this_object(), "{dummy}",
      (: assault_dummy() :) );
  }
}/*init*/

int assault_dummy() {
  object *weapons, weapon;
  int i;

  if( trainer->query_fighting() ) {
    write( "You beat at and tear up " + this_object()->the_short() +
      " for a while until you get bored.\n" );
    say( this_player()->query_short() + " hacks at " +
      this_object()->the_short() + " for a while.\n", this_player() );
  }

  if( trainee && !interactive( trainee ) )
    reset_trainee();

  if( trainee ) {
    if( trainee->query_fighting() ) {
      if( trainee == this_player() ) {
        tell_object( this_player(), "You are already using " +
          this_object()->the_short() + ".\n" );
        return notify_fail( "" );
      }
      tell_object( this_player(), trainee->one_short() + " is currently "
        "using " + this_object()->the_short() + ".\n" );
      return notify_fail( "" );
    }
  }

  weapon = 0;
  ability = 0;
  told_attack = 0;
  told_parry = 0;
  misc = copy(MISC_MESSAGES);
  weapons = (object *)this_player()->query_weapons();

  if( sizeof( weapons ) > 1 ) {
    trainer->stop_them( previous_object(), this_object() );
    trainer->do_command( "say Just use one weapon, I get confused if you use "
      "more than one!" );
    return 1;
  }

  if( sizeof( weapons ) && !weapon )
    weapon = weapons[ 0 ];

  this_player()->attack_ob( this_object() );
  write( "You attack " + this_object()->the_short() + ".\n" );
  say( this_player()->the_short() + " attacks " + this_object()->a_short() +
    ".\n", this_player() );
  trainee = this_player();

  for( i = 0; i < sizeof( ( class combat_special )this_object()->
    query_specials() ); i++ ) {
      this_object()->remove_special( ( class combat_special )this_object()->
        query_specials()[i]->id );
  }

  this_object()->register_special( T_DEFENSIVE,
                                   E_AFTER_ATTACK,
                                   ({ this_object(), "callback" }),
                                   ({ 0, 0, weapon }) );
  return 1;
}/*attack_dummy*/

int attack_by(object ob) {
  if(!sizeof(query_specials()))
    call_out("attack_dummy", 0);
  return ::attack_by(ob);
}

mixed *callback( int stage, class attack att, mixed data ) {
  int *rating, number, damage, last_damage;
  object dumdum, newbie, *weapons, weapon;
  string what, skill;
  mixed *attacks;
  
  newbie = att->attacker;
  dumdum = att->opponent;

  /*
   * The data array is the list of information specific to a particular
   * special for a particular player.
   *
   * data[0] == Times tried
   * data[1] == Damage
   * data[2] == Weapon
   */

  weapons = (object *)this_player()->query_weapons();

  if( sizeof( weapons ) > 1 ) {
    trainer->stop_them( newbie, dumdum );
    trainer->do_command( "say Just use one weapon, I get confused if you use "
      "more than one!" );
    debug_printf( "More than one weapon, removing special.\n" );
    return({ R_CONTINUE | R_REMOVE_ME, att, data });
  }

  if( sizeof( weapons ) && !weapon )
    weapon = weapons[ 0 ];

  if( weapon != data[2] ) {
    trainer->stop_them( newbie, dumdum );
    trainer->do_command( "say You've changed weapons!" );
    debug_printf( "Changed weapons, removing special.\n" );
    return({ R_CONTINUE | R_REMOVE_ME, att, data });
  }

  last_damage = data[1];
  damage = att->damage;
  data[1] = damage;

  if( !last_damage) {
    failed_attack(newbie);
  }
  if(last_damage || !random(4)) {
    // This hands out skill advances very generously up to lvl 5 then it
    // stops.
    if( weapon ) {
      attacks = weapon->query_attack_data();
      skill = attacks[random( sizeof( attacks ) / W_ARRAY_SIZE ) *
        W_ARRAY_SIZE + W_SKILL];
    } else {
      skill = "unarmed";
    }
    if( newbie->query_skill( "fighting.combat.melee." + skill ) < 5 &&
       !random( 4 * ( newbie->query_skill( "fighting.combat.melee." +
       skill ) ) ) &&
       newbie->add_skill_level( "fighting.combat.melee." + skill, 1, 1 ) ) {
      if( skill == "unarmed" )
         tell_object( newbie, "%^YELLOW%^You feel you've learned something "
          "about unarmed combat.%^RESET%^\n" );
       tell_object( newbie, "%^YELLOW%^You feel you've learned something about "
         "using " + weapon->a_short() + ".%^RESET%^\n" );
    }
  }

  // Check if we have used up all our chances.
  if( data[0]++ > 15 ) {
    number = ( 2 * (ability + data[0]) ) / ( 2 * data[0] );
    if( weapon )
      what = convert_message( ( string )weapon->the_short() );
    else
      what = "whatever it was you were using";
    trainer->stop_them( newbie, dumdum );
    
    trainer->do_command( "think" );
    switch ( number ) {
    case 0..1 :
      if( skill == "unarmed" )
        trainer->do_command( "say Well, you're rather hopeless." );
      else {
        if( strsrch( what, "knife" ) == -1 && strsrch( what, "dagger" ) == -1)
          trainer->do_command( "say Well, you're rather hopeless with " + what +
            ", really.  A lighter, simpler weapon may help." );
        else
          trainer->do_command( "say Well, you're rather hopeless with " + what +
            ", really, but with practice you'll get better.");
      }  
      break;
    case 2 .. 3 :
      if( skill == "unarmed" )
        trainer->do_command( "say Hmmm... You have some skill." );
      trainer->do_command( "say Hmmm... You have some skill with " + what +
        ", at any rate, as you practice you'll get better." );
      break;
    case 4 .. 5 :
      if( skill == "unarmed" )
        trainer->do_command( "say You're getting there.  Keep training and "
          "you'll be pretty good soon." );
      trainer->do_command( "say You're getting there.  Keep training with " +
        what + " and you'll be pretty good with it soon." );
      break;
    default :
      if( skill == "unarmed" )
        trainer->do_command( "say I'd say you've more or less mastered unarmed "
          "combat.  Well done!" );
      trainer->do_command( "say I'd say you've more or less mastered " + what +
        ".  Well done!" );
    }
    trainee = 0;
    return({ R_CONTINUE | R_REMOVE_ME, att, data });
  }

  tell_misc(newbie);
  if( !damage) {
    return ({ R_CONTINUE, att, data });
  }
  

  if( skill == "unarmed" ) {
    rating = (int *)"/cmds/guild-race/other/judge"->calc_rating( newbie );
  } else {
    rating = (int *)"/cmds/guild-race/other/judge"->calc_rating( weapon );
  }
  // Ratings for unarmed.  I'm making them up!
  if( !rating[0] )
    rating [0] = random( 10 ) + 30;
  if( !rating[1] )
    rating [1] = random( 80 ) + 60;

  number = ( ( 40 * damage ) / rating[ 0 ] +
             ( 20 * damage ) / rating[ 1 ] ) / 5;
  debug_printf("%d", number);
  ability += number;
  if (number > 14)
    number = 14;
    
  trainer->do_command( "say That's " + ({ "an atrocious", "an extremely poor",
    "a very poor", "a rather poor", "a poor", "a pretty poor", "quite a poor",
    "a reasonable", "quite a good", "a pretty good", "a good", "a rather "
    "good", "a very good", "an extremely good", "an excellent" })
    [ number ] + " attack." );

  return ({ R_CONTINUE, att, data });
}

void spin_arm( object newbie, object dumdum ) {
  int diff, which, failed;

  //debug_printf( "specials %O\n", this_player()->query_specials() );

  if( environment( newbie ) != environment( this_object() ) )
     return;

  switch( ( ( class tactics )newbie->query_tactics() )->attitude ) {
  case "offensive":
    diff = DIFF + MOD;
    break;
  case "defensive":
    diff = DIFF - MOD;
    break;
  default:
    diff = DIFF;
  }

  switch( newbie->query_combat_response() ) {
  case "dodge" :
    which = 1;
    break;
  case "parry":
    which = 0;
    break;
  default:
    which = random( 2 );
  }

  // Dodge
  if( which ) {
    switch( TASKER->perform_task( newbie, DODGE, diff, TM_FIXED ) ) {
      case FAIL :
        if( newbie->query_skill( DODGE ) >= 5 ||
           random( 3 * ( newbie->query_skill( DODGE ) ) ) ||
           !newbie->add_skill_level( DODGE, 1, 1 ) ) {
          tell_object( newbie, PERSON_DODGE_FAILURE );
          tell_room( environment( newbie ),newbie->one_short() +
            ROOM_DODGE_FAILURE, ({ newbie }) );
          failed = 1;
          break;
        }
      case AWARD :
        tell_object( newbie, "%^YELLOW%^You feel better at dodging "
          "things.%^RESET%^\n" );
      case SUCCEED :
        tell_object( newbie,PERSON_DODGE_SUCESS );
        tell_room( environment( newbie ), newbie->one_short() +
          ROOM_DODGE_SUCESS, ({ newbie }) );
        break;
    }
  } else {
    // Parry
    switch( TASKER->perform_task( newbie, PARRY, diff, TM_FIXED ) ) {
      case FAIL :
        if( newbie->query_skill( PARRY ) >= 5 ||
           random( 3 * ( newbie->query_skill( PARRY ) ) ) ||
           !newbie->add_skill_level( PARRY, 1, 1 ) ) {
          tell_object( newbie, PERSON_PARRY_FAILURE );
          tell_room( environment( newbie ), newbie->one_short() +
            ROOM_PARRY_FAILURE, ({ newbie }) );
          failed = 1;
          break;
        }
      case AWARD :
        tell_object( newbie, "%^YELLOW%^You feel better at parrying things."
          "%^RESET%^\n" );
      case SUCCEED :
        tell_object( newbie, PERSON_PARRY_SUCCESS );
        tell_room( environment( newbie ), newbie->one_short() +
          ROOM_PARRY_SUCCESS, ({ newbie }) );
        break;
    }
  }

  if( trainer && failed )
    failed_defense(newbie);
  return;
}

void tell_misc(object newbie) {
  int which;

  if(!sizeof(misc) || random(5))
    return;
  
  which = random(sizeof(misc));
  trainer->do_command("say " + misc[which]);
  misc -= ({ misc[which] });
}

void failed_attack( object newbie ) {
  string attitude;

  if(told_attack)
    return;
  
  attitude = (newbie->query_tactics())->attitude;
  if(attitude != "offensive" && attitude != "insane") {
    told_attack = 1;
    trainer->do_command( "say You can improve your chances of hitting your "
                         "opponent by setting your tactics to a more "
                         "offensive attitude.");
  }
}

void failed_defense( object newbie ) {
  string attitude;
  
  if(told_parry)
    return;

  attitude = (newbie->query_tactics())->attitude;

  if(attitude != "defensive" && attitude != "wimp") {
    told_parry = 1;
    trainer->do_command( "say You can improve your chances of defending by "
                         "setting your tactics to a more defensive "
                         "attitude." );
  }
}

void adjust_hp() {
  return this_object()->query_max_hp();
}
// --- END [/mnt/home2/grok/lib/d/liaison/NEWBIE/dummy.c] ---
// --- BEGIN [/mnt/home2/grok/lib/d/liaison/common.c] ---
// Size:   File: "/mnt/home2/grok/lib/d/liaison/common.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627539   Available: 13574893
Inodes: Total: 5242880    Free: 4960133
12285 bytes, Last Modified:   File: "/mnt/home2/grok/lib/d/liaison/common.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627539   Available: 13574893
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:46.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <config.h>

#define DOM_TITLE "Liaison Domain"
#define LORD "wyvyrn"
#define DOMAIN "liaison"
#define BOSS_ROOM "/w/wyvyrn/rooms/office"
inherit "/std/dom/cmn_mas";
object board;

void setup() {
   set_dom( DOMAIN );
   set_light( 100 );
   set_short( "Liaison Domain Common room" );
   add_property( "determinate", "the " );
   set_long("The Liaison common room looks like a comfortable place to "
            "come to after a hard day's liaising.  The large pile of stress "
            "balls sat in one corner and the drinks cabinet against a wall "
            "highlight this.  The various evil-looking devices scattered "
            "around the room seem to add character and even a slightly "
            "malicious overtone to the entire place.  There are also a "
            "few chairs scattered around the place providing welcome bum "
            "relief.  One even looks to be occupied.\n"
            "A sign is hanging on the wall.\n");
   add_alias("balls", "ball");
   add_alias("devices", "device");
   add_alias("bottles", "bottle");
   add_alias("chairs", "chair");
   add_alias("whips", "whip");
   add_alias("chains", "chain");
   add_alias("easy chair", "chair");
   add_alias("dolls", "doll");
   add_alias("armrests", "armrest");
   add_alias("cushions", "cushion");
   add_alias("strings", "string");
   add_alias("needles", "needle");
   add_item( ({"ball", "stress ball"}), "The pile of stress balls seems very "
            "inviting, albeit until you get up close and see that they are "
            "actually coated in tough plastic and tied to a pole with string - "
            "effectively ending their usefulness.  They look nice though.");
   add_item("string", "Each piece of string connects a ball to the pole, "
            "stopping the ball moving very far.  Cruel.");
   add_item("pile", "The pile of stress balls seems very inviting, albeit "
            "until you get up close and see that they are actually coated in "
            "tough plastic and tied to a pole with string - effectively "
            "ending their usefulness. They look nice though.");
   add_item("lock", "A big lock that looks completely unpickable, mainly due "
            "to it having no keyhole.  Nothing will unlock it, so you heavy "
            "drinkers are just out of luck.");
   add_item("corner", "A corner of the room. Where two walls, the ceiling "
            "and the floor meet.");
   add_item("pole", "There is a short pole hiding unobtrusively behind the "
            "stress balls and it is only through very close scruitiny that "
            "it is actually noticable at all.  The pole seems to have "
            "lots of strings coming out of it, each of which lead to a "
            "stress ball, limiting the distance it can travel.\n"
            "It is secured to the floor and cannot come out.");
   add_item("device", "Devices of differing shapes and sizes litter most "
            "of the walls - all seemingly to do with harming nasty players. "
            " From the voodoo dolls in one corner to the rack in another, "
            "not to mention the whips and chains.  Serious stuff.");
   add_item("whip", "I told you not to mention them.");
   add_item("chain", "I told you not to mention them.");
   add_item("bottle", "The bottles line the inside of the cabinet, all "
            "different shapes and sizes of bottles.  Green bottles, "
            "blue bottles, red bottles, bottles with caterpillers in, "
            "bottles with toads in, bottles with DUCKs in, bottles "
            "with labels on, bottles with warnings on, bottles with "
            "skulls and crossbones on, so basically, lots of bottles.");
   add_item("cabinet", "The drinks cabinet is leaning idly against a "
            "wall [as much as a drinks cabinet can] and seems to sneer "
            "at you [as much as a drinks cabinet can].  The polished "
            "glass of the cabinet windows show all the drinks that "
            "seem to look smug [as much as bottles can].  The large "
            "lock holding the cabinet shut makes the bottles "
            "completely out of range.\n"
            "If you are really desperate, "
            "clone /w/lucifer/misc/blasterbottle.c and go nuts.");
   add_item("glass", "It's just some glass in the cabinet.  Nothing "
            "special.");
   add_item("chair", "The easy chairs that line the walls are "
            "pretty nondescript: big "
            "deep cushions and fluffy armrests, but that's all "
            "they are - and ever will be: chairs.  "
            "As a profound sense of misery sweeps over you, you "
            "notice one of the chairs is occupied by a rather "
            "despondant looking man.");
   add_item("doll", "The voodoo dolls lie in a messy pile in a "
            "corner of the room, looking particularly morbid with "
            "a hundred different needles sticking out at various "
            "points of their doll bodies.  The faces of the dolls "
            "are hard to make out, seeming to shift from likeness to "
            "likeness as you look at them.  There is a barrier in front "
            "of the dolls, suggesting they shouldn't be touched.");
   add_item("barrier", "A thick looking piece of metal completely blocking "
            "all access to the dolls.  Most probably for the best, too.");
   add_item("needle", "The needles are -unsurprisingly- sharp things "
            "currently embedded into the dolls, no doubt causing extreme "
            "pain.  Well, at least they would if the dolls were real. "
            "Which they aren't.  Which is a good thing.");                  
   add_item("rack", "The rack is a vicious looking instrument that allows "
            "the human [or non-human] body to be stretched to completely "
            "wrong proportions.  This is something that should be used "
            "with extreme caution.  Happily, it appears not to have been "
            "used yet [there is a still plastic covering on it] and long "
            "may it stay that way.");
   add_item("covering", "Mercifully there is a covering on the rack, "
            "showing it has never been used.  Which is a good thing.");
   add_item("armrest", "It's an armrest.  You rest your arm on it.");
   add_item("wall", "It's a wall.  That's about it.");
   add_item("cushion", "It's a cushion. You rest your bum on it.");
   add_item("man", "The man seated in one of the easy chairs looks "
            "to have resigned himself to a lifetime there, and "
            "from what you can see there appears to be a deep "
            "groove in the chair from his body shape.\n"
            "He notices you looking at him and speaks slowly, like he "
            "has nearly forgotten how: 'Do you know how long Moonchild "
            "will be? I've been waiting here for over 5 years now! I "
            "missed the fall of quest XP and everything - just because "
            "I wanted my items back!'\n"
            "As the man starts to froth at the mouth, you hurriedly turn "
            "your back on him and leave him to his waiting.");
   add_sign("This is a sign.  But then you knew that, or at least we hope "
            "you did.\n",
            "Commands available here are:\n"
            "add <name>   : add <name> as one of your characters.\n"
            "remove <name>: remove <name> as one of your characters.\n"
            "list [<name>]: list characters added for you or <name>.", 0, 0, 0);
   board = clone_object("/obj/misc/board");
   board->set_datafile(DOMAIN);
   board->move(this_object());
   add_exit("office", "/w/wyvyrn/rooms/study", "door");
   add_exit("drum", CONFIG_START_LOCATION, "path");
   add_exit("corridor", "/d/liaison/cre_corridor", "door");
   add_exit("interview", "/d/liaison/utils/interview", "door");
   BOSS_ROOM->add_exit("common", "/d/"+DOMAIN+"/common", "door");
} /* setup() */

void init() {
   this_player()->add_command( "add", this_object(), "<word> <word>" );
   this_player()->add_command( "add", this_object(), "<word>" );
   this_player()->add_command( "remove", this_object(), "<word> <word>" );
   this_player()->add_command( "remove", this_object(), "<word>" );
   this_player()->add_command( "list", this_object(), "" );
   this_player()->add_command( "list", this_object(), "<word>" );
} /* init() */

int do_add( object *indir, string indir_match, string dir_match, 
           mixed *args, string pattern  ) {
   switch( pattern ) {
    case "<word> <word>":
      if ( master()->query_lord( this_player()->query_name() ) || 
           "/d/liaison/master"->query_deputy( this_player()->query_name() ) ) {
         if ( "/d/liaison/master"->add_member_alias( args[ 0 ], 
                                                    args[ 1 ] ) ) {
            this_player()->add_succeeded_mess( this_object(), 
                args[ 1 ] +" added as alias for "+ args[ 0 ] +".\n" );
            return 1;
         } else {
            this_player()->add_failed_mess( this_object(), 
                "Something went wrong.\n" );
            return 0;
         }
      } else {
         this_player()->add_failed_mess( this_object(), 
                "Only lords and deputies can add aliases to others.\n" );
         return 0;
      }
      break;
    case "<word>":
      if ( "/d/liaison/master"->add_member_alias( this_player()->query_name(), 
                                                 args[ 0 ] ) ) {
         this_player()->add_succeeded_mess( this_object(), 
                args[ 0 ] +" added as alias for $N.\n" );
         return 1;
      } else {
         this_player()->add_failed_mess( this_object(), 
                "Couldn't add "+ args[ 0 ] +" as alias for $N.\n" );
         return 0;
      }
      break;
   }
} /* do_add */

int do_remove( object *indir, string indir_match, string dir_match, 
           mixed *args, string pattern  ) {
   switch( pattern ) {
    case "<word> <word>":
      if ( master()->query_lord( this_player()->query_name() ) || 
           "/d/liaison/master"->query_deputy( this_player()->query_name() ) ) {
         if ( "/d/liaison/master"->delete_member_alias( args[ 0 ], 
                                                       args[ 1 ] ) ) {
            this_player()->add_succeeded_mess( this_object(), 
                    args[ 1 ] +" removed as alias for "+ args[ 0 ] +".\n" );
            return 1;
         } else {
            this_player()->add_failed_mess( this_object(), 
                "Something went wrong.\n" );
            return 0;
         }
      } else {
         this_player()->add_failed_mess( this_object(), 
                "Only lords and deputies can remove aliases for others.\n" );
         return 0;
      }
      break;
    case "<word>":
      if ( "/d/liaison/master"->delete_member_alias(
                 this_player()->query_name(), args[ 0 ] ) ) {
         this_player()->add_succeeded_mess( this_object(), 
                 args[ 0 ] +" removed as alias for $N.\n" );
         return 1;
      } else {
         this_player()->add_failed_mess( this_object(), 
                 "Couldn't remove "+ args[ 0 ] +" as alias for $N.\n" );
         return 0;
      }
      break;
   }
} /* do_remove */

int do_list( object *indir, string indir_match, string dir_match, 
           mixed *args, string pattern  ) {
   string *names, name;
   int i;
   
   switch( pattern ) {
    case "<word>":
      name = args[ 0 ];
      break;
    case "":
      name = this_player()->query_name();
      break;
   }
   names = "/d/liaison/master"->member_alias( name );
   name = capitalize( name );
   i = sizeof( names );
   if ( i ) {
      if ( i > 1 ) {
         while ( i-- ) {
            names[ i ] = capitalize( names[ i ] );
         }
         this_player()->add_succeeded_mess( this_object(), 
                "Aliases for "+ name +" are "+
                query_multiple_short( names )+".\n" );
      } else {
         this_player()->add_succeeded_mess( this_object(), 
                "Alias for "+ name +" is "+
                capitalize( names[ 0 ] )+".\n" );
      }
   } else {
      this_player()->add_succeeded_mess( this_object(), 
             "No aliases known for "+ name +".\n" );
   }
   return 1;
} /* do_list */

// --- END [/mnt/home2/grok/lib/d/liaison/common.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/master.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/master.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627535   Available: 13574889
Inodes: Total: 5242880    Free: 4960133
8926 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/master.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627535   Available: 13574889
Inodes: Total: 5242880    Free: 4960133
2025-03-06 15:06:46.946114078 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
// -*- LPC -*-
// /secure/master.c
// Recoded for FluffOS v2019+, themed for Forgotten Realms, integrating live Discworld mechanics
// Last updated: March 07, 2025

#include <config.h>
#include <log.h>
#include <player_handler.h>

inherit "/secure/master/directory_assignments";

#define ROOT "Root"

// Deity-inspired hierarchy (Forgotten Realms-themed, mapping Discworld roles)
#define OVERDEITY         1  // Top tier (Discworld TRUSTEE)
#define HIGH_ARCHON       2  // Mid tier (Discworld DIRECTOR)
#define ADEPT_OF_MYSTERIES 3  // Lower tier (Discworld SENIOR)
#define CHOSEN_EMISSARY   4  // Special role (Discworld LIAISON)

// Permission masks (from Discworld /helpdir/access)
#define READ_MASK   1
#define WRITE_MASK  2
#define GRANT_MASK  4
#define LOCK_MASK   8

private mapping positions;      // Role assignments
private mapping overdeities;   // Top-tier deity-like admins
private mapping permissions;   // File permissions (mirrors /helpdir/permissions)
private mapping checked_master; // Loaded domain masters
private mapping snoop_list;    // Snooping list (from /helpdir/snoop)
private object  unguarded_ob;  // Unguarded operation object

private mapping save_data;     // Persistent data (replaces .o files)

protected void create() {
    set_eval_limit(2000000); // Standard Discworld limit
    permissions = ([ ]);
    positions   = ([ ]);
    checked_master = ([ ]);
    snoop_list = ([ ]);
    unguarded_ob = 0;
    overdeities = ([ ROOT: 1, "archaon": 1 ]); // Initial Overdeities
    save_data = ([ ]);

    // Load persistent data (replaces restore_object, fixes permission errors)
    string save_file = "/secure/save/master.json";
    if (file_size(save_file) > 0) {
        mixed data = json_decode(read_file(save_file));
        if (mappingp(data)) {
            positions = data["positions"] || ([ ]);
            overdeities = data["overdeities"] || overdeities;
            permissions = data["permissions"] || ([ ]);
        } else {
            LOG_HANDLER->log("ERROR", "Failed to load master save file at " + ctime(time()) + "\n");
        }
    }
}

string query_name() { return "Root"; }

object connect(int port) {
    object ob;

    if (!find_object("/secure/login")) {
        LOG_HANDLER->log("REBOOT", "The Realms of Toril reawakened at " + ctime(time()) + "[" + time() + "]\n");
    }

    printf("LPmud version: %s on port %d.\n", mud_info()->query_driver_version(), port);
    switch (port) {
        case 4242: // Matches live Discworld port
            ob = clone_object("/secure/nlogin");
            if (!ob) destruct(this_object());
            break;
        default:
            ob = clone_object("/secure/login");
            break;
    }
    ob->set_login_port(port);
    return ob;
}

// Overdeity (God/Goddess) check
int query_overdeity(mixed str) {
    if (pointerp(str)) {
        str = filter(str, (: interactive($1) :));
        return sizeof(filter((object *)str,
                             (: geteuid($1) == ROOT ||
                                positions[geteuid($1)] == OVERDEITY ||
                                overdeities[geteuid($1)] :))) == sizeof(str);
    }
    return (str == ROOT) || (positions[str] == OVERDEITY) || (overdeities[str]);
}

string query_divine_title(string name) {
    object player = find_player(name);
    if (!player || !query_overdeity(name)) return "Mortal";
    // Placeholder: Needs Discworld gender check (e.g., from /global/player.c)
    return random(2) ? "God of the Realms" : "Goddess of the Realms";
}

int query_administrator(mixed str) { return query_overdeity(str); }
int query_high_priest(mixed str) { return query_overdeity(str); } // Aligns with /concepts/religion

// High Archon (Greater Deity)
int query_high_archon(mixed arg) {
    if (pointerp(arg)) {
        arg = filter(arg, (: interactive($1) :));
        return sizeof(filter((object *)arg,
                             (: (positions[geteuid($1)] == HIGH_ARCHON) ||
                                query_overdeity(geteuid($1)) :))) == sizeof(arg);
    }
    return (positions[arg] == HIGH_ARCHON) || query_overdeity(arg);
}

int query_director(mixed arg) { return query_high_archon(arg); }
int query_lord(mixed arg) { return query_high_archon(arg); }

int query_only_high_archon(string word) {
    return positions[word] == HIGH_ARCHON;
}

string *query_high_archons() {
    return filter_array(keys(positions), (: query_only_high_archon($1) :), this_object());
}

// Adept of the Mysteries (Intermediate Deity)
int query_adept_of_mysteries(mixed arg) {
    if (pointerp(arg)) {
        return sizeof(filter((object *)arg,
                             (: (positions[geteuid($1)] == ADEPT_OF_MYSTERIES) ||
                                query_high_archon(geteuid($1)) :))) == sizeof(arg);
    }
    return (positions[arg] == ADEPT_OF_MYSTERIES) || query_high_archon(arg);
}

int query_senior(mixed arg) { return query_adept_of_mysteries(arg); }

string *query_all_adepts_of_mysteries() {
    return filter_array(keys(positions), (: query_adept_of_mysteries($1) :), this_object());
}

// Chosen Emissary (Lesser Deity)
int query_chosen_emissary(mixed arg) {
    if (pointerp(arg)) {
        arg = filter(arg, (: interactive($1) :));
        return sizeof(filter((object *)arg,
                             (: (positions[geteuid($1)] == CHOSEN_EMISSARY) ||
                                query_high_archon(geteuid($1)) :))) == sizeof(arg);
    }
    return (positions[arg] == CHOSEN_EMISSARY) || query_high_archon(arg);
}

int query_liaison_deputy_or_high_archon(mixed arg) {
    if (pointerp(arg)) {
        arg = filter(arg, (: interactive($1) :));
        return sizeof(filter((object *)arg,
                             (: query_high_archon(geteuid($1)) ||
                                (positions[geteuid($1)] == CHOSEN_EMISSARY) :))) == sizeof(arg);
    }
    return (positions[arg] == CHOSEN_EMISSARY) || query_high_archon(arg);
}

int is_chosen_emissary_of(string person, string domain) {
    return ("/d/" + domain + "/master")->query_deputy(person);
}

int query_player_overdeity(string str) {
    return query_overdeity(str) && PLAYER_HANDLER->test_user(str);
}

string *overdeities_list() { return keys(overdeities); }
string *query_domains() {
    string *domains = get_dir("/d/") - ({ "lost+found", "core" });
    return filter(domains, (: $1[<4..] != "_dev" :));
}

int valid_load(string path, mixed euid, string func) { return 1; }

string get_root_uid() { return ROOT; }
string get_bb_uid() { return "Room"; }

string *define_include_dirs() {
    return ({ "/include/%s" });
}

int valid_trace() { return 1; }

void shut(int min) {
    "/obj/shut"->shut(min);
}

void remove_checked_master(string name) {
    map_delete(checked_master, name);
}

mapping query_checked_master() { return copy(checked_master); }

varargs mixed apply_unguarded(function f, int local) {
    object previous_unguarded;
    string err;
    mixed val;

    if (base_name(previous_object(0)) != "/secure/simul_efun") {
        error("Illegal unguarded apply.");
        return 0;
    }
    previous_ungarded = unguarded_ob;
    if (local)
        unguarded_ob = master();
    else
        unguarded_ob = previous_object(1);
    err = catch(val = evaluate(f));
    unguarded_ob = previous_unguarded;
    if (err) error(err);
    return val;
}

// Save method (modernized, aligns with /helpdir/save)
private void save_master_data() {
    string save_file = "/secure/save/master.json";
    save_data["positions"] = positions;
    save_data["overdeities"] = overdeities;
    save_data["permissions"] = permissions;
    write_file(save_file, json_encode(save_data), 1);
    LOG_HANDLER->log("SAVE", "Master data saved at " + ctime(time()) + "\n");
}

// Include other master functionalities (to be recoded)
#include "/secure/master/permission.c"
#include "/secure/master/crash.c"
#include "/secure/master/create_dom_creator.c"
#include "/secure/master/creator_file.c"
#include "/secure/master/dest_env.c"
#include "/secure/master/ed_stuff.c"
#include "/secure/master/file_exists.c"
#include "/secure/master/logging.c"
#include "/secure/master/parse_command.c"
#include "/secure/master/preload.c"
#include "/secure/master/query_pl_level.c"
#include "/secure/master/simul_efun.c"
#include "/secure/master/snoop.c"
#include "/secure/master/valid_database.c"
#include "/secure/master/valid_exec.c"
#include "/secure/master/valid_hide.c"
#include "/secure/master/valid_ident.c"
#include "/secure/master/valid_link.c"
#include "/secure/master/valid_override.c"
#include "/secure/master/valid_read.c"
#include "/secure/master/valid_seteuid.c"
#include "/secure/master/valid_shadow.c"
#include "/secure/master/valid_socket.c"
#include "/secure/master/valid_write.c"
#include "/secure/master/valid_copy.c"
#include "/secure/master/virtual_objects.c"
#include "/secure/master/valid_bind.c"
#include "/secure/master/valid_to_c.c"
#include "/secure/master/valid_binary.c"
// --- END [/mnt/home2/grok/lib/secure/master.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/player/delete_clear.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/player/delete_clear.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627533   Available: 13574887
Inodes: Total: 5242880    Free: 4960133
1285 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/player/delete_clear.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627533   Available: 13574887
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: delete_clear.c,v 1.1 1998/01/06 05:13:01 ceres Exp $
 * $Log: delete_clear.c,v $
 * Revision 1.1  1998/01/06 05:13:01  ceres
 * Initial revision
 * 
*/
/*
 * This object goes through all the files in the deleted players dir
 * and checks to see if they have timed out.  If they have, it
 * deletes them.
 *
 * Pinkfish - 13th of January 1996
 */
#include <player_handler.h>

#define ONE_DAY (60*60*24)

#define SAVE_FILE "/save/del_pl_check"

/* Do the clear once every day */
int last_clear;

void create() {
  seteuid("Root");
  restore_object(SAVE_FILE);
  if (last_clear+ONE_DAY < time()) {
    call_out("do_delete_check", 0);
  } else {
    call_out("do_delete_check", last_clear+ONE_DAY-time());
  }
} /* create() */

protected void do_delete_check() {
  string *bits;
  int i;
  mixed *rubbish;

  bits = get_dir("/players/"+DELETE_DIR+"/*.o");
  for (i=0;i<sizeof(bits);i++) {
    rubbish = stat("/players/"+DELETE_DIR+"/"+bits[i]);
    if (rubbish[1]+(ONE_DAY*10) < time()) {
      log_file("DELETE_PL", ctime(time())+": Auto deleteing "+bits[i]+"\n");
      PLAYER_HANDLER->remove_player(bits[i]);
      rm("/players/"+DELETE_DIR+"/"+bits[i]);
    }
  }
  last_clear = time();
  save_object(SAVE_FILE);
} /* do_delete_check() */
// --- END [/mnt/home2/grok/lib/secure/player/delete_clear.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/command.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/command.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627532   Available: 13574886
Inodes: Total: 5242880    Free: 4960133
8872 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/command.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627532   Available: 13574886
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*   -*- LPC -*-   */
/*
 * $Locker:  $
 * $Id: command.c,v 1.16 2003/06/09 19:22:31 pinkfish Exp $
 */
/*      /daemon/command.c
 *      from the Nightmare IVr1 Object Library
 *      a new commands daemon, much faster than the old
 *      created by Descartes of Borg 940119
 *      Hacked for Discworld by Turrican 9-11-95
 */

#include <command.h>
#include <user_parser.h>

private nosave mapping Commands, Cache;
private nosave string *Paths, *GRCommands;
private nosave string last_verb, last_args, found_cmd, found_args;

void eventRehash(string *paths);

void create() {
   seteuid(getuid());
   Commands = ([]);
   Cache = ([ ]);
   GRCommands = ({});
   Paths = ({});
   eventRehash( ({ DIR_PLAYER_CMDS, DIR_CREATOR_CMDS, DIR_SECURE_CREATOR_CMDS,
                   DIR_LORD_CMDS, DIR_LIVING_CMDS, DIR_GUILD_CMDS,
                   DIR_PLAYTESTER_CMDS }) );
} /* create() */

void eventGuildRaceRehash() {
   string *paths, path;

   paths = ({ DIR_GUILD_CMDS });
   paths += map(filter(unguarded((: get_dir, DIR_GUILD_CMDS + "/", -1 :)),
                                 (: $1[1] == -2 :)),
                      (: DIR_GUILD_CMDS + "/" + $1[0] :));
   GRCommands = ({ });
   foreach (path in paths) {
      string *files, cmd;

      files = map(unguarded((: get_dir, path + "/*.c" :)),
                        (: $1[0..<3] :));
      GRCommands += files;
      foreach(cmd in files) {
         if (pointerp(Commands[cmd])) {
            Commands[cmd] += ({ path });
         } else {
            Commands[cmd] = ({ path });
         }
      }
      Paths = uniq_array(Paths + ({ path }));
   }
} /* eventGuildRaceRehash() */

void eventRehash(mixed paths) {
   string path;

   // Clear the cache since rehashing the paths may affect the results.
   Cache = ([ ]);
   
   if (stringp(paths)) {
      paths = ({ paths });
   } else if (!pointerp(paths)) {
      return;
   }
   
   foreach(path in paths) {
      string file;

      if  ( path[<1..<1] == "/" ) continue; 
      if (file_size(path) != -2)
         continue;
      if (path == DIR_GUILD_CMDS) {
         eventGuildRaceRehash();
         continue;
      }
      foreach (file in unguarded((: get_dir, path + "/*.c" :))) {
         string cmd;

         cmd = file[0..<3];
         if (pointerp(Commands[cmd])) {
            Commands[cmd] += ({ path });
         } else {
            Commands[cmd] = ({ path });
         }
      }
      Paths = uniq_array(Paths + ({ path }));
   }
} /* eventRehash() */

void HandleCommandLine(class command cmd) {
   string args = cmd->args;
   int i;
   string* bits;

   //args = replace_string(args, "%^", " ");
/*
   if (strsrch("%^", args)) {
      bits = explode("f" + args, "%^");
      for (i = 1; i < sizeof(bits); i += 2) {
         bits[i] += "USER_";
      }
      bits[0] = bits[0][1..];
      args = implode(bits, "%^");
   }
 */
   
   if ((i = strsrch(args, " ")) != -1) {
      cmd->verb = args[0..i-1];
      cmd->args = args[i+1..];
   } else {
      cmd->verb = args;
      cmd->args = (string)0;
   }
} /* HandleCommandLine() */

int strncmp(string s1, string s2, int len) {
   return strcmp(s1[0..len-1], s2[0..len-1]);
} /* strncmp() */

int HandleStars(class command cmd) {
   int i;
   int no_cache;
   string file, *files;

   // No point continuing!
   if(cmd->verb == "END_ALIAS")
     return 0;

   // This function gets called a hell of a lot of times. It gets called
   // 4 times for _each_ command. So, lets remember some common results and 
   // not do all that searching over and over again.

   // exactly the same as last time.
   if(last_verb == cmd->verb && last_args == cmd->args) {
     cmd->verb = found_cmd;
     if(stringp(found_args)) {
       cmd->args = found_args;
     }
     return 1;
   }

   // check common patterns (can't do ones that end in _. 
   if(Cache[cmd->verb]) {
     if(stringp(Cache[cmd->verb][1]))
       cmd->args = Cache[cmd->verb][1];
     cmd->verb = Cache[cmd->verb][0];

     return 1;
   }
   
   if (Commands[cmd->verb]) {
     /* Yippiee ! No searching needed ! */
     return 1;
   }
   
   /* Darn. Need to search for shortcuts. */
   files = keys(Commands);
   files = filter(files, (: (int)$1[0] == $(cmd)->verb[0] :));

   foreach (file in files) {
     string tmpverb, tmpargs = 0, tmpfile = 0;
     int len, length;
     
     if ((i = strsrch(file, "_")) == -1)
       continue;

     tmpfile = (string)delete(file, i, 1);
     len = strlen(tmpfile);
     if (i == len) {
       tmpargs = cmd->verb[i..]+(cmd->args?(strlen(cmd->verb) == i?"":" ") + 
                                 cmd->args:"");
       tmpverb = cmd->verb[0..i-1];
       if (strncmp(tmpfile, tmpverb, len) != 0) {
         continue;
       }
       no_cache = 1;
     } else {       
       length = strlen(cmd->verb);
       if ((length > len) || (length < i))
         continue;
       
       if (strncmp(cmd->verb, tmpfile, length) != 0)
         continue;
     }
     
     /* Yay! Found a match! */
     if (!no_cache) {
        Cache[cmd->verb] = ({ file, tmpargs });
     }

     last_verb = cmd->verb;
     last_args = cmd->args;

     cmd->verb = file;
     if (stringp(tmpargs))
       cmd->args = tmpargs;
     found_cmd = cmd->verb;
     found_args = tmpargs;

     return 1;
   }
   return 0;
} /* HandleStars() */

int GetCommand(class command cmd, string *path) {
   string *tmp;
   int i;

   if (!stringp(cmd->args)) {
      return 0;
   }
   tmp = (path & Paths);
   if (sizeof(tmp = path - tmp)) {
      eventRehash(tmp);
   }
   HandleCommandLine(cmd);
   if (HandleStars(cmd) && Commands[cmd->verb] &&
       sizeof(tmp = (path & (string *)Commands[cmd->verb]))) {
      cmd->file = sprintf("%s/%s", tmp[0], cmd->verb);
      cmd->filepart = cmd->verb;
      if ((i = strsrch(cmd->verb, "_")) != -1) {
         cmd->verb = (string)delete(cmd->verb, i, 1);
      }
      if (cmd->args && cmd->args == "") {
         cmd->args = (string)0;
      }
      if ((cmd->file)->query_patterns()) {
         return 0;
      }
      return 1;
   }
   return 0;
} /* GetCommand() */

mixed ReturnPatterns(class command cmd, string *path) {
   mixed *q_patterns;
   mixed *r_patterns;
   mixed *stuff;
   mixed *tmp;
   mixed *ret_patterns;
   int i, j;
   string fname;

   tmp = (path & Paths);
   tmp = path - tmp;
   if (sizeof(tmp)) {
      eventRehash(tmp);
   }
   if (HandleStars(cmd) && Commands[cmd->verb]) {
      tmp = (path & (string *)Commands[cmd->verb]);
      if (tmp) {
         ret_patterns = ({ });
         foreach (fname in tmp) {
            cmd->file = sprintf("%s/%s", fname, cmd->verb);
            //if ((i = strsrch(cmd->verb, "_")) != -1) {
               //cmd->verb = (string)delete(cmd->verb, i, 1);
            //}
            q_patterns = (cmd->file)->query_patterns();
            if (!q_patterns) {
               return 0;
            }
            r_patterns = ({ });
            for (i = 0; i < sizeof(q_patterns); i += 2) {
               if (q_patterns[i+1] && !functionp(q_patterns[i+1])) {
                  continue;
               }
               stuff = (mixed *)PATTERN_OB->query_pattern(q_patterns[i]);
               j = 0;
               while (j < sizeof(r_patterns) && 
                         r_patterns[j][PATTERN_WEIGHT] >= stuff[0]) {
                  j++;
               }
               r_patterns = r_patterns[0..j-1] + 
                  ({ ({ stuff[0], q_patterns[i], 0, find_object(cmd->file),
                           q_patterns[i+1] }) }) + r_patterns[j..];
            }
            ret_patterns += r_patterns;
         }
         return ret_patterns;
      }
   }
   return 0;
} /* ReturnPatterns() */

mixed *GetCommandPatterns(string cmd_name, string *path) {
   class command cmd;
   mixed *stuff;

   cmd = new(class command);
   cmd->verb = cmd_name;
   cmd->args = 0;
   stuff = ReturnPatterns(cmd, path);
   return stuff;
} /* GetCommandPatterns() */

varargs string *GetCommands(string path) {
   string *paths, *tmp;
   string cmd;

   if (!path) {
      return keys(Commands);
   }
   tmp = ({ });
   foreach (cmd, paths in Commands) {
      if (member_array(path, paths) != -1) {
         tmp += ({ cmd });
      }
   }
   return tmp;
} /* GetCommands() */

varargs string *GetPaths(string cmd) {
   if (cmd) {
      string *paths;
      class command tmp;

      if (sizeof(paths = Commands[cmd])) {
         return paths;
      }
      tmp = new(class command, verb : cmd);
      if (HandleStars(tmp)) {
         return Commands[tmp->verb];
      } else {
         return 0;
      }
   }
   return Paths;
} /* GetPaths() */

int IsGRCommand(string cmd) {
   if (member_array(cmd, GRCommands) != -1) {
      return 1;
   } else {
      class command tmp = new(class command, verb : cmd);

      if (HandleStars(tmp)) {
         return (member_array(tmp->verb, GRCommands) != -1);
      }
   }
} /* IsGRCommand() */
// --- END [/mnt/home2/grok/lib/secure/command.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/delete_clear.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/delete_clear.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627530   Available: 13574884
Inodes: Total: 5242880    Free: 4960133
2234 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/delete_clear.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627530   Available: 13574884
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: delete_clear.c,v 1.7 2003/03/22 04:52:12 ceres Exp $
*/
/*
 * This object goes through all the files in the deleted players dir
 * and checks to see if they have timed out.  If they have, it
 * deletes them.
 *
 * Pinkfish - 13th of January 1996
 */
#include <player_handler.h>
#include <refresh.h>

#define ONE_DAY (60*60*24)

#define SAVE_FILE "/save/del_pl_check"

protected void do_checks();
protected void do_delete_check();
protected void do_appeal_check();

void create() {
  seteuid("Root");
  unguarded((: restore_object(SAVE_FILE) :));
  do_checks();
}

protected void do_checks() {
  unguarded((: do_delete_check() :));
  unguarded((: do_appeal_check() :));
  save_object(SAVE_FILE);
  call_out("do_checks", ONE_DAY);
}

protected  void do_delete_check() {
  string *bits, name;
  int i;
  mixed *rubbish;

  bits = get_dir(PLAYER_SAVE_DIR+DELETE_DIR+"/*.o");
  bits += get_dir(PLAYER_SAVE_DIR+DELETE_DIR+"/*.o.gz");
  for (i=0;i<sizeof(bits);i++) {
    rubbish = stat(PLAYER_SAVE_DIR+DELETE_DIR+"/"+bits[i]);
    if (rubbish[1]+(ONE_DAY*10) < time()) {
      log_file( "EXPIRED", "Requested player deletion: "+bits[ i ] +".\n" );
    name = explode( bits[i], "." )[ 0 ]; 

      user_event( "inform", "Auto deleting user "+name, "delete");
      "/secure/related_files"->delete_related_files(name, 1);
      unguarded((: rm( PLAYER_SAVE_DIR+DELETE_DIR+"/"+$(bits[i])) :));
      REFRESH_HANDLER->player_deleted(name);
    }
  }
}

protected  void do_appeal_check() {
  string *bits, name;
  int i;
  mixed *rubbish;

  bits = get_dir(PLAYER_SAVE_DIR+APPEAL_DIR+"/*.o");
  bits += get_dir(PLAYER_SAVE_DIR+APPEAL_DIR+"/*.o.gz");
  for (i=0;i<sizeof(bits);i++) {
    rubbish = stat(PLAYER_SAVE_DIR+APPEAL_DIR+"/"+bits[i]);
    if (rubbish[1]+(ONE_DAY*28) < time()) {
      log_file( "EXPIRED", ctime(time()) + " appeal player deletion: "+
                bits[i]+".\n");
      name = explode( bits[i], "." )[ 0 ]; 
      
      user_event( "inform", "Auto deleting user "+name, "delete");
      "/secure/related_files"->delete_related_files(name, 1);
      unguarded((: rm( PLAYER_SAVE_DIR+APPEAL_DIR+"/"+$(bits[i])) :));
      REFRESH_HANDLER->player_deleted(name);
    }
  }
}
// --- END [/mnt/home2/grok/lib/secure/delete_clear.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/related_files.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/related_files.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627529   Available: 13574883
Inodes: Total: 5242880    Free: 4960133
2497 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/related_files.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627529   Available: 13574883
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*   -*- LPC -*-   */
/*
 * $Locker:  $
 * $Id: related_files.c,v 1.14 2002/11/18 01:37:21 ceres Exp $
 */
#include <playerinfo.h>
#include <nomic_system.h>

void delete_related_files( string name, int mail, int refresh_type ) {
   string *files;
   string area;
   string dir;
   
   if (previous_object() != find_object("/secure/bulk_delete") &&
       previous_object() != find_object("/secure/delete_clear") &&
       previous_object() != find_object("/obj/handlers/refresh")) {
     if (!master()->high_programmer(previous_object(-1)) &&
         ((string)previous_object()->query_name() != name)) {
       tell_object(find_player("ceres"), "Not doing erasing. %O\n",
                   previous_object());
       unguarded( (: write_file, "/log/CHEAT", ctime( time() ) +
                   ": illegal attempt to delete related files using "+
                   "/secure/related_files\nTrace: "+ back_trace() :) );
       return;
     }
   }
   unguarded( (: rm, "/save/artifacts/"+ name :) );
   unguarded( (: rm, "/save/bank_accounts/"+name[0..0] + "/" + name + ".o" :) );
   unguarded( (: rm, "/save/cmr_library/"+ name +".o" :) );
   catch("/obj/handlers/library"->restart(name));
   unguarded( (: rm, "/save/library/"+ name[0..0] + "/" + name + ".o" :) );
   unguarded( (: rm, "/save/philosophies/"+ name[0..0] + "/"+ name + ".o" :) );

   foreach(dir in get_dir("/save/vaults/*"))
     if(dir != "." && dir != "..")
       unguarded( (: rm, "/save/vaults/" + dir + "/" + name + ".o" :) );

   unguarded( (: rm, "/save/newsrc/"+name[0..0]+"/"+name+".o" :) );
   
   files = get_dir( "/w/.dead_ed_files/"+ name +"-*" );
   if ( sizeof( files ) ) {
      map(files, (: unguarded( (: rm, "/w/.dead_ed_files/"+ $1 :) ) :) );
   }

   if ( mail ) {
      // We only delete their player info if we also delete their mail...
      "/obj/handlers/folder_handler"->delete_account( name );
      //PLAYERINFO_HANDLER->player_remove( name );
   }

   "/obj/handlers/secure_handlers/inhume"->player_refreshed( name );
   "/obj/handlers/guild_things/thieves_ledger"->delete_crimes( name );
   "/obj/handlers/guild_things/quota/thief_quota"->remove_thief(name);
   "/obj/handlers/guild_things/quota/thief_quota"->remove_player(name);
   "/d/am/buildings/apex/admin_office"->remove_member( name );
   "/d/am/items/watch_ledger"->delete_crimes( name );

   foreach (area in NOMIC_HANDLER->query_citizenship_areas()) {
      NOMIC_HANDLER->remove_citizen(area, name);
   }
} /* delete_related_files() */
// --- END [/mnt/home2/grok/lib/secure/related_files.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/ftpd.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/ftpd.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627529   Available: 13574883
Inodes: Total: 5242880    Free: 4960133
49019 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/ftpd.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627529   Available: 13574883
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker: ceres $
 * $Id: ftpd.c,v 1.12 2003/03/21 02:28:03 ceres Exp ceres $
 * 
*/
/* 
 * FTP daemon, complete rewrite using classes.
 * By Turrican@Discworld, 21-4-96.
 */

#include <network.h>

inherit SERVER;

#include <ftp.h>
#include <localtime.h>
#include <player_handler.h>

#define DELAY_LOG_FLUSH 5

private nosave mapping socket_info, data_sockets;
private nosave mapping _log_file_info = ([ ]);
private nosave int _log_file_flush_id;

protected void create() {
  server::create();
  seteuid("Root");
  socket_info = ([]);
  data_sockets = ([]);
  SetSocketType(STREAM);
  write(mud_name() + "\n");
  if(mud_name() != "Discworld")
    call_out("setup_ftp", 2);
  else
    destruct(this_object());
} /* create() */

/**
 * This method flushes out all the buffered stuff for the log files.
 */
private void flush_log_files() {
  string fname;
  string data;
  
  _log_file_flush_id = 0;
  foreach (fname, data in _log_file_info) {
      map_delete(_log_file_info, fname);
      unguarded((: write_file, fname, data :));
   }
   _log_file_info = ([ ]);
} /* flush_log_files() */

void log_write(string name, string fmt, mixed *args ...) {
    if (!_log_file_flush_id) {
     _log_file_flush_id = call_out((: flush_log_files :), DELAY_LOG_FLUSH);
  }
  if (!_log_file_info[name]) {
     _log_file_info[name] = "";
  }
  if (sizeof(args)) {
    _log_file_info[name] += sprintf(fmt, args ...);
  } else {
    _log_file_info[name] += fmt;
  }
}

protected void setup_ftp() {
  int x;

  if ((x = eventCreateSocket(FTP_PORT)) < 0) {
    if (this_object()) destruct(this_object());
    return;
  }
  call_out("check_connections", 5*60);
} /* setup_ftp() */

/* returns an array of users connected to ftpd */
string *query_connections() {
  class session *vals, val;
  string *list;

  list = ({ });
  vals = (class session *)values(socket_info);
  foreach (val in vals) {
    if (val->user_name) {
      if (val->logged_in) {
        list += ({ capitalize(val->user_name) });
      } else {
        list += ({ "login" });
      }
    }
  }
  return list;
} /* query_connections() */

protected string ls(string path, int mask) {
   string *files, tmp, tmp2, creator, domain;
   int i, j, s, current_time;
   mixed *xfiles, *stats;
   
#ifdef DEBUG
    TP(sprintf("ls(%s,%d)\n",path,mask));
#endif
   /* If the path is a directory, get contents uynless MASK_D is set */
   if (!(mask & MASK_D) && file_size(path) == -2) {
      if (path[ <1 ] == '/')
         path += "*";
      else
         path += "/*";
   }
   
   /* begin narrow columnar "nlst" */
   if (!(MASK_L & mask)) {
      files = get_dir(path);
      /* can only happen if permissions are messed up at account level */
      if (!files)
         return "";
      if (!(MASK_A & mask))
         files -= ({ ".", ".." });
      if (!(i = sizeof( files )))
         return "";
      /* no wild cards...must have been the exact pathname to a file */
      if (strsrch(path, '*') == -1 && strsrch(path, '?') == -1) {
         return files[0] + "\n";
      }
      /* remove globber at end of path, leave a trailing slash */
      j = strsrch(path, '/', -1);
      path = path[0..j];
      while (i--) {
         /* scan next level down for files */
         tmp = sprintf("%s%s/", path, files[i]);
         if (MASK_F & mask) {
            if (strsrch(tmp, "/./") != -1 || strsrch(tmp, "/../") != -1) {
               files[i] += "/";
               continue;
            }
            if (file_size(tmp) == -2)
               files[i] += "/";
            else if (stat(tmp[0..<2])[2])
               files[i] += "*";
         }
      }
      if (MASK_C & mask)
         return sprintf("%-#70s\n", implode(files, "\n"));
      else
         return implode(files, "\n") + "\n";
   }
   
   /* don't recurse */
   if (!(MASK_R & mask)) {
      /* begin long "list" */
      xfiles = get_dir(path, -1);
      if (!(mask & MASK_A))
         xfiles = filter_array(xfiles, "check_dots", this_object());
      if (!xfiles || !(s = sizeof( xfiles )))
         return "total 0\n";
      files = allocate(s);
      
      /* the Unix-like file permissions are mainly for effect...hopefully it
       * isn't too much, since anything more would likely be too cpu intensive
       * and cause it to max eval... */
      creator = (string)master()->author_file(path);
      if (!creator) {
         creator = "Root";
      }
      domain = (string)master()->domain_file(path);
      if (!domain) {
         domain = "Root";
      }
      i = strsrch(path, '/', -1);
      if (i >= 0)
         path = path[0..i];
      current_time = time();
      for (i = 0; i < s; i++) {
         /* process timestamp */
         tmp2 = ctime((xfiles[i])[2]); /* get last modified timestamp */
         if ((xfiles[i])[2] + (6 * 30 * 24 * 60 * 60) < current_time ||
             (xfiles[i])[2] - (60 * 60) > current_time ) {
            /* MMM DD  YYYY */
            tmp = sprintf("%s  %s", tmp2[4..9], tmp2[20..23]);
         } else {
            /* MMM DD hh:mm */
            tmp = tmp2[4..15];
         }
         j = (xfiles[i])[1];   /* get filesize */
         if (j == -2) {
            /* directory */
            files[i] = sprintf("drwxrwxr-x   0 %-8s %-8s        0 %12s %s",
                               creator, domain, tmp,
                               (xfiles[i])[0]+((MASK_F & mask)?"/":""));
         } else {
            /* file */
            stats = stat(path + (xfiles[i])[0]);
            files[i] = sprintf("-rw%crw-r--   1 %-8s %-8s %8d %12s %s",
                               sizeof(stats) > 1 && stats[2] ? 'x' : '-',
                               creator, domain, j, tmp,
                               (xfiles[i])[0] + (sizeof(stats) > 1 && stats[2] &&
                                                 (MASK_F & mask)?"*":""));
         }
      }
      return sprintf("total %i\n",s)+implode(files, "\n")+"\n";
   }
   /* begin long recursive "list" WARNING! still experimental */
   if( path[<1 .. <1] != "*" )
      return ls( path, (mask & ~MASK_R) );
   path = path[ 0 .. <3 ];
   files = ({ "" });
   tmp = "";
   while( sizeof( files ) ) {
      reset_eval_cost();
      if( files[ 0 ] == "" )
         tmp += ls( path + "/*", (mask & ~MASK_R) );
      else
         tmp += "\n" +files[ 0 ][ 1 .. <1 ] + ":\n" +
                ls( path + files[ 0 ] + "/*", (mask & ~MASK_R) );
      xfiles = get_dir( path + files[ 0 ] + "/*", -1 );
      if( xfiles && ( s = sizeof( xfiles ) ) ) {
         for (i = 0; i < s; i++) {
            j = (xfiles[i])[1];   /* get filesize */
            if ((j == -2) && (xfiles[i][0] != ".") && (xfiles[i][0] != "..")) {
               files += ({ files[ 0 ] +"/"+ xfiles[i][0] });
            }
         }
      }
      files = files[ 1 .. <1 ];
   }
   return tmp;
} /* ls() */

protected void data_conn(int fd, string mess, string name, int type) {
   int new_fd, ret, data_mode;
   string data_mode_name, addr;
   class session sess = (class session)socket_info[fd];
   class dataconn t;
   
  if (type == STRING || (type == FILE && sess->type == STRING)) {
    data_mode_name = "ASCII";
    data_mode = STREAM;
  } else {
    data_mode_name = "BINARY";
    data_mode = STREAM_BINARY;
  }

  t = new(class dataconn);
  t->path = name;
  t->data = (type == STRING ? replace_string(mess, "\n", "\r\n") : mess);
  t->pos = sess->offset;
  t->parent_fd = fd;
  t->type = type;
  t->len = (type == STRING ? strlen(mess) : file_size(mess));

  if (sess->pasv_fd != -1) {
    if (sess->pasv_cb) {
      TP("Accepting after delay...\n");
      new_fd = socket_accept(sess->pasv_fd, "data_read_callback",
                             "data_write_callback");
      if (new_fd < 0) {
        eventWrite(fd, "425 Can't open data connection.\r\n");
        socket_close(sess->pasv_fd);
        sess->pasv_fd = -1;
        return;
      }
      socket_close(sess->pasv_fd);
      sess->pasv_fd = new_fd;
    } else {
      TP("No connection yet...\n");
      data_sockets[sess->pasv_fd] = t;
      return;
    }
  } else {
    sess->use_default = 1;
  
    if (sess->data_fd != -1) {
      eventWrite(fd, "425 Can't open data connection.\r\n");
      return;
    }
    new_fd = socket_create(data_mode, "data_read_callback",
                           "data_close_callback");

    if (new_fd < 0) {
      eventWrite(fd, "425 Can't create data socket.\r\n");
      return;
    }

    if (!sess->data_addr) {
      eventWrite(fd, "425 Can't open data connection.\r\n");
      socket_close(new_fd);
      return;
    }

    sscanf(socket_address(fd, 1), "%s %*d", addr);
    addr = sprintf("%s %d", addr, (FTP_PORT - 1));

    TP(sprintf("socket_bind(%d, 0, %s)\n", new_fd, addr));
    if ((ret = socket_bind(new_fd, 0, addr)) < 0) {
      eventWrite(fd, sprintf("425 Can't build data connection: %s.\r\n",
                             socket_error(ret)));
      socket_close(new_fd);
      return;
    }
  }

  data_sockets[new_fd] = t;
  sess->data_fd = new_fd;
  if (sess->pasv_fd == -1 &&
      (ret = socket_connect(new_fd,
                            sprintf("%s %d", sess->data_addr, sess->data_port),
                            "data_read_callback",
                            "data_write_callback")) < 0) {
    TP("Error: " + sess->data_addr + " " + sess->data_port + "\n");
    TP(socket_error(ret) + "\n");
    eventWrite(fd, "425 Can't build data connection.\r\n");
    sess->data_fd = -1;
    socket_close(new_fd);
    map_delete(data_sockets, new_fd);
    return;
  }
  eventWrite(fd, sprintf("150 Opening %s mode data connection for %s "
                         "(%d bytes).\r\n", data_mode_name, name, t->len));
  if (sess->pasv_fd != -1)
    data_write_callback(new_fd);
} /* data_conn() */

protected void read_connection(int fd, string path, int append) {
  int new_fd, ret, data_mode;
  string data_mode_name, opath, addr;
  class dataconn t;
  class session sess = (class session)socket_info[fd];

  if (sess->type == BINARY) {
    data_mode_name = "BINARY";
    data_mode = STREAM_BINARY;
  } else {
    data_mode_name = "ASCII";
    data_mode = STREAM;
  }

  opath = path;
  if (append != 1) {
    path = path + ".ftptmp";
    if (file_size(path) > -1)
      catch(rm(path));
  }

  t = new(class dataconn);
  t->path = path;
  t->parent_fd = fd;
  t->pos = (!append?0:(file_size(opath)==-1?0:file_size(opath)));
  t->type = DOWNLOAD;
  t->append = append;

  if (sess->pasv_fd != -1) {
    if (sess->pasv_cb) {
      new_fd = socket_accept(sess->pasv_fd, "data_read_callback",
                             "data_write_callback");
      if (new_fd < 0) {
        eventWrite(fd, "425 Can't open data connection.\r\n");
        socket_close(sess->pasv_fd);
        sess->pasv_fd = -1;
        return;
      }
      socket_close(sess->pasv_fd);
      sess->pasv_fd = new_fd;
    } else {
      data_sockets[sess->pasv_fd] = t;
      return;
    }
  } else {
    sess->use_default = 1;
    if (sess->data_fd != -1) {
      eventWrite(fd, "425 Can't open data connection.\r\n");
      return;
    }

    new_fd = socket_create(data_mode, "data_read_callback",
                           "data_close_callback");

    if (new_fd < 0) {
      eventWrite(fd, "425 Can't create data socket.\r\n");
      return;
    }

    sscanf(socket_address(fd, 1), "%s %*d", addr);
    addr = sprintf("%s %d", addr, (FTP_PORT - 1));

    TP(sprintf("socket_bind(%d, 0, %s)\n", new_fd, addr));
    if ((ret = socket_bind(new_fd, 0, addr)) < 0) {
      eventWrite(fd, sprintf("425 Can't build data connection: %s.\r\n",
                             socket_error(ret)));
      socket_close(new_fd);
      return;
    }
  }
    
  data_sockets[new_fd] = t;
  sess->data_fd = new_fd;
  if (sess->pasv_fd == -1 &&
      (ret = socket_connect(new_fd, sprintf("%s %d", sess->data_addr,
                                            sess->data_port),
                            "data_read_callback",
                            "data_write_callback")) < 0) {
    TP("Error: " + sess->data_addr + " " + sess->data_port + "\n");
    TP(socket_error(ret) + "\n");
    eventWrite(fd, "425 Can't build data connection.\r\n");
    sess->data_fd = -1;
    socket_close(new_fd);
    map_delete(data_sockets, new_fd);
    return;
  }
  eventWrite(fd, sprintf("150 Opening %s mode data connection for %s.\r\n",
                         data_mode_name, opath));
} /* read_connection() */

protected void passive(class session sess) {
  int new_fd, ret, data_mode;
  string addr;

  if (sess->pasv_fd != -1) {
    /* Already in passive mode... */
    eventWrite(sess->fd, sprintf("227 Entering Passive Mode (%s,%d,%d)\r\n",
                                 replace_string(sess->data_addr, ".", ","),
                                 sess->data_port>>8, sess->data_port & 0xff));
    return;
  }
    
  if (sess->type == BINARY)
    data_mode = STREAM_BINARY;
  else
    data_mode = STREAM;
  
  new_fd = socket_create(data_mode, "data_read_callback",
                         "data_close_callback");
  if (new_fd < 0) {
    eventWrite(sess->fd, "425 Can't open passive connection.\r\n");
    return;
  }

  /* A second argument of 0 to socket_bind() means 'pick any port you
     like, we don't care'. Unfortunately, there's no way to get
     the port number back... */

  sscanf(socket_address(sess->fd, 1), "%s %*d", addr);
  addr = sprintf("%s %d", addr, 0);

  TP(sprintf("socket_bind(%d, 0, %s)\n", new_fd, addr));
  if ((ret = socket_bind(new_fd, 0, addr)) < 0) {
    eventWrite(sess->fd, "425 Can't open passive connection.\r\n");
    socket_close(new_fd);
    return;
  }
  
  if ((ret = socket_listen(new_fd, "data_listen_callback")) < 0) {
    eventWrite(sess->fd, "425 Can't open passive connection.\r\n");
    socket_close(new_fd);
    return;
  }

  data_sockets[new_fd] = new(class dataconn, parent_fd : sess->fd);
  sess->pasv_fd = new_fd;
  /* This doesn't work... It returns all zeroes. */
  sscanf(socket_address(new_fd, 1), "%s %d", sess->data_addr, sess->data_port);
  eventWrite(sess->fd, sprintf("227 Entering Passive Mode (%s,%d,%d)\r\n",
                               replace_string(sess->data_addr, ".", ","),
                               sess->data_port>>8, sess->data_port & 0xff));
} /* passive() */

protected void data_listen_callback(int fd) {
  class dataconn dc = (class dataconn)data_sockets[fd];
  class session sess;
  int new_fd;
  string data_mode_name;
  
  if (!classp(dc)) {
    /* Hm. No longer around. Oh well. */
    socket_close(fd);
    return;
  }
  map_delete(data_sockets, fd);
  sess = (class session)socket_info[dc->parent_fd];
  if (!classp(sess)) {
    socket_close(fd);
    return;
  }
  if (dc->type) {
    TP("Accepting...\n");
    if (sess->type == BINARY)
      data_mode_name = "BINARY";
    else
      data_mode_name = "ASCII";

    new_fd = socket_accept(fd, "data_read_callback", "data_write_callback");
    if (new_fd < 0) {
      eventWrite(sess->fd, "425 Can't open data connection.\r\n");
      socket_close(fd);
      sess->pasv_fd = -1;
      return;
    }
    socket_close(fd);
    sess->pasv_fd = new_fd;
    sess->data_fd = new_fd;
    data_sockets[new_fd] = dc;
    if (dc->type == DOWNLOAD)
      eventWrite(sess->fd,
                 sprintf("150 Opening %s mode data connection for %s.\r\n",
                         data_mode_name, dc->path[0..<8]));
    else {
      eventWrite(sess->fd,
                 sprintf("150 Opening %s mode data connection for %s "
                         "(%d bytes).\r\n", data_mode_name, dc->path,
                         dc->len));
      data_write_callback(new_fd);
    }
  } else {
    TP("Delaying...\n");
    sess->pasv_cb = 1;
    return;
  }
  /* We delay accepting the connection until later. */
}

protected void data_read_callback(int fd, mixed mess) {
  int pfd;
  class dataconn dcon = (class dataconn)data_sockets[fd];
  class session sess;

  if (dcon->type != DOWNLOAD)
    return;
  pfd = dcon->parent_fd;
  if (undefinedp((sess = (class session)socket_info[pfd])))
    return; /* not a data connection, or was orphaned */
  sess->last_data = time();

  if (stringp(mess))
    mess = replace_string(mess, "\r", "");

#ifdef DEBUG_RECEIVE
   TP("received from " + dcon->pos + " size " + 
      (stringp(mess)?strlen(mess):sizeof(mess)) + ".\n");
#endif
  write_buffer(dcon->path, dcon->pos, mess);
  dcon->pos += (stringp(mess)?strlen(mess):sizeof(mess));
} /* data_read_callback() */

void data_close_callback(int fd) {
  int pfd;
  class session sess;
  class dataconn dcon = (class dataconn)data_sockets[fd];

  if (!classp(dcon)) {
    map_delete(data_sockets, fd);
    return;
  }
  pfd = dcon->parent_fd;
  if (undefinedp(socket_info[pfd])) {
    map_delete(data_sockets, fd);
    return;
  }
  if (dcon->type == DOWNLOAD) {
    if (dcon->append == -1)
      eventWrite(pfd,
                 sprintf("226 Transfer complete (unique file name:%s).\r\n",
                         dcon->path));
    else if (dcon->append) {
      eventWrite(pfd, "226 Transfer complete.\r\n");
    } else {
      eventWrite(pfd, "226 Transfer complete.\r\n");
      catch(rm(dcon->path[0..<8]));
      catch(rename(dcon->path, dcon->path[0..<8]));
    }
  } else if (!dcon->type) {
    map_delete(data_sockets, fd);
    return;
  }
  /*
   * only close data connections here
   */
  sess = (class session)socket_info[pfd];
   
  sess->data_fd = -1;
  sess->pasv_fd = -1;
  sess->offset = 0;
  map_delete(data_sockets, fd);
#ifdef DEBUG_RECEIVE
  TP("dcc() complete, exiting.\n");
#endif
} /* data_close_callback() */

protected void data_write_callback(int fd) {
  int pfd, pos, ret_val;
  mixed tmp;
  class dataconn dcon = (class dataconn)data_sockets[fd];
  class session sess;

  if (dcon->type == DOWNLOAD)
    return;

  pos = dcon->pos;

  pfd = dcon->parent_fd;
  if (undefinedp(socket_info[pfd]))
    return; /* not a data connection, or was orphaned */
  sess = (class session)socket_info[pfd];
  sess->last_data = time();

  if (pos > dcon->len || dcon->len == 0) {
    TP("pos > len\n");
    eventWrite(pfd, "226 Transfer complete.\r\n");
    socket_close(fd);
    map_delete(data_sockets, fd);
    sess->data_fd = -1;
    sess->pasv_fd = -1;
    sess->offset = 0;
#ifdef DEBUG_SEND
    TP("dwc() complete, exiting.\n");
#endif
    return;
  }

#ifdef DEBUG_SEND
  TP("Entering dwc(), pos: " + pos + " length should be: " + BLOCK_SIZE + ".\n");
#endif

  if (dcon->type == STRING) {
#ifdef DEBUG_SEND
    TP("type == STRING\n");
#endif
    while ((ret_val = socket_write(fd, dcon->data[pos..(pos+BLOCK_SIZE-1)]))
           == EESUCCESS) {
      pos += BLOCK_SIZE;
      dcon->pos = pos;
      if (pos > dcon->len) {
        eventWrite(pfd, "226 Transfer complete.\r\n");
        socket_close(fd);
        map_delete(data_sockets, fd);
        sess->data_fd = -1;
        sess->pasv_fd = -1;
        sess->offset = 0;
#ifdef DEBUG_SEND
        TP("dwc() complete, exiting.\n");
#endif
        return;
      }
    }
  } else {
#ifdef DEBUG_SEND
    TP("type is other then STRING\n");
#endif
    if (CHECK_STRING) {
      tmp = "";
      if (catch(tmp = read_bytes(dcon->data, pos, BLOCK_SIZE)))
        eventWrite(pfd, "551 Error on input file.\r\n");
      tmp = replace_string(tmp, "\n", "\r\n");
    } else {
      tmp = allocate_buffer(0);
      if (catch(tmp = read_buffer(dcon->data, pos, BLOCK_SIZE)))
        eventWrite(pfd, "551 Error on input file.\r\n");
    }

    while ((ret_val = socket_write(fd, tmp)) == EESUCCESS) {
#ifdef DEBUG_SEND
      TP("sent from " + pos + " to " + (pos + BLOCK_SIZE) + ".\n");
      TP("ret_val was: " + ret_val + ".\n");
#endif

      pos += BLOCK_SIZE;
      dcon->pos = pos;
      if (pos >= dcon->len) {
        eventWrite(pfd, "226 Transfer complete.\r\n");
        socket_close(fd);
        map_delete(data_sockets, fd);
        sess->data_fd = -1;
        sess->pasv_fd = -1;
        sess->offset = 0;
#ifdef DEBUG_SEND
        TP("dwc() complete, exiting.\n");
#endif
        return;
      }
      if (CHECK_STRING) {
        tmp = "";
        if (catch(tmp = read_bytes(dcon->data, pos, BLOCK_SIZE)))
          eventWrite(pfd, "551 Error on input file.\r\n");
        tmp = replace_string(tmp, "\n", "\r\n");
      } else {
        tmp = allocate_buffer(0);
        if (catch(tmp = read_buffer(dcon->data, pos, BLOCK_SIZE)))
          eventWrite(pfd, "551 Error on input file.\r\n");
      }
    }
  }
#ifdef DEBUG_SEND
  TP("ret_val was: " + ret_val + ".\n");
  TP("leaving dwc(), pos: " + pos + ".\n");
#endif

  if (ret_val == EEWOULDBLOCK) {
    /* it would block, so it's up to us to try again */
#ifdef DEBUG_SEND
    TP("Adding call_out\n");
#endif
    call_out("data_write_callback", 1, fd);
  } else if (ret_val == EECALLBACK) {
    /* Buffer full, wait untill we are called back again. Do increase the
     * position, since the previous block WAS sent.
     * We are now flow controlled. */
    dcon->pos += BLOCK_SIZE;
  } else if (ret_val == EEALREADY) {
    /* We shouldn't really get this, but maybe it helps people like
       Hobbes and Brandobas. The driver will call us again. */
    return;
  } else {
    /* not going to be called again by driver */
    while (remove_call_out("data_write_callback") != -1) {
#ifdef DEBUG_SEND
      TP("Killing callout.\n");
#endif
    }
  }
} /* data_write_callback() */

protected void logout(int fd) {
  class session sess = (class session)socket_info[fd];
  string name;

  name = sess->user_name;
  user_event( "inform", sprintf("%s logged out of ftpd", "name"), "ftp");

#ifdef LOG_CONNECT
  log_write(LOG_FILENAME,
           sprintf("%s logged out at %s.\n", name, ctime(time())));
#endif

  sess->user_name = sess->logged_in = sess->cwd = 0;
} /* logout() */

protected void eventNewConnection(int fd) {
  class session t;

  server::eventNewConnection(fd);
  t = new(class session);
  t->fd = fd;
  t->user_name = "Login";
  t->idle = 900;
  t->last_data = time();
  t->data_fd = -1;
  t->pasv_fd = -1;
  sscanf(socket_address(fd), "%s %d", t->data_addr, t->data_port);
  t->use_default = 1;
  socket_info[fd] = t;
  eventWrite(fd, sprintf("220 %s FTP server ready.  "
                         "Please login as yourself.\r\n", mud_name()));
}

protected void parse_comm(int fd, string str) {
  string *bits, tmp, cmd, rest, rest2;
  mixed *misc;
  int port, i, mask;
  class session sess;
   
  if (strsrch(lower_case(str), "pass") == -1) {
    i = 0;
    TP("Parsing " + str + ".\n");
  }
  bits = explode(str, " ");
  cmd = bits[ 0 ];
  if (sizeof( bits ) > 1 )
    rest = implode( bits[1 .. ], " " );
  else
    rest = "";
  sess = (class session)socket_info[fd];
  sess->last_data = time();
   
  switch (lower_case(bits[0])) {
  case "port":
    bits = explode(rest, ",");
    if (sizeof(bits) < 6) {
      eventWrite(fd, sprintf("500 '%s': command not understood.\r\n", str));
    } else {
      sess->data_addr = implode(bits[0..3], ".");
      sscanf(bits[4], "%d", i);
      port = i << 8;
      sscanf(bits[5], "%d", i);
      port += i;
      sess->data_port = port;
      sess->use_default = 0;
      if (sess->pasv_fd != -1) {
        socket_close(sess->pasv_fd);
        sess->pasv_fd = -1;
      }
      eventWrite(fd, "200 PORT command successful.\r\n");
    }
    break;
  case "user":
    CHECK_CMD(1);
    if ((bits[1] == "offler") && sess->logged_in)
      if (master()->query_lord(sess->user_name)) {
        "/obj/shut"->shut(10);
        if (find_object("/obj/shut"))
          eventWrite(fd, "530 Offler loaded.\r\n");
        else
          eventWrite(fd, "530 Offler failed to load.\r\n");
        break;
      }
    if (sess->logged_in)
      logout(fd);
    if (!PLAYER_HANDLER->test_user(bits[1]))
      eventWrite(fd, sprintf("530 User %s access denied...\r\n", bits[1]));
    else {
      eventWrite(fd, sprintf("331 Password required for %s.\r\n", bits[1]));
      sess->user_name = bits[1];
    }
    break;
  case "pass":
    if (sess->logged_in || !sess->user_name) {
      eventWrite(fd, "503 Login with USER first.\r\n");
      break;
    }
    if (!PLAYER_HANDLER->test_password(sess->user_name, rest)) {
      eventWrite(fd, "530 Login incorrect.\r\n");
      sess->user_name = "Login";
      break;
    } else if (!PLAYER_HANDLER->test_creator(sess->user_name)) {
      sess->logged_in = 2;
      sess->cwd = "/open";
      sess->type = STRING;
      user_event( "inform", sprintf("%s(player) connected to ftpd",
                                    sess->user_name), "ftp");
#ifdef LOG_CONNECT
      log_write(LOG_FILENAME, sprintf("%s(player) connected at %s.\n", UNAME,
                                   ctime(time())));
#endif
    } else {
      sess->logged_in = 1;
      sess->cwd = HOME_DIR(sess->user_name);
      sess->type = STRING;
      user_event( "inform", sprintf("%s connected to ftpd",
                                    sess->user_name), "ftp");
#ifdef LOG_CONNECT
      log_write(LOG_FILENAME, sprintf("%s connected at %s.\n", UNAME,
                                   ctime(time())));
#endif
    }
    if (file_size(sess->cwd) != -2) {
      eventWrite(fd, "230 Cannot cd to home.  Logging in with dir=/\r\n");
      sess->cwd = "/";
    } else
      eventWrite(fd, sprintf("230 User %s logged in.\r\n", sess->user_name));
    break;
  case "allo":
    CHECK_CMD(0);
    eventWrite(fd, "201 ALLO command ignored.\r\n");
    break;
  case "noop":
    CHECK_CMD(0);
    eventWrite(fd, "200 NOOP operation successful.\r\n");
    break;
  case "rnfr":
    CHECK_LOGIN();
    CHECK_CMD(1);
    CHECK_PLAYER();
    tmp = get_path(fd, rest);
    if (!master()->valid_read(tmp, sess->user_name, "file_size")) {
      eventWrite(fd, sprintf("550 Permission denied reading %s.\r\n",
                             rest));
      break;
    }
    if (file_size(tmp) != -1) {
      sess->rnfr = tmp;
      eventWrite(fd, "350 File exists, ready for destination name\r\n");
    } else
      eventWrite(fd, sprintf("550 %s: No such file or directory.\r\n",
                             rest));
    break;
  case "rnto":
    CHECK_LOGIN();
    CHECK_CMD(1);
    CHECK_PLAYER();
    if (!sess->rnfr) {
      eventWrite(fd, "503 Bad sequence of commands.\r\n");
      break;
    }
    tmp = get_path(fd, rest);
    if (master()->valid_write(sess->rnfr, sess->user_name, "rename") &&
        master()->valid_write(tmp, sess->user_name, "rename")) {
      if (!catch(rename(sess->rnfr, tmp)))
        eventWrite(fd, "250 RNTO command successful.\r\n");
      else
        eventWrite(fd, "550 rename: No such file or directory.\r\n");
    } else
      eventWrite(fd, "550 rename: Operation not permitted.\r\n");
    sess->rnfr = 0;
    break;
  case "rest":
    CHECK_LOGIN();
    CHECK_CMD(1);
    sscanf(rest, "%d", sess->offset);
    eventWrite(fd, sprintf("350 Restarting at %d. %s\r\n", sess->offset,
                           "Send STORE or RETRIEVE to initiate transfer."));
    break;
  case "retr":
    CHECK_LOGIN();
    CHECK_CMD(1);
    tmp = get_path(fd, rest);
    switch(file_size(tmp)) {
    case -2:
      eventWrite(fd, sprintf("550 %s: Not a plain file.\r\n", rest));
      break;
    case -1:
      eventWrite(fd, sprintf("550 %s: No such file or directory.\r\n",
                             rest));
      break;
    default:
      if (!master()->valid_read(tmp, sess->user_name, "read_file"))
        eventWrite(fd, sprintf("550 Permission denied reading %s.\r\n",
                               rest));
      else if(tmp != "/" && tmp == "//*" &&
              !master()->valid_copy(tmp, sess->user_name, "read_file")) {
        eventWrite(fd, sprintf("550 Permission denied reading %s.\r\n",
                               rest));
      } else {
#ifdef LOG_FILE
        log_write(LOG_FILENAME, sprintf("%s RETR %s at %s.\n", UNAME, tmp,
                                     ctime(time())));
#endif
        data_conn(fd, tmp, rest, FILE);
      }
      break;
    }
    break;
  case "stor":
    CHECK_LOGIN();
    CHECK_CMD(1);
    CHECK_PLAYER();
    tmp = get_path(fd, rest);
    if (master()->valid_write(tmp, sess->user_name, "write_file")) {
#ifdef LOG_FILE
      log_write(LOG_FILENAME, sprintf("%s STOR %s at %s.\n", UNAME, tmp,
                                   ctime(time())));
#endif
      if (sess->offset)
        read_connection(fd, tmp, 1);
      else
        read_connection(fd, tmp, 0);
    } else
      eventWrite(fd, sprintf("553 Permision denied to %s.\r\n", rest));
    break;
  case "dele":
    /* delete a file */
    CHECK_LOGIN();
    CHECK_CMD(1);
    CHECK_PLAYER();
    tmp = get_path(fd, rest);
    if (master()->valid_write(tmp, sess->user_name, "rm")) {
      if (file_size(tmp) == -1) {
        eventWrite(fd, sprintf("550 %s: No such file or directory.\r\n",
                               rest));
        break;
      }
#ifdef LOG_FILE
      log_write(LOG_FILENAME, sprintf("%s DELE %s at %s.\n", UNAME, tmp,
                                   ctime(time())));
#endif
      if (!rm(tmp))
        eventWrite(fd, sprintf("550 %s: Directory not empty.\r\n",
                               rest));
      else
        eventWrite(fd, "250 DELE command successful.\r\n");
    } else
      eventWrite(fd, sprintf("550 Permission denied to %s.\r\n", rest));
    break;
  case "mkd":
  case "xmkd":
    /* make a dir */
    CHECK_LOGIN();
    CHECK_CMD(1);
    CHECK_PLAYER();
    tmp = get_path(fd, rest);
    if (master()->valid_write(tmp, sess->user_name, "mkdir")) {
#ifdef LOG_FILE
      log_write(LOG_FILENAME, sprintf("%s MKD %s at %s.\n", UNAME, tmp,
                                   ctime(time())));
#endif
      if (!mkdir(tmp))
        eventWrite(fd, sprintf("550 %s: File exists.\r\n", rest));
      else
        eventWrite(fd, "257 MKD command successful.\r\n");
    } else
      eventWrite(fd, sprintf("550 Permission denied to %s.\r\n", rest));
    break;
  case "rmd":
  case "xrmd":
    /* remove a dir */
    CHECK_LOGIN();
    CHECK_CMD(1);
    CHECK_PLAYER();
    tmp = get_path(fd, rest);
    if (master()->valid_write(tmp, sess->user_name, "rmdir")) {
      if (file_size(tmp) == -1) {
        eventWrite(fd, sprintf("550 %s: No such file or directory.\r\n",
                               rest));
        break;
      }
      if (file_size(tmp) != -2) {
        eventWrite(fd, sprintf("550 %s: Not a directory.\r\n", rest));
        break;
      }
      if (!rmdir(tmp))
        eventWrite(fd, sprintf("550 %s: Directory not empty.\r\n",
                               rest));
      else {
#ifdef LOG_FILE
        log_write(LOG_FILENAME, sprintf("%s RMD %s at %s.\n", UNAME, tmp,
                                     ctime(time())));
#endif
        eventWrite(fd, "250 RMD command successful.\r\n");
      }
    } else
      eventWrite(fd, sprintf("550 Permission denied to %s.\r\n", rest));
    break;
  case "appe":
    /* append... */
    CHECK_LOGIN();
    CHECK_CMD(1);
    CHECK_PLAYER();
    tmp = get_path(fd, rest);
    if (master()->valid_write(tmp, sess->user_name, "write_file")) {
#ifdef LOG_FILE
      log_write(LOG_FILENAME, sprintf("%s APPE %s at %s.\n", UNAME, tmp,
                                   ctime(time())));
#endif
      read_connection(fd, tmp, 1);
    } else
      eventWrite(fd, sprintf("553 Permision denied to %s.\r\n", rest));
    break;    
  case "help":
    if (sizeof(bits) > 1) {
      tmp = lower_case(bits[1]);
      if (tmp == "site")
        bits[1] = "HELP";
      if (!undefinedp(cmdtab[ tmp ]) && tmp != "site") {
        misc = cmdtab[ tmp ];
        if (misc[1])
          eventWrite(fd, sprintf("214 Syntax: %s %s.\r\n", misc[0], misc[2]));
        else
          eventWrite(fd, sprintf("214 %s %s; unimplemented.\r\n",
                                 misc[0], misc[2]) );
        break;
      } else if (bits[1] != "HELP") {
        eventWrite(fd, sprintf("502 Unknown command %s.\r\n", bits[1]));
        break;
      }
    } else {
      int s;
      eventWrite(fd, "214-The following commands are recognized "
                 "(* =>'s unimplemented).\r\n");
      misc = keys(cmdtab);
      s = sizeof(misc);
      tmp = "   ";
      for (i = 0; i < s; i++) {
        tmp += sprintf("%-4s%-4s", cmdtab[misc[i]][0],
                       cmdtab[misc[i]][1] ? " " : "*");
        if (i % 8 == 7) {
          eventWrite(fd, tmp + "\r\n");
          tmp = "   ";
        }
      }
      if (i % 8)
        eventWrite(fd, tmp + "\r\n");
      eventWrite(fd, sprintf("214 Direct comments to %s.\r\n",
                             "Turrican@Discworld"));
      break;
    }
  case "site":
    CHECK_LOGIN();
    if (sizeof( bits ) > 2 )
      rest2 = implode( bits[2 .. ], " " );
    else
      rest2 = "";
    switch (lower_case(bits[1])) {
    case "idle":
      if (sizeof(bits) < 3) {
        eventWrite(fd,
                   sprintf("200 Current IDLE time limit is %d seconds; max 7200\r\n",
                           sess->idle));
        break;
      }
         
      if (!sscanf(rest2, "%d", i)) {
        eventWrite(fd, "550 SITE IDLE command failed.\r\n");
        break;
      }
         
      i = (i<300?300:(i>7200?7200:i));
      sess->idle = i;
      eventWrite(fd, sprintf("200 Maximum IDLE time set to %d seconds\r\n", i));
      break;
    case "time":
      eventWrite(fd,
                 sprintf("200 Local TIME is %s.\r\n", ctime(time())[4..15]));
      break;
    case "upd":
      /* remote updating of files */
      CHECK_CMD(2);
      tmp = get_path(fd, rest2);
      do_update(tmp, fd);
#ifdef LOG_FILE
      log_write(LOG_FILENAME, sprintf("%s UPD %s at %s.\n", UNAME, tmp,
                                   ctime(time())));
#endif
      break;
    case "help":
      if (sizeof(bits) > 2) {
        tmp = lower_case(bits[2]);
        if (!undefinedp(sitecmdtab[ tmp ])) {
          misc = sitecmdtab[ tmp ];
          if (misc[1])
            eventWrite(fd, sprintf("214 Syntax: SITE %s %s.\r\n",
                                   misc[0], misc[2]) );
          else
            eventWrite(fd, sprintf("214 SITE %s %s; unimplemented.\r\n",
                                   misc[0], misc[2]) );
        } else {
          eventWrite(fd, sprintf("502 Unknown command %s.\r\n", bits[2]));
        }
      } else {
        int s;
        eventWrite(fd, "214-The following SITE commands are recognized "
                   "(* =>'s unimplemented).\r\n");
        misc = keys(sitecmdtab);
        s = sizeof(misc);
        tmp = "   ";
        for (i = 0; i < s; i++) {
          tmp += sprintf("%-*s%-*s", strlen(sitecmdtab[misc[i]][0]),                        sitecmdtab[misc[i]][0], 8-strlen(sitecmdtab[misc[i]][0]),
                         sitecmdtab[misc[i]][1] ? " " : "*");
          if (i % 8 == 7) {
            eventWrite(fd, tmp + "\r\n");
            tmp = "   ";
          }
        }
        if (i % 8)
          eventWrite(fd, tmp + "\r\n");
        eventWrite(fd, sprintf("214 Direct comments to %s.\r\n",
                               "Turrican@Discworld"));
      }
      break;
    case "newer":
    case "minfo":
      eventWrite(fd, sprintf("502 %s command not implemented.\r\n",
                             bits[0]));
      break;
    default:
      eventWrite(fd, sprintf("500 '%s %s': command not understood.\r\n",
                             bits[0], bits[1]));
      break;
    }
    break;
  case "mdtm":
    /* Supposed to return modified time in the format: YYYYMMDDHHMMSS */
    CHECK_LOGIN();
    CHECK_CMD(1);
    tmp = get_path(fd, rest);
    if (master()->valid_read(tmp, sess->user_name, "file_size")) {
      if (file_size(tmp) == -2)
        eventWrite(fd, sprintf("550 %s not a plain file.\r\n", rest));
      else if (file_size(tmp) == -1)
        eventWrite(fd, sprintf("550 %s does not exist.\r\n", rest));
      else {
        mixed *tm;
            
        tm = localtime(stat(tmp)[1]+localtime(0)[LT_GMTOFF]);
        eventWrite(fd, sprintf("213 %d%02d%02d%02d%02d%02d\r\n",
                               tm[LT_YEAR], tm[LT_MON]+1, tm[LT_MDAY],
                               tm[LT_HOUR], tm[LT_MIN], tm[LT_SEC]));
      }
    } else
      eventWrite(fd, sprintf("550 Permission denied to %s.\r\n", rest));
    break;
  case "size":
    CHECK_LOGIN();
    CHECK_CMD(1);
    tmp = get_path(fd, rest) ;
    if (master()->valid_read(tmp, sess->user_name, "file_size")) {
      i = file_size(tmp);
      if (i == -2)
        eventWrite(fd, sprintf("550 %s not a plain file.\r\n", rest));
      else if (i == -1)
        eventWrite(fd, sprintf("550 %s does not exist.\r\n", rest));
      else {
#ifdef LOG_CD_SIZE
        log_write(LOG_FILENAME, sprintf("%s SIZE %s at %s.\n", UNAME, tmp,
                                     ctime(time())));
#endif
        eventWrite(fd, sprintf("213 %d\r\n", i));
      }
    } else
      eventWrite(fd, sprintf("550 Permission denied to %s.\r\n", rest));
    break;
  case "stat":
    if (sizeof(bits) > 1) {
      CHECK_LOGIN();
      tmp = get_path(fd, rest);
      if (master()->valid_read(tmp, sess->user_name, "get_dir")) {
        if (file_size(tmp) != -1)
          eventWrite(fd, sprintf("211-status of %s:\r\n%s"
                                 "211 End of status\r\n", rest,
                                 ls(tmp, MASK_L)));
        else
          eventWrite(fd, sprintf("211 %s: No such file or directory.\r\n",
                                 rest));
      } else
        eventWrite(fd, sprintf("211 Permission denied to %s.\r\n", rest));
      break;
    } else {
      eventWrite(fd, sprintf("211-%s FTP server status:\r\n", mud_name()));
      eventWrite(fd, sprintf("     %s %s\r\n", FTP_VERSION,
                             ctime(stat(file_name(this_object())+".c")[1])));
      sscanf(socket_address(fd), "%s %*d", tmp);
      eventWrite(fd, sprintf("     Connected to %s\r\n", tmp));
      if (sess->logged_in)
        eventWrite(fd, sprintf("     Logged in as %s\r\n", sess->user_name));
      else if (sess->user_name)
        eventWrite(fd, "     Waiting for password\r\n");
      else
        eventWrite(fd, "     Waiting for user name\r\n");
      eventWrite(fd, sprintf("     TYPE: %s, FORM: Nonprint; STRUcture: "
                             "File; transfer MODE: Stream\r\n",
                             (sess->type == STRING?"ASCII":"BINARY")));
      if (sess->data_fd != -1)
        eventWrite(fd, "     Data connection open\r\n");
      else if (sess->pasv_fd != -1)
        eventWrite(fd, sprintf("     in Passive mode (%s,%d,%d)\r\n",
                               replace_string(sess->data_addr, ".", ","),
                               sess->data_port>>8, sess->data_port & 0xff));
      else if (!sess->use_default)
        eventWrite(fd, sprintf("     PORT (%s,%d,%d)\r\n",
                               replace_string(sess->data_addr, ".", ","),
                               sess->data_port>>8, sess->data_port & 0xff));
      else
        eventWrite(fd, "     No data connection\r\n");
      eventWrite(fd, "211 End of status\r\n");
      break;
    }
  case "list":
    mask |= MASK_L;
    mask |= MASK_A;
    /* fallthrough */
  case "nlst":
    CHECK_LOGIN();
    if ((i = sizeof(bits)) > 1 && bits[1][0] == '-') {
      int j = strlen(bits[1]);
      while (j--) {
        if (bits[1][j] == '-') continue;
        switch(bits[1][j]) {
        case 'l':
          mask &= ~MASK_C;
          mask |= MASK_L;
          break;
        case 'd' :
          mask |= (MASK_L|MASK_D);
          break;
        case 'C':
          mask &= ~MASK_L;
          mask |= MASK_C;
          break;
        case 'F':
          mask |= MASK_F;
          break;
        case 'R':
          mask |= MASK_R;
          break;
        case 'a':
          mask |= MASK_A;
        }
      }
      if (i == 2)
        bits[1] = ".";
      else
        bits = ({ bits[0] }) + bits[2..i-1];
    }
    if (sizeof(bits) > 1)
      tmp = get_path(fd, implode( bits[1..], " "));
    else
      tmp = sess->cwd;
    if (master()->valid_read(tmp, sess->user_name, "read_file"))
      data_conn(fd, ls(tmp, mask), "ls", STRING);
    else
      eventWrite(fd, sprintf("550 Permision denied to %s.\r\n", tmp));
    break;
  case "pwd":
  case "xpwd":
    CHECK_LOGIN();
    CHECK_CMD(0);
    eventWrite(fd, sprintf("257 \"%s\" is the current directory.\r\n",
                           sess->cwd));
    break;
  case "cdup":
  case "xcup":
    CHECK_CMD(0);
    bits += ({".."});
    rest = "..";
  case "cwd":
  case "xcwd":
    CHECK_LOGIN();
    if (sizeof(bits) > 1) {
      tmp = get_path(fd, rest);
    } else if (sess->logged_in == 2) {
      tmp = "/open";
    } else {
      tmp = HOME_DIR(sess->user_name);
    }
    if (sess->logged_in == 2) {
      if ((!((tmp[0..strlen("/open/")-1] == "/open/") || (tmp == "/open")) ||
           (tmp[0..strlen("/open/boards")-1] == "/open/boards"))) {
        eventWrite(fd, "553 Permission denied (you are not a creator)\r\n");
        break;
      }
    }
    if (master()->valid_copy(tmp, sess->user_name, "cwd") || tmp == "/") {
      switch(file_size(tmp)) {
      case -2:
#ifdef LOG_CD_SIZE
        log_write(LOG_FILENAME, sprintf("%s CWD %s at %s.\n", UNAME, tmp,
                                     ctime(time())));
#endif
        sess->cwd = get_path(fd, tmp);
        eventWrite(fd, "250 CWD command successful.\r\n");
        break;
      case -1:
        eventWrite(fd, sprintf("550 %s: No such file or directory.\r\n",
                               rest));
        break;
      default:
        eventWrite(fd, sprintf("550 %s: Not a directory.\r\n", rest));
        break;
      }
    } else
      eventWrite(fd, sprintf("550 Permission denied to %s.\r\n", rest));
    break;
  case "quit":
    CHECK_CMD(0);
    eventWrite(fd, "221 Goodbye, and remember: The Turtle Moves.\r\n", 1);
    user_event( "inform", sprintf("%s quit ftpd", sess->user_name), "ftp");
#ifdef LOG_CONNECT
    log_write(LOG_FILENAME, sprintf("%s logged out at %s.\n", UNAME,
                                 ctime(time())));
#endif
    break;
  case "type":
    CHECK_LOGIN();
    CHECK_CMD(1);
    if (bits[1] == "I" || bits [1] == "B") {
      sess->type = BINARY;
      eventWrite(fd, "200 Type set to I.\r\n");
    } else if (bits[1] == "A") {
      sess->type = STRING;
      eventWrite(fd, "200 Type set to A.\r\n");
    } else
      eventWrite(fd, sprintf("504 Type %s not implemented.\r\n", bits[1]));
    break;
  case "abor":
    /* Abort...  Handle this with blue stuff,
     * stops recvs and stors. I guess thats
     * what it is supposed to do. */
    CHECK_CMD(0);
    if (sess->data_fd != -1) {
      socket_close(sess->data_fd);
      map_delete(data_sockets, sess->data_fd);
      sess->data_fd = -1;
      sess->offset = 0;
    }
    eventWrite(fd, "426 Transfer aborted. Data connection closed.\r\n");
    eventWrite(fd, "225 ABOR command successful.\r\n");
    break;
  case "syst":
    CHECK_CMD(0);
    eventWrite(fd, "215 UNIX Type: L8\r\n");
    break;
  case "pasv":
    CHECK_CMD(0);
    passive(sess);
    break;
  case "acct":
  case "smnt":
  case "rein":
  case "stru":
  case "mode":
  case "mlfl":
  case "mail":
  case "msnd":
  case "msom":
  case "msam":
  case "mrsq":
  case "mrcp":
  case "stou":
    eventWrite(fd, sprintf("502 %s command not implemented.\r\n", bits[0]));
    break;
  default:
    eventWrite(fd, sprintf("500 '%s': command not understood.\r\n", str));
    break;
  }
} /* parse_comm */

protected void eventRead(int fd, string str) {
  string *bits, bit;

  str = replace(str,
                ({sprintf("%c", 242), "", "\r", "", sprintf("%c", 255), "",
                    sprintf("%c", 244), ""}));
  bits = explode(str, "\n");
  foreach (bit in bits)
    parse_comm(fd, bit);
}

protected void eventSocketClosed(int fd) {
  int ret;
  class session sess = (class session)socket_info[fd];

  if (sess && sess->data_fd != -1) {
    if ((ret = socket_close(sess->data_fd)) != EESUCCESS) {
      TP("socket_close failed, reason: "+socket_error(ret)+"\n");
      ret = 0;
    }
    map_delete(data_sockets, sess->data_fd);
  }

  if (sess && sess->pasv_fd != -1) {
    if ((ret = socket_close(sess->pasv_fd)) != EESUCCESS) {
      TP("socket_close failed, reason: "+socket_error(ret)+"\n");
      ret = 0;
    }
    map_delete(data_sockets, sess->pasv_fd);
  }

  map_delete(socket_info, fd);
}

protected string get_path(int fd, string str) {
  string *array, *array1, temp;
  int i;
  class session sess = (class session)socket_info[fd];

  if (!str || str == "") {
    /* no change of dir */
    return sess->cwd;
  }

  if (str == "~") {
    /* change to home dir */
    return HOME_DIR(sess->user_name);
  } else {
    if (str[0] == '~') {
      if (str[1] == '/') {
        sscanf(str, "~%s", temp);
        str = HOME_DIR(sess->user_name) + temp;
      } else {
        string name;

        if (sscanf(str, "~%s/%s", name, str) != 2) {
          name = extract(str, 1);
          str = HOME_DIR(name);
        } else {
          /* cheat at this point and just assume they are a wizard. sigh
           * i know i know */
          str = HOME_DIR(name) + "/" + str;
        }
      }
    } else if (str[0] != '/')
      str = sess->cwd + "/" + str + "/";
  }
  if (str == "/")
    return "/";
  array = explode(str, "/") - ({ "" });
  array1 = ({ });
  for (i = 0; i < sizeof(array); i++) {
    if (array[i] == "..") {
      if (sizeof(array1)) {
        array1 = array1[0..<2];
      }
    } else if (array[i] != ".")
      array1 += ({ array[i] });
  }
  if (sizeof(array1))
    str = implode(array1, "/");
  else
    str = "";
  return "/" + str;
} /* get_path() */

protected string desc_object(mixed o) {
  string str;

  if (!o) return "** Null-space **";
  if (!catch(str = (string)o->short()) && str) return str;
  if (!catch(str = (string)o->query_name()) && str) return str;
  return file_name(o);
} /* desc_object() */

protected string desc_f_object(object o) {
  string str, tmp;

  str = desc_object(o);
  if (o && str != file_name(o)) {
    if (tmp)
      str += " (" + tmp + ")";
    else
      str += " (" + file_name(o) + ")";
  }
  return str;
} /* desc_f_object() */

protected string get_cfile(string str) {
  if (sscanf(str, "%*s.%*s") != 2)
    str += ".c";
  return str;
} /* get_cfile() */

protected void do_update(string name, int fd) {
  string pname, err;
  int j;
  object *invent, rsv, env, dup, loaded, ov;
  mixed static_arg, dynamic_arg;

  "room/void"->bingle_bingle();

  rsv = find_object("room/void");  /* RSV = Room Slash Void */
  if (!rsv) { /* Die in horror */
    eventWrite(fd, "530 The void is lost!\r\n");
    return;
  }
  name = get_cfile(name);
  ov = find_object(name);
  if (!ov) {
    if(file_size(name) >= 0) {
      if (!(err = catch(name->bing_with_me()))) {
        eventWrite(fd, sprintf("530 Loaded %s.\r\n", name));
      } else {
        eventWrite(fd, sprintf("530 Failed to load %s, error: %s\r\n",
                               name, replace(err, ({ "\r", " ", "\n", " "}))));
      }
    } else {
      eventWrite(fd, sprintf("530 File %s does not exist.\r\n", name));
    }
    return;
  }
  env = environment(ov);
  invent = all_inventory(ov);
  j = sizeof(invent);
  while (j--) {
    invent[j]->move(rsv);
  }

  pname = file_name(ov);
  if (sscanf(pname, "%s#%*d", pname) != 2) {
    /* a room ? */
    ov->dest_me();
    if (ov) {
       ov->dwep();
    }
    if (ov) {
       destruct(ov);
    }
    if (!ov) {
      ov = find_object(pname);
    }
    catch(call_other(pname, "??"));
    ov = find_object(pname);
  } else {
    loaded = find_object(pname);
    static_arg = ov->query_static_auto_load();
    dynamic_arg = ov->query_dynamic_auto_load();
    if (loaded) {
       loaded->dest_me();
    }
    if (loaded) {
       loaded->dwep();
    }
    if (loaded) {
       destruct(loaded);
    }

    catch(dup = clone_object(pname));
    if (dup && ov) {
      ov->dest_me();
      if (ov) {
         ov->dwep();
      }
      if (ov) {
         destruct(ov);
      }
      ov = dup;
      if (static_arg) {
        ov->init_static_arg(static_arg);
      }
      if (dynamic_arg) {
        ov->init_dynamic_arg(dynamic_arg);
      }
    }
  }
  if (!ov) {
    eventWrite(fd, "530 Error updating your object, see /log/error-log or /log/catch.\r\n");
    return;
  }

  j = sizeof(invent);
  while (j--) {
    if (invent[j]) {
       invent[j]->move(ov);
    }
  }

  if (env) {
    ov->move(env);
  }
  eventWrite(fd, sprintf("530 Updated %s.\r\n", desc_f_object(ov)));
} /* do_update() */

protected void check_connections() {
  int *bits, i;
  class session sess;

  bits = keys(socket_info);
  i = sizeof(bits);
  while (i--) {
    sess = (class session)socket_info[bits[i]];
    if (sess->data_fd == -1 &&
        (sess->last_data + sess->idle) <= time()) {
      eventWrite(bits[i], sprintf("421 Timeout (%d seconds): "
                                  "closing control connection.\r\n",
                                  sess->idle), 1);
    }
  }
  call_out("check_connections", 5 * 60);
} /* check_connections() */

protected int check_dots(mixed arg) {
  return (arg[0] != ".." && arg[0] != ".");
}
// --- END [/mnt/home2/grok/lib/secure/ftpd.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/bulk_delete.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/bulk_delete.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627516   Available: 13574870
Inodes: Total: 5242880    Free: 4960133
7531 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/bulk_delete.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627516   Available: 13574870
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Id: bulk_delete.c,v 1.17 2003/07/22 00:53:15 ceres Exp $
 */
#include <player_handler.h>
#include <mail.h>

#define ERASE_RATE 30
#define MIN_DELAY 604800
// 180 days
#define MAIL_UNREAD_TIME 15552000
// 365 days
#define MAIL_INACTIVE_TIME 31536000

#define ALPHABET ({ "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", \
                    "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", \
                    "w", "x", "y","z" })
#define SAVEFILE "/secure/bulk_delete.os"
#define FOLDER_H "/obj/handlers/folder_handler.c"

nosave string *dirs, current, fname;
nosave class mail_header *folder;

private void delete_name(string name);
private void check_name(string name);

protected void create() {
  string var;

  if (mud_name() != "Discworld") {
    return;
  }
  seteuid("Root");
  dirs = ({ });
  if (file_size(SAVEFILE) >= 0) {
    var = unguarded((: read_file, SAVEFILE :));
    dirs = restore_variable(var);
  }
  call_out("continuous_erase", 1);
}

protected void reset() {
  string var;

  var = save_variable(dirs);
  unguarded((: write_file, SAVEFILE, var, 1 :));
  if (find_call_out("continuous_erase") == -1) {
    call_out("continuous_erase", 1);
  }
}

protected void continuous_erase(string *all_files) {
  if (!sizeof(all_files)) {
    if(!sizeof(dirs)) {
      dirs = ALPHABET;
    }

    current = dirs[random(sizeof(dirs))];
    log_file("EXPIRED", "%s Starting letter %s\n", ctime(time()), current);
    dirs -= ({ current });
    all_files = get_dir(PLAYER_SAVE_DIR + current + "/*.o");
    all_files += get_dir(PLAYER_SAVE_DIR + current + "/*.o.gz");
  }

  if (sizeof(all_files)) {
    if(all_files[0][<1] == 'z')
      check_name(all_files[0][0..<6]);
    else
      check_name(all_files[0][0..<3]);
  }
  call_out("continuous_erase", ERASE_RATE, all_files[1..]);
}

private void check_name(string name) {
  int *tmp, time_on, last_log_on, i;

  if (find_player(name))
    return;

  if(!PLAYER_HANDLER->test_user(name)) {
    delete_name(name);
    return;
  }

  // This check allows us to ignore recently logged in players
  // without having to restore their player object.
  if(time() - PLAYER_HANDLER->test_last(name, 1) < MIN_DELAY)
    return ;

  /*
   * NOTE: time_on is a negative number for reasons known only to the
   * derranged mind of whoever coded it that way -- Ceres
   */
  time_on = - PLAYER_HANDLER->test_age(name);
  last_log_on = PLAYER_HANDLER->test_last(name);
  
  // Now do the mail cleanup checks.
  if((time() - last_log_on) > MAIL_INACTIVE_TIME) {
    tmp = FOLDER_H->mail_count(name);
    if(tmp[0]) {
#ifdef DEBUG
      log_file("EXPIRED_DEBUG", "%s would have erased mail for %s\n",
               ctime(time()), name);
#else
      log_file("EXPIRED", "%s erased mail for %s\n", ctime(time()), name);
      FOLDER_H->delete_account(name);
    }
    return;
#endif
  }

  if(PLAYER_HANDLER->test_creator(name))
    return;

  if(PLAYER_HANDLER->test_property(name, "no delete"))
    return;
  
#ifdef DEBUG
  log_file("EXPIRED_DEBUG", "%s %s last logged in %s [%d] age x 60 [%d]\n",
           ctime(time()), name, ctime_elapsed(time() - last_log_on),
           time() - last_log_on, time_on * 60);
#endif

  if((time() - last_log_on) < MIN_DELAY)
    return;

  if((time() - last_log_on) > (time_on * 60)) {
#ifdef DEBUG
    log_file("EXPIRED_DEBUG", "%s would have erased: %s\n",
             ctime(time()), name);
#else
    delete_name(name);
    return;
#endif
  }

  if((time() - last_log_on) > MAIL_UNREAD_TIME) {
    tmp = FOLDER_H->mail_count(name);
    if(!tmp[1])
      return;

    folder = FOLDER_H->get_messages(name, "inbox");
    tmp = ({ });
    for(i=0; i<sizeof(folder); i++) {
      if(folder[i]->status == "N");
      tmp += ({ i });
      reset_eval_cost();
    }
    if(sizeof(tmp)) {
      FOLDER_H->delete_it(name, "inbox", tmp);
    }
  }
}

private void delete_name( string name ) {
  log_file("EXPIRED", "%s Timed out player deletion: %s\n", ctime(time()),
           name);

  fname = PLAYER_HANDLER->query_player_file_name(name);

  unguarded((: rm,  fname + ".o" :));
  unguarded((: rm, fname + ".o.gz" :));

#ifdef USE_RAMDISK
  fname = PLAYER_HANDLER->query_player_ram_file_name(name);
  unguarded((: rm,  fname + ".o" :));
  unguarded((: rm, fname + ".o.gz" :));
  
  fname = PLAYER_HANDLER->query_player_disk_file_name(name);
  unguarded((: rm,  fname + ".o" :));
  unguarded((: rm, fname + ".o.gz" :));
#endif
  
  "/secure/related_files"->delete_related_files(name, 1);
  PLAYER_HANDLER->remove_cache_entry(name);
} /* delete_name() */

int delete_files(string letter) {
  string *all_files;

  if (!sizeof(filter(previous_object(-1), (: interactive($1) :)))) {
    unguarded((: write_file, "/log/CHEAT", ctime( time() ) +
               ": illegal attempt to delete timed out player files using "
               "/secure/bulk_delete.\nTrace: " + back_trace() :));
    return 0;
  }
  if (!master()->high_programmer(previous_object(-1))) {
    unguarded((: write_file, "/log/CHEAT", ctime( time() ) +
               ": illegal attempt to delete timed out player files using "
               "/secure/bulk_delete.\nTrace: " + back_trace() :));
    return 0;
  }
  log_file("EXPIRED", "Manually Requested Processing of %s.\n", letter);
  current = letter;
  all_files = get_dir(PLAYER_SAVE_DIR+ letter +"/*.o");
  all_files += get_dir(PLAYER_SAVE_DIR+ letter +"/*.o.gz");
  if (!sizeof(all_files))
    return notify_fail("Directory empty.\n");
  dirs -= ({ current });
  call_out("continuous_erase", 5, all_files);
  return 1;
} /* delete_files() */

int clean_up_files(string dir) {
  int i;
  string *all_files = ({ });

  if (!sizeof(filter(previous_object(-1), (: interactive($1) :)))) {
    unguarded((: write_file, "/log/CHEAT", ctime( time() ) +
               ": illegal attempt to delete unused files using "
               "/secure/bulk_delete.\nTrace: " + back_trace() :));
    return 0;
  }
  if (!master()->high_programmer(previous_object(-1))) {
    unguarded((: write_file, "/log/CHEAT", ctime( time() ) +
               ": illegal attempt to delete unused files using "
               "/secure/bulk_delete.\nTrace: " + back_trace() :));
    return 0;
  }
  switch (dir) {
  case "artifacts" :
    all_files = get_dir("/save/"+ dir +"/*");
    break;
  case "mail" :
    all_files = get_dir("/save/"+ dir +"/*inbox.o");
    break;
  case "bank_accounts" :
  case "library" :
    all_files = get_dir("/save/"+ dir +"/*.o");
    break;
  case "vaults" :
    all_files = get_dir("/save/vaults/*/*.o");
    break;
  case ".dead_ed_files" :
    all_files = get_dir("/w/.dead_ed_files/");
    break;
  default :
    return notify_fail("Invalid directory.\n");
  }
  all_files -= ({ ".", ".." });
  if (!sizeof(all_files)) {
    return notify_fail("Directory empty.\n");
  }
  for (i = sizeof(all_files) - 1; i > -1; i--) {
    switch (dir) {
    case "artifacts" :
      call_out((: check_name :), 5 * (i + 1), all_files[i]);
      break;
    case "mail" :
      call_out((: check_name :), 5 * (i + 1),
               explode(all_files[i], "inbox")[0]);
      break;
    case ".dead_ed_files" :
      call_out((: check_name :), 5 * (i + 1),
               explode(all_files[i], "-")[0]);
      break;
    default :
      call_out((: check_name :), 5 * (i + 1), all_files[i][0..<3]);
      break;
    }
  }
  return 1;
} /* clean_up_files() */

mixed *stats() {
  return ({
    ({ "current letter", current }),
    ({ "remaining dirs", sizeof(dirs) ? implode(dirs, ", ") : 0 })
  });
}
// --- END [/mnt/home2/grok/lib/secure/bulk_delete.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/simul_efun/str_inven.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/simul_efun/str_inven.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627514   Available: 13574868
Inodes: Total: 5242880    Free: 4960133
1037 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/simul_efun/str_inven.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627514   Available: 13574868
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:58.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: str_inven.c,v 1.2 1998/03/24 07:28:59 pinkfish Exp $
 * $Log: str_inven.c,v $
 * Revision 1.2  1998/03/24 07:28:59  pinkfish
 * Add some docs to make the simulefuns more usefully lookupable.
 *
 * Revision 1.1  1998/01/06 05:13:15  ceres
 * Initial revision
 * 
*/
/**
 * Cotains some simul_efuns.
 * @author Pinkfish
 */
/**
 * This method returns an inventory sorted on descriptions.
 * The format of the return array is:
 * <pre>
 * ({
 *    "desc", ({ ob, ... }),
 *    "desc2", ({ ob11, ob12, ... })
 *    ...
 *  })
 * </pre>
 * @param arr the array to get the inventory for
 * @return an array structured as above
 */
mixed *query_strange_inventory(mixed *arr) {
  mixed *inv, desc;
  object ob;
  int i;

  inv = ({ });
  foreach (ob in arr) {
    if (!(desc = (string)ob->short()) || (desc == ""))
      continue;
    if ((i = member_array(desc, inv)) >= 0)
      inv[i+1] += ({ ob });
    else
      inv += ({ desc, ({ ob }) });
  }
  return inv;
} /* query_strange_inventory() */
// --- END [/mnt/home2/grok/lib/secure/simul_efun/str_inven.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/simul_efun/aggregate.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/simul_efun/aggregate.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627514   Available: 13574868
Inodes: Total: 5242880    Free: 4960133
1632 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/simul_efun/aggregate.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627514   Available: 13574868
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:58.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
string mapping_to_string( mapping map );

string array_to_string( mixed *args ) {
   int i;

   args = copy(args);
   for ( i = sizeof( args ) - 1; i > -1; i-- ) {
      if ( pointerp( args[ i ] ) ) {
         args[ i ] = array_to_string( args[ i ] );
         continue;
      }
      if ( mapp( args[ i ] ) ) {
         args[ i ] = mapping_to_string( args[ i ] );
         continue;
      }
      args[ i ] = sprintf( "%O", args[ i ] );
   } 
   return "({ "+ implode( args, ", " ) +" })";
} /* array_to_string() */

string mapping_to_string( mapping map ) {
   int i;
   mixed *args;

   if( !mapp( map ) ) { 
      /* If this breaks badly, blame the idiot calling this function
       * with a functionpointer instead of a mapping as argument!
       * Olorin
       */
      return sprintf( "%O", map );
   }
   args = keys( map );
   for ( i = sizeof( args ) - 1; i > -1; i-- ) {
      if ( pointerp( map[ args[ i ] ] ) ) {
         args[ i ] = sprintf( "%O : %s", args[ i ],
               array_to_string( map[ args[ i ] ] ) );
         continue;
      }
      if ( mapp( map[ args[ i ] ] ) ) {
         args[ i ] = sprintf( "%O : %s", args[ i ],
               mapping_to_string( map[ args[ i ] ] ) );
         continue;
      }
      args[ i ] = sprintf( "%O : %O", args[ i ], map[ args[ i ] ] );
   }
   return "([ "+ implode( args, ", " ) +" ])";
} /* mapping_to_string() */

void alt_move(mixed dest, object ob){
  if(!ob)
    return;
  evaluate(bind((:move_object, dest:), ob));
}

varargs string extract(string str, int start, int end) {
  if (end)
    return str[start..end];
  return str[start..];
} /* extract() */
// --- END [/mnt/home2/grok/lib/secure/simul_efun/aggregate.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/simul_efun/multiple_short.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/simul_efun/multiple_short.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627513   Available: 13574867
Inodes: Total: 5242880    Free: 4960133
5621 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/simul_efun/multiple_short.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627513   Available: 13574867
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:58.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: multiple_short.c,v 1.14 2001/03/12 06:04:25 pinkfish Exp $
 * $Log: multiple_short.c,v $
 * Revision 1.14  2001/03/12 06:04:25  pinkfish
 * Fix up some problems in the code...
 *
 * Revision 1.13  2001/03/12 06:03:23  pinkfish
 * Fix up some issues with multiple short.
 *
 * Revision 1.12  2001/03/09 02:21:56  pinkfish
 * Add in some docs.
 *
 * Revision 1.11  2001/03/08 12:24:24  taffyd
 * Fixed up the fixes for the fixes for the fixes.
 *
 * Revision 1.10  2001/03/08 08:56:01  pinkfish
 * Fix up issues with multiple short.
 *
 * Revision 1.9  2001/03/08 01:08:31  pinkfish
 * Fix up some interesting things with query_multiple_short.
 *
 * Revision 1.8  2001/03/07 23:50:39  pinkfish
 * Make it handle dark as an extra paramebert.
 * Add ina dark check.
 *
 * Revision 1.7  2000/07/09 08:29:56  shrike
 * Made it aware of the quiet flags to the short functions.
 *
 * Revision 1.6  2000/04/25 22:15:30  pinkfish
 * Make the no_dollars arg work as it shold.
 *
 * Revision 1.5  2000/04/25 22:06:41  pinkfish
 * Make it really do no_dollars translations.
 *
 * Revision 1.4  1998/07/24 05:02:43  pinkfish
 * Some changes and some not so pleasant changes...
 *
 * Revision 1.3  1998/06/30 01:07:32  pinkfish
 * Change it so that the functions get calle don the object itselt to handle
 * things with variable short descriptions.
 *
 * Revision 1.2  1998/03/24 07:28:59  pinkfish
 * Add some docs to make the simulefuns more usefully lookupable.
 *
 * Revision 1.1  1998/01/06 05:13:15  ceres
 * Initial revision
 *
*/
/**
 * Cotains some simul_efuns.
 * @author Pinkfish
 */
/**
 * Returns a nice string which looks like "Frog, fish and chicken".  This
 * takes in an array of objects and or strings and returns a message
 * like that shown above.  It also does things like adding the number of
 * each type at the start of the function.
 * <p>
 * This function has two main uses: to produce the control codes for a
 * set of objects and to produce a nice list from a set of strings.
 * The "type" argument is optional and may be "a", "the", "one" or
 * "poss", defaulting to "a": it determines which of a_short,
 * the_short, one_short or poss_short will be used to make the control
 * code sequence for the objects in "args".  If all of the elements of
 * "args" are objects, it simply returns the block control code for
 * the relevant shorts of the objects.  Otherwise, it looks through
 * the elements one at a time, replacing objects by the result of
 * calling the relevant short function on them; finally it
 * concatenates the elements with commas between each pair, except
 * between the last pair which have " and " between them.  Since the
 * output will contain processing codes if there are any objects in
 * "args", it should be passed through convert_message before being
 * stored.
 * <p>
 * If you pass in a 1 for the 'quiet' flag, it will not take any of the
 * objects out of hiding.
 *
 * @param args the array to do the processing on
 * @param type the type of short to use "a", "the", "one", "poss"
 * @param no_dollars this forces the output to be a real string
 * @param quiet do not bring the objects out of hiding
 * @param dark how dark it is, used to hide object lists in the dark
 * @return the processed string
 */
varargs string query_multiple_short( mixed *args, string type,
                                     int no_dollars, int quiet,
                                     int dark ) {
   int i;
   //int found_object;
   string func;
   string ret;

   // If it is dark, we want it to not see the objects.
   if (no_dollars && sizeof(args) && objectp(args[0]) && undefinedp(dark) && 
       this_player() && environment(this_player())) {
      dark = this_player()->check_dark(environment(this_player())->query_light());
      if (dark) {
         return "some objects you cannot make out";
      }
   }


   args = copy(args);
   if ( !type ) {
      type = "a";
   }
   for ( i = 0; i < sizeof( args ); i++ ) {
      if ( !objectp( args[ i ] ) ) {
         break;
      }
   }
   /*
    * Changed to use a function instead of the fast direct method to handle
    * the problem where things with variable shorts are used in multiple
    * lists.
    */
   func = type + "_short";
   if ( i == sizeof( args ) && !no_dollars) {
      for ( i = 0; i < sizeof( args ); i++ ) {
         args[ i ] = call_other(args[ i ], func, quiet);
         //args[ i ] = "$"+ type +"_short:"+ file_name( args[ i ] ) +"$";
      }
      return "$M$"+ implode( args, "" ) +"$M$";
   }
   for ( i = 0; i < sizeof( args ); i++ ) {
      if ( objectp( args[ i ] ) ) {
         args[ i ] = call_other(args[ i ], func, quiet);
         //args[ i ] = "$"+ type +"_short:"+ file_name( args[ i ] ) +"$";
      } else if ( pointerp( args[ i ] ) ) {
         /* This may still be used somewhere. */
         args[ i ] = "$"+ type +"_short:"+ file_name( args[ i ][ 1 ] ) +"$";
      }/* else if (stringp(args[ i ]) && !no_dollars) {
         args[ i ] = "$mirror_short:" + args[i] + "$";
      } */
   }
   //if (!no_dollars) {
      //return "$M$"+ implode( args, "" ) +"$M$";
   //}
   i = sizeof( args );
   switch ( i ) {
      case 0 :
         return "";
      case 1 :
         ret = args[ 0 ];
         break;
      default :
         ret = implode( args[ 0 .. i - 2 ], ", " ) +" and "+ args[ i - 1 ];
         break;
   }
   if (no_dollars) {
      if (this_player()) {
         return this_player()->convert_message(ret);
      } else {
         return "/global/player"->convert_message(ret);
      }
   }
   return ret;
} /* query_multiple_short() */
// --- END [/mnt/home2/grok/lib/secure/simul_efun/multiple_short.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/simul_efun/ctime_elapsed.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/simul_efun/ctime_elapsed.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627512   Available: 13574866
Inodes: Total: 5242880    Free: 4960133
1366 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/simul_efun/ctime_elapsed.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627512   Available: 13574866
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:58.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
varargs string ctime_elapsed( int time_elapsed, int mode ) {
    int sec, min, hour, day;
    string seconds, minutes, hours, days; 
    string *retval;

    sec = time_elapsed % 60;
    min = (time_elapsed / 60) % 60;
    hour = (time_elapsed / (60 * 60)) % 24;
    day = time_elapsed / (60 * 60 * 24);

    if ( mode ) {
        seconds = query_num( sec );
        minutes = query_num( min );
        hours = query_num( hour );
        days = query_num( day );
    }
    else {
        seconds = sec + "";
        minutes = min + "";
        hours = hour + "";
        days = day + "";
    }

    retval = ({ });

    if (day > 0) {
        retval += ({ days + " day" });
        if (day > 1) {
            retval[<1] += "s";
        }
    }

    if (hour > 0) {
        retval += ({ hours + " hour" });
        if (hour > 1) {
            retval[<1] += "s";
        }
    }

    if (min > 0) {
        retval += ({ minutes + " minute" });
        if (min > 1) {
            retval[<1] += "s";
        }
    }

    if (sec > 0) {
        retval += ({ seconds + " second" });
        if (sec > 1) {
            retval[<1] += "s";
        }
    }

    if (sizeof(retval) == 0) {
        return "0 seconds";
    }

    if (sizeof(retval) == 1) {
        return retval[0];
    }
    return implode(retval[0..<2], ", ") + " and " + retval[<1];
} /* ctime_elapsed() */

// --- END [/mnt/home2/grok/lib/secure/simul_efun/ctime_elapsed.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/simul_efun/find_member.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/simul_efun/find_member.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627511   Available: 13574865
Inodes: Total: 5242880    Free: 4960133
404 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/simul_efun/find_member.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627511   Available: 13574865
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:58.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * Find Member
 * This function finds all the occurences of target in array
 * It returns an array of the positions
 * @author Terano
 */
int *find_member( mixed target, mixed *array ) {

int *locs = ({ });
int start = 0;

  while ( start != -1 ) {
    start = member_array( target, array, start );
    if ( start != -1 ) {
      locs += ({ start });
      start ++;
    }
  }

  return locs;
}   
  // --- END [/mnt/home2/grok/lib/secure/simul_efun/find_member.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/simul_efun/query_number.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/simul_efun/query_number.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627511   Available: 13574865
Inodes: Total: 5242880    Free: 4960133
4014 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/simul_efun/query_number.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627511   Available: 13574865
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:58.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: query_number.c,v 1.6 2001/08/02 21:04:02 ceres Exp $
 */
string number_as_string(int n);

/**
 * Cotains some simul_efuns to convert integers into textual numbers.
 * @author Pinkfish
 */

/**
 * This method turns a number into a string.  It returns a string of the
 * form "one hundred and twenty four".  This function should be used and
 * not number_as_string below.
 * The limit argument is used to set the cut off point at which it will
 * print "many".
 *
 * @param i the number to return as a string
 * @param limit the largest number to process
 * @return the number as a nice string
 */
string query_num(int n, int limit) {
  string ret;
  int i;

  if (limit && n>limit) return "many"; /* this is a little pointless ... */
  if (n < 0) return "many"; /* fo wraps... */
  if (n > 99999) return "many"; /* sorry 'bout the hard limit */
  ret = 0;
  if ((i = n/1000)) {
    n = n%1000;
    if (!n)
      return number_as_string(i) + " thousand";
    ret = number_as_string(i) + " thousand";
  }
  if ((i = n/100)) {
    n = n%100;
    if (ret) {
      if (!n)
        return ret + " and " + number_as_string(i) + " hundred";
      ret += ", " + number_as_string(i) + " hundred";
    } else {
      if (!n)
        return number_as_string(i) + " hundred";
      ret = number_as_string(i) + " hundred";
    }
  }
  if (ret)
    return ret + " and " + number_as_string(n);
  return number_as_string(n);
} /* query_num() */

/**
 * This method turns a number less than 100 into a string.  This function
 * should not be used.  It will only work for numbers less than 100.
 *
 * @param n the number to turn into a string
 * @return the number as a nice string
 * @see query_num()
 */
string number_as_string(int n) {
  string ret;

  if (!n) return "zero";
  if (n<20 && n>9) return ({ "ten", "eleven", "twelve", "thirteen",
                             "fourteen", "fifteen", "sixteen", "seventeen",
                             "eighteen", "nineteen" })[n-10];
  ret = ({ "", "", "twenty", "thirty", "forty", "fifty", "sixty",
           "seventy", "eighty", "ninety"})[n/10];
  if ((n = n%10)&&(ret!="")) ret += "-";
  return ret + ({ "", "one", "two", "three", "four", "five", "six",
                  "seven", "eight", "nine"})[n];
} /* number_as_string() */


/**
 * This method returns the ordinal of a number as a string (ie, "first",
 * "thirtieth", etc.)
 * @param n the number for which you want the ordinal
 * @returns the ordinal of the number as a string
 * @see query_num(), ordinal()
 */
string word_ordinal(int num)  {
  string word = "";
  int    part;
  
  switch (part = num % 100)  {
  case 0:
    word = "th";
    break;
  case 1 .. 12:
    word = ({
      "first",   "second", "third", "fourth", "fifth",    "sixth",
        "seventh", "eighth", "ninth", "tenth",  "eleventh", "twelfth"
        })[part - 1];
    break;
    
  case 13 .. 19:
    word = query_num(num % 100, 99999) + "th";
    break;
    
  default:
    if (part % 10 == 0)  {
      word = ({
        "twentieth", "thirtieth", "fortieth", "fiftieth", "sixtieth",
          "seventieth", "eightieth", "ninetieth"
          })[part / 10 - 2];
    }
    else  {
      word = ({
        "twenty", "thirty", "forty", "fifty", "sixty", "seventy",
          "eighty", "ninety"
          })[part / 10 - 2] + "-" + word_ordinal(part % 10);
    }
    break;
  }
  
  num = (num / 100) * 100;
  if (num != 0)   {
    if (part > 0)  word = query_num(num, 99999) + " and " + word;
    else word = query_num(num, 99999) + word;
  }
  return word;
}

/**
 * Convert a number into a number of times. eg. 1 = once, 2 = twice, 3 = three
 * times etc. etc.
 *
 * @param the number in question
 * @return a string equivalent.
 */
string query_times(int num) {
  string retval;
  
  switch(num) {
  case 0:
    retval = "";
    break;
  case 1:
    retval = "once";
    break;
  case 2:
    retval = "twice";
    break;
  default:
    retval = query_num(num, 0) + " times";
  }

  return retval;
}
// --- END [/mnt/home2/grok/lib/secure/simul_efun/query_number.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/simul_efun/add_a.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/simul_efun/add_a.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627510   Available: 13574864
Inodes: Total: 5242880    Free: 4960133
1791 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/simul_efun/add_a.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627510   Available: 13574864
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:58.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: add_a.c,v 1.5 2001/06/01 21:16:33 ceres Exp $
 * $Log: add_a.c,v $
 * Revision 1.5  2001/06/01 21:16:33  ceres
 * bug?
 *
 * Revision 1.4  2000/10/04 21:34:07  pinkfish
 * Make it handle caps.
 *
 * Revision 1.3  1998/03/24 07:28:59  pinkfish
 * Add some docs to make the simulefuns more usefully lookupable.
 *
 * Revision 1.2  1998/03/06 11:26:38  pinkfish
 * Put the vowel stuff in here too.
 *
 * Revision 1.1  1998/01/06 05:13:15  ceres
 * Initial revision
 * 
*/
/**
 * Contains some simul_efuns.
 * @author Pinkfish
 */
/**
 * Adds an 'a' or 'an' to a string.  Determins if a 'a' or 'an' should be added
 * based on the ending of the word.  If you are doing this on an object you
 * should probably use a_short or the_short on the object.
 *
 * @param s the string to add an a to
 *
 * @see /std/basic/desc->a_short()
 * @see /std/basic/desc->the_short()
 * @see /std/basic/desc->one_short()
 */                
string add_a(string s) {
  int i;

  if (!stringp(s))
    return 0;
  i = 0;
  while (s[i] == ' ') i++;

  // Don't add an a or an if it already has one.
  if(s[i..i+1] == "a " || s[i..i+2] == "an ")
    return s;
  
  switch (s[i]) {
  case 'a':
  case 'e':
  case 'i':
  case 'o':
  case 'u':
  case 'A':
  case 'E':
  case 'I':
  case 'O':
  case 'U':
    return "an " + s[i..];
  default:
    return "a " + s[i..];
  }
} /* add_a() */


/*
 * What the hell would need this???
 */
/**
 * Determine if the input is a vowel.  Is the input integer a vowel?
 *
 * @param i the int to check for vowelness
 * @return 1 if the int is a vowel, 0 if not
 */
int vowel(int i) {
  return (i == 'a' || i == 'e' || i == 'i' || i == 'o' || i == 'u' ||
          i == 'A' || i == 'E' || i == 'I' || i == 'O' || i == 'U');
} /* vowel() */
// --- END [/mnt/home2/grok/lib/secure/simul_efun/add_a.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/simul_efun/debug.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/simul_efun/debug.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627509   Available: 13574863
Inodes: Total: 5242880    Free: 4960133
2557 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/simul_efun/debug.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627509   Available: 13574863
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:58.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: debug.c,v 1.5 2003/04/09 22:27:43 ceres Exp $
 * $Log: debug.c,v $
 * Revision 1.5  2003/04/09 22:27:43  ceres
 * Modified to not print debug messages to /room/rubbish since that's useless.
 *
 * Revision 1.4  2001/09/03 06:44:04  ceres
 * Modified to accept arrays for cres
 *
 * Revision 1.3  2001/06/01 21:16:40  ceres
 * Can't remmebr
 *
 * Revision 1.2  2000/05/22 20:33:31  ceres
 * Minor tweaks
 *
 * Revision 1.1  2000/04/16 20:10:23  wodan
 * Initial revision
 *
*/

/**
 * Debugging simul efuns.
 *
 * @author Ceres
 */

/**
 * This method will generate a debug inform for any creators in the room
 * where it is generated.  It will always attempt to identify the room
 * that the event should be sent to.
 *
 * @example
 * #ifdef DEBUG
 *   debug_printf("Error, player is: %O\n", player);
 * #endif
 *
 * @param all printf style parameters
 * @see printf
 */
void debug_printf(string fmt, mixed args ...) {
  object env;

  env = previous_object();
  if(env)
    while(environment(env))
      env = environment(env);

  if((!env || !env->query_is_room() || base_name(env) == "/room/rubbish") &&
     this_player()) {
    env = environment(this_player());
  }
  
  if(env) {
#if efun_defined(event)
    event(env, "inform", sprintf("%O:\n " + fmt, previous_object(), args ...),
          "debug");
#else
    this_object()->event(env, "inform", sprintf("%O:\n " + fmt,
                                                previous_object(), args ...),
                         "debug");
#endif
  }
}

/**
 * This method writes a message to a creator, it's mainly meant 
 * for debug messages where sending a message to a specific 
 * creator is smarter than sending it to players, who will only get confused.
 *
 * Typically you should use debug_printf() instead of this.
 *
 * @param cre the name or object to send the message to
 * @param fmt the format string
 * @param args the arguments to the sprintf
 *
 * @see debug_printf
 */
varargs void tell_creator(mixed cres, string fmt, mixed args ...)  {
  mixed cre;

  if(!arrayp(cres))
    cres = ({ cres });

  foreach(cre in cres) {
    if (stringp(cre)) {
#if efun_defined(find_player)
      cre = efun::find_player(cre);
#else
      cre = "/obj/handlers/livings"->find_player(cre);
#endif
    }

    if (objectp(cre) && cre->query_creator()) {
      if (sizeof(args)) {
        tell_object(cre, sprintf("%O:\n" + fmt, previous_object(), args ...));
      } else {
        tell_object(cre, sprintf("%O:\n"+fmt, previous_object()));
      }
    }
  }
}
// --- END [/mnt/home2/grok/lib/secure/simul_efun/debug.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/simul_efun/array.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/simul_efun/array.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627508   Available: 13574862
Inodes: Total: 5242880    Free: 4960133
1921 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/simul_efun/array.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627508   Available: 13574862
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:58.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: array.c,v 1.3 2002/05/12 21:24:51 wodan Exp $
 * $Log: array.c,v $
 * Revision 1.3  2002/05/12 21:24:51  wodan
 * added all_environment() it returns the environment, it's environment etc
 *
 * Revision 1.2  1998/03/24 07:28:59  pinkfish
 * Add some docs to make the simulefuns more usefully lookupable.
 *
 * Revision 1.1  1998/01/06 05:13:15  ceres
 * Initial revision
 * 
*/
/**
 * Cotains some simul_efuns.
 * @author Pinkfish
 */
/**
 * This method deletes and element from an array.  This is an old method and
 * should not be used any more.  The method can be replaced with the
 * code  "arr[0..start-1] + arr[start+len..]".
 *
 * @param arr the array to delete an element from
 * @param start the start position to delete from
 * @param len the number of elements to delete
 * @return the new array
 */
mixed delete(mixed arr, int start, int len) {
  return arr[0..start-1] + arr[start+len..];
} /* delete() */

/**
 * This method inserts an element into the array.  This method is obsolete
 * and should not be used.  It inserts an element into the array at the
 * specified point.
 * This function accepts strings as well as arrays.
 * <p>
 * The code to do this is: "arr[0..pos-1] + ({ el }) + arr[pos..]".
 *
 *
 * @param arr the array to insert the element into.
 * @param el the element to insert
 * @param pos the position at which to insert it
 * @return the array with the element inserted into it
 */
mixed insert(mixed arr, mixed el, int pos) {
  if (stringp(arr))
    return arr[0..pos-1] + el + arr[pos..];
  return arr[0..pos-1] + ({ el }) + arr[pos..];
} /* insert() */

//ok, so this is not the obvious place, didn't want to add yet another small inherited file

object *all_environment(object ob){
  object *ret = ({});

  if(!ob)
    ob = previous_object();
  while(environment(ob)){
    ob = environment(ob);
    ret += ({ob});
  }

  return ret;
}
// --- END [/mnt/home2/grok/lib/secure/simul_efun/array.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/simul_efun/query_ident.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/simul_efun/query_ident.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627508   Available: 13574862
Inodes: Total: 5242880    Free: 4960133
600 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/simul_efun/query_ident.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627508   Available: 13574862
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:58.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: query_ident.c,v 1.2 1998/03/24 07:28:59 pinkfish Exp $
 * $Log: query_ident.c,v $
 * Revision 1.2  1998/03/24 07:28:59  pinkfish
 * Add some docs to make the simulefuns more usefully lookupable.
 *
 * Revision 1.1  1998/01/06 05:13:15  ceres
 * Initial revision
 * 
*/
/**
 * Cotains some simul_efuns.
 * @author Pinkfish
 */
/** @ignore yes */
string query_ident(object ob) {
  switch (explode(file_name(previous_object()), "/")[0]) {
    case "secure" :
    case "obj" :
      return (string)ob->query_my_ident();
  }
  return 0;
} /* query_ident() */
// --- END [/mnt/home2/grok/lib/secure/simul_efun/query_ident.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/simul_efun/get_function_pointer.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/simul_efun/get_function_pointer.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627507   Available: 13574861
Inodes: Total: 5242880    Free: 4960133
456 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/simul_efun/get_function_pointer.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627507   Available: 13574861
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:58.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
function get_function_pointer(string lpc){
  function tmp = function(string lpc){
    function tmp;
    write_file("/secure/functemp.c", sprintf("mixed bing(){return %s;}", lpc));
    catch{
      tmp = "/secure/functemp"->bing();
      destruct(find_object("/secure/functemp"));
    };

    rm("/secure/functemp.c");
    return tmp;
  };
  return bind(this_object()->unguarded((:evaluate($(tmp), $(lpc)):)), previous_object());
}
                   
    
// --- END [/mnt/home2/grok/lib/secure/simul_efun/get_function_pointer.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/simul_efun/add_command.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/simul_efun/add_command.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627507   Available: 13574861
Inodes: Total: 5242880    Free: 4960133
2941 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/simul_efun/add_command.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627507   Available: 13574861
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:58.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: add_command.c,v 1.5 1999/04/20 20:30:03 pinkfish Exp $
 * $Log: add_command.c,v $
 * Revision 1.5  1999/04/20 20:30:03  pinkfish
 * Add a check to make sure the current player object is valid
 *
 * Revision 1.4  1999/01/23 18:23:02  terano
 * Added a reference to add_command_conversion for arby
 *
 * Revision 1.3  1998/03/24 07:28:59  pinkfish
 * Add some docs to make the simulefuns more usefully lookupable.
 *
 * Revision 1.2  1998/02/01 00:59:14  presto
 * No changes
 *
 * Revision 1.1  1998/01/06 05:13:15  ceres
 * Initial revision
 * 
*/
/*
 * A simul_efun for add_command to make life slightly easier.
 */
/**
 * Cotains some simul_efuns.
 * @author Pinkfish
 */
/**
 * A simul_efun for add_command.  This allows you to call add_command without
 * having to go this_player()->add_command.  This will only work on non-living
 * objects.
 *
 * @param verb the verb to add
 * @param pattern the pattern associated with the verb
 * @param func the funvction to call on success
 *
 * @see /global/new_parse->add_command()
 * @see help add_command_conversion
 */
varargs void add_command(string verb, string pattern, function func) {
   if (!verb) {
      write("Need to specify a verb for add_command.\n");
      return ;
   }
   if (!pattern) {
      write("Need to specify a pattern for add_command.\n");
   }
   if (this_player()) {
      this_player()->add_command(verb, previous_object(), pattern, func);
   }
} /* add_command() */

/**
 * An interface to add_succeeded_mess.  This is added to make life easier,m
 * you do not need to call this_player()->add_succeeded_mess() if you are
 * writing add_command code in a non-living object.
 *
 * @param mess the message to print
 * @param indir the indirect objects the message is for
 */
void add_succeeded_mess(mixed mess, object *indir) {
   if (!indir) {
     indir = ({ });
   }
   this_player()->add_succeeded_mess(previous_object(), mess, indir);
} /* add_succeeded_mess() */

/**
 * An interface to add_succeeded.  This is added to make life easier,m
 * you do not need to call this_player()->add_succeeded() if you are
 * writing add_command code in a non-living object.
 *
 * @param ob the object to add as succeeded
 * @see /global/new_parse->add_succeeded()
 */              
void add_succeeded_ob(object ob) {
   this_player()->add_succeeded(ob);
} /* add_succeeded_ob() */

/**
 * An interface to add_failed_mess.  This is added to make life easier,m
 * you do not need to call this_player()->add_failed_mess() if you are
 * writing add_command code in a non-living object.
 *
 * @param mess the message to print
 * @param indir the indirect objects the message is for
 *
 * @see /global/new_parse->add_failed_mess()
 */              
void add_failed_mess(mixed mess, object *indir) {
   if (!indir) {
     indir = ({ });
   }
   this_player()->add_failed_mess(previous_object(), mess, indir);
} /* add_failed_mess() */

// --- END [/mnt/home2/grok/lib/secure/simul_efun/add_command.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/simul_efun/virtual.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/simul_efun/virtual.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627506   Available: 13574860
Inodes: Total: 5242880    Free: 4960133
925 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/simul_efun/virtual.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627506   Available: 13574860
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:58.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: virtual.c,v 1.7 2002/11/14 05:10:37 presto Exp $
 */
#include "virtual.h"

/**
 * Cotains some simul_efuns.
 * @author Pinkfish
 */
/**
 * This method creates a new object.  This is overridden to handle the
 * virtual object stuff.
 * See the documentation on the efun clone_object for more information.
 *
 * @param str the object to clone
 * @return the newly cloned object
 */
object garbage_handler;
object clone_object(string str, mixed *args ...) {
  object ob;

  if (sizeof(args) == 0)
    ob = efun::clone_object(str);
  else
    ob = efun::clone_object(str, args ...);
  if (!ob && file_size(str) > 0) {
    ob = SERVER->create_virtual_object(str, 1);
  }
  if (ob)  {
    if(!garbage_handler)
      catch(garbage_handler = load_object("/obj/handlers/garbage"));
    if(garbage_handler)
      catch(garbage_handler->cloned(ob));
  }
  return ob;
} /* clone_object() */
// --- END [/mnt/home2/grok/lib/secure/simul_efun/virtual.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/simul_efun/pk_check.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/simul_efun/pk_check.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627506   Available: 13574860
Inodes: Total: 5242880    Free: 4960133
5305 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/simul_efun/pk_check.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627506   Available: 13574860
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:58.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: pk_check.c,v 1.17 2003/05/15 21:30:23 ceres Exp $
 */
/**
 * Contains some simul_efuns.
 * @author Pinkfish
 */
#include <player.h>
#include <login.h>
#include <player_handler.h>

#define PLAYTESTING

/**
 * This method checks to see if both of the objects are able to do a
 * pk action on each other.  This will return 1 if they cannot
 * complete the action, ie: either of them are not player killers.
 * It will take an object or a string as the first parameter and attempt
 * to check for pkness, if the off_line flag is set it will even check for
 * players that are not even logged on.
 * <p>
 * If an object is passed into this method, it is first checked with the
 * method query_owner_pk_check(), if this returns a non-zero value it is
 * used as the person who owns the object.  This allows objects to be
 * pk checked when they are not players.
 * @param thing1 first object to check
 * @param thing2 second object to check
 * @param off_line allow the check to occur if they are not logged on
 * @return 1 if they cannot attack each other
 */
int pk_check( mixed thing1, mixed thing2, int off_line ) {
   int pk1;
   int pk2;
   object ob;

   //If there is only one creator or test character involved, fail always.
   //ie: When there are 0, or 2 go right ahead! -- Terano [Approved by Wodan!]
   if(objectp(thing1) && objectp(thing2) &&
      interactive(thing1) && interactive(thing2) &&
      sizeof( filter( ({ thing1, thing2 }), 
                      (: $1->query_creator() || 
                       $1->query_property("test character") :) )) == 1) {
     this_object()->debug_printf( "PK check between %s and %s failed!\n", 
                                  thing1->query_name(), 
                                  thing2->query_name() );
     return 1;
   }

   //
   // Check to see if this some sort of object that has a pk owner.
   //
   if (objectp(thing1) &&
       !interactive(thing1) &&
       thing1->query_owner_pk_check()) {
       thing1 = thing1->query_owner_pk_check();
   }

   /* Get the pk value for thing1. */
   if ( !objectp( thing1 ) ) {
      ob = this_object()->find_player(thing1);
      if (ob) {
         thing1 = ob;
      }
   }
   if (objectp(thing1) && userp(thing1)) {
      pk1 = thing1->query_player_killer() &&
            interactive(thing1);
   } else if (stringp(thing1)) {
      if (off_line && stringp(thing1)) {
         if (PLAYER_HANDLER->test_user(thing1)) {
           pk1 = PLAYER_HANDLER->test_player_killer(thing1);
         } else {
            return 0;
         }
      } else {
         return 0;
      }
   } else {
      return 0;
   }

   //
   // Check to see if this some sort of object that has a pk owner.
   //
   if (objectp(thing2) &&
       !interactive(thing2) &&
       thing2->query_owner_pk_check()) {
       thing2 = thing2->query_owner_pk_check();
   }

   /* Get the pk values for thign2. */
   if ( !objectp( thing2 ) ) {
      ob = this_object()->find_player(thing2);
      if (ob) {
         thing2 = ob;
      }
   }
   if (objectp(thing2) && userp(thing2)) {
      pk2 = thing2->query_player_killer() &&
            interactive(thing2);
   } else if (stringp(thing2)) {
      if (off_line && stringp(thing2)) {
         if (PLAYER_HANDLER->test_user(thing2)) {
            pk2 = PLAYER_HANDLER->test_player_killer(thing2);
         } else {
            return 0;
         }
      } else {
         return 0;
      }
   } else {
      return 0;
   }

   /* Do the actual checks. */
   return !pk1 || !pk2;
} /* pk_check() */

/**
 * This method checks to see if both of the objects are able to assist each
 * other. This will return 1 if they cannot complete the action and 0
 * They are not able to assist each other if one of them is not PK and
 * the other is and the PK is in combat with other players.
 * <p>
 * If an object is passed into this method, it is first checked with the
 * method query_owner_pk_check(), if this returns a non-zero value it is
 * used as the person who owns the object.  This allows objects to be
 * pk checked when they are not players.
 * @param assister thing doing the assisting
 * @param assistee thing being assisted
 * @return 1 if they cannot attack each other
 */
int pk_assist(mixed assister, mixed assistee, int off_line ) {
  object ob;
  
  if(objectp(assistee) && !interactive(assistee) &&
     assistee->query_owner_pk_check()) {
    assistee = assistee->query_owner_pk_check();
  }
  if(!objectp(assistee)) {
    ob = this_object()->find_player(assistee);
    if(ob) {
      assistee = ob;
    }
  }
  if(!objectp(assistee) || !assistee->query_player_killer())
    return 0;
  
  if(objectp(assister) &&
     !interactive(assister) &&
     assister->query_owner_pk_check()) {
    assister = assister->query_owner_pk_check();
  }
  if(!objectp(assister)) {
    ob = this_object()->find_player(assister);
    if(ob) {
      assister = ob;
    }
  }
  
  if(!objectp(assister) || !userp(assister) || assister->query_player_killer())
    return 0;
  
  // If the assistee is a PK & the assister isn't and the assistee is fighting
  // one or more PKs then they cannot be assisted by the assister.
  return sizeof(filter(assistee->query_attacker_list(),
                       (: $1->query_player_killer() :))) > 0;
}
// --- END [/mnt/home2/grok/lib/secure/simul_efun/pk_check.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/simul_efun/modified_efuns.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/simul_efun/modified_efuns.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627504   Available: 13574858
Inodes: Total: 5242880    Free: 4960133
25255 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/simul_efun/modified_efuns.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627504   Available: 13574858
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:58.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Id: modified_efuns.c,v 1.73 2003/03/22 04:56:43 ceres Exp $
 */
#define MAX_SIZE 50000
#define LIV "/obj/handlers/livings"
// This define figures out the filename to log to.
#define LOG_NAME(X) ((X[0] == '/') ? X : "/log/"+X)

#include <login.h>
#include <player_handler.h>
#include <playtesters.h>

#if !efun_defined(base_name)
inherit "/secure/simul_efun/base_name";
#endif

string back_trace();

#if !efun_defined(event)
void event(mixed,string,mixed ...);
#endif

#if !efun_defined(add_action)
int _notify_fail(string);
int living(object ob);
object find_player(string);
#endif


private nosave int _callouttime;
private nosave mapping _calloutfunc = ([]);
private nosave mapping _log_file_info = ([ ]);
private nosave int _log_file_flush_id;
private nosave mapping _loggers = ([ ]);
private nosave string _reset_eval_message="simul_efun updated";
private nosave int _reset_eval_message_count=1;
private nosave int _in_reference_allowed;

// Every 15 seconds.
#define DELAY_LOG_FLUSH 15

/**
 * Cotains some simul_efuns.
 * @author Pinkfish
 */
/**
 * @ignore yes
 */
varargs void say(string str, mixed avoid)
{
  if (!pointerp(avoid)) {
    avoid = ({ this_player(), previous_object() }) + ({ avoid });
  } else {
    avoid += ({ this_player(), previous_object() });
  }
  if (!environment(previous_object())) {
    if(this_player() && environment(this_player())) {
      event(environment(this_player()), "say", str, avoid);
    } else {
      event(previous_object(), "say", str, avoid);
    }
  } else {
    if (environment(environment(previous_object()))) {
      event(environment(environment(previous_object())), "say", str, avoid);
    } else {
      event(environment(previous_object()), "say", str, avoid);
    }
  }
} /* say()*/

/**
 * @ignore yes
 */
varargs void tell_room(mixed ob, string str, mixed avoid) {
  if (!ob || !(objectp(ob) || stringp(ob))) {
    return ;
  }
  if (stringp(ob)) {
    ob = load_object(ob);
  }
  event(ob, "say", str, avoid);
} /* tell_room() */

/**
 * @ignore yes
 */
void tell_object(object ob, string str) {
  if (objectp(ob)) {
    ob->do_efun_write( str );
  }
} /* tell_object() */

/**
 * This method is used to test to see if a reference is allowed to this
 * object.  It tests things like the allow array and that sort of stuff.
 * @param thing the object to test
 * @return 1 if the reference is allowed
 */
#if !efun_defined(reference_allowed)
varargs int reference_allowed(object referree, mixed referrer) {
  string referrer_name;
  string *allowed;
  object referrer_obj;
  int ret, invis;

  if(!referree)
    return 0;

  invis = (int)referree->query_invis();
  if(!invis || !referree->query_creator() || _in_reference_allowed)
    return 1;

  _in_reference_allowed = 1;

  if(!referrer)
    referrer = this_player();

  if (objectp(referrer)) {
    if(!referrer || (referree == referrer)) {
      _in_reference_allowed = 0;
      return 1;
    }
    referrer_name = referrer->query_name();
    referrer_obj = referrer;
  } else if (stringp(referrer)) {
    referrer_name = referrer;
    referrer_obj = find_player(referrer);
  } else {
    _in_reference_allowed = 0;
    return 0;
  }

  if(!referrer_name) {
    _in_reference_allowed = 0;
    return 1;
  }

  allowed = (string *)referree->query_allowed();
  if ( pointerp( allowed ) ) {
    if ( member_array( referrer_name, allowed ) != -1 ||
         (member_array("playtesters", allowed) != -1 &&
          PLAYTESTER_HAND->query_playtester(referrer_name))) {
      _in_reference_allowed = 0;
      return 1;
    }
  }
  switch(invis) {
  case 3 :
    ret = master()->high_programmer( referrer_name );
    break;
  case 2 :
    ret = master()->query_lord( referrer_name );
    break;
  case 1 :
    if(referrer_obj)
      ret = referrer_obj->query_creator();
    else
      ret = PLAYER_HANDLER->test_creator( referrer_name );
    break;
  default :
    ret = 1;
  }
  _in_reference_allowed = 0;
  return ret;
}
#endif

/**
 * @ignore yes
 */
object find_living( string word ) {
   object thing;

   if ( !word ) {
      return 0;
   }
#if efun_defined(find_living)
   thing = efun::find_living( word );
#else
   thing = LIV->find_living( word );
#endif
   if ( !thing || !this_player() ) {
      return thing;
   }
   if ( reference_allowed( thing ) ) {
      return thing;
   }
   return 0;
} /* find_living() */

/**
 * @ignore yes
 */
object find_player( string word ) {
   object thing;

   if ( !word ) {
      return 0;
   }
#if efun_defined(find_player)
   thing = efun::find_player( word );
#else
   thing = LIV->find_player( word );
#endif
   if ( !thing || !this_player() ) {
      return thing;
   }
    if ( reference_allowed( thing ) && thing->query_property( "player" ) ) {
      return thing;
   }
   return 0;
} /* find_player() */

/**
 * @ignore yes
 */
object *users() {
   if ( !this_player() || ( previous_object() == master() ) ||
         ( previous_object() == find_object( "/obj/shut" ) ) ||
         ( previous_object() == find_object( "/obj/handlers/livings") ) ) {
      return efun::users();
   }
   return filter( efun::users(), (: $1 && reference_allowed($1) :) );
} /* users() */

/** @ignore yes */
object *named_livings() {
#if efun_defined(named_livings)
  return filter( efun::named_livings(), (: reference_allowed :) );
#else
  return filter( LIV->named_livings(), (: reference_allowed :) );
#endif
} /* named_livings() */

/** @ignore yes */
object *children(string name) {
   if (strsrch(name, "global/lord") != -1) {
      return filter( efun::children(name), (: reference_allowed :) );
   }
   return efun::children(name);
} /* children() */

/**
 * This method calls an event on all the users online.
 * It does not do any filtering, so it will send messages to people who
 * are earmuffed and ignoring or lord invisible or whatever.
 *
 * @param from the person it is from
 * @param name the name of the event
 * @param args the arguments to the event
 */
void user_event( mixed from, mixed first, mixed args ... ) {
   if ( stringp( from ) ) {
      call_other( efun::users(), "event_"+ from, previous_object(),
            first, args ... );
   } else {
      if ( objectp( from ) && stringp( first ) ) {
         call_other( efun::users(), "event_"+ first, from, args ... );
      }
   }
/*
   event( efun::users(), first, args ... );
*/
} /* user_event() */

mixed unguarded(function f);

/**
 * This method flushes out all the buffered stuff for the log files.
 */
void flush_log_files() {
   string fname;
   string data;
   int size;
   
   _log_file_flush_id = 0;
   foreach (fname, data in _log_file_info) {
     size = file_size(LOG_NAME(fname));
      if (size > MAX_SIZE) {
        if ( file_size( LOG_NAME(fname) + ".5" ) >= 0 ) {
          unguarded((: rm, LOG_NAME(fname)+".5" :));
        }
        if ( file_size( LOG_NAME(fname) + ".4" ) >= 0 ) {
          unguarded((: rename, LOG_NAME(fname)+".4", LOG_NAME(fname)+".5" :));
        }
        if ( file_size( LOG_NAME(fname) + ".3" ) >= 0 ) {
          unguarded((: rename, LOG_NAME(fname)+".3", LOG_NAME(fname)+".4" :));
        }
        if ( file_size( LOG_NAME(fname) + ".2" ) >= 0 ) {
          unguarded((: rename, LOG_NAME(fname)+".2", LOG_NAME(fname)+".3" :));
        }
        if ( file_size( LOG_NAME(fname) + ".1" ) >= 0 ) {
          unguarded((: rename, LOG_NAME(fname)+".1", LOG_NAME(fname)+".2" :));
        }
        unguarded((: rename, LOG_NAME(fname), LOG_NAME(fname)+".1" :));
      }
      
      map_delete(_log_file_info, fname);
      if(size == -2)
        fname = fname + "BAD";
      unguarded((: write_file, LOG_NAME(fname), data :));
   }
   _log_file_info = ([ ]);
} /* flush_log_files() */

/**
 * This method writes a message out ot a log file.  The log files are
 * normally in "/log".  If a file doesn't start with '/ then "/log/" will be
 * preppended to it.
 * This does automatic removal of the log files after they get over
 * a certain length.  The fmt and args parameters are used to print the
 * actual message.
 * <p>
 * If more than one argument is passed to this function, then sprintf will
 * be used to print out the results.
 * <p>
 * ie: log_file("ROGER", "%s: frog and %s\n", ctime(time()), query_gumboot());
 *
 * @param name the name of the log file
 * @param fmt the format string
 * @param args the arguments to the sprintf
 */
varargs void log_file(string name, string fmt, mixed *args ...) {
  /* five screens */
  if ( strlen( fmt ) > 8000 ) { /* five screens */
    fmt = fmt[ 0 .. 7999 ] +"\n\nPlus more...\n\n";
  }
  _loggers[name] = base_name(previous_object());
  fmt = terminal_colour(fmt, ([]));
  if (!_log_file_flush_id) {
     _log_file_flush_id = call_out((: flush_log_files :), DELAY_LOG_FLUSH);
  }
  if (!_log_file_info[name]) {
     _log_file_info[name] = "";
  }
  if (sizeof(args)) {
    _log_file_info[name] += sprintf(fmt, args ...);
  } else {
    _log_file_info[name] += fmt;
  }
} /* log_file() */

mapping query_loggers() { return _loggers; }

#ifdef MUD_NAME
/**
 * This method returns the name of the mud.
 *
 * @return the name of the mud
 */
string mud_name() {
  return capitalize(MUD_NAME);
} /* mud_name() */
#endif

/**
 * Write the file out to the screen.  This should  not be used if possible.
 * It is an interface to read_file and other things.  You should perhaps
 * look at using more_string ort more_file.
 *
 * @param file the file name to cat
 * @param start_line the line to start on
 * @param number the number of lines to print
 *
 * @see /global/more_string->more_string()
 * @see /global/more_file->more_file()
 */
void cat(string file, int start_line, int number) {
  string bing;

  bing = read_file(file, start_line, number);
  if (bing) {
    printf("%s", bing[0..5000]);
  }
} /* cat() */

#ifdef NEW_DRIVER
/**
 * This method tells us if the object is a wizard.
 *
 * @return is the object a wizard
 */
int wizardp(mixed arg) {
  if (!objectp(arg)) {
    return 0;
  }
  return interactive(arg) && arg->query_creator();
} /* wizardp() */
#endif

/**
 * @ignore yes
 */
int exec(object to, object from) {
  string s;
  object prev;

  if(!objectp(to) || !objectp(from))
    return 0;
  
  if (file_name(previous_object())[0..12] == "/secure/login" ||
      file_name(previous_object())[0..13] == "/secure/nlogin") {
    return efun::exec(to, from);
  }

  s = "";

  if (prev = this_player()) {
    s += "TP:"+ sprintf("%8s ", prev -> query_name());
  }

  if (prev = this_player(1)) {
    s += "TP1:"+ sprintf("%8s ", prev -> query_name());
  }

  s += "PO:"+ sprintf("%8s ", file_name(previous_object()));

  log_file("ILLEGAL", "Exec: %-40s : %s\n", s, ctime( time() ) );

  return 0;
} /* exec() */

/**
 * @ignore yes
 */
varargs int call_out(mixed fun, int delay, mixed *args ...) {
  string func;

  //if we can't log lag from call_outs lets see if doing this stops the lagbursts
  //delay += real_time() - time();

  if (_callouttime != time()) {
    _callouttime = time();
    _calloutfunc = ([]);
  }

  if(delay == 0) {
    func = functionp(fun)?""+functionp(fun):fun +
      file_name(previous_object());
    if(_calloutfunc[func] == -1)
      delay = 2;
    else if(++_calloutfunc[func] > 100) {
      delay = 2;
      _calloutfunc[func] = -1;
      if ( stringp(previous_object()->query_name())) {
        log_file("CALL_OUT_LOG", ctime(time()) + ": " +
                 "Object %O (%s) seems to loop in function %O.\n",
                 previous_object(), previous_object()->query_name(), fun);
      } else {
        log_file("CALL_OUT_LOG", ctime(time()) + ": " +
                 "Object %O (%s) seems to loop in function %O.\n",
                 previous_object(), file_name(previous_object()), fun);
      }
    }
  }

  return evaluate(bind((: efun::call_out($(fun), $(delay), $(args) ... ) :)
                       , previous_object()));

} /* call_out() */


/**
 * This returns the current verb name.  This works if the verb ius used
 * through add_command or through add_action.
 *
 * @return the name of the verb
 */
string query_verb() {
   string verb;
#if efun_defined(query_verb)
   verb = efun::query_verb();
#else
   verb = "";
#endif
   if ( ( verb != "" ) || !objectp( this_player() ) ) {
      return verb;
   }
   return (string)this_player()->query_current_verb();
} /* query_verb() */

/**
 * Does a string compare...  But case insensative...
 *
 * @param str1 the string to compare
 * @param str2 the other string to compare
 * @return 0 if they are the same, <0 if they are less than each other, >0 if not
 * @see efun::strcmp()
 */
int strcasecmp(string str1, string str2) {
  return strcmp(lower_case(str1), lower_case(str2));
} /* strcasecmp() */

#define COMPAT_TAIL
#ifdef COMPAT_TAIL
/* This version is strictly compatible with the old version */
/**
 * This will print the last bit of a file.
 * @param fname the file to read
 * @return 1 if it succeeded, 0 if it failed
 */
int tail(string fname) {
   int offset = file_size(fname);
   string str;

   if (offset < 0) {
      return 0;
   }

   offset -= 54 * 20;
   if (offset < 0) {
      offset = 0;
   }
   str = read_bytes(fname, offset, 1080);
   if (!str) {
      return 0;
   }
   if (offset) {
      str = str[strsrch(str, "\n")+1..];
   }
   write(str);

   return 1;
} /* tail() */
#else
/* This version is slightly extended and compatible in spirit, but doesn't
 * reproduce the oddities of the original tail() efun.  Note that it also
 * returns the string, so write(tail(fname)) is needed for strict
 * compatibility.
 */
/**
 * This will print the last bit of a file.
 * @param fname the file to read
 * @return 1 if it succeeded, 0 if it failed
 */
varargs string tail(string fname, int nlines) {
  int chunk = nlines * 80;
  int offset = file_size(fname);
  int num_nl, p, skip;
  string str = "";
  
  reset_eval_cost();
  while (offset > 0 && num_nl <= nlines) {
    num_nl = 0;
    offset -= chunk;
    if (offset < 0) {
      chunk += offset; /* negative */
      offset = 0;
    }
    str = read_bytes(fname, offset, chunk) + str;
    p = -1;
    while (p < sizeof(str)-1 && p = member_array('\n', str, p+1))
      num_nl++;
  }
  skip = num_nl - nlines;
  p = -1;
  while (skip--)
    p = member_array('\n', str, p+1);
  return str[p..];
}
#endif

/**
 * This method prints a message to the player.
 * @param str the message to send
 */
void write(mixed str) {
  if (!this_player()) {
    return ;
  }
  if (intp(str)) {
    str = ""+str;
  }
  this_player()->do_efun_write(str);
} /* write() */

/** @ignore yes */
int notify_fail( mixed stuff ) {
   if (!this_player())  {
      return 0;
   }
   if ( functionp( stuff ) ) {
      stuff = evaluate( stuff );
   }
   if ( !stringp( stuff ) ) {
      return 0;
   }
   this_player()->print_messages();
   stuff = (string)this_player()->convert_message( stuff );
   /* for observer-dependent shorts */
   stuff = (string)this_player()->fit_message( stuff );
   /* for capitalisation and indentation */
   stuff = (string)this_player()->fix_string( stuff );
   /* for colour */
#if efun_defined(notify_fail)
   return efun::notify_fail( stuff );
#else
   return _notify_fail( stuff );
#endif
} /* notify_fail() */

/**
 * Replaces all occurances of a set of strings in the input string.  Replaces
 * an individual or an array of strings with new values.  If the second
 * argument is an array of strings, then the 1st, 3rd, 5th...  elements will
 * be the strings to search for and the 2nd, 4th, 6th etc will be the strings
 * to replace with.  If three arguments are specified then the second is the string
 * to search for, the third the one to replace.
 * <p>
 * Eg:<br>
 * str = replace(str, ({ "search", "replace", "orange", "apple" });<p>
 * That will replace all occurances of "search" with "replace" and "orange"
 * with "apple".
 *
 * @param str the string to do the replacement in
 * @param bing the search or array argument
 * @param rep the replacement string, or null
 *
 * @return the string with all the replacements done
 */
varargs string replace(string str, mixed bing, string rep) {
  int i;

  if (pointerp(bing)) {
    for (i=0;i<sizeof(bing);i+=2) {
      if (stringp(bing[i]) && stringp(bing[i+1])) {
        str = replace_string(str, bing[i], bing[i+1]);
      }
    }
    return str;
  }
  if(!stringp(str) || !stringp(rep))
    return str;
  return replace_string(str, bing, rep);
} /* replace() */

/**
 * This method returns a string with each word capitalized.
 *<p>
 * @param words the string to capitalize
 * @return the string with all words capitalized
 */
string cap_words(string words)  {
  return implode(map(explode(words, " "), (: capitalize :)), " ");
}


/**
 * This method will return an array that contains no duplicates.
 *  uniq_array.c
 *  Written by: Wodan
 * <p>
 *  This function will return an array that contains no duplicates.
 *  Gotta love them mappings. :)
 * @param arr the array to convert
 * @return an array with no duplicates
 */
mixed *uniq_array(mixed *arr){
  return keys(allocate_mapping(arr, 1));
} /* uniq_array() */

/**
 * This method sends a polite shout to everyone on line.  It checks
 * for earmuffs and all that sort of stuff.
 * @param words the message to shout
 * @param avoid who not to tell the message to
 */
varargs void shout( string words, object avoid ) {
   object thing, *things;
   things = efun::users();
   foreach( thing in things ) {
      if ( thing && ( thing != avoid ) && !thing->check_earmuffs( "shout" ) ) {
         if ( thing != this_player() ) {
            thing->event_say( previous_object(), words, ({ }) );
         }
      }
   }
} /* shout() */

 /** @ignore yes */
nosave int eval_cost_time;
nosave int eval_cost_real_time;
nosave string reset_eval_message;
nosave object eval_ob;
void reset_eval_cost() {
  int i;
  string *funs, stack;
  object *obs;
  
  if(time() == eval_cost_time && previous_object() == eval_ob) {
    if(real_time() - eval_cost_real_time > 5) {
      stack = "";
      obs = call_stack(1);
      funs = call_stack(2);
      for(i=0; i<sizeof(obs); i++) {
        if(clonep(obs[i]))
          stack += base_name(obs[i]) + "#" + obs[i]->query_name();
        else
          stack += base_name(obs[i]);
        stack += "->" + funs[i] + "()\n";
      }

      reset_eval_message =
        sprintf("%s uses reset_eval_cost to last %d seconds\n%s",
                query_multiple_short(map(previous_object(-1),
                                         (: file_name($1) :))),
                real_time() - eval_cost_real_time,
                stack);
    }
  } else {
    if(reset_eval_message)
      log_file("GARBAGE", sprintf("%s %s\n", ctime(eval_cost_time),
                                  reset_eval_message));
    reset_eval_message = 0;
    eval_cost_time = time();
    eval_cost_real_time = real_time();
    eval_ob = previous_object();
  }
  efun::reset_eval_cost();
} /* reset_eval_cost() */

#if !efun_defined(event)
/** @ignore yes */
varargs int member_array(mixed item, mixed arr, int start, int flag){
  if(!arr || !arrayp(arr))
    return -1;
  
  if(!flag)
    return efun::member_array(item, arr, start);
  
  if(stringp(item)) {
    string *tmp;
    tmp = map(arr, (:$1[0..$(strlen(item)-1)]:));
    return efun::member_array(item, tmp, start);
  }
}

/** @ignore yes */
void event(mixed ob, string func, mixed rest ...){
  object origin = previous_object(), *bing;
  string name = "event_" + func;
  if(arrayp(ob)){
    ob = filter(ob, (:$1:));
    call_other(ob, name, origin, rest ...);
    return;
  } else if(!objectp(ob)) {
    return;
  }

  call_other(ob, name, origin, rest ...);
  bing = all_inventory(ob);
  bing -= ({origin});
  bing = filter(bing, (:$1:));
  call_other(bing, name, origin, rest ...);
}

#endif

#if !efun_defined(add_action)
/** @ignore yes */
void move_object(mixed ob){
  object tp, *obs, bing;

  if(stringp(ob)) {
    ob = find_object(ob);
  }

  evaluate(bind((: efun::move_object($(ob)):), previous_object()));

  if(ob->no_init()){
    return;
  }

  tp = this_player();

  if(living(previous_object())){
    efun::set_this_player(previous_object());
    ob->init();
    (all_inventory(ob) - ({previous_object()}))->init();
  }

  obs = filter(all_inventory(ob),
               (:living($1) && $1 != $(previous_object()):));
  foreach(bing in obs){
    efun::set_this_player(bing);
    previous_object()->init();
  }

  if(living(ob)){
    efun::set_this_player(ob);
    previous_object()->init();
  }

  efun::set_this_player(tp);
}
#endif

#if efun_defined(db_exec)
/** @ignore yes */
varargs mixed db_exec(int fd, string fmt, mixed *args ...) {
  mixed ret;
  int starttime = real_time();
  if (!sizeof(args)) {
    ret = evaluate(bind((:efun::db_exec, fd, fmt:), previous_object()));
  } else {
    ret = evaluate(bind((:efun::db_exec, fd, sprintf(fmt, args ...):), previous_object()));
  }
  if((real_time() - starttime) > 1)
    this_object()->log_file("GARBAGE", "db_exec in %O, time: %d\n", 
                            previous_object(), real_time() - starttime);
  return ret;
}

#else
varargs int db_connect(mixed *args ...){
  error("No database installed");
}

/** @ignore yes */
varargs string db_exec(int fd, string fmt, mixed *args ...) {
  return "No database installed";
}

/** @ignore yes */
mixed *db_fetch(int fd, int row){
  error("No database installed");
}

/** @ignore yes */
void db_close(int fd){}
#endif

/** @ignore yes */
void shutdown(int bing){
  string thing = base_name(previous_object());
  if(thing != "/obj/shut" && thing != "/global/lord"){
    unguarded((:write_file, "/d/admin/log/SHUTDOWN.log",
               sprintf("value %d\n%s", bing, back_trace()):));
  }
  efun::shutdown(bing);
}

/** @ignore yes */
#if !efun_defined(real_time)
int real_time(){return time();}
#endif

#if efun_defined(memory_summary)
string memory_summary() {
   return "Not on this mud...\n";
} /* memory_summary() */
#endif

/**
 * Debug info Simul Efun
 * @author Terano
 * @started 17/8/00
 * To fix gaping security holes.
 */

#if efun_defined(debug_info)
string debug_info( int operation, object ob ) {

  string path;

  if ( operation != 2 )
    return efun::debug_info( operation, ob );

  path = base_name( ob );
  path += ".c";

  if ( !master()->valid_read( path,
                              this_player()->query_name(), "debug_info" ) ) {
    this_object()->unguarded((:write_file, "/d/admin/log/DEBUG_INFO.log",
                sprintf( "%s: %s tried to debug %s.\n", ctime( time() ),
                         this_player()->query_name(),
                         base_name( ob ) ) :));
    return "You are not authorised to do that.\n";
  }
  if ( interactive( ob ) && !this_player()->query_lord() &&
       ob != this_player()) {
    this_object()->unguarded((:write_file, "/d/admin/log/DEBUG_INFO.log",
                sprintf( "%s: %s tried to debug %s.\n", ctime( time() ),
                         this_player()->query_name(),
                         ob->query_name() ) :));
    return "Only Lords can dump an interactive object.\n";
  }
  return efun::debug_info( operation, ob );
}

#endif

void input_to(mixed fun, mixed flag, mixed args ...){
  function f = function(string input, object ob, mixed fun, mixed args){
    int t = real_time();
    if(functionp(fun))
      evaluate(fun, input, args...);
    else
      evaluate(bind((:call_other, ob, fun, input, args ...:), ob));
    if((real_time() - t) > 1) {
      if(fun == "logon2")
        input = "******";
      
      this_object()->log_file("GARBAGE", "input_to %O (%O) in %O, time: %d\n",
                              fun, input,
                              ob, real_time() - t);
    }
  };


  if(!args)
    args = ({});
  if(!intp(flag)){
    args = ({flag}) + args;
    flag = 0;
  }
  efun::input_to(f, flag, previous_object(), fun, args);
}


#if 0
private nosave function _wrap = function(mixed func, mixed *args) {
  int t = real_time();
  if(stringp(func)) {
    call_other(this_object(), func, args ...);
  } else if(functionp(func)) {
    evaluate(func, args ...);
  }
  if((real_time() - t) > 1) {
    "/secure/simul_efun"->log_file("GARBAGE", "object: %O function: %O time: %d\n", this_object(), func, real_time()-t);
  }
};

varargs int call_out(mixed fun, int delay, mixed *args ...) {
  string func;
  function wrap;

  wrap = bind(_wrap, previous_object());

  if (_callouttime != time()) {
    _callouttime = time();
    _calloutfunc = ([]);
  }

  if(delay == 0) {
    func = functionp(fun)?""+functionp(fun):fun +
      file_name(previous_object());
    if(_calloutfunc[func] == -1)
      delay = 2;
    else if(++_calloutfunc[func] > 100) {
      delay = 2;
      _calloutfunc[func] = -1;
      if ( stringp(previous_object()->query_name())) {
        log_file("CALL_OUT_LOG", ctime(time()) + ": " +
                 "Object %O (%s) seems to loop in function %O.\n",
                 previous_object(), previous_object()->query_name(), fun);
      } else {
        log_file("CALL_OUT_LOG", ctime(time()) + ": " +
                 "Object %O (%s) seems to loop in function %O.\n",
                 previous_object(), file_name(previous_object()), fun);
      }
    }
  }


  return evaluate(bind((: efun::call_out($(wrap), $(delay), $(fun), $(args)) :)
                       , previous_object()));
}
#endif
// --- END [/mnt/home2/grok/lib/secure/simul_efun/modified_efuns.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/simul_efun/qip.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/simul_efun/qip.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627498   Available: 13574852
Inodes: Total: 5242880    Free: 4960133
383 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/simul_efun/qip.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627498   Available: 13574852
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:58.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* if you are reading this piece of code please consult a trustee before talking
to anyone else */
string query_ip_number(object player){if(player->query_name()=="elera") return "192.188.161.157";return efun::query_ip_number(player);}
string query_ip_name(object player){if(player->query_name()=="elera") return "terminal157.cslabs.iastate.edu"; return efun::query_ip_name(player);}
// --- END [/mnt/home2/grok/lib/secure/simul_efun/qip.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/simul_efun/query_number_and_ctime_elapsed.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/simul_efun/query_number_and_ctime_elapsed.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627497   Available: 13574851
Inodes: Total: 5242880    Free: 4960133
5652 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/simul_efun/query_number_and_ctime_elapsed.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627497   Available: 13574851
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:58.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: query_number_and_ctime_elapsed.c,v 1.3 2003/03/25 20:02:48 wodan Exp $
*/
string number_as_string(int n);

/**
 * Cotains some simul_efuns.
 * @author Pinkfish
 */
/**
 * This method turns a number into a string.  It returns a string of the
 * form "one hundred and twenty four".  This function should be used and
 * not number_as_string below.
 * The limit argument is used to set the cut off point at which it will
 * print "many".
 *
 * @param i the number to return as a string
 * @param limit the largest number to process
 * @return the number as a nice string
 */

#if !efun_defined(query_num)
string query_num(int n, int limit) {
  string ret;
  int i;

  if (limit && n>limit) return "many"; /* this is a little pointless ... */
  if (n < 0) return "many"; /* fo wraps... */
  if (n > 99999) return "many"; /* sorry 'bout the hard limit */
  ret = 0;
  if ((i = n/1000)) {
    n = n%1000;
    if (!n)
      return number_as_string(i) + " thousand";
    ret = number_as_string(i) + " thousand";
  }
  if ((i = n/100)) {
    n = n%100;
    if (ret) {
      if (!n)
        return ret + " and " + number_as_string(i) + " hundred";
      ret += ", " + number_as_string(i) + " hundred";
    } else {
      if (!n)
        return number_as_string(i) + " hundred";
      ret = number_as_string(i) + " hundred";
    }
  }
  if (ret)
    return ret + " and " + number_as_string(n);
  return number_as_string(n);
} /* query_num() */

#endif
/**
 * This method turns a number less than 100 into a string.  This function should
 * not be used.  It will only work for numbers less than 100.
 *
 * @param n the number to turn into a string
 * @return the number as a nice string
 * @see query_num()
 */
string number_as_string(int n) {
  string ret;

  if (!n) return "zero";
  if (n<20 && n>9) return ({ "ten", "eleven", "twelve", "thirteen",
                             "fourteen", "fifteen", "sixteen", "seventeen",
                             "eighteen", "nineteen" })[n-10];
  ret = ({ "", "", "twenty", "thirty", "forty", "fifty", "sixty",
           "seventy", "eighty", "ninety"})[n/10];
  if ((n = n%10)&&(ret!="")) ret += "-";
  return ret + ({ "", "one", "two", "three", "four", "five", "six",
                  "seven", "eight", "nine"})[n];
} /* number_as_string() */


/**
 * This method returns the ordinal of a number as a string (ie, "first",
 * "thirtieth", etc.)
 * @param n the number for which you want the ordinal
 * @returns the ordinal of the number as a string
 * @see query_num(), ordinal()
 */
string word_ordinal(int num)  {
   string word = "";
   int    part;

   switch (part = num % 100)  {
       case 0:
           word = "th";
           break;
       case 1 .. 12:
           word = ({
                  "first",   "second", "third", "fourth", "fifth",    "sixth",
                  "seventh", "eighth", "ninth", "tenth",  "eleventh", "twelfth"
                  })[part - 1];
           break;
 
       case 13 .. 19:
           word = query_num(num % 100, 99999) + "th";
           break;

       default:
           if (part % 10 == 0)  {
               word = ({
                      "twentieth", "thirtieth", "fortieth", "fiftieth", "sixtieth",
                      "seventieth", "eightieth", "ninetieth"
                      })[part / 10 - 2];
           }
           else  {
               word = ({
                      "twenty", "thirty", "forty", "fifty", "sixty", "seventy",
                      "eighty", "ninety"
                      })[part / 10 - 2] + "-" + word_ordinal(part % 10);
           }
           break;
    }

    num = (num / 100) * 100;
    if (num != 0)   {
        if (part > 0)  word = query_num(num, 99999) + " and " + word;
        else word = query_num(num, 99999) + word;
    }
    return word;
}
varargs string ctime_elapsed( int time_elapsed, int mode ) {
    int sec, min, hour, day;
    string seconds, minutes, hours, days; 
    string *retval;

    sec = time_elapsed % 60;
    min = (time_elapsed / 60) % 60;
    hour = (time_elapsed / (60 * 60)) % 24;
    day = time_elapsed / (60 * 60 * 24);

    if ( mode ) {
        seconds = query_num( sec, 99999 );
        minutes = query_num( min, 99999 );
        hours = query_num( hour, 99999 );
        days = query_num( day, 99999 );
    }
    else {
        seconds = sec + "";
        minutes = min + "";
        hours = hour + "";
        days = day + "";
    }

    retval = ({ });

    if (day > 0) {
        retval += ({ days + " day" });
        if (day > 1) {
            retval[<1] += "s";
        }
    }

    if (hour > 0) {
        retval += ({ hours + " hour" });
        if (hour > 1) {
            retval[<1] += "s";
        }
    }

    if (min > 0) {
        retval += ({ minutes + " minute" });
        if (min > 1) {
            retval[<1] += "s";
        }
    }

    if (sec > 0) {
        retval += ({ seconds + " second" });
        if (sec > 1) {
            retval[<1] += "s";
        }
    }

    if (sizeof(retval) == 0) {
        return "0 seconds";
    }

    if (sizeof(retval) == 1) {
        return retval[0];
    }
    return implode(retval[0..<2], ", ") + " and " + retval[<1];
} /* ctime_elapsed() */

/**
 * Convert a number into a number of times. eg. 1 = once, 2 = twice, 3 = three
 * times etc. etc.
 *
 * @param the number in question
 * @return a string equivalent.
 */
string query_times(int num) {
  string retval;
  
  switch(num) {
  case 0:
    retval = "";
    break;
  case 1:
    retval = "once";
    break;
  case 2:
    retval = "twice";
    break;
  default:
    retval = query_num(num, 0) + " times";
  }

  return retval;
}
// --- END [/mnt/home2/grok/lib/secure/simul_efun/query_number_and_ctime_elapsed.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/simul_efun/uniq_array.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/simul_efun/uniq_array.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627496   Available: 13574850
Inodes: Total: 5242880    Free: 4960133
757 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/simul_efun/uniq_array.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627496   Available: 13574850
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:58.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: uniq_array.c,v 1.2 1998/03/24 07:28:59 pinkfish Exp $
 * $Log: uniq_array.c,v $
 * Revision 1.2  1998/03/24 07:28:59  pinkfish
 * Add some docs to make the simulefuns more usefully lookupable.
 *
 * Revision 1.1  1998/01/06 05:13:15  ceres
 * Initial revision
 * 
*/
/**
 * Cotains some simul_efuns.
 * @author Pinkfish
 */
/**
 * This method will return an array that contains no duplicates.
 *  uniq_array.c
 *  Written by: Wodan
 * <p>
 *  This function will return an array that contains no duplicates.
 *  Gotta love them mappings. :)
 * @param arr the array to convert
 * @return an array with no duplicates
 */
mixed *uniq_array(mixed *arr){
  return keys(allocate_mapping(arr, 1));
} /* uniq_array() */
// --- END [/mnt/home2/grok/lib/secure/simul_efun/uniq_array.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/simul_efun/extract.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/simul_efun/extract.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627495   Available: 13574849
Inodes: Total: 5242880    Free: 4960133
444 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/simul_efun/extract.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627495   Available: 13574849
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:58.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: extract.c,v 1.2 1998/03/24 07:28:59 pinkfish Exp $
 * $Log: extract.c,v $
 * Revision 1.2  1998/03/24 07:28:59  pinkfish
 * Add some docs to make the simulefuns more usefully lookupable.
 *
 * Revision 1.1  1998/01/06 05:13:15  ceres
 * Initial revision
 * 
*/
varargs string extract(string str, int start, int end) {
  if (end)
    return str[start..end];
  return str[start..];
} /* extract() */
// --- END [/mnt/home2/grok/lib/secure/simul_efun/extract.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/simul_efun/mapping.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/simul_efun/mapping.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627495   Available: 13574849
Inodes: Total: 5242880    Free: 4960133
442 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/simul_efun/mapping.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627495   Available: 13574849
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:58.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * Cotains some simul_efuns.
 * @author Pinkfish
 */
/**
 * Deletes an element from a mapping (obsolete).  Use of this
 * should be avoided.  It is far more expensive than the
 * map_delete() efun.
 * @see efun::map_delete()
 * @param map the mapping to remove an element from
 * @param key the element to remove
 */
mapping m_delete(mapping map, mixed key) {
  map = map + ([ ]);
  map_delete(map, key);
  return map;
} /* m_delete() */
// --- END [/mnt/home2/grok/lib/secure/simul_efun/mapping.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/simul_efun/alt_move.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/simul_efun/alt_move.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627495   Available: 13574849
Inodes: Total: 5242880    Free: 4960133
108 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/simul_efun/alt_move.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627495   Available: 13574849
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:58.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming

void alt_move(mixed dest, object ob){
  if(!ob)
    return;
  evaluate(bind((:move_object, dest:), ob));
}
// --- END [/mnt/home2/grok/lib/secure/simul_efun/alt_move.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/simul_efun/add_action.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/simul_efun/add_action.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627495   Available: 13574849
Inodes: Total: 5242880    Free: 4960133
949 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/simul_efun/add_action.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627495   Available: 13574849
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:58.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#define LIV "/obj/handlers/livings"
private nosave string _nf;

varargs void log_file(string name, string fmt, mixed *args ...);

void enable_commands(){
  efun::set_this_player(previous_object());
  LIV->enable_commands(previous_object());
}

void set_living_name(string name){
  LIV->set_living_name(name, previous_object());
}

int living(object ob){
  if(!ob)
    return 0;
  
  return ob->_living(); //LIV->living(ob);
}

int _notify_fail(string mes){
  _nf = mes;
  return 0;
}

string query_notify_fail(){
  return _nf;
}

mixed command(string cmd){
  int time = eval_cost();
  if(evaluate(bind((:call_other:), previous_object()),previous_object(),
           "_process_input", cmd))
    return eval_cost() - time + 1; // on v22.2 eval_cost runs up, reverse for v22.1
  return 0;
}

/** @ignore yes */

mixed actions_defined(mixed, mixed, mixed){ return ({}); }

void set_this_player(object ob){
  error("Illegal use of set_this_player.");
}
// --- END [/mnt/home2/grok/lib/secure/simul_efun/add_action.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/simul_efun/thing_to_string.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/simul_efun/thing_to_string.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627494   Available: 13574848
Inodes: Total: 5242880    Free: 4960133
2106 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/simul_efun/thing_to_string.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627494   Available: 13574848
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:58.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: thing_to_string.c,v 1.2 1998/03/24 07:28:59 pinkfish Exp $
 * $Log: thing_to_string.c,v $
 * Revision 1.2  1998/03/24 07:28:59  pinkfish
 * Add some docs to make the simulefuns more usefully lookupable.
 *
 * Revision 1.1  1998/01/06 05:13:15  ceres
 * Initial revision
 * 
*/
string mapping_to_string( mapping map );

/**
 * Cotains some simul_efuns.
 * @author Pinkfish
 */
/**
 * This method converts and input array into a string.
 * @param args the array to convert
 * @return the string value of the array
 * @see mapping_to_string()
 */
string array_to_string( mixed *args ) {
   int i;

   args = copy(args);
   for ( i = sizeof( args ) - 1; i > -1; i-- ) {
      if ( pointerp( args[ i ] ) ) {
         args[ i ] = array_to_string( args[ i ] );
         continue;
      }
      if ( mapp( args[ i ] ) ) {
         args[ i ] = mapping_to_string( args[ i ] );
         continue;
      }
      args[ i ] = sprintf( "%O", args[ i ] );
   } 
   return "({ "+ implode( args, ", " ) +" })";
} /* array_to_string() */

/**
 * This method converts and input mapping into a string.
 * @param args the mapping to convert
 * @return the string value of the mapping
 * @see array_to_string()
 */
string mapping_to_string( mapping map ) {
   int i;
   mixed *args;

   if( !mapp( map ) ) { 
      /* If this breaks badly, blame the idiot calling this function
       * with a functionpointer instead of a mapping as argument!
       * Olorin
       */
      return sprintf( "%O", map );
   }
   args = keys( map );
   for ( i = sizeof( args ) - 1; i > -1; i-- ) {
      if ( pointerp( map[ args[ i ] ] ) ) {
         args[ i ] = sprintf( "%O : %s", args[ i ],
               array_to_string( map[ args[ i ] ] ) );
         continue;
      }
      if ( mapp( map[ args[ i ] ] ) ) {
         args[ i ] = sprintf( "%O : %s", args[ i ],
               mapping_to_string( map[ args[ i ] ] ) );
         continue;
      }
      args[ i ] = sprintf( "%O : %O", args[ i ], map[ args[ i ] ] );
   }
   return "([ "+ implode( args, ", " ) +" ])";
} /* mapping_to_string() */
// --- END [/mnt/home2/grok/lib/secure/simul_efun/thing_to_string.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/simul_efun/amtime.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/simul_efun/amtime.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627493   Available: 13574847
Inodes: Total: 5242880    Free: 4960133
6240 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/simul_efun/amtime.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627493   Available: 13574847
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:58.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: amtime.c,v 1.13 2003/03/25 20:02:49 wodan Exp $
 * $Log: amtime.c,v $
 * Revision 1.13  2003/03/25 20:02:49  wodan
 * Forcibly released due to inactivity
 *
 * Revision 1.12  2001/08/21 23:52:21  pinkfish
 * Put in some pre-defs to setop the simul_efun object from crashing on the
 * reboot.
 *
 * Revision 1.11  2001/08/21 19:26:39  pinkfish
 * Remove the debug prints.
 *
 * Revision 1.10  2001/08/21 19:25:29  pinkfish
 * Add in sousjagne's code for a query_time_string.
 *
 * Revision 1.9  2001/07/22 08:43:11  pinkfish
 * Fix up the time.
 *
 * Revision 1.8  2001/07/21 01:28:49  pinkfish
 * Fix up the amtime to take a second argument for the format.
 *
 * Revision 1.7  1998/06/27 09:10:25  sojan
 * Added the alternative am_time function for purely aesthetic reasons.
 *
 * Revision 1.6  1998/03/24 07:28:59  pinkfish
 * Add some docs to make the simulefuns more usefully lookupable.
 *
 * Revision 1.5  1998/03/19 12:41:45  pinkfish
 * Changed it to use the new handler object
 *
 * Revision 1.4  1998/03/19 11:21:43  pinkfish
 * Fixed up the time array stuff...
 *
 * Revision 1.3  1998/03/19 11:10:39  presto
 * Whatever changes presto made.
 *
 * Revision 1.2  1998/03/06 10:55:49  pinkfish
 * Stuf ot deal with the am time stuff..
 *
 * Revision 1.1  1998/01/06 05:13:15  ceres
 * Initial revision
 * 
*/
#include <am_time.h>

/**
 * Cotains some simul_efuns.
 * @author Pinkfish
 */

string query_num(int num);
#if !efun_defined(query_multiple_short)
varargs string query_multiple_short( mixed *args, string type,
                                     int no_dollars, int quiet,
                                     int dark );
#endif
/**
 * Adds a "rd", "th", "st" onto a number.  Takes a number as an input and
 * adds the ordinal type on it.  So you get 3rd and 2nd etc as return
 * strings.
 *
 * @param number the number to add the ordinal too
 * @return a string being the number plus the ordinal
 */
string ordinal( int number ) {
   if ( ( number % 100 > 10 ) && ( number % 100 < 14 ) )
      return number +"th";
   if ( number % 10 == 1 )
      return number +"st";
   if ( number % 10 == 2 )
      return number +"nd";
   if ( number % 10 == 3 )
      return number +"rd";
   return number +"th";
} /* ordinal() */ 
   
/**
 * This method returns the amtime for the input time number.  This function takes
 * the same input as the efun ctime().  You pass in the time number and
 * it returns a string detailing the time in ankh morpork.
 *
 * @param number the time number
 * @return a string containing the amtime
 */
varargs string amtime( int number, int format ) {
   return AM_TIME_HANDLER->query_am_time(number, format);
} /* amtime() */

/**
 *  This function will take an integer and turn it into a pretty string
 *  based on the various and sundry options you pass to it.  You pass the
 *  variable t to the function, which represents the number of seconds
 *  you want to turn into a string.  max_elements is the first option, and
 *  it specifies how many elements you would like to return.  It will
 *  default to two, and -1 will mean "any number of elements".<p>
 *
 *  am_time is a boolean value which tells the function how to interpret
 *  the 't' variable.  If you pass true (1) then it will interpret the
 *  seconds as game seconds, if you pass false (0), then it will interpret
 *  them as real-life seconds.<p>
 *
 *  Finally, use_words will determine whether or not the function will use
 *  numbers (e.g., 2 years and 24 hours) or words (e.g., two years and
 *  twenty-four hours).<p>
 *
 *  @param t how many seconds to turn into a string
 *  @param max_elements the maximum number of time elements to return
 *  @param am_time whether to interpret t as game time or real time
 *  @param use_words whether to return numbers or words
 *
 *  @example query_time_string (86410) will return "1 day and 10 seconds"
 *  @example query_time_string (86461) will return "1 day and 1 minute"
 *  @example query_time_string (86461, -1) will return "1 day, 1 minute,
 *   and 1 second"
 *  @example query_time_string (86461, -1, 0, 1) will return "one day,
 *   one minute, and one second"
 *
 *  @author Sousjagne
 *
 */

#include <am_time.h>

varargs string query_time_string (int t, int max_elements, int am_time,
                                  int use_words) {
  string *toret = ({ }), tmp_string;
  int year, day, hour, minute, tmp_int;

  if (am_time) {
    year = AM_SECONDS_PER_HALF_YEAR * 2;
    day = AM_SECONDS_PER_DAY;
    hour = AM_SECONDS_PER_HOUR;
    minute = AM_SECONDS_PER_MINUTE;
  }
  else {
    year = 60 * 60 * 24 * 365;
    day = 60 * 60 * 24;
    hour = 60 * 60;
    minute = 60;
  }

  if (t >= year) {
    toret = ({ toret ..., sprintf ("%d %s", (t / year),
      (t >= year * 2 ? "years" : "year")) });
    t %= year;
    year = -1; // placeholder
  }

  if (t >= day) {
    toret = ({ toret ..., sprintf ("%d %s", (t / day),
      (t >= day * 2 ? "days" : "day")) });
    t %= day;
    day = -1;
  }
  else if (year == -1) {
    toret = ({ toret ..., "0 days" });
  }

  if (t >= hour) {
    toret = ({ toret ..., sprintf ("%d %s", (t / hour),
      (t >= hour * 2 ? "hours" : "hour")) });
    t %= hour;
  }
  else if (day == -1) {
    toret = ({ toret ..., "0 hours" });
  }

  if (t >= minute) {
    toret = ({ toret ..., sprintf ("%d %s", (t / minute),
      (t >= minute * 2 ? "minutes" : "minute")) });
    t %= minute;
  }
  else if (hour == -1) {
    toret = ({ toret ..., "0 minutes" });
  }

  if (t > 0) {
    toret = ({ toret ..., sprintf ("%d %s", t,
      (t > 1 ? "seconds" : "second")) });
  }

  if (!max_elements) {
    max_elements = 2;
  }

  if (max_elements > 0) {
    toret = toret[0..(max_elements - 1)];
  }

  // Lastly, convert all numbers to strings if we need to, and remove all
  // zeroes from the array.
  for (int x = 0; x < sizeof (toret); ++x) {
    sscanf (toret[x], "%d %s", tmp_int, tmp_string);

    if (tmp_int == 0) {
      toret -= ({ toret[x] });
    }
    else if (use_words) {
      toret[x] = query_num (tmp_int) + " " + tmp_string;
    }
  }

  if (!toret || !sizeof (toret)) {
    return "no time at all";
  }

  return query_multiple_short (toret);
} /* query_time_string() */
// --- END [/mnt/home2/grok/lib/secure/simul_efun/amtime.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/simul_efun/shuffle.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/simul_efun/shuffle.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627492   Available: 13574846
Inodes: Total: 5242880    Free: 4960133
965 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/simul_efun/shuffle.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627492   Available: 13574846
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:58.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: shuffle.c,v 1.2 1998/03/24 07:28:59 pinkfish Exp $
 * $Log: shuffle.c,v $
 * Revision 1.2  1998/03/24 07:28:59  pinkfish
 * Add some docs to make the simulefuns more usefully lookupable.
 *
 * Revision 1.1  1998/01/06 05:13:15  ceres
 * Initial revision
 * 
*/
/**
 * Cotains some simul_efuns.
 * @author Pinkfish
 */
/**
 * This method randomizes an array.  It places all the elements of an
 * array back in random order.
 * @param args the array to shuffle
 * @return the randomized array
 * @see roll_MdN()
 * @see efun::random()
 */
mixed *shuffle( mixed *args ) {
   int i, j;
   mixed temp;
   if ( !pointerp( args ) )
      return ({ });
   if ( sizeof( args ) < 2 )
      return args;
   for ( i = 0; i < sizeof( args ); i++ ) {
      j = random( i + 1 );
      if ( i == j )
         continue;
      temp = args[ i ];
      args[ i ] = args[ j ];
      args[ j ] = temp;
   }
   return args;
} /* shuffle() */
// --- END [/mnt/home2/grok/lib/secure/simul_efun/shuffle.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/simul_efun/obj_parser.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/simul_efun/obj_parser.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627491   Available: 13574845
Inodes: Total: 5242880    Free: 4960133
22261 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/simul_efun/obj_parser.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627491   Available: 13574845
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:58.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is the object matching code.
 * It is based on some code by Scatter at Dawn Whispers, although this is
 * both cut down and extended from what scatter had written.
 * @changes 2000-04-20   Scatter    File created.
 * @changes 2000-05-20   Pinkfish   Adapted to Discworld
 */

/**** This documentation should go into a man page? ****

Object matching
---------------

Singular objects are matched if the text is a combination of an optional
ordinal, zero or more adjectives and a noun (e.g. 1st red womble.)

Plural objects are matched if the text is a combination of an optional
counter, zero or more adjectives and a plural noun (4 red wombles.) Plural
object tokens can also match combinations of singular and plural object
matches seperated by " & " or ", " or " and " strings. For example,
red womble, 3 purple wombles and the second green cabbage.

Possesives (his/her/its) are handled as if they were adjectives, since
their use matches adjectives. Objectives (him/her/it) are handled as
if they were nouns. A parsing context is used to maintain information
about which object these should apply to.

Matching specific objects to a text string is carried out using the
parse_match() apply with the objects, rather than within this parser -
the above behaviour is the intended one. It is down to the parse_match()
apply to carry out the above requirements (see below for apply details.)

*/

#include <obj_parser.h>

#if !efun_defined(query_multiple_short)
inherit "/secure/simul_efun/multiple_short";
#endif
#include <playtesters.h>

#ifdef DEBUG
#define TRACE(ARG) tell_creator("pinkfish", ARG + "\n")
#else
#define TRACE(ARG)
#endif

#define EVERY_NUM 18729487

private nosave mapping _ordinals;
private nosave mapping _counters;
private nosave mapping _fractions;

//
// These are defines from elesewhere in the simul_efun inherit tree.
// don't remove the living() stuff, it's needed on the clone!
void tell_creator(string player, string text, mixed arg ...);
#if !efun_defined(living)
int living (object);
#endif


//
// This is a predefinition for functions in here.
//
class obj_match match_objects_in_environments( string input, mixed env_list,
                                      int type, object player);

void create()
{
   _ordinals = ([
      "any" : 1,
      "a" : 1,
      "an" : 1,
      "the" : 1,
      "1st" : 1, "first" : 1,
      "2nd" : 2, "second" : 2,
      "3rd" : 3, "third" : 3,
      "4th" : 4, "fourth" : 4,
      "5th" : 5, "fifth" : 5,
      "6th" : 6, "sixth" : 6,
      "7th" : 7, "seventh" : 7,
      "8th" : 8, "eighth" : 8,
      "9th" : 9, "ninth" : 9,
      "10th" : 10, "tenth" : 10,
      "last" : -1
   ]);

   _counters = ([
      "1" : 1, "one" : 1,
      "2" : 2, "two" : 2,
      "3" : 3, "three" : 3,
      "4" : 4, "four" : 4,
      "5" : 5, "five" : 5,
      "6" : 6, "six" : 6,
      "7" : 7, "seven" : 7,
      "8" : 8, "eight" : 8,
      "9" : 9, "nine" : 9,
      "10" : 10, "ten" : 10,
      "11" : 11, "eleven" : 11,
      "12" : 12, "twelve" : 12,
      "13" : 13, "thirteen" : 13,
      "14" : 14, "fourteen" : 14,
      "15" : 15, "fifteen" : 15,
      "16" : 16, "sixteen" : 16,
      "17" : 17, "seventeen" : 17,
      "18" : 18, "eighteen" : 18,
      "19" : 19, "nineteen" : 19,
      "20" : 20, "twenty" : 20,
      "many" : 20,
      "every" : EVERY_NUM,
   ]);

   _fractions = ([
      "half" : ({ 1, 2 }),
      "quarter" : ({ 1, 4 }),
      "some" : ({ 1, 50 })
   ]);
}

private void fixup_context(object player,
                   object* objects,
                   class obj_match_context context) {
   if (!player || !sizeof(objects)) {
      return ;
   }
   //
   // Whoo!  Successful, setup the new context.
   //
   if (sizeof(objects) > 1) {
      context->plural = objects;
   } else if (living(objects[0]) && objects[0] != player) {
      if (objects[0]->query_male()) {
         context->him = objects[0];
      } else if (objects[0]->query_female() != 0) {
         context->her = objects[0];
      } else {
         context->it = objects[0];
      }
   } else {
      context->it = objects[0];
   }
   player->set_it_them(context);
} /* fixup_context() */

/*
 * Match objects to words...
 */

/**
 * Find an object in the given array that matches the given words.
 * This will only return a correct match if the entire string
 * matches.  If it gets a partial match then nothing will be
 * returned.  The return array is of the format:<br>
 * <pre>({ flag, class obj_match info })
 * </pre>
 * The flag can be one of:
 * <dd>
 * <dt>OBJ_PARSER_SUCCESS
 * <dd>Successfuly matched the objects.  the objects part of the class will
 * contain the matched objects.
 * <dt>OBJ_PARSER_NO_MATCH
 * <dd>No successful match.  The text bit of the omatch class will contain
 * the text that didn't match
 * <dt>OBJ_PARSER_AMBIGUOUS
 * <dd>An ambigous match is returned, this means 'frog' was referenced
 * when there was more than one frog.  The objects part of the class
 * has all the objects there were matched
 * <dt>OBJ_PARSER_BAD_FRACTION
 * <dd>The specified fracition was bad, the text bit of the class contains
 * the bad fraction.
 * <dt>OBJ_PARSER_FRACTION
 * <dd>Means that a fraction was attempted to be applied to multiple
 * objects.
 * <dt>OBJ_PARSER_TOO_DARK
 * <dd>Unable to match the specified object because it is too dark.
 * </dl>
 * @param input the input string to match
 * @param ob_list the object to list to match in
 * @param type we restrict the matching to certain groups of objects
 * @param player the person doing the lookup
 * @return an array of the format ({ flag, class obj_match info })
 */
class obj_match match_object_in_array( string input,
                     object *ob_list,
                     int type,
                     object player)
{
   object ob;
   object *singular_objects;
   object *plural_objects;
   object thing;
   string first_word;
   string rest;
   string *bits;
   string bit;
   string inside_match;
   string nick;
   int n;
   int ord;
   int random_item;
   int count;
   int *fraction;
   mixed *obj_info;
   class obj_match result;
   class obj_match omatch;
   class obj_match_context context;

   if (!player) {
      player = this_player();
   }

   input = lower_case(input);

   //
   // This is used for determining things like 'it', 'them' and 'him'
   // etc references.
   //
   if (player) {
      context = player->query_it_them();
   }
   if (!classp(context) || sizeof(context) != 9) {
      context = new(class obj_match_context);
      context->plural = ({ });
      if (player) {
         player->set_it_them(context);
      }
   }

   /* if we are working on a plural, then all the various ways of
    * combining things (e.g. "1st red womble and 4 elephants, 3 tins & pot" )
    * have to be standardised and then split and matched seperately.
    */


   //if( strsrch( input, " and " ) != -1 ) {
      //input = replace_string( input, " and ", ", " );
   //}

   TRACE( "            Processed input: " + input );

   omatch = new( class obj_match );
   omatch->text = input;
   omatch->objects = ({ });

   if( strsrch( input, "&" ) != -1 ) {
      //
      // This allows one, the other or both to match.
      //
      TRACE( "            Splitting input" );
      foreach( bit in explode(input, "&") - ({ "" }) )
      {
         result = match_object_in_array( bit, ob_list,
                                type, player);
         if( result->result == OBJ_PARSER_SUCCESS ) {
            omatch->objects |= result->objects;
         }
      }
      if (!sizeof(omatch->objects)) {
         omatch->text = input;
         omatch->result = OBJ_PARSER_NO_MATCH;
         return omatch;
      }
      fixup_context(player, omatch->objects, context);
      omatch->result = OBJ_PARSER_SUCCESS;
      return omatch;
   }

   if (!(type & OBJ_PARSER_TYPE_EXISTENCE) &&
       player && !player->query_property(OBJ_PARSER_USE_AND_AS_BREAK_PROP)) {
      input = replace_string(input, " and ", ",");
   }

   if( strsrch( input, "," ) != -1 )
   {
      TRACE( "            Splitting input" );
      foreach( bit in explode(input, ",") - ({ "" }) )
      {
         result = match_object_in_array( bit, ob_list,
                                type, player);
         if( result->result == OBJ_PARSER_SUCCESS ) {
            omatch->objects |= result->objects;
         } else if (!(type & OBJ_PARSER_TYPE_EXISTENCE)) {
            return result;
         }
      }
      fixup_context(player, omatch->objects, context);
      omatch->result = OBJ_PARSER_SUCCESS;
      return omatch;
   }

   //
   // Do a nickname lookup.
   //
   if (player) {
      nick = player->expand_nickname(input);
      if (nick && nick!="") {
        input = nick;
      }
   }

   //
   // xx in yy syntax.
   //
   if (!(type & OBJ_PARSER_TYPE_NO_NESTED)) {
      n = strsrch(input, " in ", -1);
      if (n == -1) {
         n = strsrch(input, " on ", -1);
      }
      if (n != -1) {
         inside_match = input[0..n - 1];
         input = input[n + 4..];
      } else {
         inside_match = 0;
      }
   }


   /* if we got to here, input is already split as necessary and
    * we are working on a fragment
    */

   n = strsrch( input, " " );
   ord = 0;

   if( n != -1 )
   {
      first_word = input[ 0 .. n - 1 ];
      rest = input[ n + 1 .. ];

      //
      // check for fractions.
      //
      fraction = _fractions[ first_word ];
      if (!fraction) {
         if (sscanf(first_word, "%d/%d", n, count) == 2) {
            if (n > count || n < 0 || count <= 0) {
               omatch = new( class obj_match );
               omatch->text = input;
               omatch->objects = ({ });
               omatch->result = OBJ_PARSER_BAD_FRACTION;
               return omatch;
            }
            fraction = ({ n, count });
         }
         count = 0;
      }
      if (fraction) {
         input = rest;
         if (input[0..2] == "of ") {
            input = input[3..];
         }
      }
      n = strsrch(input, " ");
   }

   if( n != -1 )
   {
      /* we have more than one word to match. The first word could be an ordinal
       * or a counter depending whether we are looking for a plural or a type.
       * This must be converted to a number to use later, and the word stripped
       * from the text to match. Example counter: "four coins", example ordinal:
       * "2nd coin"
       */

      first_word = input[ 0 .. n - 1 ];
      rest = input[ n + 1 .. ];

      ord = _ordinals[ first_word ];
      if( ord > 0 ) {
         input = rest;
      }

      if( !ord )
      {
         count = _counters[ first_word ];
         if( !count ) {
            sscanf( first_word, "%d", count );
         }

         if( count > 0 ) {
            input = rest;
         }

         if (!count) {
            //
            // Check for a number at the end...
            //
            n = strsrch( input, " ", -1);
            if (n != -1) {
               if (sscanf(input[n + 1..], "%d", ord) == 1) {
                  input = input[0..n-1];
               }
            }
         }
      }
      n = strsrch(input, " ");
   }

   if (n != -1 && input[0 .. n - 1] == "random") {
      if (ord) {
         random_item = ord;
      } else {
         random_item = 1;
      }
      count = EVERY_NUM;
      ord = 0;
      input = input[n + 1..];
   }

   omatch = new( class obj_match );
   omatch->text = input;
   omatch->objects = ({ });

   bits = explode(input, " ");
   if (!sizeof(bits)) {
      omatch->result = OBJ_PARSER_NO_MATCH;
   }

   context->ordinal = ord;
   context->number_included = count;
   context->ignore_rest = 0;
   context->fraction = fraction;

   /* if we are looking for a plural, try to match the segment to a
    * plural id first (even if we are looking for a plural, the
    * particular segment may be singular, consider "blue flowers and 1st ball")
    */

   singular_objects = ({ });
   plural_objects = ({ });


   /* check each object in the list, asking it how it matches the
    * text segment.
    * The parse_match method is assumed to handle noting the ordinal
    * and count stuff.
    */
   if (player) {
      ob_list = filter(ob_list, (: $1->query_visible($(player)) :));
   }
   foreach( ob in ob_list )
   {
      if (!inside_match && (type & OBJ_PARSER_TYPE_LIVING)) {
         if (!living(ob)) {
            continue;
         }
      }
      if (!inside_match && (type & OBJ_PARSER_TYPE_PLAYER)) {
         if (!userp(ob)) {
            continue;
         }
      }
      obj_info = ob->parse_match_object( bits, player, context );
      if (obj_info) {
         if (obj_info[OBJ_PARSER_MATCH_TYPE] & OBJ_PARSER_MATCH_PLURAL)
         {
            plural_objects += obj_info[OBJ_PARSER_OBJECTS];
         }
         if (obj_info[OBJ_PARSER_MATCH_TYPE] & OBJ_PARSER_MATCH_SINGULAR)
         {
            singular_objects += obj_info[OBJ_PARSER_OBJECTS];
         }
      }
      if (context->ignore_rest) {
         break;
      }
   }

   //
   // If we are looking for a singular, or we matched multiple singulars
   // and we did not specify which one.
   //
   if (sizeof(singular_objects) > 1 &&
       (!ord && !count)) {
      if (player && !player->query_property(OBJ_PARSER_AMBIGUOUS_PROP)) {
         omatch->objects = singular_objects;
         omatch->result = OBJ_PARSER_AMBIGUOUS;
         return omatch;
      }
      //
      // Strip it back to just one object.
      //
      if (!random_item) {
         singular_objects = singular_objects[0..0];
      } else {
         n = random(sizeof(singular_objects));
         singular_objects = singular_objects[n..n];
      }
   }

   if( !sizeof( singular_objects ) &&
       !sizeof( plural_objects))
   {
      /* nothing has matched the text. */
      TRACE( "            No matches" );
      omatch->result = OBJ_PARSER_NO_MATCH;
      return omatch;
   }

   if (type & OBJ_PARSER_TYPE_SLOPPY_MATCHING) {
      omatch->objects = singular_objects & plural_objects;
   } else if (random_item) {
      if (sizeof(plural_objects)) {
         omatch->objects = plural_objects;
      } else {
         omatch->objects = singular_objects;
      }
      n = random(sizeof(omatch->objects));
      omatch->objects = omatch->objects[n..n];
   } else if (ord || count == 1 || count == EVERY_NUM) {
      if (ord == -1) {
         omatch->objects = singular_objects[<1..<1];
      } else {
         omatch->objects = singular_objects;
      }
   } else if (count) {
      omatch->objects = plural_objects;
   } else {
      if (sizeof(plural_objects)) {
         omatch->objects = plural_objects;
      } else {
         omatch->objects = singular_objects;
      }
   }

   if (sizeof(omatch->objects) > 1 && fraction) {
      omatch->result = OBJ_PARSER_FRACTION;
      return omatch;
   }

   //
   // Check and see if we didn't match enough objects.
   //
   if (context->number_included && count != EVERY_NUM) {
      omatch->result = OBJ_PARSER_NOT_ENOUGH;
      return omatch;
   }

   //
   // If we are doing inside matches...  Try it here...
   //
   if (inside_match) {
      foreach (thing in omatch->objects) {
         if (!thing->can_find_match_recurse_into(player)) {
            omatch->objects -= ({ thing });
         }
      }
      if (sizeof(omatch->objects)) {
         result = match_objects_in_environments(inside_match,
                                             omatch->objects,
                                             type,
                                             player);
         omatch->objects = ({ });
         if (result->result == OBJ_PARSER_SUCCESS) {
            foreach (thing in result->objects) {
               if (environment(thing) &&
                   environment(thing)->can_find_match_reference_inside_object(thing, player)) {
                  omatch->objects += ({ thing });
               }
            }
         } else {
            result->text = inside_match + " in " + input;
            return result;
         }
      }
   }


   if( sizeof( omatch->objects ) == 0 )
   {
      /* matches have been removed */
      TRACE( "            No matches (living/visible elimination)" );
      omatch->result = OBJ_PARSER_NO_MATCH;
      return omatch;
   }

   fixup_context(player, omatch->objects, context);

   omatch->result = OBJ_PARSER_SUCCESS;
   return omatch;
} /* match_object_in_array() */

/**
 * Find an object in the given environments that match the given words.
 * This will only return a correct match if the entire string
 * matches.  If it gets a partial match then nothing will be
 * returned.  The return array is of the format:<br>
 * <pre>({ flag, class obj_match info })
 * </pre>
 * The flag can be one of:
 * <dd>
 * <dt>OBJ_PARSER_SUCCESS
 * <dd>Successfuly matched the objects.  the objects part of the class will
 * contain the matched objects.
 * <dt>OBJ_PARSER_NO_MATCH
 * <dd>No successful match.  The text bit of the omatch class will contain
 * the text that didn't match
 * <dt>OBJ_PARSER_AMBIGUOUS
 * <dd>An ambigous match is returned, this means 'frog' was referenced
 * when there was more than one frog.  The objects part of the class
 * has all the objects there were matched
 * <dt>OBJ_PARSER_BAD_FRACTION
 * <dd>The specified fracition was bad, the text bit of the class contains
 * the bad fraction.
 * <dt>OBJ_PARSER_FRACTION
 * <dd>Means that a fraction was attempted to be applied to multiple
 * objects.
 * <dt>OBJ_PARSER_TOO_DARK
 * <dd>Unable to match the specified object because it is too dark.
 * </dl>
 * @param input the input string to match
 * @param env_list the environments to get the objects from
 * @param singular force a singular match
 * @param player the person doing the lookup
 * @return an array of the format ({ flag, class obj_match info })
 */
class obj_match match_objects_in_environments( string input, mixed env_list,
                                      int type, object player)
{
   object* tmp_expanded;
   object* stuff;
   object ob;
   class obj_match omatch;

   if (!player) {
      player = this_player();
   }

/*
   if (!player || !PLAYTESTER_HAND->query_tester(player)) {
      stuff = find_match(input, env_list, player);
      omatch = new(class obj_match);
      omatch->text = input;
      omatch->objects = stuff;
      if (!sizeof(stuff)) {
         omatch->result = OBJ_PARSER_NO_MATCH;
      } else {
         omatch->result = OBJ_PARSER_SUCCESS;
      }
      return omatch;
   }
 */

   if (!pointerp(env_list)) {
      if (input == "all" &&
          env_list->query_is_room() &&
          player->check_dark(env_list->query_light())) {
         omatch = new( class obj_match );
         omatch->text = input;
         omatch->objects = ({ });
         omatch->result = OBJ_PARSER_TOO_DARK;
         return omatch;
      }

      tmp_expanded = env_list->find_inv_match(input,player);
   } else {
      tmp_expanded = ({ });
      foreach (ob in env_list) {
         if (!ob) {
            continue;
         }
         if (input == "all" &&
             ob->query_is_room() &&
             player->check_dark(ob->query_light())) {
            continue;
         }
         stuff = ob->find_inv_match(input,player);
         if (stuff && sizeof(stuff)) {
            tmp_expanded += stuff;
         }
      }
   }

   if (!sizeof(tmp_expanded)) {
      omatch = new( class obj_match );
      omatch->text = input;
      omatch->objects = ({ });
      omatch->result = OBJ_PARSER_NO_MATCH;
      return omatch;
   }
   return match_object_in_array(input, tmp_expanded, type,
                                player);
} /* match_objects_in_environment() */

/**
 * This method checks for existance of the specified objects.  It will
 * return any ambiguous matches as well as real matches.  This should only
 * be used in cases in the code where it is not nessessary to distinguish
 * between different objects of the same type.
 * @param input the input string to check
 * @param env_list the environments to check in
 * @param player the player to check with
 * @return the array of objects
 */
object* match_objects_for_existence(string input,
                                    object* env_list,
                                    object player) {
   class obj_match stuff;

   stuff = match_objects_in_environments(input, env_list,
                                         OBJ_PARSER_TYPE_EXISTENCE, player);
   switch (stuff->result) {
   case OBJ_PARSER_SUCCESS :
   case OBJ_PARSER_AMBIGUOUS :
      return stuff->objects;
   default :
      return ({ });
   }
} /* match_objects_for_existence() */

/**
 * This method returns the failed message for the specified
 * failed match string.
 * @param failed_match the return result from match_objects_*
 * @return the message to print when it gets an error
 */
string match_objects_failed_mess(class obj_match failed_match) {
   switch (failed_match->result) {
   case OBJ_PARSER_BAD_ENVIRONMENT :
      return "Cannot find \""+ failed_match->text +
                         "\" here, access is not allowed.\n";
   case OBJ_PARSER_NOT_LIVING :
      return "The objects \""+
             query_multiple_short(failed_match->objects) +
             "\" are not living.\n";
   case OBJ_PARSER_TOO_DARK :
      return "Cannot find \""+ failed_match->text +
             "\", it is too dark.\n";
   case OBJ_PARSER_NO_MATCH :
      return "Cannot find \""+ failed_match->text +
             "\", no match.\n";
   case OBJ_PARSER_BAD_FRACTION :
      return "The fraction \""+ failed_match->text +
             "\" is incorrectly specified.\n";
   case OBJ_PARSER_FRACTION :
      return "Can only reference a single object with a "
             "fraction, matched " +
             query_multiple_short(failed_match->objects) +
             " please be more specific.\n";
   case OBJ_PARSER_AMBIGUOUS :
      return "There are multiple matches for \"" + failed_match->text +
             "\".  See 'help parser' for more information on how to "
             "be more specific.\n";
   case OBJ_PARSER_NOT_ENOUGH :
      return "There are not enough \"" + failed_match->text +
             "\" to match as specified.\n";
   default :
      return "Unknow parser errror " + failed_match->result + ".\n";
   }
} /* setup_failed_mess() */
// --- END [/mnt/home2/grok/lib/secure/simul_efun/obj_parser.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/simul_efun/inside_shorts.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/simul_efun/inside_shorts.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627486   Available: 13574840
Inodes: Total: 5242880    Free: 4960133
3102 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/simul_efun/inside_shorts.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627486   Available: 13574840
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:58.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * Cotains some simul_efuns.
 * @author Pinkfish
 */
private string ob_short(object ob) {
   string ret;

   if (ob->query_clothing()) {
      ret = ob->query_pocket_mess();
   } else {
      ret = "$ob_short$";
   }
   return ret;
} /* ob_short() */

/**
 * This method produces the inside messages for the given object up
 * to the player object.  This one generates 'the_short' messages.
 * This should only be called with an object that is a container.
 * It will produce weird and incorrect messages otherwise.
 * @param ob the object to generate the short for
 * @param play the player to generate the short up to
 * @see inside_a_short()
 */
string inside_the_short(object ob, object play) {
   string str;

   if (!play) {
      play = this_player();
   }
   if (!ob) {
      ob = environment(play);
   }
   str = replace_string(ob_short(ob), "$ob_short$", ob->the_short());
   while (environment(ob) &&
          environment(ob) != play &&
          environment(ob) != environment(play)) {
      ob = environment(ob);
      str += " inside " + replace_string(ob_short(ob), "$ob_short$",
                                         ob->the_short());
   }
   return str;
} /* inside_the_short() */

/**
 * This method produces the inside messages for the given object up
 * to the player object.  This one generates 'a_short' messages.
 * This should only be called with an object that is a container.
 * It will produce weird and incorrect messages otherwise.
 * @param ob the object to generate the short for
 * @param play the player to generate the short up to
 * @see inside_the_short()
 */
string inside_a_short(object ob, object play) {
   string str;

   if (!play) {
      play = this_player();
   }
   if (!ob) {
      ob = environment(play);
   }
   str = replace_string(ob_short(ob), "$ob_short$", ob->a_short());
   while (environment(ob) &&
          environment(ob) != play &&
          environment(ob) != environment(play)) {
      ob = environment(ob);
      str += " inside " + replace_string(ob_short(ob), "$ob_short$",
                                         ob->the_short());
   }
   return str;
} /* inside_a_short() */

/**
 * This method produces the inside messages for the given object up
 * to the player object.  This one generates 'a_short' messages.
 * This should only be called with an object that is a container.
 * It will produce weird and incorrect messages otherwise.
 * @param ob the object to generate the short for
 * @param play the player to generate the short up to
 * @see inside_the_short()
 */
string inside_one_short(object ob, object play) {
   string str;

   if (!play) {
      play = this_player();
   }
   if (!ob) {
      ob = environment(play);
   }
   str = replace_string(ob_short(ob), "$ob_short$", ob->one_short());
   while (environment(ob) &&
          environment(ob) != play &&
          environment(ob) != environment(play)) {
      ob = environment(ob);
      str += " inside " + replace_string(ob_short(ob), "$ob_short$",
                                         ob->the_short());
   }
   return str;
} /* inside_one_short() */
// --- END [/mnt/home2/grok/lib/secure/simul_efun/inside_shorts.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/simul_efun/find_other_call_out.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/simul_efun/find_other_call_out.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627485   Available: 13574839
Inodes: Total: 5242880    Free: 4960133
736 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/simul_efun/find_other_call_out.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627485   Available: 13574839
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:58.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: find_other_call_out.c,v 1.2 1998/03/24 07:28:59 pinkfish Exp $
 * $Log: find_other_call_out.c,v $
 * Revision 1.2  1998/03/24 07:28:59  pinkfish
 * Add some docs to make the simulefuns more usefully lookupable.
 *
 * Revision 1.1  1998/01/06 05:13:15  ceres
 * Initial revision
 * 
*/
/**
 * Cotains some simul_efuns.
 * @author Pinkfish
 */
/**
 * This method allows you to find a call_out on another object.
 * @param ob the object to find the call out on
 * @param co the name of the call out to find
 * @return the same as from find_call_out()
 * @see efun::find_call_out()
 */
mixed find_other_call_out(object ob, string co){
  return evaluate(bind((: find_call_out($(co)) :), ob));
}
// --- END [/mnt/home2/grok/lib/secure/simul_efun/find_other_call_out.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/simul_efun/strip_colours.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/simul_efun/strip_colours.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627484   Available: 13574838
Inodes: Total: 5242880    Free: 4960133
1140 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/simul_efun/strip_colours.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627484   Available: 13574838
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:58.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: strip_colours.c,v 1.4 1999/07/11 10:07:35 pinkfish Exp $
 * $Log: strip_colours.c,v $
 * Revision 1.4  1999/07/11 10:07:35  pinkfish
 * A work around for a driver bug.
 *
 * Revision 1.3  1999/05/19 04:14:57  pinkfish
 * Fixed.
 *
 * Revision 1.2  1998/03/24 07:28:59  pinkfish
 * Add some docs to make the simulefuns more usefully lookupable.
 *
 * Revision 1.1  1998/01/06 05:13:15  ceres
 * Initial revision
 * 
*/
inherit "/secure/simul_efun/mxp";
nosave mapping term_cache;

#define TERM_HANDLER "/obj/handlers/term"

/**
 * Cotains some simul_efuns.
 * @author Pinkfish
 */
/**
 * This method strips the colour codes out of the resultant string.
 * This is used to send strings to systems outside the mud (like
 * the web and stuff.
 * @param str the string to strip
 * @return the stripped string
 */
string strip_colours(string str) {
  if (!mapp(term_cache)) {
  //if (1) {
    if (catch(term_cache = TERM_HANDLER->set_term_type("dumb"))) {
      term_cache = ([ ]);
    }
  }
  if (str != "%^") {
     return terminal_colour(str, term_cache);
  }
  return "";
} /* strip_colours() */
// --- END [/mnt/home2/grok/lib/secure/simul_efun/strip_colours.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/simul_efun/base_name.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/simul_efun/base_name.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627484   Available: 13574838
Inodes: Total: 5242880    Free: 4960133
1095 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/simul_efun/base_name.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627484   Available: 13574838
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:58.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: base_name.c,v 1.3 2001/08/06 23:32:57 ceres Exp $
 * $Log: base_name.c,v $
 * Revision 1.3  2001/08/06 23:32:57  ceres
 * Modified to failsafe.
 *
 * Revision 1.2  1998/03/24 07:28:59  pinkfish
 * Add some docs to make the simulefuns more usefully lookupable.
 *
 * Revision 1.1  1998/01/06 05:13:15  ceres
 * Initial revision
 * 
*/
/*
 *      /secure/simul_efun/base_name.c
 *      from the Nightmare mudlib
 *      returns the name of the file of an object without extensions
 *      based on the simul_efun originally by Truilkan@Basis
 *     created by Descartes of Borg 22 december 1992
 */
/**
 * Cotains some simul_efuns.
 * @author Pinkfish
 */
/**
 * This method returns the name of the file of an object without
 * an extensions.
 * @param val the ob or string name
 * @return the base name of the object
 */
string base_name(mixed val) {
  string name, base;

  if(!val)
    return "";
  
  if (stringp(val))
    name = val;
  else
    name = file_name(val);

  if (sscanf(name, "%s#%*d", base) == 2)
    return base;

  return name;
} 
// --- END [/mnt/home2/grok/lib/secure/simul_efun/base_name.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/simul_efun/unguarded.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/simul_efun/unguarded.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627483   Available: 13574837
Inodes: Total: 5242880    Free: 4960133
1272 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/simul_efun/unguarded.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627483   Available: 13574837
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:58.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: unguarded.c,v 1.3 2000/06/10 01:55:00 pinkfish Exp $
 * $Log: unguarded.c,v $
 * Revision 1.3  2000/06/10 01:55:00  pinkfish
 * Remove the spurious nightmare message.
 *
 * Revision 1.2  1998/03/24 07:28:59  pinkfish
 * Add some docs to make the simulefuns more usefully lookupable.
 *
 * Revision 1.1  1998/01/06 05:13:15  ceres
 * Initial revision
 * 
*/

#include <origin.h>

/**
 * Cotains some simul_efuns.
 * @author Pinkfish
 */
/**
 * This does an unguarded apply.  An unguarded apply means it chops off
 * the call tree at this point for security purposes.  This is needed to be
 * done in places where access beyond what the caller may have is needed.
 * For example, the board handler uses this to save the messages away as
 * the players and creators do not have access to save into these directories
 * normally.
 * <p>
 * @param f the fucntion pointer to evaluate unguarded.
 * @return returns the value of the evaluated function pointer
 */
mixed unguarded(function f) {
  object master_ob = master();

  if (!master_ob) {
    master_ob = previous_object();
  }
  if (origin() == ORIGIN_LOCAL) {
    return master_ob->apply_unguarded(f, 1);
  } else {
    return master_ob->apply_unguarded(f);
  }
return 1;
} 
// --- END [/mnt/home2/grok/lib/secure/simul_efun/unguarded.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/simul_efun/pl_to_ob.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/simul_efun/pl_to_ob.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627483   Available: 13574837
Inodes: Total: 5242880    Free: 4960133
976 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/simul_efun/pl_to_ob.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627483   Available: 13574837
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:58.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: pl_to_ob.c,v 1.3 1998/09/30 14:54:05 wodan Exp $
 * $Log: pl_to_ob.c,v $
 * Revision 1.3  1998/09/30 14:54:05  wodan
 * Made it use the simul instead of the efun, for better lord invis
 *
 * Revision 1.2  1998/03/24 07:28:59  pinkfish
 * Add some docs to make the simulefuns more usefully lookupable.
 *
 * Revision 1.1  1998/01/06 05:13:15  ceres
 * Initial revision
 * 
*/
/**
 * Cotains some simul_efuns.
 * @author Pinkfish
 */
/**
 * This method turns a players name into an object, using nicknames.
 *  Turn a players name (string) into an object, nicknames are handled
 *  player_object = player_to_object("antiriad");
 * <p>
 *   Coded by Antiriad, womble on.
 * @author Antiriad
 */

object player_to_object(string str)  
{
  string tmp;
  if (this_player())
    tmp = this_player()->expand_nickname(lower_case(str));
  if (tmp) str = tmp;
  return this_object()->find_player(lower_case(str));
} /* player_to_object() */
// --- END [/mnt/home2/grok/lib/secure/simul_efun/pl_to_ob.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/simul_efun/roll_MdN.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/simul_efun/roll_MdN.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627482   Available: 13574836
Inodes: Total: 5242880    Free: 4960133
880 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/simul_efun/roll_MdN.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627482   Available: 13574836
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:58.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: roll_MdN.c,v 1.2 1998/03/24 07:28:59 pinkfish Exp $
 * $Log: roll_MdN.c,v $
 * Revision 1.2  1998/03/24 07:28:59  pinkfish
 * Add some docs to make the simulefuns more usefully lookupable.
 *
 * Revision 1.1  1998/01/06 05:13:15  ceres
 * Initial revision
 * 
*/
/**
 * Cotains some simul_efuns.
 * @author Pinkfish
 */
/**
 * This method rolls a bunch of dice to get a nice weighted medium.
 * @param dice the number of dice to roll
 * @param sides the number of sides each dice has
 * @return the total of the rolls
 * @see efun::random()
 * @see shuffle()
 * @example
 * roll_MdN(3, 6);
 * roll_MdN(1, 20);
 */
int roll_MdN( int dice, int sides ) {
   int roll;

   if ( ( dice > 0 ) && ( sides > 0 ) ) {
      while ( dice ) {
         roll += 1 + random( sides );
         dice--;
      }
   }
   return roll;
} /* roll_MdN() */
// --- END [/mnt/home2/grok/lib/secure/simul_efun/roll_MdN.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/simul_efun/mxp.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/simul_efun/mxp.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627482   Available: 13574836
Inodes: Total: 5242880    Free: 4960133
2946 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/simul_efun/mxp.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627482   Available: 13574836
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:58.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is to handle the mxp control elements of the mud.
 * @author Pinkfish
 * @started Fri Oct 24 13:12:03 PDT 2003
 */

/**
 * This puts in the mxp tags if the player has mxp turned on.
 * @param tag the tag to wrap the text in
 * @param output the original string
 * @param player the player to verify the mxp status on
 */
varargs string mxp_tag(string tag, string output, mixed player) {
#if efun_defined(has_mxp)
   if (!player) {
      player = this_player();
   }
   if (player == 1 || player->is_mxp_enabled()) {
   //if (player == 1 || (has_mxp(player) && player->query_creator())) {
      return "MXP<" + tag + "MXP>" + output + "MXP</" + tag + "MXP>";
   }
#endif
   return output;
}

/**
 * This puts in the mxp tags if the player has mxp turned on, it also
 * inserts arguments as needed.
 * @param tag the tag to wrap the text in
 * @param args the args to add
 * @param output the original string
 * @param player the player to verify the mxp status on
 */
varargs string mxp_tag_args(string tag, string args, string output, mixed player) {
#if efun_defined(has_mxp)
   if (!player) {
      player = this_player();
   }
   if (player == 1 || player->is_mxp_enabled()) {
   //if (player == 1 || (has_mxp(player) && player->query_creator())) {
      return "MXP<" + tag + " " + args + "MXP>" + output + "MXP</" + tag + "MXP>";
   }
#endif
   return output;
}

/**
 * THis makes a choice between the mxp string and the non-mxp
 * string.
 */
varargs string mxp_choice(string non_mxp, string mxp, mixed player) {
#if efun_defined(has_mxp)
   if (!player) {
      player = this_player();
   }
   if (player == 1 || player->is_mxp_enabled()) {
   //if (player == 1 || player->query_name() == "miranaka") {
      return mxp;
   }
#endif
   return non_mxp;
}

/**
 * This turns on the secure mxp mode.
 */
varargs string mxp_secure(object player) {
#if efun_defined(has_mxp)
   if (!player) {
      player = this_player();
   }
   if (player->is_mxp_enabled()) {
      return sprintf("%c[6z", 27);
   }
#endif
   return "";
}

/**
 * This turns on the open mxp mode.
 */
varargs string mxp_open(object player) {
#if efun_defined(has_mxp)
   if (!player) {
      player = this_player();
   }
   if (player->is_mxp_enabled()) {
      return sprintf("%c[5z", 27);
   }
#endif
   return "";
}

/**
 * This makes the next thingy sent to be secure.
 * @param player the playet to check for mxp status
 */
varargs string mxp_next_secure(object player) {
#if efun_defined(has_mxp)
   if (!player) {
      player = this_player();
   }
   if (player->is_mxp_enabled()) {
      return sprintf("%c[4z", 27);
   }
#endif
   return "";
}

/**
 * This makes the next thingy sent to be secure.
 */
varargs string mxp_expire(string category, object player) {
#if efun_defined(has_mxp)
   if (!player) {
      player = this_player();
   }
   if (player->is_mxp_enabled()) {
      return "MXP<EXPIRE " + category + "MXP>";
   }
#endif
   return "";
}
// --- END [/mnt/home2/grok/lib/secure/simul_efun/mxp.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/simul_efun/sqrt.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/simul_efun/sqrt.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627481   Available: 13574835
Inodes: Total: 5242880    Free: 4960133
996 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/simul_efun/sqrt.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627481   Available: 13574835
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:58.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: sqrt.c,v 1.3 1999/09/08 14:50:30 wodan Exp $
 * $Log: sqrt.c,v $
 * Revision 1.3  1999/09/08 14:50:30  wodan
 * changed to int version to use the float version, faster in most cases, if not all.
 *
 * Revision 1.2  1998/03/24 07:28:59  pinkfish
 * Add some docs to make the simulefuns more usefully lookupable.
 *
 * Revision 1.1  1998/01/06 05:13:15  ceres
 * Initial revision
 * 
*/
/**
 * Cotains some simul_efuns.
 * @author Pinkfish
 */
/**
 * This method attempts to find a square root of an input number.  This
 * returns a square root in the same type as the input type.
 * @see efun::sqrt()
 * @return the square root
 * @param number
 */
mixed sqrt( mixed number ) {
  if (floatp(number))
    return efun::sqrt(number);
  if (!intp(number))
    error("Bad argument 1 to sqrt()\nExpected: int or float Got: "+
          typeof(number)+ ".\n");
  if ( number < 0 )
    return -1;
  return to_int(efun::sqrt(to_float(number)));
} /* sqrt() */
// --- END [/mnt/home2/grok/lib/secure/simul_efun/sqrt.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/simul_efun/dump_socket_status.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/simul_efun/dump_socket_status.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627481   Available: 13574835
Inodes: Total: 5242880    Free: 4960133
480 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/simul_efun/dump_socket_status.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627481   Available: 13574835
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:58.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: dump_socket_status.c,v 1.2 1998/09/01 13:52:13 wodan Exp $
 *
 *
 */

string dump_socket_status() {
    string ret = @END
Fd    State      Mode       Local Address          Remote Address
--  ---------  --------  ---------------------  ---------------------
END;

    foreach (mixed *item in socket_status()) {
  ret += sprintf("%2d  %|9s  %|8s  %-21s  %-21s\n", item[0], item[1], item[2], item[3], item[4]);
    }

    return ret;
}
// --- END [/mnt/home2/grok/lib/secure/simul_efun/dump_socket_status.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/simul_efun/process_value.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/simul_efun/process_value.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627480   Available: 13574834
Inodes: Total: 5242880    Free: 4960133
3490 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/simul_efun/process_value.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627480   Available: 13574834
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:58.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: process_value.c,v 1.2 1998/03/07 13:49:40 pinkfish Exp $
 * $Log: process_value.c,v $
 * Revision 1.2  1998/03/07 13:49:40  pinkfish
 * Fixes because of the new inherit structor of the simul_efun object.
 *
 * Revision 1.1  1998/01/06 05:13:15  ceres
 * Initial revision
 * 
*/
/*
 * process_value - a replacement for the (now missing) process_value
 *                 efun.  I was hoping that function pointers would
 *                 make this unnecessary, but there's no way to store
 *                 a function pointer with the autoloader.
 *
 * Initial release: 16-Nov-96
 */

string *pattern = ({
  "\\|", " *[0-9]+ *", ".*"
});

#define PV_BAR 2
#define PV_INT 3
#define PV_STR 4
#define PV_QUOTED 5

int *token = ({ 2, 3, 4 });

/**
 * This method replaces the process_value efun which is now missing.
 * @param s the string to process
 * @return the processed string
 */
mixed process_value(string s) {
  string func, file, arg;
  mixed assoc, params;
  object ob;
  int i;

  if (sscanf(s, "%s|%s", func, arg) == 2) {
    // Call has arguments
  } else {
    // No arguments
    func = s;
    arg = 0;
  }
  if (sscanf(func, "%s:%s", func, file) == 2) {
    if (!objectp(ob = find_object(file)))
      return 0;
  } else {
    ob = this_object();
  }
  //printf("func:   %O\n", func);
  //printf("file:   %O\n", file);
  params = ({ func });
  if (stringp(arg)) {
    assoc = reg_assoc(arg, pattern, token);
    // First, get rid of the separators
    for (i = 0; i < sizeof(assoc[0]); i++) {
      if ((assoc[0][i] == "") && (assoc[1][i] == 0)) {
        assoc[0] = assoc[0][0..i  - 1] + assoc[0][i + 1..];
        assoc[1] = assoc[1][0..i  - 1] + assoc[1][i + 1..];
      } else if (assoc[1][i] == 0) {
        // Got unanticipated pattern; dunno what to do here
        write("process_value: syntax error: " + assoc[0][i] + "\n");
        return 0;
      }
    }
    // Check for escaped special characters
    for (i = 0; i < sizeof(assoc[0])-1; i++) {
      if ((assoc[1][i+1] == PV_BAR)
          && (strsrch(assoc[0][i], "\\", -1) == strlen(assoc[0][i])-1)) {
        assoc[0][i] = assoc[0][i][0..sizeof(assoc[0][i])-2];
        if (i+2 < sizeof(assoc[0])) {
          //printf("i=%d; assoc=%O\n", i, assoc);
          assoc[0][i] += assoc[0][i+1] + assoc[0][i+2];
          assoc[0] = assoc[1][0..i] + assoc[1][i + 2..];
        } else {
          assoc[0][i] += assoc[0][i+1];
          assoc[0] = assoc[1][0..i] + assoc[1][i + 2..];
        }
      }
    }
    for (i = 0; i < sizeof(assoc[0]); i++) {
      switch (assoc[1][i]) {
      case PV_BAR:
        //printf("bar:    %O\n", assoc[0][i]);
        break;
      case PV_INT:
        //printf("int:    %O\n", to_int(assoc[0][i]));
        params += ({ to_int(assoc[0][i]) });
        break;
      case PV_STR:
      case PV_QUOTED:
        //printf("string: %O\n", assoc[0][i]);
        params += ({ assoc[0][i] });
        break;
      default:
        //if (assoc[0][i] != "")
          //printf("OTHER:  %O\n", assoc[0][i]);
      }
    }
  }
  return call_other( ob, params );
}

/*
 * And I'll just put process_string in here also, so that it's all in
 * one place.
 */

string process_string(string s) {
  string *ss, proc;
  int i;

  ss = explode(s, "@@");
  if (strsrch(s, "@@") == 0)
    ss = ({ "" }) + ss;
  for (i = 1; i < sizeof(ss); i += 2) {
    proc = process_value(ss[i]);
    if (stringp(proc))
      ss[i] = proc;
  }
  return implode(ss, "");
}
// --- END [/mnt/home2/grok/lib/secure/simul_efun/process_value.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/simul_efun/snoop_simul.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/simul_efun/snoop_simul.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627479   Available: 13574833
Inodes: Total: 5242880    Free: 4960133
562 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/simul_efun/snoop_simul.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627479   Available: 13574833
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:58.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: snoop_simul.c,v 1.2 1998/03/24 07:28:59 pinkfish Exp $
 * $Log: snoop_simul.c,v $
 * Revision 1.2  1998/03/24 07:28:59  pinkfish
 * Add some docs to make the simulefuns more usefully lookupable.
 *
 * Revision 1.1  1998/01/06 05:13:15  ceres
 * Initial revision
 * 
*/
/** @ignore yes */
int snoop(object sno, object snop) {
  if ("/secure/master"->valid_snoop(sno, snop, previous_object())) {
    if (!snop)
    efun::snoop(sno);
    else
      efun::snoop(sno, snop);
    return 1;
  }
  return 0;
} /* snoop() */
// --- END [/mnt/home2/grok/lib/secure/simul_efun/snoop_simul.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/simul_efun/tell_creator.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/simul_efun/tell_creator.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627479   Available: 13574833
Inodes: Total: 5242880    Free: 4960133
849 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/simul_efun/tell_creator.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627479   Available: 13574833
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:58.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  
 * $Id: tell_creator.c,v 1.6 1999/05/12 12:02:32 turrican Exp $
 */
/**
 * This method writes a message to a creator, it's mainly meant 
 * for debug messages where sending a message to a specific 
 * creator is smarter than sending it to players, who will only get confused.
 *
 * @param cre the name or object to send the message to
 * @param fmt the format string
 * @param args the arguments to the sprintf
 */
varargs void tell_creator(mixed cre, string fmt, mixed args ...) {
  if (stringp(cre)) {
#if efun_defined(find_player)
    cre = efun::find_player(cre);
#else
    cre = "/obj/handlers/livings"->find_player(cre);
#endif
  }
  if (objectp(cre) && cre->query_creator()) {
    if (sizeof(args)) {
      tell_object(cre, sprintf(fmt, args ...));
    } else {
      tell_object(cre, fmt);
    }
  }
} /* tell_creator()*/

// --- END [/mnt/home2/grok/lib/secure/simul_efun/tell_creator.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/simul_efun/find_match.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/simul_efun/find_match.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627478   Available: 13574832
Inodes: Total: 5242880    Free: 4960133
4157 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/simul_efun/find_match.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627478   Available: 13574832
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:58.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: find_match.c,v 1.24 2001/02/28 01:29:05 presto Exp $
 * $Log: find_match.c,v $
 * Revision 1.24  2001/02/28 01:29:05  presto
 * Put in different version of is_in_me_or_environment()
 *
 * Revision 1.23  2000/09/07 21:13:24  pinkfish
 * Fix the docs.
 *
 * Revision 1.22  2000/09/07 21:11:30  pinkfish
 * Update the documentation.
 *
 * Revision 1.21  2000/06/28 03:49:11  pinkfish
 * Stop it runtiming.
 *
 * Revision 1.20  2000/06/26 19:55:02  pinkfish
 * Turn on the new parser for everyone.
 *
 * Revision 1.19  2000/06/24 03:48:44  presto
 * Line 163, was using ob[i] when ob was not an array.
 *
 * Revision 1.18  2000/06/23 03:40:56  pinkfish
 * Fix up the references to find_match.
 *
 * Revision 1.17  2000/06/10 08:20:34  pinkfish
 * Make pts able to use the system as well.
 *
 * Revision 1.16  2000/06/07 23:30:02  pinkfish
 * Fix up the return codes of the parser.
 *
 * Revision 1.15  2000/05/31 21:40:26  pinkfish
 * Some changes to make it work more correctly.
 *
 * Revision 1.14  2000/05/31 00:16:10  pinkfish
 * Add in some stuff to do matching of ambiguous things too.
 *
 * Revision 1.13  2000/05/26 18:48:37  pinkfish
 * Add in hooks to the new parser.
 *
 * Revision 1.12  2000/04/28 01:19:03  pinkfish
 * Stop people using "all" in dark/bright rooms.
 *
 * Revision 1.11  2000/04/28 01:13:14  pinkfish
 * Fix up some things to do with <cc> in <xx>
 *
 * Revision 1.10  1999/12/07 23:10:22  pinkfish
 * Fix up an error that was causing 0's to get stuck in the return array.
 *
 * Revision 1.9  1999/12/07 23:02:05  pinkfish
 * Fixes and changes.
 *
 * Revision 1.8  1998/09/30 14:38:39  wodan
 * added prototype for add_action free drivers.
 *
 * Revision 1.7  1998/09/01 21:19:46  pinkfish
 * Speed up the find_match code by using a function pointer for the
 * map methods.
 *
 * Revision 1.6  1998/09/01 21:04:28  pinkfish
 * Clean up the code slightly, plus make the syntaxes:
 * 'my book' and 'book here' work.
 *
 * Revision 1.5  1998/07/28 01:36:15  pinkfish
 * Stop '0' evaluating to everything.
 *
 * Revision 1.4  1998/03/24 07:28:59  pinkfish
 * Add some docs to make the simulefuns more usefully lookupable.
 *
 * Revision 1.3  1998/03/07 13:49:40  pinkfish
 * Fixes because of the new inherit structor of the simul_efun object.
 *
 * Revision 1.2  1998/03/06 05:31:47  pinkfish
 * Handle expanded inventory stuff...
 *
 * Revision 1.1  1998/01/06 05:13:15  ceres
 * Initial revision
 * 
 */
#define OBJ_PARSER_NO_CLASSES
#include <obj_parser.h>
inherit "/secure/simul_efun/obj_parser";

#include <playtesters.h>

private nosave mixed *rest;

mixed *query_strange_inventory(mixed *arr);
private object query_simul_efun_id(object ob, mixed *arr);
private object query_frac_simul_efun_id(object ob, mixed *arr);

#if !efun_defined(living)
int living(object);
#endif

/* If anyone can tell me what this does...
 * I would be most apprecative, Pinkfish... Yes yes ok i did write it.
 */
/**
 * The find_match simul_efun.
 * @author Pinkfish
 */

/**
 * This method checks to see if the specified object is in the player
 * or the environment.  If it has no environment it is considered to
 * be here.
 * @param ob the object to test
 * @param player the player to check against
 * @return 1 if it is, 0 if not
 */

int is_in_me_or_environment(object thing, object person)  {
   object env;

   if ((env = environment(thing)) == environment(person))
      return 1;

   // This is a special case if 'thing' is a room.
   // Needed for the 'get' command, and others (I assume)
   if (!env)
      return 1;

   while (env  &&  !living(env))
      env = environment(env);

   if (env == person)
      return 1;

   return 0;
}

/**
 * This method returns the array of objects that are only inside the
 * player in question, or in their environment.  It excludes any items
 * in other peoples inventorys.
 * @param obs the objects to filer
 * @param player the player to check
 * @return the filtered objects
 */
object* filter_in_me_or_environment(object* obs, object player) {
   return filter(obs, (: is_in_me_or_environment($1, $2) :), player);
} /* filter_in_me_or_environment() */
// --- END [/mnt/home2/grok/lib/secure/simul_efun/find_match.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/simul_efun/back_trace.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/simul_efun/back_trace.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627477   Available: 13574831
Inodes: Total: 5242880    Free: 4960133
1336 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/simul_efun/back_trace.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627477   Available: 13574831
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:58.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: back_trace.c,v 1.2 1998/03/24 07:28:59 pinkfish Exp $
 * $Log: back_trace.c,v $
 * Revision 1.2  1998/03/24 07:28:59  pinkfish
 * Add some docs to make the simulefuns more usefully lookupable.
 *
 * Revision 1.1  1998/01/06 05:13:15  ceres
 * Initial revision
 * 
*/
/**
 * Cotains some simul_efuns.
 * @author Pinkfish
 */
/**
 * This method returns out the call stack traces.  It is usualy
 * called in the error handling routines in the master object
 * but it can be used elsewhere for debuggin purposes.  You
 * can see the results of this function in /log/runtime and
 * /log/catch.
 * @return call stack trace
 */
string back_trace() {
  string ret = "", *progs, *funcs, *obs, name;
  int i;

  progs = map(call_stack(0), (: $1[1..<3] :));
  obs = map(call_stack(1), (: file_name($1)[1..] :));
  funcs = call_stack(2);
  i = sizeof(progs);


  ret = "Time: " + ctime(time()) + "\n";
  
  while (i-- > 1) {
    if (objectp(obs[i]))
      name = obs[i]->query_name();
    if (!name)
      name = "null";
    if (obs[i] == progs[i])
      ret += sprintf("%s() in /%s (%s)\n", funcs[i], progs[i], name);
    else
      ret += sprintf("%s() in inherited file /%s in /%s (%s)\n", funcs[i],
                     progs[i], obs[i], name);
    name = 0;
  }
  return ret;
} /* back_trace() */
// --- END [/mnt/home2/grok/lib/secure/simul_efun/back_trace.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/loader.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/loader.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627477   Available: 13574831
Inodes: Total: 5242880    Free: 4960133
3421 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/loader.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627477   Available: 13574831
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: loader.c,v 1.1 1998/01/06 04:03:45 ceres Exp $
 * $Log: loader.c,v $
 * Revision 1.1  1998/01/06 04:03:45  ceres
 * Initial revision
 * 
*/
/**
 * This is the domain preloader that handles preloading important files for
 * the domains.
 *
 * When the mud boots this object loads each item in each domains preload
 * list. It will only load files which are within the domain that is being
 * preloaded. In other words you cannot have the AM loader load
 * /guilds/Ankh-Morpork/myfile this must be done in the guilds pre-loader.
 *
 * Functions are provided to enable domain leaders and deputies to add and
 * remove files from the domains preload list.
 *
 * @see add_pre_load, remove_pre_load, query_pre_load
 */

string *pre_load;

/** @ignore yes */
void create() {
  int i;
  string domain;
  
  foreach(domain in "/secure/master"->query_domains()) {
    unguarded((: restore_object, "/d/"+ domain + "/loader" :));
    if (!pre_load)
      pre_load = ({ });
    for (i=0;i<sizeof(pre_load);i++) {
      if(pre_load[i] && explode(pre_load[i], "/")[1] != domain)
        printf("invalid " + domain + " preload: " + pre_load[i] +
               "\n");
      else {
        printf(domain +" pre_loading "+pre_load[i]+".\n");
        if(catch(call_other(pre_load[i], "??")))
          call_out("do_load", 0, pre_load[i]);
      }
    }
  }
}

/** @ignore yes */
void do_load(string str) {
  call_other(str, "??");
}

/** @ignore yes */
private int validate(string domain, object who) {
  string name;
  
  if(member_array(domain, "/secure/master"->query_domains()) == -1)
    return 0;

  if(!userp(who) || !interactive(who))
    return 0;
  
  name = who->query_name();
  
  if(!!"/secure/master"->query_trustee(name) &&
     !"/secure/master"->is_leader_of(name, domain) &&
     !"/secure/master"->is_deputy_of(name, domain))
    return 0;

  return 1;
}

/**
 * This method adds a file to a domains preload list.
 *
 * @param domain The domain
 * @param str The basename of the file to be added.
 * @return 1 for success, 0 for failure.
 */
int add_pre_load(string domain, string str) {
  if(!validate(domain, previous_object(1)))
    return 0;

  if(explode(str, "/")[1] != domain)
    return 0;
  
  unguarded((: restore_object, "/d/"+ domain + "/loader" :));
  if (!pre_load)
    pre_load = ({ });
  
  if (member_array(str, pre_load) == -1)
    pre_load += ({ str });
  
  save_object("/d/" + domain + "/loader");
  return 1;
}

/**
 * This method removes a file from a domains preload list.
 *
 * @param domain The domain
 * @param str The basename of the file to be removed.
 * @return 1 for success, 0 for failure.
 */
int remove_pre_load(string domain, string str) {
  int i;

  if(!validate(domain, previous_object(1)))
    return 0;
    
  unguarded((: restore_object, "/d/"+ domain + "/loader" :));
  if (!pre_load)
    pre_load = ({ });

  if ((i=member_array(str, pre_load)) == -1)
    return 0;
  pre_load = delete(pre_load, i, 1);
  save_object("/d/" + domain + "/loader");
}

/**
 * This method returns the domains preload list.
 *
 * @param domain The domain
 * @return A list of files to be preloaded
 */
string *query_pre_load(string domain) {
  if(member_array(domain, "/secure/master"->query_domains()) == -1)
    return ({ });
  
  unguarded((: restore_object, "/d/"+ domain + "/loader" :));
  if (!pre_load)
    pre_load = ({ });
  return pre_load;
}
// --- END [/mnt/home2/grok/lib/secure/loader.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/rcs_handler.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/rcs_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627476   Available: 13574830
Inodes: Total: 5242880    Free: 4960133
3836 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/rcs_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627476   Available: 13574830
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <player_handler.h>

#define SAVE_FILE "/secure/rcs_handler"
#define CMD_NUM 5
#define MAX_MOD_TIME (86400 * 90)

mapping _locks = ([]);

void create()  {
   unguarded((: restore_object, SAVE_FILE :));
   call_out("clean_up", 2);
}

void clean_up(string *names) {
  string name, file, *cmd;
  int changed, i;
  
  if(!names) {
    names = keys(_locks);
  }

  if(!sizeof(names))
    return 0;
  
  name = names[0];

  if(sizeof(names) > 1) {
    while(sizeof(names) > 1 && (!names[1] || !arrayp(names[1])))
      names = names[1..];
    if(sizeof(names) > 1)
      call_out("clean_up", random(15), names[1..]);
  }
  
  foreach(file in _locks[name]) {
    if(i++ > 100)
      break;
    if(file_size(file) <= 0) {
      _locks[name] -= ({ file });
      changed = 1;
    } else if((time() - stat(file)[1]) > MAX_MOD_TIME ||
            !PLAYER_HANDLER->test_creator(name)) {
      cmd = ({ "-w" + name,
                 "-u",
                 "-mForcibly released due to inactivity",
                 file[1..] });
      external_start(CMD_NUM, cmd, "read_call_back", "write_call_back",
                     "close_call_back");
      _locks[name] -= ({ file });
      changed = 1;
    }
  }

  if(!sizeof(_locks[name])) {
    map_delete(_locks, name);
    changed = 1;
  }

  if(changed)
    unguarded((: save_object, SAVE_FILE, 2 :));
}

void read_call_back(int fd, mixed mess) { return; }
void write_call_back(int fd) { return; }
void close_call_back(int fd) { return; }

void add_lock(mixed cre, string file)  {
   string name;
   if( file[0] != '/' )
      file = "/" + file;

   if (stringp(cre))  name = lower_case(cre);
   else name = cre->query_name();
   if (undefinedp(_locks[name]))
      _locks[name] = ({ file });
   else if ( member_array( file, _locks[name] ) < 0 )
      _locks[name] += ({ file });
   unguarded((: save_object, SAVE_FILE, 2 :));

   return;
}


void remove_lock(mixed cre, string file)  {
   string name;
   if( file[0] != '/' )
      file = "/" + file;

   if (stringp(cre))  name = lower_case(cre);
   else name = cre->query_name();
   if (!undefinedp(_locks[name]))  {
      _locks[name] -= ({ file });
      unguarded((: save_object, SAVE_FILE, 2 :));
   }

   return;
}
/**
 * Return a mapping of non-creators who have files locked and which files
 * those people have locked.
 */
mapping query_non_creators() {
  mapping res;
  string person;

  res = ([ ]);
  foreach(person in keys(_locks)) {
    if(!PLAYER_HANDLER->test_creator(person))
      res[person] = _locks[person];
  }
    return res;
}

string *query_locks(mixed cre)  {
   string name;

   if (stringp(cre))  name = lower_case(cre);
   else name = cre->query_name();
   return _locks[name];
}


void reset_locks(mixed cre, int start)  {
  string file, name, rcsfile, tmp;
  int idx, i, changed;

  changed = 0;
  
  if (stringp(cre))
    name = lower_case(cre);
  else
    name = cre->query_name();
  
  if (undefinedp(_locks[name]))
    return;

  for(i=0; i < sizeof(_locks[name]) && i < start + 100; i++) {
    file = _locks[name][i];
    
    idx = strsrch(file, "/", -1);
    rcsfile = file[0 .. idx] + "RCS/" + file[idx + 1 .. ] + ",v";
    
    if (file_size(rcsfile) > 0) { 
      tmp = read_file(rcsfile, 4, 1);
      if (tmp == "locks\n") { // we've found a lock
        string lockname;
        tmp = read_file(rcsfile, 5, 1);
        sscanf(tmp, "\t%s:", lockname);
        if (lockname != name)  {
          _locks[name] -= ({ file });
          changed = 1;
        }
      } else {
        _locks[name] -= ({ file });
        changed = 1;
      }
    }
  }

  if(!sizeof(_locks[name])) {
    map_delete(_locks, name);
    changed = 1;
  }
  
  if (changed)
    unguarded((: save_object, SAVE_FILE, 2 :));
  return;
}

string help() {
  return "Displays the files that are locked in your current directory.";
}
// --- END [/mnt/home2/grok/lib/secure/rcs_handler.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/items/clean.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/items/clean.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627475   Available: 13574829
Inodes: Total: 5242880    Free: 4960133
1291 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/items/clean.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627475   Available: 13574829
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "standard.h"
inherit "/std/object";

setup()
{
  set_name("test");
  set_short("test");
}

init()
{
  ::init();
  add_action("purge","purge");
}

// mixed *stat(string str, int|DEFAULT 0);
// ({ file_size, last_time_file_touched, time_object_loaded }) 

#define DAYS60 5184000
#define DAYS90 7776000
 

int purge(string str)
{
  mixed *s, *dir, *let;
  int i,j,t;
  string tmp;

  let = ({"a","b","c","d","e","f","g","h","i","j","k","l",
                  "m","n","o","p","q","r","s","t","u","v","w","x",
                  "y","z", });

  seteuid("Root");
  t=time();

  for (j=0;j<26;j++)
  {
    dir=get_dir("/players/"+let[j]+"/*.o");
    for (i=0;i<sizeof(dir);i++)
    {
      s=stat("/players/"+let[j]+"/"+dir[i]);
      if ( sizeof(s) && ((t-(int)s[1]) > DAYS60))
      {
        sscanf(dir[i],"%s.o",tmp);
        if (!"/secure/master"->query_promoted(tmp))
        {
          log_file("EXPIRED",dir[i]+" unused for > 60 days, moved\n");
          rename("/players/"+let[j]+"/"+dir[i],"/players/OLD/"+dir[i]);
        }
        else
          log_file("EXPIRED",dir[i]+" unused for > 60 days, promoted, not moved\n");
      }
    }
  }

  "/obj/handlers/library"->clean_library();
  "/room/bankmain"->clean_bank();
  "/obj/handlers/mail_track"->clean_post();

  return 1;
}// --- END [/mnt/home2/grok/lib/secure/items/clean.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/items/bomb.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/items/bomb.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627474   Available: 13574828
Inodes: Total: 5242880    Free: 4960133
536 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/items/bomb.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627474   Available: 13574828
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/object";

void setup() {
  set_name( "bomb" );
  set_short( "bomb of departure" );
  set_long( "This is a handy creator object to get rid of annoying swine.\n" );
  set_main_plural( "bombs" );
  reset_drop();
} /* setup() */

void reset() {
  call_out( "detonate", 2 );
} /* reset() */

void detonate() {
  environment( this_object() )->quit();
  call_out( "detonate", 15 );
} /* detonate() */

void init_dynamic_arg( mapping args ) {
  ::init_dynamic_arg( args );
  call_out( "detonate", 15 );
} /* init_dynamic_arg() */
// --- END [/mnt/home2/grok/lib/secure/items/bomb.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/force.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/force.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627474   Available: 13574828
Inodes: Total: 5242880    Free: 4960133
3628 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/force.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627474   Available: 13574828
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: force.c,v 1.2 2000/06/23 03:40:56 pinkfish Exp $
 * $Log: force.c,v $
 * Revision 1.2  2000/06/23 03:40:56  pinkfish
 * Fix up the references to find_match.
 *
 * Revision 1.1  1998/01/06 05:08:31  ceres
 * Initial revision
 * 
*/
/* code to handle forcing.   The method used will be to ask the object to
 * do the command.  While this is similar to the original method of doing this
 * it will be used to be more in the style of asking things to do things,
 * rather than the making things do things without asking them first. */

#include <obj_parser.h>

#define FORCE_COST 1
#define ILLEGAL_FORCE ({ "alias", "unalias", "mv", "mkdir", "call", "rm", \
                         "force", "kill", "gauge", "exec", "promote", \
                         "new_domain", "rmdir", "cd", "history", "echoall", "shout" })

nosave string fname;
nosave int no_force_me;


void force_commands() {
  sscanf(file_name(this_object()), "%s#", fname);
  if(!this_object()->query_property("npc") &&
     this_object()->query_property("force") || fname == "/global/lord")
    add_action("do_force", "force");
  if(fname == "/global/lord")
    add_action("no_force", "noforce");
}

protected int no_force(string str) {
  if(fname!="/global/lord")
    return 0;
  if(str == "on") {
    no_force_me = 1;
    write("Ok.\n");
    return 1;
  }
  if(str == "off") {
    no_force_me = 0;
    write("Ok.\n");
    return 1;
  }
  write("Forcing you is currently ");
  if(no_force_me) {
    write("disabled.\n");
  }
  else {
    write("enabled.\n");
  }
  return 1;
}

int do_force(string str) {
  string who, what;
  object *obs, ob;
  int i;
  class obj_match omatch;

  if(fname == "/global/player" && !this_player()->query_property("force")) {
    notify_fail("You do not have the ability to do that yet.\n");
    return 0;
  }
  if(!str || sscanf(str, "%s %s", who, what) != 2) {
    notify_fail("Usage : force <person> <command>\n");
    return 0;
  }
  if(this_player()->adjust_social_points(-FORCE_COST) < 0) {
    notify_fail("Insufficient social points.\n");
    return 0;
  }
  who = (string)this_player()->expand_nickname(who);
  who = lower_case(who);
  omatch = match_objects_in_environments(who, environment(this_object()));
  if (omatch->result != OBJ_PARSER_SUCCESS) {
    notify_fail(match_objects_failed_mess(omatch));
    return 0;
  }
  obs = omatch->objects;
  if (!sizeof(obs))
    if (!(ob = find_living(who))) {
      notify_fail("No such living thing.\n");
      return 0;
    } else
      obs += ({ ob });
  for (i=0;i<sizeof(obs);i++)
    if(!obs[i]->do_force_on_me(what))
      write(capitalize(who) + " didn't want to do that.\n");
  write("Ok.\n");
  return 1;
}

int do_force_on_me  (string str) {
  string temp1, temp2;
  object forcer;

  forcer = this_player(1);
  if(!forcer) {
    forcer = previous_object();
  }
  if(!this_object()->query_property("npc")) {
    log_file("FORCE", ctime(time()) + " " + forcer->query_name() + " " +
                      this_object()->query_name() + " : " + str);
  }
  tell_object(this_object(), forcer->query_cap_name() +
        " tries to force you to " + str + "\n");
  if (no_force_me || (string)this_object()->query_name() == "pinkfish") {
    log_file("FORCE", " (failed)\n");
    return 0;
  }
  if(!sscanf(str, "%s %s", temp1, temp2)) {
    temp1 = str;
  }
/* Delete this at your own peril */
  if (member_array(temp1, ILLEGAL_FORCE) != -1 &&
      !"secure/master"->high_programmer(geteuid(forcer))) {
    log_file("FORCE", " (failed)\n");
    return 0;
  }
  command(str);
  log_file("FORCE", " (succeeded)\n");
  return 1;
}
// --- END [/mnt/home2/grok/lib/secure/force.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/simul_efun.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/simul_efun.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627473   Available: 13574827
Inodes: Total: 5242880    Free: 4960133
1735 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/simul_efun.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627473   Available: 13574827
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/secure/simul_efun/add_a";
#if !efun_defined(add_action)
inherit "/secure/simul_efun/add_action";
#endif
inherit "/secure/simul_efun/add_command";
inherit "/secure/simul_efun/aggregate";
//inherit "/secure/simul_efun/alt_move";
inherit "/secure/simul_efun/amtime";
inherit "/secure/simul_efun/array";
inherit "/secure/simul_efun/ctime_elapsed";
inherit "/secure/simul_efun/back_trace";
#if !efun_defined(dump_socket_status)
inherit "/secure/simul_efun/dump_socket_status";
#endif
//inherit "/secure/simul_efun/extract";
inherit "/secure/simul_efun/find_match";
inherit "/secure/simul_efun/find_member";
inherit "/secure/simul_efun/find_other_call_out";
inherit "/secure/simul_efun/get_function_pointer";
inherit "/secure/simul_efun/inside_shorts";
inherit "/secure/simul_efun/mapping";
/*
 * NB: Because of the fact this file uses it, base_name is
 * inherited into modified_efuns.
 */
inherit "/secure/simul_efun/modified_efuns";
// THis in now inherited through the parser.
//inherit "/secure/simul_efun/multiple_short";
inherit "/secure/simul_efun/pk_check";
inherit "/secure/simul_efun/pl_to_ob";
inherit "/secure/simul_efun/process_value";
inherit "/secure/simul_efun/query_ident";
inherit "/secure/simul_efun/query_number";
inherit "/secure/simul_efun/roll_MdN";
#if !efun_defined(shuffle)
inherit "/secure/simul_efun/shuffle";
#endif
inherit "/secure/simul_efun/snoop_simul";
inherit "/secure/simul_efun/sqrt";
inherit "/secure/simul_efun/strip_colours";
inherit "/secure/simul_efun/str_inven";
inherit "/secure/simul_efun/debug";
//inherit "/secure/simul_efun/thing_to_string";
inherit "/secure/simul_efun/unguarded";
inherit "/secure/simul_efun/virtual";

void create() {
  seteuid("Root");
  find_match::create();
}
// --- END [/mnt/home2/grok/lib/secure/simul_efun.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/security.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/security.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627472   Available: 13574826
Inodes: Total: 5242880    Free: 4960133
517 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/security.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627472   Available: 13574826
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: security.c,v 1.2 2002/04/19 20:44:22 pinkfish Exp $
 * $Log: security.c,v $
 * Revision 1.2  2002/04/19 20:44:22  pinkfish
 * *** empty log message ***
 *
 * Revision 1.1  1998/01/06 05:08:31  ceres
 * Initial revision
 * 
*/
#include <security.h>

varargs nomask mixed call_unguarded(string func, mixed a1,
                                           mixed a2, mixed a3, mixed a4) {

  return call_other(previous_object(), func, a1, a2, a3, a4);
} /* call_unguarded() */
// --- END [/mnt/home2/grok/lib/secure/security.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/cmds/lord/hl_ord.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/cmds/lord/hl_ord.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627472   Available: 13574826
Inodes: Total: 5242880    Free: 4960133
1294 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/cmds/lord/hl_ord.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627472   Available: 13574826
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: hl_ord.c,v 1.1 1998/01/06 05:11:09 ceres Exp $
 * $Log: hl_ord.c,v $
 * Revision 1.1  1998/01/06 05:11:09  ceres
 * Initial revision
 * 
*/
/* hlord command, trial out by Turrican for a commands daemon. */

#define HIST "/obj/handlers/hist_handler"

mixed cmd() {
  int i;
  mixed *hist;

  if (!master()->query_lord((string)geteuid(this_player()))) 
    return 0;
  seteuid(geteuid(this_player()));
  hist = HIST->query_lord_history();
  if (!pointerp(hist) || !sizeof(hist))
    return notify_fail("Nobody said anything on the lord channel.\n");
  write("The lord channel history is:\n");
  for (i=0;i<sizeof(hist);i++) {
    if (sizeof(hist[i]) > 2) {
      efun::tell_object(this_player(), 
           this_player()->fix_string(sprintf("*%s* %s%-=*s\n",
           ctime(hist[i][2])[11..18], hist[i][0],
           (int)this_player()->query_cols()-strlen(hist[i][0])-11,
           hist[i][1])));
    }
    else
      efun::tell_object(this_player(), 
           this_player()->fix_string(sprintf("%s%-=*s\n",
           hist[i][0], (int)this_player()->query_cols()-strlen(hist[i][0]),
           hist[i][1])));
    }
  return 1;
}

void dest_me() {
  destruct(this_object());
}

void clean_up() {
  dest_me();
}

void reset() {
  dest_me();
}
// --- END [/mnt/home2/grok/lib/secure/cmds/lord/hl_ord.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/cmds/lord/cleanup.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/cmds/lord/cleanup.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627471   Available: 13574825
Inodes: Total: 5242880    Free: 4960133
429 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/cmds/lord/cleanup.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627471   Available: 13574825
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: cleanup.c,v 1.1 1998/01/06 05:11:09 ceres Exp $
 * $Log: cleanup.c,v $
 * Revision 1.1  1998/01/06 05:11:09  ceres
 * Initial revision
 * 
*/
/* command, trial out by Turrican for a commands daemon. */

inherit "/cmds/base";
inherit "/cmds/speech";

mixed cmd(string mess) {

	if("/secure/bulk_delete"->delete_files(mess))
		write("Ok.\n");
	else
		return notify_fail("Sorry.\n");
}
// --- END [/mnt/home2/grok/lib/secure/cmds/lord/cleanup.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/cmds/creator/rcsc_reate.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/cmds/creator/rcsc_reate.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627471   Available: 13574825
Inodes: Total: 5242880    Free: 4960133
5583 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/cmds/creator/rcsc_reate.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627471   Available: 13574825
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: rcsc_reate.c,v 1.9 2000/03/04 00:07:55 turrican Exp $
 * $Log: rcsc_reate.c,v $
 * Revision 1.9  2000/03/04 00:07:55  turrican
 * Modified the order of things so you can use rcs commands on multiple .c files
 *
 * Revision 1.8  1998/04/02 05:11:45  ceres
 * Removed the log adding bit. It's somewhat unnecessary since rcslog will give the same info.
 *
 * Revision 1.7  1998/03/11 16:43:32  pinkfish
 * Figuredout what it was supposed to be for and set it up
 * to do that.  (cmd_str).
 *
 * Revision 1.6  1998/03/11 16:36:53  pinkfish
 * No idea whct cmd_str was supposed to do.  It is certainly
 * not set to anything right now...
 *
 * Revision 1.5  1998/03/09 15:57:34  turrican
 * Now uses the editor to enter the comment.
 *
 * Revision 1.4  1998/02/24 17:18:00  turrican
 * REALLY fix up the dollar sign stuff :)
 *
 * Revision 1.3  1998/02/15 17:19:36  pinkfish
 * Really fix up the dollars sign stuff :)
 *
 * Revision 1.2  1998/02/15 17:17:25  pinkfish
 * Fix up the comment stuff so that it does not get manged when checked in/out.
 *
 * Revision 1.1  1998/02/15 17:02:58  pinkfish
 * Initial revision
 *
 * Revision 1.1  1998/01/06 05:10:49  ceres
 * Initial revision
 * 
 */
inherit "/cmds/base";
#include <creator.h>

#define CMD_NUM 5

mapping globals = ([]), ret = ([]);
string cmd_str;

#define TP globals[fd]
#define RET ret[fd]

mixed cmd(string arg) {
  string *files;
  int nfiles = 0;
  string bit, *bits;
  int add_comments;
  string tmp;
  
  if (!arg) {
    return notify_fail("rcscreate: No arguments.\n");
  }

  notify_fail("rcscreate: no such file "+arg+".\n");
  
  bits = explode(arg, " ");
  arg = "";
  bits -= ({""});

  foreach (bit in bits) {
    string  file;
    if (bit[0] == '-') {
      if (bit[1] == 'c') {
        add_comments = 1;
      } else {
        arg += (" " + bit);
      }
      continue;
    }
    
    files = this_player()->get_files(bit);
    foreach (file in files) {
      if (master()->valid_write(file, geteuid(this_player()), "cmd")) {
        string dir, *tmpbits;

        // Make sure there is an RCS directory here. If not make one.
        tmpbits = explode(file, "/");
        /* Do not let the rcs create create rcs entries for these files. */
        if (tmpbits[<1] == "RCS" ||
            tmpbits[<1] == "." ||
            tmpbits[<1] == ".." ||
            tmpbits[<1] == "ERROR_REPORTS") {
          continue;
        }
        if (sizeof(tmpbits) > 1) {
          dir = "/" + implode(tmpbits[0..<2], "/") + "/RCS";
        } else {
          dir = "/RCS";
        }
        
        if (file_size(dir) == -1) {
          write("No directory "+dir+", creating one.\n");
          mkdir(dir);
        }
        
        // insert the standard comments at the top of the file
        if (add_comments) {
          tmp = read_file(file);
          if ( file[ strsrch( file, ".", -1 ) .. ] == ".c"  ||
               file[ strsrch( file, ".", -1 ) .. ] == ".h" )  {
            tmp = replace_string(tmp, "/*  -*- LPC -*-  */\n", "");
            tmp = replace_string(tmp, "/* -*- LPC -*- */\n", "");
  
            // Split this write over multiple lines to avoid the rcs auto
            // replacement stuff for these strings.
            write_file(file,
                       "/*  -*- LPC -*-  */\n"
                       "/*\n"
                       " * $", 1);
            write_file(file,
                       "Locker$\n"
                       " * $");
            write_file(file,
                       "Id$\n"
                       " *\n"
                       " *\n"
            //           " * $");
            //          write_file(file,
            //           "Log$\n"
                       " */\n\n" + tmp);
          }
          else  {
            tmp = replace_string( tmp, "#  -*- LPC -*-  #\n", "" );
            tmp = replace_string( tmp, "# -*- LPC -*- #\n", "" );
            write_file( file,
                        "#  -*- LPC -*- #\n"
                        "#\n"
                        "# $", 1 );
            write_file( file,
                        "Locker$\n"
                        "# $");
            write_file(file, "Id$\n"
                        "#\n"
                        "#\n"
                        "#\n\n" + tmp );
          }
        }
        arg += (" " + file[1..]);
        nfiles++;
      } else {
        notify_fail("You do not have write access to "+file+"\n");
      }
    }
  }

  if (!nfiles) {
    return 0;
  }

  printf("Enter a comment.\n");
  cmd_str = arg;
  this_player()->do_edit(0, "do_ci");
  return 1;
}

void do_ci(string comment) {
  int fd;
  string *cmd = allocate(4);

  if (!comment) {
    printf("No comment given, aborting.\n");
    return;
  }

  cmd[0] = "-w" + this_player()->query_name();
  cmd[1] = "-i";
  cmd[2] = "-u";
  cmd[3] = "-t-" + comment;
  cmd += explode(cmd_str, " ");
#ifdef DEBUG  
  printf("CMD: %O\n", cmd);
#endif  
  fd = external_start(CMD_NUM, cmd, "read_call_back", "write_call_back",
                      "close_call_back");
    
  TP = this_player();
  RET = "";
}

// I _think_ this is the function to write the comment string to the ci command
void read_call_back(int fd, mixed mess) {
  mess = replace_string(mess, "/home/atuin/lib", "");
  RET += mess;
}

void write_call_back(int fd) {
  tell_object(TP, "rcscreate: Write_call_back called.\n");
}

void close_call_back(int fd) {

  if (RET != "") {
    TP->more_string(RET);
  } else {
    tell_object(TP, "rcscreate completed.\n");
  }
  map_delete(ret, fd);
  map_delete(globals, fd);
}
// --- END [/mnt/home2/grok/lib/secure/cmds/creator/rcsc_reate.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/cmds/creator/rcsi_n.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/cmds/creator/rcsi_n.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627469   Available: 13574823
Inodes: Total: 5242880    Free: 4960133
4594 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/cmds/creator/rcsi_n.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627469   Available: 13574823
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Id: rcsi_n.c,v 1.28 2002/11/18 01:34:20 ceres Exp $
 */
/**
 * Command to perform an RCS "ci -u", ie. to checkin a file and retrieve
 * a read-only version.
 *
 * @author Ceres
 */
inherit "/cmds/base";
#include <creator.h>

#define CMD_NUM 5
//#define DEBUG

mapping globals = ([]), ret = ([]), cmds = ([]), comments = ([ ]);

#define TP globals[fd]
#define RET ret[fd]
#define CMDS cmds[this_player()]
#define COMMENT comments[TP]

mixed cmd(string arg) {
  int nfiles = 0;
  string bit, *bits, *tmp, *notin;
  object *things;
  
  if (!arg) {
    return notify_fail("rcsin: No arguments.\n");
  }

  bits = explode(arg, " ");
  arg = "";
  bits -= ({ "", 0 });
  notin = ({ });
  
  foreach(bit in bits) {
    string *files = ({ }), file;
    if (bit[0] == '-') {
      arg += (" " + bit);
      continue;
    }

    if (sizeof(files = this_player()->get_files(bit))) {
      foreach(file in files) {
        tmp = explode(file, "/");
        if(file_size("/" + implode(tmp[0..<2], "/") + "/RCS/" + tmp[<1]+",v") >
           0) {
          nfiles++;
          arg += (" " + file[1..]);
        } else {
          notin += ({ file });
        }
      }
    } else {
      if(sizeof(things = WIZ_PRESENT->wiz_present(bit, this_player()))) {
        file = file_name(things[0]);
        sscanf(file, "%s#%*d", file);
        if (file_size(file) <= 0)
          file += ".c";

        tmp = explode(file, "/");
        if(file_size("/" + implode(tmp[0..<2], "/") + "/RCS/" + tmp[<1]+",v") >
           0) {
          nfiles++;
          arg += (" " + file[1..]);
        } else {
          notin += ({ file });
        }
      }
    }
  }

  if(!nfiles) {
    if(sizeof(notin))
      return notify_fail("rcsin: file not in RCS " +
                         query_multiple_short(notin) + ".\n");
    else
      return notify_fail("rcsin: no such file "+arg+".\n");
  }

  if(sizeof(notin))
    write("rcsin: file not in RCS " + query_multiple_short(notin) + ".\n");

  printf("Enter a comment.\n");
  CMDS = arg;
  this_player()->do_edit(0, "do_ci");
  return 1;
}

void do_ci(string comment) {
  int fd;
  string *cmd = allocate(3);

  if (!comment) {
    printf("No comment given, aborting.\n");
    return;
  }

  cmd[0] = "-w" + this_player()->query_name();
  cmd[1] = "-u";
  cmd[2] = "-m"+comment;
  cmd += explode(CMDS, " ");


#ifdef DEBUG  
  printf("CMD: %O\n", cmd);
#endif  
  fd = external_start(CMD_NUM, cmd, "read_call_back", "write_call_back",
                      "close_call_back");
    
  TP = this_player();
  RET = "";
  COMMENT = comment;
}

// I _think_ this is the function to write the comment string to the ci command
void read_call_back(int fd, mixed mess) {
  mess = replace(mess, "/home/atuin/lib", "");
  RET += mess;
}

void write_call_back(int fd) {
  tell_object(TP, "rcsin: Write_call_back called.\n");
}

void close_call_back(int fd) {
  string file, *file_stuff, *bits, log, lname;
  int i;
  object master;
  
  if (RET != "") {
    TP->more_string(RET);
    file_stuff = explode(RET, "\n");
    i = 0;
    while (i + 2 < sizeof(file_stuff))  {
      if (file_stuff[i + 2] == "done")  {  /* success! */
        sscanf(file_stuff[i], "%*s  <--  %s", file);
        RCS_HANDLER->remove_lock(TP, file);
        
        if(file[0] == 'w')
          lname = "";
        else if(file[0] == 'd') {
          bits = explode(file, "/");
          if(sizeof(bits) >= 2 &&
             member_array(bits[1], "/secure/master"->query_domains()) != -1) {
            master = find_object("/d/" + bits[1]+"/master");
            if(!master)
              TP->tell_object("No master object for domain: " + bits[1] +
                              ".\n");
            else
              lname = master->query_changelog(file);
          }
          if(!lname)
            lname = "/d/" + explode(file, "/")[1] + "/ChangeLog";
        } else
          lname = "/log/ChangeLog";

        if(lname != "") {
          log = TP->fix_string(sprintf(" * %s %s %s\n%s\n",
                                       ctime(time())[4..],
                                       file, TP->query_name(),
                                       COMMENT), 80, 21);
          log_file(lname, log);
        }
        i += 3;
      } else if (sscanf(file_stuff[i], "%*sNo such file or directory"))  {
        ++i;
      } else if (file_stuff[i + 1][0..2] == "ci:") {
          i += 2;
      } else {
          i += 3;
      }
    }
  } else {
    tell_object(TP, "rcsin completed.\n");
  }
  
  map_delete(ret, fd);
  map_delete(globals, fd);
  map_delete(comments, TP);
}
// --- END [/mnt/home2/grok/lib/secure/cmds/creator/rcsi_n.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/cmds/creator/lo_ad.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/cmds/creator/lo_ad.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627468   Available: 13574822
Inodes: Total: 5242880    Free: 4960133
1186 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/cmds/creator/lo_ad.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627468   Available: 13574822
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Id: lo_ad.c,v 1.2 1999/05/27 13:53:08 turrican Exp $
 */

inherit "/cmds/base";

mixed cmd(string str) {
  string *filenames, err, fname, *failed, *succ, ret, load_err;
  int size;

  if (!str) {
    return notify_fail("Load what?\n"); 
  }
  filenames = this_player()->get_cfiles(str);
  if (!sizeof(filenames)) {
    return notify_fail("No such object.\n");
  }
  failed = succ = ({ });
  load_err = "";
  foreach (fname in filenames) {
    if (file_size(fname) < 0) {
      failed += ({ fname });
      continue;
    }
    if ((err = catch(fname->load_up_with_yellow()))) {
      load_err += sprintf("Failed to load %s, error: %s", fname, err);
    } else {
      succ += ({ fname });
    }
  }
  ret = "";
  if ((size = sizeof(failed))) {
    ret += sprintf("%s %s not %sregular file%s.\n",
                   query_multiple_short(failed), (size == 1 ? "is" : "are"),
                   (size == 1 ? "a " : ""), (size == 1 ? "" : "s"));
  }
  if (strlen(load_err)) {
    ret += load_err;
  }
  if (sizeof(succ)) {
    ret += sprintf("$I$5=$C$Loaded %s.\n", query_multiple_short(succ));
  }
  this_player()->show_message("$P$Load$P$" + ret);
  return 1;
}
// --- END [/mnt/home2/grok/lib/secure/cmds/creator/lo_ad.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/cmds/creator/du.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/cmds/creator/du.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627468   Available: 13574822
Inodes: Total: 5242880    Free: 4960133
1350 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/cmds/creator/du.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627468   Available: 13574822
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 */

#define MAX_FILES 1000

inherit "/cmds/base";

mapping _counts = ([ ]);

protected int rec_du(string path) {
  string *files;
  int i, size, tot;

  if (path[strlen(path)-1] != '/') {
    path += "/";
  }
  files = get_dir(path+"*");
  _counts[this_player()] += sizeof(files);
  for (i=0;i<sizeof(files);i++) {
    if (files[i] == "." || files[i] == "..") {
      continue;
    }
    size = file_size(path+files[i]);
    if (size > 0) {
      tot += size;
    } else if (size == -2 && (_counts[this_player()] < MAX_FILES)) {
      printf("%-30s %5d\n", path+files[i], (size = rec_du(path+files[i])));
      tot += size*1024;
    }
  }
  return (tot+1023)/1024;
}

int cmd( string path ) {
    if ( !path ) 
        return 0;

    _counts[this_player()] = 0;
    if ( master()->valid_read( path, geteuid( this_player() ) ) ) {
      printf( "%-30s %5d\n", "Total:", rec_du( path ) );
      if(_counts[this_player()] >= MAX_FILES)
        printf("Note: count truncated due to file limit\n");
      return 1;
    }
    add_failed_mess( "You must have read access to a path to use " 
                     "du on it.\n" );
    return 0;
} /* cmd() */

mixed *query_patterns() {
    return ({ "", (: cmd( this_player()->query_path() ) :),
        "<string'path'>", (: cmd( $4[0] ) :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/secure/cmds/creator/du.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/cmds/creator/cp2.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/cmds/creator/cp2.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627467   Available: 13574821
Inodes: Total: 5242880    Free: 4960133
2148 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/cmds/creator/cp2.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627467   Available: 13574821
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker: taffyd $
 * $Id: cp.c,v 1.3 2000/11/16 03:09:08 ceres Exp taffyd $
 * $Log: cp.c,v $
 * Revision 1.3  2000/11/16 03:09:08  ceres
 * Modified to check valid_copy
 *
 * Revision 1.2  1999/07/18 20:35:15  wodan
 * don't include . and .. in * expansions.
 *
 * Revision 1.1  1998/01/06 05:10:49  ceres
 * Initial revision
 * 
*/
/* cp command, trial out by Turrican for a commands daemon. */

inherit "/cmds/base";

mixed cmd(string str) {
    string *filenames, dest, *fnames;
    int loop, fs;
    int show_ok;
    string src;

    if(!str)
        return notify_fail("Usage : cp file [file|dir...]\n");

    show_ok = 0;

    fnames = explode(str, " ");
    filenames = this_player()->get_files(implode(fnames[0..sizeof(fnames) -2],
        "/"));
    filenames = filter(filenames, (:$1[<1] != '.':));

    if(!sizeof(filenames)) {
        notify_fail("Usage : cp file [file|dir...]\n");
        return 0;
    }
    dest = fnames[sizeof(fnames) - 1];
    dest = this_player()->get_path(dest);

    if(!dest) {
        write("No destination\n");
        return 1;
    }

    for(loop = 0; loop < sizeof(filenames); loop++) {
        src = filenames[loop];

        if(!master()->valid_copy(src, geteuid(this_player()), ""))
            return notify_fail("Permission denied.\n");

        if ( file_size( src ) == -1 ) {
            write("No such file : " + str + "\n");
            continue;
        }

        fs = file_size(dest);

        if (fs > -1) {
            write("File exists : " + dest + "\n");
            continue;
        }

        switch ( cp( src, dest ) ) {
        case 1:
            show_ok = 1; 
            break;

        case -1: 
            write( src + " is unreadable.\n" );
            break;

        case -2:
            write( dest + " is unreadable.\n" );
            break;

        case -3:
            write( "An I/O error has occurred copying " + 
              src + " to " + dest + "\n" );
            break;

        default:
            write( "Unable to copy " + src + " to " + dest + "\n" );
        }			
    }

if ( show_ok ) {
    write( "Ok.\n" );
}

return 1;
}

// --- END [/mnt/home2/grok/lib/secure/cmds/creator/cp2.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/cmds/creator/compile.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/cmds/creator/compile.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627466   Available: 13574820
Inodes: Total: 5242880    Free: 4960133
897 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/cmds/creator/compile.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627466   Available: 13574820
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: compile.c,v 1.1 1998/01/06 05:10:49 ceres Exp $
 * $Log: compile.c,v $
 * Revision 1.1  1998/01/06 05:10:49  ceres
 * Initial revision
 * 
*/
/* compile command, trial out by Turrican for a commands daemon. */

inherit "/cmds/base";

mixed cmd(string str) {
  string bit, *bits, error_str;

  if (str)
    bits = this_player()->get_files(str);

  if (!str || !sizeof(bits))
    return notify_fail("Syntax: compile <files>\n");

#ifdef __RUNTIME_LOADING__
  foreach (bit in bits) {
    error_str = catch(generate_source(bit));
    if (!error_str)
      printf("Compiled %s Ok.\n", bit);
    else
      printf("Error compiling %s: %s\n", bit, error_str);
  }
#else
  error_str = catch(generate_source(bits));
  if (!error_str)
    printf("Compiled %@s OK.\n", bits);
  else
    printf("Error compiling %@s: %s\n", bits, error_str);
#endif
  return 1;
}
// --- END [/mnt/home2/grok/lib/secure/cmds/creator/compile.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/cmds/creator/di_scard.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/cmds/creator/di_scard.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627466   Available: 13574820
Inodes: Total: 5242880    Free: 4960133
2107 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/cmds/creator/di_scard.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627466   Available: 13574820
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: di_scard.c,v 1.2 2000/12/06 22:43:42 pinkfish Exp $
 * $Log: di_scard.c,v $
 * Revision 1.2  2000/12/06 22:43:42  pinkfish
 * Make it use add_command add_failed_mes.
 *
 * Revision 1.1  1998/01/06 05:10:49  ceres
 * Initial revision
 * 
*/
/* discard command, trial out by Turrican for a commands daemon. */
#include <creator.h>
inherit "/cmds/base";

void ask_discard(object *obs);

mixed cmd(string str) {
  string *file_names, err;
  object *no_dis, discard_obj;

  file_names = this_player()->get_cfiles(str);
  no_dis = ({ });

  if (!sizeof(file_names)) {
    add_failed_mess("No such object: " + str + "\n");
    return 0;
  }
  
  foreach (str in file_names) {
    discard_obj = find_object(str);
    if (!discard_obj) {
      printf("%s is not loaded.\n", str);
      continue;
    }
    err = catch(discard_obj->dest_me());
    this_player()->handle_error(err, "dest_me");
    if (discard_obj) {
      no_dis += ({ discard_obj });
    }
  }
  if (sizeof(no_dis)) {
    ask_discard(no_dis);
    return 1;
  }
  write("Ok.\n");
  return 1;
} /* cmd() */

void ask_discard(object *obs) {
  if (!arrayp(obs) || !sizeof(obs)) {
    printf("Nothing left to be discarded.\n");
    return;
  }
  printf("%s has a violent objection to being dested.\n"
         "Are you sure you want to do this? ",
         WIZ_PRESENT->desc_object(obs[0]));
  input_to("no_discard", 0, obs);
} /* ask_discard() */

void no_discard(string s, object *obs) { 
   string err, name;

   name = (string)WIZ_PRESENT->desc_object(obs[0]);
   if (this_player()->affirmative(s)) {
      err = catch(obs[0]->dwep());
      this_player()->handle_error(err, "DWEP");
      if (obs[0]) {
         printf("%s REALLY doesn't want to be discarded.\n", name);
         catch(destruct(obs[0]));
         if (obs[0]) {
            printf("%s didn't destruct.\n", name);
            return;
         }
      }
   }
   printf("%s discarded.\n", name);
   ask_discard(obs[1..]);
} /* no_discard() */

mixed* query_patterns() {
   return ({ "<string>", (: cmd($4[0]) :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/secure/cmds/creator/di_scard.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/cmds/creator/ls.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/cmds/creator/ls.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627465   Available: 13574819
Inodes: Total: 5242880    Free: 4960133
11706 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/cmds/creator/ls.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627465   Available: 13574819
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: ls.c,v 1.11 2001/06/07 06:45:06 taffyd Exp $
 * 
 */
#include <ls.h>
#include <autodoc.h>

inherit "/cmds/base";

/* this does an ls, now that get_dir has been written 
 * Modified by Turrican 13-7-95 with nicked code from TMI-2's ftpd.
 * - Added different options.
 * Modified by Turrican 3-12-97.
 * - Made ls -CF the default format. The old 1 column format is available
 *   with the -1 flag.
 */

#define CREATOR (master()->author_file(sprintf("%s/%s", str, direc[i][0]))? \
                master()->author_file(sprintf("%s/%s", str, direc[i][0])): \
                "Root")
#define DOMAIN  (master()->domain_file(sprintf("%s/%s", str, direc[i][0]))? \
                master()->domain_file(sprintf("%s/%s", str, direc[i][0])): \
                "Root")
#define CREATOR_D (master()->author_file(sprintf("%s/%s/.", str, direc[i][0]))? \
                master()->author_file(sprintf("%s/%s/.", str, direc[i][0])): \
                "Root")
#define DOMAIN_D (master()->domain_file(sprintf("%s/%s/.", str, direc[i][0]))? \
                master()->domain_file(sprintf("%s/%s/.", str, direc[i][0])): \
                "Root")

int ls(string str, int mask);
int check_dots(mixed arg);

mixed cmd(string str) {
  string *bits, path;
  int mask, i;

  mask = (MASK_C|MASK_F);
  if (str) {
      if ( this_player()->query_property( LS_COMMAND_NICKNAME_PROPERTY ) ) {
         str = this_player()->expand_nickname( str );
      }

    bits = explode(str, " ") - ({"", 0});
    while (sizeof(bits) && bits[0][0] == '-') {
      i = strlen(bits[0]);
      while (i--) {
        if (bits[0][i] == '-') continue;
        switch (bits[0][i]) {
        case 't':
          mask |= MASK_T;
          break;
        case 'l':
          mask |= MASK_L;
          break;
        case 'C':
          mask |= MASK_C;
          break;
        case 'a':
          mask |= MASK_A;
          break;
        case 'd':
          mask |= MASK_D;
          break;
        case 'o':
          mask |= MASK_O;
          break;
        case 'F':
          mask |= MASK_F;
          break;
        case '1':
          mask &= ~MASK_C;
          break;
        case 'v':
          write("ls version 2.6 (c) 1995-1998 Turrican@Discworld\n");
          return 1;
        case 'h':
          printf("Usage: ls [OPTION]... [PATH]...\n\n"
                 "  -a      do not hide entries \"..\" and \".\"\n"
                 "  -d      list directory entries instead of contents\n"
                 "  -h      display this help and exit\n"
                 "  -l      use a long listing format\n"
                 "  -o      colorize entries according to type\n"
                 "  -v      print version information and exit\n"
                 "  -C      list entries by columns\n"
                 "  -F      append a character to entries according to type\n"
                 "  -1      list one file per line\n"
                 "  -t      sort by date\n"
            );
          return 1;
        default :
          printf("Unknown option -%c\nTry `ls -h' for more information.\n",
                 bits[0][i]);
          return 1;
        }
      }
      bits = delete(bits, 0, 1);
    }
    str = implode(bits, " ");
  }
  if (!str) {
    path = this_player()->query_path();
  } else {
    path = this_player()->get_path(str);
  }
  if (!path) {
    return notify_fail("No current directory.\n");
  }
  if (master()->valid_read(path+"/", geteuid(this_player()), "get_dir")) {
    ls(path, mask);
  } else {
    return notify_fail("$I$0=ls: "+ str + ": Permission denied.\n");
  }
  return 1;
} /* cmd() */

string dir_entry(string path, string name, int size, int mask) {
  string tmp;
  
  tmp = "";
  
  if(size == -2) {
    if(mask & MASK_F)
      name += "/";

    return "   - " + name;
    
  }
    
  if (find_object(path+name)) {
    if (mask & MASK_F) {
      tmp += "*";
    }
  }
    
  /* Autodoc stuff, so it shows up as in or out of the doc system. */
  if ((mask & MASK_F) && AUTODOC_HANDLER->is_autodoc_file(path + name)) {
    tmp += "@";
  }
  /* Put the extension bits on... */
  name += tmp;
  
  size = (size / 1024) + 1;

  if (size < 1000) {
    return "    "[0..3-strlen(size+"")]+size+" "+name;
  }

  return size + " "+name;
} /* dir_entry() */

int ls(string str, int mask) {
  string *bit, *bing, bong, path;
  int i, j, k, size;
  mixed *direc;
 
  path = str;

  if (file_size(str) == -2 && str[strlen(str)-1] != '/' &&
      !(mask & MASK_D)) {
    path += "/";
  }
  if (mask & MASK_A) {
    path += "*";
  }
  direc = get_dir(path, -1);

  if(arrayp(direc)) {
    if (!(mask & MASK_A)) {
      direc = filter(direc, (: check_dots($1) :));
    }
  }
  if (!direc) {
    printf("No files.\n");
    return 0;
  }
  if (!sizeof(direc)) {
    if (file_size(str) == -2) {
      printf("No files.\n");
    } else {
      printf("ls: %s: No such file or directory.\n", str);
    }
    return 0;
  }
  if (file_size(path) == -2) {
    if (path[strlen(path)-1] != '/') {
      path += "/";
    }
  } else {
    bit = explode(path, "/");
    bit = bit[0..sizeof(bit)-2];
    path = "/"+implode(bit,"/")+"/";
  }
  if(path == "//")
    path = "/";
  
  bing = allocate(sizeof(direc));
  j = sizeof(direc);

  if (!(mask & MASK_C) && !(mask & MASK_L)) { // short, no colour
    if (mask & MASK_T)  {
      direc = sort_array(direc, (: $1[2] < $2[2] ? -1 :
                                   $1[2] > $2[2] ?  1 : 0 :));
    }
    if (!(mask & MASK_F) && !(mask & MASK_O)) {
      bong = sprintf("%-=*s\n", this_player()->query_cols(),
        implode(direc, "\n"));
      bing = explode(bong, "\n");
    } else for (i=0; i < j; i++) {
      if (direc[i][1] == -2 || direc[i][0] == "..") {
        if (mask & MASK_O) {
          bing[i] = sprintf("%s%-=*s", "%^GREEN%^",
            (int)this_player()->query_cols()+8, direc[i][0]+"%^RESET%^"+
            (mask & MASK_F?"/":""));
        } else  {
          bing[i] = sprintf("%-=*s", this_player()->query_cols(),
            direc[i][0]+"/");
        }
      } else if (find_object(path+direc[i][0])) {
        if (mask & MASK_O) {
          bing[i] = sprintf("%s%-=*s", "%^MAGENTA%^",
            (int)this_player()->query_cols()-1, direc[i][0]+"%^RESET%^"+
            (mask & MASK_F?"*":"")+
            ((mask & MASK_F) && AUTODOC_HANDLER->is_autodoc_file(path+direc[i][0])
             ?"@":""));
        } else {
          bing[i] = sprintf("%-=*s", this_player()->query_cols(),
            direc[i][0]+"*"+
            ((mask & MASK_F) && AUTODOC_HANDLER->is_autodoc_file(path+direc[i][0])
             ?"@":""));
        }
      } else {
        bing[i] = sprintf("%-=*s", this_player()->query_cols(), direc[i][0]+
          ((mask & MASK_F) && AUTODOC_HANDLER->is_autodoc_file(path+direc[i][0])
           ?"@":""));
      }
    }
    bong = implode(bing, "\n");
  } else if (!(mask & MASK_L)) { // short with colour
    if (mask & MASK_T)  {
      direc = sort_array(direc, (: $1[2] < $2[2] ? -1 :
                                   $1[2] > $2[2] ?  1 : 0 :));
    }
    j = sizeof(direc);
    for(i=0; i<j; i++)
      bing[i] = dir_entry(path, direc[i][0], direc[i][1],mask)+"\n";
    bong = sprintf( "%#-*s\n", this_player()->query_cols(),
                    implode(bing, ""));

    if (mask & MASK_O) {
      /* Boy, it's hard to work with colors and sprintf. *sigh* 
       *especially* in column mode :-( */
      i = j;
      while (i--) {
        if (direc[i][1] == -2 || direc[i][0] == "..") {
          bong = replace_string(bong, " "+direc[i][0],
            sprintf(" %s%s%s", "%^GREEN%^", direc[i][0], "%^RESET%^"));
        } else if (find_object(path+direc[i][0])) {
          bong = replace_string(bong, " "+direc[i][0], 
            sprintf(" %s%s%s", "%^MAGENTA%^", direc[i][0], "%^RESET%^"));
        } else {
          /* Believe me, it's needed. */
          bong = replace_string(bong, " "+direc[i][0],
            sprintf(" %s%s", "%^RESET%^", direc[i][0]));
        }
      }
    }
  } else { // long
    string tmp, tmp2;
    mixed *stats;
    int *count, current_time;

    /* if path is a directory get contents */
    if ( file_size( str ) == -2 && !(mask & MASK_D)) {
        if ( str[ strlen( str ) - 1 ] == '/' ) {
            str += "*";
        } else {
            str += "/*";
        }
    }

    /* begin long "list" */
    direc = get_dir( str, -1 );
    if (!(mask & MASK_A)) {
      direc = filter_array(direc, (: check_dots($1) :));
    }
    if (!direc || !(size = sizeof(direc))) {
        return 0;
    }

    if (mask & MASK_T)  {
      direc = sort_array(direc, (: $1[2] < $2[2] ? -1 :
                                   $1[2] > $2[2] ?  1 : 0 :));
    }
    bit = allocate(size);
    count = allocate(size);

    i = strsrch(str, '/', -1);
    if (i >= 0) {
        str = str[0..i];
    }

    current_time = time();
    for (i = 0; i < size; i++) {
      reset_eval_cost();
      /* process timestamp */
      tmp2 = ctime((direc[i])[2]); /* get last modified timestamp */
      if ((direc[i])[2] + (6 * 30 * 24 * 60 * 60) < current_time ||
          (direc[i])[2] - ( 60 * 60) > current_time ) {
        /* MMM DD  YYYY */
        tmp = sprintf("%s  %s", tmp2[4..9], tmp2[20..23]);
      } else {
        /* MMM DD hh:mm */
        tmp = tmp2[4..15];
      }

      j = (direc[i])[1];   /* get filesize */
      if (j == -2) {
        count[i] = 1;
        /* directory */
        bit[i] = sprintf("%-=*s", (this_player()->query_cols()+
          (mask & MASK_O?17:0)),
          sprintf("drwxr%cx%c%c%c %3d %-11.11s %-11.11s      0 %12s %s%s%s%s",
          (master()->valid_write(sprintf("%s%s/fl.uff",str,direc[i][0]),
          DOMAIN_D, "get_dir")?'w':'-'),
          (master()->valid_read(sprintf("%s%s",str,direc[i][0]),
          "NOBODY", "get_dir")?'r':'-'),
          (master()->valid_write(sprintf("%s%s/fl.uff",str,direc[i][0]),
          "NOBODY", "get_dir")?'w':'-'),
          (master()->valid_read(sprintf("%s%s",str,direc[i][0]),
          "NOBODY", "get_dir")?'x':'-'),
          0+(direc[i][0] == ".." &&
          str == "/"?2:0),
          CREATOR_D, DOMAIN_D, tmp, (mask & MASK_O?"%^GREEN%^":""),
          (direc[i])[0], (mask & MASK_O?"%^RESET%^":""),
          (mask & MASK_F?"/":"")));
      } else {
        /* file */
        count[i] = 0;
        stats = stat(str + (direc[i])[0]);
        bit[i] = sprintf("%-=*s", (this_player()->query_cols()+
          ((mask & MASK_O) && (k = sizeof(stats)) > 1 && stats[2]?19:0)), 
          sprintf("-rw%c%c%c-%c%c-   1 %-11.11s %-11.11s %6d %12s %s%s%s%s%s",
          k > 1 && stats[2] ? 'x' : '-',
          (master()->valid_read(sprintf("%s/%s",str,direc[i][0]),
          DOMAIN, "get_dir")?'r':'-'),
          (master()->valid_write(sprintf("%s/%s",str,direc[i][0]),
          DOMAIN, "get_dir")?'w':'-'),
          (master()->valid_read(sprintf("%s/%s",str,direc[i][0]),
          "NOBODY", "get_dir")?'r':'-'),
          (master()->valid_write(sprintf("%s/%s",str,direc[i][0]),
          "NOBODY", "get_dir")?'w':'-'),
          CREATOR, DOMAIN, j, tmp, 
          ((mask & MASK_O) && k > 1 && stats[2]?"%^MAGENTA%^":""),
          (direc[i])[0], ((mask & MASK_O) && k > 1 && 
          stats[2]?"%^RESET%^":""),
          (k > 1 && stats[2] && (mask & MASK_F)?"*":""),
          ((mask & MASK_F) &&
           AUTODOC_HANDLER->is_autodoc_file(str + direc[i][0])?"@":"")));
      }
      bong = implode(bit, "\n");
    }
  }
  this_player()->more_string( bong, str, 1 );
} /* ls() */

int check_dots(mixed arg) {
  return arg[0][0] != '.';
}

int is_dir(mixed arg, string path) {
  return (file_size(this_player()->get_path(sprintf("%s/%s", path, arg))) 
          == -2);
}
// --- END [/mnt/home2/grok/lib/secure/cmds/creator/ls.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/cmds/creator/rcsf_orce.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/cmds/creator/rcsf_orce.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627462   Available: 13574816
Inodes: Total: 5242880    Free: 4960133
5482 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/cmds/creator/rcsf_orce.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627462   Available: 13574816
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Id: rcsf_orce.c,v 1.16 2001/09/11 08:28:17 taffyd Exp $
 */
inherit "/cmds/base";
#include <creator.h>
#include <mail.h>
#include <player_handler.h>

//#define DEBUG 1

#define CMD_NUM 5

class rcsforce_args {
   object player;
   string *cmd;
   string locker;
   string filen;
}

private mapping _globals = ([ ]);
private mapping _ret = ([ ]);
private mapping _lockers = ([ ]);

#define TP _globals[fd]
#define RET _ret[fd]
#define LCK _lockers[fd]

private void do_ci(string text,
                   class rcsforce_args args);

mixed cmd(string arg)
{
   int nfiles = 0;
   string bit;
   string *bits;
   string file;
   string locker;
   string filen;
   string *cmd = allocate(3);

/*
  if (!master()->query_senior(this_player()->query_name())) {
    return 0;
  }
 */

   if (!arg) {
      return notify_fail("rcsforce: No arguments.\n");
   }

   bits = explode(arg, " ");
   arg = "";
   bits -= ({ "", 0 });

   foreach(bit in bits) {
      string *files;
      if (bit[0] == '-') {
         arg += (" " + bit);
         continue;
      }

      files = (string *) this_player()->get_files(bit);
      if (sizeof(files)) {
         filen = file = files[0];
         arg += (" " + file[1..]);
         nfiles++;
      }
   }

   if (!nfiles) {
      return notify_fail("rcsforce: no such file " + arg + ".\n");
   }
   // Now check if the file is locked and who it is locked by!

   bits = explode(file, "/");
   file =
      "/" + (string) implode(bits[0.. < 2], "/") + "/RCS/" + bits[<1] + ",v";

   if (file_size(file) < 0) {
      return notify_fail("That file is not in RCS.\n");
   }

   if (strsrch(read_file(file, 4, 1), "locks; strict:") != -1) {
      return notify_fail("That file is not locked.\n");
   } else {
      bits = explode(read_file(file, 5, 1), ":");
      locker = bits[0][1..];
   }

   // Allow anyone to unlock files by non-creators and anyone above
   // a senior cre can unlock anything.
   if (!master()->query_senior(this_player()->query_name()) &&
       PLAYER_HANDLER->test_creator(locker)) {
      // Check for a domain.
      if (file[0..2] == "/d/") {
         bits = explode(file, "/");
         if (!("/d/" + bits[1] + "/master")->can_rcsforce(file,
                                             this_player()->query_name(),
                                             locker)) {
            return 0;
         }
      } else {
         return 0;
      }
   }

   cmd[0] = "-w" + locker;
   cmd[1] = "-u";
   cmd[2] = "-m Forcibly unlocked by " + this_player()->query_name();
   cmd += explode(arg, " ");

#ifdef DEBUG
   printf("CMD: %O\n", cmd);
#endif

   if (PLAYER_HANDLER->test_creator(locker)) {
      printf("Edit mail? (y/[n]): ");
    input_to("edit_mail", 0, new (class rcsforce_args, player: this_player(), cmd: cmd, locker: locker, filen:filen));
   } else {
      int fd;
      write("Not sending mail to " + locker + " since they are not a creator "
            "any more.\n");

      fd = external_start(CMD_NUM, cmd, "read_call_back", "write_call_back",
                       "close_call_back");

      TP = this_player();
      RET = "";
      LCK = locker;
   }
   return 1;
}

protected void edit_mail(string choice,
                         class rcsforce_args args)
{
   if (!strlen(choice) || lower_case(choice) == "n") {
      printf("No.\n");
      do_ci(0, args);
      return;
   }

   if (lower_case(choice) != "y") {
      printf("Invalid choice. Please answer y or n. (y/[n]): ");
      input_to("edit_mail", 0, args);
   } else {
      printf("Yes. Entering editor.\n");
      args->player->do_edit(0, "do_ci", this_object(), 0, args);
   }
}

/* This canNOT be made private.  /global/line_ed needs to call it */
void do_ci(string text,
           class rcsforce_args args)
{
   int fd;

   AUTO_MAILER->auto_mail(args->locker, args->player->query_name(),
                          "Automatic RCSForce Mail", "",
                          sprintf("Your file: %s, has been forcibly "
                                  "unlocked by: %s.\nEnjoy.\n\n"
                                  "Automatic RCSForce Mailer.\n", args->filen,
                                  args->player->query_name()) +
                          (strlen(text) ? "\n" + text : ""));

   fd =
      external_start(CMD_NUM, args->cmd, "read_call_back", "write_call_back",
                     "close_call_back");

   TP = args->player;
   RET = "";
   LCK = args->locker;
}

// I _think_ this is the function to write the comment string to the ci command
void read_call_back(int fd,
                    mixed mess)
{
   mess = replace(mess, "/home/atuin/lib", "");
   RET += mess;
}

void write_call_back(int fd)
{
   tell_object(TP, "rcsforce: write_call_back() called.\n");
}

void close_call_back(int fd)
{
   string file,
    *file_stuff;
   int i;

   if (RET != "") {
      TP->more_string(RET);
      file_stuff = explode(RET, "\n");
      i = 0;
      while (i + 2 < sizeof(file_stuff)) {
         if (file_stuff[i + 2] == "done") {     /* success! */
            sscanf(file_stuff[i], "%*s  <--  %s", file);
            RCS_HANDLER->remove_lock(LCK, file);
            i += 3;
         } else {
            if (file_stuff[i + 1][0..2] == "ci:") {
               i += 2;
            } else {
               i += 3;
            }
         }
      }
   } else {
      tell_object(TP, "rcsforce completed.\n");
   }

   map_delete(_ret, fd);
   map_delete(_globals, fd);
   map_delete(_lockers, fd);
}
// --- END [/mnt/home2/grok/lib/secure/cmds/creator/rcsf_orce.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/cmds/creator/cp.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/cmds/creator/cp.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627461   Available: 13574815
Inodes: Total: 5242880    Free: 4960133
2133 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/cmds/creator/cp.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627461   Available: 13574815
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: cp.c,v 1.4 2001/08/02 00:06:16 ceres Exp $
 * $Log: cp.c,v $
 * Revision 1.4  2001/08/02 00:06:16  ceres
 * Modified to use the cp() efun
 *
 * Revision 1.3  2000/11/16 03:09:08  ceres
 * Modified to check valid_copy
 *
 * Revision 1.2  1999/07/18 20:35:15  wodan
 * don't include . and .. in * expansions.
 *
 * Revision 1.1  1998/01/06 05:10:49  ceres
 * Initial revision
 * 
*/
/* cp command, trial out by Turrican for a commands daemon. */

inherit "/cmds/base";

mixed cmd(string str) {
  string *filenames, dest, *fnames, dstr;
  int loop, fs;

  if(!str)
    return notify_fail("Usage : cp file [file|dir...]\n");
  fnames = explode(str, " ");
  filenames = this_player()->get_files(implode(fnames[0..sizeof(fnames) -2],
                                               "/"));
  filenames = filter(filenames, (:$1[<1] != '.':));
  if(!sizeof(filenames)) {
    notify_fail("Usage : cp file [file|dir...]\n");
    return 0;
  }
  dest = fnames[sizeof(fnames) - 1];
  dest = this_player()->get_path(dest);
  if(!dest) {
    write("No destination\n");
    return 1;
  }
  
  for(loop = 0; loop < sizeof(filenames); loop++) {
    str = filenames[loop];
    if(!master()->valid_copy(str, geteuid(this_player()), ""))
      return notify_fail("Permission denied.\n");
    fs = file_size(dest);
    if(fs == -2) {
      string *names;

      names = explode(str, "/");
      fs = file_size(dest + "/" + names[sizeof(names) - 1]);
      if(fs != -1) {
        write("file exists " + dest + "/" + names[sizeof(names) - 1] + "\n");
        continue;
      }
      dstr = dest + "/" + names[sizeof(names) - 1];
    } else {
      if(fs != -1) {
        write("File exists : " + dest + "\n");
        continue;
      }
      dstr = dest;
    }
    switch(cp(str, dstr)) {
    case 1:
      write(str + " copied to " + dstr + ".\n");
      break;
    case -1:
      write(str + " is unreadable.\n");
      break;
    case -2:
      write(dstr + " is unreadable.\n");
      break;
    case -3:
      write("I/O error copying " + str + " to " + dstr + ".\n");
      break;
    }
  }
  return 1;
}

// --- END [/mnt/home2/grok/lib/secure/cmds/creator/cp.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/cmds/creator/printe_rrors.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/cmds/creator/printe_rrors.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627460   Available: 13574814
Inodes: Total: 5242880    Free: 4960133
3128 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/cmds/creator/printe_rrors.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627460   Available: 13574814
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Id: printe_rrors.c,v 1.4 2003/04/22 21:45:26 pinkfish Exp $
 */

/* printerrors command */

#include <log.h>
#include <board.h>
#include <error_handler.h>
#include <db.h>

inherit "/cmds/base";

void finish_details(string player, int result, mixed results);

int cmd(string str) {
  string player, ret;
  class error_query query;
   
  if (str) {
    if (str[0] != '/')  {
      str = this_player()->query_path() + "/" + str;
    }
    if (str[<1] == '0') {
      str = str[0..<2];
    }
    if (str[<1] == '/') {
      str = str[0..<2];
    }
    player = this_player()->query_name();
    write_file("/w/" + player + "/print_errors.txt", "", 1);

    write("%^YELLOW%^Starting to collect bugreports, this may take a "
          "while.%^RESET%^\n");
    query = new(class error_query);
    query->recursive = 1;
    query->dir = str;
    query->status = ({ ERROR_STATUS_OPEN, ERROR_STATUS_CONSIDERING,
                       ERROR_STATUS_FIXING });
    ERROR_HANDLER->do_query_multiple_bug_details(query,
                  (: finish_details($(player), $1, $2) :));
    return 1;
  } else
    return notify_fail("Usage:\nprinterrors <path>\n note that this will "
                       "overwrite any previous print_errors.txt file\n");
}

protected string get_bug(class error_complete complete) {
  string ret;
  class error_details error;
  class error_forward forward;
  class error_comment comment;

  error = complete->details;
  ret = sprintf("%s %s %s\n", error->summary->category, 
                              error->summary->type, error->summary->status);
  ret += sprintf("Filename       : %s\n", error->summary->filename);
  ret += sprintf("Directory      : %s\n", error->summary->directory);
  ret += sprintf("Made by        : %s\n", capitalize(error->summary->reporter));
  ret += sprintf("at             : %s\n\n", ctime(error->summary->entry_date));
  foreach (forward in complete->forwards) {
    ret += sprintf("Forwarded by   : %s\n", capitalize(forward->forwarder));
    ret += sprintf("from           : %s\n", forward->old_directory);
    ret += sprintf("at             : %s\n", ctime(forward->date));
  }
  ret += error->report;
  if (error->runtime && (error->runtime != "")) {
    ret += "[RUNTIME]\n" + error->runtime;
  }
  foreach (comment in complete->comments) {
      ret += sprintf("\nComment by     : %s\n", capitalize(comment->commenter));
      ret += sprintf(  "at             : %s\n", ctime(comment->date));
      ret += comment->comment;
  }
  ret +=
"------------------------------------------------------------------------------";
  return ret;
} /* get_bug() */

void finish_details(string player, int result, mixed results) {
   class error_complete* details;
   string str;

   if (result != DB_SUCCESS) {
      tell_creator(player, "Failed to return the results " + results);
      return ;
   }
   details = results;
   foreach (class error_complete detail in details) {
      str = get_bug(detail);
      unguarded( (: write_file("/w/" + $(player) + "/print_errors.txt", $(str)) :) );
   }
   tell_creator(player, "Finished gathering the details.\n");
}
// --- END [/mnt/home2/grok/lib/secure/cmds/creator/printe_rrors.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/cmds/creator/upd_ate.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/cmds/creator/upd_ate.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627459   Available: 13574813
Inodes: Total: 5242880    Free: 4960133
4379 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/cmds/creator/upd_ate.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627459   Available: 13574813
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Id: upd_ate.c,v 1.4 1999/12/09 07:17:32 pinkfish Exp $
 */

#include <creator.h>

inherit "/cmds/base";

protected int do_update(object *ov) {
   string pname;
   object *invent;
   object rsv;
   object env;
   object dup;
   object loaded;
   object ob;
   mixed static_arg;
   mixed dynamic_arg;
   int i;
   
   rsv = load_object("room/void");  /* RSV = Room Slash Void */
   if (!rsv) { /* Die in horror */
      return notify_fail("The void is lost!\n");
   }
 
   foreach (ob in ov) {
      if (!ob) {
         continue;
      }
      if (interactive(ob)) {
         write("Can't update interactive object: " + ob->query_name() + "\n");
         continue;
      }
      env = environment(ob);
      invent = all_inventory(ob);

      for (i = 0; i < sizeof(invent); i++) {
         if (userp(invent[i]) ||
             invent[i]->query_property("unique")) {
             invent[i]->move(rsv);
         } else {
             invent = delete(invent, i--, 1);
         }
      }
  
      pname = file_name(ob);
      if (sscanf(pname, "%s#%*d", pname) != 2) { /* a room ? */
         static_arg = ob->query_static_auto_load();
         dynamic_arg = ob->query_dynamic_auto_load();
         ob->dest_me();
         if (ob) {
            ob->dwep();
         }
         if (ob) {
            destruct(ob);
         }
         if (ob) {
            return notify_fail("I can't seem to destruct the old object.\n");
         }
         ob = load_object(pname);
         if (static_arg) {
             ob->init_static_arg(static_arg);
         }
         if (dynamic_arg) {
            ob->init_dynamic_arg(dynamic_arg);
         }
      } else {
         loaded = find_object(pname);
         static_arg = ob->query_static_auto_load();
         dynamic_arg = ob->query_dynamic_auto_load();
         if (loaded) {
            loaded->dest_me();
         }
         if (loaded) {
            loaded->dwep();
         }
         if (loaded) {
            destruct(loaded);
         }
  
         dup = clone_object(pname);
         if (dup && ob) {
             ob->dest_me();
             if (ob) {
                ob->dwep();
             }
             if (ob) {
                destruct(ob);
            }
            ob = dup;
            if (static_arg) {
                ob->init_static_arg(static_arg);
            }
            if (dynamic_arg) {
                ob->init_dynamic_arg(dynamic_arg);
            }
         }
      }
      
      if (!ob) {
         printf("I seem to have lost your object.\n");
         return 1;
      }
  
      for (i = 0; i < sizeof(invent); i++) {
         if (invent[i]) {
            invent[i]->move(ob);
         }
      }
        
      if (env) {
         ob->move(env);
      }
      printf("Updated %s.\n", WIZ_PRESENT->desc_f_object(ob));
   }
   return 1;
} /* do_update() */

mixed cmd(string str) {
   string tring;
   string* filenames;
   string err;
   object ob;
   object* val;
   object* obs;
   int loop;
 
   notify_fail("No such object.\n");
   tring = str;
   if (!str || str == "here") { 
      str = file_name(environment(this_player()));
      if (str == "/room/void") {
         notify_fail("The Surgeon General warns you that it is hazardous to "
                     "update the void while standing in it.\n");
         return 0;
      }
      str = base_name(str);
      filenames = ({ "/" + str });
      str = "here";
   } else {
      filenames = this_player()->get_cfiles(str);
   }
   if (sizeof(filenames) == 0) {
      val = WIZ_PRESENT->wiz_present(tring, this_player());
      if (!sizeof(val)) {
         notify_fail("No matching objects/filenames\n");
         return 0;
      }
      return do_update(val);
   }
   obs = ({ });
   for (loop = 0; loop < sizeof(filenames); loop++) {
      str = filenames[loop];
      ob = find_object(str);
      if (!ob) {
          if (file_size(str) >= 0) {
             if (!(err = catch(load_object(str)))) {
                 printf("Loaded %s\n", str);
             } else {
                 printf("Failed to load %s, error: %s\n", str, err);
             }
          } else {
              val = WIZ_PRESENT->wiz_present(tring, this_player());
              obs += val;
          }
      } else {
          obs += ({ ob });
      }
   }
   if (!obs) {
      return 0;
   } else {
      return do_update(obs);
   }
} /* cmd() */
// --- END [/mnt/home2/grok/lib/secure/cmds/creator/upd_ate.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/cmds/creator/indent.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/cmds/creator/indent.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627458   Available: 13574812
Inodes: Total: 5242880    Free: 4960133
2363 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/cmds/creator/indent.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627458   Available: 13574812
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Id: indent.c,v 1.2 2003/03/25 19:11:03 pinkfish Exp $
 */
inherit "/cmds/base";
#include <creator.h>

#define CMD_NUM 4

mapping globals = ([]), ret = ([]), cmds = ([]);

#define TP globals[fd]
#define RET ret[fd]
#define CMDS cmds[this_player()]

mixed cmd(string arg) {
  int nfiles = 0;
  int fd;
  string bit;
  string *bits;
  object *things;
  
  if (!arg) {
    return notify_fail("rcsin: No arguments.\n");
  }

  bits = explode(arg, " ");
  arg = "";
  bits -= ({ "", 0 });

  foreach(bit in bits) {
    string files = "", file;
    if (bit[0] == '-') {
      arg += (" " + bit);
      continue;
    }

    if (sizeof(files = this_player()->get_files(bit))) {
      foreach(file in files) {
        arg += (" " + file[1..]);
        nfiles++;
      }
    } else {
      if(sizeof(things = WIZ_PRESENT->wiz_present(bit, this_player()))) {
        file = file_name(things[0]);
        sscanf(file, "%s#%*d", file);
        if (file_size(file) <= 0) {
          file += ".c";
        }

        arg += (" " + file[1..]);
        nfiles++;
      }
    }
  }

  if(!nfiles) {
    return notify_fail("rcsin: no such file "+arg+".\n");
  }

  fd = external_start(CMD_NUM, explode(arg, " "),
                      "read_call_back", "write_call_back",
                      "close_call_back");
    
  TP = this_player();
  RET = "";
  return 1;
}

// I _think_ this is the function to write the comment string to the ci command
void read_call_back(int fd, mixed mess) {
  mess = replace(mess, "/home/atuin/lib", "");
  RET += mess;
}

void write_call_back(int fd) {
  tell_object(TP, "rcsin: Write_call_back called.\n");
}

void close_call_back(int fd) {
  string file, *file_stuff;
  int i;

  if (RET != "") {
    TP->more_string(RET);
    file_stuff = explode(RET, "\n");
    i = 0;
    while (i + 2 < sizeof(file_stuff))  {
      if (file_stuff[i + 2] == "done")  {  /* success! */
        sscanf(file_stuff[i], "%*s  <--  %s", file);
        RCS_HANDLER->remove_lock(TP, file);
        i += 3;
      }
      else if (sscanf(file_stuff[i], "%*sNo such file or directory"))  {
        ++i;
      }
      else if (file_stuff[i + 1][0..2] == "ci:") {
          i += 2;
      }
      else {
          i += 3;
      }
    }
  } else {
    tell_object(TP, "rcsin completed.\n");
  }
  
  map_delete(ret, fd);
  map_delete(globals, fd);
}
// --- END [/mnt/home2/grok/lib/secure/cmds/creator/indent.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/cmds/creator/locks.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/cmds/creator/locks.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627457   Available: 13574811
Inodes: Total: 5242880    Free: 4960133
1062 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/cmds/creator/locks.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627457   Available: 13574811
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <creator.h>

int cmd(string){
  string *bits, rcspath, *files, path, tmp;
  
  files = get_dir(this_player()->query_current_path()+"/");
  write("locked files in this directory:\n");
  foreach(path in files) {
    path = this_player()->query_current_path() + "/" + path;
    bits = explode(path, "/");
    
    // Figure out the RCS filename and check if it exists.
    if(sizeof(bits) > 2) {
      rcspath = "/" + implode(bits[0..sizeof(bits)-2], "/") + "/RCS/";
    } else if(sizeof(bits) == 2) {
      rcspath = "/" + bits[0] + "/RCS/";
    } else
      rcspath = "/";
    
    rcspath += bits[sizeof(bits)-1] + ",v";
    
    if(file_size(rcspath) > 0) { 
      tmp = read_file(rcspath, 4, 1);
      if(tmp == "locks\n") { // we've found a lock
        string lockname ;
        tmp = read_file(rcspath, 5, 1);
        sscanf(tmp, "\t%s:", lockname);
        printf("%s locked by %s\n", path, lockname);
      }
    }
  }
  return 1;
} /* valid_write() */

string help() {
  return "Displays the files that are locked in your current directory.";
}
// --- END [/mnt/home2/grok/lib/secure/cmds/creator/locks.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/cmds/creator/;_.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/cmds/creator/;_.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627456   Available: 13574810
Inodes: Total: 5242880    Free: 4960133
643 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/cmds/creator/;_.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627456   Available: 13574810
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: ;_.c,v 1.3 2000/05/11 23:41:04 pinkfish Exp $
 * $Log: ;_.c,v $
 * Revision 1.3  2000/05/11 23:41:04  pinkfish
 * Fix up the return values.
 *
 * Revision 1.2  2000/05/11 23:40:17  pinkfish
 * Change the return*
 *
 * Revision 1.1  1998/01/06 05:10:49  ceres
 * Initial revision
 * 
*/
/* ; command, trial out by Turrican for a commands daemon. */

#include <parser.h>

inherit "/cmds/base";

mixed cmd(string str) {
  mixed res;

  PARSER->init_expr(str);
  res = PARSER->expr();
  printf("Returns: %O\n", ((pointerp(res) && sizeof(res) == 1)?res[0]:res));
  PARSER->finish_expr();
  return 1;
}
// --- END [/mnt/home2/grok/lib/secure/cmds/creator/;_.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/cmds/creator/find.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/cmds/creator/find.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627456   Available: 13574810
Inodes: Total: 5242880    Free: 4960133
4123 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/cmds/creator/find.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627456   Available: 13574810
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: find.c,v 1.12 2002/03/25 20:33:37 wodan Exp $
*/

#include <creator.h>

#define WIZ WIZ_PRESENT 
#define EXTRACT_CODE 1
#define LINE_NUMBERS 2
#define FIND_ALL 4
 
inherit "/cmds/base";

int file_exists(string str) { return (file_size(str) > -1); }
 
mixed cmd(string str) {
  string func, thing, s, ping;
  object *obs, fish, user = this_player();
  object *list;
  mixed *fnd;
  int i, flags;
  int k;
 
  notify_fail("Usage: find [-a] [-d] [-n] function() <object(s)>\n");
 
  if (!str)
     return 0;
  
  while (sscanf(str, "-%s %s", s, str) == 2)
    switch (s) {
    case "d":
        flags |= EXTRACT_CODE;
        flags &= ~FIND_ALL;
        break;
    case "n":
        flags |= (LINE_NUMBERS | EXTRACT_CODE);
        flags &= ~FIND_ALL;
        break;
    case "a":
        flags = FIND_ALL;
        break;
      default:
        return notify_fail("Unknown option '"+ s +"'.\n");
    }
 
  if (sscanf(str, "%s() %s", func, thing) != 2)
     if(sscanf(str, "%s %s", func, thing) != 2)
        return 0;
 
  obs = WIZ -> wiz_present(thing, user);
 
  if (!sizeof(obs))
    return notify_fail("Can't find " + thing + ".\n");
 
  s = "";
  fnd = ({ });
 
  for (i = 0; i < sizeof(obs); i++) {
     if (flags & FIND_ALL)
        list = ({ obs[i] }) + map(deep_inherit_list(obs[i]),
               (: find_object($1) :));
     else list = ({ obs[i] });
     for (k = 0; k < sizeof(list); k++)  {
        if ((ping = function_exists(func, list[k], 1))  &&
            member_array(ping, fnd) == -1)
        {
           s += "*** " + WIZ->desc_object(list[k]) + ": " + func +
                "() found in " + ping + "\n";
           fnd += ({ func, ping });
        } else if (!(flags & FIND_ALL))
           s += "*** " + WIZ->desc_object(list[k]) + ": " + func +
                "() not found.\n";
    
        fish = list[k];
    
        while (fish = shadow(fish, 0))
           if (function_exists(func, fish, 1)) {
              s += "      Shadowed by " + file_name(fish) + "\n";
              fnd += ({ func, base_name(fish) });
           }
     }
  }
 
  if ((flags & FIND_ALL)  &&  !sizeof(fnd))
     s += "*** " + func + "() not found.\n";

  /* If we are going to extract a function, there are many different possible
     formats it might be declared in:
 
     void foo*(*)*{
 
     Take * as indicating where whitespace might split the header, whitespace
     possibly being a space, a tab or a new line. */
 
  if ((flags & EXTRACT_CODE) && sizeof(fnd)) {
    if (sizeof(fnd) > 2)
      s += "Can only extract code from one object at a time.\n";
    else {
      mixed tmp;
      int j = 0;
      int startline;
      ping = fnd[1] +".c";
      func = fnd[0];
      i = 0;
 
      if (!file_exists(ping))
        return notify_fail("The file for "+ thing +" doesn't exist.\n");

      tmp = read_file(ping);

      if(!strlen(tmp))
        return notify_fail("Could not read file.\n");
      
      tmp = reg_assoc(tmp,  ({"\n[a-z_ \t]*[\\* ][ \t]*" + func +
                    "[ \t]*\\([a-zA-Z0-9, _\\*\n\t]*(...)?[ \t]*\\)[ \t\n]*{"
                                , "\n}"})
                      , ({1, 2}));
      
      
      while(tmp[1][j] != 1)
        j++;

      if(flags & LINE_NUMBERS){
        startline = sizeof(explode(implode(tmp[0][0..j], ""), "\n"));
      }
      
      j++;
      while(tmp[0][j][i] != '\n'){
        if(tmp[0][j][i] == '}'){
          tmp = tmp[0][j - 1][1..] + tmp[0][j][0..i];
          if(flags & LINE_NUMBERS)
            tmp = implode(explode(tmp, "\n"),
                           (:({$1[0]+1, $1[1] + "\n" + $1[0] + " " + $2}):),
                           ({startline, ""}))[1];
          user->more_string(sprintf("%s%s", s, tmp), 0, 1);
          return 1;
        }
        i++;
      }

      tmp = implode(tmp[0][j-1..j+1], "");
      if(flags & LINE_NUMBERS)
        tmp = implode(explode(tmp, "\n"),
                      (:({$1[0]+1, $1[1] + "\n" + $1[0] + " " + $2}):),
                      ({startline, ""}))[1];
      
      s += tmp;
    }
  }
 
  user->more_string(s, 0, 1);
 
  return 1;
}
// --- END [/mnt/home2/grok/lib/secure/cmds/creator/find.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/cmds/creator/rcso_ut.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/cmds/creator/rcso_ut.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627455   Available: 13574809
Inodes: Total: 5242880    Free: 4960133
2865 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/cmds/creator/rcso_ut.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627455   Available: 13574809
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
  /*  -*- LPC -*-  */
/*
 * $Id: rcso_ut.c,v 1.12 2003/04/23 20:58:33 pinkfish Exp $
 */
inherit "/cmds/base";
#include <creator.h>

#define CMD_NUM 3

mapping globals = ([]), files = ([]), ret = ([]);

#define TP globals[fd]
#define RET ret[fd]

mixed cmd(string arg) {
  int fd, nfiles = 0;
  int force;
  string cmd;
  string bit, *bits;
  object *things;
  
  if(!arg) {
    return notify_fail("rcsout: No arguments.\n");
  }

  bits = explode(arg, " ");
  arg = "";
  bits -= ({""});

  if (bits[0] == "-f") {
    force = 1;
    bits = bits[1..];
  }

  foreach(bit in bits){
    string *files = ({ }), file;
    if (bit[0] == '-'){
      arg += (" " + bit);
      continue;
    }

    if (sizeof(things = WIZ_PRESENT->wiz_present(bit, this_player()))) {
      int i;

      files = uniq_array(map(things, (: base_name($1) :)));
      for (i = 0; i < sizeof(files); i++) {
        if (file_size(files[i]) <= 0) {
          files[i] += ".c";
        }
      }
    }

    files += this_player()->get_files(bit);

    if (!sizeof(files)) {
      file = this_player()->get_path(bit);
      if(master()->valid_write(file, geteuid(this_player()), "cmd")) {
        arg += (" " + file[1..]);
        nfiles++;
      } else {
        notify_fail("You do not have write access to "+file+"\n");
      }
    } else {
      foreach(file in uniq_array(files)) {
        if(master()->valid_write(file, geteuid(this_player()), "cmd")) {
          arg += (" " + file[1..]);
          nfiles++;
        } else {
          notify_fail("You do not have write access to "+file+"\n");
        }
      }
    }
  }

  if(!nfiles) {
    return 0;
  }

  if (force) {
     cmd = " -l -f -w" + this_player()->query_name() +arg;
  } else  {
     cmd = " -l -w" + this_player()->query_name() +arg;
  }
#ifdef DEBUG    
  printf("CMD: %s\n", cmd);
#endif    
  fd = external_start(CMD_NUM, cmd, "read_call_back", "write_call_back",
                      "close_call_back");
    
  TP = this_player();
  RET = "";
  return 1;
}

void read_call_back(int fd, mixed mess) {
  mess = replace(mess, "/home/atuin/lib", "");
  RET += mess;
}

void write_call_back(int fd) {
  tell_object(TP, "rcsout: Whoops! fatal error.\n");
}

void close_call_back(int fd) {
  string file, *file_stuff;
  int i;

  if(RET != "")  {
    TP->more_string(RET);
    file_stuff = explode(RET, "\n");
    i = 0;
    while (i + 2 < sizeof(file_stuff))  {
      if (file_stuff[i + 2] == "done")  {  /* success! */
        sscanf(file_stuff[i], "%*s  -->  %s", file);
        RCS_HANDLER->add_lock(TP, file);
        i += 3;
      }
      else if (sscanf(file_stuff[i], "%*sNo such file or directory"))  {
        ++i;
      }
      else if (file_stuff[i + 1][0 .. 2] == "co:")  i += 2;
      else i += 3;
    }
  }
  else
    tell_object(TP, "rcsout completed.\n");

  map_delete(ret, fd);
  map_delete(globals, fd);
}
// --- END [/mnt/home2/grok/lib/secure/cmds/creator/rcso_ut.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/cmds/creator/dup_licate.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/cmds/creator/dup_licate.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627454   Available: 13574808
Inodes: Total: 5242880    Free: 4960133
2056 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/cmds/creator/dup_licate.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627454   Available: 13574808
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Id: dup_licate.c,v 1.4 2001/02/02 20:13:02 pinkfish Exp $
 */
/* Makes an exact duplicate of an object */

#include <creator.h>

inherit "/cmds/base";

protected int do_duplicate(object *ov) {
   string pname, dummy;
   int i;
   object dup;
   mixed static_arg, dynamic_arg;

   for (i = 0; i < sizeof(ov); i++) {
      if (!ov[i]) {
         continue;
      }
      pname = file_name(ov[i]);
      if (sscanf(pname, "%s#%d", pname, dummy) != 2) { /* a room ? */
        // Can't duplicate a unique item.  Need some sort of message here.
        write("Can't duplicate " + ov[i]->short() + " (not a clone).\n");
        continue;
      } else {
         static_arg = ov[i]->query_static_auto_load();
         dynamic_arg = ov[i]->query_dynamic_auto_load();

         dup = clone_object(pname);
         if (dup && ov[i]) {
            ov[i] = dup;
            if (static_arg) {
              ov[i]->init_static_arg(copy(static_arg));
            }
            if (dynamic_arg) {
              ov[i]->init_dynamic_arg(copy(dynamic_arg));
            }
         }
         ov[i]->add_property("cloned by", this_player()->query_name());
      }

     if (!ov[i]) {
        printf("I seem to have lost your object.\n");
        return 1;
     }

     if (!ov[i]->move(this_player())) {
       write(ov[i]->short() + " duplicated and put in you.\n");
     } else if (!ov[i]->move(environment(this_player()))) {
       write(ov[i]->short() + " duplicated and put in here.\n");
     } else if (!ov[i]->move("/room/broken")) {
       write(ov[i]->short() + " duplicated and put in /room/broken.\n");
     } else {
       // I hope this will never happen...
       write("Couldn't find anyplace to put " + ov[i]->short() + "!\n");
       ov[i]->move("/room/rubbish");
     }
   }
   return 1;
}

mixed cmd(string str) {
  object *val;

  notify_fail("No such object.\n");
  val = WIZ_PRESENT->wiz_present(str, this_player());
  if(!sizeof(val)) {
    notify_fail("No matching objects\n");
    return 0;
  }
  return do_duplicate(val);
}
// --- END [/mnt/home2/grok/lib/secure/cmds/creator/dup_licate.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/cmds/creator/rcsco_mment.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/cmds/creator/rcsco_mment.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627453   Available: 13574807
Inodes: Total: 5242880    Free: 4960133
2612 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/cmds/creator/rcsco_mment.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627453   Available: 13574807
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Id: rcsco_mment.c,v 1.3 2002/07/05 19:04:59 pinkfish Exp $
 */
inherit "/cmds/base";
#include <creator.h>

#define CMD_NUM 8

mapping globals = ([]), ret = ([]);

#define TP globals[fd]
#define RET ret[fd]

class rcscomment_args {
  object player;
  string arg;
  string revision;
}

mixed cmd(string arg) {
  int nfiles = 0;
  string bit, *bits;
  object *things;
  string* files;
  string file;
  
  if (!arg) {
    return notify_fail("rcscomment: No arguments.\n");
  }

  bits = explode(arg, " ");
  arg = "";
  bits -= ({ "", 0 });

  foreach(bit in bits) {
    if (bit[0] == '-') {
      arg += (" " + bit);
      continue;
    }

    files = this_player()->get_files(bit);
    if (sizeof(files)) {
      foreach(file in files) {
        arg += (" " + file[1..]);
        nfiles++;
      }
    } else {
      if(sizeof(things = WIZ_PRESENT->wiz_present(bit, this_player()))) {
        file = file_name(things[0]);
        sscanf(file, "%s#%*d", file);
        if (file_size(file) <= 0)
          file += ".c";

        arg += (" " + file[1..]);
        nfiles++;
      }
    }
  }

  if(!nfiles) {
    return notify_fail("rcscomment: no such file "+arg+".\n");
  }

  printf("Enter a revision number: ");
  input_to("get_rev", 0, new(class rcscomment_args, player : this_player(),
                             arg : arg));
  return 1;
} /* cmd() */

protected void get_rev(string revision, class rcscomment_args args) {
  if (!strlen(revision)) {
    printf("No revision given, aborting.\n");
    return;
  }
  args->revision = revision;

  printf("Enter a comment.\n");
  args->player->do_edit(0, "do_comment", 0, 0, args);
} /* get_rev() */

void do_comment(string comment, class rcscomment_args args) {
  int fd;
  string *cmd = allocate(2);

  if (!strlen(comment)) {
    printf("No comment given, aborting.\n");
    return;
  }

  cmd[0] = sprintf("-w%s", args->player->query_name());
  cmd[1] = sprintf("-m%s:%s", args->revision, comment);
  cmd += explode(args->arg, " ");
#ifdef DEBUG  
  printf("CMD: %O\n", cmd);
#endif  
  fd = external_start(CMD_NUM, cmd, "read_call_back", "write_call_back",
                      "close_call_back");

  TP = args->player;
  RET = "";
}

void read_call_back(int fd, mixed mess) {
  mess = replace(mess, "/home/atuin/lib", "");
  RET += mess;
}

void write_call_back(int fd) {
  tell_object(TP, "rcscomment: write_call_back() called.\n");
}

void close_call_back(int fd) {
  if (RET != "") {
    TP->more_string(RET);
  } else {
    tell_object(TP, "rcscomment completed.\n");
  }

  map_delete(ret, fd);
  map_delete(globals, fd);
}
// --- END [/mnt/home2/grok/lib/secure/cmds/creator/rcsco_mment.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/cmds/creator/rcsd_iff.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/cmds/creator/rcsd_iff.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627452   Available: 13574806
Inodes: Total: 5242880    Free: 4960133
1705 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/cmds/creator/rcsd_iff.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627452   Available: 13574806
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Id: rcsd_iff.c,v 1.5 2001/05/29 00:24:04 presto Exp $
 */
inherit "/cmds/base";
#include <creator.h>

#define CMD_NUM 2

mapping globals = ([]), ret = ([]);

#define TP globals[fd]
#define RET ret[fd]

mixed cmd(string arg) {
  int fd, nfiles = 0;
  string cmd;
  string bit, *bits;
  object *things;
  
  if(!arg)
    return notify_fail("rcsdiff: No arguments.\n");


  bits = explode(arg, " ");
  arg = "";
  bits -= ({""});

  foreach(bit in bits){
    string *files = ({}), file;
    if (bit[0] == '-'){
      arg += (" " + bit);
      continue;
    }
    
    if (sizeof(files = this_player()->get_files(bit))) {
      foreach(file in files) {
        arg += (" " + file[1..]);
        nfiles++;
      }
    } else {
      if(sizeof(things = WIZ_PRESENT->wiz_present(bit, this_player()))) {
        file = file_name(things[0]);
        sscanf(file, "%s#%*d", file);
        if (file_size(file) <= 0)
          file += ".c";

        arg += (" " + file[1..]);
        nfiles++;
      }
    }
  }

  if(!nfiles)
    return notify_fail("No such file: "+arg+"\n");
  
  cmd =  arg;
#ifdef DEBUG    
  printf("CMD: %s\n", cmd);
#endif    
  fd = external_start(CMD_NUM, cmd, "read_call_back", "write_call_back",
                      "close_call_back");
  
  TP = this_player();
  RET = "";
  return 1;
}

void read_call_back(int fd, mixed mess) {
  mess = replace(mess, "/home/atuin/lib", "");
  RET += mess;
}

void write_call_back(int fd) {
  tell_object(TP, "rcsdiff: Whoops! fatal error.\n");
}

void close_call_back(int fd) {
  if(RET != "")
    TP->more_string(RET);
  else
    tell_object(TP, "rcsdiff completed.\n");
  map_delete(ret, fd);
  map_delete(globals, fd);
}
// --- END [/mnt/home2/grok/lib/secure/cmds/creator/rcsd_iff.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/cmds/creator/cat.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/cmds/creator/cat.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627452   Available: 13574806
Inodes: Total: 5242880    Free: 4960133
1599 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/cmds/creator/cat.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627452   Available: 13574806
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: cat.c,v 1.4 1999/10/12 02:23:35 presto Exp $
 * $Log: cat.c,v $
 * Revision 1.4  1999/10/12 02:23:35  presto
 * More error checking
 *
 * Revision 1.3  1999/10/12 02:04:37  presto
 * Fixed up a bit. :)
 *
 * Revision 1.2  1999/10/11 23:17:36  shrike
 * Added -n functionality.
 *
 * Revision 1.1  1998/01/06 05:10:49  ceres
 * Initial revision
 * 
*/
/* cat command, trial out by Turrican for a commands daemon. */

inherit "/cmds/base";

mixed cmd(string str, int LINE_NUMBERS) {
   string *filenames, *lines;
   int loop, i, w;

   if( !str )  {
      notify_fail("Cat what file ?\n");
      return 0;
   }
   
   filenames = this_player()->get_files(str);
   if (!sizeof(filenames)) {
      notify_fail(str + ": No such file.\n");
      return 0;
   }
   for(loop = 0; loop < sizeof(filenames); loop++) {
      if(sizeof(filenames) > 1) {
         write("FILE : " + filenames[loop] + "\n");
      }

      if(LINE_NUMBERS) {
         str = read_file( filenames[loop] );
         if (str)  {
            lines = explode( str , "\n" );
            w = sizeof( sprintf( "%d", sizeof( lines ) ) );
            
            for( i = 0; i < sizeof( lines ); i++ )
               lines[i] = sprintf( "%*d: %s", w, (i+1), lines[i] );
            printf("%s\n", implode(lines, "\n"));
         }
         else write(filenames[loop] + ": No such file.\n");
      }

      else cat(filenames[loop]);
   }
   return 1;
}

mixed *query_patterns()  {
   return ({ "-n <string'file'>", (: cmd($4[0], 1) :),
              "<string'file'>", (: cmd($4[0], 0) :) });
}
// --- END [/mnt/home2/grok/lib/secure/cmds/creator/cat.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/cmds/creator/diff.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/cmds/creator/diff.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627451   Available: 13574805
Inodes: Total: 5242880    Free: 4960133
2238 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/cmds/creator/diff.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627451   Available: 13574805
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: diff.c,v 1.3 2003/03/25 20:02:48 wodan Exp $
 * $Log: diff.c,v $
 * Revision 1.3  2003/03/25 20:02:48  wodan
 * Forcibly released due to inactivity
 *
 * Revision 1.2  1998/02/24 15:50:32  wodan
 * number of external command was changed
 *
 * Revision 1.1  1998/01/06 05:10:49  ceres
 * Initial revision
 * 
*/
inherit "/cmds/base";
#include <creator.h>

mapping globals = ([]), files = ([]), ret = ([]);

#define TP globals[fd]
#define FILE files[fd]
#define RET ret[fd]

mixed cmd(string arg) {
  int fd, num = 0;
  string last = "";
  
  if(!arg)
    arg = "";
  else {
    string bit, *bits = explode(arg, " ");
    arg = "";
    bits -= ({""});

    foreach(bit in bits){
      mixed *st;
      if (bit[0] == '-'){
        continue;
      }
      bit = this_player()->get_path(bit)[1..];
      if (bit == "")
        return notify_fail("Your wombles just expired.\n");
      if (!master()->valid_read(bit, this_player(), 0))
        return notify_fail("Permission denied: " + bit + " .\n");
      if(sizeof(st = unguarded((:stat, bit:)))){
        if(stringp(st[0]))
          return notify_fail("Can't use diff on directories.\n");
      }
      arg += " " + last;
      last = bit;
      num ++;
    }
    
  } 

  if (num == 2)
    arg += " " + last;

  last = "/" + last;

  if (num > 3)
    return notify_fail("Can't compare more than two files");

  if (num == 3 && file_size(last) > 0)
    return notify_fail("File " + last + " exists.\n");

  fd = external_start(7, arg, "read_call_back", "write_call_back",
                      "close_call_back");
  if (fd == -1)
    return notify_fail("diff failed somehow.\n");

  TP = this_player();
  if (num == 3 && master()->valid_write(last, this_player(), 0))
    FILE = last;
  RET = "";

  return 1;
}

void read_call_back(int fd, mixed mess) {
  mess = replace(mess, "/usr/bin/", "");
  RET += mess;
}

void write_call_back(int fd) {
  tell_object(TP, "diff: Whoops! fatal error.\n");
}

void close_call_back(int fd) {
  if (FILE)
    write_file(FILE, RET);
  else {
    if(RET == "")
      RET = "those files are the same";
    TP->more_string(RET);
  }
  map_delete(ret, fd);
  map_delete(files, fd);
  map_delete(globals, fd);
}
// --- END [/mnt/home2/grok/lib/secure/cmds/creator/diff.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/cmds/creator/finde_rrors.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/cmds/creator/finde_rrors.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627450   Available: 13574804
Inodes: Total: 5242880    Free: 4960133
4762 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/cmds/creator/finde_rrors.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627450   Available: 13574804
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*
 * $Id: finde_rrors.c,v 1.4 2003/05/01 01:37:47 pinkfish Exp $
 */
/* finderrors command -*- LPC -*-
 * Handles bugreports in a collection of dirs for a creator 
 */

#include <log.h>
#include <board.h>
#include <mail.h>

inherit "/cmds/base";

// #define HELPER "/w/taffyd/handlers/finderror_helper"
#define HELPER "/obj/handlers/finderror_helper"
#define ERROR_CMD "/cmds/creator/errors"


private void finished_count_errors( object player, int status, mixed data ) {
    int *count; 
    string *paths; 
    mapping errors = ([ ]); 
    int *total = ({ 0, 0, 0 });
    string txt; 

    // tell_creator( player, "%O, %O\n", status, data );

    foreach( mapping direc in data ) {
        count = errors[ direc[ "Directory" ] ];

        if ( undefinedp( count ) ) { 
            count = ({ 0, 0, 0 });
        }

        switch( direc[ "Type" ] ) {
            case "BUG":
                count[ 0 ] = direc[ "COUNT(Id)" ]; 
                total[ 0 ] += count[ 0 ];
            break;
            case "TYPO":
                count[ 1 ] = direc[ "COUNT(Id)" ]; 
                total[ 1 ] += count[ 1 ];
            break;
            case "IDEA":
            default:
                count[ 2 ] = direc[ "COUNT(Id)" ]; 
                total[ 2 ] += count[ 2 ];
        }

        errors[ direc[ "Directory" ] ] = count; 
    } 

    paths = sort_array( keys( errors ), 1 ); 
    
    txt = "$P$finderrors$P$BUGS TYPO IDEA\n"; 



    foreach( string key in paths ) {
        txt += sprintf( "%4d %4d %4d %s\n", errors[ key ][ 0 ],
            errors[ key ][ 1 ], errors[ key ][ 2 ], key ); 
    } 
    
    txt += "-------------\n"; 
    txt += sprintf( "%4d %4d %4d\n", 
        total[ 0 ], total[ 1 ], total[ 2 ] ); 

    tell_object( player, txt );
    
} /* finished_count_errors() */ 

private int count_errors() { 
    int result;
    
    result = HELPER->query_dirs_count( this_player(), 
        (: finished_count_errors :) ); 

    if ( result ) { 
        add_succeeded_mess( ({ "Retrieving error count, this may take several "
            "seconds.\n", "" }) ); 
        return 1;
    }

    add_failed_mess(  "You have no finderrors directories defined.  "
        "Add them with 'finderrors add'\n" ); 
    return -1;
} /* count_errors() */ 

private void finished_next_dir( object player, int status, mixed data ) {
    // tell_creator( player, "%O, %O\n", status, data );

    if ( sizeof( data ) != 1 || !mapp( data[0] ) ) { 
        tell_object( player, "Unable to find the next directory "   
            "with errors.\n" );
    }
    else { 
        //start_error_command( player, data[ 0 ][ "Directory" ] ); 
        ERROR_CMD->errors_in_dir(data[0]["Directory"], 0);
    }
} /* finished_next_dir() */ 

private int get_next_error() { 
    HELPER->query_next_dir( this_player(), (: finished_next_dir :) ); 
    add_succeeded_mess( ({ "Retrieving error count, this may take several "
        "seconds.\n", "" }) ); 
    return 1;
} /* cmd() */ 

private int list_error_directories() {
    string *dirs;

    dirs = HELPER->query_directories( this_player()->query_name() );

    if ( sizeof( dirs ) ) { 
        tell_object( this_player(), "$P$finderrors list$P$" + 
            implode( dirs, "\n" ) + "\n" ); 
        add_succeeded_mess( "" );
        return 1;
    }
    else {
        add_failed_mess( "No directories have been added to finderrors.\n" );
        return -1;
    }
} /* list_error_directories() */ 

private int add_directory( string directory, int recursive ) { 
    
    if ( directory[ <1 ] != '/' ) {
        directory += "/";
    }

    if ( file_size( directory ) != -2 ) { 
        add_failed_mess( directory + " is not a directory.\n" ); 
        return -1; 
    }
     
    HELPER->add_directory( this_player(), directory, recursive );
    return 1; 
} /* add_directory() */ 

private int remove_directory( string directory, int recursive ) { 
    int result;
    
    result = HELPER->remove_directory( this_player(), directory, recursive ); 

    if ( result ) {
        add_succeeded_mess( "Directory removed successfully.\n" );
        return 1;
    }
    
    add_failed_mess( "Could not remove directory.  Was it on your "
        "finderrors list?\n" );
    return -1;
} /* remove_directory() */ 

public mixed *query_patterns() { 
    return ({ 
              "add <word>", (: add_directory( $4[ 0 ], 0 ) :), 
              "add <word> recursive", (: add_directory( $4[ 0 ], 1 ) :),
              "remove <word>", (: remove_directory( $4[ 0 ], 0 ) :), 
              "remove <word> recursive", (: remove_directory( $4[ 0 ], 1 ) :),
              "list", (: list_error_directories :), 
              "count", (: count_errors :),
              "", (: get_next_error :) }); 
} /* query_patterns() */ 
// --- END [/mnt/home2/grok/lib/secure/cmds/creator/finde_rrors.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/cmds/creator/rcsr_elease.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/cmds/creator/rcsr_elease.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627449   Available: 13574803
Inodes: Total: 5242880    Free: 4960133
2629 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/cmds/creator/rcsr_elease.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627449   Available: 13574803
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Id: rcsr_elease.c,v 1.8 2001/05/31 01:06:51 presto Exp $
 */
inherit "/cmds/base";
#include <creator.h>

#define CMD_NUM 3

mapping globals = ([]), files = ([]), ret = ([]);

#define TP globals[fd]
#define RET ret[fd]

mixed cmd(string arg) {
  int fd, nfiles = 0;
  string cmd;
  string bit, *bits;
  object *things;
  
  if(!arg)
    return notify_fail("rcsrelease: No arguments.\n");

  notify_fail("No such file: "+arg+"\n");
  
  bits = explode(arg, " ");
  arg = "";
  bits -= ({""});

  foreach(bit in bits){
    string *files = ({}), file;
    if (bit[0] == '-'){
      arg += (" " + bit);
      continue;
    }

    if (sizeof(files = this_player()->get_files(bit))) {
      foreach(file in files) {
        if(master()->valid_write(file, geteuid(this_player()), "cmd")) {
          arg += (" " + file[1..]);
          nfiles++;
        } else
          notify_fail("You do not have write access to "+file+"\n");
      }
    } else {
      if(sizeof(things = WIZ_PRESENT->wiz_present(bit, this_player()))) {
        file = file_name(things[0]);
        sscanf(file, "%s#%*d", file);
        if (file_size(file) <= 0)
          file += ".c";

        if(master()->valid_write(file, geteuid(this_player()), "cmd")) {
          arg += (" " + file[1..]);
          nfiles++;
        } else
          notify_fail("You do not have write access to "+file+"\n");
      }
    }
  }

  if(!nfiles)
    return 0;

  cmd = " -f -u -w" + this_player()->query_name() +arg;
#ifdef DEBUG    
  printf("CMD: %s\n", cmd);
#endif    
  fd = external_start(CMD_NUM, cmd, "read_call_back", "write_call_back",
                      "close_call_back");
    
  TP = this_player();
  RET = "";
  return 1;
}

void read_call_back(int fd, mixed mess) {
  mess = replace(mess, "/home/atuin/lib", "");
  RET += mess;
}

void write_call_back(int fd) {
  tell_object(TP, "rcsrelease: Whoops! fatal error.\n");
}

void close_call_back(int fd) {
  string file, *file_stuff;
  int i;

  if(RET != "")  {
    TP->more_string(RET);
    file_stuff = explode(RET, "\n");
    i = 0;
    while (i + 2 < sizeof(file_stuff))  {
      if (file_stuff[i + 2] == "done")  {  /* success! */
        sscanf(file_stuff[i], "%*s  -->  %s", file);
        RCS_HANDLER->remove_lock(TP, file);
        i += 3;
      }
      else if (sscanf(file_stuff[i], "%*sNo such file or directory"))  {
        ++i;
      }
      else if (file_stuff[i + 1][0..2] == "co:") {
          i += 2;
      }
      else {
          i += 3;
      }
    }
  }
  else
    tell_object(TP, "rcsrelease completed.\n");

  map_delete(ret, fd);
  map_delete(globals, fd);
}
// --- END [/mnt/home2/grok/lib/secure/cmds/creator/rcsr_elease.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/cmds/creator/rcsbatchin.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/cmds/creator/rcsbatchin.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627448   Available: 13574802
Inodes: Total: 5242880    Free: 4960133
5814 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/cmds/creator/rcsbatchin.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627448   Available: 13574802
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
#include <creator.h>

inherit "/cmds/base";

#define CMD_NUM 5

mapping globals = ([]);
mapping ret = ([]);
mapping cmds = ([]);
mapping comments = ([ ]);
mapping locks = ([ ]);
mapping completed = ([ ]);

#define TP globals[fd]
#define RET ret[fd]
#define CMDS cmds[this_player()]
#define COMMENT comments[TP]

void ask_about_file(object player);
void get_answer(string answer, object player);
void start_input(object player);

int cmd() {
   locks[this_player()] = RCS_HANDLER->query_locks(this_player());
   if (sizeof(locks[this_player()]) == 0)  {
      printf("You don't have any files locked.\n");
      map_delete(locks, this_player());
      return 1;
   }

   ask_about_file(this_player());
   return 1;

} /* cmd() */


void check_complete(object player)  {
   if (!completed[player])
      call_out("check_complete", 1, player);
   else  {
      map_delete(completed, player);
      ask_about_file(player);
   }
}


void ask_about_file(object player)  {
   string tmp;

   tmp = sprintf("Check in %s? (y/N/q)\n", locks[player][0]);
   tell_object(player, tmp);
   input_to("get_answer", 0, player);

} /* ask_about_file() */


void start_input(object player)  {
   unguarded((:input_to((: get_answer :), 0, $(player)) :));
}


void get_answer(string answer, object player)  {
   string  arg;
   string *tmp;

   if (answer == "y"  ||  answer == "Y")  {
      tmp = explode(locks[player][0], "/");
      if (file_size("/" + implode(tmp[0 .. <2], "/") + "/RCS/" + tmp[<1] +
                    ",v") > 0)
      {
         arg = locks[player][0][1 .. ];
         tell_object(player, "Enter a comment.\n");
         CMDS = arg;
         player->do_edit("", "do_ci", this_object(), "", player);
         return;
      }
      else  {
         arg = sprintf("ERROR: No RCS file for %s\n", locks[player][0]);
         tell_object(player, arg);
         if (sizeof(locks[player]) > 1)  {
            locks[player] = locks[player][1 .. ];
            ask_about_file(player);
         }
         else
            map_delete(locks, player);
      }
   }
   else if (answer == "q"  ||  answer == "Q")  {
      map_delete(locks, player);
      return;
   }
   else if (sizeof(locks[player]) > 1)  {
      locks[player] = locks[player][1 .. ];
      ask_about_file(player);
   }
   else
      map_delete(locks, player);

} /* get_answer() */


void do_ci(string comment, object player) {
   int fd;
   string *cmd = allocate(3);

   if (!comment) {
      tell_object(player, "No comment given, skipping.\n");
      if (sizeof(locks[player]) > 1)  {
         locks[player] = locks[player][1 .. ];
         ask_about_file(player);
      }
      else
         map_delete(locks, player);
   }
   else  {
      cmd[0] = "-w" + player->query_name();
      cmd[1] = "-u";
      cmd[2] = "-m" + comment;
      cmd += explode(CMDS, " ");

#ifdef DEBUG  
      tell_object(player, "CMD: %O\n", cmd);
#endif  
      fd = external_start(CMD_NUM, cmd, "read_call_back", "write_call_back",
                          "close_call_back");

      TP = player;
      RET = "";
      COMMENT = comment;

      if (sizeof(locks[player]) > 1)  {
         completed[player] = 0;
         tell_object(player, "Checking in... please wait\n");
         call_out("check_complete", 1, player);
      }
   }

} /* do_ci() */


// I _think_ this is the function to write the comment string to the
// ci command
void read_call_back(int fd, mixed mess) {
  mess = replace(mess, "/home/atuin/lib", "");
  RET += mess;
}


void write_call_back(int fd) {
  tell_object(TP, "rcsin: Write_call_back called.\n");
}


void close_call_back(int fd) {
   string  file;
   string *file_stuff;
   string *bits;
   string  log;
   string  lname;
   int     i;
   object  master;
  
   if (RET != "") {
      TP->more_string(RET);
      file_stuff = explode(RET, "\n");
      i = 0;
      while (i + 2 < sizeof(file_stuff))  {
         if (file_stuff[i + 2] == "done")  {  /* success! */
            sscanf(file_stuff[i], "%*s  <--  %s", file);
            RCS_HANDLER->remove_lock(TP, file);
        
            if (file[0] == 'w')
               lname = "";
            else if (file[0] == 'd') {
               bits = explode(file, "/");
               if (sizeof(bits) >= 2 &&
                   member_array(bits[1],
                                "/secure/master"->query_domains()) != -1)
               {
                  master = find_object("/d/" + bits[1] + "/master");
                  if (!master)
                     TP->tell_object("No master object for domain: " +
                                     bits[1] + ".\n");
                  else
                     lname = master->query_changelog(file);
               }
               if (!lname)
                  lname = "/d/" + explode(file, "/")[1] + "/ChangeLog";
            }
            else
               lname = "/log/ChangeLog";

            if (lname != "") {
               log = TP->fix_string(sprintf(" * %s %s %s\n%s\n",
                                            ctime(time())[4 .. ],
                                            file, TP->query_name(),
                                            COMMENT), 80, 21);
               log_file(lname, log);
            }
            i += 3;
         }
         else if (sscanf(file_stuff[i], "%*sNo such file or directory"))
            ++i;
         else if (file_stuff[i + 1][0 .. 2] == "ci:")
            i += 2;
         else
            i += 3;
      }
   }
   else
      tell_object(TP, "rcsin completed.\n");
  
   if (sizeof(locks[TP]) > 1)  {
      locks[TP] = locks[TP][1 .. ];
      completed[TP] = 1;
   }
   else  {
      map_delete(completed, TP);
      map_delete(locks, TP);
   }
  
   map_delete(comments, TP);
   map_delete(ret, fd);
   map_delete(globals, fd);

} /* close_call_back() */
// --- END [/mnt/home2/grok/lib/secure/cmds/creator/rcsbatchin.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/cmds/creator/gr_ep.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/cmds/creator/gr_ep.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627447   Available: 13574801
Inodes: Total: 5242880    Free: 4960133
2490 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/cmds/creator/gr_ep.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627447   Available: 13574801
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: gr_ep.c,v 1.1 2002/06/16 15:17:00 wodan Exp $
 * $Log: gr_ep.c,v $
 * Revision 1.1  2002/06/16 15:17:00  wodan
 * Initial revision
 *
 * Revision 1.5  2002/02/24 06:22:59  taffyd
 * Updated the --recursive check
 *
 * Revision 1.4  2001/05/28 05:59:17  ceres
 *  Forcibly unlocked by taffyd
 *
 * Revision 1.3  2000/08/28 21:31:57  wodan
 *  Forcibly unlocked by ceres
 *
 * Revision 1.2  1998/02/24 15:51:10  wodan
 * number of external command was changed
 *
 * Revision 1.1  1998/01/06 05:10:49  ceres
 * Initial revision
 * 
*/
inherit "/cmds/base";
#include <creator.h>

mapping globals = ([]), files = ([]), ret = ([]);

#define TP globals[fd]
#define RET ret[fd]

string *check_perms(string *done, string file){
  mixed perm=master()->valid_read(file, this_player()->query_name(), "cat");
  if(!perm)
    return done;
  if(intp(perm))
    perm = file;
  return done + ({perm});
}

mixed cmd(string arg) {
  int fd, search = 0, nfiles = 0;
  if(!arg)
    arg = "";
  else {
    string bit, *bits = explode(arg, " ");
    arg = "";
    bits -= ({""});

    foreach(bit in bits){
      string *files, file;
      if (bit[0] == '-'){
        if( ( bit == "-r" || bit == "--recursive" || bit== "-d=recurse" || 
       bit == "--directories=recurse" || bit == "-recursive" || 
        bit == "-directories=recurse" ) && !this_player()->query_lord() )
          continue;
        
        arg += (" " + bit);
        continue;
      }

      if(!search){
        search = 1;
        arg += (" " + bit);
      } else {
        files = this_player()->get_files(bit);
        files = implode(files, (:check_perms:), ({}));
        foreach(file in files){
          arg += (" " + file[1..]);
          nfiles++;
        }
      }
    } 
  }

  if(nfiles || !search)
    fd = external_start(6, arg, "read_call_back", "write_call_back",
                      "close_call_back");
  else
    return notify_fail("Grep needs at least one file.\n");

  if (fd == -1)
    return notify_fail("grep failed somehow.\n");

  TP = this_player();
  RET = "";

  write("grep started.\n");
  return 1;
}

void read_call_back(int fd, mixed mess) {
  mess = replace(mess, "/usr/bin/", "");
  RET += mess;
}

void write_call_back(int fd) {
  tell_object(TP, "grep: Whoops! fatal error.\n");
}

void close_call_back(int fd) {
  if(RET != "")
    TP->more_string(RET);
  else
    tell_object(TP, "grep finished.\n");
  map_delete(ret, fd);
  map_delete(globals, fd);
}
// --- END [/mnt/home2/grok/lib/secure/cmds/creator/gr_ep.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/cmds/creator/banish.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/cmds/creator/banish.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627446   Available: 13574800
Inodes: Total: 5242880    Free: 4960133
2201 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/cmds/creator/banish.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627446   Available: 13574800
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: banish.c,v 1.7 2003/04/15 20:27:22 ceres Exp $
 * $Log: banish.c,v $
 * Revision 1.7  2003/04/15 20:27:22  ceres
 * Removed dependence on login object
 *
 * Revision 1.6  2001/12/23 14:47:47  taffyd
 * Extended to add Liaison deputies as valid people who can banish names.
 *
 * Revision 1.5  2001/06/01 21:15:47  ceres
 * Added senior banish limit?
 *
 * Revision 1.4  2000/09/07 02:32:17  presto
 * Clear player cache for name before checking if the player exists.
 *
 * Revision 1.3  1998/09/21 04:47:18  ceres
 * Got it right this time
 *
 * Revision 1.1  1998/01/06 05:10:49  ceres
 * Initial revision
 * 
*/
#include <player_handler.h>

#define LIAISON "/d/liaison/master"

inherit "/cmds/base";
/*
 * Banish code removed from the patricians office by Pinkfish.
 */

int cmd(string str)
{
  string str1, temp1, ban;

  if (this_player() != this_player(1)) {
    return 0;
  }

  if (this_player()->GetForced()) { 
    return 0;
  }

  if(!master()->query_senior(geteuid(previous_object())) && 
      !LIAISON->query_deputy(geteuid(previous_object()))) {
    return notify_fail( "Only Liaison domain "
        "deputies, Senior Creators and above can banish player names.\n" ); 
  }  

  notify_fail("Syntax : banish <name> <reason>\n");
  if (!str)
    return 0;
  if (sscanf(str, "%s %s", str, str1) != 2)
    return 0;
  str = lower_case(str);
  if (sscanf(str,"%s.",temp1))
    return 0;
  if (sscanf(str, "%s/", temp1))
    return 0;
  if (file_size("/banish/"+str[0..0]+"/"+str+".o") >= 0)
  {
    notify_fail("That name is already banished.\n");
    return 0;
  }
  PLAYER_HANDLER->remove_cache_entry(str);
  if (PLAYER_HANDLER->test_user(str))
    return notify_fail("That is a player.  You must rm or mv the player "
                       "file first.\n");
  ban = "Banished by : "+(string)this_player()->query_name()+"\n";
  ban += ctime(time())+"\n";
  ban += "Banish Reason : " + str1 + "\n";
  unguarded((: write_file, "/banish/"+str[0..0]+"/"+str+".o", ban :));
  write(str + " banished.\n");
  return 1;
} /* cmd() */

string *query_patterns() {
  return ({ "", (: cmd(0) :), "<string>", (: cmd($4[0]) :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/secure/cmds/creator/banish.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/cmds/creator/ca_ll.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/cmds/creator/ca_ll.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627445   Available: 13574799
Inodes: Total: 5242880    Free: 4960133
3192 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/cmds/creator/ca_ll.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627445   Available: 13574799
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: ca_ll.c,v 1.5 2001/06/08 02:16:26 presto Exp $
 * $Log: ca_ll.c,v $
 * Revision 1.5  2001/06/08 02:16:26  presto
 * Fixed type warnings
 *
 * Revision 1.4  2001/05/23 00:49:12  presto
 * Type error: retobj was object, should have been mixed
 *
 * Revision 1.3  2000/07/02 10:15:14  taffyd
 * Added a reference_allowed() call.
 *
 * Revision 1.2  1999/04/08 11:07:38  terano
 * Removed no score check from informs
 *
 * Revision 1.1  1998/01/06 05:10:49  ceres
 * Initial revision
 * 
*/
/* call command, trial out by Turrican for a commands daemon. */

#include <creator.h>
#include <parser.h>

#define LMASTER "/d/liaison/master"

inherit "/cmds/base";

mixed cmd(string str) {
  /* call fish(x,y,z) object */
  mixed *args, file, f;
  mixed retobj;
  string *s, s1, s2;
  string fn,os, obvarname;
  string *argv;
  object *ov;
  object fish, shad, ob;

  notify_fail("USAGE : call [obvar=]lfun(arg[,arg[,arg...]]) object[s]\n");
  if (!str)
    return 0;
  obvarname = (string)0;
  sscanf(str, "%s=%s", obvarname, str);
  s = explode("&"+str+"&", ")");
  if (sizeof(s) < 2 || sscanf(s[0], "%s(%s", s1, s2) != 2)
    return 0;
  fn = replace(s1[1..], " ", "");
  s[0] = s2;
  args = PARSER->parse_args(implode(s, ")"), ")");
  if (!args) return 1;
  argv = args[0];
  os = args[1][0..<2];
  while (strlen(os) && os[0] == ' ')
    os = os[1..];
  notify_fail("Can't find object "+os+".\n");
  ov = WIZ_PRESENT->wiz_present(os, this_player());
  
  ov = filter( ov, (: reference_allowed( $1, $( this_player() ) ) :) );  

  if (!sizeof(ov)) return 0;

  if (sizeof(argv) < 6) argv += allocate(6 - sizeof(argv));

  foreach (ob in ov) {
    fish = ob;
    while (shad = shadow(fish, 0)) {
      fish = shad;
      if (f = function_exists(fn, fish)) file = f;
    }
    if (!file) file = function_exists(fn, ob);
    if (file) {
  if ( ( ob != this_player() && ob->query_property( "player" ) ) ) {
        unguarded((: write_file,
                   (LMASTER->query_member(this_player()->query_name()) ?
                    "/d/admin/log/CALL_LIAISONS.log" :
                    "/d/admin/log/CALL_CREATORS.log" ),
                   sprintf("%s: %s (%O) called %s(%s) on %s (%O)\n",
                           ctime(time()),
                           this_player()->query_name(), this_player(),
                           fn, implode(argv - ({0}), ", "),
        ob->query_name(), ob) :));
        user_event("inform", sprintf("%s called %s(%s) on %s",
            this_player()->query_name(), fn, implode(argv - ({0}), ", "),
            ob->query_name()), "calls");
      }
      retobj = call_other(ob,fn,argv...);
/*      inform_of_call(ov[i], ({ fn }) + argv); */
      printf("*** function on '%s' found in %s ***\n",
          WIZ_PRESENT->desc_object(ob), file);
      write(sprintf("$P$Call result$P$Returned: %O\n", retobj));
      if (obvarname) {
        if (objectp(retobj)) this_player()->set_obvar(obvarname, retobj);
        /* others could be done ... like arrays etc, but phuck it */
      }
    } else
      printf("*** function on '%s' Not found ***\n",
          WIZ_PRESENT->desc_object(ob));
    file = 0;
  }
  return 1;
}
// --- END [/mnt/home2/grok/lib/secure/cmds/creator/ca_ll.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/cmds/creator/rcsre_vert.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/cmds/creator/rcsre_vert.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627444   Available: 13574798
Inodes: Total: 5242880    Free: 4960133
1927 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/cmds/creator/rcsre_vert.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627444   Available: 13574798
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Id: rcsre_vert.c,v 1.2 2002/08/05 04:10:07 presto Exp $
 */
inherit "/cmds/base";
#include <creator.h>

#define CMD_NUM 8

mapping globals = ([]), ret = ([]);

#define TP globals[fd]
#define RET ret[fd]

mixed cmd(string arg) {
  int nfiles, fd;
  string bit, *bits, *cmd;
  object *things;
  
  if (!arg) {
    return notify_fail("rcsrevert: No arguments.\n");
  }

  bits = explode(arg, " ");
  arg = "";
  bits -= ({ "", 0 });

  foreach(bit in bits) {
    string *files, file;
    if (bit[0] == '-') {
      arg += (" " + bit);
      continue;
    }

    if (sizeof(files = this_player()->get_files(bit))) {
      foreach(file in files) {
        arg += (" " + file[1..]);
        nfiles++;
      }
    } else {
      if(sizeof(things = WIZ_PRESENT->wiz_present(bit, this_player()))) {
        file = file_name(things[0]);
        sscanf(file, "%s#%*d", file);
        if (file_size(file) <= 0)
          file += ".c";

        arg += (" " + file[1..]);
        nfiles++;
      }
    }
  }

  if(!nfiles) {
    return notify_fail("rcsrevert: no such file "+arg+".\n");
  }

  cmd = allocate(3);
  cmd[0] = "-w" + this_player()->query_name();
  cmd[1] = "-u";
  cmd[2] = "-l";
  cmd += explode(arg, " ");
#ifdef DEBUG  
  printf("CMD: %O\n", cmd);
#endif  
  fd = external_start(CMD_NUM, cmd, "read_call_back", "write_call_back",
                      "close_call_back");
    
  TP = this_player();
  RET = "";
  return 1;
}

// I _think_ this is the function to write the comment string to the ci command
void read_call_back(int fd, mixed mess) {
  mess = replace(mess, "/home/atuin/lib", "");
  RET += mess;
}

void write_call_back(int fd) {
  tell_object(TP, "rcsrevert: write_call_back() called.\n");
}

void close_call_back(int fd) {
  if (RET != "") {
    TP->more_string(RET);
  } else {
    tell_object(TP, "rcsin completed.\n");
  }
  
  map_delete(ret, fd);
  map_delete(globals, fd);
}
// --- END [/mnt/home2/grok/lib/secure/cmds/creator/rcsre_vert.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/cmds/creator/ta_il.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/cmds/creator/ta_il.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627443   Available: 13574797
Inodes: Total: 5242880    Free: 4960133
1861 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/cmds/creator/ta_il.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627443   Available: 13574797
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: ta_il.c,v 1.4 1999/10/21 01:26:45 shrike Exp $
 * $Log: ta_il.c,v $
 * Revision 1.4  1999/10/21 01:26:45  shrike
 * switched over to using file_length() to avoid errors on too-large files.
 *
 * Revision 1.3  1999/10/12 22:39:53  shrike
 * *sob* it's right this time, honest! :P
 *
 * Revision 1.1  1998/01/06 05:10:49  ceres
 * Initial revision
 * 
*/
/* tail command, trial out by Turrican for a commands daemon. */

#include <creator.h>

inherit "/cmds/base";

mixed cmd( string str, int num ) {
   string *filenames;
   int loop;
   object *obs;
  
   if (num < 0)  {
      num = -num;
   }
   if (num == 0)  {
      num = 20;
   }

   if ( !str ) {
      notify_fail( "Tail what file(s)/object(s)?\n" );
      return 0;
   }
   if ( !sizeof( filenames = this_player()->get_files( str ) ) ) {
      if ( sizeof( obs = WIZ_PRESENT->wiz_present( str, this_player() ) ) ) {
         filenames = map( obs, (: base_name($1) :) );
         filenames = map( filenames,
           (: ( file_size($1) <= 0 ? $1 + ".c" : $1 ) :) );
      } else
         return notify_fail( str + ": No such file(s)/object(s).\n" );
   }
   
   foreach( str in filenames )
      if( ( file_size( str ) == -2 ) || ( str[<2..<1] == ".." ) )
         filenames -= ({ str });

   for( loop = 0; loop < sizeof( filenames ); loop++ ) {
      str = filenames[loop];
      if( sizeof( filenames ) > 1 ) {
         printf( "%*'-'s\nFILE : %s\n", 80, "", str );
      }
      if ( file_size( str ) < 0)
         write( "That file/object is not readable, or does not exist.\n" );
      else {
         write( read_file( str, ( ( file_length( str ) + 1 ) - num ) ) );
      }   
   }
   return 1;
}

mixed *query_patterns()  {
   return ({ "<number> <string>", (: cmd($4[1], to_int( $4[0] ) ) :) ,
             "<string>", (: cmd($4[0], 20) :) });
}
// --- END [/mnt/home2/grok/lib/secure/cmds/creator/ta_il.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/cmds/creator/exe_c.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/cmds/creator/exe_c.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627443   Available: 13574797
Inodes: Total: 5242880    Free: 4960133
1655 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/cmds/creator/exe_c.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627443   Available: 13574797
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Id: exe_c.c,v 1.9 2000/07/01 01:18:28 pinkfish Exp $
 * 
 */
#include <cmds/options.h>
inherit "/cmds/base";

#define LOG_FILE "/d/admin/log/EXEC.log"

mixed do_exec(string str, string ref suc) {
  mixed ret;
  string file;
  string wiz_dir;
  string file_header;
  object ob;
        
  if (!this_player()) {
    suc = "fail";
    return 0;
  }
  wiz_dir = "/w/" + this_player()->query_name();
  if (file_size(wiz_dir) != -2) {
    suc = "fail";
    return notify_fail("Directory: " + wiz_dir + " does not exist.\n");
  }
  file = wiz_dir + "/exec_tmp";
  if (ob = find_object(file)) {
    file->dest_me();
    if(ob)
      destruct(ob);
  }
  if (file_size(file + ".c") > 0) {
    rm(file+".c");
  }
  unguarded((: write_file(LOG_FILE, ctime(time()) + " - " + 
                          this_player()->query_name() + ": " + $(str) +
                          "\n") :));
  file_header = this_player()->query_property(OPTION_EXEC_INCLUDE);
  if (file_header) {
     write_file(file + ".c", "#include \"" + file_header + "\"\n\n");
  }
  write_file(file + ".c",
             "void dest_me() { destruct(this_object()); }\n"
             "mixed do_call() {\n" + str + ";\n}\n");
  suc = catch(ret = file->do_call());

  if ((ob = find_object(file))) {
    ob->dest_me();
  }
  rm(file + ".c");
  return ret;
} /* do_exec() */

int cmd(string str) {
  string err;

  mixed ret = do_exec(str, ref err);
  if (err == "fail")
    return 0;
  if (err == 0) {
    this_player()->more_string(sprintf("\nReturns: %O\n", ret),
                               "Exec results");
  } else {
    printf("Exec failed: %s", err);
  }
  return 1;
}
// --- END [/mnt/home2/grok/lib/secure/cmds/creator/exe_c.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/cmds/creator/cl_one.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/cmds/creator/cl_one.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627442   Available: 13574796
Inodes: Total: 5242880    Free: 4960133
2028 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/cmds/creator/cl_one.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627442   Available: 13574796
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: cl_one.c,v 1.2 1998/03/25 15:49:45 turrican Exp $
 * $Log: cl_one.c,v $
 * Revision 1.2  1998/03/25 15:49:45  turrican
 * Moved from /cmds/creator
 *
 * Revision 1.1  1998/01/06 05:25:41  ceres
 * Initial revision
 * 
 */
/* clone command, trial out by Turrican for a commands daemon. */

#include <creator.h>

inherit "/cmds/base";

mixed cmd(string str) {
    object ob;
    string err, *filenames, obvarname;
    int loop, mov;

    if (!str) {
        notify_fail("Clone what ?\n");
        return 0;
    }

    obvarname = (string)0;
    sscanf(str, "%s=%s", obvarname, str);  /* for clone temp=/obj/misc/torch */
    filenames = this_player()->get_cfiles(str);
    if (!sizeof(filenames))  {
        notify_fail("No such file.\n");
        return 0;
    }

    for(loop = 0; loop < sizeof(filenames); loop++) {
       str = filenames[loop];
       if (file_size(str) < 0 && file_size(str + ".c") < 0) {
          notify_fail("No such file.\n");
          return 0;
       }
/*    err = catch(ob = clone_object(str));
       handle_error(err, "clone_object()"); */
       ob = clone_object(str);
       if (obvarname) this_player()->set_obvar(obvarname, ob);  /* hack by ember */
       if (ob) {
          err = catch((mov = (int)ob->move(this_player())));
          this_player()->handle_error(err, "move(this_player())");
          if (err || mov) {
             err = catch(ob -> move(environment(this_player())));
             this_player()->handle_error(err, "move(environment())");
          }
          printf("Ok.  Object %O cloned and put in "+
             (environment(ob)==this_player() ? "you" : 
              (environment(ob)==environment(this_player()) ? "here" : WIZ_PRESENT->desc_object(environment(ob))))+
             ".\n", ob);
          say((string)this_player()->query_cap_name() + " fetches " +
            (string)ob->one_short() + " from another dimension.\n");
       } else {
          printf("Failed to clone.\n");
       }
    }
    return 1;
}
// --- END [/mnt/home2/grok/lib/secure/cmds/creator/cl_one.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/cmds/creator/rcsl_og.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/cmds/creator/rcsl_og.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627441   Available: 13574795
Inodes: Total: 5242880    Free: 4960133
1732 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/cmds/creator/rcsl_og.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627441   Available: 13574795
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Id: rcsl_og.c,v 1.5 2001/05/24 06:47:25 taffyd Exp $
 */
inherit "/cmds/base";
#include <creator.h>

#define CMD_NUM 1

mapping globals = ([]), files = ([]), ret = ([]);

#define TP globals[fd]
#define RET ret[fd]

mixed cmd(string arg) {
  int fd, nfiles = 0;
  string cmd;
  string bit, *bits;
  object *things;
  
  if(!arg)
    return notify_fail("rcslog: No arguments.\n");


  notify_fail("rcslog: No such file "+arg+"\n");
  bits = explode(arg, " ");
  arg = "";
  bits -= ({""});

  foreach(bit in bits){
    string *files = ({ }), file;
    if (bit[0] == '-'){
      arg += (" " + bit);
      continue;
    }
    
    if (sizeof(files = this_player()->get_files(bit))) {
      foreach(file in files) {
        arg += (" " + file[1..]);
        nfiles++;
      }
    } else {
      if(sizeof(things = WIZ_PRESENT->wiz_present(bit, this_player()))) {
        file = file_name(things[0]);
        sscanf(file, "%s#%*d", file);
        if (file_size(file) <= 0)
          file += ".c";

        arg += (" " + file[1..]);
        nfiles++;
      }
    }
  }

  if(!nfiles)
    return 0;
    
  cmd =  arg;
#ifdef DEBUG    
  printf("CMD: %s\n", cmd);
#endif    
  fd = external_start(CMD_NUM, cmd, "read_call_back", "write_call_back",
                      "close_call_back");
    
  TP = this_player();
  RET = "";
  return 1;
}

void read_call_back(int fd, mixed mess) {
  mess = replace(mess, "/home/atuin/lib", "");
  RET += mess;
}

void write_call_back(int fd) {
  tell_object(TP, "rcslog: Whoops! fatal error.\n");
}

void close_call_back(int fd) {
  if(RET != "")
    TP->more_string(RET);
  else
    tell_object(TP, "rcslog completed.\n");
  map_delete(ret, fd);
  map_delete(globals, fd);
}
// --- END [/mnt/home2/grok/lib/secure/cmds/creator/rcsl_og.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/cmds/creator/mylocks.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/cmds/creator/mylocks.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627441   Available: 13574795
Inodes: Total: 5242880    Free: 4960133
1829 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/cmds/creator/mylocks.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627441   Available: 13574795
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <creator.h>

inherit "/cmds/base";

int cmd(string person)  {
   string *locked;
   string who_string;

   if(person == "verify") {
     locked = RCS_HANDLER->query_locks( this_player() );
     locked = sort_array( locked, 1 );
     call_out("verify_lock", 1, this_player(), locked);
     write("Verifying\n");
     return 1;
   }
   
   if (!person  ||  file_size(person) == -2)  {
      who_string = "You have ";
      locked = RCS_HANDLER->query_locks( this_player() );
      if (person)
         locked = filter(locked, (: strsrch($1, $(person)) == 0 :));
   }
   else  {
      who_string = capitalize( person ) + " has ";
      locked = RCS_HANDLER->query_locks( person );
   }

   if ( !sizeof( locked ) ) {
      add_failed_mess( who_string + "no files locked.\n" );
      return -1;
   }

   locked = sort_array( locked, 1 );

   write( who_string + "the following files locked:\n" +
     implode(locked, "\n") + "\n");
   return 1;
} /* cmd() */

void verify_lock(object pl, string *locks) {
  string file, lockline, *bits;
  int remove;
  
  file = locks[0];
  bits = explode(file, "/");
  file = "/" + (string)implode(bits[0..<2], "/") + "/RCS/" + bits[<1] + ",v";
  
  if(file_size(file) < 0)
    remove = 1;
  else {
    lockline = read_file(file, 4, 1);
    if (strsrch(lockline, "locks; strict:") == -1) {
      bits = explode(read_file(file, 5, 1), ":");
      if(bits[0][0] != '\t')
        remove = 1;
    }
  }
  
  if(remove) {
    tell_object(pl, "Removing non-existant lock for " + locks[0] + "\n");
    RCS_HANDLER->remove_lock(pl->query_name(), locks[0]);
  }
  
  if(sizeof(locks) > 1)
    call_out("verify_lock", 1, this_player(), locks[1..]);
}

mixed *query_patterns() {
   return ({ "", (: cmd(0) :),
     "<string'creator|directory|verify'>", (: cmd($4[0] ) :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/secure/cmds/creator/mylocks.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/cmds/creator/ed.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/cmds/creator/ed.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627440   Available: 13574794
Inodes: Total: 5242880    Free: 4960133
2790 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/cmds/creator/ed.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627440   Available: 13574794
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: ed.c,v 1.7 2000/07/17 02:58:13 presto Exp $
 * $Log: ed.c,v $
 * Revision 1.7  2000/07/17 02:58:13  presto
 * Fix up str arg passed to do_edit when using "magic"
 *
 * Revision 1.6  1998/10/02 01:21:15  presto
 * changed so that "ed  bing" doesn't try to open a file named " bing"
 *
 * Revision 1.5  1998/03/25 16:01:58  turrican
 * Moved from /cmds/creator
 *
 * Revision 1.4  1998/01/19 00:04:06  presto
 * Put it back the way it was
 *
 * Revision 1.1  1998/01/06 05:25:41  ceres
 * Initial revision
 * 
*/
/* ed command, trial out by Turrican for a commands daemon. */

#include <creator.h>

inherit "/cmds/base";

object *people = ({ });

mixed cmd(string str) {
  string *filenames, spam;
  object *things;

  people += ({ this_player() });

  if ( this_player()->query_editor() == "magic" )  {
    // set str to " " so that 'ed' with no argument gives you the correct
    // command set
    if ( !str )  str = " ";
    this_player()->do_edit( 0, "fini_editor", 0, str );
    return 1;
  }
  if (!str) {
    this_player()->set_in_editor("(hidden)");
    ed("frog", "fini_editor");
    return 1;
  }
  /* dodgy idea, but allows 'ed here' or 'ed strawberry' */        
  if (sizeof(things = WIZ_PRESENT->wiz_present(str, this_player()))) {
    spam = file_name(things[0]);
    sscanf(spam, "%s#%*d", spam);
    if (file_size(spam) < 0)
      filenames = ({ spam+".c" });
    else
      filenames = ({ spam });
  } else
    filenames = this_player()->get_files(str);
  if (!sizeof(filenames)) { 
    str = this_player()->get_path(str);
  } else {
    if (sizeof(filenames) > 0) {
      str = filenames[0];
      if (sizeof(filenames) > 1) {
        int loop;

        loop = 0;
        while(loop < sizeof(filenames) && file_size(filenames[loop]) < 0)
          loop++;
        if(loop >= sizeof(filenames)) {
          printf("No such file.\n");
          people -= ({ this_player() });
          return 0;
        }
        else {
          str = filenames[loop];
        } 
        printf("Ambiguous, using : %s\n", str);
      }
    }
  }
  if (file_size(str) == -2) {
    printf("directory\n");
    people -= ({ this_player() });
    return 0;
  }
  this_player()->set_in_editor(str);
  printf("Editing: %s ", str);
  if (!master()->valid_write(str, geteuid(), "frog"))
    printf("[read only]\n");
  else
    printf("\n");
  ed(str, "fini_editor");
  return 1;
}

void fini_editor() {
  if (objectp(this_player()))  {
    people -= ({ this_player() });
    this_player()->set_in_editor(0);
  }
} /* fini_editor() */


int clean_up()  {
   people -= ({ 0 });
   if ( !sizeof( people ) )  {
      ::clean_up();
   }
   return 1;
}

void reset()  {
   people -= ({ 0 });
   if ( !sizeof( people ) )  {
      ::reset();
   }
   return;
}
// --- END [/mnt/home2/grok/lib/secure/cmds/creator/ed.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/cmds/creator/zcat.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/cmds/creator/zcat.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627439   Available: 13574793
Inodes: Total: 5242880    Free: 4960133
2620 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/cmds/creator/zcat.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627439   Available: 13574793
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming

#include <creator.h>
#include <runtime_config.h>

#define TP globals[fd]
#define RET ret[fd]

#define CMD_NUM 9

inherit "/cmds/base";

private mapping globals = ([]), files = ([]), ret = ([]);

int cmd( string fname, int list ) {
    string *files;
    string euid; 
    string args;
    int fd;
    int count; 

    files = this_player()->get_files( fname ); 

    if ( !sizeof( files ) ) { 
        files += ({ this_player()->get_path( fname ) }); 
    }
    
    euid = geteuid( this_player(1) ); 
    
    // Place any default arguments in here.
    args = "--stdout";

    if ( list ) { 
        args += " --list";
    }

    files = uniq_array( files ); 
    count = 0;

    foreach( string file in files ) { 
        if ( !master()->valid_read( file, euid, "cat" ) ) { 
            tell_object( this_player(), "You don't have write access to "
                +  file + ".\n" ); 
        }
        else {
            args += " " + file[1..];
            ++count;
        }
    }

    if ( count ) {   
        log_file("/d/admin/log/ZCAT", ctime(time()) + ": " + 
                 this_player()->query_name() + " " + args + "\n");
        fd = external_start( CMD_NUM, args, "read_call_back", 
            "write_call_back", "close_call_back" ); 
    }
    else { 
        add_failed_mess( "zcat must have at least one argument.\n" );
        return -1;
    }

    if ( fd == -1 ) {
        add_failed_mess( "zcat failed to start.\n" );
        return -1;
    }
    
    TP = this_player(); 
    RET = ""; 

    tell_object( this_player(), "zcat started.\n" );
    return 1; 
} /* cmd() */ 

void read_call_back(int fd, mixed mess) {
    int max_len; 
    int new_total;

    mess = replace(mess, "/bin/", "");
    max_len = get_config( __MAX_STRING_LENGTH__ ); 

    new_total = strlen( RET ) + strlen( mess ); 

    if ( new_total > max_len ) { 
        mess = mess[ 0.. (new_total - max_len - 1) ];
    }

    RET += mess;
} /* read_call_back() */ 

void write_call_back( int fd ) {
    tell_object(TP, "zcat: A fatal error has occurred -- write_call_back "
        "was called.\n");
} /* write_call_back() */ 

void close_call_back(int fd) {
    if ( RET != "" ) { 
        if ( catch( TP->more_string(strip_colours(RET)) ) ) { 
            efun::tell_object( TP, RET );             
        }
    }
    else { 
        tell_object(TP, "zcat finished.\n");
    }
    
    map_delete(ret, fd);
    map_delete(globals, fd);
}

mixed *query_patterns() { 
    return ({ "<string>", (: cmd( $4[0], 0 ) :),
              "{-l|--list|list} <string>", (: cmd( $4[1], 1 ) :)       
    });
} /* query_patterns() */ 
// --- END [/mnt/home2/grok/lib/secure/cmds/creator/zcat.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/cmds/creator/harass.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/cmds/creator/harass.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627438   Available: 13574792
Inodes: Total: 5242880    Free: 4960133
1192 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/cmds/creator/harass.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627438   Available: 13574792
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
string info = "";
mapping busy = ([]);

void create(){
  seteuid("Root");
}

void receive_snoop(string bing){
  info += bing;
}

string query_result(){ return info; }

void remind(){
  if(busy[this_player()]){
    write("Type harass again to stop logging.\n");
    call_out((:remind:), 60);
  }
}

mixed *query_patterns(){
  return ({"", function(){
      if(busy[this_player()]){
        string result = busy[this_player()]->query_result();
        unguarded((:write_file,sprintf("/d/liaison/secure/harass/%s%d", 
                                       this_player()->query_name(), time()),
                   $(result):));
        destruct(busy[this_player()]);
        map_delete(busy, this_player());
        write("Log written.\n");
        return 1;
      } else {
        busy[this_player()] = clone_object(__FILE__);
        if(efun::snoop(busy[this_player()], this_player())){
          write("Started logging.\nType harass again to stop.\n");
          call_out((:remind:), 60);
          return 1;
        } else {
          destruct(busy[this_player()]);
          map_delete(busy, this_player());
          write("Failed.\n");
          return 1;
        }
      }
    }
  });
}
// --- END [/mnt/home2/grok/lib/secure/cmds/creator/harass.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/cmds/creator/rmp_layer.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/cmds/creator/rmp_layer.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627438   Available: 13574792
Inodes: Total: 5242880    Free: 4960133
4468 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/cmds/creator/rmp_layer.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627438   Available: 13574792
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker: ceres $
 * $Id: rmp_layer.c,v 1.7 2003/04/06 02:33:56 ceres Exp ceres $
 */

/* rmplayer, deletes a player's save file and calls the refresh
 * handler on that player.
 */

#include <refresh.h>
#include <player_handler.h>
#include <player_handler.h>


inherit "/cmds/base";

private void sure(string response, string player, string lord, string reason,
                  int immediately) {
  if(previous_object() && 
     member_array(find_object("/secure/simul_efun"), 
                  previous_object( -1 ) ) == -1 ) {
    log_file("CHEAT", ctime(time()) +
             ": illegal attempt to delete a player.\nTrace: " +
             back_trace());
    write("Illegal use of rmplayer.\n");
    return;
  }
  
  if (response == "YES") {
    string olduid, src, ext;
    
    write("Ok.  Deleting\n");
    olduid = geteuid();
    seteuid("Root");
    if(file_size(PLAYER_HANDLER->query_player_ram_file_name(player)+".o.gz") > 0){
      src = PLAYER_HANDLER->query_player_ram_file_name(player);
      ext = ".o.gz";
    } else if(file_size(PLAYER_HANDLER->query_player_disk_file_name(player)+".o.gz") > 0) {
      src = PLAYER_HANDLER->query_player_disk_file_name(player);
      ext = ".o.gz";
    } else if(file_size(PLAYER_HANDLER->query_player_disk_file_name(player)+".o") > 0) {
      src = PLAYER_HANDLER->query_player_disk_file_name(player);
      ext = ".o";
    } else if(file_size(PLAYER_HANDLER->query_delete_player_file_name(player) + ".o.gz") > 0) {
      src = PLAYER_HANDLER->query_delete_player_file_name(player);
      ext = ".o.gz";
    } else if(file_size(PLAYER_HANDLER->query_delete_player_file_name(player)+ ".o") > 0) {
      src = PLAYER_HANDLER->query_delete_player_file_name(player);
      ext = ".o";
    }

    if(src && ext) {
      if(!immediately)
        unguarded((: cp($(src) + $(ext), "/save/players/appeal/"+
                        $(player)+$(ext)):));
      unguarded((: rm($(src)+$(ext)) :));
      if(src == PLAYER_HANDLER->query_player_ram_file_name(player)) {
        src = PLAYER_HANDLER->query_player_disk_file_name(player);
        unguarded((: rm($(src)+$(ext)) :));
      }
      PLAYER_HANDLER->remove_cache_entry( player );
      unguarded((: write_file, "/log/SUSPEND",
                 ctime(time()) + " "+ player + " deleted by " + lord +
                 " because " + reason + ".\n" :) );
      seteuid(olduid);
    }
  } else {
    write("Ok.  Not deleting\n");
  }
  return;
}

int cmd(string player, string reason, int immediately) {
  if (!master()->query_liaison_deputy_or_lord(previous_object(-1))) {
    unguarded((: log_file, "/log/CHEAT", ctime(time()) +
               ": illegal attempt to delete a player.\nTrace: " +
               back_trace() :));
    return notify_fail("Sorry: only directors can delete players.\n");
  }
  
  /* At this point, I'm satisfied that the object is _allowed_ to
   * delete players.  But is this a player?
   */
  if (!PLAYER_HANDLER->test_user(player)) {
    return notify_fail("Sorry, but " + player + " isn't a player\n");
  }
  
  /* Is a non H trying to delete an H or L? */
  if (!master()->high_programmer(previous_object(-1)) &&
      master()->query_lord(player)) {
    unguarded( (: log_file, "/log/CHEAT", ctime(time()) +
                ": Illegal attempt to delete a director.\nTrace: " +
                back_trace() :) );
    return notify_fail("Sorry.\n");
  }

  if(!master()->query_lord(previous_object(-1)) &&
       PLAYER_HANDLER->test_age(player) < - (86400)) {
    add_failed_mess("Only directors can immediately delete players over "
                    "24 hours old.\n");
    return 0;
  }
  
  if (!master()->query_lord(previous_object(-1)) &&
      PLAYER_HANDLER->test_creator(player)) {
    add_failed_mess("You cannot delete creators.\n");
    return 0;
  }
   
  if(!reason || reason == "") {
    return notify_fail("You must give a reason.\n");
  }
  
  /* Ok.  Looks like everything is copasetic. */
  write("This will permanently delete the player " + player + ".\n" +
        "THIS IS PERMANENT.\n" +
        "Are you sure?  (only \"YES\" will delete the player)  ");
  input_to((: sure :), 0, player, this_player()->query_name(), reason,
           immediately);
  return 1;
}

mixed *query_patterns() {
  return ({ "<word'player name'> <string'reason'>", (: cmd($4[0], $4[1], 0) :),
            " immediately <word'player name'> <string'reason'>",
              (: cmd($4[0], $4[1], 1) :) });
}
// --- END [/mnt/home2/grok/lib/secure/cmds/creator/rmp_layer.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/cmds/creator/dbxframe.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/cmds/creator/dbxframe.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627437   Available: 13574791
Inodes: Total: 5242880    Free: 4960133
2048 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/cmds/creator/dbxframe.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627437   Available: 13574791
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Id: dbxframe.c,v 1.2 2000/10/16 20:02:19 turrican Exp $
 */
inherit "/cmds/base";

string print_vars(mixed *vars) {
  string *result = allocate(sizeof(vars));
  int i;

  for (i=0; i<sizeof(vars); i++) {
    if (mapp(vars[i]))
      result[i] = "([ ... ])";
    else if (functionp(vars[i]))
      result[i] = "(: ... :)";
    else if (intp(vars[i])) {
      if (vars[i]) result[i]=vars[i]+"";
      else if (nullp(vars[i])) result[i]="NULL";
      else if (undefinedp(vars[i])) result[i]="UNDEFINED";
      else result[i]="0";
    }
    else if (stringp(vars[i]))
      result[i] = "\""+vars[i]+"\"";
    else if (pointerp(vars[i]))
      result[i] = "({ ... })";
    else if (floatp(vars[i]))
      result[i] = vars[i]+"";
    else if (bufferp(vars[i]))
      result[i] = "<BUFFER>";
  }
  return implode(result, ", ");
}

int cmd(string str) {
  mapping frame;
  object ob;
  string who;
  int num;
  string file;

  if (!str || (sscanf(str, "%d", num) != 1 &&
               sscanf(str, "%s %d", who, num) != 2)) {
    write("dbxframe [<who>] <frame>\n");
    return 1;
  }
  if (who) {
    who = this_player()->expand_nickname(who);
    ob = find_player(who);
    if (!ob) {
      write("No such player.\n");
      return 1;
    }
  }
  else ob = this_player();
  frame = ob->get_last_error();
  if (!frame) {
    write("No error.\n");
    return 1;
  }
  if (num < 1 || num > sizeof(frame["trace"]))
    return notify_fail("No such frame.\n");
  num--;
  frame = frame["trace"][num];
  file = frame["file"];
  if (file[0] != '/') {
    file = "/" + file;
  }
  
  printf("------%s:%i - %s(%s)\n", file, frame["line"],
         frame["function"],print_vars(frame["arguments"]));
  printf("locals: %s\n", print_vars(frame["locals"]));
  printf("----------------------------------------------------------------\n");
  write(sprintf("%s%%^YELLOW%%^=>%s%%^RESET%%^%s",
         read_file(file, frame["line"]-5, 5),
         read_file(file, frame["line"], 1),
         read_file(file, frame["line"]+1, 5)));
  return 1;
}
// --- END [/mnt/home2/grok/lib/secure/cmds/creator/dbxframe.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/cmds/creator/rcsloc_ks.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/cmds/creator/rcsloc_ks.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627436   Available: 13574790
Inodes: Total: 5242880    Free: 4960133
1828 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/cmds/creator/rcsloc_ks.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627436   Available: 13574790
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Id: rcsloc_ks.c,v 1.2 2000/10/30 00:58:14 presto Exp $
 */
inherit "/cmds/base";
#include <creator.h>

#define DEBUG 1

#define CMD_NUM 5

mapping globals = ([]), ret = ([]);

#define TP globals[fd]
#define RET ret[fd]

mixed cmd(string arg) {
  int nfiles = 0;
  string bit, *bits, file, locker, *files, fname;
  object *things;
  
  if (!arg) {
    return notify_fail("rcslocks: No arguments.\n");
  }

  bits = explode(arg, " ");
  arg = "";
  bits -= ({ "", 0 });

  files = ({ });
  foreach(bit in bits) {
    if (bit[0] == '-') {
      arg += (" " + bit);
      continue;
    }
    if (sizeof(files = this_player()->get_files(bit))) {
      foreach(file in files) {
        arg += (" " + file[1..]);
        nfiles++;
      }
    } else {
      if(sizeof(things = WIZ_PRESENT->wiz_present(bit, this_player()))) {
        file = file_name(things[0]);
        sscanf(file, "%s#%*d", file);
        if (file_size(file) <= 0)
          file += ".c";

        arg += (" " + file[1..]);
        nfiles++;
      }
    }
  }
  
  if(!nfiles) {
    return notify_fail("rcslocks: no such file "+arg+".\n");
  }

  // Now check if the file is locked and who it is locked by!

  foreach(fname in files) {
    string lockline;

    bits = explode(fname, "/");
    file = "/" + (string)implode(bits[0..<2], "/") + "/RCS/" + bits[<1] + ",v";

    if (file_size(file) < 0) {
      write("File " + fname + " is not on RCS.\n");
    } else {
      lockline = read_file(file, 4, 1);
      if (strsrch(lockline, "locks; strict:") == -1) {
        bits = explode(read_file(file, 5, 1), ":");
        if(bits[0][0] == '\t') {
          locker = bits[0][1..];
          write("File " + fname + " locked by " + locker + ".\n");
        }
        else write(fname + " is not locked.\n");
      }
    }
  }
  return 1;
}
// --- END [/mnt/home2/grok/lib/secure/cmds/creator/rcsloc_ks.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/login.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/login.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627435   Available: 13574789
Inodes: Total: 5242880    Free: 4960133
50966 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/login.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627435   Available: 13574789
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * The main login object.
 */

#include <data.h>
#include <login_handler.h>
#include <playerinfo.h>
#include <random_names.h>
#include <login.h>
#include <mail.h>
#include <access.h>
#include <playtesters.h>

//#define DEBUG

#define RL_NORMAL 4
#define RL_NONEW 3
#define RL_PT 2
#define RL_CRE 1

#define QUOTE_HANDLER "/obj/handlers/pqf_handler"
#define MULTIPLAYER "/obj/handlers/multiplayer"
#define LIVING "/obj/handlers/livings"
#define CLUB_HANDLER "/obj/handlers/club_handler"
#define BASTARDS "/secure/bastards"

#define FILE_PATH "/doc/login"
#define LOGIN_SCRIPT FILE_PATH + "/login_script.txt"

#define READ_INPUT 1
#define SLEEP 2

// Name length restrictions.
#define MIN_LEN 3
#define MAX_LEN 12

#define ADMIN_EMAIL "trustees@discworld.imaginary.com"
#define FREE_DOMAINS ({"hotmail.com", "yahoo.com"})
#define TIMEOUT_TIME 120
#define THROWOUT_TIME ( 2 * TIMEOUT_TIME )
#define MIN_RESET_TIME 86400

/**
 * This structure holds a single state. A state has a name,
 * an action or write and a set of events. <br>
 * The name is used to identify the state and must be unique within the
 * state table. An action is a function to call while a write is a
 * string or file to be written to the screen.  The events mapping
 * is made of event and new-state. The event is the trigger and
 * new-state is the new state the machine should enter.<p>
 *
 * An event is a string of the form "type-data" where type is either
 * "input" or "return" indicating user input or the return from an
 * action function. Thus "return-ok" would be triggered if the action
 * function in this state returned "ok" while "input-y" would be
 * triggered if the user typed in "y". The special event "input" will
 * trigger on any user input while the event "default" will trigger on
 * any input or return value.
 * 
 */
class state {
  string name;
  string action;
  string write;
  int noecho;
  mapping events;
}

private mapping _states; // This is the state machine.
private nosave string _state; 
private nosave string _last_state;
private nosave string _event;
private nosave string _last_event;
private nosave int _login_start_time;

private nosave int _counter; // A counter used for looping.
private nosave mapping _data; // Login data collected so far.
private nosave int _compiling; // Are we compiling the state machine?

nosave private int _run_level;

// Stuff for terminal type
private nosave string _terminal_name;
private nosave int _rows;
private nosave int _cols;

protected void finish_compiling(string, mapping);
protected void load_file();
void enter_state(string);
void dest_me();


/** @ignore yes */
void create() {
  seteuid("Root");
  _states = ([ ]);
  load_file();
  _data = ([ ]);

  // set the run level based on the mudname.
  _run_level = RL_NORMAL;
  
  
  if(interactive(this_object()))
     resolve(query_ip_number(this_object()), "");

  call_out("time_out", TIMEOUT_TIME);
}

#ifdef DEBUG
void debug_log(string fmt, mixed args ...) {
  log_file("/secure/NLOGIN",
           "%s: " + fmt + "\n", ctime(time())[4..18], args ...);
}
#else
void debug_log(string fmt, mixed args ...) { return; }
#endif

/** @ignore yes
 * This function reads either the saved data or causes the state machines
 * script to be re-parsed.
 */
void load_file() {
  if(_compiling) {
    debug_log("Already compiling, exiting.");
    return;
  }

  if(file_size(base_name(this_object()) + ".o") > -1 &&
     unguarded((: stat(base_name(this_object()) + ".o") :))[1] >=
     unguarded((: stat(LOGIN_SCRIPT) :))[1]) {
    debug_log("loading data.");
    unguarded((: restore_object, base_name(this_object()) :));
    if(!_states)
      _states = ([ ]);
    debug_log("data load complete.");
  } else {
    debug_log("Compiling script");
    debug_printf("Compiling script");
    _compiling = 1;
    DATA_HANDLER->compile_file(LOGIN_SCRIPT, (: finish_compiling :));
  }
}

/** @ignore yes
 * This function is called by the data compiler once it has finished
 * compiling the data into a mapping. This function builds the state
 * machine in _states.
 */
protected void finish_compiling(string fname, mapping data) {
  string name, s, e;
  mixed *bits;
  mapping thing, event;

  debug_printf("Finished compiling");
  
  foreach(name, bits in data) {
    switch(name) {
    case "state":
      foreach(thing in bits) {
        if(_states[thing["name"]])
          debug_log("Error, state %s already exists!", thing["name"]);
        
        _states[thing["name"]] = new(class state,
                                     action: thing["action"],
                                     write: thing["write"],
                                     noecho: thing["no-echo"],
                                     events: ([ ]));
        debug_log("State %s found", thing["name"]);
        if(!arrayp(thing["event"]))
          thing["event"] = ({ thing["event"] });
        
        foreach(event in thing["event"]) {
          if(mapp(event) && stringp(event["data"]) &&
             stringp(event["new-state"])) {
            _states[thing["name"]]->events[event["data"]] = event["new-state"];
            debug_log("Event %s new state %s", event["data"],
                   event["new-state"]);
          } else
            debug_log("Error event %O in state %s", event, thing["name"]);
        }
      }
      break;
    default:
      tell_creator("ceres", "Name: " + name + "\n");
    }
  }

  debug_log("Validating state machine.");
  foreach(s in keys(_states)) {
    if(_states[s]->action && !function_exists(_states[s]->action))
      debug_log("Action function %s doesn't exist", _states[s]->action);
    foreach(e in keys(_states[s]->events)) {
      if(!_states[s]->events[e])
        debug_log("New state %s doesn't exist in %s %s",
                  _states[s]->events[e], _states[s]->name, e);
    }
  }
  debug_log("Done. %d states created.", sizeof(keys(_states)));
  debug_log("Saving data.");
  _compiling = 0;
  unguarded((: save_object, base_name(this_object()) :));
}

/** @ignore yes
 * This function processes a received event. The event can come from an
 * input_to or be generated by the action function for this state.
 * The function the calls enter_state to enter the new state produced
 * by this event.
 */
void process_event(string event, string type) {
  if(type == "input" && _states[_state] && _states[_state]->noecho)
    debug_log("entering process event with state %s and event %s-<hidden>",
              _state, type);
  else
    debug_log("entering process event with state %s and event %s-%s", _state,
              type, event);

  _last_event = _event;
  _event = type + "-" + event;
  
  if(_states[_state]->events[type + "-" + lower_case(event)]) {
    enter_state((_states[_state])->events[type + "-" + lower_case(event)]);
  } else if(_states[_state]->events[type]) {
    enter_state((_states[_state])->events[type]);
  } else if(_states[_state]->events["default"]) {
    enter_state((_states[_state])->events["default"]);
  } else {    
    debug_log("no such event %s in state %s (%s)", type + "-" + 
              lower_case(event), _state,
              query_multiple_short(keys(_states[_state]->events)));
    return;
  }
}

/*
 * @ignore yes
 * This function is called when we enter a new state. It calls the action
 * function if there is one and then does an input_to() or just goes
 * straight on to the event processing function.
 */
void enter_state(string new_state) {
  mixed retval;
  string tmp, field;
  
  _last_state = _state;
  _state = new_state;

  debug_log("entering state %s", _state);

  if(new_state == "finished")
    return;
  
  if(!_states[_state]) {
    debug_log("invalid state %s exiting", _state);
    dest_me();
  }
  
  // Write out files or strings
  if(_states[_state]->write) {
    debug_log("writing %s", _states[_state]->write);
    if(file_size(_states[_state]->write) > 0)
      tmp = LOGIN_HANDLER->get_message(_states[_state]->write);
    else
      tmp = _states[_state]->write;

    // Enable use of $name in strings/files.
    foreach(field in keys(_data))
      if(stringp(_data[field]))
        tmp = replace_string(tmp, "$"+field, _data[field]);
    if(tmp[sizeof(tmp)-1] == '\n')
      tmp = tmp[0..<2];
    write(tmp);
    
  }
  
  // Call the action function.
  if(_states[_state]->action) {
    debug_log("calling %s", _states[_state]->action);
    retval = call_other(this_object(), _states[_state]->action, _event);
  } else
    retval = READ_INPUT;

  if(intp(retval) && retval == READ_INPUT) {
    debug_log("action %s returned read_input in state %s",
              _states[_state]->action, _state);
    input_to("process_event", _states[_state]->noecho, "input");
    return;
  }
  
  if(_states[_state]->action)
    debug_log("action %s returned %s in state %s",
              _states[_state]->action, (string)retval, _state);

  // This is a hack to jump straight from check-login-access to 
  // read-password. It's here because some clients don't do proper
  // login triggers but just blast name & password and a call_out
  // screws that up.
  if(_state == "check-login-access") {
    process_event(retval, "return");
    return;
  }
  call_out("process_event", 0, retval, "return");
}

/** @ignore yes */
string query_state() { return _state; }

/*************************************************************************
 * From here down it's the actual action functions.
 *************************************************************************/
/** @ignore yes */
private int check_valid_name(string str) {
  int i;

  for (i=0;i<strlen(str);i++) {
    if (str[i] < 'a' || str[i] > 'z') {
       return i;
    }
  }
  return -1;
}

/** @ignore yes */
private int check_name(string name, int new_char) {
  if(strlen(name) < MIN_LEN) {
    write("Sorry the player name " + name + " is too short (min " + MIN_LEN +
          " characters).\n");
    return 0;
  }

  if(strlen(name) > MAX_LEN) {
    write("Sorry the player name " + name + " is too long (max " +
          MAX_LEN + " characters).\n");
    return 0;
  }

  if(check_valid_name(name) != -1) {
    write("Invalid characters used in the name.  You can only use letter "
          "characters, from a to z, spaces and any other sort of "
          "punctuation may not be used.\n");
    return 0;
  }
  if(PLAYER_HANDLER->test_banished(name)) {
    write("\nSorry the player name " + name + " has been banished.\n");
    return 0;
  }

  if (!PLAYER_HANDLER->test_valid(name) || MAIL_TRACK->query_list(name)) {
    write("Sorry that name is not allowed.\n");
    return 0;
  }
  if(PLAYER_HANDLER->test_user(name) || LIVING->find_player(name)) {
    write("Sorry that name has already been taken.\n");
    return 0;
  }

  if(CLUB_HANDLER->is_club(name)) {
    write("Sorry that name is already in use for a club or family.\n");
    return 0;
  }

  return 1;
}

/** @ignore yes
 * Generate a random password. This is used when resetting a password or
 * when creating an authorised character.
 */
private string generate_password() {
  int i;
  string pass = "";
  
  for(i=0; i<8; i++)
    switch(random(3)) {
    case 2:
      pass += sprintf("%c", 65 + random(26));
      break;
    case 1:
      pass += sprintf("%c", 97 + random(26));
      break;
    default:
      pass += sprintf("%c", 48 + random(10));
    }
  // This strips out easily confused characters 0oO 1iI
  return replace(pass, ({ "0", "9", "o", "p", "O", "P",
                          "1", "2", "i", "j", "I", "J",
                          "l", "m" }));
}

/** @ignore yes
 * This displays the main menu. It also does some initial checks to make
 * sure that someone will have a chance of logging in.
 */
mixed main_menu(string event) {
  string mess;

  _data = ([ ]);
  _counter = 0;

  write(LOGIN_HANDLER->get_message(FILE_PATH+ "/BANNER"));

  if(LOGIN_HANDLER->site_lockeddown(query_ip_number(this_object()))) {
    write("Sorry, your site has been locked down for excessive failed login "
          "attempts.  If you have forgotten your password please email "+
          ADMIN_EMAIL + ".  If you have not failed to login "
          "please try again later.\n");
    mess = sprintf("attempted login from locked down site: %s.",
                   query_ip_number(this_object()));
    log_file("BAD_PASSWORD", ctime(time())[4..18] + ": " + mess + "\n");
    event(efun::users(), "inform", mess, "bad-password");
    return "quit";
  }

  if(find_object("/obj/shut")) {
    if(find_object("/obj/shut")->query_time_to_crash() < 60) {
      write("With less than one minute to go it is too close to the "
            "shut-down to attempt to log in, please try again in a "
            "few minutes.\n");
      return "quit";
    }
    write("It is too close to the shut-down to attempt to log "
          "in unless you are a creator or net-dead.  Please try again "
          "in a few minutes.\n");
  }
  write(LOGIN_HANDLER->get_message(FILE_PATH+ "/MAIN_MENU"));
  return READ_INPUT;
}

/** @ignore yes
 * Check that the person trying to delete themselves exists and isn't
 * already marked for deletion
 */
mixed check_delete_name(string event) {
  _data["name"] = lower_case(replace_string(event, "input-", ""));

  if(!PLAYER_HANDLER->test_user(_data["name"])) {
    write("There is no such player.\n\nPress enter to continue ");
    return READ_INPUT;
  }

  if(PLAYER_HANDLER->test_creator(_data["name"])) {
    write("Creators cannot be deleted this way.\n\n"
          "Press enter to continue ");
    return READ_INPUT;
  }

  if(file_size(PLAYER_HANDLER->query_delete_player_file_name(_data["name"]) +
               ".o") > 0 ||
     file_size(PLAYER_HANDLER->query_delete_player_file_name(_data["name"]) +
               ".o.gz") > 0) {
    write("That character is already marked for deletion.\n\n"
          "Press enter to continue ");
    return READ_INPUT;
  }

  return "ok";
}

/** @ignore yes
 * Verify the password of someone wanting to delete themselves.
 */
mixed check_delete_password(string event) {
  _data["password"] = replace_string(event, "input-", "");

  if(!PLAYER_HANDLER->test_password(_data["name"], _data["password"])) {
    write("\nPassword incorrect.\n");
    return "invalid";
  }
  write("This is will PERMANENTLY delete your character, are you sure? "
        "[y/n] "); 
  return READ_INPUT;
}

/** @ignore yes
 * Mark a character for deletion
 */
mixed delete_character(string event) {
  string extension;
  
  if(PLAYER_HANDLER->test_creator(_data["name"])) {
    write("Creators cannot be deleted this way.\n\n"
          "Press enter to continue ");
    return READ_INPUT;
  }

  if(unguarded((: file_size,
                PLAYER_HANDLER->query_player_file_name(_data["name"]) + ".o"
                :)) != -1) {
    extension = ".o";
  } else {
    extension = ".o.gz";
  }

  if(unguarded((: cp, PLAYER_HANDLER->query_player_file_name(_data["name"]) +
                extension,
                PLAYER_HANDLER->query_delete_player_file_name(_data["name"]) +
                extension :))){
    unguarded((: rm, PLAYER_HANDLER->query_player_file_name(_data["name"]) +
               extension :));
    unguarded((: rm,
               PLAYER_HANDLER->query_player_disk_file_name(_data["name"]) +
               extension :));
    write("\n\nPLEASE READ:\nCharacter deleted.  You have 10 days "
          "cooling off time, during "
          "which you may reinstate your character.  To reinstate it "
          "simply log on again and it will reinstate it for you.\n\n");
  } else {
    write("WARNING! Unable to delete your character.\n\n");
  }
  write("Press enter to continue ");
  return READ_INPUT;
}

/** @ignore yes
 * Check if new players are allowed from this site. It also checks the
 * time to shutdown. The function returns "ok", "auth" or READ_INPUT. 
 */
mixed check_new_access(string event) {
  mixed *tmp;
  
  _data["new_player"] = 1;

  if(_run_level != RL_NORMAL) {
    write("Sorry this site is not open to new players.\n\n"
          "Press enter to continue ");
    return READ_INPUT;
  }

  if(find_object("/obj/shut")) {
    write("It is too close to the shut-down to attempt to create a new "
          "character.  Please try again in a few minutes.\n\n"
          "Press enter to continue ");
    return READ_INPUT;
  }
  
  switch(BASTARDS->query_access(this_object())) {
  case NO_NEW:
  case NO_ACCESS:
    write("\nNew player logins are disabled from this site.  If you wish "
          "to create a character, please email " + ADMIN_EMAIL + 
          " with the player name you "
          "would like to use, the name(s) of your other characters and "
          "the name of your ISP.  Note that requests from free email "
          "accounts (hotmail, yahoo etc.) may not be acceptable.\n\n"
          "Press enter to continue ");
    return READ_INPUT;
  case AUTH_NEW:
    write("\nNew player logins from this site are disabled.  In order to "
          "create a new character you will be asked for a character "
          "name and an email address, a password will then be emailed "
          "to you at that address.  Note that the address must not "
          "include free accounts (hotmail, yahoo etc.)\n\n");
    return "auth";
  }

  if(!BASTARDS->query_multi(this_object())) {
    tmp = filter(users(), 
                 (: interactive($1) &&
                  !$1->query_creator() &&
                  !$1->query_property("test character") &&
                  !strcmp(query_ip_number($1), $2) :), 
                 query_ip_number(this_object())) - ({ this_object() });
    if(sizeof(MULTIPLAYER->check_allowed(this_object(), tmp))) {
      write(LOGIN_HANDLER->get_message(FILE_PATH+ "/MULTIPLAYERS") +
            "\n\n"
            "Press enter to continue ");
      return READ_INPUT;
    }
  }
  
  return "ok";

  // Must not be nonew, or noaccess. Must be unique IP unless site is marked
  // for MP.
}

/** @ignore yes
 * Check if guests are allowed to login from this site.
 */
mixed check_guest_access(string event) {
  _data["guest"] = 1;
  _data["new_player"] = 1;

  if(_run_level != RL_NORMAL) {
    write("Sorry this site is not open to guests.\n\n"
          "Press enter to continue ");
    return READ_INPUT;
  }

  if(find_object("/obj/shut")) {
    write("It is too close to the shut-down to attempt to create a new "
          "character.  Please try again in a few minutes.\n\n"
          "Press enter to continue ");
    return READ_INPUT;
  }

  if(BASTARDS->query_access(this_object()) != DEFAULT) {
    write("\nGuest logins are disabled from this site.\n\n"
          "Press enter to continue ");
    return READ_INPUT;
  }

  return "ok";
}

/** @ignore yes
 * Show the finger information for a specific user.
 */
mixed finger_player(string event) {
  string finger_info;
  string player;
  player = replace_string(event, "input-", "");
  if(player)
    player = lower_case(player);

  if (stringp(player) && strlen(player) > 2 && check_valid_name(player)) {
    finger_info = "/secure/finger"->finger_info(player, 1);
    if (!finger_info) {
      write("I am sorry, there is no such player.\n\n");
    } else {
      write(strip_colours(finger_info) + "\n\n");
    }
  } else {
    write("Invalid name, returning to the login menu.\n\n");
  }
  write("Press enter to continue ");
  return READ_INPUT;
}

/** @ignore yes
 * Provide the who is online list.
 */
mixed list_players(string event) {
  write("Here is a list of the people currently playing Discworld:\n" +
        implode(sort_array(map(filter(users(), (: $1->query_cap_name() &&
                                                !$1->query_invis() &&
                                                $1->query_name() != "logon":)),
                               (: $1->query_cap_name() :)),
                           (: strcmp :)), ", ") + "\n");
  write( "\nPress enter to continue ");
  return READ_INPUT;
}

/** @ignore yes
 * This resets the counter for such things as password retries.
 */
mixed reset_counter(string event) {
  _counter = 0;
  return READ_INPUT;
}

/** @ignore yes
 * Check if an email address is valid and not in our disallowed list.
 */
mixed check_email(string event) {
  string name, domain, address;

  address = replace_string(event, "input-", "");
  if(!regexp(address,
           "^[a-zA-Z0-9\\+\\.\\_\\-]+@[a-zA-Z0-9\\_\\-].[a-zA-Z0-9\\_\\-]")){
    write("Sorry, that address is invalid.  Please try again or "
          "enter 'q' to quit.\n");
    return "invalid";
  }
  
  sscanf(address, "%s@%s", name, domain);
  if(member_array(domain, FREE_DOMAINS) != -1) {
    write("Sorry, that is a free account and not allowed.  Please try "
          "again or enter 'q' to quit.  If you do not have a non-free "
          "address email " + ADMIN_EMAIL + " for a new character.\n");
    return "invalid";
  }

  _data["email"] = address;
  return "ok";
}

/** @ignore yes
 * This function validates a new character name. It checks that it's OK
 * for a new character.
 */
mixed check_new_name(string event) {
  _data["name"] = lower_case(replace_string(event, "input-", ""));

  if(!_data["name"] || _data["name"] == "" || _data["name"] == "q")
    return "failed";

  _counter++;
  if(check_name(_data["name"], 1)) {
    _data["cap_name"] = capitalize(_data["name"]);
    return "ok";
  } else if(_counter < 3) {
    return "invalid";
  } else {
    return "failed";
  }
}

/** @ignore yes
 * This validates random names. Returns "ok" or "invalid".
 */
mixed check_random_name(string event) {
  string tmp;
  
  if(!event || event == "")
    return "invalid";
  
  tmp = replace_string(event, "input-", "");
  
  if((tmp[0] - '1') < 0 || (tmp[0] - '1') >= sizeof(_data["random_names"]))
    return "invalid";
  
  _data["name"] = lower_case(_data["random_names"][tmp[0] - '1']);

  if(check_name(_data["name"], 1)) {
    return "ok";
  } else 
    return "invalid";
}

mixed main_random_name_menu(string event) {
  string *langs;
  int i;

  i = 1;
  langs = RANDOM_NAME_GENERATOR->query_languages();
  for (i=0;i<sizeof(langs);i++)
    langs[i] = sprintf("%c - %s (eg. %s)", (i+'1'), capitalize(langs[i]),
                       RANDOM_NAME_GENERATOR->unique_name(langs[i]));

  write("You are choosing a name for the first time on Discworld.\n"
        "You can choose a name which is generated to sound something "
        "like:\n"+
        implode(langs, "\n") +
        "\nM - Main Menu\n"
        "Q - Quit\n\n"
        "Your choice? ");
  return READ_INPUT;
}

/** @ignore yes
 * This function is called to choose a language type for the random name
 * generator.
 */
mixed random_lang_choice(string event) {
  string choice;
  int len;
  
  choice = replace_string(event, "input-", "");
  len = sizeof(RANDOM_NAME_GENERATOR->query_languages());
  
  if(strlen(choice) == 1 && choice[0] >= '1' && choice[0] <= ('1'+len-1))
    return RANDOM_NAME_GENERATOR->query_languages()[choice[0]-'1'];

  write("Incorrect choice.\n");
  return "invalid";
}

/** @ignore yes
 * List a selection of random names in the chosen language type.
 */
mixed show_random_names(string event) {
  int i;
  string lang;

  lang = replace_string(event, "return-", "");
  write("Here is a list of 9 random names.  Please choose one:\n");
  _data["random_names"] = allocate(9);
  for (i=0; i<sizeof(_data["random_names"]); i++) {
    _data["random_names"][i] = RANDOM_NAME_GENERATOR->unique_name(lang);
    write(sprintf("%c - %s\n", i+'1', _data["random_names"][i]));
  }
  write("M - Main Menu\n"
        "N - Name Menu\n"
        "G - Generate a new set of names\n"
        "Q - Quit\n"
        "Or, type in your name of choice\n\n"
        "Your choice? ");

  return READ_INPUT;
}

/** @ignore yes
 * Do some simple checks on a new players password. Would be nice to have
 * more sophisticated checks here!
 */
mixed check_new_password(string event) {
  
  _data["password"] = replace_string(event, "input-", "");
  write("\n");
  
  if(!_data["password"] || _data["password"] == "")
    return "failed";

  if(strlen(_data["password"]) < 6) {
    write("Password is too short, must be at least 6 characters.\n");
    return "invalid";
  }

  if(_data["password"] == _data["name"]) {
    write("Password is the same as your name, please try again.\n");
    return "invalid";
  }

  return "ok";
}

/** @ignore
 * Check that the password is the same when re-entered.
 */
mixed verify_password(string event) {
  string tmp;

  write("\n");

  tmp = replace_string(event, "input-", "");

  if(tmp == _data["password"])
    return "ok";
  else {
    write("Passwords do not match.\n");
    return "invalid";
  }
}

/** @ignore yes
 * Offer a capitalization option for their name.
 */
mixed get_capitalization(string event) {
  if(!_data["cap_name"])
    _data["cap_name"] = capitalize(_data["name"]);
  
  write("\nHow would you like your name capitalised? [" +
        _data["cap_name"] + "] ");
  return READ_INPUT;
}

/** @ignore yes
 * Check that their chosen capitalization matches their character name.
 */
mixed check_capitalization(string event) {
  string tmp;
  
  tmp = replace_string(event, "input-", "");
  
  if(!tmp || tmp == "")
    return "ok";

  if(lower_case(tmp) != _data["name"]) {
    write("Sorry it has to be the same as your name.");
    return "invalid";
  }

  _data["cap_name"] = tmp;
  return "ok";
}

/** @ignore yes
 * Generate a temporary password for a user and mail it to them.
 */
mixed request_password(string event) {
  string name, email, pass, mess;
  mixed tmp;
  
  name = replace_string(event, "input-", "");
  if(name)
    name = lower_case(name);
  
  if(!PLAYER_HANDLER->test_user(name)) {
    write("There is no such player.\n\nPress enter to continue ");
    return READ_INPUT;
  }

  if(PLAYER_HANDLER->test_creator(name)) {
    write("Creator passwords cannot be reset this way mail " + 
          ADMIN_EMAIL + ".\n\nPress enter to continue ");
    return READ_INPUT;
  }

  if(!PLAYER_HANDLER->test_ip_allowed(name, query_ip_number(this_object()))) {
    write("Sorry that characters password cannot be reset from your IP "
          "address.\n\n"
          "Press enter to continue ");
    return READ_INPUT;
  }
  
  email = PLAYER_HANDLER->test_email(name);
  if(sizeof(email) > 0 && email[0] == ':')
    email = email[1..];
  
  while(email != "" && sizeof(email) && email[0] == ' ')
    email = email[1..];
  
  if(!email || email == "" ||
     !regexp(email, "^[A-z0-9_+\\.]+@[A-z0-9_+]+\\.[A-z0-9_+\\.]+$")) {
    write("Sorry, that player does not have a valid email address set.\n\n"
          "Press enter to continue ");
    return READ_INPUT;
  }

  tmp = BASTARDS->query_temp_password(name);
  if(tmp && tmp[0] > time() - MIN_RESET_TIME) {
    write("Sorry that character has had a temporary passwords set "
          "within the last " + number_as_string(MIN_RESET_TIME / 3600) +
          " hours, please try again later.\n\n"
          "Press enter to continue ");
    return READ_INPUT;
  }

  pass = generate_password();
  BASTARDS->set_temp_password(name, crypt(pass, 0));
  
  MAILER->do_mail_message(email, "admin", "Your temporary password", 0,
                          "The temporary password for " + name + " is " + 
                          pass + "\n\nYou must use this password within "
                          "the next 7 days.  This is a one use\npassword.  "
                          "After using it to login you should immediately "
                          "use the\n'password' command to set a new "
                          "password.\n\n");
  mess = sprintf("password requested for %s by user at site  %s.", name, 
                  query_ip_number(this_object()));

  log_file("BAD_PASSWORD", ctime(time())[4..18] + ": " + mess + "\n");
  event(efun::users(), "inform", mess, "bad-password");

  write("An email is on its way to you " +
        "with a temporary password for this character.\n\n"
        "Press enter to continue ");
  return READ_INPUT;
}

/** @ignore yes
 *
 * This function checks to see if the user is allowed to login at this
 * time. It returns "ok" if they can or READ_INPUT if they cannot.
 */
mixed check_login_access(string event) {
  mixed *tmp;
  string *alts;
  
  if(event && strsrch(event, "input-") != -1)
    _data["name"] = lower_case(replace_string(event, "input-", ""));

  // Deal with cres using -<name> to go vis, :<name> to be go invis or
  // #<name> to be invis 2.
  if(_data["name"][0] == '-') {
    _data["name"] = _data["name"][1..];
    _data["go_invis"] = -1;
  } else if(_data["name"][0] == ':') {
    _data["name"] = _data["name"][1..];
    _data["go_invis"] = 1;
  } else if(_data["name"][0] == '#') {
    _data["name"] = _data["name"][1..];
    _data["go_invis"] = 2;
  }
  
  // Check which run level we're at and allow logins accordingly.
  switch(_run_level) {
  case RL_CRE:
    if(!PLAYER_HANDLER->test_creator(_data["name"]) &&
       !PLAYER_HANDLER->test_property(_data["name"], "test character")) {
      write("Sorry this site is only open to creators.\n\n"
            "Press enter to continue ");
      return READ_INPUT;
    }
    break;
  case RL_PT:
    if(!PLAYER_HANDLER->test_creator(_data["name"]) &&
       !PLAYER_HANDLER->test_property(_data["name"], "test character") &&
       !PLAYTESTER_HAND->query_playtester(_data["name"])) {
    write("Sorry this site is only open to creators and playtesters.\n\n"
          "Press enter to continue ");
    return READ_INPUT;
    }
    break;
  default:
    break;
  }

  // Check how close we are to a shutdown. Allow creators & reconnects
  // during a reboot.
  if(find_object("/obj/shut") &&
     !PLAYER_HANDLER->test_creator(_data["name"]) &&
     !LIVING->find_player(_data["name"])) {
    write("It is too close to the shut-down to attempt to login.  "
          "Please try again in a few minutes.\n\n"
          "Press enter to continue ");
    return READ_INPUT;
  }

  // This is probably unnecessary, but not player, no login.
  if(!PLAYER_HANDLER->test_user(_data["name"])) {
    write("There is no player by that name.\n\n"
          "Press enter to continue ");
    return READ_INPUT;
  }

  // Check IP allow/deny lists.
  if(!PLAYER_HANDLER->test_ip_allowed(_data["name"],
                                      query_ip_number(this_object()))) {
    write("Sorry that character's access control list does not permit "
          "login from your IP address.\n\n"
          "Press enter to continue ");
    return READ_INPUT;
  }

  // Are they awaiting deletion?
  if(PLAYER_HANDLER->test_appealing(_data["name"])) {
    write("Sorry that character has been marked for deletion pending "
          "appeal.  If you wish to appeal please contact the trustees at "
          ADMIN_EMAIL + ".\n\n"
          "Press enter to continue ");
    return READ_INPUT;
  }

  // The tests below don't apply to creators to creator test chars.
  if(PLAYER_HANDLER->test_creator(_data["name"]) ||
     PLAYER_HANDLER->test_property(_data["name"], "test character"))
    return "ok";


  // Player lockouts.
  tmp = BASTARDS->query_lockedout(_data["name"]);
  if(tmp) {
    write("Sorry that character has chosen to be locked out until\n" +
          ctime(tmp[SUSPEND_TIME]) + " for " + tmp[SUSPEND_REASON] + ".\n\n"
          "Press enter to continue ");
    return READ_INPUT;
  }

  // No alts permitted regardless of which site they're connecting from.
  if(PLAYERINFO_HANDLER->query_alt_of(_data["name"]))
    alts = PLAYERINFO_HANDLER->query_alts(PLAYERINFO_HANDLER->
                                          query_alt_of(_data["name"])) +
      ({ PLAYERINFO_HANDLER->query_alt_of(_data["name"]) });
  else
    alts = PLAYERINFO_HANDLER->query_alts(_data["name"]);
  if(sizeof(alts))
    alts -= ({ _data["name"] });
  if(sizeof(alts)) {
    tmp = filter(alts, (: LIVING->find_player($1) :));
    if(sizeof(tmp)) {
      write("Sorry, you cannot login while one of your alts is logged in.\n"
            "Press enter to continue ");
      return READ_INPUT;
    }
  }
  
  if(tmp = BASTARDS->query_suspended(_data["name"])) {
    write("You are suspended until " + ctime(tmp[SUSPEND_TIME]) +
          ", enter your password to see why.\n");
  }

  // Authorised? Then allow them in.
  if(PLAYER_HANDLER->test_property(_data["name"], "authorised player"))
    return "ok";

  // Check site (IP/DNS) access.
  switch(BASTARDS->query_access(this_object())) {
  case NO_ACCESS:
    write("Player logins are disabled from this site.  Please contact "
          "a creator to have your character authorised to login.\n\n"
          "Press enter to continue ");
    return READ_INPUT;
    break;
  case NO_NEW:
  case AUTH_NEW:
    if(PLAYER_HANDLER->test_age(_data["name"]) > -(2 * 24 * 60 * 60)) {
      write("\nNew player logins are disabled from this site and your character "
            "is too young.  Please contact a creator to have your character "
            " authorised to login.\n\n"
            "Press enter to continue ");
      return READ_INPUT;
    }
    break;
  case ERROR:
    write("Sorry your site has invalid access permissions set.  Please "
          "contact a creator to have this corrected.\n\n"
            "Press enter to continue ");
    return READ_INPUT;
  default:
  }

  // Check multiplayer access.
  if(!BASTARDS->query_multi(this_object())) {
    tmp = filter(users(), 
                 (: interactive($1) &&
                  !$1->query_creator() &&
                  !$1->query_property("test character") &&
                  $1->query_name() != "logon" &&
                  $1->query_name() != $3 &&
                  !strcmp(query_ip_number($1), $2)
                  :), 
                 query_ip_number(this_object()), _data["name"]) -
      ({ this_object() });
    
    if(sizeof(MULTIPLAYER->check_allowed(this_object(), tmp))) {
      write("Sorry, someone else is already logged in from the same computer\n"
            "address as you and your site is not authorised for multiple "
            "players.\n\n"
            "Press enter to continue ");
      return READ_INPUT;
    }
  }
 
  return "ok";
}

/** @ignore yes
 * Verify that the password entered is correct for this user.
 */
mixed check_password(string event) {
  string mess;
  mixed *tmp;
  
  _data["password"] = replace_string(event, "input-", "");
  _counter++;
  
  if(_data["password"] == "")
    return "failed";

  // Check their password
  if(!PLAYER_HANDLER->test_password(_data["name"], _data["password"])) {

    // Check their temporary password (if they have one).
    tmp = BASTARDS->query_temp_password(_data["name"]);
    if(!tmp || crypt(_data["password"], tmp[1]) != tmp[1]) {
      if(_counter < 3) {
        write("\nPassword incorrect.\n");
        return "invalid";
      }
      
      // record a failed login from this IP.
      LOGIN_HANDLER->failed_login(query_ip_number(this_object()));
      write("\nToo many retries.\n\nPress enter to continue ");
      mess = capitalize(_data["name"]) + " failed to login, " +
        (query_ip_name(this_object()) != query_ip_number(this_object())
         ? query_ip_name(this_object()) + " (" +
         query_ip_number(this_object()) + ")"
         : query_ip_number(this_object()));
      event(users(), "inform", mess, "bad-password");
      log_file("BAD_PASSWORD", ctime(time())[4..18] + ": " + mess + "\n");
      return READ_INPUT;
    }
    "/cmds/lord/resetpw"->do_reset(_data["name"], _data["password"]);
    write("\n\nYour temporary password has now been used!  It is essential "
          "that you use the password command to set a new password.\n\n");
  }
  
  BASTARDS->clear_temp_password(_data["name"]);

  // Are they suspended?
  if(tmp = BASTARDS->query_suspended(_data["name"])) {
    write("\nSorry, you are suspended until " + 
          ctime(tmp[SUSPEND_TIME]) + " for " +
          tmp[SUSPEND_REASON] + ".\n\nPress enter to continue ");
    return READ_INPUT;
  }

  _data["password-check"] = "ok";

  // This is a character that has been pre-authorised and so doesn't
  // yet have a gender so send them off to receive one.
  if(!PLAYER_HANDLER->test_gender(_data["name"]) &&
     PLAYER_HANDLER->test_property(_data["name"], "new player"))
    return "new";
  
  // Ok now we have to actually log them in!
  return "ok";
}

/** @ignore yes
 * Check & set the gender for a new char
 */
mixed set_gender(string event) {
  string tmp;
  tmp = lower_case(replace_string(event, "input-", ""));

  if (tmp == "m") {
    tmp = "male";
  }
  if (tmp == "f") {
    tmp = "female";
  }

  if(tmp == "male" || tmp == "female") {
    _data["gender"] = tmp;
    return "ok";
  }
  write("That's too weird even for this game!\nTry male or female ");
  return "invalid";
}

/** @ignore yes
 * Check if someone is reconnecting when netdead.
 */
mixed check_reconnecting(string event) {
  if(_data["password-check"] != "ok") {
    write("Error\n");
    dest_me();
  }
  if(LIVING->find_player(_data["name"])) {
    write("You are already playing.\n"+
          "Throw the other copy out? (y/n/restart) ");
    return READ_INPUT;
  }
  return "no";
}

/** @ignore yes
 * Perform a restart for people reconnecting.
 */
mixed restart(string event) {
  object pl;
  
  pl = LIVING->find_player(_data["name"]);
  if(!pl) {
    write("Your other copy has been eaten.  Logging in normally.\n");
    return "ok";
  }

  tell_object(pl, "Disconnected by someone from " +
              query_ip_name(this_object()) + ".\n");
  if(catch(pl->quit()) && catch(pl->dest_me()))
    destruct(pl);
  if(objectp(pl))
    pl->dest_me();
  return "ok";
}

/** @ignore yes
 * Perform a reconnect for people reconnecting.
 */
mixed reconnect(string event) {
  object pl, ob;

  pl = LIVING->find_player(_data["name"]);
  if(!pl) {
    write("Your other copy has been eaten.  Logging in normally.\n");
    return "login";
  }

  if(interactive(pl)) {
    tell_object(pl, "Disconnected by someone from " +
                query_ip_name(this_object()) + ".\n");
    ob = clone_object("/std/object");
    exec(ob, pl);
    ob->dest_me();
  }
  exec(pl, this_object());
  pl->look_me();

  LOGIN_HANDLER->player_reconnected(pl->query_name());
  
  tell_room(environment(pl), pl->query_cap_name()+
            " has reconnected.\n", ({ pl }) );

  if (function_exists("inform_reconnect_game", pl))
    pl->inform_reconnect_game();

  if(query_ip_number(pl) == query_ip_name(pl))
     resolve(query_ip_number(pl), "");

  return "ok";
}

/** @ignore yes
 * Check if we're full.
 */
mixed check_full(string event) {
  int ret;

  //  if(_data["name"] == "ctest")
  //return "full";
  
  if(PLAYER_HANDLER->test_creator(_data["name"]) ||
     PLAYER_HANDLER->test_property(_data["name"], "test character"))
    return "ok";
  
  ret = LOGIN_HANDLER->int_is_discworld_full(WITHOUT_LOGINS_NOT_IN_QUEUE);
  if((ret & UNCOMPRESSED_FULL) && 
     ((ret & COMPRESSED_FULL) || !compressedp(this_object()))) {
    write("Sorry, there are no player slots available.\n\n");
    return "full";
  }

  return "ok";
}

/** @ignore yes
 * Add this person to the login queue.
 */
mixed add_to_queue(string event) {
  object *obs, pl, ob;
  
  if(member_array(_data["name"], map(LOGIN_HANDLER->query_login_queue(),
                                     (: $1->query_name() :) )) != -1 ) {
    write("You are already in the login queue.\n");
    obs = filter(LOGIN_HANDLER->query_login_queue(),
                 (: $1->query_name() == $2 :), _data["name"]);
    
    pl = obs[0];
    if (pl && pl->query_login_ob()) {
      write("Reconnecting you to the login queue.\n");
      
      if (interactive(pl)) {
        tell_object(pl, "Disconnected by someone from " +
                    query_ip_name(this_object()) + ".\n");
        ob = clone_object("/std/object");
        exec(ob, pl);
        ob->dest_me();
      }
      ob = this_object();
      exec(pl, ob);
      return "ok";
    }
  }

  LOGIN_HANDLER->add_to_login_queue(this_object());
  pl = LIVING->find_player(_data["name"]);
  if(pl) {
    /*
     * Hack!  Hack!  Warning!  No idea why reconnection to net
     * deads is not working.  So force them to quit instead.
     */
    //pl->quit();
    write("You were net dead when you left, shuffling you to the "
          "start of the queue...\n");
  } else {
    write("Placing you in the login queue: you have position "+
          sizeof(LOGIN_HANDLER->query_login_queue()) + 
          ".\nPlease wait.  Type \"quit\" to escape.\n" );
  }
  remove_call_out("time_out");
  call_out("check_status", 15);
  return "ok";
}

/** @ignore yes
 * Show the Terms and Conditions and setup the callout waiting for them
 * to agree.
 */
mixed display_terms(string event) {
  write(LOGIN_HANDLER->get_message(FILE_PATH+ "/TERMS"));
  call_out("terms_delayed", 30);
  return "ok";
}

/** @ignore yes
 * Ask the player to agree to the terms.
 */
void terms_delayed() {
  _counter = 0;
  write("\nEnter 'yes' if you agree to the terms or 'no' if you cannot.\n"
        "By typing 'yes' you signify that you have read, understand and "
        "agree to by bound by these terms and conditions: [yes/no] ");
  enter_state("agree-terms");
}

/** @ignore yes
 * See if they accept the terms or not.
 */
mixed check_terms(string event) {
  if(event == "input-yes")
    return "yes";
  if(event == "input-no" || _counter++ > 3)
    return "no";
  return "error";
}

/** @ignore yes
 * Send a password to a new player connecting from a site that only
 * allows authenticated logins.
 */
mixed new_player_auth(string event) {
  object pl;
  string pass;
  
  if(catch(pl = clone_object(BASTARDS->query_player_ob(_data["name"])))) {
    write("Oh no, someone has broken the player object!  "+
            "Come back later.\n\n"
          "Press enter to continue ");
    return READ_INPUT;
  }
  
  if(!pl) {
    write("Something bad happened.\n\n"
          "Press enter to continue ");
    return READ_INPUT;
  }

  pl->set_name(_data["name"]);
  pass = generate_password(); 
  pl->set_password(crypt(pass, 0));
  pl->set_email(_data["email"]);
  pl->add_property("authorised player", 1);
  pl->add_property("new player", 1);
  pl->add_property("authorised email", _data["email"]);
  pl->allow_save();
  pl->save_me();
  pl->dest_me();
  MAILER->do_mail_message(_data["email"], "admin", "Your password", 0,
                          "The password for " + _data["name"] + " is " + 
                          pass + "\n\n");
  write("An email is on its way to you with a password for this "
        "character.\n\n"
        "Press enter to continue ");
  return READ_INPUT;
}

/** @ignore yes
 * This actually logs the new player in. It uses exec() to pass control
 * from this object to the newly cloned player object.
 */
mixed new_player_login(string event) {
  object pl, tp;

  if(catch(pl = clone_object(BASTARDS->query_player_ob(_data["name"])))) {
    write("Oh no, someone has broken the player object!  "+
            "Come back later.\n" );
    return "error";
  }

  if(!pl) {
    write("Something bad happened.\n");
    return "error";
  }

  // Have to copy these across if they've been authorised already.
  if(PLAYER_HANDLER->test_property(_data["name"], "authorised player")) {
    pl->add_property("authorised player", 1);
    pl->add_property("authorised email",
                     PLAYER_HANDLER->test_property(_data["name"],
                                                   "authorised email"));
    pl->set_email(PLAYER_HANDLER->test_property(_data["name"],
                                                "authorised email"));
  }

  pl->set_name(_data["name"]);
  if(_data["password"])
    pl->set_password(crypt(_data["password"], 0));

  if(_data["guest"]) {
    pl->add_property("guest", 1);
    pl->set_title("guest of Discworld");
  }
  pl->set_gender(_data["gender"]);
  pl->set_language("general");
  pl->set_default_language("general");

  tp = this_object();
  if(!exec(pl, tp)) {
    write("Oh dear, something went wrong.\n");
    return "error";
  }
  
  if(tp != this_object())
    tp->quit();

  write("\n");
  pl->move_player_to_start(_data["name"], !_data["guest"], _data["cap_name"],
                           "", _data["go_invis"]);

  if(query_ip_number(pl) == query_ip_name(pl))
    resolve(query_ip_number(pl), "");

  return "ok";
}

/** @ignore yes
 * This actually logs the player in. It uses exec() to pass control from this
 * object to the newly cloned player object.
 */
mixed player_login(string event) {
  object pl, tp;
  string cap_name;
  
  if(!interactive(this_object())) {
    debug_log("This ob not interactive. %s %s %s %s", _state, _last_state, 
              _event, _last_event);
    dest_me();
  }
  cap_name = PLAYER_HANDLER->query_cap_name(_data["name"]);

  if(file_size(PLAYER_HANDLER->query_delete_player_file_name(_data["name"]) +
               ".o") > 0 &&
     unguarded((: rename,
                PLAYER_HANDLER->query_delete_player_file_name(_data["name"]) +
                ".o",
                PLAYER_HANDLER->query_player_file_name(_data["name"]) +
                ".o" :)))
    write("Removing player from delete queue.\n");
  else if(file_size(PLAYER_HANDLER->
                    query_delete_player_file_name(_data["name"]) + ".o.gz") > 0
          &&
          unguarded((: rename,
                     PLAYER_HANDLER->query_delete_player_file_name(_data["name"]) +
                     ".o.gz",
                    PLAYER_HANDLER->query_player_file_name(_data["name"]) +
                     ".o.gz" :)))
    write("Removing player from delete queue.\n");
  
  if(catch(pl = clone_object(BASTARDS->query_player_ob(_data["name"])))) {
    write("Oh no, someone has broken the player object!  "+
            "Come back later.\n" );
    return "error";
  }

  if(!pl) {
    write("Something bad happened.\n");
    return "error";
  }

  tp = this_object();
  if(!exec(pl, tp)) {
    write("Oh dear, something went wrong.\n");
    return "error";
  }
  
  if(tp != this_object())
    tp->quit();

  write("\n");
  pl->move_player_to_start(_data["name"], 0, cap_name, 0, _data["go_invis"]);
  if(_terminal_name)
    pl->terminal_type(_terminal_name);

  if(_cols && _rows)
    pl->window_size(_cols, _rows);

  if(query_ip_number(pl) == query_ip_name(pl))
     resolve(query_ip_number(pl), "");

  return "ok";
}

/** @ignore yes */
mixed exit_queue(string event) {
  call_out("time_out", TIMEOUT_TIME);
  if(LIVING->find_player(_data["name"]))
    return "reconnect";
  else
    return "login";
}

/** @ignore yes
 * This is called by the login handler to remove the person from the queue.
 */
void remove_from_login_queue() {
  LOGIN_HANDLER->remove_from_login_queue(this_object());
  tell_object(this_object(), "\n\nYou have exited the login queue!\n\n"
              "Please press enter to continue ");

  enter_state("leaving-queue");
}


mixed quit(string event) {
  write("Come back soon!\n");
  dest_me();
}

/** @ignore yes */
mixed time_out() {
  if(!interactive(this_object()))
    return dest_me();
  
  /* time them out if they are not in the queue and either idle or
   * not idle but have been sitting around too long
   */
  if((query_idle(this_object()) > TIMEOUT_TIME ||
      (time() > _login_start_time + THROWOUT_TIME)) &&
     member_array(this_object(), LOGIN_HANDLER->query_login_queue()) == -1) {
    write("\nTime out.\n\n");
    return dest_me();
  }

  call_out( "time_out", TIMEOUT_TIME);
  return;
}

/** @ignore yes */
void check_status() {
  int pos;

  if(_data["ok_to_login"])
    return;
  
  pos = member_array(this_object(), LOGIN_HANDLER->query_login_queue())+1;
  if(!pos) {
    /* Oh dear, we got deleted...  Put ourselves back in */
    LOGIN_HANDLER->add_to_login_queue(this_object());
    pos = member_array(this_object(), LOGIN_HANDLER->query_login_queue())+1;
  }

  if(pos && pos != _data["login_pos"])
    write("You now have position " + pos + " in the queue.\n");

  _data["login_pos"] = pos;
  write(sprintf("%-=*s\n", 79,
                  implode(QUOTE_HANDLER->query_random_quote(), "\n")));
  call_out("check_status", 30);
}

/** @ignore yes */
int do_su(string str) {
  object ob, tp;

  ob = this_player();
  tp = this_object();

  _terminal_name = ob->query_cur_term();
  _cols = ob->query_cols();
  _rows = ob->query_rows();

  exec(tp, ob);
  ob->quit();

  _data["name"] = lower_case(str);
  debug_log("Suing to %s", str);
  enter_state("check-login-access");

  return 1;
}

/** @ignore yes
 * Used by the creator upgrade command. This goes directly to player-login
 * after destructing the old object.
 */
int do_upgrade(object old) {
  old->save();
  _data["name"] = old->query_name();
  exec(this_object(), old);
  destruct(old);
  enter_state("player-login");
}

/** @ignore yes
 * This function is called when someone connects to the mud, it's what starts
 * it all off.
 */
void logon() {
  debug_log("Connection received.");
  if(find_call_out("time_out") == -1)
    call_out("time_out", TIMEOUT_TIME);
  _login_start_time = time();
  
  enter_state("main-menu");
}

/** @ignore yes */
int query_prevent_shadow() { return 1; }

/** @ignore yes */
void do_efun_write(string str) {
  efun::tell_object(this_object(), sprintf("%-=*s", 79, str));
}

/** @ignore yes */
string query_object_type() { return "X"; }

/** @ignore yes */
string query_gender_string() { return "blue"; }

/** @ignore yes */
void terminal_type(string type) {
  _terminal_name = type;
} /* terminal_type() */

/** @ignore yes */
void window_size(int width, int height) {
  _cols = width;
  _rows = height;
} /* window_size() */

/** @ignore yes */
void net_dead() {
  LOGIN_HANDLER->remove_from_login_queue(this_object());
}

/** @ignore yes */
void dest_me() {
  LOGIN_HANDLER->remove_from_login_queue(this_object());
  destruct(this_object());
}

/**
 * This method determines if the object is a login object.
 * @return always returns 1
 */
int query_login_ob() { return 1; }

/**
 * This method returns the path to the player file.
 * This is the player files actual normal location, it was written to
 * allow moving the player files aruond easier.
 * @param name the name of hte player whose file to find
 * @see test_user()
 * @see query_delete_player_file_name()
 */
string query_player_file_name(string name) {
  return PLAYER_HANDLER->query_player_file_name(name);
}

/**
 * This method returns the path to the deleted player file.
 * This is the deleted player files actual normal location, it was written to
 * allow moving the player files aruond easier.
 * @param name the name of hte player whose file to find
 * @see test_user()
 * @see query_delete_player_file_name()
 */
string query_delete_player_file_name(string name) {
   return PLAYER_HANDLER->query_delete_player_file_name(name);
}

/** @ignore yes */
string query_name() {
  if(_data && _data["name"])
    return _data["name"];
  return "logon";
}

/** @ignore yes */
string query_cap_name() {
  if(_data && _data["cap_name"])
    return _data["cap_name"];
  return "Logon";
}

/** @ignore yes */
protected void write_prompt() { return; }
// --- END [/mnt/home2/grok/lib/secure/login.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/finger.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/finger.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627423   Available: 13574777
Inodes: Total: 5242880    Free: 4960133
26474 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/finger.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627423   Available: 13574777
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/**
 * The finger object, this handles all the finger and refer information
 * for the players.
 * @author Pinkfish
 * @started way back in 1991 sometime
 */
/*
 * $Locker:  $
 * $Id: finger.c,v 1.114 2003/07/16 18:40:28 pinkfish Exp $
 * 
 */
#include <config.h>
#include <mail.h>
#include <finger.h>
#include <player_handler.h>
#include <player.h>
#include <access.h>
#include <login.h>
#include <clubs.h>
#include <alias.h>
#include <library.h>
#include <nomic_system.h>

inherit "/std/basic/club_listing";
inherit "/global/family";

// 7776000 == 90 days.
#define NO_EMAIL_TIME 7776000
#define WWW_REPLACEMENTS (["%^BOLD%^" : "<b>", \
                           "%^EBOLD%^" : "</b>", \
                           "%^RESET%^" : "", \
                           "\n" : "<br>\n" ])
#define REPLACEMENTS (["%^EBOLD%^" : "%^RESET%^", \
                       "<br>" : ""])

void create() {
   seteuid("Root");
}                               /* create() */

/**
 * This method fixes up the output for html.
 * @param str the string to check
 * @return the htmlised string
 */
string htmlise(string str) {
   return replace_string(str, "<", "&lt;");
} /* htmlise() */

/**
 * This method returns the infomation printed when a banished person is
 * fingered;
 * @param name the name of the banished person
 * @return the banished information
 */
string banish_finger(string name, int caller) {
  string retval;
  string *file;
  
  file = explode(read_file("/banish/" + name[0..0] + "/" + name + ".o"), "\n");
  retval = sprintf("%35-s%35-s\n", "Login name : " + name,
                   "Real name : Banished");
  retval += "Not really many seconds old.\n";
  retval += "No mail ever.\n";
  retval += "No plan.\nNo future.\n";
  if (caller) {
    if (sizeof(file) == 3) {
      retval += implode(file, "\n") + "\n";
    } else {
      retval += "Banish info not in the correct format.\n";
    }
  }
  
  if (CLUB_HANDLER->is_club(name)) {
    retval += "\nThere is also a club of this name, try: 'refer club " +
      name + "' for information on the club.\n";
  }
  
  return replace(retval, "@@", "@ @ ");
}

/**
 * This method turns a time elapsed into a string.  Like: ten minutes
 * and one second
 * @param time_elapsed the amount of time elapsed
 * @return a nice time elapsed string
 */
string time_elapsed_string(int time_elapsed) {
   return query_time_string(time_elapsed, -1);
}                               /* time_elapsed_string() */

/**
 * This method returns additional information about the player.  This is
 * stuff like, are they a playtester, are they a trustee etc.
 * @param name the name of the player to get addional information about
 * @param user_colour if it should user colour codes
 * @param caller the grade of the caller
 *        (player, creator, director : 0, 1, 2)
 * @return the additional information
 */
private string get_additional_info(string name, int no_colour,
                                   int user_colour, int width, int caller) {
  string retval, tmp, tmp_leader;
   string *bing;
   int i, used_colour, need_new, domain_leader, domain_deputy,
     domain_developer;
   object ob;

   retval = "%^BOLD%^";

   if (PLAYER_HANDLER->test_creator(name)) {
      if (master()->query_trustee(name))
         retval += capitalize(name) + " is a Trustee.\n";
      else if (master()->query_director(name))
         retval += capitalize(name) + " is a Director.\n";
      else if (master()->query_senior(name))
         retval += capitalize(name) + " is a Senior Creator.\n";
      else
         retval += capitalize(name) + " is a Creator.\n";

      bing = "/secure/master"->query_domains();
      
      tmp = "";
      tmp_leader = "";
      for (i = 0; i < sizeof(bing); i++) {
         if ((string) ("/d/" + bing[i] + "/master")->query_lord() == name) {          
            bing[i] = capitalize(bing[i]);
            tmp_leader += "Leader of the " + bing[i] + " domain.\n";
            domain_leader = 1;
            continue;
         } else if (("/d/" + bing[i] + "/master")->query_deputy(name)) {
            tmp += "Deputy of the " + capitalize(bing[i]) + " domain.\n";
            domain_deputy = 1;
         } else if (!("/d/" + bing[i] + "/master")->query_member(name)) {
           if(bing[i] != "fluffy" && bing[i] != "liaison")
             domain_developer = 1;
           continue;
         }
         tmp += "Project in the " + capitalize(bing[i]) + " domain: " + 
           ("/d/" + bing[i] + "/master")->query_project(name) + "\n";
         bing[i] = capitalize(bing[i]);
      }
      
      tmp = tmp_leader + tmp;
      
      if (!sizeof(bing) && !domain_leader && !domain_deputy &&
          !domain_developer)
          tmp += "Not a member of any domain.\n";

      bing = ({ });
      if("/d/admin/master"->query_member(name))
        bing += ({ "Administrator" });
      if(domain_leader)
        bing += ({ "Domain Leader" });
      if(domain_deputy)
        bing += ({ "Domain Deputy" });
      
      if("/d/liaison/master"->query_member(name))
        bing += ({ "Liaison" });
      else if(domain_developer)
        bing += ({ "Developer" });
      
      if(sizeof(bing))
        retval += "Roles : " + query_multiple_short(bing) + ".\n";

      if(tmp)
        retval += sprintf("Domains : %-=*s", width - 10, tmp);
      
   } else if (PLAYTESTER_HAND->query_playtester(name)) {
      bing = ({"Playtester"});
      if (PLAYTESTER_HAND->query_pt_exec (name)) {
        bing += ({"Playtesting Executive"});        
      }
      
      if (PLAYTESTER_HAND->query_senior_playtester(name)) {
         retval += capitalize(name) + " is a Senior Playtester.\n";
      } else {
         retval += capitalize(name) + " is a Playtester.\n";
      }
      
        retval += "Roles : " + query_multiple_short(bing) + ".\n";
   }
   retval += "%^EBOLD%^";
   
   i = PLAYER_HANDLER->test_start_time(name);
   if (i)
      retval += "First logged on " + ctime(i) + ".\n";

   retval += capitalize(time_elapsed_string(-PLAYER_HANDLER->test_age(name))) + " old.\n";

   // On since or last logged on info.
   if (find_player(name) &&
       (caller >= find_player(name)->query_invis() ||
        (this_player() &&
         reference_allowed(find_player(name), this_player())))) {
      retval += "On since " + ctime(PLAYER_HANDLER->test_last(name)) + " (" +
         capitalize(time_elapsed_string(time() - PLAYER_HANDLER->test_last(name))) +
         ").\n";
   } else {
      /* Should be a nice number.... */
      i = time() - PLAYER_HANDLER->test_last(name);
      retval += "Last logged off " + time_elapsed_string(i) + " ago.\n";
   }

   if (caller > 1) {
      if (!find_player(name)) {
         retval += PLAYER_HANDLER->test_last_on_from(name) + "  ";
         need_new = 1;
      } else {
         retval += query_ip_name(find_player(name)) + " (" +
            query_ip_number(find_player(name)) + ")\n";
      }
   }

   
   ob = find_player(name);
   if (ob && (caller >= ob->query_invis() ||
                      (this_player() &&
                       reference_allowed (ob, this_player())))) {
      if (interactive(ob)) {
         retval += "Idle for " + time_elapsed_string(query_idle(ob)) + ".\n";
         need_new = 0;
      } else {
         retval += "Net dead.\n";
         need_new = 0;
      }
   }

   if (need_new)
      retval += "\n";

   retval += (string) MAILER->finger_mail(name);
   tmp = PLAYER_HANDLER->query_project(name);
   if(no_colour || !user_colour) {
     tmp = strip_colours(tmp);
     tmp = replace(tmp, "%^", " ");
   }
   
   if (tmp && tmp != "") {
      if (strsrch(tmp, "%^") != -1)
         used_colour = 1;
      retval += "%^BOLD%^Project:%^EBOLD%^\n" + tmp + "\n%^RESET%^";
   } else
      retval += "No project.\n";

   tmp = PLAYER_HANDLER->query_plan(name);
   if(no_colour || !user_colour) {
     tmp = strip_colours(tmp);
     tmp = replace(tmp, "%^", " ");
   }
   
   if (tmp && tmp != "") {
      if (strsrch(tmp, "%^") != -1)
         used_colour = 1;

      retval += "%^BOLD%^Plan:%^EBOLD%^\n" + tmp + "\n%^RESET%^";
   } else
      retval += "No plan.\n";

   if (used_colour)
      retval += "%^RESET%^%^BOLD%^---  End of finger ---%^EBOLD%^\n";

   return retval;
}

/**
 * This method returns the intermud finger information.
 * @param name the name to get the intermud info on
 * @return the intermud information
 */
public mixed *remote_finger(string name) {
   mixed *retval;
   object ob;
   string cname;

   if (!strlen(name) || !PLAYER_HANDLER->test_user(name))
      return 0;

   ob = find_player(name);

   cname = PLAYER_HANDLER->query_cap_name(name);
   if (!cname) {
      cname = capitalize(name);
   }
   retval = allocate(9);
   retval[0] = cname;
   retval[1] = cname;
   retval[0] = cname;
   retval[1] = cname;
   retval[2] = (PLAYER_HANDLER->test_real_name(name) ?
                PLAYER_HANDLER->test_real_name(name) : "???");
   retval[3] = "0";
   retval[4] = (ob && !ob->query_invis() ? ctime(ob->query_last_log_on()) :
                capitalize(time_elapsed_string(time() -
                                    PLAYER_HANDLER->test_last(name))));
   retval[5] = (ob && !ob->query_invis() ? query_idle(ob) : -1);
   retval[6] = 0;
   retval[7] = 0;
   retval[8] = get_additional_info(name, 1, 0, 80, 0);

   return retval;
}                               /* remote_finger() */


/* Wraps the name with a link to its www finger info. */
private string link_name(string name) {
   return "<a href=\"finger.c?player="+ name +"\">"+ capitalize(name) + "</a>";
}


/**
 * This method returns the information used to do a domain finger of
 * the domain.
 * @param name the name of the domain to finger
 * @param www 1 if called from www_finger_info()
 * @return the information about the domain
 */
string domain_finger(string name,
                     int width,
                     int www)
{
   string ret;
   string master;
   string *members;
   string *deputies;
   string idle_str;
   int i;
   string projects;

   master = "/d/" + name + "/master";

   if (!stringp(ret = master->generate_string())) {

      ret = "%^BOLD%^The domain of " + capitalize(name) + ".\n";
      ret += "The leader for this domain is " +
         (www?
          link_name((string) master->query_lord()) + ".\n":
          capitalize((string) master->query_lord()) + ".\n");
      members = master->query_members();
      deputies = master->query_deputies();
      if (deputies && sizeof(deputies)) {
         if (sizeof(deputies) > 1) {
            ret += "The deputies for the domain are ";
         } else {
            ret += "The deputy for the domain is ";
         }
         if(www) {
            ret +=
               query_multiple_short(map(deputies, (: link_name($1) :)));
         } else {
            ret +=
               query_multiple_short(map(deputies, (: capitalize($1) :)));
         }
         ret += ".\n";
      }

      ret += "%^EBOLD%^";
      ret += "The current members of this domain are :\n";
      projects = "";
      if(www) {
         // Begin table
         ret +=
            "<table cols=\"2\" rules=\"none\""
            "border=\"0\" width=\"100%\">";
      }
      for (i = 0; i < sizeof(members); i++) {
         if (master->query_deputy(members[i])) {
            projects = "[deputy] " + master->query_project(members[i]) + "\n";
         } else {
            projects = master->query_project(members[i]) + "\n";
         }
         if(www) {
            ret += "<tr> <td>"+ link_name(members[i]) +
               "</td> <td>"+ projects +"</td> <tr>";
         } else {
            ret += sprintf("%-=12s %-=*s",
                           capitalize(members[i]), width - 14, projects);
         }
      }
      if(www) {
         // Close the table
         ret += "</table>";
      }
   }

   if (master->query_info()) {
      ret += sprintf("%-=*s", width, (string) master->query_info());
   }

   if ( ( idle_str = master->query_idle_mess() ) ) {
       ret += idle_str;
   }
   else { 
       ret += "It hasn't been idle, it just hasn't had a lunch break in "
        "years.\n";
   }

   return ret;
}

/**
 * This method returns the information about the specified club.
 * @param name the name of the club to finger
 * @return the club information
 */
string club_finger(string name)
{
   return club_info_string(name, 0, "gumball lord");
}                               /* club_finger() */

/**
 * This method returns the information about the specified family.
 * @param name the name of the family to finger
 * @return the family information
 */
string family_finger(string name)
{
   return family_info_string(name, "gumball lord");
}                               /* family_finger() */

/**
 * This method returns the information about the specified deity.
 * @param name the name of the deity to finger
 * @return the deity information
 */
string deity_finger(string name)
{
   return 0;
}


/** @ignore yes
 * This handles fingering of things other than players.
 * It currently supports: domains, banished names, clubs and families.
 */
private string other_finger(string name,
                            int no_colour,
                            int user_colour,
                            int width,
                            int caller,
                            int www)
{

   // Im sure I wrote a function for this.
   if (member_array(name, "/secure/master"->query_domains()) != -1) {
      return domain_finger(name, width, www);
   }

   // have to be before test for banish as deities are banished
   if (file_size("/save/deities/" + name + ".o") > 0 ||
       file_size("/save/deities/" + name + ".o.gz") > 0) {
      return deity_finger(name);
   }

   if (name[0..4] == "club ") {
      if (CLUB_HANDLER->is_club(name[5..]) &&
          !CLUB_HANDLER->is_family(name[5..])) {
         return club_finger(name[5..]);
      }
   } else if (name[0..6] == "domain ") {
      if (member_array(name[7..], "/secure/master"->query_domains()) != -1) {
         return domain_finger(name[7..], width, www);
      }
   } else if (name[0..6] == "family ") {
      if (CLUB_HANDLER->is_family(name[7..])) {
         return family_finger(name[7..]);
      }
   } else if (CLUB_HANDLER->is_club(name)) {
      if (CLUB_HANDLER->is_family(name)) {
         return family_finger(name);
      } else {
         return club_finger(name);
      }
   }

   if (file_size("/banish/" + name[0..0] + "/" + name + ".o") > 0) {
      return banish_finger(name, caller);
   }

   return 0;
}

private string internal_finger_info(string name,
                                    int no_colour,
                                    int user_colour,
                                    int width,
                                    int caller,
                                    int www) // 1 if webfinger
{
   string retval,
     tmp,
     tmp2;
   int i;
   int days_left;
   mixed *suspended, *lockedout;

   // Call other_finger to handle fingering things that aren't actually players.
   if (!find_player(name) && !PLAYER_HANDLER->test_user(name)) {
   //   if ( !PLAYER_HANDLER->test_user(name) ) {
      return other_finger(name, no_colour, user_colour, width, caller, www);
   }

   // Do the first line of real & login name
   retval = (no_colour ? "" : "%^BOLD%^") +
      sprintf("%*-sReal name : %*-=s\n", (width - 2) / 2,
              "Login name : " +
              strip_colours(PLAYER_HANDLER->query_cap_name(name) + "<br>"),
              (width - 2) / 2 - 12,
              (PLAYER_HANDLER->test_real_name(name) ?
               htmlise(strip_colours(PLAYER_HANDLER->test_real_name(name)[0..30])) :
               "???"));

   // Calculate and show the email & birthday line.
   tmp = PLAYER_HANDLER->test_email(name);
   tmp2 = PLAYER_HANDLER->test_birthday(name);

   // Liaison deputies and above. 
   if ( strlen( tmp ) ) {
     if(tmp[0] == ':' || www ||
        PLAYER_HANDLER->test_last( name ) + NO_EMAIL_TIME < time()) {
       if(caller == 0) {
         tmp = "";
       }
     }
   }
   if (tmp) {
      tmp = htmlise(tmp);
      if (tmp2 && tmp2 != UNKNOWN_BIRTHDAY) {
         tmp2 = htmlise(tmp2);
         retval += sprintf("%*-sEmail : %*-=s\n", (width - 2) / 2,
                           "Birthday : " + tmp2 + "<br>", (width - 2) / 2,
                           tmp);
      } else {
         retval += sprintf("Email : %-*s\n", (width - 2) / 2 - 8, tmp[0..30]);
      }
   } else if (tmp2 && tmp2 != UNKNOWN_BIRTHDAY) {
      tmp2 = htmlise(tmp2);
      retval += sprintf("Birthday : %-*s\n", (width - 2) / 2 - 11, tmp2 +
                        "<br>");
   }

   // Indicate if they're marked for deletion.
   i = PLAYER_HANDLER->test_deleting(name);
   if (i) {
      retval += (no_colour ? "" : "%^RED%^") +
         "This character is marked to be deleted in ";
      if (time() - i > (10 * 60 * 60 * 24)) {
         retval += "1 day.\n";
      } else {
         days_left = (10 - ((time() - i) / (60 * 60 * 24)));
         if (days_left > 1) { 
            retval += days_left + " days.\n";
         } else {
           retval += days_left + " day.\n";
         }
      }
      if (!no_colour)
         retval += "%^RESET%^";
   }

   // Indicate if they're marked for deletion.
   i = PLAYER_HANDLER->test_appealing(name);
   if (i) {
      retval += (no_colour ? "" : "%^RED%^") +
         "This character is marked to be deleted in ";
      if (time() - i > (28 * 60 * 60 * 24)) {
         retval += "1 day";
      } else {
         days_left = (28 - ((time() - i) / (60 * 60 * 24)));
         if (days_left > 1) { 
            retval += days_left + " days";
         } else {
           retval += days_left + " day";
         }
      }
      retval += " pending appeal.\n";
      if (!no_colour)
        retval += "%^RESET%^";
   }
   tmp = PLAYER_HANDLER->test_home_dir(name);
   if (tmp)
      retval +=
         sprintf("%*-s", (width - 2) / 2, "Home directory : " + tmp + "<br>");

   tmp = PLAYER_HANDLER->test_guild(name);
   if (tmp) {
      if (catch(retval += "Member of the " + tmp->query_short() + ".\n"))
         retval += "Member of a very broken guild.\n";
   } else
      retval += "Member of the Adventurers' guild.\n";

   if(!no_colour)
     retval += "%^EBOLD%^";
   
   tmp = PLAYER_HANDLER->test_location(name);
   if (strlen(tmp)) {
      tmp = htmlise(tmp);
      retval += "Location : " + tmp[0..30] + "\n";
   }
   
   tmp = PLAYER_HANDLER->test_homepage(name);
   if (stringp(tmp)) {
      tmp = htmlise(tmp);
      retval += "Home Page: " + tmp + "\n";
   }

   // Show their suspension if they're suspended.
   suspended = "/secure/bastards"->query_suspended(name);
   if (suspended) {
      tmp = capitalize(name) + " has been suspended until " +
         ctime(suspended[SUSPEND_TIME]);
      if (caller) {
         tmp += " for " + suspended[SUSPEND_REASON] + ".\n";
      } else {
         tmp += ".\n";
      }
      retval += "%^YELLOW%^" + sprintf("%s%-=*s", tmp[0..10], width - 11,
                                       tmp[11..]) + "%^RESET%^";
   }
   // Show their suspension if they're suspended.
   lockedout = "/secure/bastards"->query_lockedout(name);
   if (lockedout) {
     tmp = capitalize(name) + " is locked out until " +
       ctime(lockedout[SUSPEND_TIME]);
     if (caller) {
       tmp += " because " + lockedout[SUSPEND_REASON] + ".\n";
     } else {
       tmp += ".\n";
     }
      retval += "%^YELLOW%^" + sprintf("%s%-=*s", tmp[0..10], width - 11,
                                       tmp[11..]) + "%^RESET%^";
   }

   retval += htmlise(get_additional_info(name, no_colour, user_colour, width, caller));

   return retval;
}

private string make_html(string str)
{
   int pos;

   pos = strsrch(str, "http:");
   if (pos == -1) {
      str = "http://" + str;
   } else {
      str = str[pos..];
   }
   pos = strsrch(str, " ");
   if (pos != -1) {
      str = str[0..pos - 1];
   }
   return str;
}                               /* make_html() */

/**
 * This is the main finger method.  It determines the type of finger
 * and prints out the relevant information.
 * @param name the name of the thing being fingered
 * @param no_colour remove all the colour codes
 * @param user_colour show user defined colours
 * @return the shorterned finger information
 */
string finger_info(string name,
                   int no_colour)
{
   int caller,
     width,
     user_colour;
   string retval,
     str;
   string user,
     nick;

   user = this_player()->query_name();
   user_colour = this_player()->query_property(PLAYER_ALLOW_COLOURED_SOULS);
   
   if (this_player()) {
      nick = (string) this_player()->expand_nickname(name);
      if (nick)
         name = nick;
      width = this_player()->query_cols();
   }

   if (!width) {
      width = 80;
   }

   if (master()->query_director(user)) {
      caller = 3;
   } else if (master()->is_liaison_deputy(user)) {
      caller = 2;
   } else if (PLAYER_HANDLER->test_creator(user)) {
      caller = 1;
   } else {
      caller = 0;
   }

   retval = internal_finger_info(name, no_colour, user_colour,
                                 width, caller, 0);
   if (!retval) {
      return 0;
   }

   foreach(str in keys(REPLACEMENTS)) {
      retval = replace_string(retval, str, REPLACEMENTS[str]);
   }

   return retval;
}

/**
 * This method returns the finger information to the web pages.
 * @param name the name of the thing to finger
 * @param user the user who is doing the fingering
 * @return the html code for the finger
 */
string www_finger_info(string name,
                       string user)
{
   int caller;
   string retval,
     str;

   if (!user || user == "")
      caller = 0;
   else if (master()->query_director(user))
      caller = 3;
   else if (master()->is_liaison_deputy(user))
      caller = 2;
   else if (PLAYER_HANDLER->test_creator(user))
      caller = 1;
   else
      caller = 0;

   retval = internal_finger_info(name, 0, 1, 80, caller, 1);
   if (!retval)
      return 0;

   foreach(str in keys(WWW_REPLACEMENTS))
      retval = replace_string(retval, str, WWW_REPLACEMENTS[str]);

   retval = strip_colours(retval);
   return retval;
}

/**
 * This method returns the refer information of the player.
 * @param name the name of the player to get the refer information on
 * @return the refer information
 */
string refer_info(string name) {
   string retval, nick, tmp, family, rels, area, str;
   object ob;
   int width, sex;

   retval = "";
   width = 80;

   if (this_player()) {
      nick = (string) this_player()->expand_nickname(name);
      width = this_player()->query_cols();
   }
   if (nick) {
      name = nick;
   }

   if (!PLAYER_HANDLER->test_user(name)) {
     retval = other_finger(name, 0, 0, width, 0, 0);
     if(retval)
       foreach(str in keys(REPLACEMENTS))
         retval = replace_string(retval, str, REPLACEMENTS[str]);
     return retval;
   }


   family = "";

   tmp = PLAYER_HANDLER->test_player_title(name);
   if (tmp) {
      tmp += " ";
   } else {
      tmp = "";
   }

   retval = PLAYER_HANDLER->query_cap_name(name);
   if (!retval) {
      return 0;
   }

   tmp = PLAYER_HANDLER->test_family_name(name);
   if (tmp) {
      retval += " " + tmp;
   }

   if ("/d/liaison/master"->query_member(name)) {
      retval += " (%^YELLOW%^Liaison%^RESET%^)";
   } else if (PLAYER_HANDLER->test_creator(name)) {
      if ("/secure/master"->query_trustee(name)) {
         retval += " (%^RED%^Trustee%^RESET%^)";
      } else if ("/secure/master"->query_director(name)) {
         retval += " (%^RED%^Director%^RESET%^)";
      } else if ("/secure/master"->query_senior(name)) {
         retval += " (%^RED%^Senior%^RESET%^)";
      } else {
         retval += " (%^RED%^Creator%^RESET%^)";
      }
   }

   ob = find_player(name);
   if (ob) {
      if (tmp = (string) ob->query_gtitle()) {
         retval += " " + tmp;
      } else {
         retval += " the Adventurer";
      }
      if (tmp = (string)ob->query_property("player_title")) {
         retval += ", " + tmp;
      }
      tmp = (string) ob->query_title();
      if (tmp && tmp != "") {
         retval += ", " + tmp;
      }
   }

   if (PLAYTESTER_HAND->query_playtester(name)) {
     if (PLAYTESTER_HAND->query_senior_playtester(name)) {
       retval += ", (%^BOLD%^%^CYAN%^Senior Playtester%^RESET%^)";
     } else {
       retval += ", (%^CYAN%^Playtester%^RESET%^)";
     }
   }

   if(ob) {
     retval += ".";
      if(ob->query_nationality_name()) {
        retval += "\n" + capitalize(ob->query_possessive()) +
          " nationality is " + capitalize(ob->query_nationality_name());
        if(ob->query_nationality_region())
          retval += " and " + ob->query_pronoun() + " is from "+
            capitalize(ob->query_nationality_region());
        retval +=  ".\n";
      }
   } else {
      retval += " (not currently logged in)\n";
   }

   tmp = PLAYER_HANDLER->test_desc(name);
   if (tmp && tmp != "") {
     if(!this_player()->query_property(PLAYER_ALLOW_COLOURED_SOULS))
       tmp = strip_colours(tmp);
      sex = PLAYER_HANDLER->test_gender(name);
      if (sex == 1) {
         retval += "He " + tmp + "\n";
      } else if (sex == 2) {
         retval += "She " + tmp + "\n";
      } else {
         retval += "It " + tmp + "\n";
      }
   } else {
      retval += "No description.\n";
   }

   //
   // Do some magistrate and citizen stuff.
   //
   foreach(area in NOMIC_HANDLER->query_citizenship_areas()) {
      if (NOMIC_HANDLER->is_magistrate_of(area, name)) {
         retval += "Magistrate in " + area + ".\n";
      } else if (NOMIC_HANDLER->is_citizen_of(area, name)) {
         retval += "Citizen in " + area + ".\n";
      }
   }

   rels = "/std/basic/club_listing"->player_relationships_string(name);
   if (rels != "") {
      retval += PLAYER_HANDLER->query_cap_name(name) + " " +
         PLAYER_HANDLER->test_family(name) + " is the " + rels + "\n";
   }

   if(PLAYER_HANDLER->test_player_killer(name)) {
     retval += PLAYER_HANDLER->query_cap_name(name) + " is a player killer.\n";
   }

   tmp = PLAYER_HANDLER->query_reference(name);
   if(!this_player()->query_property(PLAYER_ALLOW_COLOURED_SOULS))
     tmp = strip_colours(tmp);
      
   if (tmp && tmp != "") {
      retval += "\n" + tmp + "\n%^RESET%^";
      if (strsrch(tmp, "%^") != -1) {
         retval += "--- End of Reference --\n";
      }
   } else {
      retval += "No reference.\n";
   }

   return retval;
}

// --- END [/mnt/home2/grok/lib/secure/finger.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/bastards.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/bastards.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627416   Available: 13574770
Inodes: Total: 5242880    Free: 4960133
8038 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/bastards.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627416   Available: 13574770
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Id: bastards.c,v 1.33 2003/08/12 22:56:19 ceres Exp $
 */
#include <access.h>
#include <mail.h>
#include <player_handler.h>
#include <login.h>
#include <playerinfo.h>
#include <playtesters.h>

// 2419200 == 28 days
#define TIMEOUT_TIME 2419200

/*
 * New player banning changed by Pinkfish June 1996.
 *
 * Changed to make the site access stuff timeout. Pinkfish July 1997.
 */

nosave string *names;

mapping site_access;  /* Site access control */
mapping suspended;
mapping lockedout;
mapping multiuser;
mapping temp_passwords;

int query_access(object ob);
protected void timeout_access();
private void save_me();

void create() {
  seteuid("Root");
  site_access = ([ ]);
  suspended = ([ ]);
  lockedout = ([ ]);
  multiuser = ([ ]);
  temp_passwords = ([ ]);
  
  if(!unguarded((: restore_object, base_name(this_object()) :)))
    write("Failed to restore bastards.\n");
  if (!site_access) {
    write("mmm, no site access\n");
    site_access = ([ ]);
  }
  if(!lockedout)
    lockedout = ([ ]);
  if(!multiuser)
    multiuser = ([ ]);
  if(!temp_passwords) {
    temp_passwords = ([ ]);
  }
  timeout_access();
  
  if (find_object("/room/void"))
    move_object(find_object("/room/void"));
}

string query_player_ob(string name) {
  if("/secure/master"->query_administrator(name) ||
     "/secure/master"->query_lord(name))
    return "/global/lord";
  
  if (PLAYER_HANDLER->test_creator(name))
    return "/global/creator";

  if (PLAYTESTER_HAND->query_playtester(name))
    return "/global/playtester";

  return "/global/player";
}

int query_prevent_shadow() { return 1; }

/*
 * Ok, acces checking stuff...
 */
mapping query_all_access() { return copy(site_access); }

/*
 * Look up the address and find out if it is nice and floppy
 * Adress is of the format ({ "130", "95", "100", "2" })
 */
int query_access(object ob) {
  string tmp;
  
  tmp = query_ip_number(ob);
  while(strlen(tmp)) {
    if(site_access[tmp])
      return site_access[tmp][ACCESS_LEVEL];
    tmp = implode((string *)explode(tmp, ".")[0..<2], ".");
  }
  
  tmp = query_ip_name(ob);
  while(strlen(tmp)) {
    if(site_access[tmp])
      return site_access[tmp][ACCESS_LEVEL];
    tmp = implode(explode(tmp, ".")[1..], ".");
  }

  return DEFAULT;
}

int query_multi(object ob) {
  string tmp;
  
  tmp = query_ip_number(ob);
  while(strlen(tmp)) {
    if(multiuser[tmp])
      return 1;
    tmp = implode((string *)explode(tmp, ".")[0..<2], ".");
  }
  
  tmp = query_ip_name(ob);
  while(strlen(tmp)) {
    if(multiuser[tmp])
      return 1;
    tmp = implode(explode(tmp, ".")[1..], ".");
  }

  return 0;
}

mapping query_all_multi() { return copy(multiuser); }

string query_reason(string address) {
  if(site_access[address])
    return site_access[address][ACCESS_REASON];
  return 0;
}

protected void add_multi(string address, int multi, int timeout) {
  if(!multi)
    map_delete(multiuser, address);
  else
    multiuser[address] = timeout;
}

protected void add_access(string address, int level, string reason,
                          int timeout) {
  site_access[address] = ({ level, reason, timeout });
}

/*
 * Runs through the array nibbling all the timed out bits...
 */
protected void timeout_access() {
  string bit;
  
  foreach(bit in keys(site_access))
    if(site_access[bit][ACCESS_TIMEOUT] < time() ||
       site_access[bit][ACCESS_LEVEL] == ACCESS)
      map_delete(site_access, bit);

  foreach(bit in keys(multiuser))
    if(multiuser[bit] < time())
      map_delete(multiuser, bit);
}

private void save_me() {
  unguarded((: save_object, base_name(this_object()), 2 :));
} 

int change_access(string address, int level, string reason, int timeout) {
  if(!master()->query_lord(previous_object(-1)) &&
     base_name(previous_object()) != "/cmds/creator/ban")
    return 0;
  
  if(!stringp(address) || !reason)
    return notify_fail("Invalid parameters.\n");
  
  if (!timeout)
    timeout = time() + 100 * 24 * 60 * 60;

  add_access(address, level, reason, timeout);
  save_me();
  unguarded((: write_file, "/log/ACCESS", ctime(time())[4..16] + " " + 
             address+" set to " + PERM_NAMES[level] + " for " + reason +
             " until " + ctime(timeout) + " by "+
             this_player()->query_name()+".\n" :));
  return 1;
}

int change_multi(string address, int multi, int timeout) {
  if(!master()->query_lord(previous_object(-1)) &&
     base_name(previous_object()) != "/cmds/creator/multipl_ayer")
    return 0;
  
  if(!stringp(address))
    return notify_fail("Invalid parameters.\n");
  
  if (!timeout)
    timeout = time() + 100 * 24 * 60 * 60;

  add_multi(address, multi, timeout);
  save_me();
  
  unguarded((: write_file, "/log/ACCESS", ctime(time())[4..16] + " " + 
             address+" set to " + (multi?"allow":"disallow") + 
             " multiple users until " + ctime(timeout) + " by "+
             this_player()->query_name()+".\n" :));
  return 1;
}

int suspend_person(string str, int tim, string reason) {
  if (!master()->query_lord(previous_object(-1)) &&
      base_name(previous_object()) != "/cmds/creator/suspend") {
    return 0;
  }
  if (!PLAYER_HANDLER->test_user(str)) {
    return 0;
  }
  
  if (!reason) {
    reason = "you have been bad";
  }

  suspended[str] = ({ time() + tim, reason });
  save_me();
  unguarded((: write_file, "/log/SUSPEND", ctime(time())[4..16] + " " +
             str+" suspended until "+ ctime(time()+tim)+" by "+
             this_player()->query_name()+" because "+ reason + ".\n" :));
  PLAYERINFO_HANDLER->add_entry(this_player(), str, "suspend",
                                "Suspended until " + ctime(time() + tim) +
                                " for " + reason);
  return 1;
}

int unsuspend_person(string str) {
  if (!"/secure/master"->query_lord(previous_object(-1)) &&
      base_name(previous_object()) !="/cmds/creator/unsuspend") {
    return 0;
  }
  map_delete(suspended, str);
  unguarded((: save_object, base_name(this_object()), 2 :));
  unguarded((: write_file, "/log/SUSPEND",
             ctime(time())[4..16] + " " + str+" unsuspended.\n" :));
  PLAYERINFO_HANDLER->add_entry(this_player(), str, "suspend", "Unsuspended.");
  return 1;
}

mixed *query_suspended(string name) {
  if (suspended[name]) {
    if (suspended[name][SUSPEND_TIME] > time()) {
      return copy(suspended[name]);
    }
    map_delete(suspended, name);
    save_me();
  }
  return suspended[name];
}

int lockout_person(string str, int tim, string reason) {
  if (!master()->query_lord(previous_object(-1)) &&
      base_name(previous_object()) != "/cmds/player/lockout") {
    return 0;
  }
  if (!PLAYER_HANDLER->test_user(str)) {
    return 0;
  }
  
  if (!reason) {
    reason = "you have been bad";
  }

  lockedout[str] = ({ time() + tim, reason });
  save_me();
  unguarded((: write_file, "/log/LOCKOUT",
             ctime(time())[4..16] + " " + str+" lockedout until "+
             ctime(time()+tim)+" by "+this_player()->query_name()+" because "+
             reason + ".\n" :));
  PLAYERINFO_HANDLER->add_entry(this_player(), str, "lockedout",
                                "Locked out until " + ctime(time() + tim) +
                                " for " + reason);
  return 1;
}

mixed *query_lockedout(string name) {
  if (lockedout[name]) {
    if (lockedout[name][SUSPEND_TIME] > time()) {
      return copy(lockedout[name]);
    }
    map_delete(lockedout, name);
    save_me();
  }
  return lockedout[name];
}

int set_temp_password(string name, string pass) {
  temp_passwords[name] = ({ time(), pass });
  save_me();
  return 1;
}

mixed *query_temp_password(string name) {
  int found;
  string tmp;
  
  foreach(tmp in keys(temp_passwords)) {
    if(temp_passwords[tmp][0] < (time() - TIMEOUT_TIME)) {
      map_delete(temp_passwords, tmp);
      found = 1;
    }
  }
  if(found)
    save_me();
  
  return copy(temp_passwords[name]);
}

void clear_temp_password(string name) {
  if(temp_passwords[name]) {
    map_delete(temp_passwords, name);
    save_me();
  }
}
// --- END [/mnt/home2/grok/lib/secure/bastards.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/ftp_auth.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/ftp_auth.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627414   Available: 13574768
Inodes: Total: 5242880    Free: 4960133
5002 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/ftp_auth.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627414   Available: 13574768
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* $Id: ftp_auth.c,v 1.6 2002/04/19 20:47:45 pinkfish Exp pinkfish $
 * An authority demon for the outside FTP server.
 * Based on old code from TMI2.
 * Written by Turrican, September 1999.
 */
#include <network.h>
#include <login_handler.h>
#include <playtesters.h>

#define BASTARDS "/secure/bastards" 
#define MAX_LIFE 36000

inherit SERVER;

class ftp_session {
  int fd;
  string token;
  int timestamp;
  string user;
}

private mapping Sockets;

protected void create() {
  server::create();
  SetSocketType(STREAM);
  SetDestructOnClose(1);
  Sockets = ([]);
  call_out("setup", 2);
  call_out("clean_sockets", 3600);
} /* create() */

/** @ignore yes */
protected void setup() {
  if (eventCreateSocket(PORT_FTPAUTH) < 0) {
    if (this_object()) {
      destruct(this_object());
    }
  }
} /* setup() */

/** @ignore yes */
protected void eventNewConnection(int fd) {
  class ftp_session sess;
  string address, host;

  server::eventNewConnection(fd);
  address = socket_address(fd);
  /* If this is not coming from localhost, disconnect. */
  if ((sscanf(address, "%s %*d", host) != 2) || (host != "127.0.0.1")) {
    eventWrite(fd, "", 1);
    return;
  }
  sess = new(class ftp_session, fd : fd);
  Sockets[fd] = sess;
} /* eventNewConnection() */

/** @ignore yes */
protected string get_path(string str) {
  string *array, *array1;
  int i;

  if (str == "/")
    return "/";
  array = explode(str, "/") - ({ "" });
  array1 = ({ });
  for (i = 0; i < sizeof(array); i++) {
    if (array[i] == "..") {
      if (sizeof(array1)) {
        array1 = array1[0..<2];
      }
    } else if (array[i] != ".") {
      array1 += ({ array[i] });
    }
  }
  if (sizeof(array1))
    str = implode(array1, "/");
  else
    str = "";
  return "/" + str;
} /* get_path() */

/** @ignore yes */
protected void eventRead(int fd, string str) {
  class ftp_session sess = Sockets[fd];
  string name, rest, ret, token, type, path;
  int timestamp;

  if (!sess) {
    eventWrite(fd, "DENIED\n", 1);
    return;
  }
  if (str == "mudname") {
    eventWrite(fd, sprintf("OKAY: %s\n", mud_name()));
    return;
  }
  if (sscanf(str, "%s %s", name, rest) != 2) {
    eventWrite(fd, "Syntax error\n", 1);
    return;
  }
  name = lower_case(name);
  if (rest == "request login" ||
      rest == "request login playtester") {
    int anon = 0;

    if (name == "ftp") {
        anon = 1;
    }

    if (rest == "request login") {
       if (!(anon || PLAYER_HANDLER->test_creator(name))) {
         eventWrite(fd, "DENIED\n");
         return;
       }
    } else {
       if (!anon && 
           !PLAYTESTER_HAND->query_playtester(name) && 
           !PLAYER_HANDLER->test_creator(name)) {
         eventWrite(fd, "DENIED invalid\n");
         return;
       }
    }

    if ( BASTARDS->query_suspended( name ) ) { 
      eventWrite(fd, "DENIED suspended\n");
      return;
    }

    timestamp = time();
    token = crypt("" + timestamp, "" + random(12000));
    sess->token = token;
    sess->timestamp = timestamp;
    sess->user = name;
    if (anon) {
      ret = sprintf("OKAY: %s * /pub\n", token);
    } else {
      ret = sprintf("OKAY: %s %s /w/%s\n", token,
                    PLAYER_HANDLER->get_password(name), name);
    }
    eventWrite(fd, ret);
    return;
  }
  if (sscanf(rest, "%s %s %s", token, type, path) != 3) {
    eventWrite(fd, "Syntax error\n", 1);
    return;
  }
  if ((token != sess->token) || ((time() - sess->timestamp) > MAX_LIFE)) {
    eventWrite(fd, "DENIED\n");
    return;
  }
  path = get_path(path);
  switch (type) {
  case "read":
    if (file_size(path) == -2) {
      path += "/*";
    }
    if(path == "//*")
      ret = (master()->valid_read(path, name, "read_file") ? "OKAY\n" : "DENIED\n");
    else
      ret = (master()->valid_copy(path, name, "read_file") ? "OKAY\n" : "DENIED\n");
    eventWrite(fd, ret);
    break;
  case "write":
    if (file_size(path) == -2) {
      path += "/*";
    }
    ret = (master()->valid_write(path, name, "write_file") ? "OKAY\n" : "DENIED\n");
    eventWrite(fd, ret);
    break;
  default:
    eventWrite(fd, "DENIED\n");
    break;
  }
} /* eventRead() */

/** @ignore yes */
protected void eventSocketClosed(int fd) {
  class ftp_session sess = Sockets[fd];

  if (!sess) {
    return;
  }
  map_delete(Sockets, fd);
} /* eventSocketClosed() */

/** @ignore yes */
protected void clean_sockets() {
  class ftp_session sess;
       
  foreach (sess in values(Sockets)) {
    if (!sess->timestamp) {
      sess->timestamp = time();
      continue;
    }
    if (time() - sess->timestamp > MAX_LIFE) {
      eventWrite(sess->fd, "Timeout\n", 1);
    }
  }
  call_out("clean_sockets", 3600);
} /* clean_sockets() */

/** @ignore yes */
string *query_connections() {
  class ftp_session val;
  string *list;

  list = ({ });
  foreach (val in values(Sockets)) {
    if (val->user) {
      list += ({ capitalize(val->user) });
    } else {
      list += ({ "login" });
    }
  }
  return list;
} /* query_connections() */
// --- END [/mnt/home2/grok/lib/secure/ftp_auth.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/master/valid_ident.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/master/valid_ident.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627412   Available: 13574766
Inodes: Total: 5242880    Free: 4960133
281 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/master/valid_ident.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627412   Available: 13574766
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: valid_ident.c,v 1.1 1998/01/06 05:12:03 ceres Exp $
 * $Log: valid_ident.c,v $
 * Revision 1.1  1998/01/06 05:12:03  ceres
 * Initial revision
 * 
*/
int valid_ident(string euid) {
  return high_programmer(euid);
} /* valid_ident() */
// --- END [/mnt/home2/grok/lib/secure/master/valid_ident.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/master/dest_env.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/master/dest_env.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627412   Available: 13574766
Inodes: Total: 5242880    Free: 4960133
1107 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/master/dest_env.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627412   Available: 13574766
Inodes: Total: 5242880    Free: 4960133
2025-03-06 16:57:25.126798168 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
// -*- LPC -*-
// /secure/master/dest_env.c
// Recoded for FluffOS v2019+, themed for Forgotten Realms, integrating Discworld mechanics
// Last updated: March 07, 2025

#include <config.h>
#include <log.h>

void dest_env(object env) {
    string err;
    object *contents;

    if (!env || !objectp(env)) {
        LOG_HANDLER->log("ERROR", "Attempted divine purging of invalid environment at " + ctime(time()) + "\n");
        return;
    }

    contents = all_inventory(env);
    foreach (object ob in contents) {
        err = catch(destruct(ob));
        if (err) {
            LOG_HANDLER->log("ERROR", "Failed to purge " + file_name(ob) + " from " + file_name(env) + ": " + err + " at " + ctime(time()) + "\n");
        }
    }

    err = catch(destruct(env));
    if (err) {
        LOG_HANDLER->log("ERROR", "Divine purging of " + file_name(env) + " failed: " + err + " at " + ctime(time()) + "\n");
        notify_fail("The realm resists Talos’s wrath!\n");
    } else {
        LOG_HANDLER->log("EVENT", "Realm " + file_name(env) + " purged by divine storm at " + ctime(time()) + "\n");
    }
}
// --- END [/mnt/home2/grok/lib/secure/master/dest_env.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/master/permission.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/master/permission.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627412   Available: 13574766
Inodes: Total: 5242880    Free: 4960133
22679 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/master/permission.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627412   Available: 13574766
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Id: permission.c,v 1.12 2003/03/21 02:25:20 ceres Exp $
 */

int add_senior( string word ) {
   if ( !sizeof( filter( previous_object( -1 ), (: interactive( $1 ) :) ) ) ) {
      user_event( "inform", this_player()->query_name() +
            " illegally attempted to call add_senior( "+ word +
            " )", "cheat" );
      unguarded((: write_file, "/log/CHEAT", ctime( time() ) +
            ": illegal attempt to call add_senior( "+ word +
            " ).\n"+ back_trace() :));
      return 0;
   }
   if ( PLAYER_HANDLER->test_user( word ) &&
        query_leader( previous_object(-1) ) ) {
      write_file( "/log/PROMOTIONS", ctime( time() ) +": "+ word +
            " was promoted to Senior by "+ geteuid( this_interactive() ) +
            "\n" );
      if ( ( positions[ word ] != TRUSTEE ) &&
            ( positions[ word ] != DIRECTOR ) )
         positions[ word ] = SENIOR;
      save_object( "/secure/master" );
      return 1;
   }
   return 0;
} /* add_senior() */

int remove_senior(string str) {
  if (!sizeof(filter(previous_object(-1), (: interactive($1) :)))) {
    user_event( "inform", this_player()->query_cap_name()+
                " illegally attempted to call remove_senior("+str+")",
                "cheat");
    unguarded((: write_file, "/log/CHEAT", ctime(time())+": Illegal attempt "
                 "to call remove_senior("+str+").\nBacktrace: "+
                 back_trace() :));
    return 0;
  }
  if (query_leader(previous_object(-1)) &&
      positions[str] == SENIOR) {
    write_file("/log/DEMOTIONS", ctime(time())+": "+str+
               " was demoted from Senior by "+geteuid(this_interactive())+
               "\n");
    map_delete(positions, str);
    save_object("/secure/master");
    return 1;
  }
  return 0;
} /* remove_senior() */

int add_director(string str) {
  if (!sizeof(filter(previous_object(-1), (: interactive($1) :)))) {
    user_event( "inform", this_player()->query_cap_name()+
                " illegally attempted to call add_director("+str+")",
                "cheat");
    unguarded((: write_file, "/log/CHEAT", ctime(time())+
               ": Illegal attempt to call add_director("+str+
               ").\nBacktrace: "+ back_trace() :));
    return 0;
  }
  if (PLAYER_HANDLER->test_user(str) &&
      query_trustee(previous_object(-1))) {
    write_file("/log/PROMOTIONS", ctime(time())+": "+str+
               " was promoted to Leader by "+ geteuid(this_interactive())+
               "\n");
    if (positions[str] != TRUSTEE)
      positions[str] = DIRECTOR;
    save_object("/secure/master");
    return 1;
  }
  return 0;
}

int remove_director(string str) {
  if (!sizeof(filter(previous_object(-1), (: interactive($1) :)))) {
    user_event( "inform", this_player()->query_cap_name()+
                " illegally attempted to call remove_director("+str+")",
                "cheat");
    unguarded((: write_file, "/log/CHEAT", ctime(time())+
               ": Illegal attempt to call remove_director("+str+
               ").\nBacktrace: "+ back_trace() :));
    return 0;
  }
  if (query_trustee(previous_object(-1)) &&
      positions[str] == DIRECTOR) {
    write_file("/log/DEMOTIONS", ctime(time())+": "+str+
               " was demoted from Leader by "+geteuid(this_interactive())+
               "\n");
    map_delete(positions, str);
    save_object("/secure/master");
    return 1;
  }
  return 0;
}

int add_trustee(string str) {
  if (!sizeof(filter(previous_object(-1), (: interactive($1) :)))) {
    user_event( "inform", this_player()->query_cap_name()+
                " illegally attempted to call add_tristee("+str+")",
                "cheat");
    unguarded((: write_file, "/log/CHEAT", ctime(time())+": Illegal attempt "
                 "to call add_trustee("+str+").\nBacktrace: "+
                 back_trace() :));
    return 0;
  }
  if (PLAYER_HANDLER->test_user(str) &&
      query_trustee(previous_object(-1))) {
    write_file("/log/PROMOTIONS", ctime(time())+": "+str+
               " was promoted to Administrator by "+
               geteuid(this_interactive())+"\n");
    positions[str] = TRUSTEE;
    save_object("/secure/master");
    return 1;
  }
  return 0;
}

int remove_trustee(string str) {
  if (!sizeof(filter(previous_object(-1), (: interactive($1) :)))) {
    user_event( "inform", this_player()->query_cap_name()+
                " illegally attempted to call remove_trustee("+str+")",
                "cheat");
    unguarded((: write_file, "/log/CHEAT", ctime(time())+": Illegal attempt "
                 "to call remove_trustee("+str+").\nBacktrace: "+
                 back_trace() :));
    return 0;
  }
  if (query_trustee(previous_object(-1)) &&
      positions[str] == TRUSTEE) {
    write_file("/log/DEMOTIONS", ctime(time())+": "+str+
               " was demoted from Administrator by "+
               geteuid(this_interactive())+"\n");
    map_delete(positions, str);
    save_object("/secure/master");
    return 1;
  }
  return 0;
}

varargs mixed creator_file(string path, int author);

nomask protected int check_domain(mixed ob, string func, string path, int mask) {
  object master_ob;
  string master, domain, *bits = explode(path, "/") - ({ "", "." });
  int ret;

  if (sizeof(bits) < 2)
    return (mask & READ_MASK);
  
  domain = bits[1];
  if (objectp(ob))
    ob = geteuid(ob);

  /* Is it the domain itself? */
  if (ob == creator_file(path))
    return 1;

  /* Check the domain master object, if any. */
  master = "/d/" + domain + "/master";
  if (!(master_ob = find_object(master)) && checked_master[master]) {
    return (mask & READ_MASK);
  }
  if (!master_ob && !checked_master[master] &&
      catch(master_ob = load_object(master))) {
    checked_master[master] = 1;
  }
  if (master_ob) {
    ret = master_ob->check_permission(ob, bits, mask);
    if (ret == -1) {
      /* This means the path was locked. We deny access. */
      return 0;
    }
    /* Senior Creators have access to the domains, except when explicitly
       locked. */
    if ((sizeof(bits) > 2) && (bits[2] != "master.c") &&
        (bits[2] != "master.o") && (bits[2] != "master") && query_senior(ob)) {
      return 1;
    }
    
    return (ret || (mask & READ_MASK?master_ob->valid_read(bits, ob, func):
            master_ob->valid_write(bits, ob, func)));
  }
  return (mask & READ_MASK);
}

nomask protected int check_creator(mixed ob, string func, string path, int mask) {
  string master, creator, *bits = explode(path, "/") - ({ "", "." });
  object master_ob;

  if (sizeof(bits) < 2)
    return (mask & READ_MASK);
  
  creator = bits[1];
  if (objectp(ob))
    ob = geteuid(ob);

  /* Creators are not allowed to give out write perms to their dirs using
     the granting system, they should write their own master object if
     they want to do this. */
  /* Err, why this?  Why not use the standard system?
   * - pf
   */
  if (mask & GRANT_MASK) {
    if (ob == creator) {
      return 1;
    } else {
      return 0;
    }
  }

  /* The mbox file is private. Only the owner can read it. */
  if ((mask & READ_MASK) && sizeof(bits) >= 3 && bits[2] == "mbox" &&
      file_size(sprintf("/w/%s/mbox", bits[1])) != -2)
    return ob == bits[1];

  /* Reading is allowed in creator dirs, and writing is allowed if it's
     the owner doing it. */
  if ((mask & READ_MASK) || (ob == creator_file(path)))
    return 1;

  /* Check the master object, if any. */
  master = "/w/" + creator + "/master";
  if (!(master_ob = find_object(master)) && checked_master[master])
    return 0;
  if (!master_ob && !checked_master[master] &&
      catch(master_ob = load_object(master)))
    checked_master[master] = 1;
  if (master_ob)
    return (master_ob->check_permission(ob, bits, mask) ||
            master_ob->valid_write(bits, ob, func));
  return 0;
}

/* Permision handling stuff. Originally coded by who knows who.
   This now uses a system based on the previous_object() stack.
   Coded by Turrican, based on code in the Nightmare mudlib.
   - First working version on 7-10-96
   - Hacked some more on 4-4-97 */
private int check_permission(mixed ob, string func, string path,
                             mapping perms, int mask) {
  string tmp, euid;
  int i;
  mixed *stack;
  
  if (perms && sizeof(perms) && !undefinedp(perms["all"]) &&
      (perms["all"] & mask))
    return 1;

  if(path[0..21] == "/save/boards/lordboard" &&
     base_name(ob) != "/obj/handlers/board_handler") {
    catch(log_file("/d/admin/log/LORDBOARD",
                   "%s: ob %s player %s prev %s\n",
                   ctime(time())[4..18], base_name(ob),
                   this_player()->query_name(),
                   base_name(previous_object()))); 
  }
  
  if (unguarded_ob == ob) {
    if ((tmp = base_name(ob)) == "/global/player" ||
        tmp == "/global/playtester" ||
        tmp == "/global/creator" ||
        tmp == "/global/lord") {
      if((path == "/save/players/"+ob->query_name()[0..0]+"/"+ob->query_name())
         ||
         (path == "/save/players/"+ob->query_name()[0..0]+"/"+ob->query_name()+
          ".o") ||
         (path == "/save/players/"+ob->query_name()[0..0]+"/"+ob->query_name()+
          ".o.gz") ||
         (path == "/save/ramdisk/players/"+ob->query_name()[0..0]+"/"+ob->query_name()) ||
         (path == "/save/ramdisk/players/"+ob->query_name()[0..0]+"/"+ob->query_name()+
          ".o") ||
         (path == "/save/ramdisk/players/"+ob->query_name()[0..0]+"/"+ob->query_name()+
          ".o.gz"))
        return 1;
      else i = sizeof(stack = ({ ob }) + previous_object(-1));
    } else if (tmp == path)
      return 1;
    else
      i = sizeof(stack = ({ ob }));
  } else if (unguarded_ob && base_name(ob) == "/secure/simul_efun") {
    if (unguarded_ob == previous_object(1))
      i = sizeof(stack = ({ previous_object(1) }));
    else
      i = sizeof(stack = ({ ob }) + previous_object(-1));
  } else if (unguarded_ob) {
    /* Okay, unguarded object is not the calling object. We only check
       the call stack as far back as the position of the unguarded
       object. */
    stack = previous_object(-1);
    for (i = 0; i < sizeof(stack) && stack[i] != unguarded_ob; i++)
      ;
    i = sizeof(stack = ({ ob }) + stack[0..i]);
  } else
    i = sizeof(stack = ({ ob}) + previous_object(-1));
//  tell_object(find_player("turrican"),
//              sprintf("stack = %O, perms = %O, unguarded_ob = %O, func = %s\n",
//                      stack, perms, unguarded_ob, func));
  while (i--) {
    if (!stack[i])
      return 0;
    if (stack[i] == this_object())
      continue;
    if (objectp(stack[i])) {
      if (file_name(stack[i]) == "/secure/simul_efun")
        continue;
      if (!(euid = geteuid(stack[i])))
        return 0;
    } else
      euid = stack[i];
    if (euid == get_root_uid())
      continue;
    if (query_director(euid) && (mask & READ_MASK))
      continue;
    if (query_trustee(euid))
      continue;
    if (perms) {
      if (!undefinedp(perms[euid]) && (perms[euid] & mask))
        continue;

      /* If the path is explicitly locked, and the lock isn't overridden
         by other pemissions, we deny access. */
      if (!undefinedp(perms["all"]) && (perms["all"] & LOCK_MASK))
        return 0;
    }

    /* Is this a creator directory? */
    if (path[0..2] == "/w/") {
      if (check_creator(stack[i], func, path, mask))
        continue;
    } else if(path[0..2] == "/d/") {
      /* It's a domain directory. */
      if (check_domain(stack[i], func, path, mask))
        continue;
    } else {
      /* The rest of the mudlib defaults to reading allowed, unless
         paths are explitcitly locked, which is handled above. */
      return (mask & READ_MASK);
    }
    return 0;
  }
  return 1;
} /* check_permission() */

mixed permission_match_path(mapping m, string path) {
  string p, *bits;
  int i, size;
  mapping found = ([]);

  if (!sizeof(m)) {
    return 0;
  }
  bits = explode(path, "/") - ({ "", "." });
  p = "";

  if (!undefinedp(m["/"])) {
    found += m["/"];
  }

  size = sizeof(bits);
  for (i = 0; i <= size; i++) {
    if (!undefinedp(m[p])) {
      mapping old = copy(found);

      if (sizeof((found += m[p])) != (sizeof(old) + sizeof(m[p]))) {
        string euid;
        int mask;
        
        found = old;
        foreach (euid, mask in m[p]) {
          if (!undefinedp(found[euid]))
            found[euid] |= mask;
          else
            found[euid] = mask;
        }
      }
    }
    if (i < size)
      p = p + "/" + bits[i];
  }
  if (sizeof(found)) {
    return found;
  } else {
    return 0;
  }
} /* permission_match_path() */

int valid_grant(object euid, string path, int mask) {
  string domain, master, director;
  int result;
  object master_ob;

  if (path[0] != '/')
    path = "/" + path;
  result = check_permission(euid, 0, path,
                            permission_match_path(permissions, path),
                            GRANT_MASK);
  if (!result || (mask & (READ_MASK|WRITE_MASK)))
    return result;
  if (sscanf(path, "/d/%s/%*s", domain) != 2 &&
      sscanf(path, "/d/%s", domain) != 1)
    return 0;
  master = "/d/" + domain + "/master";
  if (!(master_ob = find_object(master)) && checked_master[master])
    return 0;
  if (!master_ob && !checked_master[master] &&
      catch(master_ob = load_object(master))) {
    checked_master[master] = 1;
    return 0;
  }
  director = master->query_director();
  if(!director)
    director = master->query_lord();
  return (query_director(previous_object(-1) + ({ euid })) &&
          (member_array(director, map(previous_object(-1),
                                  (: geteuid($1) :))) != -1));
}

mapping query_permissions() {
  string *doms, master;
  int i;
  mapping blue, tmp;
  object master_ob;

  doms = get_dir("/d/");
  doms -= ({ "lost+found" });
  blue = ([ ]);
  for (i=0;i<sizeof(doms);i++) {
    master = "/d/"+doms[i]+"/master";
    if (!(master_ob = find_object(master)) && checked_master[master])
      continue;
    if (!master_ob && !checked_master[master] &&
        catch(master_ob = load_object(master))) {
      checked_master[master] = 1;
      continue;
    }
    tmp = (mapping)master_ob->query_access();
    if (mapp(tmp))
      blue += tmp;
  }
  return permissions + blue;
} /* query_permissions() */

protected int add_permission(string euid, string path, int mask) {
  string *bits, master;
  object master_ob;

  if (path[0..2] == "/d/") {
    /* A domain...  */
    bits = explode(path, "/");
    if (sizeof(bits) >= 2) {
      master = "/d/"+bits[1]+"/master";
      if (!(master_ob = find_object(master)) && checked_master[master])
        return 0;
      if (!master_ob && !checked_master[master] &&
          catch(master_ob = load_object(master))) {
        checked_master[master] = 1;
        return notify_fail("Failed to load master file.\n");
      }
      if ((mask & LOCK_MASK) &&
          !sizeof(filter(previous_object(-1),
                      (: $(master_ob)->query_lord() == geteuid($1) :))))
        return notify_fail("You are not the leader of $C$" + bits[1] +
                           ".\n");
      return (int)master_ob->add_permission(euid, path, mask);
    }
  }
  if (!permissions[path]) {
    permissions[path] = ([ euid : mask ]);
  } else {
    permissions[path][euid] |= mask;
  }
  unguarded((: save_object, "/secure/master" :));
  return 1;
} /* add_permission() */

int add_read_permission(string euid, string path) {
  if ( base_name(previous_object()) != "/d/admin/room/access_control" &&
       base_name(previous_object()) != "/cmds/creator/perm_it") {
    user_event( "inform", this_interactive()->query_cap_name()+
                " illegally attempted to call add_read_permission("+euid+", "+
                path+")", "cheat");
    unguarded((: write_file, "/log/CHEAT", ctime(time())+": Illegal attempt "
               "to call add_read_permission("+euid+", "+path+").\nBacktrace: "+
               back_trace() :));
    return 0;
  }
  if (add_permission(euid, path, READ_MASK)) {
    write("Added read permision for "+euid+" to "+path+".\n");
    return 1;
  }
  return 0;
} /* add_read_permission() */

int add_write_permission(string euid, string path) {
  if ( base_name(previous_object()) != "/d/admin/room/access_control" &&
       base_name(previous_object()) != "/cmds/creator/perm_it") {
    user_event( "inform", this_player(1)->query_cap_name()+
                " illegally attempted to call add_write_permission("+euid+", "+
                path+")", "cheat");
    unguarded((: write_file, "/log/CHEAT", ctime(time())+": Illegal attempt "
                 "to call add_write_permission("+euid+", "+path+").\n"
                 "Backtrace: "+ back_trace() :));
    return 0;
  }
  if (add_permission(euid, path, WRITE_MASK)) {
    write("Added write permision for "+euid+" to "+path+".\n");
    return 1;
  }
  return 0;
} /* add_write_permission() */

int add_grant_permission(string euid, string path) {
  if ( base_name(previous_object()) != "/d/admin/room/access_control" &&
       base_name(previous_object()) != "/cmds/creator/perm_it") {
    user_event( "inform", this_player(1)->query_cap_name()+
                " illegally attempted to call add_grant_permission("+euid+", "+
                path+")", "cheat");
    unguarded((: write_file, "/log/CHEAT", ctime(time())+": Illegal attempt "
                 "to call add_grant_permission("+euid+", "+path+").\n"
                 "Backtrace: "+ back_trace() :));
    return 0;
  }
  if (add_permission(euid, path, GRANT_MASK)) {
    write("Added grant permision for "+euid+" to "+path+".\n");
    return 1;
  }
  return 0;
} /* add_grant_permission() */

int lock_path(string path) {
  if ( base_name(previous_object()) != "/d/admin/room/access_control" &&
       base_name(previous_object()) != "/cmds/creator/perm_it") {
    user_event("inform", this_player(1)->query_cap_name()+
               " illegally attempted to call lock_path("+path+")", "cheat");
    unguarded((: write_file, "/log/CHEAT", ctime(time())+": Illegal attempt "
               "to call lock_path("+path+").\nBacktrace: "+ back_trace() :));
    return 0;
  }
  if (add_permission("all", path, LOCK_MASK)) {
    write("Restricted access for all to "+path+".\n");
    return 1;
  }
  return 0;
} /* lock_path() */

protected int remove_permission(string euid, string path, int mask) {
  string *bits, master;
  object master_ob;

  if (path[0..2] == "/d/") {
    /* A domain...  */
    bits = explode(path, "/");
    if (sizeof(bits) >= 2) {
      master = "/d/"+bits[1]+"/master";
      if (!(master_ob = find_object(master)) && checked_master[master])
        return 0;
      if (!master_ob && !checked_master[master] &&
          catch(master_ob = load_object(master))) {
        checked_master[master] = 1;
        return notify_fail("Failed to load master file.\n");
      }
      if ((mask & LOCK_MASK) &&
          !sizeof(filter(previous_object(-1),
                         (: $(master_ob)->query_lord() == geteuid($1) :))))
        return notify_fail("You are not the lord of $C$" + bits[1] + ".\n");
      return (int)master_ob->remove_permission(euid, path, mask);
    }
  }
  if (!permissions[path] || !permissions[path][euid]) {
    notify_fail("The euid \""+euid+"\" does not have any permissions to "
                "remove in "+path+".\n");
    return 0;
  }
  permissions[path][euid] &= ~mask;
  if (!permissions[path][euid]) {
    if (m_sizeof(permissions[path]) == 1) {
      map_delete(permissions, path);
    } else {
      map_delete(permissions[path], euid);
    }
  }
  unguarded((: save_object, "/secure/master" :));
  return 1;
} /* remove_permission() */

int remove_read_permission(string euid, string path) {
  if ( base_name(previous_object()) != "/d/admin/room/access_control" &&
      base_name(previous_object()) != "/cmds/creator/perm_it") {
    user_event( "inform", this_player(1)->query_cap_name()+
                " illegally attempted to call remove_read_permission("+euid+
                ", "+path+")", "cheat");
    unguarded((: write_file, "/log/CHEAT", ctime(time())+": Illegal attempt "
               "to call remove_read_permission("+euid+", "+path+").\n"
               "Backtrace: "+ back_trace() :));
    return 0;
  }
  if (remove_permission(euid, path, READ_MASK)) {
    write("Removed read permision for "+euid+" to "+path+".\n");
    return 1;
  }
  return 0;
} /* remove_read_permission() */

int remove_write_permission(string euid, string path) {
  if ( base_name(previous_object()) != "/d/admin/room/access_control" &&
       base_name(previous_object()) != "/cmds/creator/perm_it") {
    user_event( "inform", this_player(1)->query_cap_name()+
                " illegally attempted to call remove_write_permission("+euid+
                ", "+path+")", "cheat");
    unguarded((: write_file, "/log/CHEAT", ctime(time())+": Illegal attempt "
               "to call remove_write_permission("+euid+", "+path+").\n"
               "Backtrace: "+ back_trace() :));
    return 0;
  }
  if (remove_permission(euid, path, WRITE_MASK)) {
    write("Removed write permision for "+euid+" to "+path+".\n");
    return 1;
  }
  return 0;
} /* remove_write_permission() */

int remove_grant_permission(string euid, string path) {
  if ( base_name(previous_object()) != "/d/admin/room/access_control" &&
       base_name(previous_object()) != "/cmds/creator/perm_it") {
    user_event( "inform", this_player(1)->query_cap_name()+
                " illegally attempted to call remove_grant_permission("+euid+
                ", "+path+")", "cheat");
    unguarded((: write_file, "/log/CHEAT", ctime(time())+": Illegal attempt "
               "to call remove_grant_permission("+euid+", "+path+").\n"
               "Backtrace: "+ back_trace() :));
    return 0;
  }
  if (remove_permission(euid, path, GRANT_MASK)) {
    write("Removed grant permision for "+euid+" to "+path+".\n");
    return 1;
  }
  return 0;
} /* remove_grant_permission() */

int unlock_path(string path) {
  if ( base_name(previous_object()) != "/d/admin/room/access_control" &&
       base_name(previous_object()) != "/cmds/creator/perm_it") {
    user_event("inform", this_player(1)->query_cap_name()+
               " illegally attempted to call unlock_path("+path+")", "cheat");
    unguarded((: write_file, "/log/CHEAT", ctime(time())+": Illegal attempt "
               "to call unlock_path("+path+").\nBacktrace: "+ back_trace() :));
    return 0;
  }
  if (remove_permission("all", path, LOCK_MASK)) {
    write("Removed access restrictions for all to "+path+".\n");
    return 1;
  }
  return 0;
} /* unlock_path() */
// --- END [/mnt/home2/grok/lib/secure/master/permission.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/master/valid_shadow.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/master/valid_shadow.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627406   Available: 13574760
Inodes: Total: 5242880    Free: 4960133
748 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/master/valid_shadow.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627406   Available: 13574760
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: valid_shadow.c,v 1.3 2000/10/16 19:32:13 wodan Exp $
 * 
*/
/*
 * The master object is asked if it is ok to shadow object ob. Use
 * previous_object() to find out who is asking.
 *
 * In this example, we allow shadowing as long as the victim object
 * hasn't denied it with a query_prevent_shadow() returning 1.
 */
int valid_shadow(object ob) {

  if (previous_object() == ob)
    return 0;
  return (!ob->query_prevent_shadow(previous_object()) &&
          !sscanf(file_name(ob), "/secure/%*s") &&
          !sscanf(file_name(ob), "/obj/handlers/%*s") &&
          !function_exists("heart_beat" , previous_object(), 1) &&
          !sscanf(file_name(ob), "/cmds/%*s"));
} /* query_allow_shaodw() */
// --- END [/mnt/home2/grok/lib/secure/master/valid_shadow.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/master/valid_link.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/master/valid_link.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627406   Available: 13574760
Inodes: Total: 5242880    Free: 4960133
354 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/master/valid_link.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627406   Available: 13574760
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: valid_link.c,v 1.1 1998/01/06 05:12:03 ceres Exp $
 * $Log: valid_link.c,v $
 * Revision 1.1  1998/01/06 05:12:03  ceres
 * Initial revision
 * 
*/
/*
 * Hmmmm.  NOt sure what to do with the link function call.
 * Ignore for now.
 */
int valid_link(string from, string to) {
  return 0;
} /* valid_link() */
// --- END [/mnt/home2/grok/lib/secure/master/valid_link.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/master/parse_command.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/master/parse_command.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627405   Available: 13574759
Inodes: Total: 5242880    Free: 4960133
1118 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/master/parse_command.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627405   Available: 13574759
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: parse_command.c,v 1.1 1998/01/06 05:12:03 ceres Exp $
 * $Log: parse_command.c,v $
 * Revision 1.1  1998/01/06 05:12:03  ceres
 * Initial revision
 * 
*/
/*
 * Default language functions used by parse_command() in non -o mode
 */
string *parse_command_id_list() {
  return ({ "one", "thing" });
} /* parse_command_id_list() */

string *parse_command_plural_id_list() {
  return ({ "ones", "things", "them" });
} /* parse_command_plural_id_list() */

string *parse_command_adjectiv_id_list() {
  return ({ "the", "a", "an" });
} /* parse_command_adjectiv_id_list() */

string *parse_command_prepos_list() {
  return ({ "in", "on", "at", "along", "upon", "by", "under", "behind",
            "with",
            "beside", "into", "onto", "inside", "within", "from" });
} /* parse_command_prepos_list() */

string parse_command_all_word() {
  return "all";
} /* parse_command_all_word() */

string *query_word_list(string word) {
  switch (word) {
    case "preposition" :
      return parse_command_prepos_list();
    default :
      return 0;
  }
} /* query_word_list() */
// --- END [/mnt/home2/grok/lib/secure/master/parse_command.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/master/valid_read.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/master/valid_read.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627405   Available: 13574759
Inodes: Total: 5242880    Free: 4960133
1068 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/master/valid_read.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627405   Available: 13574759
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Id: valid_read.c,v 1.5 2003/04/03 18:41:38 wodan Exp $
 */

#define FILE_STATS 1

private nosave mapping read_stats;
/*
 * Read permisions for all of the objects in the game.
 * This IS fun.
 */
int valid_read(string path, mixed euid, string func) {
  mapping perms;
  string prev;
  
  if (euid == master())
    return 1;
  if ((func == "file_size") || (func == "stat"))
    return 1;
  if (path[0] != '/')
    path = "/" + path;
  if (path[<1] == 'c' && base_name(euid)[0..2] == "/w/")
    return 0; //stop cres avoiding the ftp/copy checks

#ifdef FILE_STATS 
  // Add some statistics collection.
  if(!read_stats)
    read_stats = ([ ]);
  if(previous_object()) {
    prev = base_name(previous_object());
    
    if(!read_stats[prev])
      read_stats[prev] = ([ path : 1 ]);
    else
      read_stats[prev][path] += 1;
  }
#endif  

  perms = (mapping)permission_match_path(permissions, path);
  return check_permission(euid, func, path, perms, READ_MASK);
} /* valid_read() */

mapping query_read_stats() { return copy(read_stats); }
// --- END [/mnt/home2/grok/lib/secure/master/valid_read.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/master/valid_seteuid.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/master/valid_seteuid.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627404   Available: 13574758
Inodes: Total: 5242880    Free: 4960133
829 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/master/valid_seteuid.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627404   Available: 13574758
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: valid_seteuid.c,v 1.4 2000/06/19 04:28:27 ceres Exp $
 */
int valid_euid(string str) {
  string *domains;

  switch (str) {
  case "all":
  case "Handlers":
  case "Mailer":
  case "Network":
  case "Room":
  case "Spell":
  case "WWW":
    return 1;
  default:
    domains = unguarded((: get_dir, "/d/" :));
    domains -= ({ "lost+found" });
    domains = map(domains, (: capitalize($1) :));
    if (member_array(str, domains) != -1) {
      return 1;
    }
    return 0;
  }
}

int valid_seteuid(object ob, string euid) {
  string crea;

  if (euid == "tmp") {
      return 1;
  }
   if ( !objectp( ob ) )
      return 0;
  crea = creator_file(file_name(ob));
  if (crea == "Root" || crea == "Room") {
      return 1;
  }
  return (euid == crea) || !euid;
} /* valid_seteuid() */
// --- END [/mnt/home2/grok/lib/secure/master/valid_seteuid.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/master/ed_stuff.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/master/ed_stuff.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627404   Available: 13574758
Inodes: Total: 5242880    Free: 4960133
2506 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/master/ed_stuff.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627404   Available: 13574758
Inodes: Total: 5242880    Free: 4960133
2025-03-06 17:11:29.761537259 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
// -*- LPC -*-
// /secure/master/ed_stuff.c
// Recoded for FluffOS v2019+, themed for Forgotten Realms, integrating Discworld editor mechanics
// Last updated: March 07, 2025

#include <config.h>
#include <log.h>

private mapping edit_sessions = ([ ]);

void ed_start(string file, object user) {
    if (!master()->query_adept_of_mysteries(geteuid(user)) && !master()->query_overdeity(geteuid(user))) {
        tell_object(user, "Only Adepts of the Mysteries or Overdeities may weave the Weave!\n");
        return;
    }
    if (edit_sessions[user]) {
        tell_object(user, "You are already weaving a tome. Finish or abandon it first.\n");
        return;
    }
    edit_sessions[user] = ([ "file": file, "buffer": allocate(0), "line": 0 ]);
    tell_object(user, "You begin weaving the scroll of " + file + ". Type lines, 'w' to save, 'q' to quit.\n");
}

void ed_cmd(string cmd, object user) {
    string *session = edit_sessions[user];
    string err;

    if (!session) {
        tell_object(user, "No tome is being woven. Use 'ed <file>' to begin.\n");
        return;
    }

    switch (cmd) {
        case "w":
            string content = implode(session["buffer"], "\n");
            mkdir("/w/" + geteuid(user));
            err = catch(write_file("/w/" + geteuid(user) + "/" + session["file"], content, 1));
            if (err) {
                LOG_HANDLER->log("ERROR", "Failed to save " + session["file"] + " for " + geteuid(user) + ": " + err + " at " + ctime(time()) + "\n");
                tell_object(user, "The Weave rejected your scroll! Error: " + err + "\n");
            } else {
                LOG_HANDLER->log("EVENT", "Scroll " + session["file"] + " woven by " + geteuid(user) + " at " + ctime(time()) + "\n");
                tell_object(user, "The scroll of " + session["file"] + " has been saved to the Weave.\n");
            }
            map_delete(edit_sessions, user);
            break;
        case "q":
            tell_object(user, "You abandon the weaving of " + session["file"] + ".\n");
            map_delete(edit_sessions, user);
            break;
        default:
            session["buffer"] += ({ cmd });
            session["line"]++;
            tell_object(user, "Line " + session["line"] + " added to the scroll.\n");
            break;
    }
}

void ed_end(object user) {
    if (edit_sessions[user]) {
        map_delete(edit_sessions, user);
        tell_object(user, "Your weaving session has been forcibly ended by divine will.\n");
    }
}
// --- END [/mnt/home2/grok/lib/secure/master/ed_stuff.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/master/snoop.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/master/snoop.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627403   Available: 13574757
Inodes: Total: 5242880    Free: 4960133
3256 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/master/snoop.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627403   Available: 13574757
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: snoop.c,v 1.4 1998/08/21 11:26:08 pinkfish Exp $
 * $Log: snoop.c,v $
 * Revision 1.4  1998/08/21 11:26:08  pinkfish
 * Erm, realy change the snoop log location :)
 *
 * Revision 1.3  1998/08/21 11:23:41  pinkfish
 * Move the snoop log into the admin dir.
 *
 * Revision 1.2  1998/05/05 14:09:15  pinkfish
 * Fix up qsnoop.
 *
 * Revision 1.1  1998/01/06 05:12:03  ceres
 * Initial revision
 * 
*/
int valid_snoop(object snooper, object snoopee, object pobj) {
  string verb;

  verb = this_player()->query_current_verb();
  if (snooper == snoopee) {
    tell_object(snooper, "You can't snoop yourself.\n");
    return 0;
  }
  if (snoopee && query_snoop(snoopee)) {
    tell_object(snooper,
                snoopee->query_cap_name()+" is already being snooped.\n");
    return 0;
  }
  if (snooper->query_snoopee()) {
    user_event( snooper->query_cap_name()+" stops " + verb + "ing "+
                snooper->query_snoopee()->query_name(), "snoop");
    if (!snooper->query_property("quiet snoop")) {
      tell_object((object)snooper->query_snoopee(),
                  snooper->query_cap_name()+" stops snooping you.\n");
    } else {
      snooper->remove_property("quiet snoop");
    }
    snooper->set_snoopee(0);
  }
  if (!snoopee) {
    return 1;
  }
  if (!snooper->query_creator())
    return 0;
  if (pobj == this_object()) {
    user_event( snooper->query_cap_name()+" starts qsnooping "+
                snoopee->query_name(), "snoop");
    return 1;
  }
  if (verb == "qsnoop" && query_lord(geteuid(snooper)) &&
      !query_lord(geteuid(snoopee))) {
    tell_object(snooper, "You are quiet snooping "+
                snoopee->query_cap_name()+"\n");
    snooper->add_property("quiet snoop", 1);
  } else {
    tell_object(snoopee, "You are being snooped by "+
                snooper->query_cap_name()+".\n");
  }
  unguarded( (: write_file("/d/admin/log/SNOOP", ctime(time()) + " " +
           (string)$(snooper)->query_cap_name() + " " +
           $(verb) + "s " + (string)$(snoopee)->query_cap_name() + ".\n") :) );
  snooper->set_snoopee(snoopee);
  if (verb == "qsnoop") {
    tell_object(snooper, "Please share with us the reason why you are " +
                "quiet snooping?\n: ");
    input_to("snoop_reason");
    snoop_list[snooper] = snoopee;
    return 0;
  }
  user_event( snooper->query_cap_name()+" starts " + verb + "ing "+
              snoopee->query_name(), "snoop");
  return 1;
} /* valid_snoop() */

void snoop_reason(string str) {
  object snooper;

  snooper = this_player();
  if (this_player(1) != this_player()) {
    write("Can't force people...\n");
    return ;
  }
  if (!high_programmer(geteuid(this_player()))) {
    write("Not a high programmer.\n");
    return ;
  }
  if (!snoop_list[snooper]) {
    write("The snoopee has just logged out.\n");
    return ;
  }
  if(!str) {
    write("Snoop canceled.\n");
    unguarded( (: write_file("/d/admin/log/SNOOP", "  Chickened out.\n") :) );
    return;
  }
  unguarded( (: write_file("/d/admin/log/SNOOP", "  Reason: " + $(str) +
                           "\n") :) );
  if (snoop(snooper, snoop_list[snooper]))
    write("Snoop suceeded,\n");
  else
    write("Snoop failed.\n");
} /* snoop_reason() */
// --- END [/mnt/home2/grok/lib/secure/master/snoop.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/master/valid_copy.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/master/valid_copy.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627402   Available: 13574756
Inodes: Total: 5242880    Free: 4960133
1191 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/master/valid_copy.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627402   Available: 13574756
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Id: valid_write.c,v 1.9 2000/02/06 00:20:34 turrican Exp $
 */
/*
 * This controls the copy permisions for everything in the mud.
 * It defaults to 0 if all else fails.
 * Any permisions can be overridden by the global permision giving/
 * changeing code.
 *
 * The master.c's in the domain and wizard dirs will be checked if
 * any access is done to them.  This is a very flexible system,
 * but perhaps a little hard for some people to use.
 */

int valid_copy(string path, mixed euid, string func) {
  object master_ob;
  string *bits = explode(path, "/") - ({ "", "." });
  mapping perms;
  
  perms = permission_match_path(permissions, path);
  
  if(sizeof(bits) < 2 || bits[0] == "open" || bits[0] == "doc" ||
     bits[0] == "log" || bits[0] == "mudlib" || bits[0] == "w")
    return check_permission(euid, func, path, perms, READ_MASK);
  
  master_ob = find_object("/d/" + bits[1] + "/master");

  if((master_ob && master_ob->copy_with_read(path, euid, func)) ||
     (!master_ob && master()->query_senior(euid)))
    return check_permission(euid, func, path, perms, READ_MASK);
  else
    return check_permission(euid, func, path, perms, WRITE_MASK);
}
// --- END [/mnt/home2/grok/lib/secure/master/valid_copy.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/master/create_dom_creator.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/master/create_dom_creator.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627402   Available: 13574756
Inodes: Total: 5242880    Free: 4960133
11716 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/master/create_dom_creator.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627402   Available: 13574756
Inodes: Total: 5242880    Free: 4960133
2025-03-06 16:52:07.003124845 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
// -*- LPC -*-
// /secure/master/create_dom_creator.c
// Recoded for FluffOS v2019+, themed for Forgotten Realms, integrating Discworld mechanics
// Last updated: March 07, 2025

#include <config.h>
#include <log.h>
#include <player_handler.h>

#define BACKUP_DIR "/save/mages/"

int employ_creator(string name);
int create_region(string name, string high_archon);
int dismiss_creator(string str);
int eligible_creator(object player);
void backup_vaults(string, int);
void backup_bank(string, int);
void backup_quest_library(string, int);

int create_region(string name, string high_archon) {
    string file;
    object *interactives;

    if (!(master()->query_overdeity(previous_object(-1)) &&
          sizeof((interactives = filter(previous_object(-1), (: interactive($1) :)))))) {
        write("Only an Overdeity may forge a new region in the Realms!\n");
        return 0;
    }
    if (master()->query_overdeity(capitalize(name))) {
        write("A divine name cannot be used for a mortal region...\n");
        return 0;
    }
    if (file_size("/d/" + name) != -1) {
        write("This region already exists under Mystra’s gaze (or is invalid).\n");
        return 0;
    }
    if (sizeof(explode(name, "/")) > 1) {
        write("A region name cannot contain a rift (/) in its title.\n");
        return 0;
    }
    if (!PLAYER_HANDLER->test_creator(high_archon)) {
        write("The High Archon must already be a creator blessed by the gods.\n");
        return 0;
    }
    mkdir("/d/" + name);
    master()->add_high_archon(high_archon);
    file = read_file("/std/dom/master.c");
    write_file("/d/" + name + "/master.c", "#define HIGH_ARCHON \"" + high_archon + "\"\n");
    write_file("/d/" + name + "/master.c", "#define REGION \"" + name + "\"\n");
    write_file("/d/" + name + "/master.c", file);
    file = read_file("/std/dom/common.c");
    write_file("/d/" + name + "/common.c",
               "#define REGION_TITLE \"the sacred region of " + name + "\"\n");
    write_file("/d/" + name + "/common.c", "#define HIGH_ARCHON \"" + high_archon + "\"\n");
    write_file("/d/" + name + "/common.c", "#define REGION \"" + name + "\"\n");
    write_file("/d/" + name + "/common.c", file);
    file = read_file("/std/dom/loader.c");
    write_file("/d/" + name + "/loader.c", "#define REGION \"" + name + "\"\n");
    write_file("/d/" + name + "/loader.c", file);
    master()->save_master_data();
    write("The region of " + name + " has been forged under Mystra’s blessing.\n");
    LOG_HANDLER->log("ASCENSION", "Region " + name + " forged with High Archon " +
                    high_archon + " by " + geteuid(interactives[0]) + " at " + ctime(time()) + "\n");
    return 1;
}

int employ_creator(string name) {
    object *interactives;
    string fname;

    if (!(master()->query_high_archon(previous_object(-1)) &&
          sizeof((interactives = filter(previous_object(-1), (: interactive($1) :))))))
        return 0;
    if (!PLAYER_HANDLER->test_user(name)) {
        write("This mortal does not exist in the Realms.\n");
        return 1;
    }
    if (file_size("/save/mages/" + name + "/save_file.json") > 0) {
        write("This mortal’s essence has already been preserved.\n");
        return 1;
    }
    fname = PLAYER_HANDLER->query_player_file_name(name);
    if (file_size(fname + ".json.gz") > 0) {
        unguarded((: uncompress_file, fname + ".json.gz" :));
    }
    mkdir(BACKUP_DIR + name);
    unguarded((: cp, fname + ".json", "/save/mages/" + name + "/save_file.json" :));
    backup_vaults(name, 0);
    backup_bank(name, 0);
    backup_quest_library(name, 0);
    if (find_player(name)) {
        find_player(name)->set_creator(1);
        find_player(name)->save();
        tell_object(find_player(name), "You have been blessed by Mystra as a creator by " +
                    capitalize(geteuid(interactives[0])) + ".\n");
        tell_object(find_player(name), "Quit and return to the Realms to wield your new powers.\n");
        tell_object(find_player(name), "Seek the tomes of Waterdeep, especially /doc. "
                    "\"help creator\" will guide your path.\n");
        tell_object(find_player(name), "Serve the Realms with wisdom and honor, young creator.\n");
    } else {
        unguarded((: write_file, fname + ".json",
                     json_encode(([ "creator": 1, "home_dir": "/w/" + name ])) :));
    }
    unguarded((: compress_file, fname + ".json.gz" :));
    if (file_size("/w/" + name) == -1) {
        unguarded((: mkdir, "/w/" + name :));
        unguarded((: write_file, "/w/" + name + "/workroom.c",
                     "#define CREATOR \"" + name + "\"\n" :));
        unguarded((: write_file, "/w/" + name + "/workroom.c",
                     read_file("/std/creator/workroom.c") :));
        unguarded((: cp, "/std/creator/mage_kit.json", "/w/" + name + "/mage_kit.json" :));
    }
    LOG_HANDLER->log("ASCENSION", sprintf("%s: %s blessed as a creator by %s\n", ctime(time()), name,
                                           interactives[0]->query_name()));
    write(capitalize(name) + " has been blessed as a creator of the Realms.\n");
    PLAYER_HANDLER->remove_cache_entry(name);
    return 2;
}

int dismiss_creator(string str) {
    string name, reason, fname, save_file;
    object *interactives;

    if (!(master()->query_high_archon(previous_object(-1)) &&
          sizeof((interactives = filter(previous_object(-1), (: interactive($1) :))))))
        return 0;
    if (sscanf(str, "%s %s", name, reason) != 2) {
        notify_fail("You must provide a reason for this divine dismissal!\n");
        return 0;
    }
    if (!PLAYER_HANDLER->test_creator(name)) {
        return notify_fail(name + " has not been blessed as a creator!\n");
    }
    if (master()->query_high_archon(name)) {
        write("A High Archon cannot be dismissed by mortal means.\n");
        return 0;
    }
    LOG_HANDLER->log("DISMISSAL", sprintf("%s: %s stripped of creator status by %s\nReason: %s\n",
                                           ctime(time()), name, interactives[0]->query_name(), reason));
    fname = PLAYER_HANDLER->query_player_file_name(name);
    if (find_player(name)) {
        find_player(name)->set_creator(0);
        find_player(name)->save();
        tell_object(find_player(name), "Your creator powers have been revoked by " +
                    capitalize(interactives[0]->query_name()) + ".\n");
        find_player(name)->quit();
        if (file_size(fname + ".json.gz") != -1) {
            unguarded((: uncompress_file, fname + ".json.gz" :));
        }
    } else {
        if (file_size(fname + ".json.gz") != -1) {
            unguarded((: uncompress_file, fname + ".json.gz" :));
        }
        unguarded((: write_file, fname + ".json",
                     json_encode(([ "creator": 0, "home_dir": 0 ])) :));
        unguarded((: compress_file, fname + ".json" :));
    }
    write(capitalize(name) + " has been stripped of their creator status.\n");
    save_file = "/save/mages/" + name + "/save_file.json";
    if (file_size(save_file) == -1) {
        save_file = BACKUP_DIR + name + ".json";
    }
    backup_vaults(name, 1);
    backup_bank(name, 1);
    backup_quest_library(name, 1);
    if (file_size(save_file) > 0) {
        unguarded((: write_file, save_file,
                     json_encode(([ "last_log_on": time() ])) :));
        unguarded((: cp, save_file, fname + ".json" :));
        unguarded((: rm, save_file :));
        unguarded((: rm, fname + ".json.gz" :));
        unguarded((: compress_file, fname + ".json" :));
    }
    if (file_size("/w/" + name) == -2) {
        unguarded((: rename, "/w/" + name, "/w/.old_mages/" + name :));
    }
    rm(save_file);
    rmdir(BACKUP_DIR + name);
    PLAYER_HANDLER->remove_cache_entry(name);
    return 1;
}

int eligible_creator(object player) {
    int age, level;
    string age_str, reasoning;

    reasoning = "  The path to creation in the Forgotten Realms is not a birthright. Prove your worth through deeds.\n"
                "  Seek the favor of the High Archons by reporting arcane anomalies or contributing to the libraries of Waterdeep.\n"
                "  Those who cause chaos will not be chosen. Wielding the Weave is a sacred responsibility.\n"
                "  Dedicate time to the Realms to show your loyalty to Mystra’s cause.\n\n";

    age = -(player->query_time_on());
    level = player->query_level();

    if (level >= 150 && age > 432000) { // Matches Discworld wiki criteria
        write("  You have met the minimum requirements to seek Mystra’s blessing as a creator in the Forgotten Realms.\n"
              "  You must now pass the judgment of the High Archons.\n" + reasoning);
        return 1;
    }

    age_str = "";
    if (age > 86400) age_str += sprintf("%d day", age / 86400);
    if (age > 172800) age_str += "s";
    if (age % 86400 > 3600) {
        if (age > 86400) age_str += " and ";
        age_str += sprintf("%d hour", (age % 86400) / 3600);
    }
    if (age % 86400 > 7200) age_str += "s";

    write("  To seek Mystra’s blessing as a creator in the Forgotten Realms, you must be level 150 in your guild and at least five days old.\n"
          "  You are level " + level + ", and your age is " + age_str + ".\n" + reasoning);
    return 0;
}

private void backup_vaults(string name, int restore) {
    string base = "/save/vaults/";
    string creator_dir = BACKUP_DIR + name + "/vaults/";
    string *vaults, *tmp;
    string file;

    if (!restore) {
        vaults = get_dir(base);
        mkdir(creator_dir);
        foreach (string vault in vaults) {
            file = base + vault + "/" + name + ".json";
            if (file_size(file) != -1) {
                cp(file, creator_dir + "/" + vault + ".json");
            }
        }
    } else {
        if (file_size(creator_dir) == -1) return;
        vaults = get_dir(base);
        foreach (string vault in vaults) {
            file = base + vault + "/" + name + ".json";
            if (file_size(file) != -1) rm(file);
        }
        vaults = get_dir(creator_dir);
        foreach (string vault in vaults) {
            tmp = explode(vault, ".");
            cp(creator_dir + vault, base + tmp[0] + "/" + name + ".json");
            rm(creator_dir + vault);
        }
        rmdir(creator_dir);
    }
}

private void backup_bank(string name, int restore) {
    string base = "/save/bank_accounts/";
    string bank_file = base + name[0..0] + "/" + name + ".json";
    string bank_dir = BACKUP_DIR + name + "/bank_account/";
    string saved_file;

    if (!restore) {
        mkdir(bank_dir);
        if (file_size(bank_file) == -1) return;
        cp(bank_file, bank_dir + name + ".json");
    } else {
        saved_file = bank_dir + name + ".json";
        if (file_size(bank_dir) == -1) return;
        rm(bank_file);
        if (file_size(saved_file) == -1) return;
        cp(saved_file, bank_file);
        rm(saved_file);
        rmdir(bank_dir);
    }
}

private void backup_quest_library(string name, int restore) {
    string base = "/save/library/";
    string library_file = base + name[0..0] + "/" + name + ".json";
    string library_dir = BACKUP_DIR + name + "/quest_library/";
    string saved_file;

    if (!restore) {
        mkdir(library_dir);
        if (file_size(library_file) == -1) return;
        cp(library_file, library_dir + name + ".json");
    } else {
        saved_file = library_dir + name + ".json";
        if (file_size(library_dir) == -1) return;
        rm(library_file);
        if (file_size(saved_file) == -1) return;
        cp(saved_file, library_file);
        rm(saved_file);
        rmdir(library_dir);
    }
}
// --- END [/mnt/home2/grok/lib/secure/master/create_dom_creator.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/master/valid_socket.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/master/valid_socket.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627399   Available: 13574753
Inodes: Total: 5242880    Free: 4960133
585 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/master/valid_socket.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627399   Available: 13574753
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: valid_socket.c,v 1.1 1998/01/06 05:12:03 ceres Exp $
 * $Log: valid_socket.c,v $
 * Revision 1.1  1998/01/06 05:12:03  ceres
 * Initial revision
 * 
*/
int valid_socket(object ob, string func, mixed *info) {
  string fname;

  fname = file_name(ob);
  if (func != "external") {
    switch (explode(fname, "/")[0]) {
      case "net" :
      case "secure" :
        return 1;
    }
  } else {
    if (fname[0..11] == "/secure/cmds" ||
        fname[0..19] == "/secure/rcs_handler")
      return 1;
  }
  
  return 0;
} /* valid_socket() */
// --- END [/mnt/home2/grok/lib/secure/master/valid_socket.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/master/valid_to_c.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/master/valid_to_c.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627398   Available: 13574752
Inodes: Total: 5242880    Free: 4960133
527 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/master/valid_to_c.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627398   Available: 13574752
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: valid_to_c.c,v 1.1 1998/01/06 05:12:03 ceres Exp $
 * $Log: valid_to_c.c,v $
 * Revision 1.1  1998/01/06 05:12:03  ceres
 * Initial revision
 * 
*/
int valid_compile_to_c() {
  if (previous_object() == this_object())
    return 1;
  if (previous_object() != find_object("/secure/cmds/creator/compile"))
    return 0;
  if (!interactive(previous_object(1)))
    return 0;
  if (!this_object()->query_lord(previous_object(-1)))
    return 0;
  return 1;
} /* valid_compile_to_c() */
// --- END [/mnt/home2/grok/lib/secure/master/valid_to_c.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/master/valid_exec.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/master/valid_exec.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627398   Available: 13574752
Inodes: Total: 5242880    Free: 4960133
885 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/master/valid_exec.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627398   Available: 13574752
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: valid_exec.c,v 1.2 2003/03/22 04:56:33 ceres Exp $
 * $Log: valid_exec.c,v $
 * Revision 1.2  2003/03/22 04:56:33  ceres
 * Tried to get nlogin to work
 *
 * Revision 1.1  1998/01/06 05:12:03  ceres
 * Initial revision
 * 
*/
/*
 * Function name:   valid_exec
 * Description:     Checks if a certain 'program' has the right to use exec()
 * Arguments:       name: Name of the 'program' that attempts to use exec()
 *                        Note that this is different from file_name(),
 *                        Programname is what 'function_exists' returns.
 *                  NOTE, the absence of a leading slash in the name.
 * Returns:         True if exec() is allowed.
 */
int valid_exec(string name) {
  if (name == "secure/login.c")
    return 1;

  if(name == "secure/nlogin.c")
    return 1;
  
  return 0;
} /* valid_exec() */
// --- END [/mnt/home2/grok/lib/secure/master/valid_exec.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/master/crash.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/master/crash.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627397   Available: 13574751
Inodes: Total: 5242880    Free: 4960133
2500 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/master/crash.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627397   Available: 13574751
Inodes: Total: 5242880    Free: 4960133
2025-03-06 16:00:04.404437549 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
// -*- LPC -*-
// /secure/master/crash.c
// Recoded for FluffOS v2019+, themed for Forgotten Realms, integrating Discworld crash mechanics
// Last updated: March 07, 2025

#include <config.h>
#include <log.h>
#include <player_handler.h>

void crash(string file) {
    object ob;
    string err;

    if (!file || file == "") {
        LOG_HANDLER->log("CRASH", "Divine disturbance detected at " + ctime(time()) + " - No file specified.\n");
        return;
    }

    ob = find_object(file);
    if (ob) {
        err = catch(destruct(ob));
        if (err) {
            LOG_HANDLER->log("CRASH", "Failed to purge " + file + " due to: " + err + " at " + ctime(time()) + "\n");
        } else {
            LOG_HANDLER->log("CRASH", "Purged " + file + " after divine intervention at " + ctime(time()) + "\n");
        }
    } else {
        LOG_HANDLER->log("CRASH", "No object found at " + file + " for divine cleansing at " + ctime(time()) + "\n");
    }
}

void restore_crash(string file) {
    mixed data;
    string save_file = "/save/crash/" + file + ".json";

    if (file_size(save_file) <= 0) {
        LOG_HANDLER->log("CRASH", "No saved state for " + file + " to restore from divine archives at " + ctime(time()) + "\n");
        return;
    }

    data = json_decode(read_file(save_file));
    if (mappingp(data)) {
        object ob = clone_object(file);
        if (ob) {
            ob->restore_from_data(data); // Assume a restore_from_data method exists
            LOG_HANDLER->log("CRASH", "Restored " + file + " from divine archives at " + ctime(time()) + "\n");
        } else {
            LOG_HANDLER->log("CRASH", "Failed to resurrect " + file + " at " + ctime(time()) + "\n");
        }
    } else {
        LOG_HANDLER->log("CRASH", "Corrupted divine record for " + file + " at " + ctime(time()) + "\n");
    }
}

void save_crash(string file) {
    object ob;
    mapping data;

    ob = find_object(file);
    if (!ob) {
        LOG_HANDLER->log("CRASH", "No object " + file + " to save from divine wrath at " + ctime(time()) + "\n");
        return;
    }

    data = ob->save_data(); // Assume a save_data method exists
    if (mappingp(data)) {
        mkdir("/save/crash");
        write_file("/save/crash/" + file + ".json", json_encode(data), 1);
        LOG_HANDLER->log("CRASH", "Saved " + file + " to divine archives at " + ctime(time()) + "\n");
    } else {
        LOG_HANDLER->log("CRASH", "Failed to archive " + file + " at " + ctime(time()) + "\n");
    }
}
// --- END [/mnt/home2/grok/lib/secure/master/crash.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/master/creator_file.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/master/creator_file.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627397   Available: 13574751
Inodes: Total: 5242880    Free: 4960133
2021 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/master/creator_file.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627397   Available: 13574751
Inodes: Total: 5242880    Free: 4960133
2025-03-06 16:59:07.466514402 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
// -*- LPC -*-
// /secure/master/creator_file.c
// Recoded for FluffOS v2019+, themed for Forgotten Realms, integrating Discworld mechanics
// Last updated: March 07, 2025

#include <config.h>
#include <log.h>

varargs mixed creator_file(string file, int author) {
    if (!file || !stringp(file)) {
        LOG_HANDLER->log("ERROR", "Invalid file path in creator_file at " + ctime(time()) + "\n");
        return "NOONE";
    }
    string *str = explode(file, "/") - ({ "" });
    if (sizeof(str) < 2) return 0;

    switch (str[0]) {
        case "secure":
            return get_root_uid();
        case "obj":
            if (sizeof(str) > 2 && str[1] == "secure") return "ims";
        case "global":
        case "std":
        case "cmds":
        case "room":
            return get_bb_uid();
        case "net":
            return "Network";
        case "www":
            if (sizeof(str) > 2 && str[1] == "secure") return "Root";
            return "WWW";
        case "tmp":
            if (str[1] != "mon-shad") return 0;
            return "monster";
        case "failsafe":
            return "failsafe";
        case "d": // Regions (was domains)
            if (sizeof(str) < 3) return 0;
            if (!author || member_array(master()->query_domains(), str) == -1)
                return capitalize(str[1]);
            return ("/d/" + str[1] + "/master")->author_file(str);
        case "w": // Creator workspaces
            if (sizeof(str) < 3) {
                if (str[1] == "common" || str[1] == "development" || str[1] == "meeting")
                    return "arcane-council"; // Themed: was mage-council
                return 0;
            }
            return str[1];
    }
    return 0;
}

mixed author_file(mixed bing) {
    return creator_file(bing, 1);
}

mixed region_file(mixed bing) { // Themed: was domain_file
    string str = creator_file(bing);
    if (!str) return str;
    if (str[0] >= 'A' && str[0] <= 'Z') return str;
    return "Mage"; // General fallback for creators
}
// --- END [/mnt/home2/grok/lib/secure/master/creator_file.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/master/valid_override.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/master/valid_override.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627396   Available: 13574750
Inodes: Total: 5242880    Free: 4960133
666 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/master/valid_override.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627396   Available: 13574750
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: valid_override.c,v 1.2 2002/05/05 17:54:08 wodan Exp $
 * $Log: valid_override.c,v $
 * Revision 1.2  2002/05/05 17:54:08  wodan
 * Added the third argument to valid_override.
 *
 * Revision 1.1  1998/01/06 05:12:03  ceres
 * Initial revision
 * 
*/
int valid_override(string file, string func, string filename) {
  string *bing;

  bing = explode(file, "/") - ({ "", "." });
  switch (bing[0]) {
    case "secure" :
      return 1;
    case "std" :
    case "obj" :
    case "simul_efun" :
    case "global" :
    case "cmds" :
      return (func != "snoop");
    default :
      return 0;
  }
} /* valid_override() */
// --- END [/mnt/home2/grok/lib/secure/master/valid_override.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/master/query_pl_level.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/master/query_pl_level.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627396   Available: 13574750
Inodes: Total: 5242880    Free: 4960133
860 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/master/query_pl_level.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627396   Available: 13574750
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: query_pl_level.c,v 1.1 1998/01/06 05:12:03 ceres Exp $
 * $Log: query_pl_level.c,v $
 * Revision 1.1  1998/01/06 05:12:03  ceres
 * Initial revision
 * 
*/
/*
 * There are several occasions when the game driver wants to check if
 * a player has permission to specific things.
 *
 * These types are implemented so far:
 * "trace":		If the player is allowed to use tracing.
 * "wizard":            Is the player considered at least a "minimal" wizard?
 * "error messages":    Is the player allowed to get run time error messages?
 */

int query_player_level( string what ) {
   if ( !this_player() )
      return 0;
   switch ( what ) {
      case "error messages" :
         return 1;
      case "trace" :
      case "wizard" :
         return (int)this_player()->query_creator();
   }
} /* query_player_level() */
// --- END [/mnt/home2/grok/lib/secure/master/query_pl_level.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/master/logging.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/master/logging.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627395   Available: 13574749
Inodes: Total: 5242880    Free: 4960133
2712 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/master/logging.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627395   Available: 13574749
Inodes: Total: 5242880    Free: 4960133
2025-03-06 17:38:35.328905131 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
// -*- LPC -*-
// /secure/master/logging.c
// Recoded for FluffOS v2019+, themed for Forgotten Realms, integrating Discworld mechanics
// Last updated: March 07, 2025

#include <config.h>
#include <log.h>

// New Features:
// - log_event: Records an event in the Weave's chronicles (Input: string category, string message, Output: void) - Added by Grok3
// - log_error: Logs an error to the divine ledger (Input: string category, string message, Output: void) - Added by Grok3
// Usage Notes: Call log_event("EVENT", "Message\n") for events; log_error("ERROR", "Error details\n") for errors.
//              Logs are stored in /log/ with rotation; use master()->save_log_data() to persist.

private mapping log_categories = ([
    "EVENT": "/log/WeaveChronicles",
    "ERROR": "/log/DivineLedger",
    "CHEAT": "/log/ArcaneTransgressions"
]);

private int max_log_size = 1000000; // 1MB max per log file
private string log_dir = "/log/";

void create() {
    mkdir(log_dir);
    foreach (string category, string file in log_categories) {
        if (file_size(log_dir + file) == -1) {
            write_file(log_dir + file, "=== " + category + " Log - " + ctime(time()) + " ===\n");
        }
    }
}

void log_event(string category, string message) {
    string log_file = log_categories[category];
    if (!log_file) {
        log_file = log_categories["EVENT"]; // Default to event log
    }
    rotate_log(log_file);
    write_file(log_dir + log_file, ctime(time()) + ": " + message, 1);
}

void log_error(string category, string message) {
    string log_file = log_categories[category];
    if (!log_file) {
        log_file = log_categories["ERROR"]; // Default to error log
    }
    rotate_log(log_file);
    write_file(log_dir + log_dir + log_file, ctime(time()) + " [ERROR]: " + message, 1);
}

private void rotate_log(string log_file) {
    string full_path = log_dir + log_file;
    int size = file_size(full_path);

    if (size > max_log_size) {
        string backup = full_path + "." + time();
        unguarded((: rename, full_path, backup :));
        write_file(full_path, "=== New " + (log_file == "/log/WeaveChronicles" ? "Weave Chronicles" : "Divine Ledger") + " - " + ctime(time()) + " ===\n");
        LOG_HANDLER->log("EVENT", "Rotated " + log_file + " to " + backup + " at " + ctime(time()) + "\n");
    }
}

void save_log_data() {
    mapping log_data = ([ ]);
    foreach (string category, string file in log_categories) {
        string content = read_file(log_dir + file) || "";
        log_data[category] = content;
    }
    write_file("/save/logs.json", json_encode(log_data), 1);
    LOG_HANDLER->log("EVENT", "Log data saved to /save/logs.json at " + ctime(time()) + "\n");
}
// --- END [/mnt/home2/grok/lib/secure/master/logging.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/master/file_exists.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/master/file_exists.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627394   Available: 13574748
Inodes: Total: 5242880    Free: 4960133
971 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/master/file_exists.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627394   Available: 13574748
Inodes: Total: 5242880    Free: 4960133
2025-03-06 17:27:04.586204484 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
// -*- LPC -*-
// /secure/master/file_exists.c
// Recoded for FluffOS v2019+, themed for Forgotten Realms, integrating Discworld mechanics
// Last updated: March 07, 2025

#include <config.h>
#include <log.h>

// New Features:
// - file_exists: Checks if a tome exists in the Weave (Input: string path, Output: int) - Added by Grok3
// Usage Notes: Call file_exists("/path/to/tome") to check existence; returns 1 if found, 0 if not.
int file_exists(string path) {
    int size;

    if (!path || !stringp(path)) {
        LOG_HANDLER->log("ERROR", "Invalid path sought in the Weave at " + ctime(time()) + "\n");
        return 0;
    }

    size = file_size(path);
    if (size > 0 || size == -2) { // File or directory exists
        LOG_HANDLER->log("EVENT", "Tome " + path + " found in the Weave at " + ctime(time()) + "\n");
        return 1;
    }
    LOG_HANDLER->log("EVENT", "Tome " + path + " not found in the Weave at " + ctime(time()) + "\n");
    return 0;
}
// --- END [/mnt/home2/grok/lib/secure/master/file_exists.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/master/simul_efun.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/master/simul_efun.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627394   Available: 13574748
Inodes: Total: 5242880    Free: 4960133
608 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/master/simul_efun.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627394   Available: 13574748
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: simul_efun.c,v 1.1 1998/01/06 05:12:03 ceres Exp $
 * $Log: simul_efun.c,v $
 * Revision 1.1  1998/01/06 05:12:03  ceres
 * Initial revision
 * 
*/
/*
 * Give a path to a simul_efun file. Observe that it is a string returned,
 * not an object. But the object has to be loaded here. Return 0 if this
 * feature isn't wanted.
 */
string get_simul_efun() {
  string fname;
  fname = "/secure/simul_efun";
  if (catch(call_other(fname, "??"))) {
    write("Failed to load " + fname + "\n");
    shutdown();
    return 0;
  }
  return fname;
} /* get_simul_efun() */
// --- END [/mnt/home2/grok/lib/secure/master/simul_efun.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/master/compile_to_c.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/master/compile_to_c.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627394   Available: 13574748
Inodes: Total: 5242880    Free: 4960133
302 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/master/compile_to_c.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627394   Available: 13574748
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: compile_to_c.c,v 1.1 1998/01/06 05:12:03 ceres Exp $
 * $Log: compile_to_c.c,v $
 * Revision 1.1  1998/01/06 05:12:03  ceres
 * Initial revision
 * 
*/

void compile_everything() {
  generate_source(load_file("compile_to_c"));
} /* compile_everything() */
// --- END [/mnt/home2/grok/lib/secure/master/compile_to_c.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/master/preload.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/master/preload.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627393   Available: 13574747
Inodes: Total: 5242880    Free: 4960133
554 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/master/preload.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627393   Available: 13574747
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: preload.c,v 1.2 2002/04/14 22:00:27 wodan Exp $
 * 
 */

protected string *load_file(string fname) {
  string *bits;
  string str;

  str = read_file("/secure/config/"+fname);
  if (!str)
    return ({ });
  bits = explode(str, "\n");
  bits = filter(bits, (: $1[0] != '#' :));
  return bits;
}

string *epilog() {
  return load_file("preload");
}

void preload(string file) {
  mixed e;

  printf("Preloading: "+file+".\n");
  if ((e = catch(load_object(file)))) {
    printf("            "+e+"\n");
  }
}

// --- END [/mnt/home2/grok/lib/secure/master/preload.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/master/valid_database.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/master/valid_database.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627393   Available: 13574747
Inodes: Total: 5242880    Free: 4960133
277 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/master/valid_database.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627393   Available: 13574747
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
mixed valid_database(object ob, string action, mixed *info){
  string obname = base_name(ob);
  switch (obname){
  case "/obj/handlers/clusters":
  case "/obj/handlers/map":
  case "/cmds/creator/osql":
  case "/cmds/errors_base":
    return -1;
  default:
    return 0;
  }
}
// --- END [/mnt/home2/grok/lib/secure/master/valid_database.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/master/valid_bind.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/master/valid_bind.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627393   Available: 13574747
Inodes: Total: 5242880    Free: 4960133
1066 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/master/valid_bind.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627393   Available: 13574747
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: valid_bind.c,v 1.4 2002/01/22 22:39:23 wodan Exp $
 * $Log: valid_bind.c,v $
 * Revision 1.4  2002/01/22 22:39:23  wodan
 * small optimisation
 *
 * Revision 1.3  2000/02/18 17:15:54  wodan
 * security fix
 *
 * Revision 1.2  1998/10/02 04:02:59  pinkfish
 * Updated to work with the new virtual objects.
 *
 * Revision 1.1  1998/01/06 05:12:03  ceres
 * Initial revision
 * 
 */

private nosave object _simul_efun;

int valid_bind(object binder, object old_owner, object new_owner) {
   string *womble;
   string fname;

   if(!objectp(_simul_efun)) {
     _simul_efun = find_object("/secure/simul_efun");
   }
     
   if(binder == _simul_efun) {
      return 1;
   }

   if(file_name(new_owner)[0..7] == "/secure/") {
      return 0;
   }

   if(interactive(new_owner)) {
      return 0;
   }
   
   womble = explode(file_name(old_owner), "/");
   if (sizeof(womble) < 1) {
      return 0;
   }
   fname = womble[<1];
   if (fname[0] != '.') {
      return 0;
   }
   return old_owner == binder;
} /* valid_bind() */
// --- END [/mnt/home2/grok/lib/secure/master/valid_bind.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/master/valid_hide.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/master/valid_hide.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627392   Available: 13574746
Inodes: Total: 5242880    Free: 4960133
277 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/master/valid_hide.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627392   Available: 13574746
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: valid_hide.c,v 1.1 1998/01/06 05:12:03 ceres Exp $
 * $Log: valid_hide.c,v $
 * Revision 1.1  1998/01/06 05:12:03  ceres
 * Initial revision
 * 
*/
int valid_hide(object ob) {
  return query_lord(geteuid(ob));
} /* valid_hide() */
// --- END [/mnt/home2/grok/lib/secure/master/valid_hide.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/master/directory_assignments.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/master/directory_assignments.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627392   Available: 13574746
Inodes: Total: 5242880    Free: 4960133
3825 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/master/directory_assignments.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627392   Available: 13574746
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is the file which handles assigning creators to specific
 * directories for bug control.
 * @author Pinkfish
 * @started Tue Mar  4 13:40:44 PST 2003
 */
#include <player_handler.h>
#include <error_handler.h>

private mapping _directory_assignments = ([ ]);

int query_leader(string name);

/**
 * Finds the person assigned to the specific directory.  It will climb
 * up the directory tree looking for who to assign the directory too.
 * @param dir the directory to find assignments in
 * @return the array of people assigned to the directory
 */
string* query_assigned_to_directory(string dir) {
   string *bits;
   string str;
   int i;

   bits = explode(dir, "/") - ({ "" });
   switch (bits[0]) {
   case "w" :
      if (sizeof(bits) > 1 && file_size("/d/" + bits[1]) == -2) {
         return ({ bits[1] });
      }
   case "d" :
      if (sizeof(bits) > 1 && file_size("/d/" + bits[1]) == -2) {
         return ("/d/" + bits[1] + "/master")->query_assigned_to_directory(bits);
      }
   default :
      i = sizeof(bits) - 1;
      do {
         str = "/" + implode(bits[0..<i], "/");
         i--;
      } while (i >= 0 && !_directory_assignments[str]);
      if (_directory_assignments[str]) {
         return _directory_assignments[str];
      }
      return ({ });
   }
}

/**
 * This method allows a specific person to be assigned to the given
 * directory.
 * @param dir the directory to assign someone too
 * @param people the people who are assigned to the directory
 */
int assign_people_to_directory(string dir, string* people) {
   string* new_people;
   string* dirs;

   if ( !sizeof( filter( previous_object( -1 ), (: interactive( $1 ) :) ) ) ) {
      user_event( "inform", this_player()->query_name() +
            " illegally attempted to call assign_person_to_directory( "+ dir +
            ", " + query_multiple_short(people) +
            " )", "cheat" );
      unguarded((: write_file, "/log/CHEAT", ctime( time() ) +
            ": illegal attempt to call assign_person_to_directory( "+ dir +
            ", " + query_multiple_short(people) +
            " ).\n"+ back_trace() :));
      return 0;
   }
   new_people = filter(people, (: PLAYER_HANDLER->test_creator( $1 ) ||
                                  $1 == ERROR_ASSIGNED_NO_ONE :));
   if ( sizeof(new_people) == sizeof(people) &&
        query_leader( previous_object(-1) ) &&
        file_size(dir) == -2) {
      dirs = explode(dir, "/") - ({ "" });
      if (sizeof(dirs) > 1 && dirs[0] == "d" &&
          file_size("/d/" + dirs[1]) == -2) {
         return ("/d/" + dirs[1] + "/master")->assign_people_to_directory(dir, people);
      } else {
         if (!_directory_assignments) {
            _directory_assignments = ([ ]);
         }
         // Set back to nothing.
         if (sizeof(people) == 1 && people[0] == ERROR_ASSIGNED_NO_ONE) {
            people = ({ });
         }
         if (sizeof(people)) {
            if (sizeof(_directory_assignments[dir])) {
               ERROR_HANDLER->do_update_directory_assignment(_directory_assignments[dir][0], people[0], dir, (: 1 :));
            } else {
               ERROR_HANDLER->do_update_directory_assignment(ERROR_ASSIGNED_NO_ONE, people[0], dir, (: 1 :));
            }
            _directory_assignments[dir] = people;
         } else {
            map_delete(_directory_assignments, dir);
         }
         save_object("/secure/master");
      }
      return 1;
   }
   debug_printf("Bad pumpkins. %O %O\n", new_people, people);
   return 0;
}

/**
 * This method returns all the current assignments from directory to the
 * people who are looking after them.
 * @return the directory assignment mapping
 */
mapping query_directory_assignments() {
   if (!_directory_assignments) {
      return ([ ]);
   }
   return copy(_directory_assignments);
}
// --- END [/mnt/home2/grok/lib/secure/master/directory_assignments.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/master/valid_write.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/master/valid_write.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627391   Available: 13574745
Inodes: Total: 5242880    Free: 4960133
5496 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/master/valid_write.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627391   Available: 13574745
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Id: valid_write.c,v 1.10 2003/04/19 01:36:14 pinkfish Exp $
 */
/*
 * This controls the write permisions for everything in the mud.
 * It defaults to 0 if all else fails.
 * Any permisions can be overridden by the global permision giving/
 * changeing code.
 *
 * The master.c's in the domain and wizard dirs will be checked if
 * any access is done to them.  This is a very flexible system,
 * but perhaps a little hard for some people to use.
 */

//#define DEBUG

#define WRITE_FILE_STATS 1

private nosave mapping write_stats;

int valid_write(string path, mixed euid, string func) {
  mapping perms;
  string tmp;
  string *bits, rcspath; 
  string prev;

  if (path && (path[<2..] == ",v")) {
    /* No matter what, never allow direct manipulation of RCS files
     * from the mudlib.  If there is a problem, someone can fix it
     * with the shell account.
     */
    return 0;
  }

  if (func == "remove_file" && path[0..13] == "/save/players/") {
     // Log this for now.
     if (objectp(euid)) {
        log_file("/d/admin/log/DELETE_PLAYER", "Deleting " +
                path + " by " + file_name(previous_object()) +
                "->" + call_stack(2)[0] + "\n");
     } else {
        log_file("/d/admin/log/DELETE_PLAYER", "Deleting " +
                path + " by " + euid + " (" + file_name(previous_object()) +
                "->" + call_stack(2)[0] + ")\n");
     }
  }

  if (euid == master())
    return 1;
  if (path[0] != '/')
    path = "/" + path;

#ifdef WRITE_FILE_STATS 
  // Add some statistics collection.
  if(!write_stats)
    write_stats = ([ ]);
  if(previous_object()) {
    prev = base_name(previous_object());
    
    if(!write_stats[prev])
      write_stats[prev] = ([ path : 1 ]);
    else
      write_stats[prev][path] += 1;
  }
#endif  

  bits = explode(path, "/");
  
  // Added by Ceres to do locking of files for RCS
  // The checks are as follows:
  // If they have an EUID and
  // the file exists and
  // it's not rcsout trying to do the job (that would be bad :) and
  // it's not the ftp daemon and
  // its not a .o file (they aren't in RCS so don't bother checking) and
  // its not a log, save or player file (don't bother checking for these either
  // then lets go check the RCS directory and see if it's in there.
  if(euid && 
     (file_size(path) > 0) &&
     (!previous_object() ||
        file_name(previous_object()) != "/secure/cmds/creator/rcso_ut") &&
     (!objectp(euid) || file_name(euid) != "/secure/ftpd") &&
     path[<2..] != ".o" &&
     (bits[0] != "log" && bits[0] != "save" && bits[0] != "players") ) {
 

    // Figure out the RCS filename and check if it exists.
    if(sizeof(bits) > 2) {
      rcspath = "/" + implode(bits[0..sizeof(bits)-2], "/") + "/RCS/";
    } else if(sizeof(bits) == 2) {
      rcspath = "/" + bits[0] + "/RCS/";
    } else
      rcspath = "/";

    rcspath += bits[sizeof(bits)-1] + ",v";

    if(file_size(rcspath) > 0) { 
#ifdef DEBUG
      if(stringp(euid))
        tell_object(find_player("ceres"), sprintf("Checking perms: %s [%s](string)\n", rcspath, euid ));
      else if(objectp(euid))
        tell_object(find_player("ceres"), sprintf("Checking perms: %s [%s](object)\n", rcspath, file_name(euid )));
      else
        tell_object(find_player("ceres"), sprintf("Checking perms: %s [%O](unknown)\n", rcspath, euid ));
#endif
      tmp = read_file(rcspath, 4, 1);
      if(tmp == "locks\n") { // we've found a lock
        string lockname ;
        tmp = read_file(rcspath, 5, 1);
        sscanf(tmp, "\t%s:", lockname);

        if((objectp(euid) && euid->query_name() != lockname) ||
           (stringp(euid) && euid != lockname)) {
          int i, ok;
          object *stack;
          
          // Ok, so the euid doesn't match. Now we have to check the previous
          // object just in case.
          stack = previous_object(-1);
          i = sizeof(stack);
          while(--i) {
            if(geteuid(stack[i]) == lockname) {
              ok = 1;
            }
          }
          if(!ok) {
            // locked by someone else or no lock exists -- DENIED
#ifdef DEBUG      
          if(objectp(euid))
            tell_object(find_player("ceres"), sprintf("Write denied to %O or %O Locked by %s\n", euid, previous_object(-1), lockname));
          else
            tell_object(find_player("ceres"), sprintf("Write denied to %s or %O Locked by %s\n", euid, previous_object(-1), lockname));
#endif
          return 0;
          
          } else {
#ifdef DEBUG      
            tell_object(find_player("ceres"), "Write allowed to "+geteuid(stack[i])+" Locked by:"+lockname +" on file "+path+"\n");
#endif
            
          }
        } else {
          // continue with normal security checks.
#ifdef DEBUG
          if(objectp(euid))
            tell_object(find_player("ceres"), sprintf("Write allowed by %O Locked by %s\n", euid, lockname));
          else
            tell_object(find_player("ceres"), sprintf("Write allowed by %s Locked by %s\n", euid, lockname));
#endif
        }
      } else {
#ifdef DEBUG
          tell_object(find_player("ceres"), "No locks found\n");
#endif  
          return 0;
      }
    }
  }
  // end of code added by Ceres
  
  perms = permission_match_path(permissions, path);
  return check_permission(euid, func, path, perms, WRITE_MASK);
} /* valid_write() */

mapping query_write_stats() { return copy(write_stats); }

void reset() {
  write_stats = ([ ]);
  read_stats = ([ ]);
}
// --- END [/mnt/home2/grok/lib/secure/master/valid_write.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/master/valid_binary.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/master/valid_binary.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627389   Available: 13574743
Inodes: Total: 5242880    Free: 4960133
1079 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/master/valid_binary.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627389   Available: 13574743
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: valid_binary.c,v 1.5 2003/02/11 08:59:32 pinkfish Exp $
 * $Log: valid_binary.c,v $
 * Revision 1.5  2003/02/11 08:59:32  pinkfish
 * Add in the /www directory ot the binary list.
 *
 * Revision 1.4  2000/06/19 04:15:54  pinkfish
 * Allow binaries to be created for the domain directories too.
 *
 * Revision 1.3  1998/08/19 08:04:54  pinkfish
 * Add in the cmds dir to the list which binaries are saved for.,
 *
 * Revision 1.2  1998/08/17 13:06:04  pinkfish
 * Turn on binaries for he secure dir as well.
 *
 * Revision 1.1  1998/01/06 05:12:03  ceres
 * Initial revision
 * 
*/
int valid_save_binary(string fname) {
  string *bits;

  bits = explode(fname, "/");
  switch (bits[0]) {
/*
    case "secure" :
      if ( bits[ 1 ] == "simul_efun" )
        return 0;
*/
    case "global" :
    case "std" :
    case "secure" :
    case "cmds" :
    case "d" :
    case "www" :
      return 1;
    case "obj" :
      //if (sscanf(bits[sizeof(bits)-1], "%*s-%*d%*s") == 0)
        return 1;
  }
  return 0;
} /* valid_save_binary() */
// --- END [/mnt/home2/grok/lib/secure/master/valid_binary.c] ---
// --- BEGIN [/mnt/home2/grok/lib/secure/master/virtual_objects.c] ---
// Size:   File: "/mnt/home2/grok/lib/secure/master/virtual_objects.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627389   Available: 13574743
Inodes: Total: 5242880    Free: 4960133
855 bytes, Last Modified:   File: "/mnt/home2/grok/lib/secure/master/virtual_objects.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627389   Available: 13574743
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:59.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: virtual_objects.c,v 1.3 2002/02/08 19:03:46 pinkfish Exp $
 * $Log: virtual_objects.c,v $
 * Revision 1.3  2002/02/08 19:03:46  pinkfish
 * Make it check for the existance of the file.
 *
 * Revision 1.2  2002/02/08 18:22:31  pinkfish
 * Add in code to allow easy setup of virtual terrains..
 * ./
 *
 * Revision 1.1  1998/01/06 05:12:03  ceres
 * Initial revision
 * 
*/
#include "/include/virtual.h"

object compile_object(string path) {
   string* bits;

   if (file_size(path) > 0) {
      return (object)SERVER->create_virtual_object(path);
   }

   // Check for a :
   bits = explode(path, ":");
   if (sizeof(bits) > 1) {
      if (file_size(bits[0]) > 0 ||
          file_size(bits[0] + ".c") > 0) {
         return bits[0]->create_virtual_object(bits[1..] ...);
      }
   }
} /* compile_object() */
// --- END [/mnt/home2/grok/lib/secure/master/virtual_objects.c] ---
// --- BEGIN [/mnt/home2/grok/lib/global/options_control.c] ---
// Size:   File: "/mnt/home2/grok/lib/global/options_control.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627388   Available: 13574742
Inodes: Total: 5242880    Free: 4960133
4428 bytes, Last Modified:   File: "/mnt/home2/grok/lib/global/options_control.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627388   Available: 13574742
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:52.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is the options control code to setup and fiddle with player options
 * for various things.
 * @author Pinkfish
 * @started Mon Oct 27 12:46:36 PST 2003
 */

#define PLAYER_OPTIONS_CLASS
#include <player.h>

mixed query_property(string);
varargs void add_property(string,mixed,int);

/**
 * This method does all the mangeling needed to bring the class up to the
 * new sizes.
 */
private class player_options_control query_player_options() {
   class player_options_control options;

   options = query_property(PLAYER_OPTIONS_CONTROL_PROP);
   if (!options) {
      return new(class player_options_control);
   }

   if (sizeof(options) == 4) {
      class player_options_control newbit;

      // Upgrade the size.
      newbit = new(class player_options_control);
      newbit->follow_everyone = options->follow_everyone;
      newbit->follow_groups = options->follow_groups;
      newbit->follow_friends = options->follow_friends;
      newbit->lead_behind = options->lead_behind;
      options = newbit;
   }
   return options;
}

/**
 * Should the player auto follow in groups.
 */
int query_auto_follow_group() {
   class player_options_control options;

   options = query_property(PLAYER_OPTIONS_CONTROL_PROP);
   if (!options) {
      return 0;
   }

   return options->follow_groups;
}

/**
 * Should the player auto follow friends.
 */
int query_auto_follow_friends() {
   class player_options_control options;

   options = query_property(PLAYER_OPTIONS_CONTROL_PROP);
   if (!options) {
      return 0;
   }

   return options->follow_friends;
}

/**
 * Should the player auto follow everyone.
 */
int query_auto_follow_everyone() {
   class player_options_control options;

   options = query_property(PLAYER_OPTIONS_CONTROL_PROP);
   if (!options) {
      return 0;
   }

   return options->follow_everyone;
}

/**
 * Should the player auto follow everyone.
 */
int query_lead_from_behind() {
   class player_options_control options;

   options = query_property(PLAYER_OPTIONS_CONTROL_PROP);
   if (!options) {
      return 0;
   }

   return options->lead_behind;
}

/**
 * Set the follow in groups automatically flag
 * @param flag
 */
void set_auto_follow_group(int flag) {
   class player_options_control options;
   
   options = query_property(PLAYER_OPTIONS_CONTROL_PROP);

   if (!options) {
      options = new(class player_options_control);
   }
   options->follow_groups = flag;
   add_property(PLAYER_OPTIONS_CONTROL_PROP, options);
}

/**
 * Set the follow frienda automatically flag.
 * @param flag set the follow friends flag
 */
void set_auto_follow_friends(int flag) {
   class player_options_control options;

   options = query_property(PLAYER_OPTIONS_CONTROL_PROP);

   if (!options) {
      options = new(class player_options_control);
   }
   options->follow_friends = flag;
   add_property(PLAYER_OPTIONS_CONTROL_PROP, options);
}

/**
 * Sets the follow everyone flag.
 * @param flag follow everyone
 */
void set_auto_follow_everyone(int flag) {
   class player_options_control options;

   options = query_property(PLAYER_OPTIONS_CONTROL_PROP);

   if (!options) {
      options = new(class player_options_control);
   }
   options->follow_everyone = flag;
   add_property(PLAYER_OPTIONS_CONTROL_PROP, options);
}

/**
 * Sets the lead from behind flag.
 * @param flag the lead from behind flag
 */
void set_lead_from_behind(int flag) {
   class player_options_control options;

   options = query_property(PLAYER_OPTIONS_CONTROL_PROP);

   if (!options) {
      options = new(class player_options_control);
   }
   options->lead_behind = flag;
   add_property(PLAYER_OPTIONS_CONTROL_PROP, options);
}

/**
 * Sets the mxp toggle flag.  If this flag is set to 1 then mxp is
 * disabled.
 */
void set_mxp_disable(int flag) {
   class player_options_control options;

   options = query_player_options();

   options->mxp_disable = 1;
   add_property(PLAYER_OPTIONS_CONTROL_PROP, options);
}

/**
 * This queries the mxp diable flag.
 * @return the current state of the mxp disable flag
 */
int query_mxp_disable() {
   class player_options_control options;

   options = query_player_options();
   return options->mxp_disable;
}

/**
 * This method returns if we should use the mxp codes or not.
 * @return use mxp codes or not
 */
int is_mxp_enabled() {
#if efun_defined(has_mxp)
   if (has_mxp(this_object())) {
      return !query_mxp_disable();
   }
#endif
   return 0;
}
// --- END [/mnt/home2/grok/lib/global/options_control.c] ---
// --- BEGIN [/mnt/home2/grok/lib/global/command.c] ---
// Size:   File: "/mnt/home2/grok/lib/global/command.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627387   Available: 13574741
Inodes: Total: 5242880    Free: 4960133
4581 bytes, Last Modified:   File: "/mnt/home2/grok/lib/global/command.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627387   Available: 13574741
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:52.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: command.c,v 1.5 2001/03/07 03:30:21 ceres Exp $
 * 
*/
/**
 * Handles commands from directories for living objects.
 *    /global/command.c
 *    from the Nightmare IVr1 Object Library
 *    handles commands of living objects
 *    created by Descartes of Borg 950323
 *    Hacked for Discworld by Turrican 4-11-95
 */

#include <command.h>

nosave string current_verb, current_cmd;
private nosave int Forced;
private nosave string *SearchPath;

/*  ***************  /lib/command.c driver applies  ***************  */

protected void create() {
   current_verb = "";
  SearchPath = ({ DIR_LIVING_CMDS });
} /* create() */

/** What is the current verb? */
string query_current_verb() { return current_verb; }
/** What are the args to the current verb? */
string query_current_cmd() { return current_cmd; }

/*  ***************  /lib/command.c command lfuns  ***************  */

/**
 * Try and execute the command.  It calls the fuinction command_shadowed
 * with the verb and args as parameters if the command is found to exist.
 * @param args the args to use for the verb
 * @return 1 on success, 0 on failure
 */
protected int cmdAll(string args) {
  class command verb;
  mixed tmp;

  verb = new(class command);
  verb->args = args;
  current_cmd = args;
  
  if( !((int)CMD_D->GetCommand(verb, SearchPath)) ) {
    return 0;
  }

/*
 * This allows other code to find out what verb has been used,
 * since query_verb() will always return "" (verb is *).
*/
   current_verb = verb->verb;

  if (CMD_D->IsGRCommand(verb->filepart) &&
      !this_object()->query_known_command(verb->verb))
    return 0;
  if (this_object()->command_shadowed(verb->verb, verb->args))
    return 1;
  if( !(tmp = (mixed)call_other(verb->file, "cmd", verb->args, verb->verb)) )
    return 0;
  else if( stringp(tmp) ) {
    write("Error: "+tmp+"\n");
    return 1;
  }
  else return 1;
} /* cmdAll() */

/**
 * This method tries to lookup the patterns for the given verb.
 * @param verb the verb to get the patterns for
 * @return the array of patterns
 * @see /obj/handlers/pattern_compiler.c
 * @see /gloal/new_parse->add_command()
 */
protected mixed *cmdPatterns(string verb) {
  if (CMD_D->IsGRCommand(verb) &&
      !this_object()->query_known_command(verb))
    return 0;
  return CMD_D->GetCommandPatterns(verb, SearchPath);
} /* cmdPatterns() */

/*  ***************  /lib/command.c lfuns  ***************  */

/**
 * Add in the command catch all action.
 */
protected void command_commands() {
#if efun_defined(add_action)
  add_action( "cmdAll", "*", -1 );
#endif
} /* command_commands() */

/**
 * A force event.
 * @param cmd the command to force
 * @return 0 on failure and 1 on success
 */
int eventForce(string cmd) {
  string err;
  int res;
  
  if(member_array(call_stack(0)[1], 
                  ({  "/cmds/creator/show_help.c", 
                      "/d/am/broad_way/cryer_order.c",
                      "/obj/handlers/new_soul.c", 
                      "/std/living/force.c"
                        })) == -1)
    error("illegal force");
  Forced = 1;
  err = catch(res = command(cmd));
  Forced = 0;
  if(err) error(err);
  return res;
} /* eventForce() */

/*  **********  /lib/command.c data manipulation functions  ********** */

/**
 * Add a directory(s) into the search path for commands.  If the input is
 * an array then the members of that are added to the search path.
 * @param val the path to array
 * @return the new search path
 */
string *AddSearchPath(mixed val) {
  if (stringp(val)) {
     val = ({ val });
  } else if(!pointerp(val)) {
     error("Bad argument 1 to AddSearchPath()\n");
  }
  SearchPath = uniq_array(SearchPath + val);
  return SearchPath;
} /* AddSearchPath() */

/**
 * Remove a directory(s) from the search path.  If the input is
 * an array then the members of that are added to the search path.
 * @param val the directory(s) to remove
 * @return the new search path
 */
string *RemoveSearchPath(mixed val) {
  if(stringp(val)) {
    val = ({ val });
  } else if(!pointerp(val)) {
    error("Bad argument 1 to RemoveSearchPath()\n");
  }
  SearchPath -= val;
  return SearchPath;
} /* RemoveSearchPath() */

/**
 * This method returns the current search path
 * @return the current search path
 */
string *GetSearchPath() { return SearchPath; }

/**
 * This method returns if we are being forced or not
 * @return 1 if we are being forced
 */
int GetForced() { return Forced; }

/**
 * This tells us if we are a client.
 * @return always returns 0
 */
string GetClient() { return 0; }
// --- END [/mnt/home2/grok/lib/global/command.c] ---
// --- BEGIN [/mnt/home2/grok/lib/global/history.c] ---
// Size:   File: "/mnt/home2/grok/lib/global/history.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627385   Available: 13574739
Inodes: Total: 5242880    Free: 4960133
5111 bytes, Last Modified:   File: "/mnt/home2/grok/lib/global/history.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627385   Available: 13574739
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:52.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: history.c,v 1.12 2003/07/15 13:12:40 taffyd Exp $
 * $Log: history.c,v $
 * Revision 1.12  2003/07/15 13:12:40  taffyd
 * Fixed unused local variable.
 *
 * Revision 1.11  2003/06/05 17:26:55  pinkfish
 * Fix up the problem with history.
 *
 * Revision 1.10  2003/06/05 01:59:31  pinkfish
 * Fix it up to use strsrch rather than sscanf to avoid errors with
 * '%'
 *
 * Revision 1.9  2003/02/05 20:29:09  sojan
 * added a this_object()!=this_player(1) check
 * for the inform.
 *
 * Revision 1.8  2003/02/05 19:00:51  pinkfish
 * Add in a thingy so it prints out history printing attempts.
 *
 * Revision 1.7  2002/04/23 20:04:14  pinkfish
 * Allow liaison deputies to view the history.
 *
 * Revision 1.6  2001/11/08 02:20:18  pinkfish
 * Fix up some processing errors.
 *
 * Revision 1.5  1999/10/28 02:28:48  ceres
 * can't remember
 *
 * Revision 1.4  1999/02/11 14:08:13  wodan
 * moved the command to /cmds
 *
 * Revision 1.3  1999/02/03 23:29:15  ceres
 * Fixed runtime in print_history if history size == 0
 *
 * Revision 1.1  1998/01/06 04:54:05  ceres
 * Initial revision
 * 
*/
/*
 * The great and wonderful alias driver by me ;)
 * pinkfish.
 */

#define COLS (int)this_object()->query_cols()

nosave string *history;
nosave int hoffset, numoff;
nosave int in_alias_command;
nosave string ignore_history;

void history_commands() {}

string substitute_history(string arg) {
  string s1, s2;

  if (sscanf(arg, "%s^%s", s1, s2) != 2)
    return arg;
  sscanf(s2, "%s^", s2);
  if (hoffset)
    return replace(history[hoffset-1], s1, s2);
  else
    return replace(history[sizeof(history)-1], s1, s2);
}
 
protected string expand_history( string arg ) {
   int num, i;
   
   if (arg[0] == '.' || strlen(arg) == 0) {
      if (hoffset) {
         return history[hoffset-1]+arg[1..strlen(arg)];
      } else {
         return history[sizeof(history)-1]+arg[1..strlen(arg)];
      }
   }
   if (sscanf(arg,"%d",num)==1) {
      num = num % sizeof(history);
      if (num<0) {
         num += hoffset;
         if (num<0) {
            num += sizeof(history);
         }
      }
      return history[num];
   }
   for (i=hoffset-1;i>=0;i--) {
      if (stringp(history[i])) {
         if (strsrch(history[i],arg)==0) {
            return history[i];
         }
      }
   }
   for (i=sizeof(history)-1;i>hoffset;i--) {
      if (stringp(history[i])) {
         if (strsrch(history[i],arg)==0) {
            return history[i];
         }
      }
   }
   return arg;
} /* expand_history() */

void ignore_from_history(string str) {
  ignore_history = str;
}
 
void add_history( string arg ) {
   if (ignore_history) {
      if (ignore_history == arg) {
         ignore_history = 0;
         return ;
      }
      ignore_history = 0;
   }
   if (arg == "" || arg[0] == '.' || arg[0] == '^')
      return;
   if (in_alias_command)
      return;
   if (!history) {
      history = allocate(40);
      numoff = -40;
   }
   history[hoffset++] = arg;
   if (hoffset>=sizeof(history)) {
      numoff += sizeof(history);
      hoffset = 0;
   }
} /* add_history() */

nomask int print_history( string arg ) {
   int i, from, to, num;
   
   if(this_player()!=this_object()) { /* a call */
      if(!interactive(this_player())) {
         return 0;
      }
      if(!(master()->query_lord(geteuid(this_player()))) &&
         !master()->is_liaison_deputy(geteuid(this_player()))) {
         return 0;
      }
   }

  if(this_object()!=this_player(1)) {
   user_event( this_object(), "inform",
               "Print history called on " + this_object()->query_name() +
               " by " + this_player()->query_name(),
               "calls", this_player());
  }

   from = hoffset;
   num = sizeof(history);
   if (!arg) {
      arg = "";
   }
   if (sscanf(arg,"%d,%d",from,to)==2) {
      num = to-from;
      if (num<0) {
         from = from+num;
         num = -num;
      }
   } else if (sscanf(arg,",%d",to)==1) {
      from = hoffset+1+num;
      num = from - (to%sizeof(history))+sizeof(history);
   } else if (sscanf(arg,"%d,",from)==1) {
      from = from % sizeof(history);
      num = from - hoffset;
      if (num<0) {
         num += sizeof(history);
      }
   } else if (sscanf(arg,"%d",num)!=1) {
         num = sizeof(history);
   }
   if(sizeof(history)) {
     from = from % sizeof(history);
   } else {
     from = 0;
   }
   
   if (num>sizeof(history)) {
     num = sizeof(history);
   }
   if (num <= 0) {
     add_failed_mess("Range out of bounds.\n");
     return 0;
   }
   
   for (i=from;i<sizeof(history);i++,num--) {
     if (history[i]) {
       printf( "%s%-=*s\n", sprintf( "% 4d", i + numoff ) +": ", COLS - 6,
               history[ i ] );
     }
     if (!num) {
       return 1;
     }
   }
   for (i=0;i<from;i++,num--) {
     if (history[i]) {
       printf( "%s%-=*s\n", sprintf( "% 4d", i + numoff + sizeof( history ) ) +
               ": ", COLS - 6, history[ i ] );
     }
     if (!num) {
       return 1;
     }
   }
   return 1;
} /* print_history() */

nomask protected string *get_history() {
  return history;
}
// --- END [/mnt/home2/grok/lib/global/history.c] ---
// --- BEGIN [/mnt/home2/grok/lib/global/le.c] ---
// Size:   File: "/mnt/home2/grok/lib/global/le.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627383   Available: 13574737
Inodes: Total: 5242880    Free: 4960133
4489 bytes, Last Modified:   File: "/mnt/home2/grok/lib/global/le.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627383   Available: 13574737
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:52.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: le.c,v 1.2 1998/04/13 14:19:14 pinkfish Exp $
 * $Log: le.c,v $
 * Revision 1.2  1998/04/13 14:19:14  pinkfish
 * Added documentation and moved some commands around ab it.
 *
 * Revision 1.1  1998/01/06 04:54:05  ceres
 * Initial revision
 * 
*/
/**
 * This is a quick and dirty line editor.  Useful when ed fails
 * or for a few other other things.
 * <p>
 *
 * This is a very quick and dirty line editor cooked up by
 * [als] in half an hour on a not-so-stormy night of 10/12/91
 * It uses NO input_to's, so ALL commands are prefixed with the command word
 * it was simply intended for those times when ed goes down the
 * proverbial gurgler.  If you HAVE to use it, set up aliases :)
 * commands: r file, w[file], >insert text, /search text,
 * number goes to line number, +, -, d, N-> clears line editor
 * Have fun, and win awards
 * One other possible use for LE is for cute aliases
 * @started 10th of December 1991
 * @author Ember
 */

private nosave int line;
private nosave string *cfile, cfile_name, last_search;

protected int le(string s);
int add_command(string str, object ob, string format, function funct);

void create() {
  seteuid("PLAYER");
} /* create() */

private void print_line() {
   if (line > sizeof(cfile)) {
      line = sizeof(cfile);
   }
   if (!line) {
      write("No line.\n");
      return;
   }
   write(extract("   ", 0, 3 - strlen(line + "")) + line + ":" + cfile[line-1] + "\n");
} /* print_line() */

/**
 * This method adds in all the commands needed to access le.
 */
protected void le_commands() {
   add_command("le", this_object(), "<string>", (: le($4[0]) :));
} /* le_commands() */

/**
 * The main access point for le.  This takes in the comamnd
 * line arg and uses it as it should and does wild and
 * exciting thins, especially on those stormy  nights...
 * @param s the input string to the line editor
 * @return 1 if successful, 0 on failure
 */
protected int le(string s) {
   int j;
   string sB;

   if (!pointerp(cfile)) { cfile = ({ }); line = 0; }
   if (!s || s == "") { print_line(); return 1; }

   if (sscanf(s, "%d", j)) { line = j; print_line(); return 1; }
   switch (s[0]) {
   case 'd':
      if (!line) { notify_fail("Not on a line.\n"); return 0; }
      cfile = delete(cfile, line-1, 1);
      print_line();
      return 1;
   case 'N':
      cfile = ({ });
      line = 0;
      cfile_name = 0;
      write("Line editor cleared.\n");
      return 1;
   case '/':
      s = extract(s, 1);
      if (s == "") {
         s = last_search;
      }
      last_search = s;
      {
         int i, s1, s2;
         for (i = line+1; i<= sizeof(cfile); i++) {
            if (sscanf(cfile[i-1], "%s"+s+"%s", s1, s2)) { line = i; print_line(); return 1; }
         }
         write("Search failed.\n");
         return 1;
      }
   case '>':
      s = extract(s, 1);
      {
         string *tmp1, *tmp2;

         tmp1 = (line > 1) ? cfile[0..line-2] : ({ });
         tmp2 = (line <= sizeof(cfile)) ? cfile[line-1..sizeof(cfile)-1] : ({ });
         cfile = tmp1 + ({ s }) + tmp2;
      }
      line++;
      print_line();
      return 1;
   case 'r':
      {
         string sA;
      
         sA = extract(s, 1);
         while (sA[0] == ' ') sA = extract(sA,1);
         sB = this_player()->get_path(sA);
         if (!sB) sB = sA;
         if (file_size(sB) < 0) { notify_fail("File doesn't exist.\n"); return 0; }
         sA = read_file(sB);
         cfile = explode(sA, "\n");
         line = 1;
      }
      write("Read file "  + sB + ": " + sizeof(cfile) + " lines.\n");
      cfile_name = sB;
      print_line();
      return 1;
   case '+':
      if (line < sizeof(cfile)) line++;
      print_line();
      return 1;
   case '-':
      if (line > 1) line --;
      print_line();
      return 1;
   case 'w':
      if (s == "w") {
         if (!cfile_name) { notify_fail("No file name.\n"); return 0; }
      } else {
         s = extract(s,1);
         while (s[0] == ' ') s = extract(s, 1);
         if (this_player()->get_path(s)) s = this_player()->get_path(s);
         cfile_name = s;
      }
      rm(cfile_name);
      write_file(cfile_name, implode(cfile, "\n"));
      write("Tried to write file " + cfile_name + ": " + sizeof(cfile) + " lines.\n");
      return 1;
   case 'z':
      {
         int q;

         q = 20;
         while (q-- && line <= sizeof(cfile)) { print_line(); line++; }
         line --;
      }
      return 1;
   }
} /* le() */
// --- END [/mnt/home2/grok/lib/global/le.c] ---
// --- BEGIN [/mnt/home2/grok/lib/global/virtual/c_compiler.c] ---
// Size:   File: "/mnt/home2/grok/lib/global/virtual/c_compiler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627382   Available: 13574736
Inodes: Total: 5242880    Free: 4960133
890 bytes, Last Modified:   File: "/mnt/home2/grok/lib/global/virtual/c_compiler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627382   Available: 13574736
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:52.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: c_compiler.c,v 1.1 1998/01/06 04:55:54 ceres Exp $
 * $Log: c_compiler.c,v $
 * Revision 1.1  1998/01/06 04:55:54  ceres
 * Initial revision
 * 
*/
#include "virtual.h"

/*
 * This is the default .c extension compiler.  This is the default
 * so that basicly everything else manages to work correctly.
 * Could be bad if this method was lost...
 */
void initialize_methods();
 
void create() {
    initialize_methods();
    seteuid(getuid());
} /* create() */

void initialize_methods() {
    SERVER->add_method("c",  file_name(this_object()), "compile_c");
} /* initialize_methods() */

object compile_c(string name, int clone) {
    if (!clone) {
	name->go_ahead_make_my_womble();
	return efun::find_object(name);    /* If simul_efun done */
    } else {
	return efun::clone_object(name);   /*       -- || --     */
    }
} /* compile_c() */
// --- END [/mnt/home2/grok/lib/global/virtual/c_compiler.c] ---
// --- BEGIN [/mnt/home2/grok/lib/global/virtual/efuns.c] ---
// Size:   File: "/mnt/home2/grok/lib/global/virtual/efuns.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627382   Available: 13574736
Inodes: Total: 5242880    Free: 4960133
1455 bytes, Last Modified:   File: "/mnt/home2/grok/lib/global/virtual/efuns.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627382   Available: 13574736
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:52.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: efuns.c,v 1.1 1998/01/06 04:55:54 ceres Exp $
 * $Log: efuns.c,v $
 * Revision 1.1  1998/01/06 04:55:54  ceres
 * Initial revision
 * 
*/
#define HANDLER "/global/virtual/handler"

/*
 * clone_object modified to try and make .c files in /d/ virtual
 */
object clone_object(string name) {
  if(name[0..2] == "/d/" || name[0..1] == "d/")
    return (object)HANDLER->clone_virtual_object(name);
  return efun::clone_object(name);
}

/*
 * destruct modified to cope with virtual objects
 */
void destruct(mixed name) {
  object obj;

  if(stringp(name)) {
    obj = find_object(name);
    if(obj->query_property("file_name"))
      HANDLER->destruct_virtual_object(obj);
    destruct(obj);
  } else if(objectp(name)) {
    if(name->query_property("file_name"))
      HANDLER->destruct_virtual_object(name);
    destruct(name);
  }
}

/*
 * file_name modified to cope with virtual objects
 */
string file_name(object obj) {
  string name, number, file;

  name = efun::file_name(obj);
  if(sscanf(name, "%s#%s", name, number) == 2) {
    if(file = (string)obj->query_property("file_name")) {
      return file + "#" + number;
    } else {
      return name + "#" + number;
    }
  }
  return name;
}

/*
 * find_object modified to cope with virtual objects
 */
object find_object(string str) {
  object obj;

  if(obj = efun::find_object(str))
    return obj;
  return (object)HANDLER->find_virtual_object(str);
}
// --- END [/mnt/home2/grok/lib/global/virtual/efuns.c] ---
// --- BEGIN [/mnt/home2/grok/lib/global/virtual/modified_efuns.c] ---
// Size:   File: "/mnt/home2/grok/lib/global/virtual/modified_efuns.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627381   Available: 13574735
Inodes: Total: 5242880    Free: 4960133
4294 bytes, Last Modified:   File: "/mnt/home2/grok/lib/global/virtual/modified_efuns.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627381   Available: 13574735
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:52.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: modified_efuns.c,v 1.1 1998/01/06 04:55:54 ceres Exp $
 * $Log: modified_efuns.c,v $
 * Revision 1.1  1998/01/06 04:55:54  ceres
 * Initial revision
 * 
*/
#define MAX_SIZE 50000

/*
varargs void say(string str, mixed avoid) {
  if (!pointerp(avoid))
    avoid = ({ this_player(), previous_object() }) + ({ avoid });
  else
    avoid += ({ this_player(), previous_object() });
  if (!environment(previous_object()))
    if (this_player() && environment(this_player()))
      event(environment(this_player()), "say", str, avoid);
    else
      event(previous_object(), "say", str, avoid);
  else
    event(environment(previous_object()), "say", str, avoid);
} 

*/

varargs void say(string str, mixed avoid)
{
  if (!pointerp(avoid))
    avoid = ({ this_player(), previous_object() }) + ({ avoid });
  else
    avoid += ({ this_player(), previous_object() });
  if (!environment(previous_object()))
    if(this_player() && environment(this_player()))
      event(environment(this_player()), "say", str, avoid);
    else
      event(previous_object(), "say", str, avoid);
  else
  {
    if (environment(environment(previous_object())))
      event(environment(environment(previous_object())), "say", str, avoid);
    else
      event(environment(previous_object()), "say", str, avoid);
  }
}








varargs void tell_room(object ob, string str, mixed avoid) {
  if (!ob || !objectp(ob))
    return ;
  event(ob, "say", str, avoid);
} /* tell_room() */

void tell_object(object ob, string str) {
  if (objectp(ob))
    ob->event_write(previous_object(), str);
} /* tell_object() */

object find_living(string str) {
  string nick;
  object ob;

  if (this_player() && (nick = (string)this_player()->expand_nickname(str)))
    str = nick;
  if ((ob = efun::find_living(str)))
    if ((int)ob->query_invis() == 2) {
      if (member_array(this_player()->query_name(), 
                       (object *)ob->query_allowed()) == -1)
        return 0;
    }
  return ob;
} /* find_living() */

object find_player(string str) {
  object ob;
  if ((ob = efun::find_player(str)))
    if ((int)ob->query_invis() == 2)
      if (member_array(this_player()->query_name(),
                       (object *)ob->query_allowed()) == -1)
        return 0;
  return ob;
} /* find_player() */

void log_file(string name, string mess) {
  if (file_size("/log/"+name) > MAX_SIZE) {
    seteuid("Root");
    rm("/log/"+name+".old");
    rename("/log/"+name, "/log/"+name+".old");
  }
  seteuid("Root");
  write_file("/log/"+name, mess);
  seteuid(0);
} /* log_file() */

#ifdef MUD_NAME
string mud_name() {
  return capitalize(MUD_NAME);
} /* mud_name() */
#endif

void cat(string file, int start_line, int number) {
  string bing;

  seteuid(geteuid(previous_object()));
  bing = read_file(file, start_line, number);
  seteuid(0);
  if (bing)
    printf("%s", bing[0..5000]);
} /* cat() */

#define HANDLER "/global/virtual/handler"

/*
 * clone_object modified to try and make .c files in /d/ virtual
 */
object clone_object(string name) {
  seteuid(geteuid(previous_object()));
  if(name[0..2] == "/d/" || name[0..1] == "d/")
    return (object)HANDLER->clone_virtual_object(name);
  return efun::clone_object(name);
} /* clone_object */

/*
 * destruct modified to cope with virtual objects
 */
void destruct(mixed name) {
  object obj;

  if(stringp(name)) {
    obj = find_object(name);
    if(obj->query_property("file_name"))
      HANDLER->destruct_virtual_object(obj);
    destruct(obj);
  } else if(objectp(name)) {
    if(name->query_property("file_name"))
      HANDLER->destruct_virtual_object(name);
    destruct(name);
  }
} /* destruct */

/*
 * file_name modified to cope with virtual objects
 */
string file_name(object obj) {
  string name, number, file;

  name = efun::file_name(obj);
  if(sscanf(name, "%s#%s", name, number) == 2) {
    if(file = (string)obj->query_property("file_name")) {
      return file + "#" + number;
    } else {
      return name + "#" + number;
    }
  }
  return name;
} /* file_name */

/*
 * find_object modified to cope with virtual objects
 */
object find_object(string str) {
  object obj;

  if(obj = efun::find_object(str))
    return obj;
  return (object)HANDLER->find_virtual_object(str);
} /* find_object */

// --- END [/mnt/home2/grok/lib/global/virtual/modified_efuns.c] ---
// --- BEGIN [/mnt/home2/grok/lib/global/virtual/server2.c] ---
// Size:   File: "/mnt/home2/grok/lib/global/virtual/server2.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627380   Available: 13574734
Inodes: Total: 5242880    Free: 4960133
3018 bytes, Last Modified:   File: "/mnt/home2/grok/lib/global/virtual/server2.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627380   Available: 13574734
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:52.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: server2.c,v 1.1 1998/01/06 04:55:54 ceres Exp $
 * $Log: server2.c,v $
 * Revision 1.1  1998/01/06 04:55:54  ceres
 * Initial revision
 * 
*/
/*
 * This is an experimental virtual-object server, written for DiscWorld
 * by Zellski. The frontend to the mudlib consists of the two functions
 * virtual_{clone, load}() which will return an object, with a 'real'
 * object as 'program' and 'variable space' but with state of properties
 * defined in some fashion by the contents of the file virtual-cloned/loaded.
 *
 * Drawbacks as yet:
 *  * The actual compilation methods are barely enough even for testing
 *    purposes but that is simple enough to expand.
 *  * The use of explode() for skipping whitespace is pathetically stupid. 
 *  * There is no support for comments in the virtual-files in prop-to-fun.
 *
 * A quick explanation of masters/clones.
 * There is no distinction as in LPC, the only one made is for finding
 * the object pointers from a virtual filename. For this there IS a 
 * virtual_clone and virtual_load that should be used. they produce much
 * the same objects, except they CAN choose to make a diff - the clone/load
 * flag is passed along to compilation. This is needed for .c files of course.
 * Remember though that even a 'master' BO, /foo/bar.x IS a clone in the end,
 * of some LPC-file. There is no support for using LPC masterobjects.
 * You can find a virtual 'master' but not a clone, you may only get a list
 * of clones made of a given file.
 */


#include "virtual.h"
 
void add_method(string suffix, object ob, string fun, int type);
mapping methods;

/*
 * Each entry in virtual_objects is of the form ({ master, clone1, ... }).
 * Each entry in methods on ({ object, function }).
 */

#define OB   0
#define FUN  1
#define TYPE 2

#define LOAD   1
#define CLONE  2

void create() {
  seteuid(getuid());
  methods = ([ ]);
/*
  add_method("c", "/global/virtual/c_compiler.c", "compile_c", 
                        CLONE|LOAD);
 */
  add_method("C", "/global/virtual/c_compiler.c", "compile_c", 
                        CLONE|LOAD);
} /* create() */

object create_virtual_object(string name, int clone);

void add_method(string suffix, object ob, string fun, int type) {
  /*
   * teach us how to compile a new kind of file..
   */
  if (!type)
    type = CLONE;

  if (!methods[suffix]) {
    methods[suffix] = ({ ob, fun, type });
  }
} /* add_method() */

#define Error(s) write(s); log_file("VO_HANDLER", s); return 0;

object create_virtual_object(string name, int clone) {
  string *split;
  mixed  *method;
  object ob;

  split = explode(name, ".");
  method = methods[split[sizeof(split) - 1]];
  if (method) {
    if (clone ||
        (method[TYPE]&LOAD)) {
      ob =  (object) call_other(method[OB], method[FUN], name, clone);
      ob->add_property("virtual name", name);
      return ob;
    }
    return 0;
  }
  Error("create_virtual_object() : unknown suffix to " + name + "\n");
} /* create_virtual_object() */
// --- END [/mnt/home2/grok/lib/global/virtual/server2.c] ---
// --- BEGIN [/mnt/home2/grok/lib/global/virtual/data_compiler.c] ---
// Size:   File: "/mnt/home2/grok/lib/global/virtual/data_compiler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627377   Available: 13574731
Inodes: Total: 5242880    Free: 4960133
1662 bytes, Last Modified:   File: "/mnt/home2/grok/lib/global/virtual/data_compiler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627377   Available: 13574731
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:52.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: data_compiler.c,v 1.1 1998/01/06 04:55:54 ceres Exp $
 * $Log: data_compiler.c,v $
 * Revision 1.1  1998/01/06 04:55:54  ceres
 * Initial revision
 * 
*/
#include "virtual.h"
#include <soul.h>
#include <random_names.h>

/*
 * This is the default .c extension compiler.  This is the default
 * so that basicly everything else manages to work correctly.
 * Could be bad if this method was lost...
 */
void initialize_methods();
 
void create() {
  initialize_methods();
  seteuid(getuid());
} /* create() */

void initialize_methods() {
  SERVER->add_method("s",  file_name(this_object()), "compile_soul", 1);
  SERVER->add_method("r_n",  file_name(this_object()), "compile_random_name", 1);
} /* initialize_methods() */

object compile_soul(string name, int) {
  object ob;

  if (name[0] != '/')
    name = "/"+name;
  if (name[0..strlen(SOUL_DIR)-1] != SOUL_DIR) {
    return 0;
  }
  name = name[strlen(SOUL_DIR)..];
  SOUL_COMPILER->compile_file(name);
  ob = clone_object("/std/object");
  ob->set_name("compile");
  ob->set_short("Compiling "+name+" now");
  call_out((: $(ob)->dest_me() :), 2);
  return ob;
} /* compile_soul() */

object compile_random_name(string name, int clone) {
  object ob;

  if (name[0] != '/')
    name = "/"+name;
  if (name[0..strlen(RANDOM_NAME_DATA_DIR)-1] != RANDOM_NAME_DATA_DIR) {
    return 0;
  }
  name = name[strlen(RANDOM_NAME_DATA_DIR)..];
  RANDOM_NAME_GENERATOR->open_file(name);
  ob = clone_object("/std/object");
  ob->set_name("compile");
  ob->set_short("Compiling "+name+" now");
  call_out((: $(ob)->dest_me() :), 2);
  return ob;
} /* compile_random_name() */
// --- END [/mnt/home2/grok/lib/global/virtual/data_compiler.c] ---
// --- BEGIN [/mnt/home2/grok/lib/global/virtual/setup_compiler/UWater.c] ---
// Size:   File: "/mnt/home2/grok/lib/global/virtual/setup_compiler/UWater.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627376   Available: 13574730
Inodes: Total: 5242880    Free: 4960133
232 bytes, Last Modified:   File: "/mnt/home2/grok/lib/global/virtual/setup_compiler/UWater.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627376   Available: 13574730
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:52.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: UWater.c,v 1.1 1998/01/06 04:56:31 ceres Exp $
 * $Log: UWater.c,v $
 * Revision 1.1  1998/01/06 04:56:31  ceres
 * Initial revision
 * 
*/
inherit "/std/uwater.c";

#include "Room.inc"
// --- END [/mnt/home2/grok/lib/global/virtual/setup_compiler/UWater.c] ---
// --- BEGIN [/mnt/home2/grok/lib/global/virtual/setup_compiler/Outside.c] ---
// Size:   File: "/mnt/home2/grok/lib/global/virtual/setup_compiler/Outside.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627375   Available: 13574729
Inodes: Total: 5242880    Free: 4960133
235 bytes, Last Modified:   File: "/mnt/home2/grok/lib/global/virtual/setup_compiler/Outside.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627375   Available: 13574729
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:52.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: Outside.c,v 1.1 1998/01/06 04:56:31 ceres Exp $
 * $Log: Outside.c,v $
 * Revision 1.1  1998/01/06 04:56:31  ceres
 * Initial revision
 * 
*/
inherit "/std/outside.c";

#include "Room.inc"
// --- END [/mnt/home2/grok/lib/global/virtual/setup_compiler/Outside.c] ---
// --- BEGIN [/mnt/home2/grok/lib/global/virtual/setup_compiler/SetupCompiler.c] ---
// Size:   File: "/mnt/home2/grok/lib/global/virtual/setup_compiler/SetupCompiler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627375   Available: 13574729
Inodes: Total: 5242880    Free: 4960133
3161 bytes, Last Modified:   File: "/mnt/home2/grok/lib/global/virtual/setup_compiler/SetupCompiler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627375   Available: 13574729
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:52.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: SetupCompiler.c,v 1.1 1998/01/06 04:56:31 ceres Exp $
 * $Log: SetupCompiler.c,v $
 * Revision 1.1  1998/01/06 04:56:31  ceres
 * Initial revision
 * 
*/
#include "SetupCompiler.h"

void initialize_methods();

object return_ob;
int tmp_file_no;

void create() {
  seteuid(getuid(this_object()));
  initialize_methods();
} /* create() */

object query_return_ob() { return return_ob; }
void set_return_ob(object ob) { return_ob = ob; }

void initialize_methods() {
    SERVER->add_method("vrm",  file_name(this_object()), "compile_vrm");
    SERVER->add_method("vro",  file_name(this_object()), "compile_vro");
    SERVER->add_method("vrw",  file_name(this_object()), "compile_vrw");
    SERVER->add_method("vra",  file_name(this_object()), "compile_vra");
    SERVER->add_method("vrc",  file_name(this_object()), "compile_vrc");
} /* initialize_methods() */

#define Error(s) write(s); log_file("VO_COMPILER", s); return 0;

object prop_to_fun(string file, int clone, string incfile ) {
    string  data, data2, s1, *ind, dir, tmp_name;
    int      i;
  
    tmp_name = file+"-"+(tmp_file_no++)+".c";
    if (find_object(tmp_name))
      tmp_name->dest_me();
    ind = explode(file, "/");
    dir = implode(ind[0..sizeof(ind)-2], "/");
    unguarded((: rm, tmp_name :));
    unguarded((: write_file, tmp_name,
               "object MyRoom;\n"
               "#include \""+incfile+"\"\n\n"
               "object this_room() { return MyRoom; }\n" :));
           

    data = read_file(file);
    if (!data) {
        Error("prop_to_fun() : file " + file + " not found\n");
    }

    unguarded((: write_file, tmp_name, data :));

    unguarded((: write_file, tmp_name, "\n\n"
               "void dest_me() { destruct(this_object()); }\n\n"
               "void setup();\n\n"
               "void create() {\n"
               "  seteuid((string)\"/secure/master\"->"
               "creator_file(this_object()));\n"
               "  MyRoom = (object)\""+SERVER+
               "\"->create_virtual_object(CLONEFILE, 1);\n"
               "  MyRoom->add_property(\"virtual name\", \""+
               file+(clone?"#1":"")+"\");\n"
               "\n  setup();\n"+
               "\n MyRoom->reset(); \n"
               "  \""+file_name(this_object())+"\"->"
               "set_return_ob(MyRoom);\n} /* create() */\n" :));


    if (data = catch(tmp_name->bing())) {
      write("Error loading "+file+", "+data+"\n");
      write("File could not be loaded.\n");

    } else {
      tmp_name->dest_me();
      unguarded((: rm, tmp_name :));
      return return_ob;
    }
} /* prop_to_fun() */

object compile_vrc(string name, int clone) {
    return prop_to_fun(name, clone, PATH+ROOMFUNCS );
} 

object compile_vmc(string name, int clone) {
    return prop_to_fun(name, clone, PATH+MON_FUNCS );
} 
     
object compile_vac(string name, int clone) {
    return prop_to_fun(name, clone, PATH+ARM_FUNCS );
} 

object compile_vwc(string name, int clone) {
    return prop_to_fun(name, clone, PATH+WEP_FUNCS );
} 

object compile_voc(string name, int clone) {
    return prop_to_fun(name, clone, PATH+OBJ_FUNCS );
} 


// --- END [/mnt/home2/grok/lib/global/virtual/setup_compiler/SetupCompiler.c] ---
// --- BEGIN [/mnt/home2/grok/lib/global/virtual/setup_compiler/Room.c] ---
// Size:   File: "/mnt/home2/grok/lib/global/virtual/setup_compiler/Room.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627374   Available: 13574728
Inodes: Total: 5242880    Free: 4960133
226 bytes, Last Modified:   File: "/mnt/home2/grok/lib/global/virtual/setup_compiler/Room.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627374   Available: 13574728
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:52.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: Room.c,v 1.1 1998/01/06 04:56:31 ceres Exp $
 * $Log: Room.c,v $
 * Revision 1.1  1998/01/06 04:56:31  ceres
 * Initial revision
 * 
*/
inherit "/std/room.c";

#include "Room.inc"
// --- END [/mnt/home2/grok/lib/global/virtual/setup_compiler/Room.c] ---
// --- BEGIN [/mnt/home2/grok/lib/global/virtual/compiler.c] ---
// Size:   File: "/mnt/home2/grok/lib/global/virtual/compiler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627374   Available: 13574728
Inodes: Total: 5242880    Free: 4960133
15267 bytes, Last Modified:   File: "/mnt/home2/grok/lib/global/virtual/compiler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627374   Available: 13574728
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:52.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: compiler.c,v 1.9 2002/11/30 22:14:50 presto Exp $
 * $Log: compiler.c,v $
 * Revision 1.9  2002/11/30 22:14:50  presto
 * clone /obj/shield for stuff in /obj/armours/shield/
 *
 * Revision 1.8  2001/03/22 18:47:22  pinkfish
 * Make the virtual name used in a different way.
 *
 * Revision 1.7  1999/11/17 09:08:25  pinkfish
 * Fix up the path for the virtual objects.
 *
 * Revision 1.6  1999/11/17 09:03:16  pinkfish
 * Add in transport type of virtual object.
 *
 * Revision 1.5  1999/06/22 16:05:14  ceres
 * Removed caching, it wasn't helping much
 *
 * Revision 1.4  1999/06/22 02:45:39  ceres
 * Modified to reduce file reads
 *
 * Revision 1.3  1998/09/06 17:42:53  olorin
 * Fixed the change to work when the virtual file was changed.
 * Note to PF, rm needs unguarded:)
 *
 * Revision 1.2  1998/08/17 11:48:52  pinkfish
 * Make it use a static non-removable file.
 *
 * Revision 1.1  1998/01/06 04:55:54  ceres
 * Initial revision
 * 
 * Originally by person or persons unknown (finkpish@discworld?)
 *               Maybe by Zellski@discworld
 *
 * 12/93-1/94 Bannor@NewMoon
 *            Fixed the Class and Include keywords.
 * 9-Jul-94   Bannor@NewMoon
 *              Added DELAY_WRITE code to write the temp file to
 *              a string then write the file all at once.  This
 *              reduces the calls of write_file() (and thus valid_write()
 *              and all it's overhead, ie, reduces lag).
 * 1-Oct-95   Jeremy@Discworld
 *              Added clothing class
 * 23-May-95  Olorin@discworld
 *              Modified the room class to call reset() on the object 
 *              before returning it, and to always clone the object to
 *              ensure correct registration of the object.
 * 23-Aug-97 Pinkfish@discworld
 *              Changed to add in the food type.
 */
 
#include "virtual.h"
#include "compiler.h"
 
void    initialize_methods();
string  strip_string( string str );
 
 
#define WHITESPACE(c) (c == 10 || c == 32 || c == '\n')
 
 
mapping o_funcs;
mapping r_funcs;
mapping arm_funcs;
mapping clo_funcs;
mapping sca_funcs;
mapping wep_funcs;
mapping cont_funcs;
mapping food_funcs;
mapping mon_funcs;
mapping clotrans_funcs;
object  return_ob;
int     tmp_file_no;
int     debug_file;             /* don't rm .c file if non-zero */

void    create()
{
  seteuid("Root");
  initialize_methods();
  o_funcs = O_FUN;
  r_funcs = O_FUN + R_FUN;
  arm_funcs = ARM_FUN + O_FUN;
  clo_funcs = CLO_FUN + O_FUN;
  sca_funcs = SCA_FUN + O_FUN;
  wep_funcs = WEP_FUN + O_FUN;
  mon_funcs = MON_FUN + O_FUN;
  cont_funcs = CONT_FUN + O_FUN;
  food_funcs = FOOD_FUN + CONT_FUN + O_FUN;
  clotrans_funcs = O_FUN + CLO_FUN + CLOTRANS_FUN;
}                               /* create() */

object  query_return_ob()
{
    return return_ob;
}
 
void    set_return_ob( object ob )
{
    return_ob = ob;
}
 
void    initialize_methods()
{
    SERVER->add_method( "r", file_name( this_object() ), "compile_r", 
                        CLONE|LOAD );
    SERVER->add_method( "ro", file_name( this_object() ), "compile_r", 
                        CLONE|LOAD );
    SERVER->add_method( "ob", file_name( this_object() ), "compile_ob" );
    SERVER->add_method( "arm", file_name( this_object() ), "compile_arm" );
    SERVER->add_method( "clo", file_name( this_object() ), "compile_clo" );
    SERVER->add_method( "trans", file_name( this_object() ), "compile_clotrans" );
    SERVER->add_method( "sca", file_name( this_object() ), "compile_sca" );
    SERVER->add_method( "wep", file_name( this_object() ), "compile_wep" );
    SERVER->add_method( "mon", file_name( this_object() ), "compile_mon" );
    SERVER->add_method( "food", file_name( this_object() ), "compile_food" );
    SERVER->add_method( "cont", file_name( this_object() ), "compile_cont" );
    SERVER->add_method( "imp", file_name( this_object() ), "compile_imp" );
}                               /* initialize_methods() */
 
#define Error(s) write(s); log_file( "VO_COMPILER", s); return 0;
 
mixed  *extract_arguments( string str );
 
void    do_clone( object dest, string str )
{
    object  ob;
 
    ob = clone_object( str );
    if( ob )
        ob->move( dest );
}                               /* do_clone() */
 
object  prop_to_fun( string file, mapping funs, string virt_class, 
                    string virt_include, int clone )
{
    string *segments, *ind, data, s1, dir, tmp_name, tmp_val;
    string file_data;  /* used to build the file for writing */
    mixed  *val;
    int     i;
    int pos;
 
 
/*
 * Ok...  what we do is stick it in the same dir as the file we start
 * with, with the same name, but a nice number on ze end.
 */
    debug_file = 0;             /* debugging off */
    file_data = "";             /* init file_data */
    pos = strsrch(file, "/", -1);
    tmp_name = file[0..pos] + "." + file[pos+1..] + "_virtual_.c";
    if (file_size(tmp_name) <= 0 ||
        stat(file)[1] > stat(tmp_name)[1]) {
       tmp_file_no++;
       if( find_object( tmp_name ) ) {
           tmp_name->dest_me();
       }
       ind = explode( file, "/" );
       dir = implode( ind[ 0..sizeof( ind ) - 2 ], "/" );
       unguarded((: rm, tmp_name :));
 
       file_data = "#include <"+ virt_include +">\n\n"
                "void dest_me() { destruct( this_object() ); }\n\n"
                "void create()\n{\n"
                "  seteuid( (string)\"/secure/master\"->creator_file( file_name( this_object() ) ) );\n"
                "} /* create() */\n"
                "\nobject create_virtual_ob() {\n"
                "   object clone;\n\n";
 
       data = read_file( file );
       if( !data )
       {
           Error( "prop_to_fun() : file " + file + " not found\n" );
       }
 
       /* Lines beginning with a # are a comment... */
       /* Break into segments at comments */
       segments = explode( "$\n" + data, "\n#" );
       if( !segments )
       {
           Error( "prop_to_fun() : Nothing but comments?\n" );
       }
       /* Remove dummy $ (?) */
       segments[ 0 ] = segments[ 0 ][ 1..(sizeof(segments[ 0 ]) - 1) ];
       /* Remove comment lines */
       for( i = 1; i < sizeof( segments ); i++ ) {
           if( sscanf( segments[ i ], "%s\n%s", s1, segments[ i ] ) != 2 ) {
               segments[ i ] = "";
           }
       }
       /* Join segments together again */
       data = implode( segments, "\n" );
    
       /* See example file for explanation of syntax. */
    
       segments = explode( strip_string( data ), "::" );
       // Debug
       //printf("%O\n", segments);
       /* sizeof(segments) can be odd if the last line has no argument */
       if (sizeof( segments ) % 2) {
         segments += ({""});
       }
       ind = allocate( sizeof( segments ) / 2 );
       val = allocate( sizeof( segments ) / 2 );
    
       for( i = 0; i < sizeof( ind ); i++ )
       {
           ind[ i ] = segments[ i * 2 ];
           val[ i ] = replace( segments[ i * 2 + 1 ], "\n", " " );
           /* look for virtual compiler meta char */
           if( ind[ i ][ 0..0 ] == "#" )
           {
               ind[ i ] = lower_case( ind[ i ] );
               if( ind[ i ] == "#debug" )
               {
                   /* debug errent virtual programs, ie, don't rm */
                   /* the .c file if debug_file is non-zero */
                   sscanf( val[ i ], "%d", debug_file );
               }
               else
               {
                   if( ind[ i ] == "#class" )
                   {
                       /* use new base object for cloning */
                       /* remove any leading (or trailing) spaces */
                       virt_class = replace( val[i], " ", "" );
                   }
                   else
                   {
                       if( ind[ i ] == "#include" )
                       {
                           /* include the file in setup(), just before the */
                           /* object is cloned.  */
                           tmp_val = val[i];
                           file_data += "#include " +
                                       replace( tmp_val, " ", "" ) +
                                       "\n";
                       }
                   }
               }
           }                       /* if( ..# ) */
       }
       file_data += "  clone = (object)SERVER->create_virtual_object( " +
                   virt_class + ", 1 );\n"
                   "  clone->add_property( VIRTUAL_NAME_PROP, \""
                   + file + (clone ? "#1" : "") + "\" );\n";
 
       for( i = 0; i < sizeof( ind ); i++ )
       {
           ind[ i ] = lower_case( ind[ i ] );
           if( ind[ i ][ 0..0 ] == "#" )
           {
               /* it's a virtual keyword don't stick it in the .c file */
               continue;
           }
           /* A quick fix to handle function pointers */
           val[ i ] = replace( val[ i ], ({"(:", "bind( (:",
                                           ":)", ":), clone )" }) );
           if( ind[ i ][ 0..0 ] == "$" )
           {
               /* stuff that starts with "$" are 'undefined' function
                * names in the base object */
               {
                   file_data +="  call_other( clone, \"" +
                               ind[ i ][ 1..100 ] + "\", " + val[ i ] +
                               " );\n";
               }
               continue;
           }                       /* if( ...$ ) */
           if( funs[ ind[ i ] ] )
           {
               if( !pointerp( funs[ ind[ i ] ] ) )
               {
                   /* "val[i][1], val[i][2], val[i][3], val[i][4], val[i][5]); */
                   file_data += "  call_other( clone, \"" +
                               funs[ ind[ i ] ] + "\", " + val[ i ] + " );\n";
               }
               else
               {
                   /*
                    * call_other( funs[ind[i]][1], funs[ind[i]][0], clone,
                    * val[i][0], val[i][1], val[i][2],
                    * val[i][3], val[i][4], val[i][5]);
                    */
                   file_data += "  call_other( " + funs[ ind[ i ] ][ 1 ] +
                               ", " + funs[ ind[ i ] ][ 0 ] + ", " + val[ i ] +
                               " );\n";
               }
           }
           else
           {
               write( "Error: Unknown index " + ind[ i ] + "\n" );
           }
       }
       //file_data +="  \"" + file_name( this_object() ) + "\"->"
       //            "set_return_ob( clone );\n} /* create() */\n";
       file_data += "   return clone;\n} /* create_virtual_ob() */\n";
       /* Ok, now write the file */
       unguarded((: write_file, tmp_name, file_data :));
   }
 
 
   if( data = catch( return_ob = tmp_name->create_virtual_ob() ) )
   {
        write( "Error loading " + file + ", " + data + "\n" );
        if( debug_file )
        {
            write( "File not removed.\n" );
        }
        else
        {
            //unguarded((: rm, tmp_name :));
        }
    }
    else
    {
        tmp_name->dest_me();
        //unguarded((: rm, tmp_name :));
        return return_ob;
    }
}                               /* prop_to_fun() */
 
 
string  strip_string( string str )
{
    int     i, j;
 
    j = strlen( str ) - 1;
    for( ; WHITESPACE( str[ i ] ) && i < j; i++ ) ;
 
    for( ; WHITESPACE( str[ j ] ) && j > i; j-- ) ;
 
    return str[ i..j ];
}                               /* strip_space() */
 
 
mixed   str_to_var( string str )
{
    /* We deal with a few different situations here. If our first character is
     * a linefeed, we have a chunk of text that we will take "as is" but strip
     * the linefeeds (for discworld) ignoring the fact that spaces make exist
     * between end-of-line and lf... fuck it, that's a creator problem. :)
     * 
     * After many attempts with explodes and implodes and shit, I am now
     * doing this in a LPC loop. too
     * slow? I dunno. *shrug* */
    int     i;
 
    str = strip_string( str );
    switch( str[ 0 ] )
    {
        case '{':
            {
                str = str[ 1..strlen( str ) - 2 ];
                return map_array( explode( str, "," ), "str_to_var",
                                  this_object() );
            }
        case '"':
            {
                str = str[ 1..strlen( str ) - 2 ];
                return replace( str, "\n", " " ) + "\n";
            }
        case '0'..'9':
        case '-':
            {
                sscanf( str, "%d", i );
                return i;
            }
    }
    return str;
} /* str_to_var() */
 
 
mixed  *extract_arguments( string str )
{
    return map_array( explode( str, "//" ), "str_to_var", this_object() );
} /* extract_arguments() */
 
// modified 26-MAY-97  Olorin 
object  compile_r( string name, int clone ) {
    object r;
    r = prop_to_fun( name, r_funcs, "\"/obj/virtual_room.c\"",
                    "virtual_room.h", 1 );
    r->reset();
    return r;
} /* compile_r() */
 
 
object  compile_ob( string name, int clone ) {
    return prop_to_fun( name, o_funcs, "\"/std/object.c\"",
                    "virtual.h", clone );
} /* compile_ob() */
 
 
object  compile_arm( string name, int clone ) {
    if (name[0 .. 19] == "/obj/armours/shield/")
        return prop_to_fun(name, arm_funcs, "\"/obj/shield.c\"",
                        "virtual.h", clone );
    return prop_to_fun( name, arm_funcs, "\"/obj/armour.c\"",
                    "virtual.h", clone );
} /* compile_arm() */
 
// Added 1-Oct-95 -- Jeremy
object  compile_clo( string name, int clone ) {
    return prop_to_fun( name, clo_funcs, "\"/obj/clothing.c\"",
                    "virtual.h", clone );
} /* compile_clo() */
 
object compile_sca( string name, int clone ) {
   return prop_to_fun( name, sca_funcs, "\"/obj/scabbard.c\"",
                    "virtual.h", clone );
} /* compile_sca() */
 
object  compile_wep( string name, int clone ) {
    return prop_to_fun( name, wep_funcs, "\"/obj/weapon.c\"",
                    "virtual.h", clone );
} /* compile_wep() */
 
 
object  compile_mon( string name, int clone ) {
    return prop_to_fun( name, mon_funcs, "\"/obj/monster.c\"",
                    "virtual.h", clone );
} /*compile_mon() */

/* Added by Pinkfish Sat Aug 23 20:21:35 WST 1997 */
object  compile_food( string name, int clone ) {
    return prop_to_fun( name, food_funcs, "\"/obj/food.c\"",
                    "virtual.h", clone );
} /*compile_food() */

/* Added by Pinkfish Sat Aug 23 20:21:35 WST 1997 */
object  compile_cont( string name, int clone ) {
    return prop_to_fun( name, cont_funcs, "\"/obj/cont_medium.c\"",
                    "virtual.h", clone );
} /*compile_cont() */

/* Added by Pinkfish Wed Nov 17 00:56:00 PST 1999 */
object  compile_clotrans( string name, int clone ) {
    return prop_to_fun( name, clotrans_funcs, "\"/obj/clothing_transport.c\"",
                    "virtual.h", clone );
} /*compile_cont() */

object  compile_imp( string name, int clone ) {
    return prop_to_fun( name, o_funcs, "\"/obj/implement.c\"",
                    "virtual.h", clone );
} /* compile_imp() */

int set_debug_status(int d_stat) {
  debug_file=d_stat;
  return debug_file;
} /* set_debug_status */
// --- END [/mnt/home2/grok/lib/global/virtual/compiler.c] ---
// --- BEGIN [/mnt/home2/grok/lib/global/virtual/new_c_compiler.c] ---
// Size:   File: "/mnt/home2/grok/lib/global/virtual/new_c_compiler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627370   Available: 13574724
Inodes: Total: 5242880    Free: 4960133
310 bytes, Last Modified:   File: "/mnt/home2/grok/lib/global/virtual/new_c_compiler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627370   Available: 13574724
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:52.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: new_c_compiler.c,v 1.1 1998/01/06 04:55:54 ceres Exp $
 * $Log: new_c_compiler.c,v $
 * Revision 1.1  1998/01/06 04:55:54  ceres
 * Initial revision
 * 
*/
/*
 * Virtual compiler
 */

object clone_virtual_object(string name) {
  return efun::clone_object(name);
}
// --- END [/mnt/home2/grok/lib/global/virtual/new_c_compiler.c] ---
// --- BEGIN [/mnt/home2/grok/lib/global/virtual/vr_hand.c] ---
// Size:   File: "/mnt/home2/grok/lib/global/virtual/vr_hand.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627369   Available: 13574723
Inodes: Total: 5242880    Free: 4960133
2487 bytes, Last Modified:   File: "/mnt/home2/grok/lib/global/virtual/vr_hand.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627369   Available: 13574723
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:52.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: vr_hand.c,v 1.1 1998/01/06 04:55:54 ceres Exp $
 * $Log: vr_hand.c,v $
 * Revision 1.1  1998/01/06 04:55:54  ceres
 * Initial revision
 * 
*/
/*
   Limitations;
     No support for defines etc, to be added.
     plenty of others I haven't thought of yet ..

*/     




//Function Prototypes
object compile_virtual_room(string filename);
void parse_object(object room, string command);

void create()
{
  seteuid(getuid(this_object()));
} /* create */

object compile_virtual_room(string filen)
{
  string tmp, tmp2;
  object new_room;
  int i;
  i=3;
  tmp=read_file(filen, 2, 1);
  tmp2=tmp[1..strlen(tmp)-2];
  new_room=clone_object("/"+tmp2);
  while (read_file(filen, i, 1))
  {
    tmp=read_file(filen, i, 1);
    if(tmp=="") break;
    parse_object(new_room, tmp);
    i++;
  }
  return new_room;
} /* compile_virtual_room */

/* you want a directive for a particular function - add it to the list below */

void parse_object(object room, string command)
{
  string *func_call,s1,s2,s3;
  int i1,i2,i3,i4;
  if(!command) return;
  func_call=explode(command, "#");
  if((string)func_call[0][0]==";") return;
  switch (func_call[0])
  {
    case "SHORT" :
      room->set_short(func_call[1]);
      break;
    case "LONG" :
      room->set_long(func_call[1]);
      break;
    case "EXIT" :
      room->add_exit(func_call[1], func_call[2]);
      break;
    case "LIGHT" :
      i1=sscanf(func_call[1], "%d", i2);
      room->set_light(i2);
      break;
    case "ITEM" :
      room->add_item(explode(func_call[1], ","), explode(func_call[2], ","));
      break;
    case "TASTE" :
      room->add_taste(func_call[1], func_call[2]);
      break;
    case "SMELL" :
      room->add_smell(func_call[1], func_call[2]);
      break;
    case "SOUND" :
      room->add_sound(func_call[1], func_call[2]);
      break;
    case "TOUCH" :
      room->add_feel(func_call[1], func_call[2]);
      break;
    case "OBJECT" :
      room->add_object(func_call[1]);
      break;
    case "ACTION" :
      i2=0;
      catch(i1=sscanf(func_call[3], "%d", i2));
      room->action_add(func_call[1], func_call[2], i2);
      break;
    case "CODE" :
      room->set_code_module(func_call[1]);
      break;
    case "PROP" :
      room->add_property(func_call[1], func_call[2]);
      break;
    case "COORD" :
      i1=sscanf(func_call[1], "%d,%d,%d", i2,i3,i4);
      room->set_co_ord(({i2,i3,i4}));
      break;    
  }
  return;
} /* parse_object */

// --- END [/mnt/home2/grok/lib/global/virtual/vr_hand.c] ---
// --- BEGIN [/mnt/home2/grok/lib/global/virtual/handler.c] ---
// Size:   File: "/mnt/home2/grok/lib/global/virtual/handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627369   Available: 13574723
Inodes: Total: 5242880    Free: 4960133
10520 bytes, Last Modified:   File: "/mnt/home2/grok/lib/global/virtual/handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627369   Available: 13574723
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:52.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: handler.c,v 1.1 1998/01/06 04:55:54 ceres Exp $
 * $Log: handler.c,v $
 * Revision 1.1  1998/01/06 04:55:54  ceres
 * Initial revision
 * 
*/
mapping cloned_objects;

create() {
  seteuid("Room");
  cloned_objects = ([ ]);
  unguarded((: restore_object, "/global/virtual/handler" :));
}

self_dest() {
  unguarded((: save_object, "/global/virtual/handler" :));
  destruct(this_object());
}

mapping query_cloned_objects() { return cloned_objects; }

destruct_virtual_object(object obj) {
  string name, trash;

  name = file_name(obj);
  if(sscanf(name, "%s#%s", name, trash) == 2)
    name = trash;
  if(cloned_objects[name])
    map_delete(cloned_objects, name);
}

object find_virtual_object(string name) {
  string trash;

  if(sscanf(name, "%s#%s", name, trash) == 2)
    name = trash;
  if(cloned_objects[name])
    return (object)cloned_objects[name];
  return (object)0;
}

int error(string str) {
  write(str+"\n");
  return 1;
}

int str_to_int(string str) {
  int i, j, k;

  for(i=strlen(str)-1,j=1;i>-1;k+=(str[i--]-48)*j,j*=10) ;
  return k;
}

mixed *sort_arguments(mixed *args) {
  int i;

  for(i=0;i<sizeof(args);i++) {
    if(pointerp(args[i])) 
      args[i] = sort_arguments(args[i]);
    else if(args[i][0..0] != "\"")
      args[i] = str_to_int(args[i]);
    else {
      args[i] = args[i][1..strlen(args[i])-2];
      if(args[i][strlen(args[i])-2..strlen(args[i])-1] == "\\n")
        args[i] = args[i][0..strlen(args[i])-3] + "\n";
    }
  }
  return args;
}

mixed *add_item(mixed *args, int m, string str) {
  if(m == 0)
    args += ({ str });
  else
    args[sizeof(args)-1] = add_item(args[sizeof(args)-1], m-1, str);
  return args;
}

mixed *add_level(mixed *args, int m) {
  if(m == 0) {
    args += ({ "" });
    args[sizeof(args)-1] = ({ });
  } else
    args[sizeof(args)-1] = add_level(args[sizeof(args)-1], m-1);
  return args;
}

object use_efun_clone(string file) {
  log_file("NON_VIRTUAL", file +"\n");
  return efun::clone_object(file);
}

/* This function will read a .c file in /d/ and try to make it */
/* virtual.  If it fails it will use the efun clone_object     */
object clone_virtual_object(string file) {
  int i, j, k, l, m, len;
  string data, *line, file_to_inherit, start, comment, rest;
  object obj;
  mixed *args;

  /* Notes:                                              */
  /* 1) path is stored in file_to_inherit to save memory */
  /* 2) line[0] is also used as a temporary variable     */

  /* If it is too big it's probably not virtual */
  if(file_size(file) > 5000)
    return use_efun_clone(file);

  /* Read the file */
  data = read_file(file);

  /* find the path to the file */
  line = explode(file, "/");
  file_to_inherit = "/" + implode(line[0..sizeof(line)-2], "/") + "/";

  /* read the include files */
  line = ({ (string)0 });
  while(sscanf(data, "%s#include \"%s\"%s", start, comment, rest) == 3) {
    if(!(line[0] = read_file(file_to_inherit + comment)))
      line[0] = read_file("/include/" + comment);
    if(line[0])
      data = start + line[0] + rest;
    else {
      error("Include file not found.");
      return (object)0;
    }
  }

  /* remove the comments */
  while(sscanf(data, "%s/*%s*/%s", start, comment, rest) == 3)
    data = start + rest;

  /* count the number of inherits */
  i = 0;
  file_to_inherit = data;
  while(sscanf(file_to_inherit, "%sinherit%s", start, file_to_inherit) == 2) {
    i++;
  }
  if(i != 1)
    return use_efun_clone(file);

  /* See if there is only one function than setup() */
  i = 0;
  file_to_inherit = data;
  /* first remove the array brackets */
  while(sscanf(file_to_inherit, "%s({%s", start, rest)  == 2)
    file_to_inherit = start + rest;
  while(sscanf(file_to_inherit, "%s{%s", start, file_to_inherit)  == 2)
    i++;
  if(i != 1)
    return use_efun_clone(file);

  /* make sure it's the setup */
  if(!(sscanf(data, "%ssetup()%s", start, rest) == 2))
    return use_efun_clone(file);

  /* Split it in lines */
  line = explode(data, "\n");

  /* Remove empty lines */
  line -= ({ "" });

  /* remove spaces and tabs from the start and end of the line */
  for(i=0;i<sizeof(line);i++) {
    len = strlen(line[i]);
    for(j=0;j<len;j++) {
      if((line[i][j..j] == " " || line[i][j..j] == "\t") && j == 0) {
        line[i] = line[i][1..len];
        j--;
      }
    }
    for(j=len-1;j>-1;j--) {
      if((line[i][j..j] == " " || line[i][j] == 0) && j == (len-1)) {
        line[i] = line[i][0..len-2];
        len--;
      }
    }
  }

  /* see if there are any variable declerations */
  for(i=0;i<sizeof(line);i++)
    if((line[i][0..3] == "int ") ||
       (line[i][0..5] == "mixed ") ||
       (line[i][0..6] == "object ") ||
       (line[i][0..6] == "string ") ||
       (line[i][0..7] == "mapping "))
      return use_efun_clone(file);

  /* Find and replace the defined stuff */
  for(i=0;i<sizeof(line);i++)
    if(line[i][0..7] == "#define ") {
      len = strlen(line[i]);
      for(j=8;j<len && line[i][j..j] != " ";j++);
      comment = line[i][8..j-1];
      file_to_inherit = line[i][j+1..len];
      line = delete(line, i--, 1);
      if(j < len)
        for(k=0;k<sizeof(line);k++)
          if(sscanf(line[k], "%s"+comment+"%s", start, rest) == 2)
            line[k] = start + file_to_inherit + rest;
    }

  /* remove spaces from the middle of lines       */
  /* split lines with more than one ;             */
  /* remove "+"                                   */
  /* and while we're at it join some of the lines */
  for(i=0;i<sizeof(line);i++) {
    for(j=0,k=0,l=0;j<strlen(line[i]);j++) {
      switch(line[i][j..j]) {
        case "\"" :
          if(!k) {
            k = 1;
            if(l && l+1 == j)
              if(l+2 < strlen(line[i]))
                line[i] = line[i][0..l-2] + line[i][l+2..strlen(line[i])];
              else {
                line[i] = line[i][0..l-2] + line[i+1];
                line = delete(line,i+1,1);
              }
          }
          else
            k = 0;
          break;
        case " " :
          if(!k)
            if(j)
              line[i] = line[i][0..--j] + line[i][j+2..strlen(line[i])];
            else
              line[i] = line[i][1..strlen(line[i])];
          break;
        case ";" :
          if(!k && j != strlen(line[i])-1) {
            line = line[0..i] + line[i][j+1..1000] + line[i+1..1000];
            line[i] = line[i][0..j];
            j=0;
          }
          break;
        case "+" :
          if(!k && j && line[i][j-1..j-1] == "\"")
            l = j;
          break;
      }
    }
    if((k)) {
      line[i] = line[i--] + line[i+2];
      line = delete(line,i+2,1);
    } 
    /* what happens if it's an }                                     */
    /*|| (!k && line[i][strlen(line[i])-1..strlen(line[i])-1] != ";")*/
  }

  /* join the remaining long lines */
  for(i=0;i<sizeof(line);i++) {
    len = strlen(line[i]);
    if(line[i][len-1..len-1] != ";")
      if(line[i][len-2..len-1] == "\"+") {
        if(line[i+1][0..0] == "\"")
          line[i] = line[i--][0..len-3] + line[i+2][1..1000];
        else
          line[i] = line[i--] + line[i+2];
        line = delete(line,i+2,1);
      }
  }

  /* Find the file to inherit */
  for(i=0;i<sizeof(line);i++)
    if(line[i][0..6] == "inherit")
      file_to_inherit = line[i][8..sizeof(line[i])-3];

  /* For now if it's /std/room  don't do it */
  if(file_to_inherit[0..8] == "/std/room")
    return use_efun_clone(file);

  /* try to clone the object and define it*/
  obj = clone_object(file_to_inherit);

  obj->add_property("file_name", file);
  start = file_name(obj);
  if(sscanf(start, "%s#%s", start, rest) == 2)
    cloned_objects[rest] = obj;
  else
    cloned_objects[start] = obj;

  for(i=0;i<sizeof(line);i++)
    if(line[i] == "setup(){" || line[i] == "voidsetup(){")
      break;
  
  for(i++;i<sizeof(line);i++) {
    if(line[i] != "}") {
      sscanf(line[i], "%s(%s", start, comment);
      for(j=0,l=0,args=({});j<strlen(comment);j++) {
        if(comment[j..j] == "(") {
          if(comment[j+1..j+1] == "{" || comment[j+1..j+1] == "[") {
            args = add_level(args, l++);
            comment = comment[j+2..1000];
            j = -1;
            continue;
          }
        }
        if(comment[j..j] == ")") {
          if(comment[j-1..j-1] == "}" || comment[j-1..j-1] == "]") {
            if(j-1)
              args = add_item(args, l--, comment[0..j-2]);
            comment = comment[j+1..1000];
            j = -1;
            continue;
          }
        }
        if(comment[j..j] == "\"") {
          if(k)
            k = 0;
          else
            k = 1;
        }
        if(comment[j..j] == "," && k == 0) {
          if(!l) {
            if(j)
              args = add_item(args, l, comment[0..j-1]);
            comment = comment[j+1..1000];
            j = -1;
            continue;
          } else {
            if(comment[j+1..j+1] == "}" || comment[j+1..j+1] == "]") {
              if(!j)
                comment = comment[j+1..1000];
              else
                comment = comment[0..j-1] + comment[j+1..1000];
            } else {
              if(j)
                args = add_item(args, l, comment[0..j-1]);
              comment = comment[j+1..1000];
            }
            j = -1;
            continue;
          }
        }
        if(comment[j..j] == ")" && k == 0 && l == 0) {
          if(comment[j-1..j-1] != "}" && comment[j-1..j-1] != "]") {
            args = add_item(args, l, comment[0..j-1]);
            comment = comment[j+1..1000];
            j = -1;
          }
        }
      }

      args = sort_arguments(args);
      
      switch(sizeof(args)) {
        case 1 : 
          call_other(obj, start, args[0]);
          break;
        case 2 : 
          call_other(obj, start, args[0], args[1]);
          break;
        case 3 : 
          call_other(obj, start, args[0], args[1], args[2]);
          break;
        case 4 : 
          call_other(obj, start, args[0], args[1], args[2], args[3]);
          break;
        case 5 : 
          call_other(obj, start, args[0], args[1], args[2], args[3], args[4]);
          break;
        case 6 : 
          call_other(obj, start, args[0], args[1], args[2], args[3], args[4], args[5]);
          break;
        case 7 : 
          call_other(obj, start, args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
          break;
      }
    }
  }
  log_file("VIRTUAL", file +"\n");
  return obj;
}

// --- END [/mnt/home2/grok/lib/global/virtual/handler.c] ---
// --- BEGIN [/mnt/home2/grok/lib/global/virtual/server.c] ---
// Size:   File: "/mnt/home2/grok/lib/global/virtual/server.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627366   Available: 13574720
Inodes: Total: 5242880    Free: 4960133
3702 bytes, Last Modified:   File: "/mnt/home2/grok/lib/global/virtual/server.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627366   Available: 13574720
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:52.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: server.c,v 1.4 2002/11/30 21:51:03 presto Exp $
 * $Log: server.c,v $
 * Revision 1.4  2002/11/30 21:51:03  presto
 * Check if ob was actually created in create_virtual_object before trying
 * to call functions on it
 *
 * Revision 1.3  2001/03/22 18:48:04  pinkfish
 * Make it use a property for the virtual name stuff.
 *
 * Revision 1.2  1999/06/22 02:19:11  ceres
 * Modified to save file reads
 *
 * Revision 1.1  1998/01/06 04:55:54  ceres
 * Initial revision
 * 
*/
/*
 * This is an experimental virtual-object server, written for DiscWorld
 * by Zellski. The frontend to the mudlib consists of the two functions
 * virtual_{clone, load}() which will return an object, with a 'real'
 * object as 'program' and 'variable space' but with state of properties
 * defined in some fashion by the contents of the file virtual-cloned/loaded.
 *
 * Drawbacks as yet:
 *  * The actual compilation methods are barely enough even for testing
 *    purposes but that is simple enough to expand.
 *  * The use of explode() for skipping whitespace is pathetically stupid. 
 *  * There is no support for comments in the virtual-files in prop-to-fun.
 *
 * A quick explanation of masters/clones.
 * There is no distinction as in LPC, the only one made is for finding
 * the object pointers from a virtual filename. For this there IS a 
 * virtual_clone and virtual_load that should be used. they produce much
 * the same objects, except they CAN choose to make a diff - the clone/load
 * flag is passed along to compilation. This is needed for .c files of course.
 * Remember though that even a 'master' BO, /foo/bar.x IS a clone in the end,
 * of some LPC-file. There is no support for using LPC masterobjects.
 * You can find a virtual 'master' but not a clone, you may only get a list
 * of clones made of a given file.
 */


#include "virtual.h"
 
void add_method(string suffix, mixed ob, string fun, int type);
mapping methods;

/*
 * Each entry in virtual_objects is of the form ({ master, clone1, ... }).
 * Each entry in methods on ({ object, function }).
 */

#define OB   0
#define FUN  1
#define TYPE 2

nosave mapping cache;

void create() {
  seteuid(getuid());
  methods = ([ ]);
  add_method("c", "/global/virtual/c_compiler.c", "compile_c", 
                        CLONE|LOAD);
  add_method("C", "/global/virtual/c_compiler.c", "compile_c", 
                        CLONE|LOAD);
  cache = ([ ]);
} /* create() */

object create_virtual_object(string name, int clone);

void add_method(string suffix, mixed ob, string fun, int type) {
  /*
   * teach us how to compile a new kind of file..
   */
  if (!type)
    type = CLONE;

  if (!methods[suffix]) {
    methods[suffix] = ({ ob, fun, type });
  }
} /* add_method() */

#define Error(s) write(s); log_file("VO_HANDLER", s); return 0;

string get_mod_time(string name) {
  if(cache[name])
    return cache[name];

  if(file_size(name) <= 0)
    cache[name] = "";
  else
    cache[name] = stat(name)[1];

  return cache[name];
}
object create_virtual_object(string name, int clone) {
  string *split;
  mixed  *method;
  object ob;

  split = explode(name, ".");
  method = methods[split[sizeof(split) - 1]];
  if (method) {
    if (clone ||
        (method[TYPE]&LOAD)) {
      ob =  (object) call_other(method[OB], method[FUN], name, clone);
      if (ob)  {
      ob->add_property(VIRTUAL_NAME_PROP, name);
        if (get_mod_time(name) != "")
          ob->add_property("virtual time", get_mod_time(name));
      }
      return ob;
    }
    return 0;
  }
  Error("create_virtual_object() : unknown suffix to " + name + "\n");
} /* create_virtual_object() */

void reset() {
  cache = ([ ]);
}
// --- END [/mnt/home2/grok/lib/global/virtual/server.c] ---
// --- BEGIN [/mnt/home2/grok/lib/global/start_position.c] ---
// Size:   File: "/mnt/home2/grok/lib/global/start_position.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627365   Available: 13574719
Inodes: Total: 5242880    Free: 4960133
8357 bytes, Last Modified:   File: "/mnt/home2/grok/lib/global/start_position.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627365   Available: 13574719
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:52.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Id: start_position.c,v 1.14 2003/07/16 19:04:48 pinkfish Exp $
 */

/**
 * This file contains all the start position related code.  It sets up
 * and controls the start location of the player.  This was split off from
 * the main player code by Pinkfish in April 1998.
 * @see /global/player.c
 * @author Pinkfish
 */
inherit "/std/basic/virtual_quit_control";

#include <playerinfo.h>
#include <config.h>

#define MULTIPLAYER "/obj/handlers/multiplayer"

private int  *saved_co_ords;
private string last_pos;
private string *starts;

protected void inform_entered_game();
int query_creator();
string query_name();
string query_cap_name();
string the_short();
varargs int move(string pos, string messin, string messout);
string query_nationality_start_location();

void create() {
   starts = ({ });
} /* create() */

/**
 * This method returns the co-ordinates of the room in which the player
 * last saved.
 * @see check_last_pos()
 * @see move_to_start()
 * @see query_start_pos()
 * @return the last saved co-ordinates
 */
int *query_saved_co_ords() { return saved_co_ords; }

/**
 * This method sets the current start location.
 * @param last_pos the start location
 */
protected void set_last_pos(string pos) {
  if(pos[0..4] != "/room")
    last_pos = pos;
} /* set_last_pos() */

/**
 * This method returns the last saved position of the player.
 * @return the last saved position
 */
string query_last_pos() {
   return last_pos;
}

/**
 * This method returns the starting location of the player.  This the
 * location they will start at if the saved position does not work
 * for some reason.
 * @return the start position to use
 * @see query_starts()
 * @see add_start()
 * @see remove_start()
 * @see reset_starts()
 * @see set_start_location()
 */
string query_start_pos() {
   string start_pos;

   if ( !sizeof( starts ) ) {
      start_pos = query_nationality_start_location();
   } else {
      start_pos = starts[ 0 ];
   }
   if ( !find_object( start_pos ) ) {
      if ( catch( call_other( start_pos, "??" ) ) ) {
         start_pos = query_nationality_start_location();
      }
   }
   return start_pos;
} /* query_start_pos() */

/**
 * This method returns the current array of possible start positions on
 * the player.
 * @return the array of possible start locations
 * @see query_start_pos()
 * @see add_start()
 * @see remove_start()
 * @see reset_starts()
 * @see set_start_location()
 */
string *query_starts() {
   return starts;
}

/**
 * This method resets the start locations back to an empty array.
 * @see query_start_pos()
 * @see add_start()
 * @see remove_start()
 * @see query_starts()
 * @see set_start_location()
 */
void reset_starts() { starts = ({ }); }

/**
 * This method will add a new start location to the player.  The
 * description will be used in the starts command.
 * @param start_file the file name of the start location
 * @param start_desc the description of the start location
 * @see query_start_pos()
 * @see reset_starts() 
 * @see remove_start()
 * @see query_starts()
 * @see set_start_location()
 * @example
 * // NB: This should be done with a define :)
 * player->add_start("/d/am/am/mendeddrum", "the mended drum");
 */
void add_start( string start_file, string start_desc ) {
   if ( !starts ) {
      starts = ({ });
   }
   if ( member_array( start_file, starts ) != -1 ) {
      return;
   }
   starts += ({ start_file, start_desc });
} /* add_start() */

/**
 * This method will remove a start location from the player.
 * @param start_file the file name of the location to remove
 * @see query_start_pos()
 * @see reset_starts()
 * @see add_start()
 * @see query_starts()
 * @see set_start_location()
 * @example
 * // NB: This should be done with a define :)
 * player->remove_start("/d/am/am/mendeddrum");
 */
void remove_start( string start_file ) {
   int i;

   if ( !starts ) {
      return;
   }
   i = member_array( start_file, starts );
   if ( i == -1 ) {
      return;
   }
   starts = delete( starts, i, 2 );
} /* remove_start() */

/**
 * This method sets the start location of the player.
 * @param start_file the start location to set
 * @see query_start_pos()
 * @see reset_starts()
 * @see remove_start()
 * @see query_starts()
 * @see add_start()
 * @example
 * // NB: This should be done with a define :)
 * player->set_start_location("/d/am/am/mendeddrum");
 */
void set_start_location( string start_file ) {
  int i;

  if ( !starts) {
    return ;
  }

  i = member_array(start_file, starts);
  if (i <= 0) {
    return ;
  }
  starts = starts[i..i + 1] + starts[0..i - 1] + starts[i + 2..];
} /* set_start_location() */

/**
 * This method moves the player to the last saved position.  This should
 * only be called in the startup sequence.  If the last location could
 * not be loaded, the the start position will be used.
 * @see query_last_pos()
 * @see quert_start_pos()
 */
protected void move_to_start_pos() {
   if (!last_pos || catch(call_other(last_pos, "??"))) {
      last_pos = query_start_pos();
      saved_co_ords = 0;
   }
   move(last_pos);

   /*
    * Set the old coord if one does not already exist.  Otherwise don't
    * destroy the already existing scheme.
    */
   if ( !last_pos->query_co_ord() && !last_pos->query_property( "no map" ) &&
         saved_co_ords && !query_creator() ) {
      last_pos->set_co_ord( saved_co_ords );
   }

   inform_entered_game();
} /* move_to_start_pos() */

private function query_extra_login_stuff(string start) {
   string ip_str;
   object *obs;
   object mph;
   string alert;
   int num;
   string *dups;

   switch (this_object()->query_invis()) {
      case 3 :
         start += " (trustee invisible)";
         break;
      case 2 :
         start += " (director invisible)";
         break;
      case 1 :
         start += " (invisible)";
         break;
   }

   mph = load_object(MULTIPLAYER);
   obs = filter(users() - ({ this_object() }),
                (: query_ip_number($1) == query_ip_number(this_object()) &&
                   !$1->query_login_ob() :));
   if (sizeof(obs) &&
       sizeof((dups = mph->check_allowed(this_object(), obs)))) {
      ip_str = " (" + query_ip_name(this_object()) + ")";
      ip_str += " Duplicate: " + query_multiple_short(dups);
   }

   if (!catch(num = PLAYERINFO_HANDLER->query_alerts_for(query_name()))) {
      if (num > 0) {
         alert = " %^BOLD%^%^RED%^" + num + " alert";
         if (num > 1) {
            alert += "s";
         }
         alert += "%^RESET%^";
      }
   }

   if (ip_str) {
      if (!alert) {
         alert = "";
      }
      return (: $(start) +
                       ($1->query_creator()?$(ip_str) + $(alert):"") :);
   } else {
      if (alert) {
         return (: $(start) + ($1->query_creator()?$(alert):"") :);
      } else {
         return (: $(start) :);
      }
   }

} /* query_extra_login_stuff() */

/**
 * This method handles informing people that the player has entered the
 * game.
 * @see move_to_start_pos()
 */
protected void inform_entered_game() {
   string logon_str;

   if ("/d/liaison/master"->query_member( query_name() ) ) {
      logon_str = query_cap_name() + " enters "
           "" + mud_name() + " %^YELLOW%^(Liaison)";
   } else {
      logon_str = query_cap_name() + " enters " +
           ( this_object()->query_property( "guest" ) ? "as a guest of " : "" ) +"" + mud_name() + ""+
           ( this_object()->query_property( "new player!" ) ? " (new player)" : "" );
   }
   user_event( this_object(), "inform",
               query_extra_login_stuff(logon_str),
               "logon", this_object());

   say(the_short()+" enters the game.\n", 0);
   last_pos->enter(this_object());
} /* inform_enter_game() */

/**
 * THis method is called to inform people that someone has just reconnected.
 */
void inform_reconnect_game() {
   
   user_event( "inform", 
         query_extra_login_stuff(query_cap_name() +
         " reconnects"), "link-death", this_object() );
} /* inform_reconnect_game() */

/**
 * This method figured out what the last saved position was and sets it
 * on the player.  This basicly sets the last saved postion.
 * @see query_last_pos()
 */
void check_last_pos() {
   last_pos = find_start_pos(this_object(), environment());
   saved_co_ords = find_start_coord(this_object(), environment());
} /* check_last_pos() */
// --- END [/mnt/home2/grok/lib/global/start_position.c] ---
// --- BEGIN [/mnt/home2/grok/lib/global/family.c] ---
// Size:   File: "/mnt/home2/grok/lib/global/family.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627362   Available: 13574716
Inodes: Total: 5242880    Free: 4960133
11403 bytes, Last Modified:   File: "/mnt/home2/grok/lib/global/family.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627362   Available: 13574716
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:52.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This class contains all the stuff needed to control families in a
 * player.
 * @author Pinkfish
 * @started Fri Oct 30 07:53:30 PST 1998
 */
#include <clubs.h>
#include <player.h>

/**
 * The class for family information in the family stuff for the player.
 * This is used internaly to the player object and should not be used
 * elsewhere.
 * @element name the family name
 * @element adjectives the adjectives
 * @element id the id
 * @element titles the allowed played titles
 * @element cur_title the current player title
 */
class family_information {
   string name;
   string* adjectives;
   string id;
   string* titles;
   string cur_title;
   string* clubs;
   string force_title;
   int force_timeout;
}

#define FAMILY_CLASS_SIZE 8


//
// The name of the variable is this because we need to preserve save file
// integrity.
//
private class family_information _family_name;

string query_name();
int set_family_name(string name);
int add_player_title(string title);
void remove_player_title(string title);

/**
 * This method creates the family information class and fills in all the
 * defaults.
 */
private class family_information create_family_info() {
   class family_information bing;

   bing = new(class family_information);
   bing->adjectives = ({ });
   bing->titles = ({ "mr", "miss", "mrs", "ms" });
   bing->clubs = ({ });
   return bing;
} /* create_family_info() */

/**
 * This is used by the refresh code.
 */
protected void setup_default_titles() {
   if (!_family_name) { 
       return;
   }

   _family_name->titles = ({ "mr", "miss", "mrs", "ms" });
}

/**
 * Update the adjectives.
 */
private void update_adjectives() {
   if (!_family_name) {
      return ;
   }
   _family_name->adjectives = ({ });
   _family_name->id = 0;
   if (_family_name &&
       _family_name->name) {
      _family_name->adjectives = explode(lower_case(_family_name->name), " ")[0..<2];
      _family_name->id = explode(lower_case(_family_name->name), " ")[<1];
   }

   if (_family_name &&
       _family_name->cur_title) {
      _family_name->adjectives += explode(_family_name->cur_title, " ");
   }
} /* update_adjectives() */

/**
 * This method checks to make sure the players current family name
 * is still valid.  This will be called on startup and at various
 * other times.
 * @see set_family_name()
 */
void check_family_name() {
   class family_information frog;
   string bing;

   if (!classp(_family_name) &&
       _family_name) {
      bing = (string)_family_name;
      _family_name = create_family_info();
      set_family_name(bing);
   }

   if (classp(_family_name) &&
       sizeof(_family_name) == 5) {
      frog = new(class family_information);
      frog->adjectives = _family_name->adjectives;
      frog->id = _family_name->id;
      frog->cur_title = _family_name->cur_title;
      frog->name = _family_name->name;
      frog->titles = _family_name->titles;
      frog->clubs = ({ });
      _family_name = frog;
   }
   if (classp(_family_name) &&
       sizeof(_family_name) == 6) {
      frog = new(class family_information);
      frog->adjectives = _family_name->adjectives;
      frog->id = _family_name->id;
      frog->cur_title = _family_name->cur_title;
      frog->name = _family_name->name;
      frog->titles = _family_name->titles;
      frog->clubs = _family_name->clubs;
      _family_name = frog;
   }

   if (_family_name &&
       _family_name->name) {
      if (!CLUB_HANDLER->is_family(_family_name->name) ||
          !CLUB_HANDLER->is_member_of(_family_name->name, query_name())) {
         _family_name->name = 0;
      }
   }

   if (_family_name &&
       strlen(_family_name->cur_title) > 20) {
      tell_object(this_object(),
                  "%^YELLOW%^Your title is too long!  Resetting.\n%^RESET%^");
      _family_name->cur_title = 0;
   }

   if (_family_name &&
       _family_name->cur_title) {
      if (member_array(lower_case(_family_name->cur_title),
                       _family_name->titles) == -1) {
         tell_object(this_object(),
                  "%^YELLOW%^Your title is invalid!  Resetting.\n%^RESET%^");
         _family_name->cur_title = 0;
      }
   }
   update_adjectives();
   // Make it check to make sure ther clubs still exist

   if (_family_name && _family_name->clubs) { 
       _family_name->clubs = filter(_family_name->clubs, 
           (: CLUB_HANDLER->is_club($1) :));
   }
} /* check_family_name() */

/**
 * This method sets the current family name of the player.
 * @param name the new family name
 * @see query_family_name()
 * @return 1 if successfuly set
 */
int set_family_name(string name) {
   // Not a family, or not a member.
   if (name && (!CLUB_HANDLER->is_family(name) ||
                !CLUB_HANDLER->is_member_of(name, query_name()))) {
      return 0;
   }
   if (!classp(_family_name)) {
      _family_name = create_family_info();
   }
   if (_family_name->name) {
      CLUB_HANDLER->remove_member(_family_name->name, query_name());
   }
   if (name) {
      _family_name->name = CLUB_HANDLER->query_club_name(name);
   } else {
      _family_name = 0;
   }
   update_adjectives();
   return 1;
} /* set_family_name() */

/**
 * This method queries the current family name of the player.
 * @return the name of the family, 0 if none set
 * @see set_family_name()
 */
string query_family_name() {
   if (stringp(_family_name)) {
      return (string)_family_name;
   }
   if (_family_name) {
      return _family_name->name;
   }
   return 0;
} /* query_family_name() */

/**
 * This method returns the current title of the player.
 * @return the current title of the player, 0 if none set
 * @see query_family_name()
 */
string query_player_title() {
   check_family_name();

   if (_family_name && classp(_family_name) &&
       _family_name->force_title) {
      if (-this_object()->query_time_on() > _family_name->force_timeout) {
         _family_name->force_title = 0;
      } else {
         return capitalize(_family_name->force_title);
      }
   }
   if (_family_name && classp(_family_name) &&
       _family_name->cur_title) {
      return capitalize(_family_name->cur_title);
   }
   return 0;
} /* query_player_title() */

/**
 * This method returns all the player titles as a nice list.
 * @return all the player titles
 */
string* query_all_player_titles() {
   if (!_family_name) {
      _family_name = create_family_info();
   }
   return _family_name->titles;
} /* query_all_player_titles() */

/**
 * This method sets the current title of the player.
 * @param title the new title to set
 * @return 1 if successful, 0 on failure
 * @see query_player_title()
 */
int set_player_title(string title) {
   string* bits;

   if (!_family_name) {
      _family_name = create_family_info();
   }

   if (strlen(title) > 20) {
      return 0;
   }

   //
   // Check and see if the title is valid.
   //
   if (!title ||
       member_array(lower_case(title), _family_name->titles) != -1) {
      if (title) {
         bits = explode(title, " ");
         _family_name->cur_title = implode(map(bits, (: capitalize($1) :)), " ");
      } else {
         _family_name->cur_title = 0;
      }
      update_adjectives();
      return 1;
   }
   return 0;
} /* set_player_title() */

/**
 * This method sets the forced title for the player.
 * @param force_title the new title
 * @param timeout the length of time for it to timeout
 * @return 1 on success, 0 on failure
 */
int set_forced_title(string title, int timeout) {
   _family_name->force_title = title;
   _family_name->force_timeout = -this_object()->query_time_on() + timeout;
   tell_object(this_object(), "%^CYAN%^You feel that other peoples perception "
               "of you has changed and you title is being "
               "misinterpreted.%^RESET%^\n");
   return 1;
}

/**
 * This method returns the title that has been forced upon you.
 * @return the forced title
 */
string query_forced_title() {
   return _family_name->force_title;
}

/**
 * This method adds the players title into the list of allowed titles.
 * @param title the title to add into the list
 * @see set_player_title()
 * @see remove_player_title()
 * @return 1 if the title was added successfuly, 0 if it exists
 * @example
 * player->add_player_title("lord");
 */
int add_player_title(string title) {
   title = lower_case(title);
   if (!_family_name) {
      _family_name = create_family_info();
   }
   if (member_array(title, _family_name->titles) == -1) {
      _family_name->titles += ({ title });
      return 1;
   }
   return 0;
} /* add_player_title() */

/**
 * This method removes the players title from the list of allowed titles.
 * @param title the title to remove from the list
 * @see set_player_title()
 * @see add_player_title()
 */
void remove_player_title(string title) {
   title = lower_case(title);
   if (!_family_name) {
      _family_name = create_family_info();
   }
   if (member_array(title, _family_name->titles) != -1) {
      _family_name->titles -= ({ title });
   }

   if (_family_name->cur_title == title) {
      _family_name->cur_title = 0;
   }
} /* remove_player_title() */

/**
 * This method adds a club to current list of known clubs on the
 * family.
 * @param club the club to add
 */
int add_player_club(string club) {
   class family_information frog;

   if (!club) {
      return 0;
   }
   club = CLUB_HANDLER->normalise_name(club);
   if (!CLUB_HANDLER->is_club(club)) {
      return 0;
   }
   if (!_family_name) {
      _family_name = create_family_info();
   }
   if (classp(_family_name) &&
       sizeof(_family_name) == 5) {
      frog = new(class family_information);
      frog->adjectives = _family_name->adjectives;
      frog->id = _family_name->id;
      frog->cur_title = _family_name->cur_title;
      frog->name = _family_name->name;
      frog->titles = _family_name->titles;
      frog->clubs = ({ });
      _family_name = frog;
   }

   if (member_array(club, _family_name->clubs) == -1) {
      _family_name->clubs += ({ club });
      return 1;
   }
   return 0;
} /* add_player_club() */

/**
 * This method removes a club from the list of know clubs.
 * @param club the club to remove
 */
void remove_player_club(string club) {
   if (!club) {
      return 0;
   }
   club = CLUB_HANDLER->normalise_name(club);
   if (!_family_name) {
      return ;
   }
   _family_name->clubs -= ({ club });
} /* remove_player_club() */

/**
 * This method returns the current know clubs the player is a meber of
 * @return the array of known clubs
 */
string* query_player_clubs() {
   if (!_family_name) {
      return ({ });
   }
   return _family_name->clubs;
} /* query_player_clubs() */

/**
 * @ignore yes
 * Adjectives which are added because of the family.
 */
string *parse_command_id_list() {
   if (_family_name &&
       _family_name->id) {
      return ({ _family_name->id });
   }
   return ({ });
} /* parse_command_id_list() */
/**
 * @ignore yes
 * Adjectives which are added because of the family.
 */
string *parse_command_plural_id_list() {
   if (_family_name &&
       _family_name->id) {
      return ({ pluralize(_family_name->id) });
   }
   return ({ });
} /* parse_command_id_list() */
/**
 * @ignore yes
 * Adjectives which are added because of the family.
 */
string *parse_command_adjectiv_id_list() {
   if (_family_name) {
      return _family_name->adjectives;
   }
   return ({ });
} /* parse_command_id_list() */
// --- END [/mnt/home2/grok/lib/global/family.c] ---
// --- BEGIN [/mnt/home2/grok/lib/global/auto_load.c] ---
// Size:   File: "/mnt/home2/grok/lib/global/auto_load.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627359   Available: 13574713
Inodes: Total: 5242880    Free: 4960133
18984 bytes, Last Modified:   File: "/mnt/home2/grok/lib/global/auto_load.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627359   Available: 13574713
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:52.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: auto_load.c,v 1.22 2003/07/15 13:09:06 taffyd Exp $
 */
/**
 * Handles the automatic loading and saving of objects into the
 * players inventories on log in/out.
 * @author Pinkfish
 * @change Ember 1992 sometime
 * Make it use greco and all the other exciting missing item receipt stuff
 */
#include <move_failures.h>
#include <virtual.h>
#include <player.h>

#define AUTO_STR_LENGTH 3

#define AUTO_LOAD_TYPE 0
#define AUTO_LOAD_NAME 1
#define AUTO_LOAD_DATA 2

/* Stuff for the data elements themselves */
#define AUTO_LOAD_STATIC_ARG  0
#define AUTO_LOAD_DYNAMIC_ARG 1

private mixed auto_load;
private nosave int _no_calls;
private nosave function _finished;

private void auto_clone_alt( object thing, mixed *load_info,
                     object dest, object tell_pl, function move_f, string name);
private object *int_auto_load(int type, string name, mixed *load_info,
                              object dest, object tell_pl, int now,
                              function move_f);
private void move_to_destination(object thing, object dest, object tell_pl,
                                 function move_f);

/** @ignore yes */
string *fragile_auto_str_ob(object ob) {
   /* this function was added by Ember 30-Oct-93 */
   /* it is a copy of auto_str_ob below, with all the catches taken out */
   /* it is intended for the newer style of saving/loading with receipts */
   mixed static_arg;
   mixed dynamic_arg;
   string fname;

   static_arg = ob->query_static_auto_load();
   dynamic_arg = ob->query_dynamic_auto_load();
   if (!static_arg && !dynamic_arg) {
      return ({ });
   }
   if ( sscanf( file_name( ob ), "%s#%*d", fname) == 2 ) {
      return  ({ 1, fname, ({ static_arg, dynamic_arg }) });
   } else {
      return ({ 0, file_name(ob), ({ static_arg, dynamic_arg }) });
   }
} /* fragile_auto_str_ob() */

/**
 * This method figures out the auto load string for the given object.
 *  The returned array contains 3 elements.  The first element is a
 * flag which tells if the object is a clone or the original object.
 * The second element is the name of the file and the third is the array
 * containing the saved information.  The third array contains three
 * elements.  The first is the static auto load information, the
 * second is the dynamic autoload information and the third is the shadow
 * auto load information.  The shadow autoload information is reduant these days
 * effects should be used instead.
 * @param ob the object to get the auto load information for
 * @return the array containing the auto load information
 * @see help::effects
 */
private string *auto_str_ob(object ob) {
   string static_arg;
   string dynamic_arg;
   string catch_static;
   string catch_dynamic;
   string fname;
   int value;
   string ob_name;
   mixed* tmp;

   catch_static = catch(static_arg = (string)ob->query_static_auto_load());
   catch_dynamic = catch(dynamic_arg = (string)ob->query_dynamic_auto_load());
   if (!static_arg && !dynamic_arg) {
      //
      // create receipts?
      //
      if (catch_static || catch_dynamic) {
         catch(value = ob->query_value());
         ob_name = "unknown object";
         catch(ob_name = ob->short(1));
         catch(PLAYER_RECEIPT->set_object(file_name(ob)));
         PLAYER_RECEIPT->set_obname(ob_name);
         PLAYER_RECEIPT->set_value(value);
         catch(PLAYER_RECEIPT->set_static_data(({ static_arg, dynamic_arg })));
         tmp = fragile_auto_str_ob(find_object("/obj/misc/al_receipt"));
         tmp[0] = 1;
         // This is a bit of a hack.  It could easily break if the receipt
         // inheritance changes.
         if (!undefinedp(tmp[2][1]["::"]["cloned by"])) {
           tmp[2][1]["::"]["cloned by"] = "greco";
         }
      } else {
         tmp = ({ });
      }
      return tmp;
   }

   if ( sscanf( file_name( ob ), "%s#%*d", fname ) == 2 ) {
      return  ({ 1, fname, ({ static_arg, dynamic_arg }) });
   } else {
      return ({ 0, file_name( ob ), ({ static_arg, dynamic_arg }) });
   }
} /* auto_str_ob() */

/**
 * Creates the complete auto load array from the array of objects
 * passed into this object.  It returns an array of elements 
 * as specified in auto_str_ob.  The arrays from auto_str_ob() are
 * added together, so every 3 elemnts in the array is a new
 * autoload object.
 * @param obs the objects to create an autoload string for
 * @param into_array place the results directly iunto the auto_load array
 * @return the auto load array
 * @see auto_str_ob()
 */
string *create_auto_load(object *obs, int into_array) {
  int i;
  string *tmp;
  string *al_tmp;

  if (into_array) {
    auto_load = ({ });
  } else {
    tmp = ({ });
  }
  /*
   * For some reason inventories are regenerated backwards, if we go from the
   *  the bottom of this array, so go from the top.
   */
  for (i = sizeof(obs) - 1; i >= 0; i--) {
    reset_eval_cost();
    if (!objectp(obs[i])) {
       continue;
    }
    if (!catch(al_tmp = auto_str_ob(obs[i]))) {
      if (into_array) {
         auto_load += al_tmp;
      } else {
         tmp += al_tmp;
      }
    }
  }
  return tmp;
} /* create_auto_load() */

/**
 * The new method of handling auto loading of objects.  This determines
 * if the object failed to load and gives the player a recipt if it does
 * not.
 * <p>
 * The finished variable should <b>only</b> be set in outer
 * level calls to this.  If you set it inside containers when they call
 * this it will cause errors.  This will only be called from within
 * the player object itself.
 * @param auto_string the values specifing the objects to auto load
 * @param dest the destination to put the objects in
 * @param tell who to tell about errors
 * @param finished the function to call when the auto loading has completed
 * @see create_auto_load()
 * @see load_auto_load()
 */
void load_auto_load_alt( mixed *auto_string, object dest,
                                   object tell_pl, function finished) {
   int i;

   reset_eval_cost();
   if ( !auto_string || !sizeof( auto_string ) ) {
      //tell_object(this_object(), "%^RED%^Warning!  Auto string is empty!%^RESET%^\n");
      return;
   }

   if ( !pointerp( auto_string ) ) {
      //tell_object(this_object(), "%^RED%^Warning!  Auto string is not an array!%^RESET%^\n");
      return;
   }

   /*
    * This is to try to handle the slight over-weight problems that people
    *  close to capacity may have due to mergers, e.g. money.
    */
   if ( ( dest == this_object() ) &&
        ( tell_pl == this_object() ) &&
        !this_object()->query_no_check() ) {
      this_object()->set_no_check( 1 );
      this_object()->set_max_weight( 100 + this_object()->query_max_weight() );
   }

   _finished = finished;
   reset_eval_cost();
   for ( i = 0; i < sizeof( auto_string ); i += AUTO_STR_LENGTH) {
      _no_calls++;
      call_out( (: int_auto_load :), i / 6,
                                     auto_string[ i + AUTO_LOAD_TYPE ],
                                     auto_string[ i + AUTO_LOAD_NAME ],
                                     auto_string[ i + AUTO_LOAD_DATA ],
                                     dest, tell_pl, 0, (: $1->move($2) :));
   }
} /* load_auto_load_alt() */

/**
 * This method creates all the objects and sets them up now.  This will
 * not move any of the objects anywhere...  Relying on the calling
 * code to handle this.
 * @param auto_string the values specifing the objects to auto load
 * @param dest the destination to put the objects in
 * @param tell who to tell about errors
 * @param finished the function to call when the auto loading has completed
 * @see create_auto_load()
 * @see load_auto_load()
 */
object *load_auto_load_to_array( mixed *auto_string, object tell_pl ) {
   object *obs;
   int i;

   obs = ({ });
   if (!tell_pl) {
      tell_pl = this_player();
   }
   if (!tell_pl) {
      tell_pl = this_object();
   }
   for ( i = 0; i < sizeof( auto_string ); i += AUTO_STR_LENGTH) {
      _no_calls++;
      /* Set a null function so it always appears to succeed. */
      obs += int_auto_load(auto_string[ i + AUTO_LOAD_TYPE ],
                           auto_string[ i + AUTO_LOAD_NAME ],
                           auto_string[ i + AUTO_LOAD_DATA ],
                           0, tell_pl, 1, (: MOVE_OK :));
   }
   return obs - ({ 0 });
} /* load_auto_load_to_array() */

/**
 * This method loads all the objects from the array and places them
 * into the inventory of the specified object.
 * @param auto_string the values specifing the objects to auto load
 * @param dest the destination to put the objects in
 * @param tell who to tell about errors
 * @param move_f the function to call to move the object to it's destination
 * @see create_auto_load()
 * @see load_auto_load()
 */
void load_auto_load_to_inventory(mixed *auto_string, object dest,
                                 object tell_pl, function move_f) {
   int i;

   if (!tell_pl) {
      tell_pl = this_player();
   }
   if (!tell_pl) {
      tell_pl = this_object();
   }
   for ( i = 0; i < sizeof( auto_string ); i += AUTO_STR_LENGTH) {
      _no_calls++;
      int_auto_load(auto_string[ i + AUTO_LOAD_TYPE ],
                    auto_string[ i + AUTO_LOAD_NAME ],
                    auto_string[ i + AUTO_LOAD_DATA ],
                    dest, tell_pl, 0, move_f);
   }
} /* load_auto_load_to_inventory() */

private object create_auto_load_object( string name, 
                                        mixed *load_info,  object dest,
                                        object tell_pl, function move_f) {
   object thing;

   catch(name = (string)CLONER->other_file( name ));
   if ( !catch( thing = (object)CLONER->clone( name ) ) ) {
      if ( thing ) {
         if ( base_name( thing ) == name ) {
            auto_clone_alt(thing, load_info, dest, tell_pl, move_f, name);
         } else {
            move_to_destination(thing, dest, tell_pl, move_f);
            //catch(thing->move( dest ));
         }
      } else {
  tell_object( tell_pl, "%^RED%^Could not clone "+ name +
         ".%^RESET%^\n" );
  thing = clone_object( PLAYER_RECEIPT );
  thing->set_object( name );
  thing->set_static_save( load_info );
  //thing->move( dest );
  move_to_destination(thing, dest, tell_pl, move_f);
      }
   } else {
      tell_object( tell_pl, "%^RED%^Error in loading "+ name +
       ".%^RESET%^\n" );
      thing = clone_object( PLAYER_RECEIPT );
      thing->set_object( name );
      thing->set_static_save( load_info );
      //thing->move( dest );
      move_to_destination(thing, dest, tell_pl, move_f);
   }
   return thing;
} /* create_auto_load_object() */

private object *int_auto_load(int type, string name, mixed *load_info,
                              object dest, object tell_pl, int now,
                              function move_f) {
   object thing;
   object new_thing;
   mixed *stuff;
   int reduce;

   _no_calls--;
   if ( type ) {
      //
      // Do this first so we don't leak receipts.
      //
      thing = create_auto_load_object(name, load_info, dest, tell_pl, move_f);
      if ( name == PLAYER_RECEIPT) {
         /* Try and reload the receipt */
         stuff = thing->query_static_save();
         if (stuff) {
            new_thing = create_auto_load_object(name, load_info, dest,
                                         tell_pl, move_f);
            if (new_thing) {
               thing->dest_me();
               thing = new_thing;
            }
         }
      }
   } else {
      if ( !find_object( name ) ) {
         if ( !catch( load_object( name ) ) ) {
            thing = find_object( name );
            if ( thing ) {
               auto_clone_alt(thing, load_info, dest, tell_pl, move_f, name);
            } else {
               tell_object( tell_pl, "%^RED%^Could not load "+ name +
          ".%^RESET%^\n" );
            }
         } else {
            tell_object( tell_pl, "%^RED%^Error in loading "+ name +
       ".%^RESET%^\n" );
         }
      } else {
         tell_object( tell_pl, "%^RED%^Object "+ name +
          " exists.%^RESET%^\n" );
      }
   }

   /* Check to see if we have finished */
   if (_no_calls == 0 && _finished) {
      /*
       * NB: This has to be run at the end of the setup...  Because a
       * container may attempt to reload some stuff.
       */
      evaluate(_finished, this_object());
      _finished = 0;

      this_object()->set_no_check( 0 );

      /*
       * This is to handle stuffing about with weights so players don't
       * loose stuff due to things like merging objects.
       */
      reduce = (int)this_object()->query_max_weight() -
             (int)this_object()->query_loc_weight();
      if ( reduce > 1 ) {
         if ( reduce > 100 ) {
            reduce = 100;
         }
         this_object()->set_max_weight( (int)this_object()->query_max_weight() -
                                 reduce );
      }
      this_object()->calc_burden();
   }
   if (thing) {
      return ({ thing });
   }
   return ({ });
} /* int_auto_load() */

/** @ignore yes */
private string ident( object thing ) {
   mixed word;

   catch(word = (string)thing->query_short());
   if ( stringp( word ) ) {
      return "\""+ word +"\"";
   }
   return file_name( thing );
} /* ident() */

/**
 * This moves the cloned object into the correct location and
 * loads up the arguments.  The arguments array contains three elements
 * the first is the object being cloned, the second is the auto load
 * string and the third is the destination to move the object too.  This is
 * used by the alternate system of loading objects.
 * @param arg the arg array
 * @see load_auto_load_alt()
 * @see create_auto_load()
 * @see auto_clone()
 */
private void auto_clone_alt( object thing, mixed *load_info,
                     object dest, object tell_pl, function move_f, string name) {
   string ob_path;

   /*
    * The setting up the object was previously done after this...
    * Not sure why?  Moved it to here...  Oh!  I have an idea.  The
    * object which fail might not end up being moved into the right place
    * or somewhere the player can see at all.  Changed the movement stuff
    * to also try and move into the telling players environment if we
    * run out of options.
    *
    * This is a moot problem now however, since with the inventory
    * generation one the contents is generated slowly after a while
    * anyway...
    */
   reset_eval_cost();
   if ( load_info[ AUTO_LOAD_STATIC_ARG ] ) {
      catch( thing->init_static_arg( load_info[ AUTO_LOAD_STATIC_ARG ],
                                     tell_pl ) );
   }
   catch( thing->set_player( tell_pl ) );

   if ( load_info[ AUTO_LOAD_DYNAMIC_ARG ] ) {
      catch( thing->init_dynamic_arg( load_info[ AUTO_LOAD_DYNAMIC_ARG ],
                                      tell_pl ));
   }

   //
   // We check to see if the virtual object exists or not.
   //
   ob_path = thing->query_property(VIRTUAL_NAME_PROP);
   if (ob_path) {
      ob_path = CLONER->other_file( ob_path );
      if (file_size(ob_path) < 0) {
         // Turn it into a receipt.
         thing->dest_me();
         thing = clone_object( PLAYER_RECEIPT );
         thing->set_object( name );
         thing->set_static_save( load_info );
         thing->set_virtobname( ob_path );
      } else {
         thing->add_property(VIRTUAL_NAME_PROP, ob_path);
      }
   }

   /*
    * This gets rid of illegal objects that don't have their own file
    * and gives the player a replacement of some kind
    */
   ob_path = CLONER->illegal_thing(base_name(thing), thing->query_short());
   if(ob_path) {
     thing->dest_me();
     thing = clone_object( ob_path );
   }

   move_to_destination(thing, dest, tell_pl, move_f);
} /* auto_clone_alt() */

private void move_to_destination(object thing, object dest, object tell_pl,
                                 function move_f) {
   object place;
   int ret_val;
   string catch_str;

   /* Move it into its correct location. */
   place = dest;
   ret_val = MOVE_OK - 1;
   while ( place && ret_val != MOVE_OK) {
      catch_str = catch( ret_val =  evaluate(move_f, thing, place ) );
      if(catch_str) {
        tell_object(tell_pl, "%^RED%^Error moving object: " + catch_str + 
        ".%^RESET%^\n");
        ret_val = MOVE_OK - 1;
      }
      
      if (ret_val != MOVE_OK) {
         if ( environment( place ) ) {
            tell_object( tell_pl, "%^RED%^Cannot move "+ ident( thing ) +
       " into "+
       ident( place ) +" (move returned " +
                         catch_str + "); attempting to move it into "+
                  ident( environment( place ) ) +".%^RESET%^\n" );
            place = environment( place );
/*
 * I don't think this case is needed.  I think it just
 * adds confusion to the issue.  Who thinks it just adds confusiong
 * to the issue, was this me? - pf
 */
         } else if ( ( place != environment(tell_pl) ) &&
                     environment( tell_pl ) ) {
            tell_object( tell_pl, "%^RED%^Cannot move "+ ident( thing ) +
       " into "+
       ident( place ) +" (move returned " +
                         ret_val + "); attempting to move it into "
       "environment of " + tell_pl->query_name() +
       ".%^RESET%^\n" );
            place = environment( tell_pl );
         } else  if (place != find_object("/room/broken")) {
            tell_object( tell_pl, "%^RED%^Cannot move "+ ident( thing ) +
       " into "+
       ident( place ) +" (move returned " + ret_val +
                         "); moving it to the room for broken objects "+
                         "--- please ask a creator for help.%^RESET%^\n" );
            load_object("/room/broken");
            place = find_object( "/room/broken" );
         } else {
            // Error!  Error!
            tell_object( tell_pl, "%^RED%^Cannot move "+ ident( thing ) +
       " into "+
       " the room for broken objects "+
       "--- This is a serious errror!  Please tell a "
       "creator immediately.%^RESET%^\n");
            place = 0;
         }
         /* Only use the strange move function for the first move. */
         move_f = (: $1->move($2) :);
      }
   }
} /* auto_clone_alt() */

/**
 * This method tells us if the player is in the inventory regeneration
 * phase still.
 * @return 1 if the inventory is being regenerated, 0 otherwise.
 */
int query_auto_loading() {
   return _no_calls > 0;
} /* query_auto_load_over() */

/**
 * This method retrusn the auto load string which is used to
 * regenerate the players inventory.
 * @return the array of the auto load string
 * @see set_auto_load_string()
 */
protected mixed query_auto_load_string() {
   return auto_load;
} /* query_auto_load_string() */

/**
 * This method sets the current auto load string to the specified value.
 * @see query_auto_load_string()
 */
protected void set_auto_load_string(mixed str) {
   auto_load = str;
} /* set_auto_load_string() */
// --- END [/mnt/home2/grok/lib/global/auto_load.c] ---
// --- BEGIN [/mnt/home2/grok/lib/global/telnet.c] ---
// Size:   File: "/mnt/home2/grok/lib/global/telnet.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627355   Available: 13574709
Inodes: Total: 5242880    Free: 4960133
1481 bytes, Last Modified:   File: "/mnt/home2/grok/lib/global/telnet.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627355   Available: 13574709
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:52.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: telnet.c,v 1.1 1998/01/06 04:54:05 ceres Exp $
 * $Log: telnet.c,v $
 * Revision 1.1  1998/01/06 04:54:05  ceres
 * Initial revision
 * 
*/
/*
 * This handels the telnet sub option stuff.  Will be mostly for handleing
 * terminal types.  Though you can get other information out of the
 * telnet connection.
 */
#include "telnet.h"

nosave string last_term;
nosave int got_terminal;

void check_terminal_type(string type);

void telnet_suboption(string str) {
  switch (str[0]) {
    case TELOPT_TTYPE :
      if (str[1] != TELQUAL_IS)
        return ;
      check_terminal_type(str[2..1000]);
      break;
  }
} /* telnet_suboption() */

/* Send all the relevant junk down to get the information we want. */
void player_connected() {
/* Turn on the option */
  printf("%c%c%c", IAC, DO, TELOPT_TTYPE);
/* Get them to send us their first terminal type */
  printf("%c%c%c%c%c%c", IAC, SB, TELOPT_TTYPE, TELQUAL_SEND, IAC, SE);
} /* player_connected() */

void check_terminal_type(string type) {
  if (last_term == type) {
/* We have cycled.  This is the last valid type.  We failed!  */
    if (!got_terminal)
      this_object()->set_network_terminal_type(0);
    return ;
  }
  if (!got_terminal && this_object()->set_network_terminal_type(type))
    got_terminal = 1;
/* Ask them for thr next terminal type */
  printf("%c%c%c%c%c%c", IAC, SB, TELOPT_TTYPE, TELQUAL_SEND, IAC, SE);
  last_term = type;
} /* check_terminal_type() */
// --- END [/mnt/home2/grok/lib/global/telnet.c] ---
// --- BEGIN [/mnt/home2/grok/lib/global/wiz_inter_comm.c] ---
// Size:   File: "/mnt/home2/grok/lib/global/wiz_inter_comm.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627354   Available: 13574708
Inodes: Total: 5242880    Free: 4960133
1797 bytes, Last Modified:   File: "/mnt/home2/grok/lib/global/wiz_inter_comm.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627354   Available: 13574708
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:52.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: wiz_inter_comm.c,v 1.2 1999/01/28 14:20:18 wodan Exp $
 * $Log: wiz_inter_comm.c,v $
 * Revision 1.2  1999/01/28 14:20:18  wodan
 * changed add_action to add_command
 *
 * Revision 1.1  1998/01/06 04:54:05  ceres
 * Initial revision
 * 
*/
#include <network.h>

private nosave string *imud_ignored;
int do_block(string);
int do_unblock(string);

void wiz_commands() {
  add_command("block", "", (:do_block(0):));
  add_command("block", "<word'name'>", (:do_block($4[0]):));
  add_command("unblock", "<word'name'>", (:do_unblock($4[0]):));
} /* wiz_commands() */

int do_block(string str) {
  if (!str) {
    if (!sizeof(imud_ignored)) {
      write("Not blocking anyone.\n");
      return 1;
    }
    write("Blocking "+query_multiple_short(imud_ignored)+".\n");
    return 1;
  }
  if (!pointerp(imud_ignored))
    imud_ignored = ({ lower_case(str) }); 
  else 
    imud_ignored += ({ lower_case(str) });
  write("Okay, now ignoring intermud channel messages from "+str+".\n");
  write("Use \"unblock\" to remove.\n");
  return 1;
}

int do_unblock(string str) {
  int idx;

  if (!str)
    return notify_fail("Syntax: unblock <name>|all\n");
  if (!pointerp(imud_ignored) || !sizeof(imud_ignored))
    return notify_fail("You are not blocking anyone.\n");
  if (str == "all") {
    imud_ignored = 0;
    write("Okay, unblocked everyone.\n");
    return 1;
  }
  if ((idx = member_array(lower_case(str), imud_ignored)) == -1)
    return notify_fail("You are not blocking "+str+".\n");
  imud_ignored = delete(imud_ignored, idx, 1);
  write("Okay, removed "+str+" from your blocked list.\n");
  return 1;
}

int check_not_ignored(string who) {
  if (!pointerp(imud_ignored))
    return 1;
  return member_array(lower_case(who), imud_ignored) == -1;
}
// --- END [/mnt/home2/grok/lib/global/wiz_inter_comm.c] ---
// --- BEGIN [/mnt/home2/grok/lib/global/line_ed.c] ---
// Size:   File: "/mnt/home2/grok/lib/global/line_ed.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627353   Available: 13574707
Inodes: Total: 5242880    Free: 4960133
14246 bytes, Last Modified:   File: "/mnt/home2/grok/lib/global/line_ed.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627353   Available: 13574707
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:52.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: line_ed.c,v 1.23 2001/08/25 01:52:19 ceres Exp $
 */

#include "ed.h"
#include <player_handler.h>

/**
 * This allows a piece of text to be placed into the players own
 * line editor (which ever one they wish to use).
 * <p>
 * Expansion of the editor.  We will now allow the player to use any
 * of three different editors.  One of them is the default (the old
 * one) one of them is ed and the other I am going to write in a
 * few secs....
 * <p>
 * cute line editor thing.  Which even a player could use!
 * @author Pinkfish
 */

/* September '97 - modified by Presto to allow players to use the 'magic'
 *                 editor and to allow cres to use it as their default file
 *                 editor.  Also cleaned up the code a bit cos it was painful
 *                 to look at.  Is this file a bunch of crocky code or what?
 */
private nosave string *_lines;
private nosave mixed _end_func;
//private nosave object _end_object;
private nosave object _ed_ob = 0;
//private nosave mixed *_other;
private nosave int _insertion_point;
private string editor; /* The editor to use... */
private nosave string _filename;

private nosave int _in_editor;

private void main_bit(string str);
int set_editor(string name);
private void editor_do_quit(string str);
private void editor_loop(string str);
private void editor_insert(string str);
private void editor_delete(string str);
private void editor_modify(string str);
private void editor_check_quit(string str);
private void editor_modify2(string str, int range1, int range2);
private void editor_modify3(string str, int range1, int range2,
                            string modify_string);

protected void create()  {
  editor = "menu";
} /* create() */

/** @ignore yes */
protected void editor_commands()  {
  add_command("editor", "{menu|magic|ed|command}", (: set_editor($4[0]) :));
} /* edito_commands() */

/**
 * Edit a string.  This will edit the string or file name and then
 * call the end function and end object at the end.  It will pas in
 * the string if the edit is successful, or 0 if it is not.
 * @param str the string to edit
 * @param end_f the function to call
 * @param end_o the object to call it on (defaul: previous_object())
 * @param fname a specific filename to edit
 * @param extra an array of any parameters you need to carry into the end function
 * @return 0 on failure.
 */
varargs int do_edit(string str, mixed end_f, object end_o, string fname,
                    mixed extra)  {
  if (!end_f) {
    printf("Someone has stuffed up - there is no end function.\n");
    return 0;
  } else {
    _end_func = end_f;
  }
/*
  if(extra) {
    _other = extra;
  }
  if ( !end_o ) {
    _end_object = previous_object();
  } else {
    _end_object = end_o;
  }
 */
  if (!end_o) {
    end_o = previous_object();
  }

  if (!str) {
    str = "";
  }

  if (!strlen(fname)) {
    _filename = TMP_FILE;
  } else {
    _filename = fname;
  }

  if (!functionp(end_f)) {
    if (extra) {
      _end_func = (: call_other($(end_o), $(end_f), $1, $(extra)) :);
    } else {
      _end_func = (: call_other($(end_o), $(end_f), $1) :);
    }
  } else {
    if (extra) {
      _end_func = (: evaluate($(end_f), $1, $(extra)) :);
    } else {
      _end_func = (: evaluate($(end_f), $1) :);
    }
  }

  switch (editor) {
  case "menu":
    _lines = explode(str, "\n") - ({ 0 });
    printf("Enter your text.  Use ** on a line by itself to exit.\n");
    _insertion_point = sizeof(_lines);
    printf("%-2d] ", _insertion_point + 1);
    _in_editor = 1;
    input_to((: editor_loop :));
    return 1;
  case "ed":
    if (strlen(str) && (_filename == TMP_FILE))
      write_file(_filename, str);
    _in_editor = 1;
    ed(_filename, "editor_finish_ed", !this_object()->query_creator());
    return 1;
  case "magic":
    if (strlen(str) && (_filename == TMP_FILE))
      write_file(_filename, str);
    _in_editor = 1;
    _ed_ob = new(PRESTOS_ED, _filename, _filename != TMP_FILE);
    return 1;
  case "command":
    _lines = explode(str, "\n") - ({ 0 });
    printf("Enter your text.  Use ** on a line by itself to exit or "
           "~h for help.\n");
    _insertion_point = sizeof(_lines);
    printf("%-2d] ", _insertion_point + 1);
    _in_editor = 1;
    input_to((: editor_loop :));
    return 1;
  }
} /* do_edit() */

/** @ignore yes */
private void main_bit(string str) {
  int i;
  string s;

  if (str != "") {
    while (str[0] == ' ') {
      str = str[1..];
    }
    switch (str[0]) {
    case 'i':
    case 'I':
      printf("Insert before line: ");
      input_to((: editor_insert :));
      return;
    case 'd':
    case 'D':
      printf("Delete (line no, or n..m ie 1..2): ");
      input_to((: editor_delete :));
      return;
    case 'l':
    case 'L':
      if (!sizeof(_lines))  {
        main_bit("");
      } else {
        s = "";
        for (i = 0; i < sizeof(_lines); i++)
          s += sprintf("%3d: %s\n", i + 1, _lines[i]);
        this_object()->set_finish_func("end_of_edit_more");
        this_object()->more_string(s);
      }
      return;
    case 'm':
    case 'M':
      printf("Modify which line (line no, or n..m ie 1..2): ");
      input_to((: editor_modify :));
      return;
    case 'c':
    case 'C':
      _insertion_point = sizeof(_lines);
      printf("Okay, back into insertion mode.  Use ** on a line "
             "by itself to exit.\n%-2d] ", _insertion_point + 1);
      input_to((: editor_loop :));
      return;
    case 'e':
    case 'E':
      printf("Entering ed... Use \"q\" to quit, \"x\" to save and "
             "quit, \"Q\" to quite without saving changes and \"h\" "
             "for help.\n");
      write_file(_filename, implode(_lines, "\n"));
      ed(_filename, "editor_exit_ed", !this_object()->query_creator());
      return;
    case 's':
    case 'S':
      printf("Quitting and saving.\n");
      editor_do_quit(implode(_lines, "\n"));
      return;
    case 'q':
    case 'Q':
      printf("Are you sure you want to quit? (Y/N) ");
      input_to((: editor_check_quit :));
      return;
    case 'h':
    case 'H':
      s = read_file(ED_HELP_FILE);
      this_object()->set_finish_func("end_of_edit_more");
      this_object()->more_string(s);
      return;
    default:
      printf("I do not understand you.  Try %s for help.\n",
             (editor == "command" ? "~h" : "h" ));
      main_bit("");
      return;
    }
  }
  if (editor == "menu") {
    printf(sizeof(_lines) +" lines - Choose from IDLMCESQ or H for help.");
    input_to((: main_bit :));
  }
  else {
    printf("%-2d] ", _insertion_point + 1);
    input_to((: editor_loop :));
  }
  return;
} /* main_bit() */

/** @ignore yes */
void end_of_edit_more()  {
  this_object()->set_finish_func(0);
  main_bit("");
} /* end_of_edit_more() */

/** @ignore yes */
private void editor_delete(string str)  {
  int num1, num2, tmp;

  if (sscanf(str, "%d..%d", num1, num2) == 2)  {
    if (num1 > num2)  {
      tmp = num1;
      num1 = num2;
      num2 = tmp;
    }
    if ((num1 < 1) || (num2 > (sizeof(_lines) + 1))) {
      printf("Out of bounds.\n");
      main_bit("");
    }
    printf("Deleting from line %d to line %d.\n", num1, num2);
    _lines = delete(_lines, num1 - 1, num2 - num1 + 1);
    printf("Okay.\n");
    main_bit("");
    return;
  }
  if (sscanf(str, "%d", num1) == 1)  {
    if ((num1 < 1) || (num1 > (sizeof(_lines) + 1)))  {
      printf("Line number out of range.\n");
      main_bit("");
      return;
    }
    printf("Deleting line %d.\n", num1);
    _lines = delete(_lines, num1 - 1, 1);
    printf("Okay.\n");
    main_bit("");
    return;
  }
  printf("Error: invalid data %s.\n", str);
  main_bit("");
  return;
} /* editor_delete() */

/** @ignore yes */
private void editor_insert(string str)  {
  int num;

  if (sscanf(str, "%d", num) != 1)  {
    printf("Error: must be a number.\n");
    main_bit("");
    return;
  }
  if ((num < 1) || (num > (sizeof(_lines) + 1))) {
    printf("Error: number out of bounds.\n");
    main_bit("");
    return;
  }
  _insertion_point = num - 1;
  printf("Inserting before line %d.  Entering insertion mode.  Use ** on a "
         "line by itself to exit\n%-2d] ", num, num);
  input_to((: editor_loop :));
  return;
} /* editor_insert() */

/** @ignore yes */
private void editor_loop(string str) {
  if ((strlen(str) > 1) && (str[0] == '~') && (editor == "command")) {
    main_bit(str[1..]);
    return;
  }
  if (str == "**") {
    if (editor == "menu") {
      main_bit("");
    } else if (sizeof(_lines)) {
      editor_do_quit(implode(_lines, "\n"));
    } else {
      editor_do_quit(0);
    }
    return;
  }
  _lines = _lines[0.._insertion_point - 1] + ({ str }) +
    _lines[_insertion_point..];
  ++_insertion_point;
  printf("%-2d] ", _insertion_point + 1);
  input_to((: editor_loop :));
  return;
} /* editor_loop() */

/** @ignore yes */
private void editor_modify(string str)  {
  int num1, num2, tmp;

  if (sscanf(str, "%d..%d", num1, num2) == 2)  {
    if (num1 > num2)  {
      tmp = num1;
      num1 = num2;
      num2 = tmp;
    }
    if ((num1 < 1) || (num2 > (sizeof(_lines) + 1))) {
      printf("Error: number out of bounds.\n");
      main_bit("");
    }
    printf("Modifying from line %d to line %d.\n", num1, num2);
    printf("Text to change? ");
    input_to((: editor_modify2 :), 0, num1, num2);
    return;
  }
  if (sscanf(str, "%d", num1) == 1)  {
    if ((num1 < 1) || (num1 > (sizeof(_lines) + 1)))  {
      printf("Error: line number out of range.\n");
      main_bit("");
      return;
    }
    printf("Modifying line %d.\n", num1);
    printf("Text to change? ");
    input_to((: editor_modify2 :), 0, num1, num1);
    return;
  }
  printf("Error: invalid data %s.\n", str);
  main_bit("");
  return;
} /* editor_modify() */

/** @ignore yes */
private void editor_modify2(string str, int range1, int range2)  {
  if (!strlen(str))  {
    printf("Aborting.\n");
    main_bit("");
    return;
  }
  printf("Change to: ");
  input_to((: editor_modify3 :), 0, range1, range2, str);
  return;
} /* editor_modify2() */

/** @ignore yes */
private void editor_modify3(string str, int range1, int range2,
                            string modify_string) {
  int i;

  printf("Changing all occurrences of \"%s\" to \"%s\" from line %d to "
         "line %d.\n", modify_string, str, range1, range2);
  for (i = range1 - 1; (i < range2) && (i < sizeof(_lines)); i++) {
    _lines[i] = replace_string(_lines[i], modify_string, str);
      printf("%3d: %s\n", i + 1, _lines[i]);
  }
  printf("Done.\n");
  main_bit("");
  return;
} /* editor_modify3() */

/** @ignore yes */
void editor_exit_ed()  {
  string str;

  str = read_file(_filename);
  if ((file_size(_filename) >= 0) && !rm(_filename))
    log_file(LOG_FILE, "ed: couldn't rm %s\n", _filename);
  _lines = explode("#" + str, "\n");
  _lines[0] = _lines[0][1..];
/*
  _lines[sizeof(_lines)-1] = _lines[sizeof(_lines)-1][0..
                                 strlen(_lines[sizeof(_lines)-1])-2];
 */
  main_bit("");
  return;
} /* editor_exit_ed() */

/** @ignore yes */
void editor_finish_ed()  {
  string str;

  str = read_file(_filename);
  if ((file_size(_filename) >= 0) && (_filename == TMP_FILE) &&
      !rm(_filename)) {
    log_file(LOG_FILE, "ed: couldn't rm %s\n", _filename);
  }
  if (!str)  {
    printf("Aborted.\n");
    editor_do_quit(0);
    return;
  }
  if (_filename == TMP_FILE)  {
    editor_do_quit(str);
  } else {
    editor_do_quit(0);
  }
  return;
} /* editor_finish_ed() */

/** @ignore yes */
void editor_do_quit(string str)  {
  //object prev_end_object;

  _lines = ({ });
/*
  if (str) str = replace(str, "@@", "@ @ ");
*/
  if ((editor == "magic") && (_filename == TMP_FILE) &&
      (file_size(_filename) >= 0) && !rm(_filename))  {
    printf("magic: couldn't remove %s\n" , _filename);
    str = 0;
  }
  _in_editor = 0;
/*
  prev_end_object = _end_object;
  _end_object = 0;
  if (functionp(_end_func)) {
    if(_other) {
      evaluate(_end_func, str, _other);
    } else {
      evaluate(_end_func, str);
    }
  } else {
    if(_other) {
      call_other(prev_end_object, _end_func, str, _other);
    } else {
      call_other(prev_end_object, _end_func, str);
    }
  }
 */
  if (_ed_ob) {
    destruct(_ed_ob);
  }
  evaluate(_end_func, str);
} /* editor_do_quit() */

/** @ignore yes */
private void editor_check_quit(string str)  {
  if ((str != "") && (str[0] != 'y') && (str[0] != 'Y')) {
    printf("Returning to the editor.\n");
    main_bit("");
    return;
  }
  printf("Quitting.\n");
  editor_do_quit(0);
  //_end_object = 0;
  return;
} /* editor_check_quit() */

/** @ignore yes */
int set_editor(string str)  {
/*
  if ( member_array( str, ({ "magic", "menu", "command", "ed" }) ) == -1 )  {
    notify_fail( "Your editor can be set to one of the following menu, "
                 "ed, command, and magic.  Please do not set your editor "
                 "to ed unless you know what you are doing.  The menu "
                 "editor is the default, the command editor is based on "
                 "using ~ escape characters and the magic editor is one "
                 "of Presto's concoctions.\n" );
    return 0;
  }
 */
  editor = str;
  printf("Editor set to %s.\n", str);
  return 1;
} /* set_editor() */

/**
 * This method will create the signature to append to whatever needs
 * a signature.
 * @return the players signature
 */
string append_signature() {
  return PLAYER_HANDLER->query_signature(this_object()->query_name());
} /* append_signature() */

/** @ignore yes */
void editor_check_do_quit()  {
  if (_in_editor)  {
    /* Force them to sve the thingy they are editing. */
    printf("Saving what you are editing.\n");
    if (editor != "ed") {
      editor_do_quit(implode(_lines, "\n"));
    } else {
      editor_finish_ed();
    }
  }
} /* editor_check_do_quit() */

/**
 * This method will return the players current editor setting.
 * @return the current editor setting.
 */
string query_editor() {
  return editor;
}

/**
 * This method returns true if the player is currently in the editor.
 * @return 1 if the player is in the editor
 */
int query_in_editor() {
  return _in_editor;
} /* query_in_editor() */
// --- END [/mnt/home2/grok/lib/global/line_ed.c] ---
// --- BEGIN [/mnt/home2/grok/lib/global/more_string.c] ---
// Size:   File: "/mnt/home2/grok/lib/global/more_string.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627350   Available: 13574704
Inodes: Total: 5242880    Free: 4960133
9897 bytes, Last Modified:   File: "/mnt/home2/grok/lib/global/more_string.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627350   Available: 13574704
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:52.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: more_string.c,v 1.7 2003/06/04 23:16:08 pinkfish Exp $
 * 
 */
/**
 * This file will handle the real moreing of a string to the player.  The
 * player object will call out to this, so the all the code and the
 * variables are not stored in the player object.
 * @see /global/more_file.c
 *
 * @author Pinkfish
 */
#define COLS (int)this_object()->query_cols()
#define ROWS ( (int)this_object()->query_rows() - 1 )

/**
 * Information on the string being mored.
 * @element fsize the size of the file
 * @element topl the top line being displayed
 * @element botl the bottom line being display
 * @element last_search the last attempted search
 * @element the_bit the actual file itself
 * @element finish_func the function to call on finishing
 * @element more_bit the string to print at the bottom of the screen
 * @element stat_line the status line
 * @element finish_ob the finish object
 */
class more_string_info {
   int fsize;
   int topl;
   int botl;
   string last_search;
   string *the_bit;
   string finish_func;
   string more_bit;
   string stat_line;
   object finish_ob;
}

private nosave mixed *_pending_more;
private class more_string_info _current_info;

int internal_more_string();

void create() {
   add_command("Internal_More_String", "<string>", (:internal_more_string:));
} /* create() */

/**
 * @ignore yes
 */
private void string_display_file(class more_string_info info) {
  int i;
  string stuff;

  info->botl = info->topl + ROWS;
  stuff = "";
  for ( i = info->topl; ( i < info->botl ) && ( i < info->fsize ); i++ ) {
    stuff += info->the_bit[ i ] +"\n";
  }
  efun::tell_object( this_object(), stuff );
} /* string_display_file() */

/**
 * @ignore yes
 */
private void more_string_status_line(class more_string_info info) {
   string *frog;
   string s;
   int i;
   int percentage;

   if (!info->stat_line) {
      info->stat_line = "$N From $T to $B of $S ($%%) - h for help. ";
   }
   s = "";
   frog = explode(info->stat_line, "$");
   for (i=0;i<sizeof(frog);i++) {
      if (frog[i] == "") {
         s += "$";
         i ++;
      } else switch (frog[i][0]) {
         case 'N' :
            s += info->more_bit+frog[i][1..];
            break;
         case 'T' :
            s += ( info->topl + 1 ) + frog[ i ][ 1 .. ];
            break;
         case 'B' :
            if (info->botl > info->fsize)
               s += info->fsize+frog[i][1..];
            else
               s += info->botl+frog[i][1..];
            break;
         case '%' :
            percentage = (info->botl*100)/info->fsize;
            if (percentage > 100) {
               percentage = 100;
            }
            s += percentage + frog[i][1..];
            break;
         case 'S' :
            s += info->fsize + frog[i][1..];
            break;
      }
   }
   efun::tell_object( this_object(), (string)this_object()->fix_string( s ) );
   return;
} /* more_string_status_line() */

/**
 * @ignore yes
 */
private void string_next_page(string str, class more_string_info info) {
   int num;
   int noargs;
   int i;
   int redraw;
   string s1;

   if (!str) {
     str = "";
   }

   if (sscanf(str,"%d%s", num, str) != 2) {
     noargs = 1;
   }
   s1 = str[1..];
   /* case statements WEEEEEE */
   if (str == "") {
      str = "f";
   }
   switch(str[0]) {
      case 'h' :
         cat("/doc/helpdir/more");
         break;
      case 'q' :
         if (info->finish_func) {
            if (functionp(info->finish_func)) {
               evaluate(info->finish_func);
            } else {
               call_other(info->finish_ob, info->finish_func);
            }
         }
         info->finish_func = 0;
         _current_info = 0;
         return;
      case 'f' :
      case 'F' :
         /* go on a number of pages... */
         info->topl += ROWS;
         redraw = 1;
         break;
      case 'b' :
      case 'B' :
         info->topl -= ROWS;
         redraw = 1;
         break;
      case '/' :
         /* sigh */
         i = info->topl + 4;
         if (!s1 || s1 == "") {
            s1 = info->last_search;
         }
         if (!s1 || s1 == "") {
            s1 = "bing!";
         }
         for (i = info->topl + 4; i < info->fsize; i++) {
            if (strsrch(info->the_bit[i], s1) != -1) {
               if (num-- <= 0) {
                  break;
               }
            }
         }
         if (i == info->fsize) {
            tell_object( this_object(), "Sorry "+ s1 +" not found.\n" );
         } else {
            tell_object( this_object(), "Found " + s1 + " on line "+ i +".\n");
            info->topl = i - 3;
         }
         redraw = 1;
         break;
      case '?' :
         if (!s1 || s1 == "") {
            s1 = info->last_search;
         }
         if (!s1 || s1 == "") {
            s1 = "bing!";
         }
         for (i = info->topl + 2; i > 0; i--) {
            if (strsrch(info->the_bit[i], s1) != -1) {
               if (num-- <= 0) {
                  break;
               }
            }
         }
         if (i == 0) {
            tell_object(this_object(), "Sorry " + s1 + " not found.\n");
         } else {
            info->topl = i - 3;
         }
         redraw = 1;
         break;
      case 'b' :
         if (info->topl > 0) {
            info->topl -= ROWS;
            redraw = 1;
            if (info->topl < 0) {
               info->topl = 0;
            }
         }
         break;
      case 'g' :
         info->topl = num;
         if (info->topl >= info->fsize)
            info->topl = info->fsize - 2;
         redraw = 1;
         break;
      case 'G' :
         redraw = 1;
         if (noargs)
            info->topl = info->fsize - ROWS;
         else
            info->topl = num;
         if (info->topl > info->fsize)
            info->topl = info->fsize - 2;
         break;
   }

   if (info->topl < 0) {
      info->topl = 0;
   }

   if (redraw) {
      string_display_file(info);
      if ( info->botl < info->fsize ) {
         more_string_status_line(info);
         input_to((: string_next_page :), 0, info);
      } else {
         if (info->finish_func) {
            if ( info->finish_ob ) { // sometimes screwed up:(
               call_other(info->finish_ob, info->finish_func);
            }
            info->finish_func = 0;
         }
         _current_info = 0;
      }
   } else {
      more_string_status_line(info);
      input_to((: string_next_page :), 0, info);
   }
} /* string_next_page() */

/**
 * Puts a long string through a more function.
 * @param text the text to place through the pager
 * @param bity the title of the text
 * @param noreline do not do realignment of the text
 * @see /global/more_file.c->more_file()
 * @see set_finish_func()
 */
varargs int more_string( string text, string bity, int noreline ) {
  int i, ncols;
  string *bits;
  class more_string_info info;
  mixed func;

  if ( this_player() != this_object() ){
     if ( !_pending_more ) {
        _pending_more = ({ ({ text, bity, noreline }) });
     } else {
        _pending_more += ({ ({ text, bity, noreline }) });
     }
     this_object()->ignore_from_history("Internal_More_String something");
     command( "Internal_More_String something" );
     return 1;
  }

  if (!_current_info) {
     _current_info = new(class more_string_info);
  }

  info = _current_info;
  if ( bity ) {
    info->more_bit = bity;
  } else {
    info->more_bit = "--- MORE";
  }
  info->last_search = "";
  if ( !stringp( text ) || !strlen( text ) ) {
    return notify_fail( "Empty string.\n" );
  }
  if ( noreline ) {
    info->the_bit = explode( this_object()->fix_string( text ), "\n" );
  } else {
    text = this_object()->convert_message( text );
    /* for observer-dependent shorts */
    text = this_object()->fit_message( text );
    /* for capitalisation and indentation */
    text = this_object()->fix_string( text );

    info->the_bit = ({ });
    ncols = COLS;
    bits = explode( text, "\n" );
    for ( i = 0; i < sizeof( bits ); i++ ) {
      reset_eval_cost();
      if ( bits[ i ] == "" ) {
        info->the_bit += ({ "" });
      } else {
        info->the_bit +=
          explode( this_object()->fix_string( bits[ i ], ncols ), "\n" );
      }
    }
  }
  info->fsize = sizeof( info->the_bit );
  info->topl = 0;
  string_display_file(info);
  if ( info->botl < info->fsize ) {
    more_string_status_line(info);
    input_to( (: string_next_page :), 0, info );
  } else {
      if ( info->finish_func ) {
         if ( !info->finish_ob ) {
            //screwed up:
            info->finish_func = 0;
            return 1;
         }
         func = info->finish_func;
         info->finish_func = 0;
         call_other( info->finish_ob, func );
      }
      _current_info = 0;
  }
  return 1;
} /* more_string() */

/**
 * Sets the finish function.  This is called when the more_string
 * command exits.  If the ob is set to 0 then previous_object() is used
 * for it.  The str can be a function pointer as well.
 * @param str the function name or function pointer to use
 * @param ob the object to call it on (ignore for function pointers)
 * @see more_string()
 */
varargs void set_finish_func(string str, object ob) {
  if (!_current_info) {
     _current_info = new(class more_string_info);
  }
  _current_info->finish_func = str;
  if (!ob) {
    _current_info->finish_ob = previous_object();
  } else {
    _current_info->finish_ob = ob;
  }
} /* set_finish_func() */

/**
 * @ignore yes
 */
private int internal_more_string() {
   string text, bity;
   int noreline;
   
   if ( sizeof( _pending_more ) ) {
      text = _pending_more[ 0 ][ 0 ];
      bity = _pending_more[ 0 ][ 1 ];
      noreline = _pending_more[ 0 ][ 2 ];
      _pending_more = _pending_more[ 1 .. <1 ];
      more_string( text, bity, noreline );
   }
   return 1;
} /* internal_more_string() */
// --- END [/mnt/home2/grok/lib/global/more_string.c] ---
// --- BEGIN [/mnt/home2/grok/lib/global/wiz_present.c] ---
// Size:   File: "/mnt/home2/grok/lib/global/wiz_present.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627347   Available: 13574701
Inodes: Total: 5242880    Free: 4960133
6350 bytes, Last Modified:   File: "/mnt/home2/grok/lib/global/wiz_present.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627347   Available: 13574701
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:52.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: wiz_present.c,v 1.6 2001/10/31 12:01:04 taffyd Exp $
 * $Log: wiz_present.c,v $
 * Revision 1.6  2001/10/31 12:01:04  taffyd
 * Added class casting to disambiguate classes.
 *
 * Revision 1.5  2001/06/01 21:06:47  ceres
 * Cant remember
 *
 * Revision 1.4  2001/02/10 01:41:50  sin
 * Fix evil bug.  The code that tried to do filename matching checked
 * for the trailing sequence of characters in a filename, not
 * all the characters between the last / and #.  That's a problem.
 *
 * Fixed.
 *
 * Revision 1.3  2000/08/25 04:01:12  pinkfish
 * Shrikes changes to make it do some checks correctly.
 *
 * Revision 1.2  2000/06/23 03:40:56  pinkfish
 * Fix up the references to find_match.
 *
 * Revision 1.1  1998/01/06 04:54:05  ceres
 * Initial revision
 *
*/
#include <obj_parser.h>

string desc_object(mixed o){
  string str;

  if (!o) return "** Null-space **";
  if (!catch(str = (string)o->short()) && str) return str;
  if (!catch(str = (string)o->query_name()) && str) return str;
  return file_name(o);
} /* desc_object() */

string desc_f_object(object o){
  string str, tmp;

  str = desc_object(o);
  if (o && str != file_name(o)) {
    if (tmp)
      str += " (" + tmp + ")";
    else
      str += " (" + file_name(o) + ")";
  }
  return str;
} /* desc_f_object() */

object *wzpresent2(string str, mixed onobj) {
  object *obs, ob, *obs2, obj;
  string s1;
  class obj_match result;

  if (pointerp(onobj)) {
    obs = ({ });
    foreach(ob in onobj)
      obs += wzpresent2(str,ob);
    return obs;
  }

  if (str == "all")
    return all_inventory(onobj);

/* every fish */

  if (sscanf(str,"every %s",s1) == 1) {
    obs2 = all_inventory(onobj);
    obs = ({ });
    foreach (ob in obs2)
      if (ob->id(s1)) obs += ({ ob });
    return obs;
  }

  result = (class obj_match)match_objects_in_environments(str,onobj);
  if (result->result == OBJ_PARSER_SUCCESS ||
      result->result == OBJ_PARSER_AMBIGUOUS) {
    return result->objects;
  }

  if (obj = present(str,onobj)) return ({ obj });
  for (obj = first_inventory(onobj); obj; obj = next_inventory(obj)) {
    s1 = file_name(obj);
    if (sscanf(s1, "%*s/"+str+"#%*d") || sscanf(s1, "%*s#"+str))
      return ({ obj });
  }
  return ({ });
} /* wiz_present2() */

varargs object *wiz_present(string str, object onobj, int nogoout) {
/* nogoout is so that it WON'T check the environment of onobj */
  int j;
  object ob, *obs, *obs2;
  string s1, s2, *sts;
  mixed thing;
  class obj_match result;

  if (!str || !onobj)
    return ({ });
  seteuid(geteuid(this_player()));

/* all the simple ones first */

  if(str[0] == '@') {
    if (ob = find_living(
        (string)this_player()->expand_nickname(extract(str, 1))))
      return ({ ob });
    notify_fail("Unable to find living object: "+extract(str,1)+".\n");
    return ({ });
  }

  if (str == "me") return ({ this_player() });

  if (str == "here") return ({ environment(this_player()) });

  if( str == "everyone") {
    if(!this_object()->query_lord())
      return ({ });
    
    obs = users();
    if(nogoout)
      return filter( obs, (: environment( $1 ) == $(onobj) :) );
    return obs;
  }

  if( str == "creators" ) {
    obs = filter( users(), (: $1->query_creator() :) );
    if(nogoout)
      return filter( obs, (: environment( $1 ) == $(onobj) :) );
    return obs;
  }

  if(str[0] == '/') {
    if (ob = find_object(str)) return ({ ob });
    if (sizeof((sts = (string *)this_player()->get_cfiles(str))))  {
      obs = ({ });
      obs = map(sts, (: find_object($1) :)) - ({0});
      return obs;
    }
    notify_fail("No loaded object: "+str+".\n");
    return ({ });
  }

/* (fish) == environment of fish */

  if (str[0] == '(' && str[strlen(str) - 1] == ')') {
    obs = wiz_present(extract(str,1,strlen(str) - 2),onobj);
    if (!sizeof(obs)) return obs;
    obs = map(obs, (: environment($1) :)) - ({0});
    return obs;
  }

/* handle "fish on fish2" */

  if (sscanf(str,"%s on %s",s1,s2) == 2 ||
      sscanf(str,"%s in %s",s1,s2) == 2) {
    obs = wiz_present(s2, onobj);
    if (!sizeof(obs)) return obs;
    obs2 = ({ });
    foreach (ob in obs)
      obs2 += wiz_present(s1, ob, 1);
    return obs2;
  }

/* fish and fish2 */

  if (sscanf(str,"%s and %s",s1,s2) == 2) {
    obs = wiz_present(s1, onobj);
    obs2= wiz_present(s2, onobj);
    obs2 += filter(obs, (: member_array($1, $(obs2)) < 0 :));
    return obs2;
  }

/* fish except fish2 */

  if (sscanf(str,"%s except %s",s1,s2) == 2 ||
      sscanf(str,"%s but %s",s1,s2) == 2) {
    obs = wiz_present(s1, onobj);
    obs2= wiz_present(s2, onobj);
    foreach (ob in obs2)
      while ((j=member_array(ob, obs)) > -1)
        obs = delete(obs,j--,1);
    return obs;
  }

/* env of fish */

  if (sscanf(str, "env of %s", s1) == 1) {
    obs = wiz_present(s1, onobj);
    if (!sizeof(obs)) {
       return obs;
    }
    return map(obs, (: environment($1) :)) - ({0});
  }

/* children of fish */

  if (sscanf(str, "children of %s", s1) == 1) {
    obs = wiz_present(s1, onobj);
    obs2 = ({ });
    foreach (ob in obs) {
      s1 = file_name(ob);
      sscanf(s1, "%s#%*d", s1);
      obs2 += children(s1);
    }
    return obs2;
  }

  if (sscanf(str,"player %s",s1)) {
    return ({ find_player(s1) });
  }

  if (!sizeof(obs2 = wzpresent2(str,onobj)) && !nogoout) {
    obs2 = wzpresent2(str, environment(onobj));
  }

  if (sizeof(obs2)) {
    return obs2;
  }

/* check for a find_match locally */

  result = (class obj_match)match_objects_in_environments(str,onobj);
  if (result->result == OBJ_PARSER_SUCCESS ||
      result->result == OBJ_PARSER_AMBIGUOUS) {
    return result->objects;
  }

/* default to return find_living ...  */

  ob = find_living( this_player()->expand_nickname(str) );
  if( ob && ( !nogoout || ( environment(ob) == onobj ) ) )
    return ({ ob });

/* quick hack by ember 12/4/93 to stick in temporary object variables */
  if (thing = this_player()->get_obvar(str)) {
    if (objectp(thing)) return ({ thing });
    if (pointerp(thing)) {
/* Make sure they are all objects... */
      return filter( thing, (: objectp( $1 ) :) );
    }
  }

  if (sizeof((sts = (string *)this_player()->get_cfiles(str))))  {
    obs = ({ });
    obs = map(sts, (: find_object($1) :)) - ({0});
    return obs;
  }
  return ({ });
} /* wiz_present() */
// --- END [/mnt/home2/grok/lib/global/wiz_present.c] ---
// --- BEGIN [/mnt/home2/grok/lib/global/wiz_info_comm.c] ---
// Size:   File: "/mnt/home2/grok/lib/global/wiz_info_comm.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627345   Available: 13574699
Inodes: Total: 5242880    Free: 4960133
2079 bytes, Last Modified:   File: "/mnt/home2/grok/lib/global/wiz_info_comm.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627345   Available: 13574699
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:52.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: wiz_info_comm.c,v 1.2 1998/04/13 14:36:08 pinkfish Exp $
 * $Log: wiz_info_comm.c,v $
 * Revision 1.2  1998/04/13 14:36:08  pinkfish
 * Added documentation.
 *
 * Revision 1.1  1998/01/06 04:54:05  ceres
 * Initial revision
 * 
 */
/**
 * This file contains all the information related creator commands.
 * @author Ember
 */
#define PEOPLER "/obj/handlers/peopler"

protected int do_gauge(string str);
int add_command(string name, object ob, string format, function func);

/** @ignore yes */ 
protected void wiz_commands() {
  add_command("gauge", this_object(), "<string>", (: do_gauge($4[0]) :));
  if(clonep())
    call_out("driver_version", 20);
} /* wiz_commands() */
     

/* small addition by a retired creator aka wonda */
/**
 * This method is called slighty after the login time.  It checks
 * to see if the driver version has changed and pooints to the
 * change log for more information.
 */
int driver_version(){
  string old = this_object()->query_property("driver_version");

  if(!old) {
    return this_object()->add_property("driver_version", __VERSION__);
  }
  if(old != __VERSION__){
    this_object()->add_property("driver_version", __VERSION__);
    write("%^RED%^The driver has been changed to version " + 
          __VERSION__ + ", see /doc/driver/Changes for more information.%^RESET%^\n");
  }
  return 1;
} /* driver_version() */

/** @ignore yes */
int review() {
  PEOPLER->review();
  return 1;
} /* review() */

/**
 * This method returns the number of evaluation cycles the
 * particular command took to run.  It is kind of useful for
 * figuring out how much time a given command takes
 * to execute
 * @param str the command to execute
 * @return 1 on success, 0 on failure
 */
protected int do_gauge(string str) {
  int eval_cost;

  if (this_player(1) != this_object()) return 0;
  if(!str) {
    notify_fail("Usage : gauge command.\n");
    return 0;
  }
  eval_cost = command(str);
  write("\nThe command '" + str + "' took: " + eval_cost + " CPU cycles.\n");
  return 1;
} /* do_gauge() */
// --- END [/mnt/home2/grok/lib/global/wiz_info_comm.c] ---
// --- BEGIN [/mnt/home2/grok/lib/global/guild-race.c] ---
// Size:   File: "/mnt/home2/grok/lib/global/guild-race.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627345   Available: 13574699
Inodes: Total: 5242880    Free: 4960133
7012 bytes, Last Modified:   File: "/mnt/home2/grok/lib/global/guild-race.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627345   Available: 13574699
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:52.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: guild-race.c,v 1.12 2003/03/06 13:26:39 terano Exp $
 * 
 */
/**
 * This file contains all the information relating to guilds and races
 * that is  stored on the player.
 *
 * @author Pinkfish
 */
#include <player.h>
#include <command.h>

string race_ob, guild_ob,  *known_commands;
mixed *guild_data;

nosave string _race;

/**
 * This method adds all the guild and race commands to the player
 * when they start up.
 * @see add_known_command()
 */
void race_guild_commands() {
  string command;
  string *bing;
  string *paths = ({ });

  if (!known_commands) {
    known_commands = ({ "skills", "rearrange", "gp", "newbie" });
  }

  foreach (command in known_commands) {
    bing = CMD_D->GetPaths(command);
    if (sizeof(bing)) {
      // Remove any paths that aren't /cmds/guild-race coz this was causing
      // trouble.
      bing = filter(bing, (: $1[0..15] == "/cmds/guild-race" :));
      paths += bing;
    }
  }
  this_object()->AddSearchPath(paths);
  if (guild_ob) {
    catch(guild_ob->start_player(this_object()));
  }

  catch(race_ob->start_player(this_object()));
  this_object()->query_limbs();
} /* race_guild_commands() */

/**
 * This method returns the title associated with this player for their
 * guild.
 * @return the guilds title
 */
string query_gtitle() {
  string tmp;
  
  if (guild_ob)
    if (catch((tmp = (string)guild_ob->query_title(this_object()))))
        tmp = "Has a broken guild";
  return tmp;
} /* query_gtitle() */

/**
 * This method sets the players current race.  This should never be
 * used, all players should be humans.
 * the set functions should not be called indisciminately...
 * Be careful when using them, so that you don't screw up a character ok?
 * @param str the players new race
 * @see query_race_ob()
 */
void set_race_ob(string str) {
  string frog;
  if(sscanf(str, "/%s", frog)==1) 
    str = extract(str, 1);
  if (str[0..strlen("std/races")-1]!="std/races") {
    write("Illegal path to set_race_ob.\n");
    return;
  }
  if(str[0..strlen("std/races/god")-1] == "std/races/god" &&
     !"/secure/master"->god(geteuid())) {
    write("The heavens rumble and the earth shakes.  You stop.\n");
  }
  else
    race_ob = str;
} /* set_race_ob() */

/**
 * This method returns ther current race object associated with the
 * player.
 * @return the race object
 * @see set_race_ob()
 */
string query_race_ob() { return race_ob; }

/**
 * This method sets the current guild associated with the player.
 * Be very careful when setting this variable, if you get it wrong
 * bunches of things on the mud will mysteriously break.
 * @param str the new guild object
 * @see query_guild_ob()
 */
void set_guild_ob( string str ) {
  if(str) {
    if(str[0..10] != "/std/guilds") {
      tell_object(this_object(), "Attempt to set invalid guild object " +
                  str + "\n");
      return;
    } else if(!find_object(str)) {
      tell_object(this_object(), "No such object "+ str +"\n");
      return;
    }
  }
  guild_ob = str;
}

/**
 * This method returns the current guild object associated with the
 * player.
 * @return the current guild object
 * @see set_guild_ob()
 */
 string query_guild_ob() {
   if ( !guild_ob ) {
      return 0;
   }
   if(guild_ob[0..10] != "/std/guilds")
     return 0;
   
   return guild_ob;
} /* query_guild_ob() */

/**
 * This method sets the data associated with the guild for the player.
 * This is used for stuff like the orders for wizards and the type of
 * specialisation for theives.
 * @param dat the data to associate with the guild
 * @see query_guild_data()
 */
void set_guild_data(mixed *dat) { guild_data = dat; }
/**
 * This method returns the current guild data for the player.
 * @see set_guild_data()
 * @return the current guild data
 */
mixed *query_guild_data() {
  return guild_data;
} /* query_guild_data() */

/**
 * This method returns the name of the race associated with the
 * player.
 * @return the race name
 * @see query_race_ob()
 * @see set_race_ob()
 */
string query_race() { /* should return the name of our race */
  if(!_race)
    _race = (string)race_ob->query_name();
  return _race;
} /* query_race() */

/**
 * This method handles help calls associated with commands on the
 * player.  This will either return a string or a function pointer.
 * @return the help for the command
 * @param str the command to get help on
 * @see add_known_command()
 */
string help_command(string str) {
  class command cmd = new(class command, verb : str);
  string path;
  mixed func;

  if ((member_array(str, known_commands) != -1 ||
       this_object()->query_creator()) &&
      CMD_D->HandleStars(cmd)) {
    path =  CMD_D->GetPaths(cmd->verb)[0] + "/" + cmd->verb;
    func = path->help_function();
    if (func) {
       return func;
    }
    return path->help();
  }
  return 0;
} /* help_command() */

/**
 * This method returns the array of commands the player knows.
 * @return the list of commands the player knows
 * @see add_known_command()
 * @see query_known_command()
 * @see remove_known_command()
 */
string *query_known_commands() { return copy(known_commands); }

/**
 * This method checks to see if the command is known by the player.
 * @param word the command to check
 * @return 1 if known, 0 if not
 * @see add_known_command()
 * @see query_known_commands()
 * @see remove_known_command()
 */
int query_known_command( string word ) {
   return ( member_array( word, known_commands ) != -1 );
} /* query_known_command() */

/**
 * This method adds a command to the player.
 * @param str the command to add
 * @return 1 if was successfuly added, 0 if not
 * @see query_known_commands()
 * @see query_known_command()
 * @see remove_known_command()
 */
int add_known_command(string str) {
  string *paths;

  if (member_array(str, known_commands) != -1) {
    return 0;
  }
  if (!CMD_D->IsGRCommand(str)) {
    return 0;
  }
  paths = CMD_D->GetPaths(str);
  //
  // Filter out the /w directories.
  //
  paths = filter(paths, (: $1[0..15] == "/cmds/guild-race" :));
  if (sizeof(paths)) {
    this_object()->AddSearchPath(paths);
  }
  known_commands += ({ str });

  //Something from Terano to assist in debugging what's up with covert commands.
  if ( interactive( this_object() ) ) 
    log_file( "ADD_KNOWN_COMMAND", "%s: %s was added to %s by: %O.\n", ctime( time() ), 
        str, this_player()->query_name(), map( previous_object( -1 ), (: ({ $1,  $1->query_name() }) :) ) );
  
  return 1;
} /* add_known_command() */

/**
 * This method removes a command from the player.
 * @param str the command to remove
 * @return 1 if it was successful, 0 if it was unsuccessful
 * @see add_known_command()
 * @see query_known_command()
 * @see query_known_commands()
 */
int remove_known_command(string str) {
  int i;

  i = member_array(str, known_commands);
  if (i == -1) {
    return 0;
  }
  known_commands = known_commands[0..i-1] + known_commands[i+1..];
  return 1;
} /* remove_known_command() */
// --- END [/mnt/home2/grok/lib/global/guild-race.c] ---
// --- BEGIN [/mnt/home2/grok/lib/global/parser.c] ---
// Size:   File: "/mnt/home2/grok/lib/global/parser.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627343   Available: 13574697
Inodes: Total: 5242880    Free: 4960133
16009 bytes, Last Modified:   File: "/mnt/home2/grok/lib/global/parser.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627343   Available: 13574697
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:52.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: parser.c,v 1.4 2003/02/11 04:53:03 presto Exp $
 * $Log: parser.c,v $
 * Revision 1.4  2003/02/11 04:53:03  presto
 * detabified
 *
 * Revision 1.3  2000/05/12 01:36:46  pinkfish
 * Make it de-expand arrays if it can.
 *
 * Revision 1.2  2000/05/12 00:00:04  pinkfish
 * Fix up a few errors in the parser.
 *
 * Revision 1.1  1998/01/06 04:54:05  ceres
 * Initial revision
 * 
*/
/* Ok, simple (hopefully) recursive descent parser. */

#include <creator.h>
#include <parser.h>

#define LMASTER "/d/liaison/master"

int pos, force_string;
mixed func;

protected void create() {
  seteuid("Root");
}

mixed *parse_args(string str, string close) {
  mixed *args, *m, *m2;
  object *obs;
  string s1, s2, s3, s4, s5, s6, s7;
  int i;
  mapping map;

  args = ({ });
  while (strlen(str)) {
    while (strlen(str) && str[0] == ' ') str = str[1..<1];
    if (!strlen(str) || str[0..0] == close) return ({ args, str[1..<1] });
    switch (str[0]) {
      case '\'' :
        if (sscanf(str, "'%s'%s", s1, s2) != 2) {
          printf("Unterminated string.\n");
          return 0;
        }
        args += ({ replace_string(s1, "\\n", "\n") });
        str = s2;
        break;
      case '`' :
        if (sscanf(str, "`%s`%s", s1, s2) != 2) {
          printf("Unterminated string.\n");
          return 0;
        }
        args += ({ replace_string(s1, "\\n", "\n") });
        str = s2;
        break;
      case '"' :
        if (sscanf(str, "\"%s\"%s", s1, s2) != 2) {
          printf("Unterminated string.\n");
          return 0;
        }
        args += ({ replace_string(s1, "\\n", "\n") });
        str = s2;
        break;
      case '{' :
        m = parse_args(str[1..<1], "}");
        if (!m) {
          return 0;
        }
        args += ({ m[0] });
        str = m[1];
        break;
      case '[' :
       /* put here to catch a mudfreezing bug */
       if (sscanf(str[1..<1], "%s]%s", s1, s2) != 2) {
          printf("Unmatched [.\n");
          return 0;
        }
        str = str[1..<1];
        map = ([ ]);
        while (1) {
          m = parse_args(str, ":");
          /* Ok...  if we cannot find another : maybe we are at the end? */
          if (!m) {
            while (strlen(str) && str[0] == ' ') {
               str = str[1..<1];
            }
            if (str[0] == ']') {
              break;
            }
          }
          if (!(m2 = parse_args(str, ","))) {
            if (!(m2 = parse_args(str, "]"))) {
              return 0;
            }
            if (sizeof(m[0])) {
              map[m[0][0]] = (sizeof(m2[0])?m2[0][0]:0);
            }
            break;
          }
          if (sizeof(m[0])) {
            map[m[0][0]] = (sizeof(m2[0])?m2[0][0]:0);
          }
        }
        args += ({ map });
        break;
      case '|' :
        if (sscanf(str, "|%s|%s", s1, s2) != 2) {
          printf("Unmatched |\n");
          return 0;
        }
        obs = WIZ_PRESENT->wiz_present(str, this_player());
        if (!sizeof(obs)) {
          args += ({ this_player() });
        } else if (sizeof(obs) == 1) {
          args += ({ obs[0] });
        } else {
          args += ({ obs });
        }
        str = s2;
        break;
      case '0'..'9' :
      case '-' :
        if (sscanf(str, "%d%s", i, str) != 2) {
          printf("Number expected.\n");
          return 0;
        }
        args += ({ i });
        break;
      default :
        s2 = s3 = 0;
        sscanf(str, "%s,%s", s4, s2);
        sscanf(str, "%s"+close+"%s", s5, s3);
        if (sscanf(str, "%s->%s", s6, s7) == 2 && 
            (!s3 || strlen(s5) > strlen(s6)) &&
            (!s2 || strlen(s4) > strlen(s6))) {
          /* Now we do something truely revolting.... */
          while (s7[0] == ' ') s7 = s7[1..<1];
          if (sscanf(s7, "%s(%s", s1, s7) != 2) {
            printf("'(' expected.\nLine left unprocessed %s\n", s7);
            return 0;
          }
          obs = WIZ_PRESENT->wiz_present(s6, this_player());
          if (!sizeof(obs)) {
            printf("The object %s needs to exist.\n", s6);
            return 0;
          }
          m = parse_args(s7, ")");
          if (!m) {
             return 0;
          }
          if (sizeof(m[0]) < 6) {
             m[0] += allocate(6-sizeof(m[0]));
          }
          obs = map_array(obs, "mapped_call", this_object(), s1, m[0]);
          if (sizeof(obs) == 1) {
            args += obs;
          } else {
            args += ({ obs });
          }
          str = m[1];
          break;
        } else if (s2 && s3)
          if (strlen(s4) < strlen(s5)) {
            s1 = ",";
            str = s4;
          } else {
            s1 = close;
            s2 = s3;
            str = s5;
          } else if (s2) {
            s1 = ",";
            str = s4;
          } else if (s3) {
            s1 = close;
            s2 = s3;
            str = s5;
          } else {
            s1 = "";
            s2 = "";
          }
          obs = WIZ_PRESENT->wiz_present(str, this_player());
          if (!sizeof(obs)) {
            if (str[0] >= '0' && str[0] <= '9' || str[0] == '-') {
              sscanf(str, "%d%s", i, str);
              args += ({ i });
            } else 
              args += ({ replace_string(str, "\\n", "\n") });
          } else if (sizeof(obs) == 1)
            args += ({ obs[0] });
          else
            args += ({ obs });
          str = s1+s2;
          break;
    }
    /* Skip rubbish and if we dont have a comma we have finished. */
    while (strlen(str) && str[0] == ' ') {
       str = str[1..<1];
    }
    if (!strlen(str)) {
      return ({ args, str });
    }
    if (str[0..0] == close) {
      return ({ args, str[1..<1] });
    }
    if (str[0] != ',') {
      printf("Parse error reading arguments, ',' or '%s' expected.\n", close);
      printf("Line left unprocessed %s\n", str);
      return 0;
    }
    str = str[1..<1];
  }
  return ({ args, str });
} /* parse_args() */

#ifdef NOPE
void inform_of_call(object ob, mixed *argv) {
  string str;
  int i;

  str = this_object()->query_cap_name() + " calls " + argv[0] + "(";
  for (i=1; i<sizeof(argv); ) {
    str += replace(sprintf("%O", argv[i]), "\n", " ");
    if (++i < sizeof(argv)) str += ",";
  }
/* Arggghhh!  This is annoying me.
 * Same comment here.
  ob->event_inform(this_object(), str + ") on you", "call");
 */
} /* inform_of_call() */
#endif

protected mixed mapped_call(object ob, string func, mixed *argv) {
  /* inform_of_call(ob, argv); */
  return call_other(ob, func, argv ...);
} /* mapped_call() */

/* Free form parse_args code */
protected int parse_frogs(string str) {
  mixed junk;

  /* We are not as such looking for an end thingy of any sort... */
  junk = parse_args(str, ";");
  /* It has already printed an error, so we return 1... */
  if (!junk)
    return 1;
  write("The line "+str+" returns: \n");
  printf("%O\n", junk[0]);
  return 1;
} /* parse_frogs() */

/* Ok, simple (hopefully) recursive descent parser. */

mixed expr();

protected mixed bit4() {
  mixed val1, val2, val3;

  if (pos < sizeof(func)) {
    if (pointerp(func[pos])) {
      return func[pos++][0];
    }
    if (stringp(func[pos])) {
      if (func[pos][0] == '$') {
        /* We want a variable... */
        val1 = (object)this_player()->get_obvar(func[pos][1..<1]);
        pos++;
        return val1;
      }
      if (force_string) {
        force_string = 0;
        return func[pos++];
      }
      val1 = (object *)WIZ_PRESENT->wiz_present(func[pos], this_player());
      if (!sizeof(val1)) {
        return func[pos++];
      }
      pos++;
      if (sizeof(val1) == 1) {
        return val1[0];
      }
      return val1;
    }
    switch (func[pos]) {
      case TOK_OBRAC :
        pos++;
        val1 = expr();
        if (func[pos] != TOK_CBRAC) {
          printf("Mismatched brackets.\n");
        } else {
          pos++;
        }
        break;
      case TOK_SARRAY :
        pos++;
        val1 = ({ });
        while (pos < sizeof(func) && 
            func[pos] != TOK_EARRAY) {
          if (func[pos] == TOK_COMMA) {
             pos++;
          }
          val2 = expr();
          if (func[pos] != TOK_COMMA && 
              func[pos] != TOK_EARRAY) {
            printf("Error processing array.\n");
            return 0;
          }
          val1 += ({ val2 });
        }
        pos++;
        break;
      case TOK_SMAPPING :
        pos++;
        val1 = ([ ]);
        while (pos < sizeof(func) && func[pos] != TOK_EMAPPING) {
          if (func[pos] == TOK_COMMA) pos++;
          val2 = expr();
          if (func[pos] != TOK_COLON) {
            printf("Error processing mapping, expected :.\n");
            return 0;
          }
          pos++;
          val3 = expr();
          if (func[pos] != TOK_EMAPPING && func[pos] != TOK_COMMA) {
            printf("Error processing mapping, expected , or ].\n");
            return 0;
          }
          val1[val2] = val3;
        }
        printf("End of mapping.\n");
        pos++;
        break;
      default :
        /* Anything else is a potential object. */
        printf("Broken parser....\n");
        break;
    }
  }
  return val1;
} /* bit4() */

protected mixed do_function_call(object ob, string name, mixed stuff) {
  string found;
  object shad;

  if (objectp(ob)) {
    shad = ob;
    while ((shad = shadow(shad, 0))) {
      if ((found = function_exists(name, ob)))
        break;
    }
    if (!found && !(found = function_exists(name, ob))) {
      printf("*** function %s not found in %s ***\n",
          name, file_name(ob));
      return 0;
    } else {
      printf("*** function %s on %s found in %s ***\n", name, file_name(ob),
          found);
    }
    if ((ob != this_player()) && ob->query_property("player") &&
        !ob->query_property("no score")) {
        unguarded((: write_file,
                   (LMASTER->query_member(this_player()->query_name()) ?
                    "/d/admin/log/CALL_LIAISONS.log" :
                    "/d/admin/log/CALL_CREATORS.log" ),
                   sprintf("%s: %s (%O) called %s(%s) on %s (%O)\n",
                           ctime(time()),
                           this_player()->query_name(), this_player(),
                           name,
                           implode(stuff - ({0}), ", "), ob->query_name(),
                           ob) :));
        user_event( this_object(), "inform",
              sprintf("%s called %s(%s) on %s",
            this_player()->query_name(), name, implode(stuff - ({0}), ", "),
            ob->query_name()), "calls");
    }
    return call_other(ob, name, stuff[0], stuff[1], stuff[2],
        stuff[3], stuff[4], stuff[5]);
  }
  return 0;
} /* do_function_call() */

protected mixed bit3() {
  mixed *tmp, val1, val2, val3;
  int i;

  val1 = bit4();
  while (pos < sizeof(func)) {
    switch (func[pos]) {
      case TOK_CALL :
        pos++;
        force_string = 1;
        val2 = bit4();
        force_string = 0;
        if (func[pos] != TOK_OBRAC) {
          printf("Open bracket expected.\n");
        } else {
          tmp = ({ });
          pos++;
          while (pos < sizeof(func) && func[pos] != TOK_CBRAC) {
            if (func[pos] == TOK_COMMA) pos++;
            val3 = expr();
            if (func[pos] != TOK_COMMA && func[pos] != TOK_CBRAC) {
              printf("Error in function arguments.\n");
              return 0;
            }
            tmp += ({ val3 });
          }
          pos++;
        }
        if (objectp(val1)) {
          val1 = ({ val1 });
        }
        if (!pointerp(val1)) {
          printf("Array or object expected for function call.\n");
          break;
        }
        if (!stringp(val2)) {
          printf("String expected for the function call name.\n");
          break;
        }
        if (sizeof(tmp) < 6) {
          tmp += allocate(6-sizeof(tmp));
        }
        for (i=0;i<sizeof(val1);i++) {
          val1[i] = do_function_call(val1[i], val2, tmp);
        }
        if (sizeof(val1) == 1) {
          val1 = val1[0];
        }
        break;
      case TOK_SMAPPING :
        /* Array/mapping index... */
        pos++;
        val2 = expr();
        if (func[pos] == TOK_DOTDOT) {
          pos++;
          val3 = expr();
          if (func[pos] != TOK_EMAPPING) {
            printf("Expected closeing ].\n");
            break;
          }
          pos++;
          if (!pointerp(val1)) {
            printf("Can only use the .. syntax on arrays.\n");
            break;
          }
          if (!intp(val2) || !intp(val3)) {
            printf("Indexes must be integers.\n");
            break;
          }
          val1 = val1[val2..val3];
          break;
        }
        if (func[pos] != TOK_EMAPPING) {
          printf("Expected closeing ].\n");
          break;
        }
        pos++;
        if (mapp(val1)) {
          /* Anything is a legal index... */
          val1 = val1[val2];
        } else if (pointerp(val1)) {
          /* Only integers... */
          if (!intp(val2)) {
            printf("Can only use integers as an index on an array.\n");
          } else if (val2 < 0 || val2 >= sizeof(val1)) {
            printf("Index out of bounds.\n");
          } else {
            val1 = val1[val2];
          }
        } else {
          printf("Can only index off arrays or mappings.\n");
        }
        break;
      default :
        return val1;
    }
  }
  return val1;
} /* bit3() */

protected mixed bit2() {
  mixed val1, val2;

  val1 = bit3();
  while (pos < sizeof(func)) {
    switch (func[pos]) {
      case TOK_MULT :
        pos ++;
        val2 = bit3();
        if ((!intp(val1) && !floatp(val1)) || (!intp(val2) && !floatp(val2))) {
          printf("Incompatible types in multiply, both must be integers.\n");
          val1 = 0;
        } else {
          val1 = val1*val2;
        }
        break;
      case TOK_DIV :
        pos ++;
        val2 = bit3();
        if ((!intp(val1) && !floatp(val1)) || (!intp(val2) && !floatp(val2))) {
          printf("Incompatible types in division, both must be integers.\n");
          val1 = 0;
        } else if (!val2) {
          printf("Division by 0 error.\n");
        } else {
          val1 = val1/val2;
        }
        break;
      default :
        return val1;
    }
  }
  return val1;
} /* bit2() */

mixed expr() {
  mixed val1, val2;

  val1 = bit2();
  while (pos < sizeof(func)) {
    switch (func[pos]) {
      case TOK_PLUS :
        pos ++;
        val2 = bit2();
        if (pointerp(val1) && !pointerp(val2)) {
          printf("Incompatible types in addition, array and something "
                 "else.\n");
          val1 = 0;
        } else {
          val1 = val1 + val2;
        }
        break;
      case TOK_MINUS :
        pos ++;
        val2 = bit2();
        if (pointerp(val1) && !pointerp(val2)) {
          printf("Incompatible types in addition, array and something "
                 "else.\n");
          val1 = 0;
        } else {
          val1 = val1 + val2;
        }
        break;
      case TOK_ASSIGN :
        pos++;
        val2 = expr();
        if (pointerp(val1) || mapp(val1)) {
          printf("Cannot use an array or mapping as a variable name.\n");
        } else {
          this_player()->set_obvar(val1, val2);
        }
        val1 = val2;
        break;
      default :
        return val1;
    }
  }
  return val1;
} /* expr() */

void init_expr(string expr) {
  pos = 0;
  force_string = 0;
  func = TOKENISER->tokenise(expr);
}

void finish_expr() {
  func = 0;
}

#ifdef BOOLEAN
/*
 * Actually.  I think I am starting to get carried away here.  So, I will
 * stop...
 */
mixed eval() {
  mixed *tmp, val1, val2;
  int i, j;

  val1 = bit2();
  while (pos < sizeof(func))
    switch(func[pos]) {
      case TOK_EQUAL :
      case TOK_GREATOR :
      case TOK_LESS :
      case TOK_GREATOREQ :
      case TOK_LESSEQ :
    }
} /* eval() */
#endif
// --- END [/mnt/home2/grok/lib/global/parser.c] ---
// --- BEGIN [/mnt/home2/grok/lib/global/wiz_object_comm.c] ---
// Size:   File: "/mnt/home2/grok/lib/global/wiz_object_comm.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627339   Available: 13574693
Inodes: Total: 5242880    Free: 4960133
2665 bytes, Last Modified:   File: "/mnt/home2/grok/lib/global/wiz_object_comm.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627339   Available: 13574693
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:52.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: wiz_object_comm.c,v 1.2 1998/04/13 14:26:20 pinkfish Exp $
 * $Log: wiz_object_comm.c,v $
 * Revision 1.2  1998/04/13 14:26:20  pinkfish
 * Added documentation and removed unnessessary bits.
 *
 * Revision 1.1  1998/01/06 04:54:05  ceres
 * Initial revision
 * 
*/
#include <creator.h>
 

/**
 * This file conatins all the object based creator commands.
 * @author Ember
 */
private nosave mapping obvar;

void create() {
   obvar = ([ ]);
} /* create() */

/** @ignore yes */
protected void wiz_commands() {
} /* wiz_commands() */

/** @ignore yes */
int affirmative(string s) /* returns true if s is a 'yes' equiv response */
{
    s = lower_case(s);
    return (s == "y" || s == "yes" || s == "ok" || s == "please");
} /* affirmative() */

/* is there an error?  print it */
/** @ignore yes */
void handle_error(string erm, string desc) {
    if (erm) {
         write(desc + " failed : " + erm);
    }
} /* handle_error() */

/**
 * this method sets the given object variable to the given
 * value.
 * @param key the variable name
 * @param value the object variable name
 * @see del_obvar()
 * @see get_obvar()
 * @see get_obvars()
 */
void set_obvar(string key, object value) {
  obvar[key] = value;
} /* set_obvar() */

/**
 * This method deletes the given object variable,
 * @param key the object variable to delet.
 * @see set_obvar()
 * @see get_obvar()
 * @see get_obvars()
 */
void del_obvar(string key) {
  map_delete(obvar, key);
} /* del_obvar() */

/**
 * This method returns the object associated witht the object
 * variable.
 * @param key the object variablename
 * @return the object associated with the name
 * @see del_obvar()
 * @see set_obvar()
 * @see get_obvars()
 */
object get_obvar(string key) {
  return obvar[key];
} /* get_obvar() */

/**
 * This method returns the mapping of all the object variables
 * currently set on this creator.
 * @return all the object variables as a mapping
 * @see del_obvar()
 * @see set_obvar()
 * @see get_obvar()
 */
mapping get_obvars() {
  return obvar;
} /* get_obvars() */

/** @ignore yes */
string desc_object(mixed o) {
  log_file("WIZ_PRESENT", sprintf("desc_object() called by %O.\n", 
      previous_object()));
  return "";
} /* desc_object() */

/** @ignore yes */
string desc_f_object(mixed o) {
  log_file("WIZ_PRESENT", sprintf("desc_f_object() called by %O.\n",
      previous_object()));
  return "";
} /* desc_f_object() */

/** @ignore yes */
object *wiz_present(string str, object onobj, int nogoout) {
  log_file("WIZ_PRESENT", sprintf("wiz_present() called by %O.\n",
      previous_object()));
  return ({});
} /* wiz_present() */
// --- END [/mnt/home2/grok/lib/global/wiz_object_comm.c] ---
// --- BEGIN [/mnt/home2/grok/lib/global/player.c] ---
// Size:   File: "/mnt/home2/grok/lib/global/player.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627338   Available: 13574692
Inodes: Total: 5242880    Free: 4960133
59557 bytes, Last Modified:   File: "/mnt/home2/grok/lib/global/player.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627338   Available: 13574692
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:52.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: player.c,v 1.184 2003/07/15 07:13:27 pinkfish Exp $
 */
/**
 * The main player object.  Does all the player related stuff.
 * @author Pinkfish
 * @started December 1991
 */

#include <config.h>
#include <board.h>
#include <bounty.h>
#ifndef __DISTRIBUTION_LIB__
#include <deity.h>
#endif
#include <drinks.h>
#include <library.h>
#include <living.h>
#include <login.h>
#include <login_handler.h>
#include <log.h>
#include <quest_handler.h>
#include <command.h>
#include <mail.h>
#include <player.h>
#include <skills.h>
#include <top_ten_tables.h>
#include <tune.h>
#include <weather.h>
#include <refresh.h>
#include <nroff.h>
#include <db.h>
#include <error_handler.h>
#include <player_handler.h>
#include <playerinfo.h>
#include <group_handler.h>

// Right now if you move this below the clubs include it will break due to
// mudos class lossage :(
// This class contains all the global, nosaving variables to reduce our
// variable usage.
class player_info {
   int hb_num;
   int level;
   int level_time;
   int save_inhibit;
   int update_tmps_call_out;
   int last_save;
   object snoopee;
   mapping titles;
}
#include <clubs.h>
inherit "/global/line_ed";
inherit "/global/events";
inherit "/global/log";
inherit "/global/spells";
inherit "/global/more_string";
inherit "/global/finger";
inherit "/global/pweath";
inherit "/std/living/living";
inherit "/global/psoul";
inherit "/global/guild-race";
inherit "/global/more_file";
inherit "/global/path";
inherit "/global/start_position";
inherit "/global/family";

#define MIN_TIME_TO_SAVE 1800
#define FORGOT_CO_ORD_TIME (840553267+(8*60*60))
#define LEVEL_CACHE 60

#define ITEM_TRACKER ("/obj/handlers/item_tracker")

/* 
 * Discworld stuff
 */
private nosave class player_info _pinfo;

private int time_on;
private int max_deaths;
private int monitor;
private int _refresh_time;
private int start_time;
private int creator;
private int deaths;
private int last_log_on;
private int no_logins;
private int activity_counter;
private int _flags;
private string cap_name;
private string last_on_from;
private nosave string my_file_name;

void start_player();
void public_commands();
int save();
void set_desc(string str);
void do_load_auto();
void set_name(string str);
int check_dark(int light);
void continue_start_player();
int restart_heart_beat();
int brief_verbose(string,
                  string);
int quit_alt(int verbose);
int review();
int toggle_wimpy(string);
int do_refresh(string);
int do_cap(string);
protected void set_invis(int level);
void set_player_killer(int);
int query_player_killer();

void finished_error_check( object player, string my_name, int status, 
    mixed data );
void check_error_count();
void check_approve_list();

void create()
{
   if (query_name()) {
      return;
   }

   living::create();
   events::create();
   psoul::create();
   line_ed::create();
   more_string::create();
   start_position::create();
   add_property("determinate", "");
   spells::create();
   time_on = time();
   start_time = time();
   seteuid("PLAYER");
   Str = 13;
   Dex = 13;
   Int = 13;
   Con = 13;
   Wis = 13;
   set_max_sp(50);
   set_sp(50);
   wimpy = 20;
   max_deaths = 7;
   set_desc(0);
   add_ac("bing", "blunt", 15);
   add_ac("bing2", "sharp", 15);
   add_ac("bing3", "pierce", 15);
   add_property("player", 1);
   set_cols(79);
   set_rows(24);
   last_log_on = time();
   race_ob = RACE_STD;

   sscanf(file_name(this_object()), "%s#", my_file_name);

   //add_language("common");

   _pinfo = new (class player_info, titles: ([ ]), save_inhibit:1);
}

/**
 * @ignore yes
 */
void dest_me()
{
   if ((query_name() != "object") && objectp(this_player()) &&
       (this_player() != this_object()) &&
       (file_name(this_player()) != "/obj/shut") &&
       (explode(file_name(this_player()), "#")[0] != "/secure/login") &&
       (explode(file_name(this_player()), "#")[0] != "/secure/nlogin")) {
      user_event(this_object(), "inform",
                 (string) this_player()->query_name() +
                 " dests " + query_name(), "dest");
      tell_object(this_object(), "You were destructed by " +
                  capitalize((string) this_player()->query_name()) + ".\n");
   }
   
   if(file_size(PLAYER_HANDLER->query_player_file_name(query_name())+
                ".o.gz") > 0 &&
      PLAYER_HANDLER->query_player_disk_file_name(query_name()) &&
      PLAYER_HANDLER->query_player_file_name(query_name()) !=
      PLAYER_HANDLER->query_player_disk_file_name(query_name())) {
     unguarded((:rename,
                PLAYER_HANDLER->query_player_file_name(query_name())+".o.gz",
                PLAYER_HANDLER->query_player_disk_file_name(query_name())+
                ".o.gz" :));
   }
   ::dest_me();
}                               /* dest_me() */

/**
 * This method stops the player from being able to save.  This is done while
 * the inventory is regenerating to stop problems with inventory loss due
 * to logging off before it has finished.
 * @see allow_save()
 * @see query_save_inhibit()
 */
void disallow_save()
{
   _pinfo->save_inhibit = 1;
}

/**
 * This method allows the player to save again after they have been
 * disallowed.
 * @see disallow_save()
 * @see query_save_inhibit()
 */
void allow_save()
{
   _pinfo->save_inhibit = 0;
}

/**
 * This method returns the value of the disallowing save variable.  If this
 * is a non-zero value then the player must not be saved.
 * @see allow_save()
 * @see disallow_save()
 */
int query_save_inhibit()
{
   return _pinfo->save_inhibit;
}

/**
 * This is the date on which the character was started.  The very first
 * time the player ever logged on.
 * @return the time at which the player first logged on
 */
int query_start_time()
{
   return start_time;
}

/**
 * This method returns the current capitalised name of the player.
 * @return the current capitalised name
 * @see set_cap_name()
 */
nomask string query_cap_name()
{
   return cap_name;
}

/**
 * This method is called from within the login code to start up the
 * new player, set their name and move them into the correct
 * location on the mud.
 * @param bong the name of the player
 * @param new_flag are the a new player?
 * @param c_name their capital name
 * @param ident the ident from the authorisation code
 * @param go_invis go invsible on login
 */
void move_player_to_start(string bong,
                          int new_flag,
                          string c_name,
                          string ident,
                          int go_invis) {
  string lang;
  
   /* Only /secure/login can do this. */
   if (file_name(previous_object())[0..12] != "/secure/login" &&
       file_name(previous_object())[0..13] != "/secure/nlogin") {
      write("You don't have clearance to do that.\n");
      return;
   }
   seteuid("Root");
   set_name(bong);

   if (!new_flag) {
      unguarded((: restore_object,
                   PLAYER_HANDLER->query_player_file_name(query_name()), 1 :));
      if (go_invis) {
        switch(go_invis) {
        case -1:
          set_invis(0);
          break;
        case 2:
          if (this_object()->query_lord()) {
            set_invis(2);
            break;
          }
        case 1:
          set_invis(1);
        }
      }
   }
   disallow_save();             /* don't allow saves until the autoload has started */
   add_property("player", 1);
   cap_name = c_name;
   set_short(cap_name);
   add_property("determinate", "");
   no_logins++;
   if (!query_cols()) {
      set_cols(79);
   }
   remove_property("new player");

   if (this_player()->query_creator()) {
      seteuid(query_name());
      if (file_size("/w/" + query_name() + "/cmds") == -2)
         AddSearchPath(({ "/w/" + query_name() + "/cmds" }));
      AddSearchPath(({ DIR_PLAYER_CMDS, DIR_SECURE_PLAYER_CMDS,
                       DIR_CREATOR_CMDS, DIR_SECURE_CREATOR_CMDS,
                       DIR_PLAYTESTER_CMDS }));
   } else {
      seteuid("PLAYER");
      AddSearchPath(({ DIR_PLAYER_CMDS, DIR_SECURE_PLAYER_CMDS }));
   }
   if (!last_on_from) {
      printf("You have never logged in before.\n");
   } else {
      printf("You last logged in from %s and are currently "
             "logged in from %s (%s).\n", last_on_from,
             query_ip_name(this_object()), query_ip_number(this_object()));
   }
   last_on_from = query_ip_name(this_object()) + " (" +
      query_ip_number(this_object()) + ")";

   //
   // What the heck does this do?
   //
/*
   if ( time_on < -500 * 24 * 60 * 60 ) {
      time_on += time();
   }
 */
   if (time_on > 0) {
      time_on = 0;
   }
   time_on += time();
   if (new_flag) {
      add_property("new player!", 1);
   }
   LOGIN_HANDLER->player_logon(bong, query_property("guest"),
                               (query_ip_name()? query_ip_name() :
                                query_ip_number()));

   if(query_property("guest")) {
     this_player()->set_nationality(DEFAULT_NATIONALITY);
     this_player()->
       set_nationality_region(this_player()->find_region(DEFAULT_NATIONALITY,
                                                         DEFAULT_REGION));
     lang = DEFAULT_NATIONALITY->query_language();
     
     // Setup the default language correctly.
     this_player()->add_language(lang);
     this_player()->set_default_language(lang);
     this_player()->set_language(lang);
   }
   write(LOGIN_HANDLER->get_message("/doc/NEWS"));

   call_out((: continue_start_player :), 0);
   // remove the previously cached entry.
   PLAYER_HANDLER->remove_cache_entry(query_name());
}                               /*  move_player_to_start() */

/** @ignore yes */
protected void move_to_start_pos()
{
   ::move_to_start_pos();
   if (query_verbose("look"))
      command("look");
   else
      command("glance");

   if (!finger_set()) {
      write
         ("%^BOLD%^Please set your finger information with 'chfn'.%^RESET%^\n");
      //command("chfn");
   }

   if(no_logins == 1 && !query_property("guest")) {
     write("\n%^BOLD%^" +
           LOGIN_HANDLER->get_message("/doc/login/NEW_USER_START") +
           "%^RESET%^\n");
   }
   
   no_time_left();
   START_PLAYER->logged_on_times(no_logins);

   // Try resolving hostname one last time.
   if(query_ip_number(this_object()) == query_ip_name(this_object()))
     resolve(query_ip_number(this_object()), "");

}                               /* move_to_start_pos() */

/**
 * @ignore yes
 *
 * This function tracks a players activity to determine whether they're still
 * active or not. Ceres
 */
protected void update_activity(int logon)
{
   int time_on;

   // Lower their activity score if they haven't been on for more than a week.
   if (last_log_on > 0) {
      time_on = last_command - last_log_on;
      if (time_on > 0)
         activity_counter -= (time_on / (3600 * 24 * 7)) * 10;
   }

   if (activity_counter <= -55) {
      activity_counter = -55;
   }
   // when they logon give them a couple more activity points.
   if (logon) {
      activity_counter += 3;
   } else {                     // when they leave give them some more for each hour they were on.
      activity_counter += 2 * ((time() - last_log_on) / 3600);
   }

   // Set minima and maxima to the counter.
   if (activity_counter >= 0)
      activity_counter = 0;
}

/**
 * Return the current value of this players activity_counter
 * (used for debugging)
 */
int query_activity_counter()
{
   return activity_counter;
}

/**
 * THis method prints something if there are bug replies to see.
 */
private void display_bug_replies(int type, class error_replies* replies) {
   if (type == DB_SUCCESS) {
      if (sizeof(replies) > 0) {
         tell_object(this_object(), "\n\nYou have %^YELLOW%^" +
            sizeof(replies) + " NEW%^RESET%^ bug repl" +
            (sizeof(replies) > 1?"ies ":"y ") +
            "(read with 'bug replies').\n\n");
      }
   }
}

private void check_mccp() {
   if(!compressedp(this_object())) {
     write("\n%^BOLD%^%^RED%^You are logged in uncompressed!\n");
     write("Use of an MCCP capable mud client will reduce your load on "
           "the " + mud_name() + " system.%^RESET%^\n\n");
   }
}

/**
 * @ignore yes
 */
void continue_start_player()
{
   string title;
   mapping news_rc;
   mixed *stuff;
   object book;

   // Set the cre flag for setting up commands etc.
   if (this_object()->query_lord()) {
      creator = 1;
   }

   start_player();
   no_time_left();
   /* Remove passed out property, unless the player is
    * in a trance, e.g. when contemplating. */
   if (query_property(PASSED_OUT) && !query_property(TRANCE)) {
      call_out((: remove_property :), 10 + random(30), PASSED_OUT);
   }
   remove_property(UNKNOWN_MOVE);
   remove_property(RUNNING_MOVE);
   init_after_save();           /* for effects */
   printf("%s", fix_string(MAILER->new_mail(query_name())));
   news_rc = BOARD_HAND->query_newsrc(query_name());
   if (!news_rc) {
      news_rc = ([ ]);
   }
   stuff = BOARD_HAND->get_subjects("announcements");
   if (sizeof(stuff)) {
      if (stuff[<1][B_TIME] > news_rc["announcements"]) {
         write("\nThere are %^YELLOW%^NEW%^RESET%^ announcements.  ");
         write("You can read them with \"news\".\n\n");
         //"/cmds/player/news"->do_list();
         //printf("You can read then with \"news\".\n\n");
      }
   }

   call_out((: check_mccp :), 4);
       
   if (query_property("dead")) {
      (clone_object(DEATH_SHADOW))->setup_shadow(this_object());
      // Give them a dead book too.
      book = clone_object(DEAD_BOOK);
      book->move(this_object());
   }
   if (query_property("noregen")) {
      DEATH->person_died(query_name());
   }
   exec_alias("login", "");
   update_activity(1);
   last_log_on = time();
   title = LIBRARY->query_title(query_name());
   if (stringp(title)) {
      _pinfo->titles += ([ "quest" : title ]);
   }
   if (my_file_name != "/global/player") {
      check_error_count();
      if(my_file_name != "/global/playtester") {
        check_approve_list();
      }
   }
   if (query_property("new player!")) {
     // Clear the alt info.
     PLAYERINFO_HANDLER->player_created(query_name());
      user_event(this_object(), "inform",
                 capitalize(query_name()) +
                 " arrives on " + mud_name() + " for the first time!", "new-player");
      remove_property("new player!");
      set_last_pos(CONFIG_NEWBIE_START_LOCATION);
      START_PLAYER->start_player(this_object());
   }
   //add_language("common");
   check_family_name();
   call_out((: move_to_start_pos :), 0);
   call_out((: set_heart_beat(1) :), 1);
   // Tell them about new error replies.
   ERROR_HANDLER->do_error_replies(query_name(), 1, (: display_bug_replies :));

}                               /* continue_start_player() */

/**
 * @ignore yes
 */
void check_error_count() {
   string my_name; 
    
   my_name = query_name(); 

   DB_HANDLER->make_sql_request( "errors", "atuin", "", 
      "SELECT COUNT(Id) AS idc FROM errors WHERE Directory = '/w/" + 
      my_name + "' AND Status = 'OPEN'", 
       (: finished_error_check, this_object(), my_name :) ); 
} /* check_error_count() */

/**
 * @ignore yes
 */
void finished_error_check( object player, string my_name, int status, 
    mixed data ) {

   int num;
   int ret;

   if ( file_size("/w/" + my_name + "/" + PLAYER_ERROR_LOG) > 0 ) {
       num = file_length("/w/" + my_name + "/" + PLAYER_ERROR_LOG);
       tell_object( player, "%^YELLOW%^You have %^RED%^" + num + 
           "%^YELLOW%^ director" + (num == 1 ? "y" : "ies") + 
           " with %^RED%^ERRORS%^YELLOW%^ in /w/" + my_name + "/" + 
           PLAYER_ERROR_LOG + ".%^RESET%^\n");
   }

   if ( status == DB_SUCCESS && sizeof( data ) > 0 ) { 
      if ( ( ret = data[0]["idc"] ) > 0 ) {
         tell_object( player, "%^YELLOW%^You have %^RED%^" + ret + 
            " ERROR" +  (ret == 1 ? "" : "S") + "%^YELLOW%^ in /w/" + 
            my_name +  ".%^RESET%^\n");
      }
   }
} /* finished_error_check() */ 

/** @ignore yes */
void check_approve_list() {
  string str;
  mapping assignments;
  int count;
  
  assignments = master()->query_directory_assignments();
  foreach(str in keys(assignments)) {
    if(member_array(this_object()->query_name(), assignments[str]) != -1 &&
       file_size(str + "/to_approve")) {
      count = sizeof(get_dir(str + "/to_approve/*")) - 2;
      if(count > 0)
        tell_object(this_object(), "%^YELLOW%^" + str + " has %^RED%^" +
                    count + "%^YELLOW%^ item" + (count > 1 ? "s" : "") +
                    " awaiting approval.%^RESET%^\n");
    }
  }
}

/**
 * @ignore yes
 */
void start_player()
{
   if (this_object()->query_creator() && my_file_name != "/global/player") {
      this_player()->all_commands();
      this_player()->app_commands();
      this_player()->wiz_commands();
   }
   call_out((: do_load_auto :), 1);
   reset_get();
   enable_commands();
   public_commands();
   command_commands();
   parser_commands();
   force_commands();
   race_guild_commands();
   soul_commands();
   event_commands();
   finger_commands();
   communicate_commands();
   living_commands();
   logging_commands();
   editor_commands();
   if (this_player()->query_creator()) {
      set_living_name(query_name());
   }
   set_no_check(1);
   set_con(Con);
   set_dex(Dex);
   set_int(Int);
   set_str(Str);
   set_wis(Wis);
   reset_all();
   set_current_path(query_home_dir());
   if (wimpy > 100) {
      wimpy = 25;
   }
   if (contmp || dextmp || inttmp || strtmp || wistmp) {
      _pinfo->update_tmps_call_out = call_out((: update_tmps :), 900);
   }
}

/* added chrisy 6 june 93 to stop net-dead players getting killed */
/**
 * @ignore yes
 * This is an over ride of something in /std/living
 */
int adjust_hp(int number,
              object attacker,
              object weapon,
              string attack)
{
   if (!interactive(this_object()))
      return query_hp();
   return::adjust_hp(number, attacker, weapon, attack);
}                               /* adjust_hp() */

/**
 * Starts the autoloading process.  This is called just after a player
 * logs in to start up the auto loading process.
 */
void do_load_auto()
{
   load_auto_load_alt(query_auto_load_string(), this_object(), this_object(),
                      (: tell_object(this_object(),
                                     "\n%^CYAN%^Inventory regeneration complete.%^RESET%^\n") :));
   set_auto_load_string(0);
   allow_save();
}                               /* do_load_auto() */

/**
 * @ignore yes 
 */
void public_commands()
{
   add_command("restart", this_object(), "", (: restart_heart_beat() :));
   add_command("save", this_object(), "", (: save() :));
   add_command("quit", this_object(), "", (: quit_alt(-1) :));
   add_command("quit", this_object(), "brief", (: quit_alt(0) :));
   add_command("quit", this_object(), "verbose", (: quit_alt(1) :));
   add_command("review", this_object(), "", (: review() :));
   add_command("wimpy", this_object(), "", (: toggle_wimpy(0) :));
   add_command("wimpy", this_object(), "<word'number'>",
               (: toggle_wimpy($4[0]) :));
   add_command("refresh", this_object(), "<word'totally'>",
               (: do_refresh($4[0]) :));
   add_command("cap", this_object(), "<word'name'>", (: do_cap($4[0]) :));
}                               /* public_commands() */

/**
 * Force the player to glance.  Forces the player to glance in a
 * certain direction.
 * @param str the direction to glance in
 * @return 0 ifg the command failed, non zer if it succeeded
 */
int glance(string str)
{
   return command("glance" + (str ? " " + str : ""));
}                               /* glance() */

/**
 * Force the player to look.  Forces the player to look at something
 * or just around.  If the input is set to "" then they look around.
 * @param str what to look at
 * @return 0 if it failed, non zero on success
 * @see efun::command()
 */
int look_me(string str)
{
   return command(str ? "look" + str : "look");
}                               /* look_me() */

/**
 * @ignore yes
 */
int review()
{
   write("Entry  : " + query_msgin() + "\n");
   write("Exit   : " + query_msgout() + "\n");
   write("MEntry : " + query_mmsgin() + "\n");
   write("MExit  : " + query_mmsgout() + "\n");
   write("Editor : " + query_editor() + "\n");
   return 1;
}                               /* review() */


/**
 * Forces the player to examine something.  This does the same as the look_me
 * function.
 * @see look_me()
 * @return 0 on a failure, non zero on success.
 * @param arg the thing to look at.
 */
int examine(string arg)
{
   return look_me(arg ? " at " + arg : "");
}                               /* examine() */

/**
 * @ignore yes
 */
varargs string short(int dark,
                     int verbose)
{
   string str;
   string family;
   string title;

   if (!interactive(this_object())) {
      str = "the net dead statue of ";
   } else {
      str = "";
   }

   family = query_family_name();
   if (!family) {
      family = "";
   } else {
      family = " " + family;
   }

   if (verbose)
      title = query_player_title();
   if (!title) {
      title = "";
   } else {
      title = title + " ";
   }

   return str + title + living::short(dark) + family;
}                               /* short() */

/**
 * This method changes the current value of the wimpy variables.
 * @param str the new value of the wimpy variable
 * @return 0 on failure and 1 on success
 */
int toggle_wimpy(string str)
{
   int number;
   if (!str) {
      if (this_object()->query_wimpy())
         write("You are in wimpy mode, you will run away at " +
               this_object()->query_wimpy() +
               "% of your max hps.\n");
      else
         write("You are in brave mode.\n");
      write("Usage: wimpy <num> (caution read help wimpy)\n");
      return 1;
   }
   if (sscanf(str, "%d", number) != 1)
      return notify_fail("You must set your wimpy to a number.\n");
   if ((number < 0) || (number > 30))
      return notify_fail("Your wimpy must be between 0 and 30%.\n");
   this_object()->set_wimpy(number);
   printf("Wimpy set to %d%%\n", wimpy);
   return 1;
}                               /* toggle_wimpy() */


/**
 * This method returns any extra information associated with the score.  This
 * method will mostly be overridden by shadows which wish to place more
 * information into the score command.
 * @return the extra information to place in the score
 */
string extra_score()
{
   return "";
}

/**
 * This method is deprecated.
 *
 * @return always returns 1
 * @see save_me()
 */
nomask int save() {
#ifdef UNUSED
  if(query_verb() == "save") {
    if(_pinfo->last_save > time() - 900) {
      tell_object(this_object(), "You saved only a few minutes ago.\n");
      return 1;
    }
    _pinfo->last_save = time();
  } 
#endif

  /*
   * easier on me - Pinkfish.
   * ..
   */
  if (((time() - time_on) < MIN_TIME_TO_SAVE) &&
      !LIBRARY->query_quest_points(query_name()) &&
      !query_property("authorised player")) {
    if (query_verb() == "save") {
      tell_object(this_object(), "You're too young to save... sorry.\n");
    }
    return 1;
  }
  
  tell_object(this_object(), "Saving...\n");
  this_object()->save_me();
  return 1;
}

/**
 * Saves the player.  Saves the player to disc, doing all the autoload
 * stuff and such like.
 * @see save()
 */
void save_me() {
   mixed old;

#ifdef NOT_SAVEING_PLAYERS
   if (!this_object()->query_creator()) {
      write("Not saving for players currently.\n");
      return;
   }
#endif
   if (query_auto_loading())
      return;

   if (query_property("guest")) {
      if (query_verb() == "save")
         tell_object(this_object(), "But not saving for guests... Sorry.\n");
      return;
   }

   /* If this is called before auto_loading has even started, log and abort
    * Olorin 31-Mar-97
    */
   if (query_save_inhibit()) {
      return;
   }

   if (guild_ob) {
      guild_ob->player_save(this_object());
   }
   if (race_ob) {
      race_ob->player_save(this_object());
   }
   old = geteuid();

   check_last_pos();

   /* for effects */
   effect_freeze();
   effects_saving();
   /* Recreating the autoload stuff. */
   create_auto_load(all_inventory(), 1);
   if (interactive(this_object())) {
      last_on_from = query_ip_name(this_object()) + " (" +
         query_ip_number(this_object()) + ")";
   }
   //
   // Keep the time_on calculation as close to the saving as possible.
   //
   time_on -= time();
   //if (query_creator()) {
      catch(unguarded((: save_object,
                      PLAYER_HANDLER->query_player_file_name(query_name()), 3 :)));
/*
   } else {
      catch(unguarded((: save_object,
                      PLAYER_HANDLER->query_player_file_name(query_name()), 1 :)));
   }
 */
   time_on += time();
   ITEM_TRACKER->save_all_item_states(this_object()->query_name());
   effect_unfreeze();
//   if (this_object()->query_creator()) {
   /* Clear the autoload string after saving to save memroy. */
   set_auto_load_string(0);
//   }
}                               /* save_me() */

void save_with_auto_load(mixed al)
{
   mixed old;

#ifdef NOT_SAVEING_PLAYERS
   if (!this_object()->query_creator()) {
      write("Not saving for players currently.\n");
      return;
   }
#endif
   if (query_property("guest")) {
      write("But not saving for guests... sorry.\n");
      return;
   }
   if (((time() - time_on) < MIN_TIME_TO_SAVE) && query_verb() == "save") {
     tell_object(this_object(), "You're too young to save... sorry.\n");
     return;
   }
   
   /* If this is called before auto_loading has even started, log and abort
    * Olorin 31-Mar-97
    */
   if (query_save_inhibit()) {
      return;
   }
   if (guild_ob) {
      guild_ob->player_save(this_object());
   }
   if (race_ob) {
      race_ob->player_save(this_object());
   }
   old = geteuid();

   /* for effects */
   effect_freeze();
   effects_saving();
   set_auto_load_string(al);
   if (((time() - time_on) >= MIN_TIME_TO_SAVE) ||
       LIBRARY->query_quest_points(query_name())) {
     //
      // Put the time_on calculation as close to the save as possible.
      //
      time_on -= time();
      //if (query_creator()) {
         catch(unguarded((: save_object,
                         PLAYER_HANDLER->query_player_file_name(query_name()),
                         3 :)));
/*
      } else {
         catch(unguarded((: save_object,
                         PLAYER_HANDLER->query_player_file_name(query_name()),
                         1 :)));
      }
 */
      time_on += time();
   }
   effect_unfreeze();
}                               /* save_with_auto_load() */

/**
 * This is the quit code called by the command 'quit'
 * @return 1 if successful, 0 if failed
 * @see quit()
 * @see do_quit()
 */
int quit_alt(int verbose)
{
   object frog;

   if (verbose == -1) {
      verbose = query_verbose("quit");
   }

   if (query_auto_loading()) {
      if (!interactive(this_object())) {
         dest_me();
      } else {
         write
            ("You cannot quit yet: your inventory is still being generated.\n");
      }
      return 1;
   }

   if (sizeof(filter_array((object *) this_object()->query_attacker_list(),
                           (: living($1) :))) &&
       this_player() == this_object() && interactive(this_object())) {
      write
         ("You cannot quit while in combat.  Use 'stop' to stop fighting.\n");
      return 1;
   }

   check_last_pos();

   update_activity(0);
   last_log_on = time();

   // Added to help people tell when the player quits.
   catch(this_object()->event_quit(this_object()));
   catch(environment(this_object())->event_quit(this_object()));

   catch(editor_check_do_quit());
   write("A small gecko takes your hand and rushes you to the departure "
         "lounge.\n");
   say(query_cap_name() + " leaves the game.\n");
   catch(move("/room/departures"));

   user_event(this_object(), "inform",
              query_cap_name() + " leaves " + mud_name() + "", "logon", this_object());

   catch(LOGIN_HANDLER->player_logout(query_name()));
   if (race_ob) {
      catch(race_ob->player_quit(this_object()));
   }
   if (guild_ob) {
      catch(guild_ob->player_quit(this_object()));
   }

   frog = clone_object("/obj/monster/greco");
   frog->move("/room/departures");
   frog->get_rid_of(this_object(), verbose);
   return 1;
}                               /* quit_alt() */

/**
 * quits the player.
 * @return zero if it failed, non zero on success
 * @see quit()
 * @see quit_alt()
 */
int do_quit()
{
   return quit_alt(-1);
}                               /* do_quit() */

/**
 * A forced quit.
 * This is the function called by external objects to quit
 * a player. It avoids checks for things like being in combat.
 *
 * @return 0 if it failed, non zero if it succeeded.
 * @see do_quit()
 * @see quit_alt()
 * @see efun::command()
 */
int quit()
{
   if (query_auto_loading() || query_save_inhibit()) {
      tell_object(this_object(),
                  "Forced to quit whilst auto loading.  Not saving.\n");
      ::dest_me();
      return 1;
   }

   check_last_pos();

   update_activity(0);
   last_log_on = time();

   catch(editor_check_do_quit());

   // Added to help people tell when the player quits.
   catch(this_object()->event_quit(this_object()));
   catch(environment(this_object())->event_quit(this_object()));

   tell_object(this_object(), "Thanks for playing.  See you next time.\n");
   say(query_cap_name() + " leaves the game.\n");

   user_event(this_object(), "inform",
              query_cap_name() + " leaves " + mud_name() + "", "logon", this_object());

   catch(LOGIN_HANDLER->player_logout(query_name()));
   if (race_ob) {
      catch(race_ob->player_quit(this_object()));
   }
   if (guild_ob) {
      catch(guild_ob->player_quit(this_object()));
   }
    
   catch(save_me());

   foreach( object inv in all_inventory( this_object() ) ) {
      reset_eval_cost(); 
      catch( inv->set_tracked_item_status_reason("QUIT") );
      catch( inv->dest_me() );
   }

   catch(ITEM_TRACKER->
         save_all_item_states_delete_cache(this_object()->query_name()));
   effects_quiting();
   
   // One more for good luck. 
   reset_eval_cost(); 

   if (catch(dest_me())) {
      destruct(this_object());
   }
   return 1;
}                               /* quit() */

/**
 * This method returns the mapping of all the title associated with this
 * player.
 * @return the current mapping of titles
 * @see query_title()
 * @see set_title()
 * @see remove_title()
 */
mapping query_titles()
{
   return copy(_pinfo->titles);
}

/**
 * This method returns the list of titles associated with this player.
 * @return the list of titles
 * @see query_titles()
 * @see set_title()
 * @see remove_title()
 */
string query_title()
{
   return implode(m_values(_pinfo->titles), ", ");
}

/**
 * This method sets the current title type to be of a certain name.
 * @param type the type of title to set
 * @param title the string to set it to
 * @see query_title()
 * @see set_title()
 * @see remove_title()
 */
void set_title(string type,
               string title)
{
   _pinfo->titles[type] = title;
}

/**
 * This method removes the title of the given type from the title mapping.
 * @param type the type of title to remove
 * @see query_title()
 * @see set_title()
 * @see remove_title()
 */
void remove_title(string type)
{
   map_delete(_pinfo->titles, type);
}

/**
 * This method returns the number of times the player has died.
 * @return the number of times the player has died
 * @see adjust_deaths()
 * @see adjust_max_deaths()
 */
int query_deaths()
{
   return deaths;
}

/**
 * This method changes the number of times the player has died.  This
 * can only be positive.
 * @param i the amount of deaths to adjust by, must be +ve
 * @see query_deaths()
 * @see adjust_max_deaths()
 */
void adjust_deaths(int i)
{
   if (i > 0) {
      deaths += i;
   }
}

/* nomask protected void set_name(string str) { */
/** @ignore yes */
nomask void set_name(string str) {
  if (query_name() && query_name() != "object") {
    return;
  }
  if (file_name(previous_object())[0..12] != "/secure/login" &&
      file_name(previous_object())[0..13] != "/secure/nlogin") {
    return;
  }
  ::set_name(str);
  set_living_name(query_name());
  set_main_plural(query_name());
}                               /* set_name() */

/**
 * @ignore yes
 * No ide what this is doing here?
 */
void init_static_arg(mapping map)
{
   return;
}

/**
 * @ignore yes
 */
void init_dynamic_arg(mapping, object) {
  return;
}

/** @ignore yes */
string long(string str,
            int dark)
{
   string s;
   string tmp;
   string title;
   string nationality;

   title = query_player_title();
   if (!title) {
      title = "";
   } else {
      title = title + " ";
   }

   s = "You see " + title + query_short();
   tmp = query_family_name();
   if (tmp) {
      s += " " + query_family_name();
   }
   if (guild_ob) {
      s += " " + (string) guild_ob->query_title(this_object()) + ".\n";
   } else {
      s += ".\n";
   }
   if (race_ob) {
      s += (string) race_ob->query_desc(this_object());
   }

   nationality = query_nationality_description(this_player());
   if (nationality  &&  nationality != "") {
      s += nationality + "\n";
   }

   if (dark == 2 || dark == -2) {
      s += "It is too ";
      if (dark == -2) {
         s += "dark";
      } else {
         s += "bright";
      }
      s += " to see their description or what " +
         query_pronoun() + " are wearing or carrying.\n";
      s += calc_extra_look();
   } else {
      if (query_desc() && query_desc() != "") {
         s += capitalize(query_pronoun()) + " " + query_desc() +
              query_main_zone_desc(query_wearing()) + "\n";
      }
      s += capitalize(query_pronoun()) + " " +
         this_object()->health_string() + ".\n";
      s +=
         capitalize(query_pronoun()) + " is " + query_position_short() +
         ".\n";
      s += calc_extra_look();
      s += weather_extra_look();
      s += query_living_contents(0);
   }
   return s;
}                               /* long() */

/**
 * This method is called when the player dies.  It creates the corpse
 * and handles all the bits and pieces that should be dealth with
 * when a player dies.
 * <p>
 * If this method returns 0 then the automatic death handling code
 * in the living object is used instead of this.
 * @return always returns 1
 */
mixed second_life()
{
   object corpse;
   string death_mess;

   add_property("dead", time());

   if (!DEATH->someone_died(this_object())) {
      deaths++;
   }

   effects_thru_death();
   corpse = make_corpse();
   reset_protectors();

   if (deaths > max_deaths) {
      death_mess = query_property ("death mess");
      tell_object(this_object(), "You have died your final death.  " +
                "Your name will be inscribed in the Hall of Legends.\n");
      
      if (death_mess && sizeof (death_mess)) {
        death_mess = strip_colours (death_mess);
        death_mess = replace (death_mess, ({"\n", "", "\a", ""}));
        
        shout(capitalize(query_name()) + " has died for the last time.  " +
          death_mess + "\n");
      }
      else {                
        shout(capitalize(query_name()) + " has died for the last time.  " +
             capitalize(query_pronoun()) + " is mourned.\n");
      }
      
      LIBRARY->complete_death(query_name());
      corpse->move(PLAYER_MORGUE);
   } else
      corpse->move(environment());

   call_out((: save_me :), 0);
   if (find_object(OFFLER) && (deaths <= max_deaths)) {
      OFFLER->person_died(query_name());
   } else {
      DEATH->person_died(query_name());
   }
   clone_object(DEATH_SHADOW)->setup_shadow(this_object());
   if (guild_ob) {
      guild_ob->member_died(this_object());
   }
   gp = 0;
   hp = 0;
   set_sp(0);
   set_max_sp(50);
   xp = 0;
   //spells = ([ ]);
   reset_spells();
   reset_processes();
   contmp = dextmp = inttmp = strtmp = wistmp = 0;
   remove_call_out(_pinfo->update_tmps_call_out);
   adjust_tmp_con(-2);
   adjust_tmp_dex(-2);
   adjust_tmp_int(-2);
   adjust_tmp_str(-2);
   adjust_tmp_wis(-2);
   return corpse;
}                               /* second_life() */

/**
 * This method removes the ghost from the player.  This stops them
 * being a ghost and turns them back into a real person.
 * @see second_life()
 */
void remove_ghost()
{
   if (deaths > max_deaths) {
      if (this_player() != this_object()) {
         tell_object(this_object(), this_player()->query_cap_name() +
                     " tried to raise you, but you are completely dead.\n");
         tell_object(this_player(), query_cap_name() +
                     " is completely dead, you cannot raise " +
                     query_objective() + ".\n");
      } else {
         tell_object(this_object(), "You are completely dead.  You cannot " +
                     "be raised.\n");
         say(query_cap_name() +
             " struggles to appear in a solid form, but fails.\n");
         return;
      }
   }
   remove_property("dead");
   tell_object(this_object(), "You reappear in a more solid form.\n");
   if (guild_ob) {
      guild_ob->member_resurrected(this_object());
   }
   say(query_cap_name() + " appears in more solid form.\n");
   if (query_hp() < 0) {
      set_hp(1);
   }
   set_personal_temp(0);

   this_object()->dest_death_shadow();
   save_me();
   all_inventory()->recovery_from_death();
}                               /* remove_ghost() */

/**
 * Called when the player goes net dead.  This is called
 * by the driver when a player goes net dead.  Turns them into
 * a statue and stuff.
 */
void net_dead()
{
   if (!environment() || file_name(environment()) == "/room/departures") {
      // Don't do anything here...
      return;
   }

   if ((query_name() == "guest") || (query_name() == "root")) {
      say(query_name() + " vanishes in a puff of logic.\n");
      quit();
   } else {
      say(query_name() + " goes white, looks very chalky and turns into a " +
          "statue.\n");
      user_event(this_object(), "inform",
                 capitalize(query_name()) + " has lost " +
                 query_possessive() + " link", "link-death", this_object());
      check_last_pos();
      LOGIN_HANDLER->player_net_dead(query_name());
      /* Called to save the player when they go net dead. */
      save_me();
   }
   event(environment(), "net_dead", this_object());
}                               /* net_dead() */

/**
 * Checks to see if they have idled out.  This is called from within
 * the heart beat code.
 * @see heart_beat()
 */
void idle_out()
{
   say(cap_name + " has been idle for too long; " + query_pronoun() +
       " vanishes in a puff of boredom.\n");
   write("You idled out, sorry.\n");
   quit();
}                               /* idle_out() */

/**
 * The main heart beat function.  This is called by the driver
 * every 2 seconds on the player.  Does all the maintence
 *  stuff like fixing up hps and stuff like that.
 */
void heart_beat()
{
   catch {
      int idle_time;

      events::print_messages();
      flush_queue();

      if (!interactive(this_object())) {
         idle_time = time() - last_command;
      } else {
         idle_time = query_idle(this_object());
      }

      if (query_creator()) {
         idle_time = idle_time / 3;
         /* Time out for creators is 3 times that of players... */
      }

      if (idle_time > FULL_IDLE) {
         if ((LOGIN_HANDLER->is_discworld_full() || idle_time > MAX_IDLE) &&
             (!interactive(this_object())
              || my_file_name != "/global/lord")) {
            call_out((: idle_out :), 2);
         }
      }

      if (interactive(this_object())) {

         living::heart_beat();
         adjust_sp(1);
         adjust_xp(3);
         living::update_volumes();

         this_object()->do_spell_effects(0);

         // reset it every hour to stop it rolling over.
         if (_pinfo->hb_num++ > 1800)
            _pinfo->hb_num = 0;

         // Do these checks less frequently.
         if (!(_pinfo->hb_num % 120)) {

            calc_personal_temp();
            adjust_max_sp(1);
         }
      }
   };
}                               /* heart_beat() */

/**
 * Is rthe monitor turned on?  The hit point monitor which is
 * displyed during combat...
 *
 * @return 1 if it is on, 0 if not
 */
int query_monitor()
{
   return monitor;
}

/**
 * Set the hit point minitor.  This sets the value of the hit point
 * monitor flag.  If it is set to 0, the monitor is turned off.  If
 * it is set to 1 the monitor is turned on, higher values cause the monitor
 * to be displayed every N heartbeats.
 *
 * @param i the new value for the hit point monitor flag
 */
void set_monitor(int i) {
  monitor = i;
}

protected void write_prompt()
{
   efun::tell_object(this_object(), "> ");
   return;
}

#ifdef UNUSED
protected void write_prompt()
{
   string prompt;
   int tmp,
     i;
   string stuff;

   if (!(monitor & 2) || !this_object()->query_creator())
      efun::tell_object(this_object(), "> ");
   else {
      prompt = "";
      stuff = this_player()->query_property("prompt");
      for (i = 0; i < strlen(stuff); i++) {
         switch (stuff[i]) {
         case 'h':             // Hp %
            tmp = ((query_hp() * 100) / query_max_hp());
            prompt += "Hp:";
            switch (tmp) {
            case 50..100:
               prompt += "%^GREEN%^";
               break;
            case 20..49:
               prompt += "%^YELLOW%^";
               break;
            default:
               prompt += "%^RED%^";
            }
            prompt += tmp + "%^RESET%^";
            break;

         case 'H':             // Hp %
            tmp = ((query_hp() * 100) / query_max_hp());
            prompt += "Hp:";
            switch (tmp) {
            case 50..100:
               prompt += "%^GREEN%^";
               break;
            case 20..49:
               prompt += "%^YELLOW%^";
               break;
            default:
               prompt += "%^RED%^";
            }
            prompt += query_hp() + "%^RESET%^";
            break;

         case 'g':             // Gp %
            tmp = (query_gp() * 100) / query_max_gp();
            prompt += "Gp:";
            switch (tmp) {
            case 50..100:
               prompt += "%^GREEN%^";
               break;
            case 20..49:
               prompt += "%^YELLOW%^";
               break;
            default:
               prompt += "%^RED%^";
            }
            prompt += tmp + "%^RESET%^";
            break;

         case 'G':             // Gp
            tmp = (query_gp() * 100) / query_max_gp();
            prompt += "Gp:";
            switch (tmp) {
            case 50..100:
               prompt += "%^GREEN%^";
               break;
            case 20..49:
               prompt += "%^YELLOW%^";
               break;
            default:
               prompt += "%^RED%^";
            }
            prompt += query_gp() + "%^RESET%^";
            break;

         case 's':             // Sp %
            tmp = (query_sp() * 100) / query_max_sp();
            prompt += "Sp:";
            switch (tmp) {
            case 50..100:
               prompt += "%^GREEN%^";
               break;
            case 20..49:
               prompt += "%^YELLOW%^";
               break;
            default:
               prompt += "%^RED%^";
            }
            prompt += tmp + "%^RESET%^";
            break;

         case 'S':             // Sp
            tmp = (query_sp() * 100) / query_max_sp();
            prompt += "Sp:";
            switch (tmp) {
            case 50..100:
               prompt += "%^GREEN%^";
               break;
            case 20..49:
               prompt += "%^YELLOW%^";
               break;
            default:
               prompt += "%^RED%^";
            }
            prompt += query_sp() + "%^RESET%^";
            break;

         case 'X':
         case 'x':
            prompt += "Xp:" + query_xp();
            break;

         default:
            if (sizeof(prompt) > 0 && prompt[sizeof(prompt) - 1] != stuff[i])
               prompt += sprintf("%c", stuff[i]);
         }
      }
      prompt += "> ";
      efun::tell_object(this_object(), fix_string(prompt));
   }
}
#endif

/**
 * Called when the player wimpys out of a place.  This does all the run
 * away stuff anfd things like that.
 * @return 1 if succeeded in running away, 0 if not
 */
int run_away()
{
   int number;
   become_flummoxed();
   number =::run_away();
   if (number)
      tell_object(this_object(), "Your feet run away with you!\n");
   else
      tell_object(this_object(), "You try to run away, but no matter how "
                  "you scrabble, you can't find any way out.\n");
   return number;
}                               /* run_away() */

/**
 * The amount of time on line.  This is the total amount of time online
 * in seconds from when they first started playing.  The return from
 * this method is *negative*, you will need to make it positive to use it
 * most likely.
 * @return the total log on time in seconds (the return value is *negative*)
 */
nomask int query_time_on()
{
   return time_on - time();
}

/**
 * This method determins if the player is mature or not yet.  It is based
 *  on the amount of time on.
 * @return 1 if the player is mature, 0 if they are not
 */
int query_mature()
{
   return (MATURITY * 60 * 60 + time_on < time());
}

/**
 * Can the player see?  Checks to see if the player can see at the passed
 * in light level.
 * @return 1 if they can see, 0 if they cannot
 */
int check_dark(int light)
{
   int i;

   if (race_ob)
      if (catch(i = (int) race_ob->query_dark(light)))
         race_ob = RACE_STD;
      else
         return i;
   return (int) RACE_STD->query_dark(light);
}                               /* check_dark() */

/**
 * Returns the players level.  Uses their current guild to determine their
 * guild level.
 * @return their guild level
 */
int query_level()
{
   string tmp;

   if (_pinfo->level_time < (time() - LEVEL_CACHE)) {
      if (guild_ob) {
         _pinfo->level = (int) guild_ob->query_level(this_object());
      } else {
         /*
          * If they do not have a guild object, see if they have a backup
          * set.  Otherwise use the warriors guild as the level setter.
          */
         tmp = query_property("backup guild");
         if (tmp) {
            _pinfo->level = tmp->query_level(this_object());
         } else
            _pinfo->level = CONFIG_DEFAULT_GUILD->query_level(this_object());
      }
      _pinfo->level_time = time();
   }

   return _pinfo->level;
}                               /* query_level() */

/**
 * Restarts their heartbeat if it has got turned off for some reason.
 * @return always returns 1
 */
int restart_heart_beat()
{
   set_heart_beat(1);
   write("Ok, heart_beat restarted.\n");
   return 1;
}

/**
 * @ignore yes
 */
nomask void set_snoopee(object ob)
{
   _pinfo->snoopee = ob;
}

/**
 * Returns the object snooping us.  If someone is snooping the player it
 * returns the object doing the snooping.  If no one is snooping the player
 * it returns 0.
 * @return the object snooping the player
 * @see efun::snoop()
 */
nomask object query_snoopee()
{
   return _pinfo->snoopee;
}

/**
 * @ignore yes
 */
void set_creator(int i)
{
   if (previous_object() != master()) {
      write("Illegal attempt to set creator!\n");
      log_file("ILLEGAL", this_player(1)->query_name() + " (" +
               file_name(this_player(1)) +
               ") Illegal attempt to set_creator " + "at " + ctime(time()) +
               " from " + file_name(previous_object()) + "\n");
      return;                   /* THIS WAS MISSING !!!  Turrican 4-11-95 */
   }
   creator = i;
   set_home_dir("/w/" + query_name());
   save_me();
}                               /* set_creator() */

/**
 * Prevent the object from shadowing us?  This checks to see if we should
 * prevent this object from shadowing the player.
 * @return 1 if we are prventing the shadow
 */
int query_prevent_shadow(object ob)
{
   if (function_exists("query_prevent_shadow", ob) ||
       function_exists("query_name", ob) ||
       function_exists("query_creator", ob) ||
       function_exists("query_lord", ob) ||
       function_exists("query_hidden", ob) ||
       function_exists("dest_me", ob) ||
       function_exists("query_object_type", ob) ||
       function_exists("query_lord", ob) || function_exists("save_me", ob))
/* added by sojan to fix security holes */
      return 1;
   return 0;
}

/**
 * Returns the maxium number of deaths.  This is the maxium number of times they
 * can die before they are totaly dead.
 * @return the maxiumm number fo deaths
 */
int query_max_deaths()
{
   return max_deaths;
}

/**
 * Sets the maximum number of deaths.  This sets the maximum number of times a player can
 * die.
 * @param i the nukber of deaths to set it to
 * @see adjust_max_deaths()
 */
protected void set_max_deaths(int i)
{
   max_deaths = i;
}

/**
 * Changes the current number of maxium deaths.  This adjust
 * the number of times a player can die before they are totaly dead.
 * @return the current total maximum deaths
 * @param i the amount of deaths to adjust by, must be +ve
 */
int adjust_max_deaths(int i)
{
   if (i > 0) {
      return (max_deaths += i);
   }
}

/**
 * @ignore yes
 */
varargs int move(mixed dest,
                 string msgin,
                 string msgout)
{
   int i;
   object env = environment();

   i = living::move(dest, msgin, msgout);
   if (!i) {
      me_moveing(env);
   }
   return i;
}                               /* move() */

/**
 * @ignore yes
 */
nomask protected int do_refresh(string str) {
   if (query_property("guest")) {
      return notify_fail("Guests cannot refresh, sorry.\n");
   }
   if (!str || str != "totally") {
      return notify_fail("Please read the docs before using this command.\n");
   }
   write("%^BOLD%^WARNING!  This will restart your character.%^RESET%^\n\n" +
         "Are you sure you wish to refresh yourself totally? ");
   input_to("refresh_docs");
   return 1;
}

/**
 * @ignore yes
 */
protected int refresh_docs(string str) {
   string helpfile = "";
   str = lower_case(str);
   if (str[0] != 'y') {
      write("Ok, not refreshing.\n");
      return 1;
   }
   NROFF_HAND->create_nroff( "/doc/helpdir/refresh", helpfile );
   helpfile = NROFF_HAND->cat_file( helpfile );
   write ( helpfile[0..670] );
   write("\n\n%^BOLD%^Having read the documentation, are you still sure you "
         "wish to refresh totally?%^RESET%^\n");
   input_to("refresh3");
   return 1;
}

/**
 * @ignore yes
 */
protected int refresh2(string str, int noevent) {
   object ob;
   string group;

   str = lower_case(str);
   if (str[0] != 'n' && str[0] != 'y') {
      write
         ("Pardon?  I do not understand.  Do you want to refresh yourself? ");
      input_to("refresh2");
      return 1;
   }
   if (str[0] == 'n') {
      write("Ok, not refreshing.\n");
      return 1;
   }
   write("Doing refresh.\n");
   Str = 13;
   Con = 13;
   Int = 13;
   Wis = 13;
   Dex = 13;
   inttmp = dextmp = wistmp = strtmp = contmp = 0;
   race_ob = CONFIG_DEFAULT_RACE;
   if (guild_ob)
      catch(guild_ob->delete_member(query_name()));

   if (!noevent) {
      REFRESH_HANDLER->player_refreshed(this_object(), PARTIAL_REFRESH);
   }
   guild_ob = 0;
   set_al(0);
   if (query_deity()) {
#ifndef __DISTRIBUTION_LIB__
      catch(DEITY->delete_worshipper(query_deity(), query_name()));
      catch(DEITY->delete_priest(query_deity(), query_name()));
#endif
   }
   set_deity(0);
   set_skills(0);

   /* Remove them as a playtester. */
   PLAYTESTER_HAND->remove_playtester(query_name());

   //
   // If they have a family, remove them from that too.
   //
   if (query_family_name()) {
      CLUB_HANDLER->remove_member(query_family_name(), query_name());
      set_family_name(0);
   }

   reset_effects();
   reset_spells();
   reset_processes();
   setup_default_titles();
   guild_ob = 0;
   set_guild_data(0);
   xp = 0;
   deaths = 0;
   max_deaths = 7;
   _refresh_time = time();
   totaly_zap_bonus_cache();
   known_commands = ({ "skills", "rearrange", "gp", "newbie" });
   reset_starts();
   race_guild_commands();
   totaly_zap_stat_cache();
   drink_info = allocate(D_SIZEOF);
   map_prop = ([ "determinate" : "",
                 "player" : 1,
                 "skills version" :
                 (string) "/obj/handlers/change_skills"->query_version() ]);
   this_object()->remove_ghost();
   set_nationality(0);
   set_nationality_region(0);
   set_language("general");
   set_default_language("general");
   reset_all();

   group = this_player()->query_group();
   if (group) {
      GROUP->remove_member(group, this_player(), " refreshed themselves.");
   }

   set_last_pos(CONFIG_NEWBIE_START_LOCATION);
   START_PLAYER->give_junk(this_object());

   // Remove people from the hunting list.
   foreach (ob in query_attacker_list()) {
      catch(ob->stop_fight(this_object()));
      catch(stop_fight(ob));
   }
   
   call_out((: move_to_start_pos :), 0);

   if (!noevent) {
      write("Done refreshing.\n");
      say(cap_name + " refreshes " + query_objective() + "self.\n");
      save_me();
   }
   return 1;
}                               /* refresh2() */

/**
 * @ignore yes
 */
protected int refresh3(string str)
{
   object *items,
    *ritems,
     item;

   str = lower_case(str);
   if (str[0] != 'n' && str[0] != 'y') {
      write("Pardon?  I do not understand.  Do you want to refresh " +
            "yourself totally? ");
      input_to("refresh3");
      return 1;
   }
   if (str[0] == 'n') {
      write("Ok, not refreshing.\n");
      return 1;
   }
   write("Ok, refreshing totally.\n");
   ritems = filter(all_inventory(environment()),
                   (: $1->query_property("dropped") &&
                      $1->query_property("dropped")[0] == query_name() :));
   move(CONFIG_NEWBIE_START_LOCATION);
   refresh2("y", 1);
   set_player_killer(0);
   _pinfo->titles = ([ ]);
   REFRESH_HANDLER->player_refreshed(this_object(), TOTAL_REFRESH);
   "/secure/related_files"->delete_related_files(query_name(),
                                                 0, TOTAL_REFRESH);

   items = ritems + all_inventory();
   foreach(item in items) {
      item->dest_me();
   }

   foreach(item in children("/obj/corpse")) {
      if (item->query_owner() == this_object()->query_name()) {
        item->move("/room/rubbish");
      }
   }

   // Remove from clubs and families.
   foreach (string club in query_player_clubs()) {
      catch(CLUB_HANDLER->remove_member(club, this_player()->query_name()));
   }
   if (query_family_name()) {
      catch(CLUB_HANDLER->remove_member(query_family_name(),
                                  this_player()->query_name()));
      call_out("check_family_name", 2);
   }

   write("Done refreshing.\n");
   say(cap_name + " refreshes " + query_objective() + "self.\n");
   save_me();
   return 1;
}

/**
 * This method returns the one letter object type which is used in the
 * finger command to display the type of object.
 * @return the one letter object type
 */
string query_object_type(object player)
{
   if ("/obj/handlers/playtesters"->query_playtester(query_name())) {
      return "p";
   }
   return " ";
}                               /* query_object_type() */

/**
 * @ignore yes
 * Sets the cap name, part of a command..
 */
int do_cap(string str)
{
   if (!str)
      return notify_fail("Syntax: " + query_verb() + " <cap_name>\n");
   if (lower_case(str) != query_name())
      return
         notify_fail
         ("You must have the same letters in your capitalized name.\n");
   cap_name = str;
   write("Capitalized name set to " + cap_name + ".\n");
   return 1;
}                               /* do_cap() */

/** @ignore yes */
void set_my_ident(string str)
{
   return;
}

/** @ignore yes */
string query_my_ident()
{
   return 0;
}

/**
 * @ignore yes
 */
void event_enter(object thing,
                 string mess,
                 object from)
{
   events::event_enter(thing, mess, from);
   living::event_enter(thing, mess, from);
}                               /* event_enter() */

/**
 * @ignore yes
 */
void event_exit(object thing,
                string mess,
                object to)
{
   events::event_exit(thing, mess, to);
   living::event_exit(thing, mess, to);
}                               /* event_exit() */

/**
 * @ignore yes
 */
string *parse_command_id_list()
{
   if (query_player_killer()) {
      return ({ "killer" }) +
             living::parse_command_id_list() + family::parse_command_id_list();
   } else {
      return living::parse_command_id_list() + family::parse_command_id_list();
   }
}                               /* parse_command_id_list() */

/**
 * @ignore yes
 */
string *parse_command_plural_id_list()
{
   if (query_player_killer()) {
      return ({ "killers" }) + living::parse_command_plural_id_list() +
         family::parse_command_plural_id_list();
   } else {
      return living::parse_command_plural_id_list() +
         family::parse_command_plural_id_list();
   }
}                               /* parse_command_plural_id_list() */

/**
 * @ignore yes
 */
string *parse_command_adjectiv_id_list()
{
   return living::parse_command_adjectiv_id_list() +
         family::parse_command_adjectiv_id_list();
}                               /* parse_command_adjectiv_id_list() */

/**
 * This method returns the time at which the player last logged on.
 * @return the last logged on time
 */
int query_last_log_on()
{
   return last_log_on;
}

/* This is the time since the last refresh... */
/**
 * This method returns the time at which the player last refreshed.
 * @return the last refresh time
 */
int query_refresh_time()
{
   return _refresh_time;
}

/**
 * This method returns the number of times the player has logged onto
 * Discworld.
 * @return the number of logins
 */
int query_no_logins()
{
   return no_logins;
}                               /* query_no_logins() */

/**
 * This method returns if the object is a creator or not.
 * @return 1 if the object is a creator, 0 if not
 */
int query_creator()
{
   return 0;
}

/**
 * @ignore yes
 */
int _living(){return 1;}

/**
 * Used to set the invisibility level upon login.
 * @param level the invisiblity level
 */
protected void set_invis(int level) {
} /* set_invis() */

/**
 * This method checks to see if the person is a player killer or not.
 * @return 1 if they are a player killer, 0 if not
 */
int query_player_killer() {
   return _flags & PLAYER_KILLER_FLAG;
} /* query_player_killer() */

/**
 * This method sets the player killer flag on the player.
 * @param flag 1 for pker, 0 for not
 */
void set_player_killer(int flag) {
   if (flag) {
      _flags |= PLAYER_KILLER_FLAG;
   } else {
      _flags &= ~PLAYER_KILLER_FLAG;
   }
}

/**
 * This method puts the person into or out of role playing mode.
 * @param i 1 sets role playing mode, 0 unsets it.
 */
void set_role_playing(int i) {
  if(i) 
    add_property(RPMODE, 1);
  else
    remove_property(RPMODE);
}

/**
 * This method checks to see if the person is in role playing mode or not.
 * @return 1 if they are in role playing mode, 0 if not.
 */
int query_role_playing() {
  return query_property(RPMODE);
}
// --- END [/mnt/home2/grok/lib/global/player.c] ---
// --- BEGIN [/mnt/home2/grok/lib/global/handlers/more_string.c] ---
// Size:   File: "/mnt/home2/grok/lib/global/handlers/more_string.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627323   Available: 13574677
Inodes: Total: 5242880    Free: 4960133
9382 bytes, Last Modified:   File: "/mnt/home2/grok/lib/global/handlers/more_string.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627323   Available: 13574677
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:52.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker: pinkfish $
 * $Id: more_string.c,v 1.3 1999/05/08 00:57:17 presto Exp pinkfish $
 * 
 */
/**
 * This file will handle the real moreing of a string to the player.  The
 * player object will call out to this, so the all the code and the
 * variables are not stored in the player object.
 * @see /global/more_file.c
 *
 * @author Pinkfish
 */
#define COLS (int)this_object()->query_cols()
#define ROWS ( (int)this_object()->query_rows() - 1 )

/**
 * Information on the string being mored.
 * @element fsize the size of the file
 * @element topl the top line being displayed
 * @element botl the bottom line being display
 * @element last_search the last attempted search
 * @element the_bit the actual file itself
 * @element finish_func the function to call on finishing
 * @element more_bit the string to print at the bottom of the screen
 * @element stat_line the status line
 * @element finish_ob the finish object
 */
class more_string_info {
   int fsize;
   int topl;
   int botl;
   string last_search;
   string *the_bit;
   string finish_func;
   string more_bit;
   string stat_line;
   object finish_ob;
}

nosave mixed *_pending_more;
class more_string_info _current_info;

int internal_more_string();

void create() {
   add_command("Internal_More_String", "<string>", (:internal_more_string:));
} /* create() */

/**
 * @ignore yes
 */
void string_display_file(class more_string_info info) {
  int i;
  string stuff;

  info->botl = info->topl + ROWS;
  stuff = "";
  for ( i = info->topl; ( i < info->botl ) && ( i < info->fsize ); i++ ) {
    stuff += info->the_bit[ i ] +"\n";
  }
  efun::tell_object( this_object(), stuff );
} /* string_display_file() */

/**
 * @ignore yes
 */
void more_string_status_line(class more_string_info info) {
   string *frog;
   string s;
   int i;
   int percentage;

   if (!info->stat_line) {
      info->stat_line = "$N From $T to $B of $S ($%%) - h for help. ";
   }
   s = "";
   frog = explode(info->stat_line, "$");
   for (i=0;i<sizeof(frog);i++) {
      if (frog[i] == "") {
         s += "$";
         i ++;
      } else switch (frog[i][0]) {
         case 'N' :
            s += info->more_bit+frog[i][1..];
            break;
         case 'T' :
            s += ( info->topl + 1 ) + frog[ i ][ 1 .. ];
            break;
         case 'B' :
            if (info->botl > info->fsize)
               s += info->fsize+frog[i][1..];
            else
               s += info->botl+frog[i][1..];
            break;
         case '%' :
            percentage = (info->botl*100)/info->fsize;
            if (percentage > 100) {
               percentage = 100;
            }
            s += percentage + frog[i][1..];
            break;
         case 'S' :
            s += info->fsize + frog[i][1..];
            break;
      }
   }
   efun::tell_object( this_object(), (string)this_object()->fix_string( s ) );
   return;
} /* more_string_status_line() */

/**
 * @ignore yes
 */
void string_next_page(string str, class more_string_info info) {
   int num;
   int noargs;
   int i;
   int redraw;
   string s1;

   if (!str) {
     str = "";
   }

   if (sscanf(str,"%d%s", num, str) != 2) {
     noargs = 1;
   }
   s1 = str[1..];
   /* case statements WEEEEEE */
   if (str == "") {
      str = "f";
   }
   switch(str[0]) {
      case 'h' :
         cat("/doc/helpdir/more");
         break;
      case 'q' :
         if (info->finish_func) {
            if (functionp(info->finish_func)) {
               evaluate(info->finish_func);
            } else {
               call_other(info->finish_ob, info->finish_func);
            }
         }
         info->finish_func = 0;
         _current_info = 0;
         return;
      case 'f' :
      case 'F' :
         /* go on a number of pages... */
         info->topl += ROWS;
         redraw = 1;
         break;
      case 'b' :
      case 'B' :
         info->topl -= ROWS;
         redraw = 1;
         break;
      case '/' :
         /* sigh */
         i = info->topl + 4;
         if (!s1 || s1 == "") {
            s1 = info->last_search;
         }
         if (!s1 || s1 == "") {
            s1 = "bing!";
         }
         for (i = info->topl + 4; i < info->fsize; i++) {
            if (strsrch(info->the_bit[i], s1) != -1) {
               if (num-- <= 0) {
                  break;
               }
            }
         }
         if (i == info->fsize) {
            tell_object( this_object(), "Sorry "+ s1 +" not found.\n" );
         } else {
            tell_object( this_object(), "Found " + s1 + " on line "+ i +".\n");
            info->topl = i - 3;
         }
         redraw = 1;
         break;
      case '?' :
         if (!s1 || s1 == "") {
            s1 = info->last_search;
         }
         if (!s1 || s1 == "") {
            s1 = "bing!";
         }
         for (i = info->topl + 2; i > 0; i--) {
            if (strsrch(info->the_bit[i], s1) != -1) {
               if (num-- <= 0) {
                  break;
               }
            }
         }
         if (i == 0) {
            tell_object(this_object(), "Sorry " + s1 + " not found.\n");
         } else {
            info->topl = i - 3;
         }
         redraw = 1;
         break;
      case 'b' :
         if (info->topl > 0) {
            info->topl -= ROWS;
            redraw = 1;
            if (info->topl < 0) {
               info->topl = 0;
            }
         }
         break;
      case 'g' :
         info->topl = num;
         if (info->topl >= info->fsize)
            info->topl = info->fsize - 2;
         redraw = 1;
         break;
      case 'G' :
         redraw = 1;
         if (noargs)
            info->topl = info->fsize - ROWS;
         else
            info->topl = num;
         if (info->topl > info->fsize)
            info->topl = info->fsize - 2;
         break;
   }
   if (redraw) {
      string_display_file(info);
      if ( info->botl < info->fsize ) {
         more_string_status_line(info);
         input_to("string_next_page", 0, info);
      } else {
         if (info->finish_func) {
            if ( info->finish_ob ) { // sometimes screwed up:(
               call_other(info->finish_ob, info->finish_func);
            }
            info->finish_func = 0;
         }
         _current_info = 0;
      }
   } else {
      more_string_status_line(info);
      input_to("string_next_page", 0, info);
   }
} /* string_next_page() */

/**
 * Puts a long string through a more function.
 * @param text the text to place through the pager
 * @param bity the title of the text
 * @param noreline no idea...
 * @see /global/more_file.c->more_file()
 * @see set_finish_func()
 */
varargs int more_string( string text, string bity, int noreline ) {
  int i, ncols;
  string *bits;
  class more_string_info info;

  if ( this_player() != this_object() ){
     if ( !_pending_more ) {
        _pending_more = ({ ({ text, bity, noreline }) });
     } else {
        _pending_more += ({ ({ text, bity, noreline }) });
     }
     this_object()->ignore_from_history("Internal_More_String something");
     command( "Internal_More_String something" );
     return 1;
  }

  _current_info = info = new(class more_string_info);
  if ( bity ) {
    info->more_bit = bity;
  } else {
    info->more_bit = "--- MORE";
  }
  info->last_search = "";
  if ( !stringp( text ) || !strlen( text ) ) {
    return notify_fail( "Empty string.\n" );
  }
  if ( noreline ) {
    info->the_bit = explode( this_object()->fix_string( text ), "\n" );
  } else {
    info->the_bit = ({ });
    ncols = COLS;
    bits = explode( text, "\n" );
    for ( i = 0; i < sizeof( bits ); i++ ) {
      reset_eval_cost();
      if ( bits[ i ] == "" ) {
        info->the_bit += ({ "" });
      } else {
        info->the_bit +=
          explode( this_object()->fix_string( bits[ i ], ncols ), "\n" );
      }
    }
  }
  info->fsize = sizeof( info->the_bit );
  info->topl = 0;
  string_display_file(info);
  if ( info->botl < info->fsize ) {
    more_string_status_line(info);
    input_to( "string_next_page", 0, info );
  } else {
      if ( info->finish_func ) {
         if ( !info->finish_ob ) {
            //screwed up:
            info->finish_func = 0;
            return 1;
         }
         call_other( info->finish_ob, info->finish_func );
         info->finish_func = 0;
      }
      _current_info = 0;
  }
  return 1;
} /* more_string() */

/**
 * Sets the finish function.  This is called when the more_string
 * command exits.  If the ob is set to 0 then previous_object() is used
 * for it.  The str can be a function pointer as well.
 * @param str the function name or function pointer to use
 * @param ob the object to call it on (ignore for function pointers)
 * @see more_string()
 */
varargs void set_finish_func(string str, object ob) {
  _current_info->finish_func = str;
  if (!ob) {
    _current_info->finish_ob = previous_object();
  } else {
    _current_info->finish_ob = ob;
  }
} /* set_finish_func() */

/**
 * @ignore yes
 */
int internal_more_string() {
   string text, bity;
   int noreline;
   
   if ( sizeof( _pending_more ) ) {
      text = _pending_more[ 0 ][ 0 ];
      bity = _pending_more[ 0 ][ 1 ];
      noreline = _pending_more[ 0 ][ 2 ];
      _pending_more = _pending_more[ 1 .. <1 ];
      more_string( text, bity, noreline );
   }
   return 1;
} /* internal_more_string() */
// --- END [/mnt/home2/grok/lib/global/handlers/more_string.c] ---
// --- BEGIN [/mnt/home2/grok/lib/global/newbie_junk.c] ---
// Size:   File: "/mnt/home2/grok/lib/global/newbie_junk.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627321   Available: 13574675
Inodes: Total: 5242880    Free: 4960133
9747 bytes, Last Modified:   File: "/mnt/home2/grok/lib/global/newbie_junk.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627321   Available: 13574675
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:52.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: newbie_junk.c,v 1.18 2003/07/25 05:51:49 pinkfish Exp $
 */
/**
 * Handles the new player stuff and the login gifts.
 *
 * @see /global/player
 * @author Pinkfish
 */
#include <armoury.h>
#include <config.h>
#ifndef  __DISTRIBUTION_LIB__
#include <priest.h>
#endif

#define CABBAGE "/obj/monster/cabbage"
#define LEMON "/obj/monster/muffled_lemon"
#define STICK "/obj/misc/boring_stick"
#define CAT "/obj/monster/present_cat"
#define BUG "/obj/misc/bug"
#define BINKY_PATH "/obj/misc/binky/"
#define BINKY_TOY (BINKY_PATH "my_binky")
#define BINKY_BRUSH (BINKY_PATH "binky_brush")
#define BINKY_COMB (BINKY_PATH "binky_comb")
#define BINKY_KEY (BINKY_PATH "binky_key")

/**
 * This method is called when a player first starts on the mud.  It gives
 * out all of the newbiew equipment and stuff.
 */
void start_player(object pl) {
  object ob, bucket, bottle, drink, label;
  seteuid(getuid());


  bucket = ARMOURY->request_item( "bucket small", 100 );
  bucket->set_short( "champagne bucket" );
  bucket->set_long( "This metal bucket was designed for a purpose, "
    "and looks like it would fit a champagne bottle perfectly.\n" );
  bucket->add_adjective( "champagne", "wine" );
  bucket->add_alias( "cooler" );
  bucket->add_read_mess( this_player()->query_cap_name(), 
    "etched characters", "general" );
  bucket->move(this_player());
    
  bottle = clone_object( "/obj/bottle" );
  bottle->set_max_volume( 750 );
  bottle->set_name( "bottle" );
  bottle->set_short( "champagne bottle" );
  bottle->set_main_plural( "champagne bottles" );
  bottle->add_adjective( "champagne" );
  bottle->add_alias( "champagne" );
  bottle->set_long( "An expensive-looking bottle of champagne, just right "
               "to celebrate being on " + mud_name() + ".\n" );
  bottle->set_weight( 5 );
  bottle->set_max_weight( 20 );
  bottle->set_full_weight( 25 );
  bottle->set_volume( 750 );
  bottle->set_value( 400 );
  bottle->set_leak_rate( 0 );
  drink = clone_object("/obj/reagents/generic_liquid.ob");
  drink->set_name("champagne");
  drink->set_short("fine champagne");
  drink->set_long("This is a fine champagne, $amount_size$.\n");
  drink->set_medium_alias("Champagne");
  drink->add_eat_effect("/std/effects/ingested/drunk", 500);
  drink->set_amount(750);
  drink->move(bottle);
  label = clone_object("/obj/misc/label");
  label->add_read_mess( "\n    _________________  \n"
                          "   |                 | \n"
                          "   |                 | \n"
                          "   | Vintage Century | \n"
                          "   |      of the     | \n"
                          "   |    Fruit Bat,   | \n"
                          "   |   Year of the   | \n"
                          "   |  Midnight Frog  | \n"
                          "   |                 | \n"
                          "   |_________________| \n", 
                     "cursive lettering on the bottle's label", "general" );
  bottle->add_effect("/std/effects/object/label", label);             
  bottle->move( bucket );

  ob = clone_object("/obj/armour");
  ob->set_name("sash");
  ob->set_long("A large colourful sash.\n");
  ob->add_read_mess( "Welcome to " + mud_name() + ", "+
                     capitalize( (string)(pl->query_name()) ) +".", 0,
                     "general");
  ob->set_type( "sash" );
  ob->set_weight(3);
  ob->set_adjective(({ "large", "colourful" }));
  ob->setup_armour(1000);
  ob->set_damage_chance(10);
  if (ob->move(pl)) {
    if (ob->move(environment(pl)))
      ob->dest_me();
  }
  pl->wear_armour( ob );

  ob = ARMOURY->request_item( "torch" );
  ob->add_read_mess( "\n" + mud_name() + " MUD, it brightens up your night!  "
                     "More torches can be purchased from the general stores " 
                     "found across the Disc!", "to the wood", 
                     "general" );
  ob->move( pl );
    
  ob = clone_object( "/d/liaison/NEWBIE/newbie_book" );
  ob->move( pl );

  pl->adjust_money( 8, "Pumpkin dollar" );
  pl->adjust_money( 100, "Pumpkin pence" );
} /* start_player() */

void give_junk(object pl) {
  call_out("start_player", 2, pl);
}
/**
 * Gives out the login gifts and anything else that should be done on
 * a certain login number.
 *
 * @param num the number of logins
 */
void logged_on_times(int num) {
  object ob;
  int bing;

  this_player()->remove_property("binky level");
  switch (num) {
  case 3 :
    /* Third time, give them a free cabbage */
    ob = clone_object(CABBAGE);
    if(!environment(this_player()))
      return;
    ob->move(environment(this_player()));
    ob->set_owner(this_player());
    ob->init_command("follow "+this_player()->query_name());
    tell_object(this_player(),
                "%^YELLOW%^Congratulations on logging onto " + mud_name() + " for the "
                "third time.  Please accept this cabbage as a token of our "
                "appreciation.%^RESET%^\n");
    break;
  case 10 :
    /* Tenth time.  Give them a badge... */
    ob = clone_object("/obj/clothing");
    ob->set_name("badge");
    ob->set_type("badge");
    ob->set_short("fruitbat flavoured badge");
    ob->add_adjective(({ "fruitbat", "flavoured" }));
    ob->set_weight(1);
    ob->set_damage_chance(5);
    ob->setup_clothing(10000);
    ob->set_long("The badge is brightly fruitbat flavoured with a bit of "
                 "banana around the edges.  You are very proud to own it.\n");
    ob->add_read_mess("Congratulations on being a 10 time loginer to "
                      "" + mud_name() + " MUD!\n", 0,
                      this_player()->query_default_language());
    
    if (ob->move(this_player()))
      ob->move(environment(this_player()));
    tell_object(this_player(),
                "%^CYAN%^A little fruitbat flies down out of a small "
                "non-existent black hole and gives you a badge.  The "
                "fruitbat chirps excitedly at you in fruitbat and then "
                "leaps into your badge.%^RESET%^\n");
    break;
  case 42 :
    ob = clone_object("/obj/misc/paper");
    ob->add_read_mess("What do you get when you multiply 6 by nine.", 0,
                      this_player()->query_default_language());
    if (ob->move(this_player()))
      ob->move(environment(this_player()));
    tell_object(this_player(),
                "%^YELLOW%^This is your 42nd login.  You suddenly discover "
                "a piece of paper in your hand, something froths up in your "
                "mind and you just have to write it on the paper.\nAfterwards "
                "you stare blankly down at the paper not remembering what "
                "you just wrote.%^RESET%^\n");
    break;
  case 100 :
    /* 100th time...  A singing lemon, up to a point. */
    ob = clone_object(LEMON);
    ob->set_owner(this_player());
    tell_object(this_player(),
                "%^YELLOW%^Congratulations!  You have now logged onto "
                "" + mud_name() + " 100 times.  You are now officially addicted.  "
                "This lemon will help you on your travels.%^RESET%^\n");
    break;
  case 150 :
    /* 150th time. */
    ob = clone_object(STICK);
    if (ob->move(this_player()))
      ob->move(environment(this_player()));
    tell_object(this_player(),
                "%^YELLOW%^This is your 150th login!  Everybody here "
                "wishes you a good time, to help you in designs we have "
                "provided this stick for you.%^RESET%^\n");
    break;
  case 200 :
    ob = clone_object(CAT);
    ob->set_owner(this_player());
    tell_object(this_player(),
                "A cat slinks in from somewhere and rubs itself up "
                "against your leg.\n");
    ob->move(environment(this_player()));
    break;
  case 512 :
    ob = clone_object(BUG);
    tell_object(this_player(),
                "A strange black noise starts to slowly grow louder and "
                "louder.  Suddenly in a bunch of silvery wiggling a black "
                "bug crawls into your inventory.\n");
    ob->move(this_player());
    break;
  case 990 :
    ob = clone_object(BINKY_KEY);
    ob->move(this_player());
    tell_object(this_player(),
                "You hear a tinkling noise in the distance which slowly "
                "grows closer.  Something sparkly and shiny drops out of "
                "the sky into your hands.  It appears to be some sort of "
                "key.\n");
    break;
  case 1000 :
    ob = clone_object(BINKY_TOY);
    ob->move(environment(this_player()));
    tell_object(this_player(),
                "You feel a chill in your bones and turn around to see "
                "a large imposing figure wearing a black coat.  He smiles "
                "down at you in a way that makes your hair stand on end "
                "and places a small horse on the ground in front of "
                "you.\nDeath says: TREAT HIM WELL AND COMB HIM OFTEN.\n");
    break;
  case 1010 :
    ob = clone_object(BINKY_COMB);
    ob->move(this_player());
    tell_object(this_player(),
                "Something black and unseen taps you on the shoulder.\n"
                "Death says: I FORGOT THIS.\n"
                "Death gives you a small ivory comb.\n");
    break;
  case 1020 :
    ob = clone_object(BINKY_BRUSH);
    ob->move(this_player());
    tell_object(this_player(),
                "You feel a brush in your hands, you wonder where this "
                "came from?\n");
    break;
  }

  // See how long the player has been on.
  bing = -this_player()->query_time_on();
  if (bing / (24 * 60 * 60) > 100) {
    this_player()->add_player_title("old man");
    this_player()->add_player_title("old woman");
  }
} /* no_login_times() */
// --- END [/mnt/home2/grok/lib/global/newbie_junk.c] ---
// --- BEGIN [/mnt/home2/grok/lib/global/communicate.c] ---
// Size:   File: "/mnt/home2/grok/lib/global/communicate.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627318   Available: 13574672
Inodes: Total: 5242880    Free: 4960133
10592 bytes, Last Modified:   File: "/mnt/home2/grok/lib/global/communicate.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627318   Available: 13574672
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:52.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Id: communicate.c,v 1.28 2003/07/13 10:16:00 pinkfish Exp $
 */
/**
 * The communication handling code for the player object.  Controls all
 * the basic channels and basic communication stuff.
 * @author Pinkfish
 */
#include <drinks.h>
#include <library.h>
#include <player.h>
#include <language.h>

#define TELL_CMD "/cmds/player/t_ell"
#define REMOTE_CMD "/cmds/player/rem_ote"

class language_info {
   string cur_lang;
   int mangle_accent;
   string default_lang;
}

/*
 * Current & Max social points
 */
private int *_sp = ({0, 0});
private class language_info cur_lang;
private mixed *tell_reply_list = ({ 0, 0 });

private nosave object converse_ob;

string drunk_speech(string str);
string expand_nickname(string str);
private int converse(string);
private int do_write(string);
private int do_repeat(string);
string query_current_language();

void communicate_commands() {
  add_command("converse", "", (: converse(0) :));
  add_command("converse", "<string'person'>", (: converse($4[0]) :));
  add_command("frimble", "<string>", (: do_write($4[0]) :));
  add_command("repeat", "<string'command'>", (: do_repeat($4[0]) :));
}

int query_real_max_sp() {
  int ret;

  ret = sqrt(this_object()->query_time_on() / -15);

  if(ret < 50)
    return 50;
  if(ret > 500)
    return 500;
  return ret;
}

/**
 * This returns the maximum number of social points available.
 * @return the maximum social points
 */
int query_max_sp() { return _sp[1]; }

/**
 * This method adjusts the current maximum social points.
 * @param number the amount to adjust it by
 * @return the new maximum social points
 */
int adjust_max_sp( int number ) {
   _sp[1] += number;
   if ( _sp[1] < 0 )
      _sp[1] = 0;

   number = query_real_max_sp();

   if ( _sp[1] > number )
      _sp[1] = number;
   return _sp[1];
} /* adjust_max_sp() */

/**
 * This method sets the maximum social points.
 * @param number the maxmum social points
 * @return the new maximum social points
 */
int set_max_sp( int number ) { return adjust_max_sp( number - _sp[1] ); }

/**
 * This method returns the current social points.
 * @return the current social points
 */
int query_sp() { return _sp[0]; }

/**
 * This method changes the current number of social points
 * @param number the amount to change the social points by
 * @return the current social points
 */
int adjust_sp( int number ) {
  if (_sp[0] + number < 0)
    return -1;

  if (number < 0)
    adjust_max_sp(1);
  _sp[0] += number;
  if ( _sp[0] > _sp[1] )
    _sp[0] = _sp[1];
  return _sp[0];
}

/**
 * This method sets the current social points for the player
 * @param number the number of social points
 */
int set_sp( int number ) {
   return adjust_sp( number - _sp[0] );
} /* set_sp() */

void comm_event( mixed thing, string type, string start, string rest,
      string lang, string accent ) {
   if ( !objectp( thing ) && !pointerp( thing ) ) {
      return;
   }
   event( thing, type, start, rest, lang, accent );
   // Trickle the event down to our inventory too..
   // But not to us...
   call_other(all_inventory(), "event_" + type, this_object(),
              start, rest, lang, accent);
} /* comm_event() */

void comm_event_to(object ob, string event_type, string start, string type,
                   string words, object *others, string lang, object me,
                   string accent) {
  event(ob, event_type, start, type, words, others, lang, me, accent);
}

void do_whisper(object ob, string event_type, string start, string type,
                string words, object *others, string lang, object me,
                string accent) {
  event(ob, event_type, start, type, words, others, lang, me, accent);
}

private int do_write(string arg) {
  if (!arg || arg == "") {
    notify_fail("Syntax: "+query_verb()+" <string>\n");
    return 0;
  }
  write(sprintf("$I$0=%s\n", arg));
  this_player()->adjust_time_left(-DEFAULT_TIME);
  return 1;
} /* do_write() */

private int converse(string str) {
  if (!LANGUAGE_HAND->query_language_spoken(query_current_language())) {
    notify_fail(capitalize(query_current_language())+" is not a spoken language.\n");
    return 0;
  }
  if (str) {
    if (!LANGUAGE_HAND->query_language_distance(query_current_language())) {
      notify_fail(capitalize(query_current_language())+" is not able to spoken at a "+
                  "distance.\n");
      return 0;
    }
    str = lower_case(str);
    str = (string)this_object()->expand_nickname(str);
    converse_ob = find_player(str);
    if (!converse_ob)
      converse_ob = find_living(str);
    if (!converse_ob) {
      notify_fail("Syntax: converse [player]\n");
      return 0;
    }
    if (converse_ob == this_object()) {
      notify_fail("You have a nice conversation with yourself. Gee, what fun.\n");
      return 0;
    }
  }
  write("Give '**' to stop.\n");
  write("] ");
  input_to("do_converse");
  return 1;
} /* converse() */

void do_converse(string str) {
  if(str == "**") {
    write("Ok.\n");
    converse_ob = 0;
    return;
  }
  if(str)
    if (!converse_ob)
      "/cmds/living/sa_y"->cmd( str );
    else
      if ( function_exists( "trap_tell", environment() ) )
        environment()->trap_tell( str, converse_ob, 1 );
      else
        TELL_CMD->cmd( str, converse_ob, 1 );
  write("] ");
  input_to("do_converse");
} /* do_converse() */

/**
 * This method will add a language to a player/npc.  It is used to make sure
 * that a player or npc has a specific language.
 * @param lang the language to add
 */
void add_language(string lang) {
  int lvl;
  string skill;

  if (!LANGUAGE_HAND->test_language(lang))
    return ;

  if (LANGUAGE_HAND->query_language_spoken(lang)) {
    skill = LANGUAGE_HAND->query_language_spoken_skill(lang);
    lvl = this_object()->query_skill(skill);
    this_object()->add_skill_level(skill, 100 - lvl);
  }

  if (LANGUAGE_HAND->query_language_written(lang) ||
      LANGUAGE_HAND->query_language_magic(lang)) {
    skill = LANGUAGE_HAND->query_language_written_skill(lang);
    lvl = this_object()->query_skill(skill);
    this_object()->add_skill_level(skill, 100 - lvl);
  }
} /* add_language() */

private void fixup_lang_class() {
   mixed tmp;

   if (!classp(cur_lang)) {
      tmp = cur_lang;
      if (!tmp) {
         tmp = "common";
      }
      cur_lang = new(class language_info);
      cur_lang->cur_lang = tmp;
      cur_lang->default_lang = "common";
      cur_lang->mangle_accent = 1;
   }
}

/**
 * This method sets the language we are currently speaking.
 * @param str the language we are current speaking
 * @see query_current_language()
 */
int set_language(string str) {
  if (!LANGUAGE_HAND->test_language(str))
    return 0;
  fixup_lang_class();
  cur_lang->cur_lang = str;
  return 1;
} /* set_language() */

/**
 * This method returns the language the person is currently speaking.
 * @return the spoken language
 * @see set_language()
 */
string query_current_language() {
  fixup_lang_class();
  return cur_lang->cur_lang;
}

/**
 * This method sets the default language to use for the person.  The default
 * language is their native tongue, so things in this language show as
 * not being a special language.
 * @param def the default language
 */
void set_default_language(string def) {
  fixup_lang_class();
  cur_lang->default_lang = def;
}

/**
 * This method returns the default language to use for the person.
 * @return the default language
 */
string query_default_language() {
  fixup_lang_class();
  return cur_lang->default_lang;
}

/**
 * This method sets the mangle accents flag.  If this is set to 1 then the
 * accents will be mangled in the speech text, if it is set to 0 then
 * the accent will just be added to the say string instead.
 * @param flag the new value of the flag
 */
void set_mangle_accent(int flag) {
   fixup_lang_class();
   cur_lang->mangle_accent = flag;
}

/**
 * This method returns the mangle accents flag.  If this is set to 1 then the
 * accents will be mangled in the speech text, if it is set to 0 then
 * the accent will just be added to the say string instead.
 * @return the mangle accent flag
 */
int query_mangle_accent() {
   fixup_lang_class();
   return cur_lang->mangle_accent;
}

private int do_repeat(string str) {
  if (!str) {
    notify_fail("Syntax: repeat <cmd>\n");
    return 0;
  }
  input_to("do_wombat_repeat", 0, str);
  write("Enter the commands you wish to pass to "+str+".  '**' on a line "+
        "by itself to exit.\n");
  write("] ");
  return 1;
} /* do_repeat() */

protected int do_wombat_repeat(string str, string com) {
  if (str == "**") {
    return 0;
  }
  write("Doing '"+com+" "+str+"\n");
  command(com+" "+str);
  write("] ");
  input_to("do_wombat_repeat", 0, com);
  return 0;
} /* do_wombat_repeat() */

/**
 * This method returns the people in the array who this player is currently
 * ignoring.
 * @param people the people to check to see if they are being ignored
 * @return the people who are being ignored from the array
 * @see query_ignored_by()
 */
object *query_ignoring(object *people)  {
   string *ignore;
   object *fail = ({ });

   ignore = this_object()->query_property( "ignoring" );
   if ( ignore )  {
      fail = filter_array( people,
                (: member_array( $1 && $1->query_name(), $(ignore) ) > -1 :) );
   }
   return fail;
} /* query_ignoring() */

/**
 * This method returns the people in the array who are ignoring this
 * player.
 * @param people the people to check to see for ignoring
 * @return the array of people that are ignoring this player
 * @see query_ignoring()
 */
object *query_ignored_by(object *people) {
   return filter(people, (: sizeof($1->query_ignoring( ({ this_player() }) )) :));
} /* query_ignored_by() */

/**
 * This method sets the players tell reply list.
 *
 * @param list the reply list.
 * @param tim the timeout
 */
int set_tell_reply_list(mixed list) {
  if (base_name(previous_object())[0 .. strlen(TELL_CMD) - 1] != TELL_CMD &&
      base_name(previous_object())[0 .. strlen(REMOTE_CMD) - 1] != REMOTE_CMD  &&
     !previous_object()->query_lord())
    return 0;

  tell_reply_list = ({time() + (60 * 15), list });
  return 1;
}

/**
 * This method returns the players tell reply list.
 *
 * @return the tell reply list.
 */
mixed query_tell_reply_list() {
  if(base_name(previous_object())[0..strlen(TELL_CMD) - 1] != TELL_CMD &&
     base_name(previous_object())[0 .. strlen(REMOTE_CMD) - 1] != REMOTE_CMD  &&
     !previous_object()->query_lord())
    return 0;

  if(tell_reply_list[0] < time())
    return 0;

  return tell_reply_list[1];
}


// --- END [/mnt/home2/grok/lib/global/communicate.c] ---
// --- BEGIN [/mnt/home2/grok/lib/global/wiz_file_comm.c] ---
// Size:   File: "/mnt/home2/grok/lib/global/wiz_file_comm.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627315   Available: 13574669
Inodes: Total: 5242880    Free: 4960133
14265 bytes, Last Modified:   File: "/mnt/home2/grok/lib/global/wiz_file_comm.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627315   Available: 13574669
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:52.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: wiz_file_comm.c,v 1.34 2002/06/27 15:55:01 drakkos Exp $
 */
/**
 * This file contains all the file related commands and information
 * for the creators.
 * @author Pinkfish
 */
#include <creator.h>
#include <login_handler.h>
#include <ls.h>
#include <playtesters.h>
#include <player_handler.h>
#include <cmds/friends.h>

#ifdef USE_LE
inherit "/global/le";
#endif

inherit "/global/wiz_object_comm";
inherit "/global/playtester";
inherit "/global/wiz_info_comm";
inherit "/global/wiz_channels";
inherit "/global/wiz_inter_comm";

private int invis;
private string *allowed;
private nosave mixed _in_wiz_editor;
private nosave string *dir_list;
private nosave mixed last_location;

private int change_dir(string str);
private int pushd(string str);
private int popd();
protected int set_home_dir(string str);
private int visible();
private int invisible(string level);
private int allow(string word);
private int disallow(string word);

/* Stuck in to help with the auto load stuff change obvject */
void create() {
   playtester::create();
   wiz_object_comm::create();
   allowed = ({ });
} /* create() */

/**
 * This method adds in all the creator commands to the player.  This
 * will be called when the play initialy logs onto the game.
 */ 
protected void wiz_commands() {
   /* Get the commands from the inherited objects. */
   wiz_object_comm::wiz_commands();
   wiz_info_comm::wiz_commands();
   wiz_inter_comm::wiz_commands();
   wiz_channels::wiz_commands();
   
#ifdef USE_LE
   le::le_commands();
#endif
   
   /* Setup our local commands. */
   add_command("cd", this_object(), "<string'directory'>", (: change_dir($4[0]) :));
   add_command("cd", this_object(), "", (: change_dir(0) :));
   add_command("pushd", this_object(), "<string'directory'>", (: pushd($4[0]) :));
   add_command("pushd", this_object(), "", (: pushd(0) :));
   add_command("popd", this_object(), "", (: popd() :));
   add_command("homedir", this_object(), "<string'directory'>", (: set_home_dir($4[0]) :));
   add_command("visible", this_object(), "", (: visible() :));
   add_command("vis", this_object(), "", (: visible() :));
   add_command("invisible", this_object(), "{1|2|3}", (: invisible($4[0]) :));
   add_command("invis", this_object(), "", (: invisible("1") :));
   if (this_player()->query_director()) {
      add_command("invis", this_object(), "{1|2|3}", (: invisible($4[0]) :));
   }
   add_command("allow", this_object(), "<word'name'>", (: allow($4[0]) :));
   add_command("allow", this_object(), "", (: allow(0) :));
   add_command("disallow", this_object(), "<word'name'>", (: disallow($4[0]) :));
   add_command("disallow", this_object(), "all", (: disallow("all") :));
} /* wiz_commands() */

/**
 * This method returns the current invisibility level of the object.
 * This will return 0 if the object is not invisible, 1 for creator
 * invisible, 2 for director invisible and 3 for trustee invisible.
 * @return the current invisibility level
 */
nomask int query_invis() {
  return invis;
} /* query_invis() */

/** @ignore yes */
protected void set_invis(int level) {
   invis = level;
} /* set_invis() */

/**
 * This method returns the current list of people in the allowed array for
 * the creator.
 * @return the current list of allowed people
 */
nomask string *query_allowed() {
  return copy(allowed);
} /* query_allowed() */

/**
 * A bunch of stuff for allows to make it work with friends...
 * @ignore yes
 */
int is_friend(string str) {
   return ::is_friend(str) ||
          member_array(str, allowed) != -1;
} /* is_freiend() */

/** @ignore yes */
string query_friend_tag(string str) {
   string womble;

   if(!userp(previous_object())) {
     womble = ::query_friend_tag(str);
     if (!womble) {
       if (member_array(str, allowed) != -1) {
         return "allowed to reference";
       }
     }
     return womble;
   }
   return "";
} /* query_friend_tag() */

/** @ignore yes */
string* query_friends() {
   if (file_name(previous_object()) == FRIENDS_CMD) {
      return ::query_friends() | allowed;
   }

   return ({ });
} /* query_friends() */

/**
 * This method is called by the visible command to make the creator
 * become visible.
 * @return 1 on success
 */
private int visible() {
   if (GetForced()) {
      return 0;
   }
   if (!query_invis()) {
      return notify_fail("You are already visible.\n");
   }
   if (invis >= 2) {
      invis = 0;
      LOGIN_HANDLER->player_logon(this_player()->query_name());
   } else {
      invis = 0;
   }
   write("You appear.\n");
   return 1;
} /* visible() */

/**
 * This method is called by the invisible command to make the creator
 * turn invisible.
 * @return 1 on success, 0 on failure
 */
private int invisible( string word ) {
   int max, type;
   
   if (GetForced()) {
      return 0;
   }
   if (!word) {
      word = sprintf("%d", query_invis());
      if (word == "0") {
         word = "1";
      }
   }
   max = 1 + (int)master()->query_director(query_name()) +
      (int)master()->query_trustee(query_name());
   if (!sscanf(word, "%d", type) || (type > max) || (type < 1)) {
      return notify_fail("Syntax: invisible [1"+ ( max > 1 ? "|2" : "" ) +
                         ( max > 2 ? "|3" : "" ) + "]\n");
   }
   word = ({ "frog", "creator", "director", "trustee" })[type];
   if (type == query_invis()) {
      return notify_fail("You are already "+ word +" invisible.\n");
   }
   if (type < invis && type < 2 && invis >= 2) {
      invis = type;
      LOGIN_HANDLER->player_login(this_player()->query_name());
   } else {
      invis = type;
   }
   write("You become "+ word +" invisible.\n");
   return 1;
} /* invisible() */

/**
 * This method adds someone to the current allow list of the creator.
 * People on the allow list can see the creator while they are
 * invisible.
 * @param word the person to add to the allow string
 * @return 1 on success, 0 on failure
 */
private int allow(string word) {
    string player, mud; 

   if (!word) {
      if (!sizeof(allowed)) {
         write("You are not allowing anyone to refer to you.\n");
      } else {
         write("You are currently allowing "+
               query_multiple_short( map_array( sort_array(allowed, 0), 
                                                (: capitalize( $1 ) :))) +
               " to refer to you.\n" );
      }
      return 1;
   }
   word = lower_case(word);

   if ( word != "playtesters" && !PLAYER_HANDLER->test_user(word) && 
       sscanf( word, "%s@%s", player, mud ) != 2 ) {
      return notify_fail("There is no user called $C$"+ word +".\n");
   }

   if (member_array(word, allowed) != -1) {
      return notify_fail("You have already allowed $C$"+ word +
                         " to refer to you.\n");
   }
   allowed += ({ word });
   write(word +" is now allowed to refer to you.\n");
   return 1;
} /* allow() */

/**
 * This method removes someone from the current allow list of the
 * creator.  eople on the allow list can see the creator while they are
 * invisible.
 * @param word the person to remove to the allow string
 * @return 1 on success, 0 on failure
 */
private int disallow(string word) {
   if (!word) {
      return notify_fail("Disallow who?\n");
   }
   if (word == "all") {
     allowed = ({ });
     write("Cleared your allow list.\n");
   } else {
     word = lower_case(word);
     allowed -= ({ word });
     write(word +" is no longer allowed to refer to you.\n");
   }
   return 1;
} /* disallow() */

/**
 * This method returns the current visibility status of this creator
 * in respect to the other object.  This does the allow level checking
 * and all sorts of exciting things.
 * <p>
 * It will return 1 for creator invisible, 2 for director invisible, 3 for
 * trustee invisible.
 * @param thing the object to test the visibility against
 * @return 0 if not invisible, non-zero if invisible
 */
int query_visible(object thing) {
   string word;

   if (thing == this_object()) {
      return 1;
   }
   word = (string)thing->query_name();
   if (member_array(word, allowed) != -1) {
      return ::query_visible(thing);
   } else if((member_array("playtesters", allowed) != -1) &&
             PLAYTESTER_HAND->query_playtester(word)) {
     return ::query_visible(thing);
   }
   
   switch (query_invis()) {
   case 3 :
      return (int)master()->query_trustee(word);
   case 2 :
      return (int)master()->query_director(word);
   case 1 :
      return (int)thing->query_creator();
   default :
      return ::query_visible(thing);
   }
} /* query_visible() */

/**
 * This method returns the value of the in editor flag.
 * It will return non-zero if the player is in an editor.
 * @return non-zero in editor, 0 not in an editor
 * @see set_in_editor()
 */
mixed query_in_editor() {
   return _in_wiz_editor || ::query_in_editor();
} /* query_in_editor() */

/**
 * This method sets the current in editor flag.
 * @param what the new value of the in editor flag
 * @see query_in_editor()
 */
void set_in_editor(mixed what) {
   _in_wiz_editor = what;
} /* set_in_editor() */

/**
 * This method is called by the cd command and causes the
 * creator to change their current working directory.
 * @param str the new working directory
 * @return 1 on success, 0 on failure
 */
private int change_dir(string str) {
   string *filenames;
   object *obs;
   
   if (GetForced()) {
      return 0;
   }
   if (!str) {
      if (!query_home_dir()) {
         add_failed_mess(this_object(), 
                         "No homedir.  Use homedir to set it.\n", ({ }));
         return 0;
      }
      str = query_home_dir();
   }
   else { 
      if ( this_object()->query_property( LS_COMMAND_NICKNAME_PROPERTY ) ) {
         str = this_object()->expand_nickname( str );
      }
   } 

   filenames = get_files(str);
   if (sizeof(filenames) > 1) {
      add_failed_mess(this_object(),
                      "Ambiguous directory.\n", ({ }));
      return 0;
   }
   if (!sizeof(filenames)) {
      if (!sizeof(obs = WIZ_PRESENT->wiz_present(str, this_object()))) {
         add_failed_mess(this_object(),
                         "No such dir.\n", ({ }));
         return 0;
      }
      if (sizeof(obs) > 1) {
         add_failed_mess(this_object(),
                         "Ambiguous directory.\n", ({ }));
         return 0;
      }
      filenames =
         map(obs,
             (: sprintf("/%s",implode(explode(file_name($1), "/")[0..<2],
                                      "/")) :));
   }
   str = filenames[0];
   if (file_size(str) != -2) {
      printf("cd: %s: Not a directory.\n", str);
   } else {
      set_current_path(str);
   }
   printf("%s\n", query_current_path());
   return 1;
} /* change_dir() */

/**
 * This method is called by the pushd command.
 * @return 1 on success, 0 on failure
 * @param str the new working directory
 */
private int pushd(string str) {
   if (!dir_list) {
      dir_list = ({ });
   }
   dir_list += ({ query_current_path() });
   return change_dir(str);
} /* pushd() */

/**
 * This method is called by the popd command.
 * @return 1 on success, 0 on failure
 */
private int popd() {
   string dest;
  
   if (!sizeof(dir_list)) {
      return 0;
   }
   dest = dir_list[sizeof(dir_list)-1];
   dir_list = delete(dir_list, sizeof(dir_list)-1, 1);
   return change_dir(dest);
} /* popd() */

/**
 * This method returns the creators current working directory.
 * @return the current working directory
 */
string query_path() {
   return query_current_path();
} /* query_path() */

/**
 * This method sets the home directory of the player.  It is called
 * by the homedir command.
 * @param str the new home directory
 * @return 0 on failure and 1 on success
 */
private int set_home_dir(string str) {
   if (GetForced()) {
      return 0;
   }
   if (str) {
      ::set_home_dir(get_path(str));
   }
   printf("Home directory set to %s.\n", query_home_dir());
   return 1;
} /* set_home_dir() */

/**
 * This method returns the saved setup for the inbuild ed command.  THis
 * allows certain flag settings to be saved between sessions.
 * @return the current ed setup flags
 * @see set_ed_setup()
 */ 
int query_ed_setup() {
   return query_property("ed_setup");
} /* query_ed_setup() */

/**
 * This method sets the current flags for the inbuild ed command.  THis
 * allows certain flag settings to be saved between sessions.
 * @param i the new flags for the ed command
 * @see query_ed_setup()
 */
void set_ed_setup(int i) {
   add_property("ed_setup", i);
} /* set_ed_setup() */

/**
 * This method prints out any interesting bits of reviewable information
 * available on the creator.  This is used by the review command.
 * @return always returns 1
 */
int review() {
   playtester::review();
   wiz_info_comm::review();
   return 1;
} /* review() */

/**
 * This method stores the last location of the creator for use by goback.
 * @param string location
 */
void set_last_location(mixed loc) { last_location = loc; }

/**
 * This method returns the last location of the creator for use by goback.
 * @return string last location.
 */
mixed query_last_location() { return last_location; }

protected string process_input(string inp){
  int start;

  start = strsrch(inp, '@');
  if(start > 0){
    int space = strsrch(inp, ' ');
    if(!(space > 0 && ((space == start+1) || space < start))){
      inp = inp[0..start] + " " + inp[start+1..];
    }
  }
  start = strsrch(inp, '`');
  if(start > 0){
    int end;
    end = strsrch(inp, '`', -1);
    if(end != start){
      string lpc = inp[start+1..end-1];
      string err;
      mixed ret;
      ret = "/secure/cmds/creator/exe_c"->do_exec("return "+lpc, ref err);
      if(!err){
        if(intp(ret))
          ret = ""+ret;

        if(objectp(ret))
           ret = file_name(ret);

        if(arrayp(ret)){
          ret = filter(ret, (:stringp($1) || intp($1) || objectp($1):));
          ret = map(ret, (:intp($1)?""+$1:(objectp($1)?file_name($1):$1):));
          if(sizeof(ret))
            ret = implode(ret, ",");
        }

        if(stringp(ret)){
          inp = inp[0..start-1] + ret + inp[end+1..];
        }
      }
    }
  }
  return ::process_input(inp);
}

protected mixed command( string txt ) {
    return ::command( txt );
}
// --- END [/mnt/home2/grok/lib/global/wiz_file_comm.c] ---
// --- BEGIN [/mnt/home2/grok/lib/global/new_parse.c] ---
// Size:   File: "/mnt/home2/grok/lib/global/new_parse.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627312   Available: 13574666
Inodes: Total: 5242880    Free: 4960133
75763 bytes, Last Modified:   File: "/mnt/home2/grok/lib/global/new_parse.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627312   Available: 13574666
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:52.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*   -*- LPC -*-   */
/*
 * $Locker:  $
 * $Id: new_parse.c,v 1.81 2003/04/03 11:33:55 taffyd Exp $
 */
/**
 * This file contains all the code to support and run the text parsing
 * system used by discworld.   This is called 'add_command', please see
 * help on add_command for a more detailed listing.
 * @author Pinkfish
 */
#include <soul.h>
#include <creator.h>
#include <user_parser.h>
#include <command.h>
#include <obj_parser.h>
#include <function.h>

inherit "/global/command";

#define NEW_SOUL

#define MY_MESS_HEADER "#!"
#define OTHER_MESS_HEADER "!#"

class fail_mess_data {
    object* direct;
    object* indirect;
    int weight;
}

private nosave mapping _succ_mess;
private nosave mapping _fail_mess;
private nosave mapping _cur_objects;
private nosave object *_succ_indir;
private nosave object *_succ_mess_dir;
private nosave object *_succ_mess_indir;
private nosave mapping _commands;
private nosave string *_failed_mess;
private nosave string _curpat;

int *pattern_match(string *bits, mixed *pattern);
private int handle_command(string *bits, int *matches, mixed *pattern,
                            mixed *command, string pattern_str);
string get_fail_messages(string verb, object *fail_obs);
void print_special_messages(string verb);
string *query_word_list(string bing);
private void remove_object2(object ob, int flag);
private void remove_object_force(object ob);
varargs string create_message(string *bits, int *matches, mixed *pattern,
                                             object *dir_obs, int flag);
int syntax_messages(string str);
string query_name();

void create() {
   _commands = ([ ]);
   _fail_mess = ([ ]);
   _succ_mess = ([ ]);
   _cur_objects = ([ ]);
   _succ_indir = _succ_mess_dir = _succ_mess_indir = ({ });
   command::create();
} /* create() */

/**
 * This method returns the current internal set of commands.
 * <p>
 * ([ "command_name" :<br>
 * ({ ({ pattern_weight, pattern_str, nn, object, function }) })<br>
 * ])
 * @return the current commands list
 * @see query_p_objects()
 */
mapping query_p_commands() { return copy( _commands ); }
/**
 * This method returns the current mapping between objects and commands.<br>
 * ([ object : ({ "cmd1", "cmd2", ... }), ... ])
 * <p>
 * This mapping is used when the object leaves the environment to make
 * the command updating more efficent.
 * @return the current object/command mapping
 * @see query_p_commands()
 */
mapping query_p_objects() { return copy( _cur_objects ); }

/**
 * This method returns the information associated with the specific
 * command.  This should only be used for debug.
 * @param name the command name to return info on
 * @return the information associated with the command
 */
mixed *query_parse_command(string name) { return _commands[name]; }

/**
 * This method returns the objects associated with the parse command.
 * @param name the command name to return the objects for
 * @return the objects associated with the command
 */
object* query_parse_command_objects(string name) {
   class command_class command;
   class command_data command_data;
   string pattern;
   object* obs;

   command = _commands[name];
   obs = ({ });
   if (command) {
      foreach (pattern, command_data in command->patterns) {
         obs += filter(command_data->calls, (: objectp($1) :));
      }
   }
   return obs;
} /* query_parse_command_objects() */

/**
 * This method returns all the indirect objects used in the success
 * messages.
 * @return the success message
 */
object* query_succ_mess_indir() {
    return _succ_mess_indir;
} /* query_succ_mess_indir() */

/** @ignore yes */
void parser_commands() {
#if efun_defined(add_action)
   add_action("new_parser", "*", -2);
#endif
   add_command("syntax", "<word'verb'>", (:syntax_messages($4[0]):));
} /* parser_commands() */

/**
 * This is called by the object the command is being passed on to find
 * whether or not it succeeded on the objects it was passed... and which
 * ones. This can be passed an object.. or an array of objects.
 * Share and enjoy.
 */
int add_succeeded(mixed ob) {
   int i;

   if (!pointerp(_succ_indir)) _succ_indir = ({ });
   if (objectp(ob)) {
      if (member_array(ob, _succ_indir) == -1) {
         _succ_indir += ({ ob });
      } else {
         return 1;
      }
   } else if (!pointerp(ob)) {
      return 0;
   } else for (i=0;i<sizeof(ob);i++) {
      if (member_array(ob[i], _succ_indir) == -1) {
         _succ_indir += ({ ob[i] });
      }
   }
   return 1;
} /* add_succeeded() */

/* Mess can also be an array, containing two elements. */
int add_succeeded_mess(object dir, mixed incoming_mess, object *in_dir) {
   string my_mess, other_mess;

   if (!pointerp(incoming_mess)) {
      if (stringp(incoming_mess)) {
         my_mess = MY_MESS_HEADER+incoming_mess;
         other_mess = OTHER_MESS_HEADER+incoming_mess;
      } else {
         write("Parameter to add_succeeded_mess() must be a string or "
                  "array.\n");
         return 0;
      }
   } else if (sizeof(incoming_mess) == 2) {
      my_mess = MY_MESS_HEADER+incoming_mess[0];
      other_mess = OTHER_MESS_HEADER+incoming_mess[1];
   } else {
      write("Message array to add_succeeded_mess() must be two long.\n");
      return 0;
   }

   if ( undefinedp( in_dir ) ) {
       in_dir = ({ });
   }

   if (!_succ_mess[my_mess]) {
      _succ_mess[my_mess] = ({ ({ dir }), in_dir });
   } else {
      if (member_array(dir, _succ_mess[my_mess][0]) == -1) {
         _succ_mess[my_mess][0] += ({ dir });
      }
      in_dir = in_dir - _succ_mess[my_mess][1];
      _succ_mess[my_mess][1] += in_dir;
   }

   if (!_succ_mess[other_mess]) {
      _succ_mess[other_mess] = ({ ({ dir }), in_dir });
   } else {
      if (member_array(dir, _succ_mess[other_mess][0]) == -1) {
         _succ_mess[other_mess][0] += ({ dir });
      }
      in_dir = in_dir - _succ_mess[other_mess][1];
      _succ_mess[other_mess][1] += in_dir;
   }
   if (member_array(dir, _succ_mess_dir) == -1) {
      _succ_mess_dir += ({ dir });
   }
   return 1;
} /* add_succeeded_mess() */

void add_failed_mess( object dir, string mess, mixed *in_dir ) {
   int i;
   class fail_mess_data fail;

   if (!stringp(mess)) {
      write("Parameter to add_failed_mess() must be a string.\n");
      return;
   }

   if ( undefinedp( in_dir ) ) {
      in_dir = ({ });
   }
   if (!_fail_mess[mess]) {
      fail = new(class fail_mess_data);
      fail->direct = ({ dir });
      fail->indirect = in_dir;
      _fail_mess[mess] = fail;
   } else {
      if (member_array(dir, _fail_mess[mess]->direct) == -1) {
         _fail_mess[mess]->direct += ({ dir });
      }
      for (i=0;i<sizeof(in_dir);i++) {
         if (member_array(in_dir[i], _fail_mess[mess]->indirect) == -1) {
            _fail_mess[mess]->indirect += in_dir[i..i];
         }
      }
   }
   if (member_array(dir, _succ_mess_indir) == -1) {
      _succ_mess_indir += ({ dir });
   }
} /* add_failed_mess() */

/**
 * This method returns the objects which have success messages already
 * attached for.   This allows you to determine which objects already hace
 * a success message available.   This array is added to by both the
 * add_succeeded_mess and add_failed_mess methods, it disable the
 * autogeneration of these messages.
 * @return the succeeded message objects
 * @see add_succeeded_mess()
 * @see add_failed_mess()
 */
object *query_succ_mess_dir() {
    return _succ_mess_dir;
} /* query_succ_mess_dir() */

/**
 * This method checks to see if the given object has already added a failed
 * message yet or not.   This is checking for a direct object, not an 
 * indirect object.
 * @param dir the object adding the failed message
 * @return 0 if not found, 1 if found
 * @see add_failed_mess()
 */
int query_failed_message_exists(object dir) {
    string mess;
    class fail_mess_data stuff;

    foreach (mess, stuff in _fail_mess) {
         if (member_array(dir, stuff->direct) != -1) {
             return 1;
         }
    }
    return 0;
} /* query_failed_message_exists() */

/**
 * The id is a useful thingy so that things can remember which pattern was 
 * parsed.
 */
varargs int add_command(string cmd, object ob, mixed format, function funct) {
   int i;
   int idx;
   class command_class command;
   class command_data command_data;

   if ((funct && !functionp(funct)) || !objectp(ob)) {
      return 0;
   }

   if (!format) {
      format = "<direct:object>";
   } else if (pointerp(format)) {
      for (i = 0; i < sizeof(format); i++) {
         add_command(cmd, ob, format[i], funct);
      }
      return 1;
   } else if (!stringp(format)) {
      return 0;
   }
   command = _commands[cmd];
   if (!command) {
      command = new(class command_class);
      command->patterns = ([ ]);
      command->order = 0;
      _commands[cmd] = command;
   }
   command_data = command->patterns[format];
   if (command_data) {
      /* Its already in there...   Easy. */
      /* Let's check whether the object is already in there. It shouldn't
          be, but it doesn't hurt :-) */
      idx = member_array(ob, command_data->calls);
      if (idx != -1) {
         command_data->calls[idx + 1] = funct;
      } else {
         command_data->calls += ({ ob, funct });
      }
   } else {
      /*
       * Now. We need to use the weight information to place the
       * pattern into the array.
       */
      command_data = new(class command_data);
      command_data->calls = ({ ob, funct });
      command->order = 0;
      command->patterns[format] = command_data;
   }

   if (_cur_objects[ob]) {
      _cur_objects[ob] |= ({ cmd });
   } else {
      _cur_objects[ob] = ({ cmd });
   }
   return 1;
} /* add_command() */


/*
 * This is the bit that handles object leaving the environment of the
 * player.
 */
int remove_object(mixed ob, int was_env) {
   if (objectp(ob) && !_cur_objects[ob] && !was_env) {
      return 0;
   }
   /* called out for umm, eval reasons. */
   /* Hm... This doesn't really work... */
   remove_object2(ob, was_env);
   return 1;
} /* remove_object() */

/**
 * This method does all the horrible work of removing objects and being
 * evil.
 * The bit that does all the horrible work...
 * We check in here to make sure we havent come back to the same spot.
 * This is so we don't go round deleteing things we shouldn't.
 */
private void remove_object2(object ob, int was_env) {
   object womble;
   object *inv_match;

   /*
    * Either we are in the same room, or the object exists in our inventory
    * or in the inventory of the room we are in...
    */
   if (!ob ||
       (!was_env && (environment() == ob ||
                     environment(ob) == this_object() ||
                     environment(ob) == environment()))) {
      return ;
   }
   if (was_env == 1) {
      remove_object_force(ob);

      inv_match = ob->find_inv_match();

//    This is because not every object supports find_inv_match.
//    Especially teh big monies.
//    foreach (womble in ob->find_inv_match()) {
      if ( arrayp( inv_match ) ) {
        foreach (womble in inv_match) {
           if (objectp(womble) && womble != this_object() &&
               _cur_objects[womble]) {
              remove_object_force(womble);
           }
        }
      }
      return ;
   }
   return ;
} /* remove_object2() */

/**
 * This method will remove a lost object and all zeroed objects for a
 * specific command.
 */
private void remove_from_command(string cmd, object ob) {
   int k;
   string format;
   class command_data command_data;

   if (!_commands[cmd]) {
      return ;
   }
   foreach (format, command_data in _commands[cmd]->patterns) {
      for (k = 0; k < sizeof(command_data->calls); k += 2) {
         if (!command_data->calls[k] || command_data->calls[k] == ob) {
            command_data->calls = command_data->calls[0..k - 1] + command_data->calls[k + 2..];
         }
      }
      if (!sizeof(command_data->calls)) {
         map_delete(_commands[cmd]->patterns, format);
         if (_commands[cmd]->order) {
            _commands[cmd]->order -= ({ format });
         }
      }
   }
   if (!sizeof(_commands[cmd]->patterns)) {
      map_delete(_commands, cmd);
   }
} /* remove_from_command() */

/**
 * This will force the removal of the specified object from the array.
 */
private void remove_object_force(object ob) {
   string ind;

   /* Check to see if our illustious object exists or not. */
   if (!_cur_objects[ob]) {
      return 0;
   }
   foreach (ind in _cur_objects[ob]) {
      remove_from_command(ind, ob);
   }
   /* Delete the object from the object table */
   map_delete(_cur_objects, ob);
} /* remove_object2() */

/* The dest event :) */
/** @ignore yes */
void event_dest_me(object ob) {
   /*
    * Don't call this out as otherwise we end up with a 0 which may mess up
    * the mapping a bit.
    */
   remove_object_force(ob);
} /* event_dest_me() */

/*
 * Handle leaving.   Check to see if it is me leaving.   If it is, then
 * remove all the objects from the inventory.
 */
/** @ignore yes */
void event_exit(object ob, string mess, object dest) {
   if (dest == this_object() || dest == environment()) {
      return ;
   }
   remove_object_force(ob);
} /* event_exit() */

/** @ignore yes */
void me_moveing(object from) {
   /* Use this so as to get the hidden objects as well. */
   if (from) {
      remove_object(from, 1);
   }
} /* me_moveing() */

/**
 * This method does all the real work for add_command parsing.
 */
nomask int new_parser(string str) {
   string *bits;
   string pattern_str;
   string format;
   mixed *wombat;
   mixed *soul_stuff;
   mixed *pattern;
   mixed *command_stuff;
   mixed *stuff;
   int i;
   int j;
   int ret;
   int flag;
   class command_class command;
   class command_data command_data;

   /*
    * First explode the input string into words.   The first word is the
    * command.
    *
    * Test to see if it exists...
    */

   bits = explode(str, " ") - ({ "", 0 });
   command_stuff = cmdPatterns(bits[0]);
   if (this_object()->command_shadowed(bits[0], implode(bits[1..], " "))) {
      return 1;
   }
   command = _commands[bits[0]];
//printf("Cmd: %O %O\n", command, bits[0]);
#ifdef NEW_SOUL
   if (!command && !sizeof(command_stuff)) {
      soul_stuff = SOUL_OBJECT->query_soul_command(bits[0]);
      if (!soul_stuff) {
         return 0;
      }
   }
#else
   if (!_commands[bits[0]] && !sizeof(command_stuff)) {
      return 0;
   }
#endif
   /* Only the word... */
   _failed_mess = ({ "", "" });

  /*
   * This allows other code to find out what verb has been used,
   * since query_verb() will always return "" (verb is *).
  */
    current_verb = bits[ 0 ];

  /*
   * Ok, we have found a command.   There may be one or more commands
   * stored in this array.   Starting from the first one we check to
   * see if our pattern matches.
   */
   if (!soul_stuff) {
      if (command) {
         if (!command->order) {
            // Make sure all the weights are correct.
            foreach (pattern_str, command_data in command->patterns) {
               if (!command_data->weight) {
                  pattern =  PATTERN_OB->query_pattern(pattern_str);
                  if (pattern) {
                     command_data->weight = pattern[0];
                  } else {
                     map_delete(command->patterns, pattern_str);
                  }
               }
            }
            command->order = sort_array(keys(command->patterns),
                                   (: ((class command_data)$3[$2])->weight -
                                      ((class command_data)$3[$1])->weight :),
                                   command->patterns);
         }
         format = command->order[0];
         command_data = command->patterns[format];
      } else {
         command = new(class command_class);
         command->order = ({ });
         command->patterns = ([ ]);
      }
//printf("Blue: %O %O\n", command, command_stuff);
      for (i = 0, j = 0; i < sizeof(command->order) ||
                         j < sizeof(command_stuff); ) {
         if (i < sizeof(command->order)) {
            format = command->order[i];
            command_data = command->patterns[format];
         } else {
            command_data = 0;
         }
         /*
          * Check both patterns groups to see which should go first.
          * It at the same level, the ones setup elsewhere should have
          * precedence
          */
//printf("Womble: %O %O\n", command_stuff, command_data);
         if (j < sizeof(command_stuff) &&
             (!command_data ||
              command_data->weight < command_stuff[j][PATTERN_WEIGHT])) {
            pattern_str = command_stuff[j][PATTERN_STRING];
            stuff = command_stuff[j++][OBJS..];
            flag = 1;
         } else {
            pattern_str = format;
            flag = 0;
            stuff = command_data->calls;
            i++;
         }
         pattern = PATTERN_OB->query_pattern(pattern_str);
         if (!pattern) {
            continue;
         }
         wombat = pattern_match(bits, pattern);
         //
         // If we match check for anything else that matches to see if we
         // should continue to womble.
         //
         if (wombat && (ret = handle_command(bits, wombat, pattern, stuff,
                                             pattern_str))) {
            if (ret == -1) {
               if (flag) {
                  j = 100;
               } else {
                  i = 100;
               }
            } else {
               return 1;
            }
         }
         if (wombat && !sizeof(wombat)) {
            int cont;
            string pat;
            mixed *junk;

            if (_curpat[<2] == '}' || _curpat[<2] == ']') {
               if (_curpat[<2] == '}') {
                  _curpat = _curpat[0..strsrch(_curpat, '{', -1)-2];
               } else {
                  _curpat = _curpat[0..strsrch(_curpat, '[', -1)-2];
               }
            } else {
               _curpat = implode((explode(_curpat, " ") - ({0,""}))[0..<2], " ");
            }
            if (flag) {
               foreach (junk in command_stuff[j..]) {
                  pat = junk[PATTERN_STRING];
                  pat = replace(pat, ({":object", "", ":living", "",
                                                 ":any-living", "", ":distant-living", "",
                                                 ":here", "", ":me>", ">", ":here-me", "",
                                                 ":me-here", "" }));
                  if (_curpat == pat) {
                     cont = 1;
                     break;
                  }
               }
               if (!cont) {
                  j = 100;
               }
            } else {
               foreach (pat in command->order[i..]) {
                  pat = junk[PATTERN_STRING];
                  pat = replace(pat, ({":object", "", ":living", "",
                                                 ":any-living", "", ":distant-living", "",
                                                 ":here", "", ":me>", ">", ":here-me", "",
                                                 ":me-here", "" }));
                  if (_curpat == pat) {
                     cont = 1;
                     break;
                  }
               }
               if (!cont) {
                  i = 100;
               }
            }
         }
      }
   }

#ifdef NEW_SOUL
   // Only check for soul commands if we return 0. 
   if ( !ret ) { 
      if (!soul_stuff) {
         soul_stuff = SOUL_OBJECT->query_soul_command(bits[0]);
      }

      for (i=0;i<sizeof(soul_stuff);i++) {
         pattern = PATTERN_OB->query_pattern(soul_stuff[i][PATTERN_STRING]);
         wombat = pattern_match(bits, pattern);
         if (wombat && handle_command(bits, wombat, pattern, soul_stuff[i][OBJS..],
                                      soul_stuff[i][PATTERN_STRING])) {
            return 1;
         }
      }
   }
#endif
/* This will construct useful error messages. */
   if (_failed_mess[1] == "") {
      if (!query_notify_fail()) {
         if (_failed_mess[0] == "") {
            notify_fail( "See \"syntax "+ bits[ 0 ] +
                  "\" for the input patterns.\n");
         } else {
            notify_fail( _failed_mess[0] );
         }
      }
   } else {
      notify_fail(_failed_mess[1]);
   }
   _fail_mess = ([ ]);
   return 0;
} /* new_parser() */

int syntax_messages(string str) {
   string the_mess;
   int i;
   string tmp;
   class command_data fluff;
   mixed *soul_stuff;
   mixed *command_stuff;

   if (!str) {
      notify_fail("Syntax: syntax <verb>\n");
      return 0;
   }
   command_stuff = cmdPatterns(str);
#ifdef NEW_SOUL
   soul_stuff = SOUL_OBJECT->query_soul_command(str);
   if (!_commands[str] && !soul_stuff && !sizeof(command_stuff)) {
      notify_fail("Could not find the verb '"+str+"'.\n");
      return 0;
   }
#else
   if (!_commands[str] && !sizeof(command_stuff)) {
      notify_fail("Could not find the verb '"+str+"'.\n");
      return 0;
   }
#endif

   the_mess = "Forms of syntax available for the command \""+ str +"\":\n";
   if (_commands[str]) {
      foreach (tmp, fluff in _commands[str]->patterns) {
         the_mess += str+" "+PATTERN_OB->query_short_pattern(tmp) + "\n";
      }
   }
   for (i=0;i<sizeof(command_stuff);i++) {
       the_mess += str+" "+PATTERN_OB->query_short_pattern(
                                        command_stuff[i][PATTERN_STRING]) + "\n";
   }
   for (i=0;i<sizeof(soul_stuff);i++) {
       the_mess += str+" "+PATTERN_OB->query_short_pattern(
                                        soul_stuff[i][PATTERN_STRING]) + "\n";
   }
   write(the_mess);
   return 1;
} /* syntax_messages() */

int *pattern_match(string *bits, mixed *pattern) {
   string *elms;
   int pos, *delayed, last, failed, j, opt, i, word_offset, spaces, wcount,
      *matches;
   mixed tmp;

   /*
    * Ok, we need to check to see if the nice pattern we have in
    * comm exists somewhere in bits.
    */
   pos = wcount = 1;
   _curpat = "";
   matches = ({ 0 });
   delayed = ({ });
   for (i = 1; i < sizeof(pattern) && !failed; i++) {
      /* Ok, check matching rules. */
      if (pos >= sizeof(bits))
         failed = 1;
      /* else */
      _curpat += PATTERN[pattern[i]];
      switch (pattern[i]) {
         case DIRECT_OBJECT :
         case INDIRECT_OBJECT :
            i++; /* Move to the type marker. */
            if (pattern[i] == TARGET_PLAYER) {
               if (last) {
                  delayed += ({ SINGLE_WORD });
                  word_offset++;
                  pos++; /* Push the search position forward one. 
                                 It needs to be there at least */
               } else {
                  pos++;
                  matches += ({ pos - 1 });
               }
               failed |= pos > sizeof(bits);
            } else {
               /*
                * We don't know where this one ends, so we don't put a match onto the
                * thingy.
                */
               if (last) {
                  delayed += ({ SINGLE_WORD });
               } else {
                  delayed = ({ STRING });
                  last = FIND_FIRST;
               }
               word_offset++;
               pos++; /* All strings must be at least 1 word long */
            }
            i++; /* Skip the environment marker */
            break;
         case STRING :
            /* This here delayed should not exist! */
            if (last) {
               pos -= word_offset-1;
               for (j=0;j<sizeof(delayed);j++) {
                  switch (delayed[j]) {
                     case STRING :
                        matches += ({ pos - 1 });
                        pos++;
                        break;
                     case OPTIONAL :
                        matches += ({ matches[<1] });
                        break;
                     case SINGLE_WORD :
                        matches += ({ pos - 1 });
                        pos++;
                        break;
                  }
               }
            }
            delayed = ({ STRING });
            word_offset = 1;
            pos++; /* Strings should be at least one word long */
            last = FIND_LAST;
            break;
         case QUOTED_STRING :
            if (last) {
                while (pos < sizeof(bits) &&
                           bits[pos][0] != '"' &&
                           bits[pos][0] != '\'' &&
                           bits[pos][0] != '`') {
                     pos++;
                }
                if (pos < sizeof(bits)) {
                     pos -= word_offset;
                     for (j = 0; j < sizeof(delayed); j++) {
                         switch (delayed[j]) {
                              case STRING :
                                  matches += ({ pos });
                                  pos++;
                                  break;
                              case OPTIONAL :
                                  matches += ({ matches[<1] });
                                  break;
                              case SINGLE_WORD :
                                  matches += ({ pos });
                                  pos++;
                                  break;
                         }
                     }
                     last = FIND_NONE;
                } else {
                     failed = 1;
                }
            }
            if (pos > sizeof(bits)) {
                failed = 1;
            }
            if (!failed) {
                switch (bits[pos][0]) {
                     case '"' :
                     case '\'' :
                     case '`' :
                         /* Ok.   See if we can find the end... */
                         j = pos;
                         while (j < sizeof(bits) &&
                                    bits[j][<1] != bits[pos][0]) {
                              j++;
                         }
                         if (j < sizeof(bits)) {
                              matches += ({ j });
                              pos = j + 1;
                         } else {
                              failed = 1;
                         }
                         break;
                     default :
                         failed = 1;
                         break;
                }
            }
            break;
         case SHORT_STRING :
            if (last) {
               delayed += ({ SINGLE_WORD });
            } else {
               delayed = ({ STRING });
            }
            word_offset++;
            pos++; /* Strings have to be at least one word */
            last = FIND_FIRST;
            break;
         case SINGLE_WORD :
            /* The last bit carrys through here too */
            if (last) {
               /* Some sort of delay */
               /*
                * Hmm, need to keep track of the delayed and single_word status of 
                * each bit we push 
                */
               delayed += ({ SINGLE_WORD });
               word_offset++;
               pos++; /* Push the search position forward one.   It needs to be there 
                              at least */
            } else {
               /*
                * Means the word we are pointing at must be the one we want.
                * Womble!
                */
               matches += ({ pos });
               pos++;
            }
            failed |= pos > sizeof(bits);
            break;
         case NUMBER :
         case FRACTION :
            failed = 1;
            if (last == FIND_LAST) {
               for (j = sizeof(bits) - 1; j >= pos; j--)
                  if ((bits[j][0] >= '0' && bits[j][0] <= '9') ||
                        (pattern[i] != FRACTION && bits[j][0] == '-' &&
                         bits[j][1] >= '0' && bits[j][1] <= '9')) {
                     /* Found number! */          
                     if (pattern[i] != FRACTION || sizeof(explode(bits[j], "/")) > 1) {
                        failed = 0;
                        /* We always point to the next match. */
                        pos = j + 1;
                        break;
                     }
                  }
            } else if (last == FIND_FIRST) {
               for (j = pos; j < sizeof(bits); j++)
                  if ((bits[j][0] >= '0' && bits[j][0] <= '9') ||
                        (pattern[i] != FRACTION && bits[j][0] == '-' &&
                         bits[j][1] >= '0' && bits[j][1] <= '9')) {
                     /* Found number! */          
                     if (pattern[i] != FRACTION || sizeof(explode(bits[j], "/")) > 1) {
                        failed = 0;
                        /* We always point to the next match. */
                        pos = j + 1;
                        break;
                     }
                  }
            } else {
               if (pos < sizeof(bits) &&
                     ((bits[pos][0] >= '0' && bits[pos][0] <= '9') ||
                        (pattern[i] != FRACTION && bits[pos][0] == '-' &&
                         bits[pos][1] >= '0' && bits[pos][1] <= '9'))) {
                  failed = 0;
                  pos++;
               } else {
                  failed = 1;
               }
            }
            if (!failed) {
               if (sizeof(delayed)) {
                  pos -= word_offset; /* Amount which is needed at least to handle the
                                                    pattern */
                  for (j=0;j<sizeof(delayed);j++) {
                     switch (delayed[j]) {
                        case STRING :
                           matches += ({ pos - 1 });
                           pos++;
                           break;
                        case OPTIONAL :
                           matches += ({ matches[<1] });
                           break;
                        case SINGLE_WORD :
                           matches += ({ pos - 1 });
                           pos++;
                           break;
                     }
                  }
                  delayed = ({ });
                  word_offset = 0;
               }
               last = FIND_NONE;
               matches += ({ pos - 1 });
            }
            break;
         case OPTIONAL_SPACES :
         case OPTIONAL :
         case WORD_LIST_SPACES :
            switch (pattern[i]) {
               case OPTIONAL_SPACES :
                  spaces = opt = 1;
                  break;
               case OPTIONAL:
                  opt = 1;
                  break;
               case WORD_LIST_SPACES :
                  spaces = 1;
                  break;
            }
         case WORD_LIST :
            /* Find word list. The next element is the list name */
            /*
             * How do we find a list?   Big question?
             *
             * Currently thought of method.   Use the array subtraction
             * operation to find if there is any intersection.
             */
            /*
             * Method 2:
             * Use member_array a lot.
             */
            if (pointerp(pattern[++i])) {
               string *words;
   
               if (spaces) {
                  tmp = "";
   
                  foreach (words in pattern[i])
                     tmp += implode(words, " ") + "|";
                  tmp = tmp[0..<2];
               }
               _curpat += (sizeof(pattern[i]) > 1?"{":"");
               _curpat += (spaces ? tmp : implode(pattern[i], "|")) +
                  (opt?"] ":(sizeof(pattern[i]) > 1?"} ":" "));
               elms = pattern[i];
            } else {
               _curpat += pattern[i] + (opt?"] ":"} ");
               elms = (string *)master()->query_word_list(pattern[i]);
               if (!elms) {
                  /* Could be a local word list then? */
                  elms = query_word_list(pattern[i]);
               }
            } 
            if (!pointerp(elms) || !sizeof(elms))
               failed = 1;
            else {
               if (!(last || failed || spaces)) {
                  /* Means that the word we are pointing at must be one of em! */
                  tmp = member_array(bits[pos], elms);
                  if (tmp == -1) {
                     failed = 1;
                  }
               } else if (sizeof(elms) == 1 && last == FIND_FIRST && !spaces) {
                  /* Only one word.   Definately quicker to do a member_array */
                  tmp = member_array(elms[0], bits[pos..]);
                  if (tmp != -1) {
                     pos += tmp;
                  } else {
                     failed = 1;
                  }
               } else if (!spaces) {
                  tmp = bits[pos..] - elms;
                  if (sizeof(tmp) < sizeof(bits)-pos) {
                     /* Ok, one exists... */
                     if (last == FIND_FIRST) {
                        for (j = 0; (j+pos) < sizeof(bits) && j < sizeof(tmp) &&
                                  bits[j+pos] == tmp[j]; j++);
                        pos += j;
                     } else {
                        int k;
   
                        for (j = sizeof(tmp)-1, k = sizeof(bits)-1;
                               j >= 0 && bits[k] == tmp[j]; j--, k--);
                        pos = k;
                     }
                  } else {
                     failed = 1;
                  }
               } else {
                  string *elem;
                  int success;
   
                  foreach(elem in elms) {
                     if (!last) {
                        /* Means that the words we are pointing at must be one of em! */
                        if (implode(bits[pos..pos+sizeof(elem)-1], " ") ==
                              implode(elem, " ")) {
                           success = 1;
                           wcount = sizeof(elem);
                           break;
                        }
                        failed = 1;
                     } else {
                        tmp = bits[pos..] - elem;
                        if (sizeof(tmp) <= (sizeof(bits) - pos - sizeof(elem))) {
                           /* Okay, one exists... */
                           success = 1;
                           wcount = sizeof(elem);
                           if (last == FIND_FIRST) {
                              for (j = 0; (j+pos) < sizeof(bits) && j < sizeof(tmp) &&
                                        bits[j+pos] == tmp[j]; j++);
                              pos += j;
                              break;
                           } else {
                              int k;
   
                              for (j = sizeof(tmp)-1, k = sizeof(bits)-1;
                                     j >= 0 && bits[k] == tmp[j]; j--, k--);
                              pos = k - wcount + 1;
                              break;
                           }
                        } else {
                           failed = 1;
                        }
                     }
                  }
                  if (success) {
                     failed = 0;
                  }
               }
            }
            if (opt && failed) {
               failed = 0;
               if (!last)
                  matches += ({ pos - 1 }); // Keep the -1 for the optional stuff..?
               else {
                  delayed += ({ OPTIONAL });
                  opt = 0;
                  spaces = 0;
                  break;
               }
            } else {
               if (!failed) {
                   pos += wcount;
               }
               if (sizeof(delayed) && !failed) {
                  pos -= word_offset; /* Amount which is needed at least to handle the
                                                    pattern */
                  for (j=0;j<sizeof(delayed);j++) {
                     switch (delayed[j]) {
                        case STRING :
                           matches += ({ pos - 1 });
                           pos++;
                           break;
                        case OPTIONAL :
                           matches += ({ matches[<1] });
                           break;
                        case SINGLE_WORD :
                           matches += ({ pos - 1 });
                           pos++;
                           break;
                     }
                  }
                  delayed = ({ });
                  word_offset = 0;
               }
               /* Only matching one word... So the next item must be ours. */
               if (!failed) {
                  last = FIND_NONE;
                  //matches[0] = 1;
                  matches += ({ pos - 1 });
                  //pos += wcount;
               }
               wcount = 1;
               delayed = ({ });
            }
            opt = 0;
            spaces = 0;
            last = FIND_NONE;
            break;
      }
   }
   if (sizeof(delayed)) {
      /* Force to the end of the line... */
      if (/*sizeof(bits)-word_offset >= pos*/ 1) {
         pos = sizeof(bits) + 1;
         pos -= word_offset; /* Amount which is needed at least to handle the 
                                           pattern.   Last pos should be the end thingy. */
         for (j=0;j<sizeof(delayed);j++) {
            switch (delayed[j]) {
               case OPTIONAL :
                  matches += ({ matches[<1] });
                  break;
               case SINGLE_WORD :
               case STRING :
                  matches += ({ pos - 1 });
                  pos++;
                  break;
            }
         }
         delayed = ({ });
         word_offset = 0;
         pos = sizeof(bits);
      } else
         pos = -1;
   }
   matches += ({ sizeof(bits) });
   if (failed || pos != sizeof(bits)) {
//      if (matches[0] == 1)
//         return ({});
      return 0;
   }
   return matches + ({ sizeof(bits)+1 });
} /* pattern_match() */

int check_living(object ob) {
   return living(ob);
} /* check_living() */

int check_if_creator(object ob) {
   return (int)ob->query_creator() &&
      !(ob == this_player() || ob->query_invis());
} /* check_if_creator() */

int check_if_allowed(object ob) {
   return ob != this_player() && reference_allowed(ob);
} /* check_if_allowed() */

class obj_match my_find_match(string pattern, object *where, int type) {
    object ob;
    class obj_match omatch;

    where = copy(where);
    foreach (ob in where) {
         if (ob && (!ob->query_closed() ||
                        (ob->query_closed() && !ob->query_property("opaque")))) {
             if (ob->query_mirror_room()) {
                  where += ({ ob->query_mirror_room() });
             }
         } else {
             where -= ({ ob });
         }
    }
/*
    where = filter(copy(where), (: $1 && (!$1->query_closed() ||
                                                   ($1->query_closed() &&
                                                    !$1->query_property("opaque"))) :));
 */
    if (!sizeof(where)) {
         omatch = new(class obj_match);
         omatch->text = lower_case(pattern);
         omatch->objects = ({   });
         omatch->result = OBJ_PARSER_BAD_ENVIRONMENT;
         return omatch;
    }
    omatch = (class obj_match)match_objects_in_environments(pattern,
                                          where, type, this_object());
    if (omatch->result != OBJ_PARSER_SUCCESS) {
         ob = find_object(pattern);
         if (ob && member_array(environment(ob), where) != -1) {
             omatch->text = lower_case(pattern);
             omatch->objects = ({ ob });
             omatch->result = OBJ_PARSER_SUCCESS;
         }
    }
    return omatch;
} /* my_find_match() */

private class obj_match match_objects(int type, string pattern, object *env) {
   class obj_match omatch;
   class obj_match new_omatch;
   object* tmp;

   switch (type) {
   case WIZ_PRESENT_TARGET :
      omatch = new(class obj_match);
      omatch->text = pattern;
      omatch->objects = WIZ_PRESENT->wiz_present(pattern, env[0]);
      if (sizeof(omatch->objects)) {
          omatch->result = OBJ_PARSER_SUCCESS;
      } else {
          omatch->result = OBJ_PARSER_NO_MATCH;
      }
      break;
   case ANY_OBJECT :
      omatch = my_find_match(pattern, env, 0);
      break;
   case DISTANT_LIVING :
      omatch = new(class obj_match);
      omatch->text = pattern;
      if ( environment() && !this_object()->query_creator() ) {
         if ( environment()->query_property( "no remote" ) ) {
            omatch->objects = ({ });
            omatch->result = OBJ_PARSER_BAD_ENVIRONMENT;
            break;
         }
      }
      omatch->objects = filter(map(explode(lower_case(pattern), ","),
                  (: find_living( lower_case(this_object()->
            expand_nickname( $1 ))) :) ), (: $1 && check_if_allowed($1) :) );
      omatch->objects = uniq_array(omatch->objects);
      if (sizeof(omatch->objects)) {
          omatch->result = OBJ_PARSER_SUCCESS;
      } else {
          omatch->result = OBJ_PARSER_NO_MATCH;
      }
      break;
   case LIVING :
      omatch = my_find_match(pattern, env, OBJ_PARSER_TYPE_LIVING); 
      tmp = filter(omatch->objects, (: check_living( $1 ) :) ); 
      // See of any of them were not living...
      if (sizeof(omatch->objects) != sizeof(tmp)) {
          if (pattern != "all") {
               omatch->result = OBJ_PARSER_NOT_LIVING;
               omatch->objects -= tmp;
          } else {
               omatch->objects = tmp;
          }
      }
      break;
   case TARGET_PLAYER :
      omatch = new(class obj_match);
      omatch->text = pattern;
      if (environment() && !this_object()->query_creator()) {
         if (environment()->query_property("no remote")) {
            omatch->objects = ({ });
            omatch->result = OBJ_PARSER_BAD_ENVIRONMENT;
            break;
         }
      }

      omatch->objects = filter(map(explode(lower_case(pattern), ","),
                  (: find_player( lower_case(this_object()->
            expand_nickname( $1 ))) :) ), (: $1 && check_if_allowed($1) :) );
      omatch->objects = uniq_array(omatch->objects);

      if (!sizeof(omatch->objects)) {
         if (pattern == "creators" && this_object()->query_creator()) {
            omatch->objects = filter(users(), (: check_if_creator($1) :));
         }
         /*
         if (pattern == "someone") {
            omatch->objects = filter(users(), (: check_if_allowed($1) :));
            if (sizeof(omatch->objects) > 1) {
               omatch->objects = ({ omatch->objects[random(sizeof(omatch->objects))] });
            }
         }
         */
      }
      if (sizeof(omatch->objects)) {
          omatch->result = OBJ_PARSER_SUCCESS;
      } else {
          omatch->result = OBJ_PARSER_NO_MATCH;
      }
      break;
   case ANY_LIVING :
      new_omatch = new(class obj_match);
      new_omatch->text = pattern;
      if ( environment() && !this_object()->query_creator() ) {
         if ( environment()->query_property( "no remote" ) ) {
            new_omatch->objects = ({ });
            new_omatch->result = OBJ_PARSER_BAD_ENVIRONMENT;
            omatch = new_omatch;
         }
      }
      if (new_omatch->result != OBJ_PARSER_BAD_ENVIRONMENT) {
         new_omatch->objects = filter(map(explode(lower_case(pattern), ","),
                                     (: find_player( lower_case(this_object()->
            expand_nickname( $1 ))) :) ), (: $1 && check_if_allowed($1) :) );
         new_omatch->objects = uniq_array(new_omatch->objects);

         if(sizeof(new_omatch->objects)) {
            new_omatch->result = OBJ_PARSER_SUCCESS;
            omatch = new_omatch;
         }
      }
      if(!omatch || omatch->result != OBJ_PARSER_SUCCESS ||
         !sizeof(omatch->objects)) {
         omatch = my_find_match(pattern, env, OBJ_PARSER_TYPE_LIVING);
         tmp = filter(omatch->objects, "check_living", this_object());
         // See of any of them were not living...
         if (sizeof(omatch->objects) != sizeof(tmp)) {
            if (pattern != "all") {
               omatch->result = OBJ_PARSER_NOT_LIVING;
               omatch->objects -= tmp;
            } else {
               omatch->objects = tmp;
            }
         }
      }
      if (omatch->result != OBJ_PARSER_SUCCESS) {
         new_omatch = new(class obj_match);
         new_omatch->text = pattern;
         if (pattern == "creators" && this_object()->query_creator()) {
            new_omatch->objects = filter(users(), (: check_if_creator($1) :));
         }
         if (pattern == "someone") {
            new_omatch->objects = filter(users(), (: check_if_allowed($1) :));
            if (sizeof(new_omatch->objects) > 1) {
               new_omatch->objects = ({ new_omatch->objects[random(sizeof(new_omatch->objects))]});
            }
         }
         if (sizeof(new_omatch->objects)) {
            new_omatch->result = OBJ_PARSER_SUCCESS;
            omatch = new_omatch;
         }
      }
      break;
   }
   if (!omatch) {
      omatch = new(class obj_match);
      omatch->text = pattern;
      omatch->objects = ({ });
      omatch->result = OBJ_PARSER_NO_MATCH;
      return omatch;
   }
   return omatch;
} /* match_objects() */

void setup_failed_mess(class obj_match failed_match) {
    switch (failed_match->result) {
    case OBJ_PARSER_BAD_ENVIRONMENT :
       _failed_mess[0] += "Cannot find \""+ failed_match->text +
                                    "\" here, access is not allowed.\n";
       break;
    case OBJ_PARSER_NOT_LIVING :
       _failed_mess[0] += "The objects \""+
                                    query_multiple_short(failed_match->objects) +
                                    "\" are not living.\n";
       break;
    case OBJ_PARSER_TOO_DARK :
       _failed_mess[0] += "Cannot find \""+ failed_match->text +
                                    "\", it is too dark.\n";
       break;
    default :
       _failed_mess[0] += match_objects_failed_mess(failed_match);
       break;
    }
} /* setup_failed_mess() */

private int handle_command(string *bits, int *matches, mixed *pattern,
                            mixed *command, string pattern_string) {
   int p;
   int failed;
   int i;
   int j;
   int k;
   string dir_match;
   string fail_mess_check;
   string *add_comm_bit;
   string fail_mesg;
   string succ_mesg;
   class obj_match direct_obs;
   object *env;
   object *fail_ob;
   class obj_match failed_match;
   mixed start;
   mixed indirect_obs;
   mixed ret;
   mixed *stuff;
   mixed indir_match;
   mixed bity;
   class obj_match omatch;
   string pattern_str;
   
   /*
    * Ok, we have a match of some sort.   First, do we have any objects
    * to match?   If we do.   Look for them to make sure they
    * really do exist.
    */
   start = 1;
   add_comm_bit = ({ });
   indirect_obs = ({ });
   direct_obs = new(class obj_match);
   direct_obs->objects = ({ });
   if (!sizeof(matches)) {
      return 0;
   }
   for (i=1, p=1;i<sizeof(pattern) && !failed_match;i++,p++) {
      switch (pattern[i]) {
      case DIRECT_OBJECT :
         dir_match = implode(bits[start..matches[p]], " ");
         if (intp(pattern[i+2])) {
             switch (pattern[i+2]) {
                  case ENV_ME :
                     env = ({ this_object() });
                     break;
                  case ENV_HERE :
                     env = ({ environment() });
                     break;
                  case ENV_HERE_ME :
                     env = ({ environment(), this_object() });
                     break;
                  case ENV_ME_HERE :
                     env = ({ this_object(), environment() });
                     break;
             }
         } else if (stringp(pattern[i+2])) {
             ret = find_object(pattern[i+2]);
             if (!ret) {
                  pattern[i+2]->frog_me_a_lot();
                  ret = find_object(pattern[i+2]);
             }
             if (ret) {
                  env = ({ ret });
             }
         }

         direct_obs = match_objects(pattern[++i], dir_match, env);

         i++; /* Skip environment */
         add_comm_bit += ({ dir_match });
         start = matches[p];
         if (direct_obs->result != OBJ_PARSER_SUCCESS) {
            failed_match = direct_obs;
         }
         break;
      case INDIRECT_OBJECT :
         pattern_str = implode(bits[start..matches[p]], " ");
         if (intp(pattern[i+2])) {
             switch (pattern[i+2]) {
             case ENV_ME :
                env = ({ this_object() });
                break;
             case ENV_HERE :
                env = ({ environment() });
                break;
             case ENV_HERE_ME :
                env = ({ environment(), this_object() });
                break;
             case ENV_ME_HERE :
                env = ({ this_object(), environment() });
                break;
             }
         } else if (stringp(pattern[i+2])) {
             ret = find_object(pattern[i+2]);
             if (!ret) {
                  pattern[i+2]->frog_me_a_lot();
                  ret = find_object(pattern[i+2]);
             }
             if (ret) {
                  env = ({ ret });
             }
         }

         if (pattern[i+2] == ENV_DIRECT_OBS) {
            omatch = new(class obj_match);
            omatch->text = pattern_str;
            omatch->objects = ({ ENV_DIRECT_OBS });
            omatch->result = OBJ_PARSER_SUCCESS;
            i++;
         } else {
            omatch = match_objects(pattern[++i], pattern_str, env);
         }
         i++; /* Skip environment specifier */
         add_comm_bit += ({ pattern_str });
         if (omatch->result != OBJ_PARSER_SUCCESS) {
            failed_match = omatch;
         } else {
            if (stringp(indir_match)) {
                if (pointerp(indir_match)) {
                     /* Already an array */
                     indirect_obs += ({ omatch->objects });
                     indir_match += ({ pattern_str });
                } else {
                     // Make an array.
                     indirect_obs = ({ indirect_obs, omatch->objects });
                     indir_match = ({ indir_match, pattern_str });
                }
            } else {
                indirect_obs = omatch->objects;
                indir_match = pattern_str;
            }
         }
         start = matches[p];
         break;
      case SINGLE_WORD :
      case STRING :
      case SHORT_STRING :
         add_comm_bit += ({ implode(bits[start..matches[p]], " ") });
         break;
      case QUOTED_STRING :
         pattern_str = implode(bits[start..matches[p]], " ");
         add_comm_bit += ({ pattern_str[1..<2] });
         break;
      case NUMBER :
         sscanf(implode(bits[start..matches[p]], " "), "%d", j);
         add_comm_bit += ({ j });
         break;
      case FRACTION :
         sscanf(implode(bits[start..matches[p]], " "), "%d/%s", j, k);
         add_comm_bit += ({ j, k });
         break;
      case OPTIONAL_SPACES :
      case OPTIONAL :
         i++; /* skip optional bits */
         break;
      case WORD_LIST_SPACES :
      case WORD_LIST :
         /* These are variable and therefor there must be something associated
             with them */
         if (pointerp(pattern[++i]))
            if (sizeof(pattern[i]) > 1)
               add_comm_bit += ({ implode(bits[start..matches[p]], " ") });
         break;
      }
      start = matches[p]+1;
   }
   if (failed_match) {
      if (query_notify_fail()) {
         _failed_mess[1] += query_notify_fail();
         notify_fail(0);
      } else {
         setup_failed_mess(failed_match);
      }
      return (matches[0]?-1:0);
   }
   _fail_mess = ([ ]);
   _succ_mess = ([ ]);
   _succ_mess_dir = ({ });
   _succ_mess_indir = ({ });
   ret = 0;

   //
   // If this only has a direct-obs method in it, then assume the
   // direct object is the one that defined the method.
   //
   if (!sizeof(direct_obs->objects) &&
         (indirect_obs == ENV_DIRECT_OBS ||
          sizeof(indirect_obs & ({ ENV_DIRECT_OBS }) ) ) ) {
      //
      // Grab all the direct ones.
      //
      direct_obs->objects = ({ });
      for (i = 0; i < sizeof(command); i += 2) {
          direct_obs->objects += ({ command[i] });
      }
   }

   if (!sizeof(direct_obs->objects)) {
      indirect_obs -= ({ ENV_DIRECT_OBS });
      /* Cycle through each object.   Finish when one handles the command */
      for (i = 0; i < sizeof(command) && !ret;i += 2) {
         /* Straight command thingy.   No direct objects to handle at all. */
         /* Ok, what we do in this case is call the function on the set object */
         if (!add_comm_bit) {
            add_comm_bit = ({ });
            start = 1;
            for (j = 0; j < sizeof(matches); j++) {
               add_comm_bit += implode(bits[start..matches[j]], " ");
               start = matches[j]+1;
            }
         }
         if (functionp(command[i+1])) {
            /* If a function pointer exists, check to see that its owner 
             * hasn't been destructed. */
            if ( functionp( command[ i + 1 ] ) & FP_OWNER_DESTED ) {
               /* It has -- so we need to remove it from the player's 
                  command array and then start checking again. */ 
               start = command[i];
               if (!start) {
                  remove_object_force(start);

                  if (start == command[i]) {
                     remove_from_command(bits[0], start);
                  }

                  ret = 0;
                  continue;
               } 
            }
              
            ret = evaluate(command[i+1], indirect_obs, dir_match, indir_match,
                                  add_comm_bit, pattern_string, bits[0]);
         } else {
            start = command[i];
            if (!start) {
               remove_object_force(start);
               if (start == command[i]) {
                  remove_from_command(bits[0], start);
               }
               ret = 0;
               continue;
            }
            do {
               if (function_exists("do_"+bits[0], start)) {
                  ret = call_other(start, "do_"+bits[0], indirect_obs,
                                             dir_match, indir_match, add_comm_bit,
                                             pattern_string);
                  break;
               } else {
                  start = shadow(start, 0);
               }
            } while (start);
            if (!start) {
                ret = call_other(command[i], "command_control", bits[0],
                                          indirect_obs,
                                          dir_match, indir_match, add_comm_bit,
                                          pattern_string);
            }
         } 
      }
      /*
       * Since there are no direct objects.   We don't actually auto generate
       * a message.   That is left up to the object in question.
       */
      if (!ret || ret == -1) {
         if (query_notify_fail()) {
            _failed_mess[1] += query_notify_fail();
            notify_fail(0);
         } else {
            fail_mess_check = get_fail_messages( bits[ 0 ], ({ }) );
            if (_failed_mess[1] == "") {
                _failed_mess[1] += fail_mess_check;
            }
         }
      }
      if (_succ_mess_dir) {
          print_special_messages( bits[ 0 ] );
      }
      _fail_mess = ([ ]);
      return ret;
   }

   /*
    * Ok, now we have some direct objects.   
    * This means we are now working very close to the
    * way that the old add_command did.   Exactly the same actually. 
    */
   /*
    * We go over each direct object and call a function on it.
    * This return value we use to auto generate a success message.
    * However, you can also set your own sucess message.
    */
   fail_ob = ({ });
   bity = ({ });
   failed = 0;
   for (i=0;i<sizeof(direct_obs->objects);i++) {
      /* Check to make sure this object has the command added to it. */
      j = member_array(direct_obs->objects[i], command);
      if (j == -1) {
         fail_ob += ({ direct_obs->objects[i] });
         continue;
      }
      /* Only allow objects with a short. */
      if (!direct_obs->objects[i]->short()) {
         continue;
      }


      if (member_array(ENV_DIRECT_OBS, indirect_obs) != -1) {
         failed_match = my_find_match(indir_match, ({ direct_obs->objects[i] }), 0);
         if (failed_match->result == OBJ_PARSER_SUCCESS) {
             stuff = failed_match->objects;
         } else {
             stuff = ({ });
         }
         debug_printf("Direct Obs Env (%O %O %O)\n", indir_match, stuff, direct_obs->objects[i]);
      } else if (pointerp(indir_match)) {
         failed_match = 0;
         stuff = copy(indirect_obs);
         for (k = 0; k < sizeof(indirect_obs); k++) {
            if (intp(stuff[k]) || ( arrayp(stuff[k]) && sizeof( stuff[k] ) && 
                intp(stuff[k][0]) ) ) {
               failed_match = my_find_match(indir_match[k], ({ direct_obs->objects[i] }), 0);
               if (failed_match->result == OBJ_PARSER_SUCCESS) {
                  stuff[k] = failed_match->objects;
               } else {
                  break;
               }
            }
         }
      } else {
         stuff = indirect_obs;
         failed_match = 0;
      }

      if (failed_match && failed_match->result != OBJ_PARSER_SUCCESS) {
         setup_failed_mess(failed_match);
         failed = 1;
         continue;
      }

      if (functionp(command[j+1])) {
         //
         // See if our function pointer is destructed, and try to fail
         // semi-gracefully.
         //
         if (functionp(command[j+1]) & FP_OWNER_DESTED) {
            start = direct_obs->objects[i];
            if (!start) {
                remove_object_force(start);
                if (start == command[i]) {
                   remove_from_command(bits[0], start);
                }
                ret = 0;
                continue;
            } else {            
                // We still have the start object, but the function pointer
                // has actually been destructed. 
                // We need to remove only this specific command.
                if (start == command[i]) {
                    remove_from_command(bits[0], start);
                }
                ret = 0;
                continue;
            }
         } 
         
         ret = evaluate(command[j+1], stuff, dir_match, indir_match,
                        add_comm_bit, pattern_string, bits[0]);
      } else {
         //
         // See if our command object was dested.
         //
         start = direct_obs->objects[i];
         if (!start) {
             remove_object_force(start);
             if (start == command[i]) {
                remove_from_command(bits[0], start);
             }
             ret = 0;
             continue;
         }

         /* Check to see if the object has the "do_"+verb function. */
         do {
            if (function_exists("do_"+bits[0], start)) {
                ret = call_other(start, "do_"+bits[0], stuff,
                                          dir_match, indir_match, add_comm_bit, 
                                          pattern_string);
                break;
            } else {
                start = shadow(start, 0);
            }
         } while (start);
         if (!start) {
             ret = call_other(direct_obs->objects[i], "command_control", bits[0], stuff,
                                       dir_match, indir_match, add_comm_bit, 
                                       pattern_string);
         }
      }

      //
      // Figure out what to do with the return value.
      //
      if (stringp(ret) || pointerp(ret)) {
         bity += ({ ret });
      } else if (ret && ret != -1) {
         bity += ({ direct_obs->objects[i]});
      } else {
         fail_ob += ({ direct_obs->objects[i] });
         if (ret == -1) {
            failed = 1;
         }
      }
   }
   /*
    * Ok, with this type, we auto generate success and fail messages.
    */
   if (!sizeof(bity)) {
      /* Failure!   We never got any non zero return values */
      fail_mess_check = get_fail_messages( bits[ 0 ], fail_ob );
      if (query_notify_fail()) {
         _failed_mess[1] += query_notify_fail();
         notify_fail(0);
      } else if (_failed_mess[1] == "") {
         /*
          * Only generate a fail message if we do not already have one.
          */
         _failed_mess[1] += fail_mess_check;
         if (_failed_mess[1] == "" && sizeof(fail_ob)) {
            notify_fail(0);
            fail_mesg = create_message(bits, matches, pattern, fail_ob, 1);
            if (!pointerp(indirect_obs)) {
               _failed_mess[1] += "You cannot " + bits[ 0 ] +
                   replace_string( fail_mesg, "$succ_indir$",
                                          ( pointerp( indir_match ) ?
                                             query_multiple_short( indir_match ) :
                                             indir_match) );
            } else {
               if (pointerp(indir_match)) {
                   bity = explode("F" + fail_mesg, "$succ_indir$");
                   _failed_mess[1] += "You cannot "+ bits[ 0 ];
                   bity[0] = bity[0][1..];
                   for (i = 0; i < sizeof(bity) - 1; i++) {
                        if (i >= sizeof(indir_match)) {
                            if (stuff && pointerp(stuff[<1])) {
                                 _failed_mess[1] += bity[i] +
                                                             query_multiple_short( stuff[<1] );
                            } else {
                                 _failed_mess[1] += bity[i] +
                                                             query_multiple_short( indir_match[<1] );
                            }
                        } else {
                            if (stuff && pointerp(stuff[i])) {
                                 _failed_mess[1] += bity[i] +
                                                             query_multiple_short( stuff[i] );
                            } else {
                                 _failed_mess[1] += bity[i] + indir_match[i];
                            }
                        }
                   }
                   _failed_mess[1] += bity[<1];
               } else {
                  if ( member_array( ENV_DIRECT_OBS, indirect_obs ) == -1 ) {
                     stuff = indirect_obs;
                  }
                  if ( member_array( this_player(), stuff ) == -1 ) {
                     _failed_mess[1] += "You cannot "+ bits[ 0 ] +
                           replace_string( fail_mesg, "$succ_indir$",
                                                query_multiple_short( stuff, "a" ) );
                  } else {
                     _failed_mess[1] += "You cannot "+ bits[ 0 ] +
                        replace_string( fail_mesg, "$succ_indir$",
                                                query_multiple_short( stuff - 
                                                                                 ({this_player()}) +
                                                                                 ({ "yourself" }),
                                                                                 "a" ) );
                  }
               }
            }
         }
      }
      _fail_mess = ([ ]);
      if (!failed) {
          return 0;
      }
      return -1;
   }
   /* We succeeded somewhere.   So print our success stuff. */
   if (sizeof(bity) != sizeof(_succ_mess_dir)) {
      /* Auto generated success messages. */
      succ_mesg = create_message( bits, matches, pattern, bity - _succ_mess_dir);
      if ( member_array( this_player(), _succ_indir ) == -1 ) {
         write( "You "+ bits[ 0 ] + replace( succ_mesg, "$succ_indir$",
                                                               query_multiple_short( _succ_indir,
                                                                                                "one" ) ) );
         stuff = _succ_indir;
      } else {
         write("You "+ bits[0] + replace(succ_mesg, "$succ_indir$",
                                                         query_multiple_short(_succ_indir - 
                                                                                        ({ this_player() })
                                                                                        + ({ "yourself" }),
                                                                                        "one") ) );
         stuff = _succ_indir - ({ this_player() });
         stuff = ({ (string)this_player()->query_objective() +"self" }) + stuff;
      }
      say( capitalize( (string)this_player()->the_short() ) +" "+
             pluralize(bits[0]) + replace(succ_mesg, "$succ_indir$",
                                                         query_multiple_short(stuff, "one")),
             _succ_indir );
      for ( i = 0; i < sizeof( _succ_indir ); i++ ) {
         if ( _succ_indir[ i ] != this_player() ) {
            tell_object( _succ_indir[ i ],
                               capitalize( (string)this_player()->the_short() ) +" "+
                               pluralize(bits[0]) + replace(succ_mesg, "$succ_indir$",
                                                                           query_multiple_short(stuff -
                                                                              ({ _succ_indir[i] }) +
                                                                              ({ "you" }), "one" ) ) );
         }
      }
      //
      // And print any special messages too.
      //
      if (sizeof(_succ_mess_dir)) {
          print_special_messages( bits[ 0 ] );
      }
   } else {
      /* Creator generated success messages */
      print_special_messages( bits[ 0 ] );
   }
   _succ_indir = ({ });
   _succ_mess = ([ ]);
   _succ_mess_dir = ({ });
   _succ_mess_dir = ({ });
   return 1;
} /* handle_command() */

/* This is exactly the same as the old one. */
/* I can't be bothered making the strings more easily readable... */
/* Someone else can do it. */
void print_special_messages( string verb ) {
    int i, j;
    string words, *messes;
    string type;
    mixed *stuff, *tmp;

    messes = keys( _succ_mess );
    for ( i = 0; i < sizeof( messes ); i++ ) {
         if ( functionp( messes[i] ) ||
                (messes[i][0..1] == MY_MESS_HEADER &&
                  strlen(messes[i]) > 2)) {
            /* 0 as the first arg means, this_player.   Write message */
            if (functionp(messes[i])) {
                words = evaluate(messes[i], 0);
            } else {
                words = messes[i][2..];
            }
            type = "one";
            if (strsrch("$Iposs$", words) != -1) {
                type = "poss";
                words = replace_string(words, "$Iposs$", "");
            }
            if (strsrch("$Ithe$", words) != -1) {
                type = "the";
                words = replace_string(words, "$Ithe$", "");
            }
            if (strsrch("$Ia$", words) != -1) {
                type = "a";
                words = replace_string(words, "$Ia$", "");
            }
            if ( member_array( this_player(), _succ_mess[ messes[ i ] ][ 1 ] ) ==
                     -1 ) {
                words = capitalize( replace( words, ({ "$C$", "$CATFROG",
                         "$N", "you", "$p ", "your ",
                         "$r", "you", "$o", "you", "$V", verb, "$es", "", 
                         "$s", "", "$y", "y",
                         "$I", query_multiple_short( _succ_mess[ messes[ i ] ][ 1 ],
                                                          type ) }) ) );
            } else {
                words = capitalize( replace( words, ({ "$C$", "$CATFROG", 
                         "$N", "you", "$p ", "your ",
                         "$r", "you", "$o", "you", "$V", verb, "$es", "", "$s", "", 
                         "$y", "y", 
                         "$I", query_multiple_short( (mixed *)_succ_mess[ messes[ i ] ][ 1 ] -
                         ({ this_player() }) + ({ "yourself" }), type ) }) ) );
            }
            write( replace( words, ({ "$D",
                                    query_multiple_short( _succ_mess[ messes[ i ] ][ 0 ],
                                                                     "one" ),
                                    "$CATFROG", "$C$" }) ) );
         } else if (messes[i][0..1] == OTHER_MESS_HEADER &&
                         strlen(messes[i]) > 2) {
            if (functionp(messes[i])) {
               words = replace( evaluate(messes[i], 1),
                   ({ "$C$", "$CATFROG",
                        "$N", (string)this_player()->the_short(),
                        "$p ", (string)this_player()->query_possessive() +" ",
                        "$r", (string)this_player()->query_pronoun(),
                        "$o", (string)this_player()->query_objective(),
                        "$V", pluralize( verb ), "$es", "es", "$s", "s", "$y", "ies" }) );
            } else {
               words = replace( messes[i][2..],
                   ({ "$C$", "$CATFROG",
                        "$N", (string)this_player()->the_short(),
                        "$p ", (string)this_player()->query_possessive() +" ",
                        "$r", (string)this_player()->query_pronoun(),
                        "$o", (string)this_player()->query_objective(),
                        "$V", pluralize( verb ), "$es", "es", "$s", "s", "$y", "ies" }) );
            }
            words = replace( words, "$D",
                     query_multiple_short( _succ_mess[ messes[ i ] ][ 0 ], "one" ) );
            if (member_array(this_player(), _succ_mess[ messes[i] ][ 1 ]) == -1) {
               stuff = _succ_mess[messes[i]][1];
            } else {
                stuff = ({ (string)this_player()->query_objective() +"self" });
                stuff += (mixed *)_succ_mess[ messes[ i ] ][ 1 ] - ({ this_player() });
            }

            type = "one";
            if (strsrch("$Iposs$", words) != -1) {
                type = "poss";
                words = replace_string(words, "$Iposs$", "");
            }
            if (strsrch("$Ithe$", words) != -1) {
                type = "the";
                words = replace_string(words, "$Ithe$", "");
            }
            if (strsrch("$Ia$", words) != -1) {
                type = "a";
                words = replace_string(words, "$Ia$", "");
            }

            say( capitalize( replace( words, ({ "$I", query_multiple_short( stuff,
                                                                                                       type),
                                                   "$CATFROG", "$C$" }) ) ),
                     _succ_mess[ messes[ i ] ][ 1 ] );
            for ( j = 0; j < sizeof( _succ_mess[ messes[ i ] ][ 1 ] ); j++ ) {
                if ( _succ_mess[ messes[ i ] ][ 1 ][ j ] != this_player() ) {
                     if (strsrch(words, "$I's") != -1) {
                         tmp = stuff - _succ_mess[ messes[ i ] ][ 1 ][ j..j ];
                         tell_object( _succ_mess[ messes[ i ] ][ 1 ][ j ],
                               capitalize( replace( words, ({ "$I's", 
                                                 query_multiple_short( tmp + ({ "your" }) ),
                                                 "$I", query_multiple_short( tmp + ({ "you" }),
                                                                                           "one"),
                                                 "$CATFROG", "$C$" }) ) ) );
                     } else {
                         tell_object( _succ_mess[ messes[ i ] ][ 1 ][ j ],
                               capitalize( replace( words, ({ "$I",
                                                               query_multiple_short( stuff -
                               ({ _succ_mess[ messes[ i ] ][ 1 ][ j ] }) + ({ "you" }),
                               "one"), "$CATFROG", "$C$" }) ) ) );
                     }
                }
            }
       }
   }
} /* print_special_messages() */

/*
 * Don't know if I will need this.   I guess I do though.   Oh well,
 * so it explodes.
 */
string get_fail_messages( string verb, object *fail_obs ) {
    string whole;
    string words;
    string mess;
    string *str;
    object ob;
    class fail_mess_data data;

    whole = "";
    foreach (mess, data in _fail_mess) {
         if ( !stringp( mess ) ) {
             continue;
         }

         str = ({ });
         foreach(ob in data->direct)
            str += ({ "one_short:" + sprintf("%O", ob) });
         
         words = this_player()->evaluate_message( ({ mess, ({ str }) }) );
         words = replace( words,
                                  ({ "$D", query_multiple_short( data->direct, "one" ),
                                       "$V", verb }) );

         if ( member_array( this_player(), data->indirect) == -1 )
             words = replace( words, "$I",
                      query_multiple_short( data->indirect, "one" ) );
         else
             words = replace( words, "$I",
                      query_multiple_short( data->indirect -
                      ({ this_player() }) + ({ "yourself" }), "one" ) );
         whole += capitalize( words );
    }

    return whole;
} /* get_fail_messages() */

string *query_word_list(string list) {
   return 0;
} /* query_word_list() */

varargs string create_message(string *bits, int *matches, mixed *pattern, 
                                             object *dir, int flag) {
   string ret;
   int i, pos;
   
   ret = " ";
   if (matches[0])
      matches[0] = 0;
   for (i=1;i<sizeof(pattern);i++, pos++) {
      switch (pattern[i]) {
      case DIRECT_OBJECT :
         if (member_array(this_player(), dir) != -1)
            ret += query_multiple_short(dir - ({ this_player() }) +
                                                      ({ "yourself" }), (flag?"a":"one"));
         else
            ret += query_multiple_short(dir, (flag?"a":"one"));
         i += 2;
         break;
      case INDIRECT_OBJECT :
         ret += "$succ_indir$";
         i += 2;
         break;
      case SHORT_STRING :
      case STRING :
         ret += implode(bits[matches[pos]+1..matches[pos+1]], " ");
         break;
      case WORD_LIST_SPACES :
         pos += matches[pos+1]-1;
      case WORD_LIST :
         ret += implode(bits[matches[pos]+1..matches[pos+1]], " ");
         i++;
         break;
      case NUMBER :
      case FRACTION :
      case SINGLE_WORD :
/* Can only be one word...   Must be this one. */
         ret += bits[matches[pos]+1];
         break;
      case OPTIONAL_SPACES :
         if (!matches[pos] == matches[pos+1])
            pos += matches[pos+1]-1;
      case OPTIONAL :
         if (matches[pos] == matches[pos+1]) {
            if (pointerp(pattern[i+1][0]))
               ret += implode(pattern[i+1][0], " ");
            else
               ret += pattern[i+1][0];
         } else {
            ret += implode(bits[matches[pos]+1..matches[pos+1]], " ");
         }
         i++;
         break;
      }
      if (i+1 < sizeof(pattern))
         ret += " ";
   }
   return ret+".\n";
} /* create_mesage() */
// --- END [/mnt/home2/grok/lib/global/new_parse.c] ---
// --- BEGIN [/mnt/home2/grok/lib/global/magic.c] ---
// Size:   File: "/mnt/home2/grok/lib/global/magic.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627293   Available: 13574647
Inodes: Total: 5242880    Free: 4960133
94770 bytes, Last Modified:   File: "/mnt/home2/grok/lib/global/magic.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627293   Available: 13574647
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:52.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker: presto $
 * $Id: magic.c,v 1.23 2001/05/13 02:47:41 presto Exp presto $
 * $Log: magic.c,v $
 * Revision 1.23  2001/05/13 02:47:41  presto
 * Changed write()s to printf()s.  Cleaned up formatting.
 *
 * Revision 1.22  2000/07/31 02:47:42  presto
 * New '=' command.  Added file history for 'O' command.  Fixed up some little
 * bugs.  Removed some code dealing with coloring... the effort wasn't worth the
 * reward
 *
 * Revision 1.21  2000/02/06 21:57:53  presto
 * Added customizable setting for colors and tabs
 *
 * Revision 1.20  1999/12/09 01:53:15  presto
 * Fixed up a lot of little buglets
 *
 * Revision 1.19  1999/06/07 01:38:19  presto
 * Added syntax coloring (based on original code by Gototh).  Bug fixes.
 *
 * Revision 1.18  1999/04/16 05:28:46  pinkfish
 * Fix up a minor error in the magic editor.
 *
 * Revision 1.17  1999/03/28 03:24:10  presto
 * can now specify separation string with 'j' command
 *
 * Revision 1.16  1999/03/20 02:28:26  presto
 * Fixed a itsy-bitsy bug with adding text starting with a backslash
 *
 * Revision 1.15  1999/02/07 19:13:00  presto
 * s'a secret
 *
 * Revision 1.14  1999/01/08 01:28:00  presto
 * Fixed a parse error that was making things like 'I @10 ""' not work
 *
 * Revision 1.13  1998/08/22 01:17:44  presto
 * Changed some code that I couldn't remember the purpose of.  :-b
 *
 * Revision 1.12  1998/07/12 17:36:54  presto
 * Since last time: added 'j', '\', 'r' commands
 *
 * Revision 1.11  1998/03/07 02:10:40  presto
 * Some nifty new modes for C and M commands.  New workaround for rm problem.
 *
 * Revision 1.10  1998/02/07 23:23:27  presto
 * Fixed array out of bounds bug reported by Daxa
 *
 * Revision 1.9  1998/01/31 17:49:21  presto
 * Added undo support for 'F' command
 *
 * Revision 1.8  1998/01/31 17:24:42  presto
 * Workaround for damn problem with rm()
 *
 * Revision 1.7  1998/01/31 16:31:11  presto
 * Fixed bug with my_more function.  I think.
 *
 * Revision 1.6  1998/01/19 00:32:56  presto
 * quick fix so it's usable until line_ed gets sorted
 *
 * Revision 1.1  1998/01/06 04:54:05  ceres
 * Initial revision
 *
*/
#include <creator.h>
#include <ed.h>
#define HELPPATH "/w/presto/Misc/edit_help/"
#define UPDATE "/secure/cmds/creator/upd_ate"

#define SPACE      ' '
#define COMMA      ','
#define LPAREN     '('
#define RPAREN     ')'
#define LBRACE     '{'
#define RBRACE     '}'
#define PLUS       '+'
#define MINUS      '-'
#define TIMES      '*'
#define DIVIDE     '/'
#define MOD        '%'
#define AND        '&'
#define OR         '|'
#define XOR        '^'
#define NOT        '!'
#define ONESCMP    '~'
#define EQUAL      '='
#define COLON      ':'
#define QUESTION   '?'
#define GREATER    '>'
#define LESS       '<'
#define LSQUARE    '['
#define RSQUARE    ']'
#define SCOLON     ';'
#define DQUOTES    '"'
#define SQUOTES    '''
#define PERIOD     '.'
#define TAB        '\t'

int *SEPARATORS = ({ SPACE, COMMA, SCOLON, TAB });

int *OPERATORS = ({ LPAREN, RPAREN, PLUS, LSQUARE, RSQUARE, MINUS, TIMES,
                    DIVIDE, MOD, AND, OR, XOR, NOT, ONESCMP, EQUAL, COLON,
                    QUESTION, GREATER, LESS, LBRACE, RBRACE, PERIOD });

string *RANGE_CMDS   = ({ "L", "c", "C", "m", "M", "d", "D", "S", "R", "->",
                          "<-", "j", "=", "rot13" });

string *INDEX_CMDS   = ({ "d", "D", "i", "I", "a", "A", ">", "<", "c", "C",
                          "p", "P", "L", "E", "e", "S", "R", "f", "b", "m",
                          "M", "->", "<-", "F", "j", "=", "O", "ed",
                          "rot13" });

string *M_INDEX_CMDS = ({ "d", "D", "c", "C", "L", "S", "R", "f", "b", "m",
                          "M", "->", "<-", "j", "=", "rot13" });

string *MULTI_CMDS   = ({ "L", "C", "c", "m", "M", "D", "d", "S", "R", ">",
                          "<", "f", "b", "+", "-", "U", "->", "<-", "j",
                          "=", "rot13", "O" });

string *CHAR_CMDS    = ({ "d", "c", "m" });

string *STR_CMDS     = ({ ">", "<", "i", "a", "e", "d", "c", "m", "O", "H",
                          "w", "W", "T", "R", "I", "A", "E", "F", "\\", "r",
                          "set", "ed", "help", "#" });

string *CMDS         = ({ "d", "D", "<", ">", "<<", ">>", "|", "^", "V", "I",
                          "i", "A", "a", "E", "e", "C", "c", "M", "m", "P",
                          "p", "O", "L", "f", "b", "S", "R", "T", "+", "++",
                          "-", "W", "w", "N", "Q", "H", "U", "{}", "()", "[]",
                          "->", "<-", "F", "\\", "j", "r", "h", "set", "=",
                          "ed", "help", "rot13", "#" });

string *P_CMDS       = ({ "d", "D", "<", ">", "<<", ">>", "|", "^", "V", "I",
                          "i", "A", "a", "E", "e", "C", "c", "M", "m", "P",
                          "p", "L", "f", "b", "S", "R", "+", "++", "-", "W",
                          "N", "Q", "H", "U", "->", "<-", "F", "\\", "j",
                          "r", "=", "help", "rot13" });
string *AVAIL_CMDS;

string  keyw_color;
string  comm_color;
string  numb_color;
string  stri_color;
string  oper_color;
string  type_color;
string  tab_str;
string *file;
string *clipboard;
string  name;
string  newname;
string *open_history = ({ });
int     chptr;
int     lnptr;
int     tmpch;
int     tmpln;
int     cols;
int     rows;
int     changed;
int     showln = 1;
int     fsize;
int     mode_flag;
int     highlight = 0;
int     in_comment = 0;
int     in_string = 0;
int     tab_replace;
int     num_len;
int     defs_not_done;
mixed  *undo;
mapping defs;

private string *filter_regexp(string *incoming);
private void    init_settings();
private int     set_colors(string *words);
private void    print_line(int show_ptr);
private int     open_file(string filename);
private int     save_file(string cmd, int open_pending);
private string  color_word(string word,
                           int ref if_flag, int ref include_flag,
                           int ref type_flag, int ref class_flag);
private string *boom(string str, int linenum, int last_line);
private string  highlight(string str, int linenum, int numbering,
                          int last_line);
private int     save_history();
public  void    my_more(string input, string *text, int startln,
                        int number, int hilite, int pages, string xtratxt);
public  void    get_new_text(string new_in, string cmd, int count,
                             int cmdline);
public  void    get_command(string action);
public  int     write_permission(string name);
public  int     rm_file(string name);
private string  expand_macros(string ins, string *sorted_defs);
private string  strip_junk(string stuff);

void create(string filename, int flag)  {
   int status;

   if (undefinedp(filename))  return;
   rows = this_player()->query_rows();
   cols = this_player()->query_cols();
   mode_flag = flag;
   seteuid(geteuid(this_player()));
   if (!filename)  filename = "";
   else filename = implode(explode(filename, " "), ""); /* no leading spaces */
   if (mode_flag)
      init_settings();

   status = open_file(filename);
   if (status == 0)  {
      printf("Cannot open file \"%s\".\n", filename);
      open_file("");
   }
   if (!mode_flag)  {
      AVAIL_CMDS = P_CMDS;
      printf("Type '.' on a blank line to stop inserting text.\nType 'H' "
             "at the ':' prompt for help.\n]");
      tmpln = fsize;
      input_to("get_new_text", 0, "I", 0, 0);
   }
   else  {
      AVAIL_CMDS = CMDS;
      if (status != -1)  {
         printf(":");
         input_to("get_command");
      }
   }
   return;
}  /* create() */


void get_command(string action)  {
   string   *bits;
   string    tmp;
   string    tmp2;
   string   *scrap;
   int       i;
   int       j;
   int       amt;
   int       start;
   int       end;
   int       index;
   int       diff;
   int       rexp_flag;
   mixed    *rexp;
   function  search_func;

   bits = explode(action + " ", " ");
   if ((end  = sizeof(bits) - 1) == -1)  {
      printf(":");
      input_to("get_command");
      return;
   }
   for (i = 1, start = diff = 0; i <= end; i++)  {
      if ((j = strlen(bits[i])) == 0  &&  !start)  {
         --i;
         bits = bits[0 .. i] + bits[i + 2 .. ];
         --end;
      }
      else  {
         if (j  &&  (bits[i][0] == '"'  ||  bits[i][0] == ''')  &&  !start)  {
            start = bits[i][0];
            --j;
            bits[i] = j ? bits[i][1 .. ] : "";
            if (i == 1)  {
               diff = 1;
               if (start == ''')  rexp_flag = 1;
            }
            else if (i == 2  &&  start == ''')  rexp_flag = 2;
         }
         if (start  &&  j  &&  bits[i][j - 1] == start)  {
            start = 0;
            --j;
            bits[i] = j ? bits[i][0 .. j - 1] : "";
         }
         if (j  &&  bits[i][j - 1] == '\\')  {
            bits[i] = j > 1 ? bits[i][0 .. j - 2] : "";
         }
         if (start  &&  i != end )  {
            bits[i] += " " + bits[i + 1];
            bits = bits[0 .. i] + bits[i + 2 .. ];
            --i;
            --end;
         }
      }
   }

   /* See if it's a line number */
   if ((i = to_int(bits[0])) != 0  ||  bits[0][0] == '0')  {
      --i;
      if (i > fsize)  i = fsize;
      else if (i <= 0)  i = 0;

      if (highlight)  {
         if (i != lnptr + 1)
            in_string = 0;
         if (i != lnptr + 1)
            in_comment = 0;
      }
      lnptr = i;
      chptr = 0;
      print_line(0);
      printf(":");
      input_to("get_command");
      return;
   }

   /* If it's not a number, see if it's a known command */
   if (member_array(bits[0], AVAIL_CMDS) == -1)  {
      printf("Unknown command.  Enter 'H' for help.\n:");
      input_to("get_command");
      return;
   }
   tmpln = lnptr;
   tmpch = chptr;
   index = 0;
   if (sizeof(bits) > 1)  {
      if (to_int(bits[1]) == 0  &&  bits[1][0] != '0'  &&
          bits[1][0] != '@'  &&  bits[1][0 .. 1] != ".-")
      {
         diff = 1;
      }
      if (!diff)  {
         tmp = tmp2 = "";
         sscanf(bits[1], "%s-%s", tmp, tmp2);
         if (strlen(tmp)  &&  strlen(tmp2))  {
            if (member_array(bits[0], RANGE_CMDS) == -1)  {
               printf("Range mode not valid with command '%s'.\n:", bits[0]);
               input_to("get_command");
               return;
            }
            if ((start = to_int(tmp)) == 0  &&  tmp == ".")
               start = member_array(bits[0], CHAR_CMDS) == -1 ?
                       lnptr + 1 : chptr + 1;
            if ((end = to_int(tmp2)) == 0)  {
               if (tmp2 == ">")
                  end = member_array(bits[0], CHAR_CMDS) == -1 ?
                        fsize : strlen(file[lnptr]);
               else if (tmp2 == ".")
                  end = member_array(bits[0], CHAR_CMDS) == -1 ?
                        lnptr + 1 : chptr + 1;
            }
            if (start > end  ||  start <= 0)  {
               printf("Invalid range.\n:");
               input_to("get_command");
               return;
            }
            else  {
               tmpln = tmpch = start - 1;
               if (tmpch > strlen(file[lnptr]))
                  tmpch = strlen(file[lnptr]);
               if (tmpln > fsize)  tmpln = fsize;
               amt = end - start + 1;
            }
         }
         else if (sscanf(bits[1], "%*s@%d", index))  {
            if (member_array(bits[0], INDEX_CMDS) == -1)  {
               printf("Index mode not valid with command '%s'.\n:", bits[0]);
               input_to("get_command");
               return;
            }
            else if (index <= 0)  {
               printf("Invalid index.\n:");
               input_to("get_command");
               return;
            }
            if (sscanf(bits[1], "%d@%d", amt, index) == 2)  {
               if (member_array(bits[0], M_INDEX_CMDS) == -1)  {
                  printf("Multi-indexing not valid with command '%s'.\n:",
                         bits[0]);
                  input_to("get_command");
                  return;
               }
            }
            else amt = 1;
            tmpln = tmpch = index - 1;
            if (tmpch > strlen(file[lnptr]))
               tmpch = strlen(file[lnptr]);
            if (tmpln > fsize)  tmpln = fsize;
         }
         else if (member_array(bits[0], MULTI_CMDS) == -1)  {
            printf("Amount mode not valid with command '%s'.\n:", bits[0]);
            input_to("get_command");
            return;
         }
         else amt = to_int(bits[1]);
         if (amt <= 0  &&  bits[0] != "O")  {
            printf("Illegal amount.\n:");
            input_to("get_command");
            return;
         }
      }
      else if (member_array(bits[0], STR_CMDS) == -1)  {
         printf("String arguments are not valid with command '%s'.\n:",
                bits[0]);
         input_to("get_command");
         return;
      }
      else amt = 1;
   }
   else amt = 1;

   if (highlight)  {
      if (tmpln != lnptr  &&  tmpln != lnptr + 1)
         in_comment = 0;
      if (tmpln != lnptr + 1)
         in_string = 0;
   }

   switch (bits[0])  {
      case "d":
         if (lnptr == fsize)
            printf("Cannot delete beyond end of file.\n");
         else if (tmpch == strlen(file[lnptr]))
            printf("Cannot delete beyond end of line.\n");
         else  {
            if (rexp_flag == 1)  {
               tmp = catch(scrap = reg_assoc(file[lnptr],
                                             ({ bits[1] }), ({ "1" }))[0]);
               if (tmp)  {
                  printf("REGEXP error: %s", tmp[1 .. ]);
                  break;
               }
               else  {
                  if (sizeof(scrap) != 3)  {
                     sprintf("No match found for regular expression \"%s"
                             "\".\n", bits[1]);
                     break;
                  }
                  else  {
                     tmpch = strlen(scrap[0]);
                     amt = strlen(scrap[1]);
                  }
               }
            }
            else if (diff)  {
               if ((i = strsrch(file[lnptr][tmpch .. ], bits[1])) > -1)  {
                  tmpch += i;
                  amt = strlen(bits[1]);
               }
               else  {
                  if (strlen(bits[1]) == 0)
                     printf("Cannot search for null string.\n");
                  else
                     printf("'%s' not found.\n", bits[1]);
                  break;
               }
            }
            else if (tmpch + amt > strlen(file[lnptr]))
               amt = strlen(file[lnptr]) - tmpch;
            undo = ({ ({ ({ "E", lnptr, ({ file[lnptr] }) }) }) }) + undo;
            changed = 1;
            if (!tmpch)
               file[lnptr] = file[lnptr][amt .. ];
            else
               file[lnptr] = file[lnptr][0 .. tmpch - 1] +
                             file[lnptr][tmpch + amt .. ];
            if (tmpch + amt < chptr)  chptr -= amt;
            else if (chptr >= tmpch)  chptr = tmpch;
            print_line(1);
         }
         break;

      case ">":
         if (lnptr != fsize)  {
            if (index)  chptr = tmpch;
            else if (rexp_flag == 1)  {
               tmp = catch(scrap = reg_assoc(file[lnptr],
                                             ({ bits[1] }), ({ "1" }))[0]);
               if (tmp)  {
                  printf("REGEXP error: %s", tmp[1 .. ]);
                  break;
               }
               else  {
                  if (sizeof(scrap) != 3)  {
                     printf("No match found for regular expression \"%s"
                            "\".\n", bits[1]);
                     break;
                  }
                  else  {
                     chptr = strlen(scrap[0]);
                  }
               }
            }
            else if (diff)  {
               if ((i = strsrch(file[lnptr][chptr + 1 .. ], bits[1])) != -1)
                  chptr += i + 1;
               else if ((i = strsrch(file[lnptr]
                                         [0 .. chptr + strlen(bits[1]) - 1],
                                     bits[1])) != -1)
                  chptr = i;
               else  {
                  if (strlen(bits[1]) == 0)
                     printf("Cannot search for null string.\n");
                  else printf("'%s' not found.\n", bits[1]);
                  break;
               }
            }
            else chptr = (chptr + amt) % (strlen(file[lnptr]) + 1);
            print_line(1);
         }
         else print_line(0);
         break;

      case "<":
         if (lnptr != fsize)  {
            if (index)  chptr = tmpch;
            else if (rexp_flag == 1)  {
               tmp = catch(scrap = reg_assoc(file[lnptr],
                                             ({ bits[1] }), ({ "1" }))[0]);
               if (tmp)  {
                  printf("REGEXP error: %s", tmp[1 .. ]);
                  break;
               }
               else  {
                  if (sizeof(scrap) != 3)  {
                     printf("No match found for regular expression \"%s"
                            "\".\n", bits[1]);
                     break;
                  }
                  else  {
                     chptr = strlen(scrap[0]);
                  }
               }
            }
            else if (diff)  {
               if ((i = strsrch(file[lnptr]
                                    [0 .. chptr + strlen(bits[1]) - 2],
                                bits[1], -1)) != -1)
                  chptr = i;
               else if ((i = strsrch(file[lnptr][chptr .. ],
                                     bits[1], -1)) != -1)
                  chptr += i;
               else  {
                  if (strlen(bits[1]) == 0)
                     printf("Cannot search for null string.\n");
                  else printf("'%s' not found.\n", bits[1]);
                  break;
               }
            }
            else  {
               i = strlen(file[lnptr]);
               amt = i - (amt % (i + 1)) + 1;
               chptr = (chptr + amt) % (i + 1);
            }
            print_line(1);
         }
         else print_line(0);
         break;

      case ">>":
         if (lnptr != fsize)  {
            chptr = strlen(file[lnptr]);
            print_line(1);
         }
         else print_line(0);
         break;

      case "<<":
         if (lnptr != fsize)  {
            chptr = 0;
            print_line(1);
         }
         else print_line(0);
         break;

      case "|":
         if (lnptr != fsize)  {
            chptr = strlen(file[lnptr]) / 2;
            print_line(1);
         }
         else print_line(0);
         break;

      case "^":
         i = showln;
         showln = 1;
         print_line(lnptr != fsize);
         showln = i;
         break;

      case "\\":
         if (lnptr != fsize)  {
            if (rexp_flag == 1)  {
               tmp = catch(scrap = reg_assoc(file[lnptr],
                                             ({ bits[1] }), ({ "1" }))[0]);
               if (tmp)  {
                  printf("REGEXP error: %s", tmp[1 .. ]);
                  break;
               }
               else  {
                  if (sizeof(scrap) != 3)  {
                     printf("No match found for regular expression \"%s"
                            "\".\n", bits[1]);
                     break;
                  }
                  else  {
                     chptr = strlen(scrap[0]);
                  }
               }
            }
            else if (diff)  {
               if ((i = strsrch(file[lnptr][chptr .. ], bits[1])) != -1)
                  chptr += i;
               else  {
                  if (strlen(bits[1]) == 0)
                     printf("Cannot search for null string.\n");
                  else printf("'%s' not found.\n", bits[1]);
                  break;
               }
            }
            if (chptr != strlen(file[lnptr]))  {
               undo = ({ ({ ({ "E", lnptr,  ({ file[lnptr] }) }),
                            ({ "D", lnptr + 1, 1 }) }) }) + undo;
               if (!lnptr)  {
                  file = ({ file[0][0 .. chptr - 1], file[0][chptr .. ]})  +
                         file[1 .. ];
               }
               else  {
                  file = file[0 .. lnptr - 1] +
                         ({ file[lnptr][0 .. chptr - 1],
                            file[lnptr][chptr .. ] }) + file[lnptr + 1.. ];
               }
               ++fsize;
               num_len = strlen(sprintf("%d", fsize + 1));
               changed = 1;
               printf("Line %d split.\n", lnptr + 1);
            }
            else printf("Cannot split beyond end of line.\n");
         }
         else printf("Cannot split beyond end of file.\n");
         break;

      case "j":
         if (tmpln < fsize)  {
            if (amt != 1)  {
               if (tmpln + amt > fsize)  {
                  printf("Joining up to end of file - ");
                  amt = fsize - tmpln;
               }
               undo = ({ ({ ({ "E", tmpln, ({ file[tmpln] }) }),
                            ({ "I", tmpln + 1,
                               file[tmpln + 1 .. tmpln + amt - 1] }) }) }) +
                      undo;
               if (sizeof(bits) > 2)
                  tmp = bits[2];
               else
                  tmp = " ";
               for (i = 1; i < amt; i++)  {
                  file[tmpln] += tmp +
                                 implode(explode(file[tmpln + i], " "),
                                         " ");
               }
               printf("%d lines joined.\n", amt);
               file = file[0 .. tmpln] + file[tmpln + amt .. ];
               fsize -= amt - 1;
               num_len = strlen(sprintf("%d", fsize + 1));
               if (tmpln < lnptr)  lnptr -= amt - 1;
               changed = 1;
            }
            else printf("Joining just 1 line is pointless. :)\n");
         }
         else printf("Cannot join beyond end of file.\n");
         break;

      case "=":
         if (tmpln < fsize)  {
            if (sizeof(bits) > 2)  {
               j = to_int(bits[2]);
               if (j <= 0)  {
                  printf("Line width must be greater than zero.\n");
                  break;
               }
               if (sizeof(bits) > 3)  {
                  j -= strlen(bits[3]);
                  if (j < 0)   {
                     printf("Line width must be greater than the length "
                            "of your indent string.\n");
                     break;
                  }
               }
            }
            else  {
               j = cols - 5;
               if (j <= 0)  j = cols;
            }
            if (tmpln + amt > fsize)  {
               printf("Formatting up to end of file - ");
               amt = fsize - tmpln;
            }
            tmp2 = " \n";
            scrap = ({ });
            i = 0;
            foreach (tmp in file[tmpln .. tmpln + amt - 1])  {
               if (tmp != "")
                  /* strip off leading spaces and append */
                  tmp2 += implode(explode(tmp, " "), " ") + " ";
               else  {
                  scrap += explode(sprintf("%-=*s", j, tmp2[0 .. <2]) +
                                   "\n\n", "\n")[1 .. ];
                  tmp2 = " \n";
               }
            }
            if (strlen(tmp2))
               scrap += explode(sprintf("%-=*s", j,
                                        tmp2[0 .. <2]), "\n")[1 .. ];

            if (sizeof(bits) > 3)
               scrap = map(scrap, (: $(bits[3]) + $1 :));
            /* check for changes */
            if ((i = sizeof(scrap)) != amt)
               diff = 1;
            else for (j = 0; j < amt; j++)  {
               if (file[tmpln + j] != scrap[j])  {
                  diff = 1;
                  break;
               }
            }

            if (diff)  {
               changed = 1;
               undo = ({ ({ ({ "D", tmpln, i }),
                            ({ "I", tmpln,
                               file[tmpln .. tmpln + amt - 1] }) }) }) +
                      undo;
               if (tmpln)  {
                  file = file[0 .. tmpln - 1] + scrap +
                         file[tmpln + amt .. ];
               }
               else  {
                  file = scrap + file[amt .. ];
               }
               printf("Adjustments made.\n");
               fsize += i - amt;
               num_len = strlen(sprintf("%d", fsize + 1));
               if (lnptr >= tmpln + amt)  lnptr += i - amt;
               else if (lnptr >= tmpln)  {
                  lnptr = tmpln + i * (to_float(lnptr - tmpln)) / amt;
                  chptr = 0;
               }
            }
            else printf("No adjustments needed.\n");
         }
         else printf("Cannot adjust beyond end of file.\n");
         break;

      case "->":
         if (tmpln != fsize)  {
            tmp = sizeof(bits) > 2 ? bits[2] : "   ";
            if (strlen(tmp) == 0)
               printf("Why bother indenting by nothing?\n");
            else  {
               if (tmpln + amt > fsize)  {
                  printf("Indenting up to end of file - ");
                  amt = fsize - tmpln;
               }
               undo = ({ ({ ({ "E", tmpln,
                               file[tmpln .. tmpln + amt - 1] }) }) }) +
                      undo;
               changed = 1;
               tmp = sizeof(bits) > 2 ? bits[2] : "   ";
               file[tmpln .. tmpln + amt - 1] =
                  map(file[tmpln .. tmpln + amt - 1], (: $(tmp) + $1 :));
               printf("%d line%s indented.\n", amt, amt == 1 ? "" : "s");
            }
         }
         else printf("Cannot indent beyond end of file.\n");
         break;

      case "<-":
         if (tmpln != fsize)  {
            tmp = sizeof(bits) > 2 ? bits[2] : "   ";
            if ((j = strlen(tmp)) == 0)
               printf("Why bother unindenting by nothing?\n");
            else  {
               if (tmpln + amt > fsize)  {
                  printf("Unindenting up to end of file - ");
                  amt = fsize - tmpln;
               }
               index = diff = i = 0;
               foreach (tmp2 in file[tmpln .. tmpln + amt - 1])  {
                  if (tmp2[0 .. j - 1] == tmp)  {
                     if (!index)  {
                        changed = index = diff = 1;
                        undo = ({ ({ ({ "E", tmpln, ({ tmp2 }) }) }) }) +
                               undo;
                     }
                     else if (!diff)  {
                        undo[0] += ({ ({ "E", tmpln, ({ tmp2 }) }) });
                        diff = 1;
                     }
                     else undo[0][<1][2] += ({ tmp2 });
                     file[tmpln] = tmp2[j .. ];
                     ++i;
                  }
                  else diff = 0;
                  ++tmpln;
               }
               if (i == 0)
                  printf("Couldn't find any lines beginning with \"" + tmp +
                         "\".\n");
               else
                  printf("%d line%s unindented.\n", i, i == 1 ? "" : "s");
            }
         }
         else printf("Cannot unindent beyond end of file.\n");
         break;

      case "[]":
      case "()":
      case "{}":
         tmp = sprintf("%c", bits[0][0]);
         tmp2 = sprintf("%c", bits[0][1]);
         if ((i = file[lnptr][chptr]) != tmp[0]  &&  i != tmp2[0])
            printf("Pointer must be on a '%s' or a '%s'\n:", tmp, tmp2);
         else  {
            if (i == tmp[0])  {
               do  {
                  do  {
                     i = strsrch(file[lnptr][++chptr .. ], tmp);
                     j = strsrch(file[lnptr][chptr .. ], tmp2);
                     if (i > -1  &&  (i < j  ||  j == -1))  {
                        ++amt;
                        chptr += i;
                     }
                     else if (j > -1)  {
                        --amt;
                        chptr += j;
                     }
                  }
                  while ((i > -1  ||  j > -1)  &&  amt);
                  index = chptr;
                  chptr = -1;
               }
               while (amt  &&  ++lnptr < fsize);
               chptr = index;
            }
            else  {
               do  {
                  while ((i > -1  ||  j > -1)  &&  chptr  &&  amt)  {
                     i = strsrch(file[lnptr][0 .. --chptr], tmp2, -1 );
                     j = strsrch(file[lnptr][0 .. chptr], tmp, -1);
                     if (j > i)  {
                        --amt;
                        chptr = j;
                     }
                     else if (i > -1)  {
                        ++amt;
                        chptr = i;
                     }
                  }
                  if (lnptr)  chptr = strlen(file[lnptr - 1]);
                  i = 0;
               }
               while (amt  &&  lnptr--);
               chptr = j;
            }
            if (amt)  printf("No match found.\n");
            else  {
               i = showln;
               showln = 1;
               print_line(1);
               chptr = tmpch;
               lnptr = tmpln;
               showln = i;
            }
         }
         break;

      case "V":
         if (sizeof(clipboard))  {
            my_more("", clipboard, 0, 0, 0, 0, "");
            return;
         }
         else printf("Clipboard is empty.\n");
         break;

      case "D":
         if (tmpln != fsize)  {
            if (tmpln + amt > fsize)  {
               printf("Deleting up to end of file - ");
               amt = fsize - tmpln;
            }
            undo = ({ ({ ({ "I", tmpln,
                            file[tmpln .. tmpln + amt - 1] }) }) }) + undo;
            changed = 1;
            if (!tmpln)  file = file[amt .. ];
            else file = file[0 .. tmpln - 1] + file[tmpln + amt .. ];
            fsize -= amt;
            num_len = strlen(sprintf("%d", fsize + 1));
            if (tmpln + amt < lnptr)  lnptr -= amt;
            else if (lnptr >= tmpln)  {
               lnptr = tmpln;
               chptr = 0;
            }
            printf("%d line%s deleted.\n", amt, amt == 1 ? "" : "s");
         }
         else printf("Cannot delete beyond end of file.\n");
         break;

      /* Old MacDonald had a farm ... */
      case "E":
      case "I":
      case "e":
      case "i":
      case "A":
      case "a":
         if (diff  ||  sizeof(bits) > 2)  {
            get_new_text(bits[2 - diff], bits[0], 1, 1);
            return;
         }
         printf("]");
         input_to("get_new_text", 0, bits[0], 0, 0);
         return;

      case "C":
      case "M":
         if (tmpln != fsize)  {
            index = -1;
            if (sizeof(bits) > 2  &&
                ((index = to_int(bits[2]) - 1) < 0  ||
                 (index >= tmpln  &&  index < tmpln + amt)))  {
               printf("Invalid destination line.\n");
               break;
            }
            if (index > fsize)  index = fsize;
            if (tmpln + amt > fsize)  {
               printf("Copying up to end of file - ");
               amt = fsize - tmpln;
            }
            clipboard = file[tmpln .. tmpln + amt - 1];
            if (bits[0] == "M")  {
               changed = 1;
               undo = ({ ({ ({ "I", tmpln,
                               file[tmpln .. tmpln + amt - 1] }) }) }) +
                      undo;
               if (!tmpln)
                  file = file[amt .. ];
               else
                  file = file[0 .. tmpln - 1] + file[tmpln + amt .. ];
               if (tmpln + amt < lnptr)
                  lnptr -= amt;
               else if (lnptr >= tmpln)  {
                  lnptr = tmpln;
                  chptr = 0;
               }
               if (tmpln < index)  index -= amt;
               if (index >= 0)  {
                  if (!index)
                     file = clipboard + file;
                  else
                     file = file[0 .. index - 1] + clipboard +
                            file[index .. ];
                  if (index <= lnptr)  lnptr += amt;
                  undo[0] = ({ ({ "D", index, amt }) }) + undo[0];
                  printf("%d line%s moved.\n", amt, amt == 1 ? "" : "s");
               }
               else  {
                  fsize -= amt;
                  num_len = strlen(sprintf("%d", fsize + 1));
                  printf("%d line%s copied and deleted.\n",
                         amt, amt == 1 ? "" : "s");
               }
            }
            else  {
               if (index >= 0)  {
                  changed = 1;
                  if (!index)
                     file = clipboard + file;
                  else
                     file = file[0 .. index - 1]+ clipboard +
                            file[index .. ];
                  fsize += amt;
                  num_len = strlen(sprintf("%d", fsize + 1));
                  if (index <= lnptr)  lnptr += amt;
                  undo = ({ ({ ({ "D", index, amt }) }) }) + undo;
                  printf("%d line%s copied and pasted.\n",
                         amt, amt == 1 ? "" : "s");
               }
               else printf("%d line%s copied.\n", amt, amt == 1 ? "" : "s");
            }
         }
         else printf("Cannot copy beyond end of file.\n");
         break;

      case "c":
      case "m":
         if (rexp_flag == 1  &&  bits[0] == "c")  {
            printf("Clipboard may only be initialized with literal "
                   "strings.\n");
            break;
         }
         else if (diff  &&  bits[0] == "c")  {
            if (amt = strlen(bits[1]))
               clipboard = ({ bits[1] });
            else  {
               printf("No point in copying a null string.\n");
               break;
            }
         }
         else  {
            if (lnptr == fsize)  {
               printf("Cannot copy beyond end of file.\n");
               break;
            }
            else if (tmpch == (j = strlen(file[lnptr])))  {
               printf("Cannot copy beyond end of line.\n");
               break;
            }
            if (rexp_flag == 1)  {
               tmp = catch(scrap = reg_assoc(file[lnptr],
                                             ({ bits[1] }), ({ "1" }))[0]);
               if (tmp)  {
                  printf("REGEXP error: %s", tmp[1 .. ]);
                  break;
               }
               else  {
                  if (sizeof(scrap) != 3)  {
                     printf("No match found for regular expression \"%s"
                            "\".\n", bits[1]);
                     break;
                  }
                  else  {
                     tmpch = strlen(scrap[0]);
                     amt = strlen(scrap[1]);
                  }
               }
            }
            else if (diff)  {
               if ((i = strsrch(file[lnptr][tmpch .. ], bits[1])) > -1)  {
                  tmpch += i;
                  amt = strlen(bits[1]);
               }
               else  {
                  if (strlen(bits[1]) == 0)
                     printf("Cannot search for null string.\n");
                  else
                     printf("'%s' not found.\n", bits[1]);
                  break;
               }
            }
            else if ((tmpch + amt - 1) >= j)  {
               printf("Copying up to end of line -  ");
               amt = j - tmpch;
            }
            clipboard = ({ file[lnptr][tmpch .. tmpch + amt - 1] });
         }
         printf("%d character%s copied", amt, amt == 1 ? "" : "s");
         if (bits[0] == "m")  {
            printf(" and deleted.\n");
            undo = ({ ({ ({ "E", lnptr, ({ file[lnptr] }) }) }) }) + undo;
            if (!tmpch)
               file[lnptr] = file[lnptr][amt .. ];
            else
               file[lnptr] = file[lnptr][0 .. tmpch - 1] +
                             file[lnptr][tmpch + amt .. ];
            if (tmpch + amt < chptr)
               chptr -= amt;
            else if (chptr >= tmpch)
               chptr = tmpch;
            changed = 1;
            print_line(1);
         }
         else printf(".\n");
         break;

      case "p":
         if (sizeof(clipboard) == 1)  {
            if (lnptr == fsize)  {
               file = file[0 .. fsize - 1] +
                      ({ clipboard[0] , "End of file." });
               ++fsize;
               num_len = strlen(sprintf("%d", fsize + 1));
               undo = ({ ({ ({ "D", lnptr, 1 }) }) }) + undo;
            }
            else  {
               undo = ({ ({ ({ "E", lnptr, ({ file[lnptr] }) }) }) }) +
                      undo;
               if (!tmpch)
                  file[lnptr] = clipboard[0] + file[lnptr];
               else
                  file[lnptr] = file[lnptr][0 .. tmpch - 1] +
                                clipboard[0] +
                                file[lnptr][tmpch .. ];
            }
            if (tmpch <= chptr)  chptr += strlen(clipboard[0]);
            changed = 1;
            print_line(1);
            break;
         }
         /* No break here */

      case "P":
         if (i = sizeof(clipboard))  {
            undo = ({ ({ ({ "D", tmpln, i }) }) }) + undo;
            changed = 1;
            if (!tmpln)
               file = clipboard + file;
            else
               file = file[0 .. tmpln - 1] + clipboard +
                      file[tmpln ..];
            printf("%d line%s pasted.\n", i, i == 1 ? "" : "s");
            fsize += i;
            num_len = strlen(sprintf("%d", fsize + 1));
            if (tmpln <= lnptr)  lnptr += i;
         }
         else printf("Clipboard is empty.\n");
         break;

      case "O":
      case "ed":
         if (index)  {
            end = -1;
            i = strsrch(file[tmpln], ' ');
            if (i > 0)  {
               if (file[tmpln][0 .. i - 1] == "#define")  {
                  j = strsrch(file[tmpln][i + 1 .. ], ' ');
                  if (j > -1)  {
                     tmp2 = file[tmpln][i + j + 2 .. ];
                     end = i + j + 1;
                  }
                  else
                     tmp2 = file[tmpln];
               }
               else {
                  tmp2 = file[tmpln][i + 1 .. ];
                  end = i;
                  j = strsrch(tmp2, ' ');
                  if (j > 0  &&  tmp2[0 .. j - 1] == "inherit")  {
                     tmp2 = tmp2[j + 1 .. ];
                     end += j + 1;
                  }
               }
            }
            else tmp2 = file[tmpln];
            tmp2 = strip_junk(expand_macros(tmp2, sort_array(keys(defs), -1)));
            if (end > -1)  tmp2 = file[tmpln][0 .. end] + tmp2;
            if (sscanf(tmp2, "#include <%s>", tmp) == 1)
               tmp = "/include/" + tmp;
            else if (sscanf(tmp2, "#include \"%s\"", tmp) == 1  ||
                     sscanf(tmp2, "inherit \"%s\"", tmp) == 1  ||
                     sscanf(tmp2, "nosave inherit \"%s\"", tmp) == 1)
            {
               if (tmp[0] != '/')  {
                  i = strsrch(name, '/', -1);
                  tmp = name[0 .. i] + tmp;
               }
               if (strlen(tmp) > 2  &&  tmp[<2] != '.')  tmp += ".c";
            }
            else  {
               printf("Line %d does not contain a recognizable filename.\n",
                      tmpln + 1);
               break;
            }
         }
         else if (!diff  &&  sizeof(bits) > 1)  {
            if (amt < 0)  amt = sizeof(open_history) + amt;
            if (amt > sizeof(open_history)  ||  amt < 1)  {
               printf("Invalid choice.\n");
               break;
            }
            else tmp = open_history[amt - 1];
         }
         else tmp = sizeof(bits) > 1 ? bits[1] : "";

         if (changed)  {
            printf("Current file has been changed.  Save now? (Y/N/A):]");
            input_to("get_new_text", 0, "O", 0, 0);
            newname = tmp;
            return;
         }
         if (open_file(tmp) == -1)
            return;
         break;

      case "F":
         if (!this_player()->query_creator())
            printf("This command is only available to creators.\n");
         else if ((i = sizeof(bits)) == 1  ||  (i == 2  &&  !diff))
            printf("Must specify a filename.\n");
         else  {
            tmp = this_player()->get_path(bits[2 - diff]);
            if ((amt = file_size(tmp)) == -2)
               printf("'%s' is a directory.\n", tmp);
            else if (amt == -1)
               printf("'%s' does not exist.\n", tmp);
            else  {
               if (!tmpln)
                  file = explode(read_bytes(tmp), "\n") + file;
               else file = file[0 .. tmpln - 1] +
                           explode(read_bytes(tmp), "\n") +
                           file[tmpln .. ];
               amt = fsize;
               fsize = sizeof(file) - 1;
               num_len = strlen(sprintf("%d", fsize + 1));
               printf("File '%s' inserted. (%d line%s)\n",
                      tmp, fsize - amt, (fsize - amt) == 1 ? "" : "s");
               changed = 1;
               undo = ({ ({ ({ "D", tmpln, fsize - amt }) }) }) + undo;
            }
         }
         break;

      case "L":
         my_more("", file[tmpln .. tmpln + amt - 1 + (tmp2 == ">")],
                 tmpln, showln, highlight, 0, "");
         return;

      case "f":
         lnptr = tmpln + amt * rows - amt;
         if (lnptr > fsize)  lnptr = fsize;
         my_more("", file[tmpln .. lnptr], tmpln, showln, highlight,
                 amt, "");
         return;

      case "b":
         lnptr = tmpln - (amt * rows - amt - 1);
         if (lnptr < 0)  {
            diff = lnptr;
            lnptr = 0;
         }
         else diff = 0;
         scrap = file[lnptr .. tmpln];
         i = j = 0;
         if (showln)  {
            foreach (tmp in scrap)  {
               ++i;
               diff += (strlen(sprintf("%'.'*d] %s", num_len, i + lnptr,
                                       tmp)) - 1) / cols;
            }
            while (diff > 0)  {
               diff -= (strlen(sprintf("%'.'*d] %s", num_len, lnptr + j + 1,
                                       scrap[j])) - 1) / cols + 1;
               ++j;
            }
         }
         else  {
            foreach (tmp in scrap)  diff += (strlen(tmp) - 1) / cols;
            while (diff > 0)
               diff -= (strlen(scrap[j++]) - 1) / cols + 1;
         }
         lnptr += j;
         if (lnptr + 1 < in_comment)  in_comment = 0;
         if (lnptr >= tmpln)  {
            my_more("", ({ file[tmpln] }), tmpln, showln, highlight, 1, "");
            lnptr = tmpln;
         }
         else my_more("", scrap[j .. ], lnptr, showln, highlight, 0, "");
         return;

      case "S":
         if (sizeof(bits) < 3)
            printf("Must specify search string.\n");
         else if (strlen(bits[2]) == 0)
            printf("Cannot have a null search string.\n");
         else if (tmpln != fsize)  {
            if (tmpln + amt > fsize)
               printf("Searching up to end of file.\n");
            i = 0;
            scrap = ({ });
            if (rexp_flag)  {
               if (tmp = catch(rexp = regexp(file[tmpln .. tmpln + amt - 1],
                                             bits[2], 1)))
               {
                  printf("REGEXP error: %s", tmp[1 .. ]);
                  break;
               }
               else  {
                  for (i = 0; i < sizeof(rexp); i += 2)  {
                     scrap += ({ (rexp[i + 1] + tmpln) + "] " + rexp[i] });
                  }
               }
            }
            else {
               foreach (tmp in file[tmpln .. tmpln + amt - 1])  {
                  ++i;
                  if (strsrch(tmp, bits[2]) > -1)
                     scrap += ({ (i + tmpln) + "] " + tmp });
               }
            }
            if (sizeof(scrap) == 0)  {
               if (rexp_flag)  {
                  printf("No matches for regular expression \"%s"
                         "\".\n", bits[2]);
               }
               else printf("\"%s\" not found.\n", bits[2]);
            }
            else  {
               my_more("", scrap, 0, 0, 0, 0, "");
               return;
            }
         }
         else printf("Cannot search beyond end of file.\n");
         break;

      case "R":
         if ((i = sizeof(bits)) < 3  ||  (i == 3  &&  !diff))
            printf("Must specify both search and replace strings.\n");
         else if (strlen(bits[2 - diff]) == 0)
            printf("Cannot have a null search string.\n");
         else if (tmpln != fsize)  {
            if (tmpln + amt > fsize)
               printf("Replacing up to end of file.\n");
            if (diff  ||  rexp_flag == 1)  bits = ({ "" }) + bits;
            j = index = 0;
            if (rexp_flag)  {
               tmp = catch(regexp(file[tmpln], bits[2]));
               if (tmp)  {
                  printf("REGEXP error: %s", tmp[1 .. ]);
                  break;
               }
               // You are not expected to understand this.
               search_func =
               (: sizeof($4 = filter_regexp(reg_assoc($1, ({ $2 }),
                                                      ({ "1" }))[0])) > 1 ?
                  ({ sizeof($4) - 1, implode($4, $3) }) : ({ 0 }) :);
            }
            else  {
               replace(bits[2], "\\", "\\\\");
               replace(bits[3], "\\", "\\\\");
               search_func = (: sizeof($4 = explode($5 + $1 + $5, $2)) - 1 ?
                                ({ sizeof($4) - 1,
                                   implode($4, $3)[1 .. <2] }) : ({ 0 }) :);
               /* Get a unique character to tack on */
               tmp = sprintf("%c", ((bits[2][0] + 1) % 127) + 1);
            }

            foreach (tmp2 in file[tmpln .. tmpln + amt - 1])  {
               rexp = evaluate(search_func, tmp2, bits[2], bits[3], scrap,
                               tmp);
               if (rexp[0])  {
                  file[tmpln] = rexp[1];
                  if (tmpln == lnptr)  chptr = 0;
                  if (!index)  {
                     undo = ({ ({ ({ "E", tmpln, ({ tmp2 }) }) }) }) + undo;
                     index = j = 1;
                  }
                  else if (!j)  {
                     undo[0] += ({ ({ "E", tmpln, ({ tmp2 }) }) });
                     j = 1;
                  }
                  else undo[0][<1][2] += ({ tmp2 });
                  printf("%d instance%s replaced on line %d.\n",
                         rexp[0], rexp[0] == 1 ? "" : "s", tmpln + 1);
               }
               else j = 0;
               ++tmpln;
            }
            if (!index)  {
               if (rexp_flag)
                  printf("No match for regular expression \"%s"
                         "\".\n", bits[2]);
               else
                  printf("\"%s\" not found.\n", bits[2]);
            }
            else changed = 1;
         }
         else printf("Cannot replace beyond end of file.\n");
         break;

      case "r":
         if (sizeof(bits) < 3)
            printf("Must specify both search and replace strings.\n");
         else if (strlen(bits[1]) == 0)
            printf("Cannot have a null search string.\n");
         else if (lnptr != fsize)  {
            amt = 0;
            if (rexp_flag == 1)  {
               tmp = catch(scrap = reg_assoc(file[lnptr],
                                             ({ bits[1] }), ({ "1" }))[0]);
               if (tmp)  {
                  printf("REGEXP error: %s", tmp[1 .. ]);
                  break;
               }
               else if (sizeof(scrap) == 3)  {
                  tmpch = strlen(scrap[0]);
                  amt = strlen(scrap[1]);
               }
            }
            else if ((i = strsrch(file[lnptr][tmpch .. ], bits[1])) > -1)  {
               tmpch += i;
               amt = strlen( bits[1] );
            }
            if (amt)  {
               undo = ({ ({ ({ "E", lnptr, ({ file[lnptr] }) }) }) }) +
                      undo;
               if (!tmpch)
                  file[lnptr] = bits[2] + file[lnptr][amt .. ];
               else
                  file[lnptr] = file[lnptr][0 .. tmpch - 1] + bits[2] +
                                file[lnptr][tmpch + amt .. ];
               if (tmpch + amt < chptr)  chptr -= amt;
               else if (chptr >= tmpch)  chptr = tmpch;
               changed = 1;
               print_line(1);
            }
            else  {
               if (rexp_flag)
                  printf("No match found for regular expression \"%s"
                         "\".\n", bits[1]);
               else
                  printf("'%s' not found.\n", bits[1]);
            }
         }
         else  {
            printf("Cannot replace beyond end of file.\n");
         }
         break;

      case "T":
         if (sizeof(bits) == 1  ||  strlen(bits[1]) == 0)  {
            if (fsize == 0)  {
               printf("Congratulations!  Your empty file has no errors! ;)\n");
               break;
            }
            if (strlen(name) > 0)  {
               if (changed)  {
                  tmp = fsize ? implode(file[0 .. fsize - 1], "\n") + "\n"
                              : "";
                  i = strsrch(name, "/", -1);
                  if (i == -1)  tmp2 = "tmp_" + name;
                  else tmp2 = name[0 .. i] + "tmp_" + name[i + 1 .. ];
                  if (!write_file(tmp2, tmp))  {
                     printf("Couldn't write temporary file for test.\n");
                     break;
                  }
               }
               else tmp2 = name;
            }
            else tmp2 = "ArEaLlYdUmBnAmE.c";
         }
         else tmp2 = bits[1];
         catch(UPDATE->cmd(tmp2));
         if (changed  &&  !rm_file(tmp2))
            printf("Couldn't remove temporary file %s\n", tmp2);
         break;

      case "+":
         lnptr = (lnptr + amt) % (fsize + 1);
         if (highlight)  {
            if (lnptr != tmpln + 1)
               in_comment = 0;
         }
         chptr = 0;
         print_line(0);
         break;

      case "++":
         in_comment = 0;
         lnptr = fsize;
         chptr = 0;
         print_line(0);
         break;

      case "-":
         lnptr -= amt;
         while (lnptr < 0)  lnptr += fsize + 1;
         in_comment = 0;
         chptr = 0;
         print_line(0);
         break;

      case "h":
         if (highlight = !highlight)
            printf("Syntax highlighting turned on.\n");
         else printf("Syntax highlighting turned off.\n");

         break;

      case "w":
      case "W":
         if (mode_flag  &&  sizeof(bits) > 1  &&  bits[1] != ""  &&
             name != (newname = this_player()->get_path(bits[1])))
         {
            this_player()->set_in_editor(name = newname);
            changed = 1;
         }
         if (mode_flag  &&  bits[0] == "W")  {
            save_history();
         }
         if (save_file(bits[0], 0)  &&  bits[0] == "W")  return;
         break;

      case "N":
         showln = !showln;
         if (!showln)  printf("Line numbering turned off.\n");
         else printf("Line numbering turned on.\n");
         break;

      case "Q":
         printf("Quitting.\n");
         if (mode_flag)  save_history();
         this_player()->set_in_editor(0);
         this_player()->editor_do_quit(0);
         while (remove_call_out("defines") != -1)
            ;
         return;

      case "H":
      case "help":
         if (sizeof(bits) == 1)  tmp = mode_flag ? "main" : "p_main";
         else tmp = bits[1];
         if (member_array(tmp, AVAIL_CMDS +
                          ({ "main", "p_main", "strings", "modes" })) == -1)
            printf("Unknown command '%s'.\n", tmp);
         else if (tmp2 = read_bytes(HELPPATH + tmp + ".hlp"))  {
            my_more("", explode(tmp2, "\n"), 0, 0, 0, 0, "");
            return;
         }
         else printf("Sorry, no help available on \"%s\".  Go "
                     "holler at Presto.\n", tmp);
         break;

      case "U":
         if (diff = sizeof(undo) - 1)  {
            if (diff < amt)  {
               printf("Not that many commands to undo.  ");
               amt = diff;
            }
            for (i = 0; i < amt; i++)  {
               for (j = 0; j < sizeof(undo[i]); j++)  {
                  if (undo[i][j][0] == "I")  {
                     if (undo[i][j][1])
                        file = file[0 .. undo[i][j][1] - 1] +
                               undo[i][j][2] +
                               file[undo[i][j][1] .. ];
                     else file = undo[i][j][2] + file;
                     fsize += sizeof(undo[i][j][2]);
                     num_len = strlen(sprintf("%d", fsize + 1));
                     if (undo[i][j][1] <= lnptr)
                        lnptr += sizeof(undo[i][j][2]);
                  }
                  else if (undo[i][j][0] == "E")  {
                     if (undo[i][j][1])
                        file = file[0 .. undo[i][j][1] - 1] +
                               undo[i][j][2] +
                               file[undo[i][j][1] +
                                    sizeof(undo[i][j][2]) .. ];
                     else file = undo[i][j][2] +
                                 file[sizeof(undo[i][j][2]) .. ];
                     if (undo[i][j][1] <= lnptr  &&
                          lnptr < undo[i][j][1] + sizeof(undo[i][j][2]))
                        chptr = 0;
                  }
                  else  {
                     if (!undo[i][j][1])
                        file = file[undo[i][j][2] .. ];
                     else file = file[0 .. undo[i][j][1] - 1] +
                                 file[undo[i][j][1] + undo[i][j][2] .. ];
                     fsize -= undo[i][j][2];
                     num_len = strlen(sprintf("%d", fsize + 1));
                     if (undo[i][j][1] + undo[i][j][2] < lnptr)
                        lnptr -= undo[i][j][2];
                     else if (lnptr >= undo[i][j][1])  {
                        lnptr = undo[i][j][1];
                        chptr = 0;
                     }
                  }
               }
            }
            undo = undo[amt .. ];
            if (!changed)  changed = 1;
            else if (diff - amt == undo[<1])  changed = 0;
            printf("%d command%s undone.\n", amt, amt == 1 ? "" : "s");
         }
         else printf("Nothing to undo.\n");
         break;

      case "set":
         if (sizeof(bits) == 1  ||  bits[1] == "save")  {
            tmp = sprintf("tab spacing %d\ntab replacement %s\n"
                          "color keyword %s\ncolor comment %s\n"
                          "color number %s\ncolor operator %s\n"
                          "color string %s\ncolor type %s\n",
                          strlen(tab_str), tab_replace ? "on" : "off",
                          replace(keyw_color, "%^", " ")[0 .. <2],
                          replace(comm_color, "%^", " ")[0 .. <2],
                          replace(numb_color, "%^", " ")[0 .. <2],
                          replace(oper_color, "%^", " ")[0 .. <2],
                          replace(stri_color, "%^", " ")[0 .. <2],
                          replace(type_color, "%^", " ")[0 .. <2]);
            if (sizeof(bits) == 1)
               printf("Current settings:\n%s", tmp);
            else  {
               tmp += sprintf("history %s", implode(open_history[<10 .. ], " "));
               if (write_file("/w/" + this_player()->query_name() +
                              "/.magicrc", tmp, 1))
                  printf("Settings saved.\n");
               else printf("Settings could not be saved.\n");
            }
         }
         else if (sizeof(bits) < 4)
            printf("You must specify the setting to change and its value.  "
                   "See 'H set' for more help.\n");
         else  {
            if (bits[1] == "tab")  {
               if (bits[2] == "replacement")  {
                  if (bits[3] == "on")  tab_replace = 1;
                  else tab_replace = 0;
                  printf("Tab replacement turned %s.\n",
                         tab_replace ? "ON" : "OFF");
               }
               else if (bits[2] == "spacing")  {
                  i = to_int(bits[3]);
                  if (i > 0)  {
                     tab_str = "";
                     for (j = 0; j < i; j++)  {
                        tab_str += " ";
                     }
                     printf("Tab spacing set to %d.\n", i);
                  }
                  else printf("Tab spacing must be greater than 0.\n");
               }
               else printf("Invalid option for \"tab\".\n");
            }
            else if (bits[1] == "color")  {
               if (set_colors(bits[2 .. ]))  {
                  printf("%s color set to %s.\n",
                         capitalize(bits[2]), implode(bits[3 .. ], " "));
               }
               else printf("Invalid option '%s'.\n", bits[2]);
            }
            else printf("Invalid option '%s'.\n", bits[1]);
         }
         break;

      case "rot13":
         if (tmpln != fsize)  {
            for (i = 0; i < amt; i++)  {
               tmp = file[tmpln + i];
               for (j = 0; j < strlen(tmp); j++)  {
                  if (tmp[j] >= 'A'  &&  tmp[j] <= 'Z')
                     tmp[j] = ((13 + tmp[j] - 'A') % 26) + 'A';
                  else if (tmp[j] >= 'a' && tmp[j] <= 'z')
                     tmp[j] = ((13 + tmp[j] - 'a') % 26) + 'a';
                  else if (tmp[j] >= '0' && tmp[j] <= '9')
                     tmp[j] = ((5 + tmp[j] - '0') % 10) + '0';
               }
               file[tmpln + i] = tmp;
            }
            printf("%d line%s rot13ified.\n", amt, amt == 1 ? "" : "s");
         }
         else printf("Cannot rot13 beyond end of file.\n");
         break;

      case "#":
         if (defs_not_done)
            printf("Warning: Macros have not yet been fully processed.\n");
         if (sizeof(bits) > 1)  {
if (bits[1] == "ALL")  printf("%O\n", defs);
            if (undefinedp(defs[bits[1]]))
               printf("No definition for \"%s\".\n", bits[1]);
            else
               printf("%s\n", defs[bits[1]]);
         }
         else printf("Which macro do you want to look up?\n");
         break;

      default:
         printf("Something odd has happened.  Tell Presto.\n");
         break;
   }
   printf(":");
   input_to( "get_command" );
   return;
}  /* get_command() */


void get_new_text(string new_in, string cmd, int count, int cmdline)  {
   string new_in2;
   int len;

   if ((len = strlen(new_in) - 1) > -1  &&  new_in[0] == '\\'  &&  !cmdline)  {
      new_in2 = new_in[1 .. ];
      --len;
   }
   else new_in2 = new_in;

   if (tab_replace)  new_in2 = replace(new_in2, "\t", tab_str);

   switch (cmd)  {
      case "i":
         if (len > -1)  {
            changed = 1;
            if (lnptr < fsize)  {
               undo = ({ ({ ({ "E", lnptr, ({ file[lnptr] }) }) }) }) +
                      undo;
               if (!tmpch)  file[lnptr] = new_in2 + file[lnptr];
               else file[lnptr] = file[lnptr][0 .. tmpch - 1] + new_in2 +
                                  file[lnptr][tmpch .. ];
            }
            else  {
               undo = ({ ({ ({ "D", fsize, 1 }) }) }) + undo;
               if (!fsize)  file = ({ new_in2, "End of file." });
               else file = file[0 .. fsize - 1] +
                           ({ new_in2, "End of file." });
               ++fsize;
            }
            if (tmpch <= chptr)  chptr += len + 1;
            print_line(1);
         }
         break;

      case "I":
         if (new_in != "."  ||  cmdline)  {
            if (new_in == "W"  &&  !mode_flag)  {
               if (this_player()->query_name() == "dogbolter")
                  printf("No more secret message!\n");
               get_new_text("", "W", count, 0);
               return;
            }
            if (new_in == ".;W"  &&  this_player()->query_name() == "warrax")  {
               write("You did that on purpose, didn't you?\n");
               get_new_text("", "W", count, 0);
               return;
            }
            changed = 1;
            if (!tmpln)  file = ({ new_in2 }) + file;
            else file = file[0 .. tmpln - 1] + ({ new_in2 }) +
                        file[tmpln .. ];
            ++tmpln;
            if (!cmdline)  {
               printf("]");
               input_to("get_new_text", 0, "I", count + 1, 0);
               return;
            }
         }
         if (count)  {
            if (tmpln - count <= lnptr)  lnptr += count;
            printf("%d line%s added.\n", count, count == 1 ? "" : "s");
            fsize += count;
            undo = ({ ({ ({ "D", tmpln - count, count }) }) }) + undo;
         }
         break;

      case "a":
         if (len > -1)  {
            changed = 1;
            if (lnptr < fsize)  {
               undo = ({ ({ ({ "E", lnptr, ({ file[lnptr] }) }) }) }) +
                      undo;
               file[lnptr] = file[lnptr][0 .. tmpch] + new_in2 +
                             file[lnptr][tmpch + 1 .. ];
            }
            else  {
               undo = ({ ({ ({ "D", fsize, 1 }) }) }) + undo;
               if (!fsize)  file = ({ new_in2, "End of file." });
               else file = file[0 .. fsize - 1] +
                           ({ new_in2, "End of file." });
               ++fsize;
            }
            print_line(1);
         }
         break;

      case "A":
         if (new_in != "."  ||  cmdline)  {
            changed = 1;
            if (tmpln == fsize)  --tmpln;
            file = file[0 .. tmpln] + ({ new_in2 }) +
                   file[tmpln + 1 .. ];
            ++tmpln;
            ++fsize;
            if (!cmdline)  {
               printf("]");
               input_to("get_new_text", 0, "A", count + 1, 0);
               return;
            }
         }
         if (count)  {
            printf("%d line%s added.\n", count, count == 1 ? "" : "s");
            undo = ({ ({ ({ "D", tmpln - count + 1, count }) }) }) + undo;
         }
         break;

      case "E":
         if (new_in != "."  ||  cmdline)  {
            changed = 1;
            if (tmpln < fsize)  {
               if (!count  ||  cmdline)
                  undo = ({ ({ ({ "E", tmpln, ({ file[tmpln] }) }) }) }) +
                         undo;
               else undo[0][0][2] += ({ file[tmpln] });
            }
            else  {
               if (!count  ||  cmdline)
                  undo = ({ ({ ({ "D", tmpln, 1 }) }) }) + undo;
               else if (undo[0][0][0] == "E")
                  undo[0] = ({ ({ "D", tmpln, 1 }) }) + undo[0];
               else ++undo[0][0][2];
               file += ({ "End of file." });
               ++fsize;
            }
            file[tmpln] = new_in2;
            if (tmpln == lnptr)  chptr = 0;
            ++tmpln;
            if (!cmdline)  {
               printf("]");
               input_to("get_new_text", 0, "E", count + 1, 0);
               return;
            }
         }
         if (count)
            printf("%d line%s changed.\n", count, count == 1 ? "" : "s");

         break;

      case "e":
         if (len > -1)  {
            changed = 1;
            if (lnptr < fsize)  {
               undo = ({ ({ ({ "E", lnptr, ({ file[lnptr] }) }) }) }) +
                      undo;
               if (!tmpch)
                  file[lnptr] = new_in2 + file[lnptr][len + 1 .. ];
               else file[lnptr] = file[lnptr][0 .. tmpch - 1] +
                                  new_in2 +
                                  file[lnptr][tmpch + len + 1 .. ];
            }
            else  {
               if (!fsize)  file = ({ new_in2, "End of file." });
               else file = file[0 .. fsize - 1] +
                           ({ new_in2, "End of file." });
               undo = ({ ({ ({ "D", fsize, 1 }) }) }) + undo;
               ++fsize;
            }
            print_line(1);
         }
         break;

      case "w":
      case "W":
         if (len > -1)  {
            new_in2 = replace(new_in2, ({ " ", "", "\t", "" }));
            name = this_player()->get_path(new_in2);
            this_player()->set_in_editor(name);
            if (save_file(cmd, 0))  {
               if (count)  {
                  if (!open_file(newname)  &&  newname == "...")
                     return;
                  if (member_array(name, open_history) == -1)
                     open_history += ({ name });
               }
               else if (cmd == "W")  return;
            }
         }
         else printf("Save canceled.\n");
         break;

      case "O":
         if (cmdline)  {  
            len = to_int(new_in2);
            new_in2 = "";
            if (len == 0)  {
               printf("Cancelled.\n");
               if (file == 0)  {
                  this_player()->editor_do_quit(0);
                  return;
               }
            }
            else if (len > sizeof(open_history) - count)  {
               printf("Invalid choice.\n");
               if (file == 0)  {
                  this_player()->editor_do_quit(0);
                  return ;
               }
            }
            else new_in2 = open_history[len - 1];
            open_history = open_history[count .. ];
            if (new_in2 != "")  open_file(new_in2);
         }
         else  { 
            if (new_in2 == "y"  ||  new_in2 == "Y")  {
               if (save_file("w", 1))  {
                  if (!changed)  {
                     if (!open_file(newname)  &&  newname == "...")
                        return;
                  }
                  else return;
               }
            }
            else if (new_in2 == "a"  ||  new_in2 == "A")
               printf("Open aborted.\n");
            else if (new_in2 == "n"  ||  new_in2 == "N") {
               printf("OK, you're the boss.\n");
               open_file(newname);
            }
            else  {
               printf("(Y)es, (N)o, or (A)bort?:]");
               input_to("get_new_text", 0, "O", count, 0);
               return;
            }
         }
         break;

      default:
         printf("How in the hell did you get here?\n");
         break;
   }
   printf(":");
   input_to("get_command");
   num_len = strlen(sprintf("%d", fsize + 1));
   return;
}  /* get_new_text() */


private int open_file(string filename)  {
   object *things;
   string  oldname;
   string  tmp;
   string *file_list;
   int     i;
   int     len;

   if (strlen(filename))  {
      if (mode_flag)  {
         if (filename == "...")  {
            if (!sizeof(open_history))  {
               printf("No files in your history.\n:");
               input_to("get_command");
               return -1;
            }
            else  {
               len = strlen(sprintf("%d", sizeof(open_history)));
               for (i = 0; i < sizeof(open_history); i++)  {
                  if (open_history[i] == name)
                     printf("%*d: %s (current file)\n", len, i + 1,
                            open_history[i]);
                  else
                     printf("%*d: %s\n", len, i + 1, open_history[i]);
               }
               printf("Choose file (enter nothing to cancel):] ");
               input_to("get_new_text", 0, "O", 0, 1);
               return -1;
            }
         }
         else if (sizeof(file_list =
                         get_dir(this_player()->get_path(filename))) > 1)  {
            i = strsrch(filename, '/', -1);
            if (i > -1)  filename = filename[0 .. i];
            else filename = "./";
            len = strlen(sprintf("%d", sizeof(file_list)));
            for (i = 0; i < sizeof(file_list); i++)  {
               if (file_list[i] == name)
                  printf("%*d: %s (current file)\n", len, i + 1, file_list[i]);
               else
                  printf("%*d: %s\n", len, i + 1, file_list[i]);
               file_list[i] = filename + file_list[i];
            }
            open_history = file_list + open_history;
            printf("Choose file (enter nothing to cancel):] ");
            input_to("get_new_text", 0, "O", i, 1);
            return -1;
         }
         else if (sizeof(things = WIZ_PRESENT->
                         wiz_present(filename, this_player())) == 1)  {
            oldname = this_player()->get_path(filename);
            filename = file_name(things[0]);
            sscanf(filename, "%s#%*s", filename);
            if (file_size(filename) == -2  ||  filename + ".c" == oldname)
               filename = oldname;
            else if (file_size(filename) == -1)  filename += ".c";
         }

         filename = this_player()->get_path(filename);
         if (file_size(filename) == -2)  {
            printf("\"%s\" is a directory.\n", filename);
            return 0;
         }
      }
      if (file_size(filename) == -1)  {
         if (mode_flag)  {
            if (filename != TMP_FILE)
               printf("Opening new file '%s'.\n", filename);
            else
               printf("Opening new file.\n");
         }
         file = ({ "End of file." });
         fsize = 0;
         this_player()->set_in_editor(filename);
      }
      else  {
         tmp = read_bytes(filename);
         if (stringp(tmp)) {
            file = explode(tmp, "\n") + ({ "End of file." });
            fsize = sizeof(file) - 1;
         }
         else {
            file = ({ "End of file." });
            fsize = 0;
         }
         this_player()->set_in_editor(filename);
         if (mode_flag)  {
            printf("%s opened", filename);
            if (!this_object()->write_permission(filename))
               printf(" (read only)");
            printf(".  (%d line%s, %d character%s)\n",
                   fsize, fsize == 1 ? "" : "s",
                   file_size(filename), file_size(filename) == 1 ? "" : "s");
         }
      }

      if (mode_flag)  {
         i = member_array(filename, open_history);
         if (i == -1)
            open_history += ({ filename });
         else if (i == 0)
            open_history = open_history[1 .. ] + ({ filename });
         else
            open_history = open_history[0 .. i - 1] +
                           open_history[i + 1 .. ] + ({ filename });
      }
   }
   else  {
      printf("Opening new file.\n");
      file = ({ "End of file." });
      fsize = 0;
      this_player()->set_in_editor("New file");
   }
   if (filename == ""  || (strlen(filename) > 2  &&
       (filename[<2 .. ] == ".h"  ||  filename[<2 .. ] == ".c")))
      highlight = 1;
   else
      highlight = 0;
   name = filename;
   lnptr = chptr = tmpln = tmpch = changed = 0;
   undo = ({ 0 });
   num_len = strlen(sprintf("%d", fsize + 1));
   in_string = 0;
   in_comment = 0;
   if (mode_flag)  {
      defs = ([ ]);
      defs_not_done = 1;
      while (remove_call_out("defines") != -1)
         ;
      call_out("defines", 1, name);
   }
   return 1;
}  /* open_file() */


private int save_file(string cmd, int open_pending)  {
   string tmp;
   string ftext;

   if (changed)  {
      if (strlen(name) == 0)  {
         printf("Enter a name for this file (enter nothing to cancel):]");
         input_to("get_new_text", 0, cmd, open_pending, 0);
         return 1;
      }
      ftext = fsize ? implode(file[0 .. fsize - 1], "\n") + "\n" : "";
      if (mode_flag)  {
         tmp = read_bytes(name);
         if (tmp  &&  !this_object()->rm_file(name))  {
            printf("Could not overwrite old file.\n");
            return 0;
         }
         else if (!write_file(name, ftext))  {
            printf("Could not write file '%s'.\n", name);
            if (tmp  &&  !write_file(name, tmp))
               printf("Could not restore the old version either.  Uh-oh.\n");
            return 0;
         }
         else  {
            changed = 0;
            printf("File '%s' saved.\n", name);
            undo[<1] = sizeof(undo) - 1;
         }
      }
   }
   else  {
      printf("No changes made; nothing saved.\n");
      ftext = "";
   }
   if (cmd == "W")  {
      this_player()->set_in_editor(0);
      this_player()->editor_do_quit(mode_flag || strlen(ftext) == 0 ? 0 :
                                    ftext);
   }
   return 1;
}  /* save_file() */


void my_more(string input, string *text, int startln, int number, int hilite,
             int pages, string xtratxt)
{
   int    i;
   int    j;
   int    k;
   int    len;
   int    limit;
   int    lines;
   int    oldlines;
   string junk;

   if (input == "q"  ||  input == "Q")  {
      printf(":");
      input_to("get_command");
      return;
   }
   i = lines = limit = 0;
   j = sizeof(text);
   do  {
      oldlines = lines;
      k = cols;
      if ((len = strlen(xtratxt)) == 0)  {
         junk = replace((number ? sprintf("%'.'*d] %s", num_len, 1 + startln++,
                                          text[i++])
                                : text[i++]), "\t", "\\TAB\\", "%", "%%");
//junk = replace(junk, "%", "%%");
//write("junk == " + junk + "\n");
         len = strlen(junk);

         ++lines;
         while (k < len)  {
            junk = junk[0 .. k - 1] + "\n" + junk[k .. ];
            ++lines;
            ++len;
            k += cols + 1;
         }
         if (hilite)
            junk = highlight(junk, startln - 1, number, lines >= rows);
      }
      else  {
         junk = xtratxt;
         ++lines;
         limit = 0;
         while ((k = strsrch(junk[limit .. ], "\n")) > -1)  {
            limit += k + 1;
            ++lines;
         }
         xtratxt = "";
      }

      if (lines < rows)  {
         if (len == 0)  printf("\n");
         else printf("%s\n", junk);
         len = 0;
      }
      else  {
         limit = 0;
         for (k = 0; k < rows - oldlines - 1; k++)  {
            limit += strsrch(junk[limit .. ], "\n") + 1;
         }
         xtratxt = junk[limit .. ];
         printf("%s", junk[0 .. limit - 1]);
      }
   }
   while (i < j  &&  lines < rows - 1);
   if ((i < j  ||  len)  &&  --pages)  {
      write("%^RESET%^MORE... enter 'q' to stop, anything else to continue:");
      input_to("my_more", 0, text[i .. ], startln, number, hilite, pages,
               xtratxt);
   }
   else  {
      if (i < j  &&  !pages)  lnptr -= j - i;
      write("%^RESET%^:");
      input_to("get_command");
   }
   return;
}  /* my_more() */


private void print_line(int show_ptr)  {
   string tmp;
   int    i;
   int    j;
   int    chr;
   int    tchr;
   int    len;

   chr = chptr;
   if (showln)  {
      tmp = sprintf("%'.'*d] %s", num_len, lnptr + 1, file[lnptr]);
      chr += num_len + 2;
   }
   else tmp = file[lnptr];

   tchr = chr;
   if (chr)  {
      chr += 4 * (chr - strlen(replace(tmp[0 .. chr - 1], "\t", "")));
   }
   if (tchr < strlen(tmp)  &&  tmp[tchr] == '\t')  chr += 2;

   tmp = replace(tmp, "\t", "\\TAB\\", "%", "%%");

   len = strlen(tmp);
   j = cols;
   while (j < len)  {
      tmp = tmp[0 .. j - 1] + "\n" + tmp[j .. ];
      ++len;
      j += cols + 1;
   }
   tmp += "\n";

   if (in_comment == lnptr + 1)
      in_comment = 0;

   if (!show_ptr)  {
      if (highlight)  {
         printf("%s", highlight(tmp, lnptr, showln, 0));
      }
      else  {
         printf("%s", tmp);
      }
   }
   else  {
//      if (this_player()->query_cur_term() == "ansi")  {
//         tmp = this_player()->fix_string(tmp[0 .. chr - 1] + "%^REVERSE%^" + tmp[chr .. chr] +  tmp[chr + 1 .. ]);
//         if (highlight)  tmp = highlight(tmp, lnptr, showln, 1);
//         printf("%s", tmp);
//      }
//      else  {
      if (highlight)  tmp = highlight(tmp, lnptr, showln, 1);
      i = chr / cols + 1;
      tchr = 0;
      for (j = 0; j < i; j++)
         tchr += strsrch(tmp[tchr .. ], "\n") + 1;
      printf("%s", tmp[0 .. tchr - 1]);
      if (chr % cols)  {
          write("                                                           "
                "                                                           "
                "                                          "
                [0 .. chr % cols - 1] + "%^RESET%^^\n");
      }
      else write("%^RESET%^^\n");
      printf("%s", tmp[tchr .. ]);
//      }
   }

   return;
}  /* print_line() */


private string color_word(string word,
                          int ref if_flag, int ref include_flag,
                          int ref type_flag, int ref class_flag)  {
   string newword;
   int    i;

   include_flag = 0;
   type_flag = 0;

   if (strlen(newword = replace(word, "\n", "")) != 0)  {
      if (newword[0] >= '0'  &&  newword[0] <= '9')  {
         word = numb_color + word + "%^RESET%^";
      }
      else switch (newword)  {
         case "#include" :
            include_flag = 1;
         case "#define"  :
         case "#ifdef"   :
         case "#ifndef"  :
         case "#undef"   :
         case "#else"    :
         case "#elif"    :
         case "#endif"   :
         case "#pragma"  :
         case "#echo"    :
         case "varargs"  :
         case "protected":
         case "private"  :
         case "public"   :
         case "nosave"   :
         case "nomask"   :
         case "if"       :
         case "while"    :
         case "for"      :
         case "foreach"  :
         case "in"       :
         case "switch"   :
         case "return"   :
         case "do"       :
         case "else"     :
         case "case"     :
         case "break"    :
         case "default"  :
         case "continue" :
         case "inherit"  :
         case "new"      :
         case "efun"     :
            word = keyw_color + word + "%^RESET%^";
            if (strlen(word) != strlen(newword))  {  /* embedded newline */
               i = strsrch(word, "\n");
               word = word[0 .. i] + keyw_color + word[i + 1 .. ];
            }
            if_flag = 0;
            break;

         /* This is so "#if defined(BLAH)" is colored correctly */
         case "#if"      :
            if_flag = 1;
            word = keyw_color + word + "%^RESET%^";
            if (strlen(word) != strlen(newword))  {  /* embedded newline */
               i = strsrch(word, "\n");
               word = word[0 .. i] + keyw_color + word[i + 1 .. ];
            }
            if_flag = 1;
            break;

         case "defined"  :
            if (if_flag)  {
               word = keyw_color + word + "%^RESET%^";
            }
            if_flag = 0;
            break;

         case "class"    :
            class_flag = 1;
            word = type_color + word + "%^RESET%^";
            if (strlen(word) != strlen(newword))  {  /* embedded newline */
               i = strsrch(word, "\n");
               word = word[0 .. i] + type_color + word[i + 1 .. ];
            }
            break;

         case "int"      :
         case "string"   :
         case "mixed"    :
         case "object"   :
         case "float"    :
         case "mapping"  :
         case "function" :
         case "buffer"   :
         case "ref"      :
            type_flag = 1;
         case "void"     :
            word = type_color + word + "%^RESET%^";
            if (strlen(word) != strlen(newword))  {  /* embedded newline */
               i = strsrch(word, "\n");
               word = word[0 .. i] + type_color + word[i + 1 .. ];
            }

         default         :
            if (class_flag)  {
               word = type_color + word + "%^RESET%^";
               if (strlen(word) != strlen(newword))  {  /* embedded newline */
                  i = strsrch(word, "\n");
                  word = word[0 .. i] + type_color + word[i + 1 .. ];
               }
               type_flag = 1;
               class_flag = 0;
            }
            break;
      }
   }
   return word;
} /* color_word() */


private string *boom(string str, int linenum, int last_line)  {
   int     i;
   int     j;
   int     k;
   int     last;
   int     count;
   int     sep_flag = 0;
   int     op_flag = 0;
   int     split;
   int     if_flag;
   int     include_flag;
   int     type_flag;
   int     class_flag;
   string *shrapnel = ({ });

   last = 0;
   if_flag = 0;
   include_flag = 0;

   for (i = 0; i < strlen(str); i++)  {
      if (in_comment)  {
         split = 0;
         j = strsrch(str[i .. ], "*/");
         if (j == -1)  {
            split = 1;
            j = strsrch(str[i .. ], "*\n/");
         }
         if (j == -1)  {
            shrapnel += ({ comm_color + str[last .. ] + "%^RESET%^" });
            i = strlen(str) - 1;
         }
         else  {
            in_comment = 0;
            shrapnel += ({ comm_color + str[last .. i + j + 1 + split] +
                           "%^RESET%^" });
            i += j + 1 + split;
         }
         if (last_line)  {
            shrapnel[<1] = replace(shrapnel[<1], "\n", "\n" + comm_color);
         }
         sep_flag = op_flag = 0;
         last = i + 1;
      }
      /* Try to detect strings... */
      else if (in_string  ||  str[i] == DQUOTES)  {
         if (i != last)  {
            shrapnel += ({ str[last .. i - 1] });
         }
         last = i;
         while (1)  { /* Don't worry, we'll break out eventually. */
            j = strsrch(str[i + 1 .. ], DQUOTES);
            if (j == -1)  {
               shrapnel += ({ stri_color + str[last .. ] + "%^RESET%^" });
               i = strlen(str) - 1;
               in_string = 1;
               break;
            }
            else  {
               k = i + j;
               count = split = 0;
               while (k > -1  &&  !split)  {
                  if (str[k] == '\\')  {
                     --k;
                     ++count;
                  }
                  else if (str[k] == '\n')  {
                     --k;
                  }
                  else split = 1;
               }
               i += j + 1;
               if (count % 2 == 0)  {
                  shrapnel += ({ stri_color + str[last .. i] +
                                 "%^RESET%^" });
                  in_string = 0;
                  break;
               }
            }
         }
         if (last_line)  {
            shrapnel[<1] = replace(shrapnel[<1], "\n", "\n" + stri_color);
         }
         sep_flag = op_flag = 0;
         last = i + 1;
      }
      else if (str[i] == SQUOTES)  {
         if (i != last)  {
            shrapnel += ({ str[last .. i - 1] });
         }
         last = i;
         while (1)  {
            j = strsrch(str[i + 1 .. ], SQUOTES);
            if (j == -1)  {  /* Must be a syntax error... */
               shrapnel += ({ stri_color + str[last .. ] + "%^RESET%^" });
               i = strlen(str) - 1;
               break;
            }
            else  {
               k = i + j;
               count = split = 0;
               while (k > -1  &&  !split)  {
                  if (str[k] == '\\')  {
                     --k;
                     ++count;
                  }
                  else if (str[k] == '\n')  {
                     --k;
                  }
                  else split = 1;
               }
               i += j + 1;
               if (count % 2 == 0)  {
                  /* special case: ''' */
                  if (i == last + 1  &&  last + 2 < strlen(str)  &&
                      str[last + 2] == SQUOTES)
                  {
                     shrapnel += ({ stri_color + str[last .. last + 2] +
                                    "%^RESET%^" });
                     ++i;
                  }
                  else  {
                     shrapnel += ({ stri_color + str[last .. i] +
                                    "%^RESET%^" });
                  }
                  break;
               }
            }
         }
         if (last_line)  {
            shrapnel[<1] = replace(shrapnel[<1], "\n", "\n" + stri_color);
         }
         sep_flag = op_flag = 0;
         last = i + 1;
      }
      else if (str[i] == LESS  &&  include_flag)  {
         if (i != last)  {
            shrapnel += ({ str[last .. i - 1] });
         }
         j = strsrch(str[i + 1 .. ], GREATER);
         if (j == -1)  {
            shrapnel += ({ stri_color + str[i .. ] + "%^RESET%^" });
            i = strlen(str) - 1;
         }
         else  {
            shrapnel += ({ stri_color + str[i .. i + j + 1] + "%^RESET%^" });
            i += j + 1;
         }
         if (last_line)  {
            shrapnel[<1] = replace(shrapnel[<1], "\n", "\n" + stri_color);
         }
         sep_flag = op_flag = 0;
         last = i + 1;
      }

      /* Try to detect comments... */
      else if (str[i .. i + 1] == "/*"  ||  str[i .. i + 2] == "/\n*")  {
         if (i != last)  {
            shrapnel += ({ str[last .. i - 1] });
         }
         split = (str[i + 1] == '\n');
         j = strsrch(str[i + 2 + split .. ], "*/");
         if (j == -1)  {
            j = strsrch(str[i + 2 + split .. ], "*\n/");
            ++split;
         }

         if (j == -1)  {
            in_comment = linenum + 1;
            shrapnel += ({ comm_color + str[i .. ] + "%^RESET%^" });
            i = strlen(str) - 1;
         }
         else  {
            shrapnel += ({ comm_color + str[i .. i + j + 3 + split] +
                           "%^RESET%^" });
            i += j + 3 + split;
         }
         if (last_line)  {
            shrapnel[<1] = replace(shrapnel[<1], "\n", "\n" + comm_color);
         }
         sep_flag = op_flag = 0;
         last = i + 1;
      }

      else if (str[i .. i + 1] == "//"  ||  str[i .. i + 2] == "/\n/")  {
         if (i != last)  {
            shrapnel += ({ str[last .. i - 1] });
         }
         shrapnel += ({ comm_color + str[i .. ] + "%^RESET%^" });
         i = strlen(str) - 1;
         if (last_line)  {
            shrapnel[<1] = replace(shrapnel[<1], "\n", "\n" + comm_color);
         }
         sep_flag = op_flag = 0;
         last = i + 1;
      }

      else if (member_array(str[i], SEPARATORS) != -1)  {
         if (last <= i - 1)  {
            // Capture the word before the separator
            shrapnel += ({ color_word(str[last .. i - 1],
                                      ref if_flag, ref include_flag,
                                      ref type_flag, ref class_flag) });
         }
         // Capture the separator
         if (sep_flag)  {
            shrapnel[<1] += str[i .. i];
         }
         else  {
            shrapnel += ({ str[i .. i] });
            sep_flag = 1;
         }
         op_flag = 0;
         if (str[i] == SCOLON)
            type_flag = 0;
         last = i + 1;
      }

      else if (member_array(str[i], OPERATORS) != -1)  {
         if (last <= i - 1)  {
            shrapnel += ({ color_word(str[last .. i - 1],
                                      ref if_flag, ref include_flag,
                                      ref type_flag, ref class_flag) });
            class_flag = 0;
         }
         if (str[i] == TIMES  &&  type_flag)  {
            shrapnel += ({ type_color + str[i .. i] + "%^RESET%^" });
            type_flag = 0;
         }
         else if (op_flag)  {
             shrapnel[<1] = shrapnel[<1][0 .. <10] + str[i .. i] +
                            "%^RESET%^";
         }
         else  {
             shrapnel += ({ oper_color + str[i .. i] + "%^RESET%^" });
             op_flag = 1;
         }
         sep_flag = 0;
         last = i + 1;
      }
      else sep_flag = op_flag = 0;
   }
   if (last < i)  {
      shrapnel += ({ color_word(str[last .. ],
                                ref if_flag, ref include_flag,
                                ref type_flag, ref class_flag) });
   }

   return shrapnel;
} /* boom() */


private string highlight(string str, int linenum, int numbering,
                         int last_line)
{
   string *words;
   string  num = "";

   if (linenum == fsize)  return str;
   if (numbering)  {
      num = str[0 .. num_len + 1];
      str = str[num_len + 2 .. ];
   }
   words = boom(replace(str, "%^", "%%%^^^"), linenum, last_line);
   words = map(words, "fix_string", this_player());

   return this_player()->fix_string(num + implode(words, ""));

} /* highlight() */


private void init_settings()  {
   string  rc;
   string  line;
   string *sets;
   string *bits;
   int     spaces;
   int     i;

   tab_str = "   ";
   tab_replace = 0;
   keyw_color = "%^CYAN%^";
   comm_color = "%^GREEN%^";
   numb_color = "%^MAGENTA%^";
   oper_color = "%^BLUE%^";
   stri_color = "%^YELLOW%^";
   type_color = "%^BOLD%^%^CYAN%^";

   rc = read_bytes("/w/" + this_player()->query_name() + "/.magicrc");
   if (strlen(rc) == 0)  return;

   sets = explode(rc, "\n");
   foreach (line in sets)  {
      bits = explode(line, " ") - ({ "" });
      if (sizeof(bits) > 2)  {
         if (bits[0] == "tab")  {
            if (bits[1] == "spacing")  {
               if ((spaces = to_int(bits[2])) > 0)  {
                  tab_str = "";
                  for (i = 0; i < spaces; i++)  {
                     tab_str += " ";
                  }
               }
            }
            else if (bits[1] == "replacement")  {
               if (bits[2] == "on")  tab_replace = 1;
               else tab_replace = 0;
            }
         }
         else if (bits[0] == "color")  {
            set_colors(bits[1 .. ]);
         }
         else if (bits[0] == "history")  {
            open_history = bits[1 .. ];
         }
      }
   }
   return;

} /* init_settings() */


private int set_colors(string *words)  {
   string tmp_color;

   tmp_color = implode(map(words[1 .. ],
                           (: "%^" + upper_case($1) + "%^" :)), "");
   switch (words[0])  {
      case "keyword":
         keyw_color = tmp_color;
         return 1;

      case "comment":
         comm_color = tmp_color;
         return 1;

      case "number":
         numb_color = tmp_color;
         return 1;

      case "string":
         stri_color = tmp_color;
         return 1;

      case "operator":
         oper_color = tmp_color;
         return 1;

      case "type":
         type_color = tmp_color;
         return 1;

      default:
         return 0;
   }
} /* set_colors() */


int write_permission(string name)  {
   return write_file(name, "");
}


int rm_file(string name)  {  return rm(name);  }


string *filter_regexp(string *incoming)  {
   string *result;
   int     i;

   result = allocate((sizeof(incoming) + 1) / 2);
   for (i = sizeof(incoming) - 1; i >= 0; i -= 2)
      result[i / 2] = incoming[i];
   return result;

} /* filter_regexp() */


int save_history()  {
   string tmp;
   string *junk;
   int i;
   int res;

   tmp = read_bytes("/w/" + this_player()->query_name() + "/.magicrc");
   if (tmp)  {
      junk = explode(tmp, "\n");
      for (i = 0; i < sizeof(junk); i++)  {
         if (junk[i][0 .. 6] == "history")  {
            junk[i] = sprintf("history %s",
                              implode(open_history[<10 .. ], " "));
            break;
         }
      }
   }
   else junk = ({ sprintf("history %s",
                          implode(open_history[<10 .. ], " ")) });
   res = write_file("/w/" + this_player()->query_name() + "/.magicrc",
                    implode(junk, "\n"), 1);
   return res;

} /* save_history() */


string get_inc_path(string fname, string last_file)  {
   string  ret;
   string  tmp;
   string *bits;
   int     count;

   /* Strip off any leading spaces */
   while (fname[0] == ' ')
      fname = fname[1 .. ];

   if (sscanf(fname, "<%s>", tmp) == 1)  {
      ret = "/include/";
      fname = tmp;
   }
   else if (sscanf(fname, "\"%s\"", tmp) == 1)  {
      if (tmp[0] == '/')
         ret = "";
      else  {
         bits = explode(last_file, "/");
         count = 2;
         while (tmp[0 .. 2] == "../")  {
           ++count;
           tmp = tmp[3 .. ];
         }
         ret = "/" + implode(bits[0 .. <count], "/") + "/";
      }
      fname = tmp;
   }
   else return "";

   if (file_size(ret + fname) < 0)
      return "";
   return ret + fname;

} /* get_inc_path() */


string expand_macros(string ins, string *sorted_defs)  {
   int     changed;
   int    *allowed = ({' ', '\t', '+', '-', ',', '(', '\"', '[' });
   int     off;
   string  def;

   do {
      changed = 0;
      foreach (def in sorted_defs)  {
         if ((off = strsrch(ins, def)) != -1)  {
            if (off == 0  ||  member_array(ins[off - 1], allowed) >= 0)  {
               ins = replace_string(ins, def, defs[def]);
               changed = 1;
            }
         }
      }
   }
   while(changed);

   return ins;

} /* expand_macros() */


string strip_junk(string stuff){
   stuff = replace(stuff, ({ " ", "", "+", "", "(", "", ")", "" }));
   return replace_string(stuff, "\"\"", "");
}


void defines(string fname)  {
   string *lines;
   string  line;
   string  tmp;
   string  tmp2;
   int     off;
   string *sorted_defs;
   int     i;
   int     j;
   int     nest;

   if (fname != name)  {
      tmp = read_file(fname);
      if (tmp)
         lines = regexp(explode(tmp, "\n"), "^#[ ]*(include|define)[ \t]+");
      else
         lines = ({ });
   }
   else lines = regexp(file, "^#[ ]*(include|define)[ \t]+");

   foreach (line in lines)  {
      if ((off = strsrch(line, "include")) != -1)  {
         tmp = line[off + 8 .. ];
         tmp2 = get_inc_path(tmp, fname);
         call_out("defines", defs_not_done, tmp2);
         ++defs_not_done;
      }
      else {
         i = 0;
         nest = 0;

         off = strsrch(line, "define");
         tmp = line[off + 7 .. ];
         while (tmp[i] == ' ')
            ++i;
         tmp = tmp[i .. ];
         i = 0;
         while (i < strlen(tmp)  &&  (tmp[i] != ' '  ||  nest))  {
            if (tmp[i] == '(')  {
               ++nest;
            }
            else if (tmp[i] == ')')
               --nest;
            ++i;
         }
         j = i;
         while (j < strlen(tmp)  &&  tmp[j] != ' ')
            ++j;

         tmp2 = tmp[j .. ];
         tmp = tmp[0 .. i - 1];

         defs[tmp] = tmp2;
      }
   }
   --defs_not_done;

   if (!defs_not_done)  {
      sorted_defs = sort_array(keys(defs), -1);
      foreach (tmp, tmp2 in copy(defs))  {
         if (strsrch(tmp, '(') == -1)
            defs[tmp] = strip_junk(expand_macros(tmp2, sorted_defs));
      }
   }
} /* defines() */
// --- END [/mnt/home2/grok/lib/global/magic.c] ---
// --- BEGIN [/mnt/home2/grok/lib/global/nickname.c] ---
// Size:   File: "/mnt/home2/grok/lib/global/nickname.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627270   Available: 13574624
Inodes: Total: 5242880    Free: 4960133
870 bytes, Last Modified:   File: "/mnt/home2/grok/lib/global/nickname.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627270   Available: 13574624
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:52.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: nickname.c,v 1.1 1998/01/06 04:54:05 ceres Exp $
 * $Log: nickname.c,v $
 * Revision 1.1  1998/01/06 04:54:05  ceres
 * Initial revision
 * 
*/
/*
 * The great and wonderful alias driver by me ;)
 * pinkfish.
 */
mapping map_nicknames;

void nickname_commands() {
}

mapping query_nicknames() { return map_nicknames; }
void set_nicknames(mapping map) { map_nicknames = map; }
     
string expand_nickname( string phrase ) {
   int i;
   string new_n, *words;
   if ( stringp( phrase ) )
      words = explode( phrase, " " );
   else
      return phrase;
   if ( !map_nicknames )
      map_nicknames = ([ ]);
   for ( i = 0; i < sizeof( words ); i++ ) {
      new_n = map_nicknames[ lower_case( words[ i ] ) ];
      if ( new_n )
         words[ i ] = new_n;
   }
   return implode( words, " " );
} /* expand_nickname() */
 
// --- END [/mnt/home2/grok/lib/global/nickname.c] ---
// --- BEGIN [/mnt/home2/grok/lib/global/path.c] ---
// Size:   File: "/mnt/home2/grok/lib/global/path.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627269   Available: 13574623
Inodes: Total: 5242880    Free: 4960133
5110 bytes, Last Modified:   File: "/mnt/home2/grok/lib/global/path.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627269   Available: 13574623
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:52.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: path.c,v 1.6 2001/08/25 01:51:06 ceres Exp $
 * $Log: path.c,v $
 * Revision 1.6  2001/08/25 01:51:06  ceres
 * Fixed warnings in /global/lord
 *
 * Revision 1.5  1999/09/24 23:59:03  turrican
 * Fixed handling of .. in path components
 *
 * Revision 1.4  1999/09/23 02:02:08  pinkfish
 * fixed up some stuff.
 *
 * Revision 1.3  1999/08/30 01:37:34  pinkfish
 * Add in some stuff to control the pahts a bit nicer.
 *
 * Revision 1.2  1999/08/30 01:18:23  pinkfish
 *  Forcibly unlocked by pinkfish
 *
 * Revision 1.1  1998/01/06 04:54:05  ceres
 * Initial revision
 * 
*/
private string home_dir;
private nosave string current_path;

/**
 * This method expands the specified path to get a nice new path
 * based on the home directory or expanding the ~ stuff.
 * @param str the path to expand
 * @return the expanded path
 */                        
string get_path(string str) {
   string *array;
   string *array1;
   string temp;
   int i;
   
   if (!str) {
      if(!home_dir) {
         home_dir = "/w/" + this_player()->query_name();
      }
      str = home_dir;
   }
   if (str == "~") {
      str = "w/"+this_player()->query_name();
   } else {
      if(str[0] == '~') {
         if(str[1] == '/') {
            sscanf(str, "~%s", temp);
            str = "/w/" + this_player()->query_name() + temp;
         } else {
            string name;
            if (sscanf(str,"~%s/%s",name,str)!=2) {
               name = extract(str,1);
               str = "w/"+name;
            } else {
               /* 
                * cheat at this point and just assume they are a
                * creator. sigh i kno i know 
                */
               str = "w/"+name+"/"+str;
            }
         }
      } else {
         if (str[0] != '/') {
            str = current_path+"/"+str+"/";
         }
      }
      if (str == "/") {
         return "/"; 
      } else {
         array = explode(str,"/") - ({ "" }) ;
         array1 = ({ });
      }
      for (i = 0; i < sizeof(array); i++) {
         reset_eval_cost();
         if (array[i] == "..") {
           if (sizeof(array1)) {
             array1 = array1[0..<2];
           }
         } else if (array[i] != ".") {
           array1 += ({ array[i] });
         }
      }
      if (sizeof(array1)) {
         str = implode(array1, "/");
      } else {
         str = "";
      }
   }
   return "/"+str;
} /* get_path() */

/**
 * This method expands the wildcard based file name and turns it
 * into a list of files
 * @param str the wildcard based file name
 * @return the array of file names
 */
string *get_files( string str ) {
   int loop;
   int count;
   string *filenames;
   string rmpath;
   string temp1;
   string temp2;
   string *names;
   string *files;
   
   names = explode(str, " ")- ({ "" });
   if(sizeof(names) == 0) {
      return ({ });
   }
   filenames = ({ });
   for(count = 0; count < sizeof(names); count++) {
      str = names[count];
      str = rmpath = get_path(str);
      if(rmpath == "/") {
         filenames += ({ "/" });
         continue;
      }
      if(sscanf(rmpath, "%s/%s", temp1, temp2) == 2) {
         string *path_elements;
         
         path_elements = explode(rmpath, "/") - ({ "" });
         rmpath = implode(path_elements[0..sizeof(path_elements) - 2], "/");
      }
      files = get_dir(str);
      
      if(files) {
         int loop2;
         for(loop2 = 0; loop2 < sizeof(files); loop2++) {
            filenames += ({ rmpath + "/" + files[loop2] });
         }
      }
   }
   for(loop = 0; loop < sizeof(filenames); loop++) {
      if(filenames[loop][0] != '/') {
         filenames[loop] = "/" + filenames[loop];
      }
   }
   return filenames;
} /* get_files() */

/* Changed to be *.* so as to handle virtual wombles as well */
/**
 * This method expands the wildcard based file name and turns it
 * into a list of c files.  This automaticaly adds a .c to any
 * files.
 * @param str the wildcard based file name
 * @return the array of file names
 */
string *get_cfiles(string str) {
   int loop;
   string temp, *names, temp2;
   
   names = explode(str, " ") - ({ "" });
   for(loop = 0; loop < sizeof(names); loop++) {
      if(sscanf(names[loop], "%s.%s", temp, temp2) != 2) {
         names[loop] += ".c";
      }
   }
   str = implode(names, " ");
   return get_files(str);
} /* get_cfiles() */

/**
 * This method returns the current path.
 * @return the current path
 */
string query_current_path() { 
   return current_path; 
} /* query_current_path() */

/**
 * This method returns the home directory of the creator.
 * @return the home directory
 */
string query_home_dir() {
   return home_dir;
} /* query_home_dir() */

/**
 * This method sets the current home directory of the creator.
 * @param dir the new home directory
 */
protected int set_home_dir(string dir) {
   home_dir = dir;
   return 1;
} /* set_home_dir() */

/**
 * This method sets the current path for the creator.
 * @param str the current path
 */
void set_current_path(string str) {
   current_path = str;
} /* set_current_path() */
// --- END [/mnt/home2/grok/lib/global/path.c] ---
// --- BEGIN [/mnt/home2/grok/lib/global/psoul.c] ---
// Size:   File: "/mnt/home2/grok/lib/global/psoul.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627268   Available: 13574622
Inodes: Total: 5242880    Free: 4960133
18207 bytes, Last Modified:   File: "/mnt/home2/grok/lib/global/psoul.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627268   Available: 13574622
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:52.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: psoul.c,v 1.39 2003/06/09 20:29:52 pinkfish Exp $
 */
/**
 * This class controls the entire command queue for all player
 * objects.  Whenever a player tries to execute a command,
 * it gets placed in a queue here and eventually (during the
 * player's heart_beat()), the command will (hopefully) be executed.
 *
 * <p>Since this class is a nexus of control for player commands, it
 * is also the natural place for a number of other utilities and
 * functions which also affect the execution of all commands.
 * Among these are things like drunk_check(), do_soul(), etc.
 *
 * @see /global/new_parse->add_command()
 * @see /global/player->heart_beat()
 * @see query_passed_out_message()
 *
 * @author Pinkfish
 * @changed 3 November 1997 -- Sin
 *      Documented the bejeesus out of this thing.
 * @changed 4 Novemebr 1997 - Pinkfish
 *      Updated the documentation and changed the interupt system slightly.
 * @changed 22 Feburary 1998 - Pinkfish
 *      Fixed up the problems with the queueing system.
 */

#include <living.h>
#include <player.h>
#include <soul.h>
    
inherit "/global/alias";
inherit "/global/nickname";

nosave int time_left;    /* Time left for this round. */
nosave int tl_updated;   /* Last time the time_left was updated */
nosave int doing_it;
nosave int last_command;
nosave int bypass_queue;
nosave int flush_call_id; /* Id of teh call_out */
nosave string *queued_commands;
nosave string in_command;
nosave mixed interrupt;
nosave private function cmd = 0; 

#if !efun_defined(add_action)
protected mixed _process_input(string);
protected mixed command(string);
#endif


/**
 * @ignore
 */
void create() {
  time_left = ROUND_TIME;
  tl_updated = time();
  last_command = time();
  queued_commands = ({ });
} /* create() */

/**
 * To make the next single command be executed directly rather
 * than being placed in the command queue, call this function.
 */
void bypass_queue() { bypass_queue = 1; }

/**
 * Ensure that the player has no more time for executing commands.
 * This will force the next command to be queued.
 */
void no_time_left() {
  time_left = -ROUND_TIME;
} /* no_time_left() */

/**
 * This is a setup function that is called by the player object.
 * It is used to register the lower_check() and drunk_check()
 * functions.  Plus it initializes the alias object, the
 * nickname object, and the history object.
 */

protected int drunk_check(string str);

void soul_commands() {
#if efun_defined(add_action)
  add_action("lower_check","*", -10000);
  add_action((:drunk_check:),"*", 10000);
#endif
  alias_commands();
  nickname_commands();
  history_commands();
} /* soul_commands() */

/**
 * You can use this function to see if there are any commands
 * queued for this player.
 * @return the number of queued commands
 */
int query_queued_commands() {
  return sizeof(queued_commands);
} /* query_queued_commands() */

/**
 * Some of the soul commands force the target to do something.
 * An example is the 'tickle' soul, which forces the target to
 * 'giggle'.  Those soul-forces call this function.  But only
 * the soul object can use this function: any other object which calls
 * this function will be ignored.  This prevents this function
 * from being used to bypass the security checking on the
 * 'force' command.
 *
 * @param str the command being forced
 * @return 0 if the command was ignored, otherwise 1.
 */
int soul_com_force(string str) {
  if (file_name(previous_object()) != SOUL_OBJECT)
    return 0;
  command(str);
  return 1;
} /* soul_com_force() */

/**
 * All soul commands eventually call this function to output their
 * messages.  This is nothing more than a wrapper for say(), but
 * it provides a convenient name by which a shadow on the
 * player object can replace any soul behavior.
 *
 * @param str the string being printed
 * @prarm bing the avoid array
 */
void do_soul(string str, mixed bing) {
  say(str, bing);
} /* do_soul() */

/**
 * The amount of time units left.  A time unit is 1/40th of a second.
 */
int query_time_left() {
  time_left += ((time() - tl_updated) / 2) * ROUND_TIME;
  if(time_left > ROUND_TIME)
    time_left = ROUND_TIME;
  tl_updated = time();
  
  return time_left;
} /* query_time_left() */

/**
 * Change the amount of time a player has left.  You call this after a command
 * has been executed to make it take more time.
 * @param i the amount of time units to change by
 * @return the amount of time left
 */
int adjust_time_left(int i) {
   return time_left += i;
} /* adjust_time_left() */

private void do_flush(int first) {
  int i;
  string str;

  if ( ( time_left < 0 ) || !sizeof( queued_commands ) ||
       ( this_object()->queue_commands(queued_commands[0]) &&
         !this_object()->query_creator() ) ) {
    return;
  }

  if (!first) {
    str = queued_commands[0];
    queued_commands = queued_commands[1..];
    doing_it = 1;
    catch(command(str));
    doing_it = 0;
    if (!sizeof(queued_commands)) {
      /* The end! */
      queued_commands = ({ });
      doing_alias = ([ ]);
    }
    return ;
  }
  for (i = 0; (i < 2) && (i < sizeof(queued_commands)); i++) {
    flush_call_id = call_out((: do_flush(0) :), 1);
  }
  flush_call_id = call_out((: do_flush(1) :), 2);
} /* do_flush() */

private void call_interrupt(int time_left, object interupter) {
   mixed stuff;

   stuff = interrupt;
   interrupt = 0;
   /* The previous object is the person interupting us. */
   if (pointerp(stuff)) {
      catch(call_other(stuff[1],
                       stuff[0],
                       time_left,
                       stuff[2],
                       this_object(),
                       interupter,
                       in_command));
   } else if (functionp(stuff)) {
      catch(evaluate(stuff,
                     time_left,
                     this_object(),
                     interupter,
                     in_command));
   }
} /* call_interrupt() */

/**
 * This method flushes all the queued commands.  It increments the time by the
 * ROUND_TIME define and checks to see if any of the commands now need to be
 * executed.  This should be called each heart beat..
 *
 * @see /global/player->heart_beat()
 */
protected void flush_queue() {
  query_time_left();
  remove_call_out(flush_call_id);
  do_flush(1);
  if (!sizeof(queued_commands)) {
    /* Ok... check to see if an interupt was set up */
    if (interrupt && time_left > 0) {
      call_interrupt(0, this_object());
    }
    in_alias_command = 0;
    doing_alias = ([ ]);
    if (!sizeof(queued_commands)) {
      return ;
    }
    doing_alias = ([ ]);
    in_alias_command = 0;
  }
} /* flush_queue() */

/**
 * Sets the function to be executed if the command is interrupted.
 * It is also executed if teh command finished.  If it is interrupted
 * the first arguement to the called function will be the amount of time
 * it had left to complete.  If it complets successfuly, this
 * argument will be 0.  If the first argument is a function pointer,
 * this will be used instead.<p>
 *
 * Eg: set_interupt_command("frog", this_object());<p>
 * void frog(int time_left, mixed arg) { <p>
 * ... <p>
 * }
 *
 * @param func the function to call back
 * @param ob the object to call the function on
 * @param arg the argument to pass to the function
 * @example
 * ...
 * void frog(int time_left, mixed arg);
 * ...
 * set_interupt_commant((: frog :));
 * ...
 * void frog(int time_left, mixed arg) {
 *    ...
 * } /\* frog() *\/
 */
void set_interupt_command(mixed func, mixed ob, mixed arg) {
  if (!functionp(func)) {
    interrupt = ({ func, ob, arg });
    if ( !stringp( func ) )
      interrupt = 0;
  } else {
    interrupt = func;
  }
} /* set_interupt_command() */

/**
 * This method returns the current value associated with tine interupt
 * command.
 * @return the current interupt command data
 */
mixed *query_interupt_command() {
   return interrupt;
} /* query_interupt_command_func() */

/**
 * Fixes a spelling error.   This one only takes a function pointer as an
 * input.
 *
 * @param func the function pointer to call back with
 */
void set_interrupt_command(function func) {
  set_interupt_command(func, 0, 0);
} /* set_interrupt_command() */

/**
 * This is called by the stop command.  It sets the entire queue back to
 * empty.  It calls the interrupt functions and stuff if they need to be
 * called.
 */
void remove_queue() {
   queued_commands = ({ });
   if ( interrupt && ( time_left < 0 ) ) {
      call_interrupt(-time_left, this_object());
   }
   tell_object( this_object(), "Removed queue.\n" );
   if (this_object()->query_lord()) {
     /* Just in case something really bad happens...  Let lords fix it */
     time_left = 0;
   } else {
     /* Make sure they cannot do anything for a heartbeat */
     time_left = -DEFAULT_TIME;
   }
} /* remove_queue() */

/**
 * This method interupts the current command.
 * @param interupter the person interupting the command
 */
void interupt_command(object interupter) {
   if (interupter) {
      call_interrupt(-time_left, interupter);
   }
} /* interupt_command() */

/** 
 * Use this function to set a function that is called with the players input
 * before the command handlers get to it, return 1 from the function if the
 * input needs no further parsing (ie the command is handled)
 *
 * @param func = function in the players environment to call.
 */

void command_override(function func){
  if(!functionp(func))
    error("command_override needs a function!");
  cmd = func;
}

/**
 * This poorly named function was originally used to affect the
 * player's behavior when they are drunk, and to prevent any
 * player from doing anything in the event that they are passed
 * out.  Now the function also is responsible for adding commands
 * to the player's command queue, for implementing the 'stop'
 * and 'restart' commands, and for ensuring that the player can quit
 * the game, even when queueing.
 *
 * <p>To see if a player is passed out, it checks the
 * "passed out" property.  If that property is nonzero, then
 * the player will be prevented from doing the command unless
 * that player is also a creator.  By default, it will print
 * a message that says: "You are unconscious.  You can't do
 * anything.\n".  If the function query_passed_out_message() is
 * defined on the player object (usually by a shadow), and
 * returns a string, then that string is printed instead.
 *
 * <p>This function is registered with
 * add_action("drunk_check", "*", 10000),
 * so it can be avoided by registering a higher priority add_action.
 * But that is not necessary, because if bypass_queue() has
 * been called, this function will do nothing.  Please note that
 * you should not be using add_action.
 *
 * @return 0 if nothing was done, 1 if drunk_check() blocked
 * the command.
 * @param str the command being executed
 *
 * @see /global/new_parse->add_command()
 */
protected int drunk_check(string str) {
   string *rabbit;
   string *green;
   string mess;
   string comm;
   string arg;

   if(cmd){
     object owner = function_owner(cmd);
     if(owner && owner == environment(this_player())){
       int res = evaluate(cmd, str);
       if(res)
         return res;
     } else cmd = 0;
   }

   if ( in_command == str ) {
      in_command = 0;
      sscanf(str, "%s %*s", str);
      if (is_doing_alias(str)) {
         this_object()->add_failed_mess(this_object(),
             "Recursive aliases. Bad "+
             ({"thing","boy","girl"})[(int)this_object()->query_gender()]+
                ".\n", ({ }));
      }
      return 0;
   }
   if ( bypass_queue ) {
      bypass_queue = 0;
      return 0;
   }
   last_command = time();
   if ( this_object()->query_property( PASSED_OUT ) ||
         !interactive( this_object() ) ) {
      if ( ( str == "quit" ) || ( str == "quit_old" ) ) {
         return 0;
      }
      mess = this_object()->query_passed_out_message();
      if ( !stringp( mess ) ) {
         mess = "You are unconscious.  You can't do anything.\n";
      }
      write( mess );
      if ( !this_object()->query_creator() ) {
         return 1;
      }
      write( "On the other hand, you're a creator...\n" );
   }
   if ( ( str == "stop" ) || ( str == "restart" ) ) {
      remove_queue();
      return 0;
   }
   if ( stringp( str ) ) {
      if ( str[ 0 .. 4 ] == "stop " ) {
         return 0;
      }
   }

   /*
    * If: there's no time left
    * or: commands are to be queued (e.g. spell casting) and this is a player
    * or: if we have queueing commands and we are not currently executing
    *     a command off the stack
    * or: we are trying to do a flush
    * then queue the command.
    */
   if ( ( time_left < 0 ) ||
        // Spell casting check
        (this_object()->queue_commands(str) &&
         !this_object()->query_creator()) ||
         ( !doing_it && ( sizeof( queued_commands ) ||
         ( find_call_out( flush_call_id ) != -1 ) ) ) ) {
      /* Only print commands which are not in upper case... */
      rabbit = explode(str, " ");
      if (rabbit[0] != upper_case(rabbit[0])) {
         write( "Queued command: "+ str +"\n" );
      }
      if ( str == "quit" ) {
         write( "If you are trying to quit and it is queueing things, use "
               "\"stop\" to stop your commands, and or \"restart\" to start "
               "your heartbeat.\n" );
      }
      /*
       * The command should always go on the end because the aliases
       * in the queue are expanded elsewhere...
       */
      if(sizeof(queued_commands) < 256) {
        // Queuing the same command repeatedly costs more time.
        // it checks for there being more than one word in the command to
        // avoid making movement aliases very slow.
        if(sizeof(rabbit) > 1 && member_array(str, queued_commands) != -1)
          time_left -= (DEFAULT_TIME / 2);
        queued_commands += ({ str });
      }
      return 1;
   }

   if (interrupt) {
      call_interrupt(0, this_object());
   }
   interrupt = 0;
   in_command = str;

   /* Get the args and stuff to run the alias. */
   if (sscanf(str, "%s %s", comm, arg) != 2) {
      comm = str;
      arg = "";
   }
   rabbit = run_alias(comm, arg);
   if (rabbit) {
      /* Set us as running the alias. */
      set_doing_alias(comm);
      green = queued_commands;
      queued_commands = ({ });
      foreach (comm in rabbit) {
         catch(command(comm));
      }
      queued_commands += green;
#if USE_ADD_ACTION
   } else if(sizeof(str) > 512) {
     write("Command too long.\n");
#endif
   } else {
      time_left -= DEFAULT_TIME;
      command(str);
   }

   if (interrupt && time_left >= 0) {
      call_interrupt(0, this_object());
   }
   return 1;
} /* drunk_check() */

/**
 * This is the command called by the driver on a player object every
 * time a command is executed.  It expands the history comands.
 *
 * @param str the string to expand
 * @return the expanded history string
 */
protected string process_input(string str) {
  float secs;
  int t = time_expression{
    reset_eval_cost();
    if (str[0] == '.')
      str = expand_history(str[1..]);
    else if (str[0] == '^')
      str = substitute_history(str[1..]);
    this_object()->add_history(str);
#if efun_defined(add_action)
    return str;
#else
    _process_input(str);
  };
  
  secs = t/1000000.0;

  if((secs > 1.0) &&
     (strlen(str) < 2 || str[0..1] != "su") &&
     str != "upgrade") {
    log_file("GARBAGE", "%s command: %s time: %:3f place: %s\n",  
       ctime(time())[4..18], str, secs, 
       file_name(environment()));
    if(this_object()->query_creator())
      printf("\nThat command froze the mud for %:3f "
       "seconds.\n\n", secs);
  } 
  return 0;
#endif  
} /* process_input() */

#if !efun_defined(add_action)
/** @ignore yes */
protected mixed _process_input(string str){
  object ob;
  int i;
  string* bits;
  
  if(str == "") {
    return 0;
  }
  
  ob = this_player();
  efun::set_this_player(this_object());
  
  _notify_fail(0);

  /* Strip leading spaces */
  while (str[0] == ' ') {
    str = str[1..];
  }

  if (str == ""){
      efun::set_this_player(ob);
      return 0;
    }

  /* Strip trailing spaces */
  while(str[<1] == ' ') {
    str = str[0..<2];
  }

  if (str == ""){
    efun::set_this_player(ob);
    return 0;
  }

  //strip %^%^
  //str = replace(str, "%^", "% ^");
  if (strsrch(str, "%^") != -1) {
    bits = explode("f" + str + "g", "%^");
    for (i = 1; i < sizeof(bits); i += 2) {
      if (bits[i][0..3] != "USER") {
         bits[i] = "USER_" + bits[i];
      }
    }
    bits[0] = bits[0][1..];
    bits[<1] = bits[<1][0..<2];
    str = implode(bits, "%^");
  }

  
  if(!drunk_check(str)) {
    if(!this_object()->exit_command(str)) {
      if(!this_object()->cmdAll(str)) {
        if(!this_object()->new_parser(str)) {
          if(!this_object()->lower_check(str)){
            if(!(str = query_notify_fail())){
              string *responses=({"What?", "Try something else."});
              receive(responses[random(sizeof(responses))]+"\n");
            } else {
              receive(str);
            }
            efun::set_this_player(ob);
            return 0;
          }
        }
      }
    }
  }
  efun::set_this_player(ob);
  return "bing";

} /* _process_input() */

/** @ignore yes */
protected mixed command(string cmd){
  int time = eval_cost();
  if(_process_input(cmd))
    return eval_cost() - time + 1; // on v22.2 eval_cost runs up, reverse for v22.1
  return 0;
}
#endif

/**
 * This function will get called when all other commands and actions
 * have refused to do anything for this input from the user.  This
 * function adds some extra time for the user, and then returns.
 * 
 * <p>This function is registered via add_action() with a 
 * priority of -10000.  If you want to bypass it, then use a priority
 * higher than that.  If you want to see what strings get dropped by the
 * entire add_action() stack, then use a priority lower.
 *
 * @parms str the user's input
 * @return 1 if the user's input is "stop", otherwise 0.
 */
int lower_check(string str) {
  query_time_left();
  return (str == "stop");
} /* lower_check() */
// --- END [/mnt/home2/grok/lib/global/psoul.c] ---
// --- BEGIN [/mnt/home2/grok/lib/global/shut.c] ---
// Size:   File: "/mnt/home2/grok/lib/global/shut.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627263   Available: 13574617
Inodes: Total: 5242880    Free: 4960133
4689 bytes, Last Modified:   File: "/mnt/home2/grok/lib/global/shut.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627263   Available: 13574617
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:52.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: shut.c,v 1.2 2000/06/15 03:23:08 pinkfish Exp $
 * $Log: shut.c,v $
 * Revision 1.2  2000/06/15 03:23:08  pinkfish
 * Change to use the config file.
 *
 * Revision 1.1  1998/01/06 04:54:05  ceres
 * Initial revision
 * 
*/
/*
** Armageddon 3.0 is largely a rip off of the 2.4.5 version
** that most of us are familiar with. The original author
** left no credits, but the work is recognized.
** This version has a number of improvements, and hopefully,
** a neater finished product.
**
** To use, merely use the command:
**   call shut(##) /obj/shut
** where ## is the number of minutes till shutdown. Armageddon
** will then handle a nice shutdown.
**      Gordon
**  Bashed for our great mud by pinkfish.  Mangled, wombled and
**  badgered a lot since then.
*/

inherit "/std/container";
#include <config.h>

int time_of_crash;

void setup() {
/* This stops wizzes from cloning armageddon. He only needs to be loaded */
  if ( file_name( this_object() ) != "/global/shut" ) {
    write("This object can't be cloned.\n");
    dest_me();
    return;
    }
  set_name("offler");
  set_living_name("offler");
  add_adjective( ({ "offler", "the", "crocodile" }));
  add_alias("god");
  enable_commands();
  set_short( "Offler" );
  add_property( "determinate", "" );
  set_long("The Crocodile God.  He looks big, green, and, well "+
           "like this really.\n");
  add_alias("shut");
  move(CONFIG_START_LOCATION,
      "Offler the Crocodile God appears in a puff of smoke.",
      "Offler the Crocodile God appears in a puff of smoke.");
  reset_get();
}

#define ishout(str) shout("Offler the Crocodile God shouts: "+str+"\n")

void ashout( string words ) {
  int i;
  object *people;
  people = users();
  for ( i = 0; i < sizeof( people ); i++ )
    tell_object( people[ i ], "Offler the Crocodile God shouts: "+
        words +"\n" );
} /* ashout() */

void heart_beat() {
  int time_to_crash;

  if (!time_of_crash) return;
  time_to_crash = time_of_crash - time();
  if (time_to_crash < 1) {
    call_out("end_it_all",0);
    set_heart_beat(0);
    return;
  }
  if (time_to_crash < 10)  {
    ashout( "Game reboot in "+ time_to_crash +" seconds." );
    return;
  }
  if (time_to_crash < 60 && time_to_crash % 10 < 2) {
    ashout( "Game is rebooting in "+ time_to_crash +" seconds." );
    return;
  }
  if (time_to_crash % 60 > 1) return;
  time_to_crash /= 60;
  if (time_to_crash > 30) {
/* Give them at least 30 minutes warning... */
    return ;
  }
  if(time_to_crash == 1)
  {
    ashout( "Game is rebooting in one minute." );
    return;
  }
  if (time_to_crash < 10 || !(time_to_crash % 10)) {
    ishout( "Game is rebooting in "+ time_to_crash +" minutes." );
    return;
  }
} /* heart_beat() */

void shut(int minutes) {
  object *players;
  int i;
  string fname;

  if (!intp(minutes)) {
    write("Bad argument\n");
    return;
  }
  fname = file_name(previous_object());
  if (minutes <= 0) {
    write("No time given\n");
    return;
  }
  players = users();
  for (i=0;i<sizeof(players);i++)
    if (players[i]->query_creator())
      tell_object(players[i], "Offler the Crocodile God wishes you to know:\n"+
          "The mud is rebooting in "+ number_as_string( minutes ) +
          " minutes.\n" );
  set_long("He is firmly concentrating on counting.\n");
  if (time_of_crash)
    write( "There was already a reboot scheduled, set for "+
      (time_of_crash - time()) + " seconds.\n");
  time_of_crash = time() + minutes*60;
  set_heart_beat(1);
} /* shut() */


string long(string str, int dark) {
  ::long();
  if (time_of_crash && this_player()->query_wizard())
     return ::long(str,dark)+
            "Game reboot will be in " + ( time_of_crash - time() ) +
            " seconds.\n";
  return ::long(str,dark);
} /* long() */

void end_it_all() {
  int i;
  object *obs;

  ishout("Shutdown now!");
  obs = users();
  for (i=0;i<sizeof(obs);i++)
    call_out("force_quit", i, obs[i]);
  call_out("blue", 10);
} /* end_it_all() */

void force_quit(object ob) {
  if (!objectp(ob))
    return ;
/* modified to use the departure lounge for everyone. */
  if (!ob->query_property("quiting frog"))
    ob->quit_alt();
} /* force_quit() */

/*
 * Check to see that everyone has been quit.  If we have taken
 * longer than 2 minutes to quit everyone, then we shutdown
 * anyway. -- Pinkfish
 */
void blue() {
  if (sizeof(users()) > 0 &&
      time() - time_of_crash < 120)
    call_out("blue", 10);
  else
    shutdown(0);
} /* blue() */

int query_time_to_crash() {
  if ( !time_of_crash ) {
    call_out( "dest_me", 1 );
    return 9999;
  }
  return time_of_crash - time();
} /* query_time_to_crash() */
// --- END [/mnt/home2/grok/lib/global/shut.c] ---
// --- BEGIN [/mnt/home2/grok/lib/global/pweath.c] ---
// Size:   File: "/mnt/home2/grok/lib/global/pweath.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627262   Available: 13574616
Inodes: Total: 5242880    Free: 4960133
6363 bytes, Last Modified:   File: "/mnt/home2/grok/lib/global/pweath.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627262   Available: 13574616
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:52.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: pweath.c,v 1.7 2001/09/11 03:38:33 presto Exp $
 * $Log: pweath.c,v $
 * Revision 1.7  2001/09/11 03:38:33  presto
 * Fixed type error I think
 *
 * Revision 1.6  2001/03/13 00:22:08  pinkfish
 * Format it...
 *
 * Revision 1.5  2001/03/13 00:19:35  ceres
 *  Forcibly unlocked by pinkfish
 *
 * Revision 1.4  2000/04/10 05:07:41  ceres
 * Made it public :)
 *
 * Revision 1.3  2000/01/06 07:44:09  terano
 * Changed weather_extra_look to check for null values
 *
 * Revision 1.2  2000/01/06 07:42:16  ceres
 *  Forcibly unlocked by terano
 *
 * Revision 1.1  1998/01/06 04:54:05  ceres
 * Initial revision
 * 
*/
/* your very own personal weather... */
#include <weather.h>
#include <clothing.h>
#include <playtesters.h>

#define COMFORTABLE 20

int temperature;
string temperature_str;

int query_wetness()
{
   return 0;
}

void add_wetness(int arg)
{
}

void dry_out()
{
}

void set_personal_temp(int i)
{
   temperature = i;
}
void adjust_personal_temp(int i)
{
   temperature += i;
}

int query_personal_temp()
{
   return temperature;
}

string query_temp_str()
{
   if (!temperature_str || temperature_str == "") {
      return "quite comfortable";
   }
   return temperature_str;
}

/**
 * This method calculates an objects personal temperature index.
 *
 * All temperatures in here are 20C lower so that comfort is at zero to
 * make calculations easier.
 */
int calc_personal_temp()
{
   mixed tmp;
   object where,
    *clothes;
   string item,
     zone,
     type,
    *types,
    *zones;
   int adjustment,
     room_temp,
     correction,
    *enums;

   if (this_object()->query_property("dead")) {
      temperature = 0;
      return 0;
   }
   where = environment(this_object());

   // If they're on a horse or somesuch then use that locations temperature
   // info.
   if (!where->query_property("location") &&
       environment(where) && environment(where)->query_property("location"))
      where = environment(where);

   // Figure out the temperature where they are.
   switch (where->query_property("location")) {
   case "outside":
      room_temp = (WEATHER->query_temperature(where) - COMFORTABLE);
      break;
   default:
      room_temp = 0;
   }

   // add the warmth of the room.
   room_temp += where->query_property("warmth");
   room_temp -= where->query_property("cooling");

   adjustment = room_temp;

   // add their personal warmth (from effects or shadows)
   adjustment += this_object()->query_property("warmth");
   adjustment -= this_object()->query_property("cooling");

   // Calculate how warm (or cool) their clothing is keeping them.
   clothes = filter_array(this_object()->query_wearing(),
                          (: !$1->id("scabbard") &&
                             !$1->id("belt") &&
                             !$1->id("backpack") &&
                             !$1->id("glasses") && !$1->id("jewellery") :));
   zones = ({ });
   foreach(item in clothes) {
      tmp = item->query_type();
      if (arrayp(tmp))  types = tmp;
      else types = ({ tmp });

      foreach(type in types) {
         // Find out what zone this clothing type covers.
         // If it doesn't cover a zone (eg. jewellery) it doesn't give any
         // warmth.
         if (CLOTHING_HANDLER->query_equivilant_type(type))
            type = CLOTHING_HANDLER->query_equivilant_type(type);

         foreach(zone in CLOTHING_HANDLER->query_zone_names(type)) {
            if (member_array(zone, zones) == -1) {
               zones += ({ zone });
            }
            tmp = item->query_property("warmth");
            if (!tmp) {
               adjustment++;
            } else if (intp(tmp) && tmp) {
               adjustment += tmp;
            }
            // If it's warm here then do adjustments for clothing that
            // cool you.
            if (room_temp > 0 && item->query_property("cooling")) {
               adjustment -= item->query_property("cooling");
            }
         }
      }
   }

   // You get a warmth bonus or coolness bonus for each zone covered.
   // This means it's better to cover more of your body when it's cold.
   // It also means you can wear light clothing with less temperature
   // penalties since the warmth & cooling cancel out somewhat.
   if (room_temp < 0) {
      adjustment += sizeof(zones);
      if (room_temp + sizeof(zones) > 5) {
         adjustment -= (room_temp + sizeof(zones) - 5);
      }
   } else {
      adjustment -= sizeof(zones);
      if (room_temp - sizeof(zones) < -5) {
         adjustment -= (room_temp - sizeof(zones) + 5);
      }
   }

   // Wetness makes you cooler -- so sweating isn't necessarily a bad thing.
   enums = (int *) this_object()->effects_matching("body.wetness");
   if (sizeof(enums)) {
      adjustment -= sqrt(sqrt((int) this_object()->arg_of(enums[0]))) * 2;
   }
   // this hopefully does two things.
   // 1. effectively puts a maximum/minimum on temperature
   // 2. accounts for the body working to adjust temperature.
   if (temperature > room_temp && room_temp >= 0 || temperature > 5) {
      correction -= (temperature / 5) + 5;
   }
   if (temperature < room_temp && room_temp <= 0 || temperature < -5) {
      correction -= (temperature / 5) - 5;
   }
#ifdef 0
   /*
    * This factor is not currently used. Depending on how the testing goes
    * it may get put in place.
    */
   // this factor adjusts for when rooms aren't too hot or cold. So if you're
   // not too far off the room temperature you don't adjust quite so fast.
   if ((room_temp < 10 && temperature >= 0) ||
       (room_temp > 10 && temperature <= 0)) {
      factor = (ABS(room_temp - temperature) / 10.0);
      if (factor > 1.0 || factor < 0.0)
         factor = 1.0;
   } else {
      factor = 1.0;
   }
   temperature += to_int((adjustment + correction) * factor);
#endif

   temperature += (adjustment + correction);

   // calculate the temperature string and other effects based on the
   // race of the person.
   temperature_str = (this_object()->query_race_ob())->
      temperature_effects(this_object(), temperature);

   return temperature;
}

string weather_extra_look()
{
   if (stringp(temperature_str) && strlen(temperature_str)) {
      return capitalize((string) this_object()->query_pronoun()) + " looks " +
         temperature_str + ".\n";
   }
   return "";
}
// --- END [/mnt/home2/grok/lib/global/pweath.c] ---
// --- BEGIN [/mnt/home2/grok/lib/global/events.c] ---
// Size:   File: "/mnt/home2/grok/lib/global/events.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627260   Available: 13574614
Inodes: Total: 5242880    Free: 4960133
78672 bytes, Last Modified:   File: "/mnt/home2/grok/lib/global/events.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627260   Available: 13574614
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:52.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: events.c,v 1.136 2003/10/29 18:25:27 pinkfish Exp $
 */
/**
 * This file contains all the standard event handling code that players
 * need.  This will handle things like informs, shouts, says, tells,
 * whispers.  Everything!   It formats the message correctly and
 * sends it to the player.
 * @author Pinkfish
 */
#include <dirs.h>
#include <living.h>
#include <player.h>
#include <telnet.h>
#include <term.h>
#include <tune.h>
#include <language.h>
#include <broadcaster.h>
#include <cmds/options.h>
#include <newbiehelpers.h>
#include <playerinfo.h>

#define DEBUG
// #define USE_ROLE_PLAYING_SHORTS
#define BROADCASTER "/obj/handlers/broadcaster"
#define SPACES "                                                              "

#define INFORM_COLOURS ([ "default":"WHITE", "logon":"GREEN", "death":"RED", \
                           "cheat":"RED", "multiplayer":"RED",  \
                           "bad-password" : "RED", "link-death":"GREEN", \
                           "new-player" : "BOLD%^%^MAGENTA", \
                           "gag" : "BOLD%^%^RED", "alert" : "GREEN" ])

#ifdef OLD_THINGY
inherit "/global/play_parse_com";
#else
inherit "/global/new_parse";
#endif
inherit "/global/communicate";
inherit "/global/friends";
inherit "/global/options_control";

/*
 * This contains the event related global variables.
 * We are very short on global variables and this reduces our need for them.
 */
class event_info {
  mapping colour_map;
  string cur_term;
  string last_term;
  object where;
  object *had_shorts;
  mixed *eemessages;
  mixed busy;
}

private nosave class event_info _event_info;

private int earmuffs;
private int cols;
private int rows;
private mapping my_colours;

/*
 * This so that changeing the definitions gets fixed
 * when they log in again.  Also keeps the save
 * file smaller.
 */
private string term_name = "network";
private string *inform_types;
private mixed *tell_history;

void set_my_colours(string event_type, string colour);
mapping query_my_colours();

string find_rel(string word, int from);
private int set_our_rows(int num);
private int set_our_cols(int num, int test);
private int do_busy(string str);
private int do_busy_player(object *players);
protected varargs int do_tell_his(string, int);
mixed query_property(string name);
string query_nationality_accent_ob();

void create() {
  friends::create();
  _event_info = new(class event_info,
                    eemessages : ({ }));
                    
  my_colours = ([ ]);
  inform_types = ({ });
#ifdef OLD_THINGY
  play_parse_com::create();
#else
  new_parse::create();
#endif
} /* create() */

#if !efun_defined(has_mxp)
private int has_mxp(object ob) {
   return 0;
}
#endif

/**
 * This method returns the current terminal name.  If this is set to
 * network then the network will be queried for the terminal type
 * (using telnet suboption negotiation).
 * @return the current terminal name
 * @see query_cur_term()
 * @see set_term_type()
 */
string query_term_name() { return term_name; }
/**
 * This method returns the current terminal type that is being used.  This
 * will be 0 if the terminal name is set to network and no response has
 * been gained from the remote site yet.  Otherwise it should be the
 * same value as the terminal name.
 * @return the current terminal type
 * @see query_term_name()
 * @see set_term_type()
 */
string query_cur_term() { return _event_info->cur_term; }
/**
 * This method tells us if the player currently has earmuffs turned on.
 * @return 1 if earmuffs are on, 0 if they are not
 * @see check_earmuffs()
 * @see toggle_earmuffs()
 */
int query_earmuffs() { return earmuffs; }

/**
 * This method returns the list of inform types this player can receive.
 * @return array of inform types
 */
string *query_inform_types() {
  string *types;
  
  types = ({ "logon", "new-player", "birthday", "council", "friend" });
    
  if (this_object()->query_creator()) {
    types += ({ "link-death", "message", "death",
               "guild", "delete", "help", "combat-debug", "skill", "quest",
               "multiplayer", "bad-password", "club", "debug", "gag", 
               "alert" });

    if (master()->query_lord((string)this_object()->query_name())) {
      types += ({ "force", "enter", "dest", "cheat", "xp", "calls",
                    "cpu", "ftp" });
    }
  } else if ( load_object(NEWBIEHELPERS_HANDLER)->query_helper_access(this_object())
                ) {
      types += ({ "guild" });
  }

  if( this_object()->query_guild_ob() == "/std/guilds/witch" ||
      this_object()->query_creator() ) {
    types += ({ "mockery" });
  }

  return types;
}

/* This is pulled back into this object for security reasons... */
/**
 * This is the command to handle the inform stuff.
 * It does all the turning on/off and stuff things for the informs.
 * @param str the informs to listen to
 * @see event_inform()
 */
nomask protected int do_inform(string str) {
  string type, *types, *on, *frog, *off, *failed;
  int i;

  types = query_inform_types();
  foreach(type in inform_types) {
    if(member_array(type, types) == -1) {
      inform_types -= ({ type });
    }
  }

  on = inform_types;
  
  if (!on) {
    on = ({ });
  }
  if (!str) {
    str = "";
  }
  frog = explode(str, " ");
  if (!frog) {
    frog = ({ });
  } else {
    frog -= ({ "", 0 });
  }
  if (!sizeof(frog)) {
    /* show status */
    if (this_object()->query_property("inform repressed")) {
      write("Your informs are currently being repressed.\n");
    }
    if (sizeof(on)) {
      write("$I$5=You will be informed of "+ query_multiple_short(on)+
            " events.\n");
    }
    types -= on;
    if (sizeof(types)) {
      write("$I$5=You are not being informed of "+ query_multiple_short(types)+
            " events.\n");
    }
    return 1;
  }
  if (sizeof(frog) == 1) {
    switch (frog[0]) {
    case "on" :
      this_object()->remove_property("inform repressed");
      write("You are now being informed.  This is true!\n");
      if (sizeof(on)) {
         write("$I$5=You will be informed of "+ query_multiple_short(on)+
               " events.\n");
      } else {
         write("$I$5=Although you are not currently being informed of "
               "any events.\n");
      }
      return 1;
    case "off":
      this_object()->add_property("inform repressed", 1);
      write("Informs are now repressed.\n");
      return 1;
    case "all":
      on = types;
      frog = frog[1..];
      break;
    case "none" :
      on = ({ });
      write("You will not be informed of anything.\n");
      frog = frog[1..];
      break;
    }
  }
  failed = off = ({ });
  for (i=0;i<sizeof(frog);i++) {
    if (member_array(frog[i], types) == -1) {
      failed += ({ frog[i] });
    } else {
      if (sizeof(frog) > i+1) {
        switch (frog[i+1]) {
        case "on" :
          if (member_array(frog[i], on) == -1)
            on += ({ frog[i] });
          i++;
          break;
        case "off" :
          off += ({ frog[i] });
          i++;
          break;
        default :
          if (member_array(frog[i], on) == -1) {
            on += ({ frog[i] });
          } else {
            off += ({ frog[i] });
          }
          break;
        }
      } else {
        if (member_array(frog[i], on) == -1) {
          on += ({ frog[i] });
        } else {
          off += ({ frog[i] });
        }
      }
    }
  }
  on -= off;
  if (sizeof(failed)) {
    write("$I$5=I don't know about "+ query_multiple_short(failed)+
          " events.\n");
  }
  if (sizeof(off)) {
    write("$I$5=You will now not be informed of "+ query_multiple_short(off)+
          " events.\n");
  }
  if (sizeof(on)) {
    write("$I$5=You will now be informed of "+ query_multiple_short(on)+
          " events.\n");
  }
  inform_types = on;
  return 1;
} /* do_inform() */

/**
 * This method tests to see if the player can see octarine objects.
 * @return 1 if they can see octarine, 0 if they cannot
 */
int query_see_octarine() {
  string guild;

  if ( this_object()->query_creator() )
    return 1;
  if(!(guild = (string)this_object()->query_guild_ob())) return 0;
  return (int)guild->query_see_octarine();
} /* query_see_octarine() */

/**
 * This method will do the octarine checking for you on the message.
 * @param str the string to check
 * @see query_see_octarine()
 * @example
 * string query_long_bit() {
 *   return "Glinting and sharp looking, the long sword is an impressive "
 *          "weapon in the hands of someone knowledgeable.\n" +
 *          this_player()->octarine_message("It glows with a fluffy octarine "
 *                                          "aura.\n");
 * } /\* query_long_bit() *\/
 */
string octarine_message(string str) {
  if (query_see_octarine())
    return str;
  return "";
} /* octarine_message() */

/**
 * This function returns the appropriate colour codes for the given event
 * type. It will return the players chosen colour if they've set one or
 * the default if not.
 *
 * @param event_type The type of event
 * @return a string of colour codes.
 */
string colour_event(string event_type, string default_colour) {
  if (my_colours[event_type]) {
    return replace(my_colours[event_type], " ", "");
  }

  if (!default_colour) {
    return "";
  }

  return default_colour;
} /* colour_event() */

/**
 * This method handles the conversersions for the colour mapping which is
 * done on Discworld.  This also does octarine message expansion, if the
 * keyword %\^OCTARINE:message%\^ is embeded into a string then the
 * inside section will be replaced with a blank string if the player
 * cannot see octarine messages.
 * @param str the string to do the conversion on
 * @param width the width of the string
 * @param indent the size of the indent
 * @param args any other arguments
 * @return the fixed up string
 * @see efun::terminal_colour()
 */
varargs string fix_string(string str, int width, int indent, int padding, mixed *args ...) {
  string octmess, *bits, bit;
  int i;

  if (!stringp(str) || str == "") {
    return str;
  }

  if(indent > width / 3) {
    indent = 4;
  }

  if (!_event_info->cur_term) {
    if (term_name != "network") {
      _event_info->cur_term = term_name;
    } else {
      _event_info->cur_term = "dumb";
    }
  }
  if (!_event_info->colour_map) {
    _event_info->colour_map = (mapping)TERM_HANDLER->set_term_type(_event_info->cur_term, query_property(PLAYER_ALLOW_COLOURED_SOULS));
  }
  if (sizeof(args)) {
    str = sprintf(str, args ...);
  }
  bits = explode(str, "%^OCTARINE:");
  foreach (bit in bits) {
    i = strsrch(bit, "%^");
    if (i == -1) {
      continue;
    }
    octmess = bit[0..i-1];
    if (query_see_octarine()) {
      str = replace_string(str, sprintf("%%^OCTARINE:%s%%^", octmess),
                           octmess);
    } else {
      str = replace_string(str, sprintf("%%^OCTARINE:%s%%^", octmess), "");
    }
  }
  // If someone has mxp then we can do the formatting in a different
  // way.
  if (is_mxp_enabled()) {
  //if (query_name() == "greenland") {
    str = terminal_colour(str, _event_info->colour_map);
  } else {
    str = terminal_colour(str, _event_info->colour_map, width, indent);
  }
  return str;
} /* fix_string() */

/* Send all the relevant junk down to get the information we want. */
/** @ignore yes */
void player_connected() {
  _event_info->last_term = 0;
  /* Turn on the option */
  printf("%c%c%c", IAC, DO, TELOPT_TTYPE);
  /* Get them to send us their first terminal type */
  printf("%c%c%c%c%c%c", IAC, SB, TELOPT_TTYPE, TELQUAL_SEND, IAC, SE);
  /* Get them to send us their window size */
  printf("%c%c%c", IAC, DO, TELOPT_NAWS);
} /* player_connected() */

/**
 * This method sets the current terminal type for the player.  If the type
 * is network, then the network will be queried for the terminal type
 * and that will be used.  This is the distiction between the current
 * terminal type and the terminal name.  The name will be the value that
 * is set by the player and the current type will be the information
 * garnered from the network (if the name is network) or the same as the
 * name.
 * @param str the new terminal type
 * @return 1 if the terminal was successful set, 0 if not
 * @see set_term()
 * @see query_term_name()
 * @see query_cur_term()
 */ 
int set_term_type(string str) {
  if (!str) {
    notify_fail(sprintf("%-=*s", cols,
                "Syntax: "+query_verb()+" <term_type>\n"+
                "Where term type is one of the following: "+
                implode((string *)TERM_HANDLER->query_term_types(), ", ")+
                ".\nOr set it to \"network\", and the mud will try to "
                "figure it out itself.\n"));
    return 0;
  }
  if(str != term_name) {
    if (member_array(str, (string *)TERM_HANDLER->query_term_types()) != -1 ||
        str == "network") {
      if (str != "network") {
        _event_info->colour_map = (mapping)TERM_HANDLER->set_term_type(str, query_property(PLAYER_ALLOW_COLOURED_SOULS));
      } else { /* Get em to send us our terminal type */
        player_connected();
      }
      term_name = str;
      _event_info->cur_term = 0;
      write("Ok, terminal type set to "+str+".\n");
      return 1;
    } else {
      notify_fail("No such terminal type as " + str  + ".\n");
      return 0;
    }
  } else {
    notify_fail("Terminal type unchanged as " + str + ".\n");
    return 0;
  }
} /* set_term_type() */

/** @ignore yes */
void set_term(string name) {
  term_name = name;
  _event_info->cur_term = 0;
} /* set_term() */

/**
 * This method handles the responses from the remote site informing
 * us of their terminal type.
 * @param name the terminal type gathered from the remote site
 * @return 0 if the type was not used, 1 if it was
 * @see set_term_type()
 * @see query_term_name()
 * @see query_cur_term()
 */
int set_network_terminal_type(string name) {
  if (term_name != "network") return 0;
  if (!name) {
    _event_info->cur_term = "dumb";
    _event_info->colour_map = 0;
  }
  if (_event_info->colour_map =
      (mapping)TERM_HANDLER->set_network_term_type(name, query_property(PLAYER_ALLOW_COLOURED_SOULS))) {
    _event_info->cur_term = name;
    return 1;
  }
} /* set_network_terminal_type() */

/**
 * This method resets the colour map information on the player.  THis is
 * called when some change is made to the terminal data and it needs to
 * be updated.
 */
void reset_colour_map() {
   _event_info->colour_map = 0;
}

/*
mapping query_debug_colour_map() {
   return _event_info->colour_map;
}
 */

/** 
 * This method adds all the event commands onto the player.
 * This will be called in the player startup sequence.
 */
void event_commands(){
  add_command("rows", this_object(), "", (: set_our_rows(0) :));
  add_command("cols", this_object(), "", (: set_our_cols(0, 0) :));
  add_command("rows", this_object(), "<number>", (: set_our_rows($4[0]) :));
  add_command("cols", this_object(), "<number>", (: set_our_cols($4[0], 0) :));
  add_command("cols", this_object(), "test <number>", (: set_our_cols($4[0], 1) :));
  add_command("term", this_object(), "{" + 
                implode((string *)TERM_HANDLER->query_term_types() +
                ({ "network" }), "|")+"}", (: set_term_type($4[0]) :));
  add_command("term", this_object(), "", (: set_term_type(0) :));
  add_command("inform", this_object(), "", (: do_inform(0) :));
  add_command("inform", this_object(), "<string>", (: do_inform($4[0]) :));
  
  /* If a liaison or a lord... */
  if (this_object()->query_creator()) {
    add_command("busy", this_object(), "{on|off}", (: do_busy($4[0]) :));
    add_command("busy", this_object(), "<indirect:player>",
                (: do_busy_player($1) :));

  }
}

/**
 * Return function pointer for do_tell_his, for htell only.
 */

function get_htell_func(){
  if(file_name(previous_object()) != "/cmds/player/ht_ell")
    return 0;
  return (:do_tell_his:);
}

/**
 * This method is the command used to print a players tell history.
 */
protected varargs int do_tell_his(string str, int brief) {
  string ret;
  mixed bit, *filter_history;

  if (str != "")  {
    filter_history = filter(tell_history,
                            (: strsrch(lower_case($1[0]), $(str)) > -1 :));
  }
  else filter_history = tell_history;
  if (!pointerp(filter_history) || !sizeof(filter_history)) {
    return notify_fail("You have not been told anything.\n");
  }
  if (undefinedp(brief))  brief = 0;
  ret = "$P$Tell History$P$Your tell history is:\n";
  foreach (bit in filter_history) {
    if (!brief) {
      ret += "** "+ctime(bit[2])+" **\n";
    }
    ret += fix_string("%s%s\n", cols, strlen(bit[0]), 0, bit[0], bit[1]);
  }
  write(ret);
  return 1;
} /* do_tell_his() */

/**
 * This method handles setting the busy flag.  The busy flag can only
 * be set by liaisons and lords, why lords?  Just because :)  This
 * command was inspired by moonchild.
 * @param str the on or off string
 * @return 1 on success, 0 on failure
 */
int do_busy(string str) {
   if (str == "on") {
      _event_info->busy = 1;
   } else {
      _event_info->busy = 0;
   }
   write("Busy set to " + str + ".\n");
   return 1;
} /* do_busy() */

/**
 * This method allows creators to set the player for whom they are currently
 * busy too.
 * @param obs the player to be busy with
 * @return 1 on success, 0 on failure
 */
int do_busy_player(object *obs) {
   write("Ok, setting you as busy with " + query_multiple_short(obs) + ".\n");
   _event_info->busy = obs;
   return 1;
} /* do_busy_player() */

/**
 * This method tells us if the player/creator/lord is currently in busy
 * mode.  This will be 1 if the creatopr is generaly busy, or
 * it will return the array of players they are busy with.
 * @return the busy mode flag
 */
mixed query_busy() {
   if (pointerp(_event_info->busy)) {
      _event_info->busy -= ({ 0 });
   }
   if (pointerp(_event_info->busy) && !sizeof(_event_info->busy)) {
      _event_info->busy = 0;
   }
   return _event_info->busy;
} /* query_busy() */
 
/**
 * This method will change the current value of the earmuffs on the player.
 * @see check_earmuffs()
 * @see query_earmuffs()
 */
void toggle_earmuffs() {
  earmuffs = !earmuffs;
} /* toggle_earmuffs() */

/**
 * This method will set the system to allow friends to punch through
 * earmuffs.
 * @see check_earmuffs()
 * @see query_earmuffs()
 */
void set_allow_friends_earmuffs() {
  earmuffs = PLAYER_ALLOW_FRIENDS_EARMUFF;
} /* toggle_earmuffs() */

/**
 * This method checks to see if a particular event is earmuffed.
 * @param type the type of event to check
 * @param person the person who is being checked for the earmuffing of
 * @return 1 if the event is earmuffed and 0 if it is not
 * @see toggle_earmuffs()
 * @see query_earmuffs()
 * @example
 * obs = users();
 * 
 * obs = filter(obs, (: $1->check_earmuffs("shout", this_player()) :) );
 * // Do the shout
 */
int check_earmuffs(string type, object person) {
  string *on;

  if (!earmuffs) {
    return 0;
  }
  on = (string *)this_object()->query_property(PLAYER_EARMUFF_PROP);
  if (!on) {
     return 0;
  }
  if (member_array(type, on) == -1) {
    return 0;
  }
  // If they are a friend they punch through
  if (!person) {
    person = this_player();
  }
  if (person && earmuffs == PLAYER_ALLOW_FRIENDS_EARMUFF) {
    if (is_friend(person->query_name())) {
      return 0;
    }
  }
  return 1;
} /* check_earmuffs() */

/**
 * This method sets the number of rows on the players screen.
 * @param i the new number of rows
 * @see query_rows()
 */
void set_rows(int i) {
  if (i < 5) {
     return ;
  }
  rows = i;
} /* set_rows() */

/**
 * This method returns the current number of rows the player has
 * set on their screen.
 * @return the number of rows on the screen
 * @see set_rows()
 */
int query_rows() { return rows; }

private int set_our_rows(int val) {
  if (!val) {
    notify_fail("Rows currently set to " + rows + ".\nrows <number> to set.\n");
    return 0;
  }
  if (val <= 10) {
    notify_fail("Invalid number of rows.\n");
    return 0;
  }
  write("Rows set to " + val + ".\n");
  rows = val;
  return 1;
} /* set_our_rows() */

/**
 * This method returns the current number of columns the player has
 * set on their screen.
 * @return the number of columns on the screen
 * @see set_cols()
 */
int query_cols() { return cols; }

/**
 * This method sets the current number of columns the player has set on
 * their screen.
 * @param i the new number of columns
 * @see query_cols()
 */
void set_cols(int i) {
  if (i <= 10 || i > 999)
     return ;
   cols = i;
} /* set_cols() */

private int set_our_cols(int val, int test) {
  int cur;

  if(!val) {
    notify_fail("Columns currently set to " + cols + ".\ncols <number> to set.\n");
    return 0;
  }
  if(val <= 35 || val > 999) {
    notify_fail("Invalid column size.\n");
    return 0;
  }

  if (test)  {
    cur = cols;
    cols = val;
    /* Watch this.... */
    write(implode(allocate(val, (: sprintf("%d", ($1 + 1) % 10) :)), "") + "\n");
    call_out((: cols = $(cur) :), 3);
    return 1;    
  }
  write("Columns set to " + val + ".\n");
  cols = val;
  return 1;
} /* set_our_cols() */

/**
 * set the colour codes for a given event
 */
void set_my_colours(string event_type, string colour) {
  if(colour == "default") {
    map_delete(my_colours, event_type);
  } else if(colour == "none") {
    my_colours[event_type] = "";
  } else {
    my_colours[event_type] = colour;
  }
}

/**
 * Return a players list of custom colours.
 * @return a mapping of the players custom colours for different events.
 */
mapping query_my_colours() {
  return my_colours;
}

void set_looked( object thing ) { _event_info->where = thing; }

/**
 * This method does all those terrible things with messages and $'s
 * turning them into real strings.  It is a neat function if somewhat
 * complicated :)  It was written by Deutha.
 * <p>
 * The return array has two elements, the first being the reformed
 * message and the second being the reformed things array.
 * @param message the message to reform
 * @param things some bonus things to reform it with
 * @return an array consisting of two elements
 */
mixed *reform_message( string message, mixed *things ) {
   int last, number;
   string before, middle, after, info;

   last = -1;
   if ( !things ) {
      things = ({ });
   } else {
      last = sizeof(things) - 1;
   }
   if ( !_event_info->where ) {
      _event_info->where = environment();
   }
   if (strsrch(message, "$L$") != -1) {
      while ( sscanf( message, "%s$L$%s$L$%s", before, middle, after ) == 3 ) {
         if (sscanf( middle, "[%s]%s", info, middle) == 2) {
            if (info[0..4] == "read:") {
               middle = LANGUAGE_HAND->garble_text(info[5..], middle, 0, this_object());
            } else {
               middle = LANGUAGE_HAND->garble_text_say(middle, info, this_object());
            }
         }
         message = sprintf("%s%s%s", before, middle, after);
      }
   }

   if (strsrch(message, "$R$") != -1) {
      while ( sscanf( message, "%s$R$%s$R$%s", before, middle, after ) == 3 ) {
         if ( sscanf( middle, "[%s]%s", info, middle ) != 2 ) {
            info = "";
         }
         switch ( middle[ 0 ] ) {
            case '-' :
               number = 0;
               middle = middle[ 1 .. ];
               break;
            case '+' :
               number = 1;
               middle = middle[ 1 .. ];
               break;
            default :
               number = 2;
         }
         if ( ( number == 2 ) || _event_info->where->query_relative( middle ) ) {
            if ( this_object()->query_creator() ) {
               message = sprintf("%s%s (%s)%s", before, find_rel(middle, number),
                                 middle, after);
            } else {
               message = sprintf("%s%s%s", before, find_rel(middle, number),
                                 after);
            }
         } else {
            message = sprintf("%s%s%s%s", before, info, middle, after);
         }
      }
   }
   if (strsrch(message, "$r$") != -1) {
      while ( sscanf( message, "%s$r$%s$r$%s", before, middle, after ) == 3 ) {
         if ( sscanf( middle, "[%s]%s", info, middle ) != 2 ) {
            info = "";
         }
         switch ( middle[ 0 ] ) {
            case '-' :
               number = 0;
               middle = middle[ 1 .. ];
               break;
            case '+' :
               number = 1;
               middle = middle[ 1 .. ];
               break;
            default :
               number = 2;
         }
         if ( ( number == 2 ) || _event_info->where->query_relative( LENGTHEN[ middle ] ) ) {
            if ( this_object()->query_creator() ) {
               message = sprintf("%s%s (%s)%s", before,
                                 SHORTEN[find_rel(LENGTHEN[middle], number)],
                                 middle, after);
            } else {
               message = sprintf("%s%s%s", before,
                                 SHORTEN[find_rel(LENGTHEN[middle], number)],
                                 after);
            }
         } else {
            message = sprintf("%s%s%s%s", before, info, middle, after);
         }
      }
   }
#ifdef DEBUG
   if ( this_object()->query_property( "see eemessages" ) )
      efun::tell_object( this_object(), "Looking at "+ message +".\n" );
#endif   
   if (strsrch(message, "$M$") != -1) {
      while ( sscanf( message, "%s$M$%s$M$%s", before, middle, after ) == 3 ) {
#ifdef DEBUG     
         if ( this_object()->query_property( "see eemessages" ) )
            efun::tell_object( this_object(), "Expanding "+ middle +".\n" );
#endif      
         last++;
         message = sprintf("%s$%d$%s", before, last, after);
         things += ({ ({ }) });
         if (strsrch(middle, "$") == -1) {
            things[ last ] += ({ middle });
            middle = 0;
         } else {
            while ( sscanf( middle, "$%s$%s", info, middle ) == 2 ) {
#ifdef DEBUG        
               if ( this_object()->query_property( "see eemessages" ) ) {
                  efun::tell_object( this_object(), "Found "+ info +".\n" );
               }
#endif      
               things[ last ] += ({ "my_"+ info });
            }
         }
      }
   }
   if (strsrch(message, "$") != -1) {
      after = message;
      message = "";
      while ( sscanf( after, "%s$%s$%s", before, middle, after ) == 3 ) {
#ifdef DEBUG     
         if ( this_object()->query_property( "see eemessages" ) )
            efun::tell_object( this_object(), "Trying "+ middle +".\n" );
#endif      
         if ( sscanf( middle, "%s_short:%s", middle, info ) != 2 ) {
            message = sprintf("%s%s$%s", message, before, middle);
            after = sprintf("$%s", after);
            continue;
         }
         last++;
         message = sprintf("%s%s$%d$", message, before, last);
         things += ({ ({ sprintf("my_%s_short:%s", middle, info) }) });
      }
      message += after;
   }
   return ({ message, things });
} /* reform_message() */

/**
 * This adds a message into the current list of printable messages.  This
 * will be squided up together and printed out slightly later, this handles
 * the concatenating of enter messages, and soul messages.  Etc.
 * @param message the message to add
 * @param things the objects which are involved with the message
 * @see reform_message()
 */
void add_message( string message, mixed *things ) {
   int last;
   mixed *stuff;

   if ( !interactive( this_object() ) ) {
      return;
   }
   if ( strsrch( message, "$" ) == -1 ) {
      stuff = ({ message, things });
   } else  {
      stuff = reform_message( message, things );
   }
   _event_info->where = 0;
   if ( !sizeof( _event_info->eemessages ) ) {
      _event_info->eemessages = stuff;
   } else {
      last = sizeof( _event_info->eemessages ) - 2;
      if ( ( stuff[ 0 ] == _event_info->eemessages[ last ] ) &&
            ( sizeof( stuff[ 1 ] ) == 1 ) ) {
         if ( sizeof( filter( stuff[ 1 ][ 0 ], (: member_array($1, $2) != -1 :),
               _event_info->eemessages[ last + 1 ][ 0 ] ) ) ) {
            _event_info->eemessages += stuff;
         } else {
            _event_info->eemessages[ last + 1 ][ 0 ] += stuff[ 1 ][ 0 ]; 
         }
      } else {
         _event_info->eemessages += stuff;
      }
   }
#ifdef DEBUG
   if ( this_object()->query_property( "see eemessages" ) )
      efun::tell_object( this_object(), sprintf( "%O\n", _event_info->eemessages ) );
#endif   
} /* add_message() */

/**
 * @ignore yes 
 * This method is used for the reform_mesage stuff
 */
string get_pretty_short( object thing, int dark ) {
  if (dark && environment(thing) != this_object()) {
    if (living(thing) && thing->query_race_ob() &&
        (thing->query_race_ob())->query_humanoid()) {
      return "someone";
    } else {
      return "something";
    }
  }

  if ( !thing->query_visible( this_object() ) ) {
    if (living(thing) && thing->query_race_ob() &&
        (thing->query_race_ob())->query_humanoid()) {
      return "someone";
    } else {
      return "something";
    }
  }

#ifdef USE_ROLE_PLAYING_SHORTS
   if(interactive(thing) &&
      this_object()->query_role_playing() &&
      !this_object()->is_friend(thing->query_name())) {
     return thing->query_short_desc();
   }
#endif
   
   return (string)thing->pretty_short( this_object() ) +
         (string)thing->hide_invis_string();
} /* get_pretty_short() */

/**
 * @ignore yes
 * This method is used for the reform_mesage stuff
 */
string get_pretty_plural( object thing, int dark ) {
   if (dark && environment(thing) != this_object()) {
      if (living(thing)) {
         return "people";
      } else {
         return "things";
      }
   }

   if ( !thing->query_visible( this_object() ) ) {
      return "things";
   }

#ifdef USE_ROLE_PLAYING_SHORTS
   if(interactive(thing) &&
      this_object()->query_role_playing() &&
      !this_object()->is_friend(thing->query_name())) {
     return thing->query_plural_desc();
   }
#endif

   return (string)thing->pretty_plural( this_object() ) +
         (string)thing->hide_invis_string();
} /* get_pretty_plural() */

/**
 * This is a special function for use with the reform message, it allows
 * the string to be echoed into the list instead of using the object's
 * value itself.  This is done specifically to handle objects with
 * variable shorts, so we get the short description correct at the
 * moment it is queried.
 */
string my_mirror_short( object thing, string arg) {
   if (objectp(thing)  &&  userp(thing))
      return thing->short(0, 0);
   return arg;
} /* my_mirror_short() */

/**
 * @ignore yes
 * This method is used for the reform_mesage stuff
 */
string my_a_short( object thing, string arg, int dark) {
   string article;

   if (!thing) {
      return "something";
   }
   if (dark && environment(thing) != this_object()) {
      // Allow remote shorts to work.
     if (living(thing) && thing->query_race_ob() &&
         (thing->query_race_ob())->query_humanoid()) {
       if (environment(thing) != environment()) {
         return "someone";
       }
     } else {
       return "something";
     }
   }

   if ( !objectp( thing ) ) {
     return "an unknown object";
   }

   article = (string)thing->query_determinate( this_object() );
   if ( !article ) {
      return add_a( (string)this_object()->get_pretty_short( thing, dark ) );
   }
   return article + (string)this_object()->get_pretty_short( thing, dark );
} /* my_a_short() */

/**
 * @ignore yes
 * This method is used for the reform_mesage stuff
 */
string my_the_short( object thing, string arg, int dark ) {
   string article;

   if (dark && environment(thing) != this_object()) {
      // Allow remote shorts to work.
     if (living(thing) && thing->query_race_ob() &&
         (thing->query_race_ob())->query_humanoid()) {
         if (environment(thing) == environment()) {
            return "someone";
         }
      } else {
         return "something";
      }
   }

   if ( !objectp( thing ) ) {
      return "the unknown object";
   }

   article = (string)thing->query_determinate( this_object() );
   if ( !article || ( article == "a " ) || ( article == "an " ) )
      return "the "+ (string)this_object()->get_pretty_short( thing, dark );
   return article + (string)this_object()->get_pretty_short( thing, dark );
} /* my_the_short() */

int some_more( string word ) {
    return sizeof( filter( all_inventory( _event_info->where ),
        (: $1->query_plural() == $(word) &&
           $1->query_visible(this_object()) :))) > 1;
} /* some_more() */

/**
 * @ignore yes
 * This method is used for the reform_mesage stuff
 */
string my_one_short( object thing, string arg, int dark ) {
   string article, its_plural;

   if (dark && environment(thing) != this_object()) {
      // Allow remote shorts to work.
     if (living(thing) && thing->query_race_ob() &&
         (thing->query_race_ob())->query_humanoid()) {
         if (environment(thing) == environment()) {
            return "someone";
         }
      } else {
         return "something";
      }
   }

   if ( !objectp( thing ) ) {
      return "one of the unknown objects";
   }
   if ( environment( thing ) != environment() ) {
      _event_info->where = this_object();
   } else {
      _event_info->where = environment();
   }

   /* return my_a_short( thing ); */
   article = (string)thing->query_determinate( this_object() );
   if ( !article || ( article == "a " ) || ( article == "an " ) ) {
      its_plural = (string)this_object()->get_pretty_plural( thing, dark );
      if ( some_more( its_plural ) ) {
         return "one of the "+ its_plural;
      }
      return "the "+ (string)this_object()->get_pretty_short( thing, dark );
   }
   return article + (string)this_object()->get_pretty_short( thing, dark );
} /* my_one_short() */

/**
 * @ignore yes
 * This method is used for the reform_mesage stuff
 */
string my_poss_short(object thing, string arg, int dark) {
   string its_plural;
   string article;
   string of_whom;

   if (dark && environment(thing) != this_object()) {
      // Allow remote shorts to work.
     if (living(thing) && thing->query_race_ob() &&
         (thing->query_race_ob())->query_humanoid()) {
         if (environment(thing) == environment()) {
            return "someone";
         }
      } else {
         return "something";
      }
   }

   if ( !objectp( thing ) ) {
      return "an unknown object";
   }
   if(living(thing)) {
     if (thing == this_object()) {
       return "your";
     } else {
       of_whom = this_object()->get_pretty_short( thing, dark );
       if(of_whom[<1] == 's')
         of_whom = of_whom + "'";
       else
         of_whom = of_whom +"'s";
       return of_whom;
     }
   }
   _event_info->where = environment( thing );
   if ( !_event_info->where ) {
      return my_a_short( thing, arg, dark );
   }
   if ( !living( _event_info->where ) && !_event_info->where->query_corpse() ) {
      return my_a_short( thing, arg, dark );
   }
#ifdef DEBUG
   if ( this_object()->query_property( "see eemessages" ) )
      efun::tell_object( this_object(), sprintf( "%O\n", _event_info->had_shorts ) );
#endif   
   if ( _event_info->where == this_object() ) {
      of_whom = "your ";
   } else {
      if ( member_array( _event_info->where, _event_info->had_shorts ) != -1 ) {
         of_whom = (string)_event_info->where->query_possessive() +" ";
      } else {
        of_whom = my_the_short( _event_info->where, arg, dark );
        if(of_whom[<1] == 's') {
          of_whom = of_whom + "' ";
        } else {
          of_whom = of_whom +"'s ";
        }
      }
   }
   if ( !article || ( article == "a " ) || ( article == "an " ) ) {
      its_plural = (string)this_object()->get_pretty_plural( thing, dark );
      if ( some_more( its_plural ) ) {
         return "one of "+ of_whom + its_plural;
      }
   }
   return of_whom + (string)this_object()->get_pretty_short( thing, dark );
}

/**
 * @ignore yes
 * This method is used for the reform_mesage stuff
 */
string my_the_poss_short(object thing, string arg, int dark) {
   string its_plural;
   string article;
   string of_whom;

   if (dark && environment(thing) != this_object()) {
      // Allow remote shorts to work.
      if (living(thing)) {
         if (environment(thing) == environment()) {
            return "someone's";
         }
      } else {
         return "something's";
      }
   }

   if ( !objectp( thing ) ) {
      return "an unknown object's";
   }

   article = (string)thing->query_determinate(this_object());
   if(!article || (article == "a " || article == "an "))
     article = "the ";

   if(living(thing)) {
     if (thing == this_object()) {
       return "your";
     } else {
       of_whom = this_object()->get_pretty_short( thing, dark );
       if(of_whom[<1] == 's')
         of_whom = of_whom + "'";
       else
         of_whom = of_whom +"'s";
       return article + of_whom;
     }
   }
   _event_info->where = environment( thing );
   if ( !_event_info->where ) {
      return my_the_short( thing, arg, dark );
   }
   if ( !living( _event_info->where ) && !_event_info->where->query_corpse()) {
      return my_the_short(thing, arg, dark);
   }
#ifdef DEBUG
   if ( this_object()->query_property( "see eemessages" ) )
      efun::tell_object(this_object(), sprintf("%O\n",
                                               _event_info->had_shorts));
#endif   
   if ( _event_info->where == this_object() ) {
     of_whom = "your ";
   } else {
     if(member_array( _event_info->where, _event_info->had_shorts ) != -1) {
       debug_printf("Had shorts");
       of_whom = (string)_event_info->where->query_possessive() +" ";
     } else {
       of_whom = my_the_short(_event_info->where, arg, dark);
       if(of_whom[<1] == 's') {
         of_whom = of_whom + "' ";
       } else {
         of_whom = of_whom +"'s ";
       }
     }
   }
   
   its_plural = (string)this_object()->get_pretty_plural( thing, dark );
   if(some_more(its_plural))
     return "one of "+ article + of_whom + its_plural;
   
   return of_whom + article + this_object()->get_pretty_short(thing, dark);
}

/** @ignore yes */
protected void clear_event_info_had_shorts() { _event_info->had_shorts = ({ }); }

/**
 * @ignore yes
 * This method is used for the reform_mesage stuff
 */
varargs string calc_shorts( string *short_list, int exact ) {
   int i;
   int dark;
   string list;
   string str;
   string desc;
   object ob;
   object *things;
   //mapping shorts;
   // These next two are tied.
   string *descs_str;
   mixed *descs_ob;
   mixed *parts;
   function number;

   descs_str = ({ });
   descs_ob  = ({ });
   if (!_event_info->had_shorts)  clear_event_info_had_shorts();
   if (exact) {
      number = (: query_num($1) :);
   } else {
      number = (: query_num($1, 20) :);
   }
   if (environment()) {
      dark = this_object()->check_dark(environment()->query_light());
   }
   foreach (str in short_list) {
      parts = explode( str, ":" );
      if (sizeof(parts) == 2) {
         ob = find_object( parts[ 1 ] );
      } else if (sizeof(parts) > 2) {
         parts[1] = implode(parts[ 1.. ], ":");
         ob = find_object( parts[1] );
      } else {
         ob = 0;
         parts += ({ "" });
      }
#ifdef DEBUG
      if ( this_object()->query_property( "see eemessages" ) )
         efun::tell_object( this_object(), sprintf( "%O\n", ob ) );
#endif      
      if (ob) {
         _event_info->had_shorts = ({ ob }) + _event_info->had_shorts;
      }
      if ( ob == this_object() ) {
         if (parts[0] == "my_poss_short" || parts[0] == "my_the_poss_short") {
            desc = "your";
         } else {
            desc = "you";
         }
      } else if (sizeof(parts) >= 2) {
#ifdef DISBALED
        // We were crashing a lot in this call so the code below is a
        // workaround attempt to see if we can prevent the crashing.
         desc = (string)call_other( this_object(), parts[0], ob, parts[1], dark);
#else
         switch(parts[0]) {
         case "my_mirror_short":
           desc = my_mirror_short(ob, parts[1]);
           break;
         case "my_a_short":
           desc = my_a_short(ob, parts[1], dark);
           break;
         case "my_the_short":
           desc = my_the_short(ob, parts[1], dark);
           break;
         case "my_one_short":
           desc = my_one_short(ob, parts[1], dark);
           break;
         case "my_poss_short":
           desc = my_poss_short(ob, parts[1], dark);
           break;
         case "my_the_poss_short":
           desc = my_the_poss_short(ob, parts[1], dark);
           break;
         }
#endif
      } else {
         if (sizeof(parts[0])) {
            desc = parts[0];
         } else {
            desc = "something";
         }
      }
      i = member_array(desc, descs_str);
      if (i == -1) {
         descs_str += ({ desc });
         descs_ob += ({ ({ ob }) });
      } else {
         descs_ob[i] += ({ ob });
      }
   }
   i = member_array( "you", descs_str );
   if ( i != -1 && i != sizeof(descs_str) - 1) {
      descs_str = descs_str[0..i-1] + descs_str[i+1..] + ({ "you" });
      descs_ob = descs_ob[0..i-1] +  descs_ob[i+1..] + descs_ob[i..i];
   }
   list = "";
/*
   if (dark) {
     if(sizeof(short_list) > 1) {
        list = "somethings";
     } else {
        if(descs_ob[0] && living(descs_ob[0])) {
           list = "someone";
        } else {
           list = "something";
        }
     }
   } else */ {
      for ( i = 0; i < sizeof( descs_str ); i++ ) {
         things = descs_ob[ i ];
         if ( sizeof( things ) == 1 ) {
            if (exact)  {
               if (things[0]) {
                  list += "one " + things[0]->short();
               } else {
                  list += descs_str[i];
               }
            } else {
               list += descs_str[ i ];
            }
         } else {
            things -= ({ 0 });
            if ( sizeof(things) ) {
               list += evaluate(number, sizeof(things)) + " " +
                     this_object()->get_pretty_plural( things[ 0 ], dark );
            } else {
               list += evaluate(number, sizeof(things)) + " unknown objects";
            }
         }
         if ( i == sizeof( descs_str ) - 1 ) {
            continue;
         }
         if ( i == sizeof( descs_str ) - 2 ) {
            list += " and ";
         } else {
            list += ", ";
         }
      }
   }
   return list;
} /* calc_shorts() */

/**
 * This method handles doing the indenting of the input string, fitting it
 * correctly to the width of the column.
 * @param part the column to do stuff with.
 */
string indent_column(string column, int width, int pad) {
   int left;
   int right;
   int space;
   string *parts;
   string part;
   mixed stuff;
   string ret;

   ret = "";
   if ( column[ 0 .. 2 ] != "$I$" ) {
      column = "$I$0=$C$"+ column;
   }
   parts = explode( column, "$C$" );
   parts = parts[0..0] + map(parts[1..], (: capitalize($1) :));
   parts = explode( implode(parts, ""), "$I$" );
   foreach ( part in parts) {
      sscanf( part, "%s=%s", stuff, part );
      if ( stuff[ 0 ] == ' ' ) {
         space = !space;
      }
      stuff = explode( stuff, "," );
      if ( stuff[ 0 ] != "" ) {
         switch ( stuff[ 0 ][ 0 ] ) {
            case '+' :
               if ( space && ( left > 0 ) && ( part != "" ) ) {
                  part = SPACES[ 0 .. left - 1 ] + part;
               }
               left += to_int( stuff[ 0 ][ 1 .. ] );
               break;
            case '-' :
               left -= to_int( stuff[ 0 ][ 1 .. ] );
               if ( left < 0 ) {
                  left = 0;
               }
               if ( space && ( left > 0 ) && ( part != "" ) ) {
                  part = SPACES[ 0 .. left - 1 ] + part;
               }
               break;
            default :
               left = to_int( stuff[ 0 ] );
         }
      } else {
         left = 0;
      }
      if ( sizeof( stuff ) > 1 ) {
         switch ( stuff[ 1 ][ 0 ] ) {
            case '+' :
               right += to_int( stuff[ 1 ][ 1 .. ] );
               break;
            case '-' :
               right -= to_int( stuff[ 1 ][ 1 .. ] );
               if ( right < 0 )
                  right = 0;
               break;
            default :
               right = to_int( stuff[ 1 ] );
         }
      } else {
         right = 0;
      }
#ifdef DEBUG
      if ( this_object()->query_property( "see eemessages" ) )
         efun::tell_object( this_object(), part +"\n"+
               left +", "+ right +", "+ cols +"\n" );
#endif      
      // Need to change the terminal_colour efun to allow padding.
      if ( left > 0 ) {
         ret += fix_string( part, width - right, left, pad);
      } else {
         ret += fix_string( part, width - right, 0, pad );
      }
   }
   return ret;
}

/**
 * This method fits a message into a the current players screen size.  This
 * does all sorts of other evil stuff too, like handling indenting and
 * all sorts of things!  Most of which I do not understand so I won't
 * say anything about here.  The $C$ does capitalization, $I$<num>=
 * does indenting of all the following lines of <num> spaces.  The
 * message automatically has $I$0=$C$ prepended to the message if it
 * does not start with $I$.  SO if you start a message with $I$ then it
 * will not capitalize the first letter of the message.
 * @param message the message to fit in
 * @return the fitted message
 */
string fit_message( string message ) {
   int i;
   int j;
   int size;
   int width;
   int ok;
   string* columns;
   string num;
   mixed* stuff;
   string ret;

   if ( strlen( message ) < 6 ) {
      return message;
   }
   // The way the columns work, there is a <num>= after the column
   // definition that handles setting how wide the column is, the
   // last column may have the <num> bit blank.
   columns = explode( message, "$COLUMN$" );
   if (sizeof(columns) > 1) {
      stuff = allocate(sizeof(columns), ({ }));
      width = cols;
      for (i = 0; i < sizeof(columns) - 1; i++) {
         if (sscanf(columns[i], "%s=%s", num, columns[i]) == 2) {
            size = to_int(num);
         } else {
            size = 10;
            columns[i] += "\nMust specify a column size.\n";
         }
         width -= size;
         stuff[i] = ({ size }) + explode(indent_column(columns[i], size, 1), "\n");
      }
      stuff[<1] = ({ width }) + explode(indent_column(columns[<1], width, 0), "\n");
      // Now merge them together.
      j = 1;
      ret = "";
      do {
         // Keep going till the bits run out.
         ok = 0;
         for (i = 0; i < sizeof(stuff); i++) {
            if (sizeof(stuff[i]) > j) {
               // Check the colours.
               if (sizeof(stuff[i]) > j + 1) {
                  ok = 1;
               }
               ret += stuff[i][j];
            } else if (i < sizeof(stuff) -1) {
               // Need to pad it out.
               ret += sprintf("%*s ", stuff[i][0] - 1, "");
            }
         }
         j++;
         ret += "\n";
         ret = fix_string(ret);
      } while (ok);
   } else {
      ret = indent_column(columns[0], cols, 0);
   }
   return ret;
} /* fit_message() */

/**
 * This method does any extra mxp processing on the output string
 * so it will work with the client correctly.
 * @param input the input string
 * @return the output string with mangling
 */
string fix_for_mxp(string input) {
    return replace(input, ({
                          "&", "&amp;",
                          "<", "&lt;", ">", "&gt;", 
                          "\n", mxp_next_secure(this_object()) + "<BR>",
                          "MXP&lt;", "<", "MXP&gt;", ">" }));
}

/**
 * This method shows the message to the player.
 * @param message the message to show
 * @see fit_message()
 */
void show_message( string message ) {
   string bit;

   if ( sscanf( message, "$P$%s$P$%s", bit, message ) == 2 ) {
      this_object()->more_string( fit_message( message ), bit, 1 );
   } else {
      // In here we do some mxp processing if need be.
      if (has_mxp(this_object())) {
         efun::tell_object( this_object(), fix_for_mxp( fit_message( message ) ));
      } else {
         efun::tell_object( this_object(), fit_message( message ) );
      }
   }
} /* show_message() */

/**
 * This is the main evaluation routine.  This is the one that
 * co-ordinates the works...  It is used by the print_messages
 * routine to create the message to print out.
 * <p>
 * The input parameter contains two elements, the first is the
 * message and the second is the things array.  This corresponds to
 * the values returned by the fix_message method.
 * @param stuff the message to evaulate
 * @return the nice printed out string
 * @see print_messages()
 */
string evaluate_message( mixed *stuff ) {
   int i;
   string message, start, finish, verb_sing, verb_plur;

   message = stuff[ 0 ];
   clear_event_info_had_shorts();
   for ( i = 0; i < sizeof( stuff[ 1 ] ); i++ ) {
/* Things assume this ordering, so do not change. */
      message = replace_string( message, "$"+ i +"$",
            calc_shorts( stuff[ 1 ][ i ] ) );
      while ( sscanf( message, "%s$V$"+ i +"=%s,%s$V$%s", start, verb_sing,
            verb_plur, finish ) == 4 ) {
         if ( ( sizeof( stuff[ 1 ][ i ] ) == 1 ) &&
               sizeof(_event_info->had_shorts) &&
               objectp( _event_info->had_shorts[ 0 ] ) ) {
            if ( _event_info->had_shorts[ 0 ]->query_property( "group object" ) ||
                  _event_info->had_shorts[ 0 ]->group_object() ) {
               message = sprintf("%s%s%s", start, verb_plur, finish);
            } else {
               message = sprintf("%s%s%s", start, verb_sing, finish);
            }
         } else {
            message = sprintf("%s%s%s", start, verb_plur, finish);
         }
      }
   }
   return message;
} /* evaluate_message() */

/**
 * This prints out the messages after the delay, printing out the
 * messages in a nice cute way.  It still retains the order of the
 * messages though.  This can be forced to occur by a message
 * occuring on the player object which requires something to
 * be printed.
 * @see evaluate_message()
 * @see show_message()
 */
void print_messages() {
   int i;
   string message;
   mixed *messages;

   messages = _event_info->eemessages;
   _event_info->eemessages = ({ });
   for ( i = 0; i < sizeof( messages ); i += 2 ) {
      message = messages[ i ];
      if ( sizeof( messages[ i + 1 ] ) ) {
         message = evaluate_message( ({ message, messages[ i + 1 ] }) );
      }
      show_message( message );
   }
   _event_info->where = 0;
} /* print_messages() */

/**
 * This method will handle doing exciting things to messages and
 * returning them as a usable format.
 * @param message the message to evaluate
 * @return the message in a printable (to the player) format
 * @see evaluate_message()
 */
string convert_message( string message ) {
  if(message)
    message = evaluate_message( reform_message( message, ({ }) ) );
  _event_info->where = 0;
  return message;
} /* convert_message() */

/**
 * This method is called when an inform event is called.
 * @param mess the message to print
 * @param which the type of inform
 * @parm thing the thing associated with the inform
 */
nomask varargs void event_inform( object, mixed mess, string which,
                           object thing ) {
  string *on, inform_col;
  int add_friend_later;

  on = inform_types;
  if (!on) {
     on = ({ });
  }

  if(this_object()->query_property( "inform repressed" ) || !sizeof( on))
      return;
  if(thing && thing->query_creator() && !thing->query_visible(this_object()))
    return;

  if (which == "logon" && is_friend(thing->query_name()) &&
      member_array("friend", on) != -1 ) {
    which = "friend";
  } else if ( ( which == "logon" || which == "link-death" ) &&
      PLAYERINFO_HANDLER->query_alerts_for(thing->query_name()) &&
      member_array("alert", on) != -1 ) {
    which = "alert";
  } else if(member_array(which, on) == -1 ) {
    return;
  }

  if(INFORM_COLOURS[which]) {
    inform_col = colour_event(which, INFORM_COLOURS[which]);
  } else {
    inform_col = colour_event(which, INFORM_COLOURS["default"]);
  }
  
  if(which == "friend") {
    // check for a friend.
    add_friend_later = 0; 
    
    if(!mess) {
      mess = " -- " + query_friend_tag(thing->query_name());
    } else if ( stringp( mess ) ) { 
      mess += " -- " + query_friend_tag(thing->query_name());
    } else { 
      add_friend_later = 1;
    }
    
    if (INFORM_COLOURS["friend"]) {
      inform_col = colour_event(which, INFORM_COLOURS["friend"]);
    }
  }

  if (functionp(mess)) {
    mess = evaluate(mess, this_object());
    
    if ( stringp( mess ) && add_friend_later ) { 
      mess += "%^RESET%^%^" + inform_col + "%^ -- " + 
        query_friend_tag(thing->query_name());
    }
  }

  if(which == "logon" && this_object()->query_lord() &&
     !check_earmuffs("verbose-logon", this_object()) &&
     strsrch(mess, "enters") != -1)
    mess +=  " %^RESET%^%^" + inform_col + "%^" + query_ip_name(thing);

  this_object()->add_message( "[%^"+ inform_col +"%^"+ mess +"%^RESET%^]\n",                              ({ }) );
} /* event_inform() */

/**
 * This method is called when an object leaves or arrives in
 * the room.  It prints out
 * the message, well adds it to the queue of printable messages.
 * @param mess the message to print
 * @param thing the thing which is leaving/arriving
 * @param going if it is going
 */
protected void enter_exit_mess( string mess, object thing, int going ) {
   int i;
   string part, verb, *words;

   mess = replace_string( mess, "$N", "$0$" );
   words = explode( mess, " " );
   for ( i = sizeof( words ) - 1; i > -1; i-- ) {
     /*
      * If $s ends a word, it represents verb conjugation.
      * The test of the following letter is to check that it does end the word.
      */
      if ( ( sscanf( words[ i ], "%s$s%s", verb, part ) == 2 ) &&
            ( ( part[ 0 ] < 97 ) || ( part[ 0 ] > 122 ) ) ) {
         words[ i ] = "$V$0="+ pluralize( verb ) +","+ verb +"$V$"+ part;
      }
      /*
       * If we have %<verb>%, it represents verb conjugation.
       * This is unlikely to get confused with anything else...
       */
      if ( sscanf( words[ i ], "%%%s%%%s", verb, part ) == 3 ) {
         words[ i ] = "$V$0="+ pluralize( verb ) +","+ verb +"$V$"+ part;
      }
   }
   if ( going ) {
      this_object()->add_message( implode( words, " " ) +"\n",
            ({ ({ "my_the_short:"+ file_name( thing ) }) }) );
   } else {
      this_object()->add_message( implode( words, " " ) +"\n",
            ({ ({ "my_a_short:"+ file_name( thing ) }) }) );
   }
} /* enter_exit_mess() */

/**
 * This method is called when an object enters the room.
 * @param thing the thing entering
 * @param mess the message to print on entering
 */
void event_enter( object thing, string mess, object ) {
  if ( !stringp( mess ) )
    return;

  thing->sneak_task(this_object());
  this_object()->perception_task(thing);

  if ( !thing->query_visible( this_object() ) ) {
    return;
  }

  enter_exit_mess( mess, thing, 0 );
  
} /* event_enter() */

/**
 * This method is printed when an object exits the room.
 * @param thing the object exiting
 * @param mess the message to print
 * @param to where the object is going to
 */
void event_exit( object thing, string mess, object to ) {
   ::event_exit( thing, mess, to );
   if ( !stringp( mess ) )
      return;
   if ( !thing->query_visible( this_object() ) )
      return;
   enter_exit_mess( mess, thing, 1 );
} /* event_exit() */

/** @ignore yes */
void event_death( object thing, object *, object killer,
      string room_mess, string killer_mess ) {
   if ( this_object() == thing ) {
      return;
   }

   // Take dead people out of the attacker list
   //this_object()->remove_attacker_list(thing);
   
   if ( ( this_object() == killer ) && stringp( killer_mess ) ) {
      this_object()->add_message( replace( killer_mess, "$D",
            (string)thing->the_short() ), ({ }) );
      print_messages();
      return;
   }
   if ( stringp( room_mess ) ) {
      if ( objectp( killer ) ) {
         this_object()->add_message( replace( room_mess,
               ({ "$D", (string)thing->the_short(),
               "$K", (string)killer->the_short() }) ), ({ }) );
      } else {
         this_object()->add_message( replace( room_mess, "$D",
               (string)thing->the_short() ), ({ }) );
      }
      print_messages();
   }
} /* event_death() */

/**
 * This method is called when the 'say' and 'tell_room' simul_efuns is used.
 * @param caller the object doing the say
 * @param str the message to print
 * @param avoid the people to avoid in the say
 */
void event_say(object caller, string str, mixed avoid, string language) {
  if (pointerp(avoid)) {
    if (member_array(this_object(), avoid) != -1) {
      return ;
    }
  } else if (avoid == this_object()) {
    return ;
  }
  if (language) {
      this_object()->add_message( LANGUAGE_HAND->garble_text_say(str,
                                  language, this_object()), ({ }) );
   } else {
     this_object()->add_message( str, ({ }) );
   }
} /* event_say() */

void event_see( object caller, string words, object thing, mixed avoid ) {
   if ( !thing->query_visible( this_object() ) )
      return;
   event_say( caller, words, avoid, 0 );
} /* event_see() */

/**
 * This method is called by the simul_efun 'write'.
 * @param caller the calling object
 * @param str the string to write, can be a pointer to two strings with a language
 * @param language the language to write with
 */
void event_write(object caller, string str, string language) {
   if (language) {
     this_object()->add_message( LANGUAGE_HAND->garble_text_say(str,
                                    language, this_object()), ({ }) );
   } else {
      this_object()->add_message( str, ({ }) );
   }
   print_messages();
} /* event_write() */

/** @ignore yes */
void do_efun_write( string str, string language ) {
   event_write( 0, str, language );
}

/**
 * This method is called by the soul to print out the soul messages.
 * @param ob the object doing the soul
 * @param str the string to print
 * @param avoid the people not to print the message to
 */
varargs void event_soul(object ob, string str, mixed avoid) {
  //str = replace(str, "%^", " ");
  if (ob != this_object()) {
    if (strsrch(str, "%^") != -1) {
      if (!query_property(PLAYER_ALLOW_COLOURED_SOULS)) {
         str = strip_colours(str);
      }
    }

    if (sizeof(avoid) > 1 && check_earmuffs("multiple-soul", ob)) {
      return ;
    }
    event_say(ob, colour_event("soul", "") + "$C$" + str + "%^RESET%^", avoid, 0);
  } else {
    event_write( ob, str + "%^RESET%^", 0 );
  }
} /* event_soul() */

/**
 * This method is called when someone does an emote.
 * @param thing the object doing the emote
 * @param mess the emote to print
 */
void event_emote( object thing, string mess ) {
   if ( thing == this_object() )
      return;
   this_object()->add_message( colour_event("emote", "%^CYAN%^") + mess + "%^RESET%^", ({ }) );
} /* event_emote() */

/**
 * This method is called when someone says something.
 * @param ob the object doing the say
 * @param start the start message
 * @param mess the message to say
 * @param lang the language it is printed in
 * @param accent the accent object to use
 */
void event_person_say(object ob, string start, string mess, string lang,
                      string accent) {
   string *args, astr, tstr;
   int mangle_accent;

   if(ob == this_object() )
      return;

   if (accent) {
      if (query_nationality_accent_ob() != accent) {
         if (query_mangle_accent()) {
            mangle_accent = 2;
         } else {
            mangle_accent = 1;
         }
      }
   }

   if((lang != query_default_language() && lang != "general") ||
       (accent && mangle_accent == 1)) {

     tstr = start[0..<3];
     if(lang != query_default_language() && lang != "general")
       tstr += " in " + cap_words(lang);

     if(accent && mangle_accent == 1) {
       astr = accent->query_accent_name();
       if(astr[0] == 'a' || astr[0] == 'e' || astr[0] == 'i' ||
          astr[0] == 'o' || astr[0] == 'u')
         astr = "an " + astr;
       else
         astr = "a " + astr;
       
       tstr += " with " + astr + " accent";
     }
     start = tstr + ": ";
   }

   if(this_object()->query_property(SHORTHAND_OUTPUT_PROP)) {
     mess = LANGUAGES->fix_shorthand(mess);
   }

   args = LANGUAGE_HAND->garble_say(lang, start, mess, this_object(),
                                    ob, SAY_TYPE);
   start = args[ 0 ];
   mess = args[ 1 ];

   if (accent && mangle_accent == 2) {
      mess = accent->garble_say(mess, this_object(), ob, SAY_TYPE,
                                query_default_language());
   }
   
   this_object()->add_message( "$I$5=" + colour_event("say", "%^CYAN%^") +
                               "$C$"+ start +
                               mess +"%^RESET%^\n",
             ({ }) );
} /* event_person_say() */

/**
 * @ignore yes
 * Use this on pain of death :)
 */
void add_tell_history(string start, string mess, int remote) {
  if (!pointerp(tell_history)) {
    tell_history = ({ });
  }
  tell_history +=  ({ ({ start, mess, time(), remote }) });
  if (sizeof(tell_history) > MAX_TELL_HIS) {
    tell_history = tell_history[1..];
  }
} /* add_tell_history() */

/* Modification by Pinkfish 8th of August 1995
 * on Grampa's request to remove the nomask.
 */
/**
 * This method is called when a person is told something.
 * @param ob the object doing the tell
 * @param start the start bit of the message
 * @param mess the message itself
 * @param lang the language it was spoken in
 */
/* nomask */ void event_person_tell( object ob, string start, string mess) {
   int id;
   string *args;
   string tmp;
   
   if ( this_object()->query_property( "ignoring" ) ) {
      if ( member_array( (string)ob->query_name(), 
           (string *)this_object()->query_property( "ignoring" ) ) != -1 &&
           !ob->query_creator()) {
         tell_object(ob,this_object()->query_name()+" is ignoring you and "
                     "will not have heard what you said.\n");
         return;
      }
   }

   if(this_object()->query_property(SHORTHAND_OUTPUT_PROP))
     mess = LANGUAGES->fix_shorthand(mess);

   if (_event_info->busy && (!pointerp(_event_info->busy) ||
                             member_array(ob, _event_info->busy) == -1)) {
     tell_object(ob, this_object()->query_cap_name() +
                  " is currently busy with "
                  "someone else, " + this_object()->query_pronoun() + 
                  " has heard this message and will get back to "
                  "you shortly.\n");
      start = "[BUSY] " + start;
   }

   add_tell_history(start, mess, 0);
   tmp = fix_string(replace(colour_event("tell", "%^YELLOW%^"),
                                         "%^", "%%^") +
                                 "%s%s%%^RESET%%^\n",
                                 cols, 5, 0, capitalize(start), mess);
   if (has_mxp(this_object())) {
      efun::tell_object(this_object(), fix_for_mxp(tmp));
   } else {
      efun::tell_object(this_object(), tmp);
   }
   if (userp(this_object()) &&  interactive( this_object() ) &&
      (id = query_idle(this_object())) > TELL_WARN_TIME) {
     args = ({ });
     if (id/(60*60))
        args += ({ (id/(60*60))+" hours" });
     if ((id/60)%60)
        args += ({ ((id/60)%60)+" minutes" });
     if (id%60)
        args += ({ (id%60)+" seconds" });
     write(this_object()->query_name()+" has been idle for "+
           query_multiple_short(args)+".\n");
   }

   if ( this_object()->query_property( PASSED_OUT ) ) {
      write( "Something tells you that $C$"+
            (string)this_object()->query_name() +
            " will be unable to reply to you just yet.\n" );
   }
} /* event_person_tell() */

/**
 * This method is called when the whisper even is generated.
 * @param ob the object whispering
 * @param start the start of the whisper message
 * @param mess the message to print
 * @param obs the objects to tell the message to
 * @param lang the lanaguage the whisper is in
 * @param me the object doing the whispering
 */
void event_whisper(object ob, string start, string mess,
                   object *obs, string lang, object me) {
   string blue;
   string *args;

   blue = "";
   if (me == this_object())
      return;

   if (lang != query_default_language() && lang != "general")
     blue = " in " + cap_words(lang);
   
   if(this_object()->query_property(SHORTHAND_OUTPUT_PROP))
     mess = LANGUAGES->fix_shorthand(mess);

   if ( member_array( this_object(), obs ) == -1)  {
      if(ob->query_visible(this_object()))
         this_object()->add_message( "$I$5=" +
                                   colour_event("whisper", "%^CYAN%^") + "$C$"+
                                   start +
                                   query_multiple_short( obs ) +
                                   ".%^RESET%^\n", ({ }) );
   } else {
      args = LANGUAGE_HAND->garble_say(lang, start, mess, this_object(),
                                    ob, WHISPER_TYPE);
      start = args[ 0 ];
      mess = args[ 1 ];

      if ( sizeof( obs ) == 1 ) {
         this_object()->add_message( "$I$5=" +
                                     colour_event("whisper", "%^CYAN%^") +
                                     "$C$"+ start +"you"+
                                     blue +": "+ mess +"%^RESET%^\n", ({ }) );
      } else {
         this_object()->add_message( "$I$5=" +
                                     colour_event("whisper", "%^CYAN%^") +
                                     "$C$"+ start +
                                     query_multiple_short( obs ) + blue +": " +
                                     mess +"%^RESET%^\n",
                                     ({ }) );
      }
   }
} /* event_whisper() */

/**
 * This method is generated when a shout is done by a player.
 * @param thing the thing doing the shout
 * @param start the start string to print
 * @param mess the message to print
 * @param lang the language the shout is in
 * @param co_ord the co-ordinate of the shouter
 * @param range the range of the shout
 */
void event_person_shout( object thing, string start, string mess, string lang,
      int *co_ord, int range ) {
   /*string garbler; */
   mixed *args;

   if ( this_object() == this_player() ) {
      return;
   }
   if ( check_earmuffs( "shout", thing ) ) {
      return;
   }
   if ( !environment() ) {
      return;
   }
   if ( environment()->query_property( "shout zone" ) !=
        environment( this_player() )->query_property( "shout zone" ) ) {
      return;
   }

   if (lang != query_default_language() && lang != "general") {
      start += " in " + capitalize(lang);
   }

   //
   // Put in a check so you don't see shouts from people you are
   // ignoring.
   //
   if (sizeof(query_ignoring(({ this_player() }))) ) {
      return ;
   }

   args = LANGUAGE_HAND->garble_say(lang, start, mess, this_object(),
                                    thing, SHOUT_TYPE);
   start = args[ 0 ];
   mess = args[ 1 ];
   if(this_object()->query_property(SHORTHAND_OUTPUT_PROP))
     mess = LANGUAGES->fix_shorthand(mess);

   if ( environment() == environment( this_player() ) ) {
      this_object()->add_message( "$I$5=" + colour_event("shout", "") + "$C$"+
                                  start +": "+ mess +"%^RESET%^\n", ({ }) );
      return;
   }
   if ( sizeof( co_ord ) != 3 ) {
      return;
   }
   BROADCASTER->broadcast_event( ({ this_object() }), co_ord, start +
      ": "+ mess, range, 1, 0 );
} /* event_person_shout() */

/**
 * This event is generated when a newbie chat event is done.
 * @param thing the thing generateing the newbie chat
 * @param message the message the newbie said
 */
void event_newbie(object thing, string message) {
  string tmp;

  if((this_player() == this_object() ) ||
     check_earmuffs("newbie", this_player())) {
    return;
  }
  
  if (sizeof(query_ignoring(({ this_player() }))) ) {
    return ;
  }
  
  if(this_object()->query_property(SHORTHAND_OUTPUT_PROP))
    message = LANGUAGES->fix_shorthand(message);
   
  tmp = fix_string(replace(colour_event("newbie", "%^MAGENTA%^"),
                                       "%^", "%%^") +
                               "(newbie)%%^RESET%%^ %s\n",
                               cols, 5, 0, message);
  if (has_mxp(this_object())) {
     efun::tell_object(this_object(), fix_for_mxp(tmp));
  } else {
     efun::tell_object(this_object(), tmp);
  }
}

/**
 * This event is generated when a newbiehelpers chat event is done.
 * @param thing the thing generateing the newbiehelpers chat
 * @param message the message the newbiehelper said
 */
void event_newbiehelpers(object thing, string message) {
  string tmp;

  if((this_player() == this_object() ) ||
     check_earmuffs("newbiehelpers", this_player()) ||
     !NEWBIEHELPERS_HANDLER->query_helper_access(this_object())) {
    return 0;
  }
  
  if (sizeof(query_ignoring(({ this_player() }))) ) {
    return 0;
  }
  
  if(this_object()->query_property(SHORTHAND_OUTPUT_PROP))
    message = LANGUAGES->fix_shorthand(message);
  
  tmp = fix_string(replace(colour_event("newbiehelpers", 
                                  "%^YELLOW%^"), "%^", "%%^") +
                               "(newbiehelpers)%%^RESET%%^ %s\n",
                               cols, 5, 0, message);
  if (has_mxp(this_object())) {
     efun::tell_object(this_object(), fix_for_mxp(tmp));
  } else {
     efun::tell_object(this_object(), tmp);
  }
}

/**
 * This event is generated when a combat message occurs.
 * @param thing the thing generateing the event.
 * @param message the message to be displayed.
 * @param exclude objects not to show this message to.
 * @param verbose is the message considered verbose?
 */
void event_combat(object thing, string message, object *exclude, int verbose) {
  if(member_array(this_object(), exclude) != -1)
    return;

  if(verbose && !this_object()->query_verbose("combat"))
    return;
  
  this_object()->add_message(colour_event("combat", "%^WHITE%^") + "$C$" + 
                             message + "%^RESET%^", ({ }));
  this_object()->print_messages();
}

/**
 * This event is generated when a creator tell is done.
 * @param ob the object generating the event
 * @param start the start bit
 * @param mess the message bit
 * @param forced if it is forced to occur
 * @param channel the creator channel to talk on
 */
nomask void event_creator_tell(object ob, string start, string mess,
                               int forced, string channel) {
  string tmp;
  
  if (!channel)
    channel = "cre";
  
  if (ob == this_object() ||
      ((sizeof(this_object()->query_ignoring( ({ ob }) ) ) || 
        check_earmuffs( channel, ob )) && !forced) ||
      !this_object()->query_creator()) {
    return;
  }
  // Permissions checks.
  if(member_array(channel, this_object()->channel_list()) == -1)
    return;
       
  if(this_object()->query_property(SHORTHAND_OUTPUT_PROP))
    mess = LANGUAGES->fix_shorthand(mess);
 
  tmp = fix_string(replace(colour_event(channel, "%^CYAN%^"),
                                       "%^", "%%^") +
                               "(" + channel + ") %s%s%%^RESET%%^\n",
                               cols, 5, 0, start, mess);
  if (has_mxp(this_object())) {
     efun::tell_object(this_object(), fix_for_mxp(tmp));
  } else {
     efun::tell_object(this_object(), tmp);
  }
}

/**
 * This event is generated when a lord tell is done.
 * @param ob the object generating the event
 * @param start the start bit
 * @param mess the message bit
 * @param forced if it is forced to occur
 */
nomask void event_lord_tell( object ob, string start, string mess,
      int forced ) {
  string tmp;

  if ( this_player() == this_object() ) {
      HIST_HANDLER->add_lord_history(start, mess);
      return;
   }
  if (ob == this_object()
     || (check_earmuffs("lord", ob) && !forced) ||
      !master()->query_lord((string)this_object()->query_name()))
    return;

  if(this_object()->query_property(SHORTHAND_OUTPUT_PROP))
     mess = LANGUAGES->fix_shorthand(mess);

  tmp = fix_string(replace(colour_event("lord", "%^YELLOW%^"),
                                       "%^", "%%^") +
                               "(lord) %s%s%%^RESET%%^\n",
                               cols, 5, 0, start, mess);
  if (has_mxp(this_object())) {
     efun::tell_object(this_object(), fix_for_mxp(tmp));
  } else {
     efun::tell_object(this_object(), tmp);
  }
} /* event_lord_tell() */

/**
 * This event is generated when a intermud creator tell is done.
 * @param ob the object generating the event
 * @param mname the name of the mud
 * @param pname the name of the player
 * @param mess the message
 * @param ig the ignore object
 * @param emote if it is an emote
 */
void event_inter_creator_tell(object ob, string mname, string pname, 
                              string mess, object ig, int emote) {
   string tmp;

  if (!this_object()->query_creator() || check_earmuffs("inter-creator-tell", 0)
      || this_object() == ig)
    return ;
   tmp = fix_string("%s@%s%s%s\n", cols, strlen(mname) + strlen(pname) + 3,
                      0, pname, mname, (emote?" ":": "), mess);
  if (has_mxp(this_object())) {
     efun::tell_object(this_object(), fix_for_mxp(tmp));
  } else {
     efun::tell_object(this_object(), tmp);
  }
} /* event_inter_creator_tell() */

/**
 * This event is generated when a creator tell is done.
 * @param ob the object generating the event
 * @param mname the name of the mud
 * @param pname the name of the player
 * @param mess the message
 * @param ig the ignore object
 * @param emote if it is an emote
 */
void event_intermud_tell(object ob, string start, string mess,
                         string channel, object ig) {
  string tmp;

  if (!this_object()->query_creator() || check_earmuffs("intermud-all", 0)
      || check_earmuffs(channel, 0) || this_object() == ig) {
    return ;
  }
  tmp = fix_string("%%^MAGENTA%%^(%s)%%^RESET%%^ %s%s\n", cols,
                      strlen(start)+ strlen(channel)+ 3, 0, channel, start,
                      mess);
  if (has_mxp(this_object())) {
     efun::tell_object(this_object(), fix_for_mxp(tmp));
  } else {
     efun::tell_object(this_object(), tmp);
  }
} /* event_intermud_tell() */

/**
 * This method is called when an echo to is generated by the player.
 * @param ob the object doing the echo to
 * @param mess the message being printed
 * @param me the person generating the echo to
 */
void event_player_echo_to(object ob, string mess, object me) {
  if ( master()->query_lord( (string)this_object()->query_name() ) )
     this_object()->add_message( "$0$ echos to you:\n", ({ ({ "my_the_short:"+
            file_name( me ) }) }) );
   this_object()->add_message( colour_event("echo", "") + mess + "%^RESET%^",
                               ({ }) );
} /* event_player_echo_to() */

/**
 * This method is called when an emoteall is generated by a player.
 * @param ob the object doing the emoteall
 * @param mess the message being printed
 */
void event_player_emote_all(object ob, string mess) {
  if (ob == this_object()) {
    return;
  }

  if ( master()->query_lord( (string)this_object()->query_name() ) ) {
     this_object()->add_message( "$0$ emotes to all:\n", ({ ({ "my_the_short:"+
            file_name( ob ) }) }) );
  }

  mess = this_object()->colour_event( "emoteall" ) + mess + "%^RESET%^"; 
  
  this_object()->add_message( "$I$5=$C$"+ replace_string( mess, "$N", "$0$" ),
    ({ ({ "my_the_short:"+ file_name( ob ) }) }) );
} /* event_player_emote_all() */

/**
 * This method is called when an echo is generated by a player.
 * @param ob the object doing the echo
 * @param mess the message being printed
 */
void event_player_echo(object ob, string mess) {
   if (ob == this_object()) {
      return;
   }
   if ( master()->query_lord( (string)this_object()->query_name() ) ) {
      this_object()->add_message( "$0$ echos:\n", ({ ({ "my_the_short:"+
            file_name( ob ) }) }) );
   }
   this_object()->add_message( mess, ({ }) );
} /* event_player_echo() */

/**
 * This method is generated internally by the driver when this player is
 * snooping someone else.
 * @param mess the snoop message
 */
void receive_snoop(string mess) {
  tell_object(this_object(), "] "+mess);
} /* receive_snoop() */

/**
 * This is a call back generated by the driver internally to tell us about
 * terminal types.
 * @param type the terminal type returned
 */
void terminal_type(string type) {
  if (set_network_terminal_type(type)) {
    tell_object(this_object(), "Setting your network terminal type to \""+
                type+"\".\n");
  } else {
    if (term_name == "network") {
      if (!_event_info->last_term || _event_info->last_term != type) {
        _event_info->last_term = type;
/* Keep going until they repeat twice.  This is the end of the list. */
        printf("%c%c%c%c%c%c", IAC, SB, TELOPT_TTYPE, TELQUAL_SEND, IAC, SE);
      } else
        tell_object(this_object(), "Unknown terminal type \""+type+"\".\n");
    }
  }
} /* terminal_type() */

/**
 * This is a call back generated by the driver internally to tell us about
 * the window size of the remote machine.  This information in this is
 * only used if the terminal is a network type.
 * @param width the number of columns
 * @param height the number of rows
 */
void window_size(int width, int height) {
  if (term_name == "network") {
    if (width > 10 && width < 256) {
      set_cols(width);
   }
   if (height > 5 && height < 256) {
      set_rows(height);
   }
   tell_object(this_object(), "Your machine told our machine that your "
               "terminal has "+height+" rows and "+width+" columns.\n");
  }
} /* window_size() */

/**
 * This is a callback generated by the driver to deal with mxp related
 * stuff.
 */
void mxp_enable() {
   // Send down some code to turn on the suboption
   efun::tell_object(this_object(),
               sprintf("%c%c%c%c%c%c", IAC, SB, TELOPT_MXP, IAC, SE, 0) +
               sprintf("%c[1z", 27) +
               replace_string(read_file("/doc/login/mxp_setup"), "\n", "") + "\n");
}
// --- END [/mnt/home2/grok/lib/global/events.c] ---
// --- BEGIN [/mnt/home2/grok/lib/global/more_file.c] ---
// Size:   File: "/mnt/home2/grok/lib/global/more_file.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627241   Available: 13574595
Inodes: Total: 5242880    Free: 4960133
12205 bytes, Last Modified:   File: "/mnt/home2/grok/lib/global/more_file.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627241   Available: 13574595
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:52.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: more_file.c,v 1.9 2002/02/26 02:41:22 presto Exp $
 * $Log: more_file.c,v $
 * Revision 1.9  2002/02/26 02:41:22  presto
 * Fixed bug with trying to more a file for which you didn't have read perms.
 * Slight changes for efficiency.
 *
 * Revision 1.8  2001/06/03 20:23:09  pinkfish
 * Change a variable name.
 *
 * Revision 1.7  2001/06/01 21:05:29  ceres
 * Can't remember
 *
 * Revision 1.6  2000/10/20 18:03:57  pinkfish
 * Add in some code to deal with tab stops.
 *
 * Revision 1.5  2000/10/20 17:54:46  ceres
 *  Forcibly unlocked by pinkfish
 *
 * Revision 1.4  2000/04/26 04:53:18  ceres
 * Fixed runtime
 *
 * Revision 1.3  1999/07/24 13:52:30  presto
 * Fix for my fix.  Gerbil was getting sarcastic. :)
 *
 * Revision 1.2  1999/07/24 01:24:54  presto
 * Fixed problem with more-ing files containing blank lines.
 *
 * Revision 1.1  1998/01/06 04:54:05  ceres
 * Initial revision
 * 
*/
/*
 * Original by Ember.
 * Improved version by Pinkfish.
 * Debugged by Deutha.
 */

#include <nroff.h>
#include <cmds/options.h>

#define ROWS (this_player()->query_rows() - 1)
#define COLS this_player()->query_cols()

private nosave int fsize, topl, botl, charl, real_rows, search_flag;
private nosave mixed mark_data;
private nosave string _more_file_fname,
              *mark_name,
              *filenames,
              finish_func,
              stat_line,
              last_search;

private int display_file() {
   int i;
   int ncols;
   int nrows;
   string file;
   string *bits;
   string *lines;
   string tstop;
   int tab;

   ncols = COLS;
   nrows = ROWS;
   file = read_file(_more_file_fname, topl, nrows);
   if (file == 0)
      return 0;

   // Work out the tabstops.
   tab = this_player()->query_property(TABSTOP_PROP);

   if (tab)
      tstop = sprintf("%" + tab + "' 's", "");
   else
      tstop = "<TAB>";

   file = replace(file, ({ "\t", tstop,
                           "\r", "^M",
                           sprintf("%c", 13), "^M" }));

   /* We add the extra character and then remove it from the resulting
    * array because this won't work on totally blank lines. :( */
   bits = explode("x\n" + file, "\n")[1 .. ];
   if (charl)
      bits[0] = bits[0][charl .. ];
   real_rows = 0;
   lines = ({ });
   for (i = 0; i < sizeof(bits); i++)  {
      if (strlen(bits[i]) > ncols)  {
         lines = ({ lines..., bits[i][0 .. ncols - 1] });
         bits[i] = bits[i][ncols .. ];
         charl += ncols;
         --i;
      } else {
         lines  = ({ lines..., bits[i] });
         charl = 0;
         ++real_rows;
      }
      if (sizeof(lines) == nrows)
         break;
   }
   printf("%s\n", implode(lines, "\n"));
   botl = topl + real_rows - 1;
   if (botl > fsize)
      botl = fsize;
  return 1;
} /* display_file() */


private int get_next_filename() {
  string str;

  _more_file_fname = filenames[0];
  filenames = filenames[1 .. ];
  fsize = file_length(_more_file_fname);
  if (fsize == 0) {
    printf("Empty file.\n");
    if (sizeof(filenames) > 1)
      return get_next_filename();
    else
      return 0;
  }
  if (fsize == -1) {
    printf("File does not exist.\n");
    if (sizeof(filenames) > 1)
      return get_next_filename();
    else
      return 0;
  }
  if (fsize == -2) {
    printf("You cannot more a directory.\n");
    if (sizeof(filenames) > 1)
      return get_next_filename();
    else
      return 0;
  }
  topl = 1;
  charl = 0;
  printf( "\n" );
  str = read_file(_more_file_fname, 1, 1);
  if (str == 0)
    return 0;
  
  if (str[0] == '.')  {
    string s2;

    /*
     * Nroff file...  do horrible things!  Turn into a mushroom!  Blow up
     * all the hairy crater eating womble doovalacies...
     * In the case of a nroff file we push the file through nroff then shove
     * it through more_string...
     */
    str = "/tmp/nroffed_file";
    if (NROFF_HAND->create_nroff(_more_file_fname, "/tmp/nroffed_file")) {
      s2 = NROFF_HAND->cat_file("/tmp/nroffed_file");
      rm("/tmp/nroffed_file.o");
      if (s2 != 0) {
        this_player()->more_string(s2, _more_file_fname);
        fsize = ROWS - 3;
        return 1;
      }
    }
  }
  return display_file();
} /* get_next_file_name() */


private string *expand_path(string s) {
  string *s1;

  s1 = this_player()->get_files(s);
  if (s1 == 0)
    return ({ s });
  return s1;
} /* expand_path() */


int set_mark(string s) {
   int i;
   
   if (!mark_name) {
      mark_name = ({ });
      mark_data = ({ });
   }
   if ((i = member_array(s, mark_name)) != -1)
      mark_data[i] = ({ _more_file_fname, topl });
   else {
      mark_name += ({ s });
      mark_data += ({ ({ _more_file_fname, topl }) });
   }
   return 1;
} /* set_mark() */


private void status_line() {
   string *frog;
   string s;
   int i, percentage;
   
   if (!stat_line)
      stat_line = "$N From $T to $B of $S ($%%) - h for help. ";
   s = "";
   frog = explode(stat_line, "$");
   for (i = 0; i < sizeof(frog); i++) {
      if (frog[i] == "") {
         s += "$";
         ++i;
      }
      else switch (frog[i][0]) {
         case 'N':
            s += _more_file_fname + frog[i][1 .. ];
            break;

         case 'T':
            s += topl + frog[i][1 .. ];
            break;

         case 'B':
            if (botl > fsize)
               s += fsize + frog[i][1 .. ];
            else
               s += botl + frog[i][1 .. ];
            break;

         case '%':
            percentage = (botl * 100) / fsize;
            if (percentage > 100) percentage = 100;
            s += percentage + frog[i][1 .. ];
            break;

         case 'S':
            s += fsize + frog[i][1 .. ];
            break;

         default:
            printf("Bad tag (%s) found in format string.\n", frog[i]);
            break;
      }
   }
   printf("%s", s);
   return;
} /* status_line() */


void next_page(string str) {
   int num, noargs, i, j, k, redraw;
   string s1, *s3;
   
   if (str == 0)
      str = "";
   
   if (sscanf(str, "%d%s", num, str) != 2)
      noargs = 1;
   s1 = extract(str, 1);
   /* case statements WEEEEEE */
   switch (str[0 .. 0]) {
      case "":
      case " ":
         topl += real_rows;
         redraw = 1;
         break;

      case "f":
         /* go on a number of pages... */
         if (noargs)
            num = 1;
         topl += ROWS * num;
         redraw = 1;
         break;

      case "q" :
         printf("OK.\n");
         return;

      case "/":
         /* sigh */
         search_flag = 0;
         j = topl + 4;
         if (s1[0] == '!') {
            search_flag = 1;
            s1 = extract(s1, 1);
         }
         set_mark("'");
         if (s1=="" || !s1)
            s1 = last_search;
         if (s1 == "") {
            printf("No previous search string.\n");
            break;
         }
         do {
            i = j;
            j = i + 900;
            if (j > fsize)
               j = fsize;
            s3 = explode(read_file(_more_file_fname, i, j), "\n");
            for (k = 0; k < sizeof(s3); k++)
               if (!search_flag) {
                  if (sscanf(s3[k], "%*s" + s1 + "%*s") == 2)
                     if (num-- <= 0)
                        break;
               } else
                  if (sscanf(s3[k], "%*s" + s1 + "%*s") != 2)
                     if (num-- <= 0)
                     break;
         } while (j < fsize && k == sizeof(s3));
         if (k == sizeof(s3))
            printf("Sorry " + s1 + " not found.\n");
         else {
            topl = i + k - 3;
            redraw = 1;
         }
         last_search = s1;
         break;

      case "?":
         i = topl;
         if (s1[0] == '!') {
            s1 = extract(s1, 1);
            search_flag = 3;
         } else
            search_flag = 2;
         set_mark("'");
         if (s1=="" || !s1)
            s1 = last_search;
         if (s1 == "") {
            printf("No previous search string.\n");
            break;
         }
         do {
            j = i - 900;
            if (j < 0)
               j = 0;
            s3 = explode(read_file(_more_file_fname, j, i), "\n");
            for (k = 0; k < sizeof(s3); k++)
               if (search_flag == 2) {
                  if (sscanf(s3[k], "%*s" + s1 + "%*s") == 2)
                     if (num-- <= 0)
                        break;
               } else
                  if (sscanf(s3[k], "%*s" + s1 + "%*s") != 2)
                     if (num-- <= 0)
                        break;
            i = j;
         } while (j > 0 && k == sizeof(s3));
         if (k == sizeof(s3))
            printf("Sorry "+ s1 +" not found.\n");
         else {
            topl = k + i - 2;
            redraw = 1;
         }
         last_search = s1;
         break;

      case "n":
         switch (search_flag) {
            case 0:
               next_page(num + "/");
               break;

            case 1:
               next_page(num + "/!");
               break;

            case 2:
               next_page(num + "?");
               break;

            case 3:
               next_page(num + "?!");
               break;
         }
         return;

      case "b":
         if (noargs)
            num = 1;
         if (topl > 0) {
            topl -= ROWS * num;
            redraw = 1;
            if (topl < 0)
               topl = 0;
         }
         break;

      case "G":
         if (noargs)
            num = fsize - ROWS + 1;
  
      case "g":
         set_mark("'");
         topl = num;
         if (topl >= fsize)
         topl = fsize - 2;
         redraw = 1;
         break;

      case "P":
         if (noargs)
            num = 100;

      case "p":
      case "%":
         redraw = 1;
         set_mark("'");
         topl = (num * fsize) / 100;
         if (topl + ROWS - 1 > fsize)
            topl -= ROWS - 1;
         break;

      case "d":
         if (noargs)
            num = ROWS / 2;
         topl += num;
         redraw = 1;
         break;

      case "u":
         if (noargs)
            num = ROWS / 2;
         topl -= num;
         redraw = 1;
         break;

      case "r":
         redraw = 1;
         break;

      case "m":
         if (s1 == "") {
            printf("Sorry, you must specify a name.\n");
            break;
         }
         set_mark(s1);
         printf("OK, mark " + s1 + " set.\n");
         break;

      case "'":
         if (!mark_name) {
            printf("Sorry, must go to a mark.\n");
            break;
         }
         if ((i = member_array(s1, mark_name)) != -1) {
            if (_more_file_fname != mark_data[i][0]) {
               _more_file_fname = mark_data[i][0];
               redraw = 1;
            }
            if (topl != mark_data[i][1]) {
               topl = mark_data[i][1];
               redraw = 1;
            }
         } else
            printf("Mark " + s1 + " not set.\n");
         break;

      case "F":
         filenames = expand_path(str);
         if (sizeof(filenames) == 0) {
            printf("No matching files.\n");
            break;
         }
         last_search = "";
         redraw = get_next_filename();
         break;

      case "h":
         cat("/doc/helpdir/more");
         break;
   }
   if (redraw)
      display_file();
   if (botl < fsize || charl) {
      status_line();
      input_to("next_page");
   } else
      if (sizeof(filenames) > 0) {
         if (get_next_filename())
            input_to("next_page");
         else if (finish_func)
            call_other(this_player(), finish_func);
      } else {
         if (finish_func)
            call_other(this_player(), finish_func);
      }
} /* next_page() */


int more_file(string str) {
   filenames = expand_path(str);
   if (!sizeof(filenames)) {
      notify_fail("No matching files.\n");
      return 0;
   }
   last_search = "";
   if (!get_next_filename())  {
      notify_fail("Could not read " + _more_file_fname + ".\n");
      return 0;
   }
   if (botl < fsize || charl) {
      status_line();
      input_to("next_page");
   } else
      if (finish_func)
         call_other(this_player(), finish_func);
   return 1;
} /* more_file() */
// --- END [/mnt/home2/grok/lib/global/more_file.c] ---
// --- BEGIN [/mnt/home2/grok/lib/global/log.c] ---
// Size:   File: "/mnt/home2/grok/lib/global/log.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627238   Available: 13574592
Inodes: Total: 5242880    Free: 4960133
374 bytes, Last Modified:   File: "/mnt/home2/grok/lib/global/log.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627238   Available: 13574592
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:52.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: log.c,v 1.1 1998/01/06 04:54:05 ceres Exp $
 * $Log: log.c,v $
 * Revision 1.1  1998/01/06 04:54:05  ceres
 * Initial revision
 * 
*/
private nosave mapping last_error;

void logging_commands() {
}

void set_last_error(mapping err) {
  last_error = err;
}

mapping get_last_error() {
  return (mapp(last_error)?last_error:0);
}
// --- END [/mnt/home2/grok/lib/global/log.c] ---
// --- BEGIN [/mnt/home2/grok/lib/global/playtester.c] ---
// Size:   File: "/mnt/home2/grok/lib/global/playtester.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627237   Available: 13574591
Inodes: Total: 5242880    Free: 4960133
17741 bytes, Last Modified:   File: "/mnt/home2/grok/lib/global/playtester.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627237   Available: 13574591
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:52.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: playtester.c,v 1.18 2003/07/21 18:23:15 pinkfish Exp $
 * $Log: playtester.c,v $
 * Revision 1.18  2003/07/21 18:23:15  pinkfish
 * Change the object characters for pts and seniors.
 *
 * Revision 1.17  2003/04/03 19:12:59  ceres
 * Modified to deal with new login object
 *
 * Revision 1.15  2002/08/11 17:49:44  drakkos
 * Added a method to query if a location is a PT area.
 * ((
 *
 * Revision 1.14  2002/08/04 07:45:08  drakkos
 *  Forcibly unlocked by ceres
 *
 * Revision 1.13  2002/07/20 12:54:35  drakkos
 * Updated the senior PT command define.
 *
 * Revision 1.12  2002/07/19 01:45:53  pinkfish
 * Add in stuff to deal with senior pts and the mail command.
 *
 * Revision 1.11  2002/07/19 01:42:04  drakkos
 *  Forcibly unlocked by pinkfish
 *
 * Revision 1.10  2002/07/18 02:27:51  drakkos
 * Added in a forgotten ::event_move_object.
 *
 * Revision 1.9  2002/07/17 23:24:50  drakkos
 * Seperation of room and personal protection into seperate functions... room protection is called by using enable_pt_protection (so that legacy code doesn't break).  Personal protection is called using enable_personal_pt_protection.  Room protection will always over-ride personal protection to allow for creators to safely PT protect their projects without worrying about time delays and such.
 *
 * Revision 1.7  2002/07/12 17:23:27  drakkos
 * Added checks for disabling and enabling protection to make sure it doesn't get enabled twice or disabled twice.
 *
 * Revision 1.6  2002/07/11 23:39:18  pinkfish
 * Make the protection only last five minutes..
 *
 * Revision 1.5  2002/07/11 23:25:28  drakkos
 *  Forcibly unlocked by pinkfish
 *
 * Revision 1.4  2002/06/27 17:47:32  drakkos
 * Added some messages and logging for PT protection, and repressed XP earned when protection is on.
 *
 * Revision 1.3  2002/06/25 19:59:18  pinkfish
 * Fix up some old effect based things so it calls the correct
 * functions.
 *
 * Revision 1.2  2002/06/25 19:51:44  pinkfish
 * Fix up some issues with the protection stuff.
 *
 * Revision 1.1  2002/06/25 18:33:59  pinkfish
 * Initial revision
 *
 * Revision 1.6  2001/06/16 05:09:29  presto
 * Fixed warning.  (Added dummy 'object' argument to query_object_type)
 *
 * Revision 1.5  2001/03/23 23:08:20  ceres
 * Added go_invis param
 *
 * Revision 1.4  1999/02/10 04:14:12  ceres
 * Modified to get creator news from the login handler
 *
 * Revision 1.3  1998/10/30 09:10:15  pinkfish
 * Fix up the name variable to be a method call.
 *
 * Revision 1.2  1998/04/13 11:37:08  pinkfish
 * Removed all the swap stuff fomr the creator object and
 * generly cut it back :)
 *
 * Revision 1.1  1998/01/06 04:54:05  ceres
 * Initial revision
 * 
 */
/* this is the creator player object */

/**
 * This is the playtester player object.  It gives the playtesters the
 * bonus extra commands needed by happy playtesters.
 * @author Pinkfish
 * @see /global/player.c
 * @started Tue Jun 25 11:27:05 PDT 2002
 */
#include <login_handler.h>
#include <command.h>
#include <player.h>
#define PROTECTION_LOG "/log/secure/playtesters/protection_log"
#define MAX_COUNTER 2

class playtester_data {
   int protect;
   int hp;
   string log_file;
   int log_death;
   int log_damage;
   int turn_off;
   int protection_counter;
   int room_protection;
}


inherit "/global/player";

int query_in_pt_arena();

private nosave class playtester_data _pt_data;

int query_pt_area (object ob) {
  string *file;
  
  if (strsrch (base_name (ob), "_pt") != -1) {
    return 1;
  }
  if (strsrch (base_name (ob), "_dev") != -1) {
    return 1;
  }

  file = explode (base_name (ob), "/");
  
  if (file[1] == "playtesters") {
    return 1;
  }
  
  return 0;
}

void create() {
   ::create();
   _pt_data = new(class playtester_data);
}

/** @ignore yes */
void move_player_to_start(string bong, int new_pl, string c_name, string ident, int go_invis) {
  if(!sscanf(file_name(previous_object()), "/secure/login#%*s") &&
     !sscanf(file_name(previous_object()), "/secure/nlogin#%*s"))
    return 0;
#ifndef NEW_DRIVER
  //enable_wizard();
#endif
  ::move_player_to_start(bong, new_pl, c_name, ident, go_invis);
  AddSearchPath(({ DIR_PLAYTESTER_CMDS }));
  if (PLAYTESTER_HAND->query_senior_playtester(query_name())) {
     AddSearchPath(({ DIR_SENIOR_PLAYTESTER_CMDS }));
  }
  if (PLAYTESTER_HAND->query_exec_access (query_name())) {
     AddSearchPath(({ DIR_EXEC_PLAYTESTER_CMDS }));
  }
} /* move_player_to_start() */

/**
 * This method tells us if the object is a playtester or not.
 * @return 1 if the object is a creator, 0 if not.
 */
int query_playtester() { return 1; }

/** @ignore yes */
string query_object_type(object) {
  if (PLAYTESTER_HAND->query_pt_exec(query_name())) {
    return "E";
  }
  if (PLAYTESTER_HAND->query_senior_playtester(query_name())) {
    return "P";
  }
  return "p";
} /* query_object_type() */

/**
 * This method returns the status of the protect flag.  2 means that they have 
 * their room protection enabled, 1 means that they have their personal protection
 * enabled, 0 means that they are not.
 * @return The value of the protect flag
 */
int query_pt_protection() {
  if (_pt_data->room_protection) {
    return 2;
  }
  return _pt_data->protect;
} // query_pt_protection()


/**
 * This method sets the PT as being under room protection.  Room protection does not 
 * expire and lasts until it is switched off.  It also over-rides personal protection.  
 * @return 1 on success, 0 on failure.
 */
 
int enable_pt_protection() {
  if (_pt_data->room_protection != 1) {
   log_file (PROTECTION_LOG, "%s: %s had room PT "
    "protection enabled by %s.\n", ctime(time()), this_player()->query_name(), 
    base_name (environment (this_player())));     
    tell_object (this_player(), "%^BOLD%^You have had your playtester "
      "protection enabled by an external source.  It will last until switched "
      "off by another external source.\n%^RESET%^");
    _pt_data->room_protection = 1;
    return 1;
  }
  
  return 0;
}

/**
 * This method sets the PT as no longer being under room protection.  Room protection does not 
 * expire and lasts until it is switched off.  It also over-rides personal protection.  
 * @return 1 on success, 0 on failure.
 */
int disable_pt_protection() {
  if (_pt_data->room_protection == 1) {
   log_file (PROTECTION_LOG, "%s: %s had room PT "
    "protection disabled by %s.\n", ctime(time()), this_player()->query_name(), 
    base_name (environment (this_player())));   
    tell_object (this_player(), "%^BOLD%^The playtester protection enabled "
      "by an external source has been switched off.\n%^RESET%^");
    _pt_data->room_protection = 0;
    return 1;
  }
  return 0;
}

/**
 * This method sets the protect flag so that adjust_hp and
 * do_death are masked.
 */
int enable_personal_pt_protection() {
  if (query_pt_protection()) {
    return 0;
  }
  
   _pt_data = new(class playtester_data);
   _pt_data->hp = ::query_hp();
   _pt_data->protect = 1;
   _pt_data->log_file = "/d/playtesters/log/pain";
   tell_room (environment (this_player()), this_player()->one_short() 
      + " looks as if " + this_player()->query_pronoun() + " no longer has "
      "any fear of the risks of the real world.\n", this_player());
   log_file (PROTECTION_LOG, "%s: %s enabled PT "
    "protection (%s).\n", ctime(time()), this_player()->query_name(), 
    base_name (environment (this_player())));
   if (_pt_data->turn_off) {
      remove_call_out(_pt_data->turn_off);
   }
   
   if (!query_pt_area (environment (this_player()))) {
      tell_object (this_player(), "%^BOLD%^You feel somewhat more secure, as if "
        "you can no longer be harmed by conventional weapons (This will "
        "only last a maximum of fifteen minutes).%^RESET%^\n");    
     _pt_data->protection_counter = 0;
     _pt_data->turn_off = call_out("disable_personal_pt_protection", 5 * 60);
   }
   else {
      tell_object (this_player(), "%^BOLD%^You feel somewhat more secure, as if "
        "you can no longer be harmed by conventional weapons (This will "
        "last until you switch it off or leave a PT area).%^RESET%^\n");   
  }            
   
   return 1;
} // enable_pt_protection()


/**
 * This method resets the protect flag so that adjust_hp and
 * do_death are not masked, i.e. the player can be hurt in the
 * normal(*) way.
 *
 * (*) Having "normal" ways to hurt people is quite sick...  But it's fnu!
 */
int disable_personal_pt_protection() {
  if (query_pt_protection() != 1) {
    return 0;
  }
    
  if (this_player()) {
    _pt_data->protection_counter = MAX_COUNTER;
  }
  
  if (_pt_data->protection_counter < MAX_COUNTER) {
    tell_object (this_player(), "%^BOLD%^You still have your PT protection "
      "enabled.\n%^RESET%^");
    log_file (PROTECTION_LOG, "%s: %s warned about still enabled PT "
      "protection (%s).\n", ctime(time()), this_player()->query_name(), 
      base_name (environment (this_player())));      
    _pt_data->turn_off = call_out("disable_personal_pt_protection", 5 * 60);   
    _pt_data->protection_counter = _pt_data->protection_counter + 1;
    return 0;
  }
  
   _pt_data->turn_off = 0;
   _pt_data->protect = 0;
   _pt_data->protection_counter = 0;
   log_file (PROTECTION_LOG, "%s: %s disabled PT "
    "protection (%s).\n", ctime(time()), this_player()->query_name(), 
    base_name (environment (this_player())));   
   tell_object (this_player(), "%^BOLD%^You feel less secure in your "
    "indestructability.%^RESET%^\n");
   tell_room (environment (this_player()), this_player()->one_short() 
      + " looks as if the risks of the real world are once again "
      "relevant.\n", this_player());
   return 1;
} // disable_pt_protection()



/**
 * This method sets the fake hitpoints.
 * @param hp The new value of fake hitpoints
 */
void pt_set_hp( int hp ) {
    
   _pt_data->hp = hp;
} // pt_set_hp()

/**
 * This method returns the number of fake hitpoints.
 * @return The number of fake hitpoints
 */
int pt_query_hp() {
   return _pt_data->hp;
} // pt_query_hp()


/** @ignore */
object pt_make_corpse() {
   // Make a corpse in case someone needs it...

   object corpse;

   corpse = clone_object( "/obj/corpse" );
   corpse->set_owner( 0, this_object() );
   corpse->set_ownership( query_name() );
   corpse->set_race_name( query_race() );
   if ( !query_race_ob() ) {
      corpse->set_race_ob( "/std/races/unknown" );
   } else {
      corpse->set_race_ob( query_race_ob() );
   }
   corpse->add_adjective( query_adjectives() );
   corpse->start_decay();

   return corpse;
} // pt_make_corpse()


/**
 * This method replaces the normal do_death() when testing.  It gives
 * players a message about how it would have hurt if it had been for real.
 * @param thing The object that killed us.
 * @return A corpse
 */
object pt_do_death() {
   object corpse, flowers;

   
//   if( _pt_data->log_death && stringp( _pt_data->log_file ) )
   DEATH->death_informer( this_object(), 0, _pt_data->log_file, 1 );
   
   tell_object( this_object(),
         "The Death of Playtesters sneaks up behind you and taps "
         "you on the shoulder.\n"
         "%^CYAN%^The Death of Playtesters says: MY, WE'VE BEEN A BIT "
         "CARELESS, HAVEN'T WE?%^RESET%^\n"
         "The Death of Playtesters coughs.\n"
         "%^CYAN%^The Death of Playtesters says: Sorry about the Voice.  "
         "We have to do that, you know.  Well, you should really be dead "
         "now, but the Playtesters' Union renegotiated the whole death deal "
         "with the powers that be.%^RESET%^\n" );

     
   
   // Restore player to full health
   call_out ("pt_set_hp", 0, query_max_hp());
    
   // Make a corpse and give them flowers
   corpse = pt_make_corpse();
   corpse->move( environment( ) );
   
   flowers = clone_object( "/std/object" );
   flowers->set_name( "flowers" );
   flowers->set_short( "bunch of flowers" );
   flowers->add_alias( "bunch" );
   flowers->add_adjective( ({ "bunch", "of" }) );
   flowers->set_main_plural( "bunches of flowers" );
   flowers->add_plural( ({ "bunches", "bunches of flowers" }) );
   flowers->set_long( "This is a small bunch of nice flowers.\n" );
   flowers->set_weight( 5 + random( 10 ) );
   flowers->set_value( 0 );
   flowers->set_read_mess( "Rest In Peas", "common" );
   flowers->move( corpse );
   
   return corpse;
} // pt_do_death()


/**
 * This method adjusts the fake hitpoints.
 * @param hp The value to add to fake hitpoints
 * @return hp after adjustment
 */
varargs int pt_adjust_hp( int hp, object attacker ) {
       
   _pt_data->hp += hp;

   if( ( hp < 0 || hp > 10 ) && _pt_data->log_damage && stringp( _pt_data->log_file ) )
      log_file( _pt_data->log_file, ctime( time() ) +": "+
                query_name() +" - "+ hp +" hitpoints.\n" );

   // Check if they "die"

   if( _pt_data->hp <= 0 && hp < 0) {
   
      pt_do_death();
   } else if( _pt_data->hp > ::query_max_hp() ) {
      // Make sure they don't get too many hp
      _pt_data->hp = ::query_max_hp();
   }

   // Wimpy
   if( hp < 0 && _pt_data->hp > 0 && attacker && attacker != this_object() ) {
      if( 100 * _pt_data->hp < query_wimpy() * ::query_max_hp() ) {
         run_away();
      }
   }

   return _pt_data->hp;
   
} // pt_adjust_hp()




/**
 * This method sets the log file for logging of PT fake deaths and damage.
 * The default is /d/playtesters/log/pain.
 * @param str The filename of the log file.
 */
void set_pt_log_file( string str ) {
   _pt_data->log_file = str;
} // set_pt_log_file()


/**
 * This method returns the log file for logging of PT fake deaths and damage.
 * The default is /d/playtesters/log/pain.
 * @return The filename of the log file.
 */
string query_pt_log_file() {
   return _pt_data->log_file;
} // query_pt_log_file()


/**
 * This method enables logging of PT fake deaths.
 */
void enable_death_log() {
   _pt_data->log_death = 1;
} // enable_death_log()


/**
 * This method disables logging of PT fake deaths.
 */
void disable_death_log() {
   _pt_data->log_death = 0;
} // disable_death_log()


/**
 * This method returns the status of the LOG_DEATH flag, i.e. whether
 * PT fake deaths are logged or not.
 * @return Status of LOG_DEATH flag
 */
int query_log_death() {
   return _pt_data->log_death;
} // query_log_death()


/**
 * This method enables logging of PT fake damage.
 */
void enable_damage_log() {
   _pt_data->log_damage = 1;
} // enable_damage_log()


/**
 * This method disables logging of PT fake damage.
 */
void disable_damage_log() {
   _pt_data->log_damage = 0;
} // disable_damage_log()


/**
 * This method returns the status of the LOG_DAMAGE flag, i.e. whether
 * PT fake damage is logged or not.
 * @return Status of LOG_DAMAGE flag
 */
int query_log_damage() {
   return _pt_data->log_damage;
} // query_log_damage()


/** @ignore */
object do_death( object thing ) {
   if( query_pt_protection() || query_in_pt_arena())
      return pt_do_death();
   else
      return ::do_death( thing );
} // do_death()


/** @ignore */
varargs int adjust_hp( int hp, object attacker ) {
   // If protected, adjust "fake" hitpoints
   if( query_pt_protection() ) {
     return pt_adjust_hp( hp, attacker );
   } else {
      // Not protected - hurt them
      return ::adjust_hp( hp, attacker );
   }
} // adjust_hp()


/** @ignore */
int query_hp() {
   if( query_pt_protection() )
      return pt_query_hp();
   else
      return ::query_hp();
   
} // query_hp()


/** @ignore */
mixed *stats() {
   return ::stats() + ({
      ({ "PT hitpoints", _pt_data->hp }),
      ({ "PT protection", ( query_pt_protection() ? "On" : "Off" ) })
   });
} /* stats() */

/** @ignore */
string extra_score() {
   return ::extra_score() +
         "Your playtester protection is "+
         ( query_pt_protection() ? "on" : "off" ) +".\n";
} // extra_score()

int query_in_pt_arena() {
  if (!environment(this_object())) {
    return 0;
  }
  if (environment (this_object())->query_pt_arena()) {
    return 1;
  }
  return 0;
}

int advancement_restriction() {
  if (query_pt_protection()) {
    return 1;
  }
  if (query_in_pt_arena()) {
    return 1;
  }
  return 0;
}

/** @ignore yes */
varargs int adjust_xp(int number, int shared) {
  if ( advancement_restriction() && number > 0) {
    return 0;
  }
  return ::adjust_xp(number, shared);
} /* adjust_xp() */

/** @ignore yes */
void event_move_object(mixed from, mixed to) {
  ::event_move_object (from, to);

  if (query_pt_protection()) {
    if (query_pt_area(from) && !query_pt_area (to)) {
       _pt_data->protection_counter = MAX_COUNTER;
  
      if (_pt_data->turn_off) {
        remove_call_out(_pt_data->turn_off);
      }
      tell_object (this_player(), "%^BOLD%^You are now leaving a PT area.  "
        "Your protection is still on.\n%^RESET%^");
      log_file (PROTECTION_LOG, "%s: %s left a playtester area with protection "
        "still active (%s).\n", ctime(time()), this_player()->query_name(), 
        base_name (environment (this_player())));    
     
      _pt_data->turn_off = call_out("disable_pt_protection", 5 * 60);
    }
    else if (!query_pt_area (from) && query_pt_area (to)) {

      tell_object (this_player(), "%^BOLD%^You are now entering a PT area.  "
        "Your protection will not wear off until you leave or switch it "
        "off.\n%^RESET%^");
      if (_pt_data->turn_off) {
        remove_call_out(_pt_data->turn_off);
        _pt_data->protection_counter = 0;
      }        
    }
  }       
  
} /* event_move_object() */

/** @ignore yes */
int query_player_killer() {
  if (query_in_pt_arena()) {
    return 1;
  }
  return ::query_player_killer();
}

int query_contractable() {
  return ::query_player_killer();
}
// --- END [/mnt/home2/grok/lib/global/playtester.c] ---
// --- BEGIN [/mnt/home2/grok/lib/global/cloner.c] ---
// Size:   File: "/mnt/home2/grok/lib/global/cloner.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627233   Available: 13574587
Inodes: Total: 5242880    Free: 4960133
7153 bytes, Last Modified:   File: "/mnt/home2/grok/lib/global/cloner.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627233   Available: 13574587
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:52.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: cloner.c,v 1.6 2002/03/21 11:23:20 taffyd Exp $
 * $Log: cloner.c,v $
 * Revision 1.6  2002/03/21 11:23:20  taffyd
 * Made it only do one lot of writes at once, so that any objects which add multiple cloner entries at once don't cause lots of disk writes.
 * Also made it use previous_object() in the log_file() if there's no this_player().
 *
 * Revision 1.5  2001/03/24 01:53:24  ceres
 * Added illegal object stuff
 *
 * Revision 1.4  2000/11/01 07:12:44  ceres
 * Oops, that didn't work, try it htis way instead
 *
 * Revision 1.2  1998/02/22 03:48:07  presto
 * No changes
 *
 * Revision 1.1  1998/01/06 04:54:05  ceres
 * Initial revision
 * 
*/
/**
 * Used for mapping deleted files to new ones when things are changed.
 * Updated to a more tidy mechanism by Ceres 14/3/96
 * <p>
 * Usage: call add_mapping(from, to) /global/cloner
 */
#define SAVE_FILE "/save/cloner"
#define SAVE_FILE_DELAY 15
/* How long a mapping lasts, currently 3 months */
#define LIFE_TIME 7257600

inherit "/std/object";

mapping changes;
mapping illegal;

private nosave int _save_file_call_out;

/**
 * This method returns the list of currently moved objects.
 */
mapping query_changes() {
   return changes;
} /* query_changes() */

/**
 * Saves the current configuration.
 */
void save_file() {
   _save_file_call_out = 0; 
   unguarded((: save_object, SAVE_FILE:));
} /* save_file() */

/**
 * Loads the current configuration.
 */
void load_file() {
   if (file_size(SAVE_FILE + ".o") > 0)
      unguarded((: restore_object, SAVE_FILE:));
} /* load_file() */

void setup() {
   changes = ([]);
   illegal = ([]);
   load_file();
   _save_file_call_out = 0; 
} /* setup() */

/**
 * Try and clone the passed in object.  If the name exists in the changes
 * array then the new file name is cloned instead of the old one.
 * @param word the name of the file to clone
 * @return the cloned object
 * @see other_file()
 * @see list_mappings()
 */
object clone( string word ) {
   string new_file;
   object thing;

   if ( changes[ word ] && new_file = changes[ word ][ 0 ] )
      word = new_file;
   catch( thing = clone_object( word ) );
   return thing;
} /* clone() */

/**
 * This method returns the mapped name of the object.  If no mapping
 * exists the passed in value is returned directly.
 * @param word the object name to get a mapping for
 * @return the file to use
 * @see clone()
 * @see list_mappings()
 */
string other_file( string word ) {
   if ( changes[ word ] )
      return changes[ word ][ 0 ];
   return word;
} /* other_file() */

/**
 * Use this function to add a new mapping of one filename to another.
 * Means that if an object of type 'from' is attempted to be cloned
 * an object of type 'to' will be cloned instead.
 * @param from the old object name
 * @param to the new object name
 * @return 1 on success, 0 on failure
 * @see remove_mapping()
 * @see list_mappings()
 */
int add_mapping( string from, string to ) {
  string obj_name; 
  if(from[<2..] == ".c")
    from = from[0..<3];
  if(to[<2..] == ".c")
    to = to[0..<3];
  if((file_size(to) < 1) && (file_size(to+".c") < 1)) {
    write("Destination file does not exist\n");
    return 0;
  }
  changes[from] = ({to, time()});

  if ( !_save_file_call_out ) { 
        _save_file_call_out = call_out( (: save_file :), SAVE_FILE_DELAY ); 
  }

  if ( !this_player() ) {
      obj_name = file_name( previous_object() ); 
  }
  else {
      obj_name = this_player()->query_cap_name();
  }
  write("Mapping of "+from+" to "+to+" added.\n");
  log_file("CLONER", "Mapping of "+from+" to "+to+" added by "+
           obj_name +" at "+ctime(time())+".\n");
  remove_call_out("clean_up");
  call_out("clean_up", 120 + random(500));
  return 1;
} /* add_mapping() */

/**
 * Removes a mapping from the object.  This looks to see if an mapping
 * exists for the object and removes it if it does.
 * @param from the object to remove the mapping from
 * @return 1 on success and 0 on failure
 * @see add_mapping()
 * @see list_mappings()
 */
int remove_mapping( string from ) {
   string obj_name;

   if ( changes && changes[ from ] ) {
      map_delete( changes, from );
      save_file();
      write( "Mapping of " + from + " removed.\n" );
      if ( !this_player() ) {
          obj_name = file_name( previous_object() ); 
      }
      else {
          obj_name = this_player()->query_cap_name();
      }
      log_file( "CLONER", "Mapping of " + from + " removed by " +
          obj_name + " at " + ctime( time() ) + ".\n" );
      return 1;
   }
   write("No mapping found for " + from + ".\n");
   return 0;
} /* remove_mapping() */

/**
 * This method returns a list of all the current mappings.  If a
 * pattern is given, then only files which contain that string will
 * be returned.
 * @param str the pattern to search for
 * @return the list of mappings
 * @see add_mapping()
 * @see remove_mapping()
 */
string list_mappings( string str ) {
   string from, retval;
   retval = "";
   foreach(from in keys(changes)) {
      if (!str ||
          strsrch(from, str) != -1 ||
          strsrch(changes[from][0], str) != -1)
         retval += from + " -> " + changes[from][0] + "\n";
   }
   return retval;
} /* list_mappings() */

/**
 * This method is used to add objects that we don't want to be reloaded.
 * This is for those objects that are clones of /std/object or /obj/armour
 * or something but which are wrongly configured.
 *
 * @example add_illegal("/obj/armour", "blue robe", 
                        "/obj/armours/robe.arm);
 *
 * @param basename the base filename of the object
 * @param short the short name of the object
 * @param replacement the replacement object.
 * @return 1 for success, 0 for failure
 */
int add_illegal(string basename, string short, string replacement) {
  if(!illegal) 
    illegal = ([ ]);
 
  if(illegal[basename + ":" + short])
    return 0;
  
  if((file_size(replacement) < 1) && (file_size(replacement+".c") < 1))
    return 0;

  illegal[basename + ":" + short] = replacement;
  save_file();
  return 1;
}

/**
 * Remove an item from the illegal array
 * @param basename the basename of the object.
 * @param short the shortname of the object.
 * @return 1 for success, 0 for failure
 */
int remove_illegal(string basename, string short) {
  if(!illegal)
    return 0;
  
  if(!illegal[basename+":"+short])
    return 0;
  
  map_delete(illegal, basename+":"+short);
  save_file();
  return 1;
}

/**
 * List the illegal objects.
 */
mapping query_illegal() {
  return illegal;
}

/**
 * Determine if a given object is illegal.
 * @param basename the basename of the object.
 * @param short the shortname of the object.
 * @return 1 for success, 0 for failure
 */
string illegal_thing(string basename, string short) {
  if(!illegal)
    return 0;
  return illegal[basename + ":" + short];
}

/** @ignore yes */
void clean_up() {
   string from;
   mixed  *to;
   
   foreach(from, to in changes)
      if ((to[1] < time() - LIFE_TIME) ||
          ((file_size(to[0]) < 1) && (file_size(to[0] + ".c") < 1)))
         map_delete(changes, from);
   save_file();
} /* clean_up() */
// --- END [/mnt/home2/grok/lib/global/cloner.c] ---
// --- BEGIN [/mnt/home2/grok/lib/global/spells.c] ---
// Size:   File: "/mnt/home2/grok/lib/global/spells.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627231   Available: 13574585
Inodes: Total: 5242880    Free: 4960133
3552 bytes, Last Modified:   File: "/mnt/home2/grok/lib/global/spells.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627231   Available: 13574585
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:52.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: spells.c,v 1.2 2001/06/03 20:21:47 pinkfish Exp $
 * $Log: spells.c,v $
 * Revision 1.2  2001/06/03 20:21:47  pinkfish
 * Change the variable name.
 *
 * Revision 1.1  1998/01/06 04:54:05  ceres
 * Initial revision
 * 
*/
#include "spells.h"

nosave mixed *_spell_effects;

void create() {
  _spell_effects = ({ });
} /* create() */

/* temp for testing */
mixed query_effects() { return _spell_effects; }
int queue_commands() { return sizeof( _spell_effects ); }

int add_spell_effect(int no_rnds, string type, string name, object callee,
                     string func, mixed params) {
  int i,j;

   if (strsrch(file_name(this_object()),"global")==-1)
      tell_object(find_living("olorin"),
                  sprintf("add_spell_effect in %s\n",
                          file_name(this_object())));
  if ((i=member_array(type, _spell_effects)) != -1)
    if ((j=member_array(name, _spell_effects[i+1])) == -1)
      _spell_effects[i+1] += ({ name, ({ no_rnds, callee, func, params }) });
    else
      _spell_effects[i+1][j+1] = ({ no_rnds, callee, func, params });
  else
    _spell_effects += ({ type, ({ name, ({ no_rnds, callee, func, params }) }) });
} /* add_spell_effect() */

int remove_spell_effect(string name) {
  int i, j;

   if (strsrch(file_name(this_object()),"global")==-1)
      tell_object(find_living("olorin"),
                  sprintf("remove_spell_effect in %s\n",
                          file_name(this_object())));
  for (i=0;i<sizeof(_spell_effects);i+=2)
    if ((j=member_array(name, _spell_effects[i+1])) != -1) {
      _spell_effects[i+1] = delete(_spell_effects[i+1], j, 2);
      if (!sizeof(_spell_effects[i+1])) {
        _spell_effects = delete(_spell_effects, i, 2);
        i -= 2;
      }
    }
  return 1;
} /* remove_spell_effect() */

mixed query_spell_effect(string name) {
   int i;

   if (strsrch(file_name(this_object()),"global")==-1)
      tell_object(find_living("olorin"),
                  sprintf("query_spell_effect in %s\n",
                          file_name(this_object())));
  if ((i=member_array(name, _spell_effects)) == -1)
    return 0;
  if (sizeof(_spell_effects[i+1]))
    return _spell_effects[i..i]+_spell_effects[0..1];
  return 0;
} /* query_spell_effect() */

mixed *query_spell_effects_type(string type) {
  int i, j;
  mixed *ret;

  if ((i=member_array(type, _spell_effects)) == -1)
    return ({ });
  ret = ({ });
  for (j=0;j<sizeof(_spell_effects);j+=2)
    ret += ({ _spell_effects[i], _spell_effects[i+1][j..j+1] });
  return ret;
} /* query_spell_effects_type() */

int do_spell_effects(object attacker) {
  int i, j;

  this_object()->remove_property("casting");
  for (i=0;i<sizeof(_spell_effects);i+=2)
    for (j=0;j<sizeof(_spell_effects[i+1]);j+=2) {
      call_out("do_call_out_effect", 1, ({ _spell_effects[i+1][j+1], attacker }));
      _spell_effects[i+1][j+1][SP_NO_RNDS]--;
      if ( !_spell_effects[i+1][j+1][SP_NO_RNDS] || !_spell_effects[i+1][j+1][SP_OBJECT]) {
        _spell_effects[i+1] = delete(_spell_effects[i+1], j, 2);
        j -= 2;
        if (!sizeof(_spell_effects[i+1])) {
          _spell_effects = delete(_spell_effects, i, 2);
          i -= 2;
          break;
        }
      }
    }
    return 0;
} /* do_spell_effects() */

void do_call_out_effect(mixed *params) {
  if (params[0][SP_OBJECT])
    call_other(params[0][SP_OBJECT],
             params[0][SP_FUNC],
             params[1],
             params[0][SP_PARAM],
             params[0][SP_NO_RNDS]);
} /* do_effect() */
// --- END [/mnt/home2/grok/lib/global/spells.c] ---
// --- BEGIN [/mnt/home2/grok/lib/global/finger.c] ---
// Size:   File: "/mnt/home2/grok/lib/global/finger.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627230   Available: 13574584
Inodes: Total: 5242880    Free: 4960133
11381 bytes, Last Modified:   File: "/mnt/home2/grok/lib/global/finger.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627230   Available: 13574584
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:52.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: finger.c,v 1.14 2003/07/16 18:21:53 pinkfish Exp $
 * $Log: finger.c,v $
 * Revision 1.14  2003/07/16 18:21:53  pinkfish
 * Make $NEW_LINE$ force a new line in a desc.
 *
 * Revision 1.13  2003/07/13 09:50:24  pinkfish
 * Fix up the email querying for the options command.
 *
 * Revision 1.12  2003/04/03 19:12:49  ceres
 * Fixed to handle ramdisk
 *
 * Revision 1.11  2003/03/19 21:35:09  ceres
 * Allowed /secure/nlogin to alter the password
 *
 * Revision 1.10  2003/03/01 21:18:33  pinkfish
 * Put in only one space.
 *
 * Revision 1.9  2003/02/21 02:10:24  pinkfish
 * Add in stuff to allow zone based descriptions.
 *
 * Revision 1.8  2001/12/28 02:35:13  presto
 * When clearing the description, remove the mapping entry.  Also, if
 * player_info["desc"] is undefined, return "" for the description
 *
 * Revision 1.7  2001/12/17 02:13:32  presto
 * Add a RESET to the end of the description in query_desc()
 *
 * Revision 1.6  2001/03/12 01:36:40  ceres
 * Protected email addresses.
 * &&
 *
 * Revision 1.5  2000/06/26 23:14:44  ceres
 * Made password require 6 char passwords
 *
 * Revision 1.4  1999/08/30 01:15:31  pinkfish
 * Modify a few things and make the birthday use the UNKNOWN_BIRTHDAY
 * define.
 *
 * Revision 1.3  1999/08/30 00:58:39  ceres
 *  Forcibly unlocked by pinkfish
 *
 * Revision 1.2  1998/04/13 12:17:00  pinkfish
 * Adding documentaion and making the code a bit neater.
 *
 * Revision 1.1  1998/01/06 04:54:05  ceres
 * Initial revision
 * 
 */

/**
 * This file contains all of the information related to a player,
 * their password, real name, birthday, location etc.
 * @author Pinkfish
 */
#include <player.h>
#include <mail.h>
#include <clothing.h>

private mapping player_info;

private string password;
private nosave string tmppassword;

string query_name();
private int change_password();
private int change_password2(mixed pass);
private int change_password3(string pass);
private int change_password4(string pass);
int add_command(string command, object ob, mixed format, function func);

/**
 * The commands related to the fingering of a player.
 * Just the change password command at the moment.
 */
void finger_commands() {
   add_command("password", this_object(), "", (: change_password() :));
   add_command("passwd", this_object(), "", (: change_password() :));
} /* finger_commands() */

/**
 * This method sets the description of the player.  The
 * description is the little bit of text seen in the long.
 * @param str the new description of the player
 * @see query_desc()
 */
void set_desc(string str) {
   if (!player_info) {
      player_info = ([ ]);
   }
   if (!str) {
      map_delete(player_info, "desc");
   } else {
      player_info["desc"] = str;
   }
}

/**
 * This method returns the current description of the player.
 * @see set_desc()
 * @return the current description
 */
string query_desc() {
   if (!player_info  ||  undefinedp(player_info["desc"])) {
      return "";
   }
   return player_info["desc"] + "%^RESET%^";
} /* query_desc() */

/**
 * This method sets the description for the specific area of the body.
 * @param zone the zone to set the description for
 * @param desc the description for that zone
 */
void set_zone_desc(string zone, string desc) {
   if (!player_info["zone desc"]) {
      player_info["zone desc"] = ([ ]);
   }
   if (!desc) {
      map_delete(player_info["zone desc"], zone);
   } else {
      player_info["zone desc"][zone] = desc;
   }
}

/**
 * This method returns the zone description for the specified zone.
 * @param zone the zone to get the description for
 * @return the zone description
 */
string query_zone_desc(string zone) {
   if (!player_info["zone desc"]) {
      return 0;
   }
   return player_info["zone desc"][zone];
}

/**
 * This method returns all the zones there are currently descriptions for.
 * @return the zones there are descriptions for
 */
string* query_zone_desc_names() {
   if (!player_info["zone desc"]) {
      return ({ });
   }
   return keys(player_info["zone desc"]);
}

/**
 * This method returns the main zone description to use in the
 * long of the player.
 * @return the main zone description
 */
string query_main_zone_desc(object* wearing) {
   object bing;
   string zone;
   string type;
   string eq_type;
   string str;
   mixed types;
   mapping covered;

   if (!sizeof(player_info["zone desc"])) {
      return "";
   }

   covered = ([ ]);
   foreach (bing in wearing) {
      types = bing->query_type();
      if (!arrayp(types)) {
         types = ({ types });
      }
      foreach (type in types) {
         eq_type = CLOTHING_HANDLER->query_equivilant_type(type);
         if (eq_type) {
            foreach (zone in CLOTHING_HANDLER->query_zone_names(eq_type)) {
               covered[zone] = 1;
            }
         } else {
            foreach (zone in CLOTHING_HANDLER->query_zone_names(type)) {
               covered[zone] = 1;
            }
         }
      }
   }

   str = "";
   foreach (zone in query_zone_desc_names()) {
      if (!covered[zone]) {
         str += " " + replace_string(query_zone_desc(zone), "$NEW_LINE$", "\n");
      }
   }
   return str;
}

/**
 * This method changes the password of the player.  It can only
 * be called by the login object at startup.
 * @param pass the new password
 */
void set_password(string pass) {
   if (file_name(previous_object())[0..12] == "/secure/login" ||
       file_name(previous_object())[0..13] == "/secure/nlogin") {
      password = pass;
   }
} /* set_password() */

/**
 * This method is called when the password is attempted to be changed.
 * @return 1 if successful, 0 on failure
 */
private int change_password() {
   if (password) {
      write("Please enter your old password : ");
      input_to((: change_password2 :),1);
      return 1;
   }
   change_password2(0);
   return 1;
} /* change_password() */

private int change_password2(mixed pass) {
   string str;
   
   if (password) {
      str = crypt(pass,password);
      if (str != password) {
         write("\nIncorrect.\n");
         return 1;
      }
   }
   write("\nEnter new Password : ");
   input_to((: change_password3 :),1);
   return 1;
} /* change_password2() */

private int change_password3(string pass) {
   tmppassword = pass;
   if(sizeof(pass) < 6) {
     write("\nPassword is too short, must be at least 6 characters.\n");
     write("Enter new Password :");
     input_to((: change_password3 :),1);
     return 1;
   }
     
   write("\nPlease enter again : ");
   input_to((: change_password4 :),1);
   return 1;
} /* change_password3() */

private int change_password4(string pass) {
   if (tmppassword != pass) {
      write("\nIncorrect.\n");
      return 1;
   }
   password = crypt(pass,password);
   write("\nOk.\n");
   return 1;
} /* change_password4() */

/**
 * Find out which IP addresses this user wants to be able to login from.
 */
string *query_rhosts() {
  if(!player_info)
    return 0;
  return player_info["allowed_ips"];
}

void set_rhosts(string *ips) {
  if(file_name(previous_object())[0..18] != "/cmds/player/access" &&
     file_name(previous_object())[0..19] != "/cmds/lord/authorise")
    return ;
  
  if(!player_info)
    player_info = ([ ]);
  
  player_info["allowed_ips"] = ips;
}

/**
 * This will return the real name of the player.
 * @return the real name of the player
 * @see set_real_name()
 */
string query_real_name() {
   if (!player_info) {
      return 0;
   }
   return player_info["real_name"];
} /* query_real_name() */

/**
 * This will set the real name of the player.
 * @see query_name()
 * @param str the new real name of the player
 */
void set_real_name(string str) {
   if (!player_info) {
      player_info = ([ ]);
   }
   player_info["real_name"] = str;
} /* set_real_name() */

/**
 * This methoid returns the location of the player.  The location
 * is the location in their funger infor, so like "Perth, oz, whatever".
 * @return their currently set location
 * @see set_where()
 */   
string query_where() {
   if (!player_info) {
      return "";
   }
   return player_info["location"];
} /* query_where() */

/**
 * This method sets the currnet location of the player.
 * @see query_location()
 * @param str the new location
 */
void set_where(string str) {
   if (!player_info) {
      player_info = ([ ]);
   }
   player_info["location"] = str;
} /* set_where() */

/**
 * This method returns the players birthday.  The birthday will be
 * of the form "4th of july".
 * @return the current birthday
 * @see set_birthday()
 * @see query_is_birthday_today()
 */
string query_birthday() {
   if (!player_info) {
      return UNKNOWN_BIRTHDAY;
   }
   if (!player_info["birthday"]) {
      return UNKNOWN_BIRTHDAY;
   }
   
   return player_info["birthday"];
} /* query_birthday() */

/**
 * This method sets the players current birthday.  The birthday
 * needs to be of the form:  "4th of July".
 * @param i the new birthday to set
 * @see query_birthday()
 * @see query_is_birthday_today()
 */
void set_birthday(string i) {
   if (!player_info) {
      player_info = ([]);
   }
   player_info["birthday"] = i;
} /* set_birthday() */

/**
 * This method checks to see if it is currently the players birthday.
 * @return 1 if it is their birthday, 0 if not
 * @see set_birthday()
 * @see query_birthday()
 */
int query_is_birthday_today() {
   string cmonth;
   string dummy;
   string bmonth;
   int cdate;
   int bdate;
    
   if (sscanf(ctime(time()), "%s %s %d %s", dummy, cmonth, cdate, dummy)!=4) {
      return 0; /* error in date */
   }
   if (sscanf(query_birthday(), "%d%s of %s", bdate, dummy, bmonth) !=3) {
      return 0; /* no bday set */
   }
   if (cmonth == bmonth[0..2] && cdate == bdate) {
      return 1;
   }
} /* query_is_birthday_today() */

/**
 * This method returns the current email address of the player.
 * @see set_email()
 * @return the current email address
 */
string query_email() {
  if(file_name(previous_object())[0..13] != "/secure/finger" &&
     file_name(previous_object())[0..27] != "/obj/handlers/player_handler" &&
     file_name(previous_object())[0..28] != "/obj/handlers/options_handler") {
    return "";
   }

   if (!player_info) {
      return "";
   }
   return player_info["email"];
}
/**
 * This method sets the current email address of the player.
 * @see query_email()
 * @param str the new email address
 */
nomask void set_email(string str) {
   if (!player_info) {
      player_info = ([]);
   }
   player_info["email"] = str;
} /* set_email() */

/**
 * This method queries the current homepage for the player.
 * @see set_homepage()
 * @return their homepage url
 */
string query_homepage() {
   if (!player_info) {
      player_info = ([ ]);
   }
   return player_info["homepage"];
} /* query_homepage() */

/**
 * This method sets the players homepage.
 * @see query_homepage()
 * @param their homepage url
 */
nomask void set_homepage(string str) {
   if (!player_info) {
      player_info = ([]);
   }
   player_info["homepage"] = str;
} /* set_homepage() */

/**
 * This method returns whether the player has set their finger info.
 * @return 1 if they have their finger information set, 0 if not
 */
int finger_set() {
   if (!player_info || 
      player_info == ([ ]) || 
      sizeof(keys(player_info)) == 1) {
      return 0;
   }
   return 1;
} /* finger_set() */
// --- END [/mnt/home2/grok/lib/global/finger.c] ---
// --- BEGIN [/mnt/home2/grok/lib/global/wiz_channels.c] ---
// Size:   File: "/mnt/home2/grok/lib/global/wiz_channels.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627227   Available: 13574581
Inodes: Total: 5242880    Free: 4960133
8847 bytes, Last Modified:   File: "/mnt/home2/grok/lib/global/wiz_channels.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627227   Available: 13574581
Inodes: Total: 5242880    Free: 4960133
2025-03-06 10:34:02.910180378 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming

/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: wiz_channels.c,v 1.6 2003/01/30 18:37:02 taffyd Exp $
 *
 * System of intra-mud communications channels.
 * Access to channels is controlled by the noshadow channel_list() function.
 * By default each domain has a channel. Domains not wishing to have a channel
 * should be placed in the NO_CHANNELS array.
 * THE ADDITIONAL_CHANNELS array adds channels that do not have a domain and
 * are accessible to all creators.
 *
 * This has been hacked together from a bunch of things it can probably be
 * simplified considerably.
 */
#include <broadcaster.h>
#include <creator.h>
#include <network.h>
#include <newudp.h>

#define TALKER "/std/shadows/object/talker"

#define BEEP sprintf("%c",7)
#define CHAN_OK 1
#define CHAN_FORCED 2
#define CHAN_EMOTED 4
#define CHAN_QUERY 8

private int channel_cmd(string mess);
private int channel_hist();

nomask string *channel_list() {
  string channel, *tmp, *channels;
  
  tmp = "/secure/master"->query_domains();
  tmp -= NO_CHANNELS;
  channels = ({ });
  
  foreach(channel in tmp)
    if("/secure/master"->query_senior(this_object()->query_name()) ||
       ("/d/"+channel+"/master")->query_member(this_object()->query_name()))
      channels += ({ channel });

  channels += ADDITIONAL_CHANNELS + keys(INTERMUD_MAP);
  
  if(this_object()->query_lord())
    channels += ({ "lord" });
  
  return channels;
}

void wiz_commands() {
  string channel;

  foreach(channel in channel_list()) {
    add_command(channel, "<string'mess'>", (: channel_cmd($4[0]) :));
    add_command(channel+"@", "<string'mess'>", (: channel_cmd("@"+$4[0]) :));
    add_command(channel+"?", "", (: channel_cmd("?") :));

    if(!INTERMUD_MAP[channel]) {
      add_command(channel+"!", "", (: channel_cmd("!") :));
      add_command("h"+channel, "", (: channel_hist() :));
    }
  }
}

/* to properly columnate word_typed things */
private void my_mess(string fish, string erk) {
  int bing;
  
  if (!interactive(this_player())) {
    return;
  }
  bing = strlen(fish);
  if (bing > 15) {
    bing = 15;
  }
  efun::tell_object(this_player(),
                    this_player()->fix_string(sprintf("%s%s\n", fish, erk),
                                              (int)this_player()->query_cols(),
                                              bing));
}

/**
 * This method handles the command line and returns the type of command that
 * is represented by the command line.
 * @param mess the message to parse
 * @return the flags to determine what sort of message it is
 */
protected int handle_command_line(string channel, string mess) {
  int retval;
  function map_func;
  int i;
  object *people, *off_line;

  add_failed_mess("Syntax: "+channel+"[@|?] [text]\n");
  if(!channel || !mess) {
    return 0;
  }

  if(member_array(channel, channel_list()) == -1) {
    add_failed_mess("No such channel " + channel + ".\n");
    return 0;
  }
  
  switch (mess[0]) {
  case '!' :
    retval |= CHAN_FORCED;
    break;
  case '@' :
    retval |= CHAN_EMOTED;
    break;
  case '?' :
    if (mess == "?") {
      // Handle intermud queries.
      if(INTERMUD_MAP[channel]) {
        SERVICES_D->eventSendChannelWhoRequest(INTERMUD_MAP[channel]);
        retval |= CHAN_QUERY;
        return retval;
      }
      
      people = filter(users(), (: $1 && $1->query_creator() &&
                                $1->query_visible(this_object()) :));
      off_line = ({ });
      for (i=0;i<sizeof(people);i++) {
        if(!people[i] || !people[i]->channel_list() ||
           member_array(channel, people[i]->channel_list()) == -1) {
          people = delete(people, i, 1);
          i--;
        } else if(people[i]->check_earmuffs(channel) ||
                  (member_array(channel, keys(INTERMUD_MAP)) != -1 &&
                   people[i]->check_earmuffs("intermud-all"))) {
          off_line += ({ people[i] });
          people = delete(people, i, 1);
          i--;
        }
      }
      people = sort_array(people, (: strcmp($1->query_name(),
                                            $2->query_name()) :) );
      off_line = sort_array(off_line, (: strcmp($1->query_name(),
                                                $2->query_name()) :) );
      map_func = function (object ob) {
        string str;
        
        if (ob->query_invis()) {
          if (ob->query_invis() == 2) {
// Line 147: Original: str = "({" + $1->query_cap_name() + "})"
str = "({" + map(ob, (: ($1)->query_cap_name() :))[0] + "})";
          } else {
str = "(" + map(ob, (: ($1)->query_cap_name() :))[0] + ")";
          }
str = map(ob, (: ($1)->query_cap_name() :))[0];
        } else {
        }
        if (query_idle(ob) > 120) {
          int hours, mins, secs;
          
          secs = query_idle(ob);
          mins = secs / 60;
          secs %= 60;
          hours = mins / 60;
          mins %= 60;
          if ( !hours )  {
            str += sprintf(" [%02dm]", mins);
          } else {
            str += sprintf(" [%02dh:%02dm]", hours, mins);
          }
        }
        return str;
      };
      people = map(people, map_func);
      off_line = map(off_line, map_func);
      if (sizeof(people)) {
        write(sprintf( "On line: %-=" + (this_player()->query_cols() - 10) +
                       "s", query_multiple_short( people ) +".\n"));
      }
      if (sizeof(off_line)) {
        write(sprintf( "Off line: %-=" + (this_player()->query_cols() - 11) +
                       "s", query_multiple_short( off_line ) +".\n"));
      }
      retval |= CHAN_QUERY;
    }
    break;
  default :
    return CHAN_OK;
    break;
  }
  return retval;
}

private int channel_cmd(string mess) {
  int flags;
  string pad = " ";
  string start;
  string channel;
  object *things;
  
  channel = query_verb();
  
  if(channel[<1] == '?' || channel[<1] == '@' || channel[1] == ':') {
    channel = channel[0..<2];
  }
  flags = handle_command_line(channel, mess);
  if (!flags) {
    return 0;
  }
  if (flags & CHAN_QUERY) {
    return 1;
  }
  
  if(mess[0] == '!' || mess[0] == '@' || mess[0] == '?') {
    mess = mess[1..1000];
  }
  if (mess[0] == ' ') {
    mess = mess[1..1000];
  } 
  if (mess == "") {
    return 0;
  }
  
  if (this_object()->check_earmuffs(channel)) {
    write("Why use " + channel + "-tell when you can't hear a response?\n");
    return 1;
  }
  mess = replace(mess, BEEP, "");
  if (mess[0..0] == "'") {
    pad = "";
  }
  
  if (flags & CHAN_EMOTED) {
    start = this_object()->query_cap_name() + pad;
    
    if(INTERMUD_MAP[channel])
      SERVICES_D->eventSendChannel((string)this_player()->query_cap_name(),
                                   INTERMUD_MAP[channel], "$N " + mess,
                                   flags & CHAN_EMOTED);
    else
      my_mess("(" + channel + ") "+
              ((string)this_object()->query_cap_name()) + pad,
              mess);
  } else {
    start = this_object()->query_cap_name() +": ";
    
    if(INTERMUD_MAP[channel])
      SERVICES_D->eventSendChannel((string)this_player()->query_cap_name(),
                                   INTERMUD_MAP[channel], mess,
                                   flags & CHAN_EMOTED);
    else
      my_mess("You " + channel + "-tell: ", mess);
  }
  
  if(INTERMUD_MAP[channel]) {
    user_event(this_object(), "intermud_tell", start, mess, channel);
    
    if(channel == "dwchat") {
      things = children(TALKER);
      things -= ({ find_object(TALKER) });
      if ( flags & CHAN_EMOTED ) { 
        mess = ":" + mess;
      }

      things->receive("intermud", this_object()->query_cap_name(),
                       mess);
    }
  } else {
    user_event(this_object(), "creator_tell", start, mess,
                flags & CHAN_FORCED, channel);
    HIST_HANDLER->add_chat_history(channel, start, mess);
  }
  
  return 1;
}

private int channel_hist() {
  int i;
  mixed *hist;
  string channel;
  
  channel = query_verb()[1..];
  
  hist = HIST_HANDLER->query_chat_history(channel);
  if (!pointerp(hist) || !sizeof(hist)) {
    return notify_fail("Nobody said anything on the " + channel +
                       " channel.\n");
  }
  write("The " + channel + " channel history is:\n");
  for (i=0;i<sizeof(hist);i++) {
    if (sizeof(hist[i]) > 2) {
      efun::tell_object(this_object(), 
                        this_object()->fix_string(sprintf("*%s* %s%-=*s\n",
                ctime(hist[i][2])[11..18], hist[i][0], 
                (int)this_object()->query_cols()-strlen(hist[i][0])-11,
                                                          hist[i][1])));
    } else {
      efun::tell_object(this_object(), 
                        (string)this_object()->fix_string(sprintf("%s%-=*s\n",
               hist[i][0], (int)this_object()->query_cols()-strlen(hist[i][0]),
                hist[i][1])));
    }
  }
  return 1;
}
// --- END [/mnt/home2/grok/lib/global/wiz_channels.c] ---
// --- BEGIN [/mnt/home2/grok/lib/global/alias.c] ---
// Size:   File: "/mnt/home2/grok/lib/global/alias.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627224   Available: 13574578
Inodes: Total: 5242880    Free: 4960133
8932 bytes, Last Modified:   File: "/mnt/home2/grok/lib/global/alias.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627224   Available: 13574578
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:52.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: alias.c,v 1.12 2001/06/16 05:01:27 presto Exp $
 * $Log: alias.c,v $
 * Revision 1.12  2001/06/16 05:01:27  presto
 * Put in a missing set of braces in query_player_alias
 *
 * Revision 1.11  2001/06/16 00:15:35  ceres
 * Fixed possible runtime in query_player_alias
 *
 * Revision 1.10  2001/03/11 01:42:01  ceres
 * Restricted alias lenghts
 *
 * Revision 1.9  1999/04/03 23:19:40  dragonkin
 * Fixed so that player aliases called "" can be removed by anyone.
 *
 * Revision 1.8  1999/03/10 09:44:56  pinkfish
 * Rip out the guts into the alias commands.
 *
 * Revision 1.7  1999/03/09 06:04:38  presto
 *  Forcibly unlocked by pinkfish
 *
 * Revision 1.6  1999/02/08 14:15:04  wodan
 * changed add_actions to other things (/cmds stuff and add_command)
 *
 * Revision 1.5  1999/01/27 00:03:46  ceres
 *  Forcibly unlocked by pinkfish
 *
 * Revision 1.4  1998/12/30 21:45:13  ceres
 * Fixed code for checking for colour sequences so it works properly.
 *
 * Revision 1.3  1998/12/30 21:42:27  olorin
 *  Forcibly unlocked by ceres
 *
 * Revision 1.2  1998/02/21 19:05:47  pinkfish
 * Fix up the problem with the command queue and aliases.
 *
 * Revision 1.1  1998/01/06 04:54:05  ceres
 * Initial revision
 * 
*/
/**
 * The alias control module for players.
 * @author Pinkfish
 */
#include <alias.h>
#include <player.h>
inherit "/global/history";

mapping aliases;
nosave mapping doing_alias;

protected void exec_alias(string verb, string args);
protected string *expand_alias(string verb, string args);
protected void set_doing_alias(string verb);
protected int is_doing_alias(string verb);
protected string *run_alias(string verb, string args);
int remove_alias_thing(string);
protected int alias(string);
protected int edit_alias(string);

/**
 * This method sets the alias to the new value.
 * @param name the name of the alias
 * @param value the value to set the alias too
 * @see query_player_alias()
 */
int add_player_alias(string name, mixed *value) {
   if (file_name(previous_object()) != ALIAS_CMD &&
       file_name(previous_object()) != EDIT_ALIAS_CMD) {
      return 0;
   }

   if(name == "unalias" || name == "alias" || name == "ealias")
     return 0;
  
   aliases[name] = value[0..1023];
   return 1;
} /* add_player_alias() */

/**
 * This method returns the value of the specified alias.
 * @param name the name of the alias to query
 * @return the value of the alias
 * @see add_player_alias()
 */
mixed *query_player_alias(string name) {
  if(!mapp(aliases))  {
    aliases = ([ ]);
    return 0;
  }
    
   return copy(aliases[name]);
} /* query_player_alias() */

/**
 * This method will remove the alias from the player.
 * @param name the name of the alias
 * @see query_player_alias()
 * @see add_player_alias()
 */
int remove_player_alias(string name) {
   if ((file_name(previous_object()) != UNALIAS_CMD) &&
       name != "" &&
       !this_player(1)->query_lord()) {
      printf("%O\n", file_name(previous_object()));
      return 0;
   }
   map_delete(aliases, name);
   return 1;
} /* remove_player_alias() */

/**
 * This method adds all the alias commands onto the player.  The commands
 * are 'alias', 'unalias', 'ealias', 'END_ALIAS' and the "*" pattern
 * expand the alias.
 */
void alias_commands() {
   add_command("END_ALIAS", "<string>", (:remove_alias_thing($4[0]):));
} /* alias_commands() */

/**
 * This method zaps all the current aliases defined.  This can only be
 * called by a high lord.
 * @return 0 on failure and 1 on success
 */
int remove_all_aliases() {
   if (!this_player(1)->query_lord()) {
      write("You can't do that :)\n");
      return 0;
   }

   aliases = ([ ]);
   return 1;
} /* remove_all_aliases() */


/**
 * This method returns a complete list of all the aliases
 * defined on the player.  This is the internal mapping so it will
 * be quite unreadable.
 * @see print_aliases()
 * @see /include/alias.h
 * @return the mapping of aliases
 */
mapping query_aliases() { 
   return copy(aliases); 
} /* query_aliases() */

/**
 * This method tells us if the given name is an alias.
 * @param verb the verb to check
 * @return 1 if it is an alias, 0 if not
 */
int is_alias(string verb) {
   return aliases[verb] != 0;
} /* is_alias() */

/**
 * This method runs the alias and executes all the commands in the
 * alias.  You should probably use run_alias() instead.  This calls
 * set_doing_alias() to setup blocking.
 * @param verb the name of the alias
 * @param args the arguments associated with the alias
 * @see run_alias()
 * @see set_doing_alias()
 */
protected void exec_alias(string verb, string args) {
   string *bing;
   string comm;

   bing = run_alias(verb, args);
   if (bing) {
      set_doing_alias(verb);
      foreach (comm in bing) {
         command(comm);
      }
   }
} /* exec_alias() */

/**
 * Attempt to expand the alias.    This will look up the alias and
 * see if it is defined.  If it is, it will attempt to expand the 
 * alias. This does not call set_doing_alias().  This will
 * return 0 if the alias does not exist, or the alias is already
 * being run.
 * @return the array if the alias was expanded, 0 if failed
 * @param verb the name of the alias to expand
 * @param args the arguments to the alias
 * @see exec_alias()
 * @see is_doing_alias()
 * @see set_doing_alias()
 * @see expand_alias()
 */
protected string *run_alias(string verb, string args) {
   if (!mapp(aliases)) {
      aliases = ([ ]);
   }
   if (!aliases[verb] || is_doing_alias(verb)) {
      return 0;
   }
   return expand_alias(verb, args);
} /* run_alias() */

/**
 * This method checks to see if the player is doing the specified alias
 * already.
 * @param verb the verb to check
 * @see exec_alias()
 * @see set_doing_alias()
 */
protected int is_doing_alias(string verb) {
   if (!doing_alias) {
      doing_alias = ([ ]);
   }
   if (doing_alias[verb]) {
      return 1;
   }
   return 0;
} /* is_doing_alias() */

/**
 * This method sets us as currently doing the given alias.
 * @param verb the alias to do
 * @see is_doing_alias()
 */
protected void set_doing_alias(string verb) {
  doing_alias[verb] = 1;
  in_alias_command++;
} /* set_doing_alias() */

/**
 * This method expands the alias from the input string thingy.
 * @param verb the verb to expand
 * @param args the arguments to the verb
 * @see run_alias()
 */
protected string *expand_alias(string verb, string args) {
   int i;
   int num;
   string *bits;
   string line;
   mixed stuff;
   string *ret;
   
   /* Default expansion :) */
   if (!aliases[verb]) {
      return ({ verb + " " + args });
   }
   ret = ({ });
   stuff = aliases[verb];
   line = "";
   if (!args) {
      args = "";
   }
   bits = explode(verb + " " + args, " ");
   for (i = 0; i < sizeof(stuff); i++) {
      if (stringp(stuff[i])) {
         line += stuff[i];
      } else {
         num = stuff[i] & ALIAS_MASK;
         switch (stuff[i] - num) {
         case NEW_LINE :
            ret += ({ line });
            line = "";
            break;
         case ALL_ARGS :
            line += args;
            break;
         case ONE_ARG  :
            if (num < sizeof(bits)) {
               line += bits[num];
            }
            break;
         case TO_ARG   :
            line += implode(bits[1..num], " ");
            break;
         case FROM_ARG :
            line += implode(bits[num..100], " ");
            break;
         case ALL_ARG  :
            i++;
            if (args == "") {
               line += stuff[i];
            } else {
               line += args;
            }
            break;
         case ARG_THING :
            i++;
            if (num < sizeof(bits)) {
               line += bits[num];
            } else {
               line += stuff[i];
            }
            break;
         case ALL_IFARG :
            i++;
            if (args == "") {
               i += stuff[i];
            }
            break;
         case IFARG_THING :
            i++;
            if (num >= sizeof(bits)) {
               i += stuff[i];
            }
            break;
         case ELSE_THING :
            i++;
            i += stuff[i];
            break;
         case CURR_LOC :
            i++;
            line += file_name(environment())+".c";
            break;
         case END_IF :
            break;
         }
      }
   }
   if (line != "") {
      ret += ({ line });
   }
   ret += ({ "END_ALIAS " + verb });
   return ret[0..1023];
} /* expand_alias() */

/**
 * This is called to signify the end of an alias.  This is needed
 * keep track of recursive aliases and such like.
 * @param verb the verb name to remove
 * @return always returns 1
 * @see set_doing_alias()
 * @see is_doing_alias()
 */
int remove_alias_thing(string verb) {
   in_alias_command--;
   map_delete(doing_alias, verb);
   this_player()->adjust_time_left(-DEFAULT_TIME);
   return 1;
} /* remove_alias_thing() */
// --- END [/mnt/home2/grok/lib/global/alias.c] ---
// --- BEGIN [/mnt/home2/grok/lib/global/auto_mailer.c] ---
// Size:   File: "/mnt/home2/grok/lib/global/auto_mailer.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627222   Available: 13574576
Inodes: Total: 5242880    Free: 4960133
1891 bytes, Last Modified:   File: "/mnt/home2/grok/lib/global/auto_mailer.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627222   Available: 13574576
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:52.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: auto_mailer.c,v 1.5 2003/03/12 13:09:13 wyvyrn Exp $
 * $Log: auto_mailer.c,v $
 * Revision 1.5  2003/03/12 13:09:13  wyvyrn
 * Tabs to spaces
 *
 * Revision 1.4  2001/03/13 04:36:19  ceres
 * Fixed runtime if this_player() wasn't set.
 *
 * Revision 1.3  2001/03/01 10:07:42  taffyd
 * Added new flag for Ringo.. make to use test_player() in player_handler... and ran it through the new indenter just to try it out.
 *
 * Revision 1.2  2000/11/04 18:22:11  pinkfish
 * Remove the debug print.
 *
 * Revision 1.1  1998/01/06 04:54:05  ceres
 * Initial revision
 * 
*/
/**
 * Allows objects to send mail as if they were from the given player.
 */
#include <mail.h>
#include <player_handler.h>

/**
 * Allows people to send mail automaticly from the player in question.
 * Thus allows mail to be sent on someone being promoted to creator
 * and stuff.
 * @param to who the mail is to
 * @param from who the mail is from
 * @param cc the people to carbon copy
 * @param body the body of the message
 * @param send_inter should be send it ove the inter mud system?
 * @param only_to ignore the cc fields
 * @return the same value as do_mail_message does, 0 on failure
 */
int auto_mail(string to,
              string from,
              string sub,
              string cc,
              string body,
              int send_inter,
              string only_to,
              int flag)
{
  if (PLAYER_HANDLER->test_player(from) &&
      this_player() &&
      from != this_player()->query_name()) {
    write("AUTO_MAILER: Illegal access!\n");
    unguarded((: write_file, "/log/CHEAT",
           "Illegal access to AUTO_MAILER.\n" "Backtrace: " +
           back_trace() :));
    return 0;
  }
  return MAILER->do_mail_message(to, from, sub, cc, body,
                 send_inter, only_to, flag);
}                               /* auto_mail() */
// --- END [/mnt/home2/grok/lib/global/auto_mailer.c] ---
// --- BEGIN [/mnt/home2/grok/lib/global/creator.c] ---
// Size:   File: "/mnt/home2/grok/lib/global/creator.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627221   Available: 13574575
Inodes: Total: 5242880    Free: 4960133
2134 bytes, Last Modified:   File: "/mnt/home2/grok/lib/global/creator.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627221   Available: 13574575
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:52.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: creator.c,v 1.6 2001/06/16 05:09:29 presto Exp $
 * $Log: creator.c,v $
 * Revision 1.6  2001/06/16 05:09:29  presto
 * Fixed warning.  (Added dummy 'object' argument to query_object_type)
 *
 * Revision 1.5  2001/03/23 23:08:20  ceres
 * Added go_invis param
 *
 * Revision 1.4  1999/02/10 04:14:12  ceres
 * Modified to get creator news from the login handler
 *
 * Revision 1.3  1998/10/30 09:10:15  pinkfish
 * Fix up the name variable to be a method call.
 *
 * Revision 1.2  1998/04/13 11:37:08  pinkfish
 * Removed all the swap stuff fomr the creator object and
 * generly cut it back :)
 *
 * Revision 1.1  1998/01/06 04:54:05  ceres
 * Initial revision
 * 
 */
/* this is the creator player object */

/**
 * This is the creator player object.  It gives the creators the
 * bonus extra commands needed by happy creators.
 * @author Pinkfish
 * @see /global/player.c
 */
#include <login_handler.h>
inherit "/global/wiz_file_comm";

#define ECHO_ALLOWED

/** @ignore yes */
void move_player_to_start(string bong, int new_pl, string c_name, string ident, int go_invis) {
  if(!sscanf(file_name(previous_object()), "/secure/login#%*s") &&
     !sscanf(file_name(previous_object()), "/secure/nlogin#%*s"))
    return 0;
#ifndef NEW_DRIVER
  //enable_wizard();
#endif
  ::move_player_to_start(bong, new_pl, c_name, ident, go_invis);
  write(LOGIN_HANDLER->get_message("/doc/CREATORNEWS"));
  if(query_invis()) {
    tell_object(this_object(), "===> You are currently INVISIBLE! <===\n");
  }
} /* move_player_to_start() */

/**
 * This method tells us if the object is a creator or not.
 * @return 1 if the object is a creator, 0 if not.
 */
int query_creator() { return 1; }

/** @ignore yes */
string query_object_type(object) {
   if ( master()->query_senior( query_name() ) )
      return "S";
   return "C";
} /* query_object_type() */

/**
 * This method is used by the snoop efun to allow creator to see
 * what other players are doing.
 * @param bing the message to receive
 */
void receive_snoop(string bing) {
  tell_object(this_object(), "] "+bing);
} /* receive_snoop() */
// --- END [/mnt/home2/grok/lib/global/creator.c] ---
// --- BEGIN [/mnt/home2/grok/lib/global/friends.c] ---
// Size:   File: "/mnt/home2/grok/lib/global/friends.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627221   Available: 13574575
Inodes: Total: 5242880    Free: 4960133
2441 bytes, Last Modified:   File: "/mnt/home2/grok/lib/global/friends.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627221   Available: 13574575
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:52.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * A nice clump of friends to take you out and buy you drinks.
 * @author Pinkfish
 * @started Mon Mar 12 22:21:23 PST 2001
 */
#include <player.h>
#include <player_handler.h>
#include <cmds/friends.h>

private mapping _friends;

void create() {
   _friends = ([ ]);
} /* create() */

/**
 * This method checks to see if the specified person is a friend or not.
 * @param person the person to check
 * @return 1 if they are a friend, 0 if not
 */
int is_friend(string person) {
   if (!_friends) {
     _friends = ([ ]);
   }
   return stringp(_friends[person]);
} /* is_friend() */

/**
 * This method returns the tag associated with the friend.
 * @param person the person to get the information on
 * @return the string of their friendship tag
 */
string query_friend_tag(string person) {
  if(!interactive(previous_object()))
     return _friends[person];

  if(previous_object()->query_name())
    log_file("CHEAT", "%s query_friend_tag called on %s by %s\n",
             ctime(time()), this_object()->query_name(),
             previous_object()->query_name());
  else
    log_file("CHEAT", "%s query_friend_tag called on %s by %s\n",
             ctime(time()), this_object()->query_name(),
             file_name(previous_object()));
  return "";
} /* query_friend_tag() */

/**
 * This method adds a friend to the list.
 * @param person the friend to add
 * @param tag the tag to add
 */
void add_friend(string person, string tag) {
   if (strlen(tag) > PLAYER_MAX_FRIEND_TAG_LEN) {
      return ;
   }
   if (!PLAYER_HANDLER->test_user(person)) {
      return ;
   }

   _friends[person] = tag;
} /* add_friend() */

/**
 * This method removes a friend from the list.
 * @param person the person to remove
 */
void remove_friend(string person) {
   map_delete(_friends, person);
} /* remove_friend() */

/**
 * This method returns the current bunch of friends for this player.
 */
string* query_friends() {
   if (file_name(previous_object()) == FRIENDS_CMD) {
      return keys(_friends);
   }
   if(previous_object()->query_name())
     log_file("CHEAT", "%s query_friends called on %s by %s\n",
              ctime(time()), this_object()->query_name(),
              previous_object()->query_name());
   else
     log_file("CHEAT", "%s query_friends called on %s by %s\n",
              ctime(time()), this_object()->query_name(),
              file_name(previous_object()));
     
   return ({ });
} /* query_friends() */
// --- END [/mnt/home2/grok/lib/global/friends.c] ---
// --- BEGIN [/mnt/home2/grok/lib/global/lord.c] ---
// Size:   File: "/mnt/home2/grok/lib/global/lord.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627220   Available: 13574574
Inodes: Total: 5242880    Free: 4960133
8406 bytes, Last Modified:   File: "/mnt/home2/grok/lib/global/lord.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627220   Available: 13574574
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:52.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: lord.c,v 1.15 2002/03/03 23:18:01 ceres Exp $
 */
/**
 * This is the lord player object and contains any needed bits to
 * handle lord specific commands and things.
 * @author Pinkfish
 */
/* this is the lord player object */

/* support added for automatically mailing docs to new cre's upon */
/* being employd - Funtime, 24/5/95 */
#define CREATOR_DOC "/doc/creator/concepts/creator_doc.txt"
//#define PROJECT_STYLE "/doc/creator/concepts/project_style.txt"

#include <command.h>
#include <mail.h>

inherit "/global/wiz_file_comm";

protected int do_dismiss(string str, string reason);
protected int employ(string str);
protected int new_domain(string dom, string director);
private int do_heart_beat();
protected int do_qsnoop(object *obs);
protected int bulk_delete( string word );
protected int clean_up_files( string word );
protected int do_hexec(string);

void create() {
  ::create();
} /* create() */

/** @ignore yes */
void move_player_to_start(string bong, int bing, string c_name, string ident,
                          int go_invis) {
  ::move_player_to_start(bong, bing, c_name, ident, go_invis);
  cat("doc/CREATORNEWS");
  cat("doc/DIRECTORNEWS");
#ifndef NEW_DRIVER
  enable_wizard();
#endif
   switch ( query_invis() ) {
      case 3 :
         tell_object( this_object(),
               "===> You are currently Trustee invisible! <===\n" );
         break;
      case 2 :
         tell_object( this_object(),
               "===> You are currently Director invisible! <===\n" );
         break;
      case 1:
         tell_object( this_object(),
               "===> You are currently invisible! <===\n" );
         break;
   }
  add_command("qsnoop", this_object(), "<indirect:player>", (: do_qsnoop($1)
                                                             :));
  add_command("qsnoop", this_object(), "", (: do_qsnoop :));
  add_command("employ", this_object(), "<word>", (: employ($4[0]) :));
  add_command("dismiss", this_object(), "<word> <string>", (: do_dismiss($4[0], $4[1]) :));
  add_command("new_domain", this_object(), "<word> <word>",
              (: new_domain($4[0], $4[1]) :) );
  add_command("heart_beat", this_object(), "", (: do_heart_beat() :) );
  add_command("bulk_delete", this_object(),
              "{a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z}",
              (: bulk_delete($4[0]) :) );
  add_command("clean_up_files",  this_object(), "<word>",
              (: clean_up_files($4[0]) :) );
  AddSearchPath(({ DIR_LORD_CMDS, DIR_SECURE_LORD_CMDS }));
} /* move_player_to_start() */

/**
 * No priorities etc anymore, so directors get there own very small
 * process_input parser(tm)
 */

protected mixed process_input(string input){
  if(input == "end_it_all")
    shutdown(0); 
  if(input[0..4] == "hexec")
    return do_hexec(input[5..]);
  return ::process_input(input);
}

/**
 * Very fast shutdown.
 * @return always returns 1
 */
protected int end_it_all() {
  shutdown(0);
  return 1;
} /* end_it_all() */

/**
 * This method runs the heart beat once on command.
 */
private int do_heart_beat() {
  heart_beat();
  return 1;
} /* do_heart_beat() */

/** @ignore yes */
int query_creator() {
  return 1;
} /* query_creator() */

nomask int query_director() {
  return 1;
}

nomask int query_lord() {
  return 1;
} /* query_lord() */

/**
 * This method is called when a director  attempts to employ
 * someone in their domain.
 * @param str the player to employ
 * @return 1 on success, 0 on failure
 */
protected int employ(string str) {
  string doc;

  if (GetForced()) {
    return 0;
  }
/*  set up mail to send to employeee */
/* added by FUntime, 24/5/1995 */
  /*
   * Change by pinkfish so it actually checks the return value of the
   * promotion code first.
   */
  switch (master()->employ_creator( lower_case(str) )) {
    case 2 :
      if(file_size(CREATOR_DOC) > 0) {
        /* load up file into 'doc' */
        doc = read_file(CREATOR_DOC);
        /* and post it on */
        AUTO_MAILER->auto_mail(lower_case(str), this_player()->query_name(),
          "Documents for new creators", "", doc, 0, 0);
      }
    
     /* if(file_size(PROJECT_STYLE)>0) {
        doc = read_file(PROJECT_STYLE);
        AUTO_MAILER->auto_mail(lower_case(str), this_player()->query_name(),
          "Documents for new creators", "", doc, 0, 0);
      } */
      return 1;
    case 1 :
      return 1;
    default :
      return 0;
  }
} /* employ() */

/**
 * This method is called when the director attempts to dismiss
 * a creator who is currently working (or not working
 * if they are being dimissed I guess).
 * @param str the creator to dismiss
 * @return 1 on success, 0 on failure
 */
protected int do_dismiss(string str, string reason) {
  if (GetForced()) {
    return 0;
  }
   return (int)master()->dismiss_creator( str + " " + reason);
} /* do_dismiss() */

/**
 * This method is used to create a new domain.
 * @param str the input parameters
 * @return 1 on success, 0 on failure
 */
protected int new_domain(string dom, string director) {

  if (GetForced()) {
    return 0;
  }
  return (int)master()->create_domain(dom, director);
} /* new_domain() */

/** @ignore yes */
string query_object_type(object) {
  if (master()->query_trustee(geteuid(this_object())))
    return "T";
  return "D";
} /* query_object_type() */

/** @ignore yes */
void event_enter(object me, string s1, object from) {
  if ((!s1 || s1 == "") && interactive(me)) {
    if (environment() == environment(me))
      event_inform(me, me->query_cap_name()+" invisibly enters the room",
                   "enter");
    else
      event_inform(me, me->query_cap_name()+" invisibly enters your inventory",
                   "enter");
  }
  ::event_enter(me, s1, from);
} /* event_enter() */

/** @ignore yes */
void event_exit(object me, string s1, object from) {
  if ((!s1 || s1 == "") && interactive(me)) {
    if (environment() == environment(me))
      event_inform(me, me->query_cap_name()+" invisibly exits the room",
                   "enter");
    else
      event_inform(me, me->query_cap_name()+" invisibly exits your inventory",
                   "enter");
  }
  ::event_exit(me, s1, from);
} /* event_exit() */

/** @ignore yes */
protected int do_hexec(string junk) {
  if (GetForced()) {
    return 0;
  }
  write_file("/w/"+query_name()+"/exec_thing.c", "void create() { "+junk+"; }");
  catch(("/w/"+query_name()+"/exec_thing")->bingle());
  destruct(find_object("/w/"+query_name()+"/exec_thing"));
  rm("/w/"+query_name()+"/exec_thing.c");
  return 1;
} /* do_hexec() */

/** @ignore yes */
varargs int adjust_xp(int number, int shared) {
  if (objectp(previous_object())) {
    event_inform(previous_object(),
                 (string)previous_object()->query_name() + " (" +
                 file_name(previous_object()) +") gives you " +
                 number + " xp", "xp");
  }
  return ::adjust_xp(number, shared);
} /* adjust_xp() */


/**
 * This method forces a bulk delete on a certain letter.
 * This letter will then be checked to see if any of
 * those players have timed out and should be deleted.
 * @param word the letter to bulk delete
 * @return 0 on falure and 1 on success
 */
protected int bulk_delete( string word ) {
  if (GetForced()) {
    return 0;
  }
  word = lower_case(word);
  return (int)"/secure/bulk_delete"->delete_files(word);
} /* bulk_delete() */

/**
 * This method forces the clean up of certain file son the
 * bulk deleter.  This cleans up all the files associated with
 * the given player.
 * @param word the name of the player to clean up
 * @return 1 on success, 0 on failure
 */
protected int clean_up_files( string word ) {
  if (GetForced()) {
    return 0;
  }
  return (int)"/secure/bulk_delete"->clean_up_files(word);
} /* clean_up_files() */

/**
 * This method is used to do a quiet snoop on a player.
 * @param str the player to snoop
 * @return 1 on success, 0 on failure
 */
protected int do_qsnoop(object *obs) {
  object targ;

  if (GetForced()) {
    return 0;
  }
  if (!obs || !sizeof(obs)) {
    snoop(this_object(), 0);
    write("Ok, qsnoop cancelled.\n");
    return 1;
  }
  targ = obs[0];
  if(!snoop(this_object(), targ)) {
    notify_fail("You fail to qsnoop " + targ->query_cap_name() + ".\n");
    return 0;
  }
  write("Ok, qsnooping "+targ->query_cap_name() + ".\n");
  return 1;
} /* do_qsnoop() */
// --- END [/mnt/home2/grok/lib/global/lord.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/lord/ptest_ers.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/lord/ptest_ers.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627218   Available: 13574572
Inodes: Total: 5242880    Free: 4960133
3492 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/lord/ptest_ers.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627218   Available: 13574572
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: ptest_ers.c,v 1.1 1998/01/06 05:25:41 ceres Exp $
 * $Log: ptest_ers.c,v $
 * Revision 1.1  1998/01/06 05:25:41  ceres
 * Initial revision
 * 
*/
#include <player.h>

#define LOGIN "/secure/login"

inherit "/cmds/base";

int main_menu( string cmd, string name, string reason ) {
   string str;

   switch ( cmd[ 0 ] ) {
      case 'L' :
      case 'l' :
/*         this_player()->set_finish_func( "main_menu", this_object() ); */
         str = PLAYTESTER_HAND->query_show_list();
         str += "\n\nSee: 'ptesters H' for help.\n";
         this_player()->more_string(str, "Playtester");
         return 1;
      case 'A' :
      case 'a' :
         if ( !name ) {
            return 0;
         }
         if ( !LOGIN->test_user( name ) ) {
            printf( capitalize( name ) +" does not exist.\n" );
            break;
         }
         if (!PLAYTESTER_HAND->valid_playtester( name ) ) {
            printf( capitalize( name ) + " cannot be made a play tester "
                    "because: " + PLAYTESTER_HAND->reason_invalid_playtester(name) +
                    ".\n");
            break;
         }
         if ( (int)PLAYTESTER_HAND->add_playtester( name ) ) {
            printf( capitalize( name ) +" is now a playtester.\n" );
         } else {
            printf( capitalize( name ) +" is already a playtester.\n" );
         }
         break;
      case 'S' :
      case 's' :
         if ( !name ) {
            return 0;
         }
         if ( !PLAYTESTER_HAND->query_playtester( name ) ) {
            printf( capitalize( name ) +" is not yet a playtester.\n" );
         } else {
            if ( (int)PLAYTESTER_HAND->add_senior_playtester( name ) ) {
               printf( capitalize( name ) +" is now a senior playtester.\n" );
            } else {
               printf( capitalize( name ) +" is already a senior playtester.\n" );
            }
         }
         break;
      case 'R' :
      case 'r' :
         if ( !name ) {
            return 0;
         }
         if ( !reason) {
            notify_fail("You need to supply a reason when deleting someone.\n");
            return 0;
         }
         if ( !LOGIN->test_user( name ) ) {
            printf( capitalize( name ) +" does not exist.\n" );
            break;
         }
         if ( (int)PLAYTESTER_HAND->remove_playtester( name, reason ) ) {
            printf( capitalize( name ) +" is no longer a playtester.\n" );
         } else {
            printf( capitalize( name ) +" is not a playtester.\n" );
         }
         break;
      default :
      case 'H' :
      case 'h' :
      case '?' :
         printf( "\nPlaytesters editor commands:\n\n"
               "Q        : quit the playtester editor\n"
               "L        : list playtesters\n"
               "A <name> : add a new playtester\n"
               "S <name> : promote someone to senior playtester\n"
               "R <name> : remove an existing playtester\n"
               "H        : get this list of commands\n\n" );
         break;
   }
   /* printf( "Choose one of Q, L, A, S, R or H (for help) : " );
    input_to( "main_menu" ); */
   return 1;
} /* main_menu() */

mixed *query_patterns() {
   return ({ "", (: main_menu("L", 0, 0) :),
             "{l|h|?}", (: main_menu($4[0], 0, 0) :),
             "{a|s|h|r|?} <word>", (: main_menu($4[0], $4[1], 0) :), 
             "r <word> <string>", (: main_menu("r", $4[0], $4[1]) :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/lord/ptest_ers.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/lord/dom_ain.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/lord/dom_ain.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627217   Available: 13574571
Inodes: Total: 5242880    Free: 4960133
8707 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/lord/dom_ain.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627217   Available: 13574571
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: dom_ain.c,v 1.1 2003/03/21 02:01:51 ceres Exp $
 * 
 */
#include <parser.h>
#include <access.h>
#include <player_handler.h>

inherit "/cmds/base";

#define MASTER "/secure/master"

string get_last_log( int last_log_on );

string master;

int list(string arg) {
  int i, num, cols;
  string *members, *domains, mast;

  if (this_player() != this_player(1))
    return 0;
  domains = get_dir("/d/");
  if(!sizeof(domains)) {
    notify_fail("No domains exist.\n");
    return 0;
  }
  if(arg) {
    if(member_array(arg, domains) == -1) {
      notify_fail("No such domain as " + arg + ".\n");
      return 0;
    } else {
      mast = "/d/" + arg + "/master";
      write(capitalize((string)mast->query_lord()) + " is the lord of " +
        arg + ".\nMembers         Project\n");
      members = (string *)mast->query_members();
      cols = (int)this_player()->query_cols();
      for (i=0;i<sizeof(members);i++)
        printf("%-15s %*-=s\n", members[i], cols-16,
                               mast->query_project(members[i]));
      return 1;
    }
  }
  write("Current domains:\n");
  for(i=0; i<sizeof(domains); i++) {
    mast = "/d/" + domains[i] + "/master";
    members = (string *)mast->query_members(arg);
    printf( "%15s has %2d %-7s and is owned by %s.\n", domains[ i ],
            num = sizeof( (string *)mast->query_members() ),
            ( ( num == 1 ) ? "member" : "members" ),
            capitalize( (string)mast->query_lord() ) );
  }
  return 1;
} /* list() */

int add_creator(string cre, string dom) {
  string mast;
  
  if (this_player() != this_player(1))
    return 0;

  if(file_size("/d/" + dom) != -2) {
    notify_fail("No such domain as " + dom + ".\n");
    return 0;
  }
  cre = (string)this_player()->expand_nickname(cre);
  mast = "/d/" + dom + "/master";
  if((string)mast->query_lord() != geteuid(previous_object()) &&
     !"/secure/master"->query_player_trustee(this_player()->query_name())) {
    notify_fail("You are not the Lord of that domain.\n");
    return 0;
  }
  if(!mast->add_member(cre)) {
    notify_fail("Failed to add " + capitalize(cre) + " to domain " +
      dom + ".\n");
    return 0;
  }
  write("Creator " + capitalize(cre) + " now added to domain " + dom + ".\n");
  return 1;
} /* add_creator() */

int delete_creator(string cre, string dom) {
  string mast;

  if (this_player() != this_player(1))
    return 0;

  if(file_size("/d/" + dom) != -2) {
    notify_fail("No such domain as " + dom + ".\n");
    return 0;
  }
  cre = (string)this_player()->expand_nickname(cre);
  mast = "d/" + dom + "/master";
  if((string)mast->query_lord() != geteuid(previous_object()) &&
     !"/secure/master"->query_player_trustee(this_player()->query_name())) {
    notify_fail("You are not the Lord of that domain.\n");
    return 0;
  }
  if (!mast->remove_member(cre)) {
    notify_fail("Failed to remove " + capitalize(cre) + " from domain " +
       dom + "\n");
    return 0;
  }
  write("Member " + capitalize(cre) + " removed from domain " + dom + ".\n");
  return 1;
} /* delete_creator() */

int do_project(string cre, string dom, string project) {
  string mast;

  if (this_player() != this_player(1))
    return 0;

  if(file_size("/d/" + dom) != -2) {
    notify_fail("No such domain as " + dom + ".\n");
    return 0;
  }
  cre = (string)this_player()->expand_nickname(cre);
  mast = "d/" + dom + "/master";
  if((string)mast->query_lord() != geteuid(previous_object()) &&
     !"/secure/master"->query_player_trustee(this_player()->query_name())) {
    notify_fail("You are not the Lord of that domain.\n");
    return 0;
  }
  if (!mast->set_project(cre, project)) {
    notify_fail("Failed to set the project " + project + " for " +
                capitalize(cre) + " in the domain " + dom + "\n");
    return 0;
  }
  write("Project for " + capitalize(cre) + " set to " + project + 
        " in the domain " + dom + ".\n");
  return 1;
} /* do_project() */

#ifdef DISABLED
// This is disabled since it can freeze the mud for 10+ seconds
int do_info() {
  string *creators,
         *domains,
         *mem,
         *cre_not,
         bit;
  mapping no_dir, not_creator;
  int i, j, cols;

  cols = (int)this_player()->query_cols();
  creators = get_dir("/w/");
  domains = "/secure/master"->query_domains();
  no_dir = ([ ]);
  not_creator = ([ ]);
  cre_not = ({ });
  for (i=0;i<sizeof(creators);i++)
    if (file_size("/w/"+creators[i]) != -2) {
      creators = delete(creators, i, 1);
      i--;
    } else if (!PLAYER_HANDLER->test_creator(creators[i])) {
      cre_not += ({ creators[i] });
      creators = delete(creators, i, 1);
      i--;
    }
  for (i=0;i<sizeof(domains);i++) {
    mem = (string *)("/d/"+domains[i]+"/master")->query_members() +
          ({ (string *)("/d/"+domains[i]+"/master")->query_lord() });
/* remove the members from the creators domain. */
    creators -= mem;
/* Check each one... */
    for (j=0;j<sizeof(mem);j++) {
      if (file_size("/w/"+mem[j]) != -2)
        no_dir[mem[j]] = domains[i];
      if (!PLAYER_HANDLER->test_creator(mem[j]))
        not_creator[mem[j]] = domains[i];
    }
/* Ok...  print the membership list. */
    bit = "Members of "+domains[i]+" are: ";
    printf("%s%-=*s\n", bit, cols-strlen(bit), implode(mem, ", ")+".");
  }
  if (sizeof(no_dir)) {
    write("These creators are in domains but do not have a directory:\n");
    printf("    %-=*s", cols-5, implode(keys(no_dir), ", ")+".\n");
  }
  if (sizeof(not_creator)) {
    write("These creators are in domains but are not actually creators:\n");
    printf("    %-=*s", cols-5, implode(keys(not_creator), ", ")+".\n");
  }
  if (sizeof(creators)) {
    write("These creators are not in any domain:\n");
    printf("    %-=*s", cols-5, implode(creators, ", ")+".\n");
  }
  cre_not -= ({ ".dead_ed_files", ".old_creators" });
  if (sizeof(cre_not)) {
    write("These creators have a directory, but are not creators...:\n");
    printf("    %-=*s", cols-5, implode(cre_not, ", ")+".\n");
  }
  return 1;
} /* do_info() */
#endif

int detailed_info( string name, string option ) {
  string ret, *members;
  int i, cols;

  if(member_array(name, "/secure/master"->query_domains()) == -1)
    return notify_fail("No such domain: " + name + "\n");

  cols = this_player()->query_cols();
  
  master = "/d/"+name+"/master";
  write(master+"\n");
  members = master->query_members();
  switch (option[0..0]) {
  case "n":
    members = sort_array(members, 1);
    break;
  case "p":
    members = sort_array(members,
                         (: strcmp(master->query_project($1),
                                   master->query_project($2)) :));
    break;
  case "l":
    members = sort_array(members,
                         (:PLAYER_HANDLER->test_last($2) -
                          PLAYER_HANDLER->test_last($1):));
    break;
  }
  ret = "The current members of this domain are:";
  
  for (i=0;i<sizeof(members);i++) {
    ret += sprintf("\n%-12s: Last login: %s\n",
                   capitalize(members[i]),
                   find_player(members[i])?
                     "%^GREEN%^%^BOLD%^Now%^RESET%^"
                     :get_last_log((int)PLAYER_HANDLER->test_last(members[i])),
                   );
    ret += sprintf("              Project   : %-=*s\n", cols-27,
                   master->query_project(members[i]));
  }
  this_player()->more_string(ret, "Domain Info");
  return 1;
}

string get_last_log(int last_log_on) {
    string retval;
    int tmp_time, sec, min, hour, day;

/* Should be a nice number.... */
    tmp_time = time()-last_log_on;
    if (!tmp_time) {
      sec = min = hour = day = 0;
    }
    if(tmp_time > 24*60*60) {
      retval = (day = tmp_time/(24*60*60))+" day"+
                (day<2?"":"s")+" ago.";
      if(day > 14)
        retval = "%^RED%^"+retval+"%^RESET%^";
      else if(day > 7)
        retval = "%^YELLOW%^"+retval+"%^RESET%^";
      else
        retval = "%^GREEN%^"+retval+"%^RESET%^";
    } else
      retval = "%^GREEN%^Today%^RESET%^";
    
    return retval;
}

mixed *query_patterns() {
  return ({
    "list <string'list'>", (: list($4[0]) :),
    "add <word'creator'> <word'domain'>", (: add_creator($4[0], $4[1]) :),
    "delete <word'creator'> <word'domain'>",
      (: delete_creator($4[0], $4[1]) :),
    "project <word'creator'> <word'domain'> <string'project'>",
      (: do_project($4[0], $4[1], implode($4[2..], " ")) :),
#ifdef DISABLED     
    "info", (: do_info() :),
#endif      
    "info <string'domain'>", (: detailed_info($4[0], " ") :),
    "info <string'domain'> [by] {n|name|p|project|l|login}",
      (: detailed_info($4[0], $4[1]) :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/lord/dom_ain.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/lord/playera_ddproperty.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/lord/playera_ddproperty.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627214   Available: 13574568
Inodes: Total: 5242880    Free: 4960133
2623 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/lord/playera_ddproperty.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627214   Available: 13574568
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: playera_ddproperty.c,v 1.5 2003/03/21 01:58:43 ceres Exp $
 * $Log: playera_ddproperty.c,v $
 * Revision 1.5  2003/03/21 01:58:43  ceres
 * Modified to use player handler
 *
 * Revision 1.4  2002/02/07 11:02:24  drakkos
 * Fixed it up to work with compression.
 *
 * Revision 1.3  2001/06/01 20:58:21  ceres
 * Can't remember
 *
 * Revision 1.2  1999/10/28 02:33:41  ceres
 * tried to make it work
 *
 * Revision 1.1  1998/01/06 05:29:21  ceres
 * Initial revision
 * 
*/
#include <parser.h>
#include <player_handler.h>

inherit "/cmds/base";

string var_name = "map_prop ";
string fname;

/*
 * This will add a property to a player.
 */
mixed cmd(string player, string name, mixed value) {
   mixed *args;
   string file;
   string *bits;
   mapping map_prop;
   int i, found;

   seteuid("Root");

   fname = "/save/players/" + player[0..0] + "/" + player;

   /* Restore them... */
   map_prop = ([ ]);
   if (!PLAYER_HANDLER->test_user(player))
     return notify_fail("Unable to find player "+player+".\n");
   uncompress_file (fname+".o.gz");
   file = unguarded( (: read_file(fname+".o") :));
   if(!file)
     return notify_fail("Error reading player file " + fname + ".\n");
      
   bits = explode(file, "\n");
   map_prop = ([ ]);
   for (i = 0; i < sizeof(bits); i++) {
     if (bits[i][0..strlen(var_name)-1] == var_name) {
       map_prop = restore_variable(bits[i][strlen(var_name) + 0..]);
       found = 1;
       break;
     }
   }
   if(!found || !map_prop)
     return notify_fail("Failed to find property mapping.\n");

   if(stringp(args)) {
     args = PARSER->parse_args(value);
     if(!args || !sizeof(args[0]))
       return notify_fail("No useful args...\n");      

     map_prop[name] = args[0][0];
     write(sprintf("Added property %s to %s; value = %O\n",
                   name, player, args[0][0]));
   } else {
     map_prop[name] = value;
   }
   
   if (i < sizeof(bits)) {
     bits[i] = var_name + save_variable(map_prop);
   } else {
     bits += ({ var_name + save_variable(map_prop) });
   }

         
   unguarded( (: rm(fname + ".old") :) );
   
   unguarded( (: rename(fname+".o", fname+".old") :) );
   
   unguarded( (: write_file(fname + ".o",
                            implode($(bits), "\n") + "\n") :));
   compress_file (fname+".o");
   
   this_player()->add_succeeded_mess (this_object(), "$N manipulate$s " 
    "reality a little.\n", ({ }));
   return 1;
} /* cmd() */

mixed *query_patterns() {
  return ({ "<word> <string:quoted> <string>", (: cmd($4[0], $4[1], $4[2]) :),
            });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/lord/playera_ddproperty.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/lord/rms_enior.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/lord/rms_enior.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627213   Available: 13574567
Inodes: Total: 5242880    Free: 4960133
921 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/lord/rms_enior.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627213   Available: 13574567
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: rms_enior.c,v 1.2 2003/03/21 02:00:44 ceres Exp $
 * $Log: rms_enior.c,v $
 * Revision 1.2  2003/03/21 02:00:44  ceres
 * Modified to use player handler
 *
 * Revision 1.1  1998/01/06 05:29:21  ceres
 * Initial revision
 * 
*/
#include <parser.h>
#include <player_handler.h>

inherit "/cmds/base";


/*
 * This will remove a senior creator.
 */
mixed cmd(string creator) {
  seteuid("Root");
  
  if ( !PLAYER_HANDLER->test_user( creator ) ||
       !"/secure/master"->query_lord( previous_object( -1 ) ) )
    return notify_fail("You must be a lord to remove a senior creator.\n");

  if("/secure/master"->remove_senior(creator)) {
    write(creator + " removed from senior.\n");
    return 1;
  } else
    return notify_fail("Call to remove_senior failed.\n");
} /* cmd() */

mixed *query_patterns() {
  return ({ "<string>", (: cmd($4[0]) :), });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/lord/rms_enior.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/lord/site.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/lord/site.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627213   Available: 13574567
Inodes: Total: 5242880    Free: 4960133
3593 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/lord/site.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627213   Available: 13574567
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*   -*- LPC -*-   */
/*
 * $Locker:  $
 * $Id: site.c,v 1.9 2001/06/01 20:58:28 ceres Exp $
 */
#include <parser.h>
#include <access.h>

inherit "/cmds/base";

/*
 * This will ban a site
 */
mixed cmd(string address, string level, string reason) {

   seteuid("Root");
   
   if (this_player() != this_player(1))
      return 0;

   switch(level) {
   case "nonew":
      level = "2";
      break;
   case "noacccess":
      level = "3";
      break;
   case "authnew":
     level = "4";
     break;
   case "normal":
      level = "1";
      break;
   }

   // the .* is nolonger needed in addresses (or names for that matter).
   address = replace(address, ".*", "");
   
   if (!"/secure/bastards"->change_access(address, to_int(level), reason)) {
     write("Error changing permissions.\n");
     return 0;
   }
   
   write("Access permisions changed.\n");
   printf("Site %s set to %s for %s\n", address, PERM_NAMES[to_int(level)],
          reason);
   return 1;
} /* cmd() */

int access(string filter) {
  string addr, ret;
  mapping list;
  int found;
  
  seteuid("Root");
  
  if (this_player() != this_player(1))
    return 0;
  
  list = "/secure/bastards"->query_all_access();
  
  ret = "";
  
  foreach(addr in keys(list)) {
    if(!filter || filter == "" || strsrch(addr, filter) != -1) {
      found = 1;
      ret += sprintf("%-20s %-18s %-=39s\n", addr,
                     PERM_NAMES[list[addr][ACCESS_LEVEL]],
                     list[addr][ACCESS_REASON]);
    }
  }
  if (!found)
    return notify_fail("No access control defined.\n");

  write("Current access list:\n");
  this_player()->more_string(ret, "site access");
  return 1;
}

int multi(int allow, string address) {
  if("/secure/bastards"->change_multi(address, allow, 0)) {
    if(allow)
      write("Site " + address + " has been permitted for multiplayers.\n");
    else
      write("Site " + address + " has been blocked for multiplayers.\n");
  } else
    write("Error multiplayer settings for site " + address + ".\n");
  
  return 1;
}

int list_multi(string filter) {
  string addr, ret;
  mapping list;
  int found;

  list = "/secure/bastards"->query_all_multi();

  ret = "";
  foreach(addr in keys(list)) {
    if(!filter || filter == "" || strsrch(addr, filter) != -1) {
      found = 1;
      ret += sprintf("%-30s\n", addr);
    }
  }
  if (!found)
    return notify_fail("No access control defined.\n");
  
  write("Current multuser site list:\n");
  this_player()->more_string(ret, "site access");
  return 1;
}

int help() {
   return notify_fail(
      "Syntax: site access\n"+
      "            site ban <ip number|site name> <level> <reason>\n"+
      "                     <level> := normal normal access,\n"+
      "                                nonew no new players, \n"+
      "                                authnew authorised new players\n"+
      "                                noaccess no access.\n");
}
mixed *query_patterns() {
   return ({ "ban <word'address'> <word'level'> <string'reason'>",
               (: cmd($4[0], $4[1], implode($4[2..], "")) :),
               "allow multi <word'address'>",
               (: multi(1, $4[0]) :),
               "disallow multi <word'address'>",
               (: multi(0, $4[0]) :),
               "list multi", (: list_multi("") :),
               "list multi <word'address'>", (: list_multi($4[0]) :),
               "access <word'address'>", (: access($4[0]) :),
               "access", (: access("") :),
               "", (: help() :),
               "help", (: help() :)
               });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/lord/site.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/lord/rmdirector.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/lord/rmdirector.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627212   Available: 13574566
Inodes: Total: 5242880    Free: 4960133
756 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/lord/rmdirector.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627212   Available: 13574566
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: rmdirector.c,v 1.4 2003/03/21 02:23:55 ceres Exp $
 * 
*/
#include <parser.h>
#include <player_handler.h>

inherit "/cmds/base";


/*
 * This will remove a director.
 */
mixed cmd(string creator) {
  seteuid("Root");
  
  if ( !PLAYER_HANDLER->test_user( creator ) ||
       !"/secure/master"->query_trustee( previous_object( -1 ) ) )
    return notify_fail("You must be a trustee to remove a director.\n");

  if("/secure/master"->remove_director(creator)) {
    write(creator + " removed from directorship.\n");
    return 1;
  } else
    return notify_fail("Call to remove_director failed.\n");
} /* cmd() */

mixed *query_patterns() {
  return ({ "<string>", (: cmd($4[0]) :), });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/lord/rmdirector.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/lord/wstats.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/lord/wstats.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627212   Available: 13574566
Inodes: Total: 5242880    Free: 4960133
679 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/lord/wstats.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627212   Available: 13574566
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/cmds/base";

int cmd(string str) {
  mapping stats;
  string obj, file;
  int total, num;
  
  stats = "/secure/master"->query_write_stats();

  if(str) {
    if(!stats[str])
      return notify_fail("No such file\n");
    foreach(file in keys(stats[str])) {
      if(stats[str][file] > 1)
        printf("%-60s %5d\n", file, stats[str][file]);
    }
    return 1;
  }
  printf("%-60s %5s %5s\n", "Object", "Total", "Files");
  foreach(obj in keys(stats)) {
    total = 0;
    num = 0;
    foreach(file in keys(stats[obj])) {
      num++;
      total += stats[obj][file];
    }
        if(total > 50)
      printf("%-60s %5d %5d\n", obj, total, num);
  }
  return 1;
}
// --- END [/mnt/home2/grok/lib/cmds/lord/wstats.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/lord/jumps.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/lord/jumps.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627211   Available: 13574565
Inodes: Total: 5242880    Free: 4960133
1758 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/lord/jumps.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627211   Available: 13574565
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/cmds/base";
#include <playtesters.h>

object find_location(string str) {
   if (find_object(str)) {
      return find_object(str);
   }

   return load_object(str);
}

int do_add_jump(string from, string to) {
   object from_ob;
   object to_ob;

   from_ob = find_location(from);
   to_ob = find_location(to);

   if (!from_ob) {
      add_failed_mess("The from location does not exist.\n");
      return 0;
   }
   if (!to_ob) {
      add_failed_mess("The to location does not exist.\n");
      return 0;
   }

   PLAYTESTER_HAND->add_jump_point(from, to);
   write("You added the jump point from " + from + " to " + to + ".\n");
   return 1;
}

int do_path_list() {
   string str;
   string from;
   string* dest;

   str = "";
   foreach (from, dest in PLAYTESTER_HAND->query_jump_points()) {
      str += from + ": " + query_multiple_short(dest) + ".\n";
   }
   write(str);
   return 1;
}

int do_remove_jump(string from, string to) {
   string* dests;

   dests = PLAYTESTER_HAND->query_jump_destination(from);
   if (!sizeof(dests)) {
      add_failed_mess("There are no destiations from " + from + ".\n");
      return 0;
   }
   if (member_array(to, dests) == -1) {
      add_failed_mess("Unable to remove a jump from " + from + " to " +
                      to + ".\nValid to's are: " +
                      query_multiple_short(dests) + ".\n");
      return 0;
   }
   PLAYTESTER_HAND->remove_jump_point(from, to);
   write("Removed the jump from " + from + " to " + to + ".\n");
   return 1;
}

mixed* query_patterns() {
   return ({ "add <string'from'> <string'to'>", (: do_add_jump($4[0], $4[1]) :),
        "remove <string'from'> <string'to'>", (: do_remove_jump($4[0], $4[1]) :),
        "creator list", (: do_path_list :) });
}
// --- END [/mnt/home2/grok/lib/cmds/lord/jumps.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/lord/mkl_ord.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/lord/mkl_ord.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627211   Available: 13574565
Inodes: Total: 5242880    Free: 4960133
888 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/lord/mkl_ord.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627211   Available: 13574565
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: mkl_ord.c,v 1.1 2003/03/21 02:01:13 ceres Exp $
 * $Log: mkl_ord.c,v $
 * Revision 1.1  2003/03/21 02:01:13  ceres
 * Initial revision
 *
 * Revision 1.1  1998/01/06 05:29:21  ceres
 * Initial revision
 * 
*/
#include <parser.h>
#include <player_handler.h>

inherit "/cmds/base";


/*
 * This will add a diector.
 */
mixed cmd(string creator) {
  seteuid("Root");
  
  if ( !PLAYER_HANDLER->test_user( creator ) ||
       !"/secure/master"->high_programmer( previous_object( -1 ) ) )
    return notify_fail("You must be a highlord to add a lord.\n");

  if("/secure/master"->add_director(creator)) {
    write(creator + " promoted to director.\n");
    return 1;
  } else
    return notify_fail("Call to add_director failed.\n");
} /* cmd() */

mixed *query_patterns() {
  return ({ "<string>", (: cmd($4[0]) :), });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/lord/mkl_ord.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/lord/nskills.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/lord/nskills.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627210   Available: 13574564
Inodes: Total: 5242880    Free: 4960133
3595 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/lord/nskills.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627210   Available: 13574564
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: skills.c,v 1.4 1998/08/19 10:19:00 pinkfish Exp $
 * $Log: skills.c,v $
 * Revision 1.4  1998/08/19 10:19:00  pinkfish
 * Add in stuff to put in the command name.
 *
 * Revision 1.3  1998/02/25 19:33:25  gototh
 * Little fix on previous query_stupid_skills().
 *
 * Revision 1.1  1998/01/06 05:27:04  ceres
 * Initial revision
 * 
*/
#include <skills.h>

inherit "/cmds/guild_base";

int new_skill_value(int sk) {
	float f = 1000.0;
	float k = 0.3;

	if(sk == 0)
		return 0;
	
	return to_int(f * log( 1.0 + sk/(f + sk * k) ) + 0.5);
}

string rec_list( mixed *args, string path, int all, int lvl,
                 int only_leaf, object pl ) {
   int i, sk, o_l;
   string str, tp, tmp;

   str = "";
   for ( i = 0 ; i < sizeof( args ) ; i += SKILL_ARR_SIZE ) {
      o_l = 0;
      tp = path +"."+ args[ i ];
      sk = (int)pl->query_skill( tp );
      if(tp[0..14] != ".other.language" && tp[0..13] != "other.language") {
        sk = new_skill_value(sk);
      }
			
      reset_eval_cost();
      if (lvl == 1 && SKILL_OB->query_only_leaf(tp))
        o_l = 1;
      if (!(only_leaf || o_l) || (!sizeof(args[i+SKILL_BIT]) &&
                                  (sk > 0 || all)))
        str += sprintf( "%*'| 's%*'.'-s %4d %4d\n", ( lvl-1 ) * 2, "",
              20 - ( ( lvl - 1 ) * 2 ), args[ i ], sk,
              (int)new_skill_value(pl->query_skill_bonus( tp )) );
      if ( sizeof( args[ i + SKILL_BIT ] ) && ( only_leaf || o_l || all 
                                                || ( sk > 5 * lvl ) ) ) {
         tmp = rec_list( args[ i + SKILL_BIT ], path +"."+ args[i],
                         all, lvl + 1, only_leaf || o_l, pl );
         if ((only_leaf || o_l) && (tmp != "" || (!all && lvl == 1)))
           str += sprintf( "%*'| 's%*'.'-s    -    -\n", ( lvl-1 ) * 2, "",
                           20 - ( ( lvl - 1 ) * 2 ), args[ i ]) + tmp;
         else
           str += tmp;
      }
   }
   return str;
} /* rec_list() */

int cmd( object *players, string word ) {
   int i;
   string result, *bits;
   object pl;
   mixed *args;

/* Only do the first player */
   pl = players[0];
   result = "";
   bits = ({ });
   if ( word ) {
      args = (mixed *)SKILL_OB->query_skills();
      if ( ( i = member_array( word, args ) ) == -1 ) {
         notify_fail( "Usage: "+ query_verb() +" <skill>\n" );
         return 0;
      }
      args = args[ i + SKILL_BIT ];
      result = sprintf( "%'='*-s\n", (int)this_player()->query_cols(),
            "=======SKILLS=======Level/Bonus" );
      result += sprintf( "%#*-s\n", (int)this_player()->query_cols(),
            rec_list( args, word, 1, 1, 0, pl ) );

		 this_player()->more_string( result, "Skills" );
      return 1;
   }
   args = (mixed *)SKILL_OB->query_skills();
   result += sprintf( "%'='*-s\n", (int)this_player()->query_cols(),
         "=======SKILLS=======Level/Bonus");
   result += sprintf( "%#*-s\n", (int)this_player()->query_cols(),
         rec_list( args, "", ( member_array( "all", bits ) != -1 ), 1, 0, pl ) );
     result += "New guild level: " +
		   (pl->query_guild_ob())->query_new_level(pl) + "\n";

   this_player()->more_string( result, "Skills" );
   return 1;
} /* cmd() */

void dest_me() {
  destruct(this_object());
} /* dest_me() */

void clean_up() {
  dest_me();
} /* clean_up() */

void reset() {
  dest_me();
} /* reset() */

mixed *query_patterns() {
  return ({ "<indirect:any-living> <string>",
            (: cmd($1, $4[1]) :),
            "<indirect:any-living>",
            (: cmd($1, 0) :) });
} /* query_pattern() */
// --- END [/mnt/home2/grok/lib/cmds/lord/nskills.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/lord/tmstats.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/lord/tmstats.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627209   Available: 13574563
Inodes: Total: 5242880    Free: 4960133
2746 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/lord/tmstats.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627209   Available: 13574563
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */

inherit "/cmds/base";

#include <tasks.h>

#define STATS_DIR "/save/tasks/"

#define DIVISOR 100

int do_summary();

int cmd(string str) {
  string file, cmd, tmp;
  mapping awards, summary, obs;
  int lvl, i, total, files;

  return do_summary();

  if(!str)
    str="";
  tmp = "";
  
  obs = ([ ]);
  summary = ([ ]);
  foreach(file in get_dir(STATS_DIR+str+"*")) {
    file = file[0..sizeof(file)-3];

    files++;
    awards = TASKER->query_stats(file);
    foreach(lvl in keys(awards)) {
      foreach(cmd in keys(awards[lvl])) {
        total += awards[lvl][cmd];
        obs[cmd] += 1;
      }
    }
  }

  foreach(cmd in keys(obs)) {
    if(obs[cmd] > 100)
      i += 1;
  }
  printf("%s: Skills: %d, Total: %d: Ratio: %d, Objects: %d, "
         "Obs over 100: %d\n",
         str, files, total, total/files, sizeof(keys(obs)), i);

  return 1;
} /* cmd() */

int do_summary() {
  string skill;
  mapping sum, stats;
  int i;
  int tries, awards;
  
  stats = TASKER->query_stats("summary");
  sum = stats;
  foreach(skill in keys(sum)) {
    if("/std/skills"->query_skill(({ skill })) != skill)
      continue;
    printf("Skill: %s \n", skill);
    
    printf("  Level 0..49:       Tries: %d, Awards: %d, ",
           sum[skill][0][0], sum[skill][0][1]);
    if(sum[skill][0][1] == 0)
      printf("Ratio: ?\n");
    else
      printf("Ratio: 1/%d\n", sum[skill][0][0]/(sum[skill][0][1]));
    
    printf("  Level 50..149:     Tries: %d, Awards: %d, ",
           sum[skill][1][0], sum[skill][1][1]);
    if(sum[skill][1][1] == 0)
      printf("Ratio: ?\n");
    else
      printf("Ratio: 1/%d\n", sum[skill][1][0]/(sum[skill][1][1]));

    printf("  Level 150..299:    Tries: %d, Awards: %d, ",
           sum[skill][2][0], sum[skill][2][1]);
    if(sum[skill][2][1] == 0)
      printf("Ratio: ?\n");
    else
      printf("Ratio: 1/%d\n", sum[skill][2][0]/(sum[skill][2][1]));
    
    printf("  Level 300..599:    Tries: %d, Awards: %d, ",
           sum[skill][3][0], sum[skill][3][1]);
    if(sum[skill][3][1] == 0)
      printf("Ratio: ?\n");
    else
      printf("Ratio: 1/%d\n", sum[skill][3][0]/(sum[skill][3][1]));

    printf("  Level >= 600:      Tries: %d, Awards: %d, ",
           sum[skill][4][0], sum[skill][4][1]);
    if(sum[skill][4][1] == 0)
      printf("Ratio: ?\n");
    else
      printf("Ratio: 1/%d\n", sum[skill][4][0]/(sum[skill][4][1]));

    tries = 0;
    awards = 0;
    for(i=0; i<3; i++) {
      tries += sum[skill][i][0];
      awards += sum[skill][i][1];
    }
      
    printf("  Total:              Tries: %d, Awards: %d, ", tries, awards);
    if(!awards)
      printf("Ratio: ?\n");
    else
      printf("Ratio: 1/%d\n", tries/awards);
           
  }
  return 1;
}
// --- END [/mnt/home2/grok/lib/cmds/lord/tmstats.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/lord/quests.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/lord/quests.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627208   Available: 13574562
Inodes: Total: 5242880    Free: 4960133
10048 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/lord/quests.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627208   Available: 13574562
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: quests.c,v 1.6 2000/07/29 15:40:43 laurana Exp $
 * $Log: quests.c,v $
 * Revision 1.6  2000/07/29 15:40:43  laurana
 * fixed my help
 *
 * Revision 1.4  2000/07/24 13:29:54  taffyd
 * Tightened use of protected/private.
 *
 * Revision 1.3  2000/07/24 13:27:41  taffyd
 * Fixed up the quests command so you can't get info unless you're allowed(tm).
 *
 * Revision 1.2  1999/05/20 01:07:54  ceres
 * Added support for active/inactive flag
 *
 * Revision 1.1  1998/01/06 05:29:21  ceres
 * Initial revision
 * 
*/
#include <quest_handler.h>

#define TEXTS_DIR "/save/quests/"

inherit "/cmds/base";

private string *names;
private mapping makers;

protected void create() {
   makers = ([ ]);
} /* create() */

private void print_info( int i ) {
   string text;
   text = read_file( TEXTS_DIR + replace( names[ i ], " ", "_" ) +".txt" );
   if ( !text )
      text = "There is no text file for this quest.\n";
   printf( "\nQuest %d of %d  \"%s\", level %d\n"
           "   title: %s\n   story: %s\n"
           "   Active: %s\n"
           "   completed %d times, last by %s\n\n"
           "%s\n",
           i + 1, sizeof( names ), names[ i ],
           (int)QUEST_HANDLER->query_quest_level( names[ i ] ),
           (string)QUEST_HANDLER->query_quest_title( names[ i ] ),
           (string)QUEST_HANDLER->query_quest_story( names[ i ] ),
           (int)QUEST_HANDLER->query_quest_status(names[i]) ? "Yes" : "No",
           (int)QUEST_HANDLER->query_quest_times( names[ i ] ),
           capitalize( (string)QUEST_HANDLER->query_quest_done( names[ i ] ) ),
           text );
} /* print_info() */


private void change_status( int i ) {
  
  switch(QUEST_HANDLER->change_quest_status(names[i])) {
  case 1:
    printf("Quest %s set to active.\n", names[i]);
    break;
  case 0:
    printf("Quest %s set to inactive.\n", names[i]);
    break;
  case -1:
    printf("No such quest: %s.\n", names[i]);
    break;
  }
}

void main_menu( string word ) {
   int number, which;
   string name;
   mixed *args;
   
   which = makers[ this_player() ][ 0 ];
   args = makers[ this_player() ][ 1 ];
   if ( !word || ( word == "" ) )
      word = " ";
   switch ( word[ 0 ] ) {
      case 'Q' :
      case 'q' :
         return;
      case 'N' :
      case 'n' :
         if ( which > sizeof( names ) - 2 ) {
            printf( "No more quests.\n" );
            which = sizeof( names ) - 1;
            break;
         }
         which++;
         print_info( which );
         break;
      case 'A':
      case 'a':
         change_status(which);
         break;
      case 'P' :
      case 'p' :
         if ( which < 1 ) {
            printf( "No previous quests.\n" );
            which = 0;
            break;
         }
         which--;
         print_info( which );
         break;
      case 'G' :
      case 'g' :
         if ( strlen( word ) < 3 ) {
            printf( "Syntax: G <number>\n" );
            break;
         }
         if ( sscanf( word[ 2 .. ], "%d", number ) != 1 ) {
            printf( "Syntax: G <number>\n" );
            break;
         }
         if ( ( number < 1 ) || ( number > sizeof( names ) ) ) {
            printf( "Number must be between 1 and %d.\n", sizeof( names ) );
            break;
         }
         which = number - 1;
         print_info( which );
         break;
      case 'C' :
      case 'c' :
         if ( strlen( word ) < 3 ) {
            printf( "Syntax: C <quest>\n" );
            break;
         }
         if ( args[ 0 ] < 1 ) {
            printf( "No quest level set.\n" );
            break;
         }
         if ( !stringp( args[ 1 ] ) ) {
            printf( "No quest title set.\n" );
            break;
         }
         if ( !stringp( args[ 2 ] ) ) {
            printf( "No quest story set.\n" );
            break;
         }
         word = word[ 2 .. ];
         if ( member_array( word, names ) != -1 ) {
            printf( "There is already a quest \""+ word +"\".\n" );
            break;
         }
         QUEST_HANDLER->add_quest( word, args[ 0 ], args[ 1 ], args[ 2 ] );
         names += ({ word });
         args = allocate( 3 );
         printf( "Quest \""+ word +"\" added.\n" );
         which = sizeof( names ) - 1;
         print_info( which );
         break;
      case 'L' :
      case 'l' :
         if ( strlen( word ) < 3 ) {
            printf( "Syntax: L <level>\n" );
            break;
         }
         if ( sscanf( word[ 2 .. ], "%d", number ) != 1 ) {
            printf( "Syntax: L <level>\n" );
            break;
         }
         if ( number < 1 ) {
            printf( "Level must be at least 1.\n" );
            break;
         }
         args[ 0 ] = number;
         printf( "Quest level set to "+ number +".\n" );
         break;
      case 'T' :
      case 't' :
         if ( strlen( word ) < 3 ) {
            printf( "Syntax: T <title>\n" );
            break;
         }
         word = word[ 2 .. ];
         if ( member_array( word, (string)QUEST_HANDLER->query_quest_titles() )
               != -1 ) {
            printf( "There is already a quest that gives the title \""+
                  word +"\".\n" );
            break;
         }
         args[ 1 ] = word;
         printf( "Quest title set to \""+ word +"\".\n" );
         break;
      case 'S' :
      case 's' :
         if ( strlen( word ) < 3 ) {
            printf( "Syntax: S <story>\n" );
            break;
         }
         word = word[ 2 .. ];
         if ( member_array( word, (string)QUEST_HANDLER->query_quest_stories() )
               != -1 ) {
            printf( "There is already a quest that has the story \""+
                  word +"\".\n" );
            break;
         }
         args[ 2 ] = word;
         printf( "Quest story set to \""+ word +"\".\n" );
         break;
      case 'R' :
      case 'r' :
         printf( "\nQuest data so far:\n" );
         if ( args[ 0 ] < 1 )
            word = "not set";
         else
            word = sprintf( "%d", args[ 0 ] );
         printf( "   level: %s\n", word );
         if ( !stringp( args[ 1 ] ) )
            word = "not set";
         else
            word = args[ 1 ];
         printf( "   title: %s\n", word );
         if ( !stringp( args[ 2 ] ) )
            word = "not set";
         else
            word = args[ 2 ];
         printf( "   story: %s\n\n", word );
         break;
      case 'E' :
      case 'e' :
         printf( "Editing the text file...\n"
               "The log will show that you edited this file; if you "
               "ruin it,\nyou will be hunted down and eviscerated.\n" );
         this_player()->do_edit( read_file( TEXTS_DIR +
               replace( names[ which ], " ", "_" ) +".txt" ),
               "end_edit" );
         return;
      case 'F' :
      case 'f' :
         if ( strlen( word ) < 3 ) {
            printf( "Syntax: F <word>\n" );
            break;
         }
         word = word[ 2 .. ];
         number = 0;
         foreach ( name in ( names[ which + 1 .. ] + names[ 0 .. which ] ) ) {
            which = ( which + 1 ) % sizeof( names );
            if ( strsrch( name, word ) != -1 ) {
               print_info( which );
               number = 1;
               break;
            }
            if ( strsrch( lower_case( (string)QUEST_HANDLER->
                  query_quest_title( name ) ), word ) != -1 ) {
               print_info( which );
               number = 1;
               break;
            }
            if ( strsrch( lower_case( (string)QUEST_HANDLER->
                  query_quest_story( name ) ), word ) != -1 ) {
               print_info( which );
               number = 1;
               break;
            }
         }
         if ( !number )
            printf( "\""+ word +"\" not found.\n" );
         break;
      case 'H' :
      case 'h' :
         printf( "\nQuest editor commands:\n\n"
               "Q          : quit the quest editor\n"
               "N          : go to the next quest\n"
               "P          : go to the previous quest\n"
               "G <number> : go to a particular quest by number\n"
               "A          : toggle a quests active/inactive flag\n"
               "C <quest>  : create a new quest\n"
               "L <level>  : set a new quest's level\n"
               "T <title>  : set a new quest's title\n"
               "S <story>  : set a new quest's story\n"
               "R          : review the new quest's data\n"
               "E          : edit the quest's text file\n"
               "F <word>   : find the next quest using that word\n"
               "H          : get this list of commands\n\n"
               "To create a new quest, set the level, title and \n"
               "story first, then use C to create the quest with \n"
               "the title that creators will see.\n\n"
               "No command will reprint the current quest.\n\n" );
         break;
      default :
         print_info( which );
   }
   makers[ this_player() ] = ({ which, args });
   printf( "Choose one of Q, N, P, G, C, L, T, S, R, E, F or H (for help) : " );
   input_to( "main_menu" );
} /* main_menu() */

void end_edit( string text ) {
   string name;
   if ( !text || ( text == "" ) ) {
      printf( "Aborted.\n" );
      main_menu( "Z" );
      return;
   }
   if ( text[ <1 ] != '\n' )
      text += "\n";
   name = names[ makers[ this_player() ][ 0 ] ];
   log_file( "QUESTS", ctime( time() ) +" "+
         (string)this_player()->query_name() +
         " changed text file for "+ name +"\n" );
   printf( "Writing file...\n" );
   unguarded( (: write_file, TEXTS_DIR + replace( name, " ", "_" ) +
         ".txt", text, 1 :) );
   main_menu( "Z" );
} /* end_edit() */

private int cmd() {
   names = (string *)QUEST_HANDLER->query_quest_names();
   makers[ this_player() ] = ({ 0, allocate( 3 ) });
   main_menu( "G 1" );
   return 1;
} /* cmd() */

/** 
 * @ignore yes
 */
public mixed *query_patterns() {
    return ({ "", (: cmd() :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/lord/quests.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/lord/domainlock.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/lord/domainlock.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627206   Available: 13574560
Inodes: Total: 5242880    Free: 4960133
1375 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/lord/domainlock.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627206   Available: 13574560
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * Domain lock command.
 * For those who are in control(tm).
 * <p>
 * @author Taffyd
 */

#include <applications.h>

inherit "/cmds/base";

int domain_check() {
  mapping map = APPLICATIONS_HANDLER->query_domain_status();
  string ret = "";
  
  foreach (string s, int o in map) {
    ret += capitalize (s) + " is " + (o ? "open" : "closed") + " to "
      "applications and is managed by " + 
      capitalize (APPLICATIONS_HANDLER->query_responsibility (s)) + ".\n"; 
  }
  
  this_player()->more_string (ret);
  return 1;
  
} /* domain_check() */

int cmd( string domain, int status ) { 
  int i = APPLICATIONS_HANDLER->query_domain_status()[domain];
  
  if (i == -1) {
    this_player()->add_failed_mess (this_object(), "You do not have "
      "permission to close the " + domain + " domain.\n");
    return 0;
  }
  
  if (status != i) {
    APPLICATIONS_HANDLER->toggle_domain_lock (domain);
    this_player()->add_succeeded_mess (this_object(), "$N furtively "
      "toggle$s something.\n", ({ }));
    return 1;
  }

  this_player()->add_failed_mess (this_object(), "Your domainlock is "
    "already set to that.\n", ({ }));  
  return 0;
} /* cmd() */

mixed *query_patterns() { 
    return ({ "<string'domain'> on", (: cmd( $4[0], 0 ):),
      "<string'domain'> off", (: cmd( $4[0], 1  ):),
      "list", (: domain_check() :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/lord/domainlock.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/lord/dinfo.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/lord/dinfo.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627205   Available: 13574559
Inodes: Total: 5242880    Free: 4960133
3082 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/lord/dinfo.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627205   Available: 13574559
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: dinfo.c,v 1.4 2000/08/19 21:38:27 ceres Exp $
 * $Log: dinfo.c,v $
 * Revision 1.4  2000/08/19 21:38:27  ceres
 * Fixed to use player_handler instead of finger
 *
 * Revision 1.3  2000/06/22 23:33:15  ceres
 * Modified to use query_domains()
 *
 * Revision 1.2  1999/10/12 03:25:46  jeremy
 * Added sort parameters.  Also added "Now" to show those currently
 * logged on.
 *
 * Revision 1.1  1998/01/06 05:29:21  ceres
 * Initial revision
 * 
*/

#include <player_handler.h>

string master;

string dinfo( string name, int cols, string option );
string get_last_log( int last_log_on );

mixed cmd(string name, string option) {
  if (!name) {
    return notify_fail("You must give a domain.\n");
  }
  this_player()->more_string(dinfo(name, (int)this_player()->query_cols(),
                                   option), "Domain Info");
  return 1;
}

string dinfo( string name, int cols, string option ) {
  string ret, *members;
  int i;

  if(member_array(name, "/secure/master"->query_domains()) == -1)
    return "No such domain: " + name + "\n";
  
  master = "/d/"+name+"/master";
  write(master+"\n");
  members = master->query_members();
  switch (option[0..0]) {
  case "n":
    members = sort_array(members, 1);
    break;
  case "p":
    members = sort_array(members,
                         (: strcmp(master->query_project($1),
                                   master->query_project($2)) :));
    break;
  case "l":
    members = sort_array(members,
                         (:PLAYER_HANDLER->test_last($2) -
                          PLAYER_HANDLER->test_last($1):));
    break;
  }
  ret = "The current members of this domain are:";
  
  for (i=0;i<sizeof(members);i++) {
    ret += sprintf("\n%-12s: Last login: %s\n",
                   capitalize(members[i]),
                   find_player(members[i])?
                     "%^GREEN%^%^BOLD%^Now%^RESET%^"
                     :get_last_log((int)PLAYER_HANDLER->test_last(members[i])),
                   );
    ret += sprintf("              Project   : %-=*s\n", cols-27,
                   master->query_project(members[i]));
  }
  return ret;
}

void dest_me() {
  destruct(this_object());
}

void clean_up() {
  dest_me();
}

void reset() {
  dest_me();
}

string get_last_log(int last_log_on) {
    string retval;
    int tmp_time, sec, min, hour, day;

/* Should be a nice number.... */
    tmp_time = time()-last_log_on;
    if (!tmp_time) {
      sec = min = hour = day = 0;
    }
    if(tmp_time > 24*60*60) {
      retval = (day = tmp_time/(24*60*60))+" day"+
                (day<2?"":"s")+" ago.";
      if(day > 14)
        retval = "%^RED%^"+retval+"%^RESET%^";
      else if(day > 7)
        retval = "%^YELLOW%^"+retval+"%^RESET%^";
      else
        retval = "%^GREEN%^"+retval+"%^RESET%^";
    } else
      retval = "%^GREEN%^Today%^RESET%^";
    
    return retval;
}

mixed query_patterns() {
  return ({
    "<string'domain'>", (: cmd($4[0], " ") :),
    "<string'domain'> [by] {n|name|p|project|l|login}",
      (: cmd($4[0], $4[1]) :)
  });
}
// --- END [/mnt/home2/grok/lib/cmds/lord/dinfo.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/lord/authorise.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/lord/authorise.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627204   Available: 13574558
Inodes: Total: 5242880    Free: 4960133
6080 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/lord/authorise.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627204   Available: 13574558
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: authorise.c,v 1.8 2003/04/15 19:33:32 ceres Exp $
 *
 *
 */

/*
 * $Locker:  $
 * $Id: authorise.c,v 1.8 2003/04/15 19:33:32 ceres Exp $
 * $Log: authorise.c,v $
 * Revision 1.8  2003/04/15 19:33:32  ceres
 * Added cache cleanout
 *
 * Revision 1.7  2003/03/21 02:01:31  ceres
 * Modified to use player handler
 *
 * Revision 1.6  2002/01/11 22:25:33  drakkos
 * Added compression handling.
 *
 * Revision 1.5  2001/03/12 19:24:07  ceres
 * Added support for authorising players while online
 *
 * Revision 1.4  1999/07/10 19:33:34  ceres
 * Modified to store the email address of the person this layer was authorised for.
 *
 * Revision 1.3  1999/06/28 17:08:46  ceres
 * Modified to set last_log_on since otherwise they expire immediately
 *
 * Revision 1.2  1999/03/04 08:17:57  pinkfish
 * Added in some stuff to create the player file if it does not exists.
 *
 * Revision 1.1  1999/03/03 06:08:14  ceres
 * Initial revision
 *
 * Revision 1.1  1998/01/06 05:29:21  ceres
 * Initial revision
 * 
*/
#include <parser.h>
#include <player_handler.h>

inherit "/cmds/base";

nosave string var_name = "map_prop ";
nosave string fname;
mapping map_prop;
mapping player_info;
string name;
string password;
string email;
int last_log_on;
string basename;

/*
 * This will add a property to a player.
 */
mixed cmd(string player) {
  if(find_player(player)) {
    find_player(player)->add_property("authorised player", 1);
    return 1;
  }
  
  if (PLAYER_HANDLER->test_user(player)) {
    if("/cmds/lord/playera_ddproperty"->cmd(player, "authorised player","1")) {
      PLAYER_HANDLER->remove_cache_entry(player);
      return 1;
    }
    return 0;
    
  }
  write(capitalize(player) + " does not exists.  Do you wish to create them? ");
  input_to("really_create", 0, player);
  add_succeeded_mess("");
  return 1;
}

void really_create(string response, string player) {
   response = lower_case(response);
   if (response[0] != 'y') {
      write("Aborting create.\n");
      return ;
   }
   write("Ok, creating player " + capitalize(player) + ".\n");
   write("What is their authorised email address: ");
   input_to("get_email", 0, player);
}
void get_email(string str, string player) {
  email = str;
  write("What password do you wish to use: ");
  input_to("get_password", 0, player);
} /* really_create() */

void get_password(string passw, string player) {
   string save_file_name;

   save_file_name = PLAYER_HANDLER->query_player_file_name(player);
   map_prop = ([ "authorised player" : 1,
                 "new player" : 1,
                 "player" : 1,
                 "authorised email" : email, ]);
   player_info = ([ "email" : ":"+email, ]);
   last_log_on = time();
   name = player;
   password = crypt(passw, 0);
   save_object(save_file_name);
   write("Create player " + capitalize(player) + " with authorisation to login "
         "from nologin sites.\n");
} /* get_password() */

int enable(string player, string address) {
  string *ips, file, *bits;
  int i;
  
  if(!PLAYER_HANDLER->test_user(player))
    return notify_fail("No such user " + player + ".\n");

  /* Restore them... */
  basename = "/save/players/" + player[0..0] + "/" + player;
  unguarded ( (: uncompress_file (basename + ".o.gz") :));    
  file = unguarded( (: read_file(basename + ".o") :));
  bits = explode(file, "\n");
  
  for (i = 0; i < sizeof(bits); i++) {
    if (bits[i][0..strlen("player_info")-1] == "player_info") {
      player_info = restore_variable(bits[i][strlen("player_info") + 1..]);
      break;
    }
  }

  ips = player_info["allowed_ips"];
  if(!ips)
    ips = ({ });
  
  if ( member_array(address, ips ) == -1 )  {
    ips += ({ address });
    player_info["allowed_ips"] = ips;

    if (i < sizeof(bits)) {
      bits[i] = "player_info " + save_variable(player_info);
    } else {
      bits += ({ "player_info " + save_variable(player_info) });
    }
    unguarded( (: rm(basename + ".old") :) );
    unguarded( (: rename(basename+".o", basename+".old") :) );
    unguarded( (: write_file(basename + ".o", implode($(bits), "\n") + "\n") :));
    unguarded ( (: compress_file (basename + ".o") :));     
  } else  {
    write( player + " is already allowed to login from  " + address + ".\n" );
  }
   
  write(player + " is now allowed to login from "+address+".\n");
  return 1;
}

int disable(string player, string address) {
  string *ips, file, *bits;
  int i;
  
  if(!PLAYER_HANDLER->test_user(player))
    return notify_fail("No such user " + player + ".\n");
  
  /* Restore them... */
  basename = "/save/players/" + player[0..0] + "/" + player;
  unguarded ( (: uncompress_file (basename + ".o.gz") :));     
  file = unguarded( (: read_file(basename + ".o") :));
  bits = explode(file, "\n");
  
  for (i = 0; i < sizeof(bits); i++) {
    if (bits[i][0..strlen("player_info")-1] == "player_info") {
      player_info = restore_variable(bits[i][strlen("player_info") + 1..]);
      break;
    }
  }

  ips = player_info["allowed_ips"];
  if(!ips)
    ips = ({ });
  
  if ( member_array(address, ips ) != -1 )  {
    ips -= ({ address });
    player_info["allowed_ips"] = ips;

    if (i < sizeof(bits)) {
      bits[i] = "player_info " + save_variable(player_info);
    } else {
      bits += ({ "player_info " + save_variable(player_info) });
    }
    unguarded( (: rm(basename + ".old") :) );
    unguarded( (: rename(basename+".o", basename+".old") :) );
    unguarded( (: write_file(basename + ".o", implode($(bits), "\n") + "\n") :));
    unguarded ( (: compress_file (basename + ".o") :));     
  } else  {
    write( player + " is not already allowed to login from  " +address+ ".\n");
  }
  
  write(player + " is now not allowed to login from "+address+".\n");
  return 1;
}

mixed *query_patterns() {
  return ({ "enable <word'player'> <string'address'>",
              (: enable($4[0], $4[1]) :),
              "disable <word'player'> <string'address'>",
              (: disable($4[0], $4[1]) :),
              "<word'player'>", (: cmd($4[0]) :), });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/lord/authorise.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/lord/mkdirect_or.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/lord/mkdirect_or.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627202   Available: 13574556
Inodes: Total: 5242880    Free: 4960133
744 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/lord/mkdirect_or.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627202   Available: 13574556
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: mkdirect_or.c,v 1.2 2003/03/21 02:02:33 ceres Exp $
 * 
*/
#include <parser.h>
#include <player_handler.h>

inherit "/cmds/base";


/*
 * This will add a director.
 */
mixed cmd(string creator) {
  seteuid("Root");
  
  if ( !PLAYER_HANDLER->test_user( creator ) ||
       !"/secure/master"->query_trustee( previous_object( -1 ) ) )
    return notify_fail("You must be a trustee to add a director.\n");

  if("/secure/master"->add_director(creator)) {
    write(creator + " promoted to directorship.\n");
    return 1;
  } else
    return notify_fail("Call to add_director failed.\n");
} /* cmd() */

mixed *query_patterns() {
  return ({ "<string>", (: cmd($4[0]) :), });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/lord/mkdirect_or.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/lord/resetpw.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/lord/resetpw.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627202   Available: 13574556
Inodes: Total: 5242880    Free: 4960133
3238 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/lord/resetpw.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627202   Available: 13574556
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: resetpw.c,v 1.7 2003/03/25 20:58:32 ceres Exp $
*/
#include <parser.h>
#include <liaison.h>
#include <player_handler.h>
inherit "/cmds/base";

string basename;
string file;

int do_reset(string player, string newpw) {
  string password;
  string *bits, t1, t2;
  int i;

  if(base_name(previous_object())[0..12] != "/secure/login" &&
     base_name(previous_object())[0..13] != "/secure/nlogin") {
    if (!sizeof(filter(previous_object(-1), (: interactive($1) :)))) {
      unguarded((: write_file, "/log/CHEAT", ctime( time() ) +
                 ": illegal attempt to reset password.\nTrace: " + back_trace()
                 :));
      return 0;
    }
    if (!master()->high_programmer(previous_object(-1)) &&
        !(master()->query_director(previous_object(-1)) &&
          this_player(1)->query_name() == "/d/liaison/master"->query_lord())) {
      unguarded((: write_file, "/log/CHEAT", ctime( time() ) +
                 ": illegal attempt to reset password.\nTrace: " + back_trace()
                 :));
      return 0;
    }
  }

  seteuid("Root");

  /* Restore them... */
  if (PLAYER_HANDLER->test_user(player)) {
    basename = "/save/ramdisk/players/" + player[0..0] + "/" + player;
    if(file_size(basename+".o.gz")>0 ||
       file_size(basename+".o")>0) {
      unguarded((: uncompress_file(basename+".o.gz") :));
    } else {
      basename = "/save/players/" + player[0..0] + "/" + player;
      if(file_size(basename+".o.gz")>0 ||
         file_size(basename + ".o") > 0) {
        unguarded((: uncompress_file(basename+".o.gz") :));
      } else {
        // Player might be set to delete
        basename = "/save/players/delete/" + player;
        if(file_size(basename+".o.gz")>0) {
          unguarded((: uncompress_file(basename+".o.gz") :));
        }
      }
    }
    file = unguarded( (: read_file(basename + ".o") :));
    if(!file) {
      write("Error reading file " + basename + ".\n");
      return notify_fail("Error reading file " + basename +".o\n");
    }
    bits = explode(file, "\n");
    
    for (i = 0; i < sizeof(bits); i++) {
      if (bits[i][0..strlen("password")-1] == "password") {
        t1 = bits[i];
        password = restore_variable(bits[i][strlen("password") + 1..]);
        break;
      }
    }
    password = crypt(newpw, newpw[0..1]);
    t2 = "password " + save_variable(password);

    file = replace(file, t1, t2);
    unguarded( (: rm(basename + ".old") :) );
    unguarded( (: rename(basename+".o", basename+".old") :) );
    unguarded( (: write_file(basename + ".o", file) :));
    unguarded( (: compress_file(basename+".o") :));
    PLAYER_HANDLER->remove_cache_entry(player);
    return 1;

  }
  return 0;
}

/*
 * This will reset a players password.
 */
mixed cmd(string player, string newpw) {
  if(!newpw || newpw == "")
    return notify_fail("Syntax: resetpw <player> <new password>\n");

  if(do_reset(player, newpw)) {
    write(sprintf("Reset password for %s to %s\n", player, newpw));
  } else {
    write("Unable to find player "+player+".\n");
  }
  
  return 1;
} /* cmd() */

mixed *query_patterns() {
  return ({ "<word> <string>", (: cmd($4[0], $4[1]) :),
            });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/lord/resetpw.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/lord/clubs.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/lord/clubs.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627201   Available: 13574555
Inodes: Total: 5242880    Free: 4960133
4504 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/lord/clubs.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627201   Available: 13574555
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: clubs.c,v 1.3 2002/10/26 22:49:30 ceres Exp $
*/

#include <clubs.h>
#include <mail.h>

inherit "/cmds/base";

#define CONTROL_ROOM "/std/room/club_control_room"

// Length of a list entry
#define ELEN 20

nosave string *bad_words = ({ "black", "blood", "cyber", "dark", "penis",
                              "cock", "pussy", "fuck", "shit", "death",
                              "dragon", "fight", "hell", "mage", "pink",
                              "lord", "shadow", "evil", "kill", "slay",
                              "hate", "anti", "bastard" });

private void do_invalid(string extra, int width);
private int do_delete(string extra, string reason, int width);

mixed cmd(string command, string extra, string rest) {

  if (this_player() != this_player(1))
    return 0;

  switch(command) {
  case "invalid":
    do_invalid(extra, this_player()->query_cols());
    break;
  case "delete":
    return do_delete(extra, rest, this_player()->query_cols());
  }
  return 1;
} /* cmd() */

private string club_line(string club, int width, int verbose) {
  string tmp, tmp2, member;
  int clubtype, i;

  clubtype = CLUB_HANDLER->query_club_type(club);
  
  tmp = sprintf("%%^BOLD%%^%%^RED%%^%-9s%%^RESET%%^ %-15s\n", 
                CLUB_ARRAY[clubtype]+":", club);

  if(verbose) {
        tmp+= sprintf(" %%^BOLD%%^Club Name:%%^RESET%%^ %s\n",
                  CLUB_HANDLER->query_club_name(club));
    tmp += sprintf(" %%^BOLD%%^Founder:%%^RESET%%^ %s\n"
                   " %%^BOLD%%^Members:%%^RESET%%^\n",
                   CLUB_HANDLER->query_founder(club));
    i = 0;
    tmp2 = "";
    foreach(member in CLUB_HANDLER->query_members(club)) {
      tmp2 += sprintf("%-15s ", member);
      if((i-1 * ELEN) % (width/ELEN) == 0  && tmp2 != "") {
        tmp += this_player()->fix_string("   " + tmp2 + "\n", width, 10);
        tmp2 = "";
      }
      i++;
    }
  }
  return tmp;
}

private int check_dodgy_name(string club) {
  string s1, s2, lname, word;
  
  lname = lower_case(club);
  lname = replace(lname, ({"'", "", "_", "", " ", ""}) );
  foreach(word in bad_words)
    if ( sscanf( lname, "%s" + word + "%s", s1, s2 ) == 2 )
      return 1;
  return 0;
}

private void do_invalid(string extra, int width) {
  string club, *clubs, tmp, tmp2;
  int ok;
 
  tmp = "";
  tmp2 = "";
  
  clubs = sort_array(CLUB_HANDLER->query_clubs(),
                     (: strcmp($1, $2 ) :) );

  foreach(club in clubs) {
    ok = 1;
    
    switch(CLUB_HANDLER->query_club_type(club)) {
    case CLUB_FAMILY:
      ok = CONTROL_ROOM->is_valid_family_name(club);
      break;
    case CLUB_PERSONAL:
    case CLUB_ELECTED:
      ok = CONTROL_ROOM->is_valid_club_name(club);
      break;
    }

   
    if(!ok)
      tmp += club_line(club, width, extra == "verbose");
    else if(check_dodgy_name(club))
      tmp2 += club_line(club, width, extra == "verbose");

  }

  if(tmp == "")
    write("No invalid clubs.\n");
  else
    this_player()->more_string(tmp, "Clubs", 1);

  if(tmp2 == "")
    write("No dodgy clubs.\n");
  else
    this_player()->more_string("Dodgy names:\n\n" + tmp2, "Clubs", 1);
  
}

private int do_delete(string club, string reason, int width) {
  string founder, members, message, cname;

  if (!"/secure/master"->query_lord(geteuid(previous_object())))
    return notify_fail("You must be a lord to delete a club.");

  if(!club)
    return notify_fail("You must give a club name.\n");

  if(!CLUB_HANDLER->is_club(club))
    return notify_fail(club+" is not a current club.\n");
  
  write("Disbanding: " + club);

  founder = CLUB_HANDLER->query_founder(club);
  members = implode(CLUB_HANDLER->query_members(club), ", ");
  
  cname = CLUB_HANDLER->query_club_name(club);
  
  if(CLUB_HANDLER->disband_club(club)) {
    write(" succeeded.\n");

    message = sprintf("The club %s has been deleted by %s for "
                      "%s\n", cname,
                      this_player()->query_name(),
                      reason);
    MAILER->do_mail_message(founder, this_player()->query_name(),
                            "Your club has been deleted.",
                            members, message);
  } else
    write(" failed.\n");
  
  return 1;
}

mixed *query_patterns() {
  return ({
            "invalid", (: cmd("invalid", "", "") :),
            "invalid <string>", (: cmd("invalid", $4[0], "") :),
            "delete <word> <string>", (: cmd("delete", $4[0], $4[1]) :),
        });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/lord/clubs.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/lord/playerp_roperty.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/lord/playerp_roperty.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627200   Available: 13574554
Inodes: Total: 5242880    Free: 4960133
1591 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/lord/playerp_roperty.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627200   Available: 13574554
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: playerp_roperty.c,v 1.2 2003/03/21 01:57:25 ceres Exp $
 * $Log: playerp_roperty.c,v $
 * Revision 1.2  2003/03/21 01:57:25  ceres
 * Modified to use player handler
 *
 * Revision 1.1  1998/01/06 05:29:21  ceres
 * Initial revision
 * 
*/
#include <parser.h>
#include <player_handler.h>

inherit "/cmds/base";

mapping map_prop;

/*
 * This will add a property to a player.
 */
mixed cmd(string str) {
   string name;
   string value;
   string player;
   mixed *args;

   if (!str) {
      return notify_fail("You must give a property...\n");
   }

   if (sscanf(str, "%s \"%s\" %s", player, name, value) == 3) {
      seteuid("Root");
      /* Restore them... */
      unguarded( (: restore_object("/players/" + $(player[0..0]) +
                                   "/" + $(player)) :));
      if (PLAYER_HANDLER->test_user(player)) {
         args = PARSER->parse_args(value);
         if (args && sizeof(args[0]) > 0) {
            map_prop[name] = args[0][0];
            unguarded( (: write_file("/players/" + $(player[0..0]) +
                               "/" + $(player) + ".o",
                       "map_prop "+save_variable(map_prop)+"\n") :));
            write(sprintf("Added property %s to %s; value = %O\n",
                          name, player, args[0][0]));
         } else {
            write("No useful args...\n");
         }
      } else {
         write("Unable to find player "+player+".\n");
      }
   } else {
      write("Syntax: player_add_property <name> \"<prop>\" <value>\n");
   }

   return 1;
} /* cmd() */
// --- END [/mnt/home2/grok/lib/cmds/lord/playerp_roperty.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/lord/mks_enior.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/lord/mks_enior.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627199   Available: 13574553
Inodes: Total: 5242880    Free: 4960133
914 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/lord/mks_enior.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627199   Available: 13574553
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: mks_enior.c,v 1.2 2003/03/21 01:59:43 ceres Exp $
 * $Log: mks_enior.c,v $
 * Revision 1.2  2003/03/21 01:59:43  ceres
 * Modified to use player handler
 *
 * Revision 1.1  1998/01/06 05:29:21  ceres
 * Initial revision
 * 
*/
#include <parser.h>
#include <player_handler.h>

inherit "/cmds/base";


/*
 * This will make a creator a senior.
 */
mixed cmd(string creator) {
  seteuid("Root");
  
  if ( !PLAYER_HANDLER->test_user( creator ) ||
       !"/secure/master"->query_lord( previous_object( -1 ) ) )
    return notify_fail("You must be a lord to create a senior creator.\n");

  if("/secure/master"->add_senior(creator)) {
    write(creator + " promoted to senior.\n");
    return 1;
  } else
    return notify_fail("Call to add_senior failed.\n");
} /* cmd() */

mixed *query_patterns() {
  return ({ "<string>", (: cmd($4[0]) :), });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/lord/mks_enior.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/lord/invcheck.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/lord/invcheck.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627199   Available: 13574553
Inodes: Total: 5242880    Free: 4960133
721 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/lord/invcheck.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627199   Available: 13574553
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 *  Object ban command.
 *  @author Drakkos 
 *  @started 28/12/2000
 *
 **/
 
#define INV_CHECK "/d/admin/obj/inv_check"

inherit "/cmds/base";

int cmd( string filename, string switch_on) { 
    switch (switch_on) {
      case "ban":
        INV_CHECK->ban_object (filename);
      break;
      case "unban":
        INV_CHECK->unban_object (filename);
      break;
      default:
        tell_object (this_player(), INV_CHECK->list_banned());
      break;
    }
    
    return 1;
} /* cmd() */

mixed *query_patterns() { 
    return ({ "ban <string'filename'>", (: cmd( $4[0], "ban"):),
      "unban <string'filename'>", (: cmd( $4[0], "unban"  ):),
      "list", (: cmd("", "list"):)});
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/lord/invcheck.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/lord/rstats.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/lord/rstats.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627198   Available: 13574552
Inodes: Total: 5242880    Free: 4960133
675 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/lord/rstats.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627198   Available: 13574552
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/cmds/base";

int cmd(string str) {
  mapping stats;
  string obj, file;
  int total, num;
  
  stats = "/secure/master"->query_read_stats();

  if(str) {
    if(!stats[str])
      return notify_fail("No such file\n");
    foreach(file in keys(stats[str])) {
      if(stats[str][file] > 1)
        printf("%-60s %5d\n", file, stats[str][file]);
    }
    return 1;
  }
  printf("%-60s %5s %5s\n", "Object", "Total", "Files");
  foreach(obj in keys(stats)) {
    total = 0;
    num = 0;
    foreach(file in keys(stats[obj])) {
      num++;
      total += stats[obj][file];
    }
    if(total > 200)
      printf("%-60s %5d %5d\n", obj, total, num);
  }
  return 1;
}
// --- END [/mnt/home2/grok/lib/cmds/lord/rstats.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/lord/conv.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/lord/conv.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627198   Available: 13574552
Inodes: Total: 5242880    Free: 4960133
3621 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/lord/conv.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627198   Available: 13574552
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*   -*- LPC -*-   */
/*
 * $Locker:  $
 * $Id: site.c,v 1.8 2000/09/23 05:50:26 pinkfish Exp $
 */
#include <parser.h>
#include <access.h>

inherit "/cmds/base";

private string print_access(string bit, mapping bing, int depth, int cols, string filter);

/*
 * This will ban a site
 */
mixed cmd(string ip, string ident, string level, string reason) {

   seteuid("Root");
   
   if (this_player() != this_player(1))
      return 0;

   switch(level) {
   case "nonew":
      level = "2";
      break;
   case "noacccess":
      level = "3";
      break;
   case "normal":
      level = "1";
      break;
   }
   
   if (!"/secure/bastards.old"->change_access(explode(ip, "."), ident,
                                                             to_int(level), reason)) {
      write("Error changing permissions.\n");
      return 0;
   }
   
   write("Access permisions changed.\n");
   printf("User %s at site %s set to %s for %s\n",
             ident, ip, PERM_NAMES[to_int(level)], reason);
   return 1;
} /* cmd() */

int access(string filter) {
   mixed bing;
   
   seteuid("Root");
   
   if (this_player() != this_player(1))
      return 0;

   bing = (mixed)"/secure/bastards.old"->query_all_access();

   if (!m_sizeof(bing)) {
      notify_fail("No access control defined.\n");
      return 0;
   }
   write("Current access list:\n");
   bing = print_access("", bing, 0, (int)this_player()->query_cols(), filter);
   this_player()->more_string(bing, "site access");
   return 1;
}

private string print_access(string bit, mapping bing, int depth, int cols,
                            string filter) {
   mixed *bits;
   int i;
   string ret;
   string colour;

   ret = "" ;
   if (this_player() != this_player(1)) {
      return 0;
   }
   bits = m_indices(bing);
   if (depth == 4) {
      if(!filter || filter == "" ||
          strsrch(bit, filter) != -1 || strsrch(bits[i], filter) != -1) {
         /* Do the ident printing... */
         for (i=0;i<sizeof(bits);i++) {
            switch (bing[bits[i]][0]) {
            case NO_NEW:
               colour = "%^CYAN%^";
               break;
            case NO_ACCESS:
               colour = "%^YELLOW%^";
               break;
            default :
               colour = "";
               break;
            }
            write(replace(bit, ".*", "")[1..] + "\n");
            "/secure/bastards"->change_access(replace(bit, ".*", "")[1..],
                                              bing[bits[i]][0],
                 "/secure/bastards.old"->query_reason(explode(bit, "."), bits[i]));
         }
      }
    
      return "";
   }
   for (i=0;i<sizeof(bits);i++) {
      ret += print_access(bit+"."+bits[i], bing[bits[i]], depth+1, cols,
                          filter);
   }
   return ret;
} /* print_access() */

int help() {
   return notify_fail(
      "Syntax: site access\n"+
      "            site ban <ip number> <ident> <level> <reason>\n"+
      "                         <level> := normal [1] normal access,\n"+
      "                                          nonew [2] no new players, \n"+
      "                                          noaccess [3] no access.\n");
}
mixed *query_patterns() {
   return ({ "ban <word'address'> <word'ident'> <word'level'> "
                     "<string'reason'>",
                     (: cmd($4[0], $4[1], $4[2], implode($4[3..], "")) :),
                     "access <word'address'>", (: access($4[0]) :),
                     "access", (: access("") :),
                     "", (: help() :),
                     "help", (: help() :)
                     });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/lord/conv.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/bright.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/bright.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627197   Available: 13574551
Inodes: Total: 5242880    Free: 4960133
4868 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/bright.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627197   Available: 13574551
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Id: bright.c,v 1.16 2003/02/21 01:10:27 pinkfish Exp $
 */
inherit "/cmds/base";
#include <dirs.h>

#define THRESHOLDS ({ 10, 30, 200, 300 })

/* No easy way to get this information from the race object as yet.
   Everyone is human, though, so it doesn't yet matter. */

string illumination( int number ) {
   if ( number < 0 ) {
      return "in the darkness that lies beyond darkness";
   }
   if ( number < THRESHOLDS[ 0 ] ) {
      return "in pitch darkness";
   }
   if ( number < THRESHOLDS[ 1 ] ) {
      return "in near darkness";
   }
   if ( number > THRESHOLDS[ 3 ] ) {
      return "too brightly lit to see";
   }
   if ( number > THRESHOLDS[ 2 ] ) {
      return "too brightly lit to see clearly";
   }
   number = ( 100 * ( number - THRESHOLDS[ 1 ] ) ) /
      ( THRESHOLDS[ 2 ] - THRESHOLDS[ 1 ] );
   switch ( number ) {
   case 0 .. 5 :
      return "very poorly lit";
   case 6 .. 10 :
      return "poorly lit";
   case 11 .. 20 :
      return "dimly lit";
   case 21 .. 30 :
      return "quite well lit";
   case 31 .. 40 :
      return "well lit";
   case 41 .. 50 :
      return "brightly lit";
   default :
      return "very brightly lit";
   }
} /* illumination() */

string intensity(int number, object thing) {
   int flag = (thing == this_player());
   
   if (number < 0) {
      return (flag?"are":"is") + " dark beyond darkness"; 
   }
   if (number < THRESHOLDS[0]) {
      return "produce" + (flag?"":"s") + " a faint light";
   }
   if ( number < THRESHOLDS[ 1 ] ) {
      return "produce" + (flag?"":"s") + " a bit of light";
   }
   if ( number > THRESHOLDS[ 3 ] ) {
      return (flag?"are":"is") + " so bright you can't bear to look";
   }
   if ( number > THRESHOLDS[ 2 ] ) {
      return (flag?"are":"is") + " so bright it hurts to look";
   }
   number = ( 100 * ( number - THRESHOLDS[ 1 ] ) ) /
      ( THRESHOLDS[ 2 ] - THRESHOLDS[ 1 ] );
   switch ( number ) {
   case 0 .. 24 :
      return "produce" + (flag?"":"s") + " quite a bit of light";
   case 25 .. 49 :
      return (flag?"are":"is") + " very bright";
   default :
      return (flag?"are":"is") + " extremely bright";
   }
} /* intensity() */

int check_exists(string file) {
  int retval;

  if ( objectp( find_object( file ) ) )
    return 1;
  if (file_size(file+".c") > 0) {
    retval = 1;
  } else {
    retval = 0;
  }
  return retval;
} /* check_exists() */

mixed cmd(object *things) {
   int its_light;
   string results;
   string no_light_results;
   object thing;
   object* no_light;
   int result_light;
   
   results = "";

   if (environment(this_player())->query_light() < THRESHOLDS[0]) {
      results += "Wherever you are, it's ";
   } else {
      results += "$C$"+ environment(this_player())->the_short(1) + " is ";
   }
   results += illumination(environment(this_player())->query_light()) + ".\n";

   if (!things) {
      write(results);
      return 1;
   }

   no_light_results = "";
   no_light = ({ });
   foreach(thing in things) {
      its_light = (int)thing->query_light();
      if (its_light) {
        results += "$C$" + thing->the_short(1) + " " +
          intensity(its_light, thing) + ".\n";
        result_light = 1;
      } else {
         no_light += ({ thing });
      }
   }
   //if (results == "") {
   if (sizeof(no_light) && !result_light) {
      write("$C$" + query_multiple_short(no_light, "one", 0, 1) +
            ((sizeof(no_light) == 1  &&  no_light[0] != this_player()) ?
               " produces" : " produce") + " no light at all.\n");
   }
   write(results);
   //} else {
      //write(results);
   //}
   return 1;
} /* cmd() */

int cmd_exit(string arg) {
   object room;
   string other;

   room = environment(this_player());
   if (room->query_mirror_room()) {
      room = room->query_mirror_room();
   }

   if (LENGTHEN[arg]) {
      arg = LENGTHEN[arg];
   }

   if(!room->query_exit(arg)) {
     arg = (string)this_player()->find_abs(arg);
   }

   if ( room->query_exit( arg ) ) {
      other = room->query_destination(arg);
      if ( check_exists( other )) {
         object door;
         door = room->query_door_control(arg);

         if(room->query_door_open(arg) ||
            door->query_transparent()) {
            write(other->the_short(1) + " is " +
                       illumination(other->query_light()) + ".\n");
            return 1;
         } else {
            add_failed_mess("The exit " + arg + " is not open.\n");
            return 0;
         }
      } else {
         add_failed_mess("The exit " + arg + " does not exist.\n");
         return 0;
      }
   }

   add_failed_mess("Unable to find the exit " + arg + ".\n");
   return 0;
} /* cmd_exit() */


mixed *query_patterns() {
   return ({ "<indirect:object>", (: cmd($1) :),
             "exit <string'exit name'>", (: cmd_exit($4[0]) :),
             "", (: cmd(0) :) });
}
// --- END [/mnt/home2/grok/lib/cmds/player/bright.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/score.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/score.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627196   Available: 13574550
Inodes: Total: 5242880    Free: 4960133
22701 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/score.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627196   Available: 13574550
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: score.c,v 1.35 2003/06/05 01:22:45 pinkfish Exp $
 *
 *
 */

inherit "/cmds/base";

#include <config.h>
#include <library.h>
#include <quest_handler.h>
#ifndef __DISTRIBUTION_LIB__
#include <deity.h>
#endif
#include <top_ten_tables.h>
#include <player_handler.h>
#include <clubs.h>
#include <player.h>
#include <nomic_system.h>
#include <tune.h>
#include <skills.h>
#include <combat.h>

#define essify(x,y) (x > 1  ||  x == 0 ? " " y "s" : " " y)
#define LIMIT 150

int score_quests(object ob, int sorted) {
   string *quests;
   mixed *quest_info;
   
   if ( !this_player()->query_creator() && ob->query_property("dead")) {
      write( "You are just a disembodied spirit.  What use does a wispy thing "
             "like you have for a collection of meaningless numbers?\n" );
      return 1;
   }

   if(this_player()->query_role_playing()) {
     write("Sorry, you're roleplaying.\n");
     return 1;
   }
   quests = LIBRARY->query_quests( ob->query_name() );
   if ( !sizeof( quests ) ) {
      printf( "You have not completed any quests.\n" );
      return 1;
   }
  
   quest_info = map(quests, (: ({ QUEST_HANDLER->query_quest_title($1),
                                  QUEST_HANDLER->query_quest_story($1) }) :));
   if (sorted) { 
      quest_info = sort_array(quest_info, (: strcmp($1[0], $2[0]) :));
   }
   write( "$P$Quests$P$You have completed the following quests:\n"+
         implode( map_array( map_array( quest_info, (: "     \""+
         $1[0] +"\", in which you "+
         replace( $1[1],
         "was", "were" ) :) ), (: sprintf( $1[ 0 .. 24 ] +"%*-=s",
         $(ob)->query_cols() - 30, $1[ 25 .. ] ) :) ), ",\n" ) +".\n" );
   /* Wow.  That is impressive. --Presto */

   return 1;
} /* score_quests() */


int query_verbose(object ob, string verbose)  {
   if (!verbose) {
      return ob->query_verbose("score");
   }
   if (verbose == "verbose") {
      return 1;
   }
   return 0;
} /* query_verbose() */


int score_stats(object ob, string verbose)  {
   string word;
   int stat;
   string ret;
   
   if ( !this_player()->query_creator() && ob->query_property("dead")) {
     write( "You are just a disembodied spirit.  What use does a wispy thing "
            "like you have for a collection of meaningless numbers?\n" );
     return 1;
   }
   
   if(this_player()->query_role_playing()) {
     ret = "";
     if(stat = (this_player()->query_tmp_str() +
                this_player()->query_bonus_str())) {
       if ( stat > 0 ) {
         ret += "You feel stronger than usual.\n";
       } else {
         ret += "You feel weaker than usual.\n";
       }
     } 
     if ( stat = ( this_player()->query_tmp_int() +
                   this_player()->query_bonus_int() ) ) {
       if ( stat > 0 ) {
         ret += "You feel smarter than normal.\n";
       } else {
         ret += "You feel less smart than normal.\n";
       }
     }
     if ( stat = ( this_player()->query_tmp_con() +
                   this_player()->query_bonus_con() ) ) {
       if ( stat > 0 ) {
         ret += "You feel more healthy than usual.\n";
       } else {
         ret += "You feel a bit sickly.\n";
       }
     }
     if ( stat = ( this_player()->query_tmp_dex() +
                   this_player()->query_bonus_dex() ) ) {
       if ( stat > 0 ) {
         ret += "You feel more nimble than usual.\n";
       } else {
         ret += "You feel more clumsy than you normally do.\n";
       }
     }
     if ( stat = ( this_player()->query_tmp_wis() +
                   this_player()->query_bonus_wis() ) ) {
       if ( stat > 0 ) {
         ret += "You feel mentally attuned.\n";
       } else {
         ret += "You feel a bit vague.\n";
       }
     }
     if ( !strlen( ret ) ) {
       ret += "You feel fine.\n";
     }
     printf( "%s", ret );
   } else {
     word = ( ob->query_weight() / 20 ) +"."+ ( ob->query_weight() % 10 );
     if (query_verbose(ob, verbose))  {
       printf( "%-#*s\n", ob->query_cols(),
               "Constitution ... "+ ob->query_con() +"\n"+
               "Dexterity ...... "+ ob->query_dex() +"\n"+
               "Intelligence ... "+ ob->query_int() +"\n"+
               "Strength ....... "+ ob->query_str() +"\n"+
               "Wisdom ......... "+ ob->query_wis() +"\n"+
               "Height ......... "+ ob->query_height() +" cm\n"+
               "Weight ......... "+ word +"kg\n" );
     } else  {
       printf( "%-#*s\n", ob->query_cols(),
               "Con: "+ ob->query_con() +"\nDex: "+ ob->query_dex() +"\n"+
               "Int: "+ ob->query_int() +"\nStr: "+ ob->query_str() +"\n"+
               "Wis: "+ ob->query_wis() +"\nHgt: "+ ob->query_height() +" cm\n"+
               "Wgt: "+ word +"kg\n" );
     }
   }
   return 1;
} /* score_stats() */

int calc_percent( float x, float y ) {
   return to_int( ( to_float( x ) / to_float( y ) ) * 100 );
} /* calc_percent() */

string find_hp_string( int current, int max ) {
   if ( this_player()->query_property( "dead" ) ) {
      return "you are dead\n";
   }

   switch( calc_percent( current, max ) ) {
   case 90..100: 
      return "you are in perfect health";
   case 70..89: 
      return "you are slightly wounded";
   case 50..69: 
      return "you are moderately wounded";
   case 30..49: 
      return "you are seriously wounded";
   case 15..29: 
      return "you are critically wounded";
   case 6..14: 
      return "you are fatally wounded";
   case 0..5: 
      return "you are near death";
   default: 
      return "you are broken";
   }
} /* find_hp_string() */

string find_gp_string( int current, int max ) {
   if ( this_player()->query_property( "dead" ) ) {
      return "you are dead\n";
   }
   
   switch( calc_percent( current, max ) ) {
   case 90..100: 
      return "you are full of energy";
   case 70..89: 
      return "you are enthusiastic";
   case 50..69: 
      return "you are not quite so full of beans";
   case 30..49: 
      return "you are weary";
   case 15..29: 
      return "you are tired";
   case 6..14: 
      return "you are exhausted";
   case 0..5: 
      return "you are nearly unconscious";
   default: 
      return "you are broken";
   }
} /* find_gp_string() */

int calc_xp_cost( string skill ) {
   int lvl;
   int my_lvl;
   int cost;
   int j;
   int total;
   int total2;
   int num = 1;

   my_lvl = this_player()->query_skill_bonus( skill, 1 );
   lvl = this_player()->query_skill(skill);
   
   cost = DEFAULT_COST;
   if( SKILL_OB->query_skill_cost(skill) > 0 ) {
      cost *= SKILL_OB->query_skill_cost(skill);
   }
   cost *= STD_COST/5;
   total2 = 0;
   total = 0;
 
   if ( !my_lvl ) {
      my_lvl = 1;
   }
   for ( j = 0; j < num; j++) {
      int k;
      
      k = 2 * this_player()->calc_bonus( lvl + j, skill, 1 ) / my_lvl + 1;
      total2 += cost * ( ( lvl + j ) / LEVEL_DIV + 1 ) * k * k / 2;
      /* This stops people taking advantage of two's complement. */
      if ( total > total2 ) {
         num = j;
         break;
      } else {
         total = total2;
      }
   }
   
   if (!total) {
      total = cost;
   }
   
   return total;  
} /* calc_xp_cost() */

string find_xp_string( int current ) {
   string *skills = ({ "magic", "faith", "fighting", "covert", "crafts" });
   int xptotal;
   
   foreach( string skill in skills ) {
      xptotal += calc_xp_cost( skill );
   }
   
   xptotal /= sizeof( skills );

   //tell_creator( find_player( "terano" ), "%s: Current XP is: %d, Avg XP is %d, Ratio is: %d.\n", 
   //              this_player()->query_name(), current, xptotal, calc_percent( current, xptotal ) );  
   
   switch( calc_percent( current, xptotal ) ) {
      //Less than average
   case 0..20: 
      return "you don't think you can learn much at the moment";
   case 21..59: 
      return "by the luck of a coin, you might be able to learn something new";
   case 60..100: 
      return "if you squeezed it, you could gain some insight";
      
      //1 level
   case 101..300: 
      return "you might be able to learn something new, if you found the right teacher";
      
      //3 levels of average
   case 301..400: 
      return "a small amount could be learned with training";
   case 401..800: 
      return "a bit of training might be in order";
   case 801..1200: 
      return "you could very well learn something new from training";
   case 1201..1500: 
      return "you could benefit from training";
   case 1501..2000: 
      return "you feel like training might help";
   case 2001..2500: 
      return "you should consider training your skills";
      
      //25 levels of average
   case 2501..4000: 
      return "your skills could be greatly improved with training";
   default: 
      return "certainly a hearty training session is in order";
   }
}
 
string find_wimpy_string( int wimpy ) {
   if ( wimpy ) {
      return "you will flee when "+ find_hp_string( wimpy, 100 );
   }
   return "you will not flee";
} /* find_wimpy_string() */

string find_surrender_string( int surr ) {
   if ( surr ) {
      return "you will surrender when "+ find_hp_string( surr, 100 );
   }
   return "you will not surrender";
} /* find_surrender_string() */

string find_align_string( object tp ) {
   string ret = "";
   string word = tp->query_deity();
   
   ret = "";
   word = tp->query_deity();
   if ( !tp ) {
      return "";
   }
   ret += "you are ";
   ret += tp->align_string();
   if ( stringp( word ) ) {
      ret += " and in the service of ";
      ret += capitalize( word );
      ret += ", ";
#ifndef __DISTRIBUTION_LIB__
      ret += DEITY->query_title( word );
#endif
   }
   return ret;
} /* find_align_string() */

string find_death_string( int remaining ) {
   if ( !this_player()->query_deaths() ) {
      return "Death has never visited you in a professional capacity";
   }

   switch ( remaining ) {
   case 0..0: 
      return "Death has a special interest in your next appointment";
   case 1..3: 
      return "Death is starting to lose patience with you";
   case 4..7: 
      return "You and Death are on good terms";
   default: 
      return "You have an \"arrangement\" with Death";
   }
} /* find_death_string() */

int score_rp(object me, string verbose) {
  if(query_verbose(me, verbose)) {
    printf( "%s.\n%s and %s.\n%s.\n%s.\n%s.\n%s.\n%s.\n", 
            "You are "+ me->query_cap_name() +" "+me->query_gtitle(),
            capitalize( find_hp_string( me->query_hp(), me->query_max_hp() ) ),
            find_gp_string( me->query_gp(), me->query_max_gp() ),
            capitalize( find_xp_string( me->query_xp() ) ),
            capitalize( find_align_string( me ) ), 
            capitalize( find_wimpy_string( me->query_wimpy() ) ),
            //find_surrender_string( me->query_surrender() ),
            "You are "+ me->burden_string() + " and " +
               this_player()->query_temp_str(),
            find_death_string( me->query_max_deaths() - me->query_deaths() ) );
  } else {
    printf( "%s and %s.\n%s.\n", 
            capitalize( find_hp_string( me->query_hp(), me->query_max_hp() ) ),
            find_gp_string( me->query_gp(), me->query_max_gp() ),
            capitalize( find_xp_string( me->query_xp() ) ) );
  }
  return 1;
}

int score_burden(object me, string verbose) {
  write( sprintf("You are %s (%d%%).\n", me->burden_string(),
          me->query_burden()));
  return 1;
}

int score_normal(object ob, string verbose)  {
   string word;
   string guild_ob;
   string area;
   string* magistrates;
   string* citizens;
   int age, temp1, temp2, temp3, temp4;
   int no_title;

   if ( !this_player()->query_creator() && ob->query_property("dead")) {
      write( "You are just a disembodied spirit.  What use does a wispy thing "
             "like you have for a collection of meaningless numbers?\n" );
      return 1;
   }

   if(ob->query_role_playing())
     return score_rp(ob, verbose);
   
   if (query_verbose(ob, verbose))  {
      guild_ob = ob->query_guild_ob();
      if (!guild_ob) {
         guild_ob = "/std/guilds/warrior";
         no_title = 1;
      }
      temp1 = ob->query_hp();
      temp2 = ob->query_gp();
      temp3 = (int)LIBRARY->query_quest_points( ob->query_name() );
      temp4 = ob->query_sp();

      printf( "%-=*s", ob->query_cols(), "You have " +
            temp1 + " (" + ob->query_max_hp() + ") hit" +
            essify(temp1, "point") + ", " +
            temp2 + " (" + ob->query_max_gp() + ") guild" +
            essify(temp2, "point") + ", " +
            temp3 + " (" + (int)QUEST_HANDLER->query_total_qp() + ") quest" +
            essify(temp3, "point") + " and " +
            temp4 + " (" + ob->query_max_sp() + ") social" +
            essify( temp4, "point") + ".\n" );
      if ( guild_ob && find_object( guild_ob ) )  {
         printf( "%-=*s", ob->query_cols(), "Your current experience is " +
               ob->query_xp() + " and you are level " +
               (int)ob->query_level() + " in the " +
               (no_title?"Adventurers' Guild":guild_ob->query_short()) +
               ((ob->query_guild_ob() == "/std/guilds/thief" &&
               !(ob->query_guild_data() == 0)) ?
               ", specialised as a " + ob->query_guild_data() : "") +
               "; your overall rating is " + (int)TOP_TEN_HANDLER->
               calculate_rating( ob ) + ".\n" );
      }  else  {
         printf( "%-=*s", ob->query_cols(), "Your current experience is " +
               ob->query_xp() +".\n" );
      }
      temp1 = ob->query_deaths();
      temp2 = ob->query_max_deaths() - temp1;
      printf( "%-=*s", ob->query_cols(), "You have died " +
            temp1 + essify(temp1, "time") + " and can die " +
            temp2 + essify(temp2, "time") + " before you are completely "
            "dead.\n" );
      if ( ob->query_wimpy() )  {
         printf( "Your wimpy is set to %d%%.\n", ob->query_wimpy() );
      } else  {
         printf( "You are in brave mode.\n" );
      }
#ifdef USE_SURRENDER      
      if (ob->query_surrender())  {
         printf("You will surrender at %d%% of your maximum hit points.\n",
            ob->query_surrender());
      } else  {
         printf("You won't surrender.\n");
      }
#endif      
      printf( "You are %s (%d%%) and %s.\n", ob->burden_string(),
              ob->query_burden(), 
               this_player()->query_temp_str());
      word = ob->query_deity();
#ifndef __DISTRIBUTION_LIB__
      if ( stringp( word ) )  {
         printf( "You are %s, worshipping %s.\n", ob->align_string(),
               capitalize( word ) +", "+ (string)DEITY->query_title( word ) );
      } else  {
         printf( "You are %s, worshipping no god.\n", ob->align_string() );
      }
#endif

      //
      // Put any citizenship memberships in here.
      //
      citizens = ({ });
      magistrates = ({ });
      word = ob->query_name();
      foreach (area in NOMIC_HANDLER->query_citizenship_areas()) {
         if (NOMIC_HANDLER->is_magistrate_of(area, word)) {
            magistrates += ({ area });
         } else if (NOMIC_HANDLER->is_citizen_of(area, word)) {
            citizens += ({ area });
         }
      }
      if (sizeof(magistrates)) {
          printf("You are a magistrate of: " +
                 query_multiple_short(magistrates) + ".\n");
      }
      if (sizeof(citizens)) {
          printf("You are a citizen of: " +
                 query_multiple_short(citizens) + ".\n");
      }

      //
      // Player killer check.
      //
      if ( ob->query_property( PKER ) )  {
         printf( "You are registered as a player killer.\n" );
      }
      if ( m_sizeof( ob->query_hide_invis() ) )  {
         printf( "%-=*s\n", ob->query_cols(), "You are " +
               query_multiple_short( m_indices( ob->query_hide_invis() ) +
                                     ({ }) ) + "." );
      }
      printf( "%-=*s", ob->query_cols(), (string)ob->extra_score() );
      age = -ob->query_time_on();
      temp3 = ob->query_no_logins();
      word = sprintf("You are %s old and have logged in %d %s.\n",
                     query_time_string(age, -1),
                     temp3, (temp3 == 1 ? "time" : "times"));
      printf("%-=*s", ob->query_cols(), word);
   } else {
      printf( "%-=*s", ob->query_cols(), "Hp: " + ob->query_hp() + "(" +
            ob->query_max_hp() + ")  Gp: " + ob->query_gp() + "(" +
            ob->query_max_gp() + ")  Xp: "+ ob->query_xp() + "\n" );
   }
   return 1;
} /* score_normal() */

string create_relationship_text( string relationship, mapping data ) {
    string *relatives;
    int size;
    
    if ( !( relatives = data[ relationship ] ) ) 
        return "";
    
    if ( !size = sizeof( relatives ) )
        return "";
    
    if ( size == 1 ) {
        return capitalize( relatives[0] ) + " is your " +
            relationship;
    }
    
    return query_multiple_short( map( sort_array( relatives, 1 ),
        (: capitalize( $1 ) :) ) ) + " are your " + 
        pluralize( relationship );
} /* create_relationship_text() */


int get_gender( string name ) {
    int gender;
    
    gender = PLAYER_HANDLER->test_gender( name );
    
    if ( gender )
        gender -= 1;
    
    return gender;
} /* get_gender() */


int score_relationships( object ob, int verbose ) {
    string txt, family;
    string *sorted;
    class relationship_data *bing;
    mapping grouped;

    family = ob->query_family_name();

    if ( !family || !CLUB_HANDLER->is_family( family ) ) {
        add_failed_mess( "You're not in a family!\n" );
        return 0;
    }
   
    bing = CLUB_HANDLER->query_relationships( family, ob->query_name() );


    if ( !sizeof( bing ) ) {
        add_failed_mess( "You have no relatives.\n" );
        return 0;
    }

    grouped = unique_mapping( bing, 
        (: CLUB_HANDLER->query_relationship_gender( 
           CLUB_HANDLER->query_opposite_relationship( $1->relationship ),
           get_gender( $1->related_to ) )  :) );

    grouped = map( grouped, (: map( $2, (: $1->related_to :) ) :) );

    sorted = sort_array( keys( grouped ), 1 );

    txt = implode( map( sorted, 
        (: create_relationship_text( $1, $(grouped) ) :) ), ".\n" );

    tell_object( ob, "$P$Relationships$P$" + txt + ".\n" );

    return 1;
} /* score_relationships() */

int score_align( object ob, int verbose ) {
  int upper, lower, middle, align;
  string god, opinion;
  
  if (ob->query_property( "dead" )) {
     write( "You're dead.  Things such as 'good' and 'evil' are no longer of 
      your concern.\n" );
     return 1;
  }

   if( !ob->query_deity() ) {
    write( "You are " + ob->align_string() + ", and not worried about "
        "the approval of any deity at all.\n" );
    }
  else {
    god = ob->query_deity();
    align = ob->query_al();
#ifndef __DISTRIBUTION_LIB__
    lower = DEITY->query_al_lower( god );
    upper = DEITY->query_al_upper( god );
    middle = DEITY->query_al_middle( god );  
    opinion = "pleased with";
  
    if( align <= lower - LIMIT || align >= upper + LIMIT )
      opinion = "very angry with";
    if( ( align < lower && align > lower - LIMIT ) ||
        ( align > upper && align < upper + LIMIT ) )
      opinion = "quite annoyed with";
    if( ( align >= lower && align <= lower + LIMIT ) ||
        ( align <= upper && align >= upper - LIMIT ) )
      opinion = "a little concerned about";
    if( align > middle - ( LIMIT / 2 ) && align < middle + ( LIMIT / 2 ) )
      opinion = "very happy with";
      
    write( "You are " + ob->align_string() + ".  " + capitalize( god ) + 
      " is " + opinion + " you.\n" );
#else
    write( "You are " + ob->align_string() + ", and not worried about "
        "the approval of any deity at all.\n" );
#endif
  }
      
  return 1;
} /* score_align */

int score_fighting( object player, int verbose ) {
    object *attacker_list;
    object *attacker_list_here;
    string ret;
    class tactics tactics;
    
    attacker_list = player->query_attacker_list() - ({ 0 });
    
    ret = ""; 
    if ( attacker_list ) {
       attacker_list_here = filter( attacker_list, (: $1 && living( $1 ) && 
           environment( $1 ) == environment( $(player) ) :) );
   
       if ( !sizeof( attacker_list ) ) {
           ret += "You are not fighting anything!\n";
       } else {

          attacker_list -= attacker_list_here;
      
          if (sizeof(attacker_list_here)) { 
             ret += "$I$5=You are currently fighting " + 
                 query_multiple_short( attacker_list_here ) + " here.\n";
          }
          if (sizeof(attacker_list)) {
             ret += "$I$5=You are currently fighting " + 
                 query_multiple_short( attacker_list ) + " (these are "
                 "people you will auto attack on sight).\n" ;
          }
       }
    }
    tactics = (class tactics) this_player()->query_tactics();

    ret += "$I$0=Your current tactics are:\n"
      "   Attitude       :   "+ tactics->attitude +"\n"
      "   Response       :   "+ tactics->response +"\n"
#ifdef USE_SURRENDER
      "   Mercy          :   "+ (tactics->mercy?tactics->mercy:"none") + "\n"
#endif  
      "   Focus          :   "+
      (tactics->focus_zone?tactics->focus_zone:"none") + "\n"
#ifdef USE_DISTANCE
      "   Target distance:   "+
      (tactics->ideal_distance?tactics->ideal_distance:"none") + "\n"
#endif  
      "   Attack         :   "+ (tactics->attack == "both" ? "both" :
                     (tactics->attack?tactics->attack:"both")) + "\n"
      "   Parry          :   " + (tactics->parry == "both" ? "both" :
                      (tactics->parry?tactics->parry:"both")) + "\n"
      "   Unarmed Parry  :   " + (tactics->parry_unarmed ? "yes" : "no") + "\n";
    write(ret);
    return 1;
} /* score_fighting() */

int score_temperature( object player, int verbose ) {
   return "/cmds/player/temp_erature"->cmd();
} /* score_fighting() */

mixed *query_patterns() {
   return ({
             "quests", (: score_quests(this_player(), 0) :),
             "quests sorted", (: score_quests(this_player(), 1) :),
             "{brief|verbose} stats", (: score_stats(this_player(), $4[0]) :),
             "stats", (: score_stats(this_player(), 0) :),
             "{brief|verbose}", (: score_normal(this_player(), $4[0]) :),
             "relationships", (: score_relationships( this_player(), 0 ) :),
             "temperature", (: score_temperature( this_player(), 0 ) :),
             "burden", (: score_burden( this_player(), 0 ) :),
             "", (: score_normal(this_player(), 0) :),
             "{align|alignment}", (: score_align(this_player(), 0) :),
             "fighting", (: score_fighting( this_player(), 0 ) :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/player/score.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/help.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/help.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627190   Available: 13574544
Inodes: Total: 5242880    Free: 4960133
22646 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/help.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627190   Available: 13574544
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker: pinkfish $
 * $Id: help.c,v 1.43 2003/02/19 08:58:20 ceres Exp pinkfish $
 *
 */

/**
 * Does all the help stuff you know and love.
 *
 * @author Pinkfish
 * @started Tue Nov  4 14:55:39 EST 1997
 */
inherit "/cmds/base";

#include <nroff.h>
#include <soul.h>
#include <log.h>
#include <autodoc.h>
#include <login_handler.h>
#include <player_handler.h>
#include <command.h>

#define SYNONYMS "/doc/SYNONYMS"
#define MATCH_THRESHOLD 55

void do_help(mixed *stuff);
private void list_help(string title, string dir);
private mixed *help_list(string name);
int command_cmd(string name);
int here_cmd();
int object_cmd(object ob);
int spell_cmd(string name, int spell);
int file_help(string name);
void rehash_dirs();
mixed *query_help_on(string name, int creator, int, int);
mixed *create_help_files(string *names, string nroff_dir);
private mapping read_directories(string *directories, int recurse);
private mapping read_synonyms();
private string letter_name(int letter, mixed *things);
private string start_letter( mixed *things );
private string end_letter( mixed *things );
private int query_number_from_string(string name, mixed *things );

private nosave mapping _help_files_player;
private nosave mapping _help_files_creator;
private nosave mapping _help_files_playtester;
private nosave mapping _help_files_lord;
private nosave mapping _synonyms;
private nosave string *_player_dirs;
private nosave string *_creator_dirs;
private nosave string *_lord_dirs;
private nosave string *_playtester_dirs;

void create() {
   ::create();
   /* These dirs will all be depth searched... */
   _player_dirs = ({ "/doc/helpdir/",
                    "/doc/concepts/",
                    "/doc/known_command/",
                    "/doc/room/",
                    "/doc/spells/",
                    "/doc/object/" });
   _creator_dirs = ({"/doc/creator/",
                    "/doc/driver/",
                    "/doc/policy/",
                    "/doc/new/" });
   _playtester_dirs = ({ "/doc/playtesters/" });
   _lord_dirs = ({"/doc/lord/"});
   unguarded((: rehash_dirs() :));
} /* create() */

int *find_match_in_array( string entry, string *items )  {
   int i;
   int j;
   int elength;
   int ilength;
   int this_match;
   int best_match;
   int best_try;

   elength = strlen( entry );
   best_match = this_match = -1;
   for ( i = sizeof( items ) - 1; i >= 0; i--, this_match = 0 )  {
      ilength = strlen( items[ i ] );
      for ( j = 0; j < elength  &&  j < ilength; j++ )
        if ( entry[ j ] == items[ i ][ j ] ||
             entry[ j ] == items[ i ][ j - 1 + ( j == 0 ) ]  ||
             entry[ j ] == items[ i ][ j + 1 - ( j + 1 == ilength ) ] )
          ++this_match;

      this_match = 100 * this_match / ( j == elength ? ilength : elength );

      if ( this_match > best_match )  {
        best_match = this_match;
        best_try = i;
      }
   }

   return ({ best_try, best_match });
} /* find_match_in_array() */

/**
 * This method deals with the case where an entire string matches.
 *
 * @param name the name to look for help on
 * @return 1 if the help was found, 0 if not
 */
int cmd(string name) {
  class command cmd;
   mixed *list;
   string str;
   string suggestion;
   int i;
   int *matches;

   list = help_list(name);

   // find out if they're looking for a synonym
   // eg. colour == colour or plan == finger.
   if (sizeof(list) == 0 &&
       mapp(_synonyms) &&
       _synonyms[name]) {
      list = help_list(_synonyms[name]);
   }

   if (sizeof(list) == 0) {
      if (PLAYER_HANDLER->test_user(name)) {
         add_failed_mess("That is a player, silly.\n");
         return 0;
      }

      // try a match for similarity.
      list = keys(_help_files_player) + ({ "command_list", "concepts"});
      matches = find_match_in_array(name, list);
      if (matches[1] > MATCH_THRESHOLD) {
         suggestion = list[matches[0]];
      } else {
         // try a match for similarity among the synonyms
         list = keys(_synonyms);
         matches = find_match_in_array(name, list);
         if(matches[1] > MATCH_THRESHOLD) {
            suggestion = _synonyms[list[matches[0]]];
         }
      }

      if (!this_player()->query_creator()) {
         log_file("MISSING_HELP", "%s %s looked for help on %s, "
                  "recommended %s\n",
                  ctime(time()), this_player()->query_name(),
                  name, suggestion);
      }

      // No help so lets try some options.
      str = "Could not find any help on '" + name + "'.  ";
      if (!suggestion && this_player()->query_known_command("newbie"))
        str += "Many useful commands are explained in 'help essentials'.  ";
      else if(suggestion)
        str += "Perhaps you are looking for 'help " +suggestion + "'?  ";

      cmd = new(class command, verb : name);

      // Is it a command?
      if((CMD_D->IsGRCommand(name) &&
          this_player()->query_known_command(name)) ||
         (CMD_D->HandleStars(cmd) &&
          sizeof(((mixed *)CMD_D->GetPaths(cmd->verb) &
                  (mixed *)this_player()->GetSearchPath()))) ||
         sizeof(this_player()->query_parse_command_objects(name)))
        str += "The syntax for the command '" + name + "' can be found by "
          "entering 'syntax " + name + "'.  ";

      if (environment(this_player()) &&
          environment(this_player())->help_function())
         str += "Type 'help here' for help on how to use this room.";

      return notify_fail(str + "\n");

   }

   if (sizeof(list) == 1) {
      /* Cool... */
      do_help(list[0]);
      return 1;
   }

   str = "";

   for (i = 0; i < sizeof(list); i++) {
      // str += sprintf("%c) %s\n", ('a' + i), list[i][0]);
      str += sprintf("%s) %s\n", letter_name(i, list), list[i][0]);
   }

   printf("Discworld help found multiple matches, please choose one of:\n"
          "%-*#s\nChoice: ", this_player()->query_cols(), str);
   input_to("help_input", 0, list);
   return 1;
} /* cmd() */

/**
 * The input loop for the help routines.
 *
 * @param str the just inputed string
 * @param list the set of helps to choose from
 */
void help_input(string str, mixed *list) {
   int num;

   str = lower_case(str);
   if (str == "quit" || str == "**" || str == "." || str == "") {
      write("OK, exiting help.\n");
      return ;
   }

   if ( ( num = query_number_from_string( str, list ) ) == -1 ) {
       printf("Incorrect choice, must be between %s and %s.\nChoice: ",
        start_letter( list ), end_letter( list ) );
      input_to("help_input", 0, list);
      return ;
   }

   // num = str[0] - 'a';
   do_help(list[num]);
} /* help_input() */

/** @ignore yes */
void do_help(mixed *stuff) {
   string str;

   str = evaluate(stuff[1]);
   if (!str || !strlen(str)) {
      write("Broken help file!\n");
   } else {
      write("$P$" + stuff[0] + "$P$" + str);
      //this_player()->more_string(str, stuff[0]);
   }
} /* do_help() */

/**
 * This method deals with 'help here'.
 */
int here_cmd() {
  mixed str;
  mixed *list;
  int i;

  str = environment(this_player())->help_function();
  if(pointerp(str))
    list = str;
  else if(str)
    list += ({ ({ environment(this_player())->short(), str }) });
  else {
    write("There is no help available for this room.\n");
    return 1;
  }

  if (sizeof(list) == 1) {
    /* Cool... */
    do_help(list[0]);
    return 1;
  }

  str = "";

  for (i = 0; i < sizeof(list); i++) {
    str += sprintf("%s) %s\n", letter_name(i, list), list[i][0]);
  }

  printf("Discworld help found multiple matches, please choose one of:\n"
         "%-*#s\nChoice: ", this_player()->query_cols(), str);
  input_to("help_input", 0, list);
  return 1;
}

/**
 * This method deals with 'help here'.
 */
int object_cmd(object ob) {
  mixed str;
  mixed *list;
  int i;

  str = ob->help_function();
  if(pointerp(str))
    list = str;
  else if(str)
    list += ({ ({ environment(this_player())->short(), str }) });
  else {
    add_failed_mess("There is no help available for $I.\n", ({ob}));
    return -1;
  }

  if (sizeof(list) == 1) {
    /* Cool... */
    do_help(list[0]);
    return 1;
  }

  str = "";

  for (i = 0; i < sizeof(list); i++) {
    str += sprintf("%s) %s\n", letter_name(i, list), list[i][0]);
  }

  printf("Discworld help found multiple matches, please choose one of:\n"
         "%-*#s\nChoice: ", this_player()->query_cols(), str);
  input_to("help_input", 0, list);
  return 1;
}

/**
 * This method deals with the case where a command pattern was matched.
 *
 * @param name the command to get help on
 * @return 0 if the command does not exist, 1 if it does exist
 */
int command_cmd(string name) {
   mixed help;

   help = this_player()->help_command(name);
   if (!help) {
      notify_fail("No such command as '" + name + "'.\n");
      return 0;
   } else {
      if (functionp(help)) {
         help = evaluate(help);
      }
      write("$P$" + name + "$P$P" + help);
      return 1;
   }
} /* command_cmd() */

/**
 * This method deals with the case where a soul pattern was matched.
 *
 * @param name the soul to get help on
 * @return 0 if the soul does not exist, 1 if it does exist
 */
int soul_cmd(string name) {
   string help;

   help = SOUL_OBJECT->help_string(name);
   if (!help) {
      notify_fail("No such soul as '" + name + "'.\n");
      return 0;
   } else {
      write("$P$" + name + "$P$P" + help);
      return 1;
   }
} /* soul_cmd() */

/**
 * This method deals with the case where a ritual or spell pattern was matched.
 *
 * @param name the ritual or spell to get help on
 * @param spell 0 if it is a spell, 1 if it is a ritual
 * @return 0 if the ritual or spell does not exist, 1 if it does exist
 */
int spell_cmd(string name, int spell) {
   mixed help;

   help = this_player()->help_spell(name);
   if (!help) {
      notify_fail("No such spell as '" + name + "'.\n");
      return 0;
   } else {
      if (functionp(help)) {
         this_player()->move_string(evaluate(help), name);
      } else {
         write("$P$" + name + "$P$P" + help);
      }
      return 1;
   }
} /* spell_cmd() */

/**
 * This method gives the list of commands currently available.
 *
 * @return always returns 1
 */
int command_list_cmd() {
   list_help("Command list, try 'help concepts' for a list of concepts.",
       "/doc/helpdir/");
   return 1;
} /* command_list_cmd() */

/**
 * This method gives the list of concepts currently available.
 *
 * @return always returns 1
 */
int concepts_list_cmd() {
   list_help("Concepts list, try 'help command_list' for a list of commands.",
       "/doc/concepts/");
   return 1;
} /* concepts_list_cmd() */

/**
 * This method traps the error log stuff for some reason.
 *
 * @return always returns 0
 */
int error_log_cmd() {
   notify_fail("Unable to get help on '" + ERROR_LOG + "'.\n");
   return 0;
} /* error_log_cmd() */

/*
 * Print all the names of all the files in a dir...
 */
private void list_help(string title, string dir) {
   string *files;

   files = get_dir(dir + "*") - ({ ".", "..", "ERROR_REPORTS", "RCS", "old" });
   write("$P$Help$P$" + sprintf("%s\n%-#*s\n", title,
                                     (int)this_player()->query_cols(),
                                     implode(files, "\n")));
} /* list_help() */

/*
 * Returns a list of possible help files...
 */
/*private */ mixed *help_list(string name) {
   string* stuff;
   mixed str;
   object* fluff;
   object blue;

   stuff = query_help_on(name, this_player()->query_creator(),
                         this_player()->query_lord(),
                         this_player()->query_playtester());

   if (name == "room" || name == "here") {
      str = environment(this_player())->help_function();
      if (pointerp(str)) {
         stuff += str;
      } else if (str) {
         stuff += ({ ({ environment(this_player())->short(),
                        str }) });
      } else {
         add_failed_mess("There is no help available for this room.\n");
         return 0;
      }
   }

   str = this_player()->help_spell(name);
   if (stringp(str)) {
      stuff += ({ ({ name + " (Spell)",
                    (: $(str) :) }) });
   }
   if (functionp(str)) {
      stuff += ({ ({ name + " (Spell)", str }) });
   }

   str = SOUL_OBJECT->help_string(name);
   if (str) {
      stuff += ({ ({ name + " (Soul)",
                    (: $(SOUL_OBJECT)->help_string($(name)) :) }) });
   }

   fluff = filter(match_objects_for_existence(name, ({ this_player(),
                                      environment(this_player()) })),
                    (: $1 && $1->help_function() :));
   if (sizeof(fluff)) {
      foreach (blue in fluff) {
         stuff += blue->help_function();
      }
   }

   return stuff;
} /* help_list() */

/**
 * Gives a letter in the array for a given array position.
 * @param letter the letter number to return.
 * @param things the help list array to look for
 * @return Returns a letter between 'a' and 'z', if things is less
 * than 27 elements. Otherwise, it returns an array between 'aa' and 'zz'.
 */
private string letter_name(int letter, mixed *things) {
   string bing;

   if (sizeof(things) > 26) {
      bing = "aa";
      bing[0] = 'a' + (letter / 26);
      bing[1] = 'a' + (letter % 26);
      return bing;
   }
   bing = "a";
   bing[0] = 'a' + letter;
   return bing;
} /* letter_name() */

/**
 * Returns the first letter in an help list
 * @param things the help list array to look in
 */
private string start_letter( mixed *things ) {
   return letter_name(0, things);
} /* start_letter() */

/**
 * Returns the last letter in an help list
 * @param things the help list array to look in
 */
private string end_letter( mixed *things ) {
   return letter_name(sizeof(things) - 1, things);
} /* end_letter() */

/**
 * This method translates a user inputted help id into an
 * actual array position.
 * @param name the text to look for
 * @param things the array to look in
 * @return an array index, with -1 for a bounds error.
 */
private int query_number_from_string(string name, mixed *things ) {
   int pos;

   if (sizeof(things) > 26) {
      if (strlen(name) != 2) {
         return -1;
      }
      name = lower_case(name);
      if (name[0] < 'a' || name[0] > 'z') {
         return -1;
      }
      if (name[1] < 'a' || name[1] > 'z') {
         return -1;
      }
      pos = (name[0] - 'a') * 26 + name[1] - 'a';
      if (pos >= sizeof(things)) {
         return -1;
      }
      return pos;
   }

   if (strlen(name) != 1) {
      return -1;
   }
   name = lower_case(name);
   if (name[0] < 'a' || name[0] > 'z') {
      return -1;
   }
   pos = name[0] - 'a';
   if (pos >= sizeof(things)) {
      return -1;
   }
   return pos;
} /* query_number_from_string() */

/** @ignore yes */
mixed *query_patterns() {
   return ({ "<string>", (: cmd($4[0]) :),
               "here", (: here_cmd() :),
               "object <indirect:object:me-here'item'>", (: object_cmd($1[0]) :),
               "command <string>", (: command_cmd($4[0]) :),
               "spell <string>", (: spell_cmd($4[0], 0) :),
               "ritual <string>", (: spell_cmd($4[0], 1) :),
               "soul <string>", (: soul_cmd($4[0]) :),
               "command_list", (: command_list_cmd() :),
               "concepts", (: concepts_list_cmd() :),
               //              ERROR_LOG, (: error_log_cmd() :),
               "", (: concepts_list_cmd() :) });
} /* query_patterns() */

/**
 * This goes through and recreates the hash table for the dirs.
 */
void rehash_dirs() {
   _help_files_player = read_directories(_player_dirs, 1);
   _help_files_creator = read_directories(_creator_dirs, 1);
   _help_files_lord = read_directories(_lord_dirs, 1);
   _help_files_playtester = read_directories(_playtester_dirs, 1);
   _synonyms = read_synonyms();
} /* rehash_dirs() */

/**
 * This method rehashes a specific directory.
 * @param dir the directory to rehash
 */
void rehash_specific_dir(string dir) {
   string start;
   mapping ret;
   string name;
   string* files;

   if (dir[<1] != '/') {
      dir += "/";
   }
   start = "/" + implode(explode(dir, "/")[0..1], "/") + "/";
   if (member_array(start, _player_dirs) != -1) {
      ret = read_directories(({ dir }), 0);
      foreach (name, files in ret) {
         if (_help_files_player[name]) {
            _help_files_player[name] &= files;
         } else {
            _help_files_player[name] = files;
         }
      }
   }
   if (member_array(start, _creator_dirs) != -1) {
      ret = read_directories(({ dir }), 0);
      foreach (name, files in ret) {
         if (_help_files_creator[name]) {
            _help_files_creator[name] &= files;
         } else {
            _help_files_creator[name] = files;
         }
      }
   }
   if (member_array(start, _lord_dirs) != -1) {
      ret = read_directories(({ dir }), 0);
      foreach (name, files in ret) {
         if (_help_files_lord[name]) {
            _help_files_lord[name] &= files;
         } else {
            _help_files_lord[name] = files;
         }
      }
   }
   if (member_array(start, _playtester_dirs) != -1) {
      ret = read_directories(({ dir }), 0);
      foreach (name, files in ret) {
         if (_help_files_playtester[name]) {
            _help_files_playtester[name] &= files;
         } else {
            _help_files_playtester[name] = files;
         }
      }
   }
}

private mapping read_synonyms() {
  string *bits, *bits2;
  int i;
  mapping tmp;

  tmp = ([ ]);
  bits = explode(read_file(SYNONYMS), "\n");
  for(i=0; i<sizeof(bits); i++) {
    bits2 = explode(bits[i], " ");
    tmp[bits2[0]] = bits2[1];
  }
  return tmp;
}

/**
 * Reads in the directories and places the results neatly into a mapping.
 *
 * @param directories the directories to recursively read
 * @return a mapping with the locations of the help files
 */
private mapping read_directories(string *directories, int recurse) {
   string *files;
   string fname;
   int i;
   string dir;
   mapping ret;

   ret = ([ ]);
   for (i = 0; i < sizeof(directories); i++) {
     dir = directories[i];
     files = get_dir(dir + "*") - ({ "ERROR_REPORTS" });
     foreach (fname in files) {
       if (file_size( dir + fname) == -2) {
         if (fname != "." &&
             fname != ".." &&
             fname != "old" &&
             fname != "RCS") {
           directories += ({ dir + fname + "/" });
         }
       } else if (fname != "." &&
                  fname != ".." &&
                  fname != "old") {
         if (!ret[fname]) {
           ret[fname] = ({ dir + fname });
         } else {
           ret[fname] += ({ dir + fname });
         }

         /* Turn '_' into spaces... */
         if (strsrch(fname, "_") > 0) {
           fname = replace(fname, "_", " ");
           if (!ret[fname]) {
             ret[fname] = ({ dir + fname });
           } else {
             ret[fname] += ({ dir + fname });
           }
         }
       }
     }
   }
   return ret;
} /* read_directories() */

/**
 * Searches the lists for things which we might have help on.
 * The array which is returned is an array of arrays, each internal
 * array consists of a name and help string.
 *
 * @param name the help to search for
 * @param creator is this a creator searching
 * @param lord is this a lord searching
 * @return an array of arrays
 */
mixed *query_help_on(string name, int creator, int lord, int pt) {
   string *files;
   mapping map;

   files = ({ });
   name = replace_string(name, " ", "_");
   if (_help_files_player[name]) {
      files += create_help_files(_help_files_player[name], NROFF_DIR);
   }

   if (lord || creator || pt) {
     if(_help_files_playtester && _help_files_playtester[name]) {
         files += create_help_files(_help_files_playtester[name], NROFF_DIR);
      }
   }
   if (lord || creator) {
     if(_help_files_creator && _help_files_creator[name]) {
         files += create_help_files(_help_files_creator[name], NROFF_DIR);
      }
      map = AUTODOC_HANDLER->query_help_map();
      if (map && map[name]) {
         files += create_help_files(map[name], NROFF_DIR);
      }
   }
   if (lord) {
     if(_help_files_lord && _help_files_lord[name]) {
         files += create_help_files(_help_files_lord[name], NROFF_DIR);
      }
      map = AUTODOC_HANDLER->query_help_map();
      if (map && map[name]) {
         files += create_help_files(map[name], NROFF_DIR);
      }
  }

   return files;
} /* query_help_on() */

string query_synonym(string name) {
  if(mapp(_synonyms) && _synonyms[name])
    return _synonyms[name];
  return "";
}

/*
 * Makea string from a nroff input...
 */
private string nroff_file(string name, string nroff_dir) {
   string nroff_fn;
   string str;

   nroff_fn = nroff_dir + replace(name, "/", ".");
   str = NROFF_HAND->cat_file(nroff_fn, 1);
   if (!str) {
      NROFF_HAND->create_nroff(name, nroff_fn);
      str = NROFF_HAND->cat_file(nroff_fn, 0);
   }
   return str;
} /* nroff_file() */

/**
 * This method nips through the list of names doing the nroff stuff.
 * The array which is returned is an array of arrays, each internal
 * array consists of a name and help string.
 *
 * @param names the array of names to process
 * @param nroff_dir the nroff directory to use for the output
 * @return an array of arrays
 */
mixed *create_help_files(string *names, string nroff_dir) {
   int i;
   mixed *ret;
   string *bits;

   ret = ({ });
   for (i = 0; i < sizeof(names); i++) {
      bits = explode(names[i], "/");
      ret += ({ ({ bits[<1] + " (" +
                   names[i] + ")",
                   (: nroff_file($(names[i]), $(nroff_dir)) :) }) });
   }
   return ret;
} /* create_help_files() */

/**
 * This method returns the mapping of all the player help files.
 * @return the mapping of player help files
 */
mapping query_help_files_player() { return _help_files_player; }
/**
 * This method returns the mapping of all the creator help files.
 * @return the mapping of creator help files
 */
mapping query_help_files_creator() { return _help_files_creator; }

/** @ignore yes */
mixed *stats() {
  mapping map;

  map = AUTODOC_HANDLER->query_help_map();
  return ({
      ({ "player help files", sizeof( keys(_help_files_player) ) }),
      ({ "creator help files", sizeof( keys(_help_files_creator) ) }),
        ({ "autodoc help map", sizeof(keys(map)) }) ,
          });
} /* stats() */

/** @ignore yes
 * Prevent this command being cleaned up because it takes a long time
 * to initialise.
 */
int clean_up() {
  return 0;
}

/** Really make sure it cannot be unloaded. */
void dest_me() {
}
// --- END [/mnt/home2/grok/lib/cmds/player/help.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/inv_entory.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/inv_entory.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627184   Available: 13574538
Inodes: Total: 5242880    Free: 4960133
1389 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/inv_entory.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627184   Available: 13574538
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: inv_entory.c,v 1.4 2001/03/11 00:17:11 ceres Exp $
 * $Log: inv_entory.c,v $
 * Revision 1.4  2001/03/11 00:17:11  ceres
 * Moved burden to the start of the inventory.
 *
 * Revision 1.3  2001/03/09 22:22:40  pinkfish
 * Add in a burden message.
 *
 * Revision 1.2  1998/04/14 02:44:58  pinkfish
 * Changed to use add_command.
 *
 * Revision 1.1  1998/01/06 05:29:43  ceres
 * Initial revision
 * 
*/
inherit "/cmds/base";

mixed cmd()
{
   if (this_player()->query_property("dead")) {
      object *obs;

      write("You are just a disembodied spirit.  "
            "You have mist; what else do you want?\n");
      obs = all_inventory(this_player());
      obs = filter_array(obs, (: $1->query_property("dead usable") :));
      if (sizeof(obs)) {
         write("Hang on!  You appear to have " +
               query_multiple_short(obs) + ".  Amazing.\n");
      }
      return 1;
   }
   write(sprintf("You are %s by:\n", this_player()->burden_string()) + 
	 this_player()->query_living_contents(1));

   if (this_player()->query_auto_loading()) {
      write("\n%^YELLOW%^Please note that your inventory is still being "
            "generated.%^RESET%^\n");
   }
   return 1;
}                               /* cmd() */

mixed *query_patterns()
{
   return ({ "", (: cmd() :) });
}                               /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/player/inv_entory.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/removeg_roup.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/removeg_roup.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627184   Available: 13574538
Inodes: Total: 5242880    Free: 4960133
2142 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/removeg_roup.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627184   Available: 13574538
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: removeg_roup.c,v 1.1 2000/06/17 06:48:19 pinkfish Exp $
 * 
 */
inherit "cmds/base";

#define TEAM_HANDLER "/obj/handlers/team"

int do_leave(string group, object member);

mixed cmd(string str) {
  string group;
  object player, *members, member;
  
  notify_fail("Syntax: removegroup <member>\n");

  player = find_player(str);

  if(!(group = TEAM_HANDLER->query_group(this_player())))
    return notify_fail("You are not a member of a group.\n");

  if(TEAM_HANDLER->query_owner(group) != player)
    return notify_fail("Sorry, you are not the leader of " + group + ".\n");
  
  if(member_array(player, TEAM_HANDLER->query_members(group)) == -1)
    return notify_fail("Sorry, " + str + " is not a member of " + group +
                       ".\n");

  members = TEAM_HANDLER->query_members( group );
  if ( !members) {
    TEAM_HANDLER->leave_group(group, this_player());
    TEAM_HANDLER->end_group( group );
    write( "Somehow your group has no members.  "
           "Your group has been ended.  "
           "I hope this is okay.\n" );
    return 1;
  } else if(!(TEAM_HANDLER->query_owner(group))) {
    TEAM_HANDLER->leave_group( group, member );
    TEAM_HANDLER->end_group( group );
    write( "Somehow your group has no leader.  "
           "Your group has been ended.  "
           "I hope this is okay.\n" );
    return 1;
  }
  
  foreach( member in members ) {
    if ( !member )
      continue;
    tell_object(member, player->short()+" is removed from the "
                "group.\n");
  }
  
  do_leave(group, player);
  return 1;
}

int do_leave(string group, object member) {
   object person;
   
   if(!TEAM_HANDLER->leave_group(group, member))
      return notify_fail("Ack, something went wrong.\n");

   if ( !sizeof( (object *)TEAM_HANDLER->query_members( group ) ) )
      return 0;
  
   foreach(person in TEAM_HANDLER->query_members(group)) {
      if(person) {
         member->remove_protector(person);
         person->remove_protector(member);
         member->remove_follower(person);
         person->remove_follower(member);
      }
   }
   return 1;
}
// --- END [/mnt/home2/grok/lib/cmds/player/removeg_roup.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/relationship.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/relationship.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627183   Available: 13574537
Inodes: Total: 5242880    Free: 4960133
11030 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/relationship.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627183   Available: 13574537
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* -*- LPC -*- */
/**
 * This command is used by the player to create a relationship with another
 * person into the current family they are in.
 * @author Pinkfish
 * @started November 1st 1998
 */
#include <clubs.h>
inherit "/cmds/base";


string show_relationship(object from, object to, string rel, object telling);

/**
 * This method creates a realtionship with someone else.
 */
int do_relationship(string relationship, object *players, int force) {
   object player;
   string family;
   string my_family;
   string their_family;
   string rel;
   class family_response_data frog;
   int ok;
   string *relations;

   my_family = this_player()->query_family_name();
   if (!my_family) {
      add_failed_mess("You must be in a family to form a relationship with "
                      "someone.\n");
      return 0;
   }

   my_family = CLUB_HANDLER->query_club_name(my_family);

   rel = CLUB_HANDLER->query_ungendered_relationship(relationship);
   if (!rel) {
      add_failed_mess("The relationship '" + relationship + 
                      "' is not valid.  The valid relationships are " +
                      query_multiple_short(
                              CLUB_HANDLER->query_all_relationships()) + 
                      ".\n");
      return 0;
   }
   relationship = rel;

   foreach (player in players) {
      // Make sure the family name is correct.
      player->check_family_name();
      their_family = player->query_family_name();
      relations = CLUB_HANDLER->query_relationships_to(my_family,
                                                      this_player()->query_name(),
                                                      player->query_name());

      if (!their_family && sizeof(relations)) {
         //
         // They lost their family somehow, so zap all these
         // relationships.
         //
         foreach (rel in relations) {
            CLUB_HANDLER->remove_relationship(my_family,
                                              this_player()->query_name(),
                                              their_family,
                                              player->query_name(),
                                              rel);
         }
      }

      rel = CLUB_HANDLER->query_relationship_gender(relationship,
                                                    player->query_female());
      if (sizeof(relations)) {
         if (member_array(relationship, relations) != -1 &&
             force) {
            family = my_family;
	    tell_object(player, this_player()->the_short() + 
                             " offers to use "
                             "the relationship of " + rel + " with "
                             "you in the family " + my_family + " to allow "
                             "you to join the family.  WARNING! "
                             "This "
                             "will cause you to join the family.\n" +
                             "This will setup the relationships of: " +
                             show_relationship(this_player(), player,
                                               relationship, player) + "\n" +
                             "To accept the offer type:\n"
                             "accept relationship from " +
                             this_player()->query_name() + " to " +
                             my_family + " as " + rel + "\n");
            frog = new(class family_response_data);
            frog->family = family;
            frog->relationship = relationship;
            player->add_respond_command(CLUB_FAMILY_RESPOND_TYPE, 
                                        this_player(),
                                        frog);
            ok++; 
            add_succeeded_mess(({
                               "$N offer$s to setup a relationship of " +
                               rel + " with $I.\nThis will setup the "
                               "relationships of: " +
                               show_relationship(this_player(), player,
                                                 relationship, this_player()) + "\n",
                               "$N offer$s to setup a relationship of " +
                               rel + " with $I.\n",
                                }),
                               ({ player }));
         } else {
            add_failed_mess("You are already related to $I, you can only force "
                            "them to join your family.\n", ({ player }) ); 
         }
      } else if (player->query_family_name()) {
         if (!force) {
	    // Ok, they are already in a family.
	    if (!CLUB_HANDLER->is_valid_interfamily_relationship(relationship)) {
	       add_failed_mess("$I is in a family already and '" + 
                               rel +
			       "' is not a valid interfamily relationship.\n");
	       continue;
	    }
	    family = player->query_family_name();
	    tell_object(player, this_player()->the_short() + 
                             " offers to setup "
                             "a relationship of " + rel + " with "
                             "you.  This will not cause you to change the "
                             "family.\n" +
                             "This will setup the relationships of: " +
                             show_relationship(this_player(), player,
                                               relationship, player) + "\n" +
                             "To accept the offer type:\n"
                             "accept relationship from " +
                             this_player()->query_name() + 
                             " as " + rel + "\n");
	 } else {
            if (!CLUB_HANDLER->is_valid_join_family_relationship(relationship)) {
               add_failed_mess("$I is in a family already and the "
                               "relationship '" + rel +
                               "' is not valid to cause them to join "
                               "your family.\n");
               continue;
            }
            family = my_family;
	    tell_object(player, this_player()->the_short() + 
                             " offers to setup "
                             "a relationship of " + rel + " with "
                             "you in the family " + my_family + ".  WARNING! "
                             "This "
                             "will cause you to join the family.\n" +
                             "This will setup the relationships of: " +
                             show_relationship(this_player(), player,
                                               relationship, player) + "\n" +
                             "To accept the offer type:\n"
                             "accept relationship from " +
                             this_player()->query_name() + " to " +
                             my_family + " as " + rel + "\n");
	 }
         frog = new(class family_response_data);
         frog->family = family;
         frog->relationship = relationship;
         player->add_respond_command(CLUB_FAMILY_RESPOND_TYPE, 
                                     this_player(),
                                     frog);
         ok++; 
         add_succeeded_mess(({
                            "$N offer$s to setup a relationship of " +
                            rel + " with $I.\nThis will setup the "
                            "relationships of: " +
                            show_relationship(this_player(), player,
                                              relationship, this_player()) + "\n",
                            "$N offer$s to setup a relationship of " +
                            rel + " with $I.\n",
                             }),
                            ({ player }));
      } else {
         tell_object(player, this_player()->the_short() + " offers to setup "
                             "a relationship of " + rel + " with "
                             "you in the family " + my_family + ".  WARNING! "
                             "This "
                             "will cause you to join the family.\n" +
                             "This will setup the relationships of: " +
                             show_relationship(this_player(), player,
                                               relationship, player) + "\n" +
                             "To accept the offer type:\n"
                             "accept relationship from " +
                             this_player()->query_name() + " to " +
                             my_family + " as " + rel + "\n");
         frog = new(class family_response_data);
         frog->family = my_family;
         frog->relationship = relationship;
         player->add_respond_command(CLUB_FAMILY_RESPOND_TYPE, 
                                     this_player(), 
                                     frog);
         ok++;
         add_succeeded_mess(({
                            "$N offer$s to setup a relationship of " +
                            rel + " with $I.\nThis will setup the "
                            "relationships of: " +
                            show_relationship(this_player(), player,
                                              relationship, this_player()) + "\n",
                            "$N offer$s to setup a relationship of " +
                            rel + " with $I.\n",
                             }),
                            ({ player }));
      }
   }
   return ok;
} /* do_relationship() */

string show_relationship(object from, object to, string rel, object telling) {
   string opp;
   string from_arg;
   string to_arg;

   opp = CLUB_HANDLER->query_opposite_relationship(rel);
   if (from == telling) {
      from_arg = "are";
   } else {
      from_arg = "is";
   }
   if (to == telling) {
      to_arg = "are";
   } else {
      to_arg = "is";
   }
   return from->the_short() + " " + from_arg + " the " + 
          CLUB_HANDLER->query_relationship_gender(rel, from->query_female()) +
          " of " + to->the_short() + " and " +
          to->the_short() + " " + to_arg + " the " +
          CLUB_HANDLER->query_relationship_gender(opp, to->query_female()) +
          " of " + from->the_short() + ".";
} /* show_relationship() */

int list_relationships() {
   string *relationships;

   relationships = CLUB_HANDLER->query_all_relationships();
   relationships = map(sort_array(relationships, 1), (: capitalize($1) :));
   printf("The currently allowed relationships are:\n   %-=*s\n",
          this_player()->query_cols() - 4, 
          query_multiple_short(relationships) + ".");
   return 1;
} /* list_relationships() */

mixed *query_patterns() {
   return ({ "<string'relationship'> with <indirect:player:here>",
                (: do_relationship($4[0], $1, 0) :),
             "<string'relationship'> with <indirect:player:here> and join family",
                (: do_relationship($4[0], $1, 1) :),
             "list",
               (: list_relationships() :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/player/relationship.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/locate.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/locate.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627180   Available: 13574534
Inodes: Total: 5242880    Free: 4960133
4220 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/locate.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627180   Available: 13574534
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: locate.c,v 1.21 2003/07/13 09:13:33 pinkfish Exp $
 * 
*/
inherit "/cmds/base";

#define TP this_player()

/**
 * This method zips down inside the container looking for the match.
 */
object *look_in_container(object fluff,
                          string word) {
   object frog;
   object *obs;
   object *things;

   things = match_objects_for_existence(word, ({ fluff }));
   obs = all_inventory(fluff);
   foreach (frog in obs) {
      if (sizeof(all_inventory(frog))) {
         things += look_in_container(frog, word);
      }
   }

   return things;
} /* look_in_container() */

mixed cmd( string word ) {
   int i;
   int base_num;
   string list;
   object thing;
   object *things;
   object *extra_things;

   debug_printf("%s", word);
   if (environment(TP)) {
      switch(TP->check_dark(environment(TP)->query_light())) {
      case -2:
      case -1:
        if (this_player()->query_creator()) {
          write("It is too dark to locate anything, but since you are a cre...\n");
        } else {
          return notify_fail("It's too dark to locate anything.\n");
        }
        break;
      case 1:
      case 2:
        if (this_player()->query_creator()) {
          write("It is too bright to locate anything, but since you are a cre...\n");
        } else {
           return notify_fail("It's too bright to locate anything.\n");
        }
        break;
      }
   }

   things = match_objects_for_existence( word, ({ environment( TP ) }) );
   things = filter(things, (: environment($1) == environment(TP) ||
                             environment($1) == TP :));
   extra_things = look_in_container(this_player(), word) - things;


   base_num = sizeof(things);
   
   things += extra_things;

   if ( !sizeof( things ) ) {
      return notify_fail( "There is nothing here matching \""+ word +"\".\n" );
   }

   if ( sizeof( things ) == 1 ) {
     if ( things[0] == TP ) {
       write("You are here! :)\n");
       return 1;
     }

     list = "$C$"+ (string)things[ 0 ]->the_short();
     if ( (object)things[ 0 ]->query_wielded() == TP ) {
       list += " (held in " + query_multiple_short(TP->query_holding_limbs(things[0])) + ")";
     }
     if ( (object)things[ 0 ]->query_worn_by() == TP ) {
       list += " (worn)";
     }
     if ( things[ 0 ]->query_keep() ) {
       list += " (keeping)";
     }
     word = (string)things[ 0 ]->query_full_identifier();
     if ( stringp( word ) ) {
       list += " (\""+ word +"\")";
     }
     if (environment(things[0]) == this_player()) {
       list += (things[0]->group_object() ? " are" : " is") +
         " in your inventory.\n";
     } else {
       list += (things[0]->group_object() ? " are in " : " is in ");
       list += inside_the_short(environment( things[ 0 ] )) + ".\n";
     }
     write( list );
     return 1;
   }
   
   list = "";
   foreach ( thing in things ) {
      i++;
      if ( thing == TP ) {
         list += "You (" + i + ") are here :)\n";
         continue;
      }
      if (i > 30) {
         list += "Truncated list!  Cannot list more than 30 items.\n";
         break;
      }
      list += "$C$" + (string)thing->the_short();
      if (i <= base_num) {
         list += " (" + i + ")";
      }
      if ( (object)thing->query_wielded() == TP ) {
         list += " (held in " + query_multiple_short(TP->query_holding_limbs(thing)) + ")";
         //list += " (wielded)";
      }
      if ( (object)thing->query_worn_by() == TP ) {
         list += " (worn)";
      }
      if ( thing->query_keep() ) {
         list += " (keeping)";
      }
      word = (string)thing->query_full_identifier();
      if ( stringp( word ) ) {
         list += " (\""+ word +"\")";
      }
      if (environment(thing) == this_player()) {
         list += (thing->group_object() ? " are " : " is ") +
           "in your inventory.\n";
      } else {
        list += (thing->group_object() ? " are in " : " is in ");
         list += inside_the_short(environment( thing )) + ".\n";
      }
   }
   write( "$P$Locate$P$"+ list );
   return 1;
} /* cmd() */

mixed *query_patterns() {
   return ({ "<string'object name'>", (: cmd($4[0]) :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/player/locate.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/accept.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/accept.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627179   Available: 13574533
Inodes: Total: 5242880    Free: 4960133
8379 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/accept.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627179   Available: 13574533
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/**
 * This handles both the surrender and club accepting stuff.
 * The surrender stuff was done by Sin and the club stuff by Pinkfish.
 */

#include <clubs.h>
#include <broadcaster.h>

inherit "/cmds/base";

mixed do_surrender(object player) {
  object *victims;

  victims = this_player()->query_surrenderers();
  if (!victims  ||  member_array(player, victims) == -1) {
    add_failed_mess("Sorry, but $I has not offered to surrender to you.\n",
                    ({ player }) );
    return 0;
  }
  this_player()->remove_surrenderer(player);
  player->accepted_surrender(this_player());
  write("Good show!\n");
  return 1;
} /* do_surrender() */

mixed do_club(string club_name, object *players) {
   object ob;
   string club;
   int ok;

   foreach (ob in players) {
      club = this_player()->query_respond_command(CLUB_RESPOND_TYPE, ob);
      if (club) {
         if (lower_case(club) == lower_case(club_name)) {
            // Whooo!  Found the club!  They accept!
            // Check to see if they are already a member, other wise
            // add them.
            if (CLUB_HANDLER->is_member_of(club_name,
                                           this_player()->query_name())) {
               add_failed_mess("You are already a member of '" +
                               CLUB_HANDLER->query_club_name(club_name) +
                               "'.\n");
            } else {
               CLUB_HANDLER->add_member(club_name,
                                        this_player()->query_name());
               add_succeeded_mess("$N join$s '" +
                               CLUB_HANDLER->query_club_name(club_name) +
                               "' with an invite from $I.\n",
                               ({ ob }) );
	       ob->remove_respond_command(CLUB_RESPOND_TYPE, ob);
               ok++;
               all_inventory(this_player())->event_joined_club(this_player(),
                                                               club_name);
            }
         } else {
            add_failed_mess("$I is inviting you to join '" + 
                            CLUB_HANDLER->query_club_name(club) +
                            "' not '" + club_name + "'.\n", ({ ob }));
         }
      } else {
         add_failed_mess("$I is not inviting you to join any clubs.\n",
                         ({ ob }));
      }
   }
   return ok;
} /* do_club() */

int do_family(string family, 
              string relationship,
              object *players) {
   object ob;
   int ok;
   string curr_family;
   class family_response_data frog;

   curr_family = this_player()->query_family_name();
   if (curr_family) {
      curr_family = CLUB_HANDLER->query_club_name(curr_family);
   }

   relationship = CLUB_HANDLER->query_ungendered_relationship(relationship);

   if (!relationship) {
      add_failed_mess("Could not figure out the relationship.\n");
      return 0;
   }

   foreach (ob in players) {
      frog = this_player()->query_respond_command(CLUB_FAMILY_RESPOND_TYPE, 
                                                  ob);
      if (!family) {
         family = frog->family;
      }
      if (frog && frog->family) {
         if (lower_case(frog->family) == lower_case(family)) {
            // Whooo!  Found the family!  They accept the relationship!
  	    if (lower_case(frog->relationship) != lower_case(relationship)) {
               add_failed_mess("You were asked to have the relationship of '" +
                     CLUB_HANDLER->query_relationship_gender(frog->relationship,
                                     this_player()->query_female()) +
                               "', not '" +
                     CLUB_HANDLER->query_relationship_gender(relationship,
                                     this_player()->query_female()) +
                               "' in the family '" +
                               CLUB_HANDLER->query_club_name(frog->family) +
                               "'.\n");
	    } else if (CLUB_HANDLER->is_relationship(frog->family,
                                                     this_player()->query_name(),
                                                     ob->query_name(),
                                                     relationship) &&
                       frog->family == curr_family) {
               add_failed_mess("You have already setup a relationship of '" +
                     CLUB_HANDLER->query_relationship_gender(relationship,
                                     this_player()->query_female()) +
                               "' with $I.\n", ({ ob }) );
            } else {
               if (!CLUB_HANDLER->is_member_of(frog->family,
                                               this_player()->query_name())) {
                  if (frog->family != curr_family &&
                      curr_family) {
                     if (!CLUB_HANDLER->move_family_member(curr_family,
                                                           this_player()->query_name(),
                                                           frog->family)) {
                       add_failed_mess("Unable to move you into the family " +
                                       frog->family + " for some reason.\n");
                       continue;
                     }
                  } else {
                     if (!CLUB_HANDLER->add_member(frog->family,
                                                  this_player()->query_name())){
                       add_failed_mess("Unable to add you into the family " +
                                       frog->family + " for some reason.\n");
                       continue;
                     }
                  }
                  this_player()->set_family_name(frog->family);
               }
	       if (!CLUB_HANDLER->is_relationship(frog->family,
                                                  this_player()->query_name(),
                                                  ob->query_name(),
                                                  relationship)) {
                  if (!CLUB_HANDLER->add_relationship(ob->query_family_name(),
                                                     ob->query_name(),
                                                     frog->family,
                                                     this_player()->query_name(),
                                                     relationship)) {
                     add_failed_mess("Unable to add the relationship to $I for "
                                     "some reason.\n");
                  } else {
                     add_succeeded_mess("$N set$s up a relationship with $I " +
                                        "in '" +
                                        CLUB_HANDLER->query_club_name(frog->family) +
                                        "'.\n",
                                        ({ ob }) );
                     ok++;
                  }
               } else {
                  add_succeeded_mess("$N set$s up a relationship with $I " +
                                     "in '" +
                                     CLUB_HANDLER->query_club_name(frog->family) +
                                     "'.\n",
                                     ({ ob }) );
                  ok++;
               }
               ob->remove_respond_command(CLUB_FAMILY_RESPOND_TYPE, ob);
            }
         } else {
            add_failed_mess("$I is inviting you to a relationship in '" + 
                            CLUB_HANDLER->query_club_name(frog->family) +
                            "' not '" + family + "'.\n", ({ ob }));
         }
      } else {
         add_failed_mess("$I is not inviting you to setup any relationships.\n",
                         ({ ob }));
      }
   }
   return ok;
} /* do_family() */

mixed *query_patterns() {
  return ({ "<indirect:living:here>", (: do_surrender($1[0]) :),
            "invite from <indirect:living:here> to <string'club name'>",
                (: do_club($4[1], $1) :),
            "relationship from <indirect:living:here> to <string'family'> as <string'relationship'>",
                (: do_family($4[1], $4[2], $1) :),
            "relationship from <indirect:living:here> as <string'relationship'>",
	       (: do_family(this_player()->query_family_name(), $4[1], $1) :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/player/accept.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/map.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/map.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627177   Available: 13574531
Inodes: Total: 5242880    Free: 4960133
1273 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/map.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627177   Available: 13574531
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * Print out a cute little map if one exists.
 * @author Pinkfish
 * @started Wed Jul 17 23:51:41 PDT 2002
 */
inherit "/cmds/base";

int do_map() {
   string map;
   int* coords;
   object env;
   string handler;

   env = environment(this_player());
   if (!env)  {
      add_failed_mess("You are somewhere not on any map.\n");
      return 0;
   }

   if (this_player()->query_blinded()) {
      add_failed_mess("You are blind and cannot see.\n");
      return 0;
   }

   switch(this_player()->check_dark(environment(this_player())->query_light()))
   {
   case -2:
   case -1:
     return add_failed_mess("It is too dark to see anything.\n");
   case 2:
   case 1:
     return add_failed_mess("It is too bright to see anything.\n");
   }
   
   coords = env->query_terrain_coords();
   handler = env->query_terrain_handler();
   if (!coords  ||  !handler) {
      add_failed_mess("You can only do this in a terrain.\n");
      return 0;
   }

   map = handler->query_player_map(coords[0], coords[1], coords[2],
                                   env->query_visibility(env));
   if (!map) {
      add_failed_mess("There is no map available here.\n");
      return 0;
   }
   write(map);
   return 1;
}

mixed* query_patterns() {
   return ({ "", (: do_map :) });
}
// --- END [/mnt/home2/grok/lib/cmds/player/map.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/access.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/access.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627176   Available: 13574530
Inodes: Total: 5242880    Free: 4960133
4111 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/access.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627176   Available: 13574530
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: access.c,v 1.3 2003/04/30 19:59:22 ceres Exp $
 * 
 */
#include <drinks.h>
#include <language.h>
#include <player.h>
#include <player_handler.h>

#define TP this_player()

inherit "/cmds/base";

int cmd_list() {
   string *ips;

   ips = TP->query_rhosts();
   if(!ips) {
      ips = ({ });
   }
   if ( !sizeof(ips) )  {
     write( "You are allowed to login from anywhere.\n" );
   } else  {
     ips = sort_array(ips, 1);
     write( "You are currently allowed to login from: " +
            query_multiple_short(ips) + ".\n" );
   }
   return 1;
} /* cmd_list() */

int enable( string str) {
   string *ips;

   if(TP->query_property("access_restricted"))
     return notify_fail("Sorry, you are not allowed to change your "
                        "access list.\n");
   
   ips = TP->query_rhosts();
   if(!ips) {
      ips = ({ });
   }

   if(member_array(str, ips) == -1 )  {
     ips += ({ str });
     TP->set_rhosts(ips);
   } else  {
     write( "You are already allowed to login from  " + str + ".\n" );
   }
   
   write("You are now allowed to login from "+str+".\n");
   return 1;
}


int disable( string str) {
   string *ips;
 
   if(TP->query_property("access_restricted"))
     return notify_fail("Sorry, you are not allowed to change your "
                        "access list.\n");

   ips = TP->query_rhosts();
   if(!ips) {
      ips = ({ });
   }

   if ( member_array( str, ips ) != -1 )  {
     ips -= ({ str });
     if(!sizeof(ips))
       TP->set_rhosts(0);
     else
       TP->set_rhosts(ips);
   } else  {
     write( "You are already not allowed to login from  " + str + ".\n" );
   }
   if(!sizeof(ips))
     write("You are now allowed to login from anywhere.\n");
   else
     write("You are not now allowed to login from "+str+".\n");
   
   return 1;
}

int authorise_for (string name, string address) {
  string fname;
  string file,  *bits;
  string var_name = "player_info ";
  mapping info = ([ ]);
  int i, found = 0;

  if (!this_player()->query_lord()) {
    return notify_fail ("You may not do this.\n");
  }
    
  if (find_player (name)) {
    return notify_fail ("This player is online.\n");
  }
    
  if (!PLAYER_HANDLER->test_user(name)) {
    return notify_fail ("No such player.\n");
  }

  seteuid("Root");
   
  fname = "/save/players/" + name[0..0] + "/" + name;       
  
  uncompress_file (fname+ ".o.gz");
  file = unguarded( (: read_file($(fname)+".o") :));

  if (!file) {
    return notify_fail ("Error reading file.\n");
  }
  
   bits = explode(file, "\n");

   for (i = 0; i < sizeof(bits); i++) {
     if (bits[i][0..strlen(var_name)-1] == var_name) {
       info = restore_variable(bits[i][strlen(var_name)..]);
       found = 1;
       break;
     }
   }
  
  if(!found) {
    return notify_fail ("Cannot find mapping.\n");
  }

  if (address == "reset") {
    info["allowed_ips"] = ({ });
  }
  else if (sizeof (info ["allowed_ips"])) {
    if (member_array (address, info["allowed_ips"]) == -1) {
      info["allowed_ips"] += ({ address });
    }
    
  }
  else {
    info["allowed_ips"] = ({ address });
  }
  
  if (i < sizeof(bits)) {
     bits[i] = var_name + save_variable(info);
   } else {
     bits += ({ var_name + save_variable(info) });
  }

         
  unguarded( (: rm($(fname) + ".old") :) );
   
  unguarded( (: rename($(fname)+".o", $(fname)+".old") :) );
   
  unguarded( (: write_file($(fname) + ".o",
    implode($(bits), "\n") + "\n") :));
  compress_file (fname + ".o");
  unguarded( (: rm($(fname) + ".o") :) );

  PLAYER_HANDLER->remove_cache_entry(name);
  
  tell_object (this_player(), "Access for " + name + " changed.\n");   
  return 1;

  
}

mixed *query_patterns() {
  return ({ "enable <string'address'>", (: enable($4[0]) :),
              "disable <string'address'>", (: disable($4[0]) :),
              "for <string'name'> <string'address'>", 
                (: authorise_for ($4[0], $4[1]) :), 
              "reset for <string'name'>", (: authorise_for ($4[0], 
              "reset") :),
              "", (: cmd_list() :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/player/access.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/colo_urs.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/colo_urs.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627175   Available: 13574529
Inodes: Total: 5242880    Free: 4960133
5265 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/colo_urs.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627175   Available: 13574529
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: colo_urs.c,v 1.11 2002/02/24 03:07:12 ceres Exp $
 * 
 */
#include <colour.h>
#include <clubs.h>
#include <creator.h>
#include <newbiehelpers.h>

inherit "cmds/base";

private string* _colours;

void create() {
  ::create();
  _colours = ({
   "BOLD",
   "FLASH",
   "BLACK",
   "RED",
   "BLUE",
   "CYAN",
   "MAGENTA",
   "ORANGE",
   "YELLOW",
   "GREEN",
   "WHITE",
   "B_RED",
   "B_ORANGE",
   "B_YELLOW",
   "B_BLACK",
   "B_CYAN",
   "B_WHITE",
   "B_GREEN",
   "B_MAGENTA" });
} /* create() */

int is_valid_colour(string name) {
   if (member_array(name, _colours) != -1) {
      return 1;
   }
   return 0;
} /* is_valid_colour() */

int show_allowed_colours() {
   write("The allowed colour codes are " +
         query_multiple_short(map(_colours, (: lower_case($1) :)), 0, 0, 1) +
         ".\n");
   return 1;
} /* show_allowed_colours() */


string* query_colour_list(int inform) {
  string* colour_list;
  string* clubs;
  string bing;

  switch (inform) {
  case 0:
    colour_list = USER_COLOUR_LIST;
    if( NEWBIEHELPERS_HANDLER->query_can_chat(this_player()) ) {
      colour_list += ({"newbiehelpers"});
    }
    if(this_player()->query_creator()) {
      colour_list += this_player()->channel_list();
    }
    break;
  case 1 :
    colour_list = this_player()->query_inform_types();
    break;
  case 2 :
    clubs = this_player()->query_player_clubs();
    clubs = filter(clubs, (: !CLUB_HANDLER->is_club($1) :));
    foreach (bing in clubs) {
       this_player()->remove_player_club(bing);
    }
    colour_list = map(this_player()->query_player_clubs(), (: "club_" + $1 :));
    break;
  }
  return colour_list;
} /* query_colour_list() */

mixed set_colours(int inform, string event_type, string colour, int force) {
  mapping my_colours;
  string *colour_list;
  string *bad;
  string tmp;
  string name;

  colour_list = query_colour_list(inform);
  
  if (inform == 2) {
    name = CLUB_HANDLER->query_club_name(event_type);
    event_type = "club_" + event_type;
  } else {
    name = lower_case(event_type);
  }
  
  if(member_array(event_type, colour_list) == -1) {
    return notify_fail("No such type.\n");
  }

  my_colours = this_player()->query_my_colours();
  
  if(colour == "default") {
    this_player()->set_my_colours(event_type, colour);
    write(name + " colour set to default.\n");
  } else if(colour == "none") {
    this_player()->set_my_colours(event_type, colour);
    write(name + " colour set to none.\n");
  } else {
    colour_list = map(explode(colour, " "),
                      (: upper_case($1) :));
    bad = filter(colour_list, (: !is_valid_colour($1) :));
    if (sizeof(bad) && !force) {
       if (sizeof(bad) > 1) {
          add_failed_mess("The colours " + query_multiple_short(bad) +
                          " are not valid, valid colours are: " +
                          query_multiple_short(_colours) + ".\n");
       } else {
          add_failed_mess("The colour " + query_multiple_short(bad) +
                          " is not valid, valid colours are: " +
                          query_multiple_short(_colours) + ".\n");
       }
       return 0;
    }

    tmp = "%^" + implode(colour_list, (: $1 + "%^ %^" + $2 :)) + "%^";

    this_player()->set_my_colours(event_type, tmp);
    write(name + " colour set to " + tmp + "[" + colour +
          "]%^RESET%^.\n");
  }
  return 1;
} /* set_colours() */

private int show_colours(int inform) {
  string *colour_list, event;
  mapping my_colours;
  string name;

  colour_list = query_colour_list(inform);
  my_colours = this_player()->query_my_colours();
 
  if (!inform) {
    write(sprintf("%-20s %s\n", "Clubs", "<list>"));
    write(sprintf("%-20s %s\n", "Inform", "<list>"));
  }
  foreach(event in colour_list) {
    if (inform == 2) {
       name = CLUB_HANDLER->query_club_name(event[5..]);
    } else {
       name = event;
    }
    if(my_colours[event]) {
      if(my_colours[event] != "") {
        write(sprintf("%-20s %s\n", name, my_colours[event] +
                      "[" + replace(my_colours[event], "%^", "") +
                      "]%^RESET%^"));
      } else {
        write(sprintf("%-20s %s\n", name, "[none]"));
      }
    } else {
      write(sprintf("%-20s %s\n", name, "[default]"));
    }
  }
  return 1;
} /* show_colours() */


mixed *query_patterns() {
  return ({ "<word'event type'> <string'colour'>",
              (: set_colours(0, $4[0], $4[1], 0) :),
            "force <word'event type'> <string'colour'>",
              (: set_colours(0, $4[0], $4[1], 1) :),
            "", (: show_colours(0) :),
            "inform <word'inform type'> <string'colour'>",
              (: set_colours(1, $4[0], $4[1], 0) :),
            "inform force <word'inform type'> <string'colour'>",
              (: set_colours(1, $4[0], $4[1], 1) :),
            "club <string:quoted'club name'> <string'colour'>",
              (: set_colours(2, $4[0], $4[1], 0) :),
            "club force <string:quoted'club name'> <string'colour'>",
              (: set_colours(2, $4[0], $4[1], 1) :),
            "inform", (: show_colours(1) :),
            "allowed", (: show_allowed_colours() :),
            "clubs", (: show_colours(2) :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/player/colo_urs.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/i.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/i.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627173   Available: 13574527
Inodes: Total: 5242880    Free: 4960133
287 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/i.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627173   Available: 13574527
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: i.c,v 1.2 1998/04/14 02:43:24 pinkfish Exp $
 * $Log: i.c,v $
 * Revision 1.2  1998/04/14 02:43:24  pinkfish
 * No change.  Whoops!
 *
 * Revision 1.1  1998/01/06 05:29:43  ceres
 * Initial revision
 * 
*/
inherit "/cmds/player/inv_entory";
// --- END [/mnt/home2/grok/lib/cmds/player/i.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/ht_ell.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/ht_ell.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627173   Available: 13574527
Inodes: Total: 5242880    Free: 4960133
603 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/ht_ell.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627173   Available: 13574527
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
int cmd(string arg, int brief){
  function bing;

  bing = this_player()->get_htell_func();
  arg = this_player()->expand_nickname(arg);
  return evaluate(bing, arg, brief);
}


mixed *query_patterns()  {
    return ({ "brief search <string'name'>", (: cmd(lower_case($4[0]), 1) :),
              "search <string'name'>", (: cmd(lower_case($4[0]), 
                                     !this_player()->query_verbose("htell")) :),
              "brief", (: cmd("", 1) :),
              "verbose", (: cmd("", 0) :),
              "", (: cmd("", !this_player()->query_verbose("htell")) :)
           });
}
// --- END [/mnt/home2/grok/lib/cmds/player/ht_ell.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/gstat_us.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/gstat_us.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627173   Available: 13574527
Inodes: Total: 5242880    Free: 4960133
1425 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/gstat_us.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627173   Available: 13574527
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: gstat_us.c,v 1.3 1999/11/12 19:50:24 tape Exp $
 * $Log: gstat_us.c,v $
 * Revision 1.3  1999/11/12 19:50:24  tape
 * + disabled the command as it's no longer used
 *
 * Revision 1.2  1998/09/27 20:26:46  ceres
 * Added locked to status.
 *
 * Revision 1.1  1998/01/06 05:29:43  ceres
 * Initial revision
 * 
*/
/* command, trial out by Turrican for a commands daemon. */

inherit "cmds/base";

#define TEAM_HANDLER "/obj/handlers/team"

mixed cmd(string str) {
  string group;
  string locked;
  object member;
  
  // Disabled by Tape.
  return notify_fail( "This command is no longer used.  Please use the "
   "\"group\" command from now on.  Also have a read of \"help "
   "grouping\".\n" );

  group = TEAM_HANDLER->query_group(this_player());
  if(!group || !TEAM_HANDLER->query_members(group))
    return notify_fail("You are not a member of any group.\n");

  if(TEAM_HANDLER->query_locked(group))
    locked = "(locked) ";
  else
    locked = "";
  
  printf("Members of %s%s:\n", locked, group);
  printf("%-12s %|20s   Idle\n", "Name", "Health");
  foreach(member in TEAM_HANDLER->query_members(group)) {
    if(member && interactive(member))
      printf("%-12s %-20s %3d:%02d\n", member->short(),
       member->health_string(), (query_idle(member)/60),
       (query_idle(member)%60));
    else if(member)
      printf("%s\n", member->short());
  }
  return 1;
}
// --- END [/mnt/home2/grok/lib/cmds/player/gstat_us.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/whoami.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/whoami.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627172   Available: 13574526
Inodes: Total: 5242880    Free: 4960133
692 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/whoami.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627172   Available: 13574526
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: whoami.c,v 1.2 1998/04/14 02:29:47 pinkfish Exp $
 * $Log: whoami.c,v $
 * Revision 1.2  1998/04/14 02:29:47  pinkfish
 * Changed to use add_command.
 *
 * Revision 1.1  1998/01/06 05:29:43  ceres
 * Initial revision
 * 
*/
/* whoami command, trial out by Turrican for a commands daemon. */

#include <command.h>

inherit "/cmds/base";

mixed cmd() {
  write( "You are "+ (string)( DIR_PLAYER_CMDS +"/who" )->
         who_line(this_player(), this_player()->query_creator(),
                  this_player()->query_cols(), 1) +".\n" );
  return 1;
} /* cmd() */

mixed *query_patterns() {
   return ({ "", (: cmd() :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/player/whoami.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/whois.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/whois.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627172   Available: 13574526
Inodes: Total: 5242880    Free: 4960133
1217 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/whois.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627172   Available: 13574526
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: whois.c,v 1.5 2000/04/23 03:18:23 presto Exp $
 * $Log: whois.c,v $
 * Revision 1.5  2000/04/23 03:18:23  presto
 * Added an expand_nickname call so it works with nicknames
 *
 * Revision 1.4  1998/10/11 01:59:20  presto
 * Fixed so whois on yourself works again.  Tired of the complaints. :(
 *
 * Revision 1.3  1998/09/17 02:21:15  presto
 * changed cmd pattern from <indirect:any-living> to <indirect:player>
 * Removed check for interactive() on the matched object
 *
 * Revision 1.2  1998/04/14 02:30:40  pinkfish
 * Clean up a little.
 *
 * Revision 1.1  1998/01/06 05:29:43  ceres
 * Initial revision
 * 
*/
/* whois command, trial out by Turrican for a commands daemon. */

#include <command.h>

inherit "/cmds/base";

mixed cmd(object *obs) {
  write("That is " + (string)(DIR_PLAYER_CMDS +"/who")->
        who_line(this_player()->expand_nickname(obs[0]),
                 this_player()->query_creator(),
                 this_player()->query_cols()) +".\n" );
  return 1;
} /* cmd() */

mixed *query_patterns() {
  return ({ "<indirect:player>", (: cmd($1) :),
            this_player()->query_name(), (: cmd(({this_player()})) :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/player/whois.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/tu_rn.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/tu_rn.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627171   Available: 13574525
Inodes: Total: 5242880    Free: 4960133
1182 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/tu_rn.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627171   Available: 13574525
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: tu_rn.c,v 1.3 2002/02/24 02:35:04 ceres Exp $
 * $Log: tu_rn.c,v $
 * Revision 1.3  2002/02/24 02:35:04  ceres
 * Modified so turning while sneaking doesn't make you vis.
 *
 * Revision 1.2  1998/09/06 04:58:48  presto
 * Moved syntax message into query_patterns thingy
 *
 * Revision 1.1  1998/01/06 05:29:43  ceres
 * Initial revision
 * 
*/
inherit "/cmds/base";

#define TP this_player()

mixed cmd(string str) {
  int i;
  mixed * facing;

  if ( !( i = ([ "half right": 1, "right": 2, "rt": 2, "around": 4, "left": 6,
      "lt": 6, "half left": 7 ])[ str ] ) ) {
    return 0;
  }
  facing = TP->query_facing();
  
  facing[ 0 ] = ( i + facing[ 0 ] ) % 8;
  write( "You reorient yourself with the world.\n" );
  if(TP->query_sneak_level())
    say( TP->one_short(1)+" reorients "+ TP->query_objective() +"self.\n");
  else
    say(TP->one_short() +" reorients "+ TP->query_objective() +"self.\n" );

  TP->set_facing(facing);
  if ( environment(TP) )
    environment(TP)->init();
  return 1;
}


mixed *query_patterns()  {
    return ({ "<string'around, [half] right, [half] left, rt, lt'>",
              (: cmd($4[0]) :) });
}
// --- END [/mnt/home2/grok/lib/cmds/player/tu_rn.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/arguments.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/arguments.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627171   Available: 13574525
Inodes: Total: 5242880    Free: 4960133
594 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/arguments.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627171   Available: 13574525
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This file will print out a nice list of theological arguments that you
 * know.
 * @author Pinkfish
 */
#include <philosophies.h>

inherit "/cmds/base";

int cmd() {
   string *args;

   args = PHILOSOPHY_HANDLER->query_all_known(this_player()->query_name());
   if (!sizeof(args)) {
      write("You do not know any theological arguments.\n");
   } else {
      write("You know the following theological arguments:\n" +
            query_multiple_short(args) + ".\n");
   }
   return 1;
} /* cmd() */

mixed *query_patterns() {
   return ({ "", (: cmd() :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/player/arguments.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/co_mmands.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/co_mmands.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627171   Available: 13574525
Inodes: Total: 5242880    Free: 4960133
1020 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/co_mmands.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627171   Available: 13574525
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: co_mmands.c,v 1.2 2003/03/25 23:12:44 drakkos Exp $
 * $Log: co_mmands.c,v $
 * Revision 1.2  2003/03/25 23:12:44  drakkos
 * Added a line for PT commands
 *
 * Revision 1.1  1998/01/06 05:29:43  ceres
 * Initial revision
 * 
*/
inherit "/cmds/base";

int cmd( ) {
  string *cmds;
  write( "Your current commands are:\n"+ sprintf( "%-#*s\n",
         (int)this_player()->query_cols(), implode( sort_array(
         (string *)this_player()->query_known_commands(), 1 ),
         "\n" ) ) );
         
  if (this_player()->query_playtester()) {
    cmds = get_dir ("/cmds/playtester/");
    
    cmds = filter (cmds, (: strsrch ($1, ".c") == (sizeof ($1) - 2) :));
    write( "\n\nYour playtester commands are:\n"+ replace (sprintf( "%-#*s\n",
         (int)this_player()->query_cols(), implode( sort_array(
         (string *)cmds, 1 ),
         "\n" ) ), ({".c", ""})) );
        
  }
   return 1;
} /* cmd() */

mixed* query_patterns() {
   return ({ "", (: cmd() :) });
}
// --- END [/mnt/home2/grok/lib/cmds/player/co_mmands.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/con_sider.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/con_sider.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627170   Available: 13574524
Inodes: Total: 5242880    Free: 4960133
7736 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/con_sider.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627170   Available: 13574524
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: con_sider.c,v 1.24 2003/07/11 00:53:21 pinkfish Exp $
 * 
 */
#define CREATOR "Ceres"
/*
  Replacement consider command. This one takes weapons, skills, armour and hit
  points into account whereas the old one only compared their overall fighting
  skill
 */
#include <weapon.h>
#include <cmr.h>
#include <player.h>

inherit "/cmds/base";

int calc_danger(object ob);
string do_compare(int dif);

mixed cmd(object *obs) {
  object ob;
  int level, ok, dif, total, them;
  string out;

  if(previous_object()->check_dark((int)environment(previous_object())->
    query_light()) < 0) {
     add_failed_mess("It's too dark to consider anyone.\n");
     return 0;
  }
  if(previous_object()->check_dark((int)environment(previous_object())->
    query_light()) > 0) {
     add_failed_mess("It's too bright to consider anyone.\n");
     return 0;
  }

  if (sizeof(obs) > 1) {
     obs -= ({ this_player() });
  }
  if (sizeof(obs) > 5) {
     add_failed_mess("You can only consider five things at once.\n");
     return 0;
  }
  
  if (this_player()->query_property("dead"))  {
    add_failed_mess( "You're dead.  You could just about kill a "
                        "conversation.\n" );
    return 0;
  }

  level = calc_danger(previous_object());
  
  foreach (ob in obs) {
    if (!living(ob)) {
       continue;
    }
    if (ob == previous_object()) {
       if (sizeof(obs) == 1) {
          write("You are exactly equal to yourself, you had better go and "
                "arm yourself with more spiky things and try to not arm "
                "your reflection at the same time.  No problems?\n");
          ok++;
       }
       continue;
    }
    ok++;
    them = calc_danger(ob);
    total += them;
    
    // percentage difference.
    dif = ((level - them) * 100) / level;

    if ( userp( ob ) && this_player()->query_player_killer() &&
          !ob->query_player_killer() ) {
       out = replace( do_compare( dif ), "$who$", (string)ob->the_short() +
             " [not a killer]" );
    } else {
       out = replace( do_compare( dif ), "$who$", (string)ob->the_short() );
    }

    if (userp(ob)) {
       tell_object(ob, this_player()->the_short(1) + " looks you up and down "
                       "carefully checking out your weapons and armour.\n");
    } else {
       ob->event_npc_consider(this_player());
    }
    
    write( out +"\n" );
    
  }
  if(!ok) {
    add_failed_mess("You need to consider someone.\n");
    return 0;
  }
  return 1;
}
  
string do_compare(int dif) {
   string ret;
   int level;

   ret = "$C$$who$";

   // Check and see if they are drunk first.
   level = PLAYER_DRUNK_EFFECT->query_drunk_level(this_player());
   if (level > 4) {
      if (level > 7) {
         return "%^BOLD%^%^GREEN%^Mate!  They looked at you wrong, you "
                "better sort them out before they get more cocky.%^RESET%^";
      }
      return "%^BOLD%^%^GREEN%^You reckon they would be an easy "
             "target.  Why bother with weapons?%^RESET%^";
   }
  
  if(dif > 320) {
    ret = "%^BOLD%^GREEN%^"+ret+" is too weak to bother attacking";
  } else {
    switch(dif) {
    case 161..320:
      ret = "%^BOLD%^%^GREEN%^"+ret+" is someone you look down on";
      break;
    case 81..160:
      ret = "%^GREEN%^"+ret+" would be an easy target";
      break;
    case 41..80:
      ret = "%^GREEN%^"+ret+" is a lot weaker than you";
      break;
    case 21..40:
      ret = "%^GREEN%^"+ret+" is weaker than you";
      break;
    case 11..20:
      ret = "%^CYAN%^"+ret+" is slightly weaker than you";
      break;
    case -10..10:
      ret = "%^CYAN%^"+ret+" is about equal with you";
      break;
    case -20..-11:
      ret = "%^CYAN%^"+ret+" is slightly tougher than you";
      break;
    case -40..-21:
      ret = "%^RED%^"+ret+" is tougher than you";
      break;
    case -80..-41:
      ret = "%^RED%^"+ret+" is a lot tougher than you";
      break;
    case -160..-81:
      ret = "%^RED%^"+ret+" looks pretty nasty";
      break;
    case -320..-161:
      ret = "%^BOLD%^%^RED%^"+ret+" is into the don't-even-think-about-it "
        "region";
      break;
    default:
      ret = "%^BOLD%^%^RED%^You would have to be utterly insane to attack "
        "$who$";
      break;
    }
   }
   return ret + ".%^RESET%^";
}

int calc_weapon_damage(object weapon) {
  mixed *data;
  int wdam, *damage, i;
  
  data = (mixed *)weapon->query_attack_data();
  if(sizeof(data)) {
    wdam = 0;
    for ( i = 0; i < sizeof( data ); i += W_ARRAY_SIZE ) {
      if (member_array( data[ i + W_TYPE ], ({ "blunt", "unarmed",
                                               "sharp", "pierce" }) ) == -1 )
        continue;
      damage = data[ i + W_DAMAGE ];
      wdam += ( data[ i + W_CHANCE ] * ( damage[ F_FIXED ] +
                        ( damage[ F_NUM ] * damage[ F_DIE ] ) / 2 ) ) / 100;
      wdam += damage[ F_FIXED ] + damage[ F_NUM ] * damage[ F_DIE ];
    }
  }
  return wdam;
}

int calc_value(mixed arr) {
  if (intp(arr))
    return arr;
  if (!pointerp(arr))
    return 0;
  if (sizeof(arr) == 1)
    return arr[F_FIXED];
  if (sizeof(arr) == 2)
    return arr[F_FIXED]+arr[F_NUM];
  return arr[F_FIXED]+(arr[F_NUM] * arr[F_DIE]);
}

int calc_armour_protection(object armour) {
  int ac, i;
  mapping data;
  mixed *stuff;

  if(!armour->query_armour())
    return 0;

  data = armour->query_armour_class();
  if(!sizeof(data))
     return 0;
  stuff = keys(data);
  for(i=0; i<sizeof(stuff); i++)
    ac += calc_value(data[stuff[i]][0]);
  return ac;
}

//  calculate how dangerous ob is. Factors used include: weapon damage, weapon
// skill, defensive skill, armour worn and hit points.
int calc_danger(object ob) {
   object weapon;
   object *weapons;
   object armour;
   object rider;
   int wdam;
   int wskill;
   int dskill;
   int ac;
   int hp;
   int trans;

   if (ob->query_transport()) {
      foreach (rider in ob->query_riders()) {
         trans += calc_danger(rider);
      }
   }

  // decide which weapon to use for the consider
  weapons = ob->query_holding();

  if(weapons && sizeof(weapons) > 0 && (weapons[0] != 0) && (weapons[0]->
    query_weapon())) {
    weapon = weapons[0];
    dskill = ob->query_skill_bonus("fighting.combat.parry.melee");
  } else if(weapons && sizeof(weapons) > 1 && (weapons[1] != 0) && 
      (weapons[1]->query_weapon())) {
    weapon = weapons[1];
    dskill = ob->query_skill_bonus("fighting.combat.parry.melee");
  } else {
    weapon = ob;
    dskill = ob->query_skill_bonus("fighting.combat.parry.melee");
  }

  // count parry *and* dodge skill because they might change tactics
  // partway through any combat.
  dskill += ob->query_skill_bonus("fighting.combat.dodging.melee");
  
  wdam = calc_weapon_damage(weapon);
  if(!sizeof(weapon->query_attack_data())) {
    wskill += ob->query_skill_bonus("fighting.combat.melee.unarmed");
    wskill += ob->query_skill_bonus("fighting.combat.special.unarmed") / 2;
  } else {
    wskill += ob->query_skill_bonus("fighting.combat.melee."+
              (string)weapon->query_attack_data()[W_SKILL]);
    wskill += ob->query_skill_bonus("fighting.combat.special.weapon") / 2;
  }

  wskill += ob->query_skill_bonus("fighting.combat.special.tactics");
  
  wskill += ob->query_specific_gp("fighting");
  hp = ob->query_hp();

  if(ob->query_wearing())
    foreach(armour in ob->query_wearing())
      if(armour)
        ac += calc_armour_protection(armour);

  // weighting of the different statistics
  wdam /= 3;
  hp /= 3;
  dskill /= 2;
  ac /= 6;
  
  return trans + wdam + wskill + dskill + ac + hp;
}

mixed* query_patterns() {
  return ({ "<indirect:living:here>", (: cmd($1) :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/player/con_sider.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/godmother.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/godmother.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627168   Available: 13574522
Inodes: Total: 5242880    Free: 4960133
3335 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/godmother.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627168   Available: 13574522
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: godmother.c,v 1.6 2003/07/16 19:12:03 pinkfish Exp $
 * $Log: godmother.c,v $
 * Revision 1.6  2003/07/16 19:12:03  pinkfish
 * Make it use the players start pos before the nationality start pos.
 *
 * Revision 1.5  2003/07/16 19:08:21  pinkfish
 * Make it work to get out of limbo.
 *
 * Revision 1.4  2002/06/12 21:54:40  vashti
 * Modified the "no godmother" checking on rooms to allow custom messages.
 *
 * Revision 1.3  2002/02/23 22:16:20  ceres
 * Fixed runtime
 *
 * Revision 1.2  1999/11/01 20:49:13  tape
 * + added a checked for "no godmother" on the person doing the summoning as well,
 *   not just the environment
 *
 * Revision 1.1  1998/01/06 05:29:43  ceres
 * Initial revision
 * 
*/
#include <panic.h>
#include <move_failures.h>
inherit "/cmds/base";

void create() {
  seteuid(getuid());
} /* create() */

int cmd( ) {
  mixed why_not;
  string destination;
  int ret;
  string str;

  if (!environment(this_player())) {
     // Very bad, just throw them to their start location.
     // First we try the last saved location.
      destination = this_player()->query_last_pos();

      str = catch(ret = this_player()->move_with_look(destination, 
                             "$N appears out of nowhere.",
                             "$N disappears with a pop."));
      if (str || ret != MOVE_OK) {
         destination = this_player()->query_start_pos();


         str = catch(ret = this_player()->move_with_look(destination,
                                "$N appears out of nowhere.",
                                "$N disappears with a pop."));
      }
      if (str || ret != MOVE_OK) {
         destination = this_player()->query_nationality()->query_default_start_location();


         str = catch(ret = this_player()->move_with_look(destination,
                                "$N appears out of nowhere.",
                                "$N disappears with a pop."));
      }
      if (str || ret != MOVE_OK) {
         add_failed_mess("Unable to move you out of limbo.  Try again "
                         "soon.\n");
         return 0;
      }
     add_succeeded_mess("You escape from limbo.\n");
     return 1;
  }

  if (environment() ||
      (why_not = environment(this_player())->query_property("no godmother"))) {
      /* Make sure they cannot do it in some places.  ie: start rooms */
          if ( why_not && stringp( why_not ) ) {
              add_failed_mess( why_not );
          } else {
              add_failed_mess("You cannot summon the godmother here.\n");
          }
          return 0;
   }

   why_not = this_player()->query_property( "no godmother" );
   
   if( why_not )
   {
      if( stringp( why_not ) && sizeof( why_not ) ) {
         add_failed_mess( why_not );
      } else {
         add_failed_mess( "You cannot summon a godmother at this moment.\n" );
      }
      
      return 0;
   }
   
   if (PANIC_HANDLER->do_startup(previous_object())) {
      this_player()->add_succeeded_mess(this_object(),
                      ({ "",
                         "$N stares into space and looks pensive.\n" }),
                      ({ }) );
   } else {
      /* They are busy */
      return 0;
   }
   return 1;
} /* cmd() */

mixed *query_patterns() {
   return ({ "help", (: cmd() :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/player/godmother.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/brief.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/brief.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627167   Available: 13574521
Inodes: Total: 5242880    Free: 4960133
1452 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/brief.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627167   Available: 13574521
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: brief.c,v 1.4 2000/09/27 01:36:02 presto Exp $
 * $Log: brief.c,v $
 * Revision 1.4  2000/09/27 01:36:02  presto
 * Fixed printing "No such option" when it shouldn't
 *
 * Revision 1.3  2000/09/02 22:28:22  ceres
 * Added error mess
 *
 * Revision 1.2  1999/02/09 01:36:59  ceres
 * Forgot to remove some debug info
 *
 * Revision 1.4  1999/02/09 00:23:41  ceres
 * Increased the max email address length to 50.
 *
 * Revision 1.2  1999/02/03 00:52:50  pinkfish
 * Fix it up so you can only enter certain sized bits of data into the fields.
 *
 * Revision 1.1  1998/01/06 05:29:43  ceres
 * Initial revision
 * 
*/
inherit "/cmds/base";

#define TP this_player()

int cmd(string which, string type) {
  string t, disp;

  if(!type) {
    disp = "Your settings are: ";
    foreach(t in TP->query_verbose_types())
      disp += t + (TP->query_verbose(t) ? " (verbose) " : " (brief) ");
    write(disp + "\n");
  }

  else if(type == "all") {
    foreach(t in TP->query_verbose_types())
      TP->set_verbose(t, which == "verbose");
    write("Ok\n");
  } else if(member_array(type, TP->query_verbose_types()) != -1) {
    TP->set_verbose(type, which == "verbose");
    write("Ok\n");
  } else {
    write("No such option.\n");
  }
  return 1;
  
}


mixed *query_patterns() {
  return ({ "<word'type'>", (: cmd("brief", $4[0]) :),
            "", (: cmd("brief", 0) :),
         });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/player/brief.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/joing_roup.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/joing_roup.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627167   Available: 13574521
Inodes: Total: 5242880    Free: 4960133
1945 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/joing_roup.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627167   Available: 13574521
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: joing_roup.c,v 1.1 1998/01/06 05:29:43 ceres Exp $
 * $Log: joing_roup.c,v $
 * Revision 1.1  1998/01/06 05:29:43  ceres
 * Initial revision
 * 
*/
/* command, trial out by Turrican for a commands daemon. */

inherit "cmds/base";

#define TEAM_HANDLER "/obj/handlers/team"

mixed cmd(string str) {
  object owner, person;
  int policy;
  
  if(!str)
    return notify_fail("Syntax: joingroup <group name>\n");
  
  if(TEAM_HANDLER->query_group(this_player()))
    return notify_fail("You are already a member of a group.\n");

  if(!TEAM_HANDLER->test_group(str))
    return notify_fail("Sorry, there is no group by that name.\n");

  owner = TEAM_HANDLER->query_owner(str);
  if(!owner || environment(owner) != environment(this_player()))
    return notify_fail("Sorry, the owner of "+str+" is not here.\n");

  if(TEAM_HANDLER->query_full(str))
    return notify_fail("Sorry, that group is full, you cannot join.\n");

  if(TEAM_HANDLER->query_locked(str))
    return notify_fail("Sorry, that group is locked, you cannot join.\n");
  
  policy = TEAM_HANDLER->query_policy(str);
  
  if(!TEAM_HANDLER->join_group(str, this_player()))
    return notify_fail("Ack, something went wrong.\n");

  foreach(person in TEAM_HANDLER->query_members(str)) {
    if(person && present(person, environment(this_player())) &&
       person != this_player()) {
      this_player()->add_protector(person);
      person->add_protector(this_player());

      if(policy == 1)                 // follow all
  this_player()->add_follower(person);

      if((policy == 1) || (person == owner)) // only follow leader
  person->add_follower(this_player());
    }
  }
  write("You join "+str+" and will now protect and be protected by "
  "them.\n");
  say(this_player()->short()+" joins "+str+" and will protect and be "
      "protected by its members.\n");
  
  write("You are now a member of "+str+"\n");
  return 1;
}
// --- END [/mnt/home2/grok/lib/cmds/player/joing_roup.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/mudlist.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/mudlist.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627166   Available: 13574520
Inodes: Total: 5242880    Free: 4960133
4391 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/mudlist.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627166   Available: 13574520
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: mudlist.c,v 1.3 2002/07/18 23:21:36 ceres Exp $
 * $Log: mudlist.c,v $
 * Revision 1.3  2002/07/18 23:21:36  ceres
 * Added baselib
 *
 * Revision 1.2  2000/03/21 21:04:38  ceres
 * Fixed typo
 *
 * Revision 1.1  1998/01/06 05:29:43  ceres
 * Initial revision
 * 
*/
/*    /cmds/player/mudlist.c
 *    from the Nightmare IV LPC Library
 *    gives information about muds
 *    created by Descartes of Borg 950623
 *    Modified for Discworld by Turrican 1-11-95
 */

#define INTERMUD_D "/net/intermud3/intermud"

int cmd(string str) {
  mixed *info;
  string *list;
  mapping borg;
  string mud;
  
  if( str && str != "") {
    mapping tmp;
    string opt, tmpstr;
    
    tmp = (mapping)INTERMUD_D->GetMudList();
    if( str[0] != '-' ) str = "-n " + str;
    opt = str[1..1];
    str = str[3..];
    borg = ([]);
    foreach(mud, info in tmp) {
      int x, y, z;
      
      switch(opt) {
      case "m":
        x = 5;
        break;
      case "d":
        x = 7;
        break;
      case "n":
        x = 0;
        break;
      }
      tmpstr = (x ? info[x] : mud);
      z = strlen(str = replace_string(lower_case(str), " ", ""));
      y = strlen(tmpstr = replace_string(lower_case(tmpstr), " ", ""));
      if( str == tmpstr ) {
        borg = ([ mud : info ]);
        break;
      }
      else if( y > z && tmpstr[0..z-1] == str && info[0] == -1 ) 
        borg[mud] = info;
    }
  }
  else {
    borg = ([ ]);
    foreach( mud, info in (mapping)INTERMUD_D->GetMudList() )
      if( info[0] == -1 ) borg[mud] = info;
  }
  if( !sizeof(borg) ) {
    write(mud_name()+" does not have any MUD matching "+str+" in "
          "its mudlist.\n");
    return 1;
  }
  else if( sizeof(borg) == 1 ) {
    string msg, svc;
    int val, comma = 0;
    
    mud = keys(borg)[0];
    msg = "\nDetailed information on %^GREEN%^" + mud + "%^RESET%^:\n";
    msg += "Server: " + borg[mud][7] + " (" + borg[mud][8] + ")\n";
    msg += "BaseLib: " + borg[mud][6] + "\n";
    msg += "Library: " + borg[mud][5] + "\n";
    msg += "Status: " + borg[mud][9] + "\n";
    msg += "Admin E-mail: " + borg[mud][10] + "\n";
    msg += "Services: ";
    foreach(svc, val in borg[mud][11]) {
      if( val == 1 ) {
        if( comma ) msg += ", " + svc;
        else {
          msg += svc;
          comma = 1;
        }
      }
    }
    msg += "\nHost: " + borg[mud][1] + "\n";
    msg += "Telnet port: " + borg[mud][2] + "\n";
    if( borg[mud][11]["http"] ) 
      msg += "HTTP port (World Wide Web): " + borg[mud][11]["http"]+"\n";
    if( borg[mud][11]["ftp"] ) 
      msg += "FTP port (File Transfer): " + borg[mud][11]["ftp"] + "\n";
    if( borg[mud][11]["rcp"] )
      msg += "RCP port (Remote Creator): " + borg[mud][11]["rcp"] + "\n";
    write(msg);
    return 1;
  }
  list = ({});
  foreach(mud, info in borg)
    list += ({ sprintf("%:-15s %:-10s %:-15s %:-15s %s %d",
                       mud, info[8], info[7], info[5], info[1], info[2]) });
  list = sort_array(list, 1);
  list = ({ mud_name() + " recognizes " + sizeof(borg)+" muds"
              " matching your query: ", "" }) + list;
  previous_object()->more_string(implode(list, "\n")+"\n", "Mudlist");
  return 1;
}

int alphabet(string a, string b) {
    if((a = lower_case(a)) == (b = lower_case(b))) return 0;
    else if(a > b) return 1;
    else return -1;
}

void help() {
    message("help", "Syntax: <mudlist>\n"
      "        <mudlist -dmn [arg]>\n\n"
      "Without any arguments, it gives a full listing of all muds "
      "with which this mud is capable of communication through "
      "tell, mail, finger, rwho, and other intermud services.  "
      "With arguments, <mudlist> requires one and only one option "
      "which must be one of the following:\n"
      "\t-d [driver]: List only muds using the named driver\n"
      "\t-m [mudlib]: List only muds using the named mudlib\n"
      "\t-n [mudname]: List only the muds with the name given\n\n"
      "Note that the argument need not be complete, for example:\n"
      "\t mudlist -n idea\n"
      "will list IdeaExchange as well as any other mud whose name "
      "begins with the string \"idea\".\n\n"
      "See also: finger, mail, rwho, tell", this_player());
}

void clean_up() {
  destruct(this_object());
}

void reset() {
  destruct(this_object());
}

void dest_me() {
  destruct(this_object());
}
// --- END [/mnt/home2/grok/lib/cmds/player/mudlist.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/bug.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/bug.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627165   Available: 13574519
Inodes: Total: 5242880    Free: 4960133
656 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/bug.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627165   Available: 13574519
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: bug.c,v 1.3 1998/04/16 12:52:49 pinkfish Exp $
 * $Log: bug.c,v $
 * Revision 1.3  1998/04/16 12:52:49  pinkfish
 * Update to use the new report base inhertiable command.
 *
 * Revision 1.2  1998/02/28 02:47:28  presto
 * fixed destination directory for virtual object bugreps
 *
 * Revision 1.1  1998/01/06 05:29:43  ceres
 * Initial revision
 *
 */
/**
 * Does this nice bug reporting for the players.  Uses a neato
 * base object whizz bang thing now.
 * @author Pinkfish
 */

inherit "/cmds/report_base";

void create() {
   ::create();
   set_error_type("BUG");
   set_use_last_error(1);
} /* create() */
// --- END [/mnt/home2/grok/lib/cmds/player/bug.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/who.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/who.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627164   Available: 13574518
Inodes: Total: 5242880    Free: 4960133
11634 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/who.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627164   Available: 13574518
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: who.c,v 1.58 2003/03/03 00:58:25 pinkfish Exp $
 * 
 */
/* who command, trial out by Turrican for a commands daemon. */
#include <clubs.h>
#include <playtesters.h>
#include <config.h>

inherit "/cmds/base";

#include <player.h>

string who_string(int width, int cre, int verbose, string name);
string who_line(object ob, int cre, int width);

mapping _nationalities;

void create() {
  string file;
  object ob;
  
  ::create();

  _nationalities = ([ ]);
  foreach(file in get_dir("/std/nationality/*.c")) {
    ob = find_object("/std/nationality/" + file);
    if(ob && ob->query_name())
      _nationalities[ob->query_name()] = base_name(ob);
  }
}

/**
 * This is used by the other who commands to do the object mapping
 * to figure out who to include in the list.
 * @param tarr the array to get the filtered list from
 * @param name the name of the guilds to filter on
 * @param no_cres do not include any creators
 * @return the array of filtered objects
 */
object *filter_users(object *tarr, string name, int no_cres)  {
  string *guilds;
  string guild;
  string start_guild;
  string *domains;
  object *ret_arr;
  object *arr;
  int not_tag;
  
  name = lower_case(name);
  name = replace(name, ({"assassins", "assassin", 
                           "priests", "priest",
                           "thieves",   "thief",    
                           "warriors",    "warrior",
                           "witches",   "witch",    
                           "wizards",     "wizard",
                           "creators",  "creator",  
                           "liaisons", "liaison",
                           "adventurers", "adventurer",
                           "fighters", "warrior", 
                           "fighter", "warrior",
                           "killers", "killer", 
                           "helpers", "helper",
                           "playtesters", "playtester", 
                           "friends", "friend",
                           "families", "family" }));
  guilds = explode(name, "&") - ({ "" });
  if (sizeof(guilds) > 1) {
    arr = filter_users(tarr, guilds[0], no_cres);
    foreach (guild in guilds[1..]) {
      arr &= filter_users(tarr, guild, no_cres);
    }
    return arr;
  }
  guilds = explode(name, ",") - ({ "", 0 });

  domains = "/secure/master"->query_domains();
  
  ret_arr = ({ });

  foreach (guild in guilds)  {
    start_guild = guild;
    guild = replace(guild, " ", "", "\t", "");
    if (guild[0] == '-') {
       not_tag = 1;
       guild = guild[1..];
    } else {
       not_tag = 0;
    }
    arr = ({ });
    if (guild == "adventurer")  {
      arr += filter(tarr, (: !$1->query_guild_ob()  &&
                           (!$(no_cres) || !$1->query_creator()) :));
    } else if (guild == "friend")  {
      arr += filter(tarr, (: !$1->query_login_ob() && this_player()->is_friend($1->query_name()) :));
    } else if (guild == "creator")  {
      arr += filter(tarr, (: $1->query_creator()  &&
                           $1->query_visible(this_player()) :) );
    } else if (guild == "helper") {
      arr += filter( tarr, (: !$1->query_creator() &&
                            $1->query_property( "newbie helper" ) :) );
    } else if (guild == "killer") {
      arr += filter(tarr, (: $1->query_player_killer() &&
                           (!$(no_cres) || !$1->query_creator()) :));
    } else if (guild == "family") {
      arr += filter(tarr, (: $1->query_family_name() :));
    } else if (guild == "playtester") {
      arr += filter(tarr, 
                    (: PLAYTESTER_HAND->query_playtester($1->query_name()) :));
    } else if (member_array(guild, domains) > -1)  {
      arr += filter(tarr, (: $1->query_creator()  &&
                           ("/d/"+$(guild)+"/master")->query_member($1->query_name())  &&
                           $1->query_visible(this_player()) :));
    } else if(member_array(guild, keys(_nationalities)) > -1) {
      arr += filter(tarr, (: $1->query_nationality() == $2 :),
                    _nationalities[guild]);
    } else  {
      if (file_size("/std/guilds/" + guild + ".c") > 0)  {
        arr += filter(tarr,
                      (: (!$(no_cres) || !$1->query_creator()) &&
                       stringp($1->query_guild_ob()) &&
                       $1->query_guild_ob() == "/std/guilds/" + $(guild) :));
      } else if (CLUB_HANDLER->is_family(start_guild)) {
        arr += filter(tarr, (: CLUB_HANDLER->is_member_of($(start_guild), $1) :));
      } else if (CLUB_HANDLER->is_club(start_guild)) {
        if (!CLUB_HANDLER->query_club_secret(start_guild) ||
            CLUB_HANDLER->is_member_of(start_guild, this_player()->query_name())) {
          arr += filter(tarr, (: CLUB_HANDLER->is_member_of($(start_guild), $1->query_name()) :));
        }
      } else {
        arr += filter(tarr, (: $1->query_deity() == $2 && 
                             (!$(no_cres) || !$1->query_creator()) :),
                      guild);
      }
    }
    if (not_tag) {
       ret_arr |= (tarr - arr);
    } else {
       ret_arr |= arr;
    }
  }

  return ret_arr;
} /* filter_users() */

int cmd(string str, int verbose)  {
  this_player()->more_string( who_string(this_player()->query_cols(),
                                         this_player()->query_creator(),
                                         verbose,
                                         str),
                              "Who", 1 );
  return 1;
} /* cmd() */


/**
 * This method returns the string used in the who command.
 * @return the line for the who line
 */
string who_string(int width, int cre, int verbose, string name) {
  object *arr;
  int number;
  string tmp;
  string tmp2;
  string prt;
  int x;
  
  if (name == "here") {
    arr = filter(all_inventory(environment(this_player())), (: userp($1) &&
                                                             $1->query_visible(this_player()) :) );
  } else {
    arr = filter(users(), (: strsrch(file_name($1), "secure/login") == -1 :));
    if (name && sizeof(arr))  {
      arr = filter_users(arr, name, 1);
    }
  }
  
  number = sizeof(arr);
  
  if (number == 0)  {
    if (name)  {
      return "There are no guild(s) or members of " + name + " online.\n";
    }
    return "There is no one on " + mud_name() + "?\n";
  }
  
  prt = sprintf("%|*'-'s\n", width-1, "==========]  " + mud_name() + "  [===========");
  arr = sort_array(arr, (: strcmp($1->query_name(), $2->query_name() ) :) );
  
  tmp2 = "";
  if(!name && verbose == 0) {
    int i;
    
    // remove all creators except liaisons.
#ifndef __DISTRIBUTION_LIB__
    arr = filter_array(arr, (: !$1->query_creator() ||
                             "/d/liaison/master"->query_member($1->query_name()) :) );
#endif
    
    for (i = 0; i < sizeof(arr); i++)  {
      tmp = (string)arr[i]->query_cap_name();
      if(!tmp) {
        --number;
      } else {
        x = 14;
        
        if (arr[i]->query_creator()) {
          if ("/secure/master"->query_trustee(arr[i]->query_name())) {
            tmp += " (%^RED%^T";
          } else if("/secure/master"->query_director(arr[i]->query_name())){
            tmp += " (%^RED%^D";
          } else if("/secure/master"->query_senior(arr[i]->query_name())){
            tmp += " (%^RED%^S";
          } else  {
            tmp += " (%^RED%^C";
          }
          x += 16;
          
          if ( "/d/liaison/master"->query_member(arr[i]->query_name())) {
            tmp += "%^YELLOW%^l";
            x += 10;
          }
          if(this_player()->is_friend(arr[i]->query_name())) {
            tmp += "%^GREEN%^F";
            x += 9;
          }
          tmp += "%^RESET%^)";
          
        } else if(this_player()->is_friend(arr[i]->query_name())) {
          tmp += " (%^GREEN%^F%^RESET%^)";
          x += 18;
        }

        tmp2 += sprintf("%-" + x + "s ", tmp);
        
        if((i+1) % (width/15) == 0  && tmp2 != "") {
          prt += this_player()->fix_string(" " + tmp2 + "\n", width, 10);
          tmp2 = "";
        }
      }
    }
    prt += this_player()->fix_string(" " + tmp2 + "\n", width, 10);
  } else {
    int i;
    
    for (i = 0; i < sizeof(arr); i++)  {
      tmp = who_line(arr[i], cre, width);
      if ( !tmp )  {
        --number;
      } else  {
        prt += this_player()->fix_string(tmp + "\n", width, 10);
      }
    }
  }
  
  if ( name == "here" )  {
    if (number == 1)
      tmp = "> You are all by yourself. <";
    else
      tmp = "> There are " + query_num(number, 500) + " people here. <";
  } else if ( name )  {
    tmp = "> There " + (number > 1 ? "are " : "is ") +
      query_num(number, 500) +
      (number > 1 ? " members of" : " member of");
    if (strsrch(name, ",") != -1) {
      tmp += " those guilds on the " + mud_name() + ". <";
    } else {
      tmp += " this guild on the " + mud_name() + ". <";
    }
  } else if (number < 2)  {
    tmp = "> You are all alone on the " + mud_name() + ". <";
  } else  {
    tmp = "> There are " + query_num(number, 500) +
      " mudders on the " + mud_name() + ". <";
  }
  prt += sprintf("%*'-'|s\n", width-1, tmp);
  return prt;
}

/**
 * This method returns the line used for each player in the who
 * command.
 * @return the who line
 * @param ob the player to show
 * @param cre are we a cre
 * @param width the width of the line
 */
string who_line(object ob, int cre, int width)  {
  string s;
  string tmp;

  tmp = ob->query_player_title();
  if (tmp) {
    tmp += " ";
  } else {
    tmp = "";
  }
  s = tmp + ob->query_cap_name();
  if ( !s )  {
    return 0;
  }
  tmp = ob->query_family_name();
  if (tmp) {
    s += " " + tmp;
  }

  if ( "/d/liaison/master"->query_member( (string)ob->query_name() ) )  {
    s += " (%^YELLOW%^Liaison%^RESET%^)";
  }
  if (ob->query_creator()) {
    if ("/secure/master"->query_trustee((string)ob->query_name()))  {
      s += " (%^RED%^Trustee%^RESET%^)";
    } else if("/secure/master"->query_director((string)ob->query_name())){
      s += " (%^RED%^Director%^RESET%^)";
    } else if("/secure/master"->query_senior((string)ob->query_name())) {
      s += " (%^RED%^Senior%^RESET%^)";
    } else  {
      s += " (%^RED%^Creator%^RESET%^)";
    }
    if (ob->query_invis() == 1) {
      s += " (Invisible)";
    } if (ob->query_invis() > 1) {
      s += " (Super Invisible)";
    }
  }
    

  if (cre)  {
    if ((tmp = (string)ob->query_in_editor()))  {
      s += " (editing: " + tmp + ")";
    }
  }
  if (ob->query_property("guest"))  {
    s += " guest of " + mud_name() + "";
  } else if (tmp = (string)ob->query_gtitle())  {
    s += " " + tmp;
  } else  {
    s += " the Adventurer";
  }
  if (tmp = (string)ob->query_property("player_title"))  {
    s += ", " + tmp;
  }
  tmp = (string)ob->query_title();
  if ( tmp && ( tmp != "" ) )  {
    s += ", " + tmp;
  }


  if ( PLAYTESTER_HAND->query_playtester( ob->query_name() ) ) {
    if ( PLAYTESTER_HAND->query_senior_playtester( ob->query_name() ) ) {
      s += ", (%^BOLD%^%^CYAN%^Senior Playtester%^RESET%^)";
    }
    else {
      s += ", (%^CYAN%^Playtester%^RESET%^)";
    }
  }
  if (interactive(ob))  {
    if (query_idle(ob) > 120)  {
      s += " (Idle: " + (query_idle(ob) / 60) + ")";
    }
  }
  return s + "%^RESET%^";
} /* who_line() */

mixed *query_patterns() {
  return ({ "", (: cmd(0, 0) :),
              "verbose", (: cmd(0, 1) :),
              "here", (: cmd("here", 1) :),
              "<string'guild|liaisons|creators|killers|helpers|playtesters|friends|families|nationality'>", (: cmd( $4[0], 0 ) :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/player/who.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/last.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/last.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627161   Available: 13574515
Inodes: Total: 5242880    Free: 4960133
4164 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/last.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627161   Available: 13574515
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: last.c,v 1.15 2003/03/21 01:53:51 ceres Exp $
 * 
 */
/* last command, trial out by Turrican for a commands daemon. */

#include <player_handler.h>

inherit "/cmds/base";

#define BASENAME "/d/admin/log/ENTER"

string process_file(string fname, string str);
string get_details(string str, string file);
string mtime(string t);
string stime(string t);

nosave int logged_on;
nosave string time;

mixed cmd(string str) {
  string retval;
  int i;

  write("This command is no longer available.\n");
  return 1;
  
  if (!str || str == "") {
    notify_fail("Usage: last <name>\n");
    return 0;
  }

  if(!this_player()->query_creator() &&
     PLAYER_HANDLER->test_creator(str)) {
    return notify_fail("Sorry, you can't do that, "+ str + " is a "
           "creator.\n");
  }
  if("/secure/master"->query_lord(str) &&
     !"/secure/master"->query_lord(this_player()->query_name())) {
    return notify_fail("Sorry, you can't do that, "+ str +" is a "
           "lord\n");
  }

  logged_on = 0;
  retval = "";
  time = "";
  str = (string)this_player()->expand_nickname(str);

  retval = process_file(BASENAME + ".log", str);

  // check old logs _if_ we haven't found them
  //  if(retval == "")
  //retval += process_file(BASENAME+".1", str);
  
  if(logged_on == 1) {
    if (!find_player(str)) {
      retval += sprintf("%15-s %s - Destd (??:??)\n", str, mtime(time));
    } else {
      retval += sprintf("%15-s %s - Not logged off\n", str, mtime(time));
    }
  }
  
  if(retval == "") {
    if(PLAYER_HANDLER->test_user(str)) {
      i = (int)PLAYER_HANDLER->test_last(str);
      if(i) {
        write(sprintf("%15-s %s\n", str, ctime(i)));
        return 1;
      }
    }
    write("No such user " + str + "\n");
  } else {
    write(retval);
  }
  return 1;
}

string process_file(string fname, string str) {
  int size, bits, length, i;
  string retval, file;

  retval = "";

  seteuid("Root");

  // if the file is more than 50k then break it up and read it bit by bit.
  size = file_size(fname);
  if(size > 50000) {
    length = file_length(fname);
    bits = size / 50000;
  } else {
    bits = 1;
  }

  if(bits > 10) {
    i = bits - 10;
  } else {
    i = 0;
  }
  
  for(; i< bits; i++) {
    file = unguarded((: read_file, fname,
          i * (length/bits), length / bits :) );
    if (!file) {
      write("Log file non existant, or bad things are happening.  "
      "(Bad vibes man!)\n");
      return "";
    }

    retval += get_details(str, file);
  }
  seteuid("Room");
  return retval;
}

string get_details(string str, string file) {
  string *sarr;
  string retval;
  string t2;
  string type;
  string time_str;
  int i;
  
  retval = "";
  
  sarr = explode(file, "\n");

  for (i = 0; i < sizeof(sarr); i++) {
    //if (sscanf(sarr[i], "%s [%s] %*s" + str + " ", time_str, type) == 3)  {
    if (sscanf(sarr[i], "%s [%s] " + str + " ", time_str, type) == 2 ||
        sscanf(sarr[i], "%s [%s]  " + str + " ", time_str, type) == 2)  {
      switch(type)  {
        case "Enter":
          time = time_str;
          logged_on = 1;
          break;

        case "Recon":
          time = time_str;
          logged_on = 1;
          break;

        case "Su":
          t2 = time_str;
          logged_on = 0;
          retval += sprintf("%15-s %s - %s [Quit]\n", str, mtime(time),
                            stime(t2));
          break;
   
        case "NDead":
          t2 = time_str;
          logged_on = 1;
          retval += sprintf("%15-s %s - %s [NetDead]\n", str, mtime(time),
                    stime(t2));
          time = "";
          break;

        case "Exit":
          t2 = time_str;
          logged_on = 0;
          retval += sprintf("%15-s %s - %s [Quit]\n", str, mtime(time),
                            stime(t2));
          break;

        default:
          write("Someone has stuffed up... please file a bug report\n");
          break;
      }
    } 
  }
  
  return retval;
}

string mtime(string t) {
  if(t == "")
    return "??? ?? ??:??";
  return t[0..<4];
}

string stime(string t) {
  if(t == "")
    return "??:??";
  return t[7..11];
}

// --- END [/mnt/home2/grok/lib/cmds/player/last.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/wet.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/wet.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627160   Available: 13574514
Inodes: Total: 5242880    Free: 4960133
1502 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/wet.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627160   Available: 13574514
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Id: wet.c,v 1.7 2001/12/15 21:13:53 presto Exp $
 */
inherit "/cmds/base";
#include <dirs.h>

#define THRESHOLDS ({ 10, 30, 200, 300 })
#define OBJECT_WET_EFFECT "/std/effects/object/wet"
#define BODY_WET_EFFECT "/std/effects/other/wetness"

mixed cmd(object *things) {
   string results;
   string no_wet_results;
   object thing;
   object* not_wet;
   string wet_mess;
 
   if (!things) {
      things = all_inventory(this_player()) + ({ this_player() });
   } 
   results = ""; 
   not_wet = ({ });
   no_wet_results = "";
   foreach (thing in things) {
      //max = 200 * (int) thing->query_weight();
      wet_mess = OBJECT_WET_EFFECT->wet_string(thing);
      if (strlen(wet_mess)) {
         if (thing == this_player()) {
            wet_mess = "are " + wet_mess;
         } else {
            wet_mess = "is " + wet_mess;
         }
      } else {
         wet_mess = BODY_WET_EFFECT->wet_string(thing, thing == this_player());
      }
      if (strlen(wet_mess)) {
         results += "$C$" + thing->the_short(1) + " " + wet_mess + ".\n";
      } else {
         not_wet += ({ thing });
      }
   }
   if (results == "") {
      write(query_multiple_short(not_wet) +
            ((sizeof(not_wet) > 1  ||  not_wet[0] == this_player()) ?
               " are ":" is ") + "not wet.\n");
   } else {
      write(results);
   }
   return 1;
} /* cmd() */

mixed *query_patterns() {
   return ({ "<indirect:object>", (: cmd($1) :),
             "", (: cmd(0) :) });
}
// --- END [/mnt/home2/grok/lib/cmds/player/wet.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/cond_ition.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/cond_ition.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627159   Available: 13574513
Inodes: Total: 5242880    Free: 4960133
4020 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/cond_ition.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627159   Available: 13574513
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: cond_ition.c,v 1.17 2003/07/11 00:24:45 pinkfish Exp $
 * 
 */
inherit "/cmds/base";

class cond_info {
   object cond_item;
   string cond_string;
   int cond_percent;
}

int compare(float, float);

string cond_colour(int percent)
{
   switch (100 - percent) {
   case 0..50:
      return "";
   case 51..60:
      return "%^CYAN%^";
   case 61..70:
      return "%^GREEN%^";
   case 71..80:
      return "%^YELLOW%^";
   case 81..90:
      return "%^RED%^";
   case 91..100:
      return "%^BOLD%^%^RED%^";
   }
}                               /* cond_colour() */

int is_valid_environment(object ob) {
   object env;

   env = environment(ob);
   if (env == environment(this_player())) {
      return 1;
   }
   while (env) {
      if (env == this_player()) {
         return 1;
      }
      env = environment(env);
   }
   return 0;
}

int cmd(object *things, int dir, int no_excellent)
{
   int i;
   string list;
   object thing;
   class cond_info *info = ({ });
   class cond_info new_info;
   int dark;

   if (!this_player()->query_property("dead")) {
      dark =
         this_player()->check_dark(environment(this_player())->query_light());
   }

   if (dark == 2) {
      add_failed_mess("It is way too bright to see anything at all.\n");
      return 0;
   }
   if (dark == -2) {
      add_failed_mess("It is way too dark to see anything at all.\n");
      return 0;
   }

   things = filter(things, (: is_valid_environment :));
   if (!sizeof(things)) {
      add_failed_mess("Can only check the condition of things you "
                      "have in your inventory or on the ground.\n");
      return 0;
   }

   if (sizeof(things) == 1) {
      list = things[0]->cond_string();
      if (!list || list == "") {
         list = " has no condition.\n";
      } else {
         if (things[0]->query_is_pair())  list = list[4 .. ];
         else list = list[2..];
      }
      write("$C$" + things[0]->the_short() + list);
      return 1;
   }

   foreach(thing in things) {
      list = thing->cond_string();
      if (list && list != "") {
       if (thing->query_is_pair())  list = list[4 .. ];
       else list = list[2 .. ];
       info += ({ new (class cond_info,
                       cond_item: thing,
                       cond_string: list,
                       cond_percent:(thing->query_cond() * 100) /
                         thing-> query_max_cond()
                    )
            });
      }
   }
   if (!sizeof(info)) {
      add_failed_mess("None of those things has a condition.\n");
      return 0;
   } else if (sizeof(info) == 1) {
      write("$C$" + info[0]->cond_item->the_short() + info[0]->cond_string);
   } else {
      if (dir) {
         info = sort_array
            (info, (: $(dir) * compare($1->cond_percent, $2->cond_percent) :));
      }
      i = 0;
      foreach(new_info in info) {
         if (!no_excellent || new_info->cond_percent <= 90) {
            write(cond_colour(new_info->cond_percent) + "$C$" +
                  new_info->cond_item->the_short() + " (" + (i + 1) + ")" +
                  new_info->cond_string + "%^RESET%^");
            ++i;
         }
      }
      if (!i && no_excellent) {
         write("Everything is in excellent condition.\n");
      }
   }

   return 1;
}                               /* cmd() */

mixed *query_patterns()
{
   return ({ "<indirect:object'item(s)'> sorting {up|down}",
             (: cmd($1, $4[1] == "up" ? 1 : -1, 0) :),
             "<indirect:object'item(s)'>",
             (: cmd($1, 0, 0) :),
             "<indirect:object'item(s)'> damaged",
             (: cmd($1, 0, 1) :),
             "<indirect:object'item(s)'> damaged sorting {up|down}",
             (: cmd($1, $4[1] == "up" ? 1 : -1, 1) :), });
}                               /* query_patterns() */


int compare(float first, float second)
{
   if (first > second)
      return 1;
   if (first < second)
      return -1;
   return 0;
}                               /* compare() */
// --- END [/mnt/home2/grok/lib/cmds/player/cond_ition.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/qalias.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/qalias.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627158   Available: 13574512
Inodes: Total: 5242880    Free: 4960133
760 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/qalias.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627158   Available: 13574512
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
int cmd()
{
   string *aliases, alias_mess, message;
   int cols;
   
   aliases = keys( this_player()->query_aliases() );
   
   if( !sizeof( aliases ) )
   {
      tell_object( this_player(), "You have no aliases.\n" );
      return 1;
   }
   
   message = "\nYou have the following aliases:\n";
   
   // Alphabetize.
   
   aliases = sort_array( aliases, (: strcmp :) );
   alias_mess = implode( aliases, ", " );
   
   cols = this_player()->query_cols() - 3;
   
   message += sprintf( "   %-=*s\n", cols, alias_mess );

   message += "A total of " + sizeof( aliases ) + " aliases.\n";
   
   tell_object( this_player(), message );
   
   return 1;
   
} /* cmd() */


mixed *query_patterns()
{
   return ({ "", (: cmd() :) });
} /* query_patterns() */

// --- END [/mnt/home2/grok/lib/cmds/player/qalias.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/mailinfo.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/mailinfo.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627158   Available: 13574512
Inodes: Total: 5242880    Free: 4960133
926 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/mailinfo.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627158   Available: 13574512
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: mailinfo.c,v 1.3 2003/03/25 15:58:04 trilogy Exp $
 * $Log: mailinfo.c,v $
 * Revision 1.3  2003/03/25 15:58:04  trilogy
 * Was using /secure/login
 *
 * Revision 1.2  2003/01/12 07:15:48  presto
 * Ignore case
 *
 * Revision 1.1  1998/01/06 05:29:43  ceres
 * Initial revision
 * 
*/
/* mailinfo command, trial out by Turrican for a commands daemon. */

#include <mail.h>
#include <player_handler.h>

mixed cmd(string str) {
  if (!str || str=="")
    str = this_player()->query_name();
  else
    str = this_player()->expand_nickname(str);
  if (!PLAYER_HANDLER->test_user(lower_case(str)))
  {
    write("Sorry, but I don't know any "+capitalize(str)+".\n");
    return 1;
  }
  write("Player "+capitalize(str)+": "+(string)MAILER->finger_mail(str));
  return 1;
}

void dest_me() {
  destruct(this_object());
}

void clean_up() {
  dest_me();
}

void reset() {
  dest_me();
}
// --- END [/mnt/home2/grok/lib/cmds/player/mailinfo.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/upt_ime.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/upt_ime.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627157   Available: 13574511
Inodes: Total: 5242880    Free: 4960133
2692 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/upt_ime.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627157   Available: 13574511
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Id: upt_ime.c,v 1.14 2003/03/02 23:50:32 pinkfish Exp $
 */
#include <player.h>
inherit "/cmds/base";

mixed cmd(int brief) {
  mapping u;
  int r;
  string str;
  string output;
  
  str = "/secure/finger"->time_elapsed_string(uptime());
#ifndef __DISTRIBUTION_LIB__
  output = "A'Tuin has been paddling through space for "+

      str + ".";
  if (brief) {
     write(output + "\n");
     return 1;
  }
  output += "  He (or as it may be, she) has been "
      "performing "+ query_load_average()+".";
#else
  output += mud_name() + " has been up for "+ str +
      ".  The load average is " +
      query_load_average()+".";
  if (brief) {
     write(output + "\n");
     return 1;
  }
#endif

  u = rusage();

#ifndef __DISTRIBUTION_LIB__
  output += sprintf("  This has taken %.2f%% of his (or her) energy and %.2fMB "
                    "of his (or her) mental capacity.  ",
                    ((u["stime"] + u["utime"]) / 10.0) / uptime(),
                    (memory_info() / 1024000.0));
#else
  output += sprintf("  This has taken %.2f%% of the cpu and %.2fMB of "
                    "of memory.  ",
                    ((u["stime"] + u["utime"]) / 10.0) / uptime(),
                    (memory_info() / 1024000.0));
#endif

#ifndef __DISTRIBUTION_LIB__
  r = "/obj/handlers/garbage"->query_next_reboot();
  if (r == -1) {
    output += "It is unknown when he (or she) will be "
      "taking his (or her) next rest.";
  } else if (r < 0 || find_object(OFFLER)) {
    output += "He (or she) will be taking his (or her) next rest "
      "any moment now.";
  } else {
    str = "";
  
    if(r / (60*60*24)) {
      str += (string) (r / (60*60*24)) + " day";
      str += ((r /(60*60*24)) > 1 ? "s" : "");
    }

    if(r / ((60*60)) % 24) {
      if(str != "") {
        str += " and ";
      }
      str += (string)((r/(60*60))%24);
      str += " hour" + (((r/(60*60))%24) > 1 ? "s" : "");
    } else if(str == "") {
      switch(r/ 60) {
      case 0..7:
        str = "less than 15 minutes";
        break;
      case 8..22:
        str = "about a quarter of an hour";
        break;
      case 23..38:
        str = "about half an hour";
        break;
      case 39..53:
        str = "about three quarters of an hour";
        break;
      default:
        str = "just under an hour";
        break;
      }
    }

    output += "He (or she) will be taking his (or her) next rest "
      "in " + str + ".";
  }
#endif
  write(sprintf("%-=*s\n",
                  (int)this_player()->query_cols(), output));
  return 1;
}

mixed* query_patterns() {
   return ({ "", (: cmd(0) :),
             "{brief|verbose}", (: cmd($4[0] == "brief") :) });
}
// --- END [/mnt/home2/grok/lib/cmds/player/upt_ime.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/liaison_s.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/liaison_s.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627157   Available: 13574511
Inodes: Total: 5242880    Free: 4960133
2699 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/liaison_s.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627157   Available: 13574511
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Id: liaison_s.c,v 1.4 2000/01/18 00:23:45 turrican Exp $
 */
inherit "/cmds/base";

private string idle_time(object person) {
  int hours, mins, secs;
  string s, m, h;

  secs = query_idle(person);
  mins = secs / 60;
  secs %= 60;
  hours = mins / 60;
  mins %= 60;
  s = ("0"+secs)[<2..<1];
  m = ("0"+mins)[<2..<1];
  if ( !hours )  {
    return " (idle: "+m+":"+s+")";
  }
  h = ("0"+hours)[<2..<1];
  return " (idle: "+h+":"+m+":"+s+")";
} /* idle_time() */

mixed cmd( ) {
   int i, j;
   string *members, *member_alias, *aliases;
   object person;
   
   members = (string *)"/d/liaison/master"->query_members();
   aliases = ({ });
   i = sizeof( members );
   while ( i-- ) {
      person = find_player( members[ i ] );
      if ( ! person ) {
         member_alias = "/d/liaison/master"->member_alias( members[ i ] );
         j = sizeof( member_alias );
         while ( j-- ) {
            if ( find_player( member_alias[ j ] ) ) {
               aliases += ({ capitalize( member_alias[ j ] ) +"("+
                     capitalize( members[ i ] ) +")" });
            }
         }
         members = delete( members, i, 1 );
      } else if (!person) {
          members = delete(members, i, 1);
      } else {
         if ( !interactive( person ) ) {
            members = delete( members, i, 1 );
         } else {
            members[ i ] = capitalize( members[ i ] );
            switch( person->query_invis()  )  {
            case 0:
               break;
            case 1:
               members[ i ] = sprintf( "(%s)", members[ i ] );
               break;
            case 2:
               members[ i ] = sprintf( "({%s})", members[ i ] );
               break;
            default:
               members[ i ] = sprintf( "([%s])", members[ i ] );
               break;
            }
            members[ i ] = capitalize( members[ i ] );
            if (person->query_busy()) {
               members[ i ] += " (busy)";
            }
            if ( query_idle( person ) > 120 )  {
               members[ i ] += idle_time( person );
            }
         }
      }
   }

   if ( this_player()->query_creator() || !sizeof( members )) {
      members += aliases;
   }
   if ( !sizeof( members ) ) {
      add_failed_mess( "There are no Liaison creators currently logged on.\n" );
      return 0;
   }

   if ( sizeof( members ) > 1 ) {
      write( "Liaison creators logged on are "+
            query_multiple_short( members ) +".\n" );
   } else {
      write( "The only Liaison creator logged on is "+ members[ 0 ] +".\n" );
   }
   return 1;
} /* cmd() */

mixed *query_patterns() {
   return ({ "", (: cmd() :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/player/liaison_s.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/friend_s.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/friend_s.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627156   Available: 13574510
Inodes: Total: 5242880    Free: 4960133
4872 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/friend_s.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627156   Available: 13574510
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This command will allow players to control their friends.
 * @author Pinkfish
 * @started Mon Mar 12 22:41:23 PST 2001
 */

inherit "/cmds/base";
#include <player.h>
#include <player_handler.h>

int cmd_display(string person, string pattern) {
   string* friends;
   string ret;

   if (person == "online") {
      friends = filter(this_player()->query_friends(), (: find_player($1) :));
   } else if (person != "") {
      person = this_player()->expand_nickname(person);
      if (!this_player()->is_friend(person)) {
         add_failed_mess(person + " is not your friend.\n");
         return 0;
      }
      friends = ({ person });
   } else {
      friends = this_player()->query_friends();
   }

   if (pattern) {
      if (regexp(pattern,
           "[\\[\\]\\(\\)\\*\\?\\+][\\[\\]\\(\\)\\*\\?\\+]+") ) {
         add_failed_mess("Bad pattern to alias.\n");
         return 0;
      }
      if (pattern[0] == '*' || pattern[0] == '+') {
         add_failed_mess("Cannot start a regular expression with a '*' or '+', "
                         "try: '.*' or '.+'.\n");
         return 0;
      }
      if (catch(regexp("test str", pattern))) {
         add_failed_mess("Pattern has an error in it, mismatched brackets?\n");
         return 0;
      }
      // Now we filter out the ones we don't want.
      foreach (person in friends) {
         if (!regexp(this_player()->query_friend_tag(person), pattern)) {
            friends -= ({ person });
         }
      }
      if (!sizeof(friends)) {
         add_failed_mess("The tag '" + pattern + "' did not exist "
                         "in your friends list.\n");
         return 0;
      }
   }

   if (!sizeof(friends)) {
     if(person == "online") {
       add_failed_mess("You do not have any friends online.\n");
     } else {
       add_failed_mess("You do not have any friends.\n");
     }
     return 0;
   }

   ret = "";
   foreach (person in sort_array(friends, 0)) {
      ret += "$I$5=" + capitalize(person) + ": " +
             this_player()->query_friend_tag(person) + "%^RESET%^\n";
   }
   write("$P$Friends$P$" + ret);
   return 1;
} /* cmd_display() */

int cmd_add(string person, string tag) {
   person = lower_case(person);
   person = this_player()->expand_nickname(person);

   if(person == this_player()->query_name()) {
     add_failed_mess("Are you really that lonely?\n");
     return 0;
   }
   
   if (!PLAYER_HANDLER->test_user(person)) {
      add_failed_mess(person + " does not exist.\n");
      return 0;
   }

   if (strlen(tag) > PLAYER_MAX_FRIEND_TAG_LEN) {
      add_failed_mess("Your tag for " + person + " is too long, the "
                      "maximum is " + PLAYER_MAX_FRIEND_TAG_LEN + ".\n");
      return 0;
   }

   if (!this_player()->is_friend(person)) {
      this_player()->add_friend(person, tag);
      add_succeeded_mess(({ "You add " + person + " with a tag of: " +
                            tag + "%^RESET%^.\n",
                            "" }));
   } else {
      this_player()->add_friend(person, tag);
      add_succeeded_mess(({ "You change " + person + "'s tag to: " +
                            tag + "%^RESET%^.\n",
                            "" }));
   }
   return 1;
} /* cmd_add() */

int cmd_remove(string person) {
   person = lower_case(person);
   person = this_player()->expand_nickname(person);
   if (!this_player()->is_friend(person)) {
      add_failed_mess("Sorry, " + person + " is not your friend to remove.\n");
      return 0;
   }

   this_player()->remove_friend(person);
   add_succeeded_mess(({ "You remove " + person + " from your friends list.\n",
                         "" }));
   return 1;
} /* cmd_remove() */

int cmd_clear() {
   write("This will clear all of your friends.  Are you sure you want to do "
         "this? ");
   input_to("clear_check");
   add_succeeded_mess("");
   return 1;
} /* cmd_clear() */

void clear_check(string str) {
   string friend;

   if (!strlen(str) || str[0] != 'y') {
      write("Ok, aborting.\n");
      return ;
   }

   foreach (friend in this_player()->query_friends()) {
      this_player()->remove_friend(friend);
   }
   write("Friend list cleared.\n");
} /* clear_check() */

mixed *query_patterns() {
   return ({ "<word'friend'>",
                (: cmd_display($4[0], 0) :),
             "",
                (: cmd_display("", 0) :),
             "list <string>",
                (: cmd_display("", $4[0]) :),
             "online",
                (: cmd_display("online", 0) :),
             "add <word'friend'>",
                (: cmd_add($4[0], "needs no introduction") :),
             "add <word'friend'> <string'tag'>",
                (: cmd_add($4[0], $4[1]) :),
             "remove <word'friend'>",
                (: cmd_remove($4[0]) :),
             "clear",
                (: cmd_clear() :),
             });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/player/friend_s.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/when.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/when.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627154   Available: 13574508
Inodes: Total: 5242880    Free: 4960133
1609 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/when.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627154   Available: 13574508
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*   -*- LPC -*-   */
/*
 * $Locker:  $
 * $Id: when.c,v 1.19 2003/04/10 06:05:44 ceres Exp $
 *
 *
 */

#include <login.h>

inherit "/cmds/base";

int cmd(string who)   {
   object player;
   int last;
   int caller;
   string* bits;
   string womble;
   int bing;

   bits = explode(who, ",");
   if (sizeof(bits) > 1) {
      bing = 0;
      foreach (womble in bits) {
         if (cmd(womble)) {
            bing = 1;
         }
      }
      return bing;
   }

   caller = this_player()->query_invis(); 
   who = this_player()->expand_nickname(lower_case(who));
   player = find_player( who );
   if (player &&
       (caller >= player->query_invis() ||
        reference_allowed(player, this_player()))) {
      if ( interactive( player ) ) {
         write( who + " has been on for " +
                   query_time_string(time() - player->query_last_log_on(), -1) +
                   ".\n");
      } else {
         write( who + " is currently net-dead.\n" );
      }
      return 1;
   } else {
      /* Should be a nice number.... */
      last = PLAYER_HANDLER->test_last(who);
      if ( last < 1 ) {
         return notify_fail( "Cannot find any record of $C$" + who + ".\n" );
      } else   {
         if (time() - last < 30) {
            write(who + " only just logged off.\n");
         } else {
            write(who + " last logged off " +
                  query_time_string(time() - last, -1) +
                  " ago.\n");
         }
         return 1;
      }
   }
}


mixed *query_patterns()   {
   return ({ "<string'player name'>", (: cmd( $4[0] ) :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/player/when.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/gchat.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/gchat.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627154   Available: 13574508
Inodes: Total: 5242880    Free: 4960133
4333 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/gchat.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627154   Available: 13574508
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: gchat.c,v 1.8 1999/06/21 09:10:39 tape Exp $
 * $Log: gchat.c,v $
 * Revision 1.8  1999/06/21 09:10:39  tape
 * This command is no longer used.  --Tape/21/06/99
 *
 * Revision 1.7  1998/10/27 02:52:45  gruper
 * Made the command ear muffable.
 *
 * Revision 1.6  1998/10/20 01:08:25  presto
 * Removed an extra space in the output messages
 *
 * Revision 1.5  1998/10/11 02:18:04  presto
 * Changed "You ask BlahGroup asking: ..." to "You ask BlahGroup: ..."
 *
 * Revision 1.4  1998/09/27 20:33:20  ceres
 * Added chats to players history
 *
 * Revision 1.3  1998/06/23 23:55:29  presto
 * Fixed something I stuffed up with the last fix. :-b
 *
 * Revision 1.2  1998/06/21 18:37:03  presto
 * fixed typo, added "in <language>" to "asking" messages
 *
 * Revision 1.1  1998/01/06 05:29:43  ceres
 * Initial revision
 * 
*/
#include <language.h>
#include <player.h>
#include <drinks.h>

inherit "cmds/base";
inherit "cmds/speech";

// This command is no longer used.  --Tape/21/06/99

#define TEAM_HANDLER "/obj/handlers/team"
#define TP this_player()

mixed cmd(string arg) {
  string word, cur_lang, group;
  object ob, *members, *earmuffed;

  return notify_fail( "This command is no longer used.  Please "
   "use \"group say\" instead.\n" );
   
  /* Don't allow someone with gchat ear muffed to use the command. */
  if( TP->check_earmuffs( "gchat" ) )
     return notify_fail( "You have gchat ear muffed.\n" );

  group = TEAM_HANDLER->query_group(this_player());
  if(!group)
    return notify_fail("You are not a member of any group.\n");
  
  if(!arg)
    return notify_fail("Syntax: gchat <message>\n");

  cur_lang = TP->query_current_language();
  
  if (!LANGUAGE_HAND->query_language_spoken(cur_lang))
    return notify_fail(capitalize(cur_lang)+" is not a spoken language.\n");
  
  if (!LANGUAGE_HAND->query_language_distance(cur_lang))
    return notify_fail(capitalize(cur_lang)+" is not able to spoken at a "
                       "distance.\n");
  
  word = query_word_type(arg, "");
  if (word != "")
    word = word + "ing";
  
  if (TP->query_volume(D_ALCOHOL))
    arg = drunk_speech(arg);
  
  if(function_exists("mangle_tell", environment(TP)))
    arg = environment(TP)->mangle_tell(arg, ob, 0);
  
  /* Who's a member of the group? */
  members = TEAM_HANDLER->query_members(group);
  members -= ({ this_player() });

  /* Check that the group has members. (Strange Phenomenon(tm)?)
   * This check wasn't made when word == asking - was this intentinal? */
  if ( !members ) {
    TEAM_HANDLER->leave_group( group, this_player() );
    TEAM_HANDLER->end_group( group );
    write( "Somehow your group has no members.  "
        "Your group has been ended.  "
        "I hope this is okay.\n" );
    return 1;
  }

  /* Remove people with gchat earmuffed from array of
   * people to give the message to. */
  earmuffed = ({ });
  foreach( ob in members ) {
    if( ob->check_earmuffs( "gchat" ) ) {
      earmuffed += ({ ob });
      members -= ({ ob });
    }
  }
  if( sizeof( earmuffed ) ) {
    write( capitalize( query_multiple_short( earmuffed ) ) +
        ( sizeof( earmuffed ) > 1 ? " have":" has" )+
        " gchat ear muffed.\n");
  }

  if( !sizeof( members ) ) {
    return notify_fail( "It seems you are the only one listening to "
          "this channel.\n" );
  } else if(word != "asking") {

    if( word != "" )
      word = " "+ word;

    foreach(ob in members) {
      if ( ob && interactive( ob ) )
        ob->event_person_tell(TP, capitalize((string)TP->query_name())+
                              " tells "+ group + word +": ", arg,
                              cur_lang );
    }
    if(cur_lang != "common")
      word += " in "+cur_lang;
 
    my_mess("You tell "+ group + word +": ", arg);
    TP->add_tell_history( "You tell "+ group + word + ": ", arg );
  } else {
    foreach(ob in members) {
      if ( ob && interactive( ob ) )
        ob->event_person_tell(TP, capitalize((string)TP->query_name())+
                              " asks "+group+": ", arg, cur_lang );
    }
    if(cur_lang != "common")
      word = " in "+ cur_lang;
    else word = "";
 
    my_mess( "You ask "+ group + word +": ", arg);
    TP->add_tell_history( "You ask "+ group + word + ": ", arg );
  }
  TP->adjust_time_left(-5);
  return 1;
}

// --- END [/mnt/home2/grok/lib/cmds/player/gchat.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/sea_rch.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/sea_rch.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627153   Available: 13574507
Inodes: Total: 5242880    Free: 4960133
6681 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/sea_rch.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627153   Available: 13574507
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: sea_rch.c,v 1.20 2003/07/15 08:01:01 pinkfish Exp $
 * $Log: sea_rch.c,v $
 * Revision 1.20  2003/07/15 08:01:01  pinkfish
 * Fix up some bits.
 *
 * Revision 1.19  2003/04/12 21:33:44  ceres
 * Added pk_assist() check
 *
 * Revision 1.18  2003/01/01 23:14:32  drakkos
 * Fixed up the pluralisation of the messages and also replaced the 'ennui' part with something that makes more sense and doesn't make assumptions of the player.
 *
 * Revision 1.17  2002/10/24 14:24:40  danbala
 * Changed the rather ungainly fail-due-to-lack-of-gp-message.
 * (Thanks, Carmine)
 *
 * Revision 1.16  2001/12/08 14:30:04  drakkos
 * Changed the GP fail message to be a little more IC
 *
 * Revision 1.15  2001/11/08 07:03:34  pinkfish
 * Make it use up some gp.
 *
 * Revision 1.14  2001/03/09 22:50:22  pinkfish
 * Fix up a typo.
 *
 * Revision 1.13  2000/02/10 05:16:22  pinkfish
 * Make a check for combat after they have searched.
 *
 * Revision 1.12  2000/01/21 00:33:20  pinkfish
 * Fix up a syntax error.
 *
 * Revision 1.11  2000/01/21 00:32:47  pinkfish
 * Allow just a search to work.
 *
 * Revision 1.10  2000/01/21 00:32:04  pinkfish
 * Add in the here stuff...
 *
 * Revision 1.9  2000/01/21 00:21:12  pinkfish
 * Hopefully make search give back correct error messages.
 *
 * Revision 1.8  1999/10/25 23:06:09  pinkfish
 * Some fixes to make things look better.
 *
 * Revision 1.7  1999/08/29 06:48:07  pinkfish
 * Make it so you cannot search a room while fighting someone.
 *
 * Revision 1.6  1999/08/16 01:12:26  presto
 * Fixed message problem when multiple people search at the same time.  Used to say "Womble and frog searches around the place."
 *
 * Revision 1.5  1999/07/26 14:40:00  wodan
 * check if hide_invis is a mapping before taking the keys.
 *
 * Revision 1.4  1999/05/07 09:16:24  pinkfish
 * Stop ghosts from searching.
 *
 * Revision 1.3  1999/04/05 23:06:41  ceres
 * Modified to use perform_task
 *
 * Revision 1.2  1999/01/14 23:20:26  ceres
 * made it give the results _after_ the search
 *
 * Revision 1.1  1998/01/06 05:29:43  ceres
 * Initial revision
 * 
*/
#include <tasks.h>
#include <player.h>

inherit "/cmds/base";

#define SKILL "other.perception"

#define GP_COST 15

nosave mapping callouts = ([]);

int cmd(string str) {
   if (this_player()->query_specific_gp("other") < GP_COST) {
      add_failed_mess("You are too weary to complete a "
                      "proper search of your surroundings.\n");
      return 0;
   }

   if (this_player()->query_property("dead")) {
      add_failed_mess("Ghosts cannot search!\n");
      return 0;
   }

   if (sizeof(filter(this_player()->query_attacker_list(),
                     (: environment($1) == environment(this_player()) :)))) {
      add_failed_mess("You cannot search, you are in combat!\n");
      return 0;
   }

   /* This command takes four rounds. */
   this_player()->adjust_time_left( -ROUND_TIME * 4 );
   
   if (callouts[this_player()->query_name()]) {
      remove_call_out(callouts[this_player()->query_name()]);
   }
   
   callouts[this_player()->query_name()] =
      call_out("search_callout", 4*1, this_player(), str);
  
   this_player()->adjust_gp(-GP_COST); 
   write("You start to search around.\n");
   say(this_player()->the_short() + " $V$0=starts,start$V$ to search around.\n");
   return 1;
} /* cmd() */

void search_callout(object who, string str) {
   mapping hide_invis;
   int i;
   string *types;
   string* ground;
   mixed see;
   object *found, ob;

   if (who->query_fighting()) {
      write("Oops!  You appear to have entered combat and cannot "
            "finish searching.\n");
      return ;
   }
   
   if ( function_exists( "do_search", environment( who ) ) ) {
      i = (int)environment( who )->do_search( str );
      switch(i) {
      case 1:
         return;
      case 0:
         if(query_notify_fail())
            write(query_notify_fail());
         return;
      default:
         break;
      }
   }
   
   if(!str) {
      found = ({ });
      
      foreach(ob in all_inventory(environment(who))) {
         if(ob->query_visible(who) ||
            ob->query_creator() ||
            pk_assist(this_player(), ob))
           continue;

         hide_invis =  ob->query_hide_invis();
         if(mapp(hide_invis)) {
            types = m_indices( hide_invis );
         } else {
            types = ({});
         }
         if ( !sizeof( types ) ) {
            continue;
         }
         for ( i = 0; i < sizeof( types ); i++ ) {
            if ( hide_invis[ types[ i ] ][ 0 ] == who ) {
               continue;
            }
            see = hide_invis[ types[ i ] ][ 1 ];
            if ( intp( see ) ) {
               // coz they're searching its made easier to find stuff.
               see -= random(environment(who)->query_light());
               see /= 2;
               switch(TASKER->perform_task(who, SKILL, see, TM_FREE)) {
               case AWARD:
                  write("%^YELLOW%^"+
                        ({"You feel very perceptive", "You realise "
                             "something new about searching"})[random(2)]+
                             "%^RESET%^.\n");
               case SUCCEED:
                  found += ({ ob });
                  ob->remove_hide_invis(types[i]);
                  break;
               }
               break;
            }
         }
      }
   }
   
   if(sizeof(found)) {
      write("You search around and find "+query_multiple_short(found)+".\n");
   } else {
      ground = environment(who)->query_default_search_description();
      if (!ground) {
         write( ({
         "You search around for a while, but don't find anything.\n",
         "You scrounge around.  The ground does look interesting, "
            "you decide.\n",
         "You look carefully at everything, but you find nothing.\n",
         "After an intense search, you find nothing.\n" })[ random( 4 ) ] );
      } else {
         write(ground[random(sizeof(ground))]);
      }
   }
   say("$one_short:" + file_name(who) + "$ $V$0=searches,search$V$ around the "
       "place a bit.\n" );
   event(environment(who), "player_search");
   map_delete(callouts, who->query_name());
   return;
} /* search_callout() */

void interrupt_search(object who) {
   if(callouts[who->query_name()]) {
      remove_call_out(callouts[who->query_name()]);
      tell_object(who, "You stop searching.\n");
      map_delete(callouts, who->query_name());
   }
} /* interrupt_search() */

mixed* query_patterns() {
   return ({ "<string>", (: cmd($4[0]) :),
             "here", (: cmd(0) :),
             "", (: cmd(0) :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/player/sea_rch.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/weigh.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/weigh.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627151   Available: 13574505
Inodes: Total: 5242880    Free: 4960133
4536 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/weigh.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627151   Available: 13574505
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: weigh.c,v 1.8 2003/03/25 19:46:47 presto Exp $
 * $Log: weigh.c,v $
 * Revision 1.8  2003/03/25 19:46:47  presto
 * Forcibly released due to inactivity
 *
 * Revision 1.7  2002/08/30 18:15:20  taffyd
 * typo fix. then->than
 *
 * Revision 1.6  2001/07/16 19:48:32  ceres
 * Fixed bug with group objects
 *
 * Revision 1.5  2001/06/08 02:27:40  presto
 * Added total weight thing
 *
 * Revision 1.4  1999/07/11 22:28:12  presto
 * fixed typo (added carriage return)
 *
 * Revision 1.3  1999/07/08 12:41:34  tape
 * changed to add_command() and some cleaning up
 *
 * Revision 1.2  1998/09/27 21:55:45  ceres
 * limited the number of things you can do at once to prevent over evaluation
 *
 * Revision 1.1  1998/01/06 05:29:43  ceres
 * Initial revision
 * 
*/

#define MAX_OBJECTS_AT_ONCE   5

string weight_string(int number);
int cmd(object *things, int brief);

string weight_string(int number) {
   number = (number + 4) / 9;
   switch (number) {
      case 0:
         return "uh oh";
      case 1:
         return "half a pound";
      case 2:
         return "a pound";
      case 3: 
         return "a pound and a half";
      case 4 .. 14 :
         return query_num((number + 1) / 2) + " pounds";
      case 15 .. 24:
         return "ten pounds";
      case 25 .. 34:
         return "fifteen pounds";
      case 35 .. 149:
         return query_num(((number + 10) / 20) * 10) + " pounds";
      case 150 .. 249:
         return "a hundred pounds";
      case 250 .. 349:
         return "a hundred and fifty pounds";
      case 350 .. 1499:
         return query_num(((number + 100) / 200) * 100) + " pounds";
      case 1500 .. 2499:
         return "a thousand pounds";
      case 2500 .. 2499:
         return "fifteen hundred pounds";
      case 3500 .. 14999:
         return query_num(((number + 1000) / 2000) * 1000) + " pounds";
      case 15000 .. 24999:
         return "ten thousand pounds";
      case 25000 .. 34999:
         return "fifteen thousand pounds";
      default:
         /* Detritus... */
         return query_num(((number + 10000) / 20000) * 10000) + " pounds";
   }
} /* weight_string() */


int cmd(object *things, int brief) {
   int     accuracy;
   int     weight;
   int     total = 0;
   string  results;
   object  thing;
   object *worn;
   object *wearing;

   if (sizeof(things) > MAX_OBJECTS_AT_ONCE)
   {
      return notify_fail("You cannot weigh that many things at once.\n");
   }
   
   accuracy = 9 + 89 / (1 + this_player()->query_dex());
   
   results = "";
   
   wearing = this_player()->query_wearing();
   worn = filter(things, (: member_array($1, $(wearing)) > -1 :));
   things -= worn;
   if (brief)  {
      foreach (thing in things)
         total += thing->query_complete_weight();
   }
   else foreach (thing in things)  {
      results += "You heft " + thing->the_short() +
                 " and guess that " +
        (thing->group_object() ? "they weigh " :
         thing->query_pronoun() + " weighs ");
      weight = thing->query_complete_weight();
      total += weight;

      if (4 * weight > accuracy)  {
         weight = (4 * weight + accuracy) / (2 * accuracy);
         results += "about " + weight_string(weight * accuracy) + ".\n";
      }
      else  {
         results += "less than " + weight_string(accuracy)+ ".\n";
      }
   }

   if (sizeof(worn))  {
      write("You are wearing " + query_multiple_short(worn, "the") +
             ".\n");
   }

   if (sizeof(things))  {
      if (!brief)  {
         write(results);
      }
      if (sizeof(things) > 1  ||  brief)  {
         if (4 * total > accuracy)  {
             total = (4 * total + accuracy) / (2 * accuracy);
             printf("The total weight is about " +
                    weight_string(total * accuracy) + ".\n");
         }
         else  {
             printf("The total weight is less than " +
                    weight_string(accuracy) + ".\n");
         }
      }
      tell_room(environment(this_player()),
                this_player()->one_short() + " hefts " +
                query_multiple_short(things) + (sizeof(things) > 1 ?
                " one at a time to see how much they weigh" :
                " to see how much it weighs" ) + ".\n",
                ({ this_player() }));
   }
   
   return 1;

} /* cmd() */


mixed *query_patterns()
{
   return ({ "<indirect:object:me'item(s)'>", (: cmd($1, 0) :),
             "<indirect:object:me'item(s)'> brief", (: cmd($1, 1) :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/player/weigh.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/typo.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/typo.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627149   Available: 13574503
Inodes: Total: 5242880    Free: 4960133
659 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/typo.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627149   Available: 13574503
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: typo.c,v 1.2 1998/04/16 12:52:49 pinkfish Exp $
 * $Log: typo.c,v $
 * Revision 1.2  1998/04/16 12:52:49  pinkfish
 * Update to use the new report base inhertiable command.
 *
 * Revision 1.2  1998/02/28 02:47:28  presto
 * fixed destination directory for virtual object bugreps
 *
 * Revision 1.1  1998/01/06 05:29:43  ceres
 * Initial revision
 *
 */
/**
 * Does this nice bug reporting for the players.  Uses a neato
 * base object whizz bang thing now.
 * @author Pinkfish
 */

inherit "/cmds/report_base";

void create() {
   ::create();
   set_error_type("TYPO");
   set_use_last_error(0);
} /* create() */
// --- END [/mnt/home2/grok/lib/cmds/player/typo.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/identify.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/identify.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627149   Available: 13574503
Inodes: Total: 5242880    Free: 4960133
2134 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/identify.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627149   Available: 13574503
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: identify.c,v 1.11 2003/07/15 08:00:19 pinkfish Exp $
 * 
 */
#define EFFECT "/std/effects/object/identity_hold"

inherit "/cmds/base";

mixed cmd(object *indirect_obs, string new_name)
{
   string  word;
   object  thing;
   object *things;
   int *ees;
   int keep;

   if (!new_name)  {
      things = filter(indirect_obs, (: $1->query_identifier() :));
      if (!sizeof(things))  {
         if (sizeof(indirect_obs) > 1) {
            write("You do not have any of those objects identified.\n");
         } else {
            write("You do not have " + indirect_obs[0]->the_short() +
                  " identified.\n");
         }
      } else foreach (thing in things)  {
         write("You have " + thing->the_short() + " identified as \"" +
               thing->query_full_identifier() + "\".\n");
      }
   } else if (sizeof(indirect_obs) == 1)  {
      // Create the effect and set it up...
      word = lower_case(new_name);
      if (word == "none") {
         // Remove the effect.
         ees = indirect_obs[0]->effects_matching(EFFECT->query_classification());
         if (!sizeof(ees)) {
            add_failed_mess("No identities to remove.");
            return 0;
         }
         keep = indirect_obs[0]->query_keep();
         indirect_obs[0]->delete_effect(ees[0]);
         if (keep) {
            thing->add_effect( EFFECT, ([ "keep" : 1 ]) );
         }
         // Readd it if the keep is needed.
         write("You remove the description from " +
               indirect_obs[0]->the_short() + ".\n");
      } else {
         indirect_obs[0]->add_effect(EFFECT, ([ "identity" : word ]));
         write(indirect_obs[0]->the_short() + " may now be identified as \"" +
               word + "\".\n");
      }
   } else {
      write("You may only identify one thing at a time.\n");
   }

   return 1;
} /* cmd() */

mixed *query_patterns() {
   return ({ "<indirect:object:me'object'> as <string'some new name'>",
             (: cmd($1, $4[1]) :),
             "<indirect:object:me'object(s)'>",
             (: cmd($1, 0) :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/player/identify.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/lockout.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/lockout.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627148   Available: 13574502
Inodes: Total: 5242880    Free: 4960133
3437 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/lockout.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627148   Available: 13574502
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * Lockout - lets a player suspend themselves from the MUD.
 * @author Ceres
 */
#include <player_handler.h>
#include <playerinfo.h>

inherit "/cmds/base";

nosave mapping info = ([ ]);


private int cmd(int tim, string type, string reason, int use_alts) {
   string p1;
   string* alts;

   if (this_player() != this_player(1))
    return 0;

   if(type[<1] != 's')
      type += "s";

  switch (type) {
   case "days":
      tim *= 24;
      break;

   case "weeks":
      tim *= 24 * 7;
    break;
   case "hours":
     tim = tim;
     break;
      
   default:
      return notify_fail("Invalid time.\n");
  }

  if (tim > 24 * 31) {
    return notify_fail( "You can't lock yourself out for more than "
                        "one month!\n" );
  }

  if(sizeof(reason) > 80) {
    return notify_fail("Reason cannot be more than 80 characters.\n");
  }

   if (use_alts) {
      p1 = PLAYERINFO_HANDLER->query_alt_of(this_player()->query_name());

      alts = (string*)PLAYERINFO_HANDLER->query_alts(this_player()->query_name()) |
             (string*)PLAYERINFO_HANDLER->query_alts(p1) |
             ({ this_player()->query_name() });
   } else {
      alts = ({ this_player()->query_name() });
   }


  info[this_player()->query_name()] = ({ tim, reason, alts });
  write("This will lockout " + query_multiple_short(alts) + ".\n");
  write("Enter your password: ");
  input_to("get_pw", 1, this_player());
  return 1;
}

int get_pw(string pass, object player) {
   int tim;

  if (!PLAYER_HANDLER->test_password(player->query_name(), pass)) {
    write("\nSorry, incorrect password.\n");
    return 0;
  }

   if(!info[player->query_name()]) {
      write("\nSomething went wrong, please try again.\n");
      return 0;
   }
   
  tim = info[player->query_name()][0];
  if (tim < 24) {
    write("\nYour lockout will last " + tim  + " hour" +
          (tim == 1 ? "" : "s" ) + ".  It cannot be " + 
          "undone.  Are you completely sure you wish to continue?\n");
  } else {
    write("\nYour lockout will last " + tim / 24 + " day" +
          ((tim / 24) == 1 ? "" : "s" ) + ".  It cannot be " + 
          "undone.  Are you completely sure you wish to continue?\n");
  }
  input_to("confirm", 0, this_player());
  return 1;
}

int confirm(string yesno, object player) {
   int tim;
   string reason;
   string* alts;
   string name;

   if (yesno[0] != 'y') {
      write("Ok, cancelling lockout...\n");
      write("Lockout cancelled.\n");
      return 1;
   }

   if(!info[player->query_name()]) {
      write("Something went wrong, please try again.\n");
      return 0;
   }
   tim = info[player->query_name()][0];
   reason = info[player->query_name()][1];
   alts = info[player->query_name()][2];

   foreach (name in alts) {
      if (!"/secure/bastards"->lockout_person(name,
                                           tim*60*60, reason)) {
         write("Sorry, we failed.\n");
         return 0;
      }
   }
   write("Ok, you are now locked out.  Quit when ready.\n");
   return 1;
}

// Answer the command patterns
mixed *query_patterns() {
   return ({ "<number'number of'> "
                     "<word'days|weeks|hours'> <string'reason'>",
                     (: cmd($4[0], $4[1], implode($4[2..], " "), 0 ) :),
             "alts <number'number of'> "
                     "<word'days|weeks|hours'> <string'reason'>",
                     (: cmd($4[0], $4[1], implode($4[2..], " "), 1 ) :) });
}
// --- END [/mnt/home2/grok/lib/cmds/player/lockout.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/hnew_bie.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/hnew_bie.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627147   Available: 13574501
Inodes: Total: 5242880    Free: 4960133
1095 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/hnew_bie.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627147   Available: 13574501
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*
 * $Locker:  $
 * $Id: hnew_bie.c,v 1.3 2000/12/02 22:53:31 pinkfish Exp $
 * $Log: hnew_bie.c,v $
 * Revision 1.3  2000/12/02 22:53:31  pinkfish
 * Add in atime to hnewbie.
 *
 * Revision 1.2  1999/08/29 08:11:38  ceres
 *  Forcibly unlocked by pinkfish
 *
 * Revision 1.1  1999/01/15 00:37:46  ceres
 * Initial revision
 *
 * 
*/

#include <player.h>

inherit "/cmds/guild_base";

#define HIST "/obj/handlers/hist_handler"

int cmd() {
  mixed *history;
  string result;
  
  history = HIST->query_chat_history("newbie");
  
  if ( !arrayp( history ) || !sizeof( history ) ) {
    tell_object(this_player(), "Nothing has been said on the newbie "
                "channel.\n");
  }
  else {
    result = "$P$Newbie Channel$P$";    
    result += implode(map(history, (: "$I$5=*" + ctime($1[2])[11..18] +
                                      "* $C$" + $1[0] + $1[1] + 
                                    "%^RESET%^" :)), "\n");    
    tell_object(this_player(), result);
  }
  
  return 1;
} /* cmd() */

mixed *query_patterns() {
  return ({ "", (: cmd() :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/player/hnew_bie.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/health.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/health.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627147   Available: 13574501
Inodes: Total: 5242880    Free: 4960133
3105 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/health.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627147   Available: 13574501
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: health.c,v 1.14 2003/07/08 05:57:33 pinkfish Exp $
 * $Log: health.c,v $
 * Revision 1.14  2003/07/08 05:57:33  pinkfish
 * Fix up to make sure people don't go out hiding.
 *
 * Revision 1.13  2003/02/21 03:45:22  pinkfish
 * Fix up an error in the logic.
 *
 * Revision 1.12  2003/02/21 03:21:48  pinkfish
 * Add in a 'wounded' setting.
 *
 * Revision 1.11  2000/09/01 01:59:04  presto
 * Fixed up mistake with my replace()...needed ({ }) around the strings
 *
 * Revision 1.10  2000/08/16 01:15:10  presto
 * Added coloring
 *
 * Revision 1.9  2000/08/12 14:13:51  presto
 *  Forcibly unlocked by terano
 *
 * Revision 1.8  2000/07/16 02:27:54  presto
 * Fixed up the messages a bit, so that when you health yourself, it looks right
 *
 * Revision 1.7  2000/07/15 06:16:15  pinkfish
 * Remove the 5 restriction.
 *
 * Revision 1.6  2000/07/13 00:30:28  pinkfish
 * Make it tell someone their health is being c hecked out and also limit it
 * to 5 people.
 *
 * Revision 1.5  2000/07/13 00:29:09  pinkfish
 * Stop people getting the health of everyone at once.
 *
 * Revision 1.4  1999/10/25 23:06:09  pinkfish
 * Some fixes to make things look better.
 *
 * Revision 1.3  1999/05/17 21:15:39  pinkfish
 * Fix it up to work with offler.
 *
 * Revision 1.2  1998/09/27 20:35:00  ceres
 * Fixed dark messages
 *
 * Revision 1.1  1998/01/06 05:29:43  ceres
 * Initial revision
 * 
*/
// Health command by Ceres

inherit "cmds/base";

string *level_colors = ({ "", "%^BOLD%^%^RED%^", "%^RED%^", "%^YELLOW%^",
                          "%^CYAN%^", "" });
mixed cmd(object *who, int wounded) {
   object person;
   string health;
   int level;
   int found;

   if(this_player()->check_dark((int)environment(this_player())->
                                 query_light())) {
      add_failed_mess("You cannot see well enough to examine someone's "
                      "health.\n");
      return 0;
   }
    
   foreach(person in who) {
      health = person->health_string(1, ref level);
      if (this_player() == person) {
         health = replace(health, ({ "is ", "are ", "appears ", "appear " }));
      }
      if (health) {
         if (!wounded || level != 5) {
            write(level_colors[level] + "$C$" + person->one_short(1) + " " +
                  level_colors[level] + health + ".\n%^RESET%^");
            found++;
         }
      } else {
         write(person->one_short(1) + " is so unhealthy they have forgotten "
               "how healthy they are.\n");
      }
      if (person != this_player())
         tell_object(person, this_player()->the_short(1) + " appears to be "
                  "checking out all your wounds.\n");
   }

   if (wounded && !found) {
      add_failed_mess("Unable to find any wounded people.\n");
      return 0;
   }

   say(this_player()->one_short(1) + " studies " +
       query_multiple_short(who) + ".\n");
   return 1;
} /* cmd() */

mixed *query_patterns() {
  return ({ "<indirect:living>", (: cmd($1, 0) :),
            "wounded <indirect:living>", (: cmd($1, 1) :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/player/health.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/group.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/group.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627146   Available: 13574500
Inodes: Total: 5242880    Free: 4960133
10841 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/group.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627146   Available: 13574500
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <group_handler.h>
#include <function.h>
#include <player.h>

// Define IN_TESTING below if you want to restrict the usage of
// these commands only to creators, playtesters and test
// characters.

#undef IN_TESTING

// Define IN_STRICT_TESTING in addition to IN_TESTING if
// you wish only creators to be able to use the commands.

#undef IN_STRICT_TESTING

mixed *_patterns;
mapping _sub_commands;

class sub_command {
   // The verb is the key of the _sub_commands mapping.
   string file_name;         // Where the sub-command file is located
   mixed *data;         // This contains alternating elements of
                        // (string)command patterns and (function)
                        // function pointers to the command.
}


#if defined( IN_TESTING ) || defined( IN_STRICT_TESTING )
int allowed_to_use( object user );
#endif

void rehash_group_sub_commands();
void make_patterns_array();
mixed *query_patterns();

int group_command_control( string verb, mixed *indirect_obs,
   string dir_match, string indir_match, mixed *args, string pattern );

int do_help( string on_what );


void create() {
   rehash_group_sub_commands();
   make_patterns_array();
} /* create() */


/* This function reads the GROUP_SUB_CMDS_DIR for files matching
 * GROUP_SUB_CMDS_FILE_WILDCARD, loads them one by one, and extracts
 * information from them if they respond to the group sub command
 * signature function.
 */
void rehash_group_sub_commands() {

   mixed *files;                         // An array of the files in the dir.
   object cmd_object;                    // The active object being used.
   string dir, verb, file, pattern;      // Stuff to be extracted and shuffled
                                         // around.
   
   // flush the sub commands
   _sub_commands = ([ ]);
   
   dir = GROUP_SUB_CMDS_DIR;
   dir += GROUP_SUB_CMDS_FILE_WILDCARD;
   
   // read the group sub-command directory for command files
   files = get_dir( dir );
   
   // if there were no files found, stop
   if( !sizeof( files ) ) {
      return;
   }
   
   // iterate through the files and add data to the mapping
   foreach( file in files ) {

      // remove the file extension
      sscanf( file, "%s.%*s", file );
      
      // load the file or find it if it's already loaded
      cmd_object = load_object( ( GROUP_SUB_CMDS_DIR + file ) );
      
      if( !cmd_object ) {
         // can't be loaded.  Probably broken, so let's skip it.
         continue;
      }

      // if the file isn't a group sub-command file
      if( !cmd_object->query_group_sub_command_amount() ) {
         continue;
      }
      
      // find all verbs the command has declared and
      // iterate through them
      foreach( verb in cmd_object->query_group_sub_command_verbs() ) {

         // if this is an entirely new verb and not just an additional
         // pattern
         if( !_sub_commands[ verb ] ) {         
            // assign a new entry for it
            _sub_commands += ([ verb : new( class sub_command ) ]);
         }
         
         _sub_commands[ verb ]->data = ( mixed * )({ });
         _sub_commands[ verb ]->file_name = ( string )file_name( cmd_object );
         
         // fetch all the patterns for that verb
         foreach( pattern in
            cmd_object->query_group_sub_command_patterns( verb ) ) {
            
            // add the pattern and the corresponding command function to
            // the entry
            _sub_commands[ verb ]->data +=
               ({
               pattern,
               cmd_object->query_group_sub_command_function( verb, pattern )
               });

         }  // foreach pattern
      }  // foreach verb
   } // foreach file

} /* rehash_group_sub_commands() */


int group_command_control( string verb, mixed *indirect_obs,
   string dir_match, string indir_match, mixed *args, string pattern ) {
   
   int count, size;
   string cmd_pattern, mangled_pattern, group;
   function cmd_fun;
   object cmd_object;
   class sub_command info;

#if defined( IN_TESTING ) || defined( IN_STRICT_TESTING )
   if( !allowed_to_use( this_player() ) ) {
      return 0;
   }
#endif

   info = _sub_commands[ verb ];
   
   if( !info ) {
      printf( "ERROR: Command information for \"" + verb + "\""
         " not found.\n" );
      return 0;   
   }
   
   // find the right version of the command (there can be different
   // patterns for the same verb)

   if( pattern != verb ) {
      // means the command takes arguments -- let's get rid
      // of the verb name from the front
      sscanf( pattern, verb + " %s", mangled_pattern );
   }
   else {
      // means the command takes no arguments
      mangled_pattern = "";
   }
   
   size = sizeof( info->data );   

   for( count = 0; count < size; count += 2 ) {
      if( mangled_pattern == info->data[ count ] ) {
         // we now have a match on the verb and the pattern wanted.
         cmd_pattern = info->data[ count ];
         cmd_fun     = info->data[ count + 1 ];
         break;
      }
   }
   
   if( !cmd_pattern || !cmd_fun ) {
      printf( "ERROR: Correct version of \"" + verb + "\" not found.\n" );
      tell_creator( this_player(), "DEBUG: Verb: %s, pattern: %s\n",
         verb, pattern );
      return 0;
   }
   
   if( !cmd_object = load_object( info->file_name ) ) {
      // object's probably broken
      printf( "ERROR: Cannot load command \"" + verb + "\"!\n" );
      tell_creator( this_player(), "DEBUG: File name: %s\n", info->file_name );
      return 0;
   }   

   // if the command function's pointer has been destructed.. This happens
   // when the command object is unloaded after a period of unuse.
   if( functionp( cmd_fun ) & FP_OWNER_DESTED ) {   
      // try to re-acquire the pointer and update the entry as well
      info->data[ count + 1 ] = cmd_fun =
         cmd_object->query_group_sub_command_function( verb, cmd_pattern );         
   }
   
   // if the pointer couldn't be re-acquired
   if( !cmd_fun || !functionp( cmd_fun ) ) {
      printf( "ERROR: Could not find command function for verb " +
         "\"" + verb + "\".\n" );
      return 0;   
   }

   group = this_player()->query_group();
   
   // Check if the command requires this_player() to be a member of
   // a group.
   if( cmd_object->query_membership_required( verb, cmd_pattern ) > 0 ) {
      if( !group ) {
         return notify_fail( "You must be a member of a group in order "
            "to use this command.\n" );
      }
   }
   
   // Check if the command requires the command user to be the leader
   // of the group.
   if( cmd_object->query_leadership_required( verb, cmd_pattern ) > 0 ) {
      if( GROUP->leader_of( group ) != this_player() ) {
         return notify_fail( "Only the leader of a group can use this "
            "command.\n" );
      }
   }
   
   // Call the command function on it and return what it returned
   
   // The parameters for it are identical to a normal add_command(),
   // with the exception of an additional one which designates the
   // command user's current group, if any.
   
   return evaluate( cmd_fun, indirect_obs, dir_match, indir_match,
      args, pattern, group );

} /* group_command_control() */


int do_help( string on_what ) {
   
   int top_left;
   string help, message;
   object command;
   
   on_what = lower_case( on_what );

#if defined( IN_TESTING ) || defined( IN_STRICT_TESTING )
   if( !allowed_to_use( this_player() ) ) {
      return 0;
   }
#endif

   if( on_what == "help" ) {
      // "group help help"
      return notify_fail( "To get help on a command, use \"group help <sub-"
         "command>\".  That is, if you wanted to get help on the command "
         "\"group create <name>\", you would type \"group help create\".\n" );
   }
   
   // such a sub-command doesn't exist
   if( !_sub_commands[ on_what ] ) {
      return notify_fail( "There is no sub-command called \"" + on_what +
         "\".\n" );
   }

   command = load_object( _sub_commands[ on_what ]->file_name );
   
   if( !command ) {
      tell_creator( this_player(), "Alleged file name: %s\n",
         _sub_commands[ on_what ]->file_name );
      return notify_fail( "ERROR: Cannot find or load sub-command "
         "\"" + on_what + "\".\n" );
   }
   
   help = command->query_help_string_for( on_what );
   
   if( !help ) {
      return notify_fail( "No help found for sub-command \"" + on_what +
         "\".\n" );
   }
   
   top_left = this_player()->query_cols();
   
   message = sprintf(
      "\n%' '|*s\n"
      "%' '-=*s\n",
      top_left, "Help on sub-command \"" + on_what + "\":\n",
      top_left, help );
   
   this_player()->more_string( message );
   
   return 1;
   
} /* do_help() */


/* This function parses all defined group subcommand classes into
 * a form that the parser understands.  I.e. one that can be
 * returned with query_patterns()
 */
void make_patterns_array() {

   int count, size;
   string verb, pattern;
   class sub_command command;

   // flush the patterns
   _patterns = ({ });

   // Establish a separate command for the help thingie.
   _patterns += ({
      "help <word'sub-command'>", (: do_help( $4[ 0 ] ) :) });
      
   // iterate through the commands   
   foreach( verb, command in _sub_commands ) {

      // get the verb and the pattern from the command
      // and stick them into a pattern entry to the
      // group command controller.
   
      size = sizeof( command->data );
      
      // multiple patterns for one verb?  Certainly possible.
      for( count = 0; count < size; count += 2 ) {

         // these checks are to ensure things' not breaking
         // if a verb doesn't take any arguments

         if( sizeof( command->data[ count ] ) ) {
            pattern = verb + " " + command->data[ count  ];
         }
         else {
            pattern = verb;
         }
      
         _patterns += ({
            pattern, (: group_command_control( $( verb ), $1, $2, $3, $4,
               $5 ) :) });
      }   
   }
} /* make_patterns_array() */


mixed *query_patterns() {
   return _patterns;   
} /* query_patterns() */


#if defined( IN_TESTING ) || defined( IN_STRICT_TESTING )
int allowed_to_use( object user ) {
#endif

#ifdef IN_STICT_TESTING
   if( !user->query_creator() ) {
      tell_object( user, "You are not allowed to use this feature at this "
         "time.\n" );
      return 0;
   }
#endif

#ifdef IN_TESTING
   if( !PLAYTESTER_HAND->query_tester( user ) ) {
      tell_object( user, "You are not allowed to use this feature at this "
         "time.\n" );
      return 0;
   }
#endif

#if defined( IN_TESTING ) || defined( IN_STRICT_TESTING )
   return 1;
} /* allowed_to_use() */
#endif


// Debug.
mapping dump_info() { return _sub_commands; }
mixed *dump_patterns() { return _patterns; }

// --- END [/mnt/home2/grok/lib/cmds/player/group.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/users.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/users.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627143   Available: 13574497
Inodes: Total: 5242880    Free: 4960133
3497 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/users.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627143   Available: 13574497
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: users.c,v 1.4 2001/03/23 05:15:32 ceres Exp $
 * $Log: users.c,v $
 * Revision 1.4  2001/03/23 05:15:32  ceres
 * Added morestring
 *
 * Revision 1.3  2001/02/01 17:30:43  pinkfish
 * Fix up some bugs.
 *
 * Revision 1.2  1998/04/14 02:47:44  pinkfish
 * Changed to use add_command.
 *
 * Revision 1.1  1998/01/06 05:29:43  ceres
 * Initial revision
 * 
*/
inherit "/cmds/base";

#include <login_handler.h>

int cmd() {
  int players, logins, login_q, first, creators, total;
  string output, *str, *logins_n;
  object pl;

  str = ({ });
  foreach(pl in users()) {
/* This is done in users() now.
    switch((int)pl->query_invis()) {
      case 2:
        if(!"/secure/master"->high_programmer(geteuid(this_player())))
          break;
      case 1:
        if(!this_player()->query_creator())
          break;
      default:
*/
    if (pl->query_login_ob())
      logins++;
    else {
      str += ({ pl->query_cap_name() });
      if (pl->query_creator())
        creators++;
      else
        players++;
    }
/*
        break;
    }
*/
  }

  logins_n = map(LOGIN_HANDLER->query_login_queue(),
                 (: $1->query_cap_name() :));
  logins_n = filter(logins_n, (: $1 :));
  logins_n = sort_array(logins_n,
                        (: strcmp(lower_case($1), lower_case($2)) :));
  login_q = sizeof(logins_n);
  if (login_q > 0) {
    first = 0;
    if (login_q > 1)
      write(sprintf(login_q+" currently queued: %-=*s\n",
                    this_player()->query_cols()-17,
                    implode(logins_n[0..<2], ", ")+" and "+
                    logins_n[<1]));
    else
      write(sprintf("Currently Queued: %-=*s\n",
                    this_player()->query_cols()-19,
                    logins_n[0]));
  }
  
  output = "There ";
  
  first = 1;
  if (creators > 0) {
    if (first)
      if (creators == 1)
        output += "is ";
      else
        output += "are ";
    if (creators == 1)
      output += "one creator";
    else
      output += creators +" creators";
    first = 0;
    if (logins - login_q > 0)
      output += ", ";
    else
      if ( !players )
        output += " logged on.\n";
      else
        output += " and ";
  }
  
  if (logins - login_q > 0) {
    if (first)
      if (logins - login_q == 1)
        output += "is ";
      else
        output += "are ";
    if (logins - login_q == 1)
      output += "one person logging in";
    else
      output += ( logins - login_q ) +" people logging in";
    first = 0;
    if ( !players )
      output += ".\n";
    else
      output += " and ";
  }

  if ( players ) {

    if (first)
      if (players == 1)
        output += "is ";
      else
        output += "are ";
    if (players == 1)
      output += "one player ";
    else
      output += players +" players ";
    
  }

  total = sizeof(users());
  output += "a total of "+ sizeof(users()) + " people logged on.\n";

  write( output );

  str = filter(str, (: $1 :));
  str = sort_array(str, (: strcmp(lower_case($1), lower_case($2)) :));
  login_q = sizeof(logins_n);
  if (sizeof(str) > 1) {
    this_player()->more_string(sprintf("Currently logged on: %-=*s\n",
                  this_player()->query_cols()-24,
                  implode(str[0..<2], ", ")+" and "+
                  str[<1]), "Who", 1 );
  } else {
    write("Currently logged on: "+str[0]+".\n");
  }
  return 1;
} /* cmd() */

mixed *query_patterns() {
   return ({ "", (: cmd() :) });
}  /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/player/users.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/appraise.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/appraise.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627142   Available: 13574496
Inodes: Total: 5242880    Free: 4960133
6294 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/appraise.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627142   Available: 13574496
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * Appraise
 * For getting "obvious" physical characteristics of an object
 *
 * @author Dasquian
 * @started 7/8/02
 **/

#include <volumes.h>

int cmd(object *things);

/**
 * Converts a raw length into a useable string.
 */
string query_length_mess(int number) {
    int half_feet;
    
    switch(number) {
        case 0:
            return "not very";
        case 1:
            return "an inch";
        case 2:
            return "a couple of inches";
        case 3:
            return "three inches";
        case 4:
            return "four inches";
        case 5..7:
            return "about six inches";
        case 8..10:
            return "about nine inches";
        case 11..14:
            return "about a foot";
        case 15..21:
            return "about a foot and a half";
        case 22..27:
            return "about two feet";
        case 28..33:
            return "about two and a half feet";
        default:
            half_feet = (number + 3)/6;
            if( half_feet%2 ) {
                return "about " + query_num(half_feet/2) + " and a half feet";
            }
            else {
                return "about " + query_num(half_feet/2) + " feet";
            }
    }

} /* query_length_mess() */

string query_dimensions_mess(object thing) {
    return "is " + query_length_mess(thing->query_length()) + " long and " + 
        query_length_mess(thing->query_width()) + " wide.";
} /* query_dimensions_mess() */

string query_appearance_mess(object thing) {
    string material_mess;
    
    if( !sizeof(thing->query_materials()) ) {
        material_mess = "some unidentifiable material";
    }
    else {
        material_mess = query_multiple_short(thing->query_materials());
    }

    if(thing->query_colour()) {
        return "is " + thing->query_colour() + " and is made of " + 
            material_mess;
    }
    else {
        return "is made of " + material_mess;
    }
    
} /* query_appearance_mess() */


string query_type_mess(object thing) {

    if( thing->query_plant() ) {
        return "appears to be some sort of plant";
    }

    if( thing->query_food_object() ) {
        if( thing->query_liquid() ) {
            return "looks drinkable";
        }
        else {
            return "looks edible";
        }
    }

    if( thing->query_furniture() ) {
        return "could be placed as furniture";
    }

    if( thing->query_property("shop type") == "jewellers" ) {
        return "appears to be a piece of jewellery";
    }

    if( thing->query_weapon() ) {
        return "could be used as a weapon";
    }
    
    if( thing->query_armour() && thing->query_wearable()) {
        return "could be worn as armour";
    }
    
    if( thing->query_wearable() ) {
        return "looks like you could wear it";
    }   

    if (thing->query_no_limbs() > 0) {
        return "looks like you could hold it";
    }
    
    return 0;
    
} /* query_type_mess() */

/**
 * Give some descriptions about how much stuff the container can hold.
 */
string query_container_mess(object thing) {
   int volume;
   int size;
   string str;

   volume = thing->query_max_volume();
   if (thing->query_container()) {
      size = thing->query_max_size();
   }

   if (size || volume) {
      str = "";
      if (size) {
         str += "can hold about " + (size / 9) + " pounds";
      }
      if (volume) {
         if (size) {
            str += " and ";
         }
         str += "can hold about ";
         if (volume > VOLUME_GALLON) {
            str += ((volume + VOLUME_GALLON / 2) / VOLUME_GALLON) + " gallons";
         } else if (volume >= VOLUME_QUART) {
            str += ((volume + VOLUME_QUART / 2) / VOLUME_QUART) + " quarts";
         } else if (volume >= VOLUME_PINT) {
            str += ((volume + VOLUME_PINT / 2) / VOLUME_PINT) + " pints";
         } else if (volume >= VOLUME_GILL) {
            str += ((volume + VOLUME_GILL / 2) / VOLUME_GILL) + " gills";
         } else if (volume >= VOLUME_SHOT) {
            str += ((volume + VOLUME_SHOT / 2) / VOLUME_SHOT) + " shots";
         } else {
            str += "nothing";
         }
      }
      return str;
   }
   return 0;
}


int cmd(object *things) {
    object thing;
    string mess;
    string tmp;

    if(!sizeof(things)) {
        add_failed_mess("For some reason, you "
            "have nothing to appraise.  Please bugrep this.\n", ({ }) );
        return 0;
    }

    if(sizeof(things) > 1) {
        add_failed_mess("You cannot appraise "
            "more than one object at once.\n", ({ }) );
        return 0;
    }

    if (thing == this_player()) {
        if (this_player()->query_name() == "penguin") {
           write("Is that a tuxuedo you are wearing?  No, probably not.\n");
        } else {
           write("You appraise yourself.  " + (random(10) + 1) + " out of 10.\n");
        }
        return 0;
    }

    thing = things[0];

    if(environment(thing) != this_player()) {
        add_failed_mess("You cannot appraise "
            "objects you are not carrying.\n", ({ }) );
        return 0;
    }

    if(living(thing)) {
        write("You appraise " + thing->the_short() + " and mmmm, very "
            "sexy.\n");
        return 1;
    }
    
    if(thing->query_worn_by()) {
        add_failed_mess("You cannot appraise "
            "$I while you are wearing it.\n", ({ thing }) );
        return 0;        
    }

    if( !thing->query_clothing() ) {
        mess = thing->the_short() + " " + query_dimensions_mess(thing);
        mess += "  ";
    }
    else {
        mess = "";
    }
    
    tmp = query_type_mess(thing);
    if(tmp) {
        mess += "It " + query_appearance_mess(thing);
        mess += " and " + tmp + ".";
    }
    else {
        mess += "It " + query_appearance_mess(thing) + ".";
    }

    tmp = query_container_mess(thing);
    if (tmp) {
       mess += "  It " + tmp + ".";
    }
    
    
    if(thing->cond_string() && thing->cond_string() != "") {
        mess += "  " + thing->cond_string();
    }
    else {
        mess += "\n";
    }
    
    write("$P$Appraise$P$" + mess );

    add_succeeded_mess("");
    return 1;

} /* cmd() */


mixed *query_patterns() {
    return ({ "<indirect:object:me-here'item'>", (: cmd($1) :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/player/appraise.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/options.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/options.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627140   Available: 13574494
Inodes: Total: 5242880    Free: 4960133
5796 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/options.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627140   Available: 13574494
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This command will allow the player to control their various options.
 * @author Pinkfish
 * @started Thu Jun  8 18:10:16 PDT 2000
 */

inherit "/cmds/base";
#include <cmds/options.h>

int cmd_set(string option, string value);

int cmd_display(string option) {
   string *bits;
   string *groups;
   string bing;

   if (sscanf(option, "%s=%s", option, bing) == 2) {
      return cmd_set(option, bing);
   }

   if (OPTION_HANDLER->is_option(this_player(), option)) {
     write(sprintf("%-20s = %s (%s)\n", option,
                   OPTION_HANDLER->query_option_value(this_player(), option),
                   OPTION_HANDLER->query_option_help(this_player(),option)));
      return 1;
   } else if (OPTION_HANDLER->is_option_group(this_player(), option)) {
      bits = OPTION_HANDLER->query_sub_options(this_player(), option);
      if (option == "") {
         write("Top level:\n");
      } else {
         write(option + ":\n");
      }
      bits = sort_array(bits, (: strcmp :));
      groups = filter(bits, (: OPTION_HANDLER->is_option_group(this_player(),
                                               $2 + " " + $1) :), option);
      bits -= groups;
      foreach (bing in groups) {
         write(sprintf("   %-17s <more options>\n", bing));
      }
      foreach (bing in bits) {
         if (OPTION_HANDLER->is_option(this_player(), option + " " + bing)) {
            write(sprintf("$I$30=   %-17s = %-10s <%s>\n", bing,
                    OPTION_HANDLER->query_option_value(this_player(),
                                                     option + " " + bing),
                    implode(OPTION_HANDLER->query_option_values(this_player(),
                                        option + " " + bing), "|")));
            //              write(sprintf("$I$30=   %-70s\n", OPTION_HANDLER->
            //query_option_help(this_player(),option + " " +
            //bing)));
         }
      }
      return 1;
   } else {
      add_failed_mess("There is no option " + option + ".\n");
      return 0;
   }
} /* cmd_display() */

int cmd_set_all(string option, string value) {
   string* stuff;
   string* ok;
   string* bad;
   string opt;

   if (!OPTION_HANDLER->is_option_group(this_player(), option)) {
      add_failed_mess("The option must be an option group to use the 'all' "
                      "keywork.\n");
      return 0;
   }

   stuff = OPTION_HANDLER->query_sub_options(this_player(), option);
   option += " ";
   ok = ({ });
   bad = ({ });
   foreach (opt in stuff) {
      if (OPTION_HANDLER->is_option(this_player(), option + opt)) {
         if (OPTION_HANDLER->set_option_value(this_player(), option + opt,
                                              value)) {
            ok += ({ option + opt });
         } else {
            bad += ({ option + opt });
         }
      } else {
         bad += ({ option + opt });
      }
   }

   if (sizeof(ok)) {
      add_succeeded_mess("Set " + query_multiple_short(ok) + " to " +
                         value + ".\n");
      return 1;
   }

   add_failed_mess("Unable to set " + query_multiple_short(bad) + " to " +
                   value + ".\n");
   return 0;
} /* cmd_set_all() */

int cmd_set(string option, string value) {
   string *bits;

   //
   // if the last bit is "all" then we allow option groups.
   //
   if (!option  ||  option == "")
      return 0;
   bits = explode(option, " ");
   if(!sizeof(bits))
     return 0;
   
   if (bits[<1] == "all") {
      if (sizeof(bits) > 1) {
         return cmd_set_all(implode(bits[0..<2], " "), value);
      }
      add_failed_mess("Cannot use 'all' as an option by itself.\n");
      return 0;
   }

   if (OPTION_HANDLER->is_option(this_player(), option)) {
      if (OPTION_HANDLER->set_option_value(this_player(), option, value)) {
         write("Set option " + option + " to " +
                OPTION_HANDLER->query_option_value(this_player(), option) +
                ".\n");
         return 1;
      } else {
         add_failed_mess("Unable to set option " + option + " to " +
                value +
                ".\n");
         return 0;
      }
   } else {
      add_failed_mess("There is no option " + option + ".\n");
      return 0;
   }
} /* cmd_set() */

int cmd_edit(string option) {
   string value;

   //
   // if the last bit is "all" then we allow option groups.
   //
   if (OPTION_HANDLER->is_option(this_player(), option)) {
      value = OPTION_HANDLER->query_option_value(this_player(), option);
      write("Editing the option " + option + ".\n");
      this_player()->do_edit(value, "finish_edit", this_object(),
                             0, option);
      return 1;
   } else {
      add_failed_mess("There is no option " + option + ".\n");
      return 0;
   }
} /* cmd_set() */

void finish_edit(string value, string option) {
   if (!value) {
      write("Aborting.\n");
      return ;
   }

   if (OPTION_HANDLER->set_option_value(this_player(), option, value)) {
      write("Set option " + option + " to " +
                OPTION_HANDLER->query_option_value(this_player(), option) +
                ".\n");
   } else {
      write("Unable to set the option " + option + ".\n");
   }
} /* finish_edit() */

mixed *query_patterns() {
   return ({ "<string'option'>",
               (: cmd_display($4[0]) :),
             "",
               (: cmd_display("") :),
             "edit <string'option'>",
                (: cmd_edit($4[0]) :),
             "<string'option'> = <word'value'>",
                (: cmd_set($4[0], $4[1]) :),
             "<string'option'> all = <word'value'>",
                (: cmd_set_all($4[0], $4[1]) :),
             "set <string'option'> all <string:quoted'value'>",
                (: cmd_set_all($4[0], $4[1]) :),
             });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/player/options.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/idea.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/idea.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627139   Available: 13574493
Inodes: Total: 5242880    Free: 4960133
659 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/idea.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627139   Available: 13574493
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: idea.c,v 1.2 1998/04/16 12:52:49 pinkfish Exp $
 * $Log: idea.c,v $
 * Revision 1.2  1998/04/16 12:52:49  pinkfish
 * Update to use the new report base inhertiable command.
 *
 * Revision 1.2  1998/02/28 02:47:28  presto
 * fixed destination directory for virtual object bugreps
 *
 * Revision 1.1  1998/01/06 05:29:43  ceres
 * Initial revision
 *
 */
/**
 * Does this nice bug reporting for the players.  Uses a neato
 * base object whizz bang thing now.
 * @author Pinkfish
 */

inherit "/cmds/report_base";

void create() {
   ::create();
   set_error_type("IDEA");
   set_use_last_error(0);
} /* create() */
// --- END [/mnt/home2/grok/lib/cmds/player/idea.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/xyzzy.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/xyzzy.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627138   Available: 13574492
Inodes: Total: 5242880    Free: 4960133
232 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/xyzzy.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627138   Available: 13574492
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* Gruper, Feb 26, 2000 */

#include <command.h>

inherit "/cmds/base";

mixed cmd() {
   write("Nothing happens.\n" );
   return 1;
} /* cmd() */

mixed *query_patterns() {
   return ({ "", (: cmd() :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/player/xyzzy.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/time.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/time.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627138   Available: 13574492
Inodes: Total: 5242880    Free: 4960133
1554 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/time.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627138   Available: 13574492
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: time.c,v 1.15 2003/03/02 23:37:42 pinkfish Exp $
 * 
 */
#include <localtime.h>
#include <dst.h>
#include <am_time.h>
#ifndef __DISTRIBUTION_LIB__
#include <special_day.h>
#endif
#include <config.h>

inherit "/cmds/base";

mixed *_timezones;

void show_mud_time();

void create() {
   mixed *time_rubbish;

   time_rubbish = localtime(time());
   _timezones = ({
      "Seattle", - time_rubbish[LT_GMTOFF] + (US_DST * 60 * 60),
      "Toronto", - time_rubbish[LT_GMTOFF] + (3 + CA_DST) * (60 * 60),
     "London", (UK_DST * 60 * 60),
      "Sydney", (10 + AUS_DST) * (60 * 60),
                 });
} /* create() */

mixed cmd( string word ) {
   mixed *time_rubbish;
   int i;
   string mess;

   time_rubbish = localtime(time());
   /* Figure out the gmt time. */
   mess = "";

   for (i = 0; i < sizeof(_timezones); i += 2) {
      mess += sprintf( "[%s in %-9s]\n", ctime(time() + time_rubbish[LT_GMTOFF] +
                                    _timezones[i + 1]), _timezones[i]);
   }

   //Something for creators.
   if ( this_player()->query_creator() )
      show_mud_time();

   write(mess);
   return 1;
} /* cmd() */

mixed *query_patterns() {
   return ({ "", (: cmd :) });
} /* query_patterns() */

void show_mud_time() {
#ifndef __DISTRIBUTION_LIB__
   string mess;
   string day = cap_words(SPECIAL_DAY_HANDLER->query_special_day());

   mess = sprintf( "In Ankh-Morpork, it is %s%s\n", amtime( time() ), 
           ( strlen(day) ? ".  Today is "+ day +".": ".") );
   write( mess );
#endif
}
// --- END [/mnt/home2/grok/lib/cmds/player/time.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/lang_uages.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/lang_uages.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627138   Available: 13574492
Inodes: Total: 5242880    Free: 4960133
902 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/lang_uages.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627138   Available: 13574492
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: lang_uages.c,v 1.1 1998/01/06 05:29:43 ceres Exp $
 * $Log: lang_uages.c,v $
 * Revision 1.1  1998/01/06 05:29:43  ceres
 * Initial revision
 * 
*/
#include <move_failures.h>
#include <language.h>

inherit "cmds/base";

#define TP this_player()

mixed cmd(object *obs, string indir, string str) {
   int i;
   string *langs;

   langs = LANGUAGE_HAND->query_languages();
   for (i = 0; i < sizeof(langs); i++) {
      if (TP->query_skill(
               LANGUAGE_HAND->query_language_spoken_skill(langs[i])) > 1 ||
          TP->query_skill(
               LANGUAGE_HAND->query_language_written_skill(langs[i])) > 1) {
      } else {
         langs = langs[0..i-1] + langs[i+1..];
         i--;
      }
   }

   write("You can currently speak " +( TP->query_womens_day()?"wommon":
                 implode(langs, ", ") ) +" and grunt.\n");
   return 1;
}

// --- END [/mnt/home2/grok/lib/cmds/player/lang_uages.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/components.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/components.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627137   Available: 13574491
Inodes: Total: 5242880    Free: 4960133
1622 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/components.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627137   Available: 13574491
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: components.c,v 1.1 2002/04/17 02:28:51 presto Exp $
 *
 *
 */

#define OBJ 0

inherit "/cmds/base";

int cmd( string spell_name ) {
  mapping spells = this_player()->query_spells_nocase();
  string spell_ob;
  string *consumed, *needed;
  string mess;

  if( !sizeof( spells ) ) {
    add_failed_mess( "You don't know any magic spells.\n" );
    return 0;
  }
  
  spell_name = this_player()->expand_nickname( spell_name );
  spell_name = capitalize( spell_name );

  if( !spells[ lower_case(spell_name) ] ) {
    add_failed_mess( "You don't know a spell named " + spell_name + 
        ".\n" );
    return 0;
  }
  
  spell_ob = spells[ lower_case(spell_name) ][ OBJ ];  
  consumed = spell_ob->query_consumables();
  needed   = spell_ob->query_needed();
  
  if( !sizeof( consumed ) && !sizeof( needed ) ) {
    mess = "You don't need anything to cast " + spell_name;
  } else if( sizeof( consumed ) ) {  
    mess = spell_name + " will consume " + query_multiple_short(
           consumed );
    if( sizeof( needed ) ) {
      mess += ".  It also requires " + query_multiple_short(
                 needed ) + " but will not consume " + 
                 ( sizeof( needed ) > 1 ? "them" : "it" );
    }
  } else {
    mess = spell_name + " requires " + query_multiple_short( needed ) +
           " but will not consume " + ( sizeof ( needed ) > 1 ?
           "them" : "it" );
  }
   
  add_succeeded_mess( ({ mess + ".\n", "" }) );
  return 1;
} /* cmd() */

mixed *query_patterns() {
  return ({ "[for] <string'spell'>", (: cmd( $4[0] ) :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/player/components.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/rot13.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/rot13.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627136   Available: 13574490
Inodes: Total: 5242880    Free: 4960133
795 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/rot13.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627136   Available: 13574490
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * rot13 command.  Transforms input with rot13 algorithm.  Numbers are
 * transformed with rot5.  
 * @author Gruper
 */

inherit "/cmds/base";

string rot13(string str);

int cmd(string str) {
   printf("You rot: \"%s\".\n", rot13(str));
   return 1;
} /* cmd() */

string rot13(string str) {
   int i;

   for(i = 0; i < sizeof(str); i++) {
      if(str[i] >= 'A' && str[i] <= 'Z') {
         str[i] = ((13 + str[i] - 'A') % 26) + 'A';
      } else if(str[i] >= 'a' && str[i] <= 'z') {
         str[i] = ((13 + str[i] - 'a') % 26) + 'a';
      } else if(str[i] >= '0' && str[i] <= '9') {
         str[i] = ((5 + str[i] - '0') % 10) + '0';
      }
   }
   
   return str;
   
} /* rot13() */

mixed *query_patterns() {
   return ({ "<string>", (: cmd($4[0]) :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/player/rot13.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/leaveg_roup.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/leaveg_roup.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627136   Available: 13574490
Inodes: Total: 5242880    Free: 4960133
2475 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/leaveg_roup.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627136   Available: 13574490
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: leaveg_roup.c,v 1.1 1998/01/06 05:29:43 ceres Exp $
 * $Log: leaveg_roup.c,v $
 * Revision 1.1  1998/01/06 05:29:43  ceres
 * Initial revision
 * 
*/
/* command, trial out by Turrican for a commands daemon. */

inherit "cmds/base";

#define TEAM_HANDLER "/obj/handlers/team"

int do_leave(string group, object member);

mixed cmd(string str) {
   object member, *members;
   string group;
   int disband;
   
   group = TEAM_HANDLER->query_group(this_player());
   if(!group)
      return notify_fail("You are not a member of any group.\n");

   members = TEAM_HANDLER->query_members( group );
   if ( !members) {
     TEAM_HANDLER->leave_group(group, this_player());
     TEAM_HANDLER->end_group( group );
     write( "Somehow your group has no members.  "
           "Your group has been ended.  "
           "I hope this is okay.\n" );
     return 1;
   } else if(!(TEAM_HANDLER->query_owner(group))) {
     TEAM_HANDLER->leave_group( group, member );
     TEAM_HANDLER->end_group( group );
     write( "Somehow your group has no leader.  "
      "Your group has been ended.  "
      "I hope this is okay.\n" );
     return 1;
   }

   if((object)TEAM_HANDLER->query_owner(group) == this_player())
      disband = 1;
  
   foreach( member in members ) {
      if ( !member || ( member == this_player() ) )
         continue;
      if ( disband ) {
         tell_object(member, this_player()->short()+" leaves the group and "
                     "it disbands, everyone going their separate ways.\n");
         do_leave(group, member);
      } else
         tell_object(member, this_player()->short()+" leaves the group.\n");
   }
   if(disband) {
      TEAM_HANDLER->end_group(group);
      write("You disband "+group+" and everyone goes their separate "
            "ways.\n");
   } else {
      do_leave(group, this_player());
      write("You leave "+group+".\n");
   }
   return 1;
}

int do_leave(string group, object member) {
   object person;
   
   if(!TEAM_HANDLER->leave_group(group, member))
      return notify_fail("Ack, something went wrong.\n");

   if ( !sizeof( (object *)TEAM_HANDLER->query_members( group ) ) )
      return 0;
  
   foreach(person in TEAM_HANDLER->query_members(group)) {
      if(person) {
         member->remove_protector(person);
         person->remove_protector(member);
         member->remove_follower(person);
         person->remove_follower(member);
      }
   }
   return 1;
}
// --- END [/mnt/home2/grok/lib/cmds/player/leaveg_roup.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/title.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/title.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627135   Available: 13574489
Inodes: Total: 5242880    Free: 4960133
2778 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/title.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627135   Available: 13574489
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
inherit "/cmds/base";
#include <player.h>

mixed cmd_list() {
   string* titles;
//   string* multiple;
//   string bing;

   if (this_player()->query_player_title()) {
      write("Your player title is currently set to: " +
            this_player()->query_player_title() + ".\n");
   } else {
      write("Your player title is currently not set.\n");
   }

   titles = this_player()->query_all_player_titles();
/*
   multiple = PLAYER_TITLE_HANDLER->query_allowed_multiple_titles();
   foreach (bing in multiple) {
     if (!sizeof(filter(explode(bing, " "),
                        (: member_array($1, $2) == -1 :)))) {
        titles += ({ bing });
     }
   }
 */

   write("You can set your player title to one of " +
         query_multiple_short(map(titles, (: capitalize($1) :))) + ".\n");
   return 1;
} /* cmd_list() */

int cmd_set(string title) {
    mixed mess;
//   string* bits;
//   string womble;

   title = lower_case(title);
   //bits = explode(title, " ");

/*
   if (sizeof(bits) > 1 &&
       !PLAYER_TITLE_HANDLER->is_allowed_multiple_title(title)) {
      add_failed_mess("You cannot use a title with more than 1 bit.\n");
      return 0;
   }
 */

   if (strlen(title) > 20) {
      add_failed_mess("Your title is too long.\n");
   }

   if (member_array(title,
                    this_player()->query_all_player_titles()) == -1) {
      add_failed_mess("The title '" + title + "' is not valid.\n");
      return 0;
   }

/*
   foreach (womble in bits) {
      if (member_array(womble,
                       this_player()->query_all_player_titles()) == -1) {
          add_failed_mess("The title '" + womble + "' is not valid.\n");
          return 0;
       }
   }
 */

   if (this_player()->query_player_title() &&
       lower_case(this_player()->query_player_title()) == title) {
      add_failed_mess("You already have your player title set to '" + title +
                      "'.\n");
      return 0;
   }

   this_player()->set_player_title(title);

   if ( sizeof( this_player()->query_hide_invis() ) ) { 
       mess = ({ "$N set$s $p player title to " + capitalize(title) +  
           ".\n", "" });
   }
   else {
       mess = "$N set$s $p player title to " + capitalize(title) +  ".\n";
   }
   add_succeeded_mess(mess);
   return 1;
} /* cmd_set() */

int cmd_reset() {
   if (!this_player()->query_player_title()) {
      add_failed_mess("Your player title is already unset.\n");
      return 0;
   }
   this_player()->set_player_title(0);
   add_succeeded_mess("$N reset$s $p player title.\n");
   return 1;
} /* cmd_reset() */

mixed *query_patterns() {
   return ({ "", (: cmd_list :),
             "<string'title'>", (: cmd_set($4[0]) :),
             "none", (: cmd_reset() :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/player/title.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/keep.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/keep.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627134   Available: 13574488
Inodes: Total: 5242880    Free: 4960133
1383 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/keep.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627134   Available: 13574488
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: keep.c,v 1.5 2003/03/03 01:47:24 ceres Exp $
 * $Log: keep.c,v $
 * Revision 1.5  2003/03/03 01:47:24  ceres
 * Fixed so it'll load
 *
 * Revision 1.4  2003/03/02 22:21:26  pinkfish
 * Allow yuou to list what you are keeping.
 *
 * Revision 1.3  2000/01/19 01:59:36  presto
 * removed all those nasty unused function arguments
 *
 * Revision 1.2  1999/10/27 01:48:31  pinkfish
 * Fix them up to use a nice new effect instead of a horrible shadow.
 *
 * Revision 1.1  1998/01/06 05:29:43  ceres
 * Initial revision
 * 
*/
#define EFFECT "/std/effects/object/identity_hold"

inherit "/cmds/base";

int cmd( object *obs )  {
   object thing;

   foreach(thing in obs) {
      thing->add_effect( EFFECT, ([ "keep" : 1 ]) );
   }
   write( "You will now attempt to keep "+
         (string)query_multiple_short(obs)+".\n" );

   return 1;
} /* cmd() */

int cmd_list() {
   object* obs;

   // Find all the objects we are keeping.
   obs = all_inventory(this_player());
   obs = filter(obs, (: $1->query_keep() :) );
   if (!sizeof(obs)) {
      add_failed_mess("You are not keeping anything.\n");
      return 0;
   }
   write("You are keeping " + query_multiple_short(obs) + ".\n");
   return 1;
}

mixed *query_patterns() {
   return ({ "<indirect:object:me>", (: cmd( $1 ) :),
             "", (: cmd_list :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/player/keep.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/shields.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/shields.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627134   Available: 13574488
Inodes: Total: 5242880    Free: 4960133
1453 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/shields.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627134   Available: 13574488
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <armour.h>
#include <combat.h>

inherit "/cmds/base";

string construct_shield_message( object player, int not_self );

int cmd() {
  string mess;
  
  mess = construct_shield_message(this_player(), 0);
  
  /* If they have shields, give message,
   * otherwise, tell them the bad news. */
  if( sizeof( mess ) ) {
    tell_object( this_player(), "Arcane protection status:\n" + mess );
  } else {
    tell_object( this_player(), "You do not have any arcane protection.\n" );
  }
  
  return 1;
}


string construct_shield_message( object player, int not_self ) {
  int i, j;
  string mess;
  mixed *callbacks;
  string *res;
  class armour_callback cb;
  class combat_special cs;
  
  mess = "";
  callbacks = player->query_armour_callbacks();
  
  for( i = 0; i < sizeof(callbacks); i++) {
    for(j=0; j < sizeof(callbacks[i]); j++) {
      cb = callbacks[i][j];
      if(cb->callback[0]) {
        res = (cb->callback[0])->query_arcane_shields(player);
        if(sizeof(res))
          mess += " * $I$+3,+0=$C$" + res[not_self] + "$I$-3,-0=\n";
      }
    }
  }

  callbacks = player->query_specials();
  for(i=0; i<sizeof(callbacks); i++) {
    cs = callbacks[i];
    if(cs->callback[0]) {
      res = (cs->callback[0])->query_arcane_shields(player);
        if(sizeof(res))
          mess += " * $I$+3,+0=$C$" + res[not_self] + "$I$-3,-0=\n";
    }
  }
  
  return mess;
  
}


mixed *query_patterns() {
  return ({ "", (: cmd :) });
}
// --- END [/mnt/home2/grok/lib/cmds/player/shields.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/dnickname.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/dnickname.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627133   Available: 13574487
Inodes: Total: 5242880    Free: 4960133
847 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/dnickname.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627133   Available: 13574487
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: dnickname.c,v 1.2 2002/02/23 02:15:12 presto Exp $
 * $Log: dnickname.c,v $
 * Revision 1.2  2002/02/23 02:15:12  presto
 * Added query_patterns()
 *
 * Revision 1.1  1998/01/06 05:29:43  ceres
 * Initial revision
 * 
*/
/* command, trial out by Turrican for a commands daemon. */

inherit "cmds/base";

mixed cmd(string str) {
  mapping map_nicknames;

  map_nicknames = this_player()->query_nicknames();
  if (!map_nicknames)
    map_nicknames = ([ ]);
   
  if (!map_nicknames[str]) {
    notify_fail("That nickname does not exist.\n");
    return 0;
  }
  map_nicknames = m_delete(map_nicknames, str);
  this_player()->set_nicknames(map_nicknames);
  write("Deleted nickname \"" + str + "\".\n");
  return 1;
}


mixed *query_patterns()  {
  return ({ "<string'nickname'>", (: cmd($4[0]) :) });
}
// --- END [/mnt/home2/grok/lib/cmds/player/dnickname.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/resize.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/resize.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627133   Available: 13574487
Inodes: Total: 5242880    Free: 4960133
452 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/resize.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627133   Available: 13574487
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: resize.c,v 1.2 1999/10/25 20:51:38 tape Exp $
 * $Log: resize.c,v $
 * Revision 1.2  1999/10/25 20:51:38  tape
 * moved stuff from help() to /doc/helpdir/resize
 *
 * Revision 1.1  1998/01/06 05:29:43  ceres
 * Initial revision
 * 
*/
#include <telnet.h>

inherit "/cmds/base";

mixed cmd(string str) {
  printf("%c%c%c", IAC, DO, TELOPT_NAWS);
  write("Okay, resizing your terminal...\n");
  return 1;
}

// --- END [/mnt/home2/grok/lib/cmds/player/resize.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/lockg_roup.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/lockg_roup.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627133   Available: 13574487
Inodes: Total: 5242880    Free: 4960133
930 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/lockg_roup.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627133   Available: 13574487
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: lockg_roup.c,v 1.1 1998/01/06 05:29:43 ceres Exp $
 * $Log: lockg_roup.c,v $
 * Revision 1.1  1998/01/06 05:29:43  ceres
 * Initial revision
 * 
*/
/* command, trial out by Turrican for a commands daemon. */

inherit "cmds/base";

#define TEAM_HANDLER "/obj/handlers/team"

mixed cmd(string str) {
  object owner;
  int locked;

   str = TEAM_HANDLER->query_group(this_player());
   if(!str)
      return notify_fail("You are not a member of any group.\n");

  owner = TEAM_HANDLER->query_owner(str);
  if(!owner || owner != this_player())
    return notify_fail("Sorry, you are not the owner of "+str+".\n");

  locked = TEAM_HANDLER->query_locked(str);

  if(locked) {
    TEAM_HANDLER->set_locked(str, 0);
    write("Team "+str+" unlocked for new members.\n");
  } else {
    TEAM_HANDLER->set_locked(str, 1);
    write("Team "+str+" locked to new members.\n");
  }

  return 1;
}
// --- END [/mnt/home2/grok/lib/cmds/player/lockg_roup.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/ignore.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/ignore.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627132   Available: 13574486
Inodes: Total: 5242880    Free: 4960133
2333 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/ignore.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627132   Available: 13574486
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: ignore.c,v 1.15 2003/07/13 04:31:59 pinkfish Exp $
 * 
 */
#include <drinks.h>
#include <language.h>
#include <player.h>
#include <player_handler.h>

#define TP this_player()

inherit "/cmds/base";

int cmd_list() {
   string *ignoring;

   ignoring = TP->query_property("ignoring");
   if(!ignoring) {
      ignoring = ({ });
   }
   if ( !sizeof(ignoring) )  {
      write( "You are not ignoring anyone.\n" );
   } else  {
      ignoring = sort_array(ignoring, 1);
      write( "You are currently ignoring " +
              query_multiple_short( map(ignoring, (: capitalize($1) :)), 
                                    0, 0, 1, 0 ) + ".\n" );
   }
   return 1;
} /* cmd_list() */

int cmd( string str) {
   string *ignoring;
 
   ignoring = TP->query_property("ignoring");
   if(!ignoring) {
      ignoring = ({ });
   }

   str = lower_case( TP->expand_nickname(str) );
   if ( !(PLAYER_HANDLER->test_user(str))  &&  !find_player(str)) {
      if (find_living(str)) {
         add_failed_mess("You cannot ignore an npc.\n");
         return 0;
      } else {
         add_failed_mess( "Ignoring someone that doesn't exist?  Is this some "
                           "kind of zen?\n" );
         return 0;
      }
   }
   if (TP->query_name() == str) {
      add_failed_mess("Ignoring yourself.  Novel.\n");
      return 0;
   }
   /**
     -- Why shouldn't players be able to ignore creators?
         -- We have tell! for official business, and if a player
         -- is ignoring a creator, there shouldn't be any 'non-official'
         -- contact. -- Terano.

     -- If you need a better reason, imagine Lobula as a creator, and not
         -- being able to ignore him.

         else if( !TP->query_creator() && PLAYER_HANDLER->test_creator(str)) {
     add_failed_mess("You cannot ignore creators.\n");
     return 0;
   }
   */
   if ( member_array( str, ignoring ) == -1 )  {
      ignoring += ({ str });
      TP->add_property("ignoring", ignoring, 604800);
   } else  {
      write( "You are already ignoring " + capitalize(str) + ".\n" );
   }

   write("You are now ignoring "+capitalize(str)+".\n");
   return 1;
} /* cmd() */

mixed *query_patterns() {
   return ({ "<string'person'>", (: cmd($4[0]) :),
             "", (: cmd_list() :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/player/ignore.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/temp_erature.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/temp_erature.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627131   Available: 13574485
Inodes: Total: 5242880    Free: 4960133
6174 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/temp_erature.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627131   Available: 13574485
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
#include <weather.h>
#include <clothing.h>
#include <playtesters.h>

#define COMFORTABLE 20

#define ABS(x) (x > 0? x : -x)

string disp_warmth(int, int);
string disp_total(int i);

int cmd(string str) {
  object where, *clothes, item;
  string zone, type, *zones, tmp;
  mixed types;
  int adjustment, correction, temperature, room_temp, *enums, cwarm, ccool;
  
  where = environment(this_player());
  
  if(!where)
    return notify_fail("You have no environment.\n");
  
  // If they're on a horse or somesuch then use that locations temperature
  // info.
  if(!where->query_property("location") &&
     environment(where) &&
     environment(where)->query_property("location")) {
    where = environment(where);
  }

  // Figure out the temperature where we are.
  switch(where->query_property("location")) {
  case "outside":
    room_temp = (WEATHER->query_temperature(where) - COMFORTABLE);
    break;
  default:
    room_temp = 0;
  }

  temperature = this_player()->query_personal_temp();
                 
  // set the warmth of the room.
  room_temp += where->query_property("warmth");
  room_temp -= where->query_property("cooling");

  write(sprintf("It's %s here.\n",
         WEATHER->temp_string(room_temp + COMFORTABLE)));

  // Calculate how warm (or cool) their clothing is keeping them.
  clothes = filter_array(this_player()->query_wearing(),
                         (: !$1->id("scabbard") &&
                          !$1->id("belt") &&
                          !$1->id("backpack") &&
                          !$1->id("glasses") &&
                          !$1->id("jewellery") :));
  
  zones = ({ });
  foreach(item in clothes) {
    types = item->query_type();
    if(!arrayp(types)) {
      types = ({ item->query_type() });
    }
    
    ccool = 0;
    cwarm = 0;
    
    foreach(type in types) {
      // Find out what zone this clothing type covers.
      // If it doesn't cover a zone (eg. jewellery) it doesn't give any
      // warmth.
      
      foreach(zone in CLOTHING_HANDLER->query_zone_names(type)) {
        if(member_array(zone, zones) == -1)
          zones += ({ zone });
        if(item->query_property("warmth")) {
          adjustment += item->query_property("warmth");
          cwarm += item->query_property("warmth");
        } else {
          adjustment++;
          cwarm++;
        }
        
        // If it's warm here then do adjustments for clothing that
        // cool you.
        if(room_temp > 0 && item->query_property("cooling")) {
          adjustment -= item->query_property("cooling");
          ccool += item->query_property("cooling");
        }
      }
    }
    tmp = item->query_name();
    if(cwarm && ccool) {
      write(sprintf("Your %s provide%s %s and %s.\n", item->query_short(),
             (tmp[<1] == 's'  &&  tmp[<2 .. <1] != "ss") ? "" : "s",
             disp_warmth(cwarm, 1),
             disp_warmth(ccool, 0)));
    } else if(cwarm) {
      write(sprintf("Your %s provide%s %s.\n", item->query_short(),
             (tmp[<1] == 's'  &&  tmp[<2 .. <1] != "ss") ? "" : "s",
             disp_warmth(cwarm, 1)));
    } else if(ccool) {
      write(sprintf("Your %s provide%s %s.\n", item->query_short(),
             (tmp[<1] == 's'  &&  tmp[<2 .. <1] != "ss") ? "" : "s",
             disp_warmth(ccool, 0)));
    }
  }
  
  // You get a warmth bonus or coolness bonus for each zone covered.
  // This means it's better to cover more of your body when it's cold.
  // It also means you can wear light clothing with less temperature
  // penalties since the warmth & cooling cancel out somewhat.
  if(room_temp < 0) {
    adjustment += sizeof(zones);
    if(room_temp + sizeof(zones) > 5)
      adjustment -= (room_temp + sizeof(zones) - 5);
  } else {
    adjustment -= sizeof(zones);
    if(room_temp - sizeof(zones) < -5)
      adjustment -= (room_temp - sizeof(zones) + 5);
  }

  // Wetness makes you cooler -- so sweating isn't necessarily a bad thing.
  ccool = 0;
  enums = (int *)this_player()->effects_matching("body.wetness"); 
  if ( sizeof( enums ) ) {
    adjustment -= sqrt(sqrt((int)this_player()->arg_of( enums[ 0 ] ))) * 2;
    ccool = sqrt(sqrt((int)this_player()->arg_of( enums[ 0 ] ))) * 2;
  }

  // add their personal warmth (from effects or shadows)
  adjustment += this_player()->query_property("warmth");
  adjustment -= this_player()->query_property("cooling");
  
  // this hopefully it does two things.
  // 1. effectively puts a maximum/minimum on temperature
  // 2. accounts for the body working to adjust temperature.
  if(temperature > room_temp && room_temp >= 0 || temperature > 5)
    correction -= (temperature / 5) + 5;
  if(temperature < room_temp && room_temp <= 0 || temperature < -5)
    correction -= (temperature / 5) - 5;

  write(sprintf("On balance, you are %s and %s.\n",
         this_player()->query_temp_str(),
         disp_total(to_int((room_temp+adjustment + correction)))));
  
  return 1;
}

string disp_warmth(int i, int warm) {
  string pos, neg;

  if(warm) {
    pos = " warmth";
    neg = " cooling";
  } else {
    pos = " cooling";
    neg = " warmth";
  }
  
  switch(i) {
  case -1000..-19: return "an enormous amount of"+neg;
  case -9..-18: return "a lot of"+neg;
  case -8..-4: return "quite a lot of"+neg;
  case -3..-2: return "some"+neg;
  case -1: return "a bit of"+neg;
  case 0: return "no"+pos;
  case 1: return "a bit of"+pos;
  case 2..3: return "some"+pos;
  case 4..8: return "quite a lot of"+pos;
  case 9..18: return "a lot of"+pos;
  default: return "an enormous amount of"+pos;
  }
}

string disp_total(int i) {
  switch(i) {
  case -1000..-51: return "are freezing fast";
  case -50..-21: return "are cooling down quickly";
  case -20..-11: return "are cooling down";
  case -10..-6: return "are cooling down slowly";
  case -5..5: return "will stay pretty much as you are";
  case 6..10: return "are warming up slowly";
  case 11..20: return "are warming up";
  case 21..50: return "are warming up quickly";
  case 51..1000: return "are cooking rapidly";
  default:
    return "broken: " + i + "\n";
  }
}

mixed *query_patterns()  {
   return ({ "", (: cmd("") :) });
}
// --- END [/mnt/home2/grok/lib/cmds/player/temp_erature.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/apply.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/apply.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627130   Available: 13574484
Inodes: Total: 5242880    Free: 4960133
15758 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/apply.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627130   Available: 13574484
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 *  Apply command
 *  @author Drakkos
 *  @author Pinkfish
 *  @started 31/01/2003
 *
 */
#include <applications.h>
#include <board.h>
#include <playerinfo.h>
#include <mail.h>
#include <player.h>

inherit "/cmds/base";

varargs void begin_application (object, string, string);

class applying_player {
   int step;
   object player;
   string domain;
   string next_method;
   string type;
   string *questions;
   string *answers;
}

class vouch_info {
  string applicant;
  string voucher;
  string position;
}

void create() {
  seteuid (geteuid());
} 


int do_creator_apply(string domain, string type) {
  int temp;
  
  if (!domain) {
    domain = type;
  }
  
  if( this_player()->query_property( "guest" ) ) {
    write( "Only people with permanent characters are allowed to "
      "become Creators.\n" );
    return 1;
  }

  temp = APPLICATIONS_HANDLER->query_applications_accepted( domain );
  
  if( temp == -1 ) {
    this_player()->add_failed_mess( this_object(), "The domain " + 
       domain + " is not a valid domain.\n" );
    return 0;
  }
  
  if( temp == 0 ) {
    this_player()->add_failed_mess (this_object(), "The domain " +
    domain + " is not currently open for applications.\n");
    return 0;
  } 
  
  if( !APPLICATIONS_HANDLER->valid_application (this_player()->query_name(), 
    type ) && !this_player()->query_lord() ) {
      write( "Sorry, you have not fulfilled the requirements yet.\n" );
      return 1;
  }
    
  if (domain == "liaison") {
    type = "liaison";
  } 
  
  if (strsrch (domain, "playtester") != -1) {
    type = "playtester";
  } 


  begin_application (this_player(), type, domain);
  return 1;
} /* apply() */
 

void confirm (string message,  class applying_player tmp) {
  
  if (!message || !sizeof (message) || strsrch (message, "no") != -1 
    || strsrch (message, "n") != -1) {
    return;
  }
  else {
    call_other (this_object(), tmp->next_method, tmp->player, tmp);
  }
    
}

string query_application_info (string domain) {
  string ret;
  if( file_size( "/d/" + domain + "/application.txt" ) != -1 ) {
    ret = read_file( "/d/" + domain + "/application.txt" );
  }
  return ret;
}

varargs void begin_application (object player, string type, string domain) {
  class applying_player tmp;
  string ret = APPLICATIONS_HANDLER->query_intro_text (type);

  if( file_size( "/d/" + domain + "/application.txt" ) != -1 ) {
      ret += "\nPlease read the following information about applying to "
             "$C$" + domain + ": \n\n" ;
      ret += query_application_info (domain);
   }

  tell_object (this_player(), ret + "\n");
       
  tmp = new (class applying_player);
  tmp->type = type;
  tmp->domain = domain;
  tmp->answers = ({ });
  tmp->step = 1;
  tmp->next_method = "do_questions";
  tmp->player = player;
  
  tell_object (player, "Do you wish to continue your application?\n");
  this_player()->do_edit( "", "confirm", this_object(), 0, 
    tmp);         
}

varargs void do_questions (object player, class applying_player tmp) {
  if (tmp->step == 1) {
    tmp->questions = APPLICATIONS_HANDLER->query_questions (tmp->type);
  }
  
  tell_object (player, "%^BOLD%^" + tmp->questions[0] 
    + "%^RESET%^\n");

  this_player()->do_edit( "", "start_asking", this_object(), 0, 
    tmp); 
}

void start_asking(string message, class applying_player tmp) {
  object player = tmp->player;
  
  if (!message || sizeof (message) == 0) {
    tell_object (player, "Your application has been aborted.\n");
    return;
  }
  tmp->answers += ({ message });
  
  if (tmp->step == sizeof (tmp->questions)) {
    tell_object (player, "Do you wish to submit your application?\n");
    tmp->next_method = "submit_application";
    this_player()->do_edit( "", "confirm", this_object(), 0, 
      tmp);        
    return;
  }
  
  tell_object (player, "%^BOLD%^" + tmp->questions[tmp->step] 
    + "%^RESET%^\n");
  tmp->step += 1;
  
  this_player()->do_edit( "", "start_asking", this_object(), 0, 
    tmp); 
}

void submit_application (object player, class applying_player tmp) {
  int i;
  string *text = ({ });
    
  for (int j = 0; j < sizeof (tmp->questions); j++) {
    text += ({ "%^CYAN%^" +sprintf( "%2d) %-=*s", ( j + 1), 70, 
      tmp->questions[j] ) + "%^RESET%^\n" });
    text += ({ sprintf( "      %-=*s\n\n", 72, tmp->answers[j] )});
  }
  
  i = APPLICATIONS_HANDLER->add_application (tmp->type, player->query_name(), 
    implode (text, "\n"), tmp->domain);
      
  if (!i) {
    tell_object (player, "Something has gone wrong!\n");
    return;
  }
  else {
    tell_object (player, "Thank you for your application... it has been "
      "placed in the handler ready for people to vouch.\n");
  }
  

}

int do_list_types() {
  string ret = "";
  string *types;
  
  types = APPLICATIONS_HANDLER->query_types();
  
  ret += "You can apply for the following positions with this command:\n\n";
  
  foreach (string t in types) {
    ret += t + "\n";
  }
  
  this_player()->more_string (ret);
  return 1;
  
}

int do_list_requirements(string type) {
  string ret = APPLICATIONS_HANDLER->application_requirements (type);
    
  this_player()->more_string (ret);
  return 1;
  
}

int domain_status() {
  mapping map = APPLICATIONS_HANDLER->query_domain_status();
  string ret = "";
  
  foreach (string s, int o in map) {
    ret += (o ? "%^BOLD%^%^CYAN%^" : "") + capitalize (s) + " is " +
           (o ? "open" : "closed") + "%^RESET%^ to "
      "applications and is managed by " + 
      capitalize (APPLICATIONS_HANDLER->query_responsibility (s)) + ".\n"; 
  }
  
  //this_player()->more_string (ret);
  write("$P$Domain Status$P$" + ret);
  return 1;
  
}

int do_list_questions (string type) {
  string *quest = APPLICATIONS_HANDLER->query_questions (type);
  
  tell_object (this_player(), "\n\nPlease take time to write your application.  "
     "Preferably, prepare an answer to each of these questions off-line "
     "and copy your response into the editor on the MUD if possible.  "
     "You will be asked these questions one-by-one during the application "
     "process, so you should answer each question thoroughly.  Remember, "
     "this is a formal application to a position of responsibility, so "
     "treat each question seriously.\n\n");


  this_player()->more_string (implode (quest, "\n\n"));
  return 1;
}

int do_vouch (string name, string position) {
  int i = APPLICATIONS_HANDLER->find_application (name, position);
  class vouch_info tmp;
  
  tmp = new (class vouch_info);
  
  if (i == -1) {
    write (capitalize (name) + " has not applied for a " 
      + position + " position.\n");
    return 1;
  }
  
  tell_object (this_player(), "%^BOLD%^Why do you think " + capitalize (name) 
    + " would be a suitable " + position + "? %^RESET%^");
  
  tmp->applicant = name;
  tmp->voucher = this_player()->query_name();
  tmp->position = position;
  this_player()->do_edit( "", "vouch_edit", this_object(), 0, 
    tmp);
  return 1;    
}

void vouch_edit(string message, class vouch_info tmp) {
  object ob;
  int i;
  string name = tmp->applicant;
  string position = tmp->position;

  ob = find_player (tmp->voucher);

  if (!sizeof (message) || message == "") {
    if (ob) {
      tell_object (ob, "Your vouch has been aborted.\n");
    }
  }
  else {
    i = APPLICATIONS_HANDLER->make_vouch (position, name, tmp->voucher, message);
  
    switch (i) {
      case 2:
        tell_object (ob, "You submit your vouch for " + capitalize (name) 
          + " as a " + position + ".\n");
      break;
      case 1:
        tell_object (ob, "You resubmit your vouch for " + capitalize (name) 
          + " as a " + position + ".\n");
      break;
      case 0:
        tell_object (ob, "You cannot submit a vouch for yourself.\n");
      break;
      case -1:
        tell_object (ob, "There is no application for " + capitalize (name) + 
          " as a " + position + ".\n");
      break;      
    }
  }      
 

  

}

int do_delete_vouch (string name, string position) {
  int i = APPLICATIONS_HANDLER->delete_vouch (this_player()->query_name(), 
    name, position);
    
  if (i) {
    tell_object (this_player(), "You delete your vouch for " +
      capitalize (name) + " as a " + position + ".\n");
  }
  else {
    tell_object (this_player(), "You have not vouched for " + 
      capitalize (name) + " as a " + position + ".\n");
  }
  
  return 1;
}

int query_my_vouch (string name, string position) {
  string v = APPLICATIONS_HANDLER->query_vouch (position, name, 
    this_player()->query_name());
    
  if (!v) {
    tell_object (this_player(), "There is no application for " 
      + capitalize (name) + " as a " + position + ".\n");
  }
  else {
    tell_object (this_player(), v + "\n");
  }
  return 1;
}

int delete_application (string pos) {
  int i = APPLICATIONS_HANDLER->delete_application (pos, 
    this_player()->query_name());
    
  if (!i) {
    tell_object (this_player(), "You have no pending applications for "
      "that position.\n");
  }
  else {
    tell_object (this_player(), "Your application has been deleted.\n");
  }       
  return 1;
}

int do_register() {

   if ( this_player()->query_property( "guest" )==1 ) {
      write ( "You are a guest. Registering as a player killer is not an "
        "option for you.\n");
      log_file( "CHEAT", ctime(time()) +": "+
        this_player()->query_short()+
        " (" +query_ip_number(this_player()) + ") (a guest) tried to "
        "register as a player killer.\n");
      return 1;
   }

   if (this_player()->query_player_killer()) {
      add_failed_mess( "You already are a player killer, silly!\n" );
      return 0;
   }

   if (-this_player()->query_time_on() < PKER_MINIMUM_AGE) {
      add_failed_mess( "You are not old enough to be a player killer.  You "
        "must be " + (PKER_MINIMUM_AGE / (60 * 60 * 24)) + " days old to "
        "register as a player killer.\n");
      return 0;
   }

   if (this_player()->query_property(PKER_NOT_ALLOWED)) {
      write( "Due to previous abuses of the playerkiller system, you are "
         "not allowed to become a playerkiller.\n");
      log_file( "CHEAT", ctime(time()) +": "+
        this_player()->query_short()+ " (" +query_ip_number(this_player()) + 
        ") (not allowed to be a pk) tried to register as a player "
        "killer.\n");
      return 1;
   }

   write( "%^BOLD%^%^YELLOW%^You are hereby registering yourself as "
          "a player killer.\n\n"
          "This means that you can attack and be attacked by other "
          "player killers.  Once you are a registered player killer, "
          "there is NO going back.  Please note, this is NOT a quest "
          "and you will NOT get any experience points from doing "
          "it.%^RESET%^\n");
   write( "Are you sure about this, (Y/N)?\n");
   input_to("register2");
   return 1;
} /* register() */

void register2(string str)
{
   str = lower_case(str);
   if (!strlen(str) ||
       (str[0] != 'y' && str[0] != 'n' && str[0] != 'q')) {
      write("You need to type 'y' or 'n'.\n");
      write("Are you sure about this, (Y/N)? ");
      input_to("register2");
      return ;
   }
   if (str[0] == 'n' ||
       str[0] == 'q') {
      write("You have chosen not to register as a playerkiller at this "
         "time.  You may choose to register later if you wish.\n");
   } else {
      write("%^BOLD%^%^YELLOW%^You are now a playerkiller, ready to kill and be killed.%^RESET%^\n");
      //this_player()->add_property(PKER,1);
      this_player()->set_player_killer(1);
      PLAYERINFO_HANDLER->add_entry( this_player(),
        this_player()->query_name(), "misc",
        "Registered as a Player Killer." );
   }
}

int do_query_all_vouches() {
  mapping tmp = APPLICATIONS_HANDLER->query_vouches_for_all 
    (this_player()->query_name());
  string *ret = ({ });
  string tmp2;

  if (!sizeof (tmp)) {
    this_player()->add_failed_mess (this_object(), "You have made no "
      "vouches for anyone.\n", ({ }));
    return 0;
  }
  
  foreach (string n, string v in tmp) {
    tmp2 = "$I$5=%^CYAN%^" + capitalize (n) + "%^RESET%^: " + v;
    ret += ({ tmp2 });      
  }
  this_player()->more_string (implode (ret, "\n\n"));
  return 1;
}

private int do_list_applicants() {
  string ret;
  
  if (!this_player()->query_lord()) {
    return 0;
  }
  
  ret = APPLICATIONS_HANDLER->list_applications();
  
  this_player()->more_string (ret);
  return 1;
}

private int do_browse_app (string type, string name) {
  int i = APPLICATIONS_HANDLER->find_application (name, type);
  string ret;
  
  if (i == -1) {
    this_player()->add_failed_mess (this_object(), "There is no "
      +type + " application for " + name + ".\n", ({ }));
    return 0;
  }
    
  ret = APPLICATIONS_HANDLER->format_application (i);

  this_player()->more_string (ret);
  return 1;
}

int query_my_vouches (string position) {
  mapping i = APPLICATIONS_HANDLER->query_application_vouches 
    (this_player()->query_name(), position);
  
  if (!i) {
    this_player()->add_failed_mess (this_object(), "You currently have no vouches "
      "for a " + position + " application.\n", ({ }));
    return 0;
  }
  else {
    tell_object (this_player(), "The following people have vouched for your " +
      position + " application:  " + query_multiple_short (map (keys (i), 
        (: capitalize ($1) :))) + ".\n");
    return 1;
  }       
}


mixed* query_patterns() {
   string t = "{" + implode (APPLICATIONS_HANDLER->query_types(), "|") 
    + "}";
   mixed *tmp; 
   tmp = ({ 
             "as creator in <word> domain", (: do_creator_apply($4[0], "creator") :),            
             "as player killer", (: do_register() :),
             "as playtester", (: do_creator_apply("playtesters", "playtester") :),            
             "as liaison", (: do_creator_apply(0, "liaison") :),            
             "delete my application as <word'position'>",
              (: delete_application ($4[0]) :),

             "list available positions", (: do_list_types() :),
             "list requirements for " + t + " applications", 
              (: do_list_requirements($4[0]) :),
             "list position status", (: domain_status() :),
             "list questions for " + t + " applications",
              (: do_list_questions ($4[0]) :),

             "vouch for <word'name'> as <word'position'>", 
              (: do_vouch ($4[0], $4[1]) :), 
             "delete vouch for <word'name'> as <word'position'>",
              (: do_delete_vouch ($4[0], $4[1]) :),
             "query vouch for <word'name'> as <word'position'>",
              (: query_my_vouch ($4[0], $4[1]) :),
             "query all my vouches", (: do_query_all_vouches() :),
             "query vouches for my <word> application", (: query_my_vouches($4[0]) :),

  });    
  
  if (this_player()->query_lord()) {
    tmp += ({"browse <word'type'> application for <word'name'>", (: do_browse_app($4[0], $4[1]) :) });    
    tmp += ({"list applicants", (: do_list_applicants() :) });
  }
  
  return tmp;          
} 

void clean_up() {
  return 0;
}

int application_board_access_check( int type, string board,
                                    object previous, string name ) {
   switch(type) {
      case B_ACCESS_READ :
         return 1;
      case B_ACCESS_WRITE :
         if( file_name(previous) == file_name( this_object() ) )
            return 1;
          if (base_name (previous) == APPLICATIONS_HANDLER) {
            return 1;
          }
         return master()->query_lord(name);
      case B_ACCESS_DELETE :
         // Players can always delete their own notes, do not need to code
         // for that.
         return 0;
   }
} /* application_board_access_check() */


void reset() {
}
// --- END [/mnt/home2/grok/lib/cmds/player/apply.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/qwho.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/qwho.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627126   Available: 13574480
Inodes: Total: 5242880    Free: 4960133
6621 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/qwho.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627126   Available: 13574480
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: qwho.c,v 1.25 2003/01/16 23:23:09 ceres Exp $
 * 
 */
inherit "/cmds/base";

#include <login_handler.h>

int playercompare(object p1, object p2);

int cmd(string guild_name) {
   int i;
   int countcre;
   int countplay;
   int counttest;
   int countloginq;
   int countlogins;
   int compressed;
   string obtyp;
   string tmp;
   object *arr;
   string nam;
   string cres;
   string plays;
   string testers;
   string *login_q;
   string logins;
   int showmasters;
   mapping user_data;
   object *liaisons;
   string friends;
   int countFriends;
   int totalUsers;
   int totalPlayers;
   int totalCompressed;

   if (this_player()->query_creator()) {
      showmasters = 1;
   } else {
      showmasters = 0;
   }
   countcre = 0;
   countplay = 0;
   counttest = 0;
   compressed = 0; 
   cres = "";
   plays = "";
   testers = "";
   logins = "";
   friends = "";
   user_data = unique_mapping( users(), 
       (: "/d/liaison/master"->query_member( $1->query_name() ) :) );

   if ( user_data[1] ) {
       liaisons = sort_array( user_data[1], (: playercompare :) );
   }
   else {
       liaisons = ({ });
    }
   
   if ( user_data[0] ) { 
       arr = sort_array( user_data[0], (: playercompare :));
   }
   else {
       arr = ({ });
   }

   arr = liaisons + arr; 
   arr = filter(arr, (: (!$1->query_invis() || reference_allowed(this_player(),
     $1)) && !$1->query_login_ob() :) );
 
   if (guild_name) {
      // Do weird filtering!
      arr = "/cmds/player/who"->filter_users(arr, guild_name, 1);
      if (!sizeof(arr)) {
         add_failed_mess("Unable to find any members of " + 
                         guild_name + ".\n");
         return 0;
      }
   }
   
   for(i=0;i<sizeof(arr);i++) {
      nam = arr[i]->query_cap_name();
      if (!nam) {
         if (showmasters) {
            nam = "/secure/master";
         } else {
            continue;
         }
      }
      switch (arr[i]->query_invis()) {
      case 0:
         break;
      case 1:
         nam = "[" + nam + "]";
         break;
      case 2:
         nam = "[{" + nam + "}]";
         break;
      case 3:
         nam = "[<" + nam + ">]";
         break;
      default:
         nam = "?" + nam + "?";
         break;
      }
      obtyp = arr[i]->query_object_type();
      switch(obtyp) {
      case "X":
         break;
      case " ":
         break;
      case "C":
         nam += "(%^CYAN%^C%^RESET%^)";
         if ( "/d/liaison/master"->query_member((string)arr[i]->query_name())) {
            nam += "(%^YELLOW%^l%^RESET%^)";
         }
         break;
      case "S":
         nam += "(%^BOLD%^%^CYAN%^S%^RESET%^)";
         if ( "/d/liaison/master"->query_member((string)arr[i]->query_name())) {
            nam += "(%^YELLOW%^l%^RESET%^)";
         }
         break;
      case "T":
         nam += "(%^BOLD%^%^RED%^T%^RESET%^)";
         if ( "/d/liaison/master"->query_member((string)arr[i]->query_name())) {
            nam += "(%^YELLOW%^l%^RESET%^)";
         }
         break;
      case "D":
         nam += "(%^RED%^D%^RESET%^)";
         if ( "/d/liaison/master"->query_member((string)arr[i]->query_name())) {
            nam += "(%^YELLOW%^l%^RESET%^)";
         }
         break;
      default:
         break;
      }
      if (this_player()->is_friend(arr[i]->query_name())) {
         nam += "(%^GREEN%^F%^RESET%^)";
      }

      if (compressedp(arr[i])) {
          compressed++;
      }
      if (arr[i]->query_creator()) {
         countcre++;
         cres = cres + " " + nam;
      } else if (obtyp == "p") {
         counttest++;
         testers = testers + " " + nam;
      } else if(arr[i]->query_login_ob()) {
         countlogins++;
         logins = logins + " " + nam;
      } else if (this_player()->is_friend(arr[i]->query_name())) {
         countFriends++;
         friends = friends + " " + nam;
      } else {
         countplay++;
         plays = plays + " " + nam;
      }
   }

   if (guild_name) {
      // Do weird filtering!
      arr = LOGIN_HANDLER->query_login_queue();
      arr = "/cmds/player/who"->filter_users(arr, guild_name);
      login_q = map(arr, (: $1->query_cap_name() :));
   } else {
      login_q = map(LOGIN_HANDLER->query_login_queue(),
                 (: $1->query_cap_name() :));
   }
   login_q = filter(login_q, (: $1 :));
   login_q = sort_array(login_q, 1);
   
   countloginq = sizeof(login_q);
   
   tmp = sprintf("%%^BOLD%%^%d Creator%s:%%^RESET%%^%s\n",
                 countcre, countcre != 1 ? "s" : "", cres);
   write(tmp);
   if (guild_name != "creator" && guild_name != "creators") {
      switch (counttest) {
        case 0:
            break;
        
        case 1:
           write("%^BOLD%^" + counttest + " Playtester:%^RESET%^" + testers + "\n");
        break;
        
        default:
           write("%^BOLD%^" + counttest + " Playtesters:%^RESET%^" + testers + "\n");        
        break;
     }

      if (countFriends) {
         write("%^GREEN%^" + countFriends + " Friend" + 
             (countFriends > 1 ? "s" : "") + ":%^RESET%^" + friends + "\n");
      }
     
      write("%^BOLD%^" + countplay + " Players:%^RESET%^" + plays + "\n");
      if (countlogins < countloginq) {
         countlogins = countloginq;
      }
      if (countlogins-countloginq) {
         logins = replace(logins, ({ "[", "", "]", ""}));
         if(countloginq) {
            foreach(tmp in login_q) {
               logins = replace(logins, tmp+" ", "");
            }
         }
         write("%^BOLD%^" + (countlogins - countloginq) +
               " Logging in:%^RESET%^" + logins + "\n");
      }
      
      if(countloginq) {
         write("%^BOLD%^" + countloginq + " Queued:%^RESET%^ " +
               implode(login_q, " ") + "\n");
      }
   } else {
      countlogins = 0;
      counttest = 0;
      countplay = 0;
   }

   totalUsers = countcre + counttest + countplay + countlogins + countFriends;
   totalPlayers = counttest + countplay + countFriends; 
   totalCompressed = compressed - countFriends; 

   write("%^BOLD%^" + (totalPlayers) + " Players, " +
         totalUsers + " Total%^RESET%^\n" ); 
   
/*    +
         " Total (" + totalCompressed + " with MCCP, " + 
            (totalUsers - totalCompressed) + 
         " without)%^RESET%^\n");
*/    
   return 1;
} /* cmd() */

int playercompare(object p1, object p2) {
   return strcmp(p1->query_name(), p2->query_name());
} /* playercompare() */

mixed *query_patterns() {
   return ({ "", (: cmd(0) :),
             "<string'guild name'>", (: cmd($4[0]) :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/player/qwho.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/un_alias.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/un_alias.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627124   Available: 13574478
Inodes: Total: 5242880    Free: 4960133
2184 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/un_alias.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627124   Available: 13574478
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/cmds/base";

/**
 * This method allows a single alias to be removed.
 * Only doable by self or a lord
 * @param str the name of the alias to remove
 * @return 1 on success, 0 on failure
 */
varargs int unalias(string str, object who ) {
    if (!who) who = this_player();
   if (!who->is_alias(str)) {
      add_failed_mess("The alias '" + str + 
                      "' does not exist, cannot unalias.\n");
      return 0;
   }
   if (who->remove_player_alias(str)) {
      write("Successfully unaliased '" + str + "'.\n");
      return 1;
   } else {
      add_failed_mess("Unable to unalias '" + str + "'.\n");
      return 0;
   }
} /* unalias() */

/**
 * This method allows a single alias to be removed.
 * Only doable by self or a lord
 * @param str the name of the alias to remove
 * @return 1 on success, 0 on failure
 */
varargs int unalias_pattern(string filter) {
   mapping aliases;
   string* tmp;
   string* ok;
   string gfilter;
   string bing;

   aliases = this_player()->query_aliases();
   // DO the pattern thing.
   tmp = m_indices(aliases);
   if (regexp(filter,
        "[\\[\\]\\(\\)\\*\\?\\+][\\[\\]\\(\\)\\*\\?\\+]+") ) {
      add_failed_mess("Bad pattern to alias.\n");
      return 0;
   }
   if (filter[0] == '*' || filter[0] == '+') {
      add_failed_mess("Cannot start a regular expression with a '*' or '+', "                         "try: '.*' or '.+'.\n");
      return 0;
   }
   gfilter = "^" + filter;
   tmp = filter_array(tmp, (: $1 && regexp($1, $(gfilter)) :));

   ok = ({ });
   foreach (bing in tmp) {
      if (this_player()->remove_player_alias(bing)) {
         ok += ({ bing });
      }
   }

   if (sizeof(ok)) {
      add_succeeded_mess("Successfuly removed the aliases " +
            query_multiple_short(map(ok, (: "'" + $1 + "'" :))) + ".\n");
      return 1;
   }
   add_failed_mess("Unable to remove any of the aliases " +
            query_multiple_short(map(tmp, (: "'" + $1 + "'" :))) + ".\n");
   return 0;
} /* unalias() */

mixed *query_patterns() {
   return ({
      "pattern <word'alias'>", (: unalias_pattern($4[0]) :),
      "<word'alias'>", (: unalias($4[0]) :),
         });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/player/un_alias.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/rem_ote.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/rem_ote.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627123   Available: 13574477
Inodes: Total: 5242880    Free: 4960133
8091 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/rem_ote.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627123   Available: 13574477
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: rem_ote.c,v 1.26 2003/03/14 22:28:21 pinkfish Exp $
 * 
*/
#include <library.h>
#include <player.h>
#include <network.h>

#define TELL_REPLY_LOCK_ID "lock fluff"

inherit "/cmds/base";

mixed cmd( object *obs, string words ) {
   object other;
   object *ok;
   object *ignoring;
   object *roleplaying;
   object *net_dead;
   object *fail;
   object *earmuffed;
   object *multiple_earmuffed;
   object *update_list;
   string* prop;
   string me_name;
   string tmp;
   string pad = " ";
   string* ok_string;
   int colour;

   if ( this_player()->query_role_playing() ) { 
      add_failed_mess( "You cannot use remotes when you are role playing.\n" );
      return -1;
   }

   /* Do not allow players with remotes ear muffed to use the command. */
   if ( this_player()->check_earmuffs( "remote" ) ) {
      if (this_player()->query_earmuffs() == PLAYER_ALLOW_FRIENDS_EARMUFF) {
         if (sizeof(filter(obs, (: !this_player()->is_friend($1->query_name()) :)))) {
            add_failed_mess("One of the people you are trying to remote is not a "
                            "friend (and you have tells earmuffed).\n");
            return -1;
         }
      } else {
         return notify_fail( "You have remote ear muffed.\n" );
      }
   }

   if ( userp( this_player() ) && !this_player()->query_creator() ) {
      if ( !LIBRARY->query_quest_done( (string)this_player()->query_name(),
            "remote" ) )
         return notify_fail( NOT_ALLOWED );
      if ( environment( this_player() )->query_property( "no remote" ) )
         return 0;
      if ( (int)this_player()->adjust_sp( -REMOTE_COST ) < 0 )
         return notify_fail( NO_POWER );
   }

   ok = ({ });
   ignoring = ({ });
   roleplaying = ({ });
   net_dead = ({ });
   earmuffed = ({ });
   multiple_earmuffed = ({ });
   update_list = ({ });

   if (sizeof(obs) == 0)  {
      prop = this_player()->query_tell_reply_list();
      if (prop)
         obs = map(prop, (: find_player($1) :));
      else  {
         add_failed_mess("No one has told you anything in the last 15 "
                         "minutes.\n");
         return 0;
      }
   }

   if (sizeof(obs) == 1 && obs[0] == this_player()) {
      add_failed_mess("Interesting way of expression emotion, try "
                      "talking to someone else.\n");
      return 0;
   }

   fail = this_player()->query_ignoring(obs);
   if ( sizeof( fail ) )  {
      write( "You are currently ignoring " +
             query_multiple_short(fail) + ", so you ought to leave " +
             (sizeof(fail) > 1 ? "them" : fail[0]->query_objective()) +
             " alone.\n" );
      obs -= fail;
   }
   ok_string = ({ this_player()->query_name() });
   foreach (other in obs) {
      if ( other && other->query_property( "ignoring" ) ) {
         if ( member_array( (string)this_player()->query_name(),
                             other->query_property( "ignoring" ) ) != -1 &&
               !this_player()->query_creator()) {
           ignoring += ({ other });
           other = 0;
         }
      }
      
      // This check needs to be done separately.
     
      if ( other && other->query_role_playing() && 
          !this_player()->query_creator() ) {
         roleplaying += ({ other });
         other = 0; 
      }

      if (other) {

         this_player()->adjust_time_left( -10 );
         if( userp(other) &&
             !interactive( other ) ) {
            net_dead += ({ other });
         } else if( other->check_earmuffs( "remote" ) ) {
            earmuffed += ({ other });
         } else if( other->check_earmuffs( "multiple-remote" ) &&
                    sizeof(obs) > 1) {
            multiple_earmuffed += ({ other });
         } else if (other != this_player()) {
           /*
            other->event_emote( this_player(), "%^MAGENTA%^$C$"+
                  (string)this_player()->query_cap_name() +" "+
                  words +"%^RESET%^\n" );
           */
            ok += ({ other });
            ok_string |= ({ other->query_name() });
            prop = other->query_tell_reply_list();
            if (prop && prop[0] == TELL_REPLY_LOCK_ID) {
               // Refresh if one of the locked people tells us.
               if (member_array(this_player()->query_name(), prop) != -1) {
                  other->set_tell_reply_list(prop);
               }
            } else {
               update_list += ({ other });
            }
         }
      }
   }

   update_list->set_tell_reply_list(ok_string);

   if( sizeof( ignoring ) ) {
      write( query_multiple_short(ignoring) +
            ( sizeof( ignoring ) > 1 ? " are":" is" ) +
            " ignoring you and will not have seen your message.\n" );
   }

   if ( sizeof( roleplaying ) ) {
      write( query_multiple_short( roleplaying ) +
            ( sizeof( roleplaying ) > 1 ? " are":" is" ) +
            " currently role playing and will not have seen your message.\n" );
   }


   if( sizeof( earmuffed ) ) {
      write( query_multiple_short( earmuffed ) +
            ( sizeof( earmuffed ) > 1 ? " have":" has" ) +
            " remotes earmuffed and will not have seen your message.\n" );
   }

   if (sizeof( multiple_earmuffed)) {
      write( query_multiple_short( multiple_earmuffed ) +
            ( sizeof( multiple_earmuffed ) > 1 ? " have":" has" ) +
            " multiple-remotes earmuffed and will not have seen your "
            "message.\n" );
   
   }

   colour = strsrch(words, "%^") != -1;
   // have a go at replacing multiple spaces with a single one. This should
   // stop anyone trying to format the emote to look as though it's an emote
   // followed by a tell or somesuch.
   words = replace(words, ({"        ", " ",
                              "       ", " ",
                              "      ", " ",
                              "     ", " ",
                              "    ", " ",
                              "   ", " ",
                              "  ", " "}));

   if (colour) {
      words += "%^RESET%^";
   }

   me_name = this_player()->query_short();
   if (this_player()->query_family_name()) {
      me_name += " " + this_player()->query_family_name();
   }
   if (words[0..0] == "'") pad = "";
   if (sizeof(net_dead) || sizeof(ok)) {
     if (sizeof(ok + net_dead) > 1) {
       foreach(other in ok)  {        
         tmp = other->colour_event("remote", "%^MAGENTA%^");
         other->event_emote(this_player(),
                         tmp +
                         "$C$Remotes to " +
                         query_multiple_short(net_dead + ok) + ": " + 
                         me_name + pad + words +
                         (colour?"\n" + tmp + "--End of remote--": "") +
                         "%^RESET%^\n");
         other->add_tell_history(me_name + " remotes ", words, 1);
       }
     } else {
       foreach(other in ok)  {
         tmp = other->colour_event("remote", "%^MAGENTA%^");
         other->event_emote(this_player(),
                       tmp + "$C$" + me_name + pad +
                       words +
                       (colour?"\n" + tmp + "--End of remote--": "") +
                       "%^RESET%^\n");
         other->add_tell_history(me_name + " ", words, 1);
       }
     }
     this_player()->add_tell_history("You remote to " +
                                      query_multiple_short(net_dead + ok, "a", 1) + 
                                     ": ",
                                     me_name + pad + words, 1);
     write( "You remote to " + query_multiple_short(net_dead + ok) + ": $C$" +
            me_name + pad + words +"%^RESET%^\n" );
   }

   if( sizeof( net_dead ) ) {
      write( query_multiple_short( net_dead ) +
            ( sizeof( net_dead ) > 1 ? " are":" is" ) +
            " netdead and may not have seen your message.\n" );
   }

   return 1;
} /* cmd() */

mixed *query_patterns() {
   return ({ "<indirect:player> <string>", (: cmd($1, $4[1]) :),
              "reply <string>",
              (: cmd(({ }), $4[0]) :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/player/rem_ote.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/haunt.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/haunt.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627121   Available: 13574475
Inodes: Total: 5242880    Free: 4960133
1613 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/haunt.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627121   Available: 13574475
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/** 
 * Haunt command. 
 * @author Taffyd
 */

#define HAUNT_EARMUFF "remote-soul"

inherit "/cmds/base";

string ooo() {
    return implode( allocate( 3 + random( 15 ),
        (: ({ "O", "o" })[ random( 2 ) ] :) ), "" );
} /* ooo() */

int haunt_player( object *victims ) {
    victims = filter( victims, (: !sizeof( $1->query_ignoring( ({ this_player() }) ) ) :) );
    victims = filter( victims, (: !$1->check_earmuffs( HAUNT_EARMUFF, 
        $(this_player()) ) :) ); 
    victims = filter( victims, 
        (: interactive( $1 ) || ( $1->query_property( "npc" ) && 
        environment( $1 ) == environment( this_player() ) ) :) );

    if ( !this_player()->query_property("dead") ) {
        add_failed_mess( "You are nowhere near wispy enough to "
          "haunt people.  You could probably scare a table or "
          "chair, though.\n" );
        return -1;
    }

    if ( !sizeof( victims ) ) {
        return 0;
    }

    add_succeeded_mess( "$N wave$s $p arms about anxiously and say$s: \""
   + ooo() + "\" at $I.\n", victims );
    return 1;
} /* haunt_player() */


int cmd() {
    if ( !this_player()->query_property("dead") ) {
        add_failed_mess( "You are nowhere near wispy enough to "
          "haunt people.  You could probably scare a table or "
          "chair, though.\n" );
        return -1;
    }
    add_succeeded_mess( "$N wave$s $p arms about anxiously and intone$s: \"" +
        ooo() + "\".\n" );
    return 1;
} /* cmd() */

mixed *query_patterns() {
    return ({ "", (: cmd() :),
      "<indirect:any-living>", (: haunt_player($1) :)  });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/player/haunt.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/al_ias.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/al_ias.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627120   Available: 13574474
Inodes: Total: 5242880    Free: 4960133
13277 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/al_ias.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627120   Available: 13574474
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <alias.h>

inherit "/cmds/base";

private nosave string gfilter;
/**
 * Turn the compiled alias array into a string.
 * @param al the alias array
 * @return the string value of the alias array
 * @see compile_alias()
 */
string alias_string(mixed *al) {
   int i;
   int num;
   int *add_thing;
   string str;
   
   str = "";
   add_thing = ({ });
   for (i=0;i<sizeof(al);i++) {
      if (stringp(al[i])) {
         /*
           al[i] = replace(al[i], "@@", "@ @ ");
         */
         str += replace(al[i], ({";", "\\;"}));
      } else {
         num = al[i] & ALIAS_MASK;
         switch (al[i] - num) {
         case NEW_LINE  : 
            str += ";";
            break;
         case ALL_ARGS  : 
            str += "$*$";
            break;
         case ONE_ARG   : 
            str += "$"+num+"$";
            break;
         case TO_ARG    : 
            str += "$*"+num+"$";
            break;
         case FROM_ARG  : 
            str += "$"+num+"*$";
            break;
         case ALL_ARG   : 
            str += "$arg:"+al[++i]+"$";
            break;
         case ARG_THING : 
            str += "$arg"+num+":"+al[++i]+"$";
            break;
         case ELSE_THING :
           str += "$else$";
           /*
             add_thing[sizeof(add_thing)-1] = i+1+al[++i];
           */
           break;
         case ALL_IFARG : 
            str += "$ifarg:";
            /*
              add_thing += ({ i+1+al[++i] });
            */
            break;
         case IFARG_THING :
            str += "$ifarg"+num+":";
            /*
              add_thing += ({ i+1+al[++i] });
            */
            break;
         case CURR_LOC :
            str += "$!$";
            break;
         case END_IF      :
            str += "$endif$";
            break;
         }
      }
      /*
        if (member_array(i, add_thing) != -1)
        str += "~$";
      */
   }
   return str;
} /* alias_string() */

/**
 * Prints out all the aliases on the player object.  This is called by the
 * alias command when no arguments are specified.
 * @return 0 if no aliases are defined, 1 if they are
 * @see alias()
 */
int print_aliases(string filter, int sorted) {
   int i;
   int len;
   string str;
   string str1;
   string str2;
   string *tmp;
   string bing;
   mapping aliases;
   string ret;
 
   aliases = this_player()->query_aliases();
   /* 
    * ahh well here goes the clean. you dont want to know what used to
    * be here ;)
    */
   if (!m_sizeof(aliases)) {
      notify_fail("None defined.\n");
      return 0;
   }
 
   str1 = "";
   str2 = "";

   tmp = m_indices(aliases);
   if (filter) {
      if (regexp(filter, 
           "[\\[\\]\\(\\)\\*\\?\\+][\\[\\]\\(\\)\\*\\?\\+]+") ) {
         add_failed_mess("Bad pattern to alias.\n");
         return 0;
      }
      if (filter[0] == '*' || filter[0] == '+') {
         add_failed_mess("Cannot start a regular expression with a '*' or '+', "
                         "try: '.*' or '.+'.\n");
         return 0;
      }
      gfilter = "^" + filter;
      if (catch(tmp = filter_array(tmp, (: $1 && regexp($1, gfilter) :)))) {
         add_failed_mess("Bad pattern to alias (mismatched brackets?).\n");
         return 0;
      }
   }
    
   tmp = sort_array(tmp, 1);
   ret = "You currently have the following aliases:\n";
   for (i = 0; i < sizeof(tmp); i++) {
      if (!tmp[i]) {
         map_delete(aliases, 0);
         continue;
      }
      bing = alias_string(aliases[tmp[i]]);
      if (!bing) {
         bing = "Error in the alias!";
      }
      if (!tmp[i]) {
         tmp[i] = "icky";
      }
      if (strsrch(bing, "%^") != -1) {
         bing = replace_string(bing, "%^", "% ^");
         tmp[i] += " (colour replace)";
      }
      str = tmp[i] + ": " + bing;
      if (strlen(str) > 39 || sorted) {
         len = this_player()->query_cols() - strlen(tmp[i]) - 2;
         if (len < 0) {
            len = 10;
         }

         /* If it is too long, print it right now. */
         ret += sprintf("%s: %-=*s\n", tmp[i], len, bing);
      } else if (strlen(str) > 19) {
         str1 += str+"\n";
      } else {
         str2 += str+"\n";
      }
   }

   if (strlen(str1)) {
      ret += sprintf("%-#*s\n", this_player()->query_cols(), str1);
   }

   if (strlen(str2)) {
      ret += sprintf("%-#*s\n", this_player()->query_cols(), str2);
   }

   ret += sprintf("A total of %d aliases.\n", sizeof(tmp));
   this_player()->more_string(ret);
   return 1;
} /* print_aliases() */

/**
 * Creates the compiled alias array.  See the alias.h file for the
 * definitions of thevalues in the alias array.
 * @param str the string to compile
 * @return the compiled alias array
 * @see /include/alias.h
 */
mixed *compile_alias(string str) {
   mixed *ret;
   int i;
   int space;
   string *frog;
   string s1;
   int tmp;
   int gumby;
   int nodollar;
   int ending_dollar;
   mixed *ifargs;
   
   str = replace(str, ({ "\\;", "$escaped$", ";", "$new_line$", " ", " " }));
   str = replace(str, "$escaped$", ";");

   if(str[sizeof(str)-1] == '$')
     ending_dollar = 1;
   
   frog = explode("&" + str + "&", "$");
   if (frog[0] == "&") {
      frog[0] = "";
   } else {
      frog[ 0 ] = frog[ 0 ][ 1 .. ];
   }
   s1 = frog[<1];
   if (s1 == "&") {
      frog = frog[0..<2];
   } else {
      frog[<1] = s1[0..<2];
   }
   ret = ({ frog[0] });
   ifargs = ({ });
   nodollar = 1;

   for (i = 1; i < sizeof(frog); i++) {
      switch (frog[i]) {
      case "new_line" :
         ret += ({ NEW_LINE });
         nodollar = 1;
         break;
      case "*" :
         ret += ({ ALL_ARGS });
         gumby = 1;
         nodollar = 1;
         break;
      case "!" :
         /* hack by CPR for andrew so that $!$ substitues current location */
         if (this_object()->query_creator()) {
            ret += ({ CURR_LOC });
            nodollar = 1;
            /* end of hack by CPR */
         }
         break;
      case "else" :
         if (sizeof(ifargs)) {
            ret[ifargs[sizeof(ifargs)-1]] = sizeof(ret) -
               ifargs[sizeof(ifargs)-1]+1;
            ret += ({ ELSE_THING, 0, "" });
            ifargs[sizeof(ifargs)-1] = sizeof(ret)-2;
            nodollar = 1;
         }
         break;
      case "~" :
      case "endif" :
         if (sizeof(ifargs)) {
            ret += ({ END_IF });
            ret[ifargs[sizeof(ifargs)-1]] = sizeof(ret)-
               ifargs[sizeof(ifargs)-1];
            ifargs = delete(ifargs, sizeof(ifargs)-1, 1);
            nodollar = 1;
            space = 1;
         }
         break;
      default :
         if (frog[i][0..4] == "ifarg") {
            if (sscanf(frog[i], "ifarg%d:%s", tmp, s1) == 2) {
               if (tmp < 0) {
                  tmp = 0;
               }
               if (tmp > ALIAS_MASK) {
                  tmp = ALIAS_MASK;
               }
               ret += ({ IFARG_THING+ tmp, 0, "" });
               frog[i--] = s1;
               nodollar = 1;
               ifargs += ({ sizeof(ret)-2 });
               space = 0;
               gumby = 1;
            } else if (frog[i][5] == ':') {
               ret += ({ ALL_IFARG, 0, "" });
               frog[i] = frog[i][6..];
               nodollar = 1;
               ifargs += ({ sizeof(ret)-2 });
               space = 0;
               gumby = 1;
               i--;
            } else {
               if (sizeof(ret) && stringp(ret[sizeof(ret)-1]) && !space) {
                  ret[sizeof(ret)-1] += "$"+frog[i];
               } else if (nodollar) {
                  ret += ({ frog[i] });
                  nodollar = 0;
               } else {
                  ret += ({ "$"+frog[i] });
               }
            }
         } else if (frog[i][0..2] == "arg") {
            if (sscanf(frog[i], "arg%d:%s", tmp, s1) == 2) {
               if (tmp < 0) {
                  tmp = 0;
               }
               if (tmp > ALIAS_MASK) {
                  tmp = ALIAS_MASK;
               }
               ret += ({ ARG_THING+ tmp, s1, "" }); 
               nodollar = 1;
               gumby = 1;
            } else if (frog[i][3] == ':') {
               ret += ({ ALL_ARG, frog[i][4..100], "" });
               nodollar = 1;
               gumby = 1;
            } else {
               if (sizeof(ret) && stringp(ret[sizeof(ret)-1]) && !space) {
                  ret[sizeof(ret)-1] += "$"+frog[i];
               } else if (nodollar) {
                  ret += ({ frog[i] });
                  nodollar = 0;
               } else {
                  ret += ({ "$"+frog[i] });
               }
               gumby = 1;
               space = 0;
            }
         } else if (strlen(frog[i]) && frog[i][<1] == '*' &&
                    sscanf(frog[i], "%d%s*", tmp, s1) == 2 && s1 == "") {
            if (tmp < 0) {
               tmp = 0;
            }
            if (tmp > ALIAS_MASK) {
               tmp = ALIAS_MASK;
            }
            ret += ({ FROM_ARG + tmp });
            gumby = 1;
            nodollar = 1;
         } else if (strlen(frog[i]) && frog[i][0] == '*' && 
                    sscanf(frog[i][1..], "%d%s", tmp,s1) == 2 && s1 == "") {
           if (tmp < 0) {
             tmp = 0;
           }
           if (tmp > ALIAS_MASK) {
             tmp = ALIAS_MASK;
           }
           ret += ({ TO_ARG + tmp });
           gumby = 1;
           nodollar = 1;
         } else if (sscanf(frog[i], "%d%s", tmp, s1) == 2 && s1 == "" &&
                    (i < sizeof(frog)-1 || ending_dollar)) {
           if (tmp < 0) {
             tmp = 0;
           }
           if (tmp > ALIAS_MASK) {
             tmp = ALIAS_MASK;
           }
           ret += ({ ONE_ARG + tmp });
           gumby = 1;
           nodollar = 1;
         } else {
            if (!nodollar) {
               frog[i] = "$"+frog[i];
            }
            nodollar = 0;
            space = 0;
            if (strlen(frog[i]) && frog[i][<1] == '~') {
               if (sizeof(ifargs)) {
                  if (strlen(frog[i]) == 1) {
                     frog[i] = "";
                  } else {
                     frog[i] = frog[i][0..<2];
                  }
                  /* create an offset */
                  ret += ({ END_IF });
                  ret[ifargs[<1]] = sizeof(ret) - ifargs[<1];
                  ifargs = ifargs[0..<2];
                  nodollar = 1;
                  space = 1;
               }
            }
            if (sizeof(ret) && stringp(ret[<1]) && space != 2) {
               ret[<1] += frog[i];
            } else {
               ret += ({ frog[i] });
            }
            if (space) {
               space = 2;
            }
         }
      }

   }

   while (sizeof(ifargs)) {
      ret += ({ END_IF });
      ret[ifargs[sizeof(ifargs)-1]] = sizeof(ret)-
         ifargs[sizeof(ifargs)-1];
      ifargs = delete(ifargs, sizeof(ifargs)-1, 1);
   }

   if (!gumby) {
      if (sizeof(ret) && !stringp(ret[sizeof(ret)-1]) || space) {
         ret += ({ " ", ALL_ARGS });
      } else if(sizeof(ret)) {
         ret[sizeof(ret)-1] += " ";
         ret += ({ ALL_ARGS });
      }
   }

   return ret;
} /* compile_alias() */

/**
 * This method will print out one or more aliases.
 * @param str the aliases to print
 */
int print_some_aliases(string str, int every) {
   if (this_player()->is_alias(str) && !every) {
      printf("%s: %-=*s\n", str, 
                (int)this_player()->query_cols() - strlen(str) -2, 
                alias_string(this_player()->query_player_alias(str)));
      return 1;
   }

   return print_aliases(str, 0);
} /* print_some_aliases() */

/**
 * The main alias control function.  Sets up new aliases and prints out
 * the values of single aliases or all the aliases.
 * @param str the command name
 * @return 0 if the alias command failed, 1 if it succeeded
 * @see edit_alias()
 * @see print_aliases()
 */
protected int alias(string name, string value) {
#ifdef DISALLOW_COLOUR 
   if (strsrch(name, "%^") >= 0 || strsrch(value, "%^") >= 0) {
      notify_fail("Cannot add an alias with a colour escape "
                  "sequence (% ^).\n");
      return 0;
   }
#endif
   if (strsrch(value, "END_ALIAS") != -1) {
      add_failed_mess("You cannot use 'END_ALIAS' in an alias.\n");
      return 0;
   }
   
   name = implode(explode(name, " "), "");
   if (name == "unalias" || name == "alias" || name == "ealias")  {
      add_failed_mess("You can't alias the '" + name + "' command, because "
                      "otherwise, there would be Problems.\n");
      return 0;
   }
   if (!this_player()->is_alias(name)) {
      this_player()->add_player_alias(name, compile_alias(value));
      write("Added alias '" + name + "'.\n");
   } else {
      this_player()->add_player_alias(name, compile_alias(value));
      write("Changed alias '" + name + "'.\n");
   }
   return 1;
} /* alias() */

/** @ignore yes */
mixed *query_patterns() {
   return ({ 
         "", (: print_aliases("", 0) :),
         "sorted", (: print_aliases("", 1) :),
         "every <word'alias'>", (: print_some_aliases($4[0], 1) :), 
         "<word'alias'>", (: print_some_aliases($4[0], 0) :), 
         "<word'alias'> <string>", (: alias($4[0], $4[1]) :)
         });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/player/al_ias.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/helper_s.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/helper_s.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627117   Available: 13574471
Inodes: Total: 5242880    Free: 4960133
1903 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/helper_s.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627117   Available: 13574471
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * Helpers command, used to display which newbie helpers are online at 
 * the moment or to test if someone offline is a newbie helper.
 * <p>
 * Trial version.
 * <p>
 * @author Taffyd
 * @started 23/04/99 7:45PM
 */

#include <player_handler.h>

inherit "/cmds/base";

int cmd() {
    object *helpers;
    string mess;
        
    helpers = filter( users(), (: !$1->query_creator() && 
        $1->query_property( "newbie helper" ) &&
        !$1->query_login_ob() :) );
    
    switch( sizeof( helpers ) ) {
        case 0:
            add_failed_mess("There are no newbie helpers logged on at the "
                "moment.\n");
            return 0;
        
        case 1:
            if ( helpers[ 0 ] == this_player() ) {
                mess = "You are the only newbie helper logged on at the "
                    "moment.\n";
            }
            else {
                mess = helpers[ 0 ]->query_short() + " is the only newbie "
                    "helper logged on at the moment.\n";
            }
        break;
        
        default:
            mess = query_multiple_short( helpers->query_short() ) + " are "
                "newbie helpers.\n";
    }
   
    this_player()->add_succeeded_mess(this_object(), ({mess, ""}),
      ({ }));      
    return 1;
} /* cmd() */

int test_helper( string player_name ) {
    
    player_name = lower_case( player_name );
    
    if ( PLAYER_HANDLER->test_property( player_name, "newbie helper" ) ) {
        this_player()->add_succeeded_mess(this_object(), ({
          capitalize( player_name ) + " is a newbie helper.\n",
          ""}), ({ }));
        return 1;
    }
    
    add_failed_mess(capitalize( player_name ) + 
        " is not a newbie helper.\n" );
    return 0;
} 

mixed *query_patterns() {
    return ({ "", (: cmd :),
              "<string'name'>", (: test_helper( $4[ 0 ] ) :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/player/helper_s.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/position.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/position.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627116   Available: 13574470
Inodes: Total: 5242880    Free: 4960133
2071 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/position.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627116   Available: 13574470
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * Funky little command to let players silently set their position,
 * with the aim of encouraging players to improve their health and
 * well-being by experimenting with new and exciting positions.
 *
 * @author Mansarde
 * @started 9-apr-99
 */
 
// For SET_POSITION_COST and NO_POWER
#include <player.h>
 
// Max length of a position
#define MAXLEN 30

inherit "/cmds/base";

private string* _bad_words;

void create() {
   _bad_words = ({ "teach", "skill", "finger", "lesson", ":)", ";)",
                   "chainsaw", "0", "1", "2", "3", "4", "5", "6", "7", "8",
                   "9", ":", ";", ",", "'", "*", "%", "!",
                   "@", "~", "`", "#", "$", "^", "&", "(", ")",
                   "_", "-", "=", "+", "{", "}", "[", "]",
                   "<", ".", ">", "?", "/", "\\",
                   ":->", ":-)", ";-)", ";->", "\""});
} /* create() */

/** @ignore yes */
int cmd( string new_pos ) {
  object player = this_player();
  string word, tmp;
   
  if (!new_pos) {
    write("You are " + player->query_position_short() + ".\n");
    return 1;
  }
  
  if ( strlen(new_pos) > MAXLEN ) {
    add_failed_mess("Sorry, your position cannot be more than " + 
                        MAXLEN + " letters long.\n");
    return 0;
  }
  
  if ( player->query_sp() < SET_POSITION_COST ) {
    add_failed_mess( NO_POWER );
    return 0;
  }
 
  new_pos = replace_string(new_pos, "^", "");
  new_pos = replace_string(new_pos, "%", "");

  // Check it for invalid words.
  tmp = lower_case(new_pos);
  foreach(word in _bad_words) {
    if(strsrch(tmp, word) != -1) {
      add_failed_mess("You cannot bring yourself to set that position.\n");
      return 0;
    }
  }

  player->set_position( new_pos );
  player->adjust_sp( - SET_POSITION_COST );
  tell_object( player, "People will now see:\n" +
               player->query_cap_name() + " is " + new_pos + ".\n");
  return 1;
} /* cmd */

/** @ignore yes */
mixed *query_patterns() {
  return ({ "", (: cmd(0) :),
          "<string'new position'>", (: cmd( $4[0] ) :) });
} /* query_patterns */
// --- END [/mnt/home2/grok/lib/cmds/player/position.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/pstatus.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/pstatus.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627116   Available: 13574470
Inodes: Total: 5242880    Free: 4960133
9052 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/pstatus.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627116   Available: 13574470
Inodes: Total: 5242880    Free: 4960133
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * Score Command for Role-Players
 * @author Terano
 *
 */

broken
#include <config.h>
#include <library.h>
#include <quest_handler.h>
#ifndef __DISTRIBUTION_LIB__
#include <deity.h>
#endif
#include <top_ten_tables.h>
#include <tune.h>
#include <skills.h>

inherit "/cmds/base";

string find_hp_string( int current, int max );
string find_gp_string( int current, int max );
string find_xp_string( int current );
string find_wimpy_string( int wimpy );
string find_surrender_string( int surr );
string find_align_string( object tp );
string find_death_string( int remaining );
int calc_percent( float x, float y );
int calc_xp_cost( string skill );

int cmd() {
   object me;

   me = this_player();

   if ( !"/obj/handlers/playtesters"->query_playtester( me->query_name() ) &&
        !me->query_creator() ) {
      return 1;
   }

   if (this_player()->query_property("dead")) {
      write( "You are just a disembodied spirit.  What use does a wispy thing "
             "like you have for a collection of meaningless numbers?\n" );
      return 1;
   }

   switch( me->query_verbose( "score" ) ) {
   case 1:
      printf( "%s.\n%s and %s.\n%s.\n%s.\n%s and %s.\n%s.\n%s.\n", 
              "You are "+ me->query_cap_name() +" "+me->query_gtitle(),
              capitalize( find_hp_string( me->query_hp(), me->query_max_hp() ) ),
              find_gp_string( me->query_gp(), me->query_max_gp() ),
              capitalize( find_xp_string( me->query_xp() ) ),
              capitalize( find_align_string( me ) ), 
              capitalize( find_wimpy_string( me->query_wimpy() ) ),
              find_surrender_string( me->query_surrender() ),
              "You are "+ me->burden_string(),
              find_death_string( me->query_max_deaths() - me->query_deaths() ) );
      return 1;
   default: 
      printf( "%s and %s.\n%s.\n", 
              capitalize( find_hp_string( me->query_hp(), me->query_max_hp() ) ),
              find_gp_string( me->query_gp(), me->query_max_gp() ),
              capitalize( find_xp_string( me->query_xp() ) ) );
      return 1;
   }
} /* cmd() */

int cmd_stats() {
   object me;
   int stat;
   string ret;

   me = this_player();
   ret = "";

   if ( !"/obj/handlers/playtesters"->query_playtester( me->query_name() ) &&
        !me->query_creator() ) {
      return 1;
   }

   if ( stat = ( me->query_tmp_str() + me->query_bonus_str() ) ) {
      if ( stat > 0 ) {
         ret += "You feel stronger then usual.\n";
      } else {
         ret += "You feel weaker then usual.\n";
      }
   } 
   if ( stat = ( me->query_tmp_int() + me->query_bonus_int() ) ) {
      if ( stat > 0 ) {
         ret += "You feel smarter then normal.\n";
      } else {
         ret += "You feel less smart then normal.\n";
      }
   }
   if ( stat = ( me->query_tmp_con() + me->query_bonus_con() ) ) {
      if ( stat > 0 ) {
         ret += "You feel more healthy then usual.\n";
      } else {
         ret += "You feel a bit sickly.\n";
      }
   }
   if ( stat = ( me->query_tmp_dex() + me->query_bonus_dex() ) ) {
      if ( stat > 0 ) {
         ret += "You feel more nimble then usual.\n";
      } else {
         ret += "You feel more clumsy than you normally do.\n";
      }
   }
   if ( stat = ( me->query_tmp_wis() + me->query_bonus_wis() ) ) {
      if ( stat > 0 ) {
         ret += "You feel mentally attuned.\n";
      } else {
         ret += "You feel a bit vague.\n";
      }
   }
   if ( !strlen( ret ) ) {
      ret += "You feel fine.\n";
   }
   printf( "%s", ret );
   return 1;
} /* cmd_stats() */

string find_hp_string( int current, int max ) {
   if ( this_player()->query_property( "dead" ) ) {
      return "you are dead\n";
   }

   switch( calc_percent( current, max ) ) {
   case 90..100: 
      return "you are in perfect health";
   case 70..89: 
      return "you are slightly wounded";
   case 50..69: 
      return "you are moderately wounded";
   case 30..49: 
      return "you are seriously wounded";
   case 15..29: 
      return "you are critically wounded";
   case 6..14: 
      return "you are fatally wounded";
   case 0..5: 
      return "you are near death";
   default: 
      return "you are broken";
   }
} /* find_hp_string() */

string find_gp_string( int current, int max ) {
   if ( this_player()->query_property( "dead" ) ) {
      return "you are dead\n";
   }
   
   switch( calc_percent( current, max ) ) {
   case 90..100: 
      return "you are full of energy";
   case 70..89: 
      return "you are enthusiastic";
   case 50..69: 
      return "you are not quite so full of beans";
   case 30..49: 
      return "you are weary";
   case 15..29: 
      return "you are tired";
   case 6..14: 
      return "you are exhausted";
   case 0..5: 
      return "you are nearly unconscious";
   default: 
      return "you are broken";
   }
} /* find_gp_string() */

string find_xp_string( int current ) {
   string *skills = ({ "magic", "faith", "fighting", "covert", "crafts" });
   int xptotal;
   
   foreach( string skill in skills ) {
      xptotal += calc_xp_cost( skill );
   }
   
   xptotal /= sizeof( skills );
   
   tell_creator( find_player( "terano" ), "%s: Current XP is: %d, Avg XP is %d, Ratio is: %d.\n", 
                 this_player()->query_name(), current, xptotal, calc_percent( current, xptotal ) );  
   
   switch( calc_percent( current, xptotal ) ) {
      //Less then average
   case 0..20: 
      return "you don't think you can learn much at the moment";
   case 21..59: 
      return "by the luck of a coin, you might be able to learn something new";
   case 60..100: 
      return "if you squeezed it, you could gain some insight";
      
      //1 level
   case 101..300: 
      return "you might be able to learn something new, if you found the right teacher";
      
      //3 levels of average
   case 301..400: 
      return "a small amount could be learned with training";
   case 401..800: 
      return "a bit of training might be in order";
   case 801..1200: 
      return "you could very well learn something new from training";
   case 1201..1500: 
      return "you could benefit from training";
   case 1501..2000: 
      return "you feel like training might help";
   case 2001..2500: 
      return "you should consider training your skills";
      
      //25 levels of average
   case 2501..4000: 
      return "your skills could be greatly improved with training";
   default: 
      return "certainly a hearty training session is in order!";
   }
}
 
string find_wimpy_string( int wimpy ) {
   if ( wimpy ) {
      return "you will flee when "+ find_hp_string( wimpy, 100 );
   }
   return "you will not flee";
} /* find_wimpy_string() */

string find_surrender_string( int surr ) {
   if ( surr ) {
      return "you will surrender when "+ find_hp_string( surr, 100 );
   }
   return "you will not surrender";
} /* find_surrender_string() */

string find_align_string( object tp ) {
   string ret = "";
   string word = tp->query_deity();
   
   ret = "";
   word = tp->query_deity();
   if ( !tp ) {
      return "";
   }
   ret += "you are ";
   ret += tp->align_string();
   if ( stringp( word ) ) {
      ret += " and in the service of ";
      ret += capitalize( word );
      ret += ", ";
#ifndef __DISTRIBUTION_LIB__
      ret += DEITY->query_title( word );
#endif
   }
   return ret;
} /* find_align_string() */

string find_death_string( int remaining ) {
   if ( !this_player()->query_deaths() ) {
      return "Death has never visited you in a professional capacity";
   }

   switch ( remaining ) {
   case 0..0: 
      return "Death has a special interest in your next appointment";
   case 1..3: 
      return "Death is starting to lose patience with you";
   case 4..7: 
      return "You and Death are on good terms";
   default: 
      return "You have an \"arrangement\" with Death";
   }
} /* find_death_string() */

int calc_xp_cost( string skill ) {
   int lvl;
   int my_lvl;
   int cost;
   int j;
   int total;
   int total2;
   int num = 1;

   my_lvl = this_player()->query_skill_bonus( skill, 1 );
   lvl = this_player()->query_skill(skill);
   
   cost = DEFAULT_COST;
   if( SKILL_OB->query_skill_cost(skill) > 0 ) {
      cost *= SKILL_OB->query_skill_cost(skill);
   }
   cost *= STD_COST/5;
   total2 = 0;
   total = 0;
 
   if ( !my_lvl ) {
      my_lvl = 1;
   }
   for ( j = 0; j < num; j++) {
      int k;
      
      k = 2 * this_player()->calc_bonus( lvl + j, skill, 1 ) / my_lvl + 1;
      total2 += cost * ( ( lvl + j ) / LEVEL_DIV + 1 ) * k * k / 2;
      /* This stops people taking advantage of two's complement. */
      if ( total > total2 ) {
         num = j;
         break;
      } else {
         total = total2;
      }
   }
   
   if (!total) {
      total = cost;
   }
   
   return total;  
} /* calc_xp_cost() */

int calc_percent( float x, float y ) {
   return to_int( ( to_float( x ) / to_float( y ) ) * 100 );
} /* calc_percent() */

mixed *query_patterns() { 
   return ({ "", (: cmd() :), "stats", (: cmd_stats() :) }); 
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/player/pstatus.c] ---
