
// --- MUD Extraction File: mud_extraction_part1.c ---
// Generated: 2025-03-07 07:27:40 UTC
// Source Directory: /mnt/home2/grok/lib
// Purpose: Consolidated LPC .c files for analysis and recreation with FluffOS v2019+
//          and Forgotten Realms theming, replicating discworld.starturtle.net:4242
//          with optimizations (UTF-8, JSON, strict typing).
// Note: Each file break is marked with // --- END [file_path] ---
//
// --- BEGIN [/mnt/home2/grok/lib/obj/hotfood.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/hotfood.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628607   Available: 13575961
Inodes: Total: 5242880    Free: 4960134
14661 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/hotfood.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628607   Available: 13575961
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:56.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* 
 *  Inherit for hot food.
 *  Sightblinder, February 2002.
 * 
 * $Id: hotfood.c,v 1.3 2003/03/25 15:32:15 sightblinder Exp sightblinder $
 * $Log: hotfood.c,v $
 * Revision 1.3  2003/03/25 15:32:15  sightblinder
 * added $Log$
 *
*/

/**
 *
 * <BR>
 * This is an inherit for hot food which cools down, 
 * based on the temperature of the room in which it 
 * finds itself and any containers it might be in. 
 * <P>
 * It performs just as normal food, apart from the following:
 * <P>
 * - If eaten while still hot it will cause the consumer to warm up for 
 *   a period of time.
 * <P>
 * - It only decays once it has finished cooling.
 * <P>
 * It's cooling level can be checked by query_cool_level().  This
 * starts at a value of twenty times the original weight of the 
 * hot food and determines how long it takes to cool down.  Larger items
 * cool more slowly.
 * <P>
 * The level of cooling is shown in the long and short of the object.
 * These are created using query_short_rotten_adjective and 
 * query_long_decay_level, and are based on the percentage by which it has 
 * cooled.
 * <P>
 * 
 * Differant messages can be displayed when the food is eaten hot or cold
 * These can be set using set_hot_eat_message() and set_cold_eat_message()
 * Messages can also be set for eating bites of food where appropriate
 * using setup_cold_eat_piece_messages() and setup_hot_eat_piece_messages()
 * 
 * @author Sightblinder
 * 
 */

#include <bits_controller.h>
#include <weather.h>

inherit "/obj/food";

#define WARM 10        /* By how much eating this will warm you */
#define WARM_TIME 60   /* For how long eating this will warm you */
#define COOL_RATE_DEFAULT 10  /* The default cool rate, initially corresponding
                               * to 100 seconds for something of weight 1 to 
                               * cool away to nothing in a 20 deg. C 
                               * environment 
                               */                            
/* GLOBAL VARIABLES */
private int _cool_level;          /* this represents the amount left to cool.  
                                     A value of 1 = stone cold. */
private int _cool_rate;           /* This determines how quickly the item cools
                                    by controlling the frequency of the cooling 
                                    call.*/
private int _purchase_time;       /* The time the food was bought.  Used to
                                   * calculate how much it has cooled by. */
private mixed _hot_eat_message;   /* The messeage returned when the food is 
                                   * eaten while still hot. */
private mixed _cold_eat_message;  /* The messeage returned when the food is 
                                   * eaten while cold. */
private mixed _hot_eat_piece_message;  /* Messages returned by           */
private mixed _hot_eat_amt_message;    /* setup_eat_piece_messages when  */
private mixed _hot_eat_last_message;   /* dealing with hot or cold food. */
private mixed _cold_eat_piece_message; /*                                */
private mixed _cold_eat_amt_message;   /*                                */
private mixed _cold_eat_last_message;  /*                                */
 
/* FUNCTION PROTOTYPES */
void create();
void set_cool_rate( int rate );
void set_cool_level(int level);
int query_cool_rate();
int query_cool_level();
protected void do_cool();
void set_hot_eat_mess(mixed messages);
void set_cold_eat_mess(mixed messages);
mixed query_hot_eat_mess();
mixed query_cold_eat_mess();
void setup_cold_eat_piece_messages(mixed piece, mixed amt, mixed last);
void setup_hot_eat_piece_messages(mixed piece, mixed amt, mixed last);
mixed query_hot_eat_amt_message;
mixed query_hot_eat_piece_message;
mixed query_hot_last_message;
mixed query_cold_eat_amt_message;
mixed query_cold_eat_piece_message;
mixed query_cold_last_message;
/**
 * @ignore yes
 */
void create() {
   do_setup++;
   ::create();
   do_setup--;
   _cool_rate = COOL_RATE_DEFAULT;
   set_decay_speed( 1 );
   if ( !do_setup ) this_object()->setup();
   _cool_level = ( this_object()->query_weight() ) * 20;
   _purchase_time = time();
}/* create() */

/**
 * This function sets the current cooling rate for the food.  This will
 * have no real affect on the cooling of the food, as the cool rate is 
 *recalculated regularly.
 *
 * @param rate The new rate of cooling
 *
 * @see query_cool_rate()
 *
 */
void set_cool_rate( int rate ) {
   _cool_rate = rate;
} /* set_cool_rate */

/**
 * This function returns the current rate of cooling of the hot food.
 *
 * @return The current cooling rate of the food.
 *
 * @see set_cool_rate()
 *
 */
int query_cool_rate() {
   return _cool_rate;
} /* query_cool_rate */

/**
 * This function returns the current cool level of the food.  This value
 * starts at twenty times the original weight of the object, and decreases
 * in time, as the food cools. 1 = stone cold.
 *
 * @return The current cool level of the food.
 */
int query_cool_level() {
   return _cool_level;
} /* query_cool_level */

/**
 * This function returns the adjective appended to the food's
 * short description, describing how cooled or decayed it is.
 *
 * @return The adjectives added to the food's short describing its
 * state of cooling or decay if already cold.
 * @see query_long_decay_level()
 */
string query_short_rotten_adjective() {
   string ret;
   if (this_object()->query_cool_level() == 7){
       return ("cold " + ::query_short_rotten_adjective());
   }
   _cool_level = (time() - _purchase_time)/_cool_rate;
   ret = "";
   switch ( _cool_level ) {
     case 0..1:
        ret="piping hot " + ret;
        break;
     case 2:
        ret = "slightly cooled " + ret;
        break;
     case 3:
        ret = "partially cooled " + ret;
        break;
     case 4:
        ret = "half cooled " + ret;
        break;
     case 5:
        ret = "mostly cooled " + ret;
        break;
     case 6:
        ret = "almost completely cooled " + ret;
        break;
     default:
        ret ="stone cold " + ret;
        break;
        }
   return ret; 
} /* query_short_rotten_adjective */


/**
 * This function provides words for the food's long description, 
 * showing how cooled or decayed the object is.
 * 
 * @return The words appended to the food's long, showing its state of 
 *  cooling, or decay if it's already cold.
 *
 * @see query_short_rotten_adjective()
 */
string query_long_decay_level() {
   string ret;
   int flag;   
   if(query_collective() && query_amount() > 1 ) flag = 1;  
   if (this_object()->query_cool_level() == 7){
       return ("It is stone cold. " + ::query_long_decay_level());
   }
   ret = "";
  _cool_level = (time() - _purchase_time)/_cool_rate;
   
   switch ( _cool_level) {
     case 0..1:
          ret += (flag?
          "They have not yet begun to cool.\n":
          "It has not yet begun to cool.\n");
        break;
     case 2:
           ret += (flag?
           "They have cooled slightly.\n":
           "It has cooled slightly.\n");
        break;
     case 3:
           ret += (flag?
           "They have partially cooled.\n":
           "It has partially cooled.\n");
        break;
     case 4:
           ret += (flag?
           "They are half cooled.\n":
           "It is half cooled.\n");
        break;
     case 5:
           ret += (flag?
           "They have mostly cooled.\n":
           "It has mostly cooled.\n");
        break;
     case 6:
           ret += (flag?
           "They are almost completely cold.\n":
           "It is almost completely cold.\n");
        break;
     default:
           ret += (flag?
           "They are stone cold.\n":
           "It is stone cold.\n");
        break;
        }
    return ret; 
} /* query_long_decay_level */

/*
 *  If the food is still hot make the person warm for a while when they eat
 *  it.  Then inherit normal eat stuff.
 */
/**
 * @ignore yes
 */
varargs int do_eat( int no_mess ) {
  int current_warmth;
  int remaining_time;
  int new_warmth;
  int new_time;
  
  if(this_object()->query_cool_level() >= 7 ){ 
    if (this_object()->query_weight_per_bite()){
      setup_eat_piece_messages(this_object()->query_cold_eat_piece_message(),
                               this_object()->query_cold_eat_amt_message(),
                               this_object()->query_cold_eat_last_message());
      }
    else {
      set_eat_mess( this_object()->query_cold_eat_message() );
      }
     return( ::do_eat( no_mess ));
  }
  if(this_player()->query_property("warmth")){
    current_warmth = this_player() -> query_property("warmth");
    remaining_time = this_player() -> query_property_time_left("warmth");
    new_warmth = current_warmth+WARM;
    new_time = (remaining_time + WARM_TIME)*0.75;
    this_player()->add_property( "warmth",new_warmth,new_time);
    }
  else{
     this_player()->add_property("warmth",WARM,WARM_TIME);
     }
  if(this_object()->query_weight_per_bite()){
    setup_eat_piece_messages(this_object()->query_hot_eat_piece_message(),
                                 this_object()->query_hot_eat_amt_message(),
                                 this_object()->query_hot_eat_last_message());
      }
  else{
    set_eat_mess( this_object()->query_hot_eat_message() );
    }
  return( ::do_eat( no_mess ) );
} /* do_eat() */


/* This function sets up the message seen by the player when they eat the food
 * while it is still hot.
 * <P>
 * @param The message displayed when the food is eaten hot.
 * <P>
 * @see query_hot_eat_message(), set_cold_eat_message(), 
 * @see query_cold_eat_message().
*/
void set_hot_eat_message(mixed messages){
   _hot_eat_message = messages;
}

/* This function sets up the message seen by the player when they eat the food
 * when it is cold.
 * <P>
 * @param The message displayed when the food is eaten cold.
 * <P>
 * @see query_cold_eat_message(), set_hot_eat_message(), 
 * @see query_hot_eat_message().
*/
void set_cold_eat_message(mixed messages){
   _cold_eat_message = messages;
}

/* This function sets up the message seen by the player when they eat the food
 * while it is still hot.
 * <P>
 * @return The message displayed when the food is eaten hot.
 * <P>
 * @see set_hot_eat_message(), set_cold_eat_message(), 
 * @see query_cold_eat_message().
*/
mixed query_hot_eat_message(){
  return _hot_eat_message;
}

/* This function sets up the message seen by the player when they eat the food
 * when it is cold.
 * <P>
 * @return The message displayed when the food is eaten cold.
 * <P>
 * @see set_cold_eat_message(), set_hot_eat_message(), 
 * @see query_hot_eat_message().
*/
mixed query_cold_eat_message(){
  return _cold_eat_message;
}
void setup_hot_eat_piece_messages(mixed piece, mixed amt, mixed last) {
   _hot_eat_piece_message = piece;
   _hot_eat_amt_message = amt;
   _hot_eat_last_message = last;
}    

void setup_cold_eat_piece_messages(mixed piece, mixed amt, mixed last) {
   _cold_eat_piece_message = piece;
   _cold_eat_amt_message = amt;
   _cold_eat_last_message = last;
}            

mixed query_cold_eat_piece_message(){
  return _cold_eat_piece_message;
}

mixed query_cold_eat_amt_message(){
  return _cold_eat_amt_message;
}

mixed query_cold_eat_last_message(){
  return _cold_eat_last_message;
}
mixed query_hot_eat_piece_message(){
  return _hot_eat_piece_message;
}

mixed query_hot_eat_amt_message(){
  return _hot_eat_amt_message;
}

mixed query_hot_eat_last_message(){
  return _hot_eat_last_message;
}

/**
 * @ignore yes
 */
mixed *stats(){
   mixed *args;
   args =::stats() + ({ ({ "cool level", _cool_level }),
                        ({ "cool rate", _cool_rate }),
                        ({ "purchase time", _purchase_time }) });
   return args;
}/* stats() */

/*
 * This section covers all the loading of global variables
 */
/**
 * @ignore yes
 */
mapping int_query_static_auto_load(){
   return ([ "::" : ::int_query_static_auto_load(),
             "cool_level" : _cool_level,
             "cool rate" : _cool_rate,
             "purchase time" : _purchase_time ]);
} /* int_query_static_auto_load() */

/**
 * @ignore yes
 */
mapping query_static_auto_load(){
   if ( ( base_name( this_object() ) != "/obj/food" )
       && !query_continuous() ) {
      return 0;
   }
   return int_query_static_auto_load();
} /* query_static_auto_load() */

/**
 * @ignore yes
 */
void init_static_arg( mapping map ){
   if ( !mapp( map ) ) return; 
   if ( map[ "::" ] ) ::init_static_arg( map[ "::" ] );
   _cool_level = map[ "cool_level" ];
   _cool_rate = map[ "cool rate" ];
   _purchase_time = map [ "purchase time" ];
} /* init_static_arg() */

/**
 * @ignore yes
 */
mapping query_dynamic_auto_load(){
   return ([ "::" : ::query_dynamic_auto_load(),
             "cool_level" : _cool_level,
             "cool rate" : _cool_rate,
             "purchase time" : _purchase_time ]);
} /* query_dynamic_auto_load() */

/**
 * @ignore yes
 */
void init_dynamic_arg( mapping map, object ){
   if ( !mapp( map ) ) return;
   if ( map[ "::" ] ) ::init_dynamic_arg( map[ "::" ] );
   _cool_level = map[ "cool_level" ];
   _cool_rate = map[ "cool rate" ];
   _purchase_time = map [ "purchase time" ];
} /* init_dynamic_arg() */

/*
 * This is all masked stuff from /obj/food.c which stops
 * hot food from decaying while it's still hot.
 */

/*
 *  Food wont decay untill it's cold.  Then it decays in normal fashion.
 */
/**
 * @ignore yes
 */
void do_decay() {
   if (this_object()->query_cool_level()>1) return;
   ::do_decay();
} /* do_decay */


/**
 * @ignore yes
 */
int query_decays() {
   if (this_object()->query_cool_level()>1) return 0;
   return 1;
} /* query_decays() */

/**
 * @ignore yes
 */
int query_decay_speed() {
   if (this_object()->query_cool_level()>1) return 0;
   return (::query_decay_speed());
} /* query_decay_speed() */

/**
 * @ignore yes
 */
int query_decay_level() { 
   if (this_object()->query_cool_level()>1) return 0;
   return (::query_decay_level());
} /* query_decay_level() */

/**
 * @ignore yes
 */
void set_decay_speed( int decay ) {
  if (this_object()->query_cool_level()>1) return( ::set_decay_speed( 0 ) );
  return( ::set_decay_speed( 7200 ) );
} /* set_decay_speed() */

/* Mask set_main_plural() cos it breaks the short descriptions if its been 
 * set, so we leave it to the pluralizer to sort out.  If it turns out this 
 * messes things up too much for object names then it will need to be modified
 * to mask the values returned by query_multiple_short().  Yes it's a hack, 
 * but the best I could do at the time.
 */

/**
 * @ignore yes
 */
void set_main_plural(mixed str) {
   return;
}


// --- END [/mnt/home2/grok/lib/obj/hotfood.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/scabbard.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/scabbard.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628604   Available: 13575958
Inodes: Total: 5242880    Free: 4960134
6721 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/scabbard.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628604   Available: 13575958
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $locker: shrike $
 * $Id: scabbard.c,v 1.19 2003/04/23 10:03:31 runtime Exp $
 */

#include <move_failures.h>
#include <virtual.h>

inherit "/std/container";
inherit "/std/basic/wearable";

string sheath;
string * types;
int _no_types_in_long;

/** @ignore yes */
void create() {
   do_setup++;
   container::create();
   wearable::create();
   do_setup--;
   sheath = "";
   types = ({ });
   _no_types_in_long = 0;
   add_alias( "scabbard" );
   add_plural( "scabbards" );
   if ( !query_property( "shop type" ) )
      add_property( "shop type", "armoury" );
   if ( !do_setup )
      this_object()->setup();
} /* create() */

/**
 * This method determines if the object is a scabbard or not.
 * @return always returns 1 for a scabbard
 */
int query_scabbard() { return 1; }

/**
 * This method returns the types of weapons that can be sheathed in the
 * scabbard.
 * @return the types that can be sheathed
 */
string *query_types() { return types; }

/**
 * This method sets the types of weapons that can be sheathed in the
 * scabbard.
 * @param words the array of types that can be sheathed
 */
void set_types( string *words ) {
   types = words;
   switch ( sizeof( types ) ) {
      case 0 :
         sheath = "";
         return;
      case 1 :
         sheath = "It could sheathe "+ add_a( types[ 0 ] ) +".\n";
         return;
      case 2 :
         sheath = "It could sheathe "+ add_a( types[ 0 ] ) +" or "+
               types[ 1 ] +".\n";
         return;
      default :
         sheath = "It could sheathe "+ add_a( types[ 0 ] ) +", "+
               implode( types[ 2 .. ], ", " ) +" or "+ types[ 1 ] +
               ".\n";
   }
} /* set_types() */

int test_type_ok( object thing, int flag ) {
  foreach( string word in types ) {
    if( thing->full_id( word ) )
      return ::test_add( thing, flag );
  }
  return 0;
} /* test_type_ok() */

/** @ignore yes */
varargs int test_add( object thing, int flag, int noprint ) {
   int foo;

   if(flag)
      return 0;

   if( !environment( thing ) )
      return ::test_add( thing, flag );
   if( first_inventory( this_object() ) ) {
      if( !noprint )
         write( the_short() + " already holds " +
           first_inventory( this_object() )->a_short() + ".\n" );
      return 0;
   }

   foo = test_type_ok( thing, flag );
   if(foo)
      return foo;
   if( !noprint )
      write( thing->the_short() + " doesn't fit very well in "
        + the_short() + ".  " + sheath );
   return 0;
} /* test_add() */

/** @ignore yes */
string long( string word, int dark ) {
   string foo = _no_types_in_long ? "" : sheath;

   if ( dark == 2 || dark == -2) {
      return container::long( word, dark );
   }
   return container::long( word, dark ) + foo +
         query_contents( "$C$"+ the_short() +" contains: " ) +
         wearable::long( word, dark );
} /* long() */

/** @ignore yes */
int query_ac( string type, int amount ) {
   do_damage( type, amount );
} /* query_ac() */

/**
 * This method sets up the scabbards current condition.
 * @param number the current condition fo the scabbard
 */
void setup_scabbard( int number ) {
   set_max_cond( number );
   set_cond( number );
   set_lowest_cond( number );
} /* setup_scabbard() */

/** @ignore yes */
int query_value() {
   return modify_value( container::query_value() );
} /* query_value() */

/** @ignore yes */
int query_full_value() { return container::query_value(); }

/** @ignore yes */
int drop(mixed dest) {
   if ( worn_by )
      if ( living( worn_by ) )
         return 1;
   return container::drop(dest);
} /* drop() */

/** @ignore yes */
varargs int move( mixed dest, string messin, string messout ) {
   int flag;
   flag = container::move( dest, messin, messout );
   if ( ( flag == MOVE_OK ) && worn_by )
      set_worn_by( 0 );
   return flag;
} /* move() */

/** @ignore yes */
void dest_me() {
   set_worn_by( 0 );
   container::dest_me();
} /* dest_me() */

/** @ignore yes */
void break_me() {
   if ( worn_by )
      all_inventory()->move( environment( worn_by ), "$N fall$s from "+
            a_short() +"." );
   else
      all_inventory()->move( environment(), "$N fall$s out of "+
            a_short() +"." );
   ::break_me();
} /* break_me() */

/** @ignore yes */
mixed *stats() {
   return container::stats() + wearable::stats();
} /* stats() */

/** @ignore yes */
mapping query_static_auto_load() {
   if ( explode( file_name( this_object() ), "#" )[ 0 ] != "/obj/scabbard" )
      return ([ ]);
   return ([
      "::" : container::int_query_static_auto_load(),
      "wear" : wearable::query_static_auto_load(),
      "types" : types,
      "_no_types_in_long" : _no_types_in_long,
   ]);
} /* query_static_auto_load() */

/** @ignore yes */
mapping query_dynamic_auto_load() {
   return ([
      "::" : container::query_dynamic_auto_load(),
      "wear" : wearable::query_dynamic_auto_load()
   ]);
} /* query_dynamic_auto_load() */

/** @ignore yes */
void init_static_arg( mapping map ) {
   if ( !mapp( map ) )
      return;
   if ( map[ "::" ] )
      container::init_static_arg( map[ "::" ] );
   if ( map[ "wear" ] )
      wearable::init_static_arg( map[ "wear" ] );
   if ( pointerp( map[ "types" ] ) )
      set_types( map[ "types" ] );
   if ( map[ "_no_types_in_long" ] )
      _no_types_in_long = map[ "_no_types_in_long" ];
} /* init_static_arg() */

/** @ignore yes */
void init_dynamic_arg( mapping map, object ob ) {
   mapping stat_temp;
   string virt_name, new_name;

   if ( map[ "::" ] )
      container::init_dynamic_arg( map[ "::" ], ob );
   if ( map[ "wear" ] )
      wearable::init_dynamic_arg( map[ "wear" ], ob );

   if( virt_name = query_property( VIRTUAL_NAME_PROP ) ) {
     if( file_size( virt_name ) == -1 ) {
       new_name = ( CLONER )->other_file( virt_name );
       if( stringp( new_name ) && ( new_name != virt_name ) ) {
         add_property( VIRTUAL_NAME_PROP, new_name );
         virt_name = new_name;
       } else {
         if( VIRTUAL_HANDLER->query_forbidden( virt_name ) ) {
           call_out( "replace_me", 1 );
         } else {
           VIRTUAL_HANDLER->add_missing( virt_name );
         }
       }
     }
     if( file_size( virt_name ) != -1 &&
         query_property( "virtual time" ) < stat( virt_name )[1] ) {
       stat_temp = ( VIRTUAL_HANDLER )->new_data( virt_name );
       if( mapp( stat_temp ) ) {
         init_static_arg( stat_temp );
         add_property( "virtual time", time() );
       }
     }
   }
} /* init_dynamic_arg() */

int no_types_in_long() {
   return _no_types_in_long;
} /* no_types_in_long() */

int set_no_types_in_long( int val ) {
   _no_types_in_long = val ? 1 : 0;
   return _no_types_in_long;
} /* set_no_types_in_long() */
// --- END [/mnt/home2/grok/lib/obj/scabbard.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/media/sand.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/media/sand.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628602   Available: 13575956
Inodes: Total: 5242880    Free: 4960134
1045 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/media/sand.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628602   Available: 13575956
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
inherit "/obj/cont_medium";

/* One unit = 1 grain of sand.  About.  I'm roughing this
 * heavily.
 */
void setup()
{
  set_name("sand");
  set_short("sand");
  set_main_plural( "sand" );
  add_adjective( ({ "some", "grain", "pinch", "measure", "handful",
    "hatful", "beach", "of" }) );
  set_long("This is some lovely soft sand, the type that you'd find on "
    "a beach.\n");
  add_property("determinate", "some ");
  set_weight_unit( ({ 1, 1000 }) ); /* 1000 grains in 50 grams? */
  set_value_scale( 0.00001 ); /* "cheap as sand" */
  set_medium_alias("BeachAndDesertSand");
  set_pile_name("pile");
  set_continuous();
  set_amount_types( ([
    "grain": ({ 1, "grains" }),
    "pinch": ({ 40, "pinches" }),
    "measure": ({ 200, "measures" }),
    "handful": ({ 10000, "handfuls" }),
    "hatful": ({ 50000, "hatfuls" }),
    "beach": ({ 1000000, "beaches" }),
    ]) );
  set_pile_types( ({
    40, "tiny",
    10000, "small",
    50000, "medium",
    200000, "large",
    "huge"
    }) );
  set_amount(12000);
}
// --- END [/mnt/home2/grok/lib/obj/media/sand.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/lantern.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/lantern.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628601   Available: 13575955
Inodes: Total: 5242880    Free: 4960134
3239 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/lantern.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628601   Available: 13575955
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:56.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*      
  Basic lantern inherit to use till the new improved and nifty one is 
  made by someone else.
*/
#include <fuel_handler.h>

inherit "/std/object";

#define BRIGHTNESS      60
#define FUEL_PER_TICK  FUEL_TIME
#define MAX_FUEL 3600
 
/*
    Global variables.
*/
int  fuel_left;
int  is_lit;
 
void create(){
  ::create();

}

string short( int i ) {
  if ( is_lit )
    return ::short( 0 ) + " (lit)";
 
  return ::short( 0 );
}
 
int do_extinguish() {
   if ( !is_lit ) {
      this_player()->add_failed_mess(this_object(), "$D is not lit.\n", ({ }));
      return 0;
   }
   FUEL_HANDLER->remove_burner( this_object() );
   is_lit = 0;
   set_light( 0 );
   return 1;
} /* dest_me() */

int do_dowse() {
   return do_extinguish();
} /* do_dowse() */
 
int do_light() {
   if ( is_lit ) {
      this_player()->add_failed_mess( this_object(), "$D is already lit.\n",
                                     ({ }) );
      return 0;
   }
   if ( fuel_left <= 0 ) {
      this_player()->add_failed_mess( this_object(), "$D is out of fuel.\n",
                                     ({ }) );
      return 0;
   }
   FUEL_HANDLER->add_burner( this_object() );
   is_lit = 1;
   set_light( BRIGHTNESS );
   return 1;
}

void init() {
   this_player()->add_command("light", this_object());
   this_player()->add_command("extinguish", this_object());
   this_player()->add_command("dowse", this_object());
}

void out_of_fuel() {
   object env;
 
   is_lit    = 0;
   fuel_left = 0;
   env = environment( this_object() );
   FUEL_HANDLER->remove_burner( this_object() );
   set_light( 0 );

   if ( interactive( env ) ) {
      write( poss_short() +" burns out.\n" );
      tell_room( environment(env), poss_short() +" burns out.\n", env );
   } else 
      say( poss_short() +" burns out.\n" );
} /* out_of_fuel() */
 
void consume_fuel() {
   fuel_left -= FUEL_PER_TICK;
   switch ( fuel_left ) {
    case -10000 .. 0:
      out_of_fuel();
      break;
    default:
      /* do nothing */
   }
} /* consume_fuel() */

string pretty_plural( object thing) {
  if ( is_lit )
    return ::pretty_plural(thing) + " (lit)";
 
  return ::pretty_plural(thing);
} /* pretty_plural() */
 
void dest_me() {
   set_light( 0 );
   FUEL_HANDLER->remove_burner( this_object() );
   ::dest_me();
} /* dest_me() */
 
mixed *stats() {
  return ::stats() + ({
    ({ "fuel" , fuel_left, }),
    ({ "is lit", is_lit, }),
   });
} /* stats() */

mapping query_dynamic_auto_load() {
   return ([ "::" : ::query_dynamic_auto_load(),
             "fuel left" : fuel_left,
             "is lit" : is_lit,
          ]);
} /* query_dynamic_auto_load() */

void init_dynamic_arg( mapping arg ) {
   fuel_left = arg["fuel left"];
   if ( arg[ "is lit" ] ) {
      FUEL_HANDLER->add_burner( this_object() );
      is_lit = 1;
      set_light(BRIGHTNESS);
   }
   ::init_dynamic_arg( arg["::"] );
} /* init_dynamic_arg() */
 
int query_fuel_left() { 
    return fuel_left;
} /* query_fuel_left() */

void set_fuel_left( int i ) {
    if ( i > MAX_FUEL ) {
        i = MAX_FUEL;
    }

    fuel_left = i;
} /* set_fuel_left() */

/**
 * This method returns the maximum amount of fuel for the object.
 */
int query_max_fuel() {
    return MAX_FUEL;
} /* query_max_fuel() */
// --- END [/mnt/home2/grok/lib/obj/lantern.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/team.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/team.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628600   Available: 13575954
Inodes: Total: 5242880    Free: 4960134
10728 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/team.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628600   Available: 13575954
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: team.c,v 1.3 1999/10/28 02:22:12 ceres Exp $
 * $Log: team.c,v $
 * Revision 1.3  1999/10/28 02:22:12  ceres
 * tweaks
 *
 * Revision 1.2  1998/07/13 04:29:44  pinkfish
 * Fixed up a couple of things that shouldmake it stop giving empty team lists...
 *
 * Revision 1.1  1998/01/06 05:03:33  ceres
 * Initial revision
 * 
*/
#define CREATOR "Ceres"
/**
 * This handler deals with grouping players into teams. Teams are entirely
 * optional.  The handler deals with creating, joining, leaving and ending
 * teams.  It also provides functions to find out who's a member of which
 * team etc.<p>
 *
 * Commands will be available to do group things (group chatting, group
 * health etc.) By default team members will protect each other and follow
 * the leader.
 *
 * @author Ceres
 * @started June 96
 */

#include <login_handler.h>

#define SHADOW "/std/shadows/misc/team"
#define MAX_GROUP_SIZE 5

class group {
  object leader;    // the team leader
  int policy;       // the follow policy
  object *members;  // list of members
  int locked;       // is this group open to new members
}

mapping groups,     // all the teams
        members;    // which team each player is a member of

private void check_group(string g_name);
private void disband_group(string g_name, string p_name);
private void tidy_members(string g_name);

/** @ignore yes */
void create() {
  members = ([ ]);
  groups = ([ ]);
} /* create() */

/** @ignore yes */
void dest_me() {
  destruct(this_object());
} /* dest_me() */

/**
 * When a player leaves the game automatically remove them from their team.
 * this function is called automatically by the login handler for every
 * player who leaves the game
 * @param p_name the player name who is leaving
 * @param type the type of action being preformed
 * @see /obj/handlers/login_handler
 */
void leaving(string p_name, string type) {
  class group record;
  string g_name;

  if((type != "logout") || (!members[p_name]))
    return;

  g_name = members[p_name];
  record = (class group)groups[g_name];

  map_delete(members, p_name);

  if(!record)
    return;
  
  // no leader? Then disband the group.
  if((record->leader == 0) || ((record->leader)->query_name() == p_name)) {
     disband_group(g_name, p_name);

#ifdef LOG_FILE    
    log_file(LOG_FILE, sprintf("%s %s has left the game, the %s has been "
                             "disbanded.\n", ctime(time()), p_name, g_name));
#endif    

  } else {
#ifdef LOG_FILE
    log_file(LOG_FILE, sprintf("%s %s left the game while a member of the %s\n",
                             ctime(time()), p_name, g_name));
#endif    
    record->members = delete(record->members,
                             member_array(0, record->members), 1);
  }
  return;
} /* leaving() */

/* Group modification functions */

/**
 * This method creates a new team.
 * @param g_name the name of the group
 * @param leader the leader of the group (object)
 * @param policy the policy of the group
 * @see end_group()
 */
int new_group(string g_name, object leader, int policy) {
  class group record;
  
  if(!undefinedp(groups[g_name]))
    return 0;

  record = new(class group);

  record->leader = leader;
  record->policy = policy;
  record->members = ({ leader });

  groups[g_name] = record;

  members[leader->query_name()] = g_name;

  leader->set_title( "TEAM", "Team Leader of "+ g_name );
   clone_object( SHADOW )->setup_shadow( leader );

#ifdef LOG_FILE
  log_file(LOG_FILE, sprintf("%s %s created by %s\n", ctime(time()),
                           g_name, leader->query_name()));
#endif  
  return 1;
} /* new_group() */

/**
 * This method ends a group.  Closes it, finishes it, done, finito.
 * @param g_name the name of the group to close
 * @see new_group()
 */
int end_group(string g_name) {
  class group record;
  object player;
  
  if(undefinedp(groups[g_name]))
    return 0;

  record = groups[g_name];
  
  // mark all group members as not being members of a group anymore
   foreach( player in record->members )
      if ( player ) {
         map_delete( members, player->query_name() );
         player->remove_title( "TEAM" );
         player->destruct_team_shadow();
      }
   
  
  map_delete(groups, g_name);

#ifdef LOG_FILE
  log_file(LOG_FILE, sprintf("%s %s disbanded\n", ctime(time()), g_name));
#endif  
  return 1;
} /* end_group() */

// join an already existing team
/**
 * This method joins a player into an existing group.
 * @param g_name the name of the group to join
 * @param player the player to join to the group
 * @see new_group()
 * @see end_group()
 * @see leave_group()
 */
int join_group(string g_name, object player) {
  class group record;

  if(undefinedp(groups[g_name]))
    return 0;

  record = groups[g_name];
  record->members += ({ player });

  members[player->query_name()] = g_name;

   player->set_title( "TEAM", "Team Member of "+ g_name );
   clone_object( SHADOW )->setup_shadow( player );

#ifdef LOG_FILE
  log_file(LOG_FILE, sprintf("%s %s joined by %s\n", ctime(time()),
                           g_name, player->query_name()));
#endif  
  return 1;
} /* join_group() */

// leave a team
/**
 * This method removes a player from the group.
 * @param g_name the name of the group to leave
 * @param player the player to leave the group
 * @see join_group()
 */
int leave_group(string g_name, object player) {
  class group record;
  
  if(player) {
    map_delete(members, player->query_name());

      player->remove_title( "TEAM" );
      player->destruct_team_shadow();

#ifdef LOG_FILE
    log_file(LOG_FILE, sprintf("%s %s left by %s\n", ctime(time()), g_name,
                             player->query_name()));
#endif    
  }

  if(undefinedp(groups[g_name]))
    return 0;

  record = groups[g_name];

  if(member_array(player, record->members) == -1)
    return -1;

  record->members = delete(record->members,
                           member_array(player, record->members), 1);

  return 1;
} /* leave_group() */


/* Group interrogation functions. */

/**
 * This method determine the owner (leader)  of a team.
 * @param g_name the name of the group to get the owner for
 * @return the object refering to the owner
 * @see query_members()
 * @see query_policy()
 */
object query_owner(string g_name) {
  class group record;

  if(undefinedp(groups[g_name]))
    return 0;

  record = (class group)groups[g_name];

  return record->leader;
} /* query_owner() */

/**
 * This method returns the members of the team.
 * @param g_name the name of the group to get the member of
 * @return the members names as strings
 * @see query_owner()
 * @see query_policy()
 * @see query_leader()
 */
object *query_members(string g_name) {
  class group record;
  
  if(undefinedp(groups[g_name]))
    return 0;

  tidy_members(g_name);

  record = groups[g_name];

  return (object *)record->members;

} /* query_members() */

/**
 * This method returns the policy of the team
 * @param g_name the name of the team
 * @return the policy of the team
 * @see query_members()
 * @see query_leader()
 */
int query_policy(string g_name) {
  class group record;
  
  if(undefinedp(groups[g_name]))
    return 0;

  record = groups[g_name];
  return (int)record->policy;

} /* query_policy() */

/**
 * This method finds out which team player is a member of.
 * @param player the player to find the team of
 * @return the team they are a member of
 */
string query_group(object player) {
  if(undefinedp(members[player->query_name()]))
    return 0;

  return members[player->query_name()];
} /* query_group() */

/**
 * This method determine if a team exists.
 * @param g_name the name of the team
 * @return 1 if the team exists, 0 if not
 * @see new_group()
 * @see query_group()
 */
int test_group(string g_name) {
  if(undefinedp(groups[g_name]))
    return 0;

  return 1;
} /* test_group() */

/**
 * This method checks if its ok to join a group.
 * @param g_name the name of the group
 * @return 1 if the team is full, 0 if not
 * @see join_group()
 */
int query_full(string g_name) {
  class group record;
  object member;
  
  if(undefinedp(groups[g_name]))
    return 0;

  tidy_members(g_name);
  
  record = (class group)groups[g_name];
  
  if(sizeof(record->members) >= MAX_GROUP_SIZE)
    return 1;

  return 0;
} /* query_full() */

/**
 * This method determines if the team is locked.
 * @param g_name the name of the team to test
 * @return 1 if locked, 0 if unlocked
 * @see set_locked()
 */
int query_locked(string g_name) {
  class group record;

  if(undefinedp(groups[g_name]))
    return 0;

  record = (class group)groups[g_name];
  return (record->locked);
} /* query_locked() */

/**
 * This method sets the lock flag on the team.
 * @param g_name the name of the team
 * @param lock the new lock flag
 * @see query_locked()
 */
int set_locked(string g_name, int lock) {
  class group record;

  if(undefinedp(groups[g_name]))
    return 0;

  record = (class group)groups[g_name];
  record->locked = lock;

  return 1;
} /* set_locked() */

// Admin functions for creators

/**
 * This methor returns the list all the current teams.
 * @return an array of all the current team
 */
string *list_groups() {
  string frog;

  foreach (frog in keys(groups)) {
    check_group(frog);
  }
  return keys(groups);
} /* list_groups() */

/* These methods are specificaly for sanity purposes. */
private void disband_group(string g_name, string p_name) {
  class group record;
  object person;
  object member;

  record = (class group)groups[g_name];
  // go through the team members removing them from their team and
  // removing their followers and protectors
  foreach(member in record->members) {

    if(!member) // just in case
      break;
    
    map_delete(members, member->query_name());
    
    foreach(person in member->query_protectors())
      member->remove_protector(person);

    foreach(person in member->query_followers())
      member->remove_follower(person);

    tell_object(member, p_name+" has left the game and so the "+g_name+
                " has been disbanded.\n");
  }
  map_delete(groups, g_name);
} /* disband_group() */

// This method checks the group to see if it has any bad members, ie: 0's.
private void check_group(string g_name) {
  class group record;

  record = (class group)groups[g_name];
  if (record->leader == 0) {
    /* Kill the group. */
    disband_group(g_name, "Your leader");
  } else {
    record->members -= ({ 0 });
  }
} /* check_group() */

private void tidy_members(string g_name) {
  class group record;
  object member;

  record = (class group)groups[g_name];

  foreach(member in record->members)
    if(!member)
      record->members -= ({ 0 });
}
// --- END [/mnt/home2/grok/lib/obj/handlers/team.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/cmr_library.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/cmr_library.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628598   Available: 13575952
Inodes: Total: 5242880    Free: 4960134
2609 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/cmr_library.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628598   Available: 13575952
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: cmr_library.c,v 1.3 1998/10/05 21:44:25 ceres Exp $
 * $Log: cmr_library.c,v $
 * Revision 1.3  1998/10/05 21:44:25  ceres
 * sojan fixed a bug
 *
 * Revision 1.2  1998/10/04 23:31:55  ceres
 * Added autodoc and fixed parameter names
 *
 * Revision 1.1  1998/01/06 05:03:33  ceres
 * Initial revision
 * 
*/

/**
 * Handler to keep track of which players know which materials. Allows you to
 * find out which materials a player knows about and add new ones.  This is
 * typically used in conjunction with the cmr_handler for materials which
 * the player must be taught about.
 *
 * @see cmr_handler
 * @author Deutha
 */
#define RESTORE_PATH "/save/cmr_library/"
 
inherit "/std/object";

string player_name, *materials;

/**
 * Initialise a players array of known materials.
 *
 * @param pname The name of the player.
 */
void init_data( string pname ) {
  player_name = pname;
  materials = ({ });
} /* init_data() */

/**
 * @ignore yes
 */
int get_data_file( string pname ) {
  if ( player_name != pname ) {
    if ( file_size( RESTORE_PATH + pname +".o" ) > 0 )
      unguarded((: restore_object, RESTORE_PATH + pname :));
    else {
      init_data( pname );
      return 0;
    }
  }
  return 1;
} /* get_data_file() */
 
/**
 * @ignore yes
 */
void save_data_file( string word ) {
  unguarded((: save_object, RESTORE_PATH + word :));
} /* save_data_file() */

/**
 * Return the materials known by a player.
 *
 * @param pname The name of the player
 * @return A string array of known materials.
 */
string *query_known_materials( string pname ) {
  get_data_file( pname );
  if ( !materials ) {
    return ({ });
  }
  return materials + ({ });
} /* query_known_materials() */

/**
 * Return whether the player knows a particular material.
 *
 * @param pname The name of the player.
 * @param material The name of the material
 * @return 1 if known 0 if not known.
 */
int query_known_material( string pname, string material ) {
  get_data_file( pname );
  if ( !materials ) return 0;
  return ( member_array( material, materials ) != -1 );
} /* query_known_material() */

/**
 * Mark a material as known by a given player.
 *
 * @param pname The name of the player
 * @param material The name of the material
 *
 * @return Returns 0 if they already knew the material, 1 if they know it now.
 */
int add_known_material( string pname, string material ) {
  get_data_file( pname );
  if ( member_array( material, materials ) != -1 ) {
    return 0;
  }
  materials += ({ material });
  save_data_file( player_name );
  return 1;
} /* add_known_material */
// --- END [/mnt/home2/grok/lib/obj/handlers/cmr_library.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/garbage.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/garbage.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628597   Available: 13575951
Inodes: Total: 5242880    Free: 4960134
10594 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/garbage.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628597   Available: 13575951
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Id: garbage.c,v 1.29 2003/05/14 17:29:31 ceres Exp $
 */

/** handler to remove junk lost in null-space from the mud so they wont waste
 * memory, and (if they have a heart_beat) cpu anymore. 
 */

nosave string *trouble = ({});
nosave mapping cloned_by = ([]);
nosave object *_rooms;
nosave int lag, lastlag, maxlag, minlag, burstlag, users;

#define DEBUG

// minimum time between reboots (3600 == 1 hour)
#define MIN_TIME 219599

// max time between reboots (133200 == 1 day 13 hours). The driver gets
// slower and slower if we stay up too long.
// 604800 is one week
//#define MAX_TIME 604800
// 219600 is 61 hours
#define MAX_TIME 219600

// maximum no. of faults per timer interval
#define FAULT_RATE 4500

// how long a room is idle before cleaning up
#define ROOM_IDLE_DELAY 7200
// if a room has been idle for this long dont clean it up again since
// its probably not going to go away.
#define ROOM_STABLE_DELAY 10800

#define NO_AUTO_REBOOT 1
//#define NO_TIMED_REBOOT 1

#define REBOOTS_PER_CRASH 6 
#define CHANGE_SPEED 6
#define SAVE_FILE "/save/garbage"

int max_time;
int crash;
int limit;

nosave int faults_prev;
nosave int stime_prev;
nosave int utime_prev;
nosave int uptime_prev;
nosave int rate_exceeded;
nosave int times_run;

//Filter function for the objects() efun we only want clones without references
//from other objects that are not shadowing stuff, not in a room and are not
//rooms themselves.
/**
 * @ignore yes
 */
#if efun_defined(get_garbage)
int get_junk(object ob){
  return ob->query_dest_other() == 0;
}
#else
int get_junk(object ob){
  if(!clonep(ob) || refs(ob) != 2 || query_shadowing(ob) ||
     environment(ob) || ob->query_dest_other())
    return 0;
  return 1;
}
#endif
//call_out id
nosave int id;

/**
 * @ignore yes
 */

void create(){
  function tmp;
  mapping map;

  unguarded(function(){
    restore_object(SAVE_FILE);
    if(!max_time) {
      max_time = MAX_TIME;
      crash = 1;
      limit = 1000;
      save_object(SAVE_FILE);
    } else {
      if(crash)
        max_time -= max_time/CHANGE_SPEED;
      else
        max_time += max_time/(CHANGE_SPEED*REBOOTS_PER_CRASH);
      if(max_time > MAX_TIME)
        max_time = MAX_TIME;
      crash = 1;
      save_object(SAVE_FILE);
    }
  });

  map = rusage();
  faults_prev = map["majflt"];
  stime_prev = map["stime"];
  utime_prev = map["utime"];
  uptime_prev = uptime();
  id = call_out("housekeeping", 300);
  tmp = function(function func) {
    int diff;
    
    diff = real_time() - time();
    
    if(diff > 2){
      diff -= 2;
      lag += diff;
      if(diff > maxlag) {
        maxlag = diff;
        if(maxlag > 600) { //10 minutes lag we probably stopped working
          //emergency shutdown
          master()->crash("Too much lag to recover");
          shutdown(0);
        }
      }
    }
    if(diff < minlag) {
      minlag = diff;
    }
    if(diff > 2 && (diff - lastlag > burstlag))
      burstlag = diff - lastlag;

    lastlag = diff;

    diff = sizeof(users());
    if(diff > users) {
      users = diff;
    }

    efun::call_out(func, 1, func);
  };
  call_out(tmp, 1, tmp);
}



/* A word of explanation from Ceres
   The system reboots based on the rate of major page faults ie. the rate of
   paging.  To handle updating of the drum it will not reboot if
   prev_faults is 0 and just in case, there is a minimum uptime as well.
   */
/**
 * @ignore yes
 */

void check_reboot() {
  int faults_now;
  int stime_now;
  int utime_now;
  mapping map;
  int reboot;
  
  map = rusage();
  stime_now = map["stime"];
  utime_now = map["utime"];
  faults_now = map["majflt"];

  event(users(), "inform",
        "Cpu usage for period = "+
        ((((utime_now-utime_prev) + (stime_now-stime_prev) ) / 10.0 )/
         (uptime() - uptime_prev))+"% Fault rate is "+
       (faults_now - faults_prev), "cpu");
  event(users(), "inform", "Machine lag is "+
        (lag/900) + " seconds (average) "+minlag+" seconds (min) "+
        maxlag+" seconds (max) "+burstlag+" seconds (burst)", "cpu");
  log_file("GARBAGE", "%s lag %d (%d/%d) burst %d users %d faults %d "
           "cpu %.1f%%\n",
           ctime(time())[4..18], (lag/900), minlag, maxlag, burstlag, 
           users, (faults_now - faults_prev),
           ((((utime_now-utime_prev) + (stime_now-stime_prev) ) /
             15.0 )/ (uptime() - uptime_prev)));
  
  // if we're already rebooting then don't do anything
  if(find_object("/obj/shut") && "/obj/shut"->query_time_to_crash() != 9999)
    return;

#ifndef NO_TIMED_REBOOT
  if(uptime() > max_time)
    reboot = 1;
#endif
    
#ifndef NO_AUTO_REBOOT
  if((uptime() > MIN_TIME) &&
     (faults_now > (faults_prev + FAULT_RATE))) {
    if(rate_exceeded) {
      reboot = 1;
    }
  } else {
    rate_exceeded = 1;
  } else {
    rate_exceeded = 0;
  }
#endif


  if(reboot) {
    shout("A'Tuin cries out: Too heavy, I need to put the Disc down for a "+
          "moment.\n");
    "/obj/shut"->shut(10);
    log_file("GARBAGE", ctime(time())[4..18]+" Auto; Faults: "+
             faults_now+", "+ faults_prev+"; uptime: "+uptime()+"; Cpu: "+
             ((((utime_now-utime_prev) + (stime_now-stime_prev) ) / 15.0 ) /
              (uptime() - uptime_prev))+
             "\n");
    /* Get a dump of the objects before we go down */
    //    dumpallobj();
    call_out(function(){
      crash = 0;
      unguarded((:save_object(SAVE_FILE):));
    }, 9*60);
    return;
  }

#if efun_defined(set_check_limit)
  if(lag > 900)
    limit += 5;
  if(lag < 300)
    limit--;
  limit = set_check_limit(limit);
#endif

  faults_prev = faults_now;
  uptime_prev = uptime();
  stime_prev = stime_now;
  utime_prev = utime_now;
  users = 0;
  lag = 0;
  maxlag = 0;
  burstlag = 0;
  minlag = 900;
} /* check_reboot() */

/** @ignore yes
 * This does a manual call of clean_up on rooms since the driver
 * doesn't seem to want to do it. :(
 * We do it every half hour after we've been up at least 1 hour.
 */
void start_cleanup() {
  int i;
  int t = real_time();
  
  // we're just doing rooms that haven't been visited for a while
  // (but not too long) and that dont want to keep loaded.
  _rooms = filter(objects((: function_exists("query_last_visited", $1) :)),
                  (: $1->query_keep_room_loaded() == 0 &&
                   $1->query_last_visited() < (time() - ROOM_IDLE_DELAY) &&
                   $1->query_last_visited() > (time() - ROOM_STABLE_DELAY):));
  
  for(i=(times_run % 2); i<sizeof(_rooms); i += 2)
    catch(_rooms[i]->clean_up());
  
  log_file("GARBAGE", "%s cleaning %d rooms. Current memory %.2fM\n",
           ctime(time())[4..18], i/2, (memory_info() / 1024000.0));
  event(users(), "inform",
        sprintf("Cleaning %d idle rooms", i/2), "cpu");

  if(real_time() - t > 1)
    log_file("GARBAGE", "%s room cleanup took %d seconds.\n",        
             ctime(time())[4..18], real_time() - t);
}

/**
 * @ignore yes
 * Do memory saving things.
 */
void tidy_up() {
  int rmem, ocount;

  // Perform reclamation of unreferenced objects.
  rmem = memory_info();
  ocount = reclaim_objects();
  rmem -= memory_info();
  
  event(users(), "inform",
        sprintf("Reclaimed %d object%s (%d byte%s)",
                ocount, (ocount == 1 ? "" : "s"),
                rmem, (rmem == 1 ? "" : "s") ), "cpu");
}

/**
 * @ignore yes
 */
void housekeeping() {
  string *tmpkeys;
  int i;
  object *junk;
  int t = real_time();

  //get the list of junk
  i = set_eval_limit(0);
  set_eval_limit(5000000);
#if efun_defined(get_garbage)
  junk = filter(get_garbage(), (:get_junk:));
#else
  junk = objects((:get_junk:));
#endif
  set_eval_limit(i);

  times_run++;
  
  call_out("check_reboot", 10);

  if(!(times_run % 3))          /* memory reclamation */
    call_out("tidy_up", 30);
  
  if(times_run > 4 && (times_run % 2 == 1)) /* room cleanup */
    call_out("start_cleanup", 60);

  //make sure it's in the list of trouble causing objects
  foreach(object ob in junk)
    trouble |= ({base_name(ob)});

  // Do this every 15 minutes.
  id = call_out((:housekeeping:), 15 * 60);

  // Log what caused the junk, and move the junk to the rubbish room
  // This needs alt_move because not all objects have a move function
  // alt_move is NOT for general usage.
  foreach(object ob in junk) {
#ifdef DEBUG
    if(cloned_by[file_name(ob)])
      log_file("GARBAGE_DEBUG", "%O cloned by %O\n", ob,
               cloned_by[file_name(ob)]);
#endif
    reset_eval_cost(); //sigh, need to fix the chatters!
    ob->dest_me();
  }
  
  //don't waste too much memory on that mapping
  tmpkeys = keys(cloned_by);
  if(sizeof(tmpkeys)>10000){
    cloned_by = ([]);
  }
#if !efun_defined(add_action)
  "/obj/handlers/livings"->remove_garbage();
#endif
  
  if(real_time() - t > 1)
    log_file("GARBAGE", "%s garbage cleanup took %d seconds.\n",        
             ctime(time())[4..18], real_time() - t);
}

/**
 * @ignore yes
 */

nosave private object armoury, cloner;

//called by clone_object
void cloned(object ob){
  object obcloner;
  if(!armoury)
    armoury = find_object("/obj/handlers/armoury");

  if(!cloner)
    cloner = find_object("/global/cloner");

  if(previous_object(1) != armoury && previous_object() != cloner){
    obcloner = previous_object(1);
  } else catch {
    int i = 2;
    obcloner = armoury;
    while(obcloner == armoury || obcloner == cloner)
      obcloner = previous_object(i++);
  };
    
  if(member_array(base_name(ob), trouble) != -1){
    //if objects of this type caused trouble before store how it got cloned
    //only store the object for now, we crash on this once per week otherwise
    string tmp = "";
#if 0
    int i, j;
    for(i = 2; i < sizeof(call_stack()); i++){
      if(!call_stack(1)[i])
        break;
      for(j = 0; j < 4; j++)
        tmp = sprintf("%s %O", tmp, call_stack(j)[i]);
      tmp += "\n";
    }
#endif
    cloned_by[file_name(ob)] = sprintf("%O\n%s", obcloner, tmp);
  }
  
  //make sure the call_out loop is still going
  if((find_call_out(id) < 0) && ((uptime() - uptime_prev) > (30 * 60)))
    id = call_out((:housekeeping:), 0);
}

/**
 * Return the number of seconds until the next reboot.
 */
int query_next_reboot() {
#ifndef NO_TIMED_REBOOT
  return max_time - uptime();
#else
  return -1;
#endif
}

int query_faults_prev() {
   return faults_prev;
} /* query_faults_prev() */

// change the max time, sometimes it's necessary.
void set_max_time(int i) { max_time = i; save_object(SAVE_FILE); }

void dest_me(){
  crash = 0;
  unguarded((:save_object(SAVE_FILE):));
  destruct(this_object());
}
// --- END [/mnt/home2/grok/lib/obj/handlers/garbage.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/mag_eff_handler.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/mag_eff_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628594   Available: 13575948
Inodes: Total: 5242880    Free: 4960134
10573 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/mag_eff_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628594   Available: 13575948
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: mag_eff_handler.c,v 1.3 2000/11/16 23:35:36 rodion Exp $
 * $Log: mag_eff_handler.c,v $
 * Revision 1.3  2000/11/16 23:35:36  rodion
 * Took out caterpillar stat-setting, as it was causing problems.
 * Rodion
 *
 * Revision 1.2  1998/04/23 14:01:25  pinkfish
 * Added documentation.  And cleanedup a little.
 *
 * Revision 1.1  1998/01/06 05:03:33  ceres
 * Initial revision
 * 
*/
/**
 * This handler controls the ambient enchantment effects and effects
 * from solid grains of octarine.  Ambient enchantment is caused by
 * the use of spells in certain locations.  Ambient enchantment can
 * be blocked by use of the property "enchantment block".
 * @author Deutha
 */
/*
 * Other effects:
 * shower of lead cubes
 * gibbering eldritch shapes
 *  4-sided triangles
 *  pineapple-flavoured custard
 *  double ended circles
 */

#define BLACK_MASS 1000
#define NUM_POSS 6
#define NUM_USER 20

private mixed *_octonite;
private int _call_out_no;

protected void update_octonite();
protected void schedule_next();

/**
 * This method checks to see if the particular object is blocking the use
 * of enchantments.
 * @param thing the object to check for enchantment block
 * @return 1 if it is blocking enchanments, 0 if not
 * @see do_effect()
 * @see ambient_enchantment()
 * @see choose_effect()
 */
int block( object thing ) {
   if ( !thing->query_closed() )
      return 0;
   return (int)thing->query_property( "enchantment block" );
} /* block() */

/**
 * This method returns the current ambient enchantment for the particular
 * object.
 * @param thing the object to get the ambient enchantment for
 * @return the ambient enchantment of the object
 * @see do_effect()
 * @see choose_effect()
 * @see block()
 */
int ambient_enchantment( object thing ) {
   int i, total;
   object *tops;

   tops = ({ thing });
   while ( environment( tops[ 0 ] ) ) {
      tops = ({ environment( tops[ 0 ] ) }) + tops;
   }
   for ( i = 0; i < sizeof( tops ); i++ ) {
      total += (int)tops[ i ]->query_enchant();
      total = ( total * ( 100 - block( tops[ i ] ) ) + 50 ) / 100;
   }
/*
   tell_object( find_player( "deutha" ), "Total for "+ file_name( thing ) +
         " is "+ total +".\n" );
*/
   return total;
} /* ambient_enchantment() */

/**
 * This method chooses a random effect from the curent list of effects
 * defined in the handler.  It returns an array consisting of
 * two elements, the first is the number, the second is a random
 * number between the input number multiplied by 6 and then divided
 * by 1000.
 * @param number the intput number
 * @return an array as described above
 * @see do_effect()
 * @see ambient_enchantment()
 * @see block()
 */
int *choose_effect( int number ) {
  return ({ number, random( NUM_POSS * number ) / BLACK_MASS });
} /* choose_effect() */

/**
 * This method causes an effect to occur.  The number is the severity
 * of the effect.
 * @param number the severity of the magic infestation
 * @param name the name of the thing being effected
 * @param place the place being effected (room)
 * @see choose_effect()
 * @see ambient_enchantment()
 * @see block()
 */
void do_effect( int number, string name, object place ) {
  int i;
  string word;
  object thing, *things;

  switch( number ) {
    case 0:
      tell_room( place, "How curious.\n" );
      break;
    case 1:
      tell_room( place, name +" spins slowly in mid-air, then "+
        "vanishes with a small \"pop!\"\n" );
      break;
    case 2:
      i = random( 4 );
      tell_room( place, name +" sparkles and turns into a small "+
        ({ "yellow", "green", "hairy", "spotted" })[ i ] +" caterpillar.\n" );
      thing = clone_object( "/obj/monster" );
      thing->set_name( "caterpillar" );
      thing->set_short( ({ "yellow", "green", "hairy", "spotted" })[ i ]
        +" caterpillar" );
      thing->add_adjective( ({ "yellow", "green", "hairy", "spotted" })[ i ] );
      thing->set_main_plural( ({ "yellow", "green", "hairy", "spotted" })[ i ]
        +" caterpillars" );
      thing->add_plural( "caterpillars" );
      thing->set_long( "This is a small, common or garden caterpillar.\n" );
      thing->set_race( "caterpillar" );
/*
      thing->set_no_check( 1 );
      thing->set_max_hp( 10 );
      thing->set_hp( 10 );
      thing->set_max_weight( 1 );
      thing->set_get();
*/
      thing->set_level( 1 );
      thing->move( place );
      break;
    case 3:
      tell_room( place, name +" vanishes with a sharp \"spang!\"\n"+
        "A moment later, you hear a small thunderclap.\n" );
      break;
    case 4:
      tell_room( place, "Balefire blossoms, and "+ name +" turns into "+
        "a bunch of flowers.\n" );
      thing = clone_object( "/std/object" );
      thing->set_name( "flowers" );
      thing->set_short( "bunch of flowers" );
      thing->set_main_plural( "bunches of flowers" );
      thing->add_adjective( ({ "bunch", "bunches", "of" }) );
      thing->add_plural( "bunches" );
      thing->set_long( "A nice bunch of flowers.\n" );
      thing->set_weight( 10 );
      thing->set_value( 100 );
      thing->move( place );
      break;
    case 5:
      tell_room( place, "With a small gout of flame, "+ name +" begins "+
        "to accelerate.\n" );
      switch( (string)place->query_property( "location" ) ) {
        case "outside":
          tell_room( place, name +" vanishes into the distance.\n" );
          break;
        default:
          tell_room( place, "There is a small puff of burning dust as "+
            name +" passes through a wall.\n" );
      }
      things = users() - all_inventory( place );
      if ( sizeof( things ) > ( i = random( NUM_USER ) ) ) {
        if ( !( thing = environment( things[ i ] ) ) ) break;
        tell_object( find_player( "deutha" ),
            (string)things[ i ]->query_name() +"\n" );
        tell_room( thing, "You hear a high-pitched whine.\n" );
        tell_object( things[ i ], "Something small and very hot zooms past "+
          "you at ear level.\n" );
        if ( ( !( word = (string)things[ i ]->query_short() ) || ( word == "" )
          ) || things[ i ]->query_invis() ) break;
        tell_room( thing, word +" looks shaken.\n", things[ i ] );
      }
      break;
    default:
      tell_room( place, "Something really, really strange happens.\n" );
  }
} /* do_effect() */

/**
 * This method returns the current list of octonite cystals handled
 * by this handler.
 * @return the array of octonite crystals
 * @see schedule_next()
 * @see update_octonite()
 * @see add_octonite_cyrstal()
 */
object *query_octonite_crystals() { return _octonite; }

/**
 * This method adds an octonite crystal into the current list of
 * octonite crystals.
 * @param crystal the crystal to add
 * @see query_octonite_crystals()
 * @see update_octonite()
 * @see schedule_next()
 */
void add_octonite_crystal( object crystal ) {
   int i, when;

   when = time() + roll_MdN( 5, 60 );
   if ( !sizeof( _octonite ) ) {
      _octonite = ({ crystal, when });
      schedule_next();
   } else {
      for ( i = 0; i < sizeof( _octonite ); i += 2 ) {
         if ( when < _octonite[ i + 1 ] ) {
            break;
         }
      }
      if ( i == 0 ) {
         _octonite = ({ crystal, when }) + _octonite;
         schedule_next();
         return;
      }
      if ( i >= sizeof( _octonite ) ) {
         _octonite += ({ crystal, when });
         return;
      }
      _octonite = _octonite[ 0 .. i - 1 ] + ({ crystal, when }) +
            _octonite[ i ..  ];
   }
} /* add_octonite_crystal() */

/**
 * This schedules the next update to occur.  The updates are for the
 * octonite crystals.
 * @see query_octonite_crystals()
 * @see update_octonite()
 * @see add_octonite_cyrstal()
 */
protected void schedule_next() {
   int next;

   remove_call_out(_call_out_no);
   next = _octonite[ 1 ] - time();
   if ( next > 0 ) {
      _call_out_no = call_out( (: update_octonite :), next );
   } else {
      _call_out_no = call_out( (: update_octonite :), 0 );
   }
} /* schedule_next() */

/**
 * This updatest he values associated with the octonite pebbles.  They
 * decay away slowly releasing ambient magic into the background.
 * @see query_octonite_crystals()
 * @see schedule_next()
 * @see add_octonite_cyrstal()
 */
protected void update_octonite() {
   int ambient, weight;
   object crystal;

   crystal = _octonite[ 0 ];
   if ( objectp( crystal ) ) {
      weight = 20 * (int)crystal->query_weight();
      tell_object( find_player( "deutha" ), "Current: "+ weight +".\n" );
      ambient = ambient_enchantment( crystal );
      if ( ambient > weight ) {
         weight += ( ambient - weight ) / 4;
      }
      //tell_object( find_player( "deutha" ), "Influx to: "+ weight +".\n" );
      weight -= ( weight * ( 100 - block( environment( crystal ) ) ) ) / 800;
      //tell_object( find_player( "deutha" ), "Outflux to: "+ weight +".\n" );
      if ( random( 20 ) < weight % 20 ) {
         weight += 20;
      }
      weight /= 20;
      if ( !weight )
         crystal->dest_me();
      else {
         crystal->set_weight( weight );
         crystal->set_enchant( ( 7 * (int)crystal->query_max_enchant() ) / 8 );
         crystal->set_value_info( "magic", weight * 10000 );
      }
      _octonite = delete( _octonite, 0, 2 );
      if ( sizeof( _octonite ) ) {
         schedule_next();
      }
      if ( crystal ) {
         add_octonite_crystal( crystal );
      }
   } else {
      _octonite = delete( _octonite, 0, 2 );
      if ( sizeof( _octonite ) ) {
         schedule_next();
      }
   }
} /* update_octonite() */

/**
 * This method returns the extra look information for a piece of octonite.
 * It gives different messages about size depending on its weight.
 * @param thing the object to give na extra look for
 * @return the extra information about the octonite pebbles
 */
string extra_look( object thing ) {
   if ( explode( file_name( thing ), "#" )[ 0 ] != "/obj/magic/octonite" ) {
      return "";
   }
   switch ( (int)thing->query_weight() ) {
      case 0 :
         return "";
      case 1 .. 2 :
         return "It is about the size of a pea.\n";
      case 3 .. 6 :
         return "It is about the size of a hazelnut.\n";
      case 7 .. 12 :
         return "It is about the size of a walnut.\n";
      case 13 .. 20 :
         return "It is about the size of an orange.\n";
      case 21 .. 30 :
         return "It is about the size of a grapefruit.\n";
      default :
         return "It is about the size of a pumpkin.\n";
   }
} /* extra_look() */
// --- END [/mnt/home2/grok/lib/obj/handlers/mag_eff_handler.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/gossip_handler.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/gossip_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628591   Available: 13575945
Inodes: Total: 5242880    Free: 4960134
3840 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/gossip_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628591   Available: 13575945
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker: terano $
 * $Id: gossip_handler.c,v 1.3 2000/01/04 12:03:25 rue Exp terano $
 * $Log: gossip_handler.c,v $
 * Revision 1.3  2000/01/04 12:03:25  rue
 * Added a couple of words to the filter
 *
 * Revision 1.2  1999/03/11 19:43:54  sin
 * Added a function to remove gossip
 *
 * Revision 1.1  1998/01/06 05:03:33  ceres
 * Initial revision
 * 
*/
/**
 * Deals out random gossip to people who request it.
 * <p>
 * Add rumours!
 * @author Pinkfish
 */
#include <gossip.h>

mixed *gossip;
mixed *rumours;
nosave mixed *filter_these;
private void save_stuff();

void create() {
   seteuid(getuid());
   filter_these = ({ "fuck", "fucking", "fucker", "cunt", "bitch", "shit" });
   gossip = ({ });
   rumours = ({ });
   unguarded( (: restore_object(GOSSIP_SAVE_FILE) :) );
   call_out((: save_stuff :), 10*60);
} /* create() */

private void save_stuff() {
   call_out((: save_stuff :), 10*60);
   if (sizeof(gossip) > GOSSIP_KEEP_LEVEL) {
      gossip = gossip[sizeof(gossip)-GOSSIP_KEEP_LEVEL..];
   }

   if (sizeof(rumours) > RUMOUR_KEEP_LEVEL) {
      rumours = rumours[sizeof(rumours)-RUMOUR_KEEP_LEVEL..];
   }

   unguarded( (: save_object(GOSSIP_SAVE_FILE) :) );
} /* save_stuff() */

/**
 * Add a juicy bit of gossip.  This is called by ethe gossip
 * effects on the npcs.
 * @see /std/effect/npc/gossip.c
 * @param name the person who said the gossip
 * @param mess what they said
 */
void add_gossip(string name, string mess) {
   string *bits;
   int i;

   bits = explode(mess, " ");
   for (i = 0; i < sizeof(bits); i++) {
      if (member_array(bits[i], filter_these) != -1) {
         return ;
      }
   }

   gossip += ({ ({ name, mess }) });
} /* add_gossip() */

/**
 * Sometimes you just gotta remove some gossip
 */
varargs string remove_gossip(string match, int force)
{
  int pos, index;

  if (!match || match == "") return "Must provide a match string";;

  pos = -1;
  for (index = sizeof(gossip); index; index--) {
    if (strsrch(gossip[index - 1][1], match) != -1) {
      if (pos == -1)
        pos = index - 1;
      else if (!force) {
        return "too many matches";
      }
    }
  }
  if (pos != -1) {
    string found = "found " + gossip[pos][1] + " by " + gossip[pos][0];
    gossip = delete(gossip, pos, 1);
    return found;
  } else
    return "No match";
}

/**
 * Rumours are another method of dealing out gossip.
 * Rumours are added by creators...
 * @param name the name of the person saying the rumour
 * @param mess the rumour message
 */
void add_rumour(string name, string mess) {
   rumours += ({ ({ name, mess }) });
   save_stuff();
} /* add_rumour() */

/**
 * Returns a random piece of gossip.  Finds a random bit of juicy
 * gossip and returns it.  The first element of the returned
 * array is the person who said the gossip and the second bit is
 * what they said.
 * @return a two element array containing the gossip
 */
string *query_random_gossip() {
   if (sizeof(rumours) && random(2)) {
      return rumours[random(sizeof(rumours))];
   } else {
      if (sizeof(gossip))
	 return gossip[random(sizeof(gossip))];
      else
	 return 0;
   }
} /* query_random_gossip() */

/**
 * Tell us all the gossip.  This returns the complete
 * array of gossip which the npcs are drawing from.
 * @return an array of two element arrays
 * @see query_random_gossip() 
 */
mixed *query_gossip() {
   return gossip;
} /* query_gossip() */

/**
 * The current words we are filtering.  If any of these words are in the
 * gossip, we filter it out and do not save it.
 * @return the current filter array
 */
string *query_filter() {
   return filter_these;
} /* query_filter() */

/**
 * All of the current rumours.
 * @return an array of teo element arrays
 * @see query_random_gossip()
 */
mixed *query_rumours() {
   return rumours;
} /* query_rumours() */
// --- END [/mnt/home2/grok/lib/obj/handlers/gossip_handler.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/colour.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/colour.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628590   Available: 13575944
Inodes: Total: 5242880    Free: 4960134
1815 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/colour.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628590   Available: 13575944
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: colour.c,v 1.1 1998/01/06 05:03:33 ceres Exp $
 * $Log: colour.c,v $
 * Revision 1.1  1998/01/06 05:03:33  ceres
 * Initial revision
 * 
*/
#include <colour.h>

string calc_colour( int red, int green, int blue, int whitener ) {
   int main_hue;
   string result;

   result = "";
   if ( whitener > -1 ) {
      switch ( red + green + blue ) {
         case 0 .. 4 :
            return "colourless";
         case 5 .. 29 : 
            result += "faint ";
            break;
         case 30 .. 154 :
            break;
         default :
            result += "intense ";
      }
   }
   return result;
} /* calc_colour() */

/*

string add_colour( string word, int fine, int crude, int xp_thresh,
                int sp_thresh ) {
  int temp;
  temp = member_array( word, colour_names );
  if ( temp != -1 ) return "colour already exists";
  colour_names += ({ word });
  colour_details += ([ word : ({ fine, crude, xp_thresh, sp_thresh }) ]);
  save_cmr_handler();
  return "the colour "+ word +", a shade of "+ ( ( fine == crude )?
         "pure ":MODIFIERS[fine] ) + COLOURS[crude] +", with thresholds of "+
         xp_thresh +" xp and "+ sp_thresh +" sp";
} add_colour()

string identify_colour( string word, object player ) {
  int temp, *args;
  temp = member_array( word, colour_names );
  if ( temp == -1 ) return "unknown colour";
  args = allocate( 4 );
  args = colour_details[word];
   if ( !player )
      return word;
  switch ( ( ( player->query_total_xp() ) > args[2] ) +
           ( ( player->query_max_social_points() ) > args[3] ) ) {
    case 0: return COLOURS[args[1]];
    case 1: return ( ( ( args[0] == args[1] )?"pure ":MODIFIERS[args[0]] ) +
                     COLOURS[args[1]] );
    default: return word;
  }
} identify_colour()

*/
// --- END [/mnt/home2/grok/lib/obj/handlers/colour.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/bank_handler.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/bank_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628589   Available: 13575943
Inodes: Total: 5242880    Free: 4960134
11762 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/bank_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628589   Available: 13575943
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: bank_handler.c,v 1.17 2003/05/07 23:08:10 ceres Exp $
 * 
*/
/**
 * Keep track of each banks data.
 * @change 12-11-97 Pinkfish
 * Removed the player_name variable.  Made a couple of the functions
 * private
 *
 * @change 21-11-97 Terano
 * Changed the get_data_file function so that if there is no data file 
 * for a player, it calls init_data
 */


#define RESTORE_PATH "/save/bank_accounts/"
//#define LOGGING
#define CHEAT_THRESHOLD 200000

class franchise {
   string office;
   int cost_per_month;
   int cost_per_new_account;
}

class bank_data {
   string master_office;
   class franchise* franchises;
   int cost_to_start;
   int default_cost_per_month;
   int default_cost_per_new_account;
}
 
private mapping accounts;
private nosave mapping _banks;

void do_cheat_check(string, string, int, string, int);

void create() {
   string str;

   _banks = ([ ]);
   str = unguarded((: read_file, RESTORE_PATH + "bank_data.o" :));
   if (str) {
      _banks = restore_variable(str);
   }
} /* create() */

private void save_banks() {
   unguarded((: write_file, RESTORE_PATH + "bank_data.o",
                save_variable(_banks), 1 :));
} /* save_banks() */

private void init_data( string word ) {
  accounts = ([ ]);
} /* init_data() */

/**
 * Start up the system by restoreing the players data.
 * @param word the name of the player being restored
 */
int get_data_file( string name ) {
  int success;

  success = unguarded((: restore_object, RESTORE_PATH+
           name[0..0]+"/"+name :));
  if(!success) {
    init_data(name);
    
    return success;
  }
  return 1;
} /* get_data_file() */

/**
 * Save the current data file to disk.
 * @param word the name of the player being saved
 */ 
private void save_data_file( string name ) {
  if(!unguarded((: save_object, RESTORE_PATH+name[0..0]+"/"+name :)))
    debug_printf("Problem saving " + RESTORE_PATH+name[0..0]+"/"+name);
} /* save_data_file() */

/**
 * Find out how much a player has at a given bank.
 * @param word the name of the player
 * @param bank_name the name of the bank
 * @return the current balance, -1 on failure
 */
int query_account( string word, string bank_name ) {
  get_data_file( word );
  if ( !accounts ) {
    return -1;
  }
  if ( member_array( bank_name, m_indices( accounts ) ) == -1 ) {
    return -1;
  }
  return accounts[ bank_name ];
} /* query_account() */

/**
 * Change the amount of money a player has at a given bank.
 * @param name the name of the player
 * @param bank_name the name of the bank
 * @param amount the amount to change the balance by
 */
void adjust_account( string name, string bank_name, int amount ) {
  int before;
  
  get_data_file( name );
  before = accounts[ bank_name ];
  accounts[bank_name] += amount;
  if ( accounts[ bank_name ] < 0 ) {
    accounts = m_delete( accounts, bank_name );
  }
  do_cheat_check(name, bank_name, amount, "by", before);
  save_data_file( name );
  return;
} /* adjust_account() */


/**
 * Sets the balance at a certain bank to the specificed amount.
 * @param name the name of the player
 * @param bank_name the name of the bank
 * @param amount the amount to set the bank to.
 * Query the accounts a player has.
 *
 * @param player the name of the player
 */
void set_account( string name, string bank_name, int amount ) {
  int before;
  get_data_file( name );
  before = accounts[ bank_name ];
  
  if ( amount < 0 ) {
    accounts = m_delete( accounts, bank_name );
  } else {
    accounts[ bank_name ] = amount;
  }
  do_cheat_check(name, bank_name, amount, "to", before);
  save_data_file( name );      
  return;
} /* set_account() */

/**
 * Query the accounts a player has.
 *
 * @param player the name of the player
 */
string *query_accounts(string player) {
  get_data_file(player);

  if(!accounts)
    return ({ });

  return keys(accounts);
}

/**
 * THis method creates a new bank.
 * @param name the name of the bank
 * @param master the location of the master bank
 */
void create_new_bank(string name, string master) {
   class bank_data data;

   if (_banks[name]) {
      return ;
   }
   data = new(class bank_data);
   data->master_office = master;
   data->franchises = ({ });
   data->cost_to_start = 2600000;
   data->default_cost_per_month = 360000;
   data->default_cost_per_new_account = 400;
   _banks[name] = data;
   save_banks();
} /* create_new_banks() */

/**
 * This method removes a bank from the current list ofbanks.
 * @param name the name of the bank to remove
 */
void remove_bank(string name) {
   map_delete(_banks, name);
   save_banks();
} /* remove_bank() */

/**
 * This method is to be used for testing.
 */
class bank_data query_bank_data(string name) {
   return copy(_banks[name]);
} /* query_bank_data() */

/**
 * This method adds a new franchise to the operation.
 * @param name the name of the bank set
 * @param franchise_office the new franchise to add
 */
void add_new_franchise(string name, string franchise_office) {
   class franchise franchise;

   if (!_banks[name]) {
      return ;
   }

   foreach (franchise in _banks[name]->franchises) {
      if (franchise->office == franchise_office) {
         return ;
      }
   }

   franchise = new(class franchise);
   franchise->office = franchise_office;
   franchise->cost_per_month = _banks[name]->default_cost_per_month;
   franchise->cost_per_new_account = _banks[name]->default_cost_per_new_account;
   _banks[name]->franchises += ({ franchise });
   save_banks();
   return ;
} /* add_new_franchies() */

/**
 * This method sets the new cost for opening a franchise for the bank.
 * @param bank the bank to change the cost for
 * @param amount the new amount to charge to open
 */
void set_bank_default_cost_to_open(string name, int amount) {
   if (!_banks[name]) {
      return ;
   }

   _banks[name]->cost_to_start = amount;
   save_banks();
   return ;
} /* set_bank_default_cost_to_open() */

/**
 * This method sets the new cost for opening a franchise for the bank.
 * @param bank the bank to change the cost for
 * @param amount the new amount to charge to open
 */
void set_bank_default_cost_per_new_account(string name, int amount) {
   if (!_banks[name]) {
      return ;
   }

   _banks[name]->default_cost_per_new_account = amount;
   save_banks();
   return ;
} /* set_bank_cost_per_new_account() */

/**
 * This method sets the new cost for opening a franchise for the bank.
 * @param bank the bank to change the cost for
 * @param franchise the franchise to change the amounts for
 * @param amount the new amount to charge to open
 */
void set_bank_franchise_cost_per_month(string name, string franchise_office,
                                     int amount) {
   class franchise franchise;

   if (!_banks[name]) {
      return ;
   }

   foreach (franchise in _banks[name]->franchises) {
      if (franchise->office == franchise_office) {
         franchise->cost_per_month = amount;
         save_banks();
         return ;
      }
   }

   return ;
} /* set_bank_franchise_cost_per_month() */

/**
 * This method sets the new cost for opening a franchise for the bank.
 * @param bank the bank to change the cost for
 * @param amount the new amount to charge to open
 */
void set_bank_franchise_cost_per_new_account(string name, int amount) {
   if (!_banks[name]) {
      return ;
   }

   _banks[name]->cost_per_new_account = amount;
   save_banks();
   return ;
} /* set_bank_franchise_cost_per_new_account() */

/**
 * This method sets the new cost for opening a franchise for the bank.
 * @param bank the bank to change the cost for
 * @param amount the new amount to charge to open
 */
void set_bank_default_cost_per_month(string name, int amount) {
   if (!_banks[name]) {
      return ;
   }

   _banks[name]->default_cost_per_month = amount;
   save_banks();
   return ;
} /* set_bank_default_cost_per_month() */

/**
 * This method returns the new cost for opening a franchise for the bank.
 * @param bank the bank to change the cost for
 * @param amount the new amount to charge to open
 */
int query_bank_default_cost_to_open(string name) {
   if (!_banks[name]) {
      return -1;
   }

   return _banks[name]->cost_to_start;
} /* query_bank_default_cost_to_open() */

/**
 * This method returns the new cost for opening a franchise for the bank.
 * @param bank the bank to change the cost for
 * @param amount the new amount to charge to open
 */
int query_bank_default_cost_per_new_account(string name) {
   if (!_banks[name]) {
      return -1;
   }

   return _banks[name]->default_cost_per_new_account;
} /* query_bank_cost_per_new_account() */

/**
 * This method returns the new cost for opening a franchise for the bank.
 * @param bank the bank to change the cost for
 * @param franchise the franchise to change the amounts for
 * @param amount the new amount to charge to open
 */
int query_bank_franchise_cost_per_month(string name, string franchise_office) {
   class franchise franchise;

   if (!_banks[name]) {
      return -1;
   }

   foreach (franchise in _banks[name]->franchises) {
      if (franchise->office == franchise_office) {
         return franchise->cost_per_month;
      }
   }

   return -1;
} /* query_bank_franchise_cost_per_month() */

/**
 * This method returns the new cost for opening a franchise for the bank.
 * @param bank the bank to change the cost for
 * @param amount the new amount to charge to open
 */
int query_bank_franchise_cost_per_new_account(string name,
                                              string franchise_office) {
   class franchise franchise;

   if (!_banks[name]) {
      return -1;
   }

   foreach (franchise in _banks[name]->franchises) {
      if (franchise->office == franchise_office) {
         return franchise->cost_per_new_account;
      }
   }
   return -1;
} /* query_bank_franchise_cost_per_new_account() */

/**
 * This method returns the new cost for opening a franchise for the bank.
 * @param bank the bank to change the cost for
 * @param amount the new amount to charge to open
 */
int query_bank_default_cost_per_month(string name) {
   if (!_banks[name]) {
      return -1;
   }

   return _banks[name]->default_cost_per_month;
} /* query_bank_default_cost_per_month() */

/**
 * This method returns the master office of the bank.
 * @param name the bank name to check in
 * @return the master office of the bank
 */
string query_bank_master_office(string name) {
   if (!_banks[name]) {
      return 0;
   }

   return _banks[name]->master_office;
} /* query_bank_master_officer() */

/**
 * This method set the master office of the bank.
 * @param name the bank name to check in
 * @param master the master office of the bank
 */
void set_bank_master_office(string name, string master) {
   if (!_banks[name]) {
      return 0;
   }

   _banks[name]->master_office = master;
   save_banks();
} /* set_bank_master_officer() */

/**
 * This method returns the current list of banks.
 * @return the current list of banks
 */
string* query_banks() {
   return keys(_banks);
} /* query_banks() */

/**
 * This method returns the franchises for the specified bank.
 * @param bank the bank to get the franchises of
 * @return the list of franchises
 */
string* query_franchises(string bank) {
   if (!_banks[bank]) {
      return ({ });
   }

   return map(_banks[bank]->franchises, (: $1->office :) );
} /* query_franchises() */

void do_cheat_check(string name, string bank_name, int amount, 
                    string str, int after) {
#ifdef LOGGING
  if((amount - after) > CHEAT_THRESHOLD) {
    log_file ("BANK_CHEAT", sprintf ("%s: %s deposited %d into %s.\n",
                                     ctime(time()), name, (amount-after),
                                     bank_name));
  }
#endif  
}
// --- END [/mnt/home2/grok/lib/obj/handlers/bank_handler.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/refresh.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/refresh.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628586   Available: 13575940
Inodes: Total: 5242880    Free: 4960134
8411 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/refresh.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628586   Available: 13575940
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* -*- LPC -*- */
/**
 * This is the Refresh Handler.  When a player refreshes, this
 * handler is called so that all the miscellaneous bookkeeping
 * about that player can be reset.  This should be used
 * for taking someone out of the playtesters' group, resetting the
 * criminal ledger in KLK, etc.  Everything, in short,
 * which is not a property on the player object or otherwise
 * can be handled entirely by the player object without using any other
 * objects.
 *
 * Similarly, whenever a player gets deleted, this handler
 * gets called upon to call a number of deletion callbacks
 * to remove bookeeping about that player.
 *
 * If you have code that stores information about a player outside of
 * the player object, then you should call register_refresh()
 * and possibly register_delete()
 * on this handler.  That will then remember the function you
 * give it.  Then, whenever a player refreshes or deletes, the
 * function you specified will get called with the player object
 * and a flag to indicate if this is a total refresh or a partial
 * refresh (for refresh callbacks) or a string with the player
 * name (for player deletions).  Do the right thing.
 * will get called with the player object and a flag to indicate
 * if this is a total refresh or a partial refresh.  Do the
 * right thing.
 *
 * If your object moves to a different file, then you will
 * have to manually unregister the object from the refresh
 * handler.  This is very important!  To unregister, simply
 * call register_function() again, with the same object, but
 * give 0 for the function.
 *
 * Each object can have only one refresh function registered,
 * and clones can't have any!
 *
 * You can easily use the same function for both a deletion
 * and refresh callback.  All you do is declare the function
 *    void callback_func(mixed player, int flag)
 * and then test flag to see if it is PARTIAL_REFRESH,
 * TOTAL_REFRESH, or PLAYER_DELETED.  In the last case, player
 * will be a string.  Otherwise player is an object.
 *
 * @author Sin
 *
 * @change 17 Nov 1998, Sin
 *     Handles deletions now, too.
 */
#include <refresh.h>
#include <playerinfo.h>

#define SAVE_FILE "/save/refresh"

mapping refresh_callbacks;
mapping delete_callbacks;
nosave string loaded_by;
nosave string loaded_time;

/**
 * @ignore yes
 */
protected void load_me()
{
  refresh_callbacks = 0;
  delete_callbacks = 0;
  unguarded( (: restore_object, SAVE_FILE, 0 :) );
  if (!refresh_callbacks) {
    refresh_callbacks = ([ ]);
  }
  if (!delete_callbacks) {
    delete_callbacks = ([ ]);
  }
}

/**
 * @ignore yes
 */
protected void save_me()
{
  unguarded( (: save_object, SAVE_FILE, 0 :) );
}

/**
 * @ignore yes
 * This is used to make the player info handler happy.
 */
string query_name() {
   return "Refresh Handler";
} /* query_name() */

/**
 * @ignore yes
 */
void create()
{
  seteuid("/secure/master"->creator_file(file_name(this_object())));
  load_me();
  if (!previous_object()) {
    loaded_by = "The Masked Man";
  } else {
    if (previous_object()->query_creator()) {
      loaded_by = "Creator: " + previous_object()->query_name();
    } else if (previous_object()->query_interactive()) {
      loaded_by = "Player: " + previous_object()->query_name();
    } else {
      loaded_by = file_name(previous_object());
      if (this_player())
        loaded_by += sprintf(" (%s)", this_player()->query_name());
    }
  }
  loaded_time = ctime(time());
}

/**
 * @ignore yes
 */
void dest_me()
{
  save_me();
  destruct(this_object());
}

/**
 * @ignore yes
 */
nomask mixed dwep()
{
  efun::destruct(this_object());
  return "Destructed With Extreme Prejudice";
}

/**
 * Use this function to tell the refresh handler about functions that
 * you want to have called whenever any player refreshes or gets
 * deleted.
 *
 * Typically, you will call this by hand, with the 'call' command,
 * rather than coding a call to this function into your code.
 *
 * The first parameter is the object that contains the callback
 * to be called.  This can be either a pointer to the object, or
 * the filename to the object.
 *
 * The second parameter is the name of the function that should be
 * called.  This callback should take two parameters: an object for
 * the player who is affected, and an integer, which will be either
 * PARTIAL_REFRESH or TOTAL_REFRESH.
 *
 * This function will refuse to register a callback if either:
 * the object is a clone, the callback isn't defined in the object, or
 * the callback is a function pointer.
 */
string register_refresh(mixed ob, string func)
{
  object real;

  if (objectp(ob)) {
    ob = base_name(ob);
  }
  if (!ob) {
    return "Please supply an object";
  }

  real = load_object(ob);
  if (!real) {
    return "Couldn't find object";
  }
  if (func && !function_exists(func, real)) {
    return "Couldn't find function";
  }

  if (!func) {
    if (refresh_callbacks[ob]) {
      map_delete(refresh_callbacks, ob);
    }
  } else {
    if (refresh_callbacks[ob]) {
      refresh_callbacks[ob] = func;
    } else {
      refresh_callbacks += ([ ob : func ]);
    }
  }
  save_me();
}

/**
 * This function does almost exactly what register_refresh() does,
 * but it is used for registering delete handlers.
 * 
 * Delete callbacks are called with two parameters as well, but
 * the first parameter is a string containing the player's name,
 * while the second parameter is the integer PLAYER_DELETED.
 */
string register_delete(mixed ob, string func)
{
  object real;

  if (objectp(ob)) {
    ob = base_name(ob);
  }
  if (!ob) {
    return "Please supply an object";
  }

  real = load_object(ob);
  if (!real) {
    return "Couldn't find object";
  }
  if (func && !function_exists(func, real)) {
    return "Couldn't find function";
  }

  if (!func) {
    if (delete_callbacks[ob]) {
      map_delete(delete_callbacks, ob);
    }
  } else {
    if (delete_callbacks[ob]) {
      delete_callbacks[ob] = func;
    } else {
      delete_callbacks += ([ ob : func ]);
    }
  }
  save_me();
}

/**
 * This function gets called by the player object whenever
 * a player refreshes, or by any of the various objects that delete
 * players when they get deleted.  You should never call
 * this function directly.
 */
varargs void player_refreshed(object player, int totally) {
  string ob;

  if (base_name(file_name(previous_object())) != "/global/player") {
    return;
  }

  foreach (ob in keys(refresh_callbacks)) {
    object obj;

    obj = load_object(ob);
    if (obj) {
      mixed *vals;

      vals = ({ refresh_callbacks[ob], player, totally });
      call_out( (: call_other, obj, vals :), 1);
    }
  }
}

/**
 * This, like player_refreshed(), goes through and calls all the
 * registered deletion callbacks.  In this case, however, the
 * deletion callbacks get called with a _string_ rather than
 * an object.  That string is the name of the player who is being
 * deleted.
 */
varargs void player_deleted(string player)
{
  string ob;

  if (file_name(previous_object()) != "/secure/delete_clear" &&
      file_name(previous_object()) != "/cmds/lord/rmp_layer" &&
      !master()->high_programmer(previous_object(-1))) {
    unguarded( (: write_file, "/log/CHEAT", ctime( time() ) +
                ": illegal attempt to delete player files using "+
                "refresh_handler\nTrace: "+ back_trace() :) );
    return;
  }

  foreach (ob in keys(delete_callbacks)) {
    object obj;

    obj = load_object(ob);
    if (obj) {
      mixed *vals;

      vals = ({ delete_callbacks[ob], player, PLAYER_DELETED });
      call_out( (: call_other, obj, vals :), 1);
    }
  }
  "/secure/related_files"->delete_related_files(player, 1, 0);
}

/**
 * Return the current list of callback functions.
 */
mapping query_funcs()
{
  return ([
    "refresh callbacks" : refresh_callbacks,
    "delete callbacks" : delete_callbacks,
    ]);
}

/**
 * This function supports the 'stat' command.  If you stat the
 * refresh handler, you'll see up to 4 things: the number of
 * refresh callbacks registered, the number of delete callbacks registered,
 * the person or object who loaded the refresh handler, and the
 * time that the handler got loaded.
 */
mixed *stats()
{
  return ({
    ({ "refreshes", sizeof(refresh_callbacks) }),
    ({ "deletes", sizeof(delete_callbacks) }),
    ({ "loaded by", loaded_by }),
    ({ "loaded time", loaded_time }),
    });
}
// --- END [/mnt/home2/grok/lib/obj/handlers/refresh.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/clothing_handler.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/clothing_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628584   Available: 13575938
Inodes: Total: 5242880    Free: 4960134
24711 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/clothing_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628584   Available: 13575938
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This object handles all the different types of clothing, their
 * locations etc.
 * @author Pinkfish
 *
 * Fiddled!  Actually added the cloak and dresses areas and fixed here and
 * there.
 * @Siel, Summer 2001
 */

#include <clothing.h>

mapping _types;
mapping _equivilants;
mapping _zones;
string *_zone_level;

protected void add_clothing_type(string name,
                                 string *not_remove,
                                 string *hiding);
protected void add_clothing_zone(string zone, string *types);
private int fixup_types(string type, string *types);
protected void add_equivilant_type(string name, string equiv);
private void check_clothing_types();
string *query_clothing_zone(string zone);
string *query_clothing_cannot_remove(string type);
string can_wear_or_remove(object thing, object player);

void create() {
   _types = ([ ]);
   _equivilants = ([ ]);
   _zones = ([ ]);
   _zone_level = ({ });

   //
   // Special type for bandaids..
   //
   add_clothing_type("bandaid", ({ }), ({ }));

   /* Do not reorder this next section, is it in a nice order. */
   add_clothing_type("wig",
       ({ "hood", "helmet", "coif", "hat", "all covering" }),
       ({ "hood", "helmet", "coif", "hat", "all covering" }));
   add_clothing_type("hat",
       ({ "hood", "helmet", "all covering" }),
       ({ "hood", "helmet", "all covering" }));
   add_clothing_type("helmet",
       ({ "hood", "all covering" }),
       ({ "hood", "all covering" }));
   add_clothing_type("hood",
       ({ "all covering" }),
       ({ "all covering" }));
   add_clothing_type("earring",
       ({ "coif", "all covering" }),
       ({ "hood", "coif", "all covering" }));
   add_clothing_type("moustache",
       ({ "coif", "mask", "all covering" }),
       ({ "coif", "mask", "all covering" }));
   add_clothing_type("glasses",
       ({ "all covering" }),
       ({ "all covering" }));
   add_clothing_type("nosering",
       ({ "mask", "coif", "all covering" }),
       ({ "mask", "coif", "all covering" }));
   add_clothing_type("mask",
       ({ "all covering" }),
       ({ "all covering" }));
   add_clothing_type("headband",
       ({ "hat", "hood", "helmet", "coif", "all covering" }),
       ({ "hat", "hood", "helmet", "coif", "all covering" }));
   add_clothing_type("scarf",
       ({ "hood", "all covering" }),
       ({ "hood", "all covering"}));
   add_clothing_type("necklace",
       ({ "coif", "all covering" }),
       ({ "cloak", "coif", "all covering" }));
   add_clothing_type("collar",
       ({ "hood", "all covering" }),
       ({ "hood", "all covering"}));
   add_clothing_type( "shoulder",
       ({ "cloak", "cape", "sash", "robe",  "tabard", "breastplate",
          "hauberk", "haubergon", "byrnie", "jacket","jumper", "waistcoat",
          "shirt", "undershirt", "all covering" }),
       ({ "cloak", "robe", "tabard", "breastplate", "hauberk", "haubergon",
          "byrnie", "jacket", "jumper", "waistcoat", "shirt", "undershirt",
          "all covering" }));
   add_clothing_type( "bra",
       ({ "cloak", "cape", "sash", "robe",  "tabard", "breastplate",
          "hauberk", "haubergon", "byrnie", "jacket","jumper", "waistcoat",
          "shirt", "undershirt", "all covering", "long dress", "mini dress" }),
       ({ "cloak", "robe", "tabard", "breastplate", "hauberk", "haubergon",
           "byrnie", "jacket", "jumper", "waistcoat", "shirt", "undershirt",
           "all covering", "long dress", "mini dress" }));
   add_clothing_type("undershirt",
       ({ "cloak", "cape", "sash", "robe", "tabard", "breastplate",
          "haubergon", "hauberk", "byrnie", "jacket", "jumper", "waistcoat",
          "shirt", "harness", "all covering" }),
       ({ "cloak", "robe", "tabard", "breastplate", "haubergon", "hauberk",
          "byrnie", "jacket", "jumper", "shirt", "long dress", "mini dress",         
          "all covering" }));
   add_clothing_type("shirt",
       ({ "cloak", "cape", "sash", "robe", "tabard", "breastplate",
          "haubergon", "hauberk", "byrnie", "jacket",  "jumper", "waistcoat",
          "harness", "all covering" }),
       ({ "cloak", "robe", "haubergon", "hauberk", "byrnie", "jacket", 
          "jumper", "all covering" }));
   add_clothing_type("waistcoat",
       ({ "cloak", "cape", "sash", "robe", "tabard", "breastplate",
          "haubergon", "hauberk", "byrnie", "jacket", "jumper", "harness",
          "all covering" }),
       ({ "cloak", "robe", "haubergon", "hauberk", "byrnie", "jacket",
          "jumper", "all covering" }));
   add_clothing_type("harness",
       ({ "all covering" }),
       ({ "cloak", "all covering" }));
   add_clothing_type("jumper",
       ({ "cloak", "cape", "sash", "robe", "breastplate", "haubergon",
          "hauberk", "byrnie", "tabard", "jacket",  "all covering" }),
       ({ "cloak", "robe", "haubergon", "hauberk", "jacket", 
          "all covering" }));
   add_clothing_type("jacket",
       ({ "cloak", "cape", "sash", "robe", "tabard", "breastplate",
          "haubergon", "hauberk", "byrnie", "all covering" }),
       ({ "cloak", "robe", "hauberk", "all covering" }));


   add_clothing_type("tabard",
       ({ "cloak", "cape", "sash", "robe", "all covering" }),
       ({ "cloak", "robe", "all covering" }));
   add_clothing_type("robe",
       ({ "cloak", "cape", "sash", "all covering" }),
       ({ "cloak", "all covering" }));
   add_clothing_type("cloak",
       ({ "all covering" }),
       ({ "all covering" }));
   add_clothing_type("sash",
       ({ "cloak", "cape", "all covering" }),
       ({ "cloak", "all covering" }));
   add_clothing_type("cape",
       ({ "all covering" }),
       ({ "all covering" }));
   add_clothing_type("armband",
       ({ "all covering" }),
       ({ "cloak", "robe", "all covering" }));
   add_clothing_type("glove",
       ({ "all covering" }),
       ({ "all covering" }));
   add_clothing_type("bracelet",
       ({ "glove", "all covering" }),
       ({ "cloak", "glove", "all covering" }));
   add_clothing_type("ring",
       ({ "glove", "all covering" }),
       ({ "glove", "all covering" }));
   add_clothing_type("box",
       ({ "cloak", "robe", "all covering" }),
       ({ "cloak", "robe", "skirt", "all covering" }));
   add_clothing_type("apron",
       ({ "cloak", "all covering" }),
       ({ "cloak", "all covering" }));
   add_clothing_type("underwear",
       ({ "harness", "trousers", "greave", "hauberk", "haubergon",
          "byrnie", "belt", "trousers", "all covering" }),
       ({ "cloak", "robe", "skirt", "trousers", "all covering",
          "long dress", "mini dress" }));
   add_clothing_type("garter",
       ({ "greave", "hauberk", "trousers", "all covering"}),
       ({ "cloak", "robe", "greave", "hauberk", "trousers", "skirt",
          "all covering", "long dress", "mini dress"}));
   add_clothing_type("skirt",
       ({ "belt", "all covering" }),
       ({ "cloak", "robe", "all covering" }));
   add_clothing_type("trousers",
       ({ "greave", "hauberk", "belt" }),
       ({ "cloak", "hauberk", "robe", "all covering" }));
   add_clothing_type("belt",
       ({"hauberk", "haubergon", "byrnie", "all covering" }),
       ({ "cloak", "robe", "hauberk", "haubergon", "byrnie", "all covering" }));
   add_clothing_type("sock",
       ({ "overshoe", "boot", "chausse", "all covering" }),
       ({ "cloak", "overshoe", "boot", "chausse", "all covering",
          "long dress", "trousers" }));
   add_clothing_type("anklet",
       ({ }),
       ({ "cloak", "overshoe", "chausse", "all covering" }));
   add_clothing_type("boot",
       ({ "overshoe" }),
       ({ "overshoe", "all covering" }));
   add_clothing_type("overshoe",
       ({ }),
       ({ "all covering" }));
   add_clothing_type("long dress",
       ({ "cloak", "cape", "sash", "robe", "tabard", "breastplate",
          "haubergon", "hauberk", "byrnie", "jacket",  "jumper", "harness",
          "all covering","belt" }),
       ({ "cloak", "robe", "haubergon", "hauberk", "byrnie", "jacket",
          "jumper", "all covering" }));
   add_clothing_type("mini dress",
       ({ "cloak", "cape", "sash", "robe", "tabard", "breastplate",
          "haubergon", "hauberk", "byrnie", "jacket",  "jumper", "harness",
          "all covering","belt" }),
       ({ "cloak", "robe", "haubergon", "hauberk", "byrnie", "jacket",
          "jumper", "all covering" }));


   add_clothing_type("small shield",
       ({"all covering" }),
       ({ "all covering" }));
   add_clothing_type("shield",
       ({"all covering" }),
       ({ "all covering" }));
   add_clothing_type("large shield",
       ({"all covering" }),
       ({ "all covering" }));
   add_clothing_type("badge",
       ({ "all covering" }),
       ({ "cloak", "all covering" }));
   add_clothing_type("scabbard",
       ({ "all covering" }),
       ({ "cloak", "all covering" }));
   add_clothing_type("small scabbard",
       ({ "all covering" }),
       ({ "cloak", "robe", "all covering" }));
   add_clothing_type("belt scabbard",
       ({ "all covering" }),
       ({ "cloak", "robe", "all covering" }));

   // Maille armour

   add_clothing_type("coif",
       ({ "hood", "scarf", "mask", "helmet", "hat", "all covering"}),
       ({ "hood", "all covering"}));
   add_clothing_type("byrnie",
       ({ "cloak", "breastplate", "backplate", "tabard", "small scabbard",
          "belt scabbard", "robe", "cape", "sash", "all covering" }),
       ({ "cloak", "robe", "all covering" }));
   add_clothing_type("haubergon",
       ({ "cloak", "breastplate", "backplate", "tabard", "vambrace",
          "small scabbard", "belt scabbard", "robe", "cape", "sash",
          "all covering"}),
       ({ "cloak", "robe", "all covering"}));
   add_clothing_type("hauberk",
       ({ "cloak", "tabard", "vambrace", "greave", "breastplate", "backplate",
          "small scabbard", "belt scabbard", "robe", "cape", "sash",
          "all covering"}),
       ({ "cloak", "robe", "all covering" }));
   add_clothing_type("chausse",
       ({ "boot", "overshoe", "all covering"}),
       ({ "boot", "overshoe", "all covering"}));

   // Plate armour
   add_clothing_type("breastplate",
       ({ "cloak", "small scabbard", "belt scabbard", "robe", "tabard",
          "cape", "sash", "all covering" }),
       ({ "cloak", "robe", "all covering" }));
   add_clothing_type("backplate",
       ({ "cloak", "cape", "sash", "robe", "tabard", "all covering"}),
       ({ "cloak", "cape", "sash", "robe", "all covering"}));
   add_clothing_type("vambrace",
       ({ "glove", "all covering" }),
       ({ "cloak", "robe", "all covering" }));
   add_clothing_type("greave",
       ({ "all covering" }),
       ({ "cloak", "robe", "all covering" }));

   add_clothing_type("all covering", ({}), ({}));


   /* The clothing zones... */
   add_clothing_zone("head",
       ({ "hood", "helmet", "coif", "hat", "wig", "headband", "moustache",
          "glasses", "mask" }));
   add_clothing_zone("neck",
       ({ "cloak", "hood", "coif", "cape", "scarf", "collar" }));
   add_clothing_zone("chest",
       ({ "cloak", "sash", "robe", "breastplate", "haubergon", "hauberk",
          "byrnie", "tabard", "jacket","jumper", "shirt", "undershirt",
          "shoulder", "bra","shield", "large shield", "long dress",
          "mini dress", "apron", "waistcoat" }));
   add_clothing_zone("back",
       ({ "cloak", "cape", "sash", "robe", "hauberk", "haubergon", "byrnie",
          "jacket", "jumper", "shirt", "undershirt", "backplate",
          "long dress", "mini dress", "waistcoat" }));
   add_clothing_zone("abdomen",
       ({ "large shield", "robe", "breastplate", "byrnie", "hauberk",
          "skirt", "box", "trousers", "underwear", "long dress",
          "mini dress", "apron", "waistcoat" }));
   add_clothing_zone("arms",
       ({ "cloak", "small shield", "shield", "large shield", "robe",
          "vambrace", "hauberk", "haubergon", "jacket", "armband",
          "jumper", "shirt", "long dress" }));
   add_clothing_zone("hands",
       ({ "glove", "small shield", "shield", "large shield" }));
   add_clothing_zone("legs",
       ({ "cloak", "robe", "greave", "hauberk", "skirt", "trousers",
          "long dress" }));
   add_clothing_zone("feet",
       ({ "overshoe", "boot", "chausse", "sock", "anklet" }));

   /* The equivilant types. */
   add_equivilant_type("shoe", "boot");
   add_equivilant_type("sandal", "boot");
   add_equivilant_type("clog", "boot");
   add_equivilant_type("sabaton", "boot");
   add_equivilant_type("turban", "helmet");
   add_equivilant_type("gorget", "collar");
   add_equivilant_type("stocking", "sock");
   add_equivilant_type("coat", "cloak");
   add_equivilant_type("overall", "long dress");
   call_out((: check_clothing_types() :), 2);
} /* create() */

/**
 * This method returns the list of things that are blocking the removal
 * of the specific object.
 * @param thing the thing to find what it is being blocked by
 * @param player the player to look it up on
 * @return the array of objects blocking it
 */
object* query_items_blocking(object thing, object player) {
   int i;
   int j;
   int k;
   string *stuff;
   object *blocking;
   mixed junk;
   mixed main_types;
   object *wearing;

   main_types = thing->query_type();
   if (stringp(main_types)) {
      main_types = ({ main_types });
   }
   wearing = player->query_wearing() - ({ thing });
   blocking = ({ });
   for (k=0;k<sizeof(main_types);k++) {
      stuff = query_clothing_cannot_remove(main_types[k]);
      if (!sizeof(wearing) || !stuff) {
         return ({ });
      }
      for (i = 0; i < sizeof(wearing); i++) {
         junk = wearing[i]->query_type();
         if (stringp(junk)) {
            junk = ({ junk });
         }
         for (j = 0; j < sizeof(junk); j++) {
            if (member_array(junk[j], stuff) != -1 &&
                 member_array(wearing[i], blocking) == -1) {
               blocking += ({ wearing[i] });
               break;
            }
         }
      }
   }
   return blocking;
} /* query_items_blocking() */

/**
 * This method returns whether or not a player can wear or remove a given item.
 * @param thing the item to be worn or removed.
 * @param player the person doing the wearing or removing.
 * @return 0 for success, a string for failure.
 */
string can_wear_or_remove( object thing, object player ) {
   object *blocking;

   blocking = query_items_blocking(thing, player);
   if (sizeof(blocking)) {
     return "when you are wearing "+ query_multiple_short(blocking);
   }
   return 0;
} /* can_wear_or_remove() */

/**
 * This method adds a new clothing type into the existing clothing
 * type mapping.
 * @param name the name of the clothing type
 * @param not_remove the types which if worn you cannot remove this item
 * @param hiding the types which hides this clothing
 */
protected void add_clothing_type(string name,
                                 string *not_remove,
                                 string *hiding) {
   _types[name] = new (class clothing_type, _hiding : hiding,
                                           _not_remove : not_remove);
} /* add_clothing_type() */

/**
 * This method returns the information associated with the clothing
 * of a particular type.
 * <p>
 * This will returns a class containing the clothing type information
 * in it.
 * @param name the name of the type to lookup
 * @return the clothing type array, 0 if not found
 * @see query_clothing_cannot_remove()
 * @see query_clothing_cannot_remove()
 */
class clothing_type query_clothing_type(string name) {
   return _types[name];
} /* query_clothing_type() */

/**
 * This method returns the items you would be unable to remove the
 * type with.
 * @param type the type of clothing to check
 * @return array of types you would be unable to remove, 0 if invalid type
 * @see query_clothing_hiding()
 * @see query_clothing_depth()
 */
string *query_clothing_cannot_remove(string type) {
   class clothing_type bing;

   bing = _types[type];
   if (bing) {
      return bing->_not_remove;
   }
   return 0;
} /* query_clothing_not_remove() */

/**
 * This method returns the types which hide this type of thingy.
 * @param type the type of clothing to check
 * @return array of types which would hide this type, 0 if invalid type
 * @see query_clothing_cannot_remove()
 * @see query_clothing_depth()
 */
string *query_clothing_hiding(string type) {
   class clothing_type bing;

   bing = _types[type];
   if (bing) {
      return bing->_hiding;
   }
   return ({ });
} /* query_clothing_hiding() */

/**
 * This method returns the depth of the clothing type.  The parament
 * can also be an array, in which case it will return the minimum
 * non-zero depth.
 * @param type the type of clothing to check
 * @return the depth rating of the type
 * @see query_clothing_cannot_remove()
 * @see query_clothing_hiding()
 */
int query_clothing_depth(mixed type) {
   class clothing_type bing;
   int depth;
   string str;
   int min_depth;

   if (stringp(type)) {
      bing = _types[type];
      if (bing) {
         return bing->_depth;
      }
   } else if (pointerp(type)) {
      min_depth = 100000;
      foreach (str in type) {
         depth = query_clothing_depth(str);
         if (depth < min_depth && depth > 0) {
            min_depth = depth;
         }
      }
      return min_depth;
   }
   return 0;
} /* query_clothing_depth() */

/**
 * This method returns the depth of the clothing type.  The parament
 * can also be an array, in which case it will return the maximum
 * non-zero depth.
 * @param type the type of clothing to check
 * @return the depth rating of the type
 * @see query_clothing_cannot_remove()
 * @see query_clothing_hiding()
 */
int query_clothing_maximum_depth(mixed type) {
   class clothing_type bing;
   int depth;
   string str;
   int max_depth;

   if (stringp(type)) {
      bing = _types[type];
      if (bing) {
         return bing->_depth;
      }
   } else if (pointerp(type)) {
      max_depth = 0;
      foreach (str in type) {
         depth = query_clothing_depth(str);
         if (depth > max_depth) {
            max_depth = depth;
         }
      }
      return max_depth;
   }
   return 0;
} /* query_clothing_depth() */

/**
 * This method returns a mapping of the current clothing types.
 * <p>
 * The make up of this array is:<br>
 * <dl>
 * <dh>first element
 * <dd> is the items which if you're wearing this
 * one cannot be removed.
 * <dh>second element
 * <dd>is the items which hide the given item.
 * </dl>
 * i.e. The wig type cannot be removed if types hood, helmet
 * or hat are also worn, also the wig type is not visible
 * if the types hood, helmet or hat are worn.
 * @return the mapping of clothing types
 * @see add_clothing_type()
 */
mapping query_all_clothing_types() {
   return _types;
} /* query_clothing_types() */

/**
 * This method will go through all the current types and make sure the
 * hidden and the cannot remove types are valid.  It will also figure
 * out depth numbers for all the types.
 */
private void check_clothing_types() {
   string ty;
   class clothing_type bits;
   string *stuff;
   string bing;
   string type;
   int rank;

tell_creator("presto", "called check_clothing_types\n");
   foreach (ty, bits in _types) {
      foreach (bing in bits->_not_remove) {
         if (!query_clothing_type(bing)) {
            write("Unknown clothing type " + bing + " in the not remove "
                  " for " + ty + ".\n");
         }
      }
      foreach (bing in bits->_hiding) {
         if (!query_clothing_type(bing)) {
            write("Unknown clothing type " + bing + " in the hiding "
                  " for " + ty + ".\n");
         }
      }
   }
   /*
    * Go through each zone and assign levels to them...
    */
   rank = 1;
   foreach (bing in _zone_level) {
      stuff = query_clothing_zone(bing);
      /* Set the top levels. */
      foreach (type in stuff) {
         bits = _types[type];
         if (!bits->_depth &&
             (sizeof(bits->_not_remove) == 0  ||
             bits->_not_remove[0] == "all covering")) {
            bits->_depth = rank;
            rank = fixup_types(type, stuff);
         }
      }
      foreach (type in stuff) {
         bits = _types[type];
         if (!bits->_depth) {
tell_creator("presto", "setting depth of %O to %d\n", type, rank + 1);
            bits->_depth = rank++;
         }
      }
   }
} /* check_clothing_types() */

private int fixup_types(string type, string *types) {
   string bing;
   class clothing_type base;
   class clothing_type bits;
   int depth;

   base = _types[type];
   depth = base->_depth + 1;
   foreach (bing in types) {
      bits = _types[bing];
      /* Gravitate it upwards... */
      if (!bits->_depth &&
          member_array(type, bits->_not_remove) != -1) {
         bits->_depth = depth;
         depth = fixup_types(bing, types);
      }
   }
   return depth;
} /* fixup_types() */

/**
 * This method adds a clothing zone.
 * @param zone the zone name
 * @param types the types to add to the zone
 */
protected void add_clothing_zone(string zone, string *types) {
   string ty;

   /* Check to make sure each type exists. */
   foreach (ty in types) {
      if (!query_clothing_type(ty)) {
         write("Incorrect clothing type " + ty + " in zone " + zone + ".\n");
      }
   }
   _zones[zone] = types;
   _zone_level += ({ zone });
} /* add_clothing_zone() */

/**
 * This method sets the zones that a particular clothing type covers
 * @param type the clothing type
 * @zones the zones covered.
 */
protected void add_zone_coverage(string type, string *zones) {
  string zone;

  if(!query_clothing_type(type))
    write("Incorrect clothing type " + type + "\n");

  foreach(zone in zones)
    if(member_array(type, zones) != -1)
      _zones[zone] += ({ type });
}

/**
 * This method returns the clothing zones.  The mapping consists of
 * arrays of types which are in the particular zones.
 * @return the clothing zones
 */
mapping query_all_clothing_zones() {
   return _zones;
} /* query_clothing_zones() */

/**
 * This method returns the array of clothing types in the particular
 * zone.
 * @param zone the zone to get the types for
 * @return the clothing in the current zone
 */
string *query_clothing_zone(string zone) {
   return _zones[zone];
} /* query_clothing_zone() */

/**
 * This method finds the zone for the specific type.
 * @param type the type to find in the zones
 * @return the zone name, 0 if not found
 */
string query_zone_name(string type) {
   string zone;
   string *stuff;

   foreach (zone, stuff in _zones) {
      if (member_array(type, stuff) != -1) {
         return zone;
      }
   }
   return 0;
} /* query_zone_name() */

/**
 * This method finds all the zones for the specific type.
 * @param type the type to find in the zones
 * @return the zone names, 0 if not found
 */
string *query_zone_names(string type) {
   string zone;
   string *stuff;
   string *zones;

   if(_equivilants[type])
     type = _equivilants[type];

   zones = ({ });
   foreach (zone, stuff in _zones) {
     if (member_array(type, stuff) != -1 && zone) {
       zones += ({ zone });
     }
   }
   return zones;
} /* query_zone_name() */

/**
 * This method returns the level for the specified zone.
 * @param zone the zone to check
 * @return the level of the zone
 */
int query_zone_level(string zone) {
   int i;

   i = member_array(zone, _zone_level);
   return i * 100;
} /* query_zone_level() */

/**
 * This method adds an equivilant type.
 * @param name the name of the type
 * @param equiv what it is equivilant to
 */
protected void add_equivilant_type(string name, string equiv) {
   if (!query_clothing_type(equiv)) {
      write("Incorrect clothing type " + equiv + " in equivilant listing.\n");
   }
   _equivilants[name] = equiv;
} /*  add_equivilant_type() */

/**
 * This method returns all the equivilant types.
 * @return the equivilant types
 */
mapping query_all_equivilant_types() {
   return _equivilants;
} /* query_equivilant_types() */

/**
 * This method returns the equivilant type for the given type.
 * @param type the type to get the equivilant fo
 * @return the equivilant type
 */
string query_equivilant_type(string type) {
   return _equivilants[type];
} /* query_equivilant_type() */

/**
 * This method tells us if the type is valid.  It checks both normal
 * types and equivilant types.
 * @param type the type to check
 * @return 1 if it is valid, 0 if not
 * @query_equivilant_type()
 * @query_clothing_type()
 */
int query_valid_type(string type) {
   if (query_clothing_type(type) ||
       query_equivilant_type(type)) {
      return 1;
   }
   return 0;
} /* query_valid_type() */
// --- END [/mnt/home2/grok/lib/obj/handlers/clothing_handler.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/hist_handler.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/hist_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628578   Available: 13575932
Inodes: Total: 5242880    Free: 4960134
4937 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/hist_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628578   Available: 13575932
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: hist_handler.c,v 1.5 2001/08/01 23:38:00 ceres Exp $
 * 
*/
/**
 * The channel history handler. by Turrican@Discworld.
 * Based on the tell history.
 * @started 23-3-1995
 * @change 20-6-1995, Turrican
 * Added the lord channel
 * @change 13-12-1995, Turrican
 * Added chat line 1 
 * @change 28-5-1996, Turrican
 * Rewritten somewhat
 * @change 13-9-1998
 * Modified to remove ancient histories on temporary channels.
 */

#define SAVE "/save/hist_handler.o"
#define MAX_HIS 20
#define HISTORY_TIME (3600*24*2)

mapping history;

mixed *query_lord_history();
void add_lord_history( string start, string mess );

void create() {
  seteuid(master()->get_root_uid());
  history = ([]);
  if(!unguarded((: restore_object, SAVE+".gz" :)))
    unguarded((: restore_object, SAVE :));
  call_out("tidy_history", 2);
} /* create() */

/** Save the current state. */
void save_me() {
  unguarded((: save_object, SAVE, 2 :));
} /* save_me() */

/**
 * Add the history of the creator channel.
 * @param start the start bit, emote or not
 * @param mess the message they said
 */
void add_cre_history(string start, string mess) {
  mixed *cre_history = history["cre"];

  if (undefinedp(history["cre"]))
    cre_history = ({ ({ start, mess, time() }) });
  else
    cre_history += ({ ({ start, mess, time() }) });
  if (sizeof(cre_history) > MAX_HIS)
    cre_history = cre_history[1..];
  history["cre"] = cre_history;
} /* add_cre_history() */

/**
 * Returns the current creator history. The array contains arrays of
 * three elemnts each.,   In each array the first element is the
 * start, the second the mssage and thwe third the time.
 * <p>
 * <code>({  .. ({ start, mess, time }), ({ start, mess, time }), .. })</code>
 * @return an array of the creator history.
 */
mixed *query_cre_history() {
  return history["cre"];
} /* query_cre_history() */

/**
 * Keep a mesage from a specified line on the chat stick.
 * @param channel the channel being stored
 * @param start the start string (name)
 * @param mess the message being stored
 */
void add_chat_history(string channel, string start, string mess) {
  mixed *chat_history = history[channel];

  if ( !chat_history ) {
    chat_history = ({ });
  }
  if (channel == "lord")   {
    add_lord_history( start, mess );
    return;
  } else {
    chat_history += ({ ({ start, mess, time() }) });
  }
  if (sizeof(chat_history) > MAX_HIS) {
    chat_history = chat_history[1..];
  }
  history[channel] = chat_history;
} /* add_chat_history() */

/**
 * Returns the current chat channel history. The array contains arrays of
 * three elemnts each.,   In each array the first element is the
 * start, the second the mssage and thwe third the time.
 * <p>
 * <code>({  .. ({ start, mess, time }), ({ start, mess, time }), .. })</code>
 * @return an array of the chat channel history.
 * @param channel the channel to get the history of
 */
mixed *query_chat_history(string channel) {
  if (channel == "lord")
    return query_lord_history();
  return history[channel];
} /* query_chat_history() */

/**
 * Adds a amessage into the lord channel history.
 * @param start the start staring
 * @param mess what they actually said
 */
void add_lord_history(string start, string mess) {
  mixed *lord_history = history["lord"];

  if (!master()->query_lord(previous_object(-1)))
    return;
  if (undefinedp(history["lord"]))
    lord_history = ({ ({ start, mess, time() }) });
  else
    lord_history += ({ ({ start, mess, time() }) });
  if (sizeof(lord_history) > MAX_HIS)
    lord_history = lord_history[1..];
  history["lord"] = lord_history;
} /* add_lord_history() */

/**
 * Returns the current lord history. The array contains arrays of
 * three elemnts each.,   In each array the first element is the
 * start, the second the mssage and thwe third the time.
 * <p>
 * <code>({  .. ({ start, mess, time }), ({ start, mess, time }), .. })</code>
 * @return an array of the lord history.
 */           
mixed *query_lord_history() {
  if (!master()->query_lord(previous_object(-1)))
    return ({ });
  return history["lord"];
}  /* query_lord_history() */

/** @ignore yes */
void dest_me() {
  save_me();
  destruct(this_object());
} /* dest_me() */

/** @ignore yes */
void reset() {
  save_me();
}

/**
 * @ignore yes
 * Clean up old history items.
 */
void tidy_history() {
  string channel;
  int i;
  
  foreach(channel in keys(history)) {
    for(i = 0; i<sizeof(history[channel]); i++)
      if(history[channel][i][2] < time() - HISTORY_TIME) {
  history[channel] = history[channel][1..];
      } else
  break;
    if(!sizeof(history[channel]))
      map_delete(history, channel);
  }
  save_object(SAVE, 2);
}

/**
 * @ignore yes
 * Zap all the history channels back to nothing.
 */
void reset_history() {
  if (!master()->high_programmer(previous_object(-1)))
    return;
  history = ([]);
  save_object(SAVE, 2);
} /* reset_history() */
// --- END [/mnt/home2/grok/lib/obj/handlers/hist_handler.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/newspaper.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/newspaper.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628576   Available: 13575930
Inodes: Total: 5242880    Free: 4960134
24383 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/newspaper.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628576   Available: 13575930
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is a general newspaper edition handler.  It will deal with keeping
 * track of all the data for all the newspapers on the mud.
 * @author Pinkfish
 * @started Sat Apr 28 02:30:49 PDT 2001
 */
#include <room/newspaper.h>
#include <nroff.h>
#include <autodoc.h>
#include <login_handler.h>

#define SAVE_DIR "/save/newspaper/"


class edition {
   int date_published;
   class article* articles;
   class advert* adverts;
   string headline;
   int num_sold;
   int num_web_hits;
   int total_revenue;
}

class paper {
   class edition* published_editions;
   string dir_name;
   string long;
   string description;
   string office;
   int paper_cost;
   string language;
}

private mapping _papers;
private mapping _areas;
private mapping _xp;
private mapping _inform;

void load_me();
void save_me();

void create() {
   _papers = ([ ]);
   _areas = ([ ]);
   _xp = ([ ]);
   _inform = ([ ]);
   seteuid(getuid());
   load_me();
   if (!_inform) {
      _inform = ([ ]);
   }
} /* create() */

/**
 * This method checks to see if the paper exists.
 * @param paper the paper name to check for
 */
int is_paper(string paper) {
   return classp(_papers[paper]);
} /* is_paper() */

/**
 * This method adds a paper.
 * @param paper the name of the paper
 * @param long the description on the newspapers themselves
 * @param desc the description on the web page
 * @param office the path to the office
 */
void add_paper(string name, string long, string desc, string office,
    string language) {
   if (is_paper(name)) {
      return ;
   }
   _papers[name] = new(class paper);
   _papers[name]->published_editions = ({ });
   _papers[name]->dir_name = replace_string(lower_case(name), " ", "_");
   _papers[name]->long = long;
   _papers[name]->description = desc;
   _papers[name]->office = office;
   _papers[name]->paper_cost = 5 * 4;
   _papers[name]->language = language;
   save_me();
} /* add_paper() */

/**
 * This method returns the list of all the papers.
 * @return all the papers
 */
string* query_all_papers() {
   return keys(_papers);
} /* query_all_papers() */

/**
 * This method returns the current edition of the paper.
 * @param paper the paper to get the edition of
 * @return the current edition
 */
int query_current_edition_num(string paper) {
   if (!is_paper(paper)) {
      return 0;
   }
   return sizeof(_papers[paper]->published_editions) + 1;
} /* query_current_edition_num() */

/**
 * This method returns the last edition of the paper.
 * @param paper the paper to get the edition of
 * @return the last edition, 0 if there are no editions
 */
int query_last_edition_num(string paper) {
   if (!is_paper(paper)) {
      return 0;
   }
   return sizeof(_papers[paper]->published_editions);
} /* query_last_edition_num() */

/**
 * This checks to see if the specified edition is valid or not.
 * @param paper the paper to check
 * @param edition the edition to check
 * @return 1 if it ok, 0 if not
 */
int is_valid_edition(string paper, int edition) {
   if (!is_paper(paper)) {
      return 0;
   }

   if (edition > 0 && edition <= sizeof(_papers[paper]->published_editions)) {
      return 1;
   }
   return 0;
} /* is_valid_edition() */

/**
 * This method returns the date at which the specified issue was
 * published.
 * @param paper the paper to check
 * @param edition the edition to look up
 * @return the date at which the edition was published
 */
int query_edition_date(string paper, int edition) {
   if (!is_paper(paper)) {
      return 0;
   }

   if (!is_valid_edition(paper, edition)) {
      return 0;
   }

   return _papers[paper]->published_editions[edition - 1]->date_published;
} /* query_edition_date() */

/**
 * This method returns the articles in the specified edition of the
 * paper.
 * @param paper the paper to look up
 * @param edition the edition to look up
 * @return the articles in the edition
 */
class article* query_edition_articles(string paper, int edition) {
   if (!is_paper(paper)) {
      return ({ });
   }

   if (!is_valid_edition(paper, edition)) {
      return ({ });
   }

   return copy(_papers[paper]->published_editions[edition - 1]->articles);
} /* query_edition_articles() */

/**
 * This method returns the adverts in the specified edition of the
 * paper.
 * @param paper the paper to look up
 * @param edition the edition to look up
 * @return the adverts in the edition
 */
class advert* query_edition_adverts(string paper, int edition) {
   if (!is_paper(paper)) {
      return ({ });
   }

   if (!is_valid_edition(paper, edition)) {
      return ({ });
   }

   return copy(_papers[paper]->published_editions[edition - 1]->adverts);
} /* query_edition_adverts() */

/**
 * This method returns the office of the paper.
 * @param paper the paper to look up
 * @return the office of the paper
 */
string query_paper_office(string paper) {
   if (!is_paper(paper)) {
      return  0;
   }

   return _papers[paper]->office;
} /* query_paper_headline() */

/**
 * This method sets the office of the paper.
 * @param paper the paper to look up
 * @param office the new office of the paper
 */
void set_paper_office(string paper, string office) {
   if (!is_paper(paper)) {
      return  0;
   }

    _papers[paper]->office = office;
   save_me();
} /* query_paper_headline() */

/**
 * This method returns the headline for the selected edition of the paper.
 * @param paper the paper to look up
 * @param edition the edition to look up
 * @return the headline of the edition
 */
string query_paper_headline(string paper, int edition) {
   if (!is_valid_edition(paper, edition)) {
      return  "No news is good news.";
   }

   return _papers[paper]->published_editions[edition - 1]->headline;
} /* query_paper_headline() */

/**
 * This method returns the headline for the selected edition of the paper.
 * @param paper the paper to look up
 * @param edition the edition to look up
 * @param headline the headline of the issue
 */
void set_paper_headline(string paper, int edition, string headline) {
   if (!is_valid_edition(paper, edition)) {
      return  ;
   }

   _papers[paper]->published_editions[edition - 1]->headline = headline;
   save_me();
} /* set_paper_headline() */

/**
 * This method returns the total revenue for this edition.
 * @param paper the paper to look up
 * @param edition the edition to look up
 * @return the headline of the edition
 */
int query_edition_revenue(string paper, int edition) {
   if (!is_valid_edition(paper, edition)) {
      return  0;
   }

   return _papers[paper]->published_editions[edition - 1]->total_revenue;
} /* query_edition_revenue() */

/**
 * This method adds to the total revenue for this edition.
 * @param paper the paper to look up
 * @param edition the edition to look up
 * @param revenue the revenue to add
 */
void add_edition_revenue(string paper, int edition, int revenue) {
   if (!is_valid_edition(paper, edition)) {
      return  ;
   }

   _papers[paper]->published_editions[edition - 1]->total_revenue += revenue;
   save_me();
} /* add_edition_headline() */

/**
 * This method adds a web hit to the specified edition.
 * @param paper the paper to add a hit on
 * @param edition the edition to add a hit on
 */
void add_edition_web_hit(string paper, int edition) {
   if (!is_valid_edition(paper, edition)) {
      return  ;
   }

   _papers[paper]->published_editions[edition - 1]->num_web_hits++;
   _papers[paper]->published_editions[edition - 1]->total_revenue += NEWSPAPER_WEB_HIT_REVENUE;
   save_me();
} /* add_edition_web_hit() */

/**
 * This method adds a web paper sold to the specified edition.
 * @param paper the paper which was sold
 * @param edition the edition which was sold
 * @param cost the amount it was sold for
 */
void add_edition_paper_sold(string paper, int edition, int cost) {
   if (!is_valid_edition(paper, edition)) {
tell_creator("pinkfish", "Not valid edition %O %O\n", paper, previous_object());
      return  ;
   }

tell_creator("pinkfish", "Updating num sold %O %O\n", paper, edition);
   _papers[paper]->published_editions[edition - 1]->num_sold++;
   _papers[paper]->published_editions[edition - 1]->total_revenue += cost;
   save_me();
} /* add_edition_web_hit() */

/**
 * This method returns the number of papers which have been sold.
 * @param paper the paper which was sold
 * @param edition the edition to check
 * @return the number of papers that have been sold
 */
int query_edition_num_sold(string paper, int edition) {
   if (!is_valid_edition(paper, edition)) {
      return  0;
   }

   return _papers[paper]->published_editions[edition - 1]->num_sold;
} /* query_edition_num_sold() */

/**
 * This method returns the number of web hits for the editon.
 * @param paper the paper which was hit
 * @param edition the edition to check
 * @return the number of web hits on the edition
 */
int query_edition_num_web_hits(string paper, int edition) {
   if (!is_valid_edition(paper, edition)) {
      return  0;
   }

   return _papers[paper]->published_editions[edition - 1]->num_web_hits;
} /* query_edition_num_web_hits() */

/**
 * This method checks to see if the area exists or not.
 * @param area the area to check for
 */
int is_paper_area(string area) {
   return pointerp(_areas[area]);
} /* is_paper_area() */

/**
 * This method adds a paper area.
 * @param area the area to add
 */
void add_paper_area(string area) {
   if (is_paper_area(area)) {
      return ;
   }
   _areas[area] = ({ });
} /* add_paper_area() */

/**
 * This method adds a paper to a paper area.
 * @param paper the paper to add to the area
 * @param area the area to add the paper to
 */
void add_paper_to_area(string paper, string area) {
   if (!is_paper(paper) || !is_paper_area(area)) {
      return ;
   }

   _areas[area] += ({ paper });
   save_me();
} /* add_paper_to_area() */

/**
 * This method returns all the articles in the specified paper area.
 * @param area the area to lookup
 * @return the papers in the area, returns a null array when there are no papers
 */
string* query_papers_in_area(string area) {
   if (_areas[area]) {
      return _areas[area];
   }
   return ({ });
} /* query_papers_in_area() */

/**
 * This moves the data for the article into the correct location.
 * @param article the article to set the text for
 * @param text the text to set
 */
void set_article_text(class article art, string text) {
   unguarded( (:
      write_file(SAVE_DIR + $(art->file_name), save_variable(({ $(art), $(text) })), 1) :) );
} /* set_article_text() */

/**
 * This method adds an object to be informed of a paper being published.
 * When the paper is published, the function event_publish_paper,
 * is called on all the objects in this list.
 * @param paper the paper to be informed about
 * @param ob the object to be informed
 */
void add_newspaper_inform(string paper, string ob) {
   if (!_inform[paper]) {
      _inform[paper] = ({ });
   }
   if (!stringp(ob)) {
      return ;
   }
   if (member_array(ob, _inform[paper]) != -1) {
      return ;
   }
   _inform[paper] += ({ ob });
   save_me();
} /* add_newspaper_infom() */

/**
 * This method removes an object to be informed of a paper being published.
 * @param paper the paper to no longer be informed about
 * @param ob the object to no longer be informed
 */
void remove_newspaper_inform(string paper, string ob) {
   if (!_inform[paper]) {
      return ;
   }
   _inform[paper] -= ({ ob });
   save_me();
} /* remove_newspaper_infom() */

/**
 * This method returns the list of objects that want to be informed about
 * this paper.
 * @param paper the paper to be informed about
 * @return the list of objects to inform
 */
string* query_newspaper_informs(string paper) {
   if (!_inform[paper]) {
      return ({ });
   }
   return _inform[paper];
} /* query_newspaper_informs() */

/**
 * This method reads in the data associated with the specified article.
 * @param article the article to read the text for
 * @return the article text
 */
string query_article_text(class article art) {
   string str;
   string* bits;

   str = unguarded( (: read_file(SAVE_DIR + $(art->file_name)) :) );
   if (str) {
      bits = restore_variable(str);
      return bits[1];
   }
   return "Error reading the article text.";
} /* query_article_text() */

/**
 * This method reads in the data associated with the specified article
 * in html.
 * @param article the article to read the text for
 * @return the article text
 */
string query_article_text_html(class article art) {
   string str;
   string* bits;

   str = unguarded( (: read_file(SAVE_DIR + $(art->file_name)) :) );
   if (str) {
      bits = restore_variable(str);
      switch (art->type & NEWSPAPER_ARTICLE_TYPE_MASK) {
      case NEWSPAPER_ARTICLE_TYPE_PLAIN :
         bits[1] = replace_string(bits[1], "\n\n", "<p>");
         bits[1] = replace_string(bits[1], "\n", "<br>");
         return bits[1];
      case NEWSPAPER_ARTICLE_TYPE_HTML :
         bits[1] = replace_string(bits[1], "<pre>", "</font><pre>");
         bits[1] = replace_string(bits[1], "</pre>",
                                  "</pre>\n<font face=\"helvetica,arial\">");
         return bits[1];
      }
      return bits[1];
   }
   return "Error reading the article text.";
} /* query_article_text_html() */

/**
 * This method changes an input string into a 'nroff' equivilant output
 * string.
 * @param str the string to convert
 */
string convert_html(string input) {
   return AUTODOC_NROFF->convert_html(input);
} /* convert_html() */

/**
 * This method reads in the data associated with the specified article
 * in plain output.
 * @param article the article to read the text for
 * @return the article text
 */
string query_article_text_plain(class article art) {
   string str;
   string fluff;
   string* bits;

   switch (art->type & NEWSPAPER_ARTICLE_TYPE_MASK) {
   case NEWSPAPER_ARTICLE_TYPE_SECTION :
      return "";
   case NEWSPAPER_ARTICLE_TYPE_PLAIN :
      str = unguarded( (: read_file(SAVE_DIR + $(art->file_name)) :) );
      if (str) {
         bits = restore_variable(str);
         return bits[1];
      }
      break;
   case NEWSPAPER_ARTICLE_TYPE_HTML :
      // Check and see if we have an nroff file already.
      fluff = unguarded( (: NROFF_HAND->cat_file(SAVE_DIR + $(art->file_name) + ".nroff", 1) :) );
      if (!fluff) {
         // Make the html output.
         str = unguarded( (: read_file(SAVE_DIR + $(art->file_name)) :) );
         if (str) {
            bits = restore_variable(str);
            bits[1] = convert_html(bits[1]);
            unguarded( (: write_file(SAVE_DIR + $(art->file_name) + ".proc",
                                     $(bits[1]), 1) :) );
            unguarded( (: NROFF_HAND->create_nroff(SAVE_DIR + $(art->file_name) + ".proc",
                                SAVE_DIR + $(art->file_name) + ".nroff") :) );
            str = unguarded( (: NROFF_HAND->cat_file(SAVE_DIR + $(art->file_name) + ".nroff") :) );
            return str;
         }
      } else {
         return fluff;
      }
   }
   return "Error reading the article text.";
} /* query_article_text_plain() */

/**
 * This method returns the long description of the paper.  The long
 * description is used in the newspapers around the place as it's
 * description.
 * @param paper the paper to get the long for
 */
string query_paper_long(string paper) {
   if (!is_paper(paper)) {
      return "This is a very transperant and unhappy newspaper.\n";
   }

   return _papers[paper]->long;
} /* query_paper_long() */

/**
 * This method sets the description of the paper.  The description is
 * what is shown on the web page for the paper.
 * @param paper the paper to set the long for
 * @param long the new long description of the paper
 */
void set_paper_description(string paper, string description) {
   if (!is_paper(paper)) {
      return ;
   }

   _papers[paper]->description = description;
   save_me();
} /* set_paper_description() */

/**
 * This method returns the description description of the paper.  The long
 * description is used in the newspapers around the place as it's
 * description.
 * @param paper the paper to get the long for
 */
string query_paper_description(string paper) {
   if (!is_paper(paper)) {
      return "This is a very transperant and unhappy newspaper.\n";
   }

   return _papers[paper]->description;
} /* query_paper_description() */

/**
 * This method sets the long of the paper.  The long description is
 * used in the newspapers around the place.
 * @param paper the paper to set the long for
 * @param long the new long description of the paper
 */
void set_paper_long(string paper, string long) {
   if (!is_paper(paper)) {
      return ;
   }

   _papers[paper]->long = long;
   save_me();
} /* set_paper_long() */

/**
 * This method sets the cost at which the paper will be sold.
 * @param paper the paper to set the cost of
 * @param cost the new cost of the paper
 */
void set_paper_cost(string paper, int cost) {
   if (!is_paper(paper)) {
      return ;
   }

   _papers[paper]->paper_cost = cost;
   save_me();
} /* set_paper_cost() */

/**
 * This method returns the cost at which the paper will be sold.
 * @param paper the paper to set the cost of
 * @return the cost at which the paper will be sold
 */
int query_paper_cost(string paper) {
   if (!is_paper(paper)) {
      return 0;
   }

   return _papers[paper]->paper_cost;
} /* set_paper_cost() */

/**
 * This method publishes a new edition of the specified paper.
 * @param paper the paper to publish an edition of
 * @param articles the articles in the paper
 * @param text the corresponding text to the articles
 * @param adds the adverts in the paper
 * @return 1 if successful, 0 if not
 */
int publish_paper(string paper,
                  string headline,
                  class article* articles,
                  string* text,
                  class advert* adds,
                  string* editors) {
   string paper_dir;
   string tmp;
   class paper fluff;
   class article article;
   class edition womble;
   int i;
   int edition;
   int total_xp;
   int type;

   if (!is_paper(paper)) {
      return 0;
   }

   fluff = _papers[paper];
   edition = sizeof(fluff->published_editions) + 1;
   paper_dir = SAVE_DIR + fluff->dir_name;
   unguarded( (: mkdir($(paper_dir)) :));
   paper_dir += "/" + edition;
   unguarded( (: mkdir($(paper_dir)) :));

   foreach (article in articles) {
      article->file_name = fluff->dir_name + "/" + edition + "/" +
                           article->file_name;
      type = article->type & NEWSPAPER_ARTICLE_TYPE_MASK;
      // Do not give xp for adds or sections.
      if ((type == NEWSPAPER_ARTICLE_TYPE_PLAIN ||
           type == NEWSPAPER_ARTICLE_TYPE_HTML) &&
           !(article->type & NEWSPAPER_ARTICLE_NO_XP_FLAG)) {
         _xp[lower_case(article->author)] += NEWSPAPER_XP_PER_ARTICLE;
         total_xp += NEWSPAPER_XP_PER_ARTICLE;
      }
   }

   // make it 10%
   total_xp = total_xp * 10 / 100;
   total_xp += NEWSPAPER_XP_EDITOR;
   if (sizeof(editors)) {
      foreach (tmp in editors) {
         _xp[tmp] += total_xp / sizeof(editors);
      }
   }

   // Copy the article data into the relevant place.
   for (i = 0; i < sizeof(articles); i++) {
      set_article_text(articles[i], text[i]);
   }

   womble = new(class edition);
   womble->articles = articles;
   womble->adverts = adds;
   womble->date_published = time();
   womble->headline = headline;
   fluff->published_editions += ({ womble });

   save_me();

   foreach (tmp in query_newspaper_informs(paper)) {
      call_out((: $1->event_publish_paper($2) :), 2, tmp, paper);
   }
   return 1;
} /* publish_paper() */

/** @ignore yes */
void load_me() {
   string paper;
   class paper fluff;
   class paper rabbit;
   //class edition green;
   //class article igloo;
   //int i;

   unguarded( (: restore_object(SAVE_DIR + "main", 1) :) );
   foreach (paper, fluff in _papers) {
      if (sizeof(fluff) == 6) {
         rabbit = new(class paper);
         rabbit->published_editions = fluff->published_editions;
         rabbit->dir_name = fluff->dir_name;
         rabbit->long = fluff->long;
         rabbit->description = fluff->description;
         rabbit->office = fluff->office;
         rabbit->paper_cost = 5 * 4;
         rabbit->language = "general";
         _papers[paper] = rabbit;
         fluff = rabbit;
      } else if( sizeof( fluff ) == 7 ) {
         rabbit = new(class paper);
         rabbit->published_editions = fluff->published_editions;
         rabbit->dir_name = fluff->dir_name;
         rabbit->long = fluff->long;
         rabbit->description = fluff->description;
         rabbit->office = fluff->office;
         rabbit->paper_cost = 5 * 4;
         rabbit->language = fluff->language;
         _papers[paper] = rabbit;
         fluff = rabbit;
      }
/*
      foreach (green in fluff->published_editions) {
         for (i = 0; i < sizeof(green->articles); i++) {
            if (sizeof(green->articles[i]) == 6) {
               igloo = new(class article);
               igloo->file_name = green->articles[i]->file_name;
               igloo->title = green->articles[i]->title;
               igloo->author = green->articles[i]->author;
               igloo->date_written = green->articles[i]->date_written;
               igloo->type = green->articles[i]->type;
               igloo->shown_name = green->articles[i]->shown_name;
               igloo->colour = 0;
               green->articles[i] = igloo;
            }
         }
      }
 */
/*
      for (i = 0; i < sizeof(fluff->published_editions); i++) {
         if (sizeof(fluff->published_editions[i]) == 4) {
            green = new(class edition);
            green->date_published = fluff->published_editions[i]->date_published;
            green->articles = fluff->published_editions[i]->articles;
            green->adverts = fluff->published_editions[i]->adverts;
            green->headline = fluff->published_editions[i]->headline;
            fluff->published_editions[i] = green;
         }
      }
 */
   }
} /* load_me() */

/** @ignore yes */
void save_me() {
   unguarded( (: save_object(SAVE_DIR + "main") :) );
} /* save_me() */

/** @ignore yes */
mixed* stats() {
   string paper;
   string person;
   class paper data;
   mixed* ret;
   int last;
   int xp;

   ret = ({ });
   foreach (paper, data in _papers) {
      last = query_last_edition_num(paper);
      ret += ({ ({ paper + ": office", data->office }),
                ({ paper + ": dir name", data->dir_name }),
                ({ paper + ": last issue", last }),
                ({ paper + ": current issue", query_current_edition_num(paper) }),
                ({ paper + ": num sold", query_edition_num_sold(paper, last) }),
                ({ paper + ": num web hits", query_edition_num_web_hits(paper, last) }),
                ({ paper + ": revenue", query_edition_revenue(paper, last) }),
              });
   }
   foreach (person, xp in _xp) {
      ret += ({ ({ person + ": xp", xp }) });
   }
   return ret;
} /* stats() */

/**
 * @ignore yes
 * This is the login function to check the person for any exciting things like
 * waiting for xp.
 */
void player_login_check(string player, string bing) {
   object play;
   int xp;

   if (bing != LOGIN) {
      return ;
   }

   xp = _xp[player];
   if (xp) {
      play = find_player(player);
      play->adjust_xp(xp);
      map_delete(_xp, player);
      save_me();
      tell_object(play, "%^YELLOW%^You feel like the experience of writing "
                        "an article has made you a better person.\n%^RESET%^");
   }
} /* player_login_check() */

/**
 * This function sets the language for the given paper.
 * @param paper The name of the paper.
 * @param language The language to use.
 */
void set_language_for( string paper, string language ) {
    if( is_paper( paper ) )
        _papers[ paper ]->language = language;
} /* void set_language_for() */


/**
 * This function returns the language for the given newspaper.
 * @param paper The name of the paper.
 * @return The language for the paper, "general" for none or 0 if for error
 */
string query_language_for( string paper ) {
    if( is_paper( paper ) ) {
        if( !undefinedp( _papers[ paper ]->language ) )
            return _papers[ paper ]->language;
        return "general";    
    }
    return 0;
} /* string query_language_for() */


// --- END [/mnt/home2/grok/lib/obj/handlers/newspaper.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/map.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/map.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628570   Available: 13575924
Inodes: Total: 5242880    Free: 4960134
38919 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/map.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628570   Available: 13575924
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
// Planning to rewrite the thing from scratch, probably not this millenium 
// though, Wodan 31-5-1999.
/**
 * This contains information about all the rooms in the mud.  It is used
 * by things like the route handler to determine routes between two
 * locations.
 * <p>
 * As coded by Wodan and overhauled by Olorin and overhauled again by Wodan.
 * and rewritten by Olorin
 * The thing is somehow improving though :)
 * @author Wodan
 */

/* All mappings are indexed on [ directory ][ file ] 
 * map contains direction, destination pairs
 * shorts contain the a_short() of the rooms
 * movezoness contain the movezones
 * coords holds the coordinates of the rooms
 * sizes holds the sizes of the rooms
 * changetimes contain the time the file where last changed
 * forced_rooms hold the rooms that are to be updated even if the file is old.
 * 
 * cache contains the directories remembered in the mappings and
 * is used for flushing them to keep the size of the handler down.
 */
#include <map_handler.h>
#include <config.h>
inherit "/obj/handlers/inherit/distance_handler";

mapping shorts = ([ ]);
mapping movezoness = ([ ]);
mapping changetimes = ([ ]);
#if !efun_defined(db_exec)
mapping clusters = ([ ]);
mapping map = ([ ]);
#else
int db, loop = 0;
#include <db.h>
#endif
mapping forced_rooms = ([ ]);
#ifdef COORDS
mapping coords = ([ ]);
mapping sizes = ([ ]);
#endif
int load = 0, time, stopped;
string *cache = ({ }), *queue = ({ });

int check_next_call_out;

mapping stats = ([]);

private void do_room1( string room );
private void check_next();
private void check_map2( string );

void create() {
   seteuid( (string)"secure/master"->get_root_uid() );
   "/room/void"->force_load();
   check_next_call_out = call_out( (: check_next :), SKEWTIME );
#if efun_defined(db_exec)
   db = db_connect("localhost","discworld",CONFIG_DB_USER);
#endif
} /* create() */


/**
 * This method goes through the cahce on the directory and
 * removes all the current references to the directory.  If the
 * load parameter is non-zero then the directory is forced to
 * be reloaded even if it already exists.  If this parameter is
 * not set then the directory will only be loaded if it is not
 * already in the cache.
 * <p>
 * This method uses the functions in the map helper to set the
 * values in all the internal variables.  It also swaps the
 * specified directory onto the end of the cache list, so it
 * will be removed later.
 * @param directory the directory to update
 * @param load should we force this to reload
 * @see clear_cache()
 * @see /obj/handlers/map_helper.c
 */
protected void update_cache( string directory, int load ) {
   if ( !shorts[ directory ] || load ) {
      cache = ( cache - ({ directory }) ) + ({ directory });
      if ( sizeof( cache ) > CACHESIZE ) {
         map_delete( shorts, cache[ 0 ] );
         map_delete( movezoness, cache[ 0 ] );
         map_delete( changetimes, cache[ 0 ] );
#if !efun_defined(db_exec)
         map_delete( clusters, cache[ 0 ] );
         map_delete( map, cache[ 0 ] );
#endif
#ifdef COORDS
         map_delete( coords, cache[ 0 ] );
         map_delete( sizes, cache[ 0 ] );
#endif
         cache -= ({ cache[ 0 ] });
         LOG( sprintf( "%%^RED%%^uncaching %s%%^RESET%%^\n", cache[ 0 ] ) );
      }
      shorts[ directory ] = MH->query_shorts( directory );
      movezoness[ directory ] = MH->query_movezones( directory );
      changetimes[ directory ] = MH->query_changetimes( directory );
#if !efun_defined(db_exec)
      clusters[ directory ] = MH->query_clusters( directory );
      map[ directory ] = MH->query_map( directory );
#endif
#ifdef COORDS
      coords[ directory ] = MH->query_co_ords( directory );
      sizes[ directory ] = MH->query_sizes( directory );
#endif
   }
} /* update_cache() */

/**
 * This method completely clears the cache of all information.  This method
 * is used for debugging purposes.
 * @see update_cache()
 */
void clear_cache() {
   shorts = ([ ]);
   movezoness = ([ ]);
   changetimes = ([ ]);
#if !efun_defined(db_exec)
   clusters = ([ ]);
   map = ([ ]);
#endif
#ifdef COORDS
   coords = ([ ]);
   sizes = ([ ]);
#endif
   cache = ({ });
} /* clear_cache() */

#if !efun_defined(db_exec)
/**
 * This method attempts to return the map for the current directory.  This
 * returns a mapping which contains an index being the room and the
 * indicies are direction, destination pairs.
 * <pre>
 * ([
 *    file : ({
 *              direction1,
 *              destination1,
 *              ...
 *            }),
 *  ])
 * </pre>
 * @param dir the directory to load the information for
 * @return the directions mapping
 * @see update_cache()
 * @see change_map()
 */
mapping query_map( string dir ) {
   if ( !map[ dir ] ) {
     update_cache( dir, 1 );   
   }
   stats["map"]++;
   return map[ dir ];
} /* query_map() */

/**
 * This method changes the current values of the map values for the
 * specified room.
 * @param dir the directory to change the values in
 * @param room the room to change the directory for
 * @param dd the array containing the direction, destination pairs
 * @see query_map()
 */
void change_map( string dir, string room, string *dd ) {
   MH->change_map( dir, room, dd );
   map[ dir ][ room ] = dd;
} /* change_map() */
#endif

/**
 * This method will return all the shorts for the specified directory.
 * The mapping returned has keys of the room names and values of the
 * short description of the room.
 * @param dir the directory to return the shorts for
 * @return the shorts descriptions mapping
 * @see change_shorts()
 */
mapping query_shorts( string dir ) {
   if ( !shorts[ dir ] ) {
      update_cache( dir, 1 );
   }
   stats["shorts"]++;
   return shorts[ dir ];
} /* query_shorts() */

/**
 * This method changes the short description for the room and directory.
 * @param dir the directory to change the short in
 * @param room the room to change the short in
 * @param sh the short description for the room
 * @see query_shorts()
 */
void change_shorts( string dir, string room, string sh ) {
   MH->change_shorts( dir, room, sh );
   shorts[ dir ][ room ] = sh;
} /* change_shorts() */

/**
 * This method returns all the move zones for the specified directory.
 * This method returns a mapping whose keys are the rooms and the
 * values are the movezones for that room.
 * @param dir the directory to return the move zones for
 * @return the movezones mapping
 * @see change_movezones()
 */
mapping query_movezones( string dir ) {
   if ( !movezoness[ dir ] ) {
      update_cache( dir, 1 );
   }
   stats["movezones"]++;
   return movezoness[ dir ];
} /* query_movezones() */

/**
 * This method changes the value of the move zones for the specified
 * room and directory.
 * @param dir the directory to change the values in
 * @param room the room the change the values in
 * @param zones the new set of move zones
 * @see query_movezones()
 */
void change_movezones( string dir, string room, string *zones ) {
   MH->change_movezones( dir, room, zones );
   movezoness[ dir ][ room ] = zones;
} /* change_movezones() */

/**
 * This method returns all the change times for the specified directory.
 * The change times are the time at which the file was last changed.
 * This method returns a mapping, the key of the mapping is the
 * room and the index of the mapping is the time at which it changed
 * (an integer).
 * @param dir the directory to return the change times for
 * @return the change times mapping
 * @see change_changetimes()
 */
mapping query_changetimes( string dir ) {
   if ( !changetimes[ dir ] ) {
      update_cache( dir, 1 );
   }
   stats["changetimes"]++;
   return changetimes[ dir ];
} /* query_changetimes() */

/**
 * This method changes the current change time for the room in the
 * dirctory.
 * @param dir the directory to change the room in
 * @param room the room to change
 * @param time the new change time for the room
 * @see query_changetimes()
 */
void change_changetimes( string dir, string room, int time ) {
   MH->change_changetimes( dir, room, time );
   changetimes[ dir ][ room ] = time;
} /* change_changetimes() */

/**
 * This method returns the current clusters for the specified dir.
 * The returned mapping has keys of the room and the values are
 * the cluster number.
 * @param dir the directory to return the clusters for
 * @return the clusters mapping
 * @see change_clusters()
 */
#if !efun_defined(db_exec)
mapping query_clusters( string dir ) {
  if ( !clusters[ dir ] ) {
    update_cache( dir, 1 );
  }
  return clusters[ dir ];
} /* query_clusters() */

/**
 * This method change sthe current cluster for the given room.
 * @param dir the directory in which to change the room
 * @param room the room to change the cluster in
 * @param cluster the new value for the cluster of the room
 * @see quert_clusters()
 */
void change_clusters( string dir, string room, int cluster ) {
   MH->change_clusters( dir, room, cluster );
   if(clusters[ dir ])
     clusters[ dir ][ room ] = cluster;
} /* change_clusters() */
#endif

#ifdef COORDS
/**
 * This method returns the coordinates for the specified directory.
 * The mapping containers keys of the room and the values are the
 * coordinates of the room.
 * @param dir the directory to return the coordinates for
 * @return the coordinates mapping
 * @see change_co_ords()
 */
mapping query_co_ords( string dir ) {
   if ( !coords[ dir ] )
      update_cache( dir, 1 );
   stats["co_ords"]++;
   return coords[ dir ];
} /* query_co_ords() */

/**
 * This method changes the coordinates of the room.
 * @param dir the directory to change the coordinates in
 * @param room the room to change the coordinates for
 * @param coord the new coordinates for the room
 */
void change_co_ords( string dir, string room, int *coord ) {
   MH->change_co_ords( dir, room, coord );
   coords[ dir ][ room ] = coord;
} /* change_co_ords() */

/**
 * This method will return the sizes for all the rooms in the directory.
 * @return the sizes mapping
 * @param dir the directory to return the sizes mapping for
 * @see change_sizes()
 */
mapping query_sizes( string dir ) {
   if ( !sizes[ dir ] )
      update_cache( dir, 1 );
   stats["sizes"]++;
   return sizes[ dir ];
} /* query_sizes() */

/**
 * This method changes the currently stored sizes for the room
 * @param dir the direct to change the size in
 * @param room the room to change the size in
 * @param size the new size for the room
 * @see query_sizes()
 */
void change_sizes( string dir, string room, int *size ) {
   MH->change_sizes( dir, room, size );
   sizes[ dir ][ room ] = size;
} /* change_sizes() */
#endif

/**
 * This method deletes a room from the specified directory.
 * @param dir the directory to delete the room from
 * @param room the room to delete
 */
void del( string dir, string room ) {
   MH->del( dir, room );
   update_cache( dir, 1 );
} /* del() */

#if !efun_defined(db_exec)
/**
 * This method returns the cluster number for the specified room.
 * @param room the room to find the cluster for
 * @return the cluster number for the room
 * @see set_cluster()
 */
int query_cluster( string room ) {
  string directory = implode( explode( room, "/" )[ 0..<2 ], "/" );
  string troom = explode( room, "/" )[ <1 ];

  if ( troom[ <2.. ] == ".c" ) {
    troom = troom[ 0..<3];
  }
  if( !clusters[ directory ] ) {
    update_cache( directory, 1 );
  }
  if( !clusters[ directory ] ) {
    clusters[ directory ] = ([]);
  }
  return query_clusters( directory )[ troom ];
} /* query_cluser() */

/**
 * This method sets the cluster number for the specified room.
 * @param room the room to set the cluster number for
 * @param cluster the new cluster number
 * @see query_cluster()
 */
void set_cluster( string room, int cluster ) {
  string directory = implode( explode( room, "/" )[ 0..<2 ], "/" );
  string troom = explode( room, "/" )[ <1 ];

  if ( troom[ <2.. ] == ".c" ) {
    troom = troom[ 0..<3];
  }
  change_clusters( directory, troom, cluster);
} /* set_cluster() */
#endif

/**
 * This method returns the destination directory array for the specified
 * room.  This is equivilant to the method of the same name on /std/room.c
 * Returns an array of ({ direction, destination, ... })
 * @see /std/room->query_dest_dir()
 * @return an array of direction, destination pairs
 * @param room the room to return the destination direction array for
 * @see query_destination()
 */
string *query_dest_dir( string room ) {
#if !efun_defined(db_exec)
  string directory, troom;
#else
  mixed rows;
  string *ret;
  int i = 0;
#endif

  stats["dest_dir"]++;
  
  if(!room || room == "/" || room == "" || strsrch(room, "/") == -1)
    return ({ });

#if !efun_defined(db_exec)
  directory = implode( explode( room, "/" )[ 0..<2 ], "/" );
  troom = explode( room, "/" )[ <1 ];

  if ( troom[ <2.. ] == ".c" ) {
    troom = troom[ 0..<3];
  }
   
  if( !query_map( directory )[ troom ] ) {
    check_map2( room );
  }
  return query_map( directory )[ troom ];
#else
  
  if ( room[ <2.. ] == ".c" ) {
    room = room[ 0..<3];
  }

  if(loop == time())
    return ({});

  loop = time();
  
  rows = db_exec(db, "select exit, dest from roomexit where id = '%s'", db_escape(room));
  if(stringp(rows)||!rows){
    forced_rooms[ room ] = 1;
    check_map2( room );
    rows = db_exec(db, "select exit, dest from roomexit where id = '%s'", db_escape(room));
    if(stringp(rows)){
      loop = 0;
      //      tell_creator("wodan", rows);
      return ({ });
    }
  }

  ret = allocate(rows * 2);

  for(i=0; i<rows; i++){
    string *row;
    row = db_fetch(db, i + 1);
    ret[i*2] = row[0];
    ret[i*2+1] = row[1];
  }
  loop = 0;
  return ret;
#endif
} /* query_dest_dir() */

/**
 * @ignore yes
 * I sincerely hope this is just a debugging function...
 * Nope, Wodan's lazy, O.
 * May also be used to return only route related stuff later on, W.
 */
string *qdd( string room ) {
   return query_dest_dir( room );
} /* qdd() */

/**
 * This method returns the destination associated with the exit in the
 * room. 
 * @param exit the exit in the room to check
 * @param room the room in which to check for the exit
 * @return the destination for the exit
 * @see query_dest_dir()
 */
string query_destination( string exit, string room ) {
   int i;
   string *dest_dir;

   stats["destination"]++;
   
   if( !room || room == "") {
      room = file_name( environment( previous_object() ) );
      if( !room ) return "/room/void";
   }
   dest_dir = query_dest_dir( room );
   i = member_array( exit, dest_dir );
   if( i < 0 ) return "/room/void";
   return dest_dir[ i + 1 ];
} /* query_destination() */

/**
 * @ignore yes
 * I sincerely hope this is just a debugging function...
 * Nope, Wodan's lazy, O.
 */
string qdes( string exit, string room ) {
   return query_destination( exit, room );
} /* qdes() */

/**
 * @ignore yes
 */
string *qdir( string room ) {
   int i;
   string *qddir, *dir=({});

   stats["qdir"]++;
   
   if( !room || room == "") {
      room = file_name( environment( previous_object() ) );
      if( !room ) return ({ "/room/void" });
   }
   qddir = query_dest_dir( room );
   for( i = sizeof( qddir ) - 2;i > -1;i -= 2)
     dir += ({ qddir[ i ]} );
   return dir;
} /* qdir() */

/**
 * This method returns the current cache stores in the map handler.
 * @return the list of directories currently loaded
 * @see update_cache()
 * @see clear_cache()
 */
string *query_cache() { return cache; }

/**
 * This method returns the current quere stores in the map handler.  The
 * queue is a list of rooms waiting to be processed into the map
 * handler.
 * @return the current queue
 */
string *query_queue() { return queue; }

/**
 * This method sets the stopped attribute of the map handler.
 * If the stopped attribute is non-zero then the map handler will 
 * stop processing the currently queued rooms.
 * @param s the new value of the stopped flag
 */
void set_stopped( int s ) { stopped = s; }

/**
 * This method compares too arrays to see if they are the same.
 * @return 1 if they are not the same, 0 if they are
 * @param ar1 the first array to compare
 * @param ar2 the second array to compare
 */
int compare_arrays( mixed *ar1, mixed *ar2 ) {
   int i;
   if ( !ar1 && !ar2 ) return 0;
   if ( sizeof( ar1 ) != sizeof( ar2 ) ) return 1;
   i = sizeof( ar1 );
   while ( i-- ) {
      if ( ar1[ i ] != ar2[ i ] ) {
         return 1;
      }
   }
   return 0;
} /* compare_arrays() */

/**
 * This method will queue the room without doing any tests.
 * This should only be used by people who know what they are doing
 * as it bypasses several checks.
 * @param room the room to queue
 * @param force if it is forced to queue
 * @param reason the reason it was queued
 */
varargs void queue_room( string room, int force, string reason ) {
   queue -= ({ room });
   queue += ({ room });
   forced_rooms[ room ] = force;
#ifdef LOGTO
   if ( !reason ) reason = "";
   LOG( sprintf( "%%^RED%%^Queueing %s(%i) %s.%%^RESET%%^\n",
                room, sizeof( queue ), reason ) );
#else 
   reason = reason; //the unused warning is hard to stop otherwise
#endif
} /* queue_room() */

/**
 * This method will decide if room should be checked, using the checks that
 * can be done without loading the room, queue the check of this room.
 * The callout is to alleviate a problem of too deep recursion errors
 * eg. when the room to be checked it loaded because of a command like drag
 * This functions should NOT be private, since it's the fundamental interface
 * toorooms.
 * @param room the room to check
 * @see queue_room()
 */
void do_room( string room ) {
   call_out( (: do_room1 :), 1, room );
} /* do_room() */

private void do_room1( string room ) {
   mixed tmp;
   int changetime;
   string directory = implode( explode( room, "/" )[ 0 .. <2 ], "/" );
   string troom = explode( room, "/" )[ <1 ];

   if ( troom[ <2.. ] == ".c" ) /* ensure sanity if the destination 
                                 * has .c on the end */
      troom = troom[ 0 .. <3 ];
   if ( directory[ 0 ] == 'w' ) {
      LOG( sprintf( "%%^BLUE%%^Skipping %s,%%^RESET%%^ in /w/.\n", room ) );
      return; /* ignore rooms in /w/ */
   }
   if ( directory[ 0 .. 2 ] == "std" ) {
      LOG( sprintf( "%%^BLUE%%^Skipping %s,%%^RESET%%^ in /std/.\n", room ) );
      return; /* ignore rooms in /std/ */
   }
   /* does it exist? */
   tmp = stat( room +".c" );
   if( !pointerp( tmp ) || sizeof( tmp ) < 2 ) {
      tmp = stat( room );
      if( !pointerp( tmp ) || sizeof( tmp ) < 2 )
         return;
   }
   tmp = find_object( room );
   if ( tmp ) { /* if the room is loaded and has coordinates
                 * and they aren't saved, do a calc
                 */
      if( tmp->query_property( "no map" ) ) {
         LOG( sprintf( "%%^BLUE%%^Skipping %s%%^RESET%%^, it asked me to.\n",
                      tmp->a_short() ) );
         return;
      }
#ifdef COORDS
      tmp->calc_co_ord();
      if ( sizeof( tmp->query_co_ord() ) >
          sizeof( query_co_ords( directory )[ troom ] ) ) {
         queue_room( room, 1, "new co_ordinates");
         return;
      }
#endif
   }
   /* Is it newer? */
   tmp = stat( room +".c" );
   if ( query_changetimes( directory )[ troom ] == 
       ( changetime = tmp[ TIME ] ) ) {
      return;
   }
   queue -= ({ room });
   queue += ({ room });
   LOG( sprintf( "%%^RED%%^Queueing %s(%i).%%^RESET%%^\n",
                room, sizeof( queue ) ) );
} /* do_room1() */

/**
 * This method attempts to remove the next room to be checked off the
 * queue.
 */
private void check_next() {
   string room;

   if ( sizeof( queue ) && !stopped ) {
      //if ( find_call_out( check_next_call_out ) == -1 ) {
        check_next_call_out = call_out( (: check_next :), SKEWTIME );
      //}
      room = queue[ 0 ];
      queue -= ({ room });
      check_map2( room );
   } else {
      check_next_call_out = call_out( (: check_next :), 60 );
   }
} /* check_next() */

private void check_short( object room_obj, string room_short, string room ) {
   string tmp_short, bad_short;
   
   if(!room_short)
     return;
   tmp_short = lower_case(room_short);
   bad_short = 0;
   if ( tmp_short[ 0 .. 4 ] == "an a " ||
       tmp_short[ 0 .. 5 ] == "an an " ||
       tmp_short[ 0 .. 5 ] == "the the " ||
       tmp_short[ 0 .. 5 ] == "a the " ) {
      bad_short = "strange or missing determinate";
   } else {
      if(!sizeof(tmp_short))
         bad_short = "no short";
      else if ( tmp_short[ <1 ] == '.' ) {
         bad_short = "period in short";
      } else {
         if ( !(tmp_short = (string)room_obj->query_property( "determinate" ) ) ) {
            tmp_short = (string)room_obj->query_short();
            if ( tmp_short )
            if ( tmp_short[ 0 .. 0 ] != lower_case( tmp_short[ 0 .. 0 ] ) )
               bad_short = "suspicious capitalisation";
         } else {
            if ( tmp_short != "" ) {
               if ( tmp_short[ <1 ] != ' ' ) {
                  bad_short = "missing space in determinate";
               } else {
                  if ( tmp_short[ 0 .. 0 ] != lower_case( tmp_short[ 0 .. 0 ] ) ) {
                     bad_short = "suspicious capitalisation in determinate";
                  }
               }
            }
         }
      }
   }
   if ( bad_short ) {
      log_file( "STRANGE_SHORT","%s, %s (%s)\n",
               room_short, bad_short, room );
      LOG( sprintf( "%%^RED%%^%s.%%^RESET%%^\n", bad_short ) );
   }
} /* check_short() */

void check_map( string room ) {
   do_room( room );
} /* check_map() */

/**
 * This checks to make sure all the bits of the map are correct still.
 * I think...
 */
private void check_map2( string room ) {
   mixed tmp;
   int i, changetime, do_update;
   string *dest_dir, *tmpdest_dir, room_short, *movezones;
#ifdef COORDS
   int *coord;
   mixed size;
#endif
   object room_obj;
   string directory = implode( explode( room, "/" )[ 0..<2 ], "/" );
   string troom = explode( room, "/" )[ <1 ];

   if ( troom[ <2.. ] == ".c" ) {
     troom = troom[ 0..<3];
   }

   if ( directory[ 0 ] == 'w' ) {
      LOG( sprintf( "%%^BLUE%%^Skipping %s,%%^RESET%%^ in /w/.\n", room ) );
      return; /* ignore rooms in /w/ */
   }
   if ( directory[ 0 .. 2 ] == "std" ) {
      LOG( sprintf( "%%^BLUE%%^Skipping %s,%%^RESET%%^ in /std/.\n", room ) );
      return; /* ignore rooms in /std/ */
   }
   do_update = forced_rooms[ room ];

   tmp = stat( room +".c" );
   if( !pointerp( tmp ) || sizeof( tmp ) < 2 )
      return;
#ifdef COORDS
   /* check for changed coordinates for loaded rooms
    * supercede check for old file
    */
   if ( room_obj = find_object( room ) ) {
      room_obj->calc_co_ord();
      if ( ( sizeof( room_obj->query_co_ord() ) >
            sizeof( query_co_ords( directory )[ troom ] ) ) ||
          compare_arrays( room_obj->query_co_ord(),
                         query_co_ords( directory )[ troom ] ) ) {
         do_update = 1;
      }
   }
#endif
   if ( !do_update &&
       ( query_changetimes( directory )[ troom ] == 
        ( changetime = tmp[ TIME ] ) ) ) {
      return;
   }
   if ( !find_object( room ) ) /* no need to reload if it's loaded already */
      catch( room->force_load() );
   room_obj = find_object( room );

   /* remove rooms that may have been put in the queue more than once
    * done here as the force_load may have put the room here
    */
   queue -= ({ room });
   map_delete( forced_rooms, room );
      
   update_cache( directory, 0 );
   if( !room_obj ) {
      /* cloned rooms don't have their own file, 
       * so this gets those out as well 
       */
      if( shorts[ directory ][ troom ] ) {
         dest_dir = query_dest_dir(room);
         for(i = 1; i < sizeof( dest_dir ); i += 2 )
            check_map( dest_dir[ i ] );
#if !efun_defined(db_exec)
         map_delete( map[ directory ], troom );
#endif
         map_delete( shorts[ directory ], troom );
         map_delete( movezoness[ directory ], troom );
         map_delete( changetimes[ directory ], troom );
#ifdef COORDS
         map_delete( coords[ directory ], troom );
         map_delete( sizes[ directory ], troom );
#endif
         del( directory, room );
         LOG( sprintf( "%%^RED%%^Removing %s,%%^RESET%%^.\n", room ) );
      }
      return;
   }
   if ( room_obj->query_property( "no map" ) ) {
      LOG( sprintf( "%%^BLUE%%^Skipping %s,%%^RESET%%^ it asked me to.\n", 
                   room ) );
      return;
   }
   room_short = (string)"/global/events"->convert_message(
         (string)room_obj->a_short() );
   if ( shorts[ directory ][ troom ] != room_short ) 
      do_update = 1;
   LOG( sprintf( "%%^YELLOW%%^Updating %s%%^RESET%%^. (%s)\n", 
                room_short, troom ) );
#ifdef LOG_SHORTS
   check_short( room_obj, room_short, room );
#endif
   movezones = room_obj->query_zones();
   if ( !pointerp( movezones ) ) movezones = ({ });
   if ( movezoness[ directory ][ troom ] != movezones )
      do_update = 1;
#ifdef COORDS
   room_obj->calc_co_ord();
   coord = room_obj->query_co_ord();
   if ( !coord ) room_obj->calc_co_ord();
   coord = room_obj->query_co_ord();
   if ( !coords[ directory ] ) coords[ directory ] = ([ ]);
   if ( compare_arrays( coords[ directory ][ troom ], coord ) )
      do_update = 1;
   
   size = room_obj->query_room_size_array();
   if ( !sizes[ directory ] ) sizes[ directory ] = ([ ]);
   if ( sizes[ directory ][ troom ] != size )
      do_update = 1;
#endif
   
   if ( changetimes[ directory ][ troom ] != changetime )
      do_update = 1;
   
   if ( do_update ) {
      change_changetimes( directory, troom, changetime );
      change_movezones( directory, troom, movezones );
      change_shorts( directory, troom, room_short );
#ifdef COORDS
      /* only change coordinates if it actually has a new set */
      if ( sizeof( coord ) == 3 )
         change_co_ords( directory, troom, coord );
      change_sizes( directory, troom, size );
#endif
      update_cache( directory, 1 );
   }

   dest_dir = room_obj->query_dest_dir();
   if( !dest_dir ) {
      dest_dir = ({ });
   } else {
      string exit;
      if( room_obj->query_blockage() ) {
        exit = room_obj->query_direction();
        if( !exit ) // there should be a better way to do this
          for( i = 1; i < sizeof( dest_dir ); i += 2 ) 
            if( dest_dir[ i ]->query_blockage() ) {
              exit = dest_dir[ i - 1 ];
              break;
            }
      }
      if(!exit)
         exit = "";
      /* remove exits to cloned destinations ,roadblocks, 
         enter something, /w, /std and /room stuff */
      tmpdest_dir = ({ });
      for ( i = 1; i < sizeof( dest_dir ); i += 2 ) {
         mixed tmp2;
         catch(load_object(dest_dir[i]));
         if ( objectp( find_object( dest_dir[ i ] ) ) &&
                          !clonep( find_object( dest_dir[ i ] ) ) && 
              exit != dest_dir[i - 1] && 
              dest_dir[i - 1][0..5] != "enter " &&
              dest_dir[i][1] != 'w' &&
              dest_dir[i][1..3] != "std" &&
              dest_dir[i][1..4] != "room" &&
                     (catch(tmp2 = dest_dir[i]->query_property( "no map" )), !tmp2)) {
            tmpdest_dir += ({ dest_dir[ i - 1 ], dest_dir[ i ] });
         }
      }
      dest_dir = tmpdest_dir;
   }
   if ( compare_arrays( query_dest_dir(room), dest_dir ) ) {
#if !efun_defined(db_exec)
      map[ directory ][ troom ] = dest_dir;
#else
      db_exec(db, "delete from roomexit where id = '%s'", db_escape(room));
      for(i=0; i<sizeof(dest_dir)/2; i++){
        db_exec(db, "insert into roomexit values ('%s', '%s', '%s')",
                db_escape(room), db_escape(dest_dir[i*2]),
                db_escape(dest_dir[i*2+1]));
      }
#endif
      for( i = 1; i < sizeof( dest_dir );i += 2 ) {
         if ( dest_dir[ i ][ <2.. ] == ".c" ) {
#ifdef LOG_EXITS
            log_file("BAD_EXIT","from %s, %s to %s\n",
                     directory +"/"+ troom, dest_dir[ i-1 ], dest_dir[ i ] );            
#endif   
            dest_dir[ i ] = dest_dir[ i ][ 0..<3 ];
         }
      }
#if !efun_defined(db_exec)
      change_map( directory, troom, dest_dir );
#endif
#ifdef PARANOID
      update_cache( directory, 1 );
#endif
      for( i = 1; i < sizeof( dest_dir ); i += 2 ) {
         do_room( dest_dir[ i ] );
      }
#ifdef PARANOID
      return;
#endif
   }
#ifdef PARANOID
   update_cache( directory, 1 );
#endif
} /* check_map2() */

/**
 * This method returns the short description of the room.  This will return
 * the short description of named cloned objects as well as attempting to
 * force the room to load if it is not found in the internal
 * cache.
 * @param room the room to return the short description of
 */
string query_short( string room ) {
   string directory = implode( explode( room, "/" )[ 0..<2 ], "/" );
   string troom = explode( room, "/" )[ <1 ];

   if ( troom[ <2.. ] == ".c" ) {
     troom = troom[ 0..<3];
   }

   stats["short"]++;
   
   if ( strsrch( room, "#" ) != -1 ) {
      if ( find_object( room ) ) {
         return (string)"/global/events"->convert_message(
                     (string)room->a_short() );
      } else {
         return "The map_handler was called on a non-existent clone";
      }
   }
   if ( !shorts[ directory ] ) {
      update_cache( directory, 1 );
   }
   if ( !shorts[ directory ] ) {
      shorts[ directory ] = ([ ]);
   }
   if ( shorts[ directory ][ troom ] ) {
     return shorts[ directory ][ troom ];
   }
   if ( !catch( load_object(room) ) ) {
     return (string)"/global/events"->convert_message(
                            (string)room->a_short() );
   }
   return "Oops!";
} /* query_short() */

/**
 * This method returns the short description of the room only from
 * within the map handlers files.  This will not cause the room
 * to load and will not work on cloned file names.
 * @param room the room to return the short description of
 * @see query_short()
 */
string static_query_short( string room ) {
   string directory, troom;

   if(!stringp(room))
     return "";
   
   directory = implode( explode( room, "/" )[ 0..<2 ], "/" );
   troom = explode( room, "/" )[ <1 ];

   if ( troom[ <2.. ] == ".c" ) {
     troom = troom[ 0..<3];
   }

   stats["static short"]++;
   
   if ( !shorts[ directory ] ) {
      update_cache( directory, 1 );
   }
   if ( !shorts[ directory ] ) {
      shorts[ directory ] = ([ ]);
   }
   if ( shorts[ directory ][ troom ] ) {
     return shorts[ directory ][ troom ];
   }
   return 0;
} /* static_query_short() */

/**
 * This method returns the move zones for the specified room.  It will
 * load the room if it is not available in the map handlers cache.
 * @param room the room to get the zones for
 * @return the array of move zones for the room
 * @see query_short()
 */
string *query_zones( string room ) {
   string directory = implode( explode( room, "/" )[ 0..<2 ], "/" );
   string troom = explode( room, "/" )[ <1 ];
   object roomob;

   if ( troom[ <2.. ] == ".c" ) {
     troom = troom[ 0..<3];
   }

   stats["zones"]++;
   
   if ( strsrch( room, "#" ) != -1 ) {
      if ( find_object( room ) ) {
         return (string *)room->query_movezones();
      } else {
         return ({ });
      }
   }
   if ( !movezoness[ directory ] ) {
      update_cache( directory, 1 );
   }
   if ( !movezoness[ directory ] ) {
      movezoness[ directory ] = ([ ]);
   }
   if ( movezoness[ directory ][ troom ] ) {
     return movezoness[ directory ][ troom ];
   }
   if ( !catch( roomob = load_object(room) ) ) {
     if(roomob)
       return roomob->query_movezones();
   }
   return ({ "Oops!" });
} /* query_zones() */

#ifdef COORDS
/**
 * This method sets the coordinates for the specified room.
 * @param room the room to set the coordinates for
 * @param coord the coordinates to set the room to
 * @see query_co_ord()
 */
void set_co_ord( string room, int *coord ) {
   string directory = implode( explode( room, "/" )[ 0..<2 ], "/" );
   string troom = explode( room, "/" )[ <1 ];

   if ( troom[ <2.. ] == ".c" ) {
     troom = troom[ 0..<3];
   }
   
   if ( !coords[ directory ] ) {
      update_cache( directory, 1 );
   }
   if ( !coords[ directory ] ) {
      coords[ directory ] = ([ ]);
   }
   MH->change_co_ords( directory, troom, coord );
   coords[ directory ][ troom ] = coord;
} /* set_co_ords() */

/**
 * This method returns the coordinates for the specified room.  This will
 * cause the room to load if possible to extract the coordinates.
 * @param room the room the get the coordinates of
 * @return the coordinates of the room, 0 on failure
 */
int *query_co_ord( string room ) {
   string directory = implode( explode( room, "/" )[ 0..<2 ], "/" );
   string troom = explode( room, "/" )[ <1 ];

   if ( troom[ <2.. ] == ".c" ) {
     troom = troom[ 0..<3];
   }

   stats["co_ord"]++;
   
   LOG( sprintf( "%%^BLUE%%^query_co_ord(%s)%%^RESET%%^\n", room ) );
   if ( strsrch( room, "#" ) != -1 ) {
      if ( find_object( room ) ) {
         return room->query_co_ord();
      } else {
         return 0;
      }
   }
   if ( !coords[ directory ] ) {
      update_cache( directory, 1 );
   }
   if ( !coords[ directory ] ) {
      coords[ directory ] = ([ ]);
   }
   if ( coords[ directory ][ troom ] ) {
     return coords[ directory ][ troom ];
   }
   if ( !catch( load_object(room ) ) ) {
     return room->query_co_ord();
   }
   return 0;
} /* query_co_ord() */

/**
 * This method will return the coordinates of the room only using the
 * internal map information.
 * @param room the room to get the coordinates of
 * @return the coordinates of the room, 0 on failure
 */
int *static_query_co_ord( string room ) {
   string directory = implode( explode( room, "/" )[ 0..<2 ], "/" );
   string troom = explode( room, "/" )[ <1 ];

   if ( troom[ <2.. ] == ".c" ) {
     troom = troom[ 0..<3];
   }

   stats["static co_ord"]++;
   
   if ( strsrch( room, "#" ) != -1 ) {
      if ( find_object( room ) ) {
         return room->query_co_ord();
      } else {
         return 0;
      }
   }
   if ( !coords[ directory ] ) {
      update_cache( directory, 1 );
   }
   if ( !coords[ directory ] ) {
      coords[ directory ] = ([ ]);
   }
   if ( coords[ directory ][ troom ] ) {
     return coords[ directory ][ troom ];
   }
   return 0;
} /* static_query_co_ord() */

/**
 * This method returns the size of the room, it will attempt to load
 * the room if it is not in map handlers current rooms.
 * @param room the room to find the size of
 */
int *query_room_size( string room ) {
   string directory = implode( explode( room, "/" )[ 0..<2 ], "/" );
   string troom = explode( room, "/" )[ <1 ];

   if ( troom[ <2.. ] == ".c" ) {
     troom = troom[ 0..<3];
   }

   stats["room_size"]++;
   
   if ( strsrch( room, "#" ) != -1 ) {
      if ( find_object( room ) ) {
         return room->query_room_size_array();
      } else {
         return 0;
      }
   }
   if ( !sizes[ directory ] ) {
      update_cache( directory, 1 );
   }
   if ( !sizes[ directory ] ) {
      sizes[ directory ] = ([ ]);
   }
   if ( sizes[ directory ][ troom ] ) {
     return sizes[ directory ][ troom ];
   }
   if (!catch(room->force_load())) {
      return room->query_room_size_array();
   }
   return 0;
} /* query_room_size() */
#endif

/**
 * This method tests to see if the specified room exists and is loadable.
 * @param room the room to test for existance
 * @return 1 if it exists and 0 if it does not
 */
int test_room( string room ) {
   string directory = implode( explode( room, "/" )[ 0..<2 ], "/" );
   string troom = explode( room, "/" )[ <1 ];
   
   if ( troom[ <2.. ] == ".c" ) {
     troom = troom[ 0..<3];
   }
   
   if ( strsrch( room, "#" ) != -1 )  {
      return 1;
   }
   if ( !shorts[ directory ] ) {
      update_cache( directory, 1 );
   }
   if ( !shorts[ directory ] ) {
      shorts[ directory ] = ([ ]);
   }
   if ( shorts[ directory ][ troom ] ) {
     return 1;
   }
   if ( !catch( load_object(room) ) ) {
     return 1;
   }
   return 0;
} /* test_room() */

/**
 * This method returns true if the room is known of to the map handler.
 * @param room the room to test for existance
 * @return 1 if it exists, 0 if it does not
 */
int query_known( string room ) {
   string directory = implode( explode( room, "/" )[ 0..<2 ], "/" );
   string troom = explode( room, "/" )[ <1 ];

   if ( troom[ <2.. ] == ".c" ) {
     troom = troom[ 0..<3];
   }

   if ( !shorts[ directory ] ) {
      update_cache( directory, 1 );
   }
   if ( !shorts[ directory ] ) {
      shorts[ directory ] = ([ ]);
   }
   return !undefinedp(shorts[ directory ][troom]);
} /* query_known() */

/**
 * This method checks the save files in the directory to check to make
 * sure all the rooms still exist in the game.
 */
void check_save_files() {
   string *files, file, room, *tmp;

   files = unguarded((: get_dir, "/save/map/" :));
   files = map( files, (: replace( $1, ({ "_", "/", ".o", ""}) ) :) );
   foreach( file in files ) {
      printf( "%s\n", file );
      tmp = keys( MH->query_map( file ) );
      reset_eval_cost();
      foreach( room in tmp ) {
         if( file_size( file +"/"+ room + ".c" ) < 0 ) {
            printf( "%s no longer exists.\n", file + "/" + room );
            MH->del( file, room );
         }
      }
   }
   cache = ({ });
} /* check_save_files() */

/**
 * these two are not here because the handler can be saved, but to keep
 * the info over updates.
 * @ignore yes
 */
mapping query_dynamic_auto_load() {
   mapping tmp;

   tmp = ([ "shorts" : shorts,
            "movezoness" : movezoness,
            "changetimes" : changetimes,
#if !efun_defined(db_exec)
            "clusters" : clusters,
            "map" : map,
#endif
#ifdef COORDS
            "coords" : coords,
            "sizes" : sizes,
#endif
            "cache" : cache,
            "queue" : queue,
          ]);
   return tmp;
} /* query_dynamic_auto_load() */

/**
 * @ignore yes
 */
void init_dynamic_arg(mapping maps) {
   if (maps["shorts"])
      shorts = maps["shorts"];
   if (maps["movezoness"])
      movezoness = maps["movezoness"];
   if (maps["changetimes"])
      changetimes = maps["changetimes"];
#if !efun_defined(db_exec)
   if (maps["clusters"])
      clusters = maps["clusters"];
   if (maps["map"])
     map = maps["map"];
#endif
#ifdef COORDS
   if (maps["coords"])
      coords = maps["coords"];
   if (maps["sizes"])
      sizes = maps["sizes"];
#endif
   if (maps["cache"])
      cache = maps["cache"];
   if (maps["queue"])
      queue = maps["queue"];
} /* init_dynamic_arg() */

/** @ignore yes */
mixed *stats() {
   return ({
      ({ "queue size", sizeof( queue ) }),
      ({ "cache size", sizeof( cache ) }),
      ({ "next check", find_call_out( check_next_call_out ) }),
        }) + map(keys(stats), (:({$1, $(stats)[$1]}):));
}
// --- END [/mnt/home2/grok/lib/obj/handlers/map.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/quest_handler.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/quest_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628561   Available: 13575915
Inodes: Total: 5242880    Free: 4960134
14940 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/quest_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628561   Available: 13575915
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: quest_handler.c,v 1.9 2000/07/29 14:49:21 taffyd Exp $
 * $Log: quest_handler.c,v $
 * Revision 1.9  2000/07/29 14:49:21  taffyd
 * Actually did what I said I did in 1.7 ;)
 *
 * Revision 1.8  2000/07/29 14:40:33  taffyd
 * Changed logging so that if there is no this_player() it uses
previous_object().  So that the web interface to the quests command works.
 *
 * Revision 1.7  2000/07/29 14:34:29  presto
 *  Forcibly unlocked by taffyd
 *
 * Revision 1.6  2000/07/29 02:18:20  pinkfish
 *  Forcibly unlocked by presto
 *
 * Revision 1.5  2000/03/17 20:55:07  ceres
 * Removed references to the old team handler
 *
 * Revision 1.4  1999/09/27 21:19:29  wodan
 * fixed ancient bug in query_fame_str and removed line that did nothing.
 *
 * Revision 1.3  1999/09/27 21:13:25  terano
 * Got it working.
 *
 * Revision 1.2  1999/05/20 01:02:27  ceres
 * Added status for quests
 *
 * Revision 1.1  1998/01/06 05:03:33  ceres
 * Initial revision
 * 
*/
/**
 * This class keeps track of the current set of quests availabe in the
 * game.
 * @author Furball
 */
#include <library.h>
#include <player_handler.h>

#define QUEST_LOG "QUESTS"
#define SAVE_FILE "/save/quests"
#define BACKUP_FILE "/save/quests/quests"

inherit "/std/object";

private int *quest_level;
private int *num_times_done;
private int *quest_status;
private string *quest_name;
private string *quest_title;
private string *quest_story;
private string *last_done_by;
private nosave int total_qp;

/**
 * This method reloads the quests from the save file.
 * @see save_quests()
 */
void load_quests() { unguarded( (: restore_object, SAVE_FILE :) ); }

/**
 * This method saves the current set of quests to the save file.
 * @see load_quests()
 */
void save_quests() { unguarded( (: save_object, SAVE_FILE :) ); }

void create() {
   int i;
   ::create();
   load_quests();
   if ( !quest_name ) {
      quest_name = ({ });
   }
   if ( !quest_level ) {
      quest_level = ({ });
   }
   if ( !quest_title ) {
      quest_title = ({ });
   }
   if ( !quest_story ) {
      quest_story = ({ });
   }
   if ( !last_done_by ) {
      last_done_by = ({ });
   }
   if ( !num_times_done ) {
      num_times_done = ({ });
   }
   if ( !quest_status ) {
     if(sizeof(quest_name)) {
       quest_status = allocate(sizeof(quest_name));
       for(i=0; i<sizeof(quest_name); i++) {
         quest_status[i] = 1;
       }
     } else {
       quest_status = ({ });
     }
   }
   
   for(i = 0; i<sizeof(quest_level); i++) {
     if(quest_status[i]) {
       total_qp += quest_level[i];
     }
   }
   
} /* create() */

/**
 * This returns the current total gp for all of the current quests.
 * @return the total gp
 */
int query_total_qp() { return total_qp; }

/**
 * This method adds a new quest into the system.  You only need to call
 * this ONCE.  The name of the quest must be unique.  The story is
 * what can be seen in the players books about the player.
 * @param name the name of the quest
 * @param level the level of the quest 0-100
 * @param title the title for finishing the quest, 0 for none
 * @param story the story about the quest
 * @return 1 if successful, 0 if not
 * @see delete_quest()
 * @see query_quest_level()
 * @see query_quest_title()
 * @see query_quest_story()
 */
int add_quest( string name, int level, string title, string story ) {
   string log_name;
    
   if ( member_array( name, quest_name ) != -1 )
      return 0;
      
   quest_name += ({ name });
   quest_level += ({ level });
   quest_title += ({ title });
   quest_story += ({ story });
   last_done_by += ({ "nobody" });
   num_times_done += ({ 0 });
   quest_status += ({ 1 }); //Make it active!   
   
   if ( this_player() ) {
      log_name = this_player()->query_name();
   }
   else {
      log_name = file_name( previous_object() );
   }
   
   log_file( QUEST_LOG, log_name +
         " added: "+ name +", "+ level +", "+ title +", "+ story +"\n" );
   save_quests();
   unguarded( (: cp, SAVE_FILE +".o", BACKUP_FILE +"."+ time() :) );
   total_qp += level;
   return 1;
} /* add_quest() */

/**
 * Change the status of a quest from active to inactive
 * and vice versa.
 * @param the name of a quest.
 */
int change_quest_status(string name) {
  int temp;

  temp = member_array(name, quest_name);
  if(temp == -1) {
    return -1;
  }
  quest_status[temp] = !quest_status[temp];
  return quest_status[temp];
}

/**
 * This method returns the status of a quest.
 * @param the name of a quest
 * @return 1 for active, 0 for inactive.
 */
int query_quest_status(string name) {
  int temp;

  temp = member_array(name, quest_name);
  if(temp == -1) {
    return -1;
  }
  return quest_status[temp];
}


/**
 * This method returns the level of the quest.
 * @param name the name of the quest
 * @return the level of the quest, -1 on failure
 * @see add_quest()
 * @see set_quest_level()
 */
int query_quest_level(string name) {
  int temp;

  temp = member_array(name, quest_name);
  if(temp == -1) {
    return -1;
  }
  return quest_level[temp];
} /* query_quest_level() */

/**
 * This method sets the level of the quest.
 * @param name the name of the quest
 * @param level the level of the quest
 * @return 0 on failure, 1 on success
 * @see add_quest()
 * @see query_quest_level()
 */
int set_quest_level(string name, int level) {
   int temp;
   string log_name;

   temp = member_array(name, quest_name);
   if(temp == -1) {
      return 0;
   }
   
   if ( this_player() ) {
      log_name = this_player()->query_name();
   }
   else {
      log_name = file_name( previous_object() );
   }
   
   log_file(QUEST_LOG, "%s : level set for %s to %d\n\n",
            log_name, name, level);
   quest_level[ temp ] = level;
   save_quests();
   return 1;
} /* set_quest_level() */

/**
 * This method returns the story associated with the quest.
 * @param name of the quest
 * @return the story of the quest
 * @see add_quest()
 * @see set_quest_story()
 */
string query_quest_story(string name) {
  int temp;

  temp = member_array(name, quest_name);
  if(temp == -1) {
    return "did nothing";
  }
  return quest_story[temp];
} /* query_quest_story() */

/**
 * This method sets the story associated with the quest.
 * @param name of the quest
 * @param story the new story of the quest
 * @see add_quest()
 * @see query_quest_story()
 */
int set_quest_story(string name, string story) {
   int temp;
   string log_name;

   temp = member_array(name, quest_name);
   if(temp == -1) {
      return 0;
   }
   
   if ( this_player() ) {
      log_name = this_player()->query_name();
   }
   else {
      log_name = file_name( previous_object() );
   }
   
   log_file(QUEST_LOG, "%s : story set for %s to %s\n\n",
            log_name, name, story);
   quest_story[ temp ] = story;
   save_quests();
   return 1;
} /* set_quest_story() */

/**
 * This method returns the title associated with the quest.
 * @param name of the quest
 * @return the title of the quest
 * @see add_quest()
 * @see set_quest_title()
 */
string query_quest_title(string name) {
  int temp;

  temp = member_array(name, quest_name);
  if(temp == -1 || quest_title[temp] == "") {
    return "Unknown Quester";
  }
  return quest_title[temp];
} /* query_quest_title() */

/**
 * This method sets the title associated with the quest.
 * @param name of the quest
 * @param title the new title of the quest
 * @see add_quest()
 * @see query_quest_title()
 */
int set_quest_title(string name, string title) {
   int temp;
   string log_name;

   temp = member_array(name, quest_name);
   if(temp == -1) {
      return 0;
   }
   
   if ( this_player() ) {
      log_name = this_player()->query_name();
   }
   else {
      log_name = file_name( previous_object() );
   }
   
   log_file(QUEST_LOG, "%s : title set for %s to %s\n\n",
            log_name, name, title);
   quest_title[ temp ] = title;
   save_quests();
   return 1;
} /* set_quest_title() */

/**
 * This method returns the number of times the quest has been
 * completed.
 * @param name thre name of the quest
 * @return the number of times completed
 * @see quest_completed()
 * @see add_quest()
 * @see query_quest_done()
 */
int query_quest_times( string name ) {
   int i;

   i = member_array( name, quest_name );
   if ( i == -1 )
      return -1;
   return num_times_done[ i ];
} /* query_quest_times() */

/**
 * This method returns the name of the last person to complete the
 * quest.
 * @param name thre name of the quest
 * @return the last person to complete the quest
 * @see quest_completed()
 * @see add_quest()
 * @see query_quest_times()
 */
mixed query_quest_done( string name ) {
   int i; 

   i = member_array( name, quest_name );
   if ( i == -1 )
      return -1;
   return last_done_by[ i ];
} /* query_quest_done() */

/**
 * This method removes the given quest from the system.
 * @see name the name of the quest to remove
 * @return 0 on failure, 1 on success
 * @see add_quest()
 */
int delete_quest(string name) {
   int temp;
   string log_name;
   
   if ( this_player() ) {
      log_name = this_player()->query_name();
   }
   else {
      log_name = file_name( previous_object() );
   }
   
   log_file(QUEST_LOG, log_name + " removed : " +
            name + "\n\n");
   temp = member_array(name, quest_name);
   if(temp == -1) {
      return 0;
   }
   total_qp -= quest_level[temp];
   quest_name = delete(quest_name, temp, 1);
   quest_level = delete(quest_level, temp, 1);
   quest_title = delete(quest_title, temp, 1);
   quest_story = delete(quest_story, temp, 1);
   last_done_by = delete( last_done_by, temp, 1 );
   num_times_done = delete( num_times_done, temp, 1 );
   save_quests();
   return 1;
} /* delete_quest() */

/**
 * This method returns the names of all the quests.
 * @return the names of all the quests
 * @see add_quest()
 * @see delete_quest()
 */
string *query_quest_names() {
  return quest_name + ({ });
} /* query_quest_names() */

/**
 * This method returns the levels of all the quests.
 * @return the levels of all the quests
 * @see add_quest()
 * @see delete_quest()
 */
int *query_quest_levels() {
  return quest_level + ({ });
} /* query_quest_levels() */

/**
 * This method returns the titles of all the quests.
 * @return the titles of all the quests
 * @see add_quest()
 * @see delete_quest()
 */
string *query_quest_titles() {
  return quest_title + ({ });
} /* query_quest_titles() */

/**
 * This method returns the stories of all the quests.
 * @return the stories of all the quests
 * @see add_quest()
 * @see delete_quest()
 */
string *query_quest_stories() {
  return quest_story + ({ });
} /* query_quest_stories() */

/**
 * This method should be called in the code when a quest is complete.
 * @param name name of the player
 * @param quest the quest completed
 * @param prev_ob the object which completed the quest
 * @see add_quest()
 * @see delete_quest()
 */
void quest_completed( string name, string quest, object prev_ob ) {
   int i;
   string word;

   log_file( QUEST_LOG, ctime( time() ) +" "+ name +" completed "+
         quest +"\n" );
   user_event( "inform", name +" completes "+ quest, "quest" );
   if ( file_name( previous_object() ) != LIBRARY ) {
      prev_ob = previous_object();
   }
   word = (string)prev_ob->query_name();
   if ( !word ) {
      word = file_name( prev_ob );
   } else {
      word += " ("+ file_name( prev_ob ) +")";
   }
   log_file( QUEST_LOG, "given by "+ word +"\n" );
   i = member_array( quest, quest_name );
   if ( i == -1 ) {
      log_file( QUEST_LOG, "non existent quest\n" );
      return;
   }
   last_done_by[ i ] = name;
   num_times_done[ i ]++;
   save_quests();
} /* query_completed() */

/* Fame functions - for use in halls of fame / libraries etc. */
/* Piecemaker 25/3/93                                         */

/**
 * This method returns the fame of the player.
 * Gets the fame percentage of the player. Quest points / total quest points
 * @param name the name of the player
 * @return the fame as a percentage (0-100)
 * @see query_player_story()
 * @see query_fame_string()
 * @see query_total_qp()
 */
int query_player_fame(string name){
   int playerqp, rank;

   /* do checking on the names */
   if (!name){
      return 0;
   }
   /* expand the nicknames if there are any */
   if (this_player()){
      name = (string)this_player()->expand_nickname(name);
   }
   /* are they a valid player ? */
   if (!PLAYER_HANDLER->test_user(name)){ 
      return 0;
   }   

   /* do the calculations */
   playerqp = (int)LIBRARY->query_quest_points(name);

   rank = ( playerqp * 125 ) / query_total_qp();
   return rank;
} /* query_player_fame() */

/**
 * This method returns a string associated with the fame level of the
 * player.
 * @param name the name of the player
 * @return the fame string
 * @see query_player_fame()
 * @see query_player_story()
 */
string query_fame_str( string name ) {
   switch ( query_player_fame( name ) ) {
      case 0 .. 4 :
         return "completely unknown";
      case 5 .. 14 :
         return "unknown";
      case 15 .. 24 :
         return "unknown";
      case 25 .. 34 :
         return "moderately well known";
      case 35 .. 44 :
         return "well known";
      case 45 .. 54 :
         return "very well known";
      case 55 .. 64 :
         return "known throughout the region";
      case 65 .. 74 :
         return "famous";
      case 75 .. 84 :
         return "renowned";
      case 85 .. 94 :
         return "Disc renowned";
      default :
         return "so renowned that no introduction is needed";
   }
} /* query_fame_str() */

/**
 * This method lists the stories for the quests the player has done.
 * @param name the name of the player
 * @return the story of the player
 * @see query_fame_string()
 * @see query_player_fame()
 */
string *query_player_story(string name){
   string *quests; 
   string *story;
   int i;

   story = ({ });
   /* do checking on the names */
   if (!name){
      return ({ });
   }
   /* expand the nicknames if there are any */
   if (this_player()){
      name = (string)this_player()->expand_nickname(name);
   }
   /* are they a valid player ? */
   if (!PLAYER_HANDLER->test_user(name)){ 
      return 0;
   }   

   /* right, we checked everything now. Lets do some real work. */
   quests = query_quest_names();
   if (sizeof(quests) == 1){
      story = ({"Is an under achiever."});
   }
   else{  
      for(i=0;i<sizeof(quests);i++){
         if (LIBRARY->query_quest_done(name, quests[i])){
            story = ({ query_quest_story( quests[ i ] ) }) + story;
         }
      }
   }
   return story;
} /* query_player_story() */

/**
 * This method prints out a lot of quest stats. For debugging purpsoes
 * only.
 */
void print_some_stats()  {
   int i;

   for (i = 0; i < sizeof(quest_name); i++)
      printf("%s: %6d, %3d\n", quest_name[i], num_times_done[i], quest_level[i]);
} /* print_some_stats() */
// --- END [/mnt/home2/grok/lib/obj/handlers/quest_handler.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/mailer.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/mailer.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628557   Available: 13575911
Inodes: Total: 5242880    Free: 4960134
42735 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/mailer.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628557   Available: 13575911
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Id: mailer.c,v 1.27 2003/03/19 20:44:14 ceres Exp taffyd $
 */

/**
 * The mailer handler object.  This is used to send mail and do oyther
 * stuff related to mail.
 *  The new mailer object ! *shiver*
 *  Thanks to Wodan and Pinkfish for ideas and help.
 *  By Turrican@Discworld, May 1995.
 * @author Turrican
 * @started May 1995
 *
 * @change 1-10-96, Turrican
 *  Changed the way Ccs and including yourself get done
 * @change 17-09-97, Olorin
 *  Swapped 'r' and 'R' to make don't sent to CC's the default use
 */

#include <mime.h>
#include <mail.h>
#include <localtime.h>
#include <player_handler.h>

#define FOLDER_H "/obj/handlers/folder_handler.c"
#define MAIL_PATH "/save/mail/"
#define COLS (int)owner->query_cols()
#define ROWS (int)owner->query_rows()
#undef CONVERTER

nosave class mail_header *folder;
nosave int *deleted, *newish, no_menu, last_read, full_header;
nosave string current, to, subject, cc, mailrc;
nosave mixed *do_this_last;
nosave object owner;
nosave string *ignore = ({
  "email-version",
  "x-lines",
  "expires",
  "transport-options",
  "x-mailer",
  "errors-to",
  "lines",
  "priority",
  "newsgroups",
  "default-options",
  "auto-forward-count",
  "ua-message-id",
  "approved",
  "followup-to",
  "message-version",
  "message-id",
  "message-service",
  "message-type",
  "sender",
  "end-of-header",
  "content-type",
  "path",
  "report-version",
  "submitted-by",
  "message-protocol",
  "posting-number",
  "x-postmark",
  "apparently-to",
  "organization",
  "posted-date",
  "return-receipt-to",
  "keywords",
  "x-sun-charset",
  "summary",
  "in-reply-to",
  "reply-to",
  "distribution",
  "sent-by",
  "company",
  "references",
  "mts-message-id",
  "x-sequence",
  "via",
  "content-charset",
  "status",
  "confirmed-by",
  "ua-content-id",
  "content-length",
  "mime-version",
  "auto-forwarded-from",
  "content-transfer-encoding",
  "received",
  "end-of-protocol",
  "x-uidl",
  "precedence",
  "return-path"
});
string *folder_names;

/* PROTOTYPES */

varargs protected void rm_message(string input);
protected void unrm_message(string input);
private void print_message(int number);
varargs private void reply_message(int input, int flag);
private void save_me();
private int load_me();
void dest_me();
private void read_messages(string fname);
protected void read_loop(string input);
private void prompt();
protected void change_folder(string input);
varargs private void delete_it(string bonk, int last, string newish_folder);
varargs protected void move_message(string input, int flag);
private void save_message(string input);
protected void get_recipient(string input);
varargs protected void get_subject(string input, int number, int flag);
varargs protected void main_menu(string fname, int flag, int *range);
protected void forward_message(string input);
void finish_write_message(string input);
string format_date(int x);
private int *expand_range(string str);
private int valid_name(string str);
void read_mail(string str, string sub);
private void forward_email(int number);
private void write_message();
private void check_external_mail();

/* BEGIN */

private void create() {
    mapping aliases;

    seteuid("Mailer");
    no_menu = full_header = 0;
    last_read = -1;
    newish = ({ });
    folder = ({ });
    folder_names = ({ "inbox" });
    deleted = ({ });
    current = "";
    if (clonep()) {
        owner = this_player();
        if (owner) {
            aliases = owner->query_aliases();
            if (aliases) {
                mailrc = aliases[".mailrc"];
            }
        }
    } else {
        check_external_mail();
    }
} /* create() */

#define HEADER_NAME 1
#define HEADER_VAL  2

private string folder_filename(string name) {
    return MAIL_PATH+name[0..0] + "/"  + name;
}

private string strip_header(string message) {
    mixed *ra;
    int i;
    string header;

    if ((i = strsrch(message, "\n\n")) == -1) {
        return message;
    }
    header = message[0..i];
    message = message[i+1..];
    ra = reg_assoc(header,
      ({ "^[!-9;-~]+:", "((\n?[ \t])+[^\n]*(\n|$))+" }),
      ({ HEADER_NAME, HEADER_VAL }));
    for (i = 1; i + 2 < sizeof(ra[0]); i += 2) {
        if (ra[1][i] == HEADER_NAME && ra[1][i+2] == HEADER_VAL) {
            if (member_array(replace_string(lower_case(ra[0][i]), ":", ""),
                ignore) != -1) {
                ra[0][i] = ra[0][i+2] = "";
            }
        }
    }
    return implode(ra[0], "") + message;
}

private void check_external_mail() {
    string *dir, fname, mess, t, ccs;
    class mail_message msg = new(class mail_message);
    class mime_header hdr;

    dir = unguarded((: get_dir, EXTERNAL_MAIL_PATH :));
    if (!dir) {
        call_out((: check_external_mail :), 60);
        return;
    }
    foreach (fname in dir) {
        mess = unguarded((: read_file, EXTERNAL_MAIL_PATH + fname :));
        mess = replace(mess, ({ "\r\n", "\n", "\t", "        " }));
        hdr = MIME->parse_headers(mess);
        if (!hdr) {
            unguarded((: rm, EXTERNAL_MAIL_PATH + fname :));
            continue;
        }
        msg->from = hdr->header_m["from"];
        msg->subject = hdr->header_m["subject"];
        t = hdr->header_m["to"];
        if (!t) {
            continue;
        }
        msg->to = explode(t, ",");
        ccs = hdr->header_m["cc"];
        if (!ccs) {
            ccs = "";
        }
        msg->cc = explode(ccs, ",");
        msg->body = mess;
        FOLDER_H->add_it(msg, 1);
        unguarded((: rm, EXTERNAL_MAIL_PATH + fname :));
    }
    call_out((: check_external_mail :), 60);
} /* check_external_mail() */

/**
 * This method sets the call back fuinction to use when
 * the mailer has finished. ({ ob, func })
 * @param bing the call back function
 */
void set_do_this_last(mixed *bing) { do_this_last = bing; }
/**
 * This method returns the call back fuinction to use when
 * the mailer has finished. ({ ob, func })
 * @return the call back function
 */
mixed *query_do_this_last() { return do_this_last; }

/* For backwards compatibility. */
/**
 * This method allows a message to be mailed.  It checks the previous
 * object to make sure it is one of the allowed set to
 * do mailing.
 * @param t who it is to
 * @param from who it is from
 * @param sub the subject of the message
 * @param ccs the carbon copy recipients
 * @param body the body of the message
 * @param only_to only mail to the to address
 * @param flag prevent this_player() from getting the messages if flag != 0
 * @example
 * MAIL_HANDLER->do_mail_message("pinkfish", "gumboot, killer tomato":,
 *                               "About the tomatoes", "",
 *                   "The grass ius greener yesterday,.\nYours\nGumboot.");
 */
varargs int do_mail_message(string t, string from, string sub, string ccs,
  string body, int, string only_to, int flag) {
    string *cc_e, *goto;
    class mail_message msg;

    if(file_name(previous_object())[0..12] != "/secure/login" &&
       file_name(previous_object())[0..13] != "/secure/nlogin" &&
       file_name(previous_object())[0..13] != "/obj/handlers/" &&
       file_name(previous_object())[0..4] != "/www/" &&
       file_name(previous_object())[0..11] != "/net/daemon/" &&
       file_name(previous_object())[0..11] != "/global/lord" &&
       file_name(previous_object())[0..14] != "/global/creator" &&
       file_name(previous_object())[0..18] != "/global/auto_mailer" &&
       file_name(previous_object())[0..12] != "/cmds/creator" &&
       file_name(previous_object())[0..9] != "/cmds/lord" &&
       file_name(previous_object()) != "/d/am/buildings/post/parcel" &&
       file_name(previous_object()) != "/d/am/buildings/apex/admin_office" &&
       file_name(previous_object()) != "/d/am/bookkeepers/weichert_office" &&
       file_name(previous_object()) != "/d/ram/ohulan/market/post_office" &&
       file_name(previous_object()) != "/d/ram/interview" &&
       file_name(previous_object()) != "/d/forn/utils/interview" &&
       file_name(previous_object()) != "/d/am/buildings/flintwick/lawyer_office" &&
       file_name(previous_object()) != "/d/am/buildings/council/court" &&
       file_name(previous_object()) != "/d/klatch/djel/city/palace/council_court" &&
       file_name(previous_object()) != "/d/guilds/error_tracker" &&
       file_name(previous_object())[0..25] != "/d/ram/ohulan/market/post2") { 
        printf("MAILER: illegal access (%O).\n", file_name(previous_object()));
        return 0;
    }
    if ((file_name(previous_object())[0..11] == "/global/lord" ||
        file_name(previous_object())[0..14] == "/global/creator") &&
        (lower_case(from) != (string)this_player()->query_name())) {
        printf("MAILER: illegal acces.\n");
        return 0;
    }
    if (!ccs) {
        ccs = "";
    }
    cc_e = explode(ccs, ",")-({""});
    goto = explode(t, ",")-({""});
    if (only_to) {
        goto = explode(only_to, ",")-({""});
    }
    msg = new(class mail_message);
    msg->to = goto;
    msg->cc = cc_e;
    msg->body = "From " + from + " " + ctime(time()) +
    "\nDate: " + format_date(time()) +
    "\nFrom: " + from +
    "\nTo: " + t +
    "\nSubject: " + sub +
    "\n" + (sizeof(cc_e)?"Cc: "+ ccs+ "\n":"")+
    "\n" + body;
    msg->from = lower_case(from);
    msg->subject = sub;
    FOLDER_H->add_it(msg, flag);
    return 1;
} /* do_mail_message() */

/**
 * This method returns the mail information which is placed into the
 * the finger command.
 * @param pname the name of the player
 * @return the function mail string
 */
string finger_mail(string pname) {
    return FOLDER_H->finger_mail(lower_case(pname));
} /* finger_mail() */

/**
 * This method returns a string saying if the player has new mail or not.
 * This is what is used when the player first logs on.
 * @param pname the name of the player
 * @return the new mail string
 * @example
 * str = MAIL_HANDLER->new_mail(this_player()->query_name());
 */
string new_mail(string pname) {
    return FOLDER_H->check_mail(lower_case(pname));
} /* new_mail() */

/**
 * This method prints the prompt which is used in the main mail loop.
 */
private void prompt() {
    printf("\nCommand (h for main menu): ");
} /* prompt() */

/**
 * This method is the main entry point to the mailer.  It is
 * what is called to start up the system when a mailer is used.
 * @example
 * mailer = clone_object(MAIL_HANDLER);
 * mailer->read_mail();
 */
void read_mail(string str, string sub) {
    if (this_player()->query_property("guest")) {
        write("Sorry, mailer access is not allowed for guests.\n");
        if (do_this_last && objectp(do_this_last[0])) {
            call_other(do_this_last[0], do_this_last[1], do_this_last[2]);
        } else {
            dest_me();
        }
        return;
    }

    if (!load_me()) {
        if (do_this_last && objectp(do_this_last[0])) {
            call_other(do_this_last[0], do_this_last[1], do_this_last[2]);
        } else {
            dest_me();
        }
        return;
    }
    if (str) {
        no_menu = 1;
        if (!sub) {
            get_recipient(str);
        } else {
            to = str;
            get_subject(sub);
        }
        return;
    }
    MAIL_TRACK->add_mailer(this_object(), owner->query_name()); 
    main_menu("inbox");
    return;
} /* read_mail() */

/** @ignore yes */
varargs private void main_menu(string fname, int flag, int *range) {
    int i, size, offs, cols, fromcols, statcols;

    cols = COLS;
    printf("%|=*s", cols, "" + mud_name() + " mailer system version 2.0\n\n");
    if (!strlen(fname)) {
        fname = "inbox";
    }
    current = fname;
    if (!flag) {
        read_messages(current);
        last_read = -1;
        deleted = ({ });
    }
    if (!range) {
        range = ({ });
    }
    newish = ({ });
    size = sizeof(folder);
    for (i = 0; i < size; i++) {
        if (folder[i]->status == "N") {
            newish += ({ i });
        }
    }
    if (sizeof(newish) && newish[0] != 0 && last_read == -1) {
        last_read = newish[0]-1;
    }
    if (size && !sizeof(newish) && last_read == -1) {
        last_read = size-1;
    }
    printf(owner->fix_string(sprintf("%s%|=*s%s","%^CYAN%^",cols,
          "Folder "+current+" with "+
          (size?""+size:"no")+
          " message"+(size == 1?"":"s")+".\n\n",
          "%^RESET%^")));
    if (!sizeof(range)) {
        i = size - ROWS + 11;
        if (i < 0) {
            i = 0;
        }
        range = expand_range(sprintf("%d-%d", i, size));
    }
    size = sizeof(range);
    if (size) {
        offs = range[0]-1;
    } else {
        offs = 0;
    }
    statcols = cols / 3;
    fromcols = 2 * cols / 3 - 8;
    for (i = 0; i<size; i++) {
        printf(owner->
          fix_string(sprintf("%s%-6s %-*.*s %-*.*s%s\n",
              (last_read == i+offs?
                "%^REVERSE%^":""), 
              (last_read == i+offs?">":" ")+
              folder[i+offs]->status+
              " " + (i+offs+1), statcols, statcols, "From: " +
              folder[i+offs]->from, fromcols, fromcols, 
              "Subject: "+
              replace_string(terminal_colour(folder[i+offs]->subject,
                  ([ ])), "%", "%%"),
              "%^RESET%^")));
    }
    printf("%|=*s", cols, "\n  You can use any of the following commands by "
      "entering the first character;\nd)elete or u)ndelete mail,  m)ail a "
      "message,  r)eply or f)orward mail,  q)uit,\n"
      "> = move messages, c)hange folder, i)ndex of folders, ? = help\n"
      "To read next unread message, press <return>.\n");
    printf("Command: ");
    input_to("read_loop");
} /* main_menu() */

/** @ignore yes */
protected void read_loop(string input) {
    int i, num;
    string s1, s2, comm, *tmp;

    /*
     * ok this should (theoreticaly) do some clever things and get the
     * message number being reffered to out of the junk.  But then again,
     * maybe not.
     */
    num = 0;
    i = 0;
    if (sscanf(input, "%d%s", num, input) != 2) {
        comm = "";
        if (sscanf(input, "%s %d %s", s1, num, s2) == 3) {
            i = 1;
            input = s1 + " " + s2;
        }
    }
    if (sscanf(input, "%s %s", comm, input) != 2) {
        comm = input;
        input = "";
    }
    if (i)
        input = ""+num+" "+input;
    switch(comm) {
    case "q" :  if (current == "inbox") {
            if (sizeof(folder) && 
              (sizeof(folder) != sizeof(newish)) && 
              (sizeof(deleted) != sizeof(folder))) {
                printf( "\nMove read message(s) to \"received\" folder? "
                  "(y/[n]): ");
                input_to("get_yesno");
                break; 
            }
        }
        delete_it(current, 1);
        break;
    case "d" :
        if (input != "") {
            rm_message(input);
            break;
        }
        printf( "\nDelete which messages (number or range): " );
        input_to("rm_message");
        break; 
    case "u" :
        if (input != "") {
            unrm_message(input);
            break;
        }
        printf( "\nUndelete which messages (number or range): " );
        input_to("unrm_message");
        break;
    case "c" :
        if (input != "") {
            change_folder(input);
            break;
        }
        printf( "\nChange to which folder (= for inbox): " );
        input_to("change_folder");
        break;
    case "m" :
        if (input != "") {
            get_recipient(input);
            break;
        } 
        printf( "\nRecipient: " );
        input_to("get_recipient");
        break;
    case "R" :
        reply_message(num);
        break;
    case "r" :
        reply_message(num, 1);
        break;
    case "$" :
        main_menu(current);
        break;
    case "f" :
        if (input != "") {
            forward_message(input);
            break;
        }
        printf("\nForward a message.  Ranges are not supported.\n"
          "Enter the number of the message and the name(s) of the "
          "recipient(s), separated by a comma: ");
        input_to("forward_message");
        break;
    case "F" :
        forward_email(num);
        break;
    case "i" :
        printf("\nHere's the index of your folders:\n");
        printf("\n%-#*s\n", COLS, implode(folder_names, "\n")); 
        prompt();
        input_to("read_loop");
        break;
    case "L" :
        if (full_header) {
            printf("\nOkay, now showing abbreviated header.\n");
            full_header = 0;
        } else {
            printf("\nOkay, now showing full header.\n");
            full_header = 1;
        }
        prompt();
        input_to("read_loop");
        break;
    case "l" :
        if (input != "") {
            if (!MAIL_TRACK->query_list(input)) {
                printf( "\nSorry, list "+input+" does not exist.\n" );
                prompt();
                input_to("read_loop");
                break;
            }
            printf( "\nMembers of list "+ input +":\n" );
            tmp = MAIL_TRACK->query_members(input);
        } else {
            printf( "\nCurrently available mailing lists:\n" );
            tmp = MAIL_TRACK->query_mailing_lists();
        }
        printf("\n%-#*s\n", COLS, implode(tmp,"\n"));
        prompt();
        input_to("read_loop");
        break;
    case ">" :
        if (!PLAYER_HANDLER->test_user(owner->query_name())) {
            printf( "You can't do that as a guest.\n" );
            break;
        }
        if (input != "") {
            move_message(input);
            break;
        }
        printf("\nMove message to folder.\nEnter the number "
          "(or range) of the message and the name of the folder, "
          "separated by a comma: ");
        input_to("move_message");
        break;
    case "h" :  
        if (input != "") {
            main_menu(current, 1, expand_range(input));
            break;
        }
        main_menu(current, 1);
        break;
    case "s" :
        save_message(input);
        break;
    case "?" :
        owner->set_finish_func("finish_print");
        comm = read_file("/doc/helpdir/mailer");
        owner->more_string(comm);
        break;
    case "" :
        if (num) {
            print_message(num-1);
            last_read = num-1;
            break;
        }
        if (newish == ({ })) {
            printf("\nNo more new messages in folder.\n");
            prompt();
            input_to("read_loop");
            break;
        }
        last_read = newish[0];
        print_message(newish[0]);
        break;
    default :
        printf("\nUnknown command.  Use \"?\" for help.\n");
        prompt();
        input_to("read_loop");
        break; 
    }
} /* read_loop() */

/** @ignore yes */
protected void get_yesno(string input) {
    int bing, i;

    if (!input || (input == "")) {
        printf("No.\n");
        delete_it(current, 1);
        return;
    }
    if (lower_case(input) == "n") {
        delete_it(current, 1);
        return;
    }
    if (lower_case(input) == "y") {
        bing = sizeof(folder);
        for (i = 0; i < bing; i++) {
            if ((member_array(i, newish) == -1) && 
              (member_array(folder[i]->number, deleted) == -1)) {
                move_message(""+(i+1)+" received", 1); 
            }
        }
    }
    delete_it(current, 1);
    return;
} /* get_yesno() */

private void forward_email(int number) {
    int i;
    string email, body;

    if (!number) {
        if (!(i = sizeof(folder))) {
            printf("No messages in folder.\n");
            prompt();
            input_to("read_loop");
            return;
        }
        if (newish != ({ })) {
            number = newish[0];
            if (number == 0) {
                printf("All your messages are still unread: aborting.\n");
                prompt();
                input_to("read_loop");
                return;
            }
        }
        else if (last_read > -1)
            number = last_read+1;
        else 
            number = i;
    }
    if (sizeof(folder) < number) {
        printf("Oh dear.  No message with that number.\n");
        prompt();
        input_to("read_loop");
        return;
    }
    number--;
    if (!(email = PLAYER_HANDLER->test_email(owner->query_name()))) {
        printf("Sorry, your E-mail address is not set.  Use chfn or email "
          "to set it.\n");
        prompt();
        input_to("read_loop");
        return;
    }
    if (email[0] == ':') {
        email = email[1..];
    }
    body = FOLDER_H->load_message(owner->query_name(), current,
      folder[number]->number);
    if (body) {
        SMTP->eventSendMail(email, owner->query_name(), body);
        printf("Message #%d forwarded to your E-mail address.\n", number + 1);
    }
    prompt();
    input_to("read_loop");
} /* forward_mail() */

private string rewrite_local(string rcpt) {
    string tmpr;

    if ((tmpr = FOLDER_H->check_local(rcpt))) {
        return tmpr;
    }
    return rcpt;
} /* rewrite_local() */

varargs private void reply_message(int number, int flag) {
    int i;
    string body;
    class mime_header hdr;

    if (!number) {
        if (!(i = sizeof(folder))) {
            printf("No messages in folder.\n");
            prompt();
            input_to("read_loop");
            return;
        }
        if (newish != ({ })) {
            number = newish[0];
            if (number == 0) {
                printf("All your messages are still unread: aborting.\n");
                prompt();
                input_to("read_loop");
                return;
            }
        }
        else if (last_read > -1)
            number = last_read+1;
        else 
            number = i;
    }
    if (sizeof(folder) < number) {
        printf("Oh dear.  No message with that number.\n");
        prompt();
        input_to("read_loop");
        return;
    }
    number--;
    to = folder[number]->from;
    body = FOLDER_H->load_message(owner->query_name(), current,
      folder[number]->number);
    if (!body) {
        prompt();
        input_to("read_loop");
        return;
    }
    hdr = MIME->parse_headers(body);
    if (!hdr) {
        prompt();
        input_to("read_loop");
        return;
    }
    if (hdr->header_m["reply-to"]) {
        to = hdr->header_m["reply-to"];
    }
    if (!flag) {
        string tmp;

        cc = hdr->header_m["cc"];
        tmp = hdr->header_m["to"];
        if (tmp) {
            if (cc) {
                cc += "," + tmp;
            } else {
                cc = tmp;
            }
        }
        if (cc == "") {
            cc = 0;
        }
        if (cc) {
            cc = implode(map(MIME->get_email_addrs(cc)[0],
                (: rewrite_local($1) :))-({ owner->query_name(), to }),
              ",");
        }
    }
    printf("Include original message? (y/[n]/q) ");
    input_to("finish_reply_message", 0, number);
} /* reply_message() */

/** @ignore yes */
protected void finish_reply_message(string input, int number) {
    int flag, i;
    string s1;

    if (!input || input == "" || lower_case(input)[0] != 'y') {
        if (lower_case(input)[0] == 'q') {
            cc = 0;
            to = "";
            printf("Aborting.\n");
            prompt();
            input_to("read_loop");
            return;
        }
        printf( "No.\n" );
    } else flag = 1;
    subject = folder[number]->subject;
    if (sscanf(subject, "Re:#%d %s", i, s1) != 2)
        subject = "Re:#1 " + subject;
    else 
        subject = sprintf("Re:#%d %s", (i+1), s1);
    printf("Press return for a subject of \"%s\"\nSubject: ", subject);
    if (flag)
        input_to("get_subject", 0, ++number, 1);
    else
        input_to("get_subject");
} /* finish_reply_message() */

/** @ignore yes */
protected void change_folder(string input) {
    if (!input || input == "") {
        prompt();
        input_to("read_loop");
        return;
    }
    if (input == "=") {
        delete_it(current, 0, "inbox");
        return;
    }
    if (member_array(input, folder_names) == -1) {
        printf("No folder named %s.\n", input);
        prompt();
        input_to("read_loop");
        return;
    }
    delete_it(current, 0, input);
} /* change_folder() */

/** @ignore yes */
protected void get_recipient(string input) {
    string *str, *full, nn;
    int i;
    mixed *addrs;

    if (!input || input == "") {
        printf("No recipient given: aborting.\n");
        prompt();
        input_to("read_loop");
        return;
    }
    addrs = MIME->get_email_addrs(input);
    str = addrs[0];
    full = addrs[1];
    for (i=0;i<sizeof(str);i++){
        nn = (string)owner->expand_nickname(str[i]);
        if (str[i] != nn) {
            str[i] = full[i] = nn;
        }
        if (!valid_name(str[i])) {
            printf("%s is not a valid recipient.\n", str[i]);
            str = delete(str, i, 1);
            full = delete(full, i--, 1); 
        }
    }
    if (sizeof(full))
        to = implode(full, ","); 
    else {
        if (no_menu) {
            delete_it("inbox", 1);
            return;
        }
        prompt();
        input_to("read_loop");
        return;
    }
    subject = "";
    printf("Subject: ");
    input_to("get_subject");
} /* get_recipient() */

/** @ignore yes */
varargs protected void get_subject(string input, int number, int flag) {
    if ((!input || input == "") && (!subject || subject == "")) {
        printf("No subject given: aborting.\n");
        if (no_menu) {
            delete_it("inbox", 1);
            return;
        }
        prompt();
        input_to("read_loop");
        return;
    }
    if (input && input != "")
        subject = input;
    printf("Cc: ");
    input_to("get_cc", 0 , number, flag);
} /* get_subject() */

private int valid_name(string str) {
    string mud;

    str = lower_case(str);
    if (!sscanf(str, "%s@%s", str, mud) || 
      lower_case(mud) == lower_case(mud_name())) {
        /* local...  */
        return (int)PLAYER_HANDLER->test_user(str) ||
        (int)MAIL_TRACK->query_list(str);
    }
    return 1;
} /* valid_name() */  

/** @ignore yes */
varargs protected void get_cc(string input, int number, int flag) {
    string *str, body, *full, nn;
    int i;
    mixed *addrs;

    if (!input || input == "**" || input == "") {
        if (number) {
            body = FOLDER_H->load_message(owner->query_name(), current, 
              folder[number-1]->number);
            if (!body) {
                prompt();
                input_to("read_loop");
                return;
            }
            if (!flag) {
                finish_write_message("> " + replace_string(body, "\n", "\n> ") + "\n");
                return;
            }
            owner->do_edit("> " + replace_string(body, "\n", "\n> ") + "\n", 
              "finish_write_message");
            return;
        }
        write_message();
        return;
    }
    addrs = MIME->get_email_addrs(input);
    str = addrs[0];
    full = addrs[1];
    for (i = 0; i < sizeof(str); i++) {
        nn = (string)owner->expand_nickname(str[i]);
        if (str[i] != nn) {
            str[i] = full[i] = nn;
        }
        if (!valid_name(str[i])) {
            printf("%s is not a valid recipient.\n", str[i]);
            str = delete(str, i, 1);
            full = delete(full, i--, 1);
        }
    }
    if (cc)
        cc += "," + implode(full, ",");
    else
        cc = implode(full, ",");
    printf("Cc: ");
    input_to("get_cc", 0, number, flag);
}  /* get_cc() */

private void write_message() {
    owner->do_edit(0, "finish_write_message");
} /* write_message() */

/** @ignore yes */
void finish_write_message(string input) {
    if (!input || input == "") {
        if (no_menu) {
            delete_it("inbox", 1);
            return;
        }
        prompt();
        input_to("read_loop");
        return;
    }
    printf("Cc: ");
    input_to("get_cc_after", 0, input);
} /* finish_write_message() */

/** @ignore yes */
protected void get_cc_after(string input, string body) {
    mixed *goto, cc_e, *addrs;
    class mail_message msg;
    string *str, *full, nn;
    int i;

    if (!input || input == "**" || input == "") {
        body += owner->append_signature();
        FOLDER_H->mark_read(owner->query_name(), current, newish);
        goto = explode(to, ",") - ({ "" });
        if (cc && cc != "") {
            cc_e = explode(cc, ",") - ({ "" });
        } else {
            cc_e = ({ });
        }
        msg = new(class mail_message);
        msg->to = goto;
        msg->cc = cc_e;
        msg->body = "From " + owner->query_name() + " " + ctime(time()) +
        "\nDate: " + format_date(time()) +
        "\nFrom: " + owner->query_name() +
        "\nTo: " + to +
        "\nSubject: " + subject +
        "\n" + (sizeof(cc_e)?"Cc: " + cc + "\n":"") +
        "\n" + body;
        msg->from = owner->query_name();
        msg->subject = subject;
        FOLDER_H->add_it(msg, 0);
        to = "";
        cc = 0;
        subject = "";
        printf("Message sent.\n");
        if (no_menu) {
            delete_it("inbox", 1);
            return;
        }
        prompt();
        input_to("read_loop");
        return;
    }
    addrs = MIME->get_email_addrs(input);
    str = addrs[0];
    full = addrs[1];
    for (i = 0; i < sizeof(str); i++) {
        nn = (string)owner->expand_nickname(str[i]);
        if (str[i] != nn) {
            str[i] = full[i] = nn;
        }
        if (!valid_name(str[i])) {
            printf("%s is not a valid recipient.\n", str[i]);
            str = delete(str, i, 1);
            full = delete(full, i--, 1);
        }
    }
    if (cc)
        cc += "," + implode(full, ",");
    else
        cc = implode(full, ",");
    printf("Cc: ");
    input_to("get_cc_after", 0, body);
} /* get_cc_after() */

varargs private void delete_it(string fname, int last, string newish_folder) {
    if (!fname)
        fname = current;
    if (deleted != ({ })) {
        printf("Delete message(s)? ([y]/n) ");
        input_to("finish_delete_it", 0, fname, last, newish_folder);
        return;
    }
    if (last) {
        FOLDER_H->mark_read(owner->query_name(), current, newish);
        save_me();
        if (do_this_last && objectp(do_this_last[0]))
            call_other(do_this_last[0], do_this_last[1], do_this_last[2]);
        else
            dest_me();
        return;
    }
    FOLDER_H->mark_read(owner->query_name(), current, newish);
    if (!newish_folder || newish_folder == "")
        main_menu(fname);
    else
        main_menu(newish_folder);
} /* delete_it() */

/** @ignore yes */
protected void finish_delete_it(string input, string fname, int last, 
  string newish_folder) {
    if (lower_case(input) == "n" || (input && input != "" && 
        lower_case(input) != "y")) {
        printf("Keeping message(s).\n");
        deleted = ({ });
        if (last) {
            FOLDER_H->mark_read(owner->query_name(), current, newish);
            save_me();
            if (do_this_last && objectp(do_this_last[0]))
                call_other(do_this_last[0], do_this_last[1], do_this_last[2]);
            else
                dest_me();
            return;
        }
        FOLDER_H->mark_read(owner->query_name(), current, newish);
        if (!newish_folder || newish_folder == "")
            main_menu(fname);
        else
            main_menu(newish_folder);
        return;
    }
    printf("Deleting message(s).\n");
    FOLDER_H->mark_read(owner->query_name(), current, newish);
    FOLDER_H->delete_it(owner->query_name(), fname, deleted);
    deleted = ({ });
    save_me();
    if (last) {
        if (do_this_last && objectp(do_this_last[0]))
            call_other(do_this_last[0], do_this_last[1], do_this_last[2]);
        else
            dest_me();
        return;
    }
    if (!newish_folder || newish_folder == "")
        main_menu(fname);
    else
        main_menu(newish_folder);
    return;
} /* finish_delete_it() */

/** @ignore yes */
varargs protected void rm_message(string input, int flag) {
    int i, tmp;
    int *range;

    if (!input || input == "") {
        prompt();
        input_to("read_loop");
        return;
    }
    range = expand_range(input);
    tmp = sizeof(range);
    for (i = 0; i < tmp; i++) {
        if (member_array(folder[range[i]-1]->number, 
            deleted) == -1) {
            newish -= ({ range[i]-1 });
            deleted += ({ folder[range[i]-1]->number });
            folder[range[i]-1]->status = "D";
            printf("Marked message %d as deleted.\n", range[i]);
        }
    }
    if (!flag) {
        prompt();
        input_to("read_loop");
    }
} /* rm_message() */

/** @ignore yes */
protected void unrm_message(string input) {
    int i, tmp;
    int *range;

    if (!input || input == "") {
        prompt();
        input_to("read_loop");
        return;
    }
    range = expand_range(input);
    tmp = sizeof(range);
    for (i = 0; i < tmp; i++) {
        if (member_array(folder[range[i]-1]->number, 
            deleted) > -1) {
            deleted -= ({ folder[range[i]-1]->number });
            folder[range[i]-1]->status = "U";
            printf("Undeleted message %d.\n", range[i]);
        }
    }
    prompt();
    input_to("read_loop");
} /* unrm_message() */

/** @ignore yes */
protected void forward_message(string input) {
    int number, i;
    string *str, *full, nn;
    mixed *addrs;

    if (!input || input == "") {
        prompt();
        input_to("read_loop");
        return;
    }
    if (sscanf(input, "%d %s", number, to) != 2) {
        printf("Wrong syntax (ranges are not supported with forward).\n");
        prompt();
        input_to("read_loop");
        return;
    } 
    if (number > sizeof(folder) || !number) {
        printf("Oh dear. No message with that number.\n");
        prompt();
        input_to("read_loop");
        return;
    }
    addrs = MIME->get_email_addrs(to);
    str = addrs[0];
    full = addrs[1];
    for (i = 0; i < sizeof(str); i++) {
        nn = (string)owner->expand_nickname(str[i]);
        if (str[i] != nn) {
            str[i] = full[i] = nn;
        }
        if (!valid_name(str[i])) {
            printf("%s is not a valid recipient.\n", str[i]);
            str = delete(str, i, 1);
            full = delete(full, i--, 1);
        }
    }
    if (sizeof(full)) {
        to = implode(full, ",");
    } else {
        prompt();
        input_to("read_loop");
        return;
    }
    cc = 0;
    printf("Edit outgoing message? (y/[n]) ");
    input_to("edit_it", 0, number);
} /* forward_message() */

/** @ignore yes */
protected void edit_it(string input, int number) {
    subject = folder[number-1]->subject + " (fwd)";
    if (!input || input == "")
        printf( "No.\n" );
    printf("Press return for a subject of \"%s\"\nSubject: ", subject);
    if (!strlen(input) || (lower_case(input) == "n"))
        input_to("get_subject", 0, number);
    else if (lower_case(input) == "y")
        input_to("get_subject", 0, number, 1);
    return;
} /* edit_it() */

/** @ignore yes */
varargs protected void move_message(string input, int flag) {
    int *range, i, bing;
    string to_folder, number;

    if (!input || input == "") {
        prompt();
        input_to("read_loop");
        return;
    }
    if (!sscanf(input, "%s %s", number, to_folder)) {
        printf("Wrong syntax.\n");
        prompt();
        input_to("read_loop");
        return;
    }
    if (to_folder == current) {
        printf("Destination folder is the same as source folder: not moved.\n");
        prompt();
        input_to("read_loop");
        return;
    }
    if (to_folder == "=")
        to_folder = "inbox";
    range = expand_range(number);
    bing = sizeof(range);
    FOLDER_H->mark_read(owner->query_name(), current, newish);
    for (i = 0; i < bing; i++) { 
        int status;

        if (member_array(to_folder, folder_names) == -1) { 
            if (FOLDER_H->can_create_folder(owner->query_name(), to_folder)) {
                folder_names += ({ to_folder });
            } else {
                printf("Cannot create a folder called %s, please choose "
                    "another another name.\n", to_folder);
                break; 
            }
        }
        deleted += ({ folder[range[i]-1]->number });
        status = FOLDER_H->move_it(owner->query_name(), current, to_folder,
          folder[range[i]-1]->number);
        folder[range[i]-1]->status = "D";
        switch(status) {
        case 2:
          printf("Folder full!\n");
        case 1:
          printf("Marked message %d as deleted.\n", range[i]);
          break;
        case 0:
          if(!flag)
            printf("Saved message %d to folder %s.\n", range[i], to_folder);
        }
    }
    if (!flag) {
        prompt();
        input_to("read_loop");
    }
} /* move_message() */

private void save_message(string input) {
    int *range, i, bing, ret;
    string to_file, number, body, err;

    if (!wizardp(owner)) {
        printf("Sorry, only creators can save mail to files.\n");
        prompt();
        input_to("read_loop");
        return;
    }
    if (!input || input == "") {
        if (last_read != -1)
            input = sprintf("%d ~/mbox",(last_read+1));
        else {
            printf("No messages in folder or all messages still unread.\n");
            prompt();
            input_to("read_loop");
            return;
        } 
    }
    if (!sscanf(input, "%s %s", number, to_file)) {
        printf("Wrong syntax.\n");
        prompt();
        input_to("read_loop");
        return;
    }
    seteuid(geteuid(owner));
    to_file = (string)owner->get_path(to_file);
    if (!master()->valid_write(to_file, owner, "write_file")) {
        printf("You cannot write to that file.\n");
        prompt();
        input_to("read_loop");
        return;
    }
    if ((i=file_size(to_file)) > 0)
        printf("Appending to existing file.\n");
    else if (i == -2) {
        printf("That is a directory.\n");
        prompt();
        input_to("read_loop");
        return;
    }
    range = expand_range(number);
    bing = sizeof(range);
    i = 0;
    for (i = 0; i < bing; i++) {
        body = FOLDER_H->load_message(owner->query_name(), current, 
          folder[range[i]-1]->number);
        if (!body) {
            continue;
        }
        err = catch(ret = write_file(to_file, body + "\n\n"));
        if (err) {
            printf("Writing to file failed: %s\n", err);
        } else if (!ret) {
            printf("Writing to file failed.\n");
        } else {
            printf("Saved message %d to %s.\n", range[i], to_file);
        }
    }
    seteuid("Mailer");
    prompt();
    input_to("read_loop");
} /* save_message() */

private void print_message(int number) {
    string body;

    if (number > sizeof(folder)-1 || number < 0) {
        printf("No message with that number.\n");
        prompt();
        input_to("read_loop");
        return;
    }
    if (folder[number]->status == "N") {
        newish -= ({ number });
        folder[number]->status = " ";
    }
    body = FOLDER_H->load_message(owner->query_name(), current, 
      folder[number]->number);
    if (!body) {
        rm_message(""+(number+1));
        return;
    }
    owner->set_finish_func("finish_print");
    printf("\n\nMessage %d\n", (number + 1));
    owner->more_string((full_header?body:strip_header(body)),
      "Message "+(number+1));
} /* print_message() */

/** @ignore yes */
void finish_print() {
    printf("\n");
    prompt();
    input_to("read_loop");
} /* finish_print() */

private void save_me() {
    if (!PLAYER_HANDLER->test_user(owner->query_name())) {
        return;
    }
    if (current != "inbox") {
        if (FOLDER_H->check_empty(owner->query_name(), current)) {
            folder_names -= ({ current });
        }
    }
    unguarded((: save_object, folder_filename(owner->query_name()) :));
} /* save_me() */

private int load_me() {
#ifdef CONVERTER
    if ("/obj/handlers/converter"->query_busy(owner->query_name())) {
        printf( "You cannot use the mailer now, your mail is being converted.\n" );
        return 0;
    }
#endif
    unguarded((: restore_object, folder_filename(owner->query_name()) :));
    if (!folder_names) {
        folder_names = ({ "inbox" });
    }
    return 1;
} /* load_me() */

/**
 * This method returns the list of folders associated with the player.
 * @param pname the player name
 * @return an array containing the folder names
 */
string *query_folders(string pname) {
    unguarded((: restore_object, folder_filename(pname) :));
    if (!folder_names)
        return ({});
    return folder_names;
} /* query_folders() */

private void read_messages(string fname) {
    folder = FOLDER_H->get_messages(owner->query_name(), fname);
} /* read_messages() */

/** @ignore yes */
void dest_me() {
    MAIL_TRACK->delete_mailer(this_object());
    destruct(this_object());
} /* dest_me() */

/**
 * This formats the date as needed by the mailer object.
 * @param x the date to format
 * @return the new date
 */
string format_date(int x) {
    string str;
    string mon;
    mixed *tm;

    if (x<0 || !intp(x))
        return "Bad time";

    tm = localtime(x);
    str = DAYS[tm[LT_WDAY]];
    mon = MONTHS[tm[LT_MON]];
    str = sprintf("%s, %d %s %d %02d:%02d %s", str, tm[LT_MDAY], mon,
      tm[LT_YEAR], tm[LT_HOUR], tm[LT_MIN], tm[LT_ZONE]);
    return str;
} /* format_date() */

private int *expand_range(string str) {
    int *ms, i, start, end;

    if (!str)
        str = "";
    if (!sizeof(folder))
        return ({ });
    str = replace_string(str, " ", "");
    ms = ({ });
    if (sscanf(str, "%*sall%*s")==2) {
        int size = sizeof(folder) + 1;
        for (i = 1; i < size; i++) {
            ms += ({ i });
        }
        return ms;
    }
    while (sscanf(str, "%d%s", start, str) == 2) {
        if (start < 1)
            start = 1;
        if (start > sizeof(folder))
            start = sizeof(folder);
        if (str && str != "" && (str[0] == '-' || ((strlen(str) > 1) &&
              str[0..1] == ".."))) {
            sscanf(str, "%*(-|(..))%d%s", end, str);
            if (end >= start) {
                if (end > sizeof(folder))
                    end = sizeof(folder);
                for (i = start; i <= end; i++)
                    if (member_array(i, ms) == -1)
                        ms += ({ i });
            }
        } else
        if (member_array(start, ms) == -1)
            ms += ({ start });
        sscanf(str, ",%s", str);
    }
    return ms;
} /* expand_range() */
// --- END [/mnt/home2/grok/lib/obj/handlers/mailer.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/parcel.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/parcel.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628546   Available: 13575900
Inodes: Total: 5242880    Free: 4960134
8739 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/parcel.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628546   Available: 13575900
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 *
 * Post Office Delivery Handler
 * @author Terano
 * @started 26 December, 1998
 *
 */
#define BASE_PATH "/save/parcels/"
#define SAVE_PATH BASE_PATH + location + "/" + name[0..0]
#define SAVE_FILE BASE_PATH + location + "/" + name[0..0] + "/" + name + ".o"
#define POST_LOG "PARCEL_LOG"

inherit "/global/auto_load";

// This is undefined since uncompress() is broken. Once uncompress() is
// repaired it should be possible to turn compression on but please test
// it first. -- Ceres
#undef USE_COMPRESSION

#include <player_handler.h>

/**
 * Parcels is a mapping with player names as keys, and arrays of class parcel
 * as values
 */
class parcel {
  string from;
  string *autoloadinfo;
  int exp_time;
}

mapping parcels;
private nosave string _current_name, _current_location;
nosave class parcel *_parcels;

int test_expire( class parcel temp );

/**
 * @ignore
 */
void create() {
  string dir;
  
  seteuid( master()->creator_file( base_name( this_object() ) ) );
  parcels = ([ ]);
  if(parcels) {
    parcels = copy(parcels);
    parcels = ([ ]);
  }
  _parcels = ({ });

  /*  foreach(dir in get_dir("/save/parcels/*")) {
    if(dir != "." && dir != ".." && file_size("/save/parcels/" + dir) == -2) {
      tell_creator("ceres", "Starting %s", dir);
      call_out("do_migrate", random(10), 'a', dir);
    }
  }
  */
}

/**
 * @ignore
 */
private void save_file(string name, string location) {
  string str;
  
  // Save the old parcels variable.
  map_delete(parcels, name);
  if(sizeof(keys(parcels)))
    unguarded( (: save_object, SAVE_PATH, 2 :));
  
  if(file_size(SAVE_PATH) == -1)
    unguarded( (: mkdir, SAVE_PATH :) );

  // If they have a parcel then save it to a file. If not delete any existing
  // parcel file.
  if(_parcels != ({ })) {
    str = save_variable(_parcels);
#ifdef USE_COMPRESSION
    if(!ungarded( (: write_buffer, SAVE_FILE + ".gz", 0, compress(str) :) ))
#else     
    if(!unguarded((: write_file, SAVE_FILE, str, 1 :) ))
#endif
      log_file(POST_LOG, "%s: error writing to %s\n",
               ctime(time()), SAVE_FILE);
  } else {
    if(file_size(SAVE_FILE) > 0)
      unguarded( (: rm, SAVE_FILE :));
    if(file_size(SAVE_FILE+".gz") > 0)
      unguarded( (: rm, SAVE_FILE + ".gz" :));

  }
}

/**
 * @ignore
 */
private void load_file( string name, string location ) {
  // no need to load if it's the currently loaded one.
  if(_current_name == name && _current_location == location)
    return;

#ifdef USE_COMPRESSION
  if(file_size(SAVE_FILE + ".gz") > 0) {
    _parcels = restore_variable(uncompress(read_file(SAVE_FILE)));
  } else
#endif    
  if(file_size(SAVE_FILE) > 0) {
    debug_printf("%s", SAVE_FILE);
    _parcels = restore_variable(unguarded( (: read_file, SAVE_FILE :) ));
  } else if (file_size(SAVE_PATH+ ".o.gz") > 0) {
    unguarded( (: restore_object, SAVE_PATH+".o.gz" :));
    _parcels = parcels[name];
  } else if(file_size(SAVE_PATH+".o") > 0) {
    unguarded( (: restore_object, SAVE_PATH :) );
    _parcels = parcels[name];
  } else {
    parcels = ([ ]);
    _parcels = ({ });
  }

  _current_name = name;
  _current_location = location;
}

/**
 * This function deposits some items for a player
 * @param to The name of the player items are going to
 * @param from The name of the player sending the items
 * @param location The place the items are being sent from
 * @param obs An array of the objects being sent
 * @return 1 if it worked, or 0 if it screwed up :)
 */
public int deposit(string to, string from, string location, object *obs) {
  class parcel temp;
  object boxy;
  string obsstuff, tmp;

  obsstuff = "/global/events"->convert_message(query_multiple_short (obs));
  
  if(!PLAYER_HANDLER->test_user(to))
    return 0;

#ifndef __DISTRIBUTION_LIB__
    // Do multiplayer checks.
    if("/secure/alist"->query_alt(from, to) == 100) {
      tmp = capitalize(from) + " sent a parcel containing " +
        obsstuff + " to his/her alt " + capitalize(to) + ".";
      user_event("inform", tmp, "multiplayer");
      log_file("MULTIPLAYERS", ctime(time()) + ": " +
               this_player()->convert_message(tmp) + "\n");
    } else if("/secure/alist"->query_alt(from, to) > 40) {
      tmp = capitalize(from) + " sent a parcel containing " +
        obsstuff + " to his/her POSSIBLE alt "+ capitalize(to) + ".";
      user_event("inform", tmp, "multiplayer");
      log_file("MULTIPLAYERS", ctime(time()) + ": " +
               this_player()->convert_message(tmp) + "\n");
    }
#endif

  load_file(to, location ); // Load up the right save file
  if(undefinedp(_parcels) || !arrayp(_parcels))
    _parcels = ({ });
  
  boxy = clone_object("/obj/baggage");
  boxy->set_name("boxy");
  boxy->set_max_weight(100000);

  obs->move( boxy );
  temp = new( class parcel,
              from : from,
              exp_time: time() + ( 14 * 24 * 60 * 60));
  temp->autoloadinfo = create_auto_load( ({ boxy }), 0 );
  _parcels += ({ temp });
  save_file(to, location);
  boxy->dest_me();
  log_file (POST_LOG, "%s: %s deposited %s at %s for %s.\n", ctime(time()), 
      from, obsstuff, location, to);  
}

/**
 * This function collects any items available
 * @param name Name of the player collecting
 * @param location Location collecting from
 * @param target An object to move the items into, a room or container
 * @param copy An int, if its 1 it doesnt delete the objects from the parcels
 *        array
 * @return 0 if no items or failure, 1 if successful
 */
public int collect(string name, string location, object target, int copy) {
  class parcel temp;
  object *box_array = ({ });
  object *obs = ({ });
  string tmp;
  
  load_file(name, location ); // Load up the right save file
  
  if(!_parcels || _parcels == ({ }))
    return 0;
  
  foreach(temp in _parcels) {
    box_array += load_auto_load_to_array(temp->autoloadinfo, this_player());
#ifndef __DISTRIBUTION_LIB__
    obs = all_inventory(box_array[<1]);
    // Do multiplayer checks.
    if("/secure/alist"->query_alt(name, temp->from) == 100) {
      tmp = capitalize(name) + " received a parcel containing " + 
        "/global/events"->convert_message(query_multiple_short(obs)) +
        " from his/her alt " + capitalize(temp->from) + ".";
      user_event("inform", tmp, "multiplayer");
      log_file("MULTIPLAYERS", ctime(time()) + ": " +
               this_player()->convert_message(tmp) + "\n");
    } else if("/secure/alist"->query_alt(name, temp->from) > 40) {
      tmp = capitalize(name) + " received a parcel containing " +
        "/global/events"->convert_message(query_multiple_short(obs)) +
        " from his/her POSSIBLE alt "+ capitalize(temp->from) + ".";
      user_event("inform", tmp, "multiplayer");
      log_file("MULTIPLAYERS", ctime(time()) + ": " +
               this_player()->convert_message(tmp) + "\n");
    }
#endif
  }
  
  foreach( object box in box_array ) {
    obs += all_inventory (box);
    all_inventory( box )->move( target );
    box->dest_me();
  }
  
  if ( !copy )
    _parcels = ({ });

  log_file (POST_LOG, "%s: %s collected %s at %s.\n", ctime(time()), 
            name, "/global/events"->convert_message(query_multiple_short(obs)),
            location);  
  save_file(name, location);
  return 1;
}

/**
 * Queries if any parcels are at a location for a person
 * @param name of the person
 * @param location of the post office
 */
class parcel *queryparcels_for(string name, string location) {
  load_file(name, location);

  return _parcels;
} 

/**
 * Migrate packages
 * @param letter to expire
 * @param location to expire
 */
void do_migrate(int letter, string location) {
  string name;
  class parcel temp2;

  tell_creator("ceres", "Processing %c in %s\n", letter, location);
  load_file(sprintf("%c", letter), location);
  foreach(name, temp2 in parcels) {
    _parcels = filter(temp2, (: test_expire :));
    save_file(name, location);
  }
  if(!sizeof(keys(parcels))) {
    name = BASE_PATH + location + "/" + sprintf("%c", letter) + ".o.gz";
    unguarded((: rm, name :));
  }
  if(letter < 'z') {
    letter++;
    call_out("do_migrate", 15 + random(30), letter, location);
  }
}

/**
 * @ignore
 */
int test_expire(class parcel temp ) {
  if ( temp->exp_time > time() )
    return 1;

  return 0;
}

/**
 * Called when a player deletes
 * Deletes all their parcels
 * @param string name
 * @param int Total Flag
 */
void player_refreshed(mixed name, int total ) {
  string location;
  string *dirs = map( filter( get_dir( BASE_PATH, -1 ), 
                              (: $1[1] == -2 :) ), (: $1[0] :) );

  if (objectp(name))
    name = name->query_name();
  
  foreach(location in dirs) {
    load_file(name, location);
    map_delete(parcels, name);
    save_file(name, location);
  }
}
// --- END [/mnt/home2/grok/lib/obj/handlers/parcel.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/board_handler.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/board_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628544   Available: 13575898
Inodes: Total: 5242880    Free: 4960134
42162 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/board_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628544   Available: 13575898
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: board_handler.c,v 1.71 2003/05/06 22:31:22 ceres Exp $
 */
/**
 * Keeps track of all the bulletin board notes and related information.
 *
 * @index bulletin
 * @author Pinkfish
 */
#include <board.h>
#include <mail.h>
#include <clubs.h>
#include <player_handler.h>

//#define DEBUG 1

#define T_MIN 0
#define T_MAX 1
#define T_TIMEOUT 2
#define DEFAULT_MIN 10
#define DEFAULT_MAX 80
#define DEFAULT_TIMEOUT 14
#define ARCHIVE_DIR "/open/boards/"
// maximum archive file size
#define MAX_ARCHIVE_SIZE 1048576

#define BACKUPS_DIR "/save/board_backups/"
#define NEWSRC_SAVE_DIR "/save/newsrc/"
#define BACKUP_TIME_OUT (7 * 24 * 60 * 60)
#define BOARD_HANDLE_VERSION 1

#ifdef USE_RAMDISK
#define CACHE_SIZE 10
#else
#define CACHE_SIZE 250
#endif

#define CACHE_TIMEOUT 1800
#define NEWSRC_SAVE_DELAY 300

class newsrc {
  int cached;
  int changed;
  mapping newsrc;
  string *kill;
  string *board_order;
}

class read_access_cache {
   int read_time;
   int read_access;
}

private int num;
private int board_version;
private mapping archives;
private mapping boards;
private mapping priv;
private mapping security;
private mapping timeouts;
private nosave string *_allowed_objects;
private nosave mapping message_cache;
private nosave mapping _newsrc_cache;
private nosave int total_reads, cache_hits, ram_hits, clean_out;
private nosave int _ram_exists;
private nosave int _newsrc_reads, _newsrc_cache_hits;
private mapping _idiots;
private nosave mapping _read_access_cache;

string query_archive(string board);
protected int zap_message(string board, int num, string name);
int can_delete_message(string board, int off, string pname);
void save_me();

void create() {
  int number;
  int last;
  string line;
  string *lines;

  seteuid(master()->creator_file(file_name(this_object())));
  num = 1;
  boards = ([ ]);
  security = ([ ]);
  _read_access_cache = ([ ]);
  priv = ([ ]); /* Private boards... only lords or specified people
                 * can read. */
  timeouts = ([ ]);
  archives = ([ ]);
  message_cache = ([ ]);
  _newsrc_cache = ([ ]);

  _allowed_objects = ({
    // These are the objects allowed to post...
    BOARD_HAND,
      "/obj/misc/board",
      "/obj/misc/board_mas",
      "/obj/handlers/applications_handler",
      "/w/ceres/board",
      "/w/ceres/board_mas",
      "/www/boards",
      "/www/secure/nboards",
      "/obj/handlers/club_handler",
      "/obj/handlers/deity_handler",
      "/obj/handlers/folder_handler",
      "/obj/handlers/playtesters",
      "/obj/handlers/error_tracker",
      "/obj/handlers/twiki",
      "/d/forn/utils/error_tracker",
      "/d/forn/handlers/peer_review",
      "/d/sur/utils/error_tracker",
      "/d/cwc/utils/error_tracker",
      "/d/Ankh-Morpork_dev/utils/error_tracker",
      "/d/liaison/utils/error_tracker",
      "/d/am/utils/error_tracker",
      "/d/guilds/priests/items/desk",
      "/d/ram/error_tracker",
      "/d/ram/cool/bank",
      "/d/special/error_tracker",
      "/d/klatch/utils/error_tracker",
      "/d/guilds/error_tracker",
      "/d/special/utils/error_tracker",
      "/d/am/patrician/pat_applications",
      "/d/am/patrician/pat_complaints",
      "/cmds/player/news",
      "/cmds/player/apply",
      "/d/guilds/assassins/Ankh-Morpork/admin/vote_room",
      "/d/special/player_shops/tarnach's_office",
      "/std/shops/player_shop/office",
      "/d/playtesters/handlers/applications",
      "/d/guilds/warriors/Ankh-Morpork/voting_booth",
      "/secure/cmds/creator/errors",
      "/obj/handlers/player_council",
      "/d/guilds/wizards/utils/board_hand",
      "/obj/handlers/complaints_handler",
      "/obj/handlers/project_management",
      "/d/guilds/thieves/Ankh-Morpork/rooms/ground/voting_booth",
      "/d/underworld/utils/error_tracker"      
      });

  _idiots = ([ ]);

  if (file_size(BOARD_FILE +".gz") > 0) {
     unguarded((: cp, BOARD_FILE +".gz", BACKUPS_DIR +"boards."+ time() :));
  }
  lines = unguarded((: get_dir, BACKUPS_DIR +"boards.*" :));
  if ( sizeof( lines ) > 6 ) {
    last = time() - BACKUP_TIME_OUT;
    foreach(line in lines) {
      sscanf(line, "boards.%d", number);
      if (number < last)
        unguarded((: rm, BACKUPS_DIR + line :));
    }
  }
  if(!unguarded((: restore_object, BOARD_FILE+".gz" :)))
    unguarded((: restore_object, BOARD_FILE :));

  call_out("expire_boards", 5);
} /* create() */

/**
 * This method returns the file name of the message to use in retreiving
 * the message.
 * @param board the board to get the message from
 * @param num the number of the mesage to download
 */
private string get_filename(string board, int num) {
   string fixed_board;

   fixed_board = replace(board, ({" ", "_", "'", ""}));
 
   // return the filename in the appropriate subdirectory.
   return BOARD_DIR + fixed_board + "/" + num;
} /* get_filename() */

/**
 * This method returns the file name of the ramdisk cach of the message
 * the message.
 * @param board the board to get the message from
 * @param num the number of the mesage to download
 */
private string get_ram_filename(string board, int num) {
   string fixed_board;

   fixed_board = replace(board, ({" ", "_", "'", ""}));

   if(!_ram_exists) {
     _ram_exists = file_size(BOARD_RAM_DIR);
   }

   // return the filename in the appropriate subdirectory.
   // If BOARD_RAM_DIR exists we return the ramdisk file otherwise
   // we return the standard file.
   if(_ram_exists == -2)
     return BOARD_RAM_DIR + fixed_board + "/" + num;
   else
     return BOARD_DIR + fixed_board + "/" + num;
}

/**
 * Returns the names of all the boards.
 * @return the names of all the boards
 */
string *query_boards() {
   return keys(boards);
} /* query_boards() */

/**
 * This method tests to see if the board exists.
 * @param board the name of the board to check
 * @return 1 if the board exists, 0 if it does not
 */
int is_board(string board) {
   if (boards[board]) {
      return 1;
   }
   return 0;
} /* is_board() */

private int query_lord(string str) {
   return (int)master()->query_lord(str);
} /* query_lord() */

/**
 * This method checks to see if the specified person is an idiot or
 * not.
 * @param name the name to check
 * @return 1 if they are an idiot
 */
int is_idiot(string name) {
   if (!_idiots) {
      _idiots = ([ ]);
   }
   if (_idiots[name]) {
      if (_idiots[name] > time()) {
         return 1;
      }
      map_delete(_idiots, name);
   }
   return 0;
} /* is_idiot() */

/**
 * This method adds an idiot to the current list of idiots.
 * @param idiot the idiot to add
 * @param length the amount of days to add them for
 */
void add_idiot(string idiot, int length) {
   _idiots[idiot] = time() + (60 * 60 * 24 * length);
   save_me();
} /* add_idiot() */

/**
 * This method returns if they are an idiot and when their period of
 * idiocy runs out.
 * @param idiot the idiot to check
 * @return 0 if not an idiot, the time left otherwise
 */
int query_idiot(string idiot) {
   return _idiots[idiot];
} /* query_idiot() */

/**
 * Check to see if read access is allowed.
 * @param board the board to check
 * @param previous the previous object
 * @param name the name of the person doing stuff
 * @return 1 if it is allowed, 0 if not
 */
int test_can_read(string board, object previous,
                      string name) {
   int bit;
   int ret;

   /* For the moment we will just log all bad access... */
   if (member_array(base_name(previous), _allowed_objects) == -1 &&
       board != "announcements") {
#ifdef DEBUG
      log_file("BAD_BOARD", ctime(time()) + " (read): [" + board + "] " +
               base_name(previous) +
               sprintf(" (%O)\n", this_player()->query_name()));
#endif
      return 0;
   }
   bit = priv[board] & B_PRIV_TYPE_MASK;
   // The default is easy.
   if (bit == 0) {
      return 1;
   }

   // Check the cache.
   if (_read_access_cache[board] &&
       !undefinedp(_read_access_cache[board][name])) {
      return _read_access_cache[board][name];
   }

   // Default, you can read!
   ret = 1;
   if (bit == B_PRIV_ACCESS_RESTRICTED) {
      ret = query_lord(name) ||
         (member_array(name, security[board]) != -1);
   } else if (bit == B_PRIV_ACCESS_RESTRICTED_METHOD) {
      if (query_lord(name)) {
         ret = 1;
      } else {
         // This will now need to check the method and function to call.
         if (sizeof(security[board]) == 2) {
            ret = call_other(security[board][1],
                           security[board][0],
                           B_ACCESS_READ,
                           board, previous, name);
         }
      }
   }

   if (!_read_access_cache[board]) {
      _read_access_cache[board] = ([ ]);
   }
   _read_access_cache[board][name] = ret;
   return ret;
} /* test_can_read() */

/**
 * Check to see if write access is allowed.
 * @param board the board to check
 * @param previous the previous object
 * @param name the name of the person doing stuff
 * @return 1 if it is allowed, 0 if not
 */
int test_can_write(string board, object previous,
                      string name) {
  int bit;
  
  if (is_idiot(name)) {
     return 0;
  }

  if (member_array(base_name(previous), _allowed_objects) == -1) {
#ifdef DEBUG
    log_file("BAD_BOARD", ctime(time()) + " (write): " + base_name(previous) +
                          sprintf(" (%O)\n", this_player()));
#endif
    return 0;
  }
  bit = priv[board] & B_PRIV_TYPE_MASK;
  if (bit == B_PRIV_ACCESS_RESTRICTED_FILE) {
    return member_array(base_name(previous), security[board]) != -1;
  }
  if (bit == B_PRIV_ACCESS_RESTRICTED_METHOD) {
    if (query_lord(name)) {
      return 1;
    }
    // This will now need to check the method and function to call.
    if (sizeof(security[board]) == 2) {
      return call_other(security[board][1],
                        security[board][0],
                        B_ACCESS_WRITE,
                        board, previous, name);
    }
    return 0;
  }
  if (bit == B_PRIV_ACCESS_RESTRICTED ||
      bit == B_PRIV_READ_ONLY) {
    return query_lord(name) ||
           (member_array(name, security[board]) != -1);
  }
  // Default, you can write!
  return 1;
} /* test_can_write() */

/**
 * Check to see if delete is allowed.
 * @param board the board to check
 * @param previous the previous object
 * @param name the name of the person doing stuff
 * @return 1 if it is allowed, 0 if not
 */
int test_can_delete(string board, object previous,
                      string name) {
  int bit;

  if (member_array(base_name(previous), _allowed_objects) == -1) {
#ifdef DEBUG
    log_file("BAD_BOARD", ctime(time()) + " (write): " + base_name(previous) +
                          sprintf(" (%O)\n", this_player()));
#endif
    return 0;
  }
  bit = priv[board] & B_PRIV_TYPE_MASK;
  if (bit == B_PRIV_ACCESS_RESTRICTED_FILE) {
    return query_lord(name) ||
           member_array(base_name(previous), security[board]) != -1;
  }
  if (bit == B_PRIV_ACCESS_RESTRICTED ||
      bit == B_PRIV_READ_ONLY) {
    return query_lord(name) ||
           (member_array(name, security[board]) != -1);
  }
  if (bit == B_PRIV_ACCESS_RESTRICTED_METHOD) {
    if (query_lord(name)) {
      return 1;
    }
    // This will now need to check the method and function to call.
    if (sizeof(security[board]) == 2) {
      return call_other(security[board][1],
                        security[board][0],
                        B_ACCESS_DELETE,
                        board, previous, name);
    }
  }
  // Default, you can delete if your a lord!
  return query_lord(name);
} /* test_can_delete() */

private string query_destination_eaten_note(string  board, object previous,
                                            string name) {
  int bit;

  bit = priv[board] & B_PRIV_TYPE_MASK;
  if (bit == B_PRIV_ACCESS_RESTRICTED_METHOD) {
    // This will now need to check the method and function to call.
    if (sizeof(security[board]) == 2) {
      return call_other(security[board][1],
                        security[board][0],
                        B_ACCESS_DELETE,
                        board, previous, name);
    }
  }
  return 0;
} /* query_destination_eaten_note() */

/**
 * Get the subjects for the specifed board.  The subjects are
 * returns in a special array format.  See the include file for the
 * defines to get at the members of the array.
 * @see /include/board.h
 * @param name the board name to lookup
 * @return the subject array
 */
varargs mixed get_subjects(string name, string person) {
   string pl;
   int bit;

   if (file_name(previous_object()) == BOARD_WEB ||
       file_name(previous_object()) == "/w/ceres/cmds/test") {
      pl = person;
   } else if (this_player()) {
      pl = (string)this_player()->query_name();
   } else {
      pl = "unknown";
   }
   if (!test_can_read(name, previous_object(), pl)) {
      return ({ });
   }
   if (!boards[name] || bit) {
      return ({ });
   }
   return boards[name];
} /* get_subjects() */

/**
 * Get the text of a specific message.  This will look up the
 * text on a board with the given number and return that to the
 * caller.  The number is the offset into the subject array in
 * which to get the message from.
 * @param board the board name to get the message from
 * @param num the message number to use
 * @return the message or 0 if it failed
 */
string get_message(string board, int num, string person) {
  string name, rname;

  if (file_name(previous_object()) == BOARD_WEB) {
     name = person;
  } else  if (file_name(previous_object())[0..10] !=
              "/obj/misc/board"[0..10]) {
    name = "unknown";
  } else {
    name = (string)this_player()->query_name();
  }

  if(board == "lordboard") {
    catch(log_file("/d/admin/log/LORDBOARD", "%s read by prev %s player %s\n",
                   ctime(time()), base_name(previous_object()),
                   this_player()->query_name())); 
  }
  
  if (!test_can_read(board, previous_object(), name)) {
    return 0;
  }

  if (num < 0 || num >= sizeof(boards[board])) {
    return 0;
  }

  if(!message_cache) {
    message_cache = ([ ]);
  }

  total_reads++;

  // if it's not in the cache put it in there.
  if(message_cache[boards[board][num][B_NUM]]) {
    cache_hits++;
    return message_cache[boards[board][num][B_NUM]];
  }

  name = get_filename(board, boards[board][num][B_NUM]);
  if (file_size(name) <= 0) {
    return 0;
  }
  
  if(!clean_out && sizeof(keys(message_cache)) > CACHE_SIZE)
    clean_out = call_out("clean_cache", 10);

#ifdef USE_RAMDISK
  rname = get_ram_filename(board, boards[board][num][B_NUM]);
  if(rname != name) {
    if(file_size(rname) == -1) {
      unguarded((: cp, name, rname :));
    } else
      ram_hits++;
    name = rname;
  }
#endif
  
  if(!_ram_exists || _ram_exists == -1) {
    message_cache[boards[board][num][B_NUM]] = unguarded((: read_file, name :));
    return message_cache[boards[board][num][B_NUM]];
  } else {
    return unguarded((: read_file, name :));
  }
} /* get_message() */

void clean_cache() {
  int i;
  int count;
  int *list;
  string name;

  // prevent the cache getting too big.
  count = sizeof(keys(message_cache));
  list = sort_array(keys(message_cache), 0);
  for(i=0; i < (count - CACHE_SIZE); i++) {
    map_delete(message_cache, list[i]);
  }

  foreach(name in keys(_newsrc_cache)) {
    if(!_newsrc_cache[name]->changed &&
       _newsrc_cache[name]->cached < time() - CACHE_TIMEOUT) {
      map_delete(_newsrc_cache, name);
    }
  }

  clean_out = 0;

   foreach (name in keys(_read_access_cache)) {
      _read_access_cache[name] = ([ ]);
   }
} /* clean_cache() */

/**
 * Saves the state of the object.
 */
void save_me() {
  unguarded((: save_object, BOARD_FILE, 2 :));
} /* save_me() */

/**
 * Adds a new message onto the board.  This call can only be done from
 * verified source, like the bulletin oard objects themselves.  The
 * number used as a reply to should be the message number itself, not
 * the logical index.  If the reply_to is 0 then it is not
 * replying to anything at all.
 * @param board the board to add the message to
 * @param cap_name the name ofthe person posting
 * @param subject the subject of the message
 * @param body the main section of the text
 * @param reply_to the note the message is replying to
 * @return the note number, or 0 on failure
 */
int add_message(string board, string cap_name, string subject, string body,
                int reply_to, class reply_type bing) {
   int test;
   int irp;
   int index;
   string fname;
   string name;
   string from_mess;
   string mail_to;
   class reply_type reply;

   name = lower_case(cap_name);

   /* Check to see what should happen to the reply. */
   if (reply_to) {
      for (index = 0; index < sizeof(boards[board]); index++) {
         if (boards[board][index][B_NUM] == reply_to) {
            if (boards[board][index][B_REPLY_TYPE]) {
               // Do something special.
               reply = (class reply_type)boards[board][index][B_REPLY_TYPE];
               if (reply->type == B_REPLY_POSTER) {
                  mail_to = boards[board][index][B_NAME];
               } else if (reply->type == B_REPLY_NAMED) {
                  mail_to = reply->data;
               }
               if (mail_to) {
                  // Send mail instead.
                  MAILER->do_mail_message(mail_to,
                                          name,
                                          subject,
                                          "",
                                          body);
                  return 1;
               }
            }
         }
      }
   }

   if (!test_can_write(board, previous_object(), name)) {
      return 0;
   }

   if (!boards[board] || test) {
      return 0;
   } else {
      boards[board] += ({ ({ subject,
                                cap_name,
                                num++,
                                time(),
                                bing,
                                reply_to }) });
   }

   if (file_name(previous_object())[0..4] == "/www/") {
      from_mess = " [Web post]";
   } else {
      from_mess = "";
   }

   fname = get_filename(board, num-1);
   unguarded((: rm, fname :));
   fname = get_filename(board, num-1);

   unguarded((: write_file, fname, body :));
   save_me();

   // add this new message to the cache.
   message_cache[num-1] = body;
   // DO not update the message cache here since the num variable does not
   // actually contain the post number any more.
   // Further to this, shouldn't it be num-1 instead of num, that way it should
   // work -- Ceres.

   if (timeouts[board] && timeouts[board][T_MAX] &&
       sizeof(boards[board]) > timeouts[board][T_MAX]) {
      /* should be at most one message we eat...  */
      while (sizeof(boards[board]) > timeouts[board][T_MAX]) {
         zap_message(board, 0, 0);
         irp++;
      }
      if ((priv[board] & B_PRIV_TYPE_MASK) ==
          B_PRIV_ACCESS_RESTRICTED_METHOD) {
         // This will now need to check the method and function to call.
         if (sizeof(security[board]) == 2) {
            call_other(security[board][1],
                       security[board][0],
                       B_ACCESS_INFORM,
                       board, 0, cap_name, irp);
         }
      }
      if ( !(priv[board] & B_PRIV_NO_INFORM) ) {
         user_event( "inform",
                     sprintf( "%s posts a message to %s and %d message%s in sympathy%s",
                              cap_name, board, irp,
                              ( irp > 1 ? "s explode" : " explodes" ),
                              from_mess ),
                     "message",
                     this_player() );
      }
   } else {
      if ((priv[board] & B_PRIV_TYPE_MASK) ==
          B_PRIV_ACCESS_RESTRICTED_METHOD) {
         // This will now need to check the method and function to call.
         if (sizeof(security[board]) == 2) {
            call_other(security[board][1],
                       security[board][0],
                       B_ACCESS_INFORM,
                       board, 0, cap_name, 0);
         }
      }
      if ( !(priv[board] & B_PRIV_NO_INFORM) ) {
         user_event( "inform",
                     sprintf( "%s posts a message to %s%s",
                              cap_name, board, from_mess),
                     "message",
                     this_player() );
      }
   }
   return num-1;
} /* add_message() */

/**
 * Create a new board.
 * @param board the name of the board to create
 * @param priva is this board only allowed prviliged access?
 * @param person the person to add into the security array initialy
 * @return 0 on a failure, 1 on success
 */
int create_board(string board,
                 int priviliges,
                 string person) {
   if (boards[board]) {
      return 0;
   }
   if (!person) {
      person = this_player()->query_name();
   }
   boards[board] = ({ });
   security[board] = ({ person });
   if (priviliges) {
      priv[board] = priviliges;
   }
   save_me();
   //printf("Created board %s.\n", board);
   return 1;
} /* create_board() */

/**
 * Adds a member into the security array for a board.  This allows
 * certain people to read boards they may not normaly have
 * access to.
 * @param board the board to change the access on
 * @param name the name of the person to add to the array
 * @return 0 on failure, 1 on success
 */
int add_allowed(string board, string name) {
  string nam;
  int board_type;

  board_type = priv[board] & B_PRIV_TYPE_MASK;
  if (sscanf(file_name(previous_object()), "/obj/misc/board%s", nam) != 1) {
    return 0;
  }
  nam = (string)this_player()->query_name();
  if (!test_can_write(board, previous_object(), nam) ||
      (board_type != B_PRIV_ACCESS_RESTRICTED &&
       board_type != B_PRIV_READ_ONLY &&
       board_type != B_PRIV_ACCESS_RESTRICTED_FILE)) {
    return 0;
  }
  if (!PLAYER_HANDLER->test_user(name)) {
    return 0;
  }
  security[board] += ({ name });
  save_me();
  printf("Added %s to the security array for %s.\n",name, board);
  return 1;
} /* add_allowed() */

/**
 * Remove someone from the allowed array of the board.
 * @param board the board to remove the person from
 * @param name the name of the person to remove
 * @return 0 on nfailure and 1 on success
 */
int remove_allowed(string board, string name) {
  string nam;
  int i;
  int board_type;

  if (sscanf(file_name(previous_object()), "/obj/misc/board%s", nam) != 1) {
    return 0;
  }
  nam = geteuid(previous_object());
  board_type = priv[board] & B_PRIV_TYPE_MASK;
  if (!test_can_write(board, previous_object(), nam) ||
      (board_type != B_PRIV_ACCESS_RESTRICTED &&
       board_type != B_PRIV_READ_ONLY &&
       board_type != B_PRIV_ACCESS_RESTRICTED_FILE)) {
    return 0;
  }
  security[board] = delete(security[board], i, 1);
  save_me();
  printf("Removed %s from the security array for %s.\n", name, board);
  return 1;
} /* add_allowed() */

/**
 * This method sets the method to call to check for allowed postings
 * to a board setup as an method controlled post board.
 * @param board the name of the board to setup the method for
 * @param method the method to call on the object
 * @param name the object to call the method on
 * @return 0 if the method failed, 1 if it was successful
 */
int set_method_access_call(string board, string method, string name) {
   string pl;

   if (!boards[board] ||
       (priv[board] & B_PRIV_TYPE_MASK) != B_PRIV_ACCESS_RESTRICTED_METHOD) {
      return 0;
   }
   if (this_player()) {
      pl = (string)this_player()->query_name();
   } else {
      pl = "unknown";
   }
   if (query_lord(pl) ||
       file_name(previous_object()) == CLUB_HANDLER) {
      security[board] = ({ method, name });
      save_me();
      return 1;
   }
   return 0;
} /* set_method_access_call() */

/**
 * This method changes the type of the board to be a method access call
 * access restriction, instead of whatever it had before.
 * @param board the name of the board to control the access for
 */
int force_board_method_access_restricted(string board) {
   string pl;

   if (!boards[board]) {
      return 0;
   }
   if (this_player()) {
      pl = (string)this_player()->query_name();
   } else {
      pl = "unknown";
   }
   if (query_lord(pl) ||
       file_name(previous_object()) == CLUB_HANDLER) {
      priv[board] = (priv[board] & ~B_PRIV_TYPE_MASK) |
                    B_PRIV_ACCESS_RESTRICTED_METHOD;
      save_me();
      return 1;
   }
   return 0;
} /* force_board_method_access_restricted() */

/**
 * @ignore yes
 */
protected int zap_message(string board, int off, string name) {
  int num;
  string nam, archive;

  if (off < 0 || off >= sizeof(boards[board])) {
    return 0; /* out of range error */
  }
  num = boards[board][off][B_NUM];
  nam = get_filename(board, num);
  archive = query_archive(board);
  if (archive) {
    mixed *stuff;

    stuff = boards[board][off];
    // When we archive it, strip the colours out.
    unguarded((: write_file, archive,
               sprintf("\n----\nNote #%d by %s posted at %s\nTitle: '%s'\n\n",
                       off, stuff[B_NAME], ctime(stuff[B_TIME]),
                       stuff[B_SUBJECT])+unguarded((: read_file, nam :)) :));

    if(unguarded( (: file_size, archive :) ) > MAX_ARCHIVE_SIZE)
      unguarded((: rename, archive, archive+"."+time() :));
  }
  boards[board] = delete(boards[board],off,1);
  unguarded((: rm, nam :));
  save_me();
  return 1;
} /* zap_message() */

/**
 * Remove a message from a board.  The offset is the offset into the
 * subjects array.
 * @param board the board to remove the message from
 * @param off the offset to delete
 * @param override_name used by the web boards
 * @return 0 on failure and 1 on success
 */
int delete_message(string board, int off, string override_name) {
  string nam;

  if (file_name(previous_object()) == "/www/boards") {
    nam = override_name;
  } else {
    nam = this_player()->query_name();
  }

  if (!can_delete_message(board, off, nam)) {
    return 0;
  }

  return zap_message(board, off, nam);
} /* delete_message() */

/**
 * Check to see if the named person can delete the message.
 * @param pname the player name
 * @param board the board name
 * @param off the offset to delete
 * @see delete_message()
 */
int can_delete_message(string board, int off, string pname) {
  if (!boards[board]) {
    return 0;
  }

  if (off >= sizeof(boards[board])) {
    return 0;
  }

  if (!test_can_delete(board, previous_object(), pname) &&
      (lower_case(boards[board][off][B_NAME]) != lower_case(pname))) {
    return 0; /* not allowed to delete the notes */
  }

  return 1;
} /* can_delete_message() */

/**
 * Returns the security array for the given board.
 * @param board the board to get the security array for
 * @return the security array
 */
string *query_security(string board) {
  string *str;

  str = security[board];
  if (!str) {
    return str;
  }
  return copy(str);
} /* query_security() */

/**
 * Complete erase a board.
 * @param board the board to delete
 * @return 0 on failure and 1 on success
 */
int delete_board(string board) {
  string nam;

  if (!boards[board]) {
    return 0;
  }
  nam = geteuid(previous_object());
  if (!query_lord(nam) ||
      file_name(previous_object()) == CLUB_HANDLER) {
    return 0; /* not allowed to delete the notes */
  }
  while (sizeof(boards[board])) {
    if (!zap_message(board, 0, 0)) {
        return 0;
    }
  }
  map_delete(boards, board);
  map_delete(security, board);
  map_delete(archives, board);
  map_delete(timeouts, board);
  save_me();
  return 1;
} /* delete_board() */

/**
 * The names of all the boards.
 * @see query_boards()
 * @return the list of all the boards
 */
string *list_of_boards() {
  return keys(boards);
} /* list_of_boards() */

/**
 * Change the time before a message automatic gets deleted off a
 * board.
 * @param board the name of the board to set the timeout for
 * @param timeout the timeout (in seconds)
 * @return 0 on failure and 1 on success
 */
int set_timeout(string board, int timeout) {
  string nam;

  if (!boards[board]) {
    return 0;
  }
  nam = geteuid(previous_object());
  if (!test_can_write(board, previous_object(), nam)) {
    return 0; /* not allowed to delete the notes */
  }
  if (!timeouts[board]) {
    timeouts[board] = ({ DEFAULT_MIN, DEFAULT_MAX, timeout });
    return 1;
  }
  timeouts[board][T_TIMEOUT] = timeout;
  save_me();
  printf("Set the automagic timeout to %d days for %s.\n", timeout, board);
  return 1;
} /* set_timeout() */

/**
 * Sets the minimum number of message to keep on a board.  If there is less
 * than this
 * number then they will not be auto deleted.
 * @param board the board to set the minimum for
 * @param min the number of message to keep
 * @return 0 on failure and 1 on success
 */
int set_minimum(string board, int min) {
  string nam;

  if (!boards[board]) {
    return 0;
  }
  nam = geteuid(previous_object());
  if (!test_can_write(board, previous_object(), nam)) {
    return 0; /* not allowed to delete the notes */
  }
  if (!timeouts[board]) {
    timeouts[board] = ({ min, DEFAULT_MAX, DEFAULT_TIMEOUT });
    return 1;
  }
  timeouts[board][T_MIN] = min;
  save_me();
  printf("Set the minimum number of messages to %d for %s.\n", min, board);
  return 1;
} /* set_minimum() */

/**
 * Set the maximum number of message before they start being auto deleted
 * when someone posts to the board.
 * @param board the board to set the maximum for
 * @param max the maximum number of messages
 * @return 0 if it failed and 1 on success
 */
int set_maximum(string board, int max) {
  string nam;

  if (!boards[board]) {
    return 0;
  }
  nam = geteuid(previous_object());
  if (!test_can_write(board, previous_object(), nam)) {
    return 0; /* not allowed to delete the notes */
  }
  if (!timeouts[board]) {
    timeouts[board] = ({ DEFAULT_MIN, max, DEFAULT_TIMEOUT });
    return 1;
  }
  timeouts[board][T_MAX] = max;
  save_me();
  printf("Set the maximum number of messages to %d for %s.\n", max, board);
  return 1;
} /* set_maximum() */

/**
 * Set the archive file location.  This is where all deleted messages
 * wil be stored.
 * @param board the board to set the archive for
 * @param file the file name to set it to
 * @return 0 on failure and 1 on success
 */
int set_archive(string board, string file) {
  string nam;

  if (!boards[board]) {
    return 0;
  }
  nam = geteuid(previous_object());
  if (!test_can_write(board, previous_object(), nam)) {
    return 0; /* not allowed to delete the notes */
  }
  archives[board] = file;
  save_me();
  printf("Set the archive file to %s for %s.\n", file, board);
  return 1;
} /* set_archive() */

/**
 * Return the timeout time of the board.
 * @param board the board to get the timeout for
 * @return the timeout in seconds
 * @see set_timeout()
 */
int query_timeout(string board) {
  if (!timeouts[board]) {
    return 0;
  }
  return timeouts[board][T_TIMEOUT];
} /* query_timeout() */

/**
 * Return the minimum number of message allowed on the board.
 * @param board the board to get the minimum numbr of message for
 * @return 0 on failure, the minimum number of messages on success
 */
int query_minimum(string board) {
  if (!timeouts[board]) {
    return 0;
  }
  return timeouts[board][T_MIN];
} /* query_minimum() */

/**
 * Return the maximum number of message allowed on the board.
 * @param board the board to get the maximum numbr of message for
 * @return 0 on failure, the maximum number of messages on success
 */
int query_maximum(string board) {
  if (!timeouts[board]) {
    return 0;
  }
  return timeouts[board][T_MAX];
} /* query_maximum() */

/**
 * Return the archive file location for the board.
 * @param board the board to get the archive location for
 * @return the archive file location, 0 on failure
 */
string query_archive(string board) {
  if (!boards[board]) {
    return 0;
  }
  if (undefinedp(archives[board])) {
    return ARCHIVE_DIR+board;
  }
  return archives[board];
} /* query_archive() */

/**
 * This method checks to see if the board is in restricted access mode.
 * @param board the name of the board to check
 * @return 1 if it is, 0 if it is not
 */
int query_restricted_access(string board) {
   return (priv[board] & B_PRIV_TYPE_MASK) == B_PRIV_ACCESS_RESTRICTED;
} /* query_restricted_access() */

/**
 * This method checkes to see if the board is in restricted access file
 * mode.
 * @param board the name of the board to check
 * @return 1 if it is, 0 if it is not
 */
int query_restricted_access_file(string board) {
   return (priv[board] & B_PRIV_TYPE_MASK) == B_PRIV_ACCESS_RESTRICTED_FILE;
} /* query_restricted_access_file() */

/**
 * This method checks to see if the board is in a read only mode.
 * @param board the name of the board to check
 * @return 1 if it is read only, 0 if not
 */
int query_read_only(string board) {
  return (priv[board] & B_PRIV_TYPE_MASK) == B_PRIV_READ_ONLY;
} /* query_read_only() */

/**
 * This method checks to see if the board is in a no inform mode.
 * @param board the name of the board to check
 * @return 1 if it is no inform, 0 if not
 */
int query_no_inform(string board) {
  return priv[board] & B_PRIV_NO_INFORM;
} /* query_no_inform() */

/**
 * This method returns the current privilage level of the board in
 * question.  This should be used for testing only.
 * @return the current privilage level
 */
int query_privilage(string board) {
   return priv[board];
} /* query_privilage() */

/**
 * This method runs through all the messages and expires any which are
 * too old.
 */
void expire_boards() {
  string nam;
  int tim, num, *val;

  foreach (nam, val in timeouts) {
    num = 0;
    if ((tim = val[T_TIMEOUT]) &&
        (sizeof(boards[nam]) > val[T_MIN]) &&
        ((boards[nam][0][B_TIME]+(tim*(24*60*60))) < time())) {
          /* Got to delete some...  */
      while (sizeof(boards[nam]) > val[T_MIN] &&
             boards[nam][0][B_TIME]+(tim*24*60*60) < time()) {
        zap_message(nam, 0, 0);
        num++;
      }
      user_event( "inform", sprintf("Board handler removes %d messages "
                                       "from %s", num, nam), "message");
    }
  }
  if (find_call_out("expire_boards") == -1) {
    call_out("expire_boards", 60*60);
  }
} /* expire_boards() */

/** Prevents the object from being shadowed. */
int query_prevent_shadow() {
  return 1;
} /* query_prevent_shadow() */

/** The current max board number. */
int query_num() {
  return num;
} /* query_num() */

mixed *stats() {
  if(!total_reads)
    total_reads = 1;
  if(!cache_hits)
    cache_hits = 1;
  if(!ram_hits)
    ram_hits = 1;
  return  ({
    ({ "messages read", total_reads, }),
#ifdef USE_CACHE      
      ({ "cache hit percent", (cache_hits * 100) / total_reads, }),
#endif      
      ({ "ram hit percent", (ram_hits * 100) / total_reads, }),
      ({ "messages in cache", sizeof(keys(message_cache)), }),
      ({ "newsrc reads", _newsrc_reads, }),
      ({ "newsrc hit percent", (_newsrc_cache_hits * 100) / _newsrc_reads, }),
        ({ "newsrcs in cache", sizeof(keys(_newsrc_cache)), }),
          });
}

void query_cache() {
    printf("%O\n", sort_array(keys(message_cache), 0));
}

/** @ignore yes */
int load_newsrc(string player) {
  string fname, board;

  _newsrc_reads++;

  if(_newsrc_cache[player]) {
    _newsrc_cache_hits++;
    return 1;
  }

  fname = NEWSRC_SAVE_DIR+player[0..0]+"/"+player+ ".o";

  if(unguarded( (: file_size($(fname)) :)) > 0) {
    _newsrc_cache[player] =
      unguarded((: restore_variable(read_file($(fname))) :));
    if (arrayp(_newsrc_cache[player]->newsrc)) {
      _newsrc_cache[player]->newsrc = ([ ]);
      if (find_call_out("flush_newsrc") == -1) {
        call_out("flush_newsrc", NEWSRC_SAVE_DELAY);
      }
    }
    return 1;
  } else {
    _newsrc_cache[player] = new(class newsrc,
                                cached : time(),
                                kill : ({ }),
                                newsrc : ([ ]),
                                board_order : ({ }));
    if(PLAYER_HANDLER->test_property(player, NEWS_RC))
      _newsrc_cache[player]->newsrc =
        PLAYER_HANDLER->test_property(player, NEWS_RC);
    if(PLAYER_HANDLER->test_property(player, BOARD_ORDER))
      _newsrc_cache[player]->board_order =
        PLAYER_HANDLER->test_property(player, BOARD_ORDER);

    foreach(board in keys(boards)) {
      if(PLAYER_HANDLER->test_property(player, "news_kill_"+board)) {
        _newsrc_cache[player]->kill += ({ board });
      }
    }
    _newsrc_cache[player]->changed = time();
    if(find_call_out("flush_newsrc") == -1)
      call_out("flush_newsrc", NEWSRC_SAVE_DELAY);

    return 1;
  }

  return 0;
}

/** @ignore yes */
void flush_newsrc(int force) {
  string fname, player, board, *board_list;
  object ob;

  board_list = map(keys(boards), (: lower_case($1) :));

  foreach(player in keys(_newsrc_cache)) {
    if(!force && (!_newsrc_cache[player]->changed ||
       (_newsrc_cache[player]->changed > time() - NEWSRC_SAVE_DELAY &&
        !find_object("/obj/shut"))))
      continue;

    fname = NEWSRC_SAVE_DIR + player[0..0] + "/" + player + ".o";
    // save their file.
    if(unguarded( (: file_size($(fname)) :)) > 0) {
      _newsrc_cache[player]->newsrc =  
        filter(_newsrc_cache[player]->newsrc, 
               (: member_array(lower_case($1), $(board_list)) != -1 :));
      if(_newsrc_cache[player]->kill)
        _newsrc_cache[player]->kill =  
          filter(_newsrc_cache[player]->kill, 
                 (: member_array(lower_case($1), $(board_list)) != -1 :));
      if(_newsrc_cache[player]->board_order)
        _newsrc_cache[player]->board_order =  
          filter(_newsrc_cache[player]->board_order, 
                 (: member_array(lower_case($1), $(board_list)) != -1 :));
      
      unguarded( (: write_file($(fname), save_variable(_newsrc_cache[$(player)]),
                               1) :));
    } else if(ob = find_player(player)) {
      // if they're around and don't have a file then write a new one
      // and clear their properties.
      unguarded( (: write_file($(fname),
                               save_variable(_newsrc_cache[$(player)]), 1) :));
      ob->remove_property(NEWS_RC);
      ob->remove_property(BOARD_ORDER);
      foreach(board in keys(boards)) {
        ob->remove_property("news_kill_" + lower_case(board));
      }
    } else {
      // they're not around and they don't have a file so just update their
      // properties.
      PLAYER_HANDLER->special_add_property(player, NEWS_RC, _newsrc_cache[player]->newsrc);
    }
    _newsrc_cache[player]->changed = 0;
  }
}

/**
 * Get someones newsrc
 *
 * @param string the name of the player
 * @return mapping their newsrc
 */
mapping query_newsrc(string player) {
  if(!load_newsrc(player))
    return ([ ]);

  _newsrc_cache[player]->cached = time();

  return _newsrc_cache[player]->newsrc;
}

/**
 * Set someones newsrc
 *
 * @param string the name of the player
 * @param mapping their new newsrc
 * @return 1 for success, 0 for failure
 */
int set_newsrc(string player, mapping newsrc) {
  if(!load_newsrc(player))
    return 0;

  _newsrc_cache[player]->newsrc = (mapping)newsrc;
  _newsrc_cache[player]->cached = time();
  _newsrc_cache[player]->changed = time();

  if(find_call_out("flush_newsrc") == -1)
    call_out("flush_newsrc", NEWSRC_SAVE_DELAY);

  return 1;
}

/**
 * Find out if a given board is in a player killfile
 *
 * @param string the name of the player
 * @param string the name of the board (in lowercase)
 * @return 1 if it is, 0 if it isn't
 */
int query_killfile(string player, string board) {
  if(!load_newsrc(player))
    return 0;

  _newsrc_cache[player]->cached = time();
  return member_array(board, _newsrc_cache[player]->kill) != -1;
}

/**
 * Add a board to someones killfile
 *
 * @param string the name of the player
 * @param string the name of the board (in lowercase)
 * @return 1 for success, 0 for failure
 */
int set_killfile(string player, string board) {

  if(!load_newsrc(player))
    return 0;

  if(member_array(board, _newsrc_cache[player]->kill) != -1)
    return 1;

  _newsrc_cache[player]->kill += ({ board });
  _newsrc_cache[player]->changed = time();
  _newsrc_cache[player]->cached = time();

  if(find_call_out("flush_newsrc") == -1)
    call_out("flush_newsrc", NEWSRC_SAVE_DELAY);

  return 1;
}

int remove_killfile(string player, string board) {

  if(!load_newsrc(player))
    return 0;

  if(member_array(board, _newsrc_cache[player]->kill) == -1)
    return 1;

  _newsrc_cache[player]->kill -= ({ board });
  _newsrc_cache[player]->changed = time();
  _newsrc_cache[player]->cached = time();

  if(find_call_out("flush_newsrc") == -1)
    call_out("flush_newsrc", NEWSRC_SAVE_DELAY);

  return 1;
}

/**
 * Retrieve a players killfile list
 *
 * @param string the players name
 * @return string * the list of boards in their killfile
 */
string *list_killfile(string player) {

  if(!load_newsrc(player))
    return ({ });

  return _newsrc_cache[player]->kill;
}

/**
 * Retrieve someones chosen board order.
 *
 * @param string the players name
 * @return the list of boards, in order
 */
string *query_board_order(string player) {
  if(!load_newsrc(player))
    return ({ });

  _newsrc_cache[player]->cached = time();
  if(!_newsrc_cache[player]->board_order)
    return ({ });

  return _newsrc_cache[player]->board_order;
}

/**
 * Set the order boards should be shown in for a given player.
 *
 * @param string a players name
 * @param string * the list of boards
 * @return 1 for success, 0 for failure
 */
int set_board_order(string player, string *new_order) {

  if(!load_newsrc(player))
    return 0;

  _newsrc_cache[player]->board_order = new_order;
  _newsrc_cache[player]->changed = time();
  _newsrc_cache[player]->cached = time();

  if(find_call_out("flush_newsrc") == -1)
    call_out("flush_newsrc", NEWSRC_SAVE_DELAY);

  return 1;
}

/** @ignore yes */
void dest_me() {
  flush_newsrc(1);
  destruct(this_object());

}
// --- END [/mnt/home2/grok/lib/obj/handlers/board_handler.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/image.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/image.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628533   Available: 13575887
Inodes: Total: 5242880    Free: 4960134
3065 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/image.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628533   Available: 13575887
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*
 * image.c - handler for loading and storing 2D images.
 */

/**
 * Images can be used to efficiently store per-room area information.
 * Two current uses are for height maps (ie, third coordinate) and
 * exit maps (eg, a maze).  Along a row represents W-E (left to right),
 * and along a column represents N-S (top to bottom).  (0,0) in the image
 * corresponds to the northwestern-most room of the area.<p>
 * Currently, the only supported image type is RAW.
 */

#include <image.h>

/**
 * This method reads in the given image file, and returns a two-dimensional
 * array of integers representing the data in the file.  The 'rle'
 * flag is currently unused; in the future, it will be used to return
 * the array in a "run-length encoded" format, where each group of identical
 * elements in a row will be represented as a count/value pair.  This
 * may be more efficient for large arrays with sparse data.
 * @param image_file the pathname of the file containing the image
 * @rle optional (currently unused)
 * @return a 2-D array of ints, representing the image
 */
varargs class IMAGE_INFO load_image(string image_file, int rle) {
  int i, j, n, size_x, size_y;
  string image_type, l;
  mixed vals;
  class IMAGE_INFO ret;

  image_type = read_file(image_file, 1, 1);
  image_type = replace_string(image_type, " ", "");
  image_type = replace_string(image_type, "\n", "");
  if (image_type != "RAW") {
    error("Only image type RAW is currently supported.\n");
  }
  l = read_file(image_file, 2, 1);
  if (sscanf(l, "%d%d", size_x, size_y) != 2) {
    error("Image size(s) not found.\n");
  }
  ret = new(class IMAGE_INFO);
  ret->size = ({ size_x, size_y });
  // Read the rest of the file.
  vals = read_file(image_file, 3);
  // Take out newlines & explode into number strings
  //vals = explode(replace_string(vals, "\n", " "), " ");
  vals = reg_assoc(vals, ({ "[0-9]+" }), ({ 1 }));
  n = 0;
  while (vals[1][n] != 1) n++;
  // Save in image as ints.
  ret->image = allocate(size_x);
  // TODO: put the run-length encoding stuff in here, both on reading
  // and on storing in image.
  for (i = 0; i < size_x; i++) {
    ret->image[i] = allocate(size_y);
    for (j = 0; j < size_y; j++) {
      if (n >= sizeof(vals[0])) {
        error("Ran out of values for image at " + i + ", " + j + ".\n");
      }
      ret->image[i][j] = to_int(vals[0][n++]);
      while ((n < sizeof(vals[0])) && (vals[1][n] != 1))
        n++;
    }
  }
  return ret;
} /* load_image() */

/**
 * @ignore
 */
// Debugging function
void print_image(class IMAGE_INFO im) {
  int i, j;

  printf("size: %d x %d, %s, ", im->size[0], im->size[1],
         (im->rle?"rle":"no rle"));
  if (arrayp(im->nw_coord))
    printf("@ ({ %d, %d, %d })\n", im->nw_coord[0], im->nw_coord[1],
           im->nw_coord[2]);
  else
    printf("(not placed)\n");
  printf("Image:\n    ");
  for (i = 0; i < sizeof(im->image); i++) {
    for (j = 0; j < sizeof(im->image[i]); j++) {
      printf("% 4d", im->image[i][j]);
    }
    printf("\n    ");
  }
  printf("\n");
} /* print_image() */
// --- END [/mnt/home2/grok/lib/obj/handlers/image.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/gathering.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/gathering.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628532   Available: 13575886
Inodes: Total: 5242880    Free: 4960134
9175 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/gathering.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628532   Available: 13575886
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * Handler to handle the gathering of implicitly existing
 * objects that require some skill to find, such as herbs.
 * Recognition (ie, knowing what it is once you've found it) may be
 * added later.<p>
 * The data used for gathering comes from two places: the handler's
 * database of gatherable items, and the room's local information.<p>
 * The handler's database contains a class entry for each gatherable:<br>
 * <dl>
 * <dt> skill (string)
 * <dd> The skill needed to find the item.
 * <dt> difficulty (int)
 * <dd> The taskmaster difficulty.
 * <dt> upper (int)
 * <dd> The taskmaster "upper" parameter.
 * <dt> extra (mixed)
 * <dd> The taskmaster "extra" parameter.
 * <dt> season (string *)
 * <dd> The seasons during which the gatherable is available (eg, plants).
 * If this is unset, the default is all seasons.
 * Note that, currently, it is the same season everywhere on the Disc.
 * <dt> quant (int or function pointer returning an int)
 * <dd> The quantity that will be gathered.  The function pointer is
 * passed three parameters: the room, the player, and the name of the
 * gathered item.  This allows, for example, a function to be called
 * on the room to calculate the quantity, such as:
 * <pre><br>
 *     <code>(: $1->room_func($2, $3) :)</code>
 * </pre>
 * <dt> ob (string)
 * <dd> The pathname of the object to be created.  If the object is
 * continuous, the <i>amount</i> of ob is set to <i>quant</i>; otherwise,
 * <i>quant</i> copies of the object are cloned.
 * </dl><p>
 * The room's local information is set when the gatherable is added
 * via add_item(), and consists of:<p>
 * <dl>
 * <dt> item name (string or function pointer returning a string)
 * <dd> The name that will be used to look up the gatherable in the
 * handler's database.  The function pointer is passed two parameters
 * when evaluated: the room, and the player.
 * <dt> scarcity (int or function pointer returning an int)
 * <dd> The percent chance of finding any quantity of the gatherable.
 * This is an additional
 * constraint on finding the gatherable, in addition to any skill
 * requirements and quantity calculations.  A scarcity of 100 (the default)
 * indicates no scarcity constraint.  A scarcity of 0 means that the
 * gatherable will never be found.
 * </dl>
 * @author Jeremy
 */

#include <weather.h>
#include <tasks.h>

#define INIT_FILE "/obj/gatherables/handler.dat"

class item_data {
    string skill;          // skill needed to find this item
    int    difficulty;     // taskmaster difficulty
    string *season;        // available season(s)
    mixed  quant;          // quantity (int or (int)(:<code>:))
    string ob;             // filename of object to be created
}

mapping items = ([ ]);

void create() {
    seteuid("/secure/master"->creator_file(file_name(this_object())));
    items = "/obj/handlers/data"->compile_data(({ INIT_FILE }));
} /* create() */

/**
 * This method will return an array of the information associated with
 * the item.  The array consists of:
 * <pre>
 *   ({
 *      skill,       // skill needed to find this item   (string)
 *      difficulty,  // taskmaster difficulty            (int)
 *      season,      // available season(s)              (string *)
 *      quant,       // quantity (int or (int)(:\<code\>:)) (mixed)
 *      ob           // filename of object to be created (string)
 *    })
 * </pre>
 * @return the item array as detailed above.
 * @param name the name of the item to query
 * @see add_item()
 */
mixed query_item( string name ) {
    class item_data h;

    if (!(items[name])) {
        return 0;
    }
    h = (class item_data)items[name];
    return ({ h->skill, h->difficulty, h->season, h->quant, h->ob });
} /* query_item() */

/**
 * This method adds an item into the current list of gatherable items.
 * @param name the name of the item to add
 * @param skill skill needed to find this item
 * @param diff taskmaster difficulty
 * @param season available season(s)
 * @param quant quantity (int or function pointer returning an int)
 * @param ob filename of object to be created
 * @see query_item()
 * @see gather_item()
 */
void add_item( string name, string skill, int diff,
               string *season, mixed quant, string ob ) {
    class item_data h;

    h = new( class item_data );
    h->skill = skill;
    h->difficulty = diff;
    h->season = season;
    h->quant = quant;
    h->ob = ob;
    items[name] = h;
} /* add_item() */

/**
 * This method returns all of the current gatherable items.  It returns
 * this as a mapping of a class, so probably not overly useful except
 * for debugging.
 * @return mapping of a locally defined class
 * @see query_item()
 * @see add_item()
 */
mapping query_items() {
    return items;
} /* query_items() */

/**
 * This method attempts to gather some items in the environment of
 * the specified player.
 * @param word the item to try and gather
 * @param player the player doing the gathering
 * @return an array of gathered objects
 * @see query_item()
 * @see add_item()
 */
object *gather_item( string word, object player ) {
object *basket = ({ });              //The basket that our gathered items go into.
object *matched = ({ });             //Objects that match our word.
object item;                   //Object we are building.
mixed  *current_item;                //Data on current gatherable.
class item_data info;                //Info on the gatherable we're looking at.
string temp_name;                    //Name information.
int temp_scarcity;                   //Scarcity information.
int result;                    //Skill check for results.
int quantity;                  //Amount!

   if ( !objectp( player ) || !environment( player ) )
      return ({ });

   matched = match_objects_for_existence( word, ({ environment( player ) }) );

   if ( !sizeof( matched ) )
      return ({ });

   foreach( object temp in matched ) {
        //If it's in the room, just pick it up.
      if ( environment( temp ) == environment( player ) )
         basket += ({ temp });

       //If it's an add item, like most gatherables, we have to be more fancy.
      current_item = temp->query_gather();

        //I don't like doing it this way, I wish it was a class.
      temp_name = "";
      temp_scarcity = 0;

      //Whatever they matched isn't gatherable.
      if ( !sizeof( current_item ) )
         continue;

      if ( sizeof( current_item ) != 1 ) {
         error( "When Terano recoded this, he assumed that this array would "
            "only contain one array inside it. This turned out to be "
            "wrong.\n" );
      }

      for ( int x = 0; x < sizeof( current_item[0] ); x = x + 2 ) {
            //I don't know why this is an array, but it is.
         switch ( current_item[ 0 ][ x ] ) {
           case "item name":
           case "item_name":
                  temp_name = evaluate( current_item[ 0 ][ x+1 ],
               environment( player ), player );

              if ( !stringp( temp_name ) )
                    temp_name = 0;
                  break;
           case "scarcity":
                    temp_scarcity = evaluate(current_item[0][ x+1 ],
                  environment( player ), player, temp_name);
                    if ( !intp( temp_scarcity ) )
                        temp_scarcity = 0;
                    break;

         }
      }

      tell_creator( player, "Started to check for %s.\n", temp_name );

       if ( random( 100 ) >= temp_scarcity) {
         tell_creator( player, "Not found %s due to scarcity (%d).\n",
            temp_name, temp_scarcity );
         continue;
      }

      if (!items[temp_name]) {
         tell_creator( player, "Not found %s due to no info!\n",
            temp_name );
         continue;
        }

      info = items[ temp_name ];

      if ( sizeof( info->season ) ) {
          if (member_array( WEATHER->query_season(), info->season ) == -1) {
         tell_creator( player, "Not found %s: Out of season!\n",
            temp_name );
         continue;
        }
      }

      if ( stringp( info->skill ) && strlen( info->skill ) ) {
         result = TASKER->perform_task( player, info->skill ,info->difficulty, TM_FREE );

      switch( result ) {
         case FAIL:
         case BARF:
            tell_creator( player, "Not found %s: Skillcheck failed!\n",
               temp_name );
            continue;

         case AWARD:
            tell_object(player,
                  "%^YELLOW%^You have learned something new about gathering!%^RESET%^\n" );
         case SUCCEED:
            //We just use the result further down the line.
         }
      }

      quantity = evaluate( info->quant, environment( player ), player,
         temp_name );

      if ( !quantity || !intp( quantity ) )
         continue;

      item = clone_object( info->ob );

        if (item->query_continuous()) {
         item->set_amount( quantity );
            basket += ({ item });
        }
        else {
         item->dest_me();
         basket += allocate( quantity, (: clone_object( $(info->ob) ) :) );
      }
      continue; //Continue the foreach loop.
   }
   return basket;
} /* gather_item() */
// --- END [/mnt/home2/grok/lib/obj/handlers/gathering.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/key_handler.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/key_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628530   Available: 13575884
Inodes: Total: 5242880    Free: 4960134
7949 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/key_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628530   Available: 13575884
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*   -*- LPC -*-   */
/*
 * $Locker:  $
 * $Id: key_handler.c,v 1.2 1998/04/23 14:01:25 pinkfish Exp $
 * $Log: key_handler.c,v $
 * Revision 1.2  1998/04/23 14:01:25  pinkfish
 * Added documentation.  And cleanedup a little.
 *
 * Revision 1.1   1998/01/06 05:03:33   ceres
 * Initial revision
 * 
 */
/**
 * This handler keeps track of the keys.  The keys are arranged in
 * groups and each key type in the group has a name and a set of
 * permissions associated with it.
 * @author Deutha
 */
#define RESTORE_PATH "/save/keys/"
 
inherit "/std/object";

mapping keys;
mapping key_names;
nosave string _current_group;

/**
 * This sets up the variables with the correct statup values.
 * @param group the key ground to initialise
 */ 
private void init_data( string group ) {
   keys = ([ ]);
   key_names = ([ ]);
} /* init_data() */

/**
 * This gets all the current data for a specified key group.
 * @param group the key group to get the data for
 * @return 0 if the group was not found
 */
private int get_data_file( string group ) {
   if (_current_group == group) {
      return 1;
   }

   _current_group = group; 
   if ( file_size( RESTORE_PATH + group +".o" ) > 0 ) {
      unguarded((: restore_object, RESTORE_PATH + group :));
   } else {
      init_data( group );
      return 0;
   }
   return 1;
} /* get_data_file() */

/**
 * This method saves the data currently in memory to the specified key
 * group.
 */
private void save_data_file( ) {
   unguarded((: save_object, RESTORE_PATH + _current_group :));
} /* save_data_file() */

/**
 * This method returns all the keys in the current group.  The mapping
 * consists has an index of the key name and a value of an array of
 * key permission types.
 * @param group the key group to get permissions for
 * @return a mapping containing all the permissions
 * @see remove_key_permission()
 * @see add_key_permission()
 * @see query_key_permission()
 * @see set_key_permissions()
 * @see query_all_key_permissions()
 */
mapping query_all_keys( string group ) {
   get_data_file( group );
   return keys;
} /* query_all_keys() */

/**
 * This method should never be called.  It assumes internal knowedge.
 * Bad bad bad!
 * @ignore yes
 */
private void set_keys( string group, mapping list ) {
   get_data_file( group );
   keys = list;
   save_data_file( );
} /* set_keys() */

/**
 * This method returns all the permision types associated with the key.
 * The permission types are an array of string permision type names.  If
 * the key name is non-existant an empty array will be returned.
 * @param group the key group to lookup
 * @param key the key name to lookup
 * @return the array of permission types
 * @see remove_key_permission()
 * @see add_key_permission()
 * @see query_key_permission()
 * @see set_key_permissions()
 * @see query_all_keys()
 */
string *query_all_key_permissions( string group, string key ) {
   get_data_file( group );
   if ( !keys[ key ] ) {
      return ({ });
   }
   return keys[ key ];
} /* query_all_key_permissions() */

/**
 * This method will set the key permissions for a certain sort of
 * key.  It will overwrite any current possible key permission sets.
 * @param group the key group to set the permissions for
 * @param key the key to set the permission for
 * @param types the new set of permission types
 * @see remove_key_permission()
 * @see add_key_permission()
 * @see query_key_permission()
 * @see query_all_key_permissions()
 * @see query_all_keys()
 */
void set_key_permissions( string group, string key, string *types ) {
   get_data_file( group );
   if (sizeof(types)) {
      keys[ key ] = types;
   } else {
      map_delete(keys, key);
   }
   save_data_file( );
} /* set_key_permissions() */

/**
 * This method will see if the given key perrmision exists for this
 * key in this particular group and key.
 * @param group the key group to look up in
 * @param key the key to check
 * @param type the permission type to see if it exists
 * @return 1 if the permission exists, 0 if not
 * @see remove_key_permission()
 * @see add_key_permission()
 * @see set_key_permissions()
 * @see query_all_key_permissions()
 * @see query_all_keys()
 */
int query_key_permission( string group, string key, string type ) {
   get_data_file( group );
   if ( !keys[ key ] ) {
      return 0;
   }
   if ( member_array( type, keys[ key ] ) == -1 ) {
      return 0;
   }
   return 1;
} /* query_key_permission() */

/**
 * This method adds in a specific permission type into the current
 * permission set for this key.
 * @param group the key group to add the permision to
 * @param key the key to add the permission for
 * @param type the permission type to add in
 * @return 0 if it is already added, 1 if not
 * @see remove_key_permission()
 * @see query_key_permission()
 * @see set_key_permissions()
 * @see query_all_key_permissions()
 * @see query_all_keys()
 */
int add_key_permission( string group, string key, string type ) {
   get_data_file( group );
   if ( !keys[ key ] ) {
       keys[ key ] = ({ });
   }
   if ( member_array( type, keys[ key ] ) != -1 ) {
      return 0;
   }
   keys[ key ] += ({ type });
   save_data_file( );
   return 1;
} /* add_key_permission() */

/**
 * This method removes a specific permission type from the given
 * key group and key.
 * @param group the key group to remove the key from
 * @param key the key to remove the permission from
 * @param type the type of permission to remove
 * @return 0 if the permission was not remove, 1 if it was
 * @see add_key_permission()
 * @see query_key_permission()
 * @see set_key_permissions()
 * @see query_all_key_permissions()
 * @see query_all_keys()
 */
int remove_key_permission( string group, string key, string type ) {
   int i;

   get_data_file( group );
   if ( !keys[ key ] ) {
      return 0;
   }
   if ( ( i = member_array( type, keys[ key ] ) ) == -1 ) {
      return 0;
   }
   keys[ key ] = delete( keys[ key ], i, 1 );
   if (!sizeof(keys[key])) {
      map_delete(keys, key);
   }
   save_data_file( );
   return 1;
} /* remove_key_permission() */

/**
 * This method returns all the key names for the given key group.
 * The index of the mapping is the key type and the value is its name.
 * @param group the key group
 * @return the mapping containing the key names
 * @see delete_key_name()
 * @see set_key_name()
 * @see query_key_name()
 */
mapping query_all_key_names( string group ) {
   get_data_file( group );
   return key_names;
} /* query_all_key_names() */

private void set_key_names( string group, mapping list ) {
   get_data_file( group );
   key_names = list;
   save_data_file( );
} /* set_key_names() */

/**
 * This method returns the key name for a given key.
 * @param group the key group to lookup
 * @param key the key type to look up
 * @return the key's name
 * @see delete_key_name()
 * @see set_key_name()
 * @see query_all_key_names()
 */
string query_key_name( string group, string key ) {
   get_data_file( group );
   return key_names[ key ];
} /* query_key_name() */

/**
 * This method sets the name of the specified key.
 * @param group the group to set the name of the key in
 * @param key the type of key to set the name for
 * @param name the name of the key to set
 * @see delete_key_name()
 * @see query_key_name()
 * @see query_all_key_names()
 */
void set_key_name( string group, string key, string name ) {
   get_data_file( group );
   key_names[ key ] = name;
   save_data_file( );
} /* set_key_name() */

/**
 * This method removes a specified key name from the current key name
 * mapping.
 * @param group the group to remove the key from
 * @param key the key type to remove the name of
 * @see set_key_name()
 * @see query_key_name()
 * @see query_all_key_names()
 */
void delete_key_name( string group, string key ) {
   get_data_file( group );
   if ( !key_names[ key ] ) {
      return;
   }
   map_delete( key_names, key );
   save_data_file( );
} /* delete_key_name() */
// --- END [/mnt/home2/grok/lib/obj/handlers/key_handler.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/artifact_handler.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/artifact_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628528   Available: 13575882
Inodes: Total: 5242880    Free: 4960134
8296 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/artifact_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628528   Available: 13575882
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: artifact_handler.c,v 1.1 1998/01/06 05:03:33 ceres Exp $
 * $Log: artifact_handler.c,v $
 * Revision 1.1  1998/01/06 05:03:33  ceres
 * Initial revision
 * 
*/
/**
 * Keeps track of all the artifacts and the players known artifacts
 * arrays.
 */
#define SAVE_FILE "/save/artifacts"
#define SAVE_DIR "/save/artifacts/"

mapping artifacts;

/*
 * artifacts mapping has elements of the form:
 *    name : ({ file, max level, min level, bonus to make, value info })
 * e.g. "wand of eternal light" :
 *        ({ "/obj/wands/eternal_light", 85, 65, 250, 10000 })
 */

void create() {
   seteuid( (string)"/secure/master"->
         creator_file( file_name( this_object() ) ) );
   artifacts = ([ ]);
   if ( file_size( SAVE_FILE +".o" ) > 0 )
      unguarded( (: restore_object, SAVE_FILE :) );
} /* create() */

/**
 * This method returns the artifacts mapping.
 * The artifacts mapping has elements of the form:<br><pre><code>
 *    name : ({ file, max level, min level, bonus to make, value info })
 * e.g. "wand of eternal light" :
 *        ({ "/obj/wands/eternal_light", 85, 65, 250, 10000 })</code></pre>
 * @return the artificats mapping
 */
mapping query_artifacts() { return artifacts; }

/** Saves the current state to disk. */
void save_me() { unguarded( (: save_object, SAVE_FILE :) ); }

/**
 * Sets the entire artificats mapping.  This function should not be
 * used.  This looks rather too dangerous, commented out.
 * @param map the mapping to set it to
 *
void set_artifacts( mapping map ) {
  artifacts = map;
  save_me();
} * set_artifacts() */

/**
 * Returns the information about the named artificats.
 * @param name the artificant name to get information on
 * @return the informatioj on the artificant, 0 if the artifact does not exist
 */
int query_artifact( string name ) {
  if ( !artifacts[ name ] )
    return 0;
  return 1;
} /* query_artifact() */

/**
 * Add a new artifact into the artificat mapping. 
 * @see query_artificats()
 * @param name the name of the artifact
 * @param file the file name of the artifact
 * @param max the maximum level
 * @param min the minimum level
 * @param bonus the bonus required to make
 * @param value the value of the artifact
 */
void add_artifact( string name, string file, int max, int min, int bonus,
                   int value ) {
  artifacts[ name ] = ({ file, max, min, bonus, value });
  save_me();
} /* add_artifact() */

/**
 * Remove the artifact of the given name.
 * @param name the name of the artifiact to remove
 */
void remove_artifact( string name ) {
  if ( !artifacts[ name ] )
    return;
  artifacts = m_delete( artifacts, name );
  save_me();
} /* remove_artifact() */

/**
 * Find the file associated with the artifact.
 * @param name the name of the artifact
 * @return the file associated with the artifact
 */
string query_artifact_file( string name ) {
  if ( !artifacts[ name ] )
    return 0;
  return artifacts[ name ][ 0 ];
} /* query_artifact_file() */

/**
 * Find the maximum level associated with the artifact.
 * @param name the name of the artifact
 * @return the maximum level associated with the artifact
 */
int query_artifact_max( string name ) {
  if ( !artifacts[ name ] )    return 0;
  return artifacts[ name ][ 1 ];
} /* query_artifact_max() */

/**
 * Find the minimum level associated with the artifact.
 * @param name the name of the artifact
 * @return the minimum level associated with the artifact
 */
int query_artifact_min( string name ) {
  if ( !artifacts[ name ] )
    return 0;
  return artifacts[ name ][ 2 ];
} /* query_artifact_min() */

/**
 * Find the bonus to make associated with the artifact.
 * @param name the name of the artifact
 * @return the bonus to make associated with the artifact
 */
int query_artifact_bonus( string name ) {
  if ( !artifacts[ name ] )
    return 0;
  return artifacts[ name ][ 3 ];
} /* query_artifact_bonus() */

/**
 * Find the value associated with the artifact.
 * @param name the name of the artifact
 * @return the value associated with the artifact
 */
int query_artifact_value_info( string name ) {
  if ( !artifacts[ name ] )
    return 0;
  return artifacts[ name ][ 4 ];
} /* query_artifact_value_info() */

/**
 * Find the level of the artifact.  The level is determined as the
 * difference between the minimum and maximum artifact level squared
 * divided by the bonus passed in minus the bonus to create  plus the difference
 * between the maximum and minimum levels plus the maximum level.<br>
 * ie:<pre><code>
 * level = (((max-min) * (max-min)) / (bonus - make_bonus + max - min)) + min
 * </pre></code>
 * @param name the name of the artifact
 * @param bonus the bonus modifier
 * @return the level of the artifact
 */
int query_artifact_level( string name, int bonus ) {
  int number;

  if ( !artifacts[ name ] )
    return 0;
  number = artifacts[ name ][ 1 ] - artifacts[ name ][ 2 ];
  number *= number;
  number /= bonus - artifacts[ name ][ 3 ] + artifacts[ name ][ 1 ] -
      artifacts[ name ][ 2 ];
  number += artifacts[ name ][ 2 ];
  return number;
} /* query_artifact_level() */

/**
 * Determine the value of the artificant.  The value is determined by
 * the following equation:<br><code><pre>
 * value = (value * max) / query_artifiact_level(name, bonus)
 * </code></pre>
 * @param name the name of the artifact
 * @param bonus the bonus modifier
 * @return the value of the artifact
 */
int query_artifact_value( string name, int bonus ) {
  int number;

  if ( !artifacts[ name ] )
    return 0;
  number = artifacts[ name ][ 4 ] * artifacts[ name ][ 1 ];
  number /= query_artifact_level( name, bonus );
  return number;
} /* query_artifact_value() */

/**
 * Let a player attempt to find out what type of artifact the
 * thing is.
 * @param thing the item to diagnose
 * @param person the person doing the diagnosis
 */
void diagnose_artifact( object thing, object person, object) {
   int charges;
   string type;

   if ( !thing || !person )
      return;
   type = (string)thing->query_artifact_type();
   if ( !stringp( type ) ) {
      tell_object( person, "There doesn't seem to be anything special about "+
            (string)thing->the_short() +".\n" );
      return;
   }
   charges = (int)thing->query_charges();
   tell_object( person, (string)thing->the_short() +" is a level "+
         (int)thing->query_level() +" magic "+ type +".  It has "+
         ( charges == 1 ? "one charge" : query_num( charges ) +" charges" ) +
         " remaining.\n" );
} /* diagnose_artifact() */

/** 
 * The name of the wand.
 * @return the wand name
 */
string query_wand_name() { return "wand of artifact probing"; }

/**
 * Zap the wand!
 * @param thing the thing to zap with the wand
 * @param person the person doing the zapping
 * @param wand the wand being zapped
 */
void zap( object thing, object person, object wand ) {
  call_out( "diagnose_artifact", 0, thing, person, wand );
} /* zap() */

/**
 * A person will not forget how to recognise an artifact (unless they
 *     refresh, in which case all of them are forgotten, i.e. the file
 *     is wiped) so to let a person learn to recognise an artifact, add
 *     a new line to their file consisting of its name and to see if
 *     they know an artifact, check in their file for its name. This
 *     method doesn't require a library handler.
 * @param person the person check to see if they know the artifact
 * @param artifact the artifact being checked
 * @return 1 if they know it, 0 if they do not
 */
int query_known( string person, string artifact ) {
  int i;
  string *list;
  if ( !artifacts[ artifact ] )
    return 0;
  if ( unguarded((: file_length, SAVE_DIR + person :)) < 1 )
    return 0;
  list = explode( unguarded((: read_file, SAVE_DIR + person :)), "\n" );
  for ( i = 0; i < sizeof( list ); i++ ) {
    if ( list[ i ] == artifact )
      return 1;
  }
  return 0;
} /* query_known() */

/**
 * Place an artifact into a players known artifact list.
 * @param person the name of the person knowing the artifact
 * @param artifact the name of the artifact being know
 */
void add_known( string person, string artifact ) {
  if ( query_known( person, artifact ) )
    return;
  unguarded((: write_file, SAVE_DIR + person, artifact +"\n" :));
} /* add_known() */
// --- END [/mnt/home2/grok/lib/obj/handlers/artifact_handler.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/inherit/club_elected.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/inherit/club_elected.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628526   Available: 13575880
Inodes: Total: 5242880    Free: 4960134
67890 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/inherit/club_elected.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628526   Available: 13575880
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is the handler for all things clubby, a club being a group of
 * players.  Each club must have a unique name.  It also handles elections
 * for various club positions.
 * @author Pinkfish
 * @started Sun Sep 27 03:35:42 EDT 1998
 */
inherit "/obj/handlers/inherit/club_family";

#define __CLUBS_H_NO_CLASSES

#include <clubs.h>
#include <mail.h>
#include <board.h>
#include <player_handler.h>

// Saved!
private mapping _elections;
private string *_boards;

// Special variables to control the club inner workings.
private nosave mapping _discussion_items;

/* Defines for all the initial name indexes */
#define CLUB_PRESIDENT_INDEX          "president"
#define CLUB_VICE_PRESIDENT_INDEX     "vice-president"
#define CLUB_TREASURER_INDEX          "treasurer"
#define CLUB_SECRETARY_INDEX          "secretary"
#define CLUB_ORDINARY_COMMITTEE_INDEX "committee"

/* The prefix for the club name when making boards. */
#define CLUB_BOARD_PREFIX "club "

/*
 * Defines for the things which are called into the discussion item
 * methods to attempt to verify things and stuff.  The verify is
 * called at the start to verify the information is correct.
 * The complete is called at the end to complete the discussion
 * idea.
 */
#define CLUB_DISCUSS_MESSAGE_VERIFY            1
#define CLUB_DISCUSS_MESSAGE_COMPLETE          2
#define CLUB_DISCUSS_MESSAGE_SHORT_DESCRIPTION 3
#define CLUB_DISCUSS_MESSAGE_LONG_DESCRIPTION  4
#define CLUB_DISCUSS_MESSAGE_NOMINATION        5

// The maximum size of the archive array.
#define CLUB_MAX_ARCHIVE_SIZE 50

int is_nomination_accepted(string club_name,
                           string position,
                           string person);
int complete_election(string club_name);
int start_election(string club_name);
int holds_position_of(string name, string position, string person);
string query_position_name(string club_name,
                           string position);
int set_position_holder(string club_name,
                                  string position,
                                  string person);
protected int add_archive(string club_name,
                          string subject,
                          string thingy);
string query_club_board_name(string club_name);

/**
 * This is for an elected club, elected clubs ellect their officals and
 * stuff.  The treasurer etc are actually the indexes to be used into the
 * positions mapping to determine the actual member which holds the
 * position.
 * @member treasurer the name of the treasurer of the club's position
 * @member president the name of the president of the club's position
 * @member vice_president the name of the vice president of the club's position
 * @member secretary the name of the secretary of the club's position
 * @member account_info information about the accounts
 * @member positions the special extra positions available in the club
 * @member last_election when the last election was held
 * @member discussion the current items up for discussion
 */
class election_info {
   string treasurer;
   string president;
   string vice_president;
   string secretary;
   // Keeps a transation history.
   //class club_transaction *transactions;
   mapping account_info;
   mapping positions;
   int last_election;
   int election_period;
   mapping options;
   class discussion_idea *discussion;
   class club_archive *archives;
   string announcement;
   int announce_time;
}

#define CLUB_NOMINATION        1
#define CLUB_NOMINATION_SECOND 3
#define CLUB_ELECTION          2

/**
 * This class which keeps track of a currently running election.
 * @member time_of_event the time the election started
 * @member state the current state of the election
 * @member people the current votes for the specified person.<br>
 * The format is: ([ position : ([ person : votes, ... ]) ... ])
 * @member voted_for which positions everyone has voted for.<br>
 * The format is: ([ person : ({ position, position, ... }) ])
 * @member nominated the people who have been nominated for each position
 * and who nominated them.<br>
 * This is in the format: ([ position: ([ person : ({ nominations }) ]) ])
 * A person must be seconded before they are actually added as
 * a potential for a position.
 * @member election_status the status of the election, this is used with
 * defines.
 */
class election_data {
   int time_of_event;
   int state;
   // This is in the format: ([ position : ([ person : no_votes ]) ])
   mapping people;
   // This is in the format: ([ position: ([ person : ({ nominations }) ]) ])
   // A person must be seconded before they are actually added as
   // a potential for a position.
   mapping nominated;
   // This is in the format : ([ person : ({ position, postion, ... }) ])
   mapping voted_for;
   // This is the format: ([ position : number_to_elect ])
   string election_status;
}

/**
 * This class keeps track of the accounts, it has the transaction
 * info for the account and other stuff.
 * @member transactions the transactions for the account
 * @member allowed_people the people that can use the account
 * @member allowed_positions the positions that can use the account
 */
class account_info {
   class club_transaction* transactions;
   string* allowed_people;
   string* allowed_positions;
}

// Predefination which need to go after the classes.
private class election_info query_elected_info(string name);

void create() {
   _elections = ([ ]);
   _boards = ({ });
   ::create();
   if (!_boards) {
      _boards = ({ });
   }
} /* create() */

/** @ignore yes */
protected void create_extra_data(string name) {
   class election_info e_info;
   class club_info data;
   class club_transaction bing;
   class account_info frog;

   if (query_club_type(name)== CLUB_ELECTED) {
      data = (class club_info)query_club_info(name);
      e_info = new(class election_info);
      e_info->treasurer = CLUB_TREASURER_INDEX;
      e_info->president = CLUB_PRESIDENT_INDEX;
      e_info->vice_president = CLUB_VICE_PRESIDENT_INDEX;
      e_info->secretary = CLUB_SECRETARY_INDEX;
      e_info->discussion = ({ });
      e_info->positions = ([
                             CLUB_TREASURER_INDEX : CLUB_UNKNOWN_MEMBER,
                             CLUB_PRESIDENT_INDEX : data->founder,
                             CLUB_VICE_PRESIDENT_INDEX : CLUB_UNKNOWN_MEMBER,
                             CLUB_SECRETARY_INDEX : CLUB_UNKNOWN_MEMBER,
                           ]);

      e_info->account_info = ([ ]);
      e_info->last_election = time();
      e_info->options = ([ ]);
      e_info->election_period = CLUB_INVALID_TIME;
      e_info->announcement = "";
      e_info->archives = ({ });
      e_info->announce_time = 0;
      data->extra_data = e_info;
      set_club_changed(name);
      bing = new(class club_transaction);
      bing->date = time();
      bing->amount = query_balance(name, CLUB_DEFAULT_ACCOUNT_NAME);
      bing->transaction_type = CLUB_TRANSACTION_START_BALANCE;
      bing->who = CLUB_CONTROLLER_MEMBER;
      frog = new(class account_info);
      frog->transactions = ({ bing });
      frog->allowed_people = ({ });
      frog->allowed_positions = ({ CLUB_TREASURER_INDEX,
                                   CLUB_PRESIDENT_INDEX });
      e_info->account_info[CLUB_DEFAULT_ACCOUNT_NAME] = frog;
      set_club_changed(name);
   } else {
      ::create_extra_data(name);
   }
} /* create_extra_data() */

/**
 * This method changes the type of the club.
 * @param name the name of the club to change
 * @param type the new type of the club
 * @return 1 on success, 0 on failure
 * @see create_club()
 * @see disband_club()
 * @see query_club_type()
 * @ignore yes
 */
int change_club_type(string name, 
                     int type) {
   if (::change_club_type(name, type)) {
      start_election(name);
      return 1;
   }
   return 0;
} /* change_club_type() */

/**
 * This method disbands the club.  The club will be totaly zapped and
 * everything about it efficently munched.
 * @param name the name of the club to disband
 * @return 1 on success, 0 on failure
 * @see create_club()
 * @see check_extra_infromation()
 * @ignore yes
 */
int disband_club(string name) {
   if (::disband_club(name)) {
      map_delete(_elections, name);
      _boards -= ({ query_club_board_name(name) });
      save_main();
      return 1;
   }
   return 0;
} /* disband_club() */

/**
 * This method returns the elected info associated with the club.
 * @param name the name of the club to get the info for
 * @return the elected club class, 0 if no club or not elected type
 */
protected class election_info query_elected_info(string name) {
   class club_info data;
   class account_info fluff;

   if (is_elected_club(name)) {
      data = (class club_info)query_club_info(name);
      if (pointerp(data->extra_data->account_info)) {
         fluff = new(class account_info);
         fluff->transactions = data->extra_data->account_info;
         fluff->allowed_people = ({ });
         fluff->allowed_positions = ({ data->extra_data->president,
                                       data->extra_data->treasurer });
         data->extra_data->account_info = ([ CLUB_DEFAULT_ACCOUNT_NAME : fluff ]);
      }
      return data->extra_data;
   }
   return 0;
} /* query_elected_info() */

/**
 * This method returns the information about the specified account.
 * @param name the name of the club
 * @param account the name of the account
 * @return the account info
 */
protected class account_info query_account_info(string name, string account) {
   class election_info bing;

   bing = query_elected_info(name);
   if (bing) {
      if (!account) {
         account = CLUB_DEFAULT_ACCOUNT_NAME;
      }
      return bing->account_info[account];
   }
   return 0;
} /* query_account_info() */

/**
 * @ignore yes
 */
int remove_member(string club, string member) {
   class election_info bing;
   class account_info fluff;
   string account;
   string person;
   string position;
   string name;
   mapping nominations;
   string *people;

   if (::remove_member(club, member)) {
      bing = query_elected_info(club);
      if (bing) {
         foreach (account, fluff in bing->account_info) {
            fluff->allowed_people -= ({ member });
         }
         foreach (position, person in bing->positions) {
            if (person == member) {
               set_position_holder(club, position, CLUB_UNKNOWN_MEMBER);
            }
         }
      }
      name = normalise_name(club);
      if (_elections[name]) {
         foreach (position, nominations in _elections[name]->nominated) {
            map_delete(nominations, member);
            foreach (person, people in nominations) {
               nominations[person] = people - ({ member });
            }
         }
         foreach (position, nominations in _elections[name]->people) {
            map_delete(nominations, member);
         }
      }
      return 1;
   }
   return 0;
} /* remove_member() */

/**
 * This method returns the time of the last election.
 * @param name the name of the club to get the time for
 * @return the time of the last election
 */
int query_last_election(string name) {
   class election_info info;

   info = query_elected_info(name);
   if (info) {
      return info->last_election;
   }
   return 0;
} /* query_last_election() */

/**
 * This method returns the time of the next election.
 * @param name the name of the club to get the time for
 * @return the time of the next election
 */
int query_next_election(string name) {
   int bing;

   bing = query_last_election(name);
   if (bing) {
      return bing + CLUB_ELECTION_PERIOD;
   }
   return 0;
} /* query_next_election() */

/**
 * This method returns the minimum time between elections.
 * @param name the name of the club to get the time for
 * @return the minimum time for the next election
 */
int query_minimum_next_election(string name) {
   int bing;

   bing = query_last_election(name);
   if (bing) {
      return bing + CLUB_MINIMUM_ELECTION_PERIOD;
   }
   return 0;
} /* query_minimum_next_election() */

/**
 * This method will determine if the specified person is the president of
 * the club.
 * @param name the name of the club to check the president of
 * @param president the person to check for being the president
 * @return 1 if they are in the position, 0 if not
 */
int is_president_of(string name, string president) {
   class election_info info;

   info = query_elected_info(name);
   if (info) {
      return holds_position_of(name, info->president, president);
   }
   return 0;
} /* is_president_of() */

/**
 * This method will determine if the specified person is the vice president of
 * the club.
 * @param name the name of the club to check the vice president of
 * @param vice_president the person to check for being the vice president
 * @return 1 if they are in the position, 0 if not
 */
int is_vice_president_of(string name, string vice_president) {
   class election_info info;

   info = query_elected_info(name);
   if (info) {
      return holds_position_of(name, info->vice_president, vice_president);
   }
   return 0;
} /* is_vice_president_of() */

/**
 * This method will determine if the specified person is the secretary of
 * the club.
 * @param name the name of the club to check the secretary of
 * @param secretary the person to check to see if they are the secretary
 * @return 1 if they are in the position, 0 if not
 */
int is_secretary_of(string name, string secretary) {
   class election_info info;

   info = query_elected_info(name);
   if (info) {
      return holds_position_of(name, info->secretary, secretary);
   }
   return 0;
} /* is_secretary_of() */

/**
 * This method will determine if the specified person is the treasurer of
 * the club.
 * @param name the name of the club to check the treasurer of
 * @param treasurer the person to check to see if they are the treasurer
 * @return 1 if they are in the position, 0 if not
 */
int is_treasurer_of(string name, string treasurer) {
   class election_info info;

   info = query_elected_info(name);
   if (info) {
      return holds_position_of(name, info->treasurer, treasurer);
   }
   return 0;
} /* is_treasurer_of() */

/**
 * This method will determine if the specified person holds any 
 * position in the club.
 * @param name the name of the club to check for the positions
 * @param person the name of the person to check in the positions
 * @return 1 if they are in the position, 0 if not
 */
int holds_any_position_of(string name, string person) {
   class election_info info;
   string pos_name;
   string per_name;

   info = query_elected_info(name);
   if (info) {
      foreach (pos_name, per_name in info->positions) {
         if (per_name == person) {
            return 1;
         }
      }
   }
   return 0;
} /* holds_any_position_of() */

/**
 * This method will determine if the specified person holds a
 * position in the club.
 * @param name the name of the club to check for the position
 * @param position the name of the position to check
 * @param person the name of the person to check in the position
 * @return 1 if they are in the position, 0 if not
 * @see holds_any_position_of()
 * @see is_secretary_of()
 * @see is_president_of()
 * @see is_vice_president_of()
 * @see is_treasurer_of()
 */
int holds_position_of(string name, string position, string person) {
   class election_info info;

   info = query_elected_info(name);
   if (info) {
      position = query_position_name(name, position);
      return info->positions[position] == person;
   }
} /* holds_position_of() */

/**
 * @ignore yes
 */
int create_account(string name, string account) {
   if (!account) {
      account = CLUB_DEFAULT_ACCOUNT_NAME;
   }
   if (::create_account(name, account)) {
      class election_info info;
      class account_info frog;

      info = query_elected_info(name);
      if (info) {
         frog = new(class account_info);
         frog->transactions = ({ });
         frog->allowed_people = ({ });
         frog->allowed_positions = ({ info->president, info->treasurer });
         info->account_info[account] = frog;
         set_club_changed(name);
      }
      return 1;
   }
   return 0;
} /* create_account() */

/**
 * This method will pay a certain amount of money to club.  This will be
 * how long the club is payed until.  The club will cost a certain
 * amount for each member as well as a base cost.
 * @param name the name of the club
 * @param amount the amount to add
 * @param type the type of transaction
 * @param person the person doing the transaction
 * @param account the account being changed
 * @param information the information about the deposit
 * @return the amount of money not able to be placed in the account
 * @see remove_money()
 * @see query_balance()
 * @see query_transactions()
 */
int add_money(string name,
              int amount,
              int type,
              string person,
              string account,
              string information) {
   class account_info frog;
   class club_transaction bing;

   if (::add_money(name, amount, type, person, account)) {
      frog = query_account_info(name, account);
      if (frog) {
         bing = new(class club_transaction);
         bing->date = time();
         bing->amount = amount;
         bing->transaction_type = type;
         bing->who = person;
         bing->information = information;
         frog->transactions += ({ bing });
         set_club_changed(name);
      }
      return 1;
   }
   return 0;
} /* add_money() */

/**
 * This method removes money from the account.
 * @param name the name of the club
 * @param amount the amount to change the balance by
 * @param type the type of transaction
 * @param person the person doing the transaction
 * @param account the account being changed
 * @param information the information about the deposit
 * @return 1 if the removal is a success
 * @see pay_money()
 * @see query_balance()
 * @see query_transactions()
 */
int remove_money(string name,
                 int amount,
                 int type,
                 string person,
                 string account,
                 string information) {
   class account_info frog;
   class club_transaction bing;

   if (::remove_money(name, amount, type, person, account)) {
      frog = query_account_info(name, account);
      if (frog) {
         bing = new(class club_transaction);
         bing->date = time();
         // Make sure the amounts are correct even if they do
         // -ve values.
         bing->amount = -amount;
         bing->transaction_type = type;
         bing->who = person;
         bing->information = information;
         frog->transactions += ({ bing });
         set_club_changed(name);
      }
      return 1;
   }
   return 0;
} /* remove_money() */

/**
 * This method returns the transaction history for the club.  This will only
 * be kept track of for elected clubs.
 * @param name the name of the club
 * @param account the name of the account
 * @return the array of transactions
 * @see add_money()
 * @see remove_money()
 */
class club_transaction* query_transactions(string name, string account) {
   class account_info frog;
   class club_transaction bing;
   class club_transaction old;
   int i;

   if (is_elected_club(name)) {
      frog = query_account_info(name, account);
      if (sizeof(frog->transactions) &&
          sizeof(frog->transactions[0]) == 4) {
         for (i = 0; i < sizeof(frog->transactions); i++) {
            old = frog->transactions[i];
            bing = new(class club_transaction);
            bing->who = old->who;
            bing->transaction_type = old->transaction_type;
            bing->amount = old->amount;
            bing->date = old->date;
            bing->information = 0;
            frog->transactions[i] = bing;
            set_club_changed(name);
         }
      }
      return frog->transactions;
   }
   return ({ });
} /* query_transactions() */

/**
 * This method returns the string name of the transaction type.
 * @param type the type to return the transaction type for
 * @return the nice transaction type
 * @see query_transactions()
 */
string query_transaction_type_name(int type) {
   switch (type) {
      case CLUB_TRANSACTION_UPKEEP :
         return "upkeep";
      case CLUB_TRANSACTION_DEPOSIT :
         return "player deposit";
      case CLUB_TRANSACTION_INSIGNIA :
         return "insignia";
      case CLUB_TRANSACTION_START_BALANCE :
         return "start balance";
      case CLUB_TRANSACTION_WITHDRAWL :
         return "player withdrawl";
      case CLUB_TRANSACTION_TRANSFER :
         return "player transfer";
      default :
         return "unknown";
   }
} /* query_transaction_type_name() */

/**
 * This method returns the people which allowed to manipulate the
 * account.
 * @param club_name the name of the club
 * @param account the name of the account
 * @return the array of people which can manipulate the account
 * @see add_acount_allowed_person()
 * @see remove_account_allowed_person()
 */
string* query_account_allowed_people(string club_name, string account) {
   class account_info frog;

   frog = query_account_info(club_name, account);
   if (frog) {
      return frog->allowed_people;
   }
   return ({ });
} /* query_account_allowed_people() */

/**
 * This method checks to see if the specified person is allowed to
 * access the account.  It checks based on both position and name.
 * @param club_name the name of the club
 * @param account the name of the account
 * @param person the person's name to check
 * @return 1 if they can access the account, 0 if they cannot
 * @see query_account_allowed_people()
 * @see add_money()
 * @see remove_money()
 * @see query_account_allowed_positions()
 */
int is_allowed_to_modify_account(string club_name,
                               string account,
                               string person) {
   class account_info frog;
   string pos;

   frog = query_account_info(club_name, account);
   if (frog) {
      if (member_array(person, frog->allowed_people) != -1) {
         return 1;
      }
      foreach (pos in frog->allowed_positions) {
         if (holds_position_of(club_name, pos, person)) {
            return 1;
         }
      }
   }
   return 0;
} /* is_allowed_to_modify_account() */

/**
 * This method adds a person to the allowed people array.
 * @param club_name the name of the club
 * @param account the name of the account
 * @param person the person to add to the array
 * @see remove_acount_allowed_person()
 * @see query_account_allowed_person()
 */
int add_account_allowed_person(string club_name, string account, string person) {
   class account_info frog;

   frog = query_account_info(club_name, account);
   if (frog &&
       member_array(person, frog->allowed_people) == -1) {
      frog->allowed_people += ({ person });
      set_club_changed(club_name);
      return 1;
   }
   return 0;
} /* add_account_allowed_person() */

/**
 * This method removes a person from the allowed people array.
 * @param club_name the name of the club
 * @param account the name of the account
 * @param person the person to remove from the array
 * @see add_acount_allowed_person()
 * @see query_account_allowed_person()
 */
int remove_account_allowed_person(string club_name, string account, string person) {
   class account_info frog;

   frog = query_account_info(club_name, account);
   if (frog &&
       member_array(person, frog->allowed_people) != -1) {
      frog->allowed_people -= ({ person });
      set_club_changed(club_name);
      return 1;
   }
   return 0;
} /* remove_account_allowed_person() */

/**
 * This method returns the positions which are allowed to manipulate the
 * account.
 * @param club_name the name of the club
 * @param account the name of the account
 * @return the array of people which can manipulate the account
 */
string* query_account_allowed_positions(string club_name, string account) {
   class account_info frog;

   frog = query_account_info(club_name, account);
   if (frog) {
      return frog->allowed_positions;
   }
   return ({ });
} /* query_account_allowed_positions() */

/**
 * This method adds a position to the allowed positions array.
 * @param club_name the name of the club
 * @param account the name of the account
 * @param position the position to add to the array
 * @see remove_acount_allowed_position()
 * @see query_account_allowed_position()
 */
int add_account_allowed_position(string club_name, string account, string position) {
   class account_info frog;

   frog = query_account_info(club_name, account);
   if (frog &&
       member_array(position, frog->allowed_positions) == -1) {
      frog->allowed_positions += ({ position });
      set_club_changed(club_name);
      return 1;
   }
   return 0;
} /* add_account_allowed_position() */

/**
 * This method removes a position from the allowed positions array.
 * @param club_name the name of the club
 * @param account the name of the account
 * @param position the position to remove from the array
 * @see add_acount_allowed_position()
 * @see query_account_allowed_position()
 */
int remove_account_allowed_position(string club_name, string account, string position) {
   class account_info frog;

   frog = query_account_info(club_name, account);
   if (frog &&
       member_array(position, frog->allowed_positions) != -1) {
      frog->allowed_positions -= ({ position });
      set_club_changed(club_name);
      return 1;
   }
   return 0;
} /* remove_account_allowed_position() */

/**
 * This method sets an option in the club.  Options are use for things
 * like setting if the club has a board associated with it, or other
 * optional elements.
 * @param club_name the name of the club to set the option in
 * @param option the name of the option to set
 * @param value the new value of the option
 * @return 1 on success, 0 on failure
 * @see query_elected_option()
 * @see is_elected_option()
 */
int set_elected_option(string club_name,
                       string option,
                       mixed value) {
   class election_info data;

   data = query_elected_info(club_name);
   if (data) {
      data->options[option] = value;
      set_club_changed(club_name);
      return 1;
   }
   return 0;
} /* set_elected_option() */

/**
 * This method removes an option in the club.  Options are use for things
 * like setting if the club has a board associated with it, or other
 * optional elements.
 * @param club_name the name of the club to remove the option in
 * @param option the name of the option to remove
 * @return 1 on success, 0 on failure
 * @see query_elected_option()
 * @see is_elected_option()
 */
int remove_elected_option(string club_name,
                          string option) {
   class election_info data;

   data = query_elected_info(club_name);
   if (data) {
      map_delete(data->options, option);
      set_club_changed(club_name);
      return 1;
   }
   return 0;
} /* remove_elected_option() */

/**
 * This method queries the option in the club.
 * @param club_name the name of the club
 * @param option the name of the option to query
 * @return the value of the option
 * @see set_elected_option()
 * @see is_elected_option()
 */
mixed query_elected_option(string club_name,
                           string option) {
   class election_info data;

   data = query_elected_info(club_name);
   if (data) {
      return data->options[option];
   }
   return 0;
} /* query_elected_option() */

/**
 * This method checks to see if the specified option exists in this
 * club.
 * @param club_name the name of the club
 * @param option the name of the option to test
 * @return 1 if the option exists, 0 if not
 * @see set_elected_option()
 * @see query_elected_option()
 */
int is_elected_option(string club_name,
                      string option) {
   class election_info data;

   data = query_elected_info(club_name);
   if (data) {
      return !undefinedp(data->options[option]);
   }
   return 0;
} /* is_elected_option() */

/**
 * This method starts an election for the specified club.
 * @param club_name the name of the club to start an election for
 * @return 1 if the election is successful started
 * @see nominate_person()
 * @see finish_nominations()
 * @see vote_for_person()
 */
int start_election(string club_name) {
   string name;
   string pos;
   class election_info bing;
   string *stuff;

   name = normalise_name(club_name);
   if (is_elected_club(name)) {
      if (!_elections[name]) {
         bing = query_elected_info(name);
         _elections[name] = new(class election_data);
         _elections[name]->people = ([ ]);
         _elections[name]->nominated = ([ ]);
         _elections[name]->voted_for = ([ ]);
         _elections[name]->time_of_event = time() + CLUB_NOMINATION_TIME;
         _elections[name]->state = CLUB_NOMINATION;
         // Setup all the correct bits for the positions.
         foreach (pos, stuff in bing->positions) {
            _elections[name]->people[pos] = ([ ]);
            _elections[name]->nominated[pos] = ([ ]);
            _elections[name]->voted_for[pos] = ({ });
         }
         save_main();
         send_broadcast_message(name,
                         "An election has just started!  Nominate your "
                         "favourite person now at the club control centre.");
         return 1;
      }
   }
   return 0;
} /* start_election() */

/**
 * This method nominates someone for a certain position in the club.
 * @param club_name the name of the club to nominate someone in
 * @param position the position to nominate someone for
 * @param person the person to nominate
 * @param nominating the person doing the nominating
 * @return 1 if successfuly nominated
 * @see start_election()
 * @see finish_nomination()
 * @see vote_for_person()
 */
int nominate_person(string club_name, string position, string person,
                    string nominating) {
   string name;

   name = normalise_name(club_name);
  
   if (is_elected_club(name)) {
      if (_elections[name] &&
          (_elections[name]->state == CLUB_NOMINATION ||
           _elections[name]->state == CLUB_NOMINATION_SECOND)) {
         // Check to see if the position exists.
         position = query_position_name(club_name, position);
         if (_elections[name]->nominated[position]) {
            if (!_elections[name]->nominated[position][person]) {
                _elections[name]->nominated[position][person] = ({ });
            }
            if (member_array(nominating,
                        _elections[name]->nominated[position][person]) == -1) {
               _elections[name]->nominated[position][person] += ({ nominating });
               save_main();
               return 1;
            }
         }
      }
   }
   return 0;
} /* nominate_person() */

/**
 * This method finishes the nomination stuff.  The return will be 0 if the
 * election is not valid for this club.  If the election was valid it will
 * return an array of positions that do not have enough nominated people to
 * complete the election for.  If the return array is 0 in size then the
 * next phase of the election is setup.
 * @param club_name the name of the club to finish the nomination for
 * @return see description for return values
 * @see start_election()
 * @see nominate_person()
 * @see vote_for_person()
 */
mixed finish_nomination(string club_name) {
   string name;
   string position_name;
   mapping position_data;
   string *data;
   string person;
   string *bad_positions;
   class election_info frog;

   name = normalise_name(club_name);

   bad_positions = ({ });
   if (is_elected_club(name)) {
      frog = query_elected_info(name);
      if (_elections[name] &&
          (_elections[name]->state == CLUB_NOMINATION ||
           _elections[name]->state == CLUB_NOMINATION_SECOND)) {
         // Check to make sure we have enough nominations for every
         // position.
         foreach (position_name, 
                  position_data in _elections[name]->nominated) {
            _elections[name]->people[position_name] = ([ ]);
            foreach (person, data in position_data) {
               if (is_nomination_accepted(club_name, position_name, person)) {
                  _elections[name]->people[position_name][person] = 0;
               }
            }
            if (sizeof(_elections[name]->people[position_name]) == 0) {
               bad_positions += ({ position_name });
            }
         }
         if (!sizeof(bad_positions) ||
             _elections[name]->state == CLUB_NOMINATION_SECOND) {

            // Elect anyone in a position that only had one nomination.
            foreach (position_name, position_data in _elections[name]->people) {
               if (sizeof(position_data) == 1) {
                  // Just elect them.
                  set_position_holder(club_name,
                                      position_name,
                                      keys(position_data)[0]);
                  map_delete(_elections[name]->people, position_name);
               }
            }
            // Remove all the bad positions.
            foreach (position_name in bad_positions) {
               set_position_holder(club_name,
                                   position_name,
                                   CLUB_UNKNOWN_MEMBER);
               map_delete(_elections[name]->people, position_name);
            }

            bad_positions = ({ });

            // Set the club as elected and do it!
            _elections[name]->state = CLUB_ELECTION;
            if (!sizeof(_elections[name]->people)) {
               save_main();
               complete_election(name);
            } else {
               _elections[name]->election_status = 0;
               _elections[name]->time_of_event = time() +
                                                CLUB_ELECTION_TIME;
               set_club_changed(name);
               save_main();
               send_broadcast_message(name,
                            "The nomination period has finished.  Vote "
                            "for your favourite person for each position now "
                            "at the club control centre.");
            }
         } else {
            _elections[name]->election_status = "No one has accepted "
                           "nominations for " +
                           query_multiple_short(bad_positions);
            save_main();
         }
         return bad_positions;
      }
   }
   return 0;
} /* finish_nomination() */

/**
 * This method sets up a vote for a specific person for a position.
 * @param club_name the name of the club to make the vote in
 * @param position the position you are voting for
 * @param person the person to vote for
 * @param voter the person doing the voting
 * @return 1 on success, 0 on failure
 * @see start_election()
 * @see finish_nomination()
 * @see nominate_person()
 */
int vote_for_person(string club_name,
                    string position,
                    string person,
                    string voter) {
   string name;

   name = normalise_name(club_name);
   if (is_club(name)) {
      if (_elections[name] &&
          _elections[name]->state == CLUB_ELECTION) {
         position = query_position_name(club_name, position);
         // Make sure they have not voted for this position already.
         if (_elections[name]->voted_for[position] &&
             member_array(voter, 
                          _elections[name]->voted_for[position]) == -1) {
            // Whooo!  Lets make sure the person they are voting for is ok.
            if (!undefinedp(_elections[name]->people[position][person])) {
               _elections[name]->people[position][person]++;
               _elections[name]->voted_for[position] += ({ voter });
               save_main();
               return 1;
            }
         }
      }
   }
} /* vote_for_person() */

/**
 * This method completes the election.
 * @param club_name the name of the club the election is being completed for
 * @see start_election()
 * @see finish_nomination()
 * @see nominate_person()
 * @see vote_for_person()
 */
int complete_election(string club_name) {
   string name;
   string position;
   mapping people;
   string person_name;
   int count;
   int max_count;
   string *max_people;
   mapping elected_positions;
   int pos;
   class election_info frog;

   name = normalise_name(club_name);
   if (is_elected_club(name) &&
       _elections[name] &&
       _elections[name]->state = CLUB_ELECTION) {
      elected_positions = ([ ]);
      // Ok, we are electing happily.
      foreach (position, people in _elections[name]->people) {
         max_count = 0;
         max_people = ({ });
         if (sizeof(people) > 1) {
            foreach (person_name, count in people) {
               if (count > max_count) {
                  max_count = count;
                  max_people = ({ person_name });
               } else if (count == max_count) {
                  max_people += ({ person_name });
               }
            }
         } else {
            max_people = keys(people);
         }
         
         if (sizeof(max_people) == 0) {
           _elections[name]->election_status = "No one has voted for "
             "the position of " + position;
           // No one has voted!
           return 0;
         }
         // Ok...  Two people have the same count?  Choose a random one
         // of them.  Who will know? :)
         pos = random(sizeof(max_people));
         person_name = max_people[pos];
         elected_positions[position] = person_name;
      }

      frog = query_elected_info(name);
      // Ok, election finished.  Setup all the positions.
      foreach (position, person_name in elected_positions) {
         set_position_holder(club_name, position, person_name);
      }
      frog->last_election = time();
      set_club_changed(name);
      touch_club(name);
      map_delete(_elections, name);
      save_main();
      send_broadcast_message(name, "The election has finished!");
      return 1;
   }
   return 0;
} /* complete_election() */

/**
 * This method checks to see if there is currently an election in progress.
 * @param club_name the name of the club to check for an election
 * @return 1 if there is an election in progress, 0 if not
 * @see complete_election()
 * @see start_election()
 * @see is_nomination_in_progress()
 * @see is_voting_in_progress()
 */
int is_election_in_progress(string club) {
   string name;

   name = normalise_name(club);
   if (is_elected_club(name) &&
       _elections[name]) {
      return 1;
   }
} /* is_election_in_progress() */

/**
 * This method checks to see if the election is in the nomination phase.
 * @param club the name of the club to check
 * @see is_election_in_progress()
 * @see is_voting_in_progress()
 */
int is_nomination_in_progress(string club) {
   string name;

   name = normalise_name(club);
   if (is_elected_club(name) &&
       _elections[name] &&
       (_elections[name]->state == CLUB_NOMINATION ||
        _elections[name]->state == CLUB_NOMINATION_SECOND)) {
      return 1;
   }
} /* is_nomination_in_progress() */

/**
 * This method checks to see if the election is in the voting phase.
 * @param club the name of the club to check
 * @see is_election_in_progress()
 * @see is_nomination_in_progress()
 */
int is_voting_in_progress(string club) {
   string name;

   name = normalise_name(club);
   if (is_elected_club(name) &&
       _elections[name] &&
       _elections[name]->state == CLUB_ELECTION) {
      return 1;
   }
} /* is_voting_in_progress() */

/**
 * This method returns the list of available positions for the club.
 * @param club_name the name of the club
 * @return the list of available positions
 */
string *query_valid_positions(string club_name) {
   string name;
   class election_info frog;

   name = normalise_name(club_name);
   if (is_elected_club(name)) {
      frog = query_elected_info(club_name);
      return keys(frog->positions);
   }
   return ({ });
} /* query_valid_positions() */

/**
 * This method returns the committee of the club.  The committee is anyone
 * who holds a position.
 * @param club_name the name of the club
 * @return the array of people who hold positions
 */
string *query_committee(string club_name) {
   string name;
   class election_info frog;

   name = normalise_name(club_name);
   if (is_elected_club(name)) {
      frog = query_elected_info(club_name);
      return values(frog->positions);
   }
   return ({ });
} /* query_committee() */

/**
 * This method determines if this is a valid position for the club.
 * @param club_name the name of the club
 * @param position the position to check
 * @return 1 if the position is ok, 0 if not
 * @see query_valid_positions()
 * @see nominate_person()
 * @see vote_for_person()
 */
int is_valid_position(string club_name,
                      string position) {
   string *pos;

   pos = map(query_valid_positions(club_name), (: lower_case :));
   return (member_array(lower_case(position), pos) != -1);
} /* is_valid_position() */

/**
 * This method determines if the position is one of the 4 basic positions.
 * @param club_name the name of the club to check
 * @param position the position to check
 * @return 1 if it is, 0 if not
 * @see is_valid_position()
 */
int is_basic_position(string club_name,
                      string position) {
   class election_info frog;

   if (is_club(club_name) &&
       is_valid_position(club_name, position)) {
      frog = query_elected_info(club_name);
      position = query_position_name(club_name, position);
      return (position == frog->president) ||
             (position == frog->vice_president) ||
             (position == frog->secretary) ||
             (position == frog->treasurer);
   }
   return 0;
} /* is_basic_position() */

/**
 * This method figures out the actualy index of the position in the mappings
 * and stuff associated with the position.
 * @param club_name the name of the club
 * @param position the position to create the index for
 * @return the position index
 * @see query_valid_positions()
 * @see nominate_person()
 * @see vote_for_person()
 */
string query_position_name(string club_name,
                           string position) {
   string *pos;
   string *real_pos;
   int i;

   real_pos = query_valid_positions(club_name);
   pos = map(real_pos, (: lower_case :));
   i = member_array(lower_case(position), pos);
   if (i == -1) {
      return 0;
   }
   return real_pos[i];
} /* query_position_name() */

/**
 * This method returns the members of the particular position.
 * @param club_name the name of the club
 * @param position the name of the position
 * @return the array of members of the position
 * @see query_valid_position()
 * @see is_valid_position()
 */
string query_position_members(string club_name, string position) {
   class election_info frog;

   if (is_elected_club(club_name) &&
       is_valid_position(club_name, position)) {
      position = query_position_name(club_name, position);
      frog = query_elected_info(club_name);
      if (frog->positions[position]) {
         return frog->positions[position];
      }
   }
   return "not found";
} /* query_position_members() */

/**
 * This method creates a position in the club.
 * @param name the name of the club to create the position in
 * @param position the name of the position
 * @see query_position_members()
 * @see is_valid_position()
 * @see query_valid_positions()
 */
int create_position_in_club(string name,
                            string position) {
   class election_info frog;

   if (is_elected_club(name) &&
       !is_voting_in_progress(name) &&
       !is_valid_position(name, position)) {
      frog = query_elected_info(name);
      frog->positions[position] = CLUB_UNKNOWN_MEMBER;
      set_club_changed(name);
      if (is_nomination_in_progress(name)) {
         name = normalise_name(name);
         _elections[name]->nominated[position] = ([ ]);
         _elections[name]->voted_for[position] = ({ });
         _elections[name]->people[position] = ([ ]);
         save_main();
      }
      return 1;
   }
   return 0;
} /* create_position_in_club() */

/**
 * This method removes a position from a club.  The 4 basic positions cannot
 * be removed.
 * @param name the name of the club to remove the position from
 * @param position the position to remove
 * @return 1 on success, 0 on failure
 * @see create_position_in_club()
 */
int remove_position_in_club(string name,
                            string position) {
   class election_info frog;
   class account_info green;
   string account;

   if (is_elected_club(name) &&
       is_valid_position(name, position) &&
       !is_voting_in_progress(name) &&
       !is_basic_position(name, position)) {
      position = query_position_name(name, position);
      frog = query_elected_info(name);
      map_delete(frog->positions, position);
      set_club_changed(name);
      if (is_nomination_in_progress(name)) {
         name = normalise_name(name);
         map_delete(_elections[name]->nominated, position);
         map_delete(_elections[name]->voted_for, position);
         map_delete(_elections[name]->people, position);
         save_main();
      }
      foreach (account, green in frog->account_info) {
         green->allowed_positions -= ({ position });
      }
      send_observer_event("club_event_remove_position", 
                          name,
                          position);
      return 1;
   }
   return 0;
} /* remove_position_in_club() */

/**
 * This method changes the name of the position in the club.
 * @param name the name of the club to create the position in
 * @param position the name of the position to change
 * @param new_position the new name of the position
 * @see create_position_in_club()
 * @see is_valid_position()
 */
int change_position_name_in_club(string name,
                                 string position,
                                 string new_position) {
   class election_info frog;
   class account_info green;
   string account;
   int pos;

   if (is_elected_club(name) &&
       !is_valid_position(name, new_position) &&
       !is_voting_in_progress(name) &&
       is_valid_position(name, position)) {
      position = query_position_name(name, position);
      frog = query_elected_info(name);
      frog->positions[new_position] = frog->positions[position];
      map_delete(frog->positions, position);
      // Check to see if it is any of the special indexes.
      if (frog->president == position) {
         frog->president = new_position;
      } else if (frog->vice_president == position) {
         frog->vice_president = new_position;
      } else if (frog->secretary == position) {
         frog->secretary = new_position;
      } else if (frog->treasurer == position) {
         frog->treasurer = new_position;
      }
      set_club_changed(name);
      name = normalise_name(name);
      if (is_nomination_in_progress(name)) {
         _elections[name]->nominated[new_position] = 
                                         _elections[name]->nominated[position];
         map_delete(_elections[name]->nominated, position);
         _elections[name]->voted_for[new_position] =
                                         _elections[name]->voted_for[position];
         map_delete(_elections[name]->voted_for, position);
         _elections[name]->people[new_position] =
                                         _elections[name]->people[position];
         map_delete(_elections[name]->people, position);
         save_main();
      }
      foreach (account, green in frog->account_info) {
         pos = member_array(position, green->allowed_positions);
         if (pos != -1) {
            green->allowed_positions[pos] = new_position;
         }
      }
      send_observer_event("club_event_change_position_name", 
                          name,
                          position,
                          new_position);
      return 1;
   }
   return 0;
} /* change_position_name_in_club() */

/**
 * This method sets the specified person as the holder of the position.
 * @param club_name the name of the club to set the position in
 * @param position the name of the position
 * @param person the person who will hold it
 * @return 1 on success, 0 on failure
 */
int set_position_holder(string club_name,
                                  string position,
                                  string person) {
   class election_info info;

   info = query_elected_info(club_name);
   if (info) {
      if (is_valid_position(club_name, position)) {
         if (is_member_of(club_name, person) ||
             person == CLUB_UNKNOWN_MEMBER) {
            position = query_position_name(club_name, position);
            info->positions[position] = person;
            set_club_changed(club_name);
            send_observer_event("club_event_position_holder", 
                                club_name,
                                position,
                                person);
            return 1;
         }
      }
   }
   return 0;
} /* set_position_holder() */

/**
 * This method checks to see if the person has already voted in the election.
 * If the position is not being voted on then, then it will always assume
 * they have voted for that position.
 * @param club_name the name of the club
 * @param position the position they have voted in
 * @param person the person to check to see if they have voted
 * @return 1 if they have voted, 0 if not
 * @see is_valid_position()
 * @see vote_for_person()
 * @see has_nominated_person()
 */
int has_person_voted(string club_name,
                    string position,
                    string person) {
   string name;

   name = normalise_name(club_name);
   if (is_valid_position(club_name, position)) {
      if (_elections[name]) {
         position = query_position_name(club_name, position);
         if (_elections[name]->voted_for[position]) {
            return (member_array(person,
                              _elections[name]->voted_for[position]) != -1);
         } else {
            return 1;
         }
      }
   }
   return 0;
} /* has_person_voted() */

/**
 * This method checks to see if the person has already nominated
 * someone for this position.
 * @param club_name the name of the club
 * @param position the position they have voted in
 * @param person the person to check to see if they have voted
 * @see is_valid_position()
 * @see vote_for_person()
 * @see has_person_voted()
 */
int has_nominated_person(string club_name,
                         string position,
                         string nominated,
                         string by) {
   string name;

   name = normalise_name(club_name);
   if (is_valid_position(club_name, position)) {
      position = query_position_name(club_name, position);
      if (_elections[name] &&
          _elections[name]->nominated[position][nominated]) {
         return (member_array(by,
                      _elections[name]->nominated[position][nominated]) != -1);
      }
   }
} /* has_nominated_person() */

/**
 * This method returns the list of people that have been nominated for
 * the specified position in the specified club.
 * @param club_name the name of the club
 * @param position the position to get the names of
 * @see is_nominate_for()
 * @see nominate_person()
 */
string *query_nominated_for(string club_name,
                            string position) {
   string name;

   name = normalise_name(club_name);
   if (is_valid_position(club_name, position)) {
      if (_elections[name]) {
         position = query_position_name(club_name, position);
         if (is_voting_in_progress(club_name)) {
            if (_elections[name]->people[position]) {
               return keys(_elections[name]->people[position]);
            }
            return ({ });
         } else if (is_nomination_in_progress(club_name)) {
            return keys(_elections[name]->nominated[position]);
         }
      }
   }
   return ({ });
} /* query_nominated_for() */

/**
 * This method returns the people who nominated the specified person
 * to the position.
 * @param club_name the name of the club
 * @param position the position they were nominated for
 * @param nominated the person who was nominated
 * @return who nominated them
 * @see query_nominated_for()
 * @see is_nomination_accepted()
 */
string *query_nominators_for(string club_name,
                             string position,
                             string nominated) {
   string name;

   name = normalise_name(club_name);
   if (is_valid_position(club_name, position)) {
      if (_elections[name]) {
         position = query_position_name(club_name, position);
         if (is_nomination_in_progress(club_name) &&
            _elections[name]->nominated[position][nominated]) {
            return _elections[name]->nominated[position][nominated];
         }
      }
   }
   return ({ });
} /* query_nominators_for() */

/**
 * This method checks to see if the specified person has been nominated for
 * the position.
 * @param club_name the name of the club
 * @param position the position they have been nominated for
 * @param person the person who is nominated to that position
 * @return 1 if they have been nominated, 0 if not
 * @see has_person_voted()
 * @see nominate_person()
 * @see is_valid_position()
 * @see is_nomination_accepted()
 */
int is_nominated_for(string club_name,
                     string position,
                     string person) {
   if (is_valid_position(club_name, position)) {
      return member_array(person,
                          query_nominated_for(club_name, position)) != -1;
   }
} /* is_nominated_for() */

/**
 * This method checks to see if the nomination has been accepted.  Currently
 * a nomination is accepted if there is more than 2 people nominated and one
 * of them is the person who is nominated.
 * @param club_name the name of the club to check
 * @param position the position they are nominated for
 * @param person the person who has been nominated
 * @return 1 if they are nominated, 0 if not
 * @see is_nominated_for()
 * @see query_nominators_for()
 */
int is_nomination_accepted(string club_name,
                           string position,
                           string person) {
   string *nom;

   if (is_nominated_for(club_name, position, person)) {
      nom = query_nominators_for(club_name, position, person);
      if (sizeof(nom) > 1 &&
          member_array(person, nom) != -1) {
         return 1;
      }
   }
   return 0;
} /* is_nomination_accepted() */

/**
 * This method returns the time the next event will occur.  The next event
 * will be either the end of the nomination phase or the end of the
 * voting phase.
 * @param club_name the name of the club to get the event of
 * @return the time of the next event
 * @see complete_election()
 * @see start_election()
 * @see finish_nomination()
 */
int query_next_event_time(string club_name) {
   if (is_club(club_name)) {
      club_name = normalise_name(club_name);
      if (_elections[club_name]) {
         return _elections[club_name]->time_of_event;
      }
   }
} /* query_next_event_time() */

/**
 * This method queries the status associated with the election.  The
 * status will say things like when certain positions have not been
 * voted for and other such stuff.
 * @param club the club name to get the status of
 * @return the status string of the club
 * @see complete_election()
 * @see finish_nomination()
 */
string query_election_status(string club_name) {
   if (is_elected_club(club_name)) {
      if (is_election_in_progress(club_name)) {
         club_name = normalise_name(club_name);
         return _elections[club_name]->election_status;
      }
   }
} /* query_election_stutus() */

/**
 * This method returns the current announcement string.
 * @param club_name the name of the club
 * @return the announcement string
 */
string query_announcement(string club_name) {
   class election_info bing;

   bing = query_elected_info(club_name);
   if (bing) {
      return bing->announcement;
   }
   return "";
} /* query_announcement() */

/**
 * This method returns the time at which the current announcement
 * was added.
 * @param club_name the name of the club
 * @return the time the announcement was added
 */
int query_announcement_time(string club_name) {
   class election_info bing;

   bing = query_elected_info(club_name);
   if (bing) {
      return bing->announce_time;
   }
   return 0;
} /* query_announcement_time() */

/**
 * This sets the current announcement.
 * @param club_name the name of the club
 * @param announce the new announcement
 * @return 1 on success, 0 on failure
 */
int set_announcement(string club_name,
                     string announce) {

   class election_info bing;

   bing = query_elected_info(club_name);
   if (bing) {
      // Archive the old announcement.
      if (bing->announce_time &&
          strlen(bing->announcement)) {
         add_archive(club_name,
                     "Announcement",
                     "Announcement on " + ctime(time()) + ":\n\n" +
                     bing->announcement);
      }
      bing->announce_time = time();
      bing->announcement = announce;
      set_club_changed(club_name);
      send_broadcast_message(club_name, "A new announcement has been added.");
      return 1;
   } 
   return 0;
} /* set_announcement() */

private class club_archive* convert_archives(mixed *archives) {
   string archive;
   class club_archive bing;
   int i;

   for (i = 0; i < sizeof(archives); i++) {
      archive = archives[i];
      if (stringp(archive)) {
         bing = new(class club_archive);
         bing->archive_date = time();
         bing->subject = "unknown";
         bing->matter = archive;
         archives[i] = bing;
      }
   }
   return archives;
} /* convert_archives() */

/**
 * This method adds to the archives of things for the current club.
 * @param club_name the name of the club
 * @param thingy the thing to archive
 * @return 1 on success, 0 on failure
 */
protected int add_archive(string club_name,
                          string subject,
                          string thingy) {
   class election_info data;
   class club_archive fluff;

   data = query_elected_info(club_name);
   if (data) {
      fluff = new(class club_archive);
      fluff->subject = subject;
      fluff->matter = thingy;
      fluff->archive_date = time();
      data->archives += ({ fluff });
      if (sizeof(data->archives) > CLUB_MAX_ARCHIVE_SIZE) {
         data->archives = data->archives[<CLUB_MAX_ARCHIVE_SIZE..];
      }
      if (stringp(data->archives[0])) {
         data->archives = convert_archives(data->archives);
      }
      set_club_changed(club_name);
      return 1;
   }
   return 0;
} /* add_archive() */

/**
 * This method returns the archives for this club.
 * @param club_name the name of the club to get archives from
 * @return the archives for the club
 */
class club_archive *query_archives(string club_name) {
   class election_info data;

   data = query_elected_info(club_name);
   if (data) {
      if (sizeof(data->archives) &&
          stringp(data->archives[0])) {
         data->archives = convert_archives(data->archives);
         set_club_changed(club_name);
      }
      return data->archives;
   }
   return ({ });
} /* query_archives() */

/**
 * This method returns all the clubs which currently have boards.
 * This is their normalised names.
 * @return the list of boards
 */
string *query_boards() {
   return _boards;
} /* query_boards() */

/**
 * This method checks to see if the club has a board.
 * @param club_name the name of the club to check
 * @return 1 on success, 0 on failure
 * @see query_boards()
 */
int query_club_board(string club_name) {
   string name;

   name = query_club_board_name(club_name);
   return member_array(name, _boards) != -1;
} /* query_club_board() */

/**
 * This method returns the name of the board for the club.
 * @param club_name the name of the club to get the board for
 * @return the name of the club, 0 if no board
 */
string query_club_board_name(string club_name) {
   return CLUB_BOARD_PREFIX + normalise_name(club_name);
} /* query_club_board_name() */

/**
 * This method creates a board for the club.
 * @param club_name the name of the club to create the board for
 * @return 1 on success, 0 on failure
 * @see query_club_board()
 */
int create_club_board(string club_name) {
   string name;

   name = query_club_board_name(club_name);
   if(is_elected_club(club_name) || this_player()->query_director()) {
      // Got to be elected to have a board.
      if (BOARD_HAND->is_board(name)) {
         // It already exists.
         return 0;
      }
      BOARD_HAND->create_board(name,
                               B_PRIV_ACCESS_RESTRICTED_METHOD |
                               B_PRIV_NO_INFORM,
                               "frog");
      BOARD_HAND->set_method_access_call(name,
                                         "check_board_post",
                                         CLUB_HANDLER);
      BOARD_HAND->set_timeout(10);
      BOARD_HAND->set_maximum(60);
      BOARD_HAND->set_minimum(10);
      _boards += ({ name });
      save_main();
      return 1;
   }
   return 0;
} /* create_club_board() */

/**
 * This method removes the club's board.
 * @param club_name the name of the club to remove the board from
 * @return 1 on success, 0 on failure
 */
int remove_club_board(string club_name) {
   string name;

   if (query_club_board(club_name)) {
      name = query_club_board_name(club_name);
      BOARD_HAND->delete_board(name);
      _boards -= ({ name });
      save_main();
      return 1;
   }
} /* remove_club_board() */

/**
 * This method checks to see what access the person has to the board.
 * @param type the type of operation
 * @param board the name of the board
 * @param previous the previous object
 * @param name the name of the person reading the message
 * @param num the number of posts blasted when posting
 * @return 1 on success, 0 on failure
 */
int check_board_post(int type,
                     string board,
                     string previous,
                     string name,
                     int num) {
   string club;

   club = board[strlen(CLUB_BOARD_PREFIX)..];
   switch (type) {
   case B_ACCESS_READ :
      return is_member_of(club, name);
   case B_ACCESS_WRITE :
      return is_member_of(club, name);
   case B_ACCESS_DELETE :
      return holds_any_position_of(club, name);
   case B_ACCESS_INFORM :
      if (!num) {
         send_broadcast_message(club, 
                                name + " posts a message to the board.");
      } else {
         send_broadcast_message(club, 
                                name + " posts a message to the board and " +
                                num + " message" +
                                (num > 1?"s":"") + " explode in sympathy.");
      }
      return 1;
   }
} /* check_board_post() */

/**
 * This method will mail a messsage to the committee.  Useful for
 * informing members of problems and things.
 * @param club_name the name of the club to mail
 * @param subject the subject to use
 * @param body the body of the message
 */
protected void do_mail_committee(string club_name,
                            string subject,
                            string body) {
   string *committee;

   body += "\n\nYours,\nFindlewoodlwinks\n(Club Handler)\n";
   committee = query_committee(club_name) - ({ CLUB_UNKNOWN_MEMBER });
   if (!sizeof(committee)) {
      if (PLAYER_HANDLER->test_user(query_founder(club_name))) {
         committee = ({ query_founder(club_name) });
      } else {
         return ;
      }
   }
   // Ok, now send the mail out...
   MAILER->do_mail_message(implode(committee, ","),
                           "Patricians office",
                           subject,
                           "",
                           body);
} /* do_mail_committee() */

/**
 * This method checks the extra information for the club.  Please note
 * this does *not* save the information.  You need to do this yourself.
 * @param name the name of the club to check
 * @see check_clubs()
 */
protected void check_elected_information(string name,
                                         string member,
                                         int startup) {
   class election_info data;
   string position_name;
   string person;
   mapping gruff;
   string *nom;
   int cre_club;
   int votes;

   name = normalise_name(name);
   data = query_elected_info(name);
   if (data) {
      if (!mapp(data->options)) {
         data->options = ([ ]);
         set_club_changed(name);
      }

      foreach (position_name, person in data->positions) {
         if (person != CLUB_UNKNOWN_MEMBER &&
             (!is_member_of(name, person) ||
              !PLAYER_HANDLER->test_active(person) ||
              member == person)) {
            set_position_holder(name, position_name, CLUB_UNKNOWN_MEMBER);
         }
      }

      if (query_next_election(name) < time() ||
          _elections[name]) {
         if (!_elections[name]) {
            start_election(name);
         } else {
            switch (_elections[name]->state) {
               case CLUB_NOMINATION_SECOND :
               case CLUB_NOMINATION :
                  if (_elections[name]->time_of_event < time()) {
                     if (sizeof(finish_nomination(name))) {
                        _elections[name]->time_of_event = time() +
                                                          CLUB_ELECTION_TIME;
                        _elections[name]->state = CLUB_NOMINATION_SECOND;
                        save_main();
                     }
                  }
                  break;
               case CLUB_ELECTION :
                  if (_elections[name]->time_of_event < time()) {
                     complete_election(name);
                  }
                  break;
            }
         }
      }

      if (_elections[name] &&
          startup) {
         // Go through the votes and the nominations and remove people
         // that are not members any more or are now creators...
         cre_club = is_creator_club(name);
         foreach (position_name, gruff in _elections[name]->people) {
            foreach (person, votes in gruff) {
               if ((!cre_club &&
                    PLAYER_HANDLER->test_creator(person)) ||
                   !is_member_of(name, person) ||
                   !PLAYER_HANDLER->test_user(person)) {
                  map_delete(gruff, person);
               }
            }
         }

         foreach (position_name,
                  gruff in _elections[name]->nominated) {
            foreach (person, nom in gruff) {
               if ((!cre_club &&
                    PLAYER_HANDLER->test_creator(person)) ||
                   !is_member_of(name, person) ||
                   !PLAYER_HANDLER->test_user(person)) {
                  map_delete(gruff, person);
               }
            }
         }
      }
   }
} /* check_elected_information() */

/*
void fixup_ic() {
   class election_data frog;

   frog = new(class election_data);
   frog->state = CLUB_ELECTION;
   frog->time_of_event = time() + CLUB_ELECTION_TIME;
   frog->people = ([ "secretary" : ([ "stinine" : 0, "brighid" : 0 ]),
                     "treasurer" : ([ "magicman" : 0, "primus" : 0, "todd" : 0 ]) ]);
   frog->voted_for = ([ "secretary" : ({ }), "treasurer" : ({ }) ]);
   frog->nominated = ([ ]);
   _elections["ic" ] = frog;
   save_main();
}
 */
// --- END [/mnt/home2/grok/lib/obj/handlers/inherit/club_elected.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/inherit/craft_skills.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/inherit/craft_skills.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628509   Available: 13575863
Inodes: Total: 5242880    Free: 4960134
3491 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/inherit/craft_skills.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628509   Available: 13575863
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is an inheritable file to deal with the more dynamic nature of
 * craft skills.  So we can add in new ones without disturbing the balance
 * everything.
 * @author Pinkfish
 * @started Thu Nov 11 18:51:01 PST 1999
 */
#include <skills.h>

private string *_craft_skill_tree;

void add_craft_skill(string name);

void create() {
   _craft_skill_tree = ({ });

   add_craft_skill("crafts.smithing.gold");
   add_craft_skill("crafts.smithing.silver");
   add_craft_skill("crafts.smithing.black.tool");
   add_craft_skill("crafts.smithing.black.weapon");
   add_craft_skill("crafts.smithing.black.armour");
   add_craft_skill("crafts.smithing.gem.cutting");
   add_craft_skill("crafts.smithing.gem.polishing");
   add_craft_skill("crafts.smithing.gem.setting");
   add_craft_skill("crafts.mining.gem");
   add_craft_skill("crafts.mining.ore.panning");
   add_craft_skill("crafts.mining.mineral");
   add_craft_skill("crafts.hunting.tracking");
   add_craft_skill("crafts.hunting.fishing");
   add_craft_skill("crafts.hunting.trapping");
   add_craft_skill("crafts.carpentry.furniture");
   add_craft_skill("crafts.carpentry.coopering");
   add_craft_skill("crafts.carpentry.turning");
   add_craft_skill("crafts.carpentry.whittling");
   add_craft_skill("crafts.pottery.forming.throwing");
   add_craft_skill("crafts.pottery.forming.shaping");
   add_craft_skill("crafts.pottery.glazing");
   add_craft_skill("crafts.pottery.staining");
   add_craft_skill("crafts.pottery.firing");
   add_craft_skill("crafts.materials.leatherwork");
   add_craft_skill("crafts.materials.weaving");
   add_craft_skill("crafts.materials.spinning");
   add_craft_skill("crafts.materials.needlework");
   add_craft_skill("crafts.materials.dyeing");
   add_craft_skill("crafts.husbandry.plant.edible");
   add_craft_skill("crafts.husbandry.plant.herbal");
   add_craft_skill("crafts.husbandry.plant.milling");
   add_craft_skill("crafts.husbandry.plant.tree");
   add_craft_skill("crafts.husbandry.animal.grooming");
   add_craft_skill("crafts.husbandry.animal.breeding");
   add_craft_skill("crafts.culinary.cooking");
   add_craft_skill("crafts.culinary.baking");
   add_craft_skill("crafts.culinary.butchering");
   add_craft_skill("crafts.culinary.preserving");
   add_craft_skill("crafts.culinary.brewing");
   add_craft_skill("crafts.culinary.distilling");
   add_craft_skill("crafts.arts.design");
   add_craft_skill("crafts.arts.calligraphy");
   add_craft_skill("crafts.arts.drawing");
   add_craft_skill("crafts.arts.painting");
   add_craft_skill("crafts.arts.printing");
   add_craft_skill("crafts.arts.sculpture");
   add_craft_skill("crafts.points");
} /* create() */

private mixed *add_craft_skill_int(string *bits,
                                   mixed *arr) {
   int pos;

   pos = member_array(bits[0], arr);
   if (pos == -1) {
      pos = sizeof(arr);
      arr += ({ bits[0], 0, 0, ({ }) });
   }
   if (sizeof(bits) > 1) {
      arr[pos + SKILL_BIT] = add_craft_skill_int(bits[1..],
                                                 arr[pos + SKILL_BIT]);
   }
   return arr;
} /* add_craft_skill_int() */

private void add_craft_skill(string name) {
   string *bits;

   bits = explode(name, ".");
   _craft_skill_tree = add_craft_skill_int(bits, _craft_skill_tree);
} /* add_craft_skill() */

/**
 * This method returns the craft skill tree.
 * @return the crafts skill tree.
 */
mixed *query_crafts_skill_tree() {
   return _craft_skill_tree;
} /* query_crafts_skill_tree() */
// --- END [/mnt/home2/grok/lib/obj/handlers/inherit/craft_skills.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/inherit/citizens.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/inherit/citizens.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628508   Available: 13575862
Inodes: Total: 5242880    Free: 4960134
6520 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/inherit/citizens.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628508   Available: 13575862
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This handler keeps track of citizenships and magistrates.
 * @author Pinkfish 
 * @started Fri Jun 23 20:38:10 PDT 2000
 */
#include <player_handler.h>
#include <playtesters.h>
#include <player.h>

private mapping _magistrates;
private mapping _citizens;

int is_citizen_of(string area, string citizen);
void save_me();

void create() {
   _citizens = ([ ]);
   _magistrates = ([ ]);
} /* create() */

/**
 * This method creates an area for citizens to womble in.
 * @param area the name of the area to create
 * @param num_magistrates the number of magistrates
 * @return 1 on succes, 0 on failure
 */
int create_area(string area, int num_magistrates) {
   _citizens[area] = ({ });
   _magistrates[area] = allocate(num_magistrates);
   save_me();
} /* create_area() */

/**
 * This method returns all the areas for citizenship.
 * @return the possible areas for citizenship
 */
string* query_citizenship_areas() {
   return keys(_citizens);
} /* query_citizenship_areas() */

/**
 * This method adds a citizen to the specified area.
 * @param area the area to add the citizen too
 * @param citizen the citizen to add to the area
 */
int remove_citizen(string area, string citizen) {
   int pos;

   if (!_citizens[area]) {
      return 0;
   }

   if (member_array(citizen, _citizens[area]) != -1) {
      _citizens[area] -= ({ citizen });
      if (citizen) {
         pos = member_array(citizen, _magistrates[area]);
         if (pos != -1) {
            _magistrates[area][pos] = 0;
         }
      }
      save_me();
      return 1;
   }

   return 0;
} /* remove_citizen() */

/**
 * This method adds a magistrate to the area.  If there are no more
 * magistrate slots then this fails.
 * @param area the area to add the magistrate too
 * @param magistrate the magistrate to add
 */
int add_magistrate(string area, string magistrate) {
   int pos;

   if (!is_citizen_of(area, magistrate)) {
      return 0;
   }

   pos = member_array(0, _magistrates[area]);
   if (pos == -1) {
      return 0;
   }
   _magistrates[area][pos] = magistrate;
   save_me();
   PLAYER_TITLE_HANDLER->add_title_to_player(magistrate, "magistrate");
   return 1;
} /* add_magistrate() */

/**
 * This method sets up a new bunch of elected magistrates.
 * @param area the area to setup them up in
 * @param magistrates the new bunch to setup
 */
protected void setup_magistrates(string area, string* magistrates) {
   int i;
   int num;
   string magistrate;

   if (!_magistrates[area]) {
      return ;
   }

   for (i = 0; i < sizeof(_magistrates[area]); i++) {
      _magistrates[area][i] = 0;
   }

   num = sizeof(_magistrates[area]);
   if (num <= sizeof(magistrates)) {
      magistrates = magistrates[0..num];
   } else {
      magistrates += allocate(num - sizeof(magistrates));
   }
   _magistrates[area] = magistrates;
   save_me();
   foreach (magistrate in magistrates) {
      PLAYER_TITLE_HANDLER->add_title_to_player(magistrate, "magistrate");
   }
} /* setup_magistrates() */

/**
 * This method returns the number of magistrates needed for the area.
 * @param area the area to check the magistrates for
 * @return the number of allow\ed magistrates
 */
int query_number_of_magistrates(string area) {
   if (!_magistrates[area]) {
      return 0;
   }

   return sizeof(_magistrates[area]);
} /* query_number_of_magistrates() */

/**
 * This method returns the current magistrates for the area.
 * @param area the area to get the magistrates for
 * @return the array of the current magistrates
 */
string* query_magistrates(string area) {
   if (!_magistrates[area]) {
      return ({ });
   }

   return _magistrates[area] - ({ 0 });
} /* query_magistrates() */

/**
 * This method adds a citizen to the specified area.
 * @param area the area to add the citizen too
 * @param citizen the citizen to add to the area
 */
int add_citizen(string area, string citizen) {
   //string bing;

   if (!PLAYER_HANDLER->test_user(citizen)) {
      return 0;
   }

   if (!_citizens[area]) {
      return 0;
   }

/*
   foreach (bing in keys(_citizens)) {
      if (member_array(citizen, _citizens[bing]) != -1) {
         return 0;
      }
   }
 */

   _citizens[area] += ({ citizen });
   save_me();
   return 1;
} /* add_citizen() */

/**
 * This method checks to see if the specified person is a citizen or
 * not.
 * @param area the area to check them in
 * @param citizen the person to check for citizenship
 * @return 1 if they are a citizen, 0 if not
 */
int is_citizen_of(string area, string citizen) {
   if (!_citizens[area]) {
      return 0;
   }

/*
   if (PLAYTESTER_HAND->query_playtester(citizen)) {
      return 1;
   }
 */

   if (master()->query_lord(citizen)) {
      return 1;
   }

   return member_array(citizen, _citizens[area]) != -1;
} /* is_citizen_of() */

/**
 * This method checks to see if the specified person is a magistrate or
 * not.
 * @param area the area to check them in
 * @param magistrate the person to check for magistrateship
 * @return 1 if they are a magistrate, 0 if not
 */
int is_magistrate_of(string area, string magistrate) {
   if (!_magistrates[area]) {
      return 0;
   }

   if (master()->query_lord(magistrate)) {
      return 1;
   }

/*
   if (PLAYTESTER_HAND->query_playtester(magistrate)) {
      return 1;
   }
 */

   return member_array(magistrate, _magistrates[area]) != -1;
} /* is_magistrate_of() */

/**
 * This method checks to see if the specified person is a citizen and
 * where they are a citizen.
 * @param citizen the person to find where they are the citizen of
 * @return where they are a citizen, or 0 on failure
 */
string query_citizen(string citizen) {
   string bing;

   foreach (bing in query_citizenship_areas()) {
      if (is_citizen_of(bing, citizen)) {
         return bing;
      }
   }

   return 0;
} /* query_citizen() */

/**
 * This method checks to see if the person is a magistrate anywhere.
 * It will return 1 if they are a magistrate, 0 if they are not.
 * @param person the person to check
 * @return 1 if they are, 0 if not
 */
int is_magistrate_anywhere(string person) {
   string bing;

   foreach (bing in query_citizenship_areas()) {
      if (is_magistrate_of(bing, person)) {
         return 1;
      }
   }

   return 0;
} /* is_magistrate_anywhere() */

/**
 * This method returns the number of citizens in the given area.
 * @param area the area to lookup
 * @return the number of citizens
 */
int query_number_of_citizens(string area) {
   return sizeof(_citizens[area]);
} /* query_number_of_citizens() */
// --- END [/mnt/home2/grok/lib/obj/handlers/inherit/citizens.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/inherit/club_basic.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/inherit/club_basic.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628506   Available: 13575860
Inodes: Total: 5242880    Free: 4960134
29968 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/inherit/club_basic.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628506   Available: 13575860
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is the handler for all things clubby, a club being a group of
 * players.  Each club must have a unique name.  It also handles elections
 * for various club positions.
 * @author Pinkfish
 * @started Sun Sep 27 03:35:42 EDT 1998
 */
#include <clubs.h>
#include <broadcaster.h>
#include <player_handler.h>

/**
 * The basic club information class.
 * @member actual_name the actual name of the club
 * @member founder the founder of the club
 * @member recruiters the people who can recruit for the club
 * @member members the members of the club
 * @member type the type of the club
 * @member accounts the accounts in the club
 * @member last_paid when the balance was last paid
 * @member last_touched when the club was last touched
 * @member extra_data specific data for each type of club
 * @member region the region the club is in
 */
class club_info {
   string actual_name;
   string founder;
   string *recruiters;
   string *members;
   int type;
   mapping accounts;
   int last_paid;
   /**
    * This keeps track of when the club was last fiddled with.
    * It will be used to check the timeout stuff.
    */
   int last_touched;
   mixed extra_data;
   // Description of the club for others to enjoy.
   string description;
   string region;
}

#define CLUB_CACHE_SIZE 20

// The saved stuff...
private mapping _club_names;
private string *_observers;

// The cache stuff.
private nosave int _no_cache_hits;
private nosave int _no_cache_requests;
private nosave int _no_cache_miss;
private nosave int _cache_call_out;
private nosave mapping _cache;
private nosave string *_cache_order;

#define SAVE_FILE_NAME "/save/clubs"
#define SAVE_FILE_DIR "/save/clubs/"

protected void save_club(string name);
protected void load_main();
protected void save_main();
int is_club(string club_name);
int remove_recruiter(string name, string recruiter);
int is_recruiter_of(string name, string recruiter);
int query_club_type(string name);
void check_extra_information(string club_name, string member, int login);
int is_family(string name);
int disband_club(string name);
protected void set_club_changed(string name);
protected void send_broadcast_message(string club,
                                      string message);
protected void send_observer_event(string event_name,
                                   string *args ...);

void create() {
    seteuid(master()->creator_file(file_name()));

   _club_names = ([ ]);
   _cache = ([ ]);
   _cache_order = ({ });
   _observers = ({ });

   load_main();
} /* create() */

/** @ignore yes */
string query_cap_name() {
   return "Club controller";
} /* query_cap_name() */

/**
 * This method loads the data from the disk.
 */
protected void load_main() {
   unguarded( (: restore_object(SAVE_FILE_NAME, 1) :) );
} /* load_me() */

/**
 * This method loads the data from the disk.
 */
protected void save_main() {
   unguarded( (: save_object(SAVE_FILE_NAME, 1) :) );
} /* load_me() */

/**
 * This method normalises the name for lookups so that we don't
 * get names too confused.  Thanks to Terano for this idea.
 * @param name the name to normalise
 * @return the normalised name
 */
string normalise_name(string name) {
   return replace_string(lower_case(name), " ", "_");
} /* normalise_name() */

/**
 * Make the cache to the correct size.
 */
private void fixup_cache() {
   int i;

   if (sizeof(_cache_order) > CLUB_CACHE_SIZE) {
      for (i = sizeof(_cache_order) - CLUB_CACHE_SIZE; i >= 0; i--) {
         if (_club_names[_cache_order[i]]) {
            save_club(_cache_order[i]);
         }
         map_delete(_cache, _cache_order[i]);
      }
      _cache_order = _cache_order[sizeof(_cache_order) - CLUB_CACHE_SIZE + 1..];
   }
} /* fixup_cache() */

/**
 * This method either loads the data into the cache or it
 * reads it from the cache.
 */
protected class club_info query_club_info(string name) {
   class club_info bing;

   name = normalise_name(name);

   _no_cache_requests++;
   if (_cache[name]) {
      _no_cache_hits++;
      return _cache[name];
   }
   
   if (unguarded( (: file_size(SAVE_FILE_DIR + $(name)) :)) > 0) {
      _cache[name] = unguarded( (: restore_variable(read_file(SAVE_FILE_DIR +
                                                              $(name))) :) );
      _cache_order += ({ name });
      if (intp(_cache[name]->accounts)) {
         _cache[name]->accounts = ([ CLUB_DEFAULT_ACCOUNT_NAME : _cache[name]->accounts ]);
      }
      if (sizeof(_cache[name]) == 10) {
         bing = new(class club_info);
         bing->actual_name = _cache[name]->actual_name;
         bing->founder = _cache[name]->founder;
         bing->recruiters = _cache[name]->recruiters;
         bing->members = _cache[name]->members;
         bing->type = _cache[name]->type;
         bing->accounts = _cache[name]->accounts;
         bing->last_paid = _cache[name]->last_paid;
         bing->last_touched = _cache[name]->last_touched;
         bing->extra_data = _cache[name]->extra_data;
         bing->description = _cache[name]->description;
         bing->region = "Ankh-Morpork";
         _cache[name] = bing;
         set_club_changed(name);
      }
      fixup_cache();
      return _cache[name];
   }

   _no_cache_miss++;
   return 0;
} /* query_club_info() */

/**
 * This method saves the data to the disk.
 */
protected void save_club(string name) {
   name = normalise_name(name);
   if (_cache[name]) {
      _club_names[name] = 0;
      unguarded( (: write_file(SAVE_FILE_DIR + $(name),
                               save_variable(_cache[$(name)]),
                               1) :) );
   }
} /* save_club() */

/**
 * This method checks the cache and then saves anything changed to the
 * disk...
 */
protected void save_cache() {
   string name;
   class club_info data;

   foreach (name, data in _cache) {
      if (_club_names[name]) {
         save_club(name);
      }
   }
} /* save_cache() */

/**
 * This method marks the club as being changed.
 */
protected void set_club_changed(string name) {
   name = normalise_name(name);
   if (!undefinedp(_club_names[name])) {
      if (find_call_out(_cache_call_out) == -1) {
         _cache_call_out = call_out((: save_cache :), 0);
      }
      _club_names[name] = 1;
   }
} /* set_club_changed() */

/**
 * This method adds a club to the system.
 */
private void add_club(string name,
                      class club_info data) {
   name = normalise_name(name);
   _cache[name] = data;
   _club_names[name] = 0;
   set_club_changed(name);
} /* add_club() */

/** @ignore yes */
string the_short() {
   return "Club Control";
} /* the_short() */

protected void create_extra_data(string name) {
   class club_info data;

   data = query_club_info(name);
   data->extra_data = 0;
   set_club_changed(name);
} /* create_extra_data() */

/**
 * This method creates a club.  The founder and the recruiter set is
 * initialy set to the founder.
 * @param name the name of the club
 * @param founder the founder of the club
 * @param region the region of the club
 * @return 1 was able to create the club, 0 if unable to create the club
 * @see disband_club()
 * @see change_club_type()
 */
int create_club(string name, string founder, int type, string region) {
   class club_info info;

   if (!stringp(name) || !stringp(founder)) {
      return 0;
   }

   info = new(class club_info);
   info->actual_name = name;
   if (type != CLUB_FAMILY) {
      info->recruiters = ({ founder });
      info->members = ({ founder });
   } else {
      info->recruiters = ({ });
      info->members = ({ });
   }
   info->founder = founder;
   info->last_touched = time();
   info->type = type;
   info->last_paid = time();
   info->description = 0;
   info->accounts = ([ CLUB_DEFAULT_ACCOUNT_NAME : 0 ]);
   info->region = region;
   add_club(name, info);
   create_extra_data(name);
   set_club_changed(name);
   add_club(name, info);
   save_main();
   return 1;
} /* create_club() */

/**
 * This method changes the type of the club.
 * @param name the name of the club to change
 * @param type the new type of the club
 * @return 1 on success, 0 on failure
 * @see create_club()
 * @see disband_club()
 * @see query_club_type()
 */
int change_club_type(string name, 
                     int type) {
   int club_type;
   class club_info info;

   if (is_club(name)) {
      club_type = query_club_type(name);
      info = query_club_info(name);
      if (club_type != type) {
         info->type = (club_type & CLUB_FLAGS_MASK) | type;
         set_club_changed(name);
         create_extra_data(name);
         return 1;
      }
   }
   return 0;
} /* change_club_type() */

/**
 * This method returns the club type of the club.
 * @param name the name of the club to get the type of
 * @return the type of the club
 * @see change_club_type()
 * @see create_club()
 */
int query_club_type(string name) {
   class club_info data;

   if (is_club(name)) {
      data = query_club_info(name);
      if (!data) {
         disband_club(name);
      } else {
         return data->type & CLUB_TYPE_MASK;
      }
   }
} /* query_club_type() */

/**
 * This method makes a clubs membership secret.
 * @param name the name of the club to make secret
 * @return 1 on success, 0 on failure
 * @see query_club_secret()
 * @see reset_club_secret()
 */
int set_club_secret(string name) {
   class club_info data;

   if (is_club(name)) {
      data = query_club_info(name);
      data->type |= CLUB_SECRET_FLAG;
      set_club_changed(name);
      return 1;
   }
   return 0;
} /* set_club_secret() */

/**
 * This method makes a clubs membership open.
 * @param name the name of the club to make open
 * @return 1 on success, 0 on failure
 * @see query_club_secret()
 * @see set_club_secret()
 */
int reset_club_secret(string name) {
   class club_info data;

   if (is_club(name)) {
      data = query_club_info(name);
      data->type &= ~CLUB_SECRET_FLAG;
      set_club_changed(name);
      return 1;
   }
   return 0;
} /* reset_club_secret() */

/**
 * This method checks to see if the club is secret or not.
 * @param name the name of the club to check for secrecy
 * @return 1 if the club is secret, 0 if not
 * @see set_club_secret()
 */
int query_club_secret(string name) {
   class club_info data;

   if (is_club(name)) {
      data = query_club_info(name);
      return (data->type & CLUB_SECRET_FLAG) != 0;
   }
} /* query_club_secret() */

/**
 * This method returns the region of the club.
 * @param name the name of the club to check
 * @return the club name
 */
string query_club_region(string name) {
   class club_info data;

   if (is_club(name)) {
      data = query_club_info(name);
      return data->region;
   }
   return 0;
} /* query_club_region() */

/**
 * This method disbands the club.  The club will be totaly zapped and
 * everything about it efficently munched.
 * @param name the name of the club to disband
 * @return 1 on success, 0 on failure
 * @see create_club()
 * @see check_extra_infromation()
 */
int disband_club(string name) {
   class club_info data;

   name = normalise_name(name);
   if (is_club(name)) {
      data = query_club_info(name);
      if (data) {
         log_file("CLUB", ctime(time()) + ": disbanded '" + 
                       this_object()->query_club_name(name) + "'; balance = " +
                       this_object()->query_balance(name, CLUB_DEFAULT_ACCOUNT_NAME) + "; fees due = " +
                       ctime(this_object()->query_time_fees_due(name)) +
                       "\n");
      } else {
         log_file("CLUB", ctime(time()) + " disbanded '" + name + "' "
                          "which has a bad data file.\n");
      }
      map_delete(_club_names, name);
      map_delete(_cache, name);
      unguarded( (: rm(SAVE_FILE_DIR + $(name)) :) );
      save_main();
      send_observer_event("club_event_disband_club", name);
      return 1;
   }
   return 0;
} /* disband_club() */

/**
 * This method returns the names of all the clubs currently in the list
 * of clubs.
 * @return the list of current clubs
 * @see create_club()
 * @see disband_club()
 */
string *query_clubs() {
   return keys(_club_names);
} /* query_clubs() */

/**
 * This method returns the insignia object associated with the club.
 * @param name the name of the club for the insignia object
 * @return the path of the club insignia object
 * @see create_club()
 */
string query_insignia_path(string name) {
   return "/obj/misc/club_badge";
} /* query_insignia_path() */

/**
 * This method touches the club and resets the timeout date.  This should
 * be done now and then by the club to make sure it does not timeout.
 * @param name the name of the club to reset the timeout for
 * @see check_clubs()
 */
void touch_club(string name) {
   class club_info data;

   if (is_club(name)) {
      data = query_club_info(name);
      data->last_touched = time();
      set_club_changed(name);
   }
} /* touch_club() */

/**
 * This method returns the recruiters of the club.
 * @param name the club name to get the recruiters of
 * @return the recruiters of the club
 * @see add_recruiter()
 * @see remove_recruiter()
 */
string *query_recruiters(string name) {
   class club_info data;

   if (is_club(name)) {
      data = query_club_info(name);
      return data->recruiters;
   }
   return ({ });
} /* query_recruiters() */

/**
 * This method returns the founder of the club.
 * @param name the club name to get the founder of
 * @return the founder of the club
 * @see create_club()
 */
string query_founder(string name) {
   class club_info data;

   if (is_club(name)) {
      data = query_club_info(name);
      return data->founder;
   }
   return 0;
} /* query_founder() */

/**
 * This method returns the members of the club.
 * @param name the members of the club
 * @return the members of the club
 * @see add_member()
 * @see remove_member()
 */
string *query_members(string name) {
   class club_info data;

   if (is_club(name)) {
      data = query_club_info(name);
      return data->members;
   }
   return ({ });
} /* query_members() */

/**
 * This method adds a recruiter to the club.  A recruiter can only be added if
 * they are already a member.
 * @param name the club name to add the recruiter to
 * @param recruiter the recruiter of the club to add
 * @return 1 on success, 0 on failure
 * @see remove_recruiter()
 * @see query_recruiters()
 * @see add_member()
 */
int add_recruiter(string name, string recruiter) {
   class club_info data;

   if (is_club(name)) {
      data = query_club_info(name);
      if (member_array(recruiter, data->members) != -1 &&
          member_array(recruiter, data->recruiters) == -1) {
         data->recruiters += ({ recruiter });
         set_club_changed(name);
         touch_club(name);
         if (!is_family(name)) {
            send_broadcast_message(name,
                                   capitalize(recruiter) +
                                   " becomes a recruiter for the club.");
         }
         return 1;
      }
   }
   return 0;
} /* add_recruiter() */

/**
 * This method adds a member to the club.
 * @param name the name of the club to add the recruiter to
 * @param member the member of the club to add
 * @return 1 on success, 0 on failure
 * @see add_recruiter()
 * @see query_recruiters()
 * @see query_members()
 * @see remove_member()
 */
int add_member(string name, string member) {
   class club_info data;

   if (is_club(name)) {
      data = query_club_info(name);
      if (member_array(member, data->members) == -1) {
         data->members += ({ member });
         set_club_changed(name);
         touch_club(name);
         if (!is_family(name)) {
            send_broadcast_message(name,
                                   capitalize(member) + " joins the club.");
         }
         return 1;
      }
   }
   return 0;
} /* add_member() */

/**
 * This method removes a member from the club.
 * @param name the name of the club to remove a member from
 * @param member the members name to remove
 * @return 1 on success, 0 on failure
 * @see query_members()
 * @see add_member()
 * @see remove_member()
 */
int remove_member(string name, string member) {
   class club_info data;

   if (is_club(name)) {
      data = query_club_info(name);
      if (member_array(member, data->members) != -1) {
         if (is_recruiter_of(name, member)) {
            remove_recruiter(name, member);
         }
         data->members -= ({ member });
         set_club_changed(name);
         check_extra_information(name, member, 0);
         if (!is_family(name)) {
            send_broadcast_message(name,
                                   capitalize(member) + " leaves the club.");
         }
         send_observer_event("club_event_remove_member", name, member);
         return 1;
      }
   }
   return 0;
} /* remove_member() */

/**
 * This method removes a recruiter from the club.
 * @param name the name of the club to remove the member from
 * @param recruiter the recruiter to remove
 * @return 1 on success, 0 on failure
 * @see add_recruiter()
 * @see query_recruiters()
 * @see add_member()
 */
int remove_recruiter(string name, string recruiter) {
   class club_info data;

   if (is_club(name)) {
      data = query_club_info(name);
      if (member_array(recruiter, data->recruiters) != -1) {
         data->recruiters -= ({ recruiter });
         set_club_changed(name);
         if (!is_family(name)) {
            send_broadcast_message(name,
                                   capitalize(recruiter) +
                                   " stops being a recruiter for the club.");
         }
         return 1;
      }
   }
   return 0;
} /* remove_recruiter() */

/**
 * This method returns the capitalised and un messed name of the club.
 * @param club_name the name of the club
 * @return the un messed name of the club
 * @see is_club()
 */
string query_club_name(string club_name) {
   class club_info data;

   if (is_club(club_name)) {
      data = query_club_info(club_name);
      if (!data) {
         return club_name;
      }
      return data->actual_name;
   }
   return 0;
} /* query_club_name() */

/**
 * This method returns the description of the club.
 * @param club_name the name of the club to get the description of
 * @return the club description, 0 if the club is not found
 * @see query_club_name()
 * @see create_club()
 * @see set_club_description()
 */
string query_club_description(string club_name) {
   class club_info data;

   if (is_club(club_name)) {
      data = query_club_info(club_name);
      return data->description;
   }
   return 0;
} /* query_club_description() */

/**
 * This method sets the description of the club.
 * @param club_name the name of the club to set the description of
 * @param description the new description of the club
 * @return 1 on success, 0 on failure
 * @see query_club_description()
 * @see create_club()
 */
int set_club_description(string club_name, string description) {
   class club_info data;

   if (is_club(club_name)) {
      data = query_club_info(club_name);
      data->description = description;
      set_club_changed(club_name);
      return 1;
   }
   return 0;
} /* set_club_description() */

/**
 * This method returns the time at which the club dues are again due.
 * @param club_name the name of the club to get the date for
 * @see check_clubs()
 * @see query_club_cost_per_period()
 */
int query_time_fees_due(string club_name) {
   class club_info data;

   if (is_club(club_name)) {
      data = query_club_info(club_name);
      return data->last_paid + CLUB_PAY_PERIOD;
   }
   return 0;
} /* query_time_fees_due() */

/**
 * This method determines how much the club will cost to run each
 * pay period.
 * @param club_name the name of the club to get the fees for
 * @return the amount the club will cost in the next pay period
 * @see query_time_fees_due()
 */
int query_club_cost_per_period(string club_name) {
   if (is_club(club_name)) {
      return CLUB_COST_PER_YEAR +
           sizeof(query_members(club_name)) * CLUB_COST_PER_MEMBER_PER_YEAR;
   }
   return 0;
} /* query_club_cost_per_period() */

/**
 * This method checks to see if the specified club exists.
 * @param name the name of the club to check for existance
 * @return 1 if it is a club, 0 if not
 * @see query_club_name()
 */
int is_club(string name) {
   name = normalise_name(name);
   if (!undefinedp(_club_names[name])) {
      return 1;
   }
   return 0;
} /* is_club() */

/**
 * This method checks to see if the specified club exists and is an
 * elected club.
 * @param name the name of the club to check to see for an elected type
 * @return 1 if the club is an elected type
 */
int is_elected_club(string name) {
   name = normalise_name(name);
   if (is_club(name)) {
      return query_club_type(name) == CLUB_ELECTED;
   }
   return 0;
} /* is_elected_club() */

/**
 * This method checks to see if the specified club exists and is an
 * personal club.
 * @param name the name of the club to check to see for an personal type
 * @return 1 if the club is an personal type
 */
int is_personal_club(string name) {
   if (is_club(name)) {
      return query_club_type(name) == CLUB_PERSONAL;
   }
   return 0;
} /* is_personal_club() */

/**
 * This method checks to see if the club type is actually a family.
 * @param name the name of the family to check
 * @return 1 if the club is a family
 */
int is_family(string name) {
   if (is_club(name)) {
      return query_club_type(name) == CLUB_FAMILY;
   }
   return 0;
} /* is_family() */

/**
 * This method will determine if the specified person is a member of the
 * club.
 * @param name the name of the club to find the member of
 * @param member the member to check for the existance of
 * @return 1 if they are a member, 0 if they are not
 */
int is_member_of(string name, string member) {
   if (is_club(name)) { 
      return member_array(member, query_members(name)) != -1;
   }
   return 0;
} /* is_member_of() */

/**
 * This method will determine if the specified person is a recruiter of the
 * club.
 * @param name the name of the club to find the recruiter of
 * @param recruiter the person is check for the recruiter
 * @return 1 if they are a recruiter, 0 if they are not
 * @see add_recruiter()
 * @see remove_recruiter()
 */
int is_recruiter_of(string name, string recruiter) {
   if (is_club(name)) {
      return member_array(recruiter, query_recruiters(name)) != -1;
   }
   return 0;
} /* is_recruiter_of() */

/**
 * This method will determine if the specified person is the founder of
 * the club.
 * @param name the name of the club to check the founder of
 * @param founder the person to check for being the founder
 * @return 1 if they are in the position, 0 if not
 * @see create_club()
 */
int is_founder_of(string name, string founder) {
   name = normalise_name(name);
   if (is_club(name)) {
      return query_founder(name) == founder;
   }
   return 0;
} /* is_founder_of() */

/**
 * This method creates an account in the club.
 * @param name the name of the club
 * @param account the name of the account
 */
int create_account(string name,
                   string account) {
   class club_info data;

   if (!account) {
      account = CLUB_DEFAULT_ACCOUNT_NAME;
   }
   if (is_club(name)) {
      data = query_club_info(name);
      if (undefinedp(data->accounts[account])) {
         data->accounts[account] = 0;
         touch_club(name);
         set_club_changed(name);
         return 1;
      }
   }
   return 0;
} /* create_account() */

/**
 * This method will pay a certain amount of money to club.  This will be
 * how long the club is payed until.  The club will cost a certain
 * amount for each member as well as a base cost.
 * @param name the name of the club
 * @param amount the amount to change the balance by
 * @param type the tyope of the transaction
 * @param person the person removeing the money
 * @param account the account the money is coming from
 * @return the amount of money not able to be placed in the account
 * @see remove_money()
 * @see query_balance()
 * @see query_transactions()
 */
int add_money(string name,
              int amount,
              int type,
              string person,
              string account) {
   class club_info data;

   if (!account) {
      account = CLUB_DEFAULT_ACCOUNT_NAME;
   }
   if (is_club(name) && amount > 0) {
      data = query_club_info(name);
      if (!undefinedp(data->accounts[account])) {
         data->accounts[account] += amount;
         touch_club(name);
         set_club_changed(name);
         return 1;
      }
   }
   return 0;
} /* add_money() */

/**
 * This method removes money from the account.
 * @param name the name of the club
 * @param amount the amount to change the balance by
 * @param type the tyope of the transaction
 * @param person the person removeing the money
 * @param account the account the money is coming from
 * @return 1 if the removal is a success
 * @see pay_money()
 * @see query_balance()
 * @see query_transactions()
 */
int remove_money(string name,
                 int amount,
                 int type,
                 string person,
                 string account) {
   class club_info data;

   if (!account) {
      account = CLUB_DEFAULT_ACCOUNT_NAME;
   }
   if (is_club(name) && amount > 0) {
      data = query_club_info(name);
      if (!undefinedp(data->accounts[account])) {
         data->accounts[account] -= amount;
         touch_club(name);
         set_club_changed(name);
         return 1;
      }
   }
   return 0;
} /* remove_money() */

/**
 * This method returns the balance of the club.
 * @param name the name of the club
 * @param account the name of the account
 * @return the current balance of the club
 * @see pay_money()
 * @see remove_money()
 */
int query_balance(string name,
                  string account) {
   class club_info data;

   if (!account) {
      account = CLUB_DEFAULT_ACCOUNT_NAME;
   }
   if (is_club(name)) {
      data = query_club_info(name);
      return data->accounts[account];
   }
   return 0;
} /* query_balance() */

/**
 * This method returns the names of all the accounts in the club.
 * @param club_name the name of the club
 * @return the names of all the accounts
 */
string* query_account_names(string name) {
   class club_info data;

   if (is_club(name)) {
      data = query_club_info(name);
      if (data) {
         return keys(data->accounts);
      }
   }
   return ({ });
} /* query_account_names() */

/**
 * This method checks to see if the account exists for the club.
 * @param club_name the name of the name
 * @param account the name of the account to checlk
 * @return 1 if it exists, 0 if it does not
 */
int is_account_of(string club_name, string account) {
   return member_array(account, query_account_names(club_name)) != -1;
} /* is_account_of() */

/**
 * This method determines if the club is a creator club or not.  A
 * club is considered a creator club if the founder is a creator.
 * @param club_name
 * @return 1 if is a creator club, 0 if not
 */
int is_creator_club(string club_name) {
   if (is_club(club_name)) {
      if (PLAYER_HANDLER->test_creator(query_founder(club_name))) {
         return 1;
      }
   }
   return 0;
} /* is_creator_club() */

/**
 * This method checks to see if the specified thingy is an observer.
 * @param obs the observer to check
 * @return 1 on success, 0 on failure
 */
int is_observer(string obs) {
   if (member_array(obs, _observers) != -1) {
      return 1;
   }
   return 0;
} /* is_observer() */

/**
 * Adds an objec to the list to be informed of changes about the
 * clubs.
 * @param obs the name of the object to inform of changes
 * @return 1 on success, 0 on failure
 */
int add_observer(string obs) {
   if (!is_observer(obs) &&
       file_size(obs) > 0) {
      _observers += ({ obs });
      save_main();
      return 1;
   }
   return 0;
} /* add_observer() */

/**
 * This method removes an observer.
 * @param obs the obeserver to remove
 * @return 1 on success, 0 on failure
 */
int remove_observer(string obs) {
   if (is_observer(obs)) {
      _observers -= ({ obs });
      save_main();
      return 1;
   }
   return 0;
} /* remove_observer() */

/**
 * This method returns the current list of observers.
 * @return the current list of observers
 */
string *query_observers() {
   return _observers;
} /* query_observers() */

/**
 * This method calls a function on all the observers to tell them
 * when an event has taken place.
 * @param event_name the name of the event
 * @param args the arguments to the event
 */
protected void send_observer_event(string event_name,
                                   string *args ...) {
   string bing;

   foreach (bing in _observers) {
      if (file_size(bing) > 0) {
         call_out((: call_other($1, $2, $3 ...) :), 
                  0, 
                  event_name, 
                  bing, 
                  args ...); 
      } else {
         remove_observer(bing);
      }
   }
} /* send_observer_event() */

/**
 * This method sends a broadcast to the clubs talker channel.
 * @param club the name of the club to send the message to
 * @param mess the message to send
 */
protected void send_broadcast_message(string club,
                                      string message) {
   BROADCASTER->broadcast_to_channel(this_object(),
                                     lower_case(query_club_name(club)),
                                     ({ message, 0 }));
} /* send_club_message() */

/**
 * This method returns all the stats of the object.  Things about cache
 * hits and stuff.
 * @ignore yes
 */
mixed *stats() {
   return ({
              ({ "cache hits", _no_cache_hits }),
              ({ "cache requests", _no_cache_requests }),
              ({ "cache miss", _no_cache_miss }),
              ({ "percentage", _no_cache_hits * 100 / _no_cache_requests }),
           });
} /* stats() */
// --- END [/mnt/home2/grok/lib/obj/handlers/inherit/club_basic.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/inherit/case_control.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/inherit/case_control.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628498   Available: 13575852
Inodes: Total: 5242880    Free: 4960134
13251 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/inherit/case_control.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628498   Available: 13575852
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is the system for case control.  It keeps tracks of all the current
 * open cases in the area and any modifications that are done to them.
 * @author Pinkfish
 * @started Tue Jul 11 18:09:01 PDT 2000
 */
#define NOMIC_SYSTEM_NO_CLASSES
#define NOMIC_SYSTEM_CASE_CLASSES
#include <nomic_system.h>

private mapping _open_cases;
private mapping _recently_closed_cases;
private mapping _closed_cases;
private int _next_case_id;
private int _next_note_id;

void save_me();
void send_council_inform(string area, int only_magistrates,
                         string mess);

void create() {
   _open_cases = ([ ]);
   _closed_cases = ([ ]);
   _recently_closed_cases = ([ ]);
   _next_case_id = 1;
   _next_note_id = 1;
} /* create() */

/**
 * This method creates an area.
 * @param area the name of the area to create
 */
void create_area(string area) {
   if (_open_cases[area]) {
      return ;
   }
   _open_cases[area] = ({ });
   _closed_cases[area] = ({ });
   _recently_closed_cases[area] = ({ });
} /* create_area() */

/**
 * This returns the cases which are currently open.
 * @param area the are to get the cases in
 * @return the list of opened cases
 */
int* query_open_cases(string area) {
   return _open_cases[area];
} /* query_open_cases() */

/**
 * This method returns the cases which are currently closed.
 * @param area the area to get the cases in
 * @return the list of closed cases
 */
int* query_closed_cases(string area) {
   return _closed_cases[area];
} /* query_closed_cases() */

/**
 * This method returns the set of recently closed cases.  These are
 * cases that can be appealed.
 * @param area the area to get the cases in
 * @return the list of recently closed cases
 */
int* query_recently_closed_cases(string area) {
   return _recently_closed_cases[area];
} /* query_recently_closed_cases() */

/**
 * This method returns the file name for the case given the id.
 * @param id the id to return
 * @return the file name
 */
string query_case_file_name(int id) {
   return NOMIC_CASE_SAVE + sprintf("cases/%02d/%d_case", id % 20, id);
} /* query_case_file_name() */

/**
 * This method finds the next case id.
 * @return the next case id
 */
int query_next_case_id() {
   int next;

   do {
      next = _next_case_id++;
   } while (sizeof(stat(query_case_file_name(next))));
   return next;
} /* query_next_case_id() */

private void save_case(class nomic_case stuff) {
   string fname;
   string tmp;

   fname = query_case_file_name(stuff->id);
   tmp = save_variable(stuff);
   unguarded((: write_file($(fname), $(tmp), 1) :));
} /* save_case() */

/**
 * This method returns the file name for the note given the id.
 * @param id the id to return
 * @return the file name
 */
string query_note_file_name(int id) {
   return NOMIC_CASE_SAVE + sprintf("notes/%02d/%d_note", id % 20, id);
} /* query_note_file_name() */

/**
 * This method finds the next note id.
 * @return the next note id
 */
int query_next_note_id() {
   int next;

   do {
      next = _next_note_id++;
   } while (sizeof(stat(query_note_file_name(next))));
   return next;
} /* query_next_note_id() */

private void save_note(class nomic_case_note stuff) {
   string fname;
   string tmp;

   fname = query_note_file_name(stuff->id);
   tmp = save_variable(stuff);
   unguarded((: write_file($(fname), $(tmp) ) :));
} /* save_note() */

private int create_case(string opener, string short, string* people) {
   class nomic_case new_case;

   new_case = new(class nomic_case);
   new_case->id = query_next_case_id();
   new_case->opener = opener;
   new_case->short = short;
   new_case->people = people;
   new_case->notes = ({ });
   new_case->events = ({ });
   new_case->time_opened = time();
   save_case(new_case);
   return new_case->id;
} /* create_case() */

private int create_note(string person, string text) {
   class nomic_case_note new_note;

   new_note = new(class nomic_case_note);
   new_note->id = query_next_note_id();
   new_note->person = person;
   new_note->text = text;
   new_note->time_created = time();
   save_note(new_note);
   return new_note->id;
} /* create_note() */

private class nomic_case_event create_event(int type, string person,
                                            string mess, mixed data) {
   class nomic_case_event event;

   event = new(class nomic_case_event);
   event->type = type;
   event->mess = mess;
   event->person = person;
   event->event_time = time();
   event->data = data;
   return event;
} /* create_event() */

/**
 * This method returns the short name of the event type.
 * @param type the type to find the name of
 * @return the name of the type
 */
string query_event_name(int type) {
   switch (type) {
   case NOMIC_CASE_EVENT_CLOSE :
      return "closed case";
   case NOMIC_CASE_EVENT_APPEAL :
      return "appealed case";
   case NOMIC_CASE_EVENT_ADD_PERSON :
      return "add person";
   case NOMIC_CASE_EVENT_REMOVE_PERSON :
      return "remove person";
   default :
      return "unknown";
   }
} /* query_event_name() */

/**
 * This method returns the case associated with the specified open
 * case.
 * @param area the area to look for the case in
 * @param id the id of the case
 * @return the case class
 */
class nomic_case query_open_case(string area, int id) {
   string fname;
   string tmp;

   if (!_open_cases[area]) {
      return 0;
   }

   if (member_array(id, _open_cases[area]) == -1) {
      return 0;
   }

   fname = query_case_file_name(id);
   tmp = unguarded((: read_file($(fname)) :));
   if (tmp) {
      return restore_variable(tmp);
   }
   return 0;
} /* query_open_case() */

/**
 * This method returns the case associated with the specified recently
 * closed case.
 * @param area the area to look for the case in
 * @param id the id of the case
 * @return the case class
 */
class nomic_case query_recently_closed_case(string area, int id) {
   string fname;
   string tmp;

   if (!_recently_closed_cases[area]) {
      return 0;
   }

   if (member_array(id, _recently_closed_cases[area]) == -1) {
      return 0;
   }

   fname = query_case_file_name(id);
   tmp = unguarded((: read_file($(fname)) :));
   if (tmp) {
      return restore_variable(tmp);
   }
   return 0;
} /* query_closed_case() */

/**
 * This method returns the case associated with the specified closed
 * case.
 * @param area the area to look for the case in
 * @param id the id of the case
 * @return the case class
 */
class nomic_case query_closed_case(string area, int id) {
   string fname;
   string tmp;

   if (!_closed_cases[area]) {
      return 0;
   }

   if (member_array(id, _closed_cases[area]) == -1) {
      return 0;
   }

   fname = query_case_file_name(id);
   tmp = unguarded((: read_file($(fname)) :));
   if (tmp) {
      return restore_variable(tmp);
   }
   return 0;
} /* query_closed_case() */

/**
 * This method return the exciting note associated with the case.
 * @param note_num the number of the note
 * @return the note class, or 0 on failure
 */
class nomic_case_note query_note(int note_num) {
   string fname;
   string tmp;

   fname = query_note_file_name(note_num);
   tmp = unguarded((: read_file($(fname)) :));
   if (tmp) {
      return restore_variable(tmp);
   }
   return 0;
} /* query_note() */

/**
 * This method opens a new case.
 * @param area the area the case is in
 * @param opener the person who opened it
 * @param short the short description of the case
 * @param people the people involved
 * @return 0 on failure and teh case id on success
 */
int add_new_case(string area, string opener, string short, string* people) {
   int case_id;

   if (!_open_cases[area]) {
      return 0;
   }
   case_id = create_case(opener, short, people);
   _open_cases[area] += ({ case_id });

   save_me();

   send_council_inform(area, 1, opener + " opened a case with " +
                      query_multiple_short(people));
   return case_id;
} /* add_new_case() */

/**
 * This method closes the case.
 * @param area the area the case is in
 * @param id the id of the case to close
 * @param closer the person that closes the case
 * @param result the string saying what the result of the case is
 * @param desc the description of the close reason
 * @param data special internal data used specifically for appeals
 * @return 1 on success, 0 on failure
 */
int close_case(string area, int id, string closer, string result,
               mixed data) {
   class nomic_case the_case;
   class nomic_case_event event;

   the_case = query_open_case(area, id);
   if (!the_case || !stringp(result)) {
      return 0;
   }

   event = create_event(NOMIC_CASE_EVENT_CLOSE, closer, result, data);
   the_case->events += ({ event });
   save_case(the_case);
   _open_cases[area] -= ({ the_case->id });
   _recently_closed_cases[area] += ({ the_case->id });
   save_me();
   send_council_inform(area, 1, closer + " closed a case with " +
                      query_multiple_short(the_case->people));
   return 1;
} /* close_case() */

/**
 * This method sets the case as reopened for an appeal.  After an appeal
 * the case will be closed again.
 * @param area the area the case is in
 * @param id the of the case to appeal
 * @param appealer the person who does the appeal
 * @param reason the reason for the appeal
 * @return 1 on success, 0 on failure
 */
int appeal_case(string area, int id, string appealer, string reason) {
   class nomic_case the_case;
   class nomic_case_event event;

   the_case = query_recently_closed_case(area, id);
   if (!the_case || !stringp(reason)) {
      return 0;
   }

   event = create_event(NOMIC_CASE_EVENT_APPEAL, appealer, reason, 0);
   the_case->events += ({ event });
   save_case(the_case);
   _recently_closed_cases[area] -= ({ the_case->id });
   _open_cases[area] += ({ the_case->id });
   save_me();
   send_council_inform(area, 1, appealer + " appeals a case with " +
                      query_multiple_short(the_case->people));
   return 1;
} /* appeal_case() */

/**
 * This method adds a note to the case.
 * @param area the area to get the case in
 * @param id the id of the case
 * @param person the person adding the note
 * @param text the actual note text
 * @return 1 on success, 0 on failure
 */
int add_note_to_case(string area, int id, string person, string text) {
   class nomic_case the_case;
   int note_id;

   the_case = query_open_case(area, id);
   if (!the_case) {
      return 0;
   }

   note_id = create_note(person, text);
   the_case->notes += ({ note_id });
   save_case(the_case);
   save_me();
   return 1;
} /* add_note_to_case() */

/**
 * This method adds a person to the case.
 * @param area the area the case is in
 * @param id the id of the case
 * @param adder the person that adds the person
 * @param person the person to be added to the case
 * @param text the reason for adding the person
 * @return 1 on success, 0 on failure
 */
int add_person_to_case(string area, int id, string adder, 
                       string person, string text) {
   class nomic_case the_case;
   class nomic_case_event event;

   the_case = query_open_case(area, id);
   if (!the_case || !stringp(text) ||
       member_array(person, the_case->people) != -1) {
      return 0;
   }

   event = create_event(NOMIC_CASE_EVENT_ADD_PERSON, adder, text, 0);
   the_case->events += ({ event });
   the_case->people += ({ person });
   save_case(the_case);
   return 1;
} /* add_person_to_case() */

/**
 * This method removes a person from the case.
 * @param area the area the case is in
 * @param id the id of the case
 * @param remover the person that removes the person
 * @param person the person to be removed to the case
 * @param text the reason for removeing the person
 * @return 1 on success, 0 on failure
 */
int remove_person_from_case(string area, int id, string remover, 
                       string person, string text) {
   class nomic_case the_case;
   class nomic_case_event event;

   the_case = query_open_case(area, id);
   if (!the_case || !stringp(text) ||
       member_array(person, the_case->people) == -1) {
      return 0;
   }

   event = create_event(NOMIC_CASE_EVENT_REMOVE_PERSON, remover, text, 0);
   the_case->events += ({ event });
   the_case->people -= ({ person });
   save_case(the_case);
   return 1;
} /* remove_person_to_case() */

/**
 * This method goes through and checks the recently closed cases to see
 * if any of them need to be moved to the closed set.
 */
void update_recently_closed_cases() {
   string area;
   int* stuff;
   int id;
   class nomic_case the_case;
   class nomic_case_event event;
   int last_close;

   foreach (area, stuff in _recently_closed_cases) {
      foreach (id in stuff) {
         the_case = query_recently_closed_case(area, id);
         last_close = 0;
         foreach (event in the_case->events) {
            if (event->type == NOMIC_CASE_EVENT_CLOSE) {
               last_close = event->event_time;
            }
         }
         if (last_close < time() - NOMIC_CASE_APPEAL_TIME) {
            //
            // Ok, move the case into the really closed bunch.
            //
            _closed_cases[area] += ({ id });
            _recently_closed_cases[area] -= ({ id });
         }
      }
   }
} /* update_recently_closed_cases() */
// --- END [/mnt/home2/grok/lib/obj/handlers/inherit/case_control.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/inherit/distance_handler.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/inherit/distance_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628495   Available: 13575849
Inodes: Total: 5242880    Free: 4960134
4072 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/inherit/distance_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628495   Available: 13575849
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This file handles the distance checking stuff for figuring out how
 * far apart two rooms or co-ordinates are.
 * @author Rodion
 * @started Wed Jul 25 15:22:24 PDT 2001
 */
#define BAD_ROOM -1
#define TRAVEL_NOT_ALLOWED -2
#define BAD_DOMAIN -3

int* query_co_ord(string room);

private int difference(int bing, int womble){
   if (womble > bing) {
      return womble - bing;
   }
   return bing - womble;
}

//Imprecise checking, for when coord data can't be found. We only allow certain
//domains now... And nothing outside /d/.
private int filename_check(string one, string two){
   string dom_one;
   string dom_two;
   string alpha;

   log_file("/log/PORTAL", "Unable to get co-ords for %O %O, doing filename based check.\n", one, two);
   dom_one = explode(one, "/")[1];
   dom_two = explode(two, "/")[1];
   
   //Alphabatize them so we only have half as many cases... This means if 
   //you're going from AM to Forn it will be the same as going from Forn to 
   //AM (am:forn)... as it should be.
   alpha = dom_one<dom_two?dom_one+":"+dom_two:dom_two+":"+dom_one;
   switch(alpha){
      case "am:am":
         return 3000;
      
      case "am:cwc":
         return TRAVEL_NOT_ALLOWED;
      
      case "am:ram":
         return 3000000;
      
      case "am:klatch":
         return 1000000;
      
      case "am:sur":
         return 500000;
      
      case "am:forn":
         return TRAVEL_NOT_ALLOWED;
      
      case "am:guilds":
         return 1000;
   
      case "cwc:ram":
      case "cwc:klatch":
      case "cwc:forn":
      case "cwc:guilds":
      case "cwc:sur":
         return TRAVEL_NOT_ALLOWED;
      
      case "cwc:cwc":
         return 500000;

      case "forn:forn":
         return TRAVEL_NOT_ALLOWED;
      
      case "forn:ram":
         return TRAVEL_NOT_ALLOWED;
      
      case "forn:guilds":
         return TRAVEL_NOT_ALLOWED;
      
      case "forn:klatch":
         return TRAVEL_NOT_ALLOWED;
      
      case "forn:sur":
         return TRAVEL_NOT_ALLOWED;
      
      case "guilds:guilds":
         return 1000;
      
      case "guilds:klatch":
         return 500000;
      
      case "guilds:sur":
         return 500000;
      
      case "guilds:ram":
         return 1500000;
      
      case "klatch:klatch":
         return 1000;
      
      case "klatch:sur":
         return 3300000;
      
      case "klatch:ram":
         return 4000000;
      
      case "ram:ram":
         return 500000;
      
      case "ram:sur":
         return 900000;
      
      case "sur:sur":
         return 500000;
   }
   return BAD_DOMAIN;
}

/**
 * This method figures out the distance between two co-ordinates.
 * @param co_ord_one the first co-ordinate
 * @param co_ord_two the second co-ordinate
 * @return the distance
 */
int query_distance_from_coords(int* co_ord_one, int* co_ord_two){
   float x;
   float y;
   float z;
   float distanceplane;
   float distance;

   x = difference(co_ord_one[0], co_ord_two[0]);
   y = difference(co_ord_one[1], co_ord_two[1]);
   z = difference(co_ord_one[2], co_ord_two[2]);
   distanceplane = sqrt(pow(x, 2) + pow(y, 2));
   distance = sqrt(pow(distanceplane, 2) + pow(z, 2));
   return to_int(distance);
}

/**
 * This method figures out the distance between two rooms and returns the
 * result.  The result will be in co-ordinate units.
 * @param one the first room
 * @param two the second room
 * @return the distance between them
 */
int query_distance_from_rooms(mixed one, mixed two){
   mixed co_ord_one;
   mixed co_ord_two;

   if (objectp(one)) {
      one = file_name(one);
   }
   if (objectp(two)) {
      two = file_name(two);
   }

   if (one->query_co_ord()) {
      co_ord_one = one->query_co_ord();
   } else {
      co_ord_one = query_co_ord(one);
   }
   if (two->query_co_ord()) {
      co_ord_two = two->query_co_ord();
   } else {
      co_ord_two = query_co_ord(two);
   }
   if(co_ord_one == 0 || co_ord_two == 0) {
      return filename_check(one, two);
   }

   return query_distance_from_coords(co_ord_one, co_ord_two);
}
// --- END [/mnt/home2/grok/lib/obj/handlers/inherit/distance_handler.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/inherit/club_family.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/inherit/club_family.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628494   Available: 13575848
Inodes: Total: 5242880    Free: 4960134
23684 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/inherit/club_family.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628494   Available: 13575848
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is the handler for all things clubby, a club being a group of
 * players.  Each club must have a unique name.  It also handles elections
 * for various club positions.
 * @author Pinkfish
 * @started Sun Sep 27 03:35:42 EDT 1998
 */
inherit "/obj/handlers/inherit/club_personal";

#define __CLUBS_H_NO_CLASSES

#include <clubs.h>
#include <player_handler.h>

// Special variables to control the club inner workings.
private nosave mapping _valid_relationships;
private nosave mapping _gender_relationship;

private void add_valid_relationship(string relation,
                                    string relation2,
                                    int flags);
private void add_gender_relationship(string region,
                                     string relationship,
                                     string male,
                                     string female);
string* query_gender_relationships(string relationship);

/**
 * The stuff releated to families.
 * @member relationships the relations in this family
 * @member never_join the list of people who can never join
 */
class family_info {
   mapping relationships;
   string *never_join;
   // Couple of extra variables for when I think of something else to go
   // in here.
   string tmp;
   int tmp2;
}

#define CLUB_INTERFAMILY_FLAG 1
#define CLUB_JOIN_FAMILY_FLAG 2
/**
 * The information associated with relationship names.
 * @member opposite the opposite relationship name
 * @member flags flags associated with the relationship's
 */
class relationship_type_data {
   string opposite;
   int flags;
}

void create() {
   _valid_relationships = ([ ]);
   _gender_relationship = ([ ]);

   ::create();

   add_valid_relationship("spouse",
                          "spouse",
                          CLUB_INTERFAMILY_FLAG | CLUB_JOIN_FAMILY_FLAG);
   add_gender_relationship("Ankh-Morpork",
                           "spouse",
                           "husband",
                           "wife");

   add_valid_relationship("lover",
                          "lover",
                          CLUB_INTERFAMILY_FLAG | CLUB_JOIN_FAMILY_FLAG);
   add_gender_relationship("Ankh-Morpork",
                           "lover",
                           "lover",
                           "lover");

   add_valid_relationship("sibling",
                          "sibling",
                          CLUB_INTERFAMILY_FLAG | CLUB_JOIN_FAMILY_FLAG);
   add_gender_relationship("Ankh-Morpork",
                           "sibling",
                           "brother",
                           "sister");

   add_valid_relationship("sibling-in-law",
                          "sibling-in-law",
                          CLUB_INTERFAMILY_FLAG | CLUB_JOIN_FAMILY_FLAG);
   add_gender_relationship("Ankh-Morpork",
                           "sibling-in-law",
                           "brother-in-law",
                           "sister-in-law");

   add_valid_relationship("parent-in-law",
                          "child-in-law",
                          CLUB_INTERFAMILY_FLAG | CLUB_JOIN_FAMILY_FLAG);
   add_gender_relationship("Ankh-Morpork",
                           "parent-in-law",
                           "father-in-law",
                           "mother-in-law");
   add_gender_relationship("Ankh-Morpork",
                           "child-in-law",
                           "son-in-law",
                           "daughter-in-law");

   add_valid_relationship("child",
                          "parent",
                          CLUB_INTERFAMILY_FLAG | CLUB_JOIN_FAMILY_FLAG);
   add_gender_relationship("Ankh-Morpork",
                           "child",
                          "son",
                          "daughter");
   add_gender_relationship("Ankh-Morpork",
                           "parent",
                           "father",
                           "mother");

   add_valid_relationship("grandparent",
                          "grandchild",
                          CLUB_INTERFAMILY_FLAG | CLUB_JOIN_FAMILY_FLAG);
   add_gender_relationship("Ankh-Morpork",
                           "grandparent",
                           "grandfather",
                           "grandmother");
   add_gender_relationship("Ankh-Morpork",
                           "grandchild",
                           "grandson",
                           "granddaughter");

   add_valid_relationship("godchild",
                          "godparent",
                          CLUB_INTERFAMILY_FLAG | CLUB_JOIN_FAMILY_FLAG);
   add_gender_relationship("Ankh-Morpork",
                           "godchild",
                           "godson",
                           "goddaughter");
   add_gender_relationship("Ankh-Morpork",
                           "godparent",
                           "godfather",
                           "godmother");

   add_valid_relationship("uncle",
                          "niece",
                          CLUB_INTERFAMILY_FLAG | CLUB_JOIN_FAMILY_FLAG);
   add_gender_relationship("Ankh-Morpork",
                           "uncle",
                           "uncle",
                           "aunt");
   add_gender_relationship("Ankh-Morpork",
                           "niece",
                           "nephew",
                           "niece");

   add_valid_relationship("cousin",
                          "cousin",
                          CLUB_INTERFAMILY_FLAG | CLUB_JOIN_FAMILY_FLAG);
   add_gender_relationship("Ankh-Morpork",
                           "cousin",
                           "cousin",
                           "cousin");

   add_valid_relationship("master",
                          "maid",
                          CLUB_INTERFAMILY_FLAG | CLUB_JOIN_FAMILY_FLAG);
   add_gender_relationship("Ankh-Morpork",
                           "maid",
                           "butler",
                           "maid");
   add_gender_relationship("Ankh-Morpork",
                           "master",
                           "master",
                           "mistress");

   add_valid_relationship("apprentice",
                          "tutor",
                          CLUB_INTERFAMILY_FLAG | CLUB_JOIN_FAMILY_FLAG);
   add_gender_relationship("Ankh-Morpork",
                           "apprentice",
                           "apprentice",
                           "apprentice");
   add_gender_relationship("Ankh-Morpork",
                           "tutor",
                           "tutor",
                           "tutor");

   add_valid_relationship("guardian",
                          "ward",
                          CLUB_INTERFAMILY_FLAG | CLUB_JOIN_FAMILY_FLAG);
   add_gender_relationship("Ankh-Morpork",
                           "guardian",
                           "guardian",
                           "guardian");
   add_gender_relationship("Ankh-Morpork",
                           "ward",
                           "ward",
                           "ward");

   add_valid_relationship("ex-spouse",
                          "ex-spouse",
                          CLUB_INTERFAMILY_FLAG | CLUB_JOIN_FAMILY_FLAG);
   add_gender_relationship("Ankh-Morpork",
                           "ex-spouse",
                           "ex-husband",
                           "ex-wife");
} /* create() */

protected void create_extra_data(string name) {
   class family_info f_info;
   class club_info data;

   data = (class club_info)query_club_info(name);
   if (query_club_type(name) == CLUB_FAMILY) {
      f_info = new(class family_info);
      f_info->relationships = ([ ]);
      f_info->never_join = ({ });
      data->extra_data = f_info;
   } else {
      ::create_extra_data(name);
   }
   set_club_changed(name);
} /* create_extra_data() */

/**
 * This method determines how much the club will cost to run each
 * pay period.
 * @param club_name the name of the club to get the fees for
 * @return the amount the club will cost in the next pay period
 * @see query_time_fees_due()
 */
int query_club_cost_per_period(string club_name) {
   if (is_club(club_name)) {
      if (is_family(club_name)) {
         return FAMILY_COST_PER_YEAR +
              sizeof(query_members(club_name)) * FAMILY_COST_PER_MEMBER_PER_YEAR;
      } else {
         return ::query_club_cost_per_period(club_name);
      }
   }
   return 0;
} /* query_club_cost_per_period() */

/**
 * This method returns the family information.
 * @param the name of the club
 * @return the family information
 */
private class family_info query_family_info(string name) {
   class club_info data;

   if (is_family(name)) {
      data = (class club_info)query_club_info(name);
      return data->extra_data;
   }
} /* query_family_info() */

/**
 * This method adds a valid relationship to the current list.
 * @param relation1 the first relationship
 * @param relation2 the second relationship
 * @see query_opposite_relationship()
 * @see is_valid_interfamily_relationship()
 * @see is_valid_join_family_relationship()
 * @see is_valid_relationship()
 */
void add_valid_relationship(string relation1,
                            string relation2,
                            int flags) {
   class relationship_type_data frog;

   frog = new(class relationship_type_data);
   frog->opposite = relation2;
   frog->flags = flags;
   _valid_relationships[relation1] = frog;
   frog = new(class relationship_type_data);
   frog->opposite = relation1;
   frog->flags = flags;
   _valid_relationships[relation2] = frog;
} /* add_valid_relationship() */

/**
 * This method returns the opposite relationship to the specified one.
 * @param relation the relation to return the opposite of
 * @return the opposite of the relationship
 * @see add_valid_relationship()
 * @see is_valid_interfamily_relationship()
 * @see is_valid_join_family_relationship()
 * @see is_valid_relationship()
 */
string query_opposite_relationship(string relation) {
   if (_valid_relationships[relation]) {
      return _valid_relationships[relation]->opposite;
   }
   return 0;
} /* query_opposite_relationship() */

/**
 * This method checks to make sure the specified relationship is valid.
 * @param relation the relationship to check for validity
 * @return 1 if the relationship is valid
 * @see query_opposite_relationship()
 * @see is_valid_interfamily_relationship()
 * @see is_valid_join_family_relationship()
 * @see add_valid_relationship()
 */
int is_valid_relationship(string str) {
   return _valid_relationships[str] != 0;
} /* is_valid_relationship() */

/**
 * This method checks to see if the relation is a valid interfamily one.
 * @param str the relationship to check
 * @return 1 if the relation is a valid interfamily one
 * @see is_valid_relationship()
 * @see is_valid_join_family_relationship()
 */
int is_valid_interfamily_relationship(string str) {
   class relationship_type_data frog;

   frog = _valid_relationships[str];
   if (frog) {
      if (frog->flags & CLUB_INTERFAMILY_FLAG) {
         return 1;
      }
   }
   return 0;
} /* is_valid_interfamily_relationship() */

/**
 * This method checks to see if the relation is a valid join family one.
 * @param str the relationship to check
 * @return 1 if the relation is a valid join family one
 * @see is_valid_relationship()
 * @see is_valid_interfamily_relationship()
 * @see add_valid_relationship()
 * @see query_opposite_relationship()
 */
int is_valid_join_family_relationship(string str) {
   class relationship_type_data frog;

   frog = _valid_relationships[str];
   if (frog) {
      if (frog->flags & CLUB_JOIN_FAMILY_FLAG) {
         return 1;
      }
   }
   return 0;
} /* is_valid_interfamily_relationship() */

/**
 * This method returns all the valid relationships.
 * @return all the current valid relationship types
 * @see add_valid_relationship()
 * @see is_valid_interfamily_relationship()
 * @see is_valid_join_family_relationship()
 * @see is_valid_relationship()
 * @see query_opposite_relationship()
 */
string *query_all_valid_relationships() {
   return keys(_valid_relationships);
} /* query_all_valid_relationships() */

/**
 * This method adds a the different gender types for the
 * relationship.
 * @param region the region the relationship is in
 * @param relationship the relationship to set the genders for
 * @param male the male gender type
 * @param female the female gender type
 * @see query_all_relationships()
 * @see query_ungendered_relationships()
 */
private void add_gender_relationship(string region,
                                     string relationship,
                                     string male,
                                     string female) {
   _gender_relationship[male] = relationship;
   _gender_relationship[female] = relationship;
   if (!mapp(_gender_relationship[relationship])) {
      _gender_relationship[relationship] = ([ ]);
   }
   _gender_relationship[relationship][region] = ({ male,
                                                   female });
} /* add_gender_relationship() */

/**
 * This returns the real relationship type based on the possible
 * genderised relationship.
 * @param relationship the relationship to get the real relationship for
 * @return the degendered relationship name
 * @see add_gender_relationship()
 * @see query_all_relationship_types()
 */
string query_ungendered_relationship(string relationship) {
   if (stringp(_gender_relationship[relationship])) {
      return _gender_relationship[relationship];
   }
   if (mapp(_gender_relationship[relationship])) {
      return relationship;
   }
   return 0;
} /* query_ungendered_relationship() */

/**
 * This method returns all the possible relationships, including the
 * gendered ones.
 * @return the array of possible relationships
 * @see query_ungendered_relationship()
 * @see add_gender_relationship()
 */
string *query_all_relationships() {
   return keys(_gender_relationship);
} /* query_all_relationships() */

/**
 * This method returns the genderised version of the relationship.
 * @param name relationship the relation to get the gender of
 * @param female 0 for male, 1 for female
 * @param region the region the relation is in
 * @see query_all_relationships()
 * @see query_ungendered_relationship()
 * @see add_gender_relationships()
 * @see query_all_relationships()
 */
string query_relationship_gender(string relationship,
                                 int female,
                                 string region) {
   string rel;

   rel = query_ungendered_relationship(relationship);
   if (!rel ||
       female < 0 ||
       female > 1) {
      return 0;
   }
   if (!region || !_gender_relationship[rel][region]) {
      region = "Ankh-Morpork";
   }
   return _gender_relationship[rel][region][female];
} /* query_relationship_gender() */

private void real_add_relationship(string name,
                                   string person,
                                   string dest,
                                   string relationship) {
   class family_info womble;
   class relationship_data plum;

   womble = query_family_info(name);
   if (!womble->relationships[person]) {
      womble->relationships[person] = ({ });
   }
   plum = new(class relationship_data);
   plum->related_to = dest;
   plum->relationship = relationship;
   womble->relationships[person] += ({ plum });
   set_club_changed(name);
} /* real_add_relationship() */

private void real_remove_relationship(string name,
                                      string person,
                                      string dest,
                                      string relationship) {
   class family_info womble;
   int i;

   womble = query_family_info(name);
   for (i = 0; i < sizeof(womble->relationships[person]); i++) {
      if (womble->relationships[person][i]->related_to == dest &&
          womble->relationships[person][i]->relationship == relationship) {
         womble->relationships[person] = womble->relationships[person][0..i-1] +
                                         womble->relationships[person][i+1..];
         set_club_changed(name);
      }
   }
} /* real_add_relationship() */

/**
 * This method adds a relationship between two members of a family.
 * @param name the name of the family
 * @param person the person the relationship is from
 * @param dest the person the relationship is to
 * @param dest_name the name of the family the other person is in
 * @param relationship the relationship they have to you
 * @return 1 if succcessful, 0 if not
 */
int add_relationship(string name,
                     string person,
                     string dest_name,
                     string dest,
                     string relationship) {

   if (is_family(name) &&
       is_family(dest_name) &&
       is_member_of(name, person) &&
       is_member_of(dest_name, dest) &&
       is_valid_relationship(relationship)) {
      real_add_relationship(name,
                            person,
                            dest,
                            relationship);
      // Add the reverse to the other person.
      real_add_relationship(dest_name,
                            dest,
                            person,
                            query_opposite_relationship(relationship));
      save_club(name);
      return 1;
   }
   return 0;
} /* add_relationship() */

/**
 * This method returns the relationships the selected person has to
 * the other people in the family.
 * @param name the name of the family
 * @param person the person who to query the relationships for
 * @return the list of all the relationships the person has
 */
class relationship_data *query_relationships(string name,
                                             string person) {
   class family_info womble;

   if (is_family(name)) {
      womble = query_family_info(name);
      if (womble->relationships[person]) {
         return womble->relationships[person];
      }
   }
   return ({ });
} /* query_relationships() */

/**
 * This method moves a person from one family to another family.
 * @param curr_family the current family
 * @param person the persons name
 * @param dest_family the destination family
 * @return 1 if successful moved
 * @see add_member()
 */
int move_family_member(string curr_family,
                       string person,
                       string dest_family) {
  class relationship_data *stuff;
  class family_info womble;

  if (is_family(curr_family) &&
      is_family(dest_family) &&
      is_member_of(curr_family, person)) {
    stuff = query_relationships(curr_family,
                                person);
    /* Remove the relationships first. */
    womble = query_family_info(curr_family);
    map_delete(womble->relationships, person);
    set_club_changed(curr_family);
    remove_member(curr_family, person);

    /* Add the new relationship. */
    add_member(dest_family, person);
    womble = query_family_info(dest_family);
    womble->relationships[person] = stuff;
    set_club_changed(dest_family);
    return 1;
  }
  return 0;
} /* move_family_member() */

/**
 * This method returns how the first player is related to the second player.
 * @param name the family the relationship is in
 * @param person the person the relationship is from
 * @param related to person they are related to
 * @return the array of relationships they have
 */
string *query_relationships_to(string name,
                               string person,
                               string related) {
   class relationship_data frog;
   string *relationships;

   relationships = ({ });
   foreach (frog in query_relationships(name, person)) {
      if (frog->related_to == related) {
         relationships += ({ frog->relationship });
      }
   }
   return relationships;
} /* query_relationships_to() */

/**
 * This method checks to see if the specified relationship exists.
 * @param name the family the relationship is in
 * @param person the person the relationship is from
 * @param related to person they are related to
 * @param relationship the type of relationship they have
 * @return 1 if the relationship exists, 0 if not
 */
int is_relationship(string name,
                    string person,
                    string related,
                    string relationship) {
   class relationship_data frog;

   foreach (frog in query_relationships(name, person)) {
      if (frog->related_to == related &&
          frog->relationship == relationship) {
         return 1;
      }
   }
   return 0;
} /* is_relationship() */

/**
 * This method removes a relationship from the club.
 * @param name the name of the family
 * @param person the person the relationship is from
 * @param dest the person the relationship is to
 * @param relationship the relationship they have to you
 * @return 1 if succcessful, 0 if not
 */
int remove_relationship(string name,
            string person,
                        string dest_name,
      string dest,
      string relationship) {
   if (is_relationship(name, person, dest, relationship)) {
      real_remove_relationship(name,
                   person,
             dest,
             relationship);
      if (dest_name) {
         real_remove_relationship(dest_name,
                      dest,
                person,
                      query_opposite_relationship(relationship));
      }
      return 1;
   }
   return 0;
} /* remove_relationship() */

/**
 * This method checks the extra information for the club.  Please note
 * this does *not* save the information.  You need to do this yourself.
 * @param name the name of the club to check
 * @see check_clubs()
 * @see remove_member()
 */
protected void check_family_information(string name,
                                        string member,
                                        int startup) {
   class family_info fam_data;
   //class relationship_data rel;
   string family;

   fam_data = query_family_info(name);
   if (fam_data) {
      /*
       * Check the stuff in the club to make sure the positions and stuff
       * are still valid.
       */
      if (member &&
         fam_data->relationships[member]) {

         family = PLAYER_HANDLER->test_family(member);
         if (!family ||
              normalise_name(family) != name) {
            if (find_player(member)) {
               find_player(member)->set_family_name(family);
            } else {
               log_file("CLUB", ctime(time()) +
                                ": removed " +
                                member + " from " + family +
                                " family deficent.\n");
               remove_member(name, member);
            }
         }

/*
         foreach (rel in fam_data->relationships[member]) {
            family = PLAYER_HANDLER->test_family(rel->related_to);
            if (!family) {
               * Remove the relationship... *
               log_file("CLUB", ctime(time()) +
                                ": removed relationship between " +
                                member + " <-> " + rel->related_to +
                                " (" + rel->relationship +
                                "; family deficent.\n");
               real_remove_relationship(name,
                                   member,
                                   rel->related_to,
                                   rel->relationship);
            }
         }
 */

         /* Are they a member of any family now?  Hmm... */
         if (!undefinedp(fam_data->relationships)) {
            map_delete(fam_data->relationships, member);
            set_club_changed(name);
         }
      }
   }
} /* check_family_information() */
// --- END [/mnt/home2/grok/lib/obj/handlers/inherit/club_family.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/inherit/club_inherit.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/inherit/club_inherit.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628488   Available: 13575842
Inodes: Total: 5242880    Free: 4960134
15582 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/inherit/club_inherit.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628488   Available: 13575842
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is the handler for all things clubby, a club being a group of
 * players.  Each club must have a unique name.  It also handles elections
 * for various club positions.
 * <p>
 * This is broken up into this bit because LPC deals with classes and
 * inheritance in extremely odd ways.
 * @author Pinkfish
 * @started Sun Sep 27 03:35:42 EDT 1998
 */

inherit "/obj/handlers/inherit/club_discuss";

#define __CLUBS_H_NO_CLASSES
#define __MAIL_H_NO_CLASSES

#include <mail.h>
#include <clubs.h>
#include <player_handler.h>
#include <broadcaster.h>
#include <player.h>
#include <top_ten_tables.h>
#include <library.h>
#include <player_handler.h>

// To deal with the check_clubs() callout
private nosave int _callout_id;
private nosave int _test_callout_id;
private string _current_test_club;
private int _last_test_time;

protected void check_extra_information(string name, string person, int startup);
void check_clubs(int startup);

class top_ten_tables {
   int num;
   int qp;
   int age;
   int start_time;
   int gender;
   int single_gender;
   int rels;
   int no_pks;
   mapping guild;
}

/**
 * This method will do the callout to the check_clubs function
 * @ignore yes
 */
protected void setup_call_check_clubs(int time, int startup) {
   remove_call_out(_callout_id);
   _callout_id = call_out("check_clubs", time, startup);
} /* setup_call_check_clubs() */

/**
 * This method sends mail to the nessessary members of the club when the
 * balance is low.
 * @param name the name of the club to send the messages too
 */
private void send_low_balance_mail(string club) {
   string *to;
   string bit;

   switch (query_club_type(club)) {
      case CLUB_FAMILY :
         // For a family everyone gets the mail.
         to = query_members(club);
         bit = "family";
         break;
      case CLUB_PERSONAL :
         // Personal club only the initiator gets the mail.
         to = ({ query_founder(club) });
         bit = "club";
         to -= ({ "unknown" });
         if (!sizeof(to)) {
            to = query_members(club);
         }
         break;
      case CLUB_ELECTED :
         // Elected club, the committee gets it.
         to = query_committee(club) - ({ CLUB_UNKNOWN_MEMBER });
         if (!sizeof(to)) {
            to = ({ query_members(club) });
         }
         bit = "club";
         break;
   }

   to = filter(to, (: PLAYER_HANDLER->test_user($1) :));

   if (sizeof(to)) {
   // Ok, now send the mail out...
      MAILER->do_mail_message(implode(to, ","),
                           "Patricians office",
                           "The " + bit + " has fees due.",
                           "",
                           sprintf("%-=80s\n", "Morning,\n\n"
                           "This is a reminder from the Patrician's Office "
                           "the " + bit + " '" + query_club_name(club) +
                           "' is currently in remission and "
                           "its balance will need to be updated before "
                           "the next "
                           "pay period or your " + bit + " will be "
                           "disbanded.\n\nYours happily,\nThe Patrician."));
   }
} /* send_low_balance_mail() */

/**
 * This method sends mail to the nessessary members of the club when the
 * club is being disbanded.
 * @param name the name of the club to send the messages too
 */
private void send_disband_mail(string club) {
   string *to;
   string bit;

   switch (query_club_type(club)) {
      case CLUB_FAMILY :
         // For a family everyone gets the mail.
         to = query_members(club);
         bit = "family";
         break;
      case CLUB_PERSONAL :
         // Personal club only the initiator gets the mail.
         to = ({ query_founder(club) });
         bit = "club";
         break;
      case CLUB_ELECTED :
         // Elected club, the committee gets it.
         to = query_committee(club) - ({ CLUB_UNKNOWN_MEMBER });
         if (!sizeof(to)) {
            to = ({ query_members(club) });
         }
         bit = "club";
         break;
   }

   // Ok, now send the mail out...
   MAILER->do_mail_message(implode(to, ","),
                           "Patricians office",
                           "The " + bit + " has been disbanded.",
                           "",
                           sprintf("%-=80s\n", "Morning,\n\n"
                           "This is a message from the patricians "
                           "office to you that your " + bit +
                           " '" + query_club_name(club) +
                           "' has been disbanded for having its fees "
                           "in remission."
                           "\n\nYours happily,\nThe Patrician."));

} /* send_disband_mail() */

/**
 * This method checks the extra information for the club.  Please note
 * this does *not* save the information.  You need to do this yourself.
 * @param name the name of the club to check
 * @see check_clubs()
 * @see remove_member()
 */
protected void check_extra_information(string name,
                                       string member,
                                       int startup) {
   if (is_elected_club(name)) {
      check_elected_information(name, member, startup);
   } else if (is_family(name)) {
      check_family_information(name, member, startup);
   }
} /* check_extra_information() */

/**
 * This method checks the members of the club and makes sure they have
 * not been up to anything naughty, like getting deleted.  It also
 * updates the top ten information on the top ten handler.
 * @param club_name the name of the club
 * @param members the members left to check
 * @param top_info the top ten information
 */
protected void check_club_members(string club_name,
                                string* members,
                                class top_ten_tables top_info) {
   int i;
   int tmp;
   string member;
   string str;
   string flip;
   class relationship_data *rels;
   class relationship_data frog;

   for (i = 0; i < 1 && i < sizeof(members); i++) {
      member = members[i];
      if (!PLAYER_HANDLER->test_user(member)) {
         log_file("CLUB", ctime(time()) + ": removed " + member +
                          " from " + club_name + " for not existing.\n");
         remove_member(club_name, member);
      } else if (!PLAYER_HANDLER->test_creator(member) &&
                 !PLAYER_HANDLER->test_property(member, "no score")) {
         //
         // Generate information for the top ten handler.
         //
         top_info->num++;
         top_info->qp += LIBRARY->query_quest_points(member);
         tmp = -PLAYER_HANDLER->test_age(member) / (60 * 60);
         top_info->rels += sizeof(CLUB_HANDLER->query_relationships(club_name, member));
         top_info->age += tmp;
         top_info->start_time += PLAYER_HANDLER->test_start_time(member) / (60 * 60);
         str = PLAYER_HANDLER->test_guild(member);
         if (str &&
             str != "") {
            if (top_info->guild[str]) {
               top_info->guild[str]++;
            } else {
               if (file_size(str + ".c") > 0) {
                  flip = str->query_real_guild_object();
                  if (flip) {
                     str = flip;
                  }
                  top_info->guild[str]++;
               }
            }
         }
         if (PLAYER_HANDLER->test_player_killer(member)) {
            top_info->no_pks++;
         }
         if (!top_info->gender) {
            top_info->gender = PLAYER_HANDLER->test_gender(member);
         }
         if (top_info->single_gender != -1 &&
             PLAYER_HANDLER->test_gender(member) != top_info->gender) {
            top_info->single_gender = -1;
         }
      }
      if (is_family(club_name)) {
         check_family_information(club_name, member, 0);
         rels = CLUB_HANDLER->query_relationships(club_name, member);
         foreach (frog in rels) {
            if (!PLAYER_HANDLER->test_family(frog->related_to)) {
/*
               remove_relationship(club_name,
                                   member,
                                   0,
                                   frog->related_to,
                                   frog->relationship);
 */
               log_file("CLUB", ctime(time()) + ": removed relationship " +
                          member +
                          " <-> " + frog->related_to + " (" +
                          frog->relationship + ") for loosing their "
                          "family.\n");
            }
         }
      }
   }

   //
   // Check to see if we have checked all the members...
   //
   members = members[1..];
   if (!sizeof(members)) {
      if (!sizeof(query_members(club_name))) {
         disband_club(club_name);
      } else if (top_info->num > 3) {
         //
         // Tell the club handler about this club/family...
         //
         TOP_TEN_HANDLER->inform_of_club(club_name,
                                         is_family(club_name),
                                         TOP_TEN_LARGEST_FAMILY,
                                         top_info->num);
         TOP_TEN_HANDLER->inform_of_club(club_name,
                                         is_family(club_name),
                                         TOP_TEN_OLDEST_FAMILY,
                                         top_info->age / top_info->num);
         TOP_TEN_HANDLER->inform_of_club(club_name,
                                         is_family(club_name),
                                         TOP_TEN_MOST_QUEST_POINTS,
                                         top_info->qp / top_info->num);
         TOP_TEN_HANDLER->inform_of_club(club_name,
                                         is_family(club_name),
                                         TOP_TEN_MOST_GUILD,
                                         top_info->guild);
         TOP_TEN_HANDLER->inform_of_club(club_name,
                                         is_family(club_name),
                                         TOP_TEN_MOST_PKS,
                                         top_info->no_pks);
         if (top_info->single_gender != -1) {
            TOP_TEN_HANDLER->inform_of_club(club_name,
                                            is_family(club_name),
                                            TOP_TEN_SINGLE_GENDER,
                                            top_info->num);
         } else {
            TOP_TEN_HANDLER->inform_of_club(club_name,
                                            is_family(club_name),
                                            TOP_TEN_SINGLE_GENDER,
                                            0);
         }
         TOP_TEN_HANDLER->inform_of_club(club_name,
                                         is_family(club_name),
                                         TOP_TEN_OLDEST_LOGONS,
                                         top_info->start_time / top_info->num);
      }

      top_info = new(class top_ten_tables);
      top_info->guild = ([ ]);
      i = member_array(_current_test_club, query_clubs());
      if (i < sizeof(query_clubs())) {
         _current_test_club = query_clubs()[i+1];
         _test_callout_id = call_out("check_club_members", 60, _current_test_club, query_members(_current_test_club), top_info);
      } else {
         _current_test_club = 0;
         _test_callout_id = 0;
      }
      save_main();
   } else {
      _test_callout_id = call_out("check_club_members", 60, club_name, members, top_info);
   }
} /* check_club_members() */

private nosave int _specific_callout_id = 0;
private nosave string *_clubs_to_check = ({ });

protected void check_specific_club(string club_name, int startup) {
    class club_info bing;

    bing = (class club_info)query_club_info(club_name);

    if (bing->last_touched < time() - CLUB_TIMEOUT) {
        disband_club(club_name);
        return;
    }

    if (!pointerp(query_members(club_name))) {
        disband_club(club_name);
        return;
    }

/*
      blue = new(class top_ten_tables);
      blue->guild = ([ ]);
      call_out("check_club_members",
               extra_space,
               club_name,
               query_members(club_name),
               blue);
 */

    if (query_time_fees_due(club_name) < time()) {
        if (query_balance(club_name, CLUB_DEFAULT_ACCOUNT_NAME) < 0) {
            // This means they must have already have been mailed.
            // So disband the club...
            send_disband_mail(club_name);
            disband_club(club_name);
            return;
        }

        if (remove_money(club_name, query_club_cost_per_period(club_name),
            CLUB_TRANSACTION_UPKEEP, "Club Dues", 
            CLUB_DEFAULT_ACCOUNT_NAME, 0)) {
            int tmp;

            bing = (class club_info)query_club_info(club_name);
            tmp = bing->last_paid;
            bing->last_paid = query_time_fees_due(club_name);
            set_club_changed(club_name);
            if (query_balance(club_name, CLUB_DEFAULT_ACCOUNT_NAME) < 0) {
               // Mail people about this.
               reset_eval_cost();
               send_low_balance_mail(club_name);
            }
        }
    }

    /*
     * This checks things like if an election needs to be called and if all
     * the people in the positions still exist in the club.
     */
    call_out( (: check_extra_information :),  1,  club_name, 0,  startup);
} /* check_specific_club() */

protected void check_specific_clubs( int startup, int pos ) {
    string club_name;
    
    if ( pos >= sizeof( _clubs_to_check ) ) {
        _clubs_to_check = ({ }); 
        _specific_callout_id = 0; 
        pos = 0; 
        return;
    }

    club_name = _clubs_to_check[ pos ]; 

    tell_creator( "taffyd", "Checking club %s (%d)\n", club_name, pos ); 
    
    check_specific_club(club_name, startup); 
    
    // Now check the next club. 
    _specific_callout_id = call_out( (: check_specific_clubs :), 10, startup, ++pos ); 
}

/**
 * This method checks all the clubs to make sure they are currently valid
 * and takes money out of the accounts of those that need to pay.  It
 * will notify those whose accounts are deliquent.
 */
void check_clubs(int startup) {
   class top_ten_tables blue;

   //remove_call_out(_callout_id);
   setup_call_check_clubs(24 * 60 * 60, 0);

   if ( !_specific_callout_id ) {
       _clubs_to_check = query_clubs();
        _specific_callout_id = call_out( (: check_specific_clubs :), 0, 
            startup, 0 ); 
   }

   // foreach (club_name in query_clubs()) {
   //   call_out("check_specific_club", extra_space - 2, club_name, extra_space,
   //            startup);
   // } 

   //
   // Start checking the members of the clubs.
   //
   remove_call_out(_test_callout_id);
   if (!_current_test_club &&
       _last_test_time + 7 * 24 * 60 * 60 < time()) {
      if (sizeof(query_clubs()) > 0) {
         _current_test_club = query_clubs()[0];
      }
      _last_test_time = 0;
      save_main();
   }
   if (_current_test_club) {
      blue = new(class top_ten_tables);
      blue->guild = ([ ]);
      _test_callout_id = call_out("check_club_members",
                                 60,
                                 _current_test_club,
                                 query_members(_current_test_club),
                                 blue);
   }
} /* check_clubs() */

#ifdef OLD_CHECK_CODE
protected void check_specific_club(string club_name, int extra_space,
                                   int startup) {
} /* check_specific_club() */
#endif
// --- END [/mnt/home2/grok/lib/obj/handlers/inherit/club_inherit.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/inherit/nomic_rules.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/inherit/nomic_rules.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628484   Available: 13575838
Inodes: Total: 5242880    Free: 4960134
9365 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/inherit/nomic_rules.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628484   Available: 13575838
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This handler deals with all the nomic rules for councils.
 * @author Pinkfish
 * @started Fri Jun 23 19:51:04 PDT 2000
 */
#include <nomic_system.h>

private mapping _rules;

void save_me();
int query_can_change_rule(string area, class nomic_rule rule);
class nomic_rule find_nomic_rule(string area, string creator, string text);

void create() {
   _rules = ([ ]);
} /* create() */

/**
 * This method adds a nomic rule into the system.
 * @param area the area the rule is added in
 * @param type the type of rule to add
 * @param creator the person that created the rule
 * @param text the text associated with the rule
 * @return the new number of the rule, NOMIC_ERROR on fai;l
 */
int add_nomic_rule(string area, int type, string creator, string text) {
   int bing;
   class nomic_rule nomic_rule;

   if (!_rules[area]) {
      return NOMIC_ERROR;
   }
   if (type < 0 || type >= sizeof(_rules[area]->new_type_num)) {
      return NOMIC_ERROR;
   }

   if (find_nomic_rule(area, creator, text)) {
      return NOMIC_ERROR;
   }

   nomic_rule = new(class nomic_rule);
   bing = _rules[area]->new_type_num[type];
   nomic_rule->id = bing;
   nomic_rule->creator = creator;
   nomic_rule->type = type;
   nomic_rule->text = text;
   nomic_rule->date_created = time();
   nomic_rule->amendments = ({ });
   _rules[area]->rules += ({ nomic_rule });
   _rules[area]->new_type_num[type] = bing + 1;
   save_me();
   return bing;
} /* add_nomic_rule() */

/**
 * This method adds a nomic rule into the system.
 * @param area the area the rule is added in
 * @param new_rule the rule that is being added
 * @param type the type of the rule
 * @return the new number of the rule, NOMIC_ERROR on fai;l
 */
protected int add_nomic_rule_class(string area,
                                   class nomic_rule new_rule,
                                   int type) {
   int bing;

   if (!_rules[area]) {
      return NOMIC_ERROR;
   }

   if (type < 0 || type >= sizeof(_rules[area]->new_type_num)) {
      return NOMIC_ERROR;
   }

   if (find_nomic_rule(area, new_rule->creator, new_rule->text)) {
      return NOMIC_ERROR;
   }

   bing = _rules[area]->new_type_num[type];
   new_rule->id = bing;
   new_rule->type = type;
   _rules[area]->rules += ({ new_rule });
   _rules[area]->new_type_num[type] = bing + 1;
   save_me();
   return bing;
} /* add_nomic_rule() */

/**
 * This method moves a rule from one type to another.
 * @param area the area the rule is added in
 * @param rule the rule to move
 * @param type the new type of the rule
 * @return the new number of the rule, NOMIC_ERROR on fai;l
 */
protected int move_nomic_rule(string area, class nomic_rule rule,
                              int type) {
   int bing;
   int i;

   if (!_rules[area]) {
      return NOMIC_ERROR;
   }
   if (type < 0 || type >= sizeof(_rules[area]->new_type_num)) {
      return NOMIC_ERROR;
   }

   bing = _rules[area]->new_type_num[type];
   for (i = 0; i < sizeof(_rules[area]->rules); i++) {
      if (_rules[area]->rules[i]->id == rule->id) {
         if (!query_can_change_rule(area, _rules[area]->rules[i])) {
            return NOMIC_ERROR;
         }
         _rules[area]->rules[i]->id = bing;
         ((class nomic_rule)_rules[area]->rules[i])->type = type;
         _rules[area]->new_type_num[type] = bing + 1;
         save_me();
         return bing;
      }
   }
   return NOMIC_ERROR;
} /* add_nomic_rule() */

/**
 * This method moves a rule from one type to another.
 * @param area the area the rule is added in
 * @param rule the rule to move
 * @param type the new type of the rule
 * @return the new number of the rule, NOMIC_ERROR on fai;l
 */
int change_nomic_rule(string area, class nomic_rule rule) {
   int i;

   if (!_rules[area]) {
      return 0;
   }

   for (i = 0; i < sizeof(_rules[area]->rules); i++) {
      if (_rules[area]->rules[i]->id == rule->id) {
         if (!query_can_change_rule(area, _rules[area]->rules[i])) {
            return NOMIC_ERROR;
         }
         rule->type = ((class nomic_rule)_rules[area]->rules[i])->type;
         rule->id = ((class nomic_rule)_rules[area]->rules[i])->id;
         _rules[area]->rules[i] = rule;
         save_me();
         return 1;
      }
   }
   return 0;
} /* add_nomic_rule() */

/**
 * This method removes a nomic rule from the system.
 * @param area the area the rule is removed in
 * @param id the id of the rule to remove
 * @return the status of the removal, NOMIC_ERROR on fai;l
 */
int remove_nomic_rule(string area, int id) {
   class nomic_rule nomic_rule;

   if (!_rules[area]) {
      return NOMIC_ERROR;
   }
   foreach (nomic_rule in _rules[area]->rules) {
      if (nomic_rule->id == id) {
         if (!query_can_change_rule(area, nomic_rule)) {
            return NOMIC_ERROR;
         }
         _rules[area]->rules -= ({ nomic_rule });
         save_me();
         return 1;
      }
   }
   return 0;
} /* remove_nomic_rule() */

/**
 * This method by passes the standard nomic rules check, it can be used
 * to remove an immutable rule.
 */ 
int int_remove_nomic_rule(string area, int id) {
   class nomic_rule nomic_rule;

   if (!_rules[area]) {
      return NOMIC_ERROR;
   }
   foreach (nomic_rule in _rules[area]->rules) {
      if (nomic_rule->id == id) {
         _rules[area]->rules -= ({ nomic_rule });
         save_me();
         return 1;
      }
   }
   return 0;
} /* remove_nomic_rule() */

/**
 * This method returns a nomic rule for the specified area.
 * @param area the area to get the rule in
 * @param id the id of the rule to match
 * @return 0 if failed, the class if succeeded
 */
class nomic_rule query_nomic_rule(string area, int id) {
   class nomic_rule nomic_rule;

   if (!_rules[area]) {
      return 0;
   }
   foreach (nomic_rule in _rules[area]->rules) {
      if (nomic_rule->id == id) {
         return copy(nomic_rule);
      }
   }
   return 0;
} /* query_nomic_rule() */

/**
 * This method returns all the nomic rules for the area.
 * @param area the area to get the rule sin
 * @return all the rules
 */
class nomic_rule* query_all_nomic_rules(string area) {
   if (!_rules[area]) {
      return ({ });
   }

   return copy(_rules[area]->rules);
} /* query_all_nomic_rules() */

/**
 * This method searches through for the specified rule.  This stops the
 * same rule being added more than once by some error in the code.
 * @param area the area the rule is in
 * @param creator the creator of the rule
 * @param text the text of the rule
 * @return the rule if it is found, 0 if not
 */
class nomic_rule find_nomic_rule(string area, string creator, string text) {
   class nomic_rule rule;

   if (!_rules[area]) {
      return 0;
   }

   foreach (rule in _rules[area]->rules) {
      if (rule->creator == creator && rule->text == text) {
         return rule;
      }
   }

   return 0;
} /* find_nomic_rule() */

/**
 * This method creates an new nomic area.
 * @param area the new nomic area name
 * @return 1 on success, 0 on failure
 */
int create_area(string area) {
   class nomic_area new_area;

   if (_rules[area]) {
       return 0;
   }

   new_area = new(class nomic_area);
   new_area->new_type_num = NOMIC_DEFAULT_TYPE_NUMS;
   new_area->rules = ({ });
   _rules[area] = new_area;
   return 1;
} /* create_area() */

/**
 * This method returns the number for the corresponding type name.
 * @param name the name of the area to get the number of
 * @return the type number
 */
int query_type_number(string name) {
   switch (lower_case(name)) {
   case "immutable" :
      return NOMIC_TYPE_IMMUTABLE;
   case "general" :
      return NOMIC_TYPE_GENERAL;
   case "citizen" :
      return NOMIC_TYPE_CITIZEN;
   default :
      return NOMIC_ERROR;
   }
} /* query_type_number() */

/**
 * This method returns the name of the corresponding type name.
 * @param type_no the type number
 * @return the type name string
 */
string query_type_name(int type_no) {
   switch (type_no) {
   case NOMIC_TYPE_IMMUTABLE :
      return "immutable";
   case NOMIC_TYPE_GENERAL :
      return "general";
   case NOMIC_TYPE_CITIZEN :
      return "citizen";
   default :
      return "error";
   }
} /* query_type_name() */

/**
 * This method checks to see if the specified rule can be changed.
 * @param area the area in which the rule will be changed in
 * @param rule the rule to check
 * @return 1 if it can be changed, 0 if not
 */
int query_can_change_rule(string area, class nomic_rule rule) {
   return rule->type != NOMIC_TYPE_IMMUTABLE;
} /* query_can_change_rule() */

/**
 * This method returns the rule as a string.
 * @param rule the rule to make a string
 * @return the string version of us
 */
string rule_as_string(int indent, class nomic_rule rule) {
   string ret;
   class nomic_amendment amend;

   ret = "$I$" + (indent + 5) + "=" + sprintf("%*s", indent, "") +
          (rule->id?rule->id+"":"(" +
          NOMIC_HANDLER->query_type_name(rule->type) + ")") + " by " +
          capitalize(rule->creator) + " (" +
          ctime(rule->date_created) + "):\n" + rule->text +
          "\n";
   foreach (amend in rule->amendments) {
      ret += "$I$" + (indent + 10) + "=" + sprintf("%*s", indent + 3, "") +
             capitalize(amend->amender) + " (" +
             ctime(amend->date_amended) + "):\n" +
             amend->text + "\n";
   }

   return ret;
} /* rule_as_string() */
// --- END [/mnt/home2/grok/lib/obj/handlers/inherit/nomic_rules.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/inherit/player_council.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/inherit/player_council.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628481   Available: 13575835
Inodes: Total: 5242880    Free: 4960134
27237 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/inherit/player_council.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628481   Available: 13575835
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This handler is for the control of player houses.
 * @author Pinkfish
 * @started Fri Jun 23 22:50:02 PDT 2000
 */
inherit "/obj/handlers/inherit/nomic_rules";
inherit "/obj/handlers/inherit/case_control";
inherit "/obj/handlers/inherit/citizen_elections";
#define NOMIC_SYSTEM_NO_CLASSES
#include <nomic_system.h>
#include <player.h>

private mapping _motions;
private mapping _new_citizens;
private int _completion_id;

void save_me();
class nomic_motion find_motion(string area, int rule_no, int type);
void update_immutables(string area);
void send_council_inform(string area, int only_magistrates,
                         string mess);
string motion_as_string(int indent, string area, class nomic_motion motion, int brief);

void create() {
   _motions = ([ ]);
   _new_citizens = ([ ]);
   citizen_elections::create();
   nomic_rules::create();
   case_control::create();

   //
   // Check for motion completions at midnight... (well, 2 minutes after).
   //
   _completion_id = call_out("check_for_completions",
       (time() - time() % (24 * 60 * 60) + (24 * 60 * 60) + (2 * 60)) - time());
} /* create() */

/**
 * This method creates a new area.
 * @param area the new area
 */
void create_area(string area) {
   citizen_elections::create_area(area);
   nomic_rules::create_area(area);
   case_control::create_area(area);

   _motions[area] = ({ });
   _new_citizens[area] = ({ });
   update_immutables(area);
} /* create_area() */

/**
 * This method updates the immutable laws with the new set of general rules.
 * @param area the area to update.
 */
void update_immutables(string area) {
   string tmp;
   string type;
   string file;
   int int_type;
   class nomic_rule rule;

   //
   // Get rid of the old immutables first.
   //
   foreach (rule in query_all_nomic_rules(area)) {
      if (rule->type == NOMIC_TYPE_IMMUTABLE) {
         remove_nomic_rule(area, rule->id);
      }
   }

   //
   // Add in all the default rules.
   //
   foreach (file in get_dir(NOMIC_RULE_DEFAULT_DIR)) {
      if (file_size(NOMIC_RULE_DEFAULT_DIR + "/" + file) > 0) {
         tmp = read_file(NOMIC_RULE_DEFAULT_DIR + "/" + file);
         type = explode(tmp, "\n")[0];
         tmp = implode(explode(tmp, "\n")[1..], "\n");
         switch (type) {
         case "immutable" :
            int_type = NOMIC_TYPE_IMMUTABLE;
            break;
         case "citizen" :
            int_type = NOMIC_TYPE_CITIZEN;
            break;
         case "general" :
            int_type = NOMIC_TYPE_GENERAL;
            break;
         default :
            int_type = -1;
            printf("Ignoring file " + file + "\n");
            break;
         }
         if (int_type != -1) {
            add_nomic_rule(area, int_type, area + " administrator", tmp);
         }
      }
   }
   save_me();
} /* create_area() */

private int query_next_motion_id(string area) {
   int num;
   class nomic_motion fluff;

   num = 1;
   foreach (fluff in _motions[area]) {
      if (num <= fluff->identifier) {
         num = fluff->identifier + 1;
      }
   }

   return num;
} /* query_next_motion_id() */

/**
 * This method puts a new rule up for voting.  It is first placed into
 * the hands of the magistrates, then into the hands of the players.
 * @param area the area for the rule to be voted on in
 * @param type the type of the rules
 * @param text the text associated with the new rule
 * @return 1 on success, 0 on failure
 */
int add_create_rule_motion(string area, int type, string text,
                          string creator) {
   class nomic_motion fluff;

   if (!is_magistrate_of(area, creator)) {
      return 0;
   }
   fluff = new(class nomic_motion);
   fluff->motion_type = NOMIC_MOTION_TYPE_RULE_ADD;
   fluff->rule = new(class nomic_rule);
   fluff->rule->creator = creator;
   fluff->rule->text = text;
   fluff->rule->type = type;
   fluff->rule->amendments = ({ });
   fluff->rule->date_created = time();
   fluff->comments = ({ });
   fluff->voted = ({ });
   fluff->state = NOMIC_STATE_COUNCIL_REVIEW;
   fluff->date_added = time();
   fluff->date_event = time();
   fluff->yes_votes = 0;
   fluff->no_votes = 0;
   fluff->added_by = creator;
   fluff->identifier = query_next_motion_id(area);
   _motions[area] += ({ fluff });
   save_me();
   send_council_inform(area, 1, creator + " added a new rule motion");
   post_magistrate_message(area, "New: Create rule motion",
              PLAYER_OB->convert_message(motion_as_string(0, area, fluff, 0)));
   return 1;
} /* add_motion_for_voting() */

/**
 * This method puts up a request to move a rule from one type to another.
 * @param area the area to do the move in
 * @param rule_no the rule number to move
 * @param type the type to move the rule to
 * @param creator the creator of this request
 * @return 1 on success, 0 on failure
 */
int add_move_rule_type_motion(string area, int rule_no, int type,
                              string creator) {
   class nomic_motion fluff;
   class nomic_rule bing;

   bing = query_nomic_rule(area, rule_no);
   if (!bing) {
      return 0;
   }

   if (bing->type == type) {
      return 0;
   }

   //
   // First check and see if are alread moveing this rule.
   //
   fluff = find_motion(area, rule_no, NOMIC_MOTION_TYPE_RULE_MOVE);
   if (fluff) {
      return 0;
   }

   fluff = new(class nomic_motion);
   fluff->motion_type = NOMIC_MOTION_TYPE_RULE_MOVE;
   fluff->rule = bing;
   fluff->new_rule_type = type;
   fluff->comments = ({ });
   fluff->voted = ({ });
   fluff->state = NOMIC_STATE_COUNCIL_REVIEW;
   fluff->date_added = time();
   fluff->date_event = time();
   fluff->yes_votes = 0;
   fluff->no_votes = 0;
   fluff->added_by = creator;
   fluff->identifier = query_next_motion_id(area);
   _motions[area] += ({ fluff });
   save_me();
   send_council_inform(area, 1, creator + " added a move rule motion");
   post_magistrate_message(area, "New: Move rule motion",
              PLAYER_OB->convert_message(motion_as_string(0, area, fluff, 0)));
   return 1;
} /* add_move_rule_type() */

/**
 * This method adds in a request to amend a rule.
 * @param area the area to put the amendment in
 * @param rule_no the rule to amend
 * @param amendment the amendment text
 * @param creator the person doing the amendment
 * @return 1 on success, 0 on failure
 */
int add_amend_rule_motion(string area, int rule_no, string amendment,
                           string creator) {
   class nomic_motion fluff;
   class nomic_rule bing;
   class nomic_amendment amend;

   bing = query_nomic_rule(area, rule_no);
   if (!bing) {
      return 0;
   }

   //
   // First check and see if are already amending this rule.
   //
   fluff = find_motion(area, rule_no, NOMIC_MOTION_TYPE_RULE_AMEND);
   if (fluff) {
      return 0;
   }

   fluff = new(class nomic_motion);
   fluff->motion_type = NOMIC_MOTION_TYPE_RULE_AMEND;
   amend = new (class nomic_amendment);
   amend->amender = creator;
   amend->text = amendment;
   amend->date_amended = time();
   bing->amendments += ({ amend });
   fluff->rule = bing;
   fluff->comments = ({ });
   fluff->voted = ({ });
   fluff->state = NOMIC_STATE_COUNCIL_REVIEW;
   fluff->date_added = time();
   fluff->date_event = time();
   fluff->yes_votes = 0;
   fluff->no_votes = 0;
   fluff->added_by = creator;
   fluff->identifier = query_next_motion_id(area);
   _motions[area] += ({ fluff });
   save_me();
   send_council_inform(area, 1, creator + " added an add rule motion");
   post_magistrate_message(area, "New: Ammend rule motion",
              PLAYER_OB->convert_message(motion_as_string(0, area, fluff, 0)));
   return 1;
} /* add_rule_amendment() */

/**
 * This method remove a request to amend a rule.
 * @param area the area to put the amendment in
 * @param rule_no the rule to amend
 * @param amendment the amendment text
 * @param creator the person doing the amendment
 * @return 1 on success, 0 on failure
 */
int remove_rule_motion(string area, int rule_no, string creator) {
   class nomic_motion fluff;
   class nomic_rule bing;

   bing = query_nomic_rule(area, rule_no);
   if (!bing) {
      return 0;
   }

   //
   // First check and see if are alread removeing this rule.
   //
   fluff = find_motion(area, rule_no, NOMIC_MOTION_TYPE_RULE_REMOVE);
   if (fluff) {
      return 0;
   }

   fluff = new(class nomic_motion);
   fluff->motion_type = NOMIC_MOTION_TYPE_RULE_REMOVE;
   fluff->rule = bing;
   fluff->comments = ({ });
   fluff->voted = ({ });
   fluff->state = NOMIC_STATE_COUNCIL_REVIEW;
   fluff->date_added = time();
   fluff->date_event = time();
   fluff->yes_votes = 0;
   fluff->no_votes = 0;
   fluff->added_by = creator;
   fluff->identifier = query_next_motion_id(area);
   _motions[area] += ({ fluff });
   save_me();
   send_council_inform(area, 1, creator + " added a remove rule motion");
   post_magistrate_message(area, "New: Remove rule motion",
              PLAYER_OB->convert_message(motion_as_string(0, area, fluff, 0)));
   return 1;
} /* remove_rule_motion() */

/**
 * This method returns a nice new rule.
 * @param area the areat to look in
 * @param id the id of the new rule to find
 * @return 1 on success, 0 on failure
 */
class nomic_motion query_motion(string area, int id) {
   class nomic_motion fluff;

   if (!_motions[area]) {
      return 0;
   }

   foreach (fluff in _motions[area]) {
      if (fluff->identifier == id) {
         return fluff;
      }
   }

   return 0;
} /* query_motion() */

/**
 * This method returns all the new rules for the specified area.
 * @param area the area to return the new rules in
 * @return the array of new rules
 */
class nomic_motion* query_all_motions(string area) {
   if (!_motions[area]) {
      return ({ });
   }

   return copy(_motions[area]);
} /* query_all_motions() */

/**
 * This method finds the specified motion.
 * @param area the area to look in
 * @param rule_no the rule number
 * @param type the type of the motion
 * @return the motion if successful, 0 if not
 */
class nomic_motion find_motion(string area, int rule_no, int type) {
   class nomic_motion motion;

   foreach (motion in _motions[area]) {
      if (motion->rule->id == rule_no &&
          motion->motion_type == type) {
         return motion;
      }
   }
   return 0;
} /* find_motion() */

/**
 * This method adds a comment to the new rule/amendment/whatever.
 * @param area the area the comment is to go in
 * @param id the rule update id
 * @param comment the comment to make
 * @param commenter the person commenting
 * @return 1 on success, 0 on failure
 */
int comment_on_motion(string area, int id, string comment_text,
                            string commenter) {
   class nomic_comment comment; 
   class nomic_motion bing;
   
   bing = query_motion(area, id);
   if (!bing) {
      return 0;
   }

   if (bing->state != NOMIC_STATE_COUNCIL_REVIEW &&
       bing->state != NOMIC_STATE_COUNCIL_VOTE) {
      return 0;
   }

   comment = new(class nomic_comment);
   comment->text = comment_text;
   comment->commenter = commenter;
   comment->date_commented = time();
   bing->comments += ({ comment });
   save_me();
   return 1;
} /* add_motion_update_comment() */

/**
 * This method adds an amendment to the new rule/amendment/whatever, this
 * rewrites the text of the ammendment of whatever it is.
 * @param area the area the amendmend is to go in
 * @param id the rule update id
 * @param amendmend the amendmend to make
 * @param amendmender the person amendmending
 * @return 1 on success, 0 on failure
 */
int amend_motion(string area, int id, string amend_text,
                    string amender) {
   //class nomic_amendment amend;
   class nomic_motion bing;
   
   bing = query_motion(area, id);
   if (!bing) {
      return 0;
   }

   // This only works in the review phase.
   if (bing->state != NOMIC_STATE_COUNCIL_REVIEW) {
      return 0;
   }

/*
   amend = new(class nomic_amendment);
   amend->text = amend_text;
   amend->amender = amender;
   amend->date_amended = time();
   bing->rule->amendments += ({ amend });
 */
   switch (bing->motion_type) {
   case NOMIC_MOTION_TYPE_RULE_ADD :
      bing->rule->text = amend_text;
      break;
   case NOMIC_MOTION_TYPE_RULE_REMOVE :
   case NOMIC_MOTION_TYPE_RULE_MOVE :
      return 0;
   case NOMIC_MOTION_TYPE_RULE_AMEND :
      bing->rule->amendments[<1]->text = amend_text;
   }
   save_me();
   return 1;
} /* add_motion_update_comment() */

/**
 * This method votes for the specified ammentment/whatever.
 * @param area the area to vote in
 * @param id the id to vote for
 * @param vote_type the type of the vote
 * @param voter the person is voting
 * @return 1 on success, 0 on failure
 */
int vote_for_motion(string area, int id, int vote_type, string voter) {
   class nomic_motion bing;

   bing = query_motion(area, id);
   if (!bing) {
      return 0;
   }

   if (member_array(voter, bing->voted) != -1) {
      return 0;
   }

   if (bing->state != NOMIC_STATE_COUNCIL_VOTE &&
       bing->state != NOMIC_STATE_CITIZEN_VOTE) {
      return 0;
   }

   switch (vote_type) {
   case NOMIC_VOTE_YES :
      bing->yes_votes++;
      break;
   case NOMIC_VOTE_NO :
      bing->no_votes++;
      break;
   case NOMIC_VOTE_ABSTAIN :
      bing->abstain_votes++;
      break;
   default :
      return 0;
   }
   bing->voted += ({ voter });
   save_me();
   return 1;
} /* vote_for_motion() */

/**
 * This method checks to see if the person has voted for the specified
 * new rule/amendment/whatever
 * @param area the area to check
 * @param id the id to check
 * @param voter the person to check for voting
 * @return 1 on success, 0 on failure
 */
int has_voted_for_motion(string area, int id, string voter) {
   class nomic_motion bing;

   bing = query_motion(area, id);
   if (!bing) {
      return 0;
   }

   return member_array(voter, bing->voted) != -1;
} /* has_voted_for_motion() */

/**
 * This method returns the current set of votes for the specied new rule.
 * @param area the area to lookup the votes in
 * @param id the idea to check
 * @return ({ yes, no, abstain })
 */
int* query_votes_for_motion(string area, int id) {
   class nomic_motion bing;

   bing = query_motion(area, id);
   if (!bing) {
      return 0;
   }

   return ({ bing->yes_votes, bing->no_votes, bing->abstain_votes });
} /* query_voted_for_motions() */

private void remove_motion(string area, class nomic_motion motion) {
   int i;

   for (i = 0; i < sizeof(_motions[area]); i++) {
      if (_motions[area][i] == motion) {
         _motions[area] = _motions[area][0..i-1] + _motions[area][i+1..];
      }
   }
} /* remove_motion() */

/**
 * This method sends informs to all the specified council of some sort of
 * nifty council event.
 * @param area the area the council is for
 * @param only_magistrates only send it to the magistrates?
 * @param mess the message to send
 */
void send_council_inform(string area, int only_magistrates,
                         string mess) {
   object *obs;

   if (only_magistrates) {
      obs = filter(users(), (: is_magistrate_of($2, $1->query_name()) :), area);
   } else {
      obs = filter(users(), (: is_citizen_of($2, $1->query_name()) :), area);
   }
   call_other(obs, "event_inform", this_object(), mess, "council");
} /* send_council_inform() */

/**
 * This method figures out the compleion time for the specified motion.
 * @param area the area to check
 * @param the motion in the area
 * @return the completion time
 */
int query_completion_time(string area, class nomic_motion motion) {
   return (motion->date_event - motion->date_event % (24 * 60 * 60) +
           7 * (24 * 60 * 60));
} /* query_completion_time() */

/**
 * This method completes the vote on the specified new rule.
 * @param area the area to complete the rule in
 * @param id the id to complete
 * @return 1 on success, 0 on failure
 */
int complete_motion(string area, int id) {
   class nomic_motion bing;
   class nomic_motion motion;
   int passed;
   int new_num;
   string mess;
   int only_magistrates;
   string voting_result;

   bing = query_motion(area, id);
   if (!bing) {
      return 0;
   }

   passed = bing->yes_votes > bing->no_votes;

   voting_result = "Voting Results:\n"
                   "    Yes: " + bing->yes_votes + "\n"
                   "     No: " + bing->no_votes + "\n"
                   "Abstain: " + bing->abstain_votes + "\n";
   mess = "Motion added by " + bing->added_by + " to ";
   switch (bing->motion_type) {
   case NOMIC_MOTION_TYPE_RULE_ADD :
      mess += "add a new rule";
      break;
   case NOMIC_MOTION_TYPE_RULE_REMOVE :
      mess += "remove rule " + bing->rule->id;
      break;
   case NOMIC_MOTION_TYPE_RULE_MOVE :
      mess += "move rule " + bing->rule->id;
      break;
   case NOMIC_MOTION_TYPE_RULE_AMEND :
      mess += "amend rule " + bing->rule->id;
      break;
   }
   if (passed || bing->state == NOMIC_STATE_COUNCIL_REVIEW) {
      switch (bing->state) {
      case NOMIC_STATE_COUNCIL_REVIEW :
         bing->yes_votes = 0;
         bing->no_votes = 0;
         bing->abstain_votes = 0;
         bing->voted = ({ });
         bing->state = NOMIC_STATE_COUNCIL_VOTE;
         mess += " is open for magistrates to vote";
         only_magistrates = 1;
         post_magistrate_message(area, "Motion now in voting phase",
              PLAYER_OB->convert_message(motion_as_string(0, area, bing, 0)));
         break;
      case NOMIC_STATE_COUNCIL_VOTE :
         //
         // Pass this and set all the defaults back up.
         //
         bing->yes_votes = 0;
         bing->no_votes = 0;
         bing->abstain_votes = 0;
         bing->voted = ({ });
         bing->state = NOMIC_STATE_CITIZEN_VOTE;
         bing->comments = ({ });
         mess += " is open for citizens to vote";
         post_magistrate_message(area, "Law passed onto citizens",
                    PLAYER_OB->convert_message(rule_as_string(0, bing->rule)) +
                              "\n\n" + voting_result);
         post_citizen_message(area, "New motion for voting on",
              PLAYER_OB->convert_message(motion_as_string(0, area, bing, 0)));
         break;
      case NOMIC_STATE_CITIZEN_VOTE :
         switch (bing->motion_type) {
         case NOMIC_MOTION_TYPE_RULE_ADD :
            add_nomic_rule_class(area, bing->rule, bing->motion_type);
            break;
         case NOMIC_MOTION_TYPE_RULE_AMEND :
            change_nomic_rule(area, bing->rule);
            break;
         case NOMIC_MOTION_TYPE_RULE_MOVE :
            new_num = move_nomic_rule(area, bing->rule, bing->new_rule_type);
            foreach (motion in _motions[area]) {
               if (motion->rule->id == bing->rule->id) {
                  motion->rule->id = new_num;
               }
            }
            break;
         case NOMIC_MOTION_TYPE_RULE_REMOVE :
            remove_nomic_rule(area, bing->rule->id);
            break;
         }
         remove_motion(area, bing);
         mess += " is now law";
         post_citizen_message(area, "New Law!",
                    PLAYER_OB->convert_message(rule_as_string(0, bing->rule)));
         post_magistrate_message(area, "New Law!",
                    PLAYER_OB->convert_message(rule_as_string(0, bing->rule)) +
                    "\n\n" + voting_result);
         break;
      }
      bing->date_event = time();
   } else {
      if (bing->state == NOMIC_STATE_COUNCIL_VOTE) {
         mess += " not passed by the magistrates";
         only_magistrates = 1;
         post_magistrate_message(area, "Law not passed onto citizens",
                              rule_as_string(0, bing->rule) + "\n\n" +
                              voting_result);
      } else {
         mess += " not ratified by the citizens";
         only_magistrates = 0;
         post_citizen_message(area, "Law not passed",
                              rule_as_string(0, bing->rule));
         post_magistrate_message(area, "Law not passed",
                              rule_as_string(0, bing->rule) + "\n\n" +
                              voting_result);
      }
      remove_motion(area, bing);
   }

   save_me();
   send_council_inform(area, only_magistrates, mess);
   return 1;
} /* complete_motion() */

/**
 * This method figures out all the current things and when they completed.
 */
void check_for_completions() {
   string area;
   class nomic_motion* bits;
   class nomic_motion motion;

   foreach (area, bits in _motions) {
      foreach (motion in bits) {
         if (query_completion_time(area, motion) < time()) {
            complete_motion(area, motion->identifier);
         }
      }
   }

   remove_call_out(_completion_id);
   _completion_id = call_out("check_for_completions",
            (time() - time() % (24 * 60 * 60) + (24 * 60 * 60)) - time());

   //
   // Check the cases to see if they want to mess around too.
   //
   update_recently_closed_cases();
} /* check_for_completions() */

/**
 * This method returns the new motion as a string.
 * @param indent the indentation to putin front of all the lines
 * @param area the area the motion is defined in
 * @param motion the new motion to turn into a styring
 * @param brief disable comments
 * @return the string version of the motion
 */
string motion_as_string(int indent, string area, class nomic_motion motion,
                        int brief) {
   string ret;
   class nomic_comment comment;

   ret = "";
   switch (motion->motion_type) {
   case NOMIC_MOTION_TYPE_RULE_ADD :
      ret += "$I$" + (indent + 5) + "=" + sprintf("%*s", indent, "") +
             motion->identifier + ") Add new rule; added by " +
             capitalize(motion->added_by) + " at " +
             ctime(motion->date_added) + "\n";
      break;
   case NOMIC_MOTION_TYPE_RULE_REMOVE :
      ret += "$I$" + (indent + 5) + "=" + sprintf("%*s", indent, "") +
             motion->identifier + ") Remove rule; added by " +
             capitalize(motion->added_by) + " at " +
             ctime(motion->date_added) + "\n";
      break;
   case NOMIC_MOTION_TYPE_RULE_MOVE :
      ret += "$I$" + (indent + 5) + "=" + sprintf("%*s", indent, "") +
             motion->identifier + ") Transmogrify rule; added by " +
             capitalize(motion->added_by) + " at " +
             ctime(motion->date_added) + "\n";
      break;
   case NOMIC_MOTION_TYPE_RULE_AMEND :
      ret += "$I$" + (indent + 5) + "=" + sprintf("%*s", indent, "") +
             motion->identifier + ") Amend rule; added by " +
             capitalize(motion->added_by) + " at " +
             ctime(motion->date_added) + "\n";
      break;
   }

   ret += rule_as_string(5 + indent, motion->rule);
   if (sizeof(motion->comments)) {
      if (!brief) {
         ret += "$I$" + (indent + 5) + "=     Comments:\n";
         foreach (comment in motion->comments) {
            ret += "$I$" + (indent + 11) + "=" + sprintf("%*s", indent + 3, "") +                capitalize(comment->commenter) + " (" +
                   ctime(comment->date_commented) + "):\n" +
                   comment->text + "\n";
         }
      } else {
         ret += "$I$0=" + sprintf("%*s", indent, "") + "     " +
                 sizeof(motion->comments) + " Comments.\n";
      }
   } else {
      ret += "$I$0=" + sprintf("%*s", indent, "") + "     No Comments.\n";
   }

   switch (motion->state) {
   case NOMIC_STATE_COUNCIL_REVIEW :
      ret += "$I$0=" + sprintf("%*s", indent, "") +
             "The item is currently being reviewed by the magistrates.\n";
      break;
   case NOMIC_STATE_COUNCIL_VOTE :
      ret += "$I$0=" + sprintf("%*s", indent, "") +
             "The item is currently being voted on by the magistrates.\n";
      break;
   case NOMIC_STATE_CITIZEN_VOTE :
      ret += "$I$0=" + sprintf("%*s", indent, "") +
             "The item is currently being ratified by the citizens.\n";
      break;
   }

   //
   // The next stage!
   //
   ret += "$I$0=" + sprintf("%*s", indent, "") +
          "The item will go onto the next stage at " +
          ctime(query_completion_time(area, motion)) +
          ".\n";

   return ret;
} /* motion_as_string() */

/**
 * This method turns a rule into html.
 * @param rule the rule to turn into html
 * @return the rule as a string
 */
string rule_as_html(class nomic_rule rule) {
   string ret;
   class nomic_amendment amend;

   ret = "<i><b>" + (rule->id?rule->id+"":"(" +
          NOMIC_HANDLER->query_type_name(rule->type) + ")") + "</b> by " +
          capitalize(rule->creator) + " (" +
          ctime(rule->date_created) + "):</i>\n"
          "<p style=\"margin-left: 30pt;margin-top: 5pt\">\n" +
          replace_string(rule->text, "\n", "<br>") +
          "<br>\n";
   foreach (amend in rule->amendments) {
      ret += "<i><b>Ammendment</b> by " + capitalize(amend->amender) + " (" +
             ctime(amend->date_amended) + "):</i>\n"
             "<p style=\"margin-left: 60pt;margin-top: 5pt\">\n" +
             replace_string(amend->text, "\n", "<br>") +
             "\n</p>\n";
   }

   ret += "</p>\n";
   return ret;
} /* rule_as_html() */

/**
 * This method returns the new motion as a string.
 * @param area the area the motion is defined in
 * @param motion the new motion to turn into a styring
 * @return the string version of the motion
 */
string motion_as_html(string area, class nomic_motion motion) {
   string ret;
   class nomic_comment comment;

   ret = "";
   switch (motion->motion_type) {
   case NOMIC_MOTION_TYPE_RULE_ADD :
      ret += "<b>" + motion->identifier + ") Add new rule; added by " +
             capitalize(motion->added_by) + " at " +
             ctime(motion->date_added) + "</b>\n";
      break;
   case NOMIC_MOTION_TYPE_RULE_REMOVE :
      ret += "<b>" + motion->identifier + ") Remove rule; added by " +
             capitalize(motion->added_by) + " at " +
             ctime(motion->date_added) + "</b>\n";
      break;
   case NOMIC_MOTION_TYPE_RULE_MOVE :
      ret += "<b>" + motion->identifier + ") Transmogrify rule; added by " +
             capitalize(motion->added_by) + " at " +
             ctime(motion->date_added) + "</b>\n";
      break;
   case NOMIC_MOTION_TYPE_RULE_AMEND :
      ret += "<b>" + motion->identifier + ") Amend rule; added by " +
             capitalize(motion->added_by) + " at " +
             ctime(motion->date_added) + "</b>\n";
      break;
   }

   ret += "<ul>" + rule_as_html(motion->rule) + "</ul>";
   if (sizeof(motion->comments)) {
      ret += "<b>Comments:</b><br>\n";
      foreach (comment in motion->comments) {
         ret += ctime(comment->date_commented) + "):<br>\n" +
                comment->text + "<p>\n";
      }
   }

   switch (motion->state) {
   case NOMIC_STATE_COUNCIL_REVIEW :
      ret += "The item is currently being reviewed by the magistrates.\n";
      break;
   case NOMIC_STATE_COUNCIL_VOTE :
      ret += "The item is currently being voted on by the magistrates.\n";
      break;
   case NOMIC_STATE_CITIZEN_VOTE :
      ret += "The item is currently being ratified by the citizens.\n";
      break;
   }

   //
   // The next stage!
   //
   ret += "<br>The item will go onto the next stage at " +
          ctime(query_completion_time(area, motion)) +
          ".\n";

   return ret;
} /* motion_as_string() */
// --- END [/mnt/home2/grok/lib/obj/handlers/inherit/player_council.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/inherit/error_handler.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/inherit/error_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628474   Available: 13575828
Inodes: Total: 5242880    Free: 4960134
24274 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/inherit/error_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628474   Available: 13575828
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is a handler to keep track of errors, make adding them and querying
 * them easier.
 * @author Pinkfish
 * @started Mon Jun 17 17:28:04 PDT 2002
 */
#include <db.h>
#include <error_handler.h>

#define SAVE_FILE "/save/handlers/error_handler"

#define ERROR_SUMMARY_FIELDS "id, entrydate, filename, type, category, name, reporter, status, directory"
#define ERROR_DETAILS_FIELDS ERROR_SUMMARY_FIELDS \
                      ", report, runtime"

// 4 weeks.
#define ERROR_REPLY_TIMEOUT (60 * 60 * 24 * 7 * 4)

void finish_update(int type, mixed data, function finished, string query);

private string _db;
private string _user;
private string _password;

void create() {
   unguarded( (: restore_object(SAVE_FILE) :) );
   // Do a call on the handler to clean up the old error replies.
   DB_HANDLER->make_sql_request(_db, _user, _password, 
                 "delete from error_replies where senddate < " +
                 (time() - ERROR_REPLY_TIMEOUT), (: 1 :));
}

/**
 * This method sets up the access permissions to use for accessing
 * the database.
 * @param user the user to use
 * @param db the database to use
 * @param password the password to use
 */
protected void setup_error_handler(string user, string db, string password) {
   _user = user;
   _db = db;
   _password = password;
   save_object(SAVE_FILE);
}

/**
 * This method builds an sql query from the input query.
 * @param query the input query
 * @return an sql string query
 */
protected string build_sql_query(string select_rows, class error_query query) {
   string* restrict;
   string name;
   string tmp;

   restrict = ({ });
   if (query->id != 0) {
      restrict += ({ "id = " + query->id });
   }
   if (query->dir) {
      if (query->dir[<1] == '/') {
         query->dir = query->dir[0..<2];
      }
      if (query->recursive) {
         restrict += ({ "directory like '" + query->dir + "%'" });
      } else {
         restrict += ({ "directory = '" + query->dir + "'" });
      }
   }

   if (query->assigned_to) {
      restrict += ({ "AssignedTo = '" + query->assigned_to + "'" });
   }

   if (query->reporter) {
      restrict += ({ "Reporter = '" + query->reporter + "'" });
   }

   if (query->file_name) {
      restrict += ({ "FileName = '" + query->file_name + "'" });
   }

   if (sizeof(query->type)) {
      tmp = "Type in (";
      foreach (name in query->type) {
         tmp += "'" + name + "',";
      }
      tmp = tmp[0..<2] + ")";
      restrict += ({ tmp });
   }

   if (sizeof(query->status)) {
      tmp = "Status in (";
      foreach (name in query->status) {
         tmp += "'" + name + "',";
      }
      tmp = tmp[0..<2] + ")";
      restrict += ({ tmp });
   }

   if (sizeof(query->category)) {
      tmp = "Category in (";
      foreach (name in query->category) {
         tmp += "'" + name + "',";
      }
      tmp = tmp[0..<2] + ")";
      restrict += ({ tmp });
   }
   if (sizeof(restrict)) {
      tmp = "select " + lower_case(select_rows) + " from errors where " +
             implode(restrict, " and ");
      switch (query->order_by) {
      case ERROR_ORDER_BY_FILENAME :
         tmp += " order by filename, entrydate";
         break;
      case ERROR_ORDER_BY_DATE :
         tmp += " order by entrydate";
         break;
      case ERROR_ORDER_BY_REPORTER :
         tmp += " order by reporter, entrydate";
         break;
      case ERROR_ORDER_BY_DIRECTORY :
      default :
         tmp += " order by directory, filename, entrydate";
         break;
      }
      return tmp + " limit 150";
   }
   return 0;
}

/**
 * This method builds an sql update from the given inputs.
 * @param id the id of the bug to update
 * @param field the field to update
 * @param value the new value of the field
 */
string build_sql_update(int id, string field, mixed value) {
   string ret;

   ret = "update errors set " + field + " = ";
   if (stringp(value)) {
      ret += "'" + value + "'";
   } else {
      ret += "" + value;
   }
   ret += " where id = " + id;
   return ret;
}

/**
 * This method creates the error forward from the input mapping.
 * @param map the mapping to create the forward from
 * @return the error forward class
 */
class error_forward create_error_forward(mapping map) {
   class error_forward newy;

   newy = new(class error_forward);
   newy->date = map["forwarddate"];
   newy->forwarder = map["forwarder"];
   newy->old_directory = map["olddirectory"];
   return newy;
}

/**
 * This method creates the error comment from the input mapping.
 * @param map the mapping to create the comment from
 * @return the error comment class
 */
class error_comment create_error_comment(mapping map) {
   class error_comment newy;

   newy = new(class error_comment);
   newy->date = map["commentdate"];
   newy->commenter = map["commenter"];
   newy->comment = map["comment"];
   return newy;
}

/**
 * This method creates the error summary from the input mapping.
 * @param map the mapping to create the summary from
 * @return the error summary class
 */
class error_summary create_error_summary(mapping map) {
   class error_summary newy;

   newy = new(class error_summary);
   newy->id = map["id"];
   newy->entry_date = map["entrydate"];
   newy->filename = map["filename"];
   newy->category = map["category"];
   newy->assigned_to = map["assignedto"];
   newy->reporter = map["reporter"];
   newy->status = map["status"];
   newy->type = map["type"];
   newy->directory = map["directory"];
   return newy;
}

/**
 * This method creates the error details from the return data.
 */
class error_details create_error_details(mapping map) {
   class error_details newy;

   newy = new(class error_details);
   newy->summary = create_error_summary(map);
   newy->fix_date = map["fixdate"];
   newy->fixer = map["fixer"];
   newy->report = map["report"];
   newy->runtime = map["runtime"];
   return newy;
}

/**
 * This method creates the complete error class from the error details
 * passed in.
 * @param details the details to make the complete error from
 */
class error_complete create_error_complete(class error_details details) {
   class error_complete newy;

   newy = new(class error_complete);
   newy->details = details;
   newy->comments = ({ });
   newy->forwards = ({ });
   newy->replies = ({ });
   return newy;
}

/**
 * This method creates the error reply class from the sql query.
 * @param map the mapping to convert to the class
 * @return the nice new error reply class
 */
class error_replies create_error_replies(mapping map) {
   class error_replies reply;

   reply = new(class error_replies);
   reply->id = map["id"];
   reply->bug_id = map["bug_id"];
   reply->sender = map["sender"];
   reply->status = map["status"];
   reply->recipient = map["recipient"];
   reply->senddate = map["senddate"];
   reply->subject = map["subject"];
   reply->message = map["message"];
   return reply;
}

/**
 * This method finishes a summary based query.
 * @param type the type returned (error etc)
 * @param data the data returned
 * @param finished the function to call on finish
 */
void finish_summary(int type, mixed data, function finished, string query) {
   class error_summary* errors;
   mapping map;

   if (type != DB_SUCCESS) {
      evaluate(finished, type, data, query);
   } else {
      errors = ({ });
      foreach (map in data) {
         errors += ({ create_error_summary(map) });
      }
      evaluate(finished, type, errors, query);
   }
}

/**
 * This method updates the comments based on the query results.
 * @param type type type
 * @param fdata the return data from the query
 * @param function finsiished the finished function
 * @param errors the errors results we are updating
 * @param query the ids list we are using
 */
void finish_forwards(int type, mixed data, function finished,
                     class error_complete* errors, string query) {
   mapping map;
   class error_complete detail;

   if (type != DB_SUCCESS) {
      evaluate(finished, DB_SUCCESS, errors, query);
   } else {
      foreach (map in data) {
         foreach (detail in errors) {
            if (detail->details->summary->id == map["id"]) {
                 detail->forwards += ({ create_error_forward(map) });
            }
         }
      }
      evaluate(finished, type, errors, query);
   }
}

/**
 * This method updates the comments based on the query results.
 * @param type type type
 * @param fdata the return data from the query
 * @param function finsiished the finished function
 * @param errors the errors results we are updating
 * @param query the ids list we are using
 */
void finish_details_error_replies(int type, mixed data, function finished, 
                     class error_complete* errors, string ids, string query) {
   mapping map;
   class error_complete detail;

   if (type != DB_SUCCESS) {
      evaluate(finished, DB_SUCCESS, errors, query);
   } else {
      foreach (map in data) {
         foreach (detail in errors) {
            if (detail->details->summary->id == map["bug_id"]) {
               detail->replies += ({ create_error_replies(map) });
            }
         }
      }
      DB_HANDLER->make_sql_request(_db, _user, _password, 
                     "select id,forwarddate,forwarder,olddirectory from "
                     "forwards where id in " + ids +
                     " order by forwarddate",
                     (: finish_forwards($1, $2, $(finished), $(errors), $(query)) :));
      //evaluate(finished, type, errors, query);
   }
}
/**
 * This method updates the comments based on the query results.
 * @param type type type
 * @param fdata the return data from the query
 * @param function finsiished the finished function
 * @param errors the errors results we are updating
 * @param query the ids list we are using
 */
void finish_comments(int type, mixed data, function finished, 
                     class error_complete* errors, string ids, string query) {
   mapping map;
   class error_complete detail;

   if (type != DB_SUCCESS) {
      evaluate(finished, DB_SUCCESS, errors, query);
   } else {
      foreach (map in data) {
         foreach (detail in errors) {
            if (detail->details->summary->id == map["id"]) {
                 detail->comments += ({ create_error_comment(map) });
            }
         }
      }
      DB_HANDLER->make_sql_request(_db, _user, _password, 
                     "select * from "
                     "error_replies where bug_id in " + ids +
                     " order by senddate",
                     (: finish_details_error_replies($1, $2, $(finished), $(errors), $(ids), $(query)) :));
      //evaluate(finished, type, errors, query);
   }
}

/**
 * This method finishes a details based query.
 * @param type the type returned (error etc)
 * @param data the data returned
 * @param finished the function to call on finish
 */
void finish_details(int type, mixed data, function finished, string query) {
   class error_complete* errors;
   mapping map;
   string str;

   if (type != DB_SUCCESS) {
      evaluate(finished, type, data, query);
   } else {
      errors = ({ });
      str = "(";
      foreach (map in data) {
         errors += ({ create_error_complete(create_error_details(map)) });
         str += map["id"] + ",";
      }
      str = str[0..<2] + ")";
      DB_HANDLER->make_sql_request(_db, _user, _password, 
                     "select commentdate,commenter,comment,id "
                     "from comments where id in " + str +
                     " order by commentdate desc",
                     (: finish_comments($1, $2, $(finished), $(errors), $(str), $(query)) :));
      //evaluate(finished, type, errors, query);
   }
}

/**
 * This method finishes a details based query.
 * @param type the type returned (error etc)
 * @param data the data returned
 * @param finished the function to call on finish
 */
void finish_forward_query(int type, mixed data, function finished,
                          string user, string newdir) {
   class error_complete error;
   mapping map;
   string str;

   if (type != DB_SUCCESS) {
      evaluate(finished, type, data);
   } else {
      map = data[0];
      error = create_error_complete(create_error_details(map));
      if (error->details->summary->directory != newdir) {
         str = "insert into forwards (id,forwarddate,forwarder,olddirectory) " +
               "values (" + error->details->summary->id + ", " + time() + ", '" +
               db_escape(user) + "', '" +
               db_escape(error->details->summary->directory) +
               "')";
         DB_HANDLER->make_sql_request(_db, _user, _password, 
                     str, (: 1 :));


         str = build_sql_update(error->details->summary->id, "directory", newdir);
         DB_HANDLER->make_sql_request(_db, _user, _password, str,
                                 (: finish_update($1, $2, $(finished), $(str)) :));
      } else {
         // Don't forward again if the bug is already there.
         evaluate(finished, type, data);
      }
   }
}

void finish_status_query(int type, mixed data, function finished,
                         string status,
                         int nomail, string user, string subject, 
                         string message) {
   class error_complete error;
   mapping map;
   string str;

   if (type != DB_SUCCESS) {
      evaluate(finished, type, data);
   } else {
      map = data[0];
      error = create_error_complete(create_error_details(map));

      // Send the mail if needed.
      if (!nomail) {
         // Send mail.
         str = "insert into error_replies (bug_id,status,sender,recipient,senddate,message,subject) "
               "values (" +
               error->details->summary->id + ", 'NEW', '" + user + "', '" +
               error->details->summary->reporter + "', " +
               time() + ", '" +
               "Change status from " + error->details->summary->status +
               " to " + status +
               "\n" + db_escape(message) + "', '" + db_escape(subject) + "')";
         DB_HANDLER->make_sql_request(_db, _user, _password, str,
                 (: 1 :) );
      }
   
      str = build_sql_update(error->details->summary->id, "status", status);
      if (!str) {
         return 0;
      }

      DB_HANDLER->make_sql_request(_db, _user, _password, str,
                            (: finish_update($1, $2, $(finished), $(str)) :));
   }
}

/**
 * This method finishes an update based query.
 * @param type the type returned (error etc)
 * @param data the data returned
 * @param finished the function to call on finish
 */
void finish_update(int type, mixed data, function finished, string query) {
   evaluate(finished, type, data, query);
}

/**
 * This method finishes doing a reply lookup.
 */
void finish_error_replies(int type, mixed data, function finished, string query) {
   class error_replies* replies;
   mapping map;

   if (type != DB_SUCCESS) {
      evaluate(finished, type, data);
   } else {
      replies = ({ });
      foreach (map in data) {
         replies += ({ create_error_replies(map) });
      }
      evaluate(finished, type, replies);
   }
}

/**
 * This method sets up a query for the specific data, this returns the
 * bug summary for all the found bugs.
 * @param query the class to use for the query
 * @param finished the function to call when things are finished
 * @return 1 on success, 0 on failure
 */
int do_query_bug_summary(class error_query query, function finished) {
   string str;

   str = build_sql_query(ERROR_SUMMARY_FIELDS,
                         query);
   if (!str) {
      return 0;
   }

   DB_HANDLER->make_sql_request(_db, _user, _password, str,
                                   (: finish_summary($1, $2, $(finished), $(str)) :));
   return 1;
}

/**
 * This method sets up a call to return the details of the error.
 * @param bug_id the id of the bug to get the details from
 * @param finished the function to call when things are finished
 * @return 1 on success, 0 on failure
 */
int do_query_bug_details(int bug_id, function finished) {
   string str;
   class error_query query;

   query = new(class error_query);
   query->id = bug_id;
   str = build_sql_query(ERROR_DETAILS_FIELDS, query);
   if (!str) {
      return 0;
   }

   DB_HANDLER->make_sql_request(_db, _user, _password, str,
                               (: finish_details($1, $2, $(finished), $(str)) :));
   return 1;
}

/**
 * This method finds the bug summary for all the open bugs in the
 * specified directory.
 * @param dir the directory to find the open bugs in
 * @param finished the function to call when things are finished
 * @return 1 on success, 0 on failure
 */
int do_query_open_bugs_in_dir(string dir, function finished) {
   class error_query query;

   query = new(class error_query);
   query->dir = dir;
   query->status = ({ "OPEN", "FIXING", "CONSIDERING" });
   return do_query_bug_summary(query, finished);
}

/**
 * This returns the bug summary for all the open bugs associated with
 * the specified file.
 * @param fname the file name
 * @param finished the function to call when things are finished
 * @return 1 on success, 0 on failure
 */
int do_query_open_bugs_for_fname(string fname, function finished) {
   class error_query query;

   query = new(class error_query);
   query->file_name = fname;
   query->status = ({ "OPEN", "FIXING", "CONSIDERING" });
   return do_query_bug_summary(query, finished);
}

/**
 * This returns the bug summary for all the open bugs associated with
 * the specified reporter.
 * @param reporter the reporter to find the bugs for
 * @param finished the function to call when things are finished
 * @return 1 on success, 0 on failure
 */
int do_query_open_bugs_by_reporter(string reporter, function finished) {
   class error_query query;

   query = new(class error_query);
   query->reporter = reporter;
   query->status = ({ "OPEN", "FIXING", "CONSIDERING" });
   return do_query_bug_summary(query, finished);
}

/**
 * This method changes the type of the bug.  The type is in the set
 * 'bug', 'typo', 'idea'.
 * @param id the id of the bug to update
 * @param type the new type of the bug
 * @return 1 on success, 0 on failure
 */
int do_change_type(int id, string type, function finished) {
   string str;

   str = build_sql_update(id, "type", type);
   if (!str) {
      return 0;
   }
   DB_HANDLER->make_sql_request(_db, _user, _password, str,
                               (: finish_update($1, $2, $(finished), $(str)) :));
   return 1;
}

/**
 * This method changes the category of the bug.  The category is in the set
 * 'room', 'object', 'help', 'ritual', 'spell', 'command', 'general'.
 * @param id the id of the bug to update
 * @param category the new category of the bug
 * @return 1 on success, 0 on failure
 */
int do_change_category(int id, string category, function finished) {
   string str;

   str = build_sql_update(id, "category", category);
   if (!str) {
      return 0;
   }
   DB_HANDLER->make_sql_request(_db, _user, _password, str,
                               (: finish_update($1, $2, $(finished), $(str)) :));
   return 1;
}

/**
 * This method changes who the bug is assigned to.
 * @param id the id of the bug to change
 * @param assigned_to the person it is assigned to
 * @return 1 on success, 0 on failure
 */
int do_assign_bug_to(int id, string assigned_to, function finished) {
   string str;

   str = build_sql_update(id, "assignedto", assigned_to);
   if (!str) {
      return 0;
   }
   DB_HANDLER->make_sql_request(_db, _user, _password, str,
                               (: finish_update($1, $2, $(finished), $(str)) :));
   return 1;
}

/**
 * This method changes the status of the bug, it also automaticaly
 * sends a message to the person who reported the bug and who the bug
 * is assigned to if someone else changes it.
 * @param id the id of the bug to change
 * @param status the new status of the bug
 * @param nomail dont send any mail
 * @param user the user who is making the change
 * @param subject the subject of the mail
 * @param message the main body of the mail
 * @return 0 on failure and 1 on success
 */
int do_change_status(int id, string status, int nomail, string subject,
                     string user, string message, function finished) {
   string str;
   class error_query query;

   query = new(class error_query, id : id);
   str = build_sql_query(ERROR_DETAILS_FIELDS, query);
   if (!str) {
      return 0;
   }

   DB_HANDLER->make_sql_request(_db, _user, _password, str,
             (: finish_status_query($1, $2, $(finished), $(status),
                                    $(nomail), $(user), $(subject),
                                     $(message)) :));
   return 1;
}

/**
 * This method changes the status of the bug, it also automaticaly
 * sends a message to the person who reported the bug and who the bug
 * is assigned to if someone else changes it.
 * @param id the id of the bug to change
 * @param user the user
 * @param dir the directory
 * @return 0 on failure and 1 on success
 */
int do_forward(int id, string user, string dir, function finished) {
   string str;
   class error_query query;

   if (!strlen(dir)) {
      return 0;
   }
   if (dir[0] != '/') {
      dir = "/" + dir;
   }
   if (dir[<1] == '/') {
      dir = dir[0..<2];
   }
   // Don't let people forward to root.
   if (file_size(dir) != -2 || dir == "/") {
      return 0;
   }

   query = new(class error_query, id : id);
   str = build_sql_query(ERROR_DETAILS_FIELDS, query);
   if (!str) {
      return 0;
   }

   // Need to get the details to find the old directory.
   DB_HANDLER->make_sql_request(_db, _user, _password, str,
             (: finish_forward_query($1, $2, $(finished), $(user), $(dir)) :));
   return 1;
}

/**
 * This method adds a comment into the database.
 * @param id the bug to comment on
 * @param user the user making the comment
 * @param comment the comment to make
 * @param finished the finished function
 */
int do_comment(int id, string user, string comment, function finished) {
   string str;

   str = "insert into comments (id,commentdate,commenter,comment) values (" +
         id + ", " + time() + ", '" + user + "', '" + db_escape(comment) +
         "')";
   DB_HANDLER->make_sql_request(_db, _user, _password, str,
                             (: finish_update($1, $2, $(finished), $(str)) :));
   return 1;
}

/**
 * This method looks for all the error replies for the specific recipient.
 * @param recipient the recipient
 * @param only_new only new messages
 * @param finished the function to call on finishing
 */
int do_error_replies(string recipient, int only_new, function finished) {
   string str;

   str = "select * from error_replies where recipient = '" + recipient +
         "'";
   if (only_new) {
      str += " and status = 'NEW'";
   } else {
      str += " and status != 'DELETED'";
   }
   str += " order by senddate";
   DB_HANDLER->make_sql_request(_db, _user, _password, str,
                      (: finish_error_replies($1, $2, $(finished), $(str)) :));
   return 1;
}

/**
 * This method sets the error reply status to something useful.
 * @param id the id of the error reply
 * @param status the new status
 * @param finished the finished fuinction
 * @return 1 if the setup is successful, 0 if not
 */
int do_status_error_reply(int id, string status, function finished) {
   string str;

   str = "update error_replies set status = '" + status + "' where id = " +
         id;
   DB_HANDLER->make_sql_request(_db, _user, _password, str,
                      (: finish_update($1, $2, $(finished), $(str)) :));
   return 1;
}

/**
 * THis method adds an error reply into the system.  THis is a debug message
 * and only useful until all the error setups are connected together properly.
 */
int do_add_error_reply(int bug_id, string from, string to, string subject, string message) {
   string str;

   str = "insert into error_replies (bug_id,status,sender,recipient,senddate,message,subject) "
         "values (" + bug_id + ", 'NEW', '" + from + "', '" + to + "', " +
         time() + ", '" +
         db_escape(message) + "', '" + db_escape(subject) + "')";
   DB_HANDLER->make_sql_request(_db, _user, _password, str,
           (: 1 :) );
   return 1;
}
// --- END [/mnt/home2/grok/lib/obj/handlers/inherit/error_handler.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/inherit/club_personal.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/inherit/club_personal.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628468   Available: 13575822
Inodes: Total: 5242880    Free: 4960134
1314 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/inherit/club_personal.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628468   Available: 13575822
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is the handler for all things clubby, a club being a group of
 * players.  Each club must have a unique name.  It also handles elections
 * for various club positions.
 * @author Pinkfish
 * @started Sun Sep 27 03:35:42 EDT 1998
 */
inherit "/obj/handlers/inherit/club_basic";

#define __CLUBS_H_NO_CLASSES

#include <clubs.h>

/**
 * This is for a personal club, a personal club will be removed when
 * the founder disappears.
 */
class personal_info {
}

protected void create_extra_data(string name) {
   class personal_info p_info;
   class club_info data;

   data = (class club_info)query_club_info(name);
   if (query_club_type(name) == CLUB_PERSONAL) {
         p_info = new(class personal_info);
      data->extra_data = p_info;
      set_club_changed(name);
   } else {
      ::create_extra_data(name);
   }
} /* create_extra_data() */

/**
 * This method returns the personal info associated with the club.
 * @param name the name of the club to get the info for
 * @return the personal club class, 0 if no club or not personal type
 */
private class personal_info query_personal_info(string name) {
   class club_info data;

   if (is_personal_club(name)) {
      data = (class club_info)query_club_info(name);
      return data->extra_data;
   }
   return 0;
} /* query_personal_info() */
// --- END [/mnt/home2/grok/lib/obj/handlers/inherit/club_personal.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/inherit/citizen_elections.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/inherit/citizen_elections.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628468   Available: 13575822
Inodes: Total: 5242880    Free: 4960134
18479 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/inherit/citizen_elections.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628468   Available: 13575822
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is the file used to do elections for magistrate positions.
 * @author Pinkfish
 * @started Mon Oct 23 22:30:19 PDT 2000
 */
inherit "/obj/handlers/inherit/citizens";

#include <player_handler.h>
#include <player.h>
#include <board.h>
#define NOMIC_SYSTEM_NO_CLASSES
#include <nomic_system.h>

#define CITIZEN_ELECTION_PHASE_NONE       0
#define CITIZEN_ELECTION_PHASE_NOMINATION 1
#define CITIZEN_ELECTION_PHASE_ELECTION   2
#define CITIZEN_ELECTION_PHASE_GRACE      3
#define CITIZEN_ELECTION_PHASE_DISABLED 4

#define CITIZEN_ELECTION_TIME   (20 * (7 * 24 * 60 * 60))
#define CITIZEN_ELECTION_PHASE_TIME      (10 * 24 * 60 * 60)
#define CITIZEN_PHASE_TIME      (14 * 24 * 60 * 60)
#define CITIZEN_GRACE_TIME      (14 * 24 * 60 * 60)
#define CITIZEN_ELECTION_DISABLED_TIME (14 * 24 * 60 * 60)

class election_data {
   int last_election;
   int phase;
   int phase_start;
   mapping nominations;
   mapping votes;
   string* voted;
}

protected void finish_election_phase(string area);
int post_citizen_message(string area, string subject, string message);

private mapping _elections;
private mapping _boards;

void create() {
   _elections = ([ ]);
   _boards = ([ ]);
   citizens::create();
   call_out("do_next_event", 10);
} /* create() */

/** @ignore yes */
void create_area(string area) {
   _elections[area] = new(class election_data);
   _elections[area]->phase = CITIZEN_ELECTION_PHASE_GRACE;
   _elections[area]->phase_start = time();
   _elections[area]->nominations = ([ ]);
   _elections[area]->votes = ([ ]);
   _elections[area]->voted = ({ });
   ::create_area(area);
} /* create_area() */

/**
 * This method returns the time of the next election.
 * @return the time of the next election, 0 if on is in progress
 */
int query_next_election_time(string area) {
   if (!_elections[area]) {
      return 0;
   }

   if (_elections[area]->phase == CITIZEN_ELECTION_PHASE_GRACE) {
      return _elections[area]->phase_start + CITIZEN_GRACE_TIME;
   }

   if (_elections[area]->phase == CITIZEN_ELECTION_PHASE_NONE) {
      return _elections[area]->last_election + CITIZEN_ELECTION_TIME;
   }
   return 0;
} /* query_next_election_time() */

/**
 * This method returns the end of the phase time.
 * @return the end of the phase time, 0 on failure
 */
int query_end_of_phase_time(string area) {
   if (!_elections[area]) {
      return 0;
   }

   if (_elections[area]->phase == CITIZEN_ELECTION_PHASE_NONE) {
      return 0;
   }

   if (_elections[area]->phase == CITIZEN_ELECTION_PHASE_ELECTION) {
      return _elections[area]->phase_start + CITIZEN_ELECTION_PHASE_TIME;
   }

   return _elections[area]->phase_start + CITIZEN_PHASE_TIME;
} /* query_end_of_phase_time() */

/**
 * This method returns the phase of the election.
 * @param area the area to check
 * @return the election phase
 */
protected int query_election_phase(string area) {
   if (!_elections[area]) {
      return CITIZEN_ELECTION_PHASE_NONE;
   }
   return _elections[area]->phase;
} /* query_election_phase() */

/**
 * This method checks to see if we are in the nomination phase.
 * @param area the area to check
 * @return 1 if we are, 0 if not
 */
int is_nomination_phase(string area) {
   return query_election_phase(area) == CITIZEN_ELECTION_PHASE_NOMINATION;
} /* is_nomination_phase() */

/**
 * This method checks to see if we are in the election phase.
 * @param area the area to check
 * @return 1 if we are, 0 if not
 */
int is_election_phase(string area) {
   return query_election_phase(area) == CITIZEN_ELECTION_PHASE_ELECTION;
} /* is_election_phase() */

/**
 * This method checks to see if we are in the grace phase.
 * @param area the area to check
 * @return 1 if we are, 0 if not
 */
int is_grace_phase(string area) {
   return query_election_phase(area) == CITIZEN_ELECTION_PHASE_GRACE;
} /* is_grace_phase() */

/**
 * This method nominates a person for a position.
 * @param area the area to nominate in
 * @param person the being nominated
 * @param nominator the person doing the nomination
 * @return 1 on success, 0 on failure
 */
int nominate_magistrate(string area, string person, string nominator) {
   if (!_elections[area] ||
       !is_citizen_of(area, person) ||
       !is_citizen_of(area, nominator)) {
      return 0;
   }

   if (_elections[area]->phase == CITIZEN_ELECTION_PHASE_NOMINATION) {
      if (!_elections[area]->nominations[person]) {
         _elections[area]->nominations[person] = ({ });
      } else if (member_array(nominator,
                              _elections[area]->nominations[person]) != -1) {
         return 0;
      }
      _elections[area]->nominations[person] += ({ nominator });
      save_me();
      return 1;
   }

   return 0;
} /* nominate_magistrate() */

/**
 * This method checks to see who has nominated a specified person.
 * @param area the area to check
 * @param person the person to check
 * @return the array of people who have nominated the person
 */
string* query_nominated_by(string area, string person) {
   if (!_elections[area]) {
      return ({ });
   }

   if (_elections[area]->phase == CITIZEN_ELECTION_PHASE_NOMINATION) {
      if (_elections[area]->nominations[person]) {
         return copy(_elections[area]->nominations[person]);
      }
   }

   return ({ });
} /* query_nominated_by() */

/**
 * This method returns the list of people who have been nominated.
 * @param area the area to get the list of people who are nominated
 * @return the list of people who have been nominated
 */
string* query_people_nominated(string area) {
   if (!_elections[area]) {
      return ({ });
   }

   if (_elections[area]->phase == CITIZEN_ELECTION_PHASE_NOMINATION) {
      return keys(_elections[area]->nominations);
   }

   return ({ });
} /* query_people_nominate() */

/**
 * This method checks to see if the specifiedf person has accepted their
 * nomination or not.
 * @param area the area to check in
 * @param person the person to check to see if they have accepted
 * @return 1 if they are accepted, 0 if not
 */
int is_nomination_accepted(string area, string person) {
   string* nominations;

   nominations = query_nominated_by(area, person);
   if (sizeof(nominations) >= 2 &&
       member_array(person, nominations) != -1) {
      return 1;
   }
   return 0;
} /* is_nomination_accepted() */

/**
 * This method checks to see if the specified person has voted.
 * @param area the area to check in
 * @param person the person the check
 * @return 1 if they have voted, 0 if not
 */
int has_voted(string area, string person) {
   if (!_elections[area]) {
      return 0;
   }

   if (_elections[area]->phase == CITIZEN_ELECTION_PHASE_ELECTION) {
      return member_array(person, _elections[area]->voted) != -1;
   }
   return 0;
} /* has_voted() */

/**
 * This method checks to see if the specified person is an eligible
 * person to vote for.
 * @param area the area to checlk
 * @param person the person to check
 * @return 1 if they are, 0 if not
 */
int is_eligible_to_vote_for(string area, string person) {
   if (!_elections[area]) {
      return 0;
   }

   if (_elections[area]->phase == CITIZEN_ELECTION_PHASE_ELECTION) {
      return member_array(person, keys(_elections[area]->votes)) != -1;
   }

   return 0;
} /* is_eleigble_to_vote_for() */

/**
 * This method votes for a specified person in the area.
 * @param area the area to vote for someone in
 * @param person the person to vote for
 * @param voter the person voting
 * @return 1 on success, 0 on failure
 */
int vote_for_people(string area, string* people, string voter) {
   string person;

   if (!_elections[area] ||
       !is_citizen_of(area, voter)) {
      return 0;
   }

   foreach (person in people) {
      if (!is_citizen_of(area, person)) {
         return 0;
      }
   }

   if (_elections[area]->phase == CITIZEN_ELECTION_PHASE_ELECTION) {
      if (has_voted(area, voter)) {
         return 0;
      }

      foreach (person in people) {
         if (is_eligible_to_vote_for(area, person)) {
            _elections[area]->votes[person]++;
         }
      }
      _elections[area]->voted += ({ voter });
      save_me();
      return 1;
   }

   return 0;
} /* vote_for_people() */

/**
 * This method retuns the list of people that can be voted for.
 * @param area the area to check in
 * @return the array of people that can be voted for
 */
string* query_can_vote_for(string area) {
   if (!_elections[area]) {
      return ({ });
   }

   if (_elections[area]->phase == CITIZEN_ELECTION_PHASE_ELECTION) {
      return keys(_elections[area]->votes);
   }

   return ({ });
} /* query_can_vote_for() */

/**
 * This method starts the election.
 * @param area the area to do the election for
 */
protected void start_election(string area) {
   if (!_elections[area]) {
      return ;
   }

   if (_elections[area]->phase == CITIZEN_ELECTION_PHASE_NONE ||
       _elections[area]->phase == CITIZEN_ELECTION_PHASE_GRACE) {
      _elections[area]->votes = ([ ]);
      _elections[area]->voted = ({ });
      _elections[area]->nominations = ([ ]);
      _elections[area]->phase_start = time();
      _elections[area]->phase = CITIZEN_ELECTION_PHASE_NOMINATION;
      save_me();
      post_citizen_message(area, "Nomination phase has started.",
                           "Please go to your council offices and "
                           "nominate\nthe magistrates for office.\n");
   }
} /* start_election() */

/**
 * This method finishes the nomination phase.
 * @param area the area to finish the phase for
 */
protected void finish_nomination_phase(string area) {
   string person;
   string* nominators;

   if (!_elections[area]) {
      return ;
   }

   if (_elections[area]->phase == CITIZEN_ELECTION_PHASE_NOMINATION) {
      //
      // Ok, zip through and remove all badies, non-citizens or 
      // people that were not nominated enough.
      //
      _elections[area]->votes = ([ ]);
      _elections[area]->voted = ({ });
      foreach (person, nominators in _elections[area]->nominations) {
         if (is_citizen_of(area, person) &&
             is_nomination_accepted(area, person) &&
             !PLAYER_HANDLER->test_creator(person)) {
            _elections[area]->votes[person] = 0;
         }
      }
      _elections[area]->phase = CITIZEN_ELECTION_PHASE_ELECTION;
      _elections[area]->phase_start = time();
      _elections[area]->nominations = ([ ]);
      save_me();
      post_citizen_message(area, "Nomination phase finished.",
                           "The people nominated for election are:\n" +
                           implode(map(keys(_elections[area]->votes),
                                       (: "   " + $1 :)), "\n"));
      if (sizeof(keys(_elections[area]->votes)) <=
          query_number_of_magistrates(area)) {
          //
          // Turn them all into magistrates.
          //
          finish_election_phase(area);
      }
   }
 
} /* finish_nomination_phase() */

/**
 * This method finishes the election phase.
 * @param area the area to finish the phase for
 */
protected void finish_election_phase(string area) {
   string* voted;
   string* sorted_voted;
   string high_pk;
   string high_non_pk;
   string person;
   string results;
   int needed;
   int num;

   if (!_elections[area]) {
      return ;
   }

   if (_elections[area]->phase == CITIZEN_ELECTION_PHASE_ELECTION) {
      if (sizeof(keys(_elections[area]->votes)) <=
          query_number_of_magistrates(area)) {
         voted = sort_array(keys(_elections[area]->votes),
                            (: $3[$2] - $3[$1] :), _elections[area]->votes);
         sorted_voted = voted;
      } else {
         //
         // Sort the people in order of votes.
         //
         voted = sort_array(keys(_elections[area]->votes),
                            (: $3[$2] - $3[$1] :), _elections[area]->votes);
         sorted_voted = voted;

         //
         // Ok, see if we have one pk and one npk.
         //
         needed = query_number_of_magistrates(area);
         foreach (person in voted) {
            if (PLAYER_HANDLER->test_player_killer(person)) {
               if (!high_pk) {
                  needed--;
                  high_pk = person;
               }
            } else {
               if (!high_non_pk) {
                  needed--;
                  high_non_pk = person;
               }
            }
            if (high_pk && high_non_pk) {
               break;
            }
         }

         voted -= ({ high_pk, high_non_pk });
         voted = voted[0..needed - 1];
         voted += ({ high_pk, high_non_pk });
         voted -= ({ 0 });
      }
      //
      // Post the results.
      //
      results = "Votes:\n";
      foreach (person in sorted_voted) {
         results += sprintf("%20s %d\n", capitalize(person),
                            _elections[area]->votes[person]);
      }
      results += "\nElected officals are " + query_multiple_short(voted) + "\n";
      results += "\nNumber of people who voted " +
                 sizeof(_elections[area]->voted);
      num = query_number_of_citizens(area);
      if (num == 0) {
         results += " (100% of the citizens)\n";
      } else {
         results += " (" + (sizeof(_elections[area]->voted) * 100 / num) +
                    "% of the citizens)\n";
      }
      _elections[area]->votes = ([ ]);
      _elections[area]->voted = ({ });
      _elections[area]->phase = CITIZEN_ELECTION_PHASE_NONE;
      _elections[area]->phase_start = time();
      _elections[area]->last_election = time();
      _elections[area]->nominations = ([ ]);

      post_citizen_message(area, "Election results", results);

      setup_magistrates(area, voted);
      save_me();
   }
} /* finish_election_phase() */

/** @ignore yes */
protected void do_next_event() {
   int next_event;
   int time_to_next_event;
   string area;
   class election_data data;

   foreach (area, data in _elections) {
      switch (data->phase) {
      case CITIZEN_ELECTION_PHASE_NONE :
         next_event = (data->last_election - time()) + CITIZEN_ELECTION_TIME;
         if (next_event <= 0) {
            start_election(area);
         }
         break;
      case CITIZEN_ELECTION_PHASE_NOMINATION :
         next_event = (data->phase_start - time()) + CITIZEN_PHASE_TIME;
         if (next_event <= 0) {
            finish_nomination_phase(area);
         }
         break;
      case CITIZEN_ELECTION_PHASE_ELECTION :
         next_event = (data->phase_start - time()) + CITIZEN_ELECTION_PHASE_TIME;
         if (next_event <= 0) {
            finish_election_phase(area);
         }
         break;
      case CITIZEN_ELECTION_PHASE_GRACE :
         next_event = (data->phase_start - time()) + CITIZEN_GRACE_TIME;
         if (next_event <= 0) {
            start_election(area);
         }
         break;

      case CITIZEN_ELECTION_PHASE_DISABLED : 
         next_event = (data->phase_start - time()) + 
            CITIZEN_ELECTION_DISABLED_TIME;
         if (next_event <= 0) {
             /*  Because this phase is disabled, we're not going to do to
                 trigger any event here at all. */ 
             next_event = next_event;
         }
         break;
      }

      if (next_event > 0 &&
          (next_event < time_to_next_event || !time_to_next_event)) {
         time_to_next_event = next_event;
      }
   }
   if(time_to_next_event) {
     call_out("do_next_event", time_to_next_event);
   }
} /* do_next_event() */

/**
 * This method sets the board for the specified area.
 * @param area the area to set the board for
 * @param name the name of the board
 */
void set_citizen_board(string area, string name) {
   if (!pointerp(_boards[area])) {
      _boards[area] = ({ 0, 0 });
   }
   _boards[area][0] = name;
   save_me();
} /* set_citizen_board() */

/**
 * This method returns the board for the specified area.
 * @param area the area to look for the board on
 * @return the board name for the area, 0 for none
 */
string query_magistrate_board(string area) {
   if (pointerp(_boards[area])) {
      return _boards[area][1];
   }
   return 0;
} /* query_magistrate_board() */

/**
 * This method sets the board for the specified area.
 * @param area the area to set the board for
 * @param name the name of the board
 */
void set_magistrate_board(string area, string name) {
   if (!pointerp(_boards[area])) {
      _boards[area] = ({ 0, 0 });
   }
   _boards[area][1] = name;
   save_me();
} /* set_magistrate_board() */

/**
 * This method returns the board for the specified area.
 * @param area the area to look for the board on
 * @return the board name for the area, 0 for none
 */
string query_citizen_board(string area) {
   if (pointerp(_boards[area])) {
      return _boards[area][0];
   }
   return 0;
} /* query_citizen_board() */

/**
 * This method will post a message to the citizen board from the
 * administration.
 * @param area the area to post the message to 
 * @param subject the subject it has
 * @param message the message to post
 */
int post_citizen_message(string area, string subject, string message) {
   string board;

   board = query_citizen_board(area);
   if (board) {
      return BOARD_HAND->add_message(board,
                           NOMIC_SYSTEM_ADMINISTRATOR_NAME,
                           subject,
                           message);
   }
   return 0;
} /* post_citizen_message() */

/**
 * This method will post a message to the magistrate board from the
 * administration.
 * @param area the area to post the message to 
 * @param subject the subject it has
 * @param message the message to post
 */
int post_magistrate_message(string area, string subject, string message) {
   string board;

   board = query_magistrate_board(area);
   if (board) {
      return BOARD_HAND->add_message(board,
                           NOMIC_SYSTEM_ADMINISTRATOR_NAME,
                           subject,
                           message);
   }
   return 0;
} /* post_magistrate_message() */

/**
 * This method sets the specifed election to "disabled", meaning it will
 * sit indefinitely with no election.
 */
int disable_citizen_election(string area) {
    if (!_elections[area]) {
      return 0;
    }

   _elections[area]->phase = CITIZEN_ELECTION_PHASE_DISABLED;
   _elections[area]->phase_start = time();
   _elections[area]->nominations = ([ ]);
   _elections[area]->votes = ([ ]);
   _elections[area]->voted = ({ });
   save_me();
   return 1;
} /* disable_citizen_election() */ 

// --- END [/mnt/home2/grok/lib/obj/handlers/inherit/citizen_elections.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/inherit/club_discuss.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/inherit/club_discuss.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628463   Available: 13575817
Inodes: Total: 5242880    Free: 4960134
88872 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/inherit/club_discuss.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628463   Available: 13575817
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is the handler for all things clubby, a club being a group of
 * players.  Each club must have a unique name.  It also handles elections
 * for various club positions.
 * @author Pinkfish
 * @started Sun Sep 27 03:35:42 EDT 1998
 */
inherit "/obj/handlers/inherit/club_elected";

#define __CLUBS_H_NO_CLASSES

#include <clubs.h>
#include <broadcaster.h>
#include <player_handler.h>
#include <player_handler.h>

// Special variables to control the club inner workings.
private nosave mapping _discussion_items;

#define CLUB_DISCUSS_FUNCTION_OBJECT     0
#define CLUB_DISCUSS_FUNCTION_FUNCTION   1

#define CLUB_DISCUSS_QUORUM_COMMITTEE   75
#define CLUB_DISCUSS_QUORUM_OPEN        25

private void add_club_discussion(int type,
                                 function func);
protected int remove_discussion_item(string club_name,
                                     class discussion_idea item);
private mixed club_discuss_new_position(int message,
                                        string club_name,
                                        class discussion_idea frog);
private mixed club_discuss_position_name(int message,
                                         string club_name,
                                         class discussion_idea frog,
                                         string arg1, 
                                         string arg2);
private mixed club_discuss_position_remove(int message,
                                           string club_name,
                                           class discussion_idea frog,
                                           string arg1, 
                                           string arg2);
private mixed club_discuss_description(int message,
                                       string club_name,
                                       class discussion_idea frog);
private mixed club_discuss_memo(int message,
                                string club_name,
                                class discussion_idea frog);
private mixed club_discuss_secret(int message,
                                  string club_name,
                                  class discussion_idea frog);
private mixed club_discuss_remove_member(int message,
                                         string club_name,
                                         class discussion_idea frog,
                                         string member);
private mixed club_discuss_no_confidence(int message,
                                         string club_name,
                                         class discussion_idea frog,
                                         string arg1, 
                                         string arg2);
private mixed club_discuss_election(int message,
                                    string club_name,
                                    class discussion_idea frog,
                                    string arg1, 
                                    string arg2);
private mixed club_discuss_nomination(int message,
                                      string club_name,
                                      class discussion_idea frog,
                                      string arg1,
                                      string arg2);
private mixed club_discuss_function(int message,
                                    string club_name,
                                    class discussion_idea frog,
                                    string arg1,
                                    string arg2);
private mixed club_discuss_create_account(int message,
                                    string club_name,
                                    class discussion_idea frog,
                                    string arg1,
                                    string arg2);
class discussion_idea query_discussion_item_by_type(string club_name,
                                                    int type,
                                                    class discussion_idea idea);
protected mixed send_discuss_message(string club_name,
                                    int message,
                                    class discussion_idea item,
                                    string arg1,
                                    string arg2);
protected void broadcast_discuss_message(string club_name,
                                         int message,
                                         string arg1,
                                         string arg2);
int add_discussion_item(string club,
                        int type,
                        string added_by,
                        string name,
                        string info,
                        string *choices,
                        int time_to_finish,
                        mixed extra_data);
int setup_by_election(string club,
                      string position,
                      string info);
int is_discuss_nominateable(string club_name,
                            int id);

void create() {
   _discussion_items = ([ ]);
   ::create();

   add_club_discussion(CLUB_DISCUSS_NEW_POSITION,
                       (: club_discuss_new_position :));
   add_club_discussion(CLUB_DISCUSS_POSITION_NAME,
                       (: club_discuss_position_name :));
   add_club_discussion(CLUB_DISCUSS_POSITION_REMOVE,
                       (: club_discuss_position_remove :));
   add_club_discussion(CLUB_DISCUSS_DESCRIPTION,
                       (: club_discuss_description :));
   add_club_discussion(CLUB_DISCUSS_MEMO,
                       (: club_discuss_memo :));
   add_club_discussion(CLUB_DISCUSS_MEMBER_REMOVE,
                       (: club_discuss_remove_member :));
   add_club_discussion(CLUB_DISCUSS_SECRET_TYPE,
                       (: club_discuss_secret :));
   add_club_discussion(CLUB_DISCUSS_NO_CONFIDENCE,
                       (: club_discuss_no_confidence :));
   add_club_discussion(CLUB_DISCUSS_ELECTION,
                       (: club_discuss_election :));
   add_club_discussion(CLUB_DISCUSS_NOMINATION,
                       (: club_discuss_nomination :));
   add_club_discussion(CLUB_DISCUSS_FUNCTION,
                       (: club_discuss_function :));
   add_club_discussion(CLUB_DISCUSS_CREATE_ACCOUNT,
                       (: club_discuss_create_account :));
} /* create() */

private void add_club_discussion(int type,
                                 function func) {
   _discussion_items[type] = func;
} /* add_club_discussion() */

/**
 * This method is called when a discussion item is finished.  It then
 * archives it or whatever else it wishes to do with the item
 * @param club_name the name of the club
 * @param item the text string of the finished item
 */
protected int archive_discussion_item(string club_name,
                                      string subject,
                                      string item) {
   if (is_elected_club(club_name)) {
      // Do some useful archiving.
      add_archive(club_name,
                  subject,
                  item);
   }
} /* archive_discussion_item() */

/**
 * This is a special function to be used with the discuss items to
 * make sure that there is not another discussion item checking the
 * same name.
 * @param club_name the name of the club to check
 * @param position the position to check for
 * @return 1 if the position is being discussed as an item
 */
int is_discussion_position_valid(string club_name,
                                 string position) {
   class discussion_idea bing;

   position = lower_case(position);
   // Not already a position name.
   if (is_valid_position(club_name, position)) {
      return 0;
   }

   // Discussing it as a possible alternative name.
   do {
      bing = query_discussion_item_by_type(club_name,
                                           CLUB_DISCUSS_POSITION_NAME,
                                           bing);
      if (bing) {
         if (!undefinedp(bing->choices[position])) {
            return 0;
         }
      }
   } while (bing);

   // Discussing it as a new position type.
   do {
      bing = query_discussion_item_by_type(club_name,
                                           CLUB_DISCUSS_NEW_POSITION,
                                           bing);
      if (bing) {
         if (bing->information == position) {
            return 0;
         }
      }
   } while (bing);

   return 1;
} /* is_discussion_position_valid() */

private mixed club_discuss_position_name(int message,
                                         string club_name,
                                         class discussion_idea frog,
                                         string arg1,
                                         string arg2) {
   string body;
   string position;
   int num;
   string old_pos;

   switch (message) {
      case CLUB_DISCUSS_MESSAGE_VERIFY :
         /*
          * The current position must be in the list of choices.  Add
          * it if it is not..  Also make sure that none of the other
          * names are already positions in the club.
          */
         if (!is_discussion_position_valid(club_name, frog->optional_data)) {
            return 0;
         }

         frog->choices = ([ CLUB_DISCUSS_YES_CHOICE : 0,
                            CLUB_DISCUSS_NO_CHOICE : 0,
                            CLUB_DISCUSS_ABSTAIN_CHOICE : 0 ]);

         if (!is_valid_position(club_name, frog->name)) {
            return 0;
         }

         return 1;

      case CLUB_DISCUSS_MESSAGE_COMPLETE :
         /*
          * Ok!  Now we complete the position and tally up to find
          * which position is the best.
          */
         body = "Hello!\n\nThe discussion item " 
                "added at " + ctime(frog->time_added) + ", finished at " +
                ctime(time()) + " and added by " + frog->added_by +
                " has finished.";
         body += "  The final votes for the discussion item to change the " 
                "position " +frog->name + " to " + frog->optional_data +
                " is:\n";
         foreach (position, num in frog->choices) {
            body += position + ":   " + num + "\n";
         }
         body += "\n";
         if (frog->information) {
            body += frog->information + "\n";
         }

         // Need to keep track of the old name since the change postion
         // call will modify the name in the structure.
         old_pos = frog->name;

         if (frog->choices[CLUB_DISCUSS_YES_CHOICE] > 
             frog->choices[CLUB_DISCUSS_NO_CHOICE]) {
            change_position_name_in_club(club_name,
                                        frog->name,
                                        frog->optional_data);
            body += "Which means the position " + old_pos +
                     " has been changed to " + frog->optional_data + ".\n";
         } else {
            body += "Which means the position " + old_pos +
                    " has not been changed to " + frog->optional_data + ".\n";
         }
         do_mail_committee(club_name,
                           "Results of changing the position " + 
                              frog->name,
                           body);
         archive_discussion_item(club_name,
                                 send_discuss_message(club_name,
                                                 CLUB_DISCUSS_MESSAGE_SHORT_DESCRIPTION,
                                                 frog,
                                                 0,
                                                 0),
                                 body);
         return 1;

      case CLUB_DISCUSS_MESSAGE_LONG_DESCRIPTION :
         body = "Voting on changing the position '" + frog->name +
                "' to '" + frog->optional_data + "'.\n";
         if (frog->information) {
            body += frog->information;
         }
         return body;

      case CLUB_DISCUSS_MESSAGE_SHORT_DESCRIPTION :
         return "Changing the position '" + frog->name + "'";

      case CLUB_DISCUSS_MESSAGE_CHANGE_POSITION :
         if (frog->name == arg1) {
            frog->name = arg2;
            return 1;
         }
         return 0;

      case CLUB_DISCUSS_MESSAGE_REMOVE_POSITION :
         if (frog->name == arg1) {
            remove_discussion_item(club_name, frog);
            return 1;
         }
         return 0;
   }
   return 0;
} /* club_discuss_position_name() */

private mixed club_discuss_position_remove(int message,
                                           string club_name,
                                           class discussion_idea frog,
                                           string arg1,
                                           string arg2) {
   string body;
   string position;
   int num;

   switch (message) {
      case CLUB_DISCUSS_MESSAGE_VERIFY :
         /*
          * The current position must be in the list of choices.  Add
          * it if it is not..  Also make sure that none of the other
          * names are already positions in the club.
          */
         if (!is_valid_position(club_name, frog->name)) {
            return 0;
         }

         if (is_basic_position(club_name, frog->name)) {
            return 0;
         }

         frog->choices = ([ CLUB_DISCUSS_YES_CHOICE : 0,
                            CLUB_DISCUSS_NO_CHOICE : 0,
                            CLUB_DISCUSS_ABSTAIN_CHOICE : 0 ]);

         return 1;

      case CLUB_DISCUSS_MESSAGE_COMPLETE :
         /*
          * Ok!  Now we complete the position and tally up to find
          * which position is the best.
          */
         body = "Hello!\n\nThe discussion item " 
                "added at " + ctime(frog->time_added) + ", finished at " +
                ctime(time()) + " and added by " + frog->added_by +
                " has finished.";
         body += "  The final votes for the discussion item " 
                "to remove the position " + frog->name + " are:\n";
         foreach (position, num in frog->choices) {
            body += position + ":   " + num + "\n";
         }
         body += "\n";
         if (frog->information) {
            body += frog->information + "\n";
         }

         if (frog->choices[CLUB_DISCUSS_YES_CHOICE] > 
             frog->choices[CLUB_DISCUSS_NO_CHOICE]) {
            if (is_basic_position(club_name, frog->name)) {
               body += "Unable to remove the basic position " + frog->name +
                        ".\n";
            } else if (remove_position_in_club(club_name, frog->name)) {
               body += "Which means the position " + frog->name +
                        " has been removed.\n";
            } else {
               body += "Unable to remove the position " + frog->name +
                        " for some reason, basic position or something?\n";
            }
         } else {
            body += "Which means the position " + frog->name +
                    " has not been removed.\n";
         }
         do_mail_committee(club_name,
                           "Results of removing the position " + 
                              frog->name,
                           body);
         archive_discussion_item(club_name,
                                 send_discuss_message(club_name,
                                                 CLUB_DISCUSS_MESSAGE_SHORT_DESCRIPTION,
                                                 frog,
                                                 0,
                                                 0),
                                 body);
         return 1;

      case CLUB_DISCUSS_MESSAGE_LONG_DESCRIPTION :
         body = "Voting on removing the position '" + frog->name +
                "'.\n";
         if (frog->information) {
            body += frog->information;
         }
         return body;

      case CLUB_DISCUSS_MESSAGE_SHORT_DESCRIPTION :
         return "Removing the position '" + frog->name + "'";

      case CLUB_DISCUSS_MESSAGE_CHANGE_POSITION :
         if (frog->name == arg1) {
            frog->name = arg2;
            return 1;
         }
         return 0;

      case CLUB_DISCUSS_MESSAGE_REMOVE_POSITION :
         if (frog->name == arg1) {
            remove_discussion_item(club_name, frog);
            return 1;
         }
         return 0;
   }
   return 0;
} /* club_discuss_position_remove() */

private mixed club_discuss_new_position(int message,
                                        string club_name,
                                        class discussion_idea frog) {
   string body;

   switch (message) {
      case CLUB_DISCUSS_MESSAGE_VERIFY :
         /* Make sure they only have a yes and no choice. */
         frog->choices = ([ CLUB_DISCUSS_YES_CHOICE : 0,
                            CLUB_DISCUSS_NO_CHOICE : 0,
                            CLUB_DISCUSS_ABSTAIN_CHOICE : 0 ]);
         if (!is_discussion_position_valid(club_name, frog->name)) {
            return 0;
         }
         return 1;

      case CLUB_DISCUSS_MESSAGE_COMPLETE :
         body = "Hello!\n\nThe discussion item " 
                "added at " + ctime(frog->time_added) + ", finished at " +
                ctime(time()) + " and added by " + frog->added_by +
                " has finished.";
         body += "  The vote for adding the position " +
            frog->name + " to the club " + query_club_name(club_name) +
            " has been completed and the results are " +
            frog->choices[CLUB_DISCUSS_YES_CHOICE] + " in favour, " +
            frog->choices[CLUB_DISCUSS_NO_CHOICE] + " against and " +
            frog->choices[CLUB_DISCUSS_ABSTAIN_CHOICE] + " abstaining.\n";
         if (frog->information) {
            body += frog->information;
         }
         if (is_valid_position(club_name, frog->name)) {
            body += "\nUnfortunately " + frog->name +
               " is not a valid position.  Vote forfited.\n";
            do_mail_committee(club_name,
                              "Results of adding " + frog->name,
                              body);
            return 0;
         }
         if (frog->choices[CLUB_DISCUSS_YES_CHOICE] >
             frog->choices[CLUB_DISCUSS_NO_CHOICE]) {
            if (create_position_in_club(club_name, frog->name)) {
               body += "\nWhich means that the position " + frog->name +
                  " has been created.\n";
               setup_by_election(club_name,
                                 frog->name,
                                 frog->information);
            } else if (is_voting_in_progress(club_name)) {
               body += "\nWhich means we attempted to create the position " +
                  frog->name + " but were prevented because "
                  "voting is in progress?\n";
            } else {
               body += "\nWhich means we attempted to create the position " +
                  frog->name + " but were prevented for some reason.\n";
            }
         } else {
            body += "\nWhich means that the position " + frog->name +
               " was not created.\n";
         }
         do_mail_committee(club_name,
                           "Results of adding " + frog->name,
                           body);
         archive_discussion_item(club_name,
                                 send_discuss_message(club_name,
                                                 CLUB_DISCUSS_MESSAGE_SHORT_DESCRIPTION,
                                                 frog,
                                                 0,
                                                 0),
                                 body);
         return 1;

      case CLUB_DISCUSS_MESSAGE_LONG_DESCRIPTION :
         body = "Voting on adding the position '" + frog->name +
            "' to the club.\n";
         if (frog->information) {
            body += frog->information;
         }
         return body;

      case CLUB_DISCUSS_MESSAGE_SHORT_DESCRIPTION :
         return "Adding the position '" + frog->name + "'";
   }
   return 0;
} /* club_discuss_position_name() */

private mixed club_discuss_description(int message,
                                       string club_name,
                                       class discussion_idea frog) {
   string body;

   switch (message) {
      case CLUB_DISCUSS_MESSAGE_VERIFY :
         /* See if there is already one of these going... */
         if (query_discussion_item_by_type(club_name,
                                           CLUB_DISCUSS_DESCRIPTION,
                                           0)) {
            return 0;
         }

         /* Make sure they only have a yes and no choice. */
         frog->choices = ([ CLUB_DISCUSS_YES_CHOICE : 0,
                            CLUB_DISCUSS_NO_CHOICE : 0,
                            CLUB_DISCUSS_ABSTAIN_CHOICE : 0 ]);
         return 1;

      case CLUB_DISCUSS_MESSAGE_COMPLETE :
         body = "Hello!\n\nThe discussion item " 
                "added at " + ctime(frog->time_added) + ", finished at " +
                ctime(time()) + " and added by " + frog->added_by +
                " has finished.";
         body += "  The vote for changing the description of the " +
            "club " + query_club_name(club_name) +
            " to:\n" + frog->information + "\nThe vote has been completed "
            "and the results are " +
            frog->choices[CLUB_DISCUSS_YES_CHOICE] + " in favour, " +
            frog->choices[CLUB_DISCUSS_NO_CHOICE] + " against and " +
            frog->choices[CLUB_DISCUSS_ABSTAIN_CHOICE] + " abstaining.\n";

         if (frog->choices[CLUB_DISCUSS_YES_CHOICE] >
             frog->choices[CLUB_DISCUSS_NO_CHOICE]) {
            set_club_description(club_name, frog->information);
            body += "Which means the description has been changed.\n";
         } else {
            body += "Which means the description has not been changed.\n";
         }
         do_mail_committee(club_name,
                           "Results of changing the description",
                           body);
         archive_discussion_item(club_name,
                                 send_discuss_message(club_name,
                                                 CLUB_DISCUSS_MESSAGE_SHORT_DESCRIPTION,
                                                 frog,
                                                 0,
                                                 0),
                                 body);
         return 1;

      case CLUB_DISCUSS_MESSAGE_LONG_DESCRIPTION :
         body = "Voting on changing the description of the club to:\n" + 
                frog->information + "\n";
         return body;

      case CLUB_DISCUSS_MESSAGE_SHORT_DESCRIPTION :
         return "Changing the description";
   }
   return 0;
} /* club_discuss_description() */

private mixed club_discuss_secret(int message,
                                  string club_name,
                                  class discussion_idea frog) {
   string body;

   switch (message) {
      case CLUB_DISCUSS_MESSAGE_VERIFY :
         /* See if there is already one of these going... */
         if (query_discussion_item_by_type(club_name,
                                           CLUB_DISCUSS_SECRET_TYPE,
                                           0)) {
            return 0;
         }

         /* Make sure they only have a yes and no choice. */
         frog->choices = ([ CLUB_DISCUSS_YES_CHOICE : 0,
                            CLUB_DISCUSS_NO_CHOICE : 0,
                            CLUB_DISCUSS_ABSTAIN_CHOICE : 0 ]);
         return 1;

      case CLUB_DISCUSS_MESSAGE_COMPLETE :
         body = "Hello!\n\nThe discussion item " 
                "added at " + ctime(frog->time_added) + ", finished at " +
                ctime(time()) + " and added by " + frog->added_by +
                " has finished.";
         body += "  The vote for changing the club " +
                query_club_name(club_name) + " to ";
         if (query_club_secret(club_name)) {
            body += "an open club";
         } else {
            body += "a secret club";
         }
         body += " has been completed and the "
            "results are " +
            frog->choices[CLUB_DISCUSS_YES_CHOICE] + " in favour and " +
            frog->choices[CLUB_DISCUSS_NO_CHOICE] + " against with " +
            frog->choices[CLUB_DISCUSS_ABSTAIN_CHOICE] + " abstaining.\n\n";
         if (frog->choices[CLUB_DISCUSS_YES_CHOICE] >
             frog->choices[CLUB_DISCUSS_NO_CHOICE]) {
            if (query_club_secret(club_name)) {
               reset_club_secret(club_name);
               body += "Which means the club is now open.\n";
            } else {
               set_club_secret(club_name);
               body += "Which means the club is now secret.\n";
            }
         } else {
            body += "Which means the club's secret flag has not been "
                    "changed.\n";
         }
         if (frog->information) {
            body += "\n" + frog->information;
         }
         do_mail_committee(club_name,
                           "Results of changing the secret flag",
                           body);
         archive_discussion_item(club_name,
                                 send_discuss_message(club_name,
                                                 CLUB_DISCUSS_MESSAGE_SHORT_DESCRIPTION,
                                                 frog,
                                                 0,
                                                 0),
                                 body);
         return 1;

      case CLUB_DISCUSS_MESSAGE_LONG_DESCRIPTION :
         if (query_club_secret(club_name)) {
            body = "Voting on changing the club to be open.\n";
         } else {
            body = "Voting on changing the club to be secret.\n";
         }
         if (frog->information) {
            body += frog->information;
         }
         return body;

      case CLUB_DISCUSS_MESSAGE_SHORT_DESCRIPTION :
         if (query_club_secret(club_name)) {
            return "Changing the club to be open";
         } else {
            return "Changing the club to be secret";
         }
   }
   return 0;
} /* club_discuss_secret() */

private mixed club_discuss_memo(int message,
                                string club_name,
                                class discussion_idea frog) {
   string body;
   string choice;
   int num;

   switch (message) {
      case CLUB_DISCUSS_MESSAGE_VERIFY :
         /*
          * A memo can have any fields.  The verification is always
          * correct.
          */
         return 1;

      case CLUB_DISCUSS_MESSAGE_COMPLETE :
         /*
          * Ok!  Now we complete the position and tally up to find
          * which position is the best.
          */
         body = "Hello!\n\nThe discussion item " 
                "added at " + ctime(frog->time_added) + ", finished at " +
                ctime(time()) + " and added by " + frog->added_by +
                " has finished.";
         body += "   The final votes for discussion memo '" +
                frog->name + "' were:\n";
         foreach (choice, num in frog->choices) {
            body += choice + ":   " + num + "\n";
         }
         body += "\n" + frog->information;

         do_mail_committee(club_name,
                           "Results of memo '" +
                           frog->name + "'\n",
                           body);
         archive_discussion_item(club_name,
                                 send_discuss_message(club_name,
                                                 CLUB_DISCUSS_MESSAGE_SHORT_DESCRIPTION,
                                                 frog,
                                                 0,
                                                 0),
                                 body);
         return 1;

      case CLUB_DISCUSS_MESSAGE_LONG_DESCRIPTION :
         body = "Voting on the memo '" + frog->name +
                "'.\n";
         if (stringp(frog->information)) {
            body += "\n" + frog->information;
         }
         return body;

      case CLUB_DISCUSS_MESSAGE_SHORT_DESCRIPTION :
         return "Memo: " + frog->name;
   }
   return 0;
} /* club_discuss_memo() */

private mixed club_discuss_remove_member(int message,
                                         string club_name,
                                         class discussion_idea frog,
                                         string member) {
   string body;
   class discussion_idea womble;

   switch (message) {
      case CLUB_DISCUSS_MESSAGE_VERIFY :
         /* See if there is already one of these going... */
         frog->name = lower_case(frog->name);
         do {
            womble = query_discussion_item_by_type(club_name,
                                                   CLUB_DISCUSS_MEMBER_REMOVE,
                                                   womble);
            // Check to see if they are already being removed.
            if (womble &&
                womble->name == frog->name) {
               return 0;
            }
         } while (womble);

         if (!is_member_of(club_name, frog->name)) {
            return 0;
         }

         /* Make sure they only have a yes and no choice. */
         frog->choices = ([ CLUB_DISCUSS_YES_CHOICE : 0,
                            CLUB_DISCUSS_NO_CHOICE : 0,
                            CLUB_DISCUSS_ABSTAIN_CHOICE : 0 ]);
         return 1;

      case CLUB_DISCUSS_MESSAGE_COMPLETE :
         body = "Hello!\n\nThe discussion item " 
                "added at " + ctime(frog->time_added) + ", finished at " +
                ctime(time()) + " and added by " + frog->added_by +
                " has finished.";
         body += "  The vote for changing removing the member " +
                frog->name + " from the club " +
                query_club_name(club_name) + 
                " has been completed and the "
            "results are " +
            frog->choices[CLUB_DISCUSS_YES_CHOICE] + " in favour and " +
            frog->choices[CLUB_DISCUSS_NO_CHOICE] + " against with " +
            frog->choices[CLUB_DISCUSS_ABSTAIN_CHOICE] + " abstaining.\n\n";
         if (frog->information) {
            body += frog->information;
         }
         if (frog->choices[CLUB_DISCUSS_YES_CHOICE] >
             frog->choices[CLUB_DISCUSS_NO_CHOICE]) {
            if (!is_member_of(club_name, frog->name)) {
               body += "Looks like someone beat us to removing them.\n";
            } else {
               body += "Which means they have now been removed.\n";
               remove_member(club_name, frog->name);
            }
         } else {
            body += "Which means no one has been removed.\n";
         }
         do_mail_committee(club_name,
                           "Results of removing the member",
                           body);
         archive_discussion_item(club_name,
                                 send_discuss_message(club_name,
                                                 CLUB_DISCUSS_MESSAGE_SHORT_DESCRIPTION,
                                                 frog,
                                                 0,
                                                 0),
                                 body);
         return 1;

      case CLUB_DISCUSS_MESSAGE_LONG_DESCRIPTION :
         body = "Voting on removing the member " + frog->name + ".\n";
         if (frog->information) {
            body += frog->information;
         }
         return body;

      case CLUB_DISCUSS_MESSAGE_SHORT_DESCRIPTION :
         return "Removing the member " + frog->name;

      case CLUB_DISCUSS_MESSAGE_REMOVE_MEMBER :
         if (frog->name == member) {
            // Remove this discussion item!
            return remove_discussion_item(club_name, frog);
         }
         return 0;
   }
   return 0;
} /* club_discuss_remove_member() */

private mixed club_discuss_no_confidence(int message,
                                         string club_name,
                                         class discussion_idea frog,
                                         string arg1,
                                         string arg2) {
   string body;
   class discussion_idea womble;
   string real;
   string pos;

   if (!frog->name) {
      real = "all postions";
   } else {
      real = frog->name;
   }

   switch (message) {
      case CLUB_DISCUSS_MESSAGE_VERIFY :
         /* See if there is already one of these going... */
         frog->name = lower_case(frog->name);
         do {
            womble = query_discussion_item_by_type(club_name,
                                                   CLUB_DISCUSS_NO_CONFIDENCE,
                                                   womble);
            // Check to see if they are already being removed.
            if (womble &&
                womble->name == frog->name) {
               return 0;
            }
         } while (womble);

         if (!is_valid_position(club_name, frog->name) &&
             frog->name) {
            return 0;
         }

         /* Make sure they only have a yes and no choice. */
         frog->choices = ([ CLUB_DISCUSS_YES_CHOICE : 0,
                            CLUB_DISCUSS_NO_CHOICE : 0,
                            CLUB_DISCUSS_ABSTAIN_CHOICE : 0 ]);
         return 1;

      case CLUB_DISCUSS_MESSAGE_COMPLETE :
         body = "Hello!\n\nThe discussion item " 
                "added at " + ctime(frog->time_added) + ", finished at " +
                ctime(time()) + " and added by " + frog->added_by +
                " has finished.";
         body += "   The vote for no confidence in " +
                real + " in the club " +
                query_club_name(club_name) + 
                " has been completed and the "
            "results are " +
            frog->choices[CLUB_DISCUSS_YES_CHOICE] + " in favour and " +
            frog->choices[CLUB_DISCUSS_NO_CHOICE] + " against with " +
            frog->choices[CLUB_DISCUSS_ABSTAIN_CHOICE] + " abstaining.\n\n";
         if (frog->choices[CLUB_DISCUSS_YES_CHOICE] >
             frog->choices[CLUB_DISCUSS_NO_CHOICE]) {
            if (!frog->name) {
               body += "Therefor we have removed everyone from the committee "
                  "and started a new election.\n";
               foreach (pos in query_valid_positions(club_name)) {
                  catch(set_position_holder(club_name, pos, CLUB_UNKNOWN_MEMBER));
               }
               start_election(club_name);
            } else if (is_valid_position(club_name,
                                  frog->name)) {
               set_position_holder(club_name, frog->name, CLUB_UNKNOWN_MEMBER);
               body += "Therefor we had set the position as vacant.\n";
            } else {
               body += "The position in the club appears to have vanished!\n";
            }
         } else {
            body += "Which means nothing has happened.\n";
         }

         if (frog->information) {
            body += frog->information;
         }

         do_mail_committee(club_name,
                           "Results of no confidence vote",
                           body);
         archive_discussion_item(club_name,
                                 send_discuss_message(club_name,
                                                 CLUB_DISCUSS_MESSAGE_SHORT_DESCRIPTION,
                                                 frog,
                                                 0,
                                                 0),
                                 body);
         return 1;

      case CLUB_DISCUSS_MESSAGE_LONG_DESCRIPTION :
         body = "Voting on confidence in the position " +
                real + ", a yes vote indicates that you are in favour of the "
                "no confidence vote.\n";
         if (frog->information) {
            body += frog->information;
         }
         return body;

      case CLUB_DISCUSS_MESSAGE_SHORT_DESCRIPTION :
         return "No confidence in " + real;

      case CLUB_DISCUSS_MESSAGE_REMOVE_MEMBER :
         if (holds_position_of(club_name,
                               frog->name,
                               arg1) ||
             holds_position_of(club_name,
                               frog->name,
                               CLUB_UNKNOWN_MEMBER)) {
            return remove_discussion_item(club_name, frog);
         }
         return 0;

      case CLUB_DISCUSS_MESSAGE_CHANGE_POSITION :
         if (frog->name == arg1) {
            frog->name = arg2;
            return 1;
         }
         return 0;

      case CLUB_DISCUSS_MESSAGE_REMOVE_POSITION :
         if (frog->name == arg1) {
            remove_discussion_item(club_name, frog);
            return 1;
         }
         return 0;
   }
   return 0;
} /* club_discuss_no_confidence() */

private int is_nomination_or_election_being_discussed(
   string club_name,
   string pos_name
   )
{
   class discussion_idea womble;

   womble = 0;
   do {
      womble = query_discussion_item_by_type(club_name,
                                             CLUB_DISCUSS_ELECTION,
                                             womble);
      // Check to see if they are already being elected.
      if (womble &&
          lower_case(womble->name) == lower_case(pos_name)) {
         return 1;
      }
   } while (womble);

   womble = 0;
   do {
      womble = query_discussion_item_by_type(club_name,
                                             CLUB_DISCUSS_NOMINATION,
                                             womble);
      // Check to see if they are already being nominated.
      if (womble &&
          lower_case(womble->name) == lower_case(pos_name)) {
         return 1;
      }
   } while (womble);

   return 0;
} /* is_nomination_or_election_discussed() */

private mixed club_discuss_nomination(int message,
                                      string club_name,
                                      class discussion_idea frog,
                                      string arg1,
                                      string arg2) {
   string body;
   string name;
   string *nom;
   string *nominated;
   int ret;

   switch (message) {
      case CLUB_DISCUSS_MESSAGE_VERIFY :
         //
         // Make the name correct.
         //
         frog->name = query_position_name(club_name, frog->name);

         /* See if there is already one of these going... */
         if (is_nomination_or_election_being_discussed(club_name, frog->name)) {
            return 0;
         }

         if (!is_valid_position(club_name, frog->name)) {
            return 0;
         }

         if (is_election_in_progress(club_name) ||
             is_nomination_in_progress(club_name)) {
            return 0;
         }

         /* Setup the nomination mapping. */
         frog->choices = ([ ]);
         return 1;

      case CLUB_DISCUSS_MESSAGE_COMPLETE :
         body = "Hello!\n\nThe discussion item " 
                "added at " + ctime(frog->time_added) + ", finished at " +
                ctime(time()) + " and added by " + frog->added_by +
                " has finished.";
         body += "  The vote for nominations for the position of " +
                frog->name + " in the club " +
                query_club_name(club_name) + 
                " has been completed and the "
            "results are:\n";
         nominated = ({ });
         foreach (name, nom in frog->choices) {
            body += name + ": " + query_multiple_short(nom);
            if (member_array(name, nom) != -1 &&
                sizeof(nom) >= 2) {
               body += " (accepted)\n";
               nominated += ({ name });
            } else {
               body += "\n";
            }
         }
         if (frog->information) {
            body += frog->information;
         }
         if (sizeof(nominated)) {
            if (is_valid_position(club_name,
                                  frog->name)) {
               if (sizeof(nominated) != 1) {
                  body += "Therefor we had added an election for " + 
                     query_multiple_short(nominated) +
                     " .\n";
                  //
                  // Do the addition in a call out, so we are removed first.
                  //
                  call_out((: add_discussion_item :), 0,
                                      club_name,
                                      CLUB_DISCUSS_ELECTION |
                                         CLUB_DISCUSS_OPEN |
                                         CLUB_DISCUSS_NO_QUORUM,
                                      CLUB_CONTROLLER_MEMBER,
                                      frog->name,
                                      frog->information,
                                      nominated,
                                      7 * (24 * 60 * 60),
                                      0);
               } else {
                  body += "Only " + nominated[0] +
                     " was nominated, so they are elected immediately.\n";
                  set_position_holder(club_name, frog->name, nominated[0]);
               }
            } else {
               body += "The position in the club appears to have vanished!\n";
            }
         } else {
            if (is_valid_position(club_name, frog->name)) {
               body += "No one accepted their nomination, so nothing "
                       "happened.\n";
               //
               // Do the addition in a call out, so we are removed first.
               //
               call_out((: add_discussion_item :), 0,
                                   club_name,
                                   CLUB_DISCUSS_NOMINATION |
                                      CLUB_DISCUSS_OPEN |
                                      CLUB_DISCUSS_NO_QUORUM,
                                   frog->added_by,
                                   frog->name,
                                   frog->information,
                                   ({ }),
                                   7 * (24 * 60 * 60),
                                   frog->optional_data);
            } else {
               body += "The position in the club appears to have vanished!\n";
            }
         }
         do_mail_committee(club_name,
                           "Results of nomination",
                           body);
         archive_discussion_item(club_name,
                                 send_discuss_message(club_name,
                                                 CLUB_DISCUSS_MESSAGE_SHORT_DESCRIPTION,
                                                 frog,
                                                 0,
                                                 0),
                                 body);
         return 1;

      case CLUB_DISCUSS_MESSAGE_LONG_DESCRIPTION :
         body = "Nominations for the position " + frog->name + ":\n";
         foreach (name, nom in frog->choices) {
            body += name + ": " + query_multiple_short(nom);
            if (member_array(name, nom) != -1 &&
                sizeof(nom) >= 2) {
               body += " (accepted)\n";
            } else {
               body += "\n";
            }
         }
         if (frog->information) {
            body += frog->information;
         }
         return body;

      case CLUB_DISCUSS_MESSAGE_SHORT_DESCRIPTION :
         return "Nominations for " + frog->name;

      case CLUB_DISCUSS_MESSAGE_NOMINATION :
         if (is_member_of(club_name, arg1) &&
             is_member_of(club_name, arg2)) {
            // Pass in the person nominated in the optional data.
            if (!frog->choices[arg2]) {
               frog->choices[arg2] = ({ arg1 });
               return 1;
            } else if (member_array(arg1, 
                                    frog->choices[arg2]) == -1) {
               frog->choices[arg2] += ({ arg1 });
               return 1;
            }
         }
         return 0;

      case CLUB_DISCUSS_MESSAGE_WITHDRAW :
         if (frog->choices[arg1]) {
            map_delete(frog->choices, arg1);
            return 1;
         }
         return 0;

      case CLUB_DISCUSS_MESSAGE_REMOVE_MEMBER :
         // Check out to see if they have been nominated or nominated someone.
         if (frog->choices[arg1]) {
            map_delete(frog->choices, arg1);
            ret = 1;
         }
         foreach (name, nom in frog->choices) {
            if (member_array(arg1, nom) != -1) {
               frog->choices[name] = nom - ({ arg1 });
               if (!sizeof(frog->choices[name])) {
                  map_delete(frog->choices, name);
               }
               ret = 1;
            }
         }
         return ret;

      case CLUB_DISCUSS_MESSAGE_CHANGE_POSITION :
         if (frog->name == arg1) {
            frog->name = arg2;
            return 1;
         }
         return 0;

      case CLUB_DISCUSS_MESSAGE_TYPE :
         return CLUB_DISCUSS_MESSAGE_TYPE_NOMINATE;

      case CLUB_DISCUSS_MESSAGE_NOMINATION_QUERY :
         return frog->choices;

      case CLUB_DISCUSS_MESSAGE_REMOVE_POSITION :
         if (frog->name == arg1) {
            remove_discussion_item(club_name, frog);
            return 1;
         }
         return 0;
   }
   return 0;
} /* club_discuss_nomination() */

private mixed club_discuss_election(int message,
                                    string club_name,
                                    class discussion_idea frog,
                                    string arg1,
                                    string arg2) {
   string body;
   string name;
   int num;
   int highest;
   string *voted;

   switch (message) {
      case CLUB_DISCUSS_MESSAGE_VERIFY :
         //
         // Make the name correct.
         //
         frog->name = query_position_name(club_name, frog->name);

         /* See if there is already one of these going... */
         if (is_nomination_or_election_being_discussed(club_name, frog->name)) {
            return 0;
         }

         if (!is_valid_position(club_name, frog->name)) {
            return 0;
         }

         if (is_election_in_progress(club_name) ||
             is_nomination_in_progress(club_name)) {
            return 0;
         }

         /* Make sure they only voting for people in the club. */
         foreach (name, num in frog->choices) {
            frog->choices[name] = 0;
            if (!is_member_of(club_name, name)) {
               map_delete(frog->choices, name);
            }
         }

         if (!sizeof(frog->choices)) {
            return 0;
         }
         return 1;

      case CLUB_DISCUSS_MESSAGE_COMPLETE :
         body = "Hello!\n\nThe discussion item " 
                "added at " + ctime(frog->time_added) + ", finished at " +
                ctime(time()) + " and added by " + frog->added_by +
                " has finished.";
         body += "  The vote the position of " +
                frog->name + " in the club " +
                query_club_name(club_name) + 
                " has been completed and the "
            "results are:\n";
         highest = 0;
         voted = ({ });
         foreach (name, num in frog->choices) {
            body += name + ": " + num + "\n";
            if (num > highest) {
               highest = num;
               voted = ({ name });
            } else if (highest == num) {
               voted += ({ name });
            }
         }
         if (frog->information) {
            body += frog->information;
         }
         if (sizeof(voted)) {
            if (is_valid_position(club_name,
                                  frog->name)) {
               if (sizeof(voted) == 1) {
                  body += "Therefor " + voted[0] + 
                     " was elected to the position of " + frog->name +
                     ".\n";
                  set_position_holder(club_name, frog->name, voted[0]);
               } else {
                  body += "More than one person tied for the position, so "
                     "the election has been added again.\n";
               }
            } else {
               body += "The position in the club appears to have vanished!\n";
            }
         } else {
            body += "No one voted for anyone, so nothing happened.\n";
         }
         do_mail_committee(club_name,
                           "Results of election",
                           body);
         archive_discussion_item(club_name,
                                 send_discuss_message(club_name,
                                                 CLUB_DISCUSS_MESSAGE_SHORT_DESCRIPTION,
                                                 frog,
                                                 0,
                                                 0),
                                 body);
         return 1;

      case CLUB_DISCUSS_MESSAGE_LONG_DESCRIPTION :
         body = "Election for the position of " + frog->name + ".\n";
         if (frog->information) {
            body += frog->information;
         }
         return body;

      case CLUB_DISCUSS_MESSAGE_SHORT_DESCRIPTION :
         return "Election for " + frog->name;

      case CLUB_DISCUSS_MESSAGE_REMOVE_MEMBER :
         if (!undefinedp(frog->choices[arg1])) {
            map_delete(frog->choices, arg1);
            return 1;
         }
         return 0;

      case CLUB_DISCUSS_MESSAGE_CHANGE_POSITION :
         if (frog->name == arg1) {
            frog->name = arg2;
            return 1;
         }
         return 0;

      case CLUB_DISCUSS_MESSAGE_REMOVE_POSITION :
         if (frog->name == arg1) {
            remove_discussion_item(club_name, frog);
            return 1;
         }
         return 0;
   }
   return 0;
} /* club_discuss_election() */

private mixed club_discuss_function(int message,
                                    string club_name,
                                    class discussion_idea frog,
                                    string arg1,
                                    string arg2) {
   mixed ret;

   ret = call_other(frog->name[CLUB_DISCUSS_FUNCTION_OBJECT],
                    frog->name[CLUB_DISCUSS_FUNCTION_FUNCTION],
                    message,
                    club_name,
                    frog,
                    arg1,
                    arg2);
   if (message == CLUB_DISCUSS_MESSAGE_COMPLETE &&
       stringp(ret)) {
      do_mail_committee(club_name,
                      send_discuss_message(club_name,
                                           CLUB_DISCUSS_MESSAGE_SHORT_DESCRIPTION,
                                           frog,
                                           arg1,
                                           arg2),
                      ret);
      archive_discussion_item(club_name,
                              send_discuss_message(club_name,
                                                 CLUB_DISCUSS_MESSAGE_SHORT_DESCRIPTION,
                                                 frog,
                                                 0,
                                                 0),
                              ret);
      return 1;
   }

   return ret;
} /* club_discuss_function() */

private mixed club_discuss_create_account(int message,
                                    string club_name,
                                    class discussion_idea frog,
                                    string arg1,
                                    string arg2) {
   string body;
   class discussion_idea womble;

   switch (message) {
      case CLUB_DISCUSS_MESSAGE_VERIFY :
         /* See if there is already one of these going... */
         do {
            womble = query_discussion_item_by_type(club_name,
                                                   CLUB_DISCUSS_CREATE_ACCOUNT,
                                                   womble);
            // Check to see if the account is already being added.
            if (womble &&
                womble->name == frog->name) {
               return 0;
            }
         } while (womble);

         frog->choices = ([ CLUB_DISCUSS_YES_CHOICE : 0,
                            CLUB_DISCUSS_NO_CHOICE : 0,
                            CLUB_DISCUSS_ABSTAIN_CHOICE : 0 ]);

         if (is_account_of(club_name, frog->name)) {
            return 0;
         }

         return 1;

      case CLUB_DISCUSS_MESSAGE_COMPLETE :
         body = "Hello!\n\nThe discussion item " 
                "added at " + ctime(frog->time_added) + ", finished at " +
                ctime(time()) + " and added by " + frog->added_by +
                " has finished.";
         body += "  The vote for adding the special account " +
                frog->name + " in the club " +
                query_club_name(club_name) + 
                " has been completed and the "
                "results are " +
                frog->choices[CLUB_DISCUSS_YES_CHOICE] + " in favour, " +
                frog->choices[CLUB_DISCUSS_NO_CHOICE] + " against and " +
                frog->choices[CLUB_DISCUSS_ABSTAIN_CHOICE] + " abstaining.\n";

         if (frog->choices[CLUB_DISCUSS_YES_CHOICE] >
             frog->choices[CLUB_DISCUSS_NO_CHOICE]) {
            if (create_account(club_name, frog->name)) {
                body += "Which means the special account " + frog->name +
                     " has been created.\n";
            } else {
                body += "Which means the special account " + frog->name +
                     " was attempted to be created but had some problems.\n";
            }
         } else {
            body += "Which means the special account " + frog->name +
                  " has not been created.\n";
         }

         if (frog->information) {
            body += frog->information;
         }
         do_mail_committee(club_name,
                           "Results of creating account",
                           body);
         archive_discussion_item(club_name,
                                 send_discuss_message(club_name,
                                                 CLUB_DISCUSS_MESSAGE_SHORT_DESCRIPTION,
                                                 frog,
                                                 0,
                                                 0),
                                 body);
         return 1;

      case CLUB_DISCUSS_MESSAGE_LONG_DESCRIPTION :
         body = "Creating the special account " + frog->name + ".\n";
         if (frog->information) {
            body += frog->information;
         }
         return body;

      case CLUB_DISCUSS_MESSAGE_SHORT_DESCRIPTION :
         return "Create special account " + frog->name;
   }
   return 0;
} /* club_discuss_election() */

/**
 * This method figures out the discussion item for the club with the
 * given id.
 * @param club_name the name of the club
 * @param id the id of the discussion item
 * @return the found discussion item
 * @see add_discussion_item()
 */
class discussion_idea query_discussion_item(string club_name,
                                            int id) {
   class election_info frog;
   class discussion_idea bing;

   frog = (class election_info)query_elected_info(club_name);
   if (frog) {
      foreach (bing in frog->discussion) {
         if (bing->id == id) {
            return bing;
         }
      }
   }
   return 0;
} /* query_discussion_item() */

/**
 * This method returns all the current discussion items for this
 * club.
 * @param club_name the name of the club to query the discussion items for
 * @return the list of current discussion items
 */
class discussion_idea* query_all_discussion_items(string club_name) {
   class election_info frog;

   frog = (class election_info)query_elected_info(club_name);
   if (frog) {
      return copy(frog->discussion);
   }
   return 0;
} /* query_all_discussion_items() */

/**
 * This method returns a nice little description of the discussion item.
 * This is a very short description usable in lists and stuff.
 * @param club_name the name of the club
 * @param id the id of the discussion item
 * @return a short description of the item
 */
string query_discussion_item_short_description(string club_name,
                                               int id) {
   class discussion_idea bing;

   bing = query_discussion_item(club_name, id);
   if (bing) {
      if (_discussion_items[bing->discuss_type & CLUB_DISCUSS_TYPE_MASK]) {
         return send_discuss_message(club_name,
                                     CLUB_DISCUSS_MESSAGE_SHORT_DESCRIPTION,
                                     bing,
                                     0,
                                     0);
      }
   }
   return 0;
} /* query_discuss_item_short_description() */

/**
 * This method returns a nice little description of the discussion item.
 * This is a longer description, useful in more places.
 * @param club_name the name of the club
 * @param id the id of the discussion item
 * @return a long description of the item
 */
string query_discussion_item_long_description(string club_name,
                                            int id) {
   class discussion_idea bing;

   bing = query_discussion_item(club_name, id);
   if (bing) {
      if (_discussion_items[bing->discuss_type & CLUB_DISCUSS_TYPE_MASK]) {
         return send_discuss_message(club_name,
                                     CLUB_DISCUSS_MESSAGE_LONG_DESCRIPTION,
                                     bing,
                                     0,
                                     0);
      }
   }
   return 0;
} /* query_discuss_item_long_description() */

/**
 * This method checks to make sure the type of the discussion item
 * is valid.
 * @param type the type of the discussion item
 * @return 1 if it is valid, 0 if not
 */
int is_valid_discussion_item_type(int type) {
   if (_discussion_items[type & CLUB_DISCUSS_TYPE_MASK]) {
      return 1;
   }
   return 0;
} /* is_valid_duscussion_item_type() */

/**
 * This method will add a discussion item to the table to be voted on.
 * @param club the club the item is being added to
 * @param type the type of the discussion item to be added
 * @param added_by who added the discussion item
 * @param name the name of the discussion item
 * @param choices the choices for the discussion item
 * @param time_to_finish the amount of time the election has to run
 * @param extra_data any optional data associated with the discussion idea
 * @return 1 if successfully added, 0 if not
 */
int add_discussion_item(string club,
                        int type,
                        string added_by,
                        string name,
                        string info,
                        string *choices,
                        int time_to_finish,
                        mixed extra_data) {
   class discussion_idea bing;
   class election_info frog;
   int max_id;
   string choice;
   int i;

   // Allow the item to be added by the club contoller or the club itself.
   if (is_elected_club(club) &&
       is_valid_discussion_item_type(type) &&
       time_to_finish > 0 &&
       (is_member_of(club, lower_case(added_by)) ||
        added_by == CLUB_CONTROLLER_MEMBER ||
        normalise_name(added_by) == normalise_name(club))) {
      /* Cool, then we can add this item. */
      frog = (class election_info)query_elected_info(club);
      if (!pointerp(frog->discussion)) {
         frog->discussion = ({ });
      }
      bing = new(class discussion_idea);
      max_id = 0;
      for (i = 0; i < sizeof(frog->discussion); i++) {
         if (frog->discussion[i]->id > max_id) {
            max_id = frog->discussion[i]->id;
         }
      }
      bing->id = max_id + 1;
      bing->time_added = time();
      bing->time_finish = time() + time_to_finish;
      bing->discuss_type = type;
      bing->added_by = added_by;
      bing->name = name;
      bing->information = info;
      bing->choices = ([ ]);
      foreach (choice in choices) {
         bing->choices[lower_case(choice)] = 0;
      }
      bing->voted = ({ });
      bing->optional_data = extra_data;
      /* Verify the data... */
      if (send_discuss_message(club,
                               CLUB_DISCUSS_MESSAGE_VERIFY,
                               bing,
                               0,
                               0)) {
         frog->discussion += ({ bing });
         set_club_changed(club);
         return 1;
      }
      return 0;
   }
   return 0;
} /* add_discussion_item() */

/**
 * This method figures out the discussion item for the club with the
 * given type.  It will also continue on a search from a last found item.
 * @param club_name the name of the club
 * @param type the type of the discussion item to find
 * @return the found discussion item
 * @see add_discussion_item()
 */
class discussion_idea query_discussion_item_by_type(string club_name,
                                                    int type,
                                                    class discussion_idea idea) {
   class election_info frog;
   class discussion_idea bing;
   int found;

   frog = (class election_info)query_elected_info(club_name);
   if (frog) {
      if (!idea) {
         found = 1;
      }
      foreach (bing in frog->discussion) {
         if (found) {
            if ((bing->discuss_type & CLUB_DISCUSS_TYPE_MASK) == type) {
               return bing;
            }
         } else if (bing == idea) {
            found = 1;
         }
      }
   }
   return 0;
} /* query_discussion_item_by_type() */

/**
 * This method returns all the choices for this discussion item.
 * @param club_name the name of the club
 * @param id the id of the discussion item
 * @return an array of the valid set of choices, empty array on failure
 */
string *query_discussion_choices(string club_name,
                             int id) {
   class discussion_idea frog;

   frog = query_discussion_item(club_name, id);
   if (frog) {
      return keys(frog->choices);
   }
   return ({ });
} /* is_valid_discussion_choice() */

/**
 * This method returns the person who added the discussion item.
 * @param club_name the name of the club
 * @param id the id of the discussion item
 * @return the name of the person who added the discussion item
 */
string query_discussion_added_by(string club_name,
                                 int id) {
   class discussion_idea frog;

   frog = query_discussion_item(club_name, id);
   if (frog &&
       frog->added_by) {
      return frog->added_by;
   }
   return CLUB_UNKNOWN_MEMBER;
} /* query_discussion_added_by() */

/**
 * This method returns the timeout time of the current discussion item.
 * @param club_name the name of the club
 * @param id the id of the discussion item
 * @return the time at which the dicussion item will finish
 */
int query_discussion_time_finish(string club_name,
                                 int id) {
   class discussion_idea frog;

   frog = query_discussion_item(club_name, id);
   if (frog) {
      return frog->time_finish;
   }
   return 0;
} /* query_discussion_time_finish() */

/**
 * This method returns the timeout time of the current discussion item.
 * @param club_name the name of the club
 * @param id the id of the discussion item
 * @return the time at which the dicussion item will finish
 */
int query_discussion_time_added(string club_name,
                                 int id) {
   class discussion_idea frog;

   frog = query_discussion_item(club_name, id);
   if (frog) {
      return frog->time_finish;
   }
   return 0;
} /* query_discussion_time_added() */

/**
 * This method returns the optional data of the discussion item.
 * @param club_name the name of the club
 * @param id the id of the discussion item
 * @return the optional data in the club
 */
mixed query_discussion_optional_data(string club_name,
                                     int id) {
   class discussion_idea frog;

   frog = query_discussion_item(club_name, id);
   if (frog) {
      return frog->optional_data;
   }
   return 0;
} /* query_discussion_optional_data() */

/**
 * This method returns the nomination mapping for the discussion item
 * if it exists.  The nomination mapping is of the format:<br>
 * <pre>
 * ([
 *    name : ({ nomated_by, nominated_by, ... })
 *    ..
 *  ])
 * </pre>
 * @param club_name the name of the club
 * @param id the id of the discussion item
 * @return the mapping as described above
 */
mapping query_discussion_nomination(string club_name,
                                    int id) {
   class discussion_idea frog;
   mapping stuff;

   frog = query_discussion_item(club_name, id);
   if (frog) {
      stuff = send_discuss_message(club_name,
                                   CLUB_DISCUSS_MESSAGE_NOMINATION_QUERY,
                                   frog,
                                   0,
                                   0);
      if (stuff) {
         return stuff;
      }
      return ([ ]);
   }
   return ([ ]);
} /* query_discussion_nomination() */

/**
 * This method checks to see if the given nomination has already been 
 * done.
 * @param club_name the name of the club
 * @param id the id of the discussion ite,
 * @param nominator the person doing the nomination
 * @param nominated the person being nominated
 * @return 1 if they are already nominated, 0 if not
 */
int is_discuss_person_nominated(string club_name,
                               int id,
                               string nominator,
                               string nominated) {
   mapping bing;

   bing = query_discussion_nomination(club_name, id);
   if (bing[nominated]) {
      if (member_array(nominator, bing[nominated]) != -1) {
         return 1;
      }
   }
   return 0;
} /* is_discuss_person_nominated() */

/**
 * This method checks to see if the discussion item is a committee only
 * item.
 * @param club_name the name of the club
 * @param id the id of the discussion item
 * @return 1 if it is a committee only item, 0 if it is open
 */
int is_committee_discussion_item(string club_name,
                                 int id) {
   class discussion_idea frog;

   frog = query_discussion_item(club_name, id);
   if (frog) {
       if (frog->discuss_type & CLUB_DISCUSS_OPEN) {
          return 0;
       }
       return 1;
   }
   return 0;
} /* is_committee_discussion_item() */

/**
 * This method checks to see if the discussion item has no quorum
 * associated with it.
 * @param club_name the name of the club
 * @param id the id of the discussion item
 * @return 1 if it has no quorum, 0 if it is does
 */
int is_no_quorum_discussion_item(string club_name,
                                 int id) {
   class discussion_idea frog;

   frog = query_discussion_item(club_name, id);
   if (frog) {
       if (frog->discuss_type & CLUB_DISCUSS_NO_QUORUM) {
          return 1;
       }
       return 0;
   }
   return 0;
} /* is_no_quorum_discussion_item() */

/**
 * This method checks to see if the discussion item is completed yet.
 * @param club_name the name of the club
 * @param id the id of the discussion item
 * @return 1 if the discussion item is finished
 * @see vote_for_discussion_item()
 */
int is_discussion_item_finished(string club_name,
                                int id) {
   class discussion_idea frog;
   string *committee;

   frog = query_discussion_item(club_name, id);
   if (frog) {
      /*
       * If this is a committee only item, then if all the committee have
       * voted it is finished.
       */
      if (is_committee_discussion_item(club_name, id)) {
         // Check to see if everyone has voted.
         committee = query_committee(club_name);
         if (committee &&
             !sizeof(committee - frog->voted)) {
            return 1;
         }
      }

      // See if it has run to its completion time.
      if (frog->time_finish < time()) {
         return 1;
      }
   }
   return 0;
} /* is_discussion_item_finished() */

/**
 * This method returns the number of people needed for quorum
 * in this discussion item.
 * @param club_name the name of the club to check for quorum
 * @param id the discussion item id
 * @return the number of people needed for quorum
 */
int query_discussion_item_quorum_number(string club_name,
                                        int id) {
   class discussion_idea bing;
   int num;

   bing = query_discussion_item(club_name, id);
   // No need for a quorum on this item.
   if (is_no_quorum_discussion_item(club_name, id)) {
      return 0;
   } else if (is_committee_discussion_item(club_name, id)) {
      /* Quorum is 75% of the (active) committee... */
      num = sizeof(filter(query_committee(club_name),
                          (: $1 != CLUB_UNKNOWN_MEMBER &&
                             PLAYER_HANDLER->test_active($1) :)));
      return (num * CLUB_DISCUSS_QUORUM_COMMITTEE / 100);
   } else {
      /* Only require 50% of the (active) general assembly to vote. */
      num = sizeof(filter(query_members(club_name),
                          (: $1 != CLUB_UNKNOWN_MEMBER &&
                             PLAYER_HANDLER->test_active($1, 1) :)));
      return (num * CLUB_DISCUSS_QUORUM_OPEN / 100);
   }
   return 0;
} /* query_discussion_item_quorum_number() */

/**
 * This method returns the number of people who have voted for the
 * discussion item.
 * @param club_name the name of the club to check for quorum
 * @param id the discussion item id
 * @return the number of people who have voted
 */
int query_discussion_item_number_voted(string club_name,
                                       int id) {
   class discussion_idea bing;

   bing = query_discussion_item(club_name, id);
   if (bing) {
      return sizeof(bing->voted);
   }
   return 0;
} /* query_discussion_item_quorum_number() */

/**
 * This method checks to see if quorum has been reached or not
 * for the club.
 * @param club_name the name of the club to check for quorum
 * @param id the discussion item id
 * @return 1 if quorum is reached, 0 if not
 */
int is_discussion_item_quorum(string club_name,
                              int id) {
   class discussion_idea bing;
   int num;

   bing = query_discussion_item(club_name, id);
   if (bing) {
      num = query_discussion_item_quorum_number(club_name, id);
      if (sizeof(bing->voted) >= num) {
         return 1;
      }
   }
   return 0;
} /* is_discussion_item_quorum() */

/**
 * This checks to see if the specified choice is a real discussion item
 * choice.
 * @param club_name the name of the club
 * @param id the id of the discussion item
 * @param choice the choice to check
 */
int is_valid_discussion_choice(string club_name,
                               int id,
                               string choice) {
   class discussion_idea frog;

   frog = query_discussion_item(club_name, id);
   choice = lower_case(choice);
   if (frog &&
       !undefinedp(frog->choices[choice])) {
      return 1;
   }
   return 0;
} /* is_valid_discussion_choice() */

/**
 * This method checks to see if the discussion item is a votable
 * item or not.
 * @param club_name the name of the club
 * @param id the id of the discussion item
 * @return 1 if it is votable, 0 if not
 */
int is_discuss_votable(string club_name,
                       int id) {
   class discussion_idea frog;

   frog = query_discussion_item(club_name, id);
   if (frog) {
      if (send_discuss_message(club_name,
                               CLUB_DISCUSS_MESSAGE_TYPE,
                               frog,
                               0,
                               0) == CLUB_DISCUSS_MESSAGE_TYPE_VOTE) {
         return 1;
      }
   }
   return 0;
} /* is_discuss_votable() */

/**
 * This method checks to see if the discussion item is a votable
 * item or not.
 * @param club_name the name of the club
 * @param id the id of the discussion item
 * @return 1 if it is votable, 0 if not
 */
int is_discuss_nominateable(string club_name,
                            int id) {
   class discussion_idea frog;

   frog = query_discussion_item(club_name, id);
   if (frog) {
      if (send_discuss_message(club_name,
                               CLUB_DISCUSS_MESSAGE_TYPE,
                               frog,
                               0,
                               0) == CLUB_DISCUSS_MESSAGE_TYPE_NOMINATE) {
         return 1;
      }
   }
   return 0;
} /* is_discuss_nominateable() */

/**
 * This method checks to see if the specified person can see the
 * discussion idea. 
 * @param club_name the name of the club
 * @param id the id of the discussion idea
 * @param person the name of the person
 * @see vote_for_discussion_item()
 */
int can_reference_discussion_item(string club_name,
                                  int id,
                                  string person) {
   class discussion_idea frog;

   frog = query_discussion_item(club_name, id);
   if (frog && 
       (!is_committee_discussion_item(club_name, id) ||
        holds_any_position_of(club_name, person))) {
      return 1;
   }
   return 0;
} /* can_reference_discussion_item() */

/**
 * This method checks to see if the specified person has already voted for
 * this discussion item.
 * @param club_name the name of the club
 * @param id the id of the discussion item
 * @param person the name of the person to check
 */
int has_voted_for_discussion_item(string club_name,
                                  int id,
                                  string person) {
   class discussion_idea frog;

   frog = query_discussion_item(club_name, id);
   if (frog &&
       member_array(person, frog->voted) != -1) {
      return 1;
   }
   return 0;
} /* has_voted_for_discussion_item() */

/**
 * This method sets up the discussion item as being voted by the
 * person specified.
 * @param club_name the name of the club
 * @param id the id of the discussion item
 * @param person the person doing the voting
 * @param choice the choices there are to vote on
 * @see add_discussion_item()
 */
int vote_for_discussion_item(string club_name,
                             int id,
                             string person,
                             string choice) {
   class discussion_idea frog;

   frog = query_discussion_item(club_name, id);
   choice = lower_case(choice);
   if (frog &&
       can_reference_discussion_item(club_name, id, person) &&
       !has_voted_for_discussion_item(club_name, id, person) &&
       is_valid_discussion_choice(club_name, id, choice) &&
       is_discuss_votable(club_name, id)) {
      frog->choices[choice]++;
      frog->voted += ({ person });
      set_club_changed(club_name);
      return 1;
   }
   return 0;
} /* vote_for_discussion_item() */

/**
 * This message does the nomination thing for those discussion items
 * which accept nominations.
 * @param club_name the name of the club
 * @param id the id of the discussion item
 * @param nominator the person doing the nomination
 * @param nominated the person nominated
 */
int nominate_discussion_item(string club_name,
                             int id,
                             string nominator,
                             string nominated) {
   class discussion_idea frog;

   frog = query_discussion_item(club_name, id);
   if (frog &&
       is_member_of(club_name, nominator) &&
       is_member_of(club_name, nominated) &&
       is_discuss_nominateable(club_name, id)) {
      if (!is_creator_club(club_name) &&
          PLAYER_HANDLER->test_creator(nominated)) {
         return 0;
      }
      if (send_discuss_message(club_name,
                               CLUB_DISCUSS_MESSAGE_NOMINATION,
                               frog,
                               nominator,
                               nominated)) {
         set_club_changed(club_name);
         return 1;
      }
   }
   return 0;
} /* nominate_discussion_item() */

/**
 * This message does the withdraw thing for those discussion items
 * which accept nominations.
 * @param club_name the name of the club
 * @param id the id of the discussion item
 * @param withdraw the person being withdrawn
 */
int withdraw_discussion_item(string club_name,
                             int id,
                             string withdraw) {
   class discussion_idea frog;

   frog = query_discussion_item(club_name, id);
   if (frog &&
       is_member_of(club_name, withdraw) &&
       is_discuss_nominateable(club_name, id)) {
      if (send_discuss_message(club_name,
                               CLUB_DISCUSS_MESSAGE_WITHDRAW,
                               frog,
                               withdraw,
                               withdraw)) {
         set_club_changed(club_name);
         return 1;
      }
   }
   return 0;
} /* withdraw_discussion_item() */

/**
 * This method removes a discussion item from the club.
 * @param club_name the name of the club to remove the discussion item
 * @param item the discusion item to remove
 * @return 1 on success, 0 on failure
 */
protected int remove_discussion_item(string club_name,
                                     class discussion_idea item) {
   class election_info bing;
   int i;

   bing = (class election_info)query_elected_info(club_name);
   if (bing) {
      for (i = 0; i < sizeof(bing->discussion); i++) {
         if (bing->discussion[i] == item) {            
            bing->discussion = bing->discussion[0..i - 1] + 
               bing->discussion[i + 1..];
            set_club_changed(club_name);
            return 1;
         }
      }
   }
   return 0;
} /* remove_discussion_item() */

/**
 * This method completes the discussion item.
 * @param club_name the name of the club
 * @param id the id of the discussion item
 * @return 1 if successful, 0 if not
 * @see add_discussion_item()
 */
int complete_discussion_item(string club_name,
                             int id) {
   class discussion_idea frog;
   class election_info bing;
   int ret;

   frog = query_discussion_item(club_name, id);
   bing = (class election_info)query_elected_info(club_name);
   if (frog &&
       is_discussion_item_finished(club_name, id)) {
      if (is_discussion_item_quorum(club_name, id)) {
         if (_discussion_items[frog->discuss_type & CLUB_DISCUSS_TYPE_MASK]) {
            send_broadcast_message(club_name,
                                   "Finished discussion item: " +
                                   send_discuss_message(club_name,
                                                        CLUB_DISCUSS_MESSAGE_SHORT_DESCRIPTION,
                                                        frog,
                                                        0,
                                                        0) +
                                   " see archives for results.");
            send_discuss_message(club_name,
                                 CLUB_DISCUSS_MESSAGE_COMPLETE,
                                 frog,
                                 0,
                                 0);
         } else {
            ret = -1;
            do_mail_committee(club_name,
                              "Completed vote",
                              "The completed vote on:\n" +
                              "Discussion type " +
                               (frog->discuss_type & CLUB_DISCUSS_TYPE_MASK) +
                              " failed due to major internal messes.\n");
         }
      } else {
         if (_discussion_items[frog->discuss_type & CLUB_DISCUSS_TYPE_MASK]) {
            do_mail_committee(club_name,
                              "Completed vote",
                              "The completed vote on:\n" +
                              query_discussion_item_long_description(club_name,
                                                                     id) +
                              "\n\nDid not have quorum, only " +
                              sizeof(frog->voted) + " people voted.\n");
         } else {
            do_mail_committee(club_name,
                              "Completed vote",
                              "The completed vote on:\n" +
                              "Discussion type " + (frog->discuss_type & CLUB_DISCUSS_TYPE_MASK) +
                              " failed due to major internal messes.\n");
         }
         ret = -1;
      }
      remove_discussion_item(club_name, frog);
      //bing->discussion -= ({ frog });
      //set_club_changed(club_name);
   }
   return ret;
} /* complete_discussion_item() */

/**
 * This method sends a message to all the discussion items in the club
 * and then marks the club as changed if any of them return a non-zero
 * value.  This is used for events like a member being removed of a
 * position being changed in name.
 * @param club_name the name of the club
 * @param message the message number
 * @param arg1 the first arguement
 * @param arg2 the second arguement
 */
protected mixed send_discuss_message(string club_name,
                                     int message,
                                     class discussion_idea item,
                                     string arg1,
                                     string arg2) {
   return evaluate(_discussion_items[item->discuss_type &
                                           CLUB_DISCUSS_TYPE_MASK],
                   message,
                   club_name,
                   item,
                   arg1,
                   arg2);
} /* send_discuss_message() */

/**
 * This method sends a message to all the discussion items in the club
 * and then marks the club as changed if any of them return a non-zero
 * value.  This is used for events like a member being removed of a
 * position being changed in name.
 * @param club_name the name of the club
 * @param message the message number
 * @param arg1 the first arguement
 * @param arg2 the second arguement
 */
protected void broadcast_discuss_message(string club_name,
                                         int message,
                                         string arg1,
                                         string arg2) {
   class discussion_idea frog;
   class election_info bing;

   bing = (class election_info)query_elected_info(club_name);
   foreach (frog in bing->discussion) {
      if (send_discuss_message(club_name,
                               message,
                               frog,
                               arg1,
                               arg2)) {
         set_club_changed(club_name);
      }
   }
} /* broadcast_discuss_message() */

/*
 * -----   Methods for checking changes to the club and reporting them to 
 * -----   the discusion items
 */

/**
 * Catch the remove member calls and inform the system about them.
 * @ignore yes
 */
int remove_member(string name,
                  string member) {
   if (::remove_member(name, member)) {
      if (is_elected_club(name)) {
         broadcast_discuss_message(name,
                                   CLUB_DISCUSS_MESSAGE_REMOVE_MEMBER,
                                   member,
                                   0);
      }
      return 1;
   }
   return 0;
} /* remove_member() */

/**
 * Catch the position change call and inform the system about it.
 * @ignore yes
 */
int change_position_name_in_club(string name,
                                 string position,
                                 string new_position) {
   if (::change_position_name_in_club(name, position, new_position)) {
      if (is_elected_club(name)) {
         broadcast_discuss_message(name,
                                   CLUB_DISCUSS_MESSAGE_CHANGE_POSITION,
                                   position,
                                   new_position);
      }
      return 1;
   }
   return 0;
} /* change_position_name_in_club() */

/**
 * Catch the position removal things...
 * @ignore yes
 */
int remove_position_in_club(string name,
                            string position) {
   if (::remove_position_in_club(name, position)) {
      if (is_elected_club(name)) {
         broadcast_discuss_message(name,
                                   CLUB_DISCUSS_MESSAGE_REMOVE_POSITION,
                                   position,
                                   0);
      }
      return 1;
   }
   return 0;
} /* remove_position_in_club() */

/**
 * Catch the position holder message and turn it into a nomination.
 * @ignore yes
 */
int set_position_holder(string club_name,
                                  string position,
                                  string person) {
   if (::set_position_holder(club_name, position, person)) {
      if (person == CLUB_UNKNOWN_MEMBER) {
         add_discussion_item(club_name,
                             CLUB_DISCUSS_NOMINATION |
                                CLUB_DISCUSS_NO_QUORUM |
                                CLUB_DISCUSS_OPEN,
                             CLUB_CONTROLLER_MEMBER,
                             position,
                             "Position became vacant.\n",
                             ({ }),
                             7 * (24 * 60 * 60),
                             0);
      }
      return 1;
   }
   return 0;
} /* set_position_holder() */

/**
 * Catch the start election thing and zap all currently running
 * by-elections.
 * @ignore yes
 */
int start_election(string name) {
   class discussion_idea womble;
   class election_info data;
   int type;

   if (::start_election(name)) {
      data = (class election_info)query_elected_info(name);
      foreach (womble in data->discussion) {
         type = womble->discuss_type & CLUB_DISCUSS_TYPE_MASK;
         if (type == CLUB_DISCUSS_NOMINATION ||
             type == CLUB_DISCUSS_ELECTION) {
            remove_discussion_item(name, womble);
            set_club_changed(name);
         }
      }
      return 1;
   }
   return 0;
} /* start_election() */

/** @ignore yes */
protected void check_elected_information(string name,
                                        string member,
                                        int startup) {
   class election_info data;
   class discussion_idea frog;
   string pos;

   ::check_elected_information(name, member, startup);

   data = (class election_info)query_elected_info(name);
   if (data) {
      foreach (frog in data->discussion) {
         if (is_discussion_item_finished(name, frog->id)) {
            complete_discussion_item(name, frog->id);
            set_club_changed(name);
         } else if (frog->discuss_type == CLUB_DISCUSS_NOMINATION ||
                    frog->discuss_type == CLUB_DISCUSS_ELECTION) {
           if (!is_election_in_progress(name) &&
               !is_nomination_in_progress(name)) {
               frog->discuss_type |= CLUB_DISCUSS_OPEN |
                                     CLUB_DISCUSS_NO_QUORUM;
               set_club_changed(name);
            } else {
               remove_discussion_item(name, frog);
            }
         }
      }

      //
      // Check each position to see if we should start a by election
      // for it.
      //
      foreach (pos, member in data->positions) {
         if (member == CLUB_UNKNOWN_MEMBER &&
             !is_election_in_progress(name) &&
             !is_nomination_in_progress(name) &&
             !is_nomination_or_election_being_discussed(name, pos)) {
/*
tell_creator("pinkfish", "Setting up by election for position " + pos +
             " in club " + name + ": " + member + "\n");
 */
            setup_by_election(name,
                              pos, 
                              "Automatic after the position is declared "
                              "vacant.\n");
            set_club_changed(name);
         }
      }
   }
} /* check_elected_information() */

/**
 * This method setups up a by-election for the specified position in the
 * club.
 * @param club the club to make a byelection in
 * @param position the position the byelection is for
 * @param info the information about the vote
 * @return 1 on success, 0 on failure
 */
int setup_by_election(string club,
                      string position,
                      string info) {
   // Check to make sure that we are not in the election or nomination
   // Phase right now.  If we are too close to this phase we should
   // wait for the election to happen.
   return add_discussion_item(club,
                              CLUB_DISCUSS_NOMINATION |
                                 CLUB_DISCUSS_OPEN |
                                 CLUB_DISCUSS_NO_QUORUM,
                              CLUB_CONTROLLER_MEMBER,
                              position,
                              info,
                              ({ }),
                              7 * 24 * 60 * 60,
                              0);
} /* setup_by_election() */
// --- END [/mnt/home2/grok/lib/obj/handlers/inherit/club_discuss.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/tokeniser.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/tokeniser.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628441   Available: 13575795
Inodes: Total: 5242880    Free: 4960134
3666 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/tokeniser.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628441   Available: 13575795
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: tokeniser.c,v 1.3 2000/05/11 23:54:51 pinkfish Exp $
 * $Log: tokeniser.c,v $
 * Revision 1.3  2000/05/11 23:54:51  pinkfish
 * Make sure it detects floats correctly.
 *
 * Revision 1.2  1998/04/03 19:46:40  pinkfish
 * Add floating point support.
 *
 * Revision 1.1  1998/01/06 05:03:33  ceres
 * Initial revision
 * 
*/
/**
 * Does tokenising the the parser used by the mudlib when someone uses
 * the ';' command.
 * @author Pinkfish
 */
/* Ok, simple (hopefully) recursive descent parser. */
#include "tokenise.h"

mapping token;

void create() {
  token = ([
           '+' : TOK_PLUS,
           '-' : TOK_MINUS,
           '*' : TOK_MULT,
           '/' : TOK_DIV,
           '(' : TOK_OBRAC,
           ')' : TOK_CBRAC,
           '{' : TOK_SARRAY,
           '}' : TOK_EARRAY,
           '[' : TOK_SMAPPING,
           ']' : TOK_EMAPPING,
           ':' : TOK_COLON,
           ',' : TOK_COMMA,
           '.' : TOK_DOT,
           '\t' : TOK_TAB,
           '=' : TOK_ASSIGN,
#ifdef BOOLEAN
           '>' : TOK_GREATOR,
           '<' : TOK_LESS,
           "==" : TOK_EQUAL,
           ">=" : TOK_GREATOREQ,
           "<=" : TOK_LESSEQUAL,
#endif
           "->" : TOK_CALL,
           ".." : TOK_DOTDOT,
           ]);
} /* create() */

/**
 * Tokenise, we rip out strings and make them as seperate enties
 * Otherwise things inside strings will get processed elsewhere
 * which could be bad...
 * @param inp the input string
 * @return the tokenised string
 */
mixed tokenise(string inp) {
  string *bits, *cur;
  int pos, num;
  int start_pos;

  cur = ({ });
  while (pos < strlen(inp))
    switch (inp[pos++]) {
      case ' ' :
      case '\t' :
        break;
      case '\'' :
      case '"' :
      case '`' :
        bits = explode("#"+inp[pos-1..]+"#", inp[pos-1..pos-1]);
        if (!bits || sizeof(bits) < 2) {
          write("Error processing the string.\n");
          return 0;
        }
        pos += strlen(bits[1])+1;
        cur += ({ ({ bits[1] }) });
        break;
      case '.' :
      case '0' :
      case '1' :
      case '2' :
      case '3' :
      case '4' :
      case '5' :
      case '6' :
      case '7' :
      case '8' :
      case '9' :
        start_pos = pos;
        while ((inp[pos] >= '0' && inp[pos] <= '9') || (inp[pos] == '.')) {
          pos++;
        }
        if (strsrch(inp[start_pos..pos], ".") != -1) {
          sscanf(inp[start_pos-1..pos], "%f", num);
        } else {
          sscanf(inp[start_pos-1..pos], "%d", num);
        }
        cur += ({ ({ num }) });
        break;
      case '+' :
      case '*' :
      case ':' :
      case ',' :
      case '{' :
      case '}' :
      case '(' :
      case ')' :
      case '[' :
      case ']' :
        cur += ({ token[inp[pos-1]] });
        break;
      case '>' :
      case '<' :
      case '=' :
      case '-' :
      case '/' :
      case '.' :
        if (inp[pos-1] != '/') {
          if ((num = token[inp[pos-1..pos]])) {
            cur += ({ num });
            pos++;
            break;
          }
          num = token[inp[pos-1]];
          if (num) {
            cur += ({ num });
            break;
          }
        } else {
          if (sizeof(cur) && !stringp(cur[sizeof(cur)-1])) {
            cur += ({ token[inp[pos-1]] });
            break;
          }
        }
      default :
        num = pos-1;
        while (pos < strlen(inp) && (!token[inp[pos++]] || inp[pos-1] == '/'));
        if (pos == num+1)
          break;
        if (token[inp[pos-1]])
          pos--;
        cur += ({ inp[num..pos-1] });
        break;
    }
  return cur;
} /* tokenise() */
// --- END [/mnt/home2/grok/lib/obj/handlers/tokeniser.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/languages.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/languages.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628440   Available: 13575794
Inodes: Total: 5242880    Free: 4960134
10806 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/languages.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628440   Available: 13575794
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker: ceres $
 * $Id: languages.c,v 1.32 2003/02/19 08:35:25 ceres Exp ceres $
*/
/**
 * The language handler.  This will keep track of the info on languages
 * Each language can be a written language a spoken language and have
 * a garble object.
 *<p>
 * The function garble_say, garble_tell, garble_shout and
 * garble_written should be defined on the garbling object.
 * They should return the entire string to print.  So if the
 * routine returns 0 nothing is printed.
 *
 * @author Pinkfish
 */
 
#include <language.h>

#define L_NEW 512

#define REPLACEMENTS (["no1":"noone",\
                       "ne1":"anyone",\
                       "any1":"anyone",\
                       "u":"you",\
                       "r":"are", \
                       "NE1":"anyone",\
                       "U":"you",\
                       "R":"are", \
                       "ur":"you are",\
                       "teh":"the", \
                       "some1":"someone", \
                       "c":"see", \
                       "cing":"seeing",\
                       "sum1":"someone",\
                       "urs":"yours",\
                       "thier":"their", \
                       "pls":"please",\
                       "PLZ":"please",\
                       "plz":"please",\
                       "b4":"before", \
                       "tnx":"thanks"])

mapping languages;
string search;

void create() {
  languages = ([
  "rabbit" : ({ L_SPOKEN|L_WRITTEN|L_DISTANCE|L_ALWAYS_SPEAK|L_NEW,
                "/std/languages/rabbit", 10 }),
  "general" : ({ L_SPOKEN|L_WRITTEN|L_DISTANCE|L_ALWAYS_SPEAK/*|L_NEW */,
                "/std/languages/general", 10 }),
  //"common" : ({ L_SPOKEN|L_WRITTEN|L_DISTANCE/*|L_NEW */,
  //              "/std/languages/common", 10 }),
  "grunt" : ({ L_SPOKEN | L_ALWAYS_SPEAK, "/std/languages/grunt", 100 }),
  "wommon" : ({ L_WRITTEN|L_SPOKEN|L_DISTANCE|L_MAGIC,
                "/std/languages/wommon", 10 }),
              ]);

  search = "(" + implode(keys(REPLACEMENTS), "|") + ")";
} /* create() */

/**
 * Determine if the language is spoken. 
 *
 * @param str the language name to test
 * @return 1 if the language is spoken, 0 if it is not
 */
int query_language_spoken(string str) {
  if (!languages[str])
    return 0;
  return languages[str][0]&L_SPOKEN;
} /* query_language_spoken() */

/**
 * Determine if the language is written.
 *
 * @param str the language name to test
 * @return 1 if the language is written, 0 if it is not
 */ 
int query_language_written(string str) {
  if (!languages[str])
    return 0;
  return languages[str][0]&L_WRITTEN;
} /* query_language_written() */
 
/**
 * Determine if the language is spoken.
 * Distance languages can be used with tell and shout.
 *
 * @param str the language name to test
 * @return 1 if it is distance language, 0 if it is not
 */      
int query_language_distance(string str) {
  if (!languages[str])
    return 0;
  return languages[str][0]&L_DISTANCE;
} /* query_language_distance() */


/**
 * @ignore yes
 */
int query_language_new(string str) {
  if (!languages[str])
     return 0;
  return languages[str][0]&L_NEW;
} /* query_language_new() */
 
/**
 * Determine if it is a magical language.
 * A magical langage gets a function called on it's object whenever it
 * is read even if the person knows the language.  It is also the language
 * spells are written in.
 *
 * @param str the language to test
 * @return 1 if it is magical, 0 if it is not
 */
int query_language_magic(string str) {
  if (!languages[str])
    return 0;
  return languages[str][0]&L_MAGIC;
} /* query_language_magic() */

/**
 * The size of the language.  Some languages have bigger letters
 * and stuff than others.
 * 
 * @param str the language to get the size of
 * @return the size of each letter 
 */
int query_language_size(string str) {
  if (!languages[str])
    return 0;
  return languages[str][2];
} /* query_language_size() */
 
/**
 * Determine if the language is always able to be spoken. 
 *
 * @param str the language name to test
 * @return 1 if the language is spoken, 0 if it is not
 */
int query_language_always_spoken(string str) {
  if (!languages[str])
    return 0;
  return languages[str][0]&L_ALWAYS_SPEAK;
} /* query_language_spoken() */

/* This is called to resize the text if it doesnt fit... */
/**
 * @ignore yes
 */
mixed squidge_text(string lang, mixed str, int size) {
  if (!languages[lang])
    return 0; /* Don't add it... */
  if (!(languages[lang][0]&L_MAGIC))
    return str[0..(size/languages[lang][2])];
  return (mixed)languages[lang][1]->squidge_text(str, size);
} /* squish_text() */

/* Should not really allow this... 
int add_language(string name, int flags, mixed ob, int size) {
  languages[name] = ({ flags, ob, size });
} * add_language() */

/**
 * Return all the flags for the language.
 *
 * @param name the language to get the flags of
 * @return all the flags
 * @see /include/language.h
 */
int query_flags(string name) {
  if (!languages[name])
    return 0;
  return languages[name][0];
} /* query_flags() */

/**
 * Figure out the garble object.  This returns the garble object for the
 * language.  The garble object is used to modify the text so that
 * player does not see plain text if they do not know the language.
 *
 * @param name the language to get the garble object for
 * @return the garble object
 */ 
string query_garble_object(string name) {
  if (!languages[name])
    return 0;
  return languages[name][1];
} /* query_garble_object() */

/**
 * Names of all the languages.
 * @return the names of all the languages
 */ 
string *query_languages() {
  return m_indices(languages);
} /* query_languages() */

/**
 * Determine if this is a language.
 * @return 1 if it is a language, 0 if it s not
 * @param str the language to check
 */ 
int test_language(string str) {
  return pointerp(languages[str]);
} /* test_language() */

/**
 * The skill for the spoken language.  This gets the skill name in the skill
 * tree for the spoken part of the language.
 * @param lang the language to get the skill of
 * @return the skill name
 */
string query_language_spoken_skill(string lang) {
  return LANGUAGE_SKILL_START + replace(lang, " ", "_") + "." + SPOKEN_SKILL;
} /* query_language_spoken_skill() */

/**
 * The skill for the written language.  This gets the skill name in the skill
 * tree for the written part of the language.
 * @param lang the language to get the skill of
 * @return the skill name
 */
string query_language_written_skill(string lang) {
  return LANGUAGE_SKILL_START + replace(lang, " ", "_") + "." + WRITTEN_SKILL;
} /* query_language_written_skill() */

/**
 * This garbles a say.  Called from the events class to garble the text
 * that players see.  This looks up the garble object and calls the
 * correct function on it.  The returned array contains the
 * garbled start and message.
 *
 * @param lang the language spoken in
 * @param start the start bit
 * @param mess the message itself
 * @param player the player hearing
 * @param from the player speaking
 * @param type 'say', 'tell', 'shout' etc
 * @return an array <code>({ start, mess })</code>
 */
mixed garble_say(string lang, string start, string mess,
                 object player, object from, string type) {
   string garble_ob;

   if (query_language_new(lang)) {
      garble_ob = query_garble_object(lang);
      if (living (from) && garble_ob) {
         return garble_ob->garble_say(start, mess, player, from, type,
                                      query_language_spoken_skill(lang),
                                      type == SHOUT_TYPE);
      }
   } else {
      if (player->query_skill(query_language_spoken_skill(lang)) < 99) {
         garble_ob = query_garble_object(lang);
         if(garble_ob)
           return garble_ob->garble_say(start, mess, player, type);
         else
           debug_printf("Error, %s has no garble object.", lang);
      }
   }
   
   return ({ start, mess });
} /* garble_say() */

/**
 * Garble written text.  This is the same as garble_say, but it works on
 * written text.
 *
 * @param lang the language written in
 * @param text the text which has been written
 * @param thing the thing which is written on
 * @param player the player doing the reading
 * @return the garbled text as a string
 */
string garble_text(string lang, mixed text, object thing, object player ) {
   string garble_ob;

   if (functionp(text)) {
      text = evaluate(text);
   }

   if (query_language_new(lang)) {
      garble_ob = query_garble_object(lang);
      if (garble_ob) {
         return garble_ob->garble_text(text, thing, player,
                                       query_language_written_skill(lang));
      }
   } else {
      if (player->query_skill(query_language_written_skill(lang)) < 99) {
         garble_ob = query_garble_object(lang);
         if( !garble_ob )
            return "You do not recognise the language.\n";
         else
            return garble_ob->garble_text(text, thing, player);
      }
      if (query_language_magic(lang)) {
         garble_ob = query_garble_object(lang);
         return garble_ob->magical_text(text, thing, player);
      }
      return text;
   }

   if (query_language_magic(lang))
      return 0;

   return "Text written in " + lang + " could not have been written.  "
          "There are "
          "broken bits of letters scattered over the page, looks like "
          "someone had a bad game of scrabble.\n";
} /* garble_text() */

/**
 * Remove "ne1" and suchlike
 */

string do_replacements(string mess) {
  string *bits, name, value;
  mixed *tmp;
  int index, i, add_space;

  // This one's a little different so it's done on its own.
  mess = replace(mess, ({"ne1 no ", "anyone know "}));
  
  // First check to see if the sentance contains a possible replacement.
  if(!regexp(mess, search))
    return mess;

  /*
   * We have a possible so explode the line into words and check each
   * replacement against each word. If there's a match then replace.
   */
  if(mess[<1] == ' ')
    add_space = 1;
  bits = explode(mess, " ");
  foreach(name, value in REPLACEMENTS) {
    tmp = regexp(bits, "(^|[^A-Za-z0-9\\\\./_&-]+)"+name+"($|[^A-Za-z0-9\\./&_-]+)", 1);
    if(sizeof(tmp)) {
      for(i=0; i<sizeof(tmp); i+=2) {
        index = tmp[i+1]-1;
        bits[index] = replace(bits[index], name, value);
      }
    }
  }
  return implode(bits, " ") + (add_space ? " " : "");
}

string fix_shorthand(string mess) {
  string pre, mid, post, res;

  if (!stringp(mess)) {
     return "";
  }
  res = "";
  while(sscanf(mess, "%s'%s'%s", pre, mid, post) == 3) {
    res += do_replacements(pre) + "'" + mid;
    mess = "'" + post;
  }
    
  res += do_replacements(mess);
  
  return res;
}

// --- END [/mnt/home2/grok/lib/obj/handlers/languages.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/terrain_things/sample_room_1.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/terrain_things/sample_room_1.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628437   Available: 13575791
Inodes: Total: 5242880    Free: 4960134
668 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/terrain_things/sample_room_1.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628437   Available: 13575791
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/room";

void setup() {
   set_short( "small room" );
   set_light( 20 );
   set_room_size( 15 );
   set_long( "You are in a small room.  The walls, floor and ceiling are "+
         "comprised of large stone blocks.  The room is quite bare.\n" );
   add_item( ({ "wall", "floor", "ceiling" }), "The walls, floor and "+
         "ceiling of the room are formed from large stone blocks." );
   add_item( "large stone block", "The blocks of stone that make up the "+
         "surfaces of this room are not too rough, but they were never "+
         "polished smooth either." );
} /* setup() */

string query_exit_type( string word ) { return "corridor"; }
// --- END [/mnt/home2/grok/lib/obj/handlers/terrain_things/sample_room_1.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/terrain_things/logroom.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/terrain_things/logroom.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628437   Available: 13575791
Inodes: Total: 5242880    Free: 4960134
2029 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/terrain_things/logroom.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628437   Available: 13575791
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: logroom.c,v 1.1 1998/01/06 05:06:10 ceres Exp $
 * $Log: logroom.c,v $
 * Revision 1.1  1998/01/06 05:06:10  ceres
 * Initial revision
 * 
*/
#include <terrain.h>

#define SAVE_FILE RESTORE_PATH +"logroom"

inherit "/std/room";

mapping locations;

void setup() {
   set_short( "limbo" );
   set_light( 50 );
   set_long( "You are between worlds, surrounded by raw potentiality and "+
         "not a lot else.\n" );
   add_item( "potentiality", "Well, it's sort of potentially something and "+
         "potentially nothing, and it can't quite decide at the moment.  "+
         "With any luck, though, you won't be here long enough to find "+
         "out...\n" );
   add_exit( "drum", "/d/am/am/mendeddrum", "path" );
   locations = ([ ]);
   if ( file_size( SAVE_FILE +".o" ) )
      unguarded((: restore_object, SAVE_FILE :));
} /* setup() */

void save_this() {
  unguarded((: save_object, SAVE_FILE :));
}

void player_quitting( object player, object place ) {
   if ( player->query_property( "guest" ) )
      return;
   locations[ (string)player->query_name() ] =
         ({ (string)place->query_property( "terrain name" ),
         (int *)place->query_co_ord() });
   save_this();
   call_out( "check_quitted", 5, (string)player->query_name() );
} /* player_quitting() */

void check_quitted( string word ) {
   if ( !find_player( word ) )
      return;
   if ( locations[ word ] )
      locations = m_delete( locations, word );
   save_this();
} /* check_quitted() */

void event_enter( object player, string words, object thing ) {
   object location;
   mixed *data;
   data = locations[ (string)player->query_name() ];
   if ( !data ) {
      player->move( (string)player->query_start_pos(),
            "$N enter$s the game." );
      return;
   }
   location = (object)TERRAIN_MAP->find_location( data[ 0 ],
         data[ 1 ] );
   player->move( location );
   locations = m_delete( locations, (string)player->query_name() );
   save_this();
} /* event_enter() */
// --- END [/mnt/home2/grok/lib/obj/handlers/terrain_things/logroom.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/terrain_things/sample_passage.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/terrain_things/sample_passage.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628436   Available: 13575790
Inodes: Total: 5242880    Free: 4960134
435 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/terrain_things/sample_passage.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628436   Available: 13575790
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/room";

void setup() {
   set_short( "dusty corridor" );
   set_light( 20 );
   set_room_size( 5 );
   set_long( "You are in a dry, dusty corridor.  It looks as though it has "+
         "been deserted for a long time.\n" );
   add_item( "dust", "There's quite a bit of dust in here, collecting along "+
         "the bottom of the walls." );
} /* setup() */

string query_exit_type( string word ) { return "corridor"; }
// --- END [/mnt/home2/grok/lib/obj/handlers/terrain_things/sample_passage.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/terrain_things/sample_room_3.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/terrain_things/sample_room_3.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628436   Available: 13575790
Inodes: Total: 5242880    Free: 4960134
668 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/terrain_things/sample_room_3.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628436   Available: 13575790
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/room";

void setup() {
   set_short( "large room" );
   set_light( 20 );
   set_room_size( 35 );
   set_long( "You are in a large room.  The walls, floor and ceiling are "+
         "comprised of large stone blocks.  The room is quite bare.\n" );
   add_item( ({ "wall", "floor", "ceiling" }), "The walls, floor and "+
         "ceiling of the room are formed from large stone blocks." );
   add_item( "large stone block", "The blocks of stone that make up the "+
         "surfaces of this room are not too rough, but they were never "+
         "polished smooth either." );
} /* setup() */

string query_exit_type( string word ) { return "corridor"; }
// --- END [/mnt/home2/grok/lib/obj/handlers/terrain_things/sample_room_3.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/terrain_things/dungeon_maker.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/terrain_things/dungeon_maker.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628435   Available: 13575789
Inodes: Total: 5242880    Free: 4960134
15798 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/terrain_things/dungeon_maker.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628435   Available: 13575789
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: dungeon_maker.c,v 1.2 1999/08/17 17:46:06 wodan Exp $
 * $Log: dungeon_maker.c,v $
 * Revision 1.2  1999/08/17 17:46:06  wodan
 * changed to add_command
 *
 * Revision 1.1  1998/01/06 05:06:10  ceres
 * Initial revision
 * 
*/
#include <dirs.h>
#include <terrain.h>

#define END 0
#define TWO 1
#define FOUR 2
#define ROOM 3

#define HALF 0
#define FULL 1

#define DIRS ({ "north", "northeast", "east", "southeast", \
      "south", "southwest", "west", "northwest" })
inherit "/std/object";

int max, size, *clear, *c_probs, *p_probs, *r_probs, *start;
string terrain_name, *passage_files, *room_files;
object easel;
mixed *passages, *room_entries;

void setup() {
   set_name( "box" );
   set_short( "green box" );
   add_adjective( "green" );
   set_long( "This is a green box.  It's quite featureless but, strangely "+
         "enough, something tells you it's a dungeon generator.\n" );
   reset_get();
   start = allocate( 3 );
   passages = ({ });
   room_entries = ({ });
} /* setup() */

void dest_me() {
   if ( easel )
      easel->dest_me();
   ::dest_me();
} /* dest_me() */

int query_max_locations() { return max; }
void set_max_locations( mixed arg ) { max = to_int( arg ); }

int *query_junction_clearance() { return clear; }
void set_junction_clearance( mixed *args ) {
   int i;
   clear = allocate( sizeof( args ) );
   for ( i = 0; i < sizeof( args ); i++ )
      clear[ i ] = to_int( args[ i ] );
} /* set_junction_clearance() */

int *query_continue_probabilities() { return c_probs; }
void set_continue_probabilities( mixed *args ) {
   int i;
   c_probs = allocate( sizeof( args ) );
   for ( i = 0; i < sizeof( args ); i++ )
      c_probs[ i ] = to_int( args[ i ] );
} /* set_continue_probabilities() */

int *query_passage_probabilities() { return p_probs; }
void set_passage_probabilities( mixed *args ) {
   int i;
   p_probs = allocate( sizeof( args ) );
   for ( i = 0; i < sizeof( args ); i++ )
      p_probs[ i ] = to_int( args[ i ] );
} /* set_passage_probabilities() */

int *query_room_probabilities() { return r_probs; }
void set_room_probabilities( mixed *args ) {
   int i;
   r_probs = allocate( sizeof( args ) );
   for ( i = 0; i < sizeof( args ); i++ )
      r_probs[ i ] = to_int( args[ i ] );
} /* set_room_probabilities() */

int *query_start_co_ord() { return start; }
void set_start_co_ord( mixed *args ) {
   int i;
   if ( sizeof( args ) != 3 )
      return;
   for ( i = 0; i < sizeof( args ); i++ )
      start[ i ] = to_int( args[ i ] );
} /* set_passage_probabilities() */

string query_terrain_name() { return terrain_name; }
void set_terrain_name( string word ) { terrain_name = word; }

string *query_passage_files() { return passage_files; }
void set_passage_files( string *words ) { passage_files = words; }

string *query_room_files() { return room_files; }
void set_room_files( string *words ) { room_files = words; }

object query_easel() { return easel; }

mixed *query_passages() { return passages; }

mixed *query_room_entries() { return room_entries; }

int do_generate(string);

void init() {
//  ::init();
   add_command( "generate", "<word'terrainname'>", (:do_generate($4[0]):));
} /* init() */

void mark_passage( int *co_ord ) {
   easel->add_shape( ({ ( co_ord[ 1 ] - start[ 1 ] ) / size,
         ( start[ 0 ] - co_ord[ 0 ] ) / size }), ({ "#" }) );
} /* mark_passage() */

void mark_room( int *co_ord, string room ) {
   int width;
   width = (int)room->query_room_size();
   easel->add_shape( ({ ( co_ord[ 1 ] - start[ 1 ] - width - size / 2 ) / size,
         ( start[ 0 ] - co_ord[ 0 ] - width - size / 2 ) / size }),
         (string *)easel->make_block( ( 2 * width ) / size + 2 ) );
} /* mark_room() */

int do_generate( string word ) {
   int i;
   string data, direc, *lines;
   mixed *parameters;
   if ( easel )
      return notify_fail( "The generator is working on "+
            terrain_name +".\n" );
   if ( file_size( word ) < 0 )
      return notify_fail( "File "+ word +" does not exist.\n" );
   lines = explode( read_file( word ), "\n" );
   for ( i = 0; i < sizeof( lines ); i++ ) {
      if ( lines[ i ] == "" )
         continue;
       if ( lines[ i ][ 0 .. 0 ] == "#" )
         continue;
      parameters = explode( lines[ i ], " " );
      if ( !stringp( parameters[ 0 ] ) ) {
         printf( "%s line %d: %O is not a string.\n", word, i,
               parameters[ 0 ] );
         continue;
      }
      if ( sizeof( parameters ) == 2 )
         call_other( this_object(), "set_"+ parameters[ 0 ],
               parameters[ 1 ] );
      else
         call_other( this_object(), "set_"+ parameters[ 0 ],
               parameters[ 1 .. sizeof( parameters ) - 1 ] );
      printf( "Set %s to %O.\n", parameters[ 0 ], call_other( this_object(),
            "query_"+ parameters[ 0 ] ) );
   }
   if ( file_size( RESTORE_PATH + terrain_name +".o" ) > 0 )
      return notify_fail( "Terrain "+ terrain_name +" already exists.\n" );
   easel = clone_object( "/obj/misc/easel" );
   set_long( "This is a green box.  It's quite featureless but, strangely "+
         "enough, something tells you it's a dungeon generator.\nIt seems "+
         "to be humming quietly but in a very powerful way.\n" );
   write( "Working on "+ terrain_name +".\n" );
   direc = DIRS[ random( 8 ) ];
   for ( i = 0; i < 4; i++ )
      passages += ({ ({ DIRS[ ( member_array( direc, DIRS ) + 2 * i ) % 8 ],
            passage_files[ random( sizeof( passage_files ) ) ],
            start, 0, 0, 1 + clear[ 0 ] + random( clear[ 1 ] ) }) });
   size = 2 * (int)passage_files[ 0 ]->query_room_size();
   TERRAIN_MAP->add_floating_location( terrain_name, passage_files[ 0 ],
         start, 0 );
   call_out( "process_passages", 2 );
   return 1;
} /* do_generate() */

void stop_working() {
   tell_room( environment(), "The box stops humming as it extrudes an "+
         "easel from a slot in one side.\n" );
   easel->add_shape( ({ 0, 0 }), ({ "@" }) );
   write_file( "/open/"+ terrain_name +".map",
         implode( (string *)easel->query_lines(), "\n" ) );
   easel->move( environment() );
   easel = 0;
   passages = ({ });
   room_entries = ({ });
   set_long( "This is a green box.  It's quite featureless but, strangely "+
         "enough, something tells you it's a dungeon generator.\n" );
} /* stop_working() */

int *shift_in( int *co_ord, string direc, string from, string to ) {
   int i, delta, *new_co_ord, *vector;
   delta = (int)from->query_room_size() + (int)to->query_room_size();
   new_co_ord = allocate( 3 );
   vector = STD_ORDERS[ member_array( direc, STD_ORDERS ) + 1 ];
   for ( i = 0; i < 3; i++ )
      new_co_ord[ i ] = co_ord[ i ] - delta * vector[ i ];
   return new_co_ord;
} /* shift_in() */

void process_passages() {
   int i, j, k, prob, straight, *co_ord, *new_co_ord;
   string direc, new_direc, type, new_type;
   mixed *last;
   if ( !sizeof( passages ) ) {
      tell_room( environment(), "No passages to process.\n" );
      return stop_working();
   }
   if ( max < 1 ) {
      tell_room( environment(), "Reached maximum.\n" );
      return stop_working();
   }
   max--;
   direc = passages[ 0 ][ 0 ];
   type = passages[ 0 ][ 1 ];
   co_ord = passages[ 0 ][ 2 ];
   last = passages[ 0 ][ 3 .. 4 ];
   straight = passages[ 0 ][ 5 ];
   passages = delete( passages, 0, 1 );
   call_out( "process_passages", 2 );
   for ( i = 0; i < 3; i++ ) {
      new_direc = DIRS[ ( member_array( direc, DIRS ) + 7 + i ) % 8 ];
      new_co_ord = shift_in( co_ord, new_direc, type, type );
      if ( sizeof( (mixed *)TERRAIN_MAP->
            member_floating_locations( new_co_ord ) ) ) {
         tell_room( environment(), "Passage already at "+ new_co_ord[ 0 ] +
               ", "+ new_co_ord[ 1 ] +", "+ new_co_ord[ 2 ] +"; ending "+
               "passage at "+ co_ord[ 0 ] +", "+ co_ord[ 1 ] +", "+
               co_ord[ 2 ] +".\n" );
         return;
      }
      for ( j = 0; j < sizeof( room_entries ); j++ ) {
         for ( k = 0; k < 3; k++ )
            if ( new_co_ord[ k ] != room_entries[ j ][ k ] )
               break;
         if ( k < 3 )
            continue;
         tell_room( environment(), "Room entry at "+ new_co_ord[ 0 ] +
               ", "+ new_co_ord[ 1 ] +", "+ new_co_ord[ 2 ] +"; "+
               "joining passage at "+ co_ord[ 0 ] +", "+ co_ord[ 1 ] +", "+
               co_ord[ 2 ] +".\n" );
         TERRAIN_MAP->add_floating_location( terrain_name, type, new_co_ord,
               0 );
         mark_passage( new_co_ord );
         room_entries = delete( room_entries, j, 1 );
         return;
      }
      if ( (int)easel->query_at( ({ ( new_co_ord[ 1 ] - start[ 1 ] ) / size,
            ( start[ 0 ] - new_co_ord[ 0 ] ) / size }) ) != 32 ) {
         tell_room( environment(), "Something at "+ new_co_ord[ 0 ] +
               ", "+ new_co_ord[ 1 ] +", "+ new_co_ord[ 2 ] +"; ending "+
               "passage at "+ co_ord[ 0 ] +", "+ co_ord[ 1 ] +", "+
               co_ord[ 2 ] +".\n" );
         return;
      }
   }
   prob = random( 100 );
   if ( prob < p_probs[ END ] ) {
      tell_room( environment(), "Passage going "+ direc +" ends at "+
            co_ord[ 0 ] +", "+ co_ord[ 1 ] +", "+ co_ord[ 2 ] +".\n" );
      return;
   }
   prob -= p_probs[ END ];
   if ( ( prob < p_probs[ TWO ] ) && !straight ) {
      if ( random( 100 ) >= c_probs[ HALF ] + c_probs[ FULL ] ) {
         tell_room( environment(), "Passage branching "+ direc +" and " );
         new_co_ord = shift_in( co_ord, direc, type, type );
         TERRAIN_MAP->add_floating_location( terrain_name, type,
               new_co_ord, 0 );
         passages += ({ ({ direc, type, new_co_ord, co_ord, last[ 0 ],
               clear[ 0 ] + random( clear[ 1 ] ) }) });
         mark_passage( new_co_ord );
         if ( random( c_probs[ HALF ] + c_probs[ FULL ] ) < c_probs[ HALF ] )
            direc = DIRS[ ( member_array( direc, DIRS ) + 1 +
                  6 * random( 2 ) ) % 8 ];
         else
            direc = DIRS[ ( member_array( direc, DIRS ) + 2 +
                  4 * random( 2 ) ) % 8 ];
         type = passage_files[ random( sizeof( passage_files ) ) ];
         new_co_ord = shift_in( co_ord, direc, type, type );
         TERRAIN_MAP->add_floating_location( terrain_name, type, new_co_ord,
               0 );
         passages += ({ ({ direc, type, new_co_ord, co_ord, last[ 0 ],
               clear[ 0 ] + random( clear[ 1 ] ) }) });
         mark_passage( new_co_ord );
         tell_room( environment(), direc +" from "+
               co_ord[ 0 ] +", "+ co_ord[ 1 ] +", "+ co_ord[ 2 ] +".\n" );
         return;
      }
      if ( random( c_probs[ HALF ] + c_probs[ FULL ] ) < c_probs[ HALF ] )
         new_direc = DIRS[ ( member_array( direc, DIRS ) + 1 ) % 8 ];
      else
         new_direc = DIRS[ ( member_array( direc, DIRS ) + 2 ) % 8 ];
      type = passage_files[ random( sizeof( passage_files ) ) ];
      new_co_ord = shift_in( co_ord, new_direc, type, type );
      TERRAIN_MAP->add_floating_location( terrain_name, type, new_co_ord, 0 );
      passages += ({ ({ new_direc, type, new_co_ord, co_ord, last[ 0 ],
            clear[ 0 ] + random( clear[ 1 ] ) }) });
      mark_passage( new_co_ord );
      tell_room( environment(), "Passage branching "+ new_direc +" and " );
      if ( random( c_probs[ HALF ] + c_probs[ FULL ] ) < c_probs[ HALF ] )
         new_direc = DIRS[ ( member_array( direc, DIRS ) + 7 ) % 8 ];
      else
         new_direc = DIRS[ ( member_array( direc, DIRS ) + 6 ) % 8 ];
      type = passage_files[ random( sizeof( passage_files ) ) ];
      new_co_ord = shift_in( co_ord, new_direc, type, type );
      TERRAIN_MAP->add_floating_location( terrain_name, type, new_co_ord, 0 );
      passages += ({ ({ new_direc, type, new_co_ord, co_ord, last[ 0 ],
            clear[ 0 ] + random( clear[ 1 ] ) }) });
      mark_passage( new_co_ord );
      tell_room( environment(), new_direc +" from "+
            co_ord[ 0 ] +", "+ co_ord[ 1 ] +", "+ co_ord[ 2 ] +".\n" );
      return;
   }
   prob -= p_probs[ TWO ];
   if ( ( prob < p_probs[ FOUR ] ) && !straight ) {
      tell_room( environment(), "Crossroads from "+ direc +" at "+
            co_ord[ 0 ] +", "+ co_ord[ 1 ] +", "+ co_ord[ 2 ] +".\n" );
      for ( i = 0; i < 3; i++ ) {
         new_direc = DIRS[ ( member_array( direc, DIRS ) + 6 + 2 * i ) % 8 ];
         type = passage_files[ random( sizeof( passage_files ) ) ];
         new_co_ord = shift_in( co_ord, new_direc, type, type );
         TERRAIN_MAP->add_floating_location( terrain_name, type, new_co_ord,
               0 );
         passages += ({ ({ new_direc, type, new_co_ord, co_ord, last[ 0 ],
               clear[ 0 ] + random( clear[ 1 ] ) }) });
         mark_passage( new_co_ord );
      }
      return;
   }
   prob -= p_probs[ FOUR ];
   if ( ( prob < p_probs[ ROOM ] ) && !straight ) {
      prob = random( 100 );
      new_type = room_files[ 0 ];
      for ( i = 1; i < sizeof( room_files ); i++ )
         if ( prob < r_probs[ FULL + i ] ) {
            new_type = room_files[ i ];
            break;
         } else
            prob -= r_probs[ FULL + i ];
      new_co_ord = shift_in( co_ord, direc, type, new_type );
      tell_room( environment(), "Room at "+ new_co_ord[ 0 ] +", "+
            new_co_ord[ 1 ] +", "+ new_co_ord[ 2 ] +".\n" );
      TERRAIN_MAP->add_floating_location( terrain_name, new_type,
            new_co_ord, 0 );
      mark_room( new_co_ord, new_type );
      mark_passage( co_ord );
      for ( i = 1; i < 8; i++ ) {
         new_direc = DIRS[ ( member_array( direc, DIRS ) + 4 + i ) % 8 ];
         type = passage_files[ random( sizeof( passage_files ) ) ];
         co_ord = shift_in( new_co_ord, new_direc, new_type, type );
         if ( i % 2 ) {
            if ( random( 100 ) < r_probs[ HALF ] ) {
               tell_room( environment(), "Passage leaving room to "+
                     new_direc +".\n" );
               TERRAIN_MAP->add_floating_location( terrain_name, type, co_ord,
                     0 );
               passages += ({ ({ new_direc, type, co_ord, new_co_ord,
                     last[ 0 ], clear[ 0 ] + random( clear[ 1 ] ) }) });
               mark_passage( co_ord );
            } else
               room_entries += ({ co_ord });
         } else {
            if ( random( 100 ) < r_probs[ FULL ] ) {
               tell_room( environment(), "Passage leaving room to "+
                     new_direc +".\n" );
               TERRAIN_MAP->add_floating_location( terrain_name, type, co_ord,
                     0 );
               passages += ({ ({ new_direc, type, co_ord, new_co_ord,
                     last[ 0 ], clear[ 0 ] + random( clear[ 1 ] ) }) });
               mark_passage( co_ord );
            } else
               room_entries += ({ co_ord });
         }
      }
      return;
   }
   prob = random( 100 );
   if ( ( prob < c_probs[ HALF ] ) && !straight ) {
      direc = DIRS[ ( member_array( direc, DIRS ) + 1 +
             6 * random( 2 ) ) % 8 ];
      straight = clear[ 0 ] + random( clear[ 1 ] );
   } else {
      prob -=  c_probs[ HALF ];
      if ( ( prob < c_probs[ FULL ] ) && !straight ) {
         direc = DIRS[ ( member_array( direc, DIRS ) + 2 +
               4 * random( 2 ) ) % 8 ];
         straight = clear[ 0 ] + random( clear[ 1 ] );
      }
   }
   if ( straight > 0 )
      straight--;
   new_co_ord = shift_in( co_ord, direc, type, type );
   tell_room( environment(), "Passage goes "+ direc +" from "+
         co_ord[ 0 ] +", "+ co_ord[ 1 ] +", "+ co_ord[ 2 ] +".\n" );
   TERRAIN_MAP->add_floating_location( terrain_name, type, new_co_ord, 0 );
   passages += ({ ({ direc, type, new_co_ord, co_ord, last[ 0 ],
         straight }) });
   mark_passage( new_co_ord );
} /* process_passages() */
// --- END [/mnt/home2/grok/lib/obj/handlers/terrain_things/dungeon_maker.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/terrain_things/sample_passage_2.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/terrain_things/sample_passage_2.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628431   Available: 13575785
Inodes: Total: 5242880    Free: 4960134
463 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/terrain_things/sample_passage_2.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628431   Available: 13575785
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/room";

void setup() {
   set_short( "rock-walled tunnel" );
   set_light( 20 );
   set_room_size( 5 );
   set_long( "You are tunnel with rough-hewn rock walls.  It looks as though "+
         "it has been deserted for a long time.\n" );
   add_item( ({ "rough-hewn rock wall", "rock" }), "The walls are rough, "+
         "where the tunnel was hewn out of the rock." );
} /* setup() */

string query_exit_type( string word ) { return "corridor"; }
// --- END [/mnt/home2/grok/lib/obj/handlers/terrain_things/sample_passage_2.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/terrain_things/sample_room_2.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/terrain_things/sample_room_2.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628431   Available: 13575785
Inodes: Total: 5242880    Free: 4960134
672 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/terrain_things/sample_room_2.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628431   Available: 13575785
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/room";

void setup() {
   set_short( "largish room" );
   set_light( 20 );
   set_room_size( 25 );
   set_long( "You are in a largish room.  The walls, floor and ceiling are "+
         "comprised of large stone blocks.  The room is quite bare.\n" );
   add_item( ({ "wall", "floor", "ceiling" }), "The walls, floor and "+
         "ceiling of the room are formed from large stone blocks." );
   add_item( "large stone block", "The blocks of stone that make up the "+
         "surfaces of this room are not too rough, but they were never "+
         "polished smooth either." );
} /* setup() */

string query_exit_type( string word ) { return "corridor"; }
// --- END [/mnt/home2/grok/lib/obj/handlers/terrain_things/sample_room_2.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/terrain_things/sample_passage_1.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/terrain_things/sample_passage_1.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628431   Available: 13575785
Inodes: Total: 5242880    Free: 4960134
435 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/terrain_things/sample_passage_1.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628431   Available: 13575785
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/room";

void setup() {
   set_short( "dusty corridor" );
   set_light( 20 );
   set_room_size( 5 );
   set_long( "You are in a dry, dusty corridor.  It looks as though it has "+
         "been deserted for a long time.\n" );
   add_item( "dust", "There's quite a bit of dust in here, collecting along "+
         "the bottom of the walls." );
} /* setup() */

string query_exit_type( string word ) { return "corridor"; }
// --- END [/mnt/home2/grok/lib/obj/handlers/terrain_things/sample_passage_1.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/housing.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/housing.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628430   Available: 13575784
Inodes: Total: 5242880    Free: 4960134
25469 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/housing.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628430   Available: 13575784
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * A handler to track player houses.  This handler should only be used for
 * general houses that are available for sale or rent. Don't add club or
 * special (eg. guildmaster) houses here or they'll get sold or rented :)
 *
 * The handler stores information about registered player houses, makes houses
 * vacant if their owners are idle and charges rent on rented houses.
 *
 * @author Ceres
 */

#include <housing.h>
#include <login_handler.h>
#include <am_time.h>
#include <nomic_system.h>

#define BANK "/obj/handlers/bank_handler"
#define DEFAULT_BANK "Bing's First"
#define DEFAULT_PLACE "Ankh-Morpork"
#define MAIL_HANDLER "/obj/handlers/mailer"

#define SAVE_FILE "/save/player_housing/housing"

/**
 * This class stores all the data about a given house. The class is used
 * within the houses mapping. The key of the mapping is the basename of the
 * house (the filename of the main room) and the value is this class, which
 * explains why this class doesn't have a name or filename field for the house.
 *
 * @field other_rooms a string array of the other rooms in the house.
 * @field owner the name of the current owner. This may also be 'For Sale' or
 * 'Under Offer' while the house is vacant or being auctioned.
 * @field region The region the house is in eg. 'Ankh-Morpork'
 * @field type The type of house. 1 for rented, 0 for owned.
 * @field value The current value of the house. For rented houses this is the
 * monthly rent, for owned houses this is the purchase price.
 *
 */
class housing {
  string *other_rooms;
  string owner;
  string address;
  string region;
  int type;
  int value;
  string bank;
}

void load_file();
string query_housing_area_bank(string area);

private nosave string *_tmp_houses;
private nosave string *_tmp_rentals;

private mapping houses;
private int last_paid;
// This is a mapping to setup a link between housing and a specific citizenship
// area.
private mapping _housing_area;
private mapping _area_money;

/** @ignore yes */
void create() {
  houses = ([ ]);
  _housing_area = ([ ]);
  _area_money = ([ ]);
  seteuid("Root");
  load_file();
  if (!_housing_area) {
    _housing_area = ([ ]);
  }
  if (!_area_money) {
    _area_money = ([ ]);
  }
  call_out("check_owners", 900 + random(1800), 0);
  call_out("check_rent", 900 + random(1800));
}

/*
 * Utility functions
 */
/** @ignore yes */
void save_file() {
  unguarded((: cp, SAVE_FILE + ".o", SAVE_FILE + ".o.bak" :));
  unguarded((: save_object, SAVE_FILE :));
}

/** @ignore yes */
void load_file() {
  if (file_size(SAVE_FILE+".o") > 0)
    unguarded((: restore_object, SAVE_FILE :));
}

#ifdef 0
int change() {
  class housing nhouse;
  string house;

  foreach(house in keys(houses)) {
    write(sizeof(houses[house]) + "\n");
    if(sizeof(houses[house]) == 6) {
      nhouse = new(class housing,
                   other_rooms: houses[house]->other_rooms,
                   owner: houses[house]->owner,
                   address: houses[house]->address,
                   region: houses[house]->region,
                   type: houses[house]->type,
                   bank: houses[house]->region
               );
      houses[house] = nhouse;
    }
  }
  save_file();
  return 1;
}
#endif

/**
 * Add a new house to the handler.
 *
 * @param house the basename of the house
 * @param other_rooms an array of other rooms in the house
 * @param address a string for the address
 * @param region the region (used for house sales)
 * @param type an integer. 1 for owned, 0 for rented.
 * @return 1 for success, 0 for failure
 */
int add_house(string house, string *other_rooms, string address,
              string region, int type) {
  if(!houses)
    houses = ([ ]);

  if(houses[house])
    return 0;

  houses[house] = new(class housing,
                      other_rooms: uniq_array(other_rooms),
                      address: address,
                      region: region,
                      type: type,
                      bank: query_housing_area_bank(region)
                  );
  save_file();
  return 1;
}

/**
 * Modify a houses information.
 *
 * @param house the basename of the house
 * @param other_rooms an array of other rooms in the house
 * @param address a string for the address
 * @param region the region (used for house sales)
 * @param type an integer. 1 for owned, 0 for rented.
 * @return 1 for success, 0 for failure
 */
int modify_house(string house, string *other_rooms, string address,
              string region, int type) {
  if(!houses)
    houses = ([ ]);

  if(!houses[house])
    return 0;

  houses[house] = new(class housing,
                      other_rooms: uniq_array(other_rooms),
                      address: address,
                      region: region,
                      type: type,
                      bank: query_housing_area_bank(region));
  save_file();
  return 1;
}

/**
 * Rename a house. This will remove the "main" room and replace it with
 * another.
 * @param house the current basename of the house
 * @param newhouse the new basename.
 */
int rename_house(string house, string newhouse) {
  if(!houses[house])
    return 0;
  if(houses[newhouse])
    return 0;
  houses[newhouse] = houses[house];
  if(member_array(newhouse, houses[newhouse]->other_rooms) != -1)
    houses[newhouse]->other_rooms -= ({ newhouse });
  map_delete(houses, house);
  save_file();
  return 1;
}

/**
 * Remove a house from the list of houses
 *
 * @param house the basename of the house
 * @return 1 for success 0 for failure
 */
int remove_house( string house ) {
  if(!houses[house])
    return 0;
  
  map_delete( houses, house );
  return 1;
}

/**
 * Add secondary rooms to a house.
 *
 * @param house the basename of the house
 * @param an array of basenames for the rooms
 * @return 1 for success 0 for failure
 */
int add_rooms(string house, string *rooms) {
  if(!houses[house])
    return 0;

  houses[house]->other_rooms = uniq_array(houses[house]->other_rooms + rooms);
  save_file();
  return 1;
}

/**
 * Remove secondary rooms from a house.
 *
 * @param house the basename of the house
 * @param an array of basenames for the rooms
 * @return 1 for success 0 for failure
 */
int remove_rooms(string house, string *rooms) {
  if(!houses[house])
    return 0;

  houses[house]->other_rooms -= rooms;
  save_file();
  return 1;
}


/**
 * Set the owner of this house.
 *
 * @param house The basename of the house
 * @param owner The new owner of the house
 * @return 1 for success 0 for failure
 */
int set_owner(string house, string owner) {
  string room;
  
  if(!houses)
    return 0;
  if(!houses[house])
    return 0;
  if(!owner)
    return 0;
  
  // Inform the house and all its rooms that the owner has changed.
  owner = lower_case(owner);
  house->ownership_change(houses[house]->owner, owner);
  foreach(room in houses[house]->other_rooms)
    room->ownership_change(houses[house]->owner, owner);
  
  log_file("HOUSING", "%s Owner for %s set to %s from %s.\n",
           ctime(time())[4..15], house, owner, houses[house]->owner);
  houses[house]->owner = owner;
  save_file();
  return 1;
}

/**
 * Set the region of this house.
 *
 * @param house The basename of the house
 * @param region The new region of the house
 * @return 1 for success 0 for failure
 */
int set_region(string house, string region) {
  if(!houses) {
    return 0;
  }
  if(!houses[house]) {
    return 0;
  }
  if(!stringp(region)) {
    return 0;
  }
  
  // Inform the house and all its rooms that the owner has changed.
  houses[house]->region = region;
  save_file();
  log_file("HOUSING", "%s Region for %s set to %s\n",
           ctime(time())[4..15], house, region);
  return 1;
}

/**
 * Set the address of this house.
 *
 * @param house The basename of the house
 * @param address The new address of the house
 * @return 1 for success 0 for failure
 */
int set_address(string house, string address) {
  if(!houses) {
    return 0;
  }
  if(!houses[house]) {
    return 0;
  }
  if(!stringp(address)) {
    return 0;
  }
  
  // Inform the house and all its rooms that the owner has changed.
  houses[house]->address = address;
  save_file();
  log_file("HOUSING", "%s Address for %s set to %s\n",
           ctime(time())[4..15], house, address);
  return 1;
}

/**
 * Find out the current owner of this house.
 *
 * @param house The basename of the house
 * @return the owners name.
 */
string query_owner(string house) {
  string tmp;
  
  if(!houses)
    return 0;
  if(houses[house])
    return replace(houses[house]->owner, " (In Arrears)", "");

  foreach(tmp in keys(houses))
    if(member_array(house, houses[tmp]->other_rooms) != -1)
      return replace(houses[tmp]->owner, " (In Arrears)", "");
}

/**
 * Check if a given house is registered.
 *
 * @param house The basename of the house
 * @return 1 if its registered, 0 otherwise.
 */
int query_house(string house) {
  if(!houses)
    return 0;
  if(!houses[house])
    return 0;
  return 1;
}

/**
 * Set the bank account to be used for rent on this house.
 *
 * @param house The basename of the house
 * @param owner The new bank to use
 * @return 1 for success 0 for failure
 */
int set_bank(string house, string bank) {
  if(!houses)
    return 0;
  if(!houses[house])
    return 0;
  if(!bank)
    return 0;
  if(((class housing)houses[house])->type != RENT)
    return 0;
  houses[house]->bank = bank;
  save_file();
  return 1;
}

/**
 * Return which bank account rent will be removed from for a house.
 *
 * @param house The basename of the house
 * @return the bank name.
 */
string query_bank(string house) {
  if(!houses)
    return 0;
  if(!houses[house])
    return 0;
  return houses[house]->bank;
}

/**
 * Get a list of the houses rooms.
 *
 * @param house The basename of the house
 * @return a list of rooms.
 */
string *query_rooms(string house) {
  string *tmp;
  
  if(!houses)
    return 0;
  if(!houses[house])
    return 0;

  if(sizeof(houses[house]->other_rooms)) {
    tmp = houses[house]->other_rooms;
    tmp += ({ house });
  } else
    tmp = ({ house });
  
  return tmp;
}

/**
 * Find out the address of a house.
 *
 * @param house The basename of the house
 * @return the address.
 */
string query_address(string house) {
  if(!houses)
    return 0;
  if(!houses[house])
    return 0;

  return houses[house]->address;
}

/**
 * Find out the region a house is in for sale/rental purposes.
 *
 * @param house The basename of the house
 * @return the region.
 */
string query_region(string house) {
  if(!houses)
    return 0;
  if(!houses[house])
    return 0;

  return houses[house]->region;
}
/**
 * Set the type of a house. ie. Whether it's rented or owned.
 * (1 for rented, 0 for owned).
 *
 * @param house The basename of the house
 * @return the type.
 */
int set_type(string house, int type) {
  if(!houses)
    return 0;
  if(!houses[house])
    return 0;
  if(type < 0 || type > 1)
    return 0;

  ((class housing)houses[house])->type = type;
  save_file();

  return 1;
}

/**
 * Find out the type of a house. ie. Whether it's rented or owned.
 *
 * @param house The basename of the house
 * @return the type.
 */
int query_type(string house) {
  if(!houses)
    return -1;
  if(!houses[house])
    return -1;

  return ((class housing)houses[house])->type;
}

/**
 * Find out the current value of a house.
 *
 * @param house The basename of the house
 * @return the value.
 */
int query_value(string house) {
  if(!houses)
    return 0;
  if(!houses[house])
    return 0;

  return houses[house]->value;
}

/**
 * Function to get a list of houses that are vacant in a given region.
 * This function is used by the auction system or other sales mechanism.
 *
 * @param region Region to list houses in
 * @return a list of houses.
 */
string *query_vacant(string region) {
  string house, *sale_list;

  sale_list = ({ });
  foreach(house in keys(houses)) {
    if(stringp(houses[house]->owner)) {
      if (lower_case(houses[house]->owner) == "for sale" &&
          houses[house]->region == region) {
        sale_list += ({ house });
      }
    } else {
      debug_printf("Bad owner for house %O\n", house);
    }
  }

  return sale_list;
}

/**
 * Mark a house as being For Sale this puts it in the list of possible
 * houses to go into the vacant list.
 *
 * @param house the basename of the house
 * @return 1 for success 0 for failure
 */
int set_for_sale(string house) {
  if(!houses || !houses[house])
    return 0;

  log_file("HOUSING", "%s %s set to For Sale from %s\n",
           ctime(time())[4..15], house, houses[house]->owner);
  
  houses[house]->owner = "For Sale";
  houses[house]->bank = DEFAULT_BANK;
  save_file();
  return 1;
}

/**
 * Mark a house as being Under Offer (to prevent anyone else trying to sell
 * it too.
 *
 * @param house the basename of the house
 * @return 1 for success 0 for failure
 */
int set_under_offer(string house) {
  if(!houses || !houses[house])
    return 0;

  log_file("HOUSING", "%s %s set to Under Offer from %s\n",
           ctime(time())[4..15], house, houses[house]->owner);
  
  houses[house]->owner = "Under Offer";
  houses[house]->value = 0; // So the old rent isn't visible anymore.
  save_file();
  return 1;
}

/**
 * Mark a house as being in arrears.  This is the step just prior to being
 * repossessed.
 *
 * @param house the basename of the house
 * @return 1 for success 0 for failure
 */
int set_in_arrears(string house) {
  if(!houses || !houses[house])
    return 0;

  log_file("HOUSING", "%s %s set to In Arrears from %s\n",
           ctime(time())[4..15], house, houses[house]->owner);
  
  houses[house]->owner = houses[house]->owner + " (In Arrears)";
  save_file();
  return 1;
}

/**
 * Set the value of a particular house.
 *
 * @param house the basename of the house
 * @param value the value in monetary units.
 * @return 1 for success 0 for failure
 */
int set_value(string house, int value) {
  if(!houses || !houses[house])
    return 0;

  houses[house]->value = value;
  save_file();
  return 1;
}
/**
 * @ignore yes
 * This function is called by the refresh handler when a player refreshes
 * or deletes.
 */
int player_refreshed(mixed name, int refresh_type) {
  class housing house;
  string hname;
  
  if(objectp(name))
    name = name->query_name();

  foreach(hname, house in houses)
    if(house->owner == name) {
      log_file("HOUSING", "%s %s refreshed or deleted.\n", ctime(time())[4..15],
               house->owner);
      set_for_sale(hname);
    }
  
  return 1;
}

/**
 * This method sets a mapping between a housing area and the citizenship
 * required to hold a house there.
 * @param area the housing area to link
 * @param citizenship the citizenship the housing area needs
 */
void set_housing_area_citizenship(string area, string citizenship) {
   _housing_area[area] = citizenship;
   save_file();
}

/**
 * This method removes the mapping between a housing area and it's citizenship
 * requirements.
 * @param area the housing area to remove the link from
 */
void remove_housing_area_citizenship(string area) {
   map_delete(_housing_area, area);
   save_file();
}

/**
 * This method returns the current mappings between the housing area and the
 * required citizenship.
 * @param area the area to check
 * @return the citizenship required, 0 if none
 */
string query_housing_area_citizenship(string area) {
   return _housing_area[area];
}

/**
 * This method returns all of the current mappings between the housing
 * area and the citizenship.  This shouuld not be used for anything
 * except debugging.
 * @return all the housing area stuff
 */
mapping query_all_housing_area_citizenships() {
   return copy(_housing_area);
}

void set_housing_area_money( string area, string bank, string place ) {

    if( !_area_money[area] ) {
        _area_money[area] = ([ ]);
    }
    if( bank ) {
        _area_money[area]["bank"] = bank;
    }
    if( place ) {
        _area_money[area]["place"] = place;
    }
    save_file();
    
} /* set_housing_area_money() */

/**
 * This method returns the current mappings between the housing area and the
 * initial bank to use.
 * @param area the area to check
 * @return the initial bank used, DEFAULT_BANK if none set
 */
string query_housing_area_bank(string area) {
    if( _area_money[area] && _area_money[area]["bank"] ) {
        return _area_money[area]["bank"];
    }
    else {
        return DEFAULT_BANK;
    }
} /* query_housing_area_bank() */

/**
 * This method returns the current mappings between the housing area and the
 * money area ("Ankh-Morpork", "Counterweight Continent", etc) to use.
 * @param area the area to check
 * @return the money area used, DEFAULT_PLACE if none set
 */
string query_housing_area_place(string area) {
    if( _area_money[area] && _area_money[area]["place"] ) {
        return _area_money[area]["place"];
    }
    else {
        return DEFAULT_PLACE;
    }
} /* query_housing_area_place() */



/** @ignore yes
 * This function goes through the houses and checks that the owners
 * are still active.
 */
void check_owners(int i) {
  class housing tmp;
  
  if(!_tmp_houses)
    _tmp_houses = keys(houses);

  if(i == sizeof(_tmp_houses))
    return;

  tmp = houses[_tmp_houses[i]];

  if(!tmp->owner ||
     lower_case(tmp->owner) == "for sale" ||
     lower_case(tmp->owner) == "under offer" ||
     strsrch(lower_case(tmp->owner), "(in arrears)") != -1) {
    call_out("check_owners", 1, ++i);
    return;
  }
 
  if(!PLAYER_HANDLER->test_user(lower_case(tmp->owner))) {
    log_file("HOUSING", "%s %s doesn't exist.\n", ctime(time())[4..15],
             tmp->owner);
    set_for_sale(_tmp_houses[i]);
  } else if(!PLAYER_HANDLER->test_creator(tmp->owner)) {
    switch(tmp->type) {
    case SALE:
      if(PLAYER_HANDLER->test_last(tmp->owner) < time() - OWNER_TIMEOUT) {
        log_file("HOUSING", "%s %s is idle last login %s ago [%s].\n",
                 ctime(time())[4..15], tmp->owner,
                 ctime_elapsed(time() - PLAYER_HANDLER->test_last(tmp->owner)),
                 _tmp_houses[i]);
        set_for_sale(_tmp_houses[i]);
      }
      break;
    case RENT:
      if(PLAYER_HANDLER->test_last(tmp->owner) < time() - RENTER_TIMEOUT) {
        log_file("HOUSING", "%s %s is idle last login %s [%s].\n",
                 ctime(time())[4..15], tmp->owner,
                 ctime_elapsed(time() - PLAYER_HANDLER->test_last(tmp->owner)),
                 _tmp_houses[i]);
        set_for_sale(_tmp_houses[i]);
      }
      if (_housing_area[tmp->region] &&
          !NOMIC_HANDLER->is_citizen_of(_housing_area[tmp->region],
                                        tmp->owner)) {
        log_file("HOUSING", "Property %s has an owner %s, who is not "
                 "a citizen of %s [rent %d].\n", _tmp_rentals[i],
                 tmp->owner, _housing_area[tmp->region], tmp->value);
        MAIL_HANDLER->do_mail_message(tmp->owner,
                                      "Housing Rental Office",
                                      "Reposession", "",
                                      "Due to not being a citizen of " +
                                      _housing_area[tmp->region] +
                                      " when your rent was due, your property "
                                      "at " +tmp->address + " has been "
                                      "reposessed and put up for sale.\n\n"
                                      "The rental office.\n");
        set_for_sale(_tmp_rentals[i]);
      }
      break;
    }
  }
  call_out("check_owners", 1, ++i);
}

/** @ignore yes
 *
 * Charge people rent if appropriate.
 */
void check_rent() {
  int *now, daysleft;

  now = AM_TIME_HANDLER->query_am_time_array(time());

  // Check we haven't charged rent this month and charge it.
  if(now[AM_TIME_MONTH] != last_paid) {
    log_file("HOUSING", "Processing rent for " +
             AM_TIME_HANDLER->query_month(now[AM_TIME_MONTH]) + "\n");
    call_out("charge_rent", 0);
    last_paid = now[AM_TIME_MONTH];
    save_file();
  }

  daysleft = AM_TIME_HANDLER->query_days_per_month()[now[AM_TIME_MONTH]-1] -
    now[AM_TIME_DAY_OF_MONTH];
  call_out("check_rent", (daysleft * AM_SECONDS_PER_DAY) + 1);
}


/** @ignore yes
 *
 * This function goes through the houses and checks that the owners
 * are still active.
 */
void charge_rent(int i) {
  class housing tmp;
  string owner;
  
  if(!_tmp_rentals)
    _tmp_rentals = keys(houses);
  
  if(i >= sizeof(_tmp_rentals))
    return;
  
  tmp = houses[_tmp_rentals[i]];
  // Find the next rental house in the list that has an owner
  while(i < sizeof(_tmp_rentals) &&
        (tmp->type != RENT || !tmp->owner ||
         lower_case(tmp->owner) == "for sale" ||
         lower_case(tmp->owner) == "under offer")) {
    
    if(++i < sizeof(_tmp_rentals))
      tmp = houses[_tmp_rentals[i]];
  }
  
  if(i >= sizeof(_tmp_rentals)) {
    return;
  }

  call_out("charge_rent", 1, (i+1));

  // Sanity check in case they have no bank
  if(!tmp->bank) {
    set_bank( _tmp_rentals[i], query_housing_area_bank( tmp->region ) );
    log_file("HOUSING", "Property %s had no bank, setting it to %s.\n", 
             _tmp_rentals[i], tmp->bank);  
  }
  
  if(!tmp->value) {
    log_file("HOUSING", "Property %s has a rent of zero.\n",
             _tmp_rentals[i]);
  } else if(strsrch(tmp->owner, "(In Arrears)") != -1) {
    // This owner is in arrears on their payments.
    owner = replace(tmp->owner, " (In Arrears)", "");
    if(BANK->query_account(owner, tmp->bank) < tmp->value * 3) {
      // They don't have the requisite 3 months rent so the property
      // is repossessed.
      log_file("HOUSING", "%s %s failed to pay %d (%d) for %s [%s] "
               "property repossessed.\n",
               ctime(time())[4..15], owner, tmp->value * 3, 
               BANK->query_account(owner, tmp->bank), _tmp_rentals[i],
               tmp->bank);
      MAIL_HANDLER->do_mail_message(owner,
                                    "Housing Rental Office",
                                    "Reposession", "",
                                    "Due to insufficient funds in your "
                                    "account at " + tmp->bank + " bank your "
                                    "property\n"
                                    "at " +tmp->address + " has been "
                                    "reposessed.\n\n"
                                    "The rental office.\n");
      // Take what we can to cover outstanding rent.
      BANK->adjust_account(owner, tmp->bank,
                           -(BANK->query_account(owner, tmp->bank)));
      set_for_sale(_tmp_rentals[i]);
    } else {
      // Have them pay last months rent, a months late fee and this 
      // month's rent and then return the house to normal ownership.
      BANK->adjust_account(owner, tmp->bank, - (tmp->value * 3));
      log_file("HOUSING", "%s %s paid arrears of %d for %s [%s]\n",
               ctime(time())[4..15], tmp->owner, tmp->value * 3, 
               BANK->query_account(owner, tmp->bank), _tmp_rentals[i],
               tmp->bank);
      set_owner(_tmp_rentals[i], owner);
    }
  } else if(BANK->query_account(tmp->owner, tmp->bank) < tmp->value) {
    log_file("HOUSING", "%s %s failed to pay %d (%d) for %s [%s] "
             "property set in arrears.\n", ctime(time())[4..15], tmp->owner,
             tmp->value, BANK->query_account(tmp->owner, tmp->bank),
             _tmp_rentals[i], tmp->bank);
    MAIL_HANDLER->do_mail_message(tmp->owner,
                                  "Housing Rental Office",
                                  "In Arrears", "",
                                  "Due to insufficient funds in your account "
                                  "at " + tmp->bank + " bank your property\n"
                                  "at " +tmp->address + " is now in arrears."
                                  "\n\n"
                                  "Next month you will be charged three times "
                                  "the normal rent (this months rent, a one "
                                  "month late fee and next months rent).\n\n"
                                  "Failure to pay will result in repossession "
                                  "of your property.\n\n"
                                  "The rental office.\n");
    set_in_arrears(_tmp_rentals[i]);
  } else {
    BANK->adjust_account(tmp->owner, tmp->bank, -tmp->value);
    log_file("HOUSING", "%s %d rental paid by %s for %s\n",
             ctime(time())[4..15], tmp->value, tmp->owner, _tmp_rentals[i]);
  }
  
  if(tmp->owner != "For Sale" &&
     BANK->query_account(tmp->owner, tmp->bank) < (tmp->value * 3)) {
    
    MAIL_HANDLER->do_mail_message(tmp->owner,
                                  "Housing Rental Office",
                                  "Shortage of funds", "",
                                  "Your bank account currently has funds for "
                                  "less than three months rent.\n\n"
                                  "The rental office.\n");
  }
  
  debug_printf("Doing callout %d.", (i+1));
}

/** @ignore yes
 * Get a list of all the houses that exist. This is just a debug function.
 * @return a mapping of all the houses.
 */
mapping query_houses() {
  return copy(houses);
}

/** @ignore yes */
mixed stats() {
  return ({
    ({ "total houses", sizeof(keys(houses)) }),
      ({ "paid for" , AM_TIME_HANDLER->query_month(last_paid) }),
      });
}
// --- END [/mnt/home2/grok/lib/obj/handlers/housing.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/world_map.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/world_map.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628424   Available: 13575778
Inodes: Total: 5242880    Free: 4960134
14174 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/world_map.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628424   Available: 13575778
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is the handler to help control the world map.  It co-ordinates
 * all the terrains connecting themselves together.  All terrains are
 * rectangular.
 * @author Pinkfish
 * @started Fri Mar 22 16:58:35 PST 2002
 */
#include <terrain_map.h>
class region {
   mixed* terrains;
   string* features;
   int last_touched;
}

#define SAVE_DIR "/save/world_map/"

#define BOUNDARY TERRAIN_MAP_WORLD_BOUNDARY 
#define REGION_SIZE TERRAIN_MAP_WORLD_REGION_SIZE
#define REGION_BOUNDARY TERRAIN_MAP_WORLD_REGION_BOUNDARY
#define OFFSET TERRAIN_MAP_WORLD_OFFSET

#define REGION_WIDTH TERRAIN_MAP_WORLD_REGION_WIDTH

void load_me();
private void generate_main_templates();
private void generate_blocking_templates();

// Array of array of regions
private nosave mixed* _regions;
//private string* _features;
private nosave mixed* _templates;
private nosave mixed* _blocking_templates;

void create() {
   // Make a 10 x 10 grid.
   _regions = allocate(REGION_WIDTH, (: allocate(REGION_WIDTH) :));
   //_features = ({ });
   seteuid(getuid());
   generate_main_templates();
   generate_blocking_templates();
   //load_me();
}

private void generate_main_templates() {
   int size;
   mixed* last;
   int x;
   int y;
   int u;
   int v;
   int e;
   int i;

   _templates = allocate(12);

   last = ({ ({ 1 }) });
   for (size = 0; size < sizeof(_templates); size++) {
      for (i = 0; i < sizeof(last); i++) {
         last[i] = ({ 0 }) + last[i] + ({ 0 });
      }
      _templates[size] = ({ allocate((size + 1) * 2 + 1) }) + last +
                         ({ allocate((size + 1) * 2 + 1) });
      // Draw a circle of the right size.
      x = 0;
      y = size + 1;
      u = 1;
      v = 2 * (size + 1) - 1;
      e = 0;

      while (x <= y) {
         _templates[size][size + 1 + x][size + 1 + y] = 1;
         _templates[size][size + 1 + x][size + 1 - y] = 1;
         _templates[size][size + 1 - x][size + 1 + y] = 1;
         _templates[size][size + 1 - x][size + 1 - y] = 1;
         _templates[size][size + 1 + y][size + 1 + x] = 1;
         _templates[size][size + 1 + y][size + 1 - x] = 1;
         _templates[size][size + 1 - y][size + 1 + x] = 1;
         _templates[size][size + 1 - y][size + 1 - x] = 1;

         if (size > 0) {
            _templates[size][size + 1 + x - 1][size + 1 + y] = 1;
            _templates[size][size + 1 + x - 1][size + 1 - y] = 1;
            _templates[size][size + 1 - x + 1][size + 1 + y] = 1;
            _templates[size][size + 1 - x + 1][size + 1 - y] = 1;
            _templates[size][size + 1 + y - 1][size + 1 + x] = 1;
            _templates[size][size + 1 + y - 1][size + 1 - x] = 1;
            _templates[size][size + 1 - y + 1][size + 1 + x] = 1;
            _templates[size][size + 1 - y + 1][size + 1 - x] = 1;
         }
         x++;
         e += u;
         u += 2;
         if (v < 2 * e) {
            y--;
            e -= v;
            v -= 2;
         }
         if (x > y) {
            break;
         }
      }
      last = copy(_templates[size]);
   }
}

mixed* generate_blocking(int x, int y, string* start,
                          string* straight, string* diagonal) {
   int i;
   int dx;
   int ex;
   int dy;
   int balance;
   int sx;
   int sy;
   int blocked;
   int blocked_straight;
   int blocked_diagonal;
   int first_block;

   first_block = -1;
   for (i = 0; i <= sizeof(start); i++) {
      // Generate a line from 0,0 to 0,i
      sx = 0;
      sy = 0;
      ex = sizeof(start);
      dx = sizeof(start);
      dy = i;
      dy <<= 1;
      balance = dy - dx;
      dx <<= 1;
      blocked_straight = blocked_diagonal = blocked = 0;
      while (sx != ex) {
         if (blocked) {
            if (first_block == -1) {
               first_block = i;
            }
            start[sy] = start[sy][0..sx-1] + "*" + start[sy][sx+1..];
         } else {
            start[sy] = start[sy][0..sx-1] + " " + start[sy][sx+1..];
         }
         if (blocked_straight) {
            straight[sy] = straight[sy][0..sx-1] + "*" + straight[sy][sx+1..];
         } else {
            straight[sy] = straight[sy][0..sx-1] + " " + straight[sy][sx+1..];
         }
         if (blocked_diagonal) {
            diagonal[sy] = diagonal[sy][0..sx-1] + "*" + diagonal[sy][sx+1..];
         } else {
            diagonal[sy] = diagonal[sy][0..sx-1] + " " + diagonal[sy][sx+1..];
         }
         if (sx == x && sy == y) {
            blocked_diagonal = blocked_straight = blocked = 1;
            diagonal[sy] = diagonal[sy][0..sx-1] + "@" + diagonal[sy][sx+1..];
            start[sy] = start[sy][0..sx-1] + "@" + start[sy][sx+1..];
            straight[sy] = straight[sy][0..sx-1] + "@" + straight[sy][sx+1..];
         }
         if (sx == x && sy == y + 1) {
            blocked_straight = 1;
            straight[sy] = straight[sy][0..sx-1] + "|" + straight[sy][sx+1..];
         }
         if (sx == x + 1 && sy == y + 1) {
            blocked_diagonal = 1;
            diagonal[sy] = diagonal[sy][0..sx-1] + "\\" + diagonal[sy][sx+1..];
         }
         if (balance >= 0) {
            sy++;
            balance -= dx;
         }
         balance += dy;
         sx++;
      }
   }
   // Need to redo back in the other direction to remove extra unneeded blocking
   // bits.
   if (first_block >= (sizeof(start) / 2)) {
      for (i = sizeof(start); i >= 6; i--) {
         // Generate a line from 0,0 to 0,i
         sx = 0;
         sy = 0;
         ex = sizeof(start);
         dx = sizeof(start);
         dy = i;
         dy <<= 1;
         balance = dy - dx;
         dx <<= 1;
         blocked = 0;
         while (sx != ex) {
            start[sy] = start[sy][0..sx-1] + " " + start[sy][sx+1..];
            if (sx == x && sy == y) {
               break;
            }
            if (balance >= 0) {
               sy++;
               balance -= dx;
            }
            balance += dy;
            sx++;
         }
      }
   }
   return ({ start, straight, diagonal });
}

private void generate_blocking_templates() {
   int x;
   int y;
   int size;
   mixed* basic;
   string* start;
   string line;

   basic = _templates[<1];
   size = sizeof(_templates);
   // Chop it into just a quarter.
   line = "";
   for (x = 0; x < size + 1; x++) {
      line += " ";
   }
   start = allocate(size + 1, line);
   _blocking_templates = allocate(size + 1, ({ }));
   for (x = 0; x < size + 1; x++) {
      _blocking_templates[x] = allocate(size + 1);
   }
   // We only need to generate for one octant.
   // That is from the straight line to the x == y line.
   for (x = 0; x < size + 1; x++) {
      for (y = x; y < size + 1; y++) {
         // Only if it is in the circle.
         if (basic[x + size][y + size] && (x != 0 || y != 0)) {
            // Generate the template for here.
            _blocking_templates[x][y] = generate_blocking(y, x, copy(start), copy(start), copy(start));
         }
      }
   }
}

/**
 * Find the template to use for the area blocked by an obstacle.
 * This will do nifty template fitting stuff for obstacles.
 * @param x the x co-ordinate of the blockage
 * @param y the y co-ordinate of the blockage
 * @param type the type is 0 for normal, 1 for straight, 2 for diagonal
 */
string *query_blocking_template(int x, int y, int type) {
   if (arrayp(_blocking_templates[x][y])) {
      return copy(_blocking_templates[x][y][type]);
   }
   return 0;
}

/**
 * This method returns the template for the specific size of the
 * map.  This is for visibility considerations.
 * @param size the size of the template
 * @return the template
 */
mixed* query_map_template(int size) {
   return copy(_templates[size - 1]);
}

/** @ignore yes */
void load_region(int x, int y) {
   class region region;
   string fname;

   if (_regions[x][y]) {
      _regions[x][y]->last_touched = time();
      return ;
   }
   fname = SAVE_DIR + "region_" + x + "_" + y;
   if (unguarded((: file_size($(fname)) :)) > 0) {
      region = unguarded( (: restore_variable(read_file($(fname), 1)) :));
   } else {
      region = new(class region,
                   terrains : allocate(REGION_SIZE, (: allocate(REGION_SIZE) :)),
                   features : ({ }));
   }
   _regions[x][y] = region;
   _regions[x][y]->last_touched = time();
}

/** @ignore yes */
void save_region(int x, int y) {
   string fname;
   class region region;

   if (_regions[x][y]) {
      region = _regions[x][y];
      fname = SAVE_DIR + "region_" + x + "_" + y;
      unguarded( (: write_file($(fname), save_variable($(region)), 1) :));
   }
}

/**
 * This method adds the specified terrain to the world map.
 */
int add_terrain(string path, int x1, int y1, int x2, int y2) {
   int tmp;
   int region_x;
   int region_y;

   if (x1 > x2) {
      tmp = x1;
      x1 = x2;
      x2 = tmp;
   }
   if (y1 > y2) {
      tmp = y1;
      y1 = y2;
      y2 = tmp;
   }

   if (x2 - x1 != BOUNDARY ||
       y2 - y1 != BOUNDARY) {
      // Not the correct size.
      debug_printf("Incorrect terrain size (%d x %d): %s\n",
                  x2 - x1, y2 - y1, path);
      return 0;
   }

   if (x1 % BOUNDARY ||
       y1 % BOUNDARY) {
      // Not  on a correct boundary.
      debug_printf("Incorrect boundary (%d - %d): %s\n",
                  x1 % BOUNDARY, y1 % BOUNDARY, path);
      return 0;
   }

   x1 = ((x1 + OFFSET) / BOUNDARY);
   y1 = ((y1 + OFFSET) / BOUNDARY);
   region_x = x1 / REGION_SIZE;
   region_y = y1 / REGION_SIZE;

   load_region(region_x, region_y);
   x2 = x1 % REGION_SIZE;
   y2 = y1 % REGION_SIZE;
   _regions[region_x][region_y]->terrains[x2][y2] = path;
   save_region(region_x, region_y);
   debug_printf("Added terrain (%d {%d}, %d {%d}) [%d,  %d]: %s\n",
                 x1, x2, y1, y2, region_x, region_y, path);
   return 1;
} /* add_terrain() */

/**
 * This method finds the terrain at the specific location.
 * @param x the x co-ordinate
 * @param y the y co-ordinate
 * @return the path to the terrain
 */
string find_terrain_at(int x, int y) {
   int region_x;
   int region_y;

   x = ((x + OFFSET) / BOUNDARY);
   y = ((y + OFFSET) / BOUNDARY);
   region_x = x / REGION_SIZE;
   region_y = y / REGION_SIZE;
   //debug_printf("Finding terrain (%d, %d) [%d,  %d]\n",
   //              x, y, region_x, region_y);
   load_region(region_x, region_y);
   return _regions[region_x][region_y]->terrains[x % REGION_SIZE][y % REGION_SIZE];
}

/**
 * This method finds the specific room at the specific location
 * @param x the x co-ordinate
 * @param y the y co-ordinate
 * @return the path to the room
 */
string find_room_at(int x, int y) {
   string path;

   path = find_terrain_at(x, y);
   if (path) {
      return path->find_room_at_real_coord(x, y);
   }
   return 0;
}

/**
 * This method adds a feature into the world map.
 * @param feature the feature to add
 */
void add_feature(string feature) {
   int x;
   int y;

   //_features += ({ feature });
   // Go through the regionsand figure out which ones this feature is in.
   for (x = 0; x < REGION_WIDTH; x++) {
      for (y = 0; y < REGION_WIDTH; y++) {
         if (feature->is_inside_region(
                                (x * REGION_WIDTH) * BOUNDARY - OFFSET,
                                (y * REGION_WIDTH) * BOUNDARY - OFFSET,
                                ((x + 1) * REGION_WIDTH) * BOUNDARY - OFFSET,
                                ((y + 1) * REGION_WIDTH) * BOUNDARY - OFFSET)) {
            load_region(x, y);
            _regions[x][y]->features |= ({ feature });
            save_region(x, y);
            debug_printf("Added feature to region %d, %d\n", x, y);
         }
      }
   }
}

/**
 * This method removes a feature from the world map.
 * @param feature the feature to remove
 */
void remove_feature(string feature) {
   int x;
   int y;

   for (x = 0; x < REGION_WIDTH; x++) {
      for (y = 0; y < REGION_WIDTH; y++) {
         load_region(x, y);
         if (member_array(feature, _regions[x][y]->features) != -1) {
            _regions[x][y]->features -= ({ feature });
            save_region(x, y);
         }
      }
   }
}

/**
 * This method returns the list of all the features available at the
 * specific location.
 * @param x the x position
 * @param y the y position
 * @return the features at the location
 */
string* query_features_at(int x, int y) {
   int region_x;
   int region_y;

   x = ((x + OFFSET) / BOUNDARY);
   y = ((y + OFFSET) / BOUNDARY);
   region_x = x / REGION_WIDTH;
   region_y = y / REGION_WIDTH;
   load_region(region_x, region_y);
   return _regions[region_x][region_y]->features;
}

/**
 * This method finds all the features inside the specified region.  This
 * is quite expensive in terms of evaluation cost, so do not try and call
 * this too much.  Cache the results if possible.
 * @param x1 the top x location
 * @param y1 the top y location
 * @param x2 the bottom x location
 * @param y2 the bottom y location
 * @return the features in the region
 */
string* query_features_in_region(int x1_orig, int y1_orig, int x2_orig, int y2_orig) {
   int region_x;
   int region_y;
   int x1;
   int y1;
   int x2;
   int y2;
   int tmp;
   string* features;
   string feat;

   x1 = ((x1_orig + OFFSET) / BOUNDARY) / REGION_WIDTH;
   y1 = ((y1_orig + OFFSET) / BOUNDARY) / REGION_WIDTH;
   x2 = ((x2_orig + OFFSET) / BOUNDARY) / REGION_WIDTH;
   y2 = ((y2_orig + OFFSET) / BOUNDARY) / REGION_WIDTH;

   if (x1 > x2) {
      tmp = x1;
      x1 = x2;
      x2 = tmp;
   }
   if (y1 > y2) {
      tmp = y1;
      y1 = y2;
      y2 = tmp;
   }
   features = ({ });

   if (x1 < 0) {
      x1 = 0;
   }
   if (y1 < 0) {
      y1 = 0;
   }
   if (x2 >= REGION_WIDTH) {
      x2 = REGION_WIDTH - 1;
   }
   if (y2 >= REGION_WIDTH) {
      y2 = REGION_WIDTH - 1;
   }

   // Now we loop through the possible regions.
   for (region_x = x1; region_x <= x2; region_x++) {
      for (region_y = y1; region_y <= y2; region_y++) {
         load_region(region_x, region_y);
         foreach (feat in _regions[region_x][region_y]->features) {
            if (feat->is_inside_region(x1_orig, y1_orig, x2_orig, y2_orig)) {
               features |= ({ feat });
            }
         }
      }
   }
   return features;
}
// --- END [/mnt/home2/grok/lib/obj/handlers/world_map.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/attack_messages.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/attack_messages.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628420   Available: 13575774
Inodes: Total: 5242880    Free: 4960134
12961 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/attack_messages.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628420   Available: 13575774
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This handles the standard messages for attacks.  I cannot be bothered
 * rewriting the docs for this.
 * This handles the standard messages for the given damage types:
 *    blunt, sharp, pierce, fire.
 *
 *  There are also subtypes:
 *    blunt - hands, feet, tail, hoof, wrestle, pommel.
 *    sharp - claws, chew, slice, chop.
 *    pierce - bite, beak, stab, horns, tusks.
 * @author pinkfish
 */

mapping weapon_mess;

/** @ignore */
void create() {
  weapon_mess = ([
    "blunt" : ({
      0, "$N swing$s at $I with $D",
        20, "$N tap$s $I in the $z with $D",
        60, "$N hit$s $I in the $z with $D",
        100, "$N bruise$s $P $z with $D",
        140, "$N hit$s $I hard in the $z with $D",
        180, "$N smash$es $I in the $z with $D",
        220, "$N crush$es $P $z with $D",
        5000, "$N mash$es $P $z with $D",
        }),
    "blunt-tail" : ({
      0, "$N swing$s $p tail at $I",
        20, "$N tap$s $I in the $z with $p tail",
        60, "$N slap$s $I in the $z with $p tail",
        100, "$N bruise$s $P $z with $p tail",
        140, "$N hit$s $I hard in the $z with $p tail",
        180, "$N bash$es $I in the $z with $p tail",
        220, "$N smash$es $p tail into $P $z",
        5000, "$N send$s $I reeling with a powerful blow to the $z with $p tail"
        }),
    "blunt-hoof" : ({
      0, "$N kick$s out at $I",
        20, "$N tap$s $I in the $z with $p hoof",
        60, "$N kick$s $I in the $z with $p hoof",
        100, "$N bruise$s $P $z with $p hoof",
        140, "$N hit$s $I hard in the $z with $p hoof",
        180, "$N smash$es $I in the $z with $p hoof",
        220, "$N crush$es $p hoof into $P $z",
        5000, "$N mash$es $P $z with $p hoof"
        }),
    "blunt-wrestle" : ({
      0, "$N grab$s for $I",
        25, "$N grapple$s with $I",
        50, "$N catch$es $I in an arm lock",
        75, "$N grab$s $I around the neck",
        100, "$N poke$s $I in the face",
        125, "$N throw$s $I to the ground",
        150, "$N fling$s $I over $p shoulder",
        175, "$N punch$es $I in the stomach",
        200, "$N twist$s $P arm painfully",
        225, "$N thump$s $P head hard",
        250, "$N kick$s $I in the back",
        275, "$N jump$s up and down on $I",
        5000, "$N slam$s $P head against the ground"
        }),
    "blunt-hands" : ({
      0, "$N punch$es at $I",
        10, "$N poke$s $I in the $z",
        40,"$N tickle$s $I in the $z",
        70, "$N jab$s $I in the $z",
        100, "$N hit$s $I in the $z with an uppercut",
        130, "$N hit$s $I in the $z with a cross",
        160, "$N hit$s $I in the $z with a vicious hook",
        5000, "$N beat$s $P $z to a pulp",
        }),
    "blunt-feet" : ({
      0, "$N kick$s out at $I",
        10, "$N poke$s $I",
        40, "$N tickle$s $I in the $z with $p toes",
        70, "$N kick$s $I in the $z",
        100, "$N viciously boot$s $I in the $z",
        130, "$N kick$s $I in the $z",
        160, "$N viciously kick$s $I in the $z",
        5000, "$N kick$s $P $z into a bloody mess"
        }),
    "blunt-pommel": ({
      0, "$N strike$s at $I with the pommel of $D",
        20, "$N tap$s $I in the $z with the pommel of $D",
        60, "$N knock$s $P $z with the hilt of $D",
        100, "$N bruise$s $P $z with the pommel of $D",
        140, "$N bash$es $I in the $z with the hilt of $D",
        180, "$N beat$s $I in the $z with the pommel of $D",
        220, "$N smash$es the hilt of $D into $P $z",
        5000, "$N smash$es $I in the $z with the pommel of $D",
        }),
    "blunt-cane" : ({
      0, "$N strike$s at $I with $D",
        20, "$N tap$s $P $z with $D",
        60, "$N knock$s $P $z with $D",
        100, "$N strike$s $I lightly in the $z with $D",
        140, "$N strike$s $I in the $z with $D",
        180, "$N strike$s $I hard in the $z with $D",
        220, "$N batter$s $P $z with $D",
        5000, "$N bludgeon$s $P $z with $D",
        }),
    "blunt-self" : ({
      0, "$N swing$s at $I",
        20, "$N tap$s $I in the $z",
        60, "$N hit$s $I in the $z",
        100, "$N bruise$s $P $z",
        140, "$N hit$s $I hard in the $z",
        180, "$N smash$es $I in the $z",
        220, "$N crush$es $P $z",
        5000, "$N mash$es $P $z",
        }),
    "sharp" : ({
      0, "$N slash$es at $I with $D",
        20, "$N snick$s $P $z with $D",
        60, "$N scratch$es $P $z with $D",
        100, "$N nick$s $P $z with $D",
        140, "$N cut$s $P $z with $D",
        180, "$N slice$s $P $z with $D",
        220, "$N hack$s $P $z with $D",
        5000, "$N chop$s up $P $z with $D"
        }),
    "sharp-claws" : ({
      0, "$N rake$s at $I with $p claws",
        10, "$N snick$s $P $z with $p claws",
        40, "$N scratch$es $P $z with $p claws",
        70, "$N nick$s $P $z with $p claws",
        100, "$N claw$s $P $z",
        130, "$N slice$s $P $z up with $p claws",
        160, "$N hack$s $P $z up with $p claws",
        5000, "$N cut$s $P $z into small pieces with $p claws",
        }),
    "sharp-chew" : ({
      0, "$N bite$s at $I",
        10, "$N chew$s on $P $z",
        40, "$N munch$es on $P $z",
        70, "$N gash$es $P $z with $p teeth",
        100, "$N rip$s flesh off $P $z",
        130, "$N tear$s deeply into $P $z",
        160, "$N rip$s $P $z to pieces with $p teeth",
        5000,  "$N rend$s huge chunks of flesh from $P $z",
        }),
    "sharp-slice": ({
      0, "$N slice$s at $I with $D",
        20, "$N just manage$s to slice $P $z with $D",
        60, "$N slice$s $D across $P $z",
        100, "$N shred$s $P $z with $D",
        140, "$N slice$s $D into $P $z",
        180, "$N take$s a sliver off $P $z with $D",
        220, "$N slice$s $D deeply into $P $z",
        5000, "$N neatly fillet$s $P $z with $D",
        }),
    "sharp-chop": ({
      0, "$N swing$s $D at $I",
        20, "$N attempt$s to chop $P $z with $D",
        60, "$N chop$s at $P $z with $D",
        100, "$N chop$s $P $z with $D",
        140, "$N chop$s $D into $P $z",
        180, "$N hack$s into $P $z with $D",
        220, "$N chop$s $D deeply into $P $z",
        5000, "$N chop$s $P $z into pieces with $D",
        }),
    "pierce": ({
      0, "$N thrust$s at $I with $D",
        20, "$N barely hit$s $I in the $z with $D",
        60, "$N jab$s $D into $P $z",
        100, "$N pierce$s $P $z with $D",
        140, "$N impale$s $P $z on $D",
        180, "$N skewer$s $P $z with $D",
        220, "$N run$s $I through the $z with $D",
        5000, "$N make$s a kebab of $P $z with $D",
        }),
    "pierce-spike": ({
      0, "$N swing$s at $I with $D",
        20, "$N barely hit$s $I in the $z with $D",
        60, "$N jab$s $D into $P $z",
        100, "$N spike$s $P $z with $D",
        140, "$N impale$s $P $z on $D",
        180, "$N ventilate$s $P $z with $D",
        220, "$N perforate$s $P $z with $D",
        5000, "$N make$s a mess of $P $z with $D",
        }),
    "pierce-beak" : ({
      0, "$N pecks at $I with $p beak",
        10, "$N snick$s $P $z",
        40, "$N scratch$es $P $z with $p beak",
        70, "$N peck$s $P $z",
        100, "$N viciously peck$s $P $z",
        130, "$N gouge$s a hole in $P $z with $p beak",
        160, "$N slice$s $P $z with $p beak",
        5000, "$N slice$s $P $z into small bits with $p beak",
        }),
    "pierce-stab": ({
      0, "$N thrust$s at $I with $D",
        20, "$N barely stab$s $I in the $z with $D",
        60, "$N stab$s $I in the $z with $D",
        100, "$N messily stab$s $I in the $z with $D",
        140, "$N stab$s $I deeply in the $z with $D",
        180, "$N perforate$s $P $z with $D",
        220, "$N pierce$s $P $z with $D",
        5000, "$N stab$s $D right through $P $z",
        }),
    "pierce-horns": ({
      0, "$N attempt$s to gore $I with $p horns",
        20, "$N prod$s $I in the $z with $p horns",
        60, "$N poke$s $I in the $z with $p horns",
        100, "$N butt$s $I in the $z with $p horns",
        140, "$N pierce$s $I deeply in the $z with $p horns",
        180, "$N ram$s $I in the $z with $p horns",
        220, "$N gore$s $P $z with $p horns",
        5000, "$N impale$s $P $z on $p horns",
        }),
    "pierce-tusks": ({
      0, "$N attempt$s to gore $I with $p tusks",
        20, "$N prod$s $P $z with $p tusks",
        60, "$N poke$s $I in the $z with $p tusks",
        100, "$N jab$s $p tusks into $P $z",
        140, "$N pierce$s $P $z with $p tusks",
        180, "$N stab$s $p tusks deeply into $P $z",
        220, "$N gore$s $P $z with $p tusks",
        5000, "$N impale$s $P $z on $p tusks",
        }),
    "pierce-bite" : ({
      0, "$N attempt$s to bite $I",
        10, "$N nip$s $I in the $z",
        40, "$N nibble$s at $P $z",
        70, "$N bite$s $I in the $z",
        100, "$N sink$s $p teeth into $P $z",
        130, "$N bite$s into $P $z",
        160, "$N sink$s $p teeth deep into $P $z",
        5000, "$N bite$s deeply into $P $z, splintering $P bones",
        }),
    "fire" : ({
      20, "$N smoke$s $I",
        60, "$N toast$s $I",
        100, "$N scorch$es $I",
        140, "$N crisp$s $I",
        180, "$N singe$s $I",
        220, "$N fry$s $I",
        260, "$N roast$s $I",
        300, "$N melt$s $I",
        340, "$N char$s $I",
        380, "$N burn$s $I",
        420, "$N incinerate$s $I",
        460, "$N cremate$s $I",
        5000, "$N vapourise$s $I",
        }),
    ]);
}

/** @ignore */
string parse_string(string mess, object him, object me, object wep,
                    string zone) {

   return replace( replace( mess, ({
      "$mposs$ $D", (string)wep->poss_short() }) ),
         ({ "$hname$", (string)him->query_name(),
            "$mname$", (string)me->query_name(),
            "$hcname$", (string)him->the_short(),
            "$mcname$", (string)me->the_short(),
            "$hposs$", (string)him->query_possessive(),
            "$mposs$", (string)me->query_possessive(),
            "$hpname$", (string)him->poss_short(),
            "$mpname$", (string)me->poss_short(),
            "$hpron$", (string)him->query_pronoun(),
            "$mpron$", (string)me->query_pronoun(),
            "$hobj$", (string)him->query_objective(),
            "$mobj$", (string)me->query_objective(),
            "$wname$", (string)wep->query_name(),
            "$wcname$", (string)wep->short(0),
            "$zname$", zone})
   );
} /* parse_string() */

mixed query_message( int dam, string type, object him, object me,
                     string name, object wep, string zone) {
  int j;
  mixed ind;
  string tmp;

  if(!zone) {
    zone = "body";
  } else {
    if(zone[sizeof(zone)]-1 == 's')
      zone = zone[0..<2];
  }

  ind = wep->query_attack_message(name, type);

  if (!ind) {
    // When we changed weapons to use AT_SKILL instead of AT_NAME
    // it broke unarmed combat.
    if(type == "unarmed") {
      switch(name) {
      case "bite":
      case "beak":
      case "stab":
      case "horns":
      case "tusks":
        type = "pierce";
        break;
      case "claws":
      case "chew":
      case "slice":
      case "chop":
        type = "sharp";
        break;
      default:
        type = "blunt";
      }
    }
    ind = weapon_mess[type+"-"+name];
    if(!ind) {
      ind = weapon_mess[type];
      if (!ind) {
        return 0;
      }
    }
  }

  /* Find the correct message */
  while (j < sizeof(ind) && dam > ind[j]) {
    j += 2;
  }
  if (j >= sizeof(ind)) {
    j = sizeof(ind)-2;
  }

  ind = ind[j+1];
  /* If it is a string, new format */
  if (stringp(ind)) {
    tmp = replace(ind,
                  ({ "$N", (string)me->the_short(),
                       "$p ", (string)me->query_possessive() +" ",
                       "$r", (string)me->query_pronoun(),
                       "$o", (string)me->query_objective(),
                       "$z", zone,
                       "$D", wep->poss_short(),
                       "$I", him->the_short(),
                       "$P", (string)him->the_poss_short(),
                       "$O", (string)him->query_objective(),
                       "$es", "es", "$s", "s" }) );

    ind = ({ replace( ind, ({ "$N", "you", "$p ", "your ",
                                "$r", "you", "$o", "you",
                                "$es", "", "$s", "",
                                "$D", wep->poss_short(),
                                "$z", zone,
                                "$I",  him->the_short(),
                                "$P", him->the_poss_short(),
                                "$O", him->query_objective(),
                                
                                }) ),
               tmp,
               tmp });
    return ind;
  }
  return ({
    parse_string(ind[0], him, me, wep, zone),
      parse_string(ind[1], him, me, wep, zone),
      parse_string(ind[2], him, me, wep, zone)});
} /* query_message() */
// --- END [/mnt/home2/grok/lib/obj/handlers/attack_messages.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/livings.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/livings.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628417   Available: 13575771
Inodes: Total: 5242880    Free: 4960134
5665 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/livings.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628417   Available: 13575771
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * A handler to deal with all the living objects on the disc.  
 * @author Wodan
 * @changed Pinkfish March 16th
 * After wodan didn't add any autodoc comments and made some bits quite
 * inefficent
 */
private nosave mapping _lnames = ([]);
private nosave mapping _players = ([]);

#ifdef 0
void create() {
  object player, *players;

  players = filter(efun::users(), (: $1 && inherits("/std/container", $1) :));
  foreach(player in players) {
    _players[player->query_name()] = player;
  }
}
#endif

/** 
 * This method checks through the living names in the handler and 
 * removes an invalid entries.
 * @param names an array of strings which contains the names of 
 * the creatures to check in the array.
 */
private void check_lnames(string* names) {
   string key;

   foreach (key in names) {
      mixed bing = _lnames[key];
       
      // If the values are an array, then remove any zeros and check
      // to see if we can clean up. 
      if (arrayp(bing)) {
         bing -= ({ 0 }); 

         if (sizeof(bing)) {
            _lnames[key] = bing;
         }
         else { 
            // It's empty, so clean it up. 
            map_delete(_lnames, key);
         }
      }
      else { 
         // We got an undefined or non-array value, so let's delete
         // the key from the mapping. 
         map_delete(_lnames, key);
      }
   }
} /* check_lname() */

/**
 * Same checks as in check_lname(), but for the _players
 * mapping instead.
 * @see check_lnames()
 */
private void check_players(string* names) {
   string key;
   
   foreach (key in names) {
      mixed bing = _players[key];     

      if (arrayp(bing)) {
         bing -= ({ 0 }); 

         if (sizeof(bing)) {
            _players[key] = bing;
         }
         else { 
            map_delete(_players, key);
         }
      }
      else { 
         map_delete(_players, key);
      }
   }
} /* check_lname() */

/**
 * Removes all the not very useful things from the huge mapping.
 */
void remove_garbage(){
  string* names;
  int i;

  names = keys(_lnames);
  for (i = 0; i < sizeof(names); i += 50) {
     call_out((: check_lnames :), i / 25, names[i..i+50]);
  }
  names = keys(_players);
  for (i = 0; i < sizeof(names); i += 50) {
     call_out((: check_players :), i / 25, names[i..i+50]);
  }
}

/**
 * Enables commands on the object.
 * @param ob the object to enable the commands on
 */
void enable_commands(object ob){
}

/**
 * This method registers the living name with the specific object.
 * @param name the name to register
 * @param ob the object to register it with
 */
void set_living_name(string name, object ob){
  if (!stringp(name) || !objectp(ob)) {
    return ;
  }
  if(!_lnames[name]) {
    _lnames[name] = ({ob});
  } else {
    _lnames[name] += ({ob});
  }

  if ( ob == master() ) {
     log_file( "LIVINGS", "%O (%s) became a living. %O\n", ob,
         name, call_stack(0) );
  }
}

/**
 * This method returns the name of all the named livings in the game.
 * Do not use this method except for debugging.
 */
object *named_livings(){
  object *ret;

  ret = keys(_lnames);
  ret = map(ret, (:$1?(_lnames)[$1]:0:));
  reset_eval_cost(); 
  ret = filter(ret, (:$1:));
  reset_eval_cost(); 
  ret = implode(ret, (:$1 + $2:));
  reset_eval_cost(); 
  ret = filter(ret, (:$1:));
  return ret;
}

/**
 * Returns the living object associated with the name.
 * @return the living object
 */
object find_living(string it) {
  if(_lnames[it]) {
    _lnames[it] = filter(_lnames[it], (: $1 :));
    if(sizeof(_lnames[it]))
      return _lnames[it][<1];
  }
  return 0;
}

/**
 * Returns the player associated with the name.
 * @return the player object
 */
object find_player(string it) {
  object *people;
  int t = real_time();
  object *tmp;

  if(_players[it]) {
    // temporarily removed this
    // if(reference_allowed(_players[it]))
      return _players[it];
    return 0;
  }

  //reset_eval_cost();
  people = filter(efun::users(), (: $1 && $1->query_name() == $(it) &&
                                  inherits("/std/container", $1):));
  
  if(sizeof(people)) {
    _players[it] = people[0];
    if(real_time() - t > 1)
      log_file("GARBAGE", "find_player took %d seconds to find %s (1)\n",
               real_time() - t, it);
    // --temporarily removed this.. 
    // if(reference_allowed(_players[it]))
      return _players[it];
  }
  if(!_lnames[it]) {
    if(real_time() - t > 1)
      log_file("GARBAGE", "find_player took %d seconds to find %s (2)\n",
               real_time() - t, it);
    return 0;
  }

  tmp = filter(_lnames[it], (: $1 && userp($1) :));

  if(real_time() - t > 1)
    log_file("GARBAGE", "find_player took %d seconds to find %s (3)\n",
             real_time() - t, it);

  if(sizeof(tmp))
    return tmp[0];
  return 0;
}

/**
 * These two are not here because the handler can be saved, but to keep
 * the info over updates.
 * @ignore yes
 */
mapping query_dynamic_auto_load() {
   mapping tmp;
   tmp = ([ "lnames" : _lnames,
            "players" : _players,
          ]);
   return tmp;
}

/**
 * @ignore yes
 */
void init_dynamic_arg(mapping maps) {
   object ob;
   string name;
   if (maps["lnames"])
      _lnames = maps["lnames"];
   if (maps["players"])
      _players = maps["players"];

   foreach(ob in efun::users()){
      if ( !ob ) {
        continue;
      }
      name = ob->query_name();
      _players[name] = ob;
      if(!_lnames[name]){
        _lnames[name] = ({ob});
      } else {
        _lnames[name] |= ({ob});
      }
   }
}

mixed *stats() {
  return ({ ({ "lnames", sizeof(keys(_lnames)) }),
              ({ "players", sizeof(keys(_players)) })});
}
// --- END [/mnt/home2/grok/lib/obj/handlers/livings.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/reaction.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/reaction.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628415   Available: 13575769
Inodes: Total: 5242880    Free: 4960134
16838 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/reaction.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628415   Available: 13575769
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: reaction.c,v 1.13 2002/02/24 06:18:32 taffyd Exp $
 * $Log: reaction.c,v $
 * Revision 1.13  2002/02/24 06:18:32  taffyd
 * Patched a runtime
 *
 * Revision 1.12  2001/07/26 04:38:17  tannah
 * Ceres' new version with fixes for runtimes.
 *
 * Revision 1.9  2001/07/18 23:35:49  tannah
 * replaced set_amount with adjust_amount and reordered a few things
 * in check_reaction()
 *
 * Revision 1.8  2001/06/30 05:42:04  pinkfish
 * Fix it up to stop spamming /log/catch.
 *
 * Revision 1.7  2000/04/10 05:08:25  ceres
 * No idea.
 *
 * Revision 1.6  1999/05/02 04:46:21  jeremy
 * Added merging of effects.
 *
 * Revision 1.5  1998/09/10 17:02:03  jeremy
 * ratios can now be int or array of ints (previously had to be floats).
 *
 * Revision 1.4  1998/08/04 04:14:35  jeremy
 * Fixed typo (I hope) in range-of-ratios section, and added more comments.
 *
 * Revision 1.3  1998/05/08 03:20:26  jeremy
 * Took out unused variables, and added update_from_files() (untested).
 *
 * Revision 1.2  1998/04/21 03:45:39  jeremy
 * Added check for a->query_amount() going to 0 in the main loop.
 *
 * Revision 1.1  1998/01/06 05:03:33  ceres
 * Initial revision
 *
*/
/*
 *  reaction handler - Handles reactions between substances that have
 *      been mixed together.
 *
 *  A few notes of what I have planned:
 *
 *  the substance mapping will have as its keys the substance names
 *  (as returned by query_medium_alias()).
 *  The value will be another mapping (one for each substance).  This
 *  second-level mapping will have as its keys the substances with
 *  which it reacts.  To save space, the names of the two substances
 *  will be compared, and the alphanumerically lower one will be the
 *  index into the top-level mapping.
 *
 *  The value of the second-level mapping is the tricky part.
 *  It is currently a class that contains all the relevant information.
 *  See the definition of the class for more info.
 *
 *  The following pseudo-objects may be used in the message strings and
 *  function call strings; process_string is explicitly called in both
 *  cases:
 *    #env# - replaced by the filename of the environment
 *    #env2# - replaced by the filename of the environment of the enviroment
 *    #obj_a# - The object being added to the container
 *    #obj_b# - The object with which 'a' is reacting
 *    #obj_x# - The transient object, or the result object if no transient
 *
 *  Various debugging messages will be printed if this_player() has a
 *  property call "debug_rh" with a non-zero value.
 *
 *  To Do:
 *    Handle concentrations.
 *
 */

#include <move_failures.h>
#include <reaction.h>

#define REACTIONS "/obj/reactions/"
#define SUBSTANCES 10

mapping substance = allocate_mapping(SUBSTANCES);
int debug_rh = 0;

void restore_from_files();

void write_dbg(string str) { if (debug_rh) write(str); }

void create() {
    seteuid("/secure/master"->creator_file(file_name(this_object())));
    restore_from_files();
}

// Merge the effects mappings, weighted by relative amounts, and return
// a mapping that can be used to add the new effects.  Note that, since
// add_xxx_effect() is cumulative, the result reflects the difference.
mapping merge_effects(mapping effects_a, mapping effects_m, int q_a, int q_m) {
    int q_t, strength;
    string key;
    mapping ret = ([ ]);

    if(!mapp(effects_a) || !mapp(effects_m))
      return 0;

    q_t = q_a + q_m;
    if ( !q_t ) {
        return 0;
    }

    foreach (key in keys(effects_a)) {
        if (!intp(effects_a[key]) || !intp(effects_m[key])) {
            continue;
        }
        if (undefinedp(effects_m[key])) {
            strength = (effects_a[key]*q_a)/q_t;
        } else {
            strength = (effects_a[key]*q_a + effects_m[key]*q_m)/q_t
                - effects_m[key];
            map_delete(effects_m, key);
        }
        ret += ([key: strength]);
    }
    foreach (key in keys(effects_m)) {
        if (!intp(effects_m[key])) {
            continue;
        }
        strength = (effects_a[key]*q_a + effects_m[key]*q_m)/q_t
            - effects_m[key];
        ret += ([key: strength]);
    }
    return ret;
}

// This is used to merge the new substance with any amounts of the same
// type already in the container, so that the total is checked.
object merge_cont_medium(object a, string medium_alias) {
    object medium;
    int no_join, q_a, q_m;
    mapping effects_a, effects_m, eff;
    string key;

    a->remove_alias(medium_alias);
    no_join = a->query_no_join();
    if ((medium = present(medium_alias, environment(a))) && !no_join) {
        a->set_no_join();
        a->move("/room/void");
        q_a = a->query_amount();
        q_m = medium->query_amount();
        medium->adjust_amount(q_a);
        // Adjust strengths of effects
        effects_a = copy(a->query_eat_effects());
        effects_m = copy(medium->query_eat_effects());
        eff = merge_effects(effects_a, effects_m, q_a, q_m);
        if (mapp(eff)) {
           foreach (key in keys(eff)) {
               medium->add_eat_effect(key, eff[key]);
           }
        }
        effects_a = copy(a->query_external_effects());
        effects_m = copy(medium->query_external_effects());
        eff = merge_effects(effects_a, effects_m, q_a, q_m);
        if(eff) {
          foreach (key in keys(eff)) {
            medium->add_external_effect(key, eff[key]);
          }
        }
        call_out("dest_substance", 0, a);
        return medium;
    } else {
        a->add_alias(medium_alias);
        return a;
    }
}

void check_reaction(object a) {
    int amt_a, need_amt_a, amt_b, need_amt_b;
    string name_a, name_b, i_a, i_b, msg, fcn;
    mixed *fcns;
    int i, j, amt_result;
    object x, *bs, ob_a, ob_b;
    float ratio;
    class reaction rcn;

    if (objectp(this_player()))
      debug_rh = this_player()->query_property("debug_rh");
    else
      debug_rh = 0;
    write_dbg("Entering reaction_handler.\n");
    name_a = a->query_medium_alias();
    if (!name_a || !a->query_continuous()) {
        write_dbg("Leaving reaction_handler because there is no A or it is not "
        "continous.\n");
        return; // Only bother if added item is a cont_medium
    }

    if ( a->query_medium_alias() == a->query_name() ) {
        debug_printf( "WARNING: Your cont_medium alias must "
          "not be the same as your name.\n" );
        return;
    }

    a = merge_cont_medium(a, name_a);
    bs = all_inventory(environment(a));
    debug_printf( "A is %O at %O. Bs are: %O.\n", a, environment( a ), bs );
    if ((sizeof(bs) < 2) || (!a->query_amount())) {
        write_dbg("Leaving reaction_handler because there is no B, or there is "
        "0 amounts of A.\n");
        return;
    }
    write_dbg("Checking the following: ");
    for (i = 0; i < sizeof(bs); i++) {
        write_dbg(bs[i]->query_medium_alias() + ", ");
    }
    write_dbg("\n");
    for (i = 0; i < sizeof(bs); i++) {
        // Check if a has been all used up yet.
        if (!a->query_amount()) {
            write_dbg("Leaving reaction_handler.\n");
            return;
        }
        // Find if a reacts with b
        name_b = bs[i]->query_medium_alias();
        if (!name_b || !bs[i]->query_continuous() || !bs[i]->query_amount()) {
            continue;
        }
        // The substance table is indexed in alphabetical order;
        // ob_a and ob_b are used to keep the two objects straight
        // whether or not they had to be swapped (mainly when dealing
        // with amounts).
        if (name_a < name_b) {
            i_a = name_a;
            i_b = name_b;
            ob_a = a;
            ob_b = bs[i];
        } else {
            i_a = name_b;
            i_b = name_a;
            ob_a = bs[i];
            ob_b = a;
        }
        write_dbg("Checking " + i_a + " against " + i_b + ".\n");
        if (!substance[i_a] || !substance[i_a][i_b]) {
            continue;
        }
        write_dbg("...they react.\n");
        rcn = substance[i_a][i_b];
        amt_a = ob_a->query_amount();
        amt_b = ob_b->query_amount();
        ratio = to_float(amt_a) / amt_b;
        if (intp(rcn->ratio)) {
            // These need to be floats
            rcn->ratio = to_float(rcn->ratio);
        }
        if (floatp(rcn->ratio)) {
            write_dbg("Single ratio...\n");
            if (ratio > rcn->ratio) {
                need_amt_b = amt_b;
                // Round up fractions (maybe this could be random?)
                need_amt_a = to_int(ceil(amt_b*rcn->ratio));
                write_dbg("Setting amt_a to "+ to_int(ceil(amt_b*rcn->ratio)) +".\n" );
            } else {
                need_amt_a = amt_a;
                need_amt_b = to_int(ceil(amt_a/rcn->ratio));
                write_dbg("Setting amt_b to "+ to_int(ceil(amt_a/rcn->ratio)) +".\n" );
            }
        } else if (arrayp(rcn->ratio) && (sizeof(rcn->ratio) == 2)) {
            // Ratio range
            // I've gotten confused by this, so here's my rationale:
            //   a/b should be in the range (r[0], r[1]).
            //   If above range, too much of a: take all of b; take as much of
            //     a as necessary to match upper ratio (ie, b*r[1]).
            //   If below range, too much of b: take all of a; take as much of
            //     b as necessary to match lower ratio (ie, a/r[0]).
            //   If in range, take all of both.
            write_dbg("Range of ratios...");
            if (intp(rcn->ratio[0])) {
                rcn->ratio[0] = to_float(rcn->ratio[0]);
            }
            if (intp(rcn->ratio[1])) {
                rcn->ratio[1] = to_float(rcn->ratio[1]);
            }
            if (ratio > rcn->ratio[1]) {
                write_dbg("above range...(" + ratio + ")\n");
                need_amt_b = amt_b;
                need_amt_a = to_int(ceil(amt_b*rcn->ratio[1]));
                write_dbg("Setting amt_a to "+ to_int(ceil(amt_b*rcn->ratio[1])) +".\n" );
                write_dbg("This is because amta is: "+ amt_b +" and ratio is "+ rcn->ratio[1] + ".\n" );
            } else if (ratio < rcn->ratio[0]) {
                write_dbg("below range...(" + ratio + ")\n");
                need_amt_a = amt_a;
                need_amt_b = to_int(ceil(amt_a/rcn->ratio[0]));
                write_dbg("Setting amt_b to "+ to_int(ceil(amt_a/rcn->ratio[0])) +".\n" );
                write_dbg("This is because amta is: "+ amt_a +" and ratio is "+ rcn->ratio[0] + ".\n" );
            } else {
                // Ratio within range, take all of both
                write_dbg("within range...(" + ratio + ")\n");
                need_amt_a = amt_a;
                need_amt_b = amt_b;
            }
        } else {
            error("Illegal reaction ratio; expecting float, int, or "
                  "array of two floats or ints.");
        }
        amt_result = to_int((need_amt_a + need_amt_b)*rcn->result_amt);
        write_dbg("...got ("+amt_a+","+amt_b+"), taking ("+need_amt_a+","+
                  need_amt_b+"), creating " + amt_result + ".\n");
        write_dbg("...creating "+rcn->result+".\n");
        // Create result object
        x = clone_object(rcn->result);
        if (rcn->result_amt) {
            if (function_exists("set_amount", x)) {
                x->set_amount(amt_result);
            } else {
                x->set_weight(amt_result);
            }
        }
        // Print out message when they mix.  This is pretty much
        // obsolete, since 'func' can do it also; but I kept it in
        // anyway.
        msg = rcn->message;
        if (msg) {
            msg = replace(rcn->message, ({
                "#env#", file_name(environment(a)),
                "#env2#", file_name(environment(environment(a))),
                "#obj_a#", file_name(ob_a),
                "#obj_b#", file_name(ob_b),
                "#obj_x#", file_name(x)
              }));
            tell_room(environment(environment(a)), msg);
        }
        // This is a back-door for any special functions that need
        // to be called.
        fcns = rcn->func;
        if (fcns) {
            for (j = 0; j < sizeof(fcns); j++) {
                if (stringp(fcns[j])) {
                    fcn = replace(fcns[j], ({
                        "#env#", file_name(environment(a)),
                        "#env2#", file_name(environment(environment(a))),
                        "#obj_a#", file_name(ob_a),
                        "#obj_b#", file_name(ob_b),
                        "#obj_x#", file_name(x)
                      }));
                } else if (functionp(fcns[j])) {
                    evaluate(fcns[j], ob_a, ob_b, x, environment(a),
                             environment(environment(a)), need_amt_a,
                             need_amt_b);
                }
            }
        }

        // Question: should I move the new object to the container
        // right now, or save it and add them all at once?  It might
        // make the order of reaction different; then again, it may
        // be arbitrary anyway.
        //x->move(environment(a));
        // I decided to postpone the move until after I leave the
        // handler.  Probably not necessary, but it makes debugging
        // easier.
        call_out("move_substance", 0, ({x, environment(a)}));

        // Decrease amounts and dest if gone
        ob_a->adjust_amount( -need_amt_a );
        ob_b->adjust_amount( -need_amt_b );

    }
    write_dbg("Leaving reaction_handler.\n");
}

void move_substance(object *ob) {
    // Used to move substance from a call_out
    int vol, vol_left, cont, closed, i, mv_stat;
    object *contents;

    if (!ob[0] || !ob[1]) return;
    vol_left = (int)ob[1]->query_max_volume() - (int)ob[1]->query_volume();
    if (cont = ob[0]->query_continuous()) {
        vol = ob[0]->query_amount();
    } else {
        vol = (int)ob[0]->query_weight()*200;
    }
    closed = ob[1]->query_closed();
    ob[1]->set_open();
    if ((mv_stat = ob[0]->move(ob[1])) != MOVE_OK) {
        write_dbg(sprintf("Move error (%d)...", vol));
        if ((vol > vol_left) && cont && !closed) {
            write_dbg("too much...\n");
            ob[0]->set_amount(vol_left);
            tell_room(environment(ob[1]), ob[0]->short(0) +
                      " leaks out of the " + ob[1]->short(0) + ".\n");
            mv_stat = ob[0]->move(ob[1]);
        }
        if (mv_stat == MOVE_OK) {
            if (closed) ob[1]->set_closed();
        } else {
            // Too big to fit! (or other problem)
            // Destroy container (unless living or a room) and contents.
            contents = all_inventory(ob[1]);
            write_dbg(sprintf("contents = %O\n", contents));
            for (i = 0; i < sizeof(contents); i++) {
                contents[i]->dest_me();
            }
            if (!living(ob[1]) && !function_exists("query_co_ord", ob[1])) {
                tell_room(environment(ob[1]), ob[1]->the_short(0) +
                          " explodes, splattering the contents all over.\n");
                //ob[1]->dest_me();
                ob[1]->move("/room/rubbish");
            }
            //ob[0]->dest_me();
            ob[0]->move("/room/rubbish");
        }
    } else {
        if (closed) ob[1]->set_closed();
    }
}

void dest_substance(object ob) {
    // Used to dest substance from a call_out.
    if (ob) {
        ob->dest_me();
    }
}

mixed *query_reaction(string name_a, string name_b) {
    // Return reaction parameters
    if (!substance[name_a] || !substance[name_a][name_b]) {
        return 0;
    }
    return substance[name_a][name_b];
}

mapping query_reactions() { return substance; }

// This should eliminate the need for the (now deleted) database manipulation
// functions.  Basically, all reactions in all files in the directory
// REACTIONS will be loaded.  This uses /obj/handler/data.  See the
// documentation on it and /include/reaction.h for the file format.

void restore_from_files() {
    string *files;
    int i;

    // This is the file with the #include and stuff that should only be
    // there once.
    files = ({ "base.hdr" });
    // These are the real data files
    files += get_dir(REACTIONS + "*.rcn");
    for (i = 0; i < sizeof(files); i++) {
        files[i] = REACTIONS + files[i];
    }
    //printf("files = %O\n", files);
    substance = "/obj/handlers/data"->compile_data(files);
}

void update_from_files(string fn) {
    mapping new_substance;
    string a, b;

    new_substance = "/obj/handlers/data"->compile_data( ({ fn }) );
    foreach (a in keys(new_substance)) {
      if (undefinedp(substance[a])) {
        substance[a] = ([ ]);
      }
      foreach (b in keys(new_substance[a])) {
        substance[a][b] = new_substance[a][b];
      }
    }
}
// --- END [/mnt/home2/grok/lib/obj/handlers/reaction.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/money_handler.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/money_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628411   Available: 13575765
Inodes: Total: 5242880    Free: 4960134
44812 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/money_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628411   Available: 13575765
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*   -*- LPC -*-   */
/*
 * $Locker:  $
 * $Id: money_handler.c,v 1.44 2002/10/24 03:43:12 presto Exp $
 */
/**
 * This handles all the methods for determining values of coins and
 * the current valid set of coins.   It also handles change calculation.
 * This was written originaly by Pinkfish, reworked significantly by
 * Deutha to add in the multiple currency areas.
 * @see /std/living/money.c
 * @author Pinkfish
 */
#include <money.h>

#define DEF_VALUE 1
#define SAVE_FILE "/save/money_handler"
//#undef USE_VAULT
#define USE_VAULT DEF_VALUE

mapping values;
mapping symbols;
mapping details;
mapping aliases;
mapping adjectives;

mixed *merge_money_arrays(mixed *m_array1, mixed *m_array2);
varargs object *filter_legal_money_array(mixed *m_array, string where);
varargs mixed *filter_legal_money_to_array(mixed *m_array, string where);


void create() {
   seteuid( (string)"/secure/master"->
      creator_file( file_name( this_object() ) ) );
   values = ([ "default": ({ "brass", 1, "copper", 10, "silver", 100,
                                          "gold", 2000, "platinum", 6000 }) ]);
   symbols = ([ ]);
   details = ([
      "brass": ({ "heads", "tails", "a head", "a tail", "brass", 0 }),
      "copper": ({ "heads", "tails", "a head", "a tail", "copper", 0 }),
      "silver": ({ "heads", "tails", "a head", "a tail", "silver", 0 }),
      "gold": ({ "heads", "tails", "a head", "a tail", "gold", 0 }),
      "platinum": ({ "heads", "tails", "a head", "a tail", "platinum", 0 }) ]);
   aliases = ([ ]);
   adjectives = ([ ]); 
   if ( file_size( SAVE_FILE +".o" ) > 0 ) {
      unguarded((: restore_object, SAVE_FILE :));
   }
   if ( !symbols ) {
      symbols = ([ ]);
   }
   if ( !aliases ) {
      aliases = ([ ]);
   }
   if ( !adjectives ) {
      adjectives = ([ ]);
   }
} /* create() */

/**
 * This method saves the current state of the money object.
 */
void save_me() { unguarded( (: save_object, SAVE_FILE :) ); }

/**
 * This method returns the mapping containing all the values of the
 * currently valid money types.   The mapping has keys of the domain
 * of the money and has a value of an array.   The array contains
 * alternating name, value pairs.
 * <pre>
 * ([ "default": ({ "brass", 1, "copper", 10, "silver", 100,
 *                                             "gold", 2000, "platinum", 6000 }) ])
 * </pre>
 * @return the mapping of values
 * @see query_values()
 * @see query_values_in()
 */
mapping query_all_values() { return copy( values ); }

/**
 * This method returns the current set of areas in which types can
 * be found.
 * @return the set of places
 */
string *query_all_places() {
   return keys(values);
} /* query_all_places() */

/**
 * This method returns the values in the default area.
 * This method returns the array as given in the value above.
 * It contains name, value pairs and is for the "default"
 * area.
 * @return the array of values
 * @see query_all_values()
 * @see query_values_in()
 */
mixed *query_values() { return copy( values[ "default" ] ); }

/**
 * This method returns the values in the specified area.
 * It contains name, value pairs and is for the "default"
 * area.
 * @return the array of values
 * @param where the area in which to return the values for
 * @see query_all_values()
 * @see query_values()
 * @see add_type()
 * @see query_mapped_values_in()
 */
mixed *query_values_in( string where ) {
   if ( !where || ( where == "" ) ) {
      where = "default";
   }
   return copy( values[ where ] );
} /* query_values_in() */

mixed *query_weighted_values_in( string where, int backwards ) {
    mixed *bits;
    int i, j; 
    int max_size; 
    int len; 
    mixed *arr, *reversed;

    if ( !where || ( where == "" ) ) {
        return 0; 
    }
    
    bits = copy( values[ where ] );
    arr = ({ }); 

    max_size = 0; 

    for ( i = 0; i < sizeof( bits ); i += 2 ) {
        len = sizeof( bits[ i ] );

        if ( len > max_size ) {
            arr += ({ bits[ i ], bits[ i + 1 ] }); 
            max_size = len; 
            continue; 
        }
        
        for ( j = 0; j < sizeof( arr ); j += 2 ) {
            if ( len <= sizeof( arr[ j ] ) ) {
                arr = arr[ 0..j-1] + ({ bits[ i ], bits[ i + 1 ] }) + arr[j..];
                break; 
            }
        }
    }

    if ( backwards ) { 
        reversed = ({ });

        for ( i = sizeof( arr ) - 1; i > 0; i -= 2) {
            reversed += ({ arr[ i - 1 ], arr[ i ] });
        }

        return reversed;
    }
    else { 
       return arr;
    }
} /* query_weighted_values_in() */

/**
 * This returns the smallest value in the specified area.  Used to
 * make sure we are not charging too little or too much when doing
 * comparisons.
 * @return the smallest value in the specified area
 * @param where the area to check
 */
int query_smallest_value_in(string where) {
   mixed* values;
   int value;
   int i;

   if (! where) {
      where = "default";
   }
   values = query_values_in(where);
   value = values[1];
   for (i = 2; i < sizeof(values); i += 2) {
      if (values[i + 1] < value) {
         value = values[i + 1];
      }
   }
   return value;
} /* query_smallest_value_in() */

/**
 * This adds a type of money to the money handler.
 * @param where the area in which to add the type of money
 * @param type the name of the money to add
 * @param value the value of the money
 * @see query_values_in()
 * @see remove_type()
 */
void add_type( string where, string type, int value ) {
   int i;

   if ( !values[ where ] ) {
      values[ where ] = ({ type, value });
      save_me();
      return;
   }
   if ( member_array( type, values[ where ] ) != -1 ) {
      return;
   }
   for ( i = 0; i < sizeof( values[ where ] ); i += 2 ) {
      if ( value < values[ where ][ i + 1 ] ) {
         values[ where ] = values[ where ][ 0 .. i - 1 ] + ({ type, value })
                           + values[ where ][ i .. sizeof( values ) ];
         save_me();
         return;
      }
   }
   values[ where ] += ({ type, value });
   save_me();
} /* add_type() */

/**
 * This method removes the type of money from the handler.
 * @param where the area to remove it from
 * @param type the type to remove
 * @see add_type()
 */
void remove_type( string where, string type ) {
   int i;

   if ( !values[ where ] ) {
      return;
   }
   i = member_array( type, values[ where ] );
   if ( i == -1 ) {
      return;
   }
   values[ where ] = delete( values[ where ], i, 2 );
   if ( !sizeof( values[ where ] ) ) {
      map_delete( values, where );
   }
   save_me();
} /* remove_type() */

/**
 * This method returns all the details for the current set of
 * coins.   The details are information which is shown when the coin
 * is looked at.   Stuff about heads and tails and things.
 * <pre>
 *   ([
 *      "brass": ({ "heads", "tails", "a head", "a tail", "brass", 0 }),
 *      "copper": ({ "heads", "tails", "a head", "a tail", "copper", 0 }),
 *      "silver": ({ "heads", "tails", "a head", "a tail", "silver", 0 }),
 *      "gold": ({ "heads", "tails", "a head", "a tail", "gold", 0 }),
 *      "platinum": ({ "heads", "tails", "a head", "a tail", "platinum", 0 }) ])
 * </pre>
 * The places correspond to:
 * <pre>
 * ({ forward short, reverse short,
 *      forward long, reverse long, composition, plural })
 * </pre>
 * @return the details array
 */
mapping query_details() { return copy( details ); }

/**
 * This method returns the details for a specified type of money.
 * It will return an array of the form:
 * <pre>
 * ({ "heads", "tails", "a head", "a tail", "brass", 0 })
 * </pre>
 * The places correspond to:
 * <pre>
 * ({ forward short, reverse short,
 *      forward long, reverse long, composition, plural })
 * </pre>
 * @param word the money type to get the type for
 * @see add_details()
 */
mixed *query_details_for( string word ) {
   if ( !details[ word ] ) {
      return ({ "heads", "tails", "a head", "a tail", "unknown", 0 });
   }
   return copy( details[ word ] );
} /* query_details_for() */

/**
 * This method adds the details for the given coin type into the current
 * list.
 * @param word the coin type the details are for
 * @param hd_sht the heads side short
 * @param tl_sht the tail side short
 * @param hd_lng the head side long
 * @param tl_lnd the tail side long
 * @param composition the composition of the money
 * @param plural the plural value of the object, if 0 then use default plural
 * @see query_details_for()
 * @see remove_details()
 */
void add_details( string word, string hd_sht, string tl_sht, string hd_lng,
                  string tl_lng, mixed composition, string plural ) {
   if ( details[ word ] ) {
      return;
   }
   details[ word ] = ({ hd_sht, tl_sht, hd_lng, tl_lng, composition, plural });
   save_me();
} /* add_details() */

/**
 * This method removes the specified detail. 
 * @param word the type of money to remove the details for
 * @see add_detail()
 * @see query_details_for()
 */
void remove_details( string word ) {
   if ( !details[ word ] ) {
      return;
   }
   map_delete( details, word );
   save_me();
} /* remove_details() */

/**
 * This method returns all the symbols for the current money areas in the
 * handler.   The return value is mapping with the key being the
 * money area and the value being the symboliser for the money.
 * The symboliser is called with a value to get the money to
 * print itself out nicely.   This is used when the quantity of
 * actual coins is not known and only the value of them is
 * known.
 * @return all of the symbols
 * @see query_symbol_for()
 * @see add_symbol()
 * @see remove_symbol()
 */
mapping query_symbols() { return copy( symbols ); }

/**
 * This method returns the symboliser for the specified money area.
 * @param word the area in which the money is occuring
 * @return the syboliser for the money area
 * @see query_symbols()
 * @see add_symbol()
 * @see remove_symbol()
 */
string query_symbol_for( string word ) {
   if ( !symbols[ word ] ) {
      return 0;
   }
   return copy( symbols[ word ] );
} /* query_symbol_for() */

/**
 * This method adds in a symboliser for a specified money area.
 * @example
 * add_symbol("Ankh-Morpork", "/d/am/money");
 * @example
 * // This is an example of a symboliser object
 * string symbolise_value( int value ) {
 *    int dollars, pence;
 * 
 *    dollars = value / 400;
 *    pence = ( value % 400 ) / 4;
 *    if ( !pence ) {
 *       return "A$"+ dollars;
 *    }
 *    if ( !dollars ) {
 *       return pence +"p";
 *    }
 *    if ( pence < 10 ) {
 *       return "A$"+ dollars +".0"+ pence;
 *    }
 *    return "A$"+ dollars +"."+ pence;
 * } /\* symbolise_value() *\/
 * @param word the money area to add the symbol for
 * @param symboliser the path to the symboliser object
 * @see query_symbols()
 * @see query_symbol_for()
 * @see remove_symbol()
 */
void add_symbol( string word, string symboliser ) {
   if ( symbols[ word ] ) {
      return;
   }
   symbols[ word ] = symboliser;
   save_me();
} /* add_symbol() */

/**
 * This method removes the symboliser for the particular money area.
 * @see query_symbols()
 * @see query_symbol_for()
 * @see add_symbol()
 * @param word the money area to remove the symbol for
 */
void remove_symbol( string word ) {
   if ( !symbols[ word ] ) {
      return;
   }
   map_delete( symbols, word );
   save_me();
} /* remove_symbol() */

/** @ignore yes */
string query_alias_for( string type ) {
   log_file("OBSOLETE_CALLS",
      sprintf("%O %s: %O called query_alias_for\n",
         this_object(),
         ctime(time()),
         previous_object()
         ));
   if ( !details[ type ] ) return "coin";
   if ( !details[ type ][ 5 ] ) return "coin";
   return explode( type, " " )[ sizeof( explode( type, " " ) ) - 1 ];
} /* query_alias_for() */

/**
 * This method sets the aliases for the specified money type.
 * @param type the type of money to set the aliases for
 * @param words the aliases for the money
 * @see query_aliases_for()
 * @param type the type of money to set the aliases for
 * @param words the aliases for the money
 */
void set_aliases_for(string type, string *words) {
   if (!words || !sizeof(words)) {
      if (aliases[type]) {
         map_delete(aliases, type);
      }
   } else {
      aliases[type] = words;
   }
   save_me();
   return;
} /* set_aliases_for() */

/**
 * This method returns all the current aliases for the given type
 * of money.
 * @param type the type of money to get the aliases for
 * @return the aliases for the money type
 * @see set_aliases_for()
 */
string *query_aliases_for( string type ) {
   string *ret;

   if ( !details[ type ] || !details[ type ][ MONEY_DETAILS_PLURAL ] ) {
      ret = ({ "coin" });
   } else {
      ret = ({ explode(type, " ")[<1] });
   }
   if ( aliases[ type ] ) {
      ret += aliases[ type ];
   }
   return ret;
} /* query_aliases_for() */

/**
 * This method sets the adjectives for the specified money type.
 * @param type the type of money to set the adjectives for
 * @param words the adjectives for the money
 * @see query_adjectives_for()
 * @param type the type of money to set the adjectives for
 * @param words the adjectives for the money
 */
void set_adjectives_for(string type, string *words) {
   if (!words || !sizeof(words)) {
      if (adjectives[type]) {
         map_delete(adjectives, type);
      }
   } else {
      adjectives[type] = words;
   }
   save_me();
   return;
} /* set_adjectives_for() */

/**
 * This method returns all the current adjectives for the given type
 * of money.
 * @param type the type of money to get the aliases for
 * @return the adjectives for the money type
 * @see set_adjectives_for()
 */
string *query_adjectives_for( string type ) {
   string *ret;

   if ( adjectives[ type ] ) {
      ret = adjectives[ type ];
   }
   else {
      ret = ({ });
   }
   
   return ret;
} /* query_adjectives_for() */

/**
 * This method returns the short description of the money type.
 * @param type the money type to get the short description for
 * @return the short description for the money object
 * @see query_main_plural_for()
 */
string query_short_for( string type ) {
   if ( !details[ type ] ) {
      return type +" coin";
   }
   if ( !details[ type ][ MONEY_DETAILS_PLURAL ] ) {
      return type +" coin";
   }
   return type;
} /* query_short_for() */

/**
 * This method returns the short plural description of the money type.
 * This returns just the one word, like 'coins' or 'talons'.
 * @param type the money type to get the short plural description for
 * @return the short plural description for the money object
 * @see set_plural_for()
 * @see query_main_plural_for()
 */
string query_plural_for( string type ) {
   if ( !details[ type ] ) {
      return "coins";
   }
   if ( !details[ type ][ MONEY_DETAILS_PLURAL ] ) {
      return "coins";
   }
   return details[ type ][ MONEY_DETAILS_PLURAL ];
} /* query_plural_for() */

/**
 * This method sets the plural for the specified money type.
 * @param type the money to set the plural for
 * @param plural the new plural for the money
 * @see query_plural_for()
 * @see query_main_plural_for()
 */
void set_plural_for( string type, string plural ) {
   if ( !details[ type ] ) {
      return;
   }
   details[ type ][ MONEY_DETAILS_PLURAL ] = plural;
   save_me();
} /* set_plural_for() */

/**
 * This method returns the main short plural description of the money type.
 * This returns the expanded plural version like 'Ankh-Morpork pennies'.
 * @param type the money type to get the short plural description for
 * @return the short plural description for the money object
 * @see set_plural_for()
 * @see query_plural_for()
 * @see query_short_for()
 */
string query_main_plural_for( string type ) {
   string *type_exp;

   if ( !details[ type ] ) {
      return type +" coins";
   }
   if ( !details[ type ][ MONEY_DETAILS_PLURAL ] ) {
      return type +" coins";
   }
   type_exp = explode(type, " ");
   return implode(type_exp[0 .. <2] +
      ({ details[ type ][ MONEY_DETAILS_PLURAL ] }), " " );
} /* query_main_plural_for() */

/**
 * This method returns the value of a specified type of money in a certain
 * money area.
 * @param type the type of money to get the value for
 * @param where the money area the money is in
 * @return the integer value of the money
 * @see query_total_value()
 */
varargs int query_value( string type, string where ) {
   int i, j, count, total;
   string *places;

   if ( !where || ( where == "" ) ) {
      where = "default";
   }
   if ( where == "mean" ) {
      places = m_indices( values );
      for ( i = 0; i < sizeof( places ); i++ ) {
         if ( ( j = member_array( type, values[ places[ i ] ] ) ) != -1 ) {
            count++;
            total += values[ places[ i ] ][ j + 1 ];
         }
      }
      if ( !count ) {
         return 0;
      }
      if ( !( total / count ) ) {
         return 0;
      }
      return total / count;
   }
   if ( !values[ where ] ) {
      return 0;
   }
   i = member_array( type, values[ where ] );
   if ( i == -1 ) {
      return 0;
   }
   return values[ where ][ i + 1 ];
} /* query_value() */

/**
 * This method determines the total value of a specified money array.
 * A money array consists of pairs of values ({ type, number })
 * @param mon_array the array to find the value of
 * @param where the money area to get the value in
 * @return the total value as an integer
 * @see query_value()
 */
varargs int query_total_value( mixed mon_array, string where ) {
   int i, amt;

   if ( !where || ( where == "" ) ) {
      where = "default";
   }
   for ( i = 0; i < sizeof( mon_array ); i += 2 ) {
      amt += mon_array[ i + 1 ] * query_value( mon_array[ i ], where );
   }
   return amt;
} /* query_total_value() */

/**
 * This method converts a money array into a string so it can be displayed.
 * @param mon_array the money array to convert into a string
 * @see money_value_string()
 */
string money_string( mixed mon_array ) {
   int i;
   string ret;

   if ( !sizeof( mon_array ) ) {
      return "nothing";
   }
   ret = "";
   while( i < sizeof( mon_array ) ) {
      if ( !mon_array[ i + 1 ] ) {
         mon_array = delete( mon_array, i, 2 ); 
      } else {
         i += 2;
      }
   }
   for ( i = 0; i < sizeof( mon_array ); i += 2 ) {
      ret += mon_array[ i + 1 ] +" ";
      if ( mon_array[ i + 1 ] == 1 ) {
         ret += query_short_for( mon_array[ i ] );
      } else {
         ret += query_main_plural_for( mon_array[ i ] );
      }
      if ( i == sizeof( mon_array ) - 4 ) {
         ret += " and ";
      } else if ( i != sizeof( mon_array ) - 2 ) {
         ret += ", ";
      }
   }
   return ret;
} /* money_string() */

/**
 * This method creates a money array from a certain value in a particular
 * money area. A money array consists of ({ type, number }) pairs in an
 * array.   ie: ({ "brass", 12, "copper", 24 }).
 * @example 
 * place = query_property("place");
 * if (!place) {
 *      place = "default";
 * }
 * mon_array = create_money_array( 1000, place);
 * @param value the value to get the money array for
 * @param where the money area to get the value in
 * @return a money array for the value in the area
 * @see money_value_string()
 */
varargs mixed *create_money_array( int value, string where ) {
   int i, amt;
   mixed *mon_array;

   if ( !where || ( where == "" ) ) {
      where = "default";
   }
   if ( !value ) {
      return ({ });
   }
   mon_array = ({ });
   for ( i = sizeof( values[ where ] ) - 2; i >= 0; i -= 2 ) {
      if ( value >= values[ where ][ i + 1 ] ) {
         mon_array += ({ values[ where ][ i ], amt = value /
                         values[ where ][ i + 1 ] });
         value -= amt * values[ where ][ i + 1];
      }
   }
   return mon_array;
} /* create_money_array() */

/**
 * This method returns a string which is based on the value of
 * the money in a certain money area.
 * @param value the value to get the string for
 * @param where the place to get the string for
 * @return a string of the money value in the certain money area
 * @see create_money_array()
 * @see money_string()
 * @see value_from_string()
 */
varargs string money_value_string( int value, string where ) {
   string symboliser;

   if ( !where || ( where == "" ) ) {
      where = "default";
   }
   if ( !symbols[ where ] ) {
      if (value < 0) {
         return "negative " + money_string( create_money_array( -value,
                                                                where ) );
      } else {
         return money_string( create_money_array( value, where ) );
      }
   }
   symboliser = symbols[ where ];
   return (string)symboliser->symbolise_value( value );
} /* money_value_string() */

/**
 * This method attempts to find a money value from a string.  It will
 * attempt to do fuzzy matching of the type.  This means it will match on
 * partial matches, this could lead to somewhat weird behaviour...  So it
 * goes...  It will return a money array, rather than a value
 * @param str the string to find the value of
 * @return a money array of the types matched
 * @see money_value_string()
 */
mixed* money_array_from_string(string str, string where) {
   int value;
   int number;
   int i;
   int pos;
   int frog;
   int match;
   int max_match;
   string plural;
   string *bits;
   string type;
   string match_name;
   mixed *stuff;
   mixed* ret_arr;

   if (!where) {
      where = "default";
   }

   if (symbols[ where ]) {
      value = symbols[ where ]->unsymbolise_string( str );
      if (value) {
         return create_money_array(value, where);
      }
   }
   ret_arr = ({ });
   stuff = query_weighted_values_in( where, 1 ); 

   if (!value && stuff) {
      /* Let's sort "stuff" based on the size. */ 

      /* Try and figure it out long hand. */
      bits = explode(str, " ") - ({ "and", ",", "" });
      for (i = 0; i < sizeof(bits); i++) {
         /* First we search for a number. */
         if (sscanf(bits[i], "%d", number) == 1 &&
             i + 1 < sizeof(bits)) {
            /*
             * Cool, now see if the next thing is a money type.  Go for longest
             * possible matching string
             */
            i++;
            type = bits[i];
            max_match = 0;
            do {
               match = 0;
               if (type[<1] == ',') {
                  type = type[0..<2];
               }
               type = lower_case(type);
               for (pos = 0; pos < sizeof(stuff); pos += 2) {
                  plural = query_plural_for(stuff[pos]);
                  // Find the last space and splice ourselves in.
                  frog = strsrch(stuff[pos], " ", -1);
                  if (frog) {
                     plural = stuff[pos][0..frog] + plural;
                  }
                  // Do fuzzy matching.
                  if (lower_case(stuff[pos]) == type ||
                      strsrch(lower_case(stuff[pos]), type) != -1 ||
                      lower_case(plural) == type ||
                      strsrch(lower_case(plural), type) != -1) {
                     match = stuff[pos + 1];
                     match_name = stuff[pos];
                  }
               }
               if (match) {
                  i++;
                  max_match = match;
                  if (i < sizeof(bits)) {
                     type += " " + bits[i];
                  }
               }
            } while (match && i < sizeof(bits));
            if (max_match) {
               ret_arr += ({ match_name, number });
            }
            i--;
         } else {
            i++;
         }
      }
   }
   return ret_arr;
} /* value_from_string() */

/**
 * This method attempts to find a money value from a string.  It will
 * attempt to do fuzzy matching of the type.  This means it will match on
 * partial matches, this could lead to somewhat weird behaviour...  So it
 * goes...
 * @param str the string to find the value of
 * @see money_value_string()
 * @example
 * // This will tell us the integer money value of the string.
 * write(MONEY_HAND->value_from_string("1 dollar and 12 pence",
 *                                     "Ankh-Morpork"));
 */
int value_from_string(string str, string where) {
   return query_total_value(money_array_from_string(str, where), where);
} /* value_from_string() */

/**
 * This method calculates the change of a certain value from a
 * given money array.   This makes sure that the change does not include
 * money that does not actually exist.
 * @param value the value of the change to calculate
 * @param mon_array the money array to determine the change from
 * @return the money array containing the change to use
 * @see make_payment()
 * @see pay_amount_from()
 */
mixed *calc_change( int value, mixed *mon_array ) {
   int i, num;
   mixed *ret;

   ret = ({ });
   for ( i = sizeof( mon_array ) - 2; i >= 0; i -= 2 ) {
      if ( value >= mon_array[ i + 1 ] ) {
         num = value / mon_array[ i + 1 ];
         value = value % mon_array[ i + 1 ];
         ret += ({ mon_array[ i ], num });
         if ( !value ) {
            return ret;
         }
      }
   }
   return ret;
} /* calc_change() */

/**
 * This method makes a payment from a money array.  It returns the
 * depleted money array, the amount taken out and the change
 * needed.  If the type is not set, then the best fit for the value
 * is found from the array.
 * <p>
 * The return array is formated as:<br>
 * ({ depleted_money_array, change, taken_from })<br>
 * The change is an integer value.
 * @example
 * ret = make_money_array_payment("Lancre Crown", 2, mon_array, "Lancre", 0);
 * @param type the type of money to take out (ie: "Lancre Crown")
 * @param value the amount of the type to take out
 * @param mon_array the money array to use
 * @param where the money area
 * @param use_default allow the use of the default money type
 * @return the return array as formated above
 */
mixed *make_money_array_payment( string type,
                                 int value,
                                 mixed *mon_array,
                                 string where,
                                 int use_default) {
   
   int i;
   int j;
   int num;
   int total;
   int cur_match;
   string mon_name;
   mixed *poss_values;
   mixed *ret;

   /* Figure out the money type. */
   if ( !where || ( where == "" ) ) {
      where = "default";
   }

   /* See if the money is there and its all easy. */
   if (type) {
      i = member_array( type, mon_array );
      if ( i != -1 ) {
         if ( value <= mon_array[ i + 1 ] ) {
            mon_array[ i + 1] -= value;
            return ({ ({ type, value }), 0, mon_array });
         }
      }

      /*
       * Damn, its not easy.  Figure out the real value and see if we can
       * get it out of the arrays.
       */
      value *= query_value( type, where );
   }

   // Cannot make a 0 value payment.
   if (!value) {
      return 0;
   }

   /* Check to make sure the total is ok. */
   total = query_total_value( mon_array, where );
   if (use_default  &&  where != "default") {
      total += query_total_value( mon_array, "default" );
   }
   /* If the value is more than the total...  */
   if ( value > total ) {
      return 0;
   }

   /* Get the possible values. */
   poss_values = ({ });
   if ( where != "default" && use_default ) {
      poss_values += values[ "default" ];
   }
   poss_values += values[ where ];

   /* Determine the return array */
   ret = ({ });
   /* This attempts an exact match of coins. */
   for ( i = ( sizeof( poss_values ) - 2 ); i >= 0; i -= 2 ) {
      j = member_array( poss_values[ i ], mon_array );
      if ( j != - 1 ) {
         if ( poss_values[ i + 1 ] <= value ) {
            num = value / poss_values[ i + 1 ];
            if ( num > mon_array[ j + 1 ] ) {
               num = mon_array[ j + 1 ];
            }
            mon_array[ j + 1] -= num;
            value -= num * poss_values[ i + 1 ];
            ret += ({ poss_values[ i ], num });
            if ( !value ) {
               return ({ ret, value, mon_array });
            }
         }
      }
   }

   /* No exact match...   So we need to figure out how much change to give. */
   /* One zoom through the array finding which one has the closest match. */
   cur_match = value + 10000000;
   for (i = 0; i < sizeof(poss_values); i +=2 ) {
      j = member_array( poss_values[ i ], mon_array);
      if (j != -1 &&
          mon_array[j + 1] > 0 &&
          poss_values[i + 1] >= value &&
          poss_values[i + 1] - value <= cur_match - value) {
         cur_match = poss_values[i + 1];
         mon_name = poss_values[i];
      }
   }

   if (mon_name) {
      j = member_array(mon_name, mon_array);
      i = member_array(mon_name, poss_values);
      mon_array[j + 1] -= 1;
      value = poss_values[i + 1] - value;
      ret += ({ poss_values[ i ], 1 });
   } else {
      return 0;
   }

   return ({ ret, value, mon_array });
} /* make_money_array_payment() */

/**
 * This method makes a payment of a particular amount in a particular
 * money area.   Please note that player or living objects can double
 * as money objects in this circumstance.  The first element of the
 * payment array is the values which should be used to take off
 * the player, the second element is the change needed to be payed
 * back.
 * @param type the type of money to pay in (ie: "Lancre Crown")
 * @param value the number of the type to pay
 * @param thing the thing which is doing the payment (money object)
 * @param where the money area the payment will occur in
 * @return the payment array
 * @see pay_amount_from()
 * @see calc_change()
 */
varargs mixed *make_payment( string type, int value, object thing,
                             string where ) {
   mixed *mon_array;
   mixed *stuff;

   if (!type) {
     return 0;
   }

   mon_array = copy(thing->query_money_array());
   stuff = make_money_array_payment( type, value, mon_array, where, 1);
   if (!stuff) {
      return stuff;
   }
   if (stuff[MONEY_PAY_CHANGE]) {
      return ({ stuff[MONEY_PAY_RETURN], calc_change(stuff[MONEY_PAY_CHANGE],
                                                     values[where]) });
   }
   return ({ stuff[MONEY_PAY_RETURN], stuff[MONEY_PAY_CHANGE] });
} /* make_payment() */

/**
 * This method makes a payment from a specified money object.
 * @param value the amount to pay
 * @param money the money object to pay from
 * @param where the money area the payment occurs in
 * @return the change object
 * @see make_payment()
 * @see calc_change()
 */
varargs object pay_amount_from(int value, object money, string where) {
   int i;
   object change;
   mixed *m_array, *p_array;
   mixed *change_array;
   mixed *pay_array;

   if (!where || where == "") {
      where = "default";
   }
   change_array = ({ });
   pay_array = ({ });
   m_array = create_money_array(value, where);
   for (i = 0; i < sizeof(m_array); i += 2) {
      p_array = make_payment(m_array[i], m_array[i + 1], money, where);
      if (!pointerp(p_array)) {
         continue;
      }

      if (sizeof(p_array[0]) > 0)
         pay_array = merge_money_arrays(pay_array, p_array[0]);
      if (sizeof(p_array[1]) > 0) {
         change_array = merge_money_arrays(change_array, p_array[1]);
      }
   }

   if (sizeof(pay_array) > 0)  {
      for (i = 0; i < sizeof(pay_array); i += 2) {
         pay_array[i + 1] = -pay_array[i + 1];
      }
      money->adjust_money(pay_array);
   }

   if (sizeof(change_array) == 0) {
      return 0;
   }

#ifdef USE_VAULT
   change = MONEY_VAULT->get_money_ob();
   change->set_money_array(change_array);
#else
   change = clone_object(MONEY_OBJECT);
#endif
   return change;

} /* pay_amount_from() */

/**
 * This method creates a money object of a certain value in a certain
 * money area.
 * @param value the value to create the new money object with
 * @param where the area to create the new money object in
 * @return the new money object
 */
varargs object make_new_amount( int value, string where ) {
   object money;

   if ( !where || ( where == "" ) ) {
      where = "default";
   }
#ifdef USE_VAULT   
   money = MONEY_VAULT->get_money_ob();
#else
   money = clone_object( MONEY_OBJECT );
#endif
   money->set_money_array( create_money_array( value, where ) );
   if ( !(int)money->query_value_in( where ) ) {
      money->dest_me();
      return 0;
   }
   return money;
} /* make_new_amount() */

/**
 * This method figures out the legal and illegal tender money from
 * the specified money object in the specified money area.   This method
 * returns a two element array which consists of the legal and illegal
 * tender for the given money area.   ({ legal, illegal }).  WARNING:
 * This method destructs the money object passed to it.
 * @param money the money object to get the legal tender from
 * @param where the money area the tender is for
 * @return an two element array of objects ({ legal, illegal })
 * @see parse_money()
 * @see filter_legal_money_array()
 * @see filter_legal_money_to_array()
 */
varargs object *filter_legal_tender(object money, string where) {
   mixed *m_array;
   object *monies;

   m_array = money->query_money_array();
   monies = filter_legal_money_array(m_array, where);

#ifdef USE_VAULT
   MONEY_VAULT->add_to_list(money);
#else
   money->move("/room/rubbish");
#endif

   return monies;
} /* filter_legal_tender() */


/**
 * This method is identical to filter_legal_tender, except that it takes
 * a money array rather than a money object
 * @param m_array the money array to get the legal tender from
 * @param where the money area the tender is for
 * @return an two element array of objects ({ legal, illegal })
 * @see parse_money()
 * @see filter_legal_tender()
 * @see filter_legal_money_to_array();
 */
varargs object *filter_legal_money_array(mixed *m_array, string where) {
   object good, no_good;
   mixed *money_arrays;

   money_arrays = filter_legal_money_to_array(m_array, where);

   if (sizeof(money_arrays[0]) == 0) {
      good = 0;
   } else  {
#ifdef USE_VAULT     
      good = MONEY_VAULT->get_money_ob();
#else
      good = clone_object(MONEY_OBJECT);
#endif
      good->set_money_array(money_arrays[0]);
   }

   if (sizeof(money_arrays[1]) == 0) {
      no_good = 0;
   } else  {
#ifdef USE_VAULT
     no_good = MONEY_VAULT->get_money_ob();
#else
     no_good = clone_object(MONEY_OBJECT);
#endif
     no_good->set_money_array(money_arrays[1]);
   }

   return ({ good, no_good });

} /* filter_legal_money_array() */


/**
 * This method is identical to filter_legal_money_array, except that it
 * returns an array of two money arrays rather than an array of two
 * money objects
 * @param m_array the money array to get the legal tender from
 * @param where the money area the tender is for
 * @return an two element array of money arrays ({ legal, illegal })
 * @see parse_money()
 * @see filter_legal_tender()
 * @see filter_legal_money_array()
 */
varargs mixed *filter_legal_money_to_array(mixed *m_array, string where) {
   int i;
   mixed *poss_values;
   mixed *good_array = ({ });
   mixed *no_good_array = ({ });


   if (sizeof(m_array) == 0) {
      return ({ ({ }), ({ }) });
   }
   if (!where || where == "") {
     where = "default";
   }
   if (!(poss_values = values[where])) {
      return ({ ({ }), copy(m_array) });
   }

   for (i = 0; i < sizeof(m_array); i += 2) {
      if (member_array(m_array[i], poss_values) != -1) {
         good_array += ({ m_array[i], m_array[i + 1] });
      } else {
         no_good_array += ({ m_array[i], m_array[i + 1] });
      }
   }

   return ({ good_array, no_good_array });

} /* filter_legal_money_to_array() */


/**
 * This method merges two money arrays together and returns the
 * merged array
 * @param m_array1 the first money array
 * @param m_array2 the second money_array
 * @return a money array of m_array1 and m_array2 joined
 */
mixed *merge_money_arrays(mixed *m_array1, mixed *m_array2)  {
   int i;
   int idx;
   mixed *new_m_array;

   if (!m_array1)
      m_array1 = ({ });
   if (!m_array2)
      m_array2 = ({ });

   /* Loop over smallest array for efficiency */
   if (sizeof(m_array1) < sizeof(m_array2))  {
      new_m_array = copy(m_array2);
      for (i = 0; i < sizeof(m_array1); i += 2)  {
         idx = member_array(m_array1[i], new_m_array);
         if (idx > -1)  {
            new_m_array[idx + 1] += m_array1[i + 1];
            if (new_m_array[idx + 1] <= 0)
               new_m_array = delete(new_m_array, idx, 2);
         }
         else
            new_m_array += ({ m_array1[i], m_array1[i + 1] });
      }
   }
   else  {
      new_m_array = copy(m_array1);
      for (i = 0; i < sizeof(m_array2); i += 2)  {
         idx = member_array(m_array2[i], new_m_array);
         if (idx > -1)  {
            new_m_array[idx + 1] += m_array2[i + 1];
            if (new_m_array[idx + 1] <= 0)
               new_m_array = delete(new_m_array, idx, 2);
         }
         else
            new_m_array += ({ m_array2[i], m_array2[i + 1] });
      }
   }
   return new_m_array;

} /* merge_money_arrays() */


/**
 * This method determines all the money from the player object and moves
 * it into a container.  It then figures out the legal tender for
 * specified money area and tells the player if the given money is
 * legal tender for the current area.  It will automatically return the
 * illegal tender and send a message to the player about it.
 * @param words the string to match the money on
 * @param player the player who is attempting the transaction
 * @param place the money area the transaction is taking place
 * @return a money object consisting of the legal tender
 * @see filter_legal_tender()
 */
varargs mixed parse_money(string words, object player, string place) {
   object  thing;
   object *monies;
   object *things;
   mixed  *m_array;
   mixed  *m_array2;
   int     i;
   int     adjust_flag;

   things = match_objects_for_existence(words, ({ player }));
   if (sizeof(things) == 0) {
      // If not here, try a money_array_from_string thing.
      m_array = money_array_from_string(words, place);
       if (sizeof(m_array) == 0) {
         return NO_MATCH;
      }
      // Now, check and see if the money exists.
      thing = present(MONEY_ALIAS, player);
      if (!thing) {
         return NO_MATCH;
      }
      for (i = 0; i < sizeof(m_array); i += 2) {
         if (thing->query_money(m_array[i]) < m_array[i + 1]) {
            return NO_MATCH;
         }
      }
      adjust_flag = 1;
   }
   else {
      things = filter(things, (: $1->query_property("money") :));
      if (sizeof(things) == 0)
         return NO_MONEY;
      adjust_flag = 0;

      m_array = ({ });
      foreach (thing in things) {
         m_array = merge_money_arrays(m_array, thing->query_money_array());
#ifdef USE_VAULT
         MONEY_VAULT->add_to_list(thing);
#else
         thing->move("/room/rubbish");
#endif
      }
   }

   monies = filter_legal_money_array(m_array, place);

   /* Illegal money */
   if(monies[1])  {
      tell_object(player, monies[1]->the_short() +
            (monies[1]->query_number_coins() == 1 ? " is" : " are") +  
            " not legal tender here.\n");
      m_array = monies[1]->query_money_array();

      /* Give back illegal money */
      if (!adjust_flag)
         this_player()->adjust_money(m_array);

#ifdef USE_VAULT
      MONEY_VAULT->add_to_list(monies[1]);
#else
      monies[1]->dest_me();
#endif
   }

   /* Legal money */
   if (monies[0])  {
      if (adjust_flag)  {
         m_array2 = copy(monies[0]->query_money_array());
         for (i = 0; i < sizeof(m_array2); i += 2)
            m_array2[i + 1] = -m_array2[i + 1];
   
         /* Deduct valid money */
         this_player()->adjust_money(m_array2);
      }

      return monies[0];
   }
   else  {
      return NO_LEGAL;
   }

} /* parse_money() */


/**
 * This method makes a payment from one person to another.
 * This method figures out what money should be given to the player
 * and what should be taken from the other to make a payment of the
 * correct value in the correct place.
 * @param value the value to pay
 * @param place the place to make the payment in
 * @param payer the person the money is payed from
 * @param payee the person the money is payed to
 * @return two element array, or 0 if it cannot be done
 */
mixed *query_person_payments(int value, string place,
                             object payer, object payee) {
   mixed *stuff;
   mixed *mon_array;
   mixed *rabbit;

   mon_array = copy(payer->query_money_array());
   stuff = make_money_array_payment( 0, value, mon_array, place, 0);
   if (!stuff) {
      return 0;
   }
   if (stuff[MONEY_PAY_CHANGE]) {
      /*
       * Ok, now check to see if we can get the change from the other
       * guy.
       */
      mon_array = copy(payee->query_money_array());
      rabbit = make_money_array_payment( 0, stuff[MONEY_PAY_CHANGE],
                                         mon_array, place, 0);
      if (!rabbit || rabbit[MONEY_PAY_CHANGE]) {
         return 0;
      }
      return ({ stuff[MONEY_PAY_RETURN], rabbit[MONEY_PAY_RETURN] });
   }
   return ({ stuff[MONEY_PAY_RETURN], ({ }) });
} /* query_person_payments() */

/**
 * This returns a list of valid coin types
 * @return an array of valid coin types
 */
string * query_valid_types(){
  mixed *tmp;
  string *elem, *valid_types = ({ });
  int i;
      
  tmp = values(query_all_values());
  foreach( elem in tmp ){ 
    for( i = 0; i < sizeof( elem ); i += 2 ){
      if ( stringp( elem[i] ) )
        valid_types += ({ elem[i] });
    }
  } return valid_types;
}/* query_valid_types() */

/**
 * This takes a coin type and returns the place it is associated with.
 * @param type the coin type i.e. "Ankh-Morpork dollar"
 * @return the place i.e. "Ankh-Morpork"
 */
string query_origin_of( string type ){
  string elem, *places;
  
  if( member_array( type, query_valid_types() ) == -1 )
    return 0;
  
  places = query_all_places();
  
  foreach( elem in places ){
    if( member_array( type,query_values_in( elem ) ) != -1 )
      return elem;
  }
}/* query_origin_of() */

/**
 * This converts a currency type's alias (i.e. "royal" ) and returns
 * its 'real' names (i.e. "Ankh-Morpork royal"
 * @param word the alias to find the real name of
 * @return an array of real names, or 0 if it's not a real alias
 */
string * query_aliases_of( string word ){
  string *types, elem, *aliases = ({ });
  
  types = query_valid_types();
  
  foreach( elem in types ){
    if( member_array( word,query_aliases_for( elem ) ) != -1 )
      aliases += ({ elem });
  } return aliases;
}/* query_alias_of */

/**
 *This returns the value of a currency type.
 * @param type currency type
 * @return an int of the currency type's value
 */
int query_value_of( string type ){
  if( member_array( type, query_valid_types() ) == -1 )
    return 0;
   return query_value( type, query_origin_of( type ) );
}/* query_value_of() */


/**
 * This returns the smallest unit of currency in this place.
 * @param place The place to query.
 * @return A string of the smallest unit of currency
 * @see smallest_value_in()
 */
string smallest_in( string place ) {
   int i, smallest, r;
   mixed *values;

   values = query_values_in( place );
   smallest = values[1];
   r = 1;
   for ( i = 3; i < sizeof( values ); i += 2 ) {
      if ( values[i] < smallest ) {
         smallest = values[i];
         r = i;
      }
   }
   return values[r-1];
}
/* smallest_in() */


/**
 * This returns the smallest value of currency in this place.
 * @param place The place to query.
 * @return the value of the smallest unit of currency
 * @see smallest_in()
 */
int smallest_value_in( string place ) {
   int i, smallest;
   mixed *values;

   values = query_values_in( place );
   smallest = values[1];
   for ( i = 3; i < sizeof( values ); i += 2 ) {
      if ( values[i] < smallest ) {
         smallest = values[i];
      }
   }
   return smallest;
}
/* smallest_value_in() */


/**
 * This method returns the values in the specified area.
 * It contains name, value pairs and is for the "default"
 * area.  It is returned as a mapping for easier sorting
 * & manipulation.
 * @param where the area in which to return the values for
 * @see query_all_values()
 * @see query_values()
 * @see add_type()
 * @see query_values_in()
 */
mapping query_mapped_values_in( string where ) {
   mapping values = ([]);
  mixed * array;
  int i;

   if ( !where || ( where == "" ) )
      where = "default";
  array = query_values_in(where);
   for ( i = 1; i < sizeof(array); i += 2 )
  {
      values += ([array[i-1]:array[i]]);
   }
   return values;
} /* query_mapped_values_in() */
// --- END [/mnt/home2/grok/lib/obj/handlers/money_handler.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/state_change.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/state_change.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628400   Available: 13575754
Inodes: Total: 5242880    Free: 4960134
5313 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/state_change.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628400   Available: 13575754
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: state_change.c,v 1.4 2002/09/30 14:07:19 terano Exp $
 * $Log: state_change.c,v $
 * Revision 1.4  2002/09/30 14:07:19  terano
 * Added some extra functionality in the form of a third arg to transform.
 *
 * Revision 1.3  2002/09/19 19:51:39  tilly
 * Added a check for collective objects along with the continuous, as collective obs were getting fucked up amounts set.
 *
 * Revision 1.2  1998/11/14 05:00:52  jeremy
 * Added autodoc stuff.
 *
 * Revision 1.1  1998/01/06 05:03:33  ceres
 * Initial revision
 * 
 */
/**
 * This handler is meant to simulate the changing of an object's
 * "state", such as melting, grinding, etc.  In reality, rather than
 * changing the source object, the transform() method clones a
 * completely new object, based on the internal lookup table; it is
 * the caller's responsibility to dest the source object and put the
 * new one in its place.
 * <p>
 * The handler's lookup table is stored in a series of files:
 * any files in /obj/state_change ending in .dat will be added
 * to the table when the handler is loaded.  See /include/state_change.h
 * for field definitions.  The data files are loaded by the data
 * handler, and can contain fancy things like expressions and function
 * pointers.
 * @author Jeremy
 * @see /include/state_change.h
 * @see /obj/handlers/data.c
 */

#include <state_change.h>

#define PROP "state name"
// I can't think of anyplace good to put this
#define DATA_DIR "/obj/state_change/"

mapping table = ([ ]);

void set_amount_of_ob( object ob, int amount );

/**
 * This method returns the entire lookup table.  It is mainly for
 * debugging.
 * @return the state_change lookup table
 */
mixed query_table() { return table; }

/** @ignore yes */
void create() {
    string *files;
    int i;

    seteuid("/secure/master"->creator_file(file_name(this_object())));
    files = ({ "base.hdr" });
    files += get_dir(DATA_DIR + "*.dat");
    for (i = 0; i < sizeof(files); i++) {
        files[i] = DATA_DIR + files[i];
    }
    table += "/obj/handlers/data"->compile_data(files);
} /* create() */

// TODO: this should be able to clone and return an array of objects.
// TODO: being able to pass in an argument for the func field would be nice.
/**
 * This method is generally called by the object doing the state
 * change (e.g., a food grinder).  It looks up the specified source
 * object in the table and clones the "transformed" object as specified.
 * <p>
 * The table is indexed by the source object as follows: if the source
 * object has a property "state name", the value of this is used.  If
 * not, the object's medium alias (if any, regardless of whether the
 * object is continuous) is used.  Failing these, the object's short
 * description is used.  The first one resulting in a valid string is
 * concatenated with the transformation string (with a ":" between)
 * and the result is used as the index.  If the lookup fails, 0 is
 * returned.
 * <p>
 * Note that the resulting object is only cloned.  It is the responsibility
 * of the caller to dest the source and put the result in its place.
 * @param ob the source object
 * @param transformation a string specifying the transformation (e.g., "grind")
 * @param The player to whom this state change will be attributed to! [optional]
 * @return the result of the transformation */
varargs object transform( object ob, string transformation, object player ) {
    string index, name;
    object ret;
    class state_change c;
    function f;
    int *weight_unit;

    // First try a property
    if (!stringp(name = ob->query_property(PROP)))
      // Next see if it has a medium alias (this would be the norm)
      if (!stringp(name = ob->query_medium_alias()))
        // Finally, use the short
        name = ob->short();

    if ( !player )
      player = this_player();
    
    index = transformation + ":" + name;
    if (undefinedp(table[index]))
      return 0;
    c = table[index];
    ret = clone_object(c->result);

    foreach (f in c->func)
      evaluate(f, ob, ret, player);

    if (ret->query_continuous()) {
        if ( ob->query_continuous() || ob->query_collective() ) {
            ret->set_amount(to_int(ob->query_amount() * c->factor));
        } else {
            weight_unit = ret->query_weight_unit();
            set_amount_of_ob( ret, to_int( ob->query_weight() * c->factor *
              weight_unit[1] / weight_unit[0] ) );
        }
    } else {
        if ( ob->query_continuous() || ob->query_collective() ) {
            weight_unit = ob->query_weight_unit();
            ret->set_weight(to_int(ob->query_amount() * c->factor *
                                   weight_unit[0] / weight_unit[1]));
        } else {
            ret->set_weight(to_int(ob->query_weight() * c->factor));
        }
    }
    log_file( "STATE_CHANGE", "Changed %d amount of %s to %d amount of %s via %s.\n", 
      ob->query_amount(), ob->query_medium_alias(), ret->query_amount(), 
      ret->query_medium_alias(), transformation );
    return ret;
} /* transform() */

/**
 * @ignore
 * Helper function to ensure 0 amount cont obs are destroyed.
 */
void set_amount_of_ob( object ob, int amount ) {
  if ( !ob ) 
      return;

  if ( !amount )
      ob->dest_me();

  ob->set_amount( amount );
  return;
}

// --- END [/mnt/home2/grok/lib/obj/handlers/state_change.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/title_handler.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/title_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628398   Available: 13575752
Inodes: Total: 5242880    Free: 4960134
4487 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/title_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628398   Available: 13575752
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This handler will keep track of special player titles.  It will allow
 * them to be added or removed based on specific events.  Use the
 * include <player.h> to get the path to this file.
 * @author Pinkfish
 * @started Wed Sep 27 14:00:31 PDT 2000
 */
#include <login.h>

private mapping _pending;
private mapping _titles;
private nosave string* _allowed_multiple;

#define SAVE_FILE "/save/titles"

void load_me();
void save_me();

class blob {
   string ob;
   string func;
}

void create() {
   _pending = ([ ]);
   _titles = ([ ]);
   load_me();

   //
   // List of titles you can use with others...  (Like adjectives).
   //
   _allowed_multiple = ({ "very reverend", "mostly reverend",
                          "reverend mother", "mad granny",
                          "mad nanny", "mad mr", "mad ms", "mad miss",
                          "mad mrs" });
} /* create() */

/**
 * This method checks to see if the title is an allowed multiple title.
 * @param title the title to check
 * @return 1 if it is allowed, 0 if not
 */
int is_allowed_multiple_title(string title) {
   return member_array(lower_case(title), _allowed_multiple) != -1;
} /* is_allowed_multiple_title() */

/**
 * This method returns the list of allowed multiple titles.
 * @return the list of allowed multiple titles
 */
string* query_allowed_multiple_titles() {
   return _allowed_multiple;
} /* query_allowed_multiple_titles() */

/**
 * This method adds a person to the pending list for gaining a specific
 * title.  If the person is currently on then they will get the title
 * immediately.  If they are not on then it will be added to them when they
 * next log on.
 * @param person the person to give the title too
 * @param title the title to give them
 */
void add_title_to_player(string person, string title) {
   object ob;

   ob = find_player(person);
   if (ob) {
      ob->add_player_title(title);
      return ;
   }

   if (!_pending[person]) {
      _pending[person] = ({ });
   }
   _pending[person] += ({ title });
   save_me();
} /* add_title_to_player() */

/**
 * This method returns the list of titles pending for the specific person.
 * @param person the person to get the titles for
 * @return the array of pending titles
 */
string* query_pending_titles(string person) {
   if (_pending[person]) {
      return _pending[person];
   }
   return ({ });
} /* query_pending_titles() */

/**
 * Add a method to be called to check if the person is allowed to have
 * the specified title.  This should be added to control things like
 * special titles.
 * @example
 * add_controlled_title("magistrate", NOMIC_HANDLER, "is_magistrate_somewhere");
 * @param title the title to control
 * @param ob the object to call the method on
 * @param function the function to call
 */
void add_controlled_title(string title, string ob, string func) {
   class blob fluff;

   fluff = new(class blob);
   fluff->ob = ob;
   fluff->func = func;
   _titles[title] = fluff;
   save_me();
} /* add_controlled_title() */

/**
 * This method returns the blob for the controlled title.
 * @param title the title which is controlled
 * @return the blob for the controlled title
 */
protected class blob query_controlled_title(string title) {
   return _titles[title];
} /* query_controlled_title() */

/**
 * This method checks a player when they logon for titles.
 * @param player the player to check
 */
void check_player(object player) {
   string* titles;
   string title;

   if (!player) {
      return ;
   }
   if (_pending[player->query_name()]) {
      foreach (title in _pending[player->query_name()]) {
         player->add_player_title(title);
      }
      map_delete(_pending, player->query_name());
      save_me();
   }
   titles = player->query_all_player_titles();
   foreach (title in titles) {
      if (_titles[title]) {
         if(!find_object(_titles[title]->ob) ||
            !call_other(_titles[title]->ob, _titles[title]->func,
                        player->query_name())) {
           player->remove_player_title(title);
         }
      }
   }
} /* check_player() */

/** @ignore yes */
void login_handler_call(string person, string type) {
   if (type == LOGIN) {
      call_out((: check_player(find_player($1)) :), 2, person);
   }
} /* login_handler_call() */

/** @ignore yes */
void save_me() {
   unguarded((: save_object(SAVE_FILE) :));
} /* save_me() */

/** @ignore yes */
void load_me() {
   unguarded((: restore_object(SAVE_FILE, 1) :));
} /* load_me() */
// --- END [/mnt/home2/grok/lib/obj/handlers/title_handler.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/group_handler.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/group_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628397   Available: 13575751
Inodes: Total: 5242880    Free: 4960134
24740 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/group_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628397   Available: 13575751
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is the group handler.  It does all the handling of
 * player-run adventuring groups, but not alone.  It's
 * accompanied by the group commands, effect and shadow.
 * For paths to these files, consult /include/group_handler.h
 *
 * This system owes its design first and foremost to the irreplaceable
 * Ceres who wrote the original system.  Next come all the valuable
 * Creators who shared their knowledge of LPC.  Last but not least
 * are the countless playtesters who dedicated their time and worked
 * out all (or most of) the kinks and provided feedback and suggestions.
 *
 * So give 'em all a big hug.
 *
 * @author Tape
 * @started February 99
 */

#include <group_handler.h>
#include <broadcaster.h>
#include <login_handler.h>

int _loaded;
int _groups_formed;

mapping _groups;

class group
{
   int start_time;               // Time() when group was created
   string short;                 // Group's short description
   string leader_name;           // Group's leader's name
   object leader;                // Group's leader
   object *members;              // Group's members
   object *invited;              // People invited to group
}


int is_group( string group );
int is_member( string name, object person );
int is_invited( string name, object person );
object *invitations_to( string name );
string query_group_short( string name );
object *members_of( string name );
object leader_of( string name );
string short_to_name( string short );
int create_group( string name );
int remove_group( string name );
int add_invite( string name, object person, int flag );
int remove_invite( string name, object person );
int add_member( string name, object person );
int remove_member( string name, object person );
varargs int set_leader( string name, object person, object appointer );
void notify_group( string name, object broadcaster, mixed message );
varargs void disband_group( string name, mixed message );
varargs object shuffle_new_leader( string group, int way, object *exclude );
void leader_goes_linkdead( string player, string event_type );
void handle_group_follow( string group, object who, object *what,
   int unfollow, int silent );
void broadcast_to_groups( string *name, string message );
string *query_groups();
int set_group_short( string, string);

/** @ignore yes */
void create()
{
   _groups = ([ ]);
   _loaded = time();
   _groups_formed = 0;
} /* create() */


/** @ignore yes */
void dest_me() {

   string name;

   broadcast_to_groups( 0, "%^BOLD%^WARNING%^RESET%^: The group handler is being destructed."
      "  All active groups will be disbanded.  It should be possible to "
      "recreate the group almost immediately afterwards.  If not, please "
      "file a bug report for the \"group\" command." );
      
   foreach( name in query_groups() ) {
      disband_group( name, 0 );
   }

} /* dest_me() */


/** @ignore yes */
void stats_please() {
   printf( "The handler was loaded on %s.  Since then, "
      "%i groups have been formed.\n", ctime( _loaded ),
      _groups_formed );
} /* stats_please() */


/**
 * This returns the names of all groups currently in the database.
 * @return the names of all groups in database
 */
string *query_groups() {
   return keys( _groups );
} /* query_groups() */


/**
 * This function checks if such a group exists at the moment.
 *
 * @param group the name of the group
 * @return 1 if the group exists, 0 otherwise
 */
int is_group( string group ) {
   return !undefinedp( _groups[ group ] );
} /* is_group() */


/**
 * This function allows you to check whether a person is a member
 * of a group.
 *
 * @param name the name of the group
 * @param person the person you want to check for membership
 *
 * @return 1 if he is a member, 0 if he isn't (or the group doesn't exist)
 *
 */
int is_member( string name, object person ) {

   if( !is_group( name ) ) {
      return 0;
   }
   
   if( member_array( person, _groups[ name ]->members ) == -1 ) {
      return 0;
   }

   return 1;

} /* is_member() */


/**
 * This function allows you to check whether an invitation for a
 * person is pending in a specific group.
 *
 * @param name the name of the group
 * @param person the person to be checked
 *
 * @return 1 if such an invitation exists, 0 if not
 */
int is_invited( string name, object person )
{
   if( member_array( person, _groups[ name ]->invited ) != -1 )
   {
      return 1;
   }
   
   return 0;
} /* is_invited() */


/**
 * This function lists all invitations to a particular group.
 * @param name the name of the group
 * @return objects who have been invited to the group
 */
object *invitations_to( string name )
{
   if( !is_group( name ) )
   {
      return 0;
   }

   return _groups[ name ]->invited;
} /* invitations_to() */


/**
 * This returns the short description of a group.
 * @param name the name of the group
 * @return the short of the group
 */
string query_group_short( string name )
{
   if( !is_group( name ) )
   {
      return 0;
   }
   return _groups[ name ]->short;
} /* query_group_short() */


/**
 * This function returns all the members of a group.
 * @param name the name of the group
 * @return an object * of the members
 */
object *members_of( string name )
{
   
   if( !is_group( name ) )
   {
      return 0;
   }
   
   return _groups[ name ]->members;
} /* members_of() */


/**
 * This function returns the person who is currently
 * leading the group, if any.
 *
 * @param name the name of the group
 * @return the object pointing to the leader, 0 if none
 */
object leader_of( string name )
{
   if( !is_group( name ) )
   {
      return 0;
   }
   return _groups[ name ]->leader;
} /* leader_of() */


/**
 * This function returns the time when the group was created.
 * @param name the name of the group
 * @return the time when the group was created
 */
int query_start_time( string name )
{
   if( !is_group( name ) )
   {
      return 0;
   }
   return _groups[ name ]->start_time;
} /* query_start_time() */


/**
 * This function concatenates the short of a group to a valid name
 * that can then be used with create_group().  The function will
 * also return invalid if a channel with such a name exists in the
 * broadcaster.
 *
 * @param short the short of the group
 * @return the name of the group, or "" if invalid
 */
string short_to_name( string short )
{
   
   string *words;
   
   short = lower_case( short );   
   words = explode( short, " " );
   words -= INVALID_WORDS;
   
   if( !sizeof( words ) ) {
      return "";
   }

   short = implode( words, " " );

   if( BROADCASTER->query_channel_members( "group_" + short ) ) {
      return "";
   }   
   
   return short;

} /* short_to_name() */

   
/**
 * This function allows you to create a new group.  Note that the
 * name of the group shouldn't be just any name.  It should first
 * be filtered through short_to_name().  The short, set with
 * set_group_short() can be set to anything.  The "name" of a
 * group is mostly used internally to query and set stuff in
 * the handler.  The short is visible to players.
 *
 * @param name the name of the new group
 * @param founder points to the thing creating the group
 *
 * @see short_to_name()
 * @see set_group_short()
 *
 * @return 1 on success, 0 if the group already exists
 */
int create_group( string name )
{
   if( is_group( name ) ) {
      return 0;
   }
   
   _groups += ([ name : new( class group ) ]);
   
   _groups[ name ]->members = ({ });
   _groups[ name ]->invited = ({ });
   _groups[ name ]->start_time = time();

   // For stats.
   _groups_formed++;
   
   return 1;
   
} /* create_group() */

/**
 * This method renames the group.
 * @param group the old group name
 * @param new_group the new group name
 */
int rename_group(string group, string new_group) {
   object member;

   if (is_group(new_group) || new_group == group) {
      return 0;
   }

   _groups[new_group] = _groups[group];
   map_delete(_groups, group);
   set_group_short(new_group, new_group);
   foreach (member in _groups[new_group]->members) {
      if (!member) {
         continue;
      }
      // Remove the old group stuff.
      BROADCASTER->remove_object_from_channel( "group_" + group, member );

      member->group_membership_removed();

      member->add_effect( EFFECT, new_group);

      // Add him to his group's channel.

      BROADCASTER->add_object_to_channel( "group_" + new_group, member );

      member->set_title( GROUP_TITLE, "a member of " +
      query_group_short( new_group ) );

   }
   notify_group( new_group, this_object(), ({ "", "The group has been renamed to " +
      new_group + "." }) );
   return 1;
}


/**
 * This sets the short description of a group.
 *
 * @param name the name of the group
 * @param short_desc the short of the group
 *
 * @return 1 on success, 0 if group doesn't exist
 */
int set_group_short( string name, string short_desc )
{
   if( !is_group( name ) ) {
      return 0;
   }
   _groups[ name ]->short = short_desc;
   return 1;
} /* set_group_short() */


/**
 * This function removes a group from the handler and is only used
 * internally.  No notification of this is given to players, and
 * no cleanup is done on their part.
 * If you want to force the deletion of a group, use disband_group()
 * instead.
 *
 * @param name name of the group to be disbanded
 * @return 1 on success, 0 if group doesn't exist
 * @see disband_group()
 */
int remove_group( string name )
{
   if( !is_group( name ) ) {
      return 0;
   }
   
   if( _groups[ name ]->leader_name ) {
      LOGIN_HANDLER->remove_login_call(
         _groups[ name ]->leader_name, "leader_goes_linkdead",
         this_object() );
   }
   
   map_delete( _groups, name );
   
   return 1;
} /* remove_group() */


/**
 * This function allows you to add a person to the invite array
 * of a group.  Only invited people are allowed to join a group.
 * If the call succeeds, an internal call_out is started which
 * runs out after INVITE_TIMEOUT seconds and removes the person
 * from the array.
 *
 * @param name the name of the group
 * @param person the person we're inviting
 * @param flag set to 1 if you don't want the auto-removal of the invite
 *
 * @return 1 on success, 0 if the group doesn't exist or the person is
 *    already invited
 *
 * @see /include/group_handler.h
 */
int add_invite( string name, object person, int flag )
{
   
   if( !is_group( name ) )
   {
      return 0;
   }
   
   if( is_member( name, person ) ) 
   {
      return 0;
   }
   
   if( member_array( person, _groups[ name ]->invited ) != -1 ) 
   {
      return 0;
   }
   
   _groups[ name ]->invited += ({ person });
      
   if( !flag ) 
   {
      call_out( (: remove_invite, name, person :), INVITE_TIMEOUT );
   }
   
   return 1;
} /* add_invite() */


/**
 * This function allows you to remove an invite of a person from
 * a group.
 *
 * @param name the name of the group
 * @param person the person you want to remove
 *
 * @return 1 on success, 0 if group doesn't exist or person hasn't been
 *    invited
 */
int remove_invite( string name, object person ) 
{

   if( !is_group( name ) ) 
   {
      return 0;
   }
   
   if( !is_invited( name, person ) ) 
   {
      return 0;
   }
   
   _groups[ name ]->invited -= ({ person, 0 });
   
   return 1;
   
} /* remove_invite() */


/**
 * This function allows you to add a member to a group.
 *
 * @param name the name of the group
 * @param person the person you're adding
 * @return 1 on success, 0 if the group doesn't exist or person is
 *    already a member
 */
int add_member( string name, object person ) 
{
   if( !is_group( name ) ) 
   {
      return 0;
   }
   
   if( is_member( name, person ) ) 
   {
      return 0;
   }
    
   _groups[ name ]->members += ({ person });
   _groups[ name ]->invited -= ({ person });
   
   // Add the group effect.
   
   person->add_effect( EFFECT, name );
   
   // Add him to his group's channel.
   
   BROADCASTER->add_object_to_channel( "group_" + name, person );
   
   notify_group( name, person, ({ "You have joined the group.",
      person->query_cap_name() + " has joined the group." }) );

   if( sizeof( _groups[ name ]->members ) > 1 )
   {
      handle_group_follow( name, person, ({ _groups[ name ]->leader }), 0, 0 );
   }

   person->set_title( GROUP_TITLE, "a member of " +
      query_group_short( name ) );
      
   return 1;
   
} /* add_member() */


/**
 * This function allows you to remove a person from a group.
 *
 * @param name the name of the group
 * @param person the person you want removed
 *
 * @return 1 on success, 0 if group doesn't exist or person isn't a
 *    member
 */
int remove_member( string name, object person )
{

   object member;

   if( !is_group( name ) )
   {
      return 0;
   }
   
   if( !is_member( name, person ) )
   {
      // Not a member.
      return 0;
   }
   
   if( person )
   {

      notify_group( name, person, ({
         "You have left the group.",
      person->query_cap_name() + " has left the group." }) );   
      
      foreach( member in person->query_assisting() )
      {

         // Stop assisting members.
         
         if( !member )
         {
            continue;
         }
         
         member->remove_assister( person );
      }

      foreach( member in person->query_assisters() )
      {
      
         // Stop being assisted.
         
         if( !member )
         {
            continue;
         }
         
         member->remove_assisting( person );
      }
      
   }

   _groups[ name ]->members -= ({ person });

   // Stop listening to the group's channel.
   
   BROADCASTER->remove_object_from_channel( "group_" + name, person );
   
   if( person )
   {
      // Delete the effect.
      person->group_membership_removed();
   }

   if( person == leader_of( name ) && sizeof( members_of( name ) ) )
   {

      // If the person was the leader, assign a new one.

      if (sizeof(members_of(name)) == 1) {
         notify_group( name, this_object(), "The current leader has left "
            "the group, you are now all alone.  Better start recruiting.");
      } else {
         notify_group( name, this_object(), "The current leader has left "
            "the group.  A new leader will be chosen randomly." );
      }

      if( !shuffle_new_leader( name, 0 ) )
      {
         // Couldn't find a suitable new leader (which really shouldn't
         // happen unless everyone is net dead, afaik).
         
         notify_group( name, this_object(), "The choosing of a new "
            "leader has failed (oh dear).  The group is hereby "
            "disbanded.\n" );

         call_out( "disband_group", 0, name );

         return 1;
      }
   }

   // Stop following everyone.
   
   handle_group_follow( name, person, _groups[ name ]->members, 1, 1 );

   foreach( member in _groups[ name ]->members ) {

      // Make sure people stop following you.

      handle_group_follow( name, member, ({ person }), 1, 1 );
   }

   // Remove the "whois" title.
   if (person && objectp(person)) { 
      person->remove_title( GROUP_TITLE );
   }
      
   // If the group's empty, remove it altogether.
   
   if( !sizeof( members_of( name ) ) ) {
      remove_group( name );
   }

   return 1;

} /* remove_member() */


/**
 * This function allows you to set a new leader for the group.
 *
 * @param name the name of the group
 * @param person the new leader
 * @param appointer if this != 0, group is told he set the new leader
 *
 * @return 1 on success, 0 if the group doesn't exist
 */
varargs int set_leader( string name, object person, object appointer )
{

   object *followers, old_leader, member;
   
   if( !is_group( name ) )
   {
      return 0;
   }
   
   if( !is_member( name, person ) )
   {
      return 0;
   }
   
   if( !person )
   {
      return 0;
   }
   
   if( _groups[ name ]->leader_name )
   {
      LOGIN_HANDLER->remove_dynamic_login_call(
         _groups[ name ]->leader_name, "leader_goes_linkdead",
         base_name( this_object() ) );
   }

   old_leader = _groups[ name ]->leader;
   
   if( old_leader )
   {
      
      // Those who were following the old leader will now follow the new
      // leader.
      
      followers = ( old_leader->query_followers() & _groups[ name ]->members );
      followers -= ({ 0 });
      followers += ({ old_leader });
      
      foreach( member in followers )
      {
         handle_group_follow( name, member, ({ old_leader }), 1, 1 );
         handle_group_follow( name, member, ({ person }), 0, 1 );
      }
      
      // Set the title back to "only" a member.
      
      old_leader->set_title( GROUP_TITLE, "a member of " +
         query_group_short( name ) );
   }
   
   _groups[ name ]->leader = person;

   if( userp( person ) ) {
      _groups[ name ]->leader_name = person->query_name();
      LOGIN_HANDLER->add_dynamic_login_call( person->query_name(),
         "leader_goes_linkdead", base_name( this_object() ) );
   }
   else
   {
      // How can a non-user become the leader?  Beats me, but I'm paranoid.
      _groups[ name ]->leader_name = 0;
   }
   
      
   if( !appointer )
   {
      notify_group( name, person, ({ "You are now the leader of "
         "the group.", person->query_cap_name() + " is now the leader "
         "of the group." }) );
   }
   else
   {
      notify_group( name, appointer, "By the power vested in " +
         appointer->query_cap_name() + ", " + person->query_cap_name() +
         " has been appointed as the new leader of the group." );
   }

   person->set_title( GROUP_TITLE, "the leader of " +
      GROUP->query_group_short( name ) );

   return 1;
} /* set_leader() */


/**
 * This function broadcasts a message to the group's channel using
 * the broadcaster handler.  The first argument specifies the
 * group's name (not short), which also acts as the channel
 * name.  The second argument is the object doing the broadcasting.
 * The third argument varies.  It can either be a simple string,
 * in which case that string is printed as the message.  It can
 * also be a two-element string array.  The first element is
 * printed only to the object specified in the second argument.
 * The second element is printed to everyone else.
 *
 * @param name the name of the group
 * @param object person or object doing the broadcasting
 * @param message the message to be broadcasted
 *
 */
void notify_group( string name, object broadcaster, mixed message ) {
   BROADCASTER->broadcast_to_channel( broadcaster, "group_" + name,
      ({ message, time() }) );
} /* notify_group() */


/**
 * This function does a clean removal of a group from the handler.
 * If a message is specified, it is broadcasted to the group
 * before all members are removed.
 *
 * @param name the name of the group to be disbanded
 * @param message message to be broadcasted, if any
 * @see remove_group()
 */
varargs void disband_group( string name, mixed message ) {

   object bugger, leader, *members;

   if( !is_group( name ) ) {
      return;
   }
   
   if( message ) {   
      notify_group( name, this_object(), message );
   }
   
   members = members_of( name );
   leader = leader_of( name );
   
   if( leader ) {
      members -= ({ leader });
   }
   
   foreach( bugger in members ) {
      remove_member( name, bugger );
   }
   
   remove_member( name, leader );
   
   remove_group( name );
   
} /* disband_group() */


/**
 * This function allows you to choose a new leader for the group
 * in a variety of ways.  It only includes players who are
 * interactive().
 *
 * @param group the name of the group
 * @param way 0 for random (no other ways present atm)
 * @param exclude an object array of members to exclude from the start
 * @return an object pointing to the new leader, or 0
 */
varargs object shuffle_new_leader( string group, int way, object *exclude ) {
      
   object leader;
   object *members;
   
   if( !is_group( group ) ) {
      return 0;
   }
   
   members = members_of( group );
   
   if( !sizeof( members ) ) {
      return 0;
   }
   
   if( exclude ) {
      members -= exclude;
   }
   
   members = filter( members, (: $1 && interactive( $1 ) :) );

   if( !sizeof( members ) ) {
      return 0;
   }

   switch( way ) {
      case 0:
         leader = members[ random( sizeof( members ) ) ];
         if( set_leader( group, leader ) ) {
            return leader;
         }
         return 0;
      default:
         return 0;
   }
   
} /* shuffle_new_leader() */


// Caution: The following function contains undocumented, convoluted code.
//          Browse at your own risk.

/** @ignore yes */
void leader_goes_linkdead( string player, string event_type ) {

   string group;
   object player_ob, *members;

   // This function only takes care of leader reassignment when
   // the current leader goes netdead.  Quitting or otherwise
   // destructing is taken care of in the shadow.  Don't ask me
   // why, I'm just lazy.

   if( event_type != NETDEATH && event_type != RECONNECT ) {
      LOGIN_HANDLER->remove_dynamic_login_call( player,
         "leader_goes_linkdead", base_name( this_object() ) );
      return;
   }
   
   if( !player_ob = find_player( player ) ) {
      LOGIN_HANDLER->remove_dynamic_login_call( player,
         "leader_goes_linkdead", base_name( this_object() ) );
      return;
   }
   
   group = player_ob->query_group();
   
   if( !group ) {
      LOGIN_HANDLER->remove_dynamic_login_call( player,
         "leader_goes_linkdead", base_name( this_object() ) );
      return;
   }
      
   if( _groups[ group ]->leader_name != player ) {
      // Well that was weird.  A login call should only be added for
      // the current leader.
      LOGIN_HANDLER->remove_dynamic_login_call( player,
         "leader_goes_linkdead", base_name( this_object() ) );
      return;
   }
   
   members = members_of( group );
   members -= ({ player_ob });
   
   if( !sizeof( members ) ) {
      // Looks like a one-man group.  Let's wait until he wakes up.
      return;
   }

   LOGIN_HANDLER->remove_dynamic_login_call( player,
      "leader_goes_linkdead", base_name( this_object() ) );

   notify_group( group, this_object(), "The current leader "
      "has gone netdead.  A new leader will be selected at random." );
   
   if( !shuffle_new_leader( group, 0, 0 ) ) {
      notify_group( group, this_object(), "No eligible leaders "
         "found.  The group is disbanded." );
      disband_group( group );
   }
   
} /* leader_goes_linkdead() */


/** @ignore */
void handle_group_follow( string group, object who, object *what,
   int unfollow, int silent ) {

   string short, mess_to_me, mess_to_others;
      
   switch( unfollow ) {
      case 0:
         what = filter( what, (: $1->add_follower( $( who ) ) :) );
         if( !sizeof( what ) ) {
            mess_to_me = "You begin following noone.";
            break;
         }
         short = query_multiple_short( what );
         mess_to_me = "You begin following " + short + ".";
         mess_to_others = who->query_cap_name() + " begins following " +
            short + ".";
         break;

      case 1:
         what = filter( what, (: $1->remove_follower( $( who ) ) :) );
         if( !sizeof( what ) ) {
            mess_to_me = "You stop following noone.";
            mess_to_others = 0;
            break;
         }
         short = query_multiple_short( what );
         mess_to_me = "You stop following " + short + ".";
         mess_to_others = who->query_cap_name() + " stops following " +
            short + ".";
         break;
      default:
         printf( "Barf.\n" );
         return;
   }

   if( !silent ) {
      notify_group( group, who, ({ mess_to_me, mess_to_others }) );
   }
   
} /* handle_group_follow() */


/**
 * With this function you can broadcaster a message to all or
 * some of the groups currently active.  It will not include
 * your name, so make sure you identify yourself if necessary.
 *
 * If "name" is empty or 0, the message will be broadcasted
 * to all groups.
 *
 * @param name a string array with names of groups
 * @message the message to be broadcasted
 */
void broadcast_to_groups( string *name, string message ) {
   
   string group;
   string *groups;
   
   if( name && sizeof( name ) ) {
      groups = name;
   }
   else {
      groups = keys( _groups );
   }
   
   foreach( group in groups ) {
      notify_group( group, this_player(), message );
   }

} /* broadcast_to_groups() */


mapping query_dynamic_auto_load() {
   return ([ "groups" : _groups,
             "groups formed" : _groups_formed ]);
}

void init_dynamic_arg(mapping map) {
   _groups = map["groups"];
   _groups_formed = map["groups formed"];
}
// --- END [/mnt/home2/grok/lib/obj/handlers/group_handler.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/monster_handler.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/monster_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628391   Available: 13575745
Inodes: Total: 5242880    Free: 4960134
944 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/monster_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628391   Available: 13575745
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: monster_handler.c,v 1.3 1999/06/22 01:53:32 ceres Exp $
 * $Log: monster_handler.c,v $
 * Revision 1.3  1999/06/22 01:53:32  ceres
 * No idea why this thing is counting, but now it saves its count less frequently
 *
 * Revision 1.2  1998/05/10 14:52:34  pinkfish
 * Added in documentation.
 *
 * Revision 1.1  1998/01/06 05:03:33  ceres
 * Initial revision
 * 
*/
/**
 * This handler is used for the (now obsolette) monster action code.
 * Please see the effects code instead.
 * @author Pinkfish
 */

int num;

void create() {
  seteuid("Room");
  unguarded((: restore_object, "/save/monster-handler" :));
} /* create() */

/** @ignore yes */
string query_shadow_name() {
  num++;
  return "/tmp/mon-shad/frog-"+num;
} /* query_shadow_name() */

void reset() {
  unguarded((: save_object, "/save/monster-handler" :));
}

void dest_me() {
  unguarded((: save_object, "/save/monster-handler" :));
}
// --- END [/mnt/home2/grok/lib/obj/handlers/monster_handler.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/non_refuelling_lantern.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/non_refuelling_lantern.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628390   Available: 13575744
Inodes: Total: 5242880    Free: 4960134
3239 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/non_refuelling_lantern.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628390   Available: 13575744
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*      
  Basic lantern inherit to use till the new improved and nifty one is 
  made by someone else.
*/
#include <fuel_handler.h>

inherit "/std/object";

#define BRIGHTNESS      60
#define FUEL_PER_TICK  FUEL_TIME
#define MAX_FUEL 3600
 
/*
    Global variables.
*/
int  fuel_left;
int  is_lit;
 
void create(){
  ::create();

}

string short( int i ) {
  if ( is_lit )
    return ::short( 0 ) + " (lit)";
 
  return ::short( 0 );
}
 
int do_extinguish() {
   if ( !is_lit ) {
      this_player()->add_failed_mess(this_object(), "$D is not lit.\n", ({ }));
      return 0;
   }
   FUEL_HANDLER->remove_burner( this_object() );
   is_lit = 0;
   set_light( 0 );
   return 1;
} /* dest_me() */

int do_dowse() {
   return do_extinguish();
} /* do_dowse() */
 
int do_light() {
   if ( is_lit ) {
      this_player()->add_failed_mess( this_object(), "$D is already lit.\n",
                                     ({ }) );
      return 0;
   }
   if ( fuel_left <= 0 ) {
      this_player()->add_failed_mess( this_object(), "$D is out of fuel.\n",
                                     ({ }) );
      return 0;
   }
   FUEL_HANDLER->add_burner( this_object() );
   is_lit = 1;
   set_light( BRIGHTNESS );
   return 1;
}

void init() {
   this_player()->add_command("light", this_object());
   this_player()->add_command("extinguish", this_object());
   this_player()->add_command("dowse", this_object());
}

void out_of_fuel() {
   object env;
 
   is_lit    = 0;
   fuel_left = 0;
   env = environment( this_object() );
   FUEL_HANDLER->remove_burner( this_object() );
   set_light( 0 );

   if ( interactive( env ) ) {
      write( poss_short() +" burns out.\n" );
      tell_room( environment(env), poss_short() +" burns out.\n", env );
   } else 
      say( poss_short() +" burns out.\n" );
} /* out_of_fuel() */
 
void consume_fuel() {
   fuel_left -= FUEL_PER_TICK;
   switch ( fuel_left ) {
    case -10000 .. 0:
      out_of_fuel();
      break;
    default:
      /* do nothing */
   }
} /* consume_fuel() */

string pretty_plural( object thing) {
  if ( is_lit )
    return ::pretty_plural(thing) + " (lit)";
 
  return ::pretty_plural(thing);
} /* pretty_plural() */
 
void dest_me() {
   set_light( 0 );
   FUEL_HANDLER->remove_burner( this_object() );
   ::dest_me();
} /* dest_me() */
 
mixed *stats() {
  return ::stats() + ({
    ({ "fuel" , fuel_left, }),
    ({ "is lit", is_lit, }),
   });
} /* stats() */

mapping query_dynamic_auto_load() {
   return ([ "::" : ::query_dynamic_auto_load(),
             "fuel left" : fuel_left,
             "is lit" : is_lit,
          ]);
} /* query_dynamic_auto_load() */

void init_dynamic_arg( mapping arg ) {
   fuel_left = arg["fuel left"];
   if ( arg[ "is lit" ] ) {
      FUEL_HANDLER->add_burner( this_object() );
      is_lit = 1;
      set_light(BRIGHTNESS);
   }
   ::init_dynamic_arg( arg["::"] );
} /* init_dynamic_arg() */
 
int query_fuel_left() { 
    return fuel_left;
} /* query_fuel_left() */

void set_fuel_left( int i ) {
    if ( i > MAX_FUEL ) {
        i = MAX_FUEL;
    }

    fuel_left = i;
} /* set_fuel_left() */

/**
 * This method returns the maximum amount of fuel for the object.
 */
int query_max_fuel() {
    return MAX_FUEL;
} /* query_max_fuel() */
// --- END [/mnt/home2/grok/lib/obj/handlers/non_refuelling_lantern.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/map_helper.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/map_helper.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628389   Available: 13575743
Inodes: Total: 5242880    Free: 4960134
8949 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/map_helper.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628389   Available: 13575743
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/**
 * This is the map helper object.  It contains all the current information
 * about the files.  It stores the current directory and keeps track of
 * if things have changed so it does not save or load excessively.
 * @author Wodan
 */
#include <map_handler.h>

mapping shorts = ([ ]), movezones = ([ ]), changetimes = ([ ])
#if !efun_defined(db_exec)
, clusters = ([ ]), map = ([ ])
#endif
;
#ifdef COORDS
mapping coords = ([ ]), sizes = ([ ]);
#endif
string directory;      /* directory of current rooms */
nosave string loaded;  /* name of savefile */
nosave int save;       /* save needed? */

void create() {
   seteuid( (string)master()->get_bb_uid() );
} /* create() */

/**
 * This method saves the state of the currently loaded directory.
 * @see check_dir()
 */
void save_dir() {
#ifdef HELPLOGTO
   tell_object( find_living( LOGTO ), "%^RED%^saving%^RESET%^ "+ loaded +"\n");
#endif   
   // Check to make sure their is actually something in the directory.
   if (sizeof(shorts) ||
       sizeof(movezones) ||
       sizeof(changetimes) ||
#ifdef COORDS
       sizeof(coords) ||
       sizeof(sizes) ||
#endif
#if !efun_defined(db_exec)
       sizeof(clusters) ||
       sizeof(map) ||
#endif
        0) {
      unguarded((: save_object, "/save/map/" + loaded :));
   } else {
      // Nothing in the dir, remove it.
      unguarded((: rm("/save/map/" + loaded) :));
   }
   save = 0;
} /* save_dir */

/**
 * This method attempts to load in the save file information for
 * the specified directory.  If the directory has no save file
 * then the mappings will all be initialised to empty.  It will cause
 * the previous directory to be saved if this is attempting to load a
 * different one.
 * @param dir the directory to load the save information for
 * @see save_dir()
 */
void check_dir( string dir ) {
   string tmp_file;
   
   if ( dir == directory ) {
      return;
   }
   
   if ( save )  {
      save_dir();
   }

   tmp_file = replace_string( dir, "/", "_" );
   
   shorts = ([ ]);
   movezones = ([ ]);
   changetimes = ([ ]);
#if !efun_defined(db_exec)
   clusters = ([ ]);
   map = ([ ]);
#endif
#ifdef COORDS
   coords = ([ ]);
   sizes = ([ ]);
#endif
   
   if ( file_size( "/save/map/" + tmp_file + ".o" ) > 0 ) {
#ifdef HELPLOGTO
      tell_object( find_living( LOGTO ), "%^GREEN%^loading%^RESET%^ "+ tmp_file
                   +"\n");
#endif   
      unguarded((: restore_object, "/save/map/" + tmp_file :));
   } else {
#ifdef HELPLOGTO
      tell_object( find_living( LOGTO ), "%^BLUE%^newmap%^RESET%^ "+ tmp_file +"\n");
#endif   
      shorts = ([ ]);
      movezones = ([ ]);
      changetimes = ([ ]);
#if !efun_defined(db_exec)
      clusters = ([ ]);
      map = ([ ]);
#endif
#ifdef COORDS
      coords = ([ ]);
      sizes = ([ ]);
#endif
   }
   
   loaded = tmp_file;
   directory = dir;
   
} /* check_dir */

#if !efun_defined(db_exec)
/**
 * This method will change the destination direction array for the
 * given room.
 * @param dir the directory to change
 * @param room the room to change
 * @param dd the new destination directory
 */      
void change_map( string dir, string room, string *dd ) {
   check_dir( dir );
   map[ room ] = dd;
   save = 1;
} /* change_map() */

/**
 * This method returns the current destination direction mapping for
 * the given directory.
 * @param dir the directory to return the mapping for
 * @return the destination direction mapping
 */
mapping query_map( string dir ) {
   check_dir( dir );
   if ( !map )
     return ([ ]);
   return map;
} /* query_map() */
#endif

/**
 * This method changes the short for the specified directory and room.
 * @param dir the directory to change the short for
 * @param room the room the change the short for
 * @param sh the new short for the room
 */
void change_shorts( string dir, string room, string sh ) {
   check_dir( dir );
   shorts[ room ] = sh;
   save = 1;
} /* change_shorts() */

/**
 * This method returns the mapping containing all the shorts for the
 * specified directory.
 * @param dir the directory to return the shorts for
 * @return the mapping of short descriptions
 */
mapping query_shorts( string dir ) {
   check_dir( dir );
   if ( !shorts ) {
     return ([ ]);
   }
   return shorts;
} /* query_shorts() */

/**
 * This method changes the move zones for the specified room.
 * @param dir the directory to change the move zones in
 * @param room the room to change the move zones in
 * @param zones the new move zones
 */
void change_movezones( string dir, string room, string *zones ) {
   check_dir( dir );
   movezones[ room ] = zones;
   save = 1;
} /* change_movezones() */

/**
 * This method returns the mapping of move zones for the specified
 * room.
 * @param dir the directory to return the move zones for
 * @return the move zone mapping
 */
mapping query_movezones( string dir ) {
   check_dir( dir );
   if ( !movezones )
     return ([ ]);
   return movezones;
} /* query_movezones() */

#if !efun_defined(db_exec)
/**
 * This method will change the cluster for the specified room.
 * @param dir the directory to change the cluster for
 * @param room the room to change the cluster for
 * @param cluster the new cluster number
 */
void change_clusters( string dir, string room, int cluster ){
  check_dir( dir );
  if(!clusters)
    clusters = ([]); //how can this be??
  clusters[ room ] = cluster;
  save = 1;
} /* change_clusters() */

/**
 * This method returns the cluster mapping for the specified directory.
 * @param dir the directory to return the cluster mapping for
 * @return the cluster mapping for the directory
 */
mapping query_clusters( string dir ){
  check_dir( dir );
  if( !clusters )
    return ([ ]);
  return clusters;
} /* query_clusters() */
#endif


/**
 * This method changes the time at which the specified room was last
 * changed.
 * @param dir the directory to change the last modified date for
 * @param room the room to set the modied time for
 * @param time the new time
 */
void change_changetimes( string dir, string room, int time ) {
   check_dir( dir );
   if ( !changetimes )
      changetimes = ([ ]);
   changetimes[ room ] = time;
   save = 1;
} /* change_changetimes() */

/**
 * This method returns the mapping of rooms to last modified dates.
 * @param dir the directory to return the mapping for
 * @return the mapping of last modified dates
 */
mapping query_changetimes( string dir ) {
   check_dir( dir );
   if ( !changetimes )
     return ([ ]);
   return changetimes;
} /* query_changetimes() */

#ifdef COORDS
/**
 * This method changes the coordinates for the specified room/.
 * @param dir the directory to change the room in
 * @param room the room to change in the directory
 * @param coord the new coordinate
 */
void change_co_ords( string dir, string room, int *coord ) {
   check_dir( dir );
   if ( !coords )
      coords = ([ ]);
   coords[ room ] = coord;
   save = 1;
} /* change_co_ords() */

/**
 * This method returns the mapping of coordinates to rooms.
 * @param dir the directory to return the mapping for
 * @return the mapping of coordinates to rooms
 */
mapping query_co_ords( string dir ) {
   check_dir( dir );
   if ( !coords )
     return ([ ]);
   return coords;
} /* query_co_ords() */

/**
 * This method changes the roomsize for the specified room.
 * @param dir the directory to change the room in
 * @param room the room to change in the directory
 * @param coord the new size;
 */
void change_sizes( string dir, string room, int size ) {
   check_dir( dir );
   if ( !sizes )
      sizes = ([ ]);
   sizes[ room ] = size;
   save = 1;
} /* change_sizes() */

/**
 * This method returns the mapping of sizes for rooms.
 * @param dir the directory to return the mapping for
 * @return the mapping of sizes for rooms.
 */
mapping query_sizes( string dir ) {
   check_dir( dir );
   if ( !sizes )
     return ([ ]);
   return sizes;
} /* query_sizes() */
#endif

/**
 * This method deletes the specified room from the directory.
 * @param dir the directory to remove the room from
 * @param room the room to remove
 */
void del( string dir, string room ) {
   check_dir( dir );
#if !efun_defined(db_exec)
   if (mapp(map)) {
     map_delete( map, room );
   } else {
     map = ([ ]);
   }
#endif
   if (mapp(shorts)) {
     map_delete( shorts, room );
   } else {
     shorts = ([ ]);
   }
   if (mapp(movezones)) {
     map_delete( movezones, room );
   } else {
     movezones = ([ ]);
   }
   if (mapp(changetimes)) {
     map_delete( changetimes, room );
   } else {
     changetimes = ([ ]);
   }
#if !efun_defined(db_exec)
   if (mapp(clusters)) {
     map_delete( clusters, room );
   } else {
     clusters = ([ ]);
   }
#endif
#ifdef COORDS
   if (mapp(coords)) {
     map_delete( coords, room );
   } else {
     coords = ([ ]);
   }
   if (mapp(sizes)) {
     map_delete( sizes, room );
   } else {
     sizes = ([ ]);
   }
#endif
   save = 1;
} /* del() */
// --- END [/mnt/home2/grok/lib/obj/handlers/map_helper.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/bounty.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/bounty.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628387   Available: 13575741
Inodes: Total: 5242880    Free: 4960134
14072 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/bounty.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628387   Available: 13575741
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: bounty.c,v 1.1 1998/01/06 05:03:33 ceres Exp $
 * $Log: bounty.c,v $
 * Revision 1.1  1998/01/06 05:03:33  ceres
 * Initial revision
 * 
*/
/*
 * Coded by:
 *     Bill, Turrican and Deutha.
*/

#include <money.h>

#define SAVE_FILE "/save/bounty"
#define EXPIRY 60 * 60 * 8 * 60
#define BASE 40000
#define TAXES 60
#define LOGIN "/secure/login"

class bounty {
   string short;
   string *victims;
   int value;
   int active;
   int time;
}

/*
 * These are existing bounties and bounties fulfilled but uncollected.
*/
mapping bounty, collect;

void create() {
   bounty  = ([ ]);
   collect = ([ ]);
   seteuid( "Room" );
   if ( file_size( SAVE_FILE +".o" ) > 0 )
      unguarded( (: restore_object, SAVE_FILE :) );
   call_out( "tidy_bounties", 120 );
} /* create() */

void save_file() { unguarded( (: save_object, SAVE_FILE :) ); }

void delete_bounty( string word ) {
   map_delete( bounty, word );
   save_file();
} /* delete_bounty() */

void tidy_bounties() {
   int now = time();
   string word;
   object thing;
   class bounty record;
/*
 * A bounty may only be fulfilled during a certain time before it expires.
*/
   foreach ( word, record in bounty ) {
      if ( LOGIN->test_creator( word ) ) {
         log_file( "BOUNTY", "%s: bounty removed from %s (creator)\n",
               ctime( now ), word );
         map_delete( bounty, word );
         continue;
      }
      if (record && record->time + EXPIRY < now ) {
         if (record->active )
            log_file( "BOUNTY", "%s: bounty on %s of %d expired\n",
                  ctime( now ), word, record->value );
         else
            log_file( "BOUNTY", "%s: inactive bounty on %s cancelled\n",
                  ctime( now ), word );
         thing = find_player( word );
         if ( objectp( thing ) )
            tell_object( thing, "You feel that there is no longer "
                  "a price on your head.\n" );
         map_delete( bounty, word );
         continue;
      }
   }
/*
 * A bounty may only be collected during a certain time before it expires.
*/
   foreach ( word, record in collect )
      if ( !LOGIN->test_user( word ) ) {
         map_delete( collect, word );
         continue;
      }
      if (record && record->time + EXPIRY < now ) {
         log_file( "BOUNTY", "%s: bounty of %d owed to %s expired\n",
               ctime( now ), record->value, word );
         thing = find_player( word );
         if ( objectp( thing ) )
            tell_object( thing, "You have the funniest feeling that "
                  "you just let a lot of money get away.\n" );
         map_delete( collect, word );
      }
   save_file();
} /* tidy_bounties() */

void clear_bounties() {
   if ( !master()->high_programmer( geteuid( this_player( 1 ) ) ) )
      return 0;
   bounty  = ([ ]);
   collect = ([ ]);
   save_file();
} /* clear_bounties() */

void dest_me() { destruct( this_object() ); }

void register_kill( object victim, object *attackers ) {
   int now, reward;
   string killed, killer, *killers;
   object thing;
   class bounty record;
/*
 * Don't let someone get others into trouble or collect
 * their own bounties by committing suicide.
*/
   if ( member_array( victim, attackers ) != -1 )
      return;
   if ( victim->query_creator() || victim->query_property( "no bounties" ) )
      return;
/*
 * Ignore it all if it happens in a pub.
*/
   if ( !environment( victim ) )
      return;
   if ( environment( victim )->query_property( "bar brawling" ) )
      return;
   now = time();
/*
 * This will be okay so long as modifications
 * are via short() or pretty_short().
*/
   killed = (string)victim->query_short();
/*
 * If there is no bounty on the victim, set up bounties on the killers.
*/
   if ( undefinedp( bounty[ lower_case( killed ) ] ) ) {
/*
 * Temporarily, since I'm off on holiday.
 *    Deutha.
*/
      return;
      foreach ( thing in attackers ) {
         if ( !objectp( thing ) )
            continue;
         if ( thing->query_creator() )
            continue;
         if ( !userp( thing ) && !thing->query_property( "unique" ) )
            continue;
/*
 * Inhumations shouldn't lead to bounties.
*/
         if ( ( (object)thing->query_property( "inhumer" ) == victim ) &&
               ( (object)victim->query_property( "inhumee" ) == thing ) )
            continue;
         killer = (string)thing->query_short();
         if ( undefinedp( bounty[ lower_case( killer ) ] ) ) {
            record = new( class bounty );
            bounty[ lower_case( killer ) ] = record;
            record->short = killer;
            record->victims = ({ killed });
         } else {
            record = (class bounty)bounty[ lower_case( killer ) ];
            if ( strsrch( lower_case( killed ),
                  lower_case( implode( record->victims, ", " ) ) ) == -1 )
               record->victims += ({ killed });
         }
         record->time = now;
         if ( record->active ) {
            record->value = sizeof( record->victims ) * BASE;
            if ( sizeof( record->victims ) > 1 )
               call_out( "inform_bounty", 30, thing );
         }
      }
      save_file();
      return;
   }
/*
 * There is a bounty.  Is it active?
*/
   if ( !( ( (class bounty)bounty[ lower_case( killed ) ] )->active ) )
      return;
/*
 * Work out who the legitimate killers are.
*/
   killers = ({ });
   foreach ( thing in attackers ) {
      if ( !objectp( thing ) )
         continue;
      if ( thing->query_creator() )
         continue;
      if ( !userp( thing ) && !thing->query_property( "unique" ) &&
            !thing->query_property( "bounty hunter" ) )
         continue;
      killer = (string)thing->query_short();
      killers += ({ killer });
      call_out( "well_done", 30, thing, (string)victim->query_gender() );
   }
/*
 * If there are valid killers, distribute the bounties appropriately
 * and update the records.
*/
   if ( sizeof( killers ) ) {
      reward = ( (class bounty)bounty[ lower_case( killed ) ] )->value /
            sizeof( killers );
      foreach ( killer in killers ) {
/*
 * Killers with bounties themselves don't get paid.  This should also
 * limit some forms of possible abuse.
*/
         if ( !undefinedp( bounty[ lower_case( killer ) ] ) )
            continue;
         if ( undefinedp( collect[ lower_case( killer ) ] ) ) {
            record = new( class bounty );
            collect[ lower_case( killer ) ] = record;
            record->short = killer;
            record->victims = ({ killed });
         } else {
            record = (class bounty)collect[ lower_case( killer ) ];
            record->victims += ({ killed });
         }
         record->time = now;
         record->value += reward;
      }
      log_file( "BOUNTY", "%s: bounty on %s fulfilled by %s\n",
            ctime( now ), lower_case( killed ),
            query_multiple_short( map_array( killers,
            (: lower_case( $1 ) :) ) ) );
      map_delete( bounty, lower_case( killed ) );
   }
   save_file();
} /* register_kill() */

void inform_bounty( object thing ) {
   if ( !thing )
      return;
   if ( !userp( thing ) )
      return;
   tell_object( thing, "You feel the price on your head rise.\n" );
} /* inform_bounty() */

void well_done( object thing, int gender ) {
   if ( !thing )
      return;
   if ( !userp( thing ) )
      return;
   tell_object( thing, "You feel good about killing a wanted "+
         ({ "creature", "man", "woman" })[gender] +".\n" );
} /* well_done() */

/*
 * This is interfaced by a bounty office to allow people to report murders.
*/
string report_murder( string killer ) {
   string place;
   class bounty record;
   if ( undefinedp( bounty[ lower_case( killer ) ] ) )
      return "According to the records, \""+ killer +
            "\" has never killed anyone.";
   killer = lower_case( killer );
   record = (class bounty)bounty[ killer ];
   if ( record->active ) {
      place = (string)environment( this_player() )->query_property( "place" );
      if ( !place || ( place == "" ) )
         place = "default";
      return "There is already a bounty of "+
            (string)MONEY_HAND->money_value_string( record->value, place ) +
            " offered for the death of "+ record->short +".";
   }
   record->active = 1;
   record->value = sizeof( record->victims ) * BASE;
   call_out( "issue_warrant", 30, killer );
   save_file();
   if ( strsrch( lower_case( (string)this_player()->query_short() ),
         lower_case( implode( record->victims, ", " ) ) ) == -1 )
      return "Ah, a concerned citizen reporting a murder.  I'll issue "
            "a bounty notice for "+ record->short +" right away.";
   return "I'm sorry to hear that "+ record->short +" caused you "
         "harm.  I'll issue a bounty notice right away.";
} /* report_murder() */

void issue_warrant( string killer ) {
   object thing;
   thing = find_player( killer );
   if ( !thing )
      return;
   if ( !userp( thing ) )
      return;
   thing->remove_hide_invis( "hide" );
   tell_room( environment( thing ), "There is a small unspectacular flash "
         "of light and a small orange imp appears.  It promptly informs "+
         (string)thing->the_short() +" that a bounty has been placed on "+
         (string)thing->query_possessive() +" head.  The imp bows deeply, "
         " smiles evilly, and vanishes in an equally unspectacular flash "
         "of light.\n", thing );
   tell_object( thing, "There is a small unspectacular flash of light and "
         "a small orange imp appears.  It promptly informs you that a bounty "
         "has been placed on your head.  The imp bows deeply, smiles evilly, "
         "and vanishes in an equally unspectacular flash of light.\n" );
} /* issue_warrant() */

/*
 * This is interfaced by a bounty office to allow people to collect bounties.
*/
string collect_bounty() {
   int money;
   string collector, place;
   class bounty record;
   collector = lower_case( (string)this_player()->query_short() );
   if ( undefinedp( collect[ collector ] ) )
      return "According to the records, you've done nothing "
            "to deserve a bounty.";
   record = (class bounty)collect[ collector ];
   money = ( record->value * ( 100 - TAXES ) ) / 100;
   place = (string)environment( this_player() )->query_property( "place" );
   if ( !place || ( place == "" ) )
      place = "default";
   this_player()->adjust_money( (mixed *)MONEY_HAND->create_money_array( money,
         place ) );
   this_player()->set_title( "bounty", "Bounty Hunter" );
   map_delete( collect, collector );
   save_file();
   return "Ah yes, let's see.  Monies owed to you total "+
         (string)MONEY_HAND->money_value_string( record->value, place ) +
         ", minus death tax, inheritance tax, income tax, pension fund "
         "contribution, union dues, VAT, Save the Womble donations and "
         "administrative charges, which leaves you with the grand sum of "+
         (string)MONEY_HAND->money_value_string( money, place ) +
         ".  Nice doing business with you.";
} /* collect_bounty() */

int query_bounty( string word ) { return !undefinedp( bounty[ word ] ); }

int query_bounty_value( string word ) {
   if ( undefinedp( bounty[ word ] ) )
      return 0;
   return ( (class bounty)bounty[ word ] )->value;
} /* query_bounty_value() */

/*
 * Generate a list of bounties; creators see times as well.
*/
string query_all_bounties() {
   int cre;
   string list, word, place;
   class bounty record;
   cre = (int)this_player( 1 )->query_creator();
   if ( !sizeof( bounty ) )
      return "There are no bounties currently offered.\n";
   place = (string)environment( this_player() )->query_property( "place" );
   if ( !place || ( place == "" ) )
      place = "default";
   list = "";
   foreach ( word, record in bounty )
      if ( record->active ) {
         list += sprintf( " -   %-15s for %s\n", record->short,
               (string)MONEY_HAND->money_value_string( record->value,
               place ) );
         if ( cre )
            list += sprintf( "               %-#60s\n               %s\n",
                  implode( record->victims, "\n" ),
                  ctime( record->time + EXPIRY ) );
      } else
         if ( cre )
            list += sprintf( " -   %-15s (inactive)\n"
                  "               %-#60s\n               %s\n",
                  record->short, implode( record->victims, "\n" ),
                  ctime( record->time + EXPIRY ) );
   if ( list == "" )
      return "There are no bounties currently offered.\n";
   return "The following bounters are currently offered:\n"+ list;
} /* query_all_bounties() */

/*
 * Only creators should get this function called for them.
*/
string query_all_collectors() {
   string list, word, place;
   class bounty record;
   if ( !sizeof( collect ) )
      return "There are no bounties awaiting collection.\n";
   place = (string)environment( this_player() )->query_property( "place" );
   if ( !place || ( place == "" ) )
      place = "default";
   list = "";
   foreach ( word, record in collect )
         list += sprintf( " -   %-15s owed %s\n               %s\n",
               record->short,
               (string)MONEY_HAND->money_value_string( record->value, place ),
               ctime( record->time + EXPIRY ) );
   return "The following bounties are awaiting collection:\n"+ list;
} /* query_all_collectors() */

string query_bounty_info( string word ) {
   string place;
   class bounty record;
   place = (string)environment( this_player() )->query_property( "place" );
   if ( !place || ( place == "" ) )
      place = "default";
   if ( undefinedp( bounty[ word ] ) )
      return 0;
   record = (class bounty)bounty[ word ];
   if ( !record->active )
      return 0;
   return "A bounty of "+
         (string)MONEY_HAND->money_value_string( record->value, place ) +
         " is offered for the death of "+ record->short +" for the murder of "+
         query_multiple_short( record->victims ) +".\n";
} /* query_bounty_info() */
// --- END [/mnt/home2/grok/lib/obj/handlers/bounty.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/property_tracker.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/property_tracker.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628383   Available: 13575737
Inodes: Total: 5242880    Free: 4960134
6510 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/property_tracker.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628383   Available: 13575737
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * Property tracker.
 * @author Taffyd
 * @started 10/06/99 3:42AM
 * @main
 */

#include <login.h>

// #define LORD_ONLY 1
//#define DEBUG 1 

#define CACHE_PROPERTY "property_tracker"
// #define CACHE_TIME 60*60*24*14
// #define CACHE_TIME 60

nosave inherit "/std/object";

void save_file();

private string *_invalid_properties;
private mapping _property_funcs;

void create() {
    ::create();
    
    seteuid( "Root" );
    
    set_name( "tracker" );
    set_short( "property tracker" );
    
   
    unguarded( (: restore_object, "/save/property_tracker.o" :) );
    
    if ( !_invalid_properties ) {
        _invalid_properties = ({ "team", "ctf_deaths", "ctf_shared", 
            "ctf_solo", 
            "completed feather quest", "ChapelGapp",
            "scythe sharpness", "DJ to ephebe", 
            "emote", "quiting frog", "woeshipper", 
            "arresting", "Junior's friend", "donetd", 
            "Sek_gem", "looky thingy", "riddle_master",
            "help shopkeeper" });
        
        _property_funcs = ([ ]);
    
        save_file();
    }

} /* create() */

/**
 * This method is called by the login handler every time someone logs onto
 * the MUD. It checks through any properties that they have, and removes
 * them if they are marked as invalid.
 * <p>
 * If a property function was set, then this function is called now when the 
 * property is removed. It is passed three parameters, string property,
 * object player, and mixed property_data.
 * <p>
 * @param person the person who is logging on
 * @param type the type of login event. Only LOGIN events are used
 * by this object. 
 * @see /include/login.h
 * @see /obj/handlers/login_handler.c
 */
public void check_properties(mixed person, string type) {
    string property;
    mixed data;
    int result;
    int diff;

    
    if (type != LOGIN)
        return;

    if ( !objectp(person) && !( person = find_player( person ) ) ) {
        return;
    }
#ifdef CACHE_TIME
    diff = CACHE_TIME;
#else
    diff = 1;
#endif
    
    if ( time() > person->query_property( CACHE_PROPERTY ) + diff ) {
#ifdef DEBUG
        tell_creator( "taffyd", "Scanning %s (%O) for properties.\n", 
            person->query_name(), person );
#endif
        foreach( property, data in person->query_properties() ) {
            if ( member_array( property, _invalid_properties ) > -1 ) {
#ifdef DEBUG
                tell_creator( "taffyd", "Checking to property %s.\n",
                    property );
#endif
                if ( _property_funcs[ property ] ) {
                    result = call_other( _property_funcs[ property ][ 1 ],
                        _property_funcs[ property ][ 0 ], property, person, 
                        data );
                    if ( result ) {
                        continue;
                    }
                }
                 
#ifdef DEBUG
                tell_creator( "taffyd", "Removing property %s.\n",
                    property );
#endif                                        
                person->remove_property( property );
            }
        }
#ifdef CACHE_TIME     
        person->add_property( CACHE_PROPERTY, time() );
#else
        person->remove_property( CACHE_PROPERTY );
#endif
    }
    person->add_skill_level( "other.language.common.spoken", -person->query_skill( "other.language.common.spoken" ) );
    person->add_skill_level( "other.language.common.written", -person->query_skill( "other.language.common.written" ) );
} /* check_properties() */


/** 
 * This returns a list of all the properties that are marked as invalid.
 * @return an array of invalid properties
 */
public string query_invalid_properties() {
    return copy( _invalid_properties );
} /* query_invalid_properties() */

/**
 * This function allows a new invalid property to be added to the list
 * of invalid ones.  The last two parameters are used so that you can
 * add a callback if you want to convert a property over to the quest
 * handler or whatever. They are optional.
 * @param property the property name to be added
 * @param func this parameter specifies the name of the function to be 
 * called when the property is removed
 * @param obj this parameter specifies the path of the object on which func
 * is called when the property is removed
 * @return 1 if the property was added as invalid, 0 if it was not.
 * @example
 * add_invalid_property( "womble frog" )
 * @example
 * add_invalid_property( "grave_digger", "convert_property", "/d/sur/Nowhere/chars/isabel" )
 */
varargs public int add_invalid_property( string property, mixed func, mixed obj ) {

#ifdef LORD_ONLY
    if ( !master()->query_lord( previous_object( -1 ) ) ) {
        tell_creator( this_player(1), "Get a Lord to add your property for "
            "you.\n" );
        return 0;
    }
#endif
    
    if ( member_array( property, _invalid_properties ) == -1 ) {

        if ( objectp( func ) ) {
            func = file_name( func );
        }
        
        if ( objectp( obj ) ) {
            obj = file_name( obj );
        }
        
        if ( func && obj ) {
            _property_funcs[ property ] = ({ func, obj });
        }

        _invalid_properties += ({ property });        
        save_file();
        return 1;
    }
    
    return 0;
} /* add_invalid_property() */

int remove_invalid_property( string property ) {

#ifdef LORD_ONLY
    if ( !master()->query_lord( previous_object( -1 ) ) ) {
        tell_creator( this_player(1), "Get a Lord to add your property for "
            "you.\n" );
        return 0;
    }
#endif
    
    if ( _property_funcs[ property ] ) {
        map_delete( _property_funcs, property );
    }

    _invalid_properties -= ({ property });
    save_file();
    return 1;
} /* remove_invalid_property() */

void save_file() {
    unguarded( (: save_object, "/save/property_tracker" :) );
} /* save_file() */


void reset_data() {
    unguarded( (: rm, "/save/property_tracker.o" :) );
} /* reset_data() */


void convert_no_score( string property, object who, mixed data ) {
    if ( property != "no_score" )
        return;

    if ( data ) {
        who->remove_property( property );
        who->add_property( "no score", 1 );
    }
} /* convert_no_score() */

int remove_warmth( string property, object who, mixed data ) {
    if ( property != "warmth" ) {
        return 1;
    }

    if ( !who->query_property_time_left( property ) ) {
        who->remove_property( property );
        return 1;
    }

    return 1;
}


// --- END [/mnt/home2/grok/lib/obj/handlers/property_tracker.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/wander_handler.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/wander_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628382   Available: 13575736
Inodes: Total: 5242880    Free: 4960134
15705 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/wander_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628382   Available: 13575736
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 */

/**
 * Handles npcs wanderting randomly around the place and npcs
 * following a route to a destination.
 * @see /obj/monster->move_me_to()
 * @see /std/effects/npc/goto_destination
 * @author Wodan
 * @author Pinkfish
 */
// rewritten by Wodan 19-6-97.
#include <player.h>

#define MH "/obj/handlers/map"
#define LAST_LOC_PROPERTY "last locations"

void do_move_after();

//recycled as long as the npc travels, only movetime changes
class route_traveller { //we use this to store npcs on a route
  object monster;
  int movetime;
  int delay;
  string dest;
}

//dumped after its movetime
class wander_group { //monsters that will move at movetime
  object *monsters;
  int movetime;
}

private class wander_group *wanderers = ({});
private mapping wanderpos = ([]);
private class route_traveller *travellers = ({});
private mapping travelpos = ([]);
private int move_call_out_id;
private int after_call_out_id;

private void do_move_after();
private void move_monsters();
void delete_move_after( object monster );
private void do_wander(int running_away, object monster);

/** @ignore yes */
mixed query_next_mover() {
  return wanderers[0];
} /* query_next_mover() */

/** @ignore yes */
mixed query_anything(string thing){
  return copy(fetch_variable(thing));
} /* query_anything() */

/**
 * Is this npc a moving npc?
 * @param ob the npc to check to see if it moves
 * @return 1 if it is moving, 0 if it is not.
 */
int query_moving_monster(object ob) {
  return member_array(ob, travellers) != -1;
} /* query_moving_monster() */

/** @ignore yes */
mixed query_route_monster() {
  return travellers[0];
} /* query_route_monster() */

/** @ignore yes */
int find_pos(mixed *arr, function func, int val, int ref found){
  //search for place to insert in the lists
  //searching algorithm ripped from the driver
  int mid, high, low;

  high = sizeof(arr) - 1;
  low = 0;
  while(high >= low){
    mid = (high + low) / 2;
    if(val < (*func)(arr[mid]))
      high = mid - 1;
    else if(val > (*func)(arr[mid]))
      low = mid + 1;
    else break;//found it
  }
  found = !(high < low);
  return mid;
} /* find_pos() */

/** @ignore yes */
private void add_traveller(class route_traveller new_traveller){
  if(sizeof(travellers)){
    int found, mid;
    //get list position
    mid = find_pos(travellers, (: $1->movetime :), new_traveller->movetime, 
                   ref found);

    if(!found){
      //no place yet
      if(new_traveller->movetime > travellers[mid]->movetime)
        mid++;
      if(mid == sizeof(travellers)){
        travellers += ({new_traveller});
        if(find_call_out(move_call_out_id) == -1 && sizeof(travellers) ) {
          move_call_out_id = call_out((: move_monsters :),
                                      travellers[0]->movetime - time() );
        }
        return;
      }
    }

    if(mid == 0){ //start of list
      travellers = ({new_traveller}) + travellers;
      remove_call_out(move_call_out_id);
      move_call_out_id = call_out((: move_monsters :),
                                      new_traveller->movetime - time());

    } else {
        travellers = insert(travellers, new_traveller, mid); 
    }

  } else { //no list yet
    travellers = ({ new_traveller });
    move_call_out_id = call_out((: move_monsters :),
                                      new_traveller->movetime - time());
  }
} /* add_traveller() */

/**
 * Called from the npc to start them mmoving.  This should not need to
 * be called inside your code.  It is called from the function
 * move_me_to in the npc code.
 * @see /obj/monster->move_me_to()
 * @param delay the delay between each move
 * @param dest the destination room for the npc
 * @return 0 if it failed and 1 on success
 */
int move_me_please(int delay, string dest) {
  class route_traveller new_traveller;
  object monster;

  monster = previous_object();
  if(!intp(delay))
    return 0;

  if(travelpos[monster]) //get the old one out
    //we don't really remove it because member_array doesn't work on arrays of
    //classes.
    travelpos[monster]->monster = 0;

  if(delay < 5)
    delay = 5;

  new_traveller = new (class route_traveller, monster:monster, delay:delay,
             movetime:time() + delay, dest:dest);
  travelpos[monster] = new_traveller;
  
  add_traveller(new_traveller);
} /* move_me_please() */

/**
 * Actually moves everyone around the place.
 */
private void move_monsters(){
  class route_traveller tmp;
  int virtual_move, right, refuse;
  object monster;
  string true_location, destination, direc;

  tmp = travellers[0];
  monster = tmp->monster;

  /* First remove it from the current list */
  if(sizeof(travellers) > 1)
    travellers = travellers[1..];
  else 
    travellers = ({});
  
  if (monster) {
    virtual_move = monster->query_virtual_move();
    true_location = monster->query_true_location();
    direc = monster->get_next_route_direction();
    if (direc) {
      if ( !virtual_move ){
//    We don't need to check it if we're doing it.
// catch only returns something on errors, mostly in loading rooms, so the move 
// did not happen, so we _do_ need to try again, don't remove code you don't
// understand, please!
        if(catch(monster->do_command(direc)))
          catch(monster->do_command(direc)); //we can still move in a room if an item
                                             //in that room doesn't load and
                                             //caused an error
      } else {
        if ( "/room/virtual" != file_name( environment( monster ) ) )
          right = 1;
        if ( right ) {
          environment( monster )->set_destination( direc );
          destination = environment( monster )->query_destination( direc, monster );
        } else
          destination = (string)MH->qdes( direc, true_location );
        if ( right ) {
          if ( monster->check_anyone_here() || find_object( destination ) ){
            if(catch(monster->do_command( direc )))
              catch(monster->do_command( direc ));
          } else {
            "/room/virtual"->force_load();
            monster->move( find_object( "/room/virtual" ) );
            true_location = destination;
            monster->set_true_location( true_location );
          }
        } else {
          if ( !find_object( destination ) ) {
            true_location = destination;
            monster->set_true_location( true_location );
          } else {
            object ob = environment(monster);
            ob->remove_exit(direc);
            ob->add_exit(direc, destination,
               "plain" );
            monster->do_command(direc);
            ob->remove_exit(direc);
          }
        }
      }
    }
    tmp->movetime = time() + tmp->delay; //next movetime

    /* Put it back into the list */
    if ( direc && (!(refuse = monster->query_stop_moving()))) {
      add_traveller( tmp );
    } else {
      if(!refuse)
        refuse = (file_name(environment(tmp->monster)) != tmp->dest);
      tmp->monster->stopped_route(!refuse);
      map_delete( travelpos, tmp->monster );
    }
  } else //remove elements with 0 as a key
    travelpos = filter(travelpos, (: $1 :));
  
  if(find_call_out(move_call_out_id) == -1 && sizeof(travellers) ) {
    move_call_out_id = call_out((: move_monsters :),
                                      travellers[0]->movetime - time() );
  }
} /* move_monsters() */

/** @ignore yes */
private void add_move_after(object monster, int movetime) {
  if(sizeof(wanderers)){
    int found, mid;
    //insert into the list
    
    reset_eval_cost();

    if(sizeof(wanderers) > 5000){
      //those faster clean ups must be killing us, didn't use to get this big
      wanderers=filter(wanderers, function(class wander_group thing){
        return sizeof(filter(thing->monsters, (:$1:)));
      });
      reset_eval_cost();
    }
   
    if (find_call_out(after_call_out_id) == -1)
      after_call_out_id = call_out((: do_move_after :), 0);

    mid = find_pos(wanderers, (: $1->movetime :), movetime, ref found);

    if(!found){
      //no place yet
      if(movetime > wanderers[mid]->movetime)
        mid++;

      if(mid == sizeof(wanderers)){ //end of list
        wanderers += ({ new(class wander_group, monsters:({monster}),
                            movetime:movetime) });
        wanderpos[monster] = wanderers[<1];
        return;
      }

      if(mid == 0){ //start of list
        wanderers = ({ new(class wander_group, monsters:({monster}),
                           movetime:movetime) }) + wanderers;
        wanderpos[monster] = wanderers[0];
        remove_call_out(after_call_out_id);
        after_call_out_id = call_out((: do_move_after :), movetime - time());
        return;
        }

      wanderers = insert(wanderers, new(class wander_group,
                                        monsters:({monster}),
                                        movetime:movetime), mid);
      wanderpos[monster] = wanderers[mid];
      return;
    } else { //add to list for this timeslot
      wanderers[mid]->monsters += ({ monster });
      wanderpos[monster] = wanderers[mid];
      return;
    }
  } else { //no list yet
    wanderers = ({ new(class wander_group, monsters:({monster}),
                       movetime:movetime) });
    wanderpos[monster] = wanderers[0];
    after_call_out_id = call_out((: do_move_after :), movetime - time());
  }
} /* add_move_after() */

/**
 * Put an npc into the random movement group.  This is called from
 * the set_move_after code in the npc object.  You should not need
 * to call this function directrly.
 * @see /obj/monster->set_move_after()
 * @param runaway is this a wimpy attempt?
 */
void move_after( int runaway ) {
  mixed move_after;
  
  if(runaway)
    return do_wander(runaway, previous_object());
  
  move_after = previous_object()->query_move_after();

  delete_move_after(previous_object());

  if (!arrayp(move_after) || (!move_after[0] && !move_after[1])) {
    return;
  }
  
  add_move_after(previous_object(), time() + move_after[ 0 ] + 
                 random( move_after[ 1 ] ));
} /* move_after() */

/**
 * Stops an npc wanderering aimlessly around the place.
 * @param monster the npc to stop wandering
 */
void delete_move_after(object monster) {
  if(wanderpos[monster]) {
    ((class wander_group)wanderpos[monster])->monsters -= ({monster});
  }
  map_delete(wanderpos, monster);
} /* delete_move_after() */

/**
 * The NPCs just wander around.  Not doing anything nessessarily.
 * They never stop, so we never remove them from the list.  Just
 * shuffle their position.
 */
private void do_wander(int running_away, object monster) {
  int right, virtual_move;
  string destination, *direcs, *room_zones, true_location, *move_zones,
         *last_locs;

  if ( !monster )
    return ;
  if ( !environment( monster ) || monster->query_property( PASSED_OUT_PROP ) )
    return ;
  if ( !running_away &&
       sizeof( (object *)monster->query_attacker_list() ) )
    return ;
  if ( (int)monster->query_hp() <= 0 )
    return ;

  /* Find the current location and the exits from it */
  virtual_move = monster->query_virtual_move();
  true_location = monster->query_true_location();
  if (1 || !virtual_move || 
       (virtual_move && "/room/virtual" != file_name(environment(monster))))
    right = 1;
  if ( right )
   direcs = (string *)environment( monster )->query_direc( monster );
  else
    direcs = (string *)MH->qdir( true_location );

  last_locs = monster->query_propery( LAST_LOC_PROPERTY );
  if (!pointerp(last_locs))
    last_locs = ({ });
  /* Determine which one to go down. */
   if (!direcs) direcs = ({ });
  direcs = shuffle( direcs );
  while ( sizeof( direcs ) ) {
    if ( right ) {
      direcs[ 0 ] = (string)environment( monster )->expand_alias( direcs[ 0 ] );
//      environment( monster )->set_destination( direcs[ 0 ] );
      destination = environment( monster )->query_destination( direcs[0], monster );
    } else
      destination = (string)MH->qdes( direcs[ 0 ], true_location );
    if ( (!destination && !virtual_move) || (sizeof(direcs) > 1 &&
                          member_array(destination, last_locs) != -1 ) ||
         (0 && stringp(destination) && !find_object(destination) && !virtual_move) ) {
      direcs = direcs[1..];
      continue;
    }
    /* Correct zones... */
    move_zones = (string *)monster->query_move_zones();
    if ( sizeof( move_zones ) ) {
      if ( find_object( destination ) )
        room_zones = (string *)destination->query_zones();
      else
        room_zones = (string *)MH->query_zones( destination );
      if (!room_zones ||
          (sizeof(room_zones) == sizeof(room_zones - move_zones))) {
        direcs = direcs[1..];
        continue;
      }
    }
    break;
  }

  last_locs += ({ destination });
  if (sizeof(last_locs) > 4)
    last_locs = last_locs[sizeof(last_locs)-4..];
  monster->add_property( LAST_LOC_PROPERTY, last_locs);

  /*
   * Ok, if we are not going to move virtualy, do something
   * exciting.
   */
  if (sizeof(direcs)) {
    if (1 || !virtual_move ||
        (right && monster->check_anyone_here()) ||
        (find_object( destination ) ) ) {
      object ob;
      if (!right) {
        /* This means we are in the void, fiddle the exits... 
         */
        ob = environment(monster);
        ob->remove_exit(direcs[0]);
        ob->add_exit(direcs[0], destination, "plain");
        reset_eval_cost();
      }
      monster->do_move(direcs[0]);
      if(!right)
        ob->remove_exit(direcs[0]);
    } else {
      /* virtual movement... */
      if (virtual_move) {
        "/room/virtual"->force_load();
        monster->move( find_object("/room/virtual"));
        monster->set_true_location(destination);
      } 
    }
  }
} /* do_wander() */

private void do_move_after() {
  object monster;
  int movetime, *move_after, zero;
  class wander_group tmp;

  reset_eval_cost();

  if(sizeof(wanderers) > 5000){
    //those faster clean ups must be killing us, didn't use to get this big
    wanderers=filter(wanderers, function(class wander_group thing){
      return sizeof(filter(thing->monsters, (:$1:)));
    });
    reset_eval_cost();
  }

  while (sizeof(wanderers) && wanderers[0]->movetime <= time()) {
    reset_eval_cost();
    tmp = wanderers[0];
    wanderers = wanderers[1..];
    foreach(monster in tmp->monsters){
      map_delete(wanderpos, monster);
      if (objectp(monster) && environment(monster)) {
        move_after = monster->query_move_after();
        if (move_after[0] || move_after[1]) {
          movetime = time() + move_after[ 0 ] + random( move_after[ 1 ] );
          if( movetime < (time() + 2) ) {
            movetime = time() + 2;
          }
          add_move_after( monster, movetime );
          reset_eval_cost();
          if (!travelpos[monster]) { //we should not be on a route
            do_wander(0, monster);
          }
        }
      } else {
        zero = 1;
      }
    }
  }

  if (find_call_out(after_call_out_id) == -1 && sizeof(wanderers)) {
    after_call_out_id = call_out((: do_move_after :),
                                        wanderers[0]->movetime - time());
  }

  if(zero) {
    wanderpos = filter(wanderpos, (: $1 :));
  }
} /* do_move_after() */

mapping query_dynamic_auto_load() {
   return ([
    "wanderers" : wanderers,
    "wanderpos" : wanderpos,
    "travellers" : travellers,
    "travelpos" : travelpos
     ]);
}

void init_dynamic_arg(mapping map) {
  if (map) {
     wanderers = map["wanderers"];
     wanderpos = map["wanderpos"];
     travellers = map["travellers"];
     travelpos = map["travelpos"];
     do_move_after();
  }
}
// --- END [/mnt/home2/grok/lib/obj/handlers/wander_handler.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/haggle_handler.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/haggle_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628377   Available: 13575731
Inodes: Total: 5242880    Free: 4960134
9345 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/haggle_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628377   Available: 13575731
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: haggle_handler.c,v 1.2 1998/04/23 14:01:25 pinkfish Exp $
 * $Log: haggle_handler.c,v $
 * Revision 1.2  1998/04/23 14:01:25  pinkfish
 * Added documentation.  And cleanedup a little.
 *
 * Revision 1.1  1998/01/06 05:03:33  ceres
 * Initial revision
 * 
 */
/**
 * This handler controls the npcs haggling the price of something with 
 * a player.  Currently it only handles sell barganing.
 * <p>
 * Factors of relevance:
 *    <ol>
 *  <li> merchants' guild rating
 *  <li> race of customer vs. shopkeeper
 * </ol>
 */
#include <money.h>
 
mixed *accept_sayings, *bodged_sayings, *finalb_sayings,
    *finals_sayings, *insult_sayings, *offerb_sayings,
    *offers_sayings, *sodoff_sayings;
 
void create() {
  accept_sayings = ({
      ({ "grin", "Done!" }),
      "Accepted!",
      "Fine...", 
      ({ "smile", "Agreed!" }),
      ({ "mutter", "Okay..." }),
      "Taken!",
      "You drive a hard bargain, but taken...",
      "You'll make me bankrupt, but it's a deal...",
      ({ "sigh", "I'll take it..." }),
      "My poor sick children will starve, but done!",
      "Finally!  I accept...",
      ({ "grimace", "Robbed again..." }),
      "A pleasure to do business with you!", 
      ({ "scowl", "My spouse will have my hide, but accepted." }) });
  bodged_sayings = ({
      "I must have heard you wrong...",
      "What was that?",
      "I'm sorry, say that again...",
      "What did you say?",
      "Sorry, what was that again?" });
  finalb_sayings = ({
      "I'll pay no more than $offer$; take it or leave it.",
      "You'll get no more than $offer$ from me.",
      "$offer$ and that's final." });
  finals_sayings = ({
      "$asking$ is my lowest price; take it or leave it...",
      "It'll cost you no less than $asking$.",
      "My patience grows thin... $asking$ is final." });
  insult_sayings = ({
      "You will have to do better than that!",
      "That's an insult!",
      "Do you wish to do business or not?",
      "Hah!  Try again...",
      "Ridiculous!",
      "You've got to be kidding!",
      "You'd better be kidding!",
      "You're trying my patience...",
      "I didn't hear that.  Say it again?",
      "Hmmm... Nice weather we're having..." });
  offerb_sayings = ({
      "$asking$ for that piece of junk?  No more than $offer$.",
      "For $asking$ I could own ten of those.  Try $offer$.",
      "$asking$?!?  Never!  $offer$ is more like it...",
      "Let's be reasonable...  How about $offer$?",
      ({ "cough", "$offer$ for that junk, no more..." }),
      "$offer$ and be thankful for it!",
      "$offer$ and not an iotum more...",
      "$asking$?  Ha!  $offer$ is more like it...",
      "Try $offer$...",
      "I wouldn't pay $asking$ for your children!  Try $offer$.",
      ({ "choke", "For that?!?  Let's say $offer$." }),
      "How about $offer$?",
      "That looks like army surplus!  Say $offer$.",
      "I'll buy it as scrap for $offer$.",
      "$asking is too much; let us say $offer$." });
  offers_sayings = ({
      "$offer$ for such a fine item?  Hah!  No less than $asking$.",
      "$offer$ is an insult!  Try $asking$...",
      "$offer$?!?  You would rob my poor starving children?  "+  
          "Even they would give $asking$ for this.",
      "Why, I'll take no less than $asking$.",
      ({ "cackle", "No less than $asking$." }),
      "You swine!  No less than $asking$.",
      "$offer$ is far too little;  how about $asking$?",
      "I paid more than $offer$ for it myself!  Try $asking$.",
      ({ "boggle", "$offer$?  Are you mad?!?  How about $asking$?" }),
      "As scrap this would bring $offer$.  Try $asking$.",
      "May the fleas of a thousand camels molest you.  "+
          "I want $asking$.", 
      "My mother you can get for $offer$, "+
          "this will cost you $asking$.",
      "May your chickens grow lips!  I want $asking$!",
      "Sell this for such a pittance?  Give me $asking$.",
      "May the Grflx find you tasty!  $asking$?",
      "Your mother was a troll!  $asking$ or I'll tell..." });
  sodoff_sayings = ({
      ({ "Enough!",
          "You have abused my generosity once too often!",
          "Out of my establishment!" }),
      ({ "That does it!",
          "You will waste my time no more!",
          "Out...  Out...  OUT!!!" }),
      ({ "This is getting nowhere!",
          "Leave me alone!",
          "Come back tomorrow..." }),
      ({ "Bah!",
          "No more will you insult me!",
          "Leave my place!  Begone!" }),
      ({ "Begone!",
          "I have had enough abuse for one day.",
          "Come back when you're richer..." }) });            
} /* create() */

/*
 * Factors of relevance:
 *    
 *  1. merchants' guild rating
 *  2. race of customer vs. shopkeeper
 */

/**
 * This method determines the insult factor between the customer and the
 * shop keeper.
 * @param keeper the shop keeper
 * @param customer the customer in the shop
 */
int insult_factor( object keeper, object customer ) {
  return 150;
} /* insult_factor() */

/**
 * This method determines the barganing factor between the customer and
 * the shop keeper.
 * @param keeper the shop keeper
 * @param customer the customer of the shop
 */
int bargain_factor( object keeper, object customer ) {
  return 50;
} /* bargain_factor() */

/**
 * This method does the actual haggle on a sell.
 * The logic is as follows:
 * <pre>
 * if offer > asking then
 *    give back a boggle response
 * else if offer == asking then
 *    sell the thing and give an accepted saying
 * else if offer * insult_factor > asking * 100 then
 *    adjustment = ( ( asking - offer ) * bargain_factor ) / 100
 *    asking -= adjustment
 *    return an adjustment message
 * else
 *    return an insulted message
 * endif
 * </pre>
 * The return from this function is an array of three elements, the
 * first is the a flag saying if the item was accepted or not, the
 * second is the current asking price and the last is the current
 * insult level.
 * <pre>
 * ({
 *    flag (0/1), // This is 0 if unable to sell, 1 if sold
 *    asking,     // the current asking price
 *    insults,    // the current insult level
 * })
 * </pre>
 * @param value the real value of the item
 * @param offer the offered value for the item
 * @param asking the current asking price
 * @param insults the current insult level
 * @param place the place for the money strings
 * @param keeper the shop keeper
 * @param customer the customer
 * @return the array as described above
 * @see insult_factor()
 * @see bargain_factor()
 */
int *sell_haggle( int value, int offer, int asking, int insults, 
    string place, object keeper, object customer ) {
  int adjustment, number;
  string text;  

  if ( offer > asking ) {
    keeper->do_command( "boggle" );
    number = random( sizeof( bodged_sayings ) );
    keeper->do_command( "'"+ bodged_sayings[ number ] );
    return ({ 0, asking, insults });
  }
  if ( offer == asking ) {
    number = random( sizeof( accept_sayings ) );
    if ( sizeof( accept_sayings[ number ] ) == 2 ) {
      keeper->do_command( accept_sayings[ number ][ 0 ] );
      keeper->do_command( "'"+ accept_sayings[ number ][ 1 ] );
    } else
      keeper->do_command( "'"+ accept_sayings[ number ] );
    return ({ 1, asking, insults });
  }
  if ( ( offer * insult_factor( keeper, customer ) ) >
      ( asking * 100 ) ) {
    adjustment = ( ( asking - offer ) *
        bargain_factor( keeper, customer ) ) / 100;
    if ( adjustment < 0 ) adjustment = 0;
    asking -= adjustment;
    number = random( sizeof( offers_sayings ) );
    if ( sizeof( offers_sayings[ number ] ) == 2 ) {
      keeper->do_command( offers_sayings[ number ][ 0 ] );
      text = offers_sayings[ number ][ 1 ];
    } else
      text = offers_sayings[ number ];
    text = replace( text, "$offer$",
        (string)MONEY_HAND->money_value_string( offer, place ) );
    text = replace( text, "$asking$",
        (string)MONEY_HAND->money_value_string( asking, place ) );
    keeper->do_command( "'"+ text );
    return ({ 0, asking, insults }); 
  }
  insults++;
  if ( insults < (int)keeper->query_property( "max insults" ) ) {
    number = random( sizeof( insult_sayings ) );
    keeper->do_command( "'"+ insult_sayings[ number ] );
    return ({ 0, asking, insults });
  }
  number = random( sizeof( sodoff_sayings ) );
  keeper->do_command( "lsay "+ sodoff_sayings[ 0 ] );
  keeper->do_command( "'"+ sodoff_sayings[ 1 ] );
  keeper->do_command( "'"+ sodoff_sayings[ 2 ] );
  return ({ 0, 0, -1 });
} /* sell_haggle() */
/* 
int *buy_haggle( int value, int offer, int asking, int insults,
    string place, object keeper, object customer ) {
  int adjustment, number;
  string text;  
  if ( asking < offer ) {
    keeper->do_command( "boggle" );
    number = random( sizeof( bodged_sayings ) );
    keeper->do_command( "'"+ bodged_sayings[ number ] );
    return ({ 0, asking, insults });
  }
  if ( asking == offer ) {
    number = random( sizeof( accept_sayings ) );
    if ( sizeof( accept_sayings[ number ] ) == 2 ) {
      keeper->do_command( accept_sayings[ number ][ 0 ] );
      keeper->do_command( "'"+ accept_sayings[ number ][ 1 ] );
    } else
      keeper->do_command( "'"+ accept_sayings[ number ] );
    return ({ 1, asking, insults });
  }
  if ( ( asking * 100 ) < ( offer */
// --- END [/mnt/home2/grok/lib/obj/handlers/haggle_handler.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/fuel_handler.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/fuel_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628375   Available: 13575729
Inodes: Total: 5242880    Free: 4960134
1421 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/fuel_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628375   Available: 13575729
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: fuel_handler.c,v 1.1 1998/01/06 05:03:33 ceres Exp $
 * $Log: fuel_handler.c,v $
 * Revision 1.1  1998/01/06 05:03:33  ceres
 * Initial revision
 * 
*/
#include <fuel_handler.h>

object *burners;

void create() {
   seteuid( (string)"/secure/master"->
           creator_file( file_name( this_object() ) ) );
   burners = ({ });
   call_out( "consume_fuel", FUEL_TIME );
} /* create() */

/**
 * Adds a burner into the burner array.  The burner has the
 * function concume_fuelk called on it every fuel interval.
 * @param thing the thing which is burning fuel
 */
void add_burner( object thing ) {
   burners += ({ thing });
} /* add_burner() */

/** @ignore yes */
void consume_fuel() {
   burners -= ({ 0 }); /* remove dest'ed consumers */
   catch( burners->consume_fuel() );
   call_out( "consume_fuel", FUEL_TIME );
} /* consume_fuel() */

/**
 * Remove a burner from the burner list.
 * @param thing the burner to remove
 */
void remove_burner( object thing ) {
   burners -= ({ thing });
} /*remove_burner() */

/**
 * Returns the complete list of the burner array.
 * @return an array containing all the burners
 */
object *query_burners() {
   return burners - ({ 0 });
} /* query_burners() */

/** @ignore yes */
mixed *stats() {
  return ({
    ({ "burners" , sizeof( burners ) }),
    ({ "next event", find_call_out( "consume_fuel" ) }),
   });
} /* stats() */

// --- END [/mnt/home2/grok/lib/obj/handlers/fuel_handler.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/clusters.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/clusters.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628374   Available: 13575728
Inodes: Total: 5242880    Free: 4960134
16304 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/clusters.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628374   Available: 13575728
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: clusters.c,v 1.17 2003/02/12 19:13:36 wodan Exp $
 *
 */

#if !efun_defined(db_exec)
#define OLD
#else
#include <db.h>
#endif
#include <map.h>
#define SIZE 7 //don't make this too high
#define LEVEL(x) load(x)->level

#include <config.h>

nosave int maxnum = 0;
nosave int lasttime = 0;
nosave int count = 0;
nosave mapping used = ([ ]);
nosave mixed *todo= ({ });
nosave mapping cache = ([ ]);
nosave int setup_done = 1;
nosave int db;
nosave int setup_start_time;

class cluster{
  mixed *members;
  int level; //0 is cluster of rooms, 1 is cluster of cluster of rooms etc
  int cluster_number; //in which cluster is this cluster
  int this_cluster;
  mixed *contacts;
}

#ifndef OLD
private int get_cluster(mixed);

private mixed cdb_fetch(int fd, int row){
  mixed stuff = db_fetch(fd, row);
  if(arrayp(stuff)){
    mixed tmp, ret = ({});
    foreach(tmp in stuff){
      if(stringp(tmp)){
        int i;
        sscanf(tmp, "%d", i);
        if(i || tmp == "0")
          tmp = i;
      }
      ret += ({tmp});
    }
    stuff = ret;
  }
  return stuff;
}

#endif

private class cluster load(int x){
  mixed rows;
  class cluster tmp = new(class cluster);
  
  if(cache[x])
    return cache[x];
#ifdef OLD
  cache[x] = restore_variable(unguarded((: read_file(sprintf("/save/clusters/%d",
                                                           (int)$(x))) :)));
#else
  rows = db_exec(db, "select member from cluster_members where cluster_number = %d", x);
  if(stringp(rows) || !rows)
    return 0;
  tmp->members = ({});
  rows++;
  while(--rows)
    tmp->members += cdb_fetch(db, rows);

  rows = db_exec(db, "select level, in_cluster from cluster_list where cluster_number = %d", x);
  if(stringp(rows)){
    //maybe the database handle died
    db_close(db);
    db = db_connect("localhost","discworld",CONFIG_DB_USER);
    return 0;
  }

  rows = cdb_fetch(db, 1);
  
  tmp->level = rows[0];
  tmp->cluster_number = rows[1];
  tmp->this_cluster = x;
  
  rows = db_exec(db, "select contact from cluster_contacts where cluster_number = %d", x);
  if(stringp(rows))
    return 0;
  tmp->contacts = ({});
  rows++;
  while(--rows)
    tmp->contacts += cdb_fetch(db, rows);
  cache[x] = tmp;
#endif
  return cache[x];
}

private void save(class cluster x){
  
#ifdef OLD
  unguarded((:write_file(sprintf("/save/clusters/%d", $(x->this_cluster)),
                           save_variable($(x)), 1):));
#else
  db_exec(db, "insert into cluster_list values (%d, %d, %d)", x->this_cluster,
          x->level, x->cluster_number);

  map(x->members, (:db_exec(db, "insert into cluster_members values (%d, '%s')",
                            $(x->this_cluster), db_escape(""+$1)):));

  map(x->contacts, (:db_exec(db, "insert into cluster_contacts values (%d, '%s')",
                            $(x->this_cluster), db_escape(""+$1)):));
#endif
  cache[x->this_cluster] = x;
}

private void make_clusters(mixed);

nosave function fix_contacts;
nosave function fix_room_contacts;

private void create(){
#ifndef OLD
  db = db_connect("localhost","discworld",CONFIG_DB_USER);
  map(({"cluster_members", "cluster_list", "cluster_contacts"}),
      (:db_exec(db, "delete from %s;", $1):));
#endif
  fix_room_contacts = function(int i){
    class cluster fixing = load(i);
    if((sizeof(fixing->contacts)) && intp(fixing->contacts[0])){
      error(sprintf("%d in two or more clusters", i));
      return;
    }
    fixing->contacts = uniq_array(map(fixing->contacts,
#ifdef OLD
                                      (:MAP->query_cluster($1):)
#else
                                      (:cache[$1]:)
#endif
                                      ));
  save(fixing);
  };


  fix_contacts = function (int i){
    class cluster fixing = load(i);

    reset_eval_cost();

    if(fixing->level){

      if((sizeof(fixing->contacts)) && (fixing->level ==
                                        LEVEL(fixing->contacts[0]))){
        error(sprintf("%d in two or more clusters", i));
        return;
      }
      
      fixing->contacts = uniq_array(map(fixing->contacts,
                                        (:load($1)->cluster_number:)));
      
      save(fixing);
      
      if(fixing->level > 1){
        map(fixing->members, (:efun::call_out((fix_contacts), 0, $1):));
        return;
      }
      
      map(fixing->members, fix_room_contacts);
    }
  };

#ifdef OLD
  unguarded(function(){
    string file, *files=get_dir("/save/clusters/");
    foreach(file in files)
      rm(sprintf("/save/clusters/%s", file));
  });
#endif
}

private void make_clusters(mixed start){
  //read at your own risk...

  int count = 0, depth = -1, oldmax = maxnum, level = (stringp(start)? 0 :
                                                       load(start)->level + 1);
  class cluster current;
  mixed *list;
  function qdd, real;

  if(stringp(start)){ //normal rooms
    qdd = function(string room){

      //f leaves just the rooms with an exit back
      function f = function(string there, string room){
        mixed tmp;
        return member_array(room, 
                            (tmp = MAP->qdd(there), tmp? tmp : ({}))) + 1;
      };

      string *qdd = MAP->qdd(room);
      return filter(allocate(sizeof(qdd) / 2, (:$(qdd)[$1 * 2 + 1]:)), f, room);
    };

    real = (:$1:);

  } else { 
    qdd = (:load($1)->contacts:);

    if(stringp(load(start)->contacts[0]))
      real = (:cache[$1]:); //(:MAP->query_cluster($1):);
    else
      real = (:load($1)->cluster_number:);
  }
  
  current = new (class cluster, members:({start}),
                 level:level,
                 this_cluster:++maxnum,
                 contacts:({}));

  list = ({start});
  if(used[start])
    error(sprintf("%O already in a cluster", start));
  used[start] = 1;

  while(++depth < sizeof(list) || sizeof(todo)){
    mixed *exits;
    mixed exit;
    if(depth < sizeof(list)) 
      exits = (*qdd)(list[depth]);
    else { 
      count = SIZE + 1;
      exits = ({});
    }
    foreach(exit in exits) {
      if(!used[exit = (*real)(exit)]) {
        current->members += ({exit});
        list += ({exit});
        used[exit] = 1;
        if(++count > SIZE)
          break;
      }
    }
    if(count > SIZE || !(((1 + depth) < sizeof(list)) || sizeof(todo))){
      mixed tmp, *contacts = ({});
      count = 0;
      foreach(tmp in current->members){
        reset_eval_cost();
        if(stringp(tmp)){
#ifdef OLD
          MAP->set_cluster(tmp, current->this_cluster)
#endif
          ;
          cache[tmp] = current->this_cluster;
        }
        else{
          class cluster clust;
          clust = load(tmp);
          clust->cluster_number = current->this_cluster;
          cache[tmp] = clust;
        }
        
        exits = (*qdd)(tmp);

        if(exits){
          function add_non_member, convert_and_add;

          // and now we need to get the rooms this cluster connects to from the
          // exits info. 

          add_non_member = (: (member_array($2, $(current->members)) == -1)?
                            ($1 | ({ $2 })) : //don't want doubles
                            $1 //room was a member
                           :);

          convert_and_add = (:evaluate($(add_non_member), $1, 
                                      evaluate($(real), $2)):);

          contacts = implode(exits, convert_and_add, contacts);
        }
      }

      //and now we generate exit names for them
      current->contacts = contacts;

      if(sizeof(contacts) || current->level > 1)
        cache[current->this_cluster] = current; 
      else 
        maxnum--;

      todo = filter(todo + list + contacts, (:!used[$1]:)); //rooms not yet 
                                                            //in a cluster 

      depth = -1;
      if(sizeof(todo)){
        list = ({todo[0]});
        todo = todo[1..];
        if(used[list[0]])
          error("corrupt todo list");
        used[list[0]] = 1;
        
        current = new (class cluster, members:({list[0]}),
                       level:level,
                       this_cluster:++maxnum,
                       contacts:({}));
      } else 
        list = ({ });   
    }
  }
  
  if((maxnum - oldmax) > SIZE)
    make_clusters(current->this_cluster - 1);
  else { //fix contacts arrays
    int i;
    for(i = oldmax + 1; i <= maxnum; i++)
      if(LEVEL(i))
        efun::call_out(fix_contacts, 0, i);
      else
        efun::call_out(fix_room_contacts, 0, i);
  }
  used = ([]);
  efun::call_out((:cache = ([]), setup_done = 1:), 2);
}

#ifndef OLD
private int get_cluster(mixed thing){
  if(stringp(thing)){
    mixed exret = db_exec(db, "select cluster_number from cluster_members where member = '%s'",
                          db_escape(thing));
    if(!stringp(exret) && exret){
      return cdb_fetch(db, 1)[0];
    }
  } else if(intp(thing)){
    mixed exret = db_exec(db, "select in_cluster from cluster_list where cluster_number = %d",
                          thing);
    if(!stringp(exret) && exret){
      return cdb_fetch(db, 1)[0];
    }
  }
  return 0;
}
#endif

private int query_top_cluster(string room){
  int ret;
#ifdef OLD
  ret = MAP->query_cluster(room);

  if(ret && unguarded((:file_size(sprintf("/save/clusters/%d", $(ret))):)) > 0)
    while(load(ret)->cluster_number){
      int last = ret;
      ret = load(ret)->cluster_number;
      if(last == ret)
        return ret;
    }
#else
  ret = get_cluster(room);
  if(ret){
    int last = ret;
    ret = get_cluster(ret);
    while(ret){
      last = ret;
      ret = get_cluster(ret);
    }
    return last;
  }
#endif
  else{ //new cluster space
    setup_start_time = time();
    setup_done = 0;
    make_clusters(room);
  }

  return ret;
}

#ifndef OLD
private mixed *get_members(int clust){
  mixed rows;
  rows = db_exec(db, "select member from cluster_members where cluster_number = %d", clust);
  if(stringp(rows))
    return ({ });
  return allocate(rows, (:cdb_fetch(db, $1 + 1)[0]:));
}

private mixed *get_contacts(int clust){
  mixed rows;
  rows = db_exec(db, "select contact from cluster_contacts where cluster_number = %d", clust);
  if(stringp(rows))
    return ({ });
  return allocate(rows, (:cdb_fetch(db, $1 + 1)[0]:));
}
#endif

private mixed *find_places(int start, int end, int *places){
  int found = 0, depth = 0;
  int *key;
  int *exits, bing, *result, ob, exit;
  mapping search = ([]);

  if(start == end){
#ifdef OLD
    return load(start)->members;
#else
    return get_members(start);
#endif
  }

  key = ({ start });
  search[start] = "binglewop";
  while (!found) {
    reset_eval_cost();
    ob = key[depth];
    if (ob) {
      /* Get the destinations */
#ifdef OLD
      exits = load(ob)->contacts;
#else
      exits = get_contacts(ob);
#endif
      foreach(exit in exits) {
        if ((!search[exit]) && (member_array(exit, places) != -1 ||
                               sizeof(places) == 0)) {
          search[exit] = ob;
          key += ({ exit });
          if (exit == end)
            found = 1;
        }
      }
    }
    if (!found && ++depth >= sizeof(key))
      return 0;
  }

  exits = ({ });
  bing = end;
  result = ({ });

  while (bing != start) {
    reset_eval_cost();
#ifdef OLD
    result += load(bing)->members;
#else
    result += get_members(bing);
#endif
    bing = search[bing];
  }
#ifdef OLD
  result += load(bing)->members;
#else
  result += get_members(bing);
#endif
  return result;
} /* find_places() */
  
private mixed find_route(mixed start, mixed end, string *places){
  int found = 0, i, depth = 0;
  string *key;
  string *exits, bing, *result, ob;
  mapping route = ([]), search = ([]);
  int t = real_time();
  
  if(start == end)
    return ({});

  key = ({ start });
  route[start] = "binglewop";
  while (!found) {
    reset_eval_cost();
    ob = key[depth];
    if (ob) {
      /* Get the destinations */
      exits = MAP->qdd(ob);
      for (i = 1; i < sizeof(exits); i += 2) {
        mixed exit = exits[i];
        if ((!route[exit]) && (member_array(exit, places) != -1 ||
                               sizeof(places) == 0)) {
          route[exit] = exits[i - 1];
          search[exit] = ob;
          key += ({ exit });
          if (exit == end)
            found = 1;
        }
      }
    }
    if (!found && (++depth >= sizeof(key) || (real_time() - t) > 4))
      return 0;
  }
  
  exits = ({ });
  bing = end;
  result = ({ });

  while (bing != start) {
    reset_eval_cost();
    /* Create it backwards, we go from the destination to the source */
    result = ({route[bing]}) + result; 
    bing = search[bing];
  }
  return result;
} /* find_route() */

nosave int debugging = 0;

private void debug(int *clusters){
  int cluster;
  if(debugging)
    error("read the error trace");
  debugging = 1;
  reset_eval_cost();
  while(intp(load(clusters[0])->members[0]))
    clusters = implode(clusters, (:$1 + load($2)->members:), ({}));
  foreach(cluster in clusters){
    string *rooms = load(cluster)->members;
    string room, room2;
    reset_eval_cost();
    foreach(room in rooms)
      foreach(room2 in rooms)
        if(!this_object()->get_route(room, room2))
          error("cluster error");
  }
}


/** 
 * Returns an array with move instructions from 'start' to 'end'
 * @param start the start location
 * @param end the end location
 * @param callback the function to call back with the result
 */

string* get_route(string start, string end, function callback){
  mixed *places = ({}), *oldplaces;
  int sip = 0; //succes is possible
  int from, to;
  int level;

  if(lasttime != time()){
    lasttime = time();
    count = 0;
  } else {
    if(count++ > 10) {
      return ({}); //10 routes per second is madness, probably a broken npc
    }
  }

  if(!setup_done){
    if((time()-setup_start_time) < 5)  {
      return 0;
    }
    //looks like we're broken cp runtime logs.
#ifndef OLD
    //catch(db_close(db));
#endif
    catch(unguarded(function(){
      cp("/log/runtime", "/w/wodan/clusterruntime");
      cp("/log/catch", "/w/wodan/clustercatch");
    }));
    
    //destruct(this_object());
    tell_creator("wodan", "would have dested");
    setup_done = 1;
    return 0;
  }

  if(!stringp(start)){
    start = base_name(start);
    if(!stringp(start))
      error("illegal start point");
  }  
  if(!stringp(end)){
    end = base_name(end);
    if(!stringp(end))
      error("illegal end point");
  }  
  if(catch(from = query_top_cluster(start))){
#ifndef OLD
    //may have lost the database connection
    db_close(db);
    db = db_connect("localhost","discworld", CONFIG_DB_USER);
#endif
    return 0;
  }

  if(!setup_done) {
    return 0;
  }

  if(from) {
    level = LEVEL(from);
  }

  to = query_top_cluster(end);
    
  if(!to || (level != LEVEL(to))) {
    return ({}); //a route can't exist
  }

  while (level) {
#ifdef OLD
    from = MAP->query_cluster(start);
    to = MAP->query_cluster(end);
#else
    from = get_cluster(start);
    to = get_cluster(end);
#endif
    
    while((from != to) && (LEVEL(from) < level)){
      from = load(from)->cluster_number;
      to = load(to)->cluster_number;
    }
    
    level = LEVEL(from);
  
    if(!level){ //this can only happen in the first loop
      if(!sip) {
        break;
      }
      error("wrong level");
    }
    oldplaces = places;
    places = find_places(from, to, places);
  
    //printf("level %d sizeof places %d\n", level, sizeof(places));
    if(!places){
      if(!sip) {
        return ({});
      }
      debug(oldplaces);
      error("this can't happen, honest!");
    }
    sip = 1;
    level--;
  }


  // level is now 0
#ifdef OLD
  from = MAP->query_cluster(start);
  to = MAP->query_cluster(end);
#else
  from = get_cluster(start);
  to = get_cluster(end);
#endif
  
  oldplaces = places;
  places = find_places(from, to, places);
  
  if(!places){
    if(!sip) {
      return ({});
    }
    debug(oldplaces);
    error("this can't happen, honest!!");
  }

  //now places is an array of real rooms which should contain the rooms on the
  //route from start to end

  cache = ([]); // don't need to waste memory on the cache anymore
  return find_route(start, end, places);
}
  
#ifndef OLD
void dest_me(){
  db_close(db);
  destruct(this_object());
}
#endif
// --- END [/mnt/home2/grok/lib/obj/handlers/clusters.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/armoury.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/armoury.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628370   Available: 13575724
Inodes: Total: 5242880    Free: 4960134
15066 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/armoury.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628370   Available: 13575724
Inodes: Total: 5242880    Free: 4960134
2025-03-06 11:41:31.312128282 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming

/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: armoury.c,v 1.34 2002/11/10 02:17:42 ceres Exp $
 */
/**
 * Keeps track of all the standard armours, weapons and clothing.
 *
 * @see /include/armoury.h
 * @index armour
 * @index weapon
 * @index scabard
 * @index clothing
 * @index clothes
 * @index jewellery
 * @index misc
 * @index plants
 * @author Furball
 * @changes Many many, by many people
 * @changes 4/1/97 Ceres
 * The discworld armoury was rewritten by Ceres on 4/1/97 to handle
 * subdirectories within the standard dirs.
 * @changes 5/2/2001 Pinkfish
 * Changed to allow the various domains to have their own armoury
 * subdirectories that can be found and specified with a flag to the
 * creation sequences.
 * @changes 23 Apr 2001 Ceres
 * Removed the recycling. It was a lot of overhead for little benefit.
 * @changes 24 Aug 2001 Siel
 * added /obj/misc/, /obj/plants/ and /obj/furnitures/ to the request list
 */
#include <move_failures.h>
#include <armoury.h>

/* two week timeout */
#define MAX_RECYCLE 6


inherit "/std/room/basic_room";

#define DEFAULT_RECYCLE_AREA "default"
#define SAVE "/save/armoury"
#define TYPES ({"armours", "clothes", "weapons", "plants", "foods", "scabbards", "jewelleries", "misc" })

private nosave int _total_requests;

private mapping _smalls;
private mapping _armour_list;
private mapping _weapon_list;
private mapping _clothing_list;
private mapping _jewellery_list;
private mapping _scabbard_list;
private mapping _food_list;
private mapping _misc_list;
private mapping _plant_list;
private mapping _areas;
private mapping forbidden;

private void rehash_all();
int rehash(string place);
string* walk_directory (string);

/** @ignore yes */
void save_me() {
   unguarded( (: save_object(SAVE, 3) :));
} /* save_me() */

/** @ignore yes */
void load_me() {
   unguarded( (: restore_object(SAVE, 1) :));
} /* load_me() */

void setup() {
   set_short( "" + mud_name() + " Armoury" );
   add_property( "determinate", "the " );
   set_light( 50 );
   set_long( "You are in the " + mud_name() + " Armoury.  From here you can list "
         "all of the \"weapons\", \"armour\", \"clothing\", \"jewellery\", "
         "\"food\", \"plants\", \"misc\" "
         "and \"scabbards\" that are available, and \"request\" one of "
         "them.  The armoury stores its list of items in mappings, which "
         "can be updated with \"rehash\".  The list of forbidden items "
         "can be listed out or added to with \"forbid\".\n" );
   _smalls = ([ ]);
   _areas = ([ ]);
   _armour_list = _weapon_list = _clothing_list = _plant_list = _misc_list =
      _jewellery_list = _scabbard_list = _food_list = ([ ]);
   // If it is in the boot sequence
   load_me();
   rehash_all();
} /* setup() */

/**
 * This returns the list of small objects available for the area.  These
 * are things that can be fgound in gutters and so on.
 * @param area the area of the recycling
 * @return the array of small objects
 */
object *query_smalls(string area) {
   if (!area) {
      area = DEFAULT_RECYCLE_AREA;
   }
   return _smalls[area];
}

/**
 * Returns the list of domain armoury items.
 * @param domain the domain/area to get the items from.
 * @return the area sub-mapping.
 */
mapping query_area(string domain) {
  if (_areas[domain]) {
      return _areas[domain];
  }

  return ([ ]);
} /* query_area() */

int request(string, int, string);
int forbid(string);

/** @ignore yes */
void init() {
   string comm;
   ::init();
   add_command("rehash", "{foods|clothes|weapons|armours|misc|jewelleries|"
                         "scabbards|plants}",
                (:rehash($4[0]) :));
   add_command("rehash", "domain <string'domain'>",
                (:rehash($4[0]) :));
   add_command("request", "<string'item name'> <number'percent'>",
                (:request($4[0], $4[1], 0):));
   add_command("request", "<string'item name'> <number'percent'> in <string'area'>",
               (:request($4[0], $4[1], $4[2]):));
   add_command("forbid", "", (:forbid, "":));
   add_command("forbid", "<string'name'>", (:forbid($4[0]):));
   foreach(comm in ({"weapons", "armour", "clothing", "jewellery", "plant",
                     "misc", "scabbards", "food", })) {
      add_command(comm, "", (:call_other(this_object(), $(comm)):));
   }
} /* init() */

/* Internal Functions */

// create a list of armours/whatever.  base_dir is the dir to look in,
// extensions is the file extensions to look for.  The base_dir will be
// recursed to find all files in sub-dirs as well.
/** @ignore yes */
/** @ignore yes */
mapping make_list(string base_dir, string *extensions) {
  string *dirs, dir, extension, file_name;
  mapping list;
  mixed *files;

  dirs = walk_directory(base_dir);
  if (!arrayp(dirs)) dirs = ({ }); // Ensure array
  list = ([ ]);
  foreach (dir in dirs) {
    foreach (extension in extensions) {
      files = get_dir(dir + "*" + extension);
      if (arrayp(files)) { // Ensure array
        foreach (file_name in files) {
          if (file_name[0] != '.') {
            list[replace_string(explode(file_name, ".")[0], "_", " ")] = dir + file_name;
          }
        }
      }
    }
  }
  return list;
}

/** @ignore yes */
int clean_up(int i) { return 0; }

// External functions

/**
 * This will choose a small item from the specific area.
 * @param area the are to check in
 * @return the small object to choose
 */
object choose_small_item(string area) {
  object ob;

  if(!area)
    area = DEFAULT_RECYCLE_AREA;

  if(!_smalls || !_smalls[area] || !arrayp(_smalls[area]) || !_smalls[area][0])
    return 0;

  ob = clone_object(_smalls[area][0]);
  _smalls[area] = _smalls[area][1..];
  return ob;
}

/**
 * General item retreival function.  It returns a new item
 * it handles any sort of item.  The percentage is the
 * percentage condition in which it is returned.
 * The "word" parameter is the name of the requested item, essentially
 * the filename without directory and with "_"'s changed to " "'s. The
 * "percent" parameter is used as measure of how good it
 * is compared to a fully functional one. So a 50% dagger is only 50% as
 * good as a 100% one.
 * <p>
 * The file armoury.h defines the ARMOURY variable.  You need to include
 * this into your file to use it.  You should include this file and
 * uyse ythis define rather than the full path to the armoury, as
 * otherwise your code could stuff up :)
 * @param word the name of the item to retreive
 * @param percent the percentage condition to be in
 * @param area the area to choose the item in
 * @see /include/armoury.h
 * @return the requested object, or 0 on failure
 * @example
 * // get a slightly worn long sword and give it to the npc.
 * ARMOURY->request_item("long sword", 85)->move(npc);
 * @example
 * // Get a random condition armour.
 * armour = ARMOURY->request_item("leather jacket", random(100));
 */
object request_item(string word, int percent, string area) {
  int add_area;
  object thing;
  string filename;

  if(!word) {
    return 0;
  }
  if (!area) {
    area = DEFAULT_RECYCLE_AREA;
  }

  if (_areas[area] &&
      _areas[area][word]) {
    filename = _areas[area][word];
    add_area = 1;
  } else if(_weapon_list[word]) {
    filename = _weapon_list[word];
  } else if(_armour_list[word]) {
    filename = _armour_list[word];
  } else if(_clothing_list[word]) {
    filename = _clothing_list[word];
  } else if(_jewellery_list[word]) {
    filename = _jewellery_list[word];
  } else if(_scabbard_list[word]) {
    filename = _scabbard_list[word];
  } else if(_misc_list[word]) {
    filename = _misc_list[word];
  } else if(_plant_list[word]) {
    filename = _plant_list[word];
  } else if(_food_list[word]) {
    filename = _food_list[word];
  } else {
    if(base_name(previous_object()) != "/cmds/creator/req_uest") {
      printf( "No file for item \"%s\".\n", word );
      log_file( "ARMOURY", "%s No file for %s (%s)\n", ctime(time())[4..9],
                word, file_name( previous_object() ) );
    }
    return 0;
  }

  if(file_size( filename ) > 0)
    thing = clone_object(filename);

  if(!thing) {
    printf( "Cannot find item \"%s\".\n", word );
    log_file( "ARMOURY", "Cannot find %s (%s)\n", word,
              file_name( previous_object() ) );
    return 0;
  }

  _total_requests++;

  if(!_smalls[area])
    _smalls[area] = ({ });

  // If there's less than 20 items in the smalls list and this item meets
  // all the criteria then add it.
  if(sizeof(_smalls[area]) < 20 &&
     thing->query_weight() < roll_MdN(5, 20) && // must be small
     thing->query_value() < random(4000) && // not too valuable
     !thing->query_liquid() && // must not be a liquid
     !sizeof((mapping)thing->query_value_info()) &&
     strsrch(filename, "_pt") == -1 && // not in pt
     strsrch(filename, "_dev") == -1 && // not in dev
     !thing->query_property("no recycling")) { // must be recyclable
    _smalls[area] += ({ filename });
  }

  if (add_area)
    thing->add_property(ARMOURY_RECYCLING_AREA_PROP, area);

  thing->set_percentage( percent );
  return thing;
} /* request_item() */

/**
 * This method tries to find a match for the object if it has moved between
 * directories.
 * @param path the old path
 * @return the new path
 */
string remap_file_path(string path) {
   string* bits;
   mapping list;
   string new_fname;

   bits = explode(path, "/");
   if (bits[0] != "obj") {
      return path;
   }
   switch (bits[1]) {
   case "armours" :
      list = _armour_list;
      break;
   case "weapons" :
      list = _weapon_list;
      break;
   case "clothes" :
      list = _clothing_list;
      break;
   case "jewellery" :
      list = _jewellery_list;
      break;
   case "scabbards" :
      list = _scabbard_list;
      break;
   case "food" :
      list = _food_list;
      break;
   case "misc" :
      list = _misc_list;
      break;
   case "plants" :
      list = _plant_list;
      break;
   }

   if (list) {
      new_fname = list[replace_string(explode(bits[<1], ".")[0], "_", " ")];
      if (new_fname) {
         return new_fname;
      }
   }

   return path;
} /* remap_file_path() */

// Action functions

// Update the list of known items
/** @ignore yes */
int rehash(string thing) {
  string special;
  int found;

  switch (thing) {
  case "armours" :
     _armour_list=make_list("/obj/armours/", ({".arm", ".c"}));
     break;
  case "clothes" :
     _clothing_list=make_list("/obj/clothes/", ({".clo", ".c"}));
     break;
  case "weapons" :
     _weapon_list = make_list("/obj/weapons/", ({".wep", ".c"}));
     break;
  case "scabbards" :
     _scabbard_list = make_list( "/obj/scabbards/", ({ ".sca", ".c" }));
     break;
  case "jewellery" :
  case "jewelleries" :
     _jewellery_list = make_list( "/obj/jewellery/", ({ ".arm", ".clo", ".c" }));
     break;
  case "food" :
  case "foods" :
     _food_list = make_list( "/obj/food/", ({ ".ob", ".food", ".c" }));
     break;
  case "misc" :
     _misc_list = make_list( "/obj/misc/", ({ ".ob", ".c" }));
     break;
  case "plants" :
     _plant_list = make_list( "/obj/plants/", ({ ".ob", ".food", ".c" }));
     break;
  default :
    // Rehash the domains...
    if (file_size("/d/" + thing + "/items") == -2) {
      _areas[thing] = make_list( "/d/" + thing + "/items/",
                                  ({ ".arm", ".c", ".clo", ".wep", ".sca",
                                     ".ob", ".food" }));
      found = 1;
    }
    if (file_size("/d/" + thing + "/armoury") == -2) {
      foreach (special in get_dir("/d/" + thing + "/armoury")) {
         if (file_size("/d/" + thing + "/armoury/" + special + "/") == -2) {
           _areas[special] = make_list( "/d/" + thing + "/armoury/" + special + "/",
                                  ({ ".arm", ".c", ".clo", ".wep", ".sca" }));
         }
      }
       return 0;
    }
  }

  save_me();

  write("Rehash of " + thing + " complete.\n");
  return 1;
}

/**
 * This method rehashes a specific directory of things.  At the moment we
 * fudge this a little.
 * @param dir the directory to rehash
 * @return 1 if it found something to rehash
 */
int rehash_specific_dir(string dir) {
   return rehash(explode(dir, "/")[1]);
}

/**
 * This will only be called in the bootup sequence -- yea right! I've made it
 * work a little more slowly.
 */
private void rehash_all() {
  string thing;
  int i;

  foreach(thing in TYPES + "/secure/master"->query_domains()) {
    i += 5;

    call_out("rehash", i, thing);
  }
} /* rehash_all() */

/** @ignore yes */
string *query_types() { return TYPES + keys(_areas); }

/** @ignore yes */
mapping query_items(string type, string filter) {
  mapping items;
  string item;

  switch(type) {
  case "armours":
    items = _armour_list;
    break;
  case "weapons":
    items = _weapon_list;
    break;
  case "clothes":
    items = _clothing_list;
    break;
  case "jewellery":
  case "jewelleries":
    items = _jewellery_list;
    break;
  case "scabbards":
    items = _scabbard_list;
    break;
  case "food":
  case "foods":
    items = _food_list;
    break;
  case "misc":
    items = _misc_list;
    break;
  case "plants":
    items = _plant_list;
    break;
  default:
    if(member_array(type, "/secure/master"->query_domains()) != -1 &&
       _areas[type])
      items = _areas[type];
    else
      return 0;
  }

  items = copy (items);
  if (sizeof (filter)) {
    foreach(item in keys(items))
      if(strsrch(item, filter) == -1)
        map_delete(items, item);
  }
  return items;
}

// Return an item for someone
/** @ignore yes */
int request( string word, int percentage, string area ) {
  object thing;

  thing = request_item( word, percentage, area );

  if ( !thing ) {
    add_failed_mess(word + " not found.\n");
    return 0;
  }
  if ( (int)thing->move( this_player() ) != MOVE_OK ) {
    write( (string)thing->a_short() +" has been placed in here.\n" );
    thing->move( this_object() );
  } else
    write( (string)thing->a_short() +
          " has been placed in your inventory.\n" );
  return 1;
} /* request() */

/** @ignore yes */
mixed stats() {
  string tmp;
  mixed *ret;

  ret = ({ });
  foreach(tmp in keys(_areas)) {
    ret += ({ tmp, sizeof(_areas[tmp]) });
  }
  
  return ::stats() + ({
    ({ "item requests", _total_requests, }),
      ({ "armours", sizeof(_armour_list) }),
      ({ "clothes", sizeof(_clothing_list) }),
      ({ "weapons", sizeof(_weapon_list) }),
      ({ "scabbards", sizeof(_scabbard_list) }),
      ({ "jewellery", sizeof(_jewellery_list) }),
      ({ "food", sizeof(_food_list) }),
      ({ "misc", sizeof(_misc_list) }),
      ({ "plants", sizeof(_plant_list) }),
      ret });
} /* stats() */

/** @ignore yes */
string* walk_directory(string dir) {
  string *tmp, *dirs = ({ }), *tmp2;
  mixed *file;

  tmp = get_dir(dir, -1);
  if (!arrayp(tmp)) tmp = ({ }); // Ensure array

  if (sizeof(tmp))
    dirs += ({ dir });

  foreach (file in tmp) {
    if (file[1] == -2) {
      tmp2 = walk_directory(dir + file[0] + "/");
      if (sizeof(tmp2))
        dirs += tmp2;
    }
  }

  return dirs;
}
// --- END [/mnt/home2/grok/lib/obj/handlers/armoury.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/playerinfo.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/playerinfo.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628366   Available: 13575720
Inodes: Total: 5242880    Free: 4960134
47950 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/playerinfo.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628366   Available: 13575720
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*
 * $Locker:  $
 * $Id: playerinfo.c,v 1.63 2003/05/31 18:40:26 ceres Exp $
 */

/**
 * Playerinfo database handler.
 *
 * This handler collects all the fascinating information about players and
 * their sins. At the moment, the following events are supported:
 * replace (all replacements, added by Presto's wand),
 * gag (gagging and ungagging, added by the gagger),
 * suspend (player suspension, added by the "suspend" command),
 * meteor (meteoring a player, added by the "meteor" command),
 * multiplay (various events added by the multiplayer handler),
 * harassment (comments about cases of harassment, added via 'addevent'),
 * misc (misc. comments, added via 'addevent'),
 * cheat (currently unused)
  *
 * The "replace" and "multiplay" events are debounced (merged). In addition,
 * the "replace" events expire in 30 days.
 *
 * @author Fiona
 */
#include <playerinfo.h>
#include <player_handler.h>
#include <refresh.h>
#include <applications.h>
#include <newbiehelpers.h>

// This is where our save files go
#define SAVE_DIR         "/save/playerinfo"
#define SAVE_FILE        ( SAVE_DIR + "/handler_data" )
#define NO_ACCESS_LOG    6

// Originators of function calls. Checked for security reasons
#define LIAISON_WAND       "/d/liaison/items/wand"
#define LIAISON_SCEPTRE    "/d/liaison/items/mort_sceptre"
#define LIAISON_PEN        "/d/liaison/items/quota_pen"
#define LIAISON_INTERVIEW  "/d/liaison/utils/interview"
#define MULTIPLAY          "/obj/handlers/multiplayer"
#define GAG                "/cmds/creator/gag"
#define UNGAG              "/cmds/creator/ungag"
#define METEOR             "/cmds/creator/meteor"
#define FRY                "/cmds/creator/fry"
#define REPORT_COMMAND     "/cmds/creator/playerinfo"
#define ADD_COMMAND        "/cmds/creator/addevent"
#define DELETE_COMMAND     "/cmds/creator/delevent"
#define ADDALT_COMMAND     "/cmds/creator/addalt"
#define DELALT_COMMAND     "/cmds/creator/delalt"
#define FAMILY_COMMAND     "/cmds/creator/family"
#define SUSPENDER          "/secure/bastards"
#define SHOWHELP_COMMAND   "/cmds/creator/show_help"
#define PATRICIAN_PALACE   "/d/am/patrician/patrician"
#define REFRESH_HANDLER    "/obj/handlers/refresh"
#define PRISON             "/d/sur/beta/prison/dungeon"
#define FETCH_COMMAND      "/cmds/creator/fetch"
#define REARRANGE_COMMAND  "/cmds/guild-race/rearrange"
#define PATRICIAN_PT       "/d/playtesters/handlers/applications"
#define PATRICIAN_COMPLAIN "/d/am/patrician/pat_complaints"
#define RUN_HANDLER        "/obj/handlers/guild_things/run"
#define BANISH_COMMAND     "/secure/cmds/creator/banish"
#define FAIRY_GODMOTHER    "/obj/handlers/fairy_godmothers"

#define CACHE_SIZE 150

// These don't really belong here... and we have /include/colour.h...
// ...oh well.
#define CL_CREATOR      "%^CYAN%^"
#define CL_EVENT        "%^RED%^"
#define CL_RESET        "%^RESET%^"
#define CL_HEADER       "%^RED%^"

// This is the interval at which debounced events are saved.
#define DEBOUNCE_PERIOD (60*30)

// This is the interval between consecutive checks for timeouts.
// One day is suffucuent.
#define TIMEOUT_PERIOD  (60*60*24)


//This is one week.
#define ONE_WEEK           ( 60 * 60 * 24 * 7 )

nosave inherit "/std/object";

// Function prototypes
mapping          query_timeouts();
protected string filename(string name);
string *         query_events();
protected int    query_debounced(string event);
protected int    query_lord_only(string event);
int              query_source_ok(string event, string source);
protected int    query_deleter_ok(string event, object deleter);
protected int    query_can_add(string e, object p);
protected int    query_can_delete(string e, object p);
protected int    query_can_handle_alts(object p);
protected void   do_debouncing(string player, class dbentry entry);
protected void   do_timeout();
protected void   load_player(string player);
protected void   save_player(string player);
void             player_remove(string player);
int              add_entry(object creator, string player, string event,
                   string comment, mixed *extra);
int              delete_entry(object creator, string player, string event,
                   int n);
protected string query_header(string player);
protected string query_entry(int idx, class dbentry e,
                   string display_name);
string           query_access_log(object source, string player, int lastn);
string           query_event(object source, string player, string event);
string           add_alt(object creator, string player, string alt);
string           delete_alt(object creator, string player, string alt);
mapping          query_alerts();
int              query_alerts_for( string player );
int              is_alert( string player, int idx );
int              acknowledge_alert( object creator, string player,
                   string event, int idx, string update, mixed * extra );
void             clear_alerts_for( string player );
int              increment_alerts_for( string player );
int              decrement_alerts_for( string player );
void             correct_alts_for( string player );
void player_deleted(mixed player, int deleted);
void fix_alts(mixed player);

class source {
   string *add;
   string *delete;
}

// This is where the current player's info resides.
private class playerinfo    dossier;
// Event timeout information (in seconds)
private nosave mapping      timeouts    = ([ "replace" : (60*60*24*30) ]);

// Ok guys, NEVER do things like this, it is highly poisonous...
private int local_time;
private nosave mapping _sources;

nosave mapping _alerts; // format: ([ "playername1":n, "playername2":n ... ])
                 // where n is the number of alerts in their dossier.
nosave string * _lordonly;

private nosave int correcting_alts; // used to control the alt correction
                                    // process so we don't loop infinitely.
private nosave int no_recurse;

private nosave mapping _dossier_cache;
private nosave int _dossier_cache_hits;
private nosave int _dossier_total;

void save_handler_data() {
   mapping vars = ([ ]);
   string tmp;

   vars["alerts"] = _alerts;

   tmp = save_variable( vars );
   
   unguarded( (: write_file, SAVE_FILE, tmp, 1 :) );
} /* save_handler_data() */

void load_handler_data() {
   mapping vars;
   string tmp;

   if( file_size( SAVE_FILE ) <= 0 )
      return;

   tmp = unguarded( (: read_file, SAVE_FILE :) );
   vars = restore_variable( tmp );

   _alerts = vars["alerts"];
} /* load_handler_data() */

void create() {
    ::create();
    _sources = ([
        "cheat":        new(class source,
                            add : ({ }),
                            delete : ({ DELETE_COMMAND })),
        "discipline":   new(class source,
                            add : ({ ADD_COMMAND, PRISON, REPORT_COMMAND,
                                     BANISH_COMMAND }),
                            delete : ({ DELETE_COMMAND })),
        "email":        new(class source,
                            add : ({ }),
                            delete : ({ DELETE_COMMAND })),
        "family":       new(class source,
                            add : ({ FAMILY_COMMAND }),
                            delete : ({ DELETE_COMMAND })),
        "gag":          new(class source,
                            add : ({ GAG, UNGAG,
                                     ADD_COMMAND, REPORT_COMMAND }),
                            delete : ({ DELETE_COMMAND })),
        "harassment":   new(class source,
                            add : ({ ADD_COMMAND, REPORT_COMMAND }),
                            delete : ({ DELETE_COMMAND })),
        "meteor":       new(class source,
                            add : ({ METEOR, FRY }),
                            delete : ({ DELETE_COMMAND })),
        "misc":         new(class source,
                            add : ({ ADD_COMMAND, APPLICATIONS_HANDLER,
                                     REARRANGE_COMMAND, PATRICIAN_PT,
                                     PATRICIAN_COMPLAIN, RUN_HANDLER,
                                     REPORT_COMMAND, NEWBIEHELPERS_HANDLER, 
                                     LIAISON_SCEPTRE, 
                                     LIAISON_PEN, FAIRY_GODMOTHER,
                                     LIAISON_INTERVIEW }),
                            delete : ({ DELETE_COMMAND })),
        "multiplay":    new(class source,
                            add : ({ MULTIPLAY, ADD_COMMAND,
                                     REPORT_COMMAND }),
                            delete : ({ DELETE_COMMAND })),
        "replace":      new(class source,
                            add : ({ LIAISON_WAND, 
                                     ADD_COMMAND, FETCH_COMMAND, 
                                     REPORT_COMMAND }),
                            delete : ({ DELETE_COMMAND })),
        "showhelp":     new(class source,
                            add : ({ SHOWHELP_COMMAND }),
                            delete : ({ DELETE_COMMAND })),
        "suspend":      new(class source,
                            add : ({ SUSPENDER }),
                            delete : ({ })),
        "alert":        new(class source,
                            add : ({ ADD_COMMAND, REPORT_COMMAND }),
                            delete : ({ DELETE_COMMAND })),
        "refresh":      new(class source,
                            add : ({ REFRESH_HANDLER }),
                            delete : ({ DELETE_COMMAND })),
        "delete":      new(class source,
                           add : ({ REFRESH_HANDLER }),
                           delete : ({ DELETE_COMMAND }))
    ]);

    _alerts = ([ ]);
    _lordonly = ({ });
    _dossier_cache = ([ ]);
    _dossier_cache_hits = 0;
    _dossier_total = 0;

    seteuid("Room");
    load_handler_data();


} /* create() */

// Return the mapping of event timeouts
mapping query_timeouts() {
    return timeouts;
} /* query_timeouts() */

string query_name() {
    return "playerinfo handler";
}

/**
 * Give the filename for the player's savefile.
 * @param name the name of the player
 * @return the name of the playerinfo file
 * @ignore
 */
protected string filename(string name) {
    string p = lower_case(name);
    return sprintf("%s/%c/%s.o",SAVE_DIR,p[0],p);
} /* filename() */

/**
 * Answer the list of all possible events.
 * @return array of all event types recognized by the playerinfo handler
 */
string *query_events() {
    return keys(_sources);
} /* query_events() */

/**
 * Check if the event should be debounced.
 * @param event the name of the event
 * @return nonzero if the given event is to be debounced
 * @ignore
 */
protected int query_debounced(string event) {
    return (event == "replace" || event == "multiplay" ||
            event == "gag" || event == "misc" ||
            event == "discipline" || event == "showhelp" ||
            event == "suspend");
} /* query_debounced() */

/**
 * Check if the event is lords-only.
 * @param event the name of the event
 * @return nonzero if the event can only be added by lords
 * @ignore
 */
protected int query_lord_only(string event) {
    return ( member_array( event, _lordonly ) >= 0 ) ? 1 : 0;
} /* query_lord_only() */

/**
 * Check if the event has come from the valid source.
 * @param event the name of the event
 * @param source the object trying to add the event
 * @return nonzero if the event can be added by the given source
 */
int query_source_ok(string event, string source) {
    // 0 means no check should be done; ({ }) means nobody can add it
    string *reqd;

    reqd = _sources[event]->add;

    if(reqd == 0) {
        return 1;
    }
    if(sizeof(reqd) == 0) {
        return 0;
    }
    return member_array(source,reqd) >= 0;
} /* query_source_ok() */

/**
 * Check if the request to delete an event came from the valid source.
 * @param event the name of the event
 * @param remover the object that tries to remove the event
 */
protected int query_deleter_ok(string event, object deleter) {
    // 0 means no check should be done; ({ }) means nobody can delete it
    string *reqd;

    reqd = _sources[event]->delete;

    if (reqd == 0) {
        return 1;
    }
    if (sizeof(reqd) == 0) {
        return 0;
    }
    return member_array(base_name(deleter),reqd) >= 0;
} /* query_deleter_ok() */

/**
 * Check if the player is allowed to add the event.
 * @param e the name of the event
 * @param p the player who is trying to add it
 * @return nonzero of the player is allowed to add the event
 * @ignore
 */
protected int query_can_add(string e, object p) {
    if(member_array(e,query_events()) < 0)
        return 0;
    if(!interactive(p))
        return 1;
    return !(query_lord_only(e) && !p->query_lord());
} /* query_can_add() */

/**
 * Check if the player is allowed to perform delete operations.
 * @param p the player who is trying to delete something
 * @ignore
 */
protected int query_can_delete(string e, object p) {
    if( !interactive(p) ) {
        return 1;
    }
    if( e == "misc" || e == "replace" ) {
        return master()->query_senior( p->query_name() ) ||
               "/d/liaison/master"->query_deputy( p->query_name() );
    }
    return p->query_lord();
} /* query_can_delete() */

/**
 * Check if the player is allowed to add and delete alt characters.
 * @param p the player who is trying to add or delete alt(s)
 * @ignore
 */
protected int query_can_handle_alts(object p) {
    if( !interactive(p) ) {
        return 1;
    }
    return master()->query_senior( p->query_name() ) ||
           "/d/liaison/master"->query_deputy( p->query_name() );
} /* query_can_handle_alts() */

/**
 * Check if we can debounce the event. Add a new event or modify
 * the last event depending on whether it's debounceable or not.
 * @param player the name of the player for which the database entry is added
 * @param entry the database entry to be added
 * @ignore
 */
protected void do_debouncing(string player, class dbentry entry) {
    int             n;
    class dbentry   last;

    if (query_debounced(entry->event)) {
        //tell_creator("pinkfish", "[playerinfo] Debouncing: %O.\n",entry);
        n = sizeof(dossier->data);
        if ( n ) {
            last = dossier->data[ n - 1 ];
            //tell_creator("pinkfish", "[playerinfo] Last: %O.\n",last);
            if( entry->event == last->event &&
                entry->creator == last->creator &&
                entry->time - last->time <= DEBOUNCE_PERIOD)
            {
                // Merge the two events
                // tell_creator("pinkfish", "[playerinfo] Merging events.\n");
                last->comment += entry->comment;
                last->time = entry->time;
                if(last->extra != 0) {
                    if(entry->extra == 0) {
                        entry->extra = ({ });
                    }
                    last->extra += entry->extra;
                }
                //tell_creator("pinkfish", "[playerinfo] Result: %O.\n",last);
                return;
            }
        }
    }
    //tell_creator("pinkfish", "[playerinfo] Not merging events.\n");
    dossier->data += ({ entry });
    return;
} /* do_debouncing() */

/**
 * Check the currently loaded data for timed out entries and remove them.
 * @ignore
 */
protected void do_timeout() {
    function not_timed_out = function(class dbentry p)
    {
        int life = timeouts[p->event];

        if(life == 0)          // This event cannot be timed out
            return 1;
        // Time it out if its life period has expired
        return local_time <= (p->time + life);
    };

    local_time = time();

    dossier->data = filter(dossier->data, not_timed_out);
    dossier->last_check = time();
} /* do_timeout() */

/**
 * Load the data of the playerinfo object from its save file. If there's no
 * file, create an empty dossier. Don't load anything if the data is
 * already loaded.
 * @param player the name of the player whose data is to be loaded
 * @ignore
 */
protected void load_player(string player) {
    string  p = lower_case(player);
    string  fn = filename(p);
    class playerinfo tmp;
    mixed result;

    _dossier_total++;

    if ( !undefinedp(_dossier_cache[ player ] ) ) {
        dossier = _dossier_cache[ player ]; 
        _dossier_cache_hits++;
        return; 
    }

    if( dossier != 0 && dossier->name == p ) {
        return;                // Already have it here
    }

    if(file_size(fn) > 0) {
        result = unguarded( (: restore_object, fn, 0 :) );
    } else {
        dossier = new(class playerinfo,
            name:       p,
            last_check: time(),
            alts:       ({ }),
            data:       ({ }));
    }

    if (!classp(dossier)) {
        dossier = new(class playerinfo,
            name:       p,
            last_check: time(),
            alts:       ({ }),
            data:       ({ }));
    }

    if(sizeof(dossier) == 5) {
      tmp = new(class playerinfo,
                name: dossier->name,
                last_check: dossier->last_check,
                alts: copy(dossier->alts),
                data: copy(dossier->data),
                main_alt: dossier->main_alt,
                old_alts: ({ }));
      dossier = tmp;
    }
    if(!dossier->old_alts)
      dossier->old_alts = ({ });
    
    // Try and correct some of the damage caused by the last batch
    // of changes which screwed up the alt system.
    if(!correcting_alts) {
        correct_alts_for( dossier->name );
    }

    _dossier_cache[ player ] = dossier;
} /* load_player() */

/**
 * Save the data of the playerinfo object to its save file.
 * @param player the name of the player whose data is to be saved
 * @ignore
 */
protected void save_player(string player) {
    if( time() - dossier->last_check >= TIMEOUT_PERIOD ) {
        do_timeout();
    }

    unguarded( (: save_object, filename(player) :) );
} /* save_player() */

/**
 * Remove the player's data file.
 * @param player the name of the player
 */
void player_remove(string player) {
    string alt, new_main;
    string * alts;

    if ( !player ) {
        return;
    }
    player = lower_case( player );

    // If this is a main alt, pick one of their alts and make them the
    // main.
    correcting_alts = 1;
    load_player( player );
    if ( sizeof( dossier->alts ) ) {
        // Grab a list of alts from this dossier...
        alts = copy( dossier->alts );
        new_main = alts[0];

        alts -= ({ new_main });
        // ... Set up the new main player...
        load_player( new_main );
        dossier->main_alt = 0;
        dossier->alts = uniq_array( alts + ({ player }) );
        save_player( new_main );

        // ... And make all the other alts point to the new main.
        foreach( alt in alts ) {
            load_player( alt );
            dossier->main_alt = new_main;
            save_player( alt );
        }
    }
    correcting_alts = 0;

    unguarded( (: rm, filename(player) :) );
    clear_alerts_for(player);
} /* player_remove() */

/**
 * Add a new entry to the player's database.
 * @param source the creator or another object trying to add the event
 * @param player the name of the player
 * @param event event the name of the event to be added
 * @param comment arbitrary comment text (more than one line is OK)
 * @param extra arbitrary array of arbitrary objects (can be 0)
 * @return nonzero if the entry was successfully added to the database
 */
int add_entry(object creator, string player, string event, string comment,
  mixed *extra) {
    class dbentry   new_entry;

    if(!query_can_add(event,creator))
        return 0;              // No permission to add this event
    if(!query_source_ok(event,base_name(previous_object())))
        return 0;              // Wrong object trying to add this event
    if(!PLAYER_HANDLER->test_user(lower_case(player)))
        return 0;              // No such player
    if(comment[<1..<1] != "\n") {
        comment += "\n";
    }

    load_player(player);
    new_entry = new(class dbentry,
            time:       time(),
            creator:    capitalize(creator->query_name()),
            event:      event,
            comment:    (comment == 0 ? "" : comment),
            extra:      extra);
    do_debouncing(player, new_entry);
    save_player(player);
    // Add the player to the alerts mapping (to be checked by the login
    // handler which will dispatch warnings to currently online creators
    // the next time the player logs in, until the event is acknowledged)
    if( event == "alert" )
        increment_alerts_for(player);
    return 1;
} /* add_entry() */

/**
 * Delete an entry from the playerinfo database.
 * @param source the creator or another object trying to add the event
 * @param player the name of the player
 * @param event the name of the event of the entry being deleted
 * @param n the index of the entry being deleted
 * @return nonzero if the entry was successfully deleted
 */
int delete_entry(object creator, string player, string event, int n) {
   int idx = n - 1;
   class dbentry * data;
   class dbentry fluff;

   if( !query_can_delete( event, creator ) )
      return 0;
   if( !query_deleter_ok( event, previous_object() ) )
      return 0;      // Wrong object trying to delete this event
   load_player(player);
   if( ( idx < 0 ) || ( idx >= sizeof( dossier->data ) ) )
      return 0;
   fluff =  dossier->data[idx];
   if( fluff->event != event )
      return 0;

   data = copy( dossier->data );
   data = data[0 .. (idx - 1)] + data[(idx + 1) .. <1];
   dossier->data = data;
   save_player(player);
   log_file("DELETE", ctime(time()) + ": " + event + " added by " +
            fluff->creator + "\n");

   if( event == "alert" )
      decrement_alerts_for(player);

   return 1;
} /* delete_entry() */

/**
 * Print the header of of the database report.
 * @param source the creator who requested the report
 * @param player the name of the player
 * @ignore
 */
protected string query_header( string player ) {
  string aka, alts, str;
  string *tmp, *tmp2;
  
  aka = alts = str = "";
  
  if( sizeof( dossier->alts ) > 0 )
    alts = " aka " +
      query_multiple_short(map(dossier->alts,
                               (: CL_HEADER+capitalize($1)+CL_RESET :)));
  if(sizeof(dossier->old_alts) > 0)
    alts += " (and was " +
      query_multiple_short(map(dossier->old_alts,
                               (: CL_HEADER+capitalize($1)+CL_RESET :))) + ")";
    
  if( dossier->main_alt ) {
    // Cleanup their alt list if the main_alt is deleted.
    if(!PLAYER_HANDLER->test_user(dossier->main_alt)) {
      fix_alts(player);
      load_player(player);
    }
        
    aka = " (alt of " + CL_HEADER + capitalize(dossier->main_alt) + CL_RESET;

    // Load up the 'main' player file and grab a list of all their alts,
    // then reload this player's file.
    load_player(dossier->main_alt);
    tmp = copy(dossier->alts);
    tmp2 = copy(dossier->old_alts);
    
    if(!tmp) {
      tmp = ({ });
      dossier->alts = ({ });
      save_player( dossier->name );
    }
    load_player(player);

    tmp -= ({ player });
    if(sizeof(tmp)) 
      aka += ", aka " +
        query_multiple_short(map(tmp, (: CL_HEADER+capitalize($1)+CL_RESET :)));

    if( arrayp( tmp2 ) ) {
      tmp2 -= ({ player });
      if(sizeof(tmp2)) {
        aka += " and was " +
          query_multiple_short(map(tmp2, (: CL_HEADER+capitalize($1)+CL_RESET:)));
      }
    }
    aka += ")";
  }
  return sprintf( "Report for: %s%s%s\n\n",
                  CL_HEADER + capitalize(player) + CL_RESET, alts, aka );
}

/**
 * Print one entry of the dossier.
 * @param source the creator who requested the report
 * @param idx the index of the database entry to print
 * @param e the database entry to print
 * @ignore
 */
protected string query_entry( int idx, class dbentry e,
                              string display_name ) {
   string  date      = ctime( e->time );
   string  creator   = e->creator;
   string  event     = e->event;
   string  *comments = explode( e->comment, "\n" );
   string  line, str;
   int     lines = 0;

   if( display_name )
      display_name = sprintf( "%-31s ",
        "(" + CL_CREATOR + display_name + CL_RESET + ")" );
   else
      display_name = "";
   str = sprintf( "%2d. %s%s %s%|14s%s (by %s%s%s)\n",
     idx + 1, display_name, date, CL_EVENT, event, CL_RESET,
     CL_CREATOR, creator, CL_RESET );
   foreach( line in comments ) {
      if( sizeof(line) != 0 ) {
         str += sprintf( "    %s\n", line );
         lines++;
      }
   }
   if( !lines ) {
      str += sprintf( "    (no comments)\n" );
   }
   return str;
}

/**
 * Print all entries from the given player's dossier.
 * @param source the creator who requested the report
 * @param player the name of the player
 */
varargs string query_dossier( object source, string player, int lastn ) {
   int             i;
   class dbentry   * list;
   string          msg, str;
   mapping         log;

   load_player(player);
   str = query_header(player);
   list = dossier->data;

   //Backwards compatability.
   if ( sizeof( dossier ) == NO_ACCESS_LOG ) {
    dossier = new ( class playerinfo, 
        name: dossier->name,
        last_check: dossier->last_check,
        alts: dossier->alts,
        data: dossier->data,
        main_alt: dossier->main_alt,
        old_alts: dossier->old_alts,
        access_log: ([ ]) );
   }

   if ( mapp( dossier->access_log ) ) 
     log = dossier->access_log;
   else
     log = ([ ]);

   if( !lastn ||
       sizeof(list) <= lastn ||
       source->query_property(VERBOSE_PI) )
   {
      i = 0;
   } else {
      i = sizeof(list) - lastn;
      msg = "%^RED%^NOTE:%^RESET%^ Only displaying this player's most "
        "recent " + lastn + " entries.  Use 'playerinfo "
        + player + " verbose' to see their entire dossier.\n";
      str += msg + "\n";
   }

   for( ; i < sizeof( list ); i++ ) {
      str += query_entry( i, list[i], 0 );
   }

   if( msg ) {
      str += "\n" + msg;
   }

   //Filter week old entries.
   log = filter( log, (: $2 > time() - ONE_WEEK :) );

   //Add new ones!
   if ( interactive( source ) ) 
     log[ source->query_name() ] = time();

  //Restore the access log.
  dossier->access_log = log;
  save_player( player );
  return str;
}

/**
 * Print all entries from the given player's dossier with the given event
 * type.
 * @param source the creator who requested the report
 * @param player the name of the player
 * @param event the name of the event
 */
string query_event( object source, string player, string event ) {
   int             i;
   class dbentry   *list;
   string          str;

   load_player(player);
   str = query_header(player);
   list = dossier->data;
   for( i = 0; i < sizeof(list); i++ ) {
      if( list[i]->event == event )
         str += query_entry( i, list[i], 0 );
   }
   return str;
}

/**
 * Print all entries for this player and all alts, in chronological order.
 * @param source the creator who requested the report
 * @param player the name of the player
 */
string query_interleaved( object source, string player, string event ) {
   class playerinfo * dossiers;
   class dbentry * stuff;
   string str;
   string * alts;
   int i, size, done, earliest, earliestt, count;
   int * earliests;

   load_player(player);
   if( dossier->main_alt ) {
      player = dossier->main_alt;
      load_player(player);
   }
   str = query_header(player);

   // Find all this player's alts
   alts = ({ player }) + copy( dossier->alts );
   size = sizeof(alts);

   // If the player has no alts, just use the standard dossier display code
   if( size == 1 ) {
      if(event) {
        str = query_event( source, player, event );
      } else {
        str = query_dossier( source, player );
      }
      return str;
   }

   // load up all of the dossiers locally
   dossiers = allocate(size);
   earliests = allocate(size);
   for( i = 0; i < size; i++ ) {
     load_player( alts[i] );
     if( sizeof( dossier->data ) ) {
       dossiers[i] = copy(dossier);
     } else {
       dossiers[i] = 0;
     }
     earliests[i] = 0;
   }

   // loop until there are no entries left to display.
   count = 0;
   while( !done ) {
      done = 1;
      earliestt = 0;
      for( i = 0; i < size; i++ ) {
         if( !dossiers[i] ) {
            continue;
         }
         done = 0;
         stuff = dossiers[i]->data;
         if( !earliestt || stuff[ earliests[i] ]->time < earliestt ) {
            earliest = i;
            earliestt = stuff[ earliests[i] ]->time;
         }
      }
      if(done) {
         continue;
      }
      stuff = dossiers[earliest]->data;
      if( !event ||
          stuff[ earliests[earliest] ]->event == event )
      {
         str += query_entry( count, stuff[ earliests[earliest] ],
                             alts[earliest] );
         count++;
      }
      earliests[earliest]++;
      if( earliests[earliest] >= sizeof(stuff) ) {
         dossiers[earliest] = 0;
      }
   }
   return str;
}

/**
 * Return which player this player is an alt of (if any).
 * param player A players name
 * return the name of the players main alt.
 */
string query_alt_of(string player) {
  if(!PLAYER_HANDLER->test_user(player))
    return 0;
  
  load_player(player);
  return dossier->main_alt;
}

string *query_alts(string player) {
  if(!PLAYER_HANDLER->test_user(player))
    return ({ });

  load_player(player);
  return dossier->alts;
}

/**
 * Add an alt character name to this player's dossier. This function succeeds
 * if both characters are not "main", or only one if them is "main". Both
 * players will have their dossiers modified.
 * @param player the name of the player
 * @param alts the names of the alt characters to add
 * @return a string describing the outcome of the function call
 */
string add_alt(object creator, string player, string alt) {
  class dbentry new_entry;
  int is_deleted;
  string *alts, tmp;
  
  if((base_name(previous_object()) != "/cmds/player/register") &&
     !query_can_handle_alts(this_player()))
    return "You are not allowed to add players' alts.\n";

  alt = lower_case(alt);

  if(!find_player(alt) && !PLAYER_HANDLER->test_user(alt)) {
    if(!creator)
      return "No such player: " + capitalize(alt) + ".\n";
    if(file_size(filename(alt)) == -1)
      return "No such player and no record for: " + capitalize(alt) + ".\n";
    is_deleted = 1;
  }
  
  load_player(alt);
  if(dossier->main_alt && PLAYER_HANDLER->test_user(dossier->main_alt) &&
     !is_deleted)
    return capitalize(alt) + " is already an alt of " +
      capitalize(dossier->main_alt) + ".\n";

  if(sizeof(dossier->alts)) {
    if(is_deleted)
      return capitalize(alt) + " already has alts.\n";
    else {
      // Since this player is deleted we'll add these alts & old_alts to
      // the newly registered player.
      alts = dossier->alts + dossier->old_alts;
    }
  }
  
  player = lower_case(player);
  if(!find_player(player) && !PLAYER_HANDLER->test_user(player))
    return "No such player: "+ capitalize(player) +".\n";

  correcting_alts = 1;

  load_player(player);
  if(dossier->main_alt == alt) {
    correcting_alts = 0;
    return capitalize(player) + " is already an alt of " +
      capitalize(dossier->main_alt) + ".\n";
  }
  
  if(dossier->alts && member_array(alt, dossier->alts) != -1) {
    correcting_alts = 0;
    return capitalize(alt) + " is already an alt of " +
      capitalize(player) + ".\n";
  }

  if(!dossier->alts)
    dossier->alts = ({ });
  
  dossier->alts += ({ alt });
  if(alts) {
    foreach(tmp in alts) {
      if(PLAYER_HANDLER->test_user(tmp))
        dossier->alts += ({ tmp });
      else
        dossier->old_alts += ({ tmp });
    }
  }
  
  new_entry = new(class dbentry,
                  time:       time(),
                  creator:    creator ? capitalize(creator->query_name()) :
                              player,
                  event:      "register",
                  comment:    "Registered " + capitalize(alt) +
                              " as an alt.\n",
                  extra:      0);

  do_debouncing(player, new_entry);
  save_player(player);

  load_player(alt);
  dossier->main_alt = player;
  dossier->alts = ({ });
  dossier->old_alts = ({ });
  new_entry = new(class dbentry,
                  time:       time(),
                  creator:    creator ? capitalize(creator->query_name()) :
                              player,
                  event:      "register",
                  comment:    "Registered as an alt of " + player + ".\n",
                  extra:      0);
  do_debouncing(alt, new_entry);
  save_player(alt);

  correcting_alts = 0;
  
  return "Added " + capitalize(alt) + " as an alt of " + capitalize(player) +
    ".\n";
}

/**
 * Delete an alt character name from this player's dossier. Note that both
 * players have their dossier modified.
 * @param player the name of the player
 * @param alts the name of the alt characters to delete
 * @return a string describing the outcome of the function call
 */
string delete_alt(object creator, string player, string alt) {
  string ret;
  class dbentry new_entry;

  if(!query_can_handle_alts(this_player())) 
    return "You are not allowed to delete players' alts.\n";

  player = lower_case(player);
  alt = lower_case(alt);

  load_player(player);
  if(!dossier->alts || member_array(alt, dossier->alts) == -1)
    ret = capitalize(alt) + " was not an alt of " + capitalize(player);
  else {
    dossier->alts -= ({ alt });
    new_entry = new(class dbentry,
                    time:       time(),
                    creator:    capitalize(creator->query_name()),
                    event:      "register",
                    comment:    "Removed " + capitalize(alt) + " as an alt.\n",
                    extra:      0);
    do_debouncing(alt, new_entry);
    save_player(player);
  }
  
  load_player(alt);

  if(dossier->main_alt != player) {
    if(ret)
      return capitalize(alt) + " is not an alt of " + capitalize(player) +
        ".\n";
    else
      ret = capitalize(player) + " was not the main player for " +
        capitalize(alt);
  } else {
    dossier->main_alt = 0;
    dossier->alts = ({ });
    dossier->old_alts = ({ });
    new_entry = new(class dbentry,
                    time:       time(),
                    creator:    capitalize(creator->query_name()),
                    event:      "register",
                    comment:    "Removed as an alt of " + capitalize(player) +
                    ".\n",
                    extra:      0);
    do_debouncing(alt, new_entry);
    save_player(alt);
  }

  if(ret)
    return "Deleted " + capitalize(alt) + " from " + capitalize(player) +
      "'s list of alts (" + ret + ").\n";
  else
    return "Deleted " + capitalize(alt) + " from " + capitalize(player) +
      "'s list of alts.\n";
}

/**
 *  @return The alerts mapping.
 */
mapping query_alerts() {
   if( !_alerts ) {
      _alerts = ([ ]);
   }
   return _alerts;
} /* query_alerts() */

/**
 * @param player Name of the player to query
 * @return The number of alerts for that player
 */
int query_alerts_for( string player ) {
   player = lower_case(player);

   if( !_alerts ) {
      _alerts = ([ ]);
   }
   return _alerts[player];
} /* query_alerts_for() */

/**
 * @param player The name of the player
 * @param idx The number of the event to check for alert status.
 * @return 0 if the event is not an alert, 1 if it is.
 */
int is_alert( string player, int idx ) {
//   if( !PLAYER_HANDLER->test_user( lower_case( player ) ) ) {
//      return 0;              // No such player
//   }
   load_player( player );
   if( sizeof(dossier->data) < idx ) {
      return 0;
   }
   return ( dossier->data[ idx - 1 ] )->event == "alert";
} /* is_alert() */

/*
 * @param player The name of the player.
 * @param event The type of event to change the alert to.
 * @param idx The number of the event to acknowledge.
 * @param update The event description
 * @return 1 for success or 0 for failure.
 */
int acknowledge_alert( object creator, string player, string event,
   int idx, string update, mixed * extra ) {
   class dbentry entry;
   string previnfo;

   player = lower_case(player);

   if( !query_can_add( event, creator ) )
      return 0;   // No permission to add this event
   if( !query_source_ok( "alert", base_name( previous_object() ) ) )
      return 0;   // Wrong object trying to add this event
   if( !query_source_ok( event,  base_name( previous_object() ) ) )
      return 0;   // This object is not allowed to add this type of event.
   if( !PLAYER_HANDLER->test_user(player) )
      return 0;   // No such player
   if( member_array( event, keys(_sources) ) < 0 )
      return 0;   // No such event type

   // Update the entry
   idx--;
   load_player( player );
   entry = dossier->data[idx];

   previnfo = sprintf( "Originally added by %s%s%s at %s:\n%s\n---\n",
     CL_CREATOR, entry->creator, CL_RESET, ctime( entry->time ),
     entry->comment );

   entry->time    = time();
   entry->creator = capitalize( creator->query_name() );
   entry->event   = lower_case( event );
   entry->comment = previnfo + update;

   dossier->data[idx] = entry;
   if( event != "alert" ) {
      decrement_alerts_for(player);
   }

   save_player( player );
   return 1;
} /* acknowledge_alert() */

/**
 * @param player The name of the player.
 */
void clear_alerts_for( string player ) {
   player = lower_case(player);

   if( !_alerts ) {
      _alerts = ([ ]);
   }

   map_delete( _alerts, player );
   save_handler_data();
} /* clear_alerts_for() */

/**
 * @param player The name of the player.
 * @return The updated number of alerts for that player.
 */
int increment_alerts_for( string player ) {
   player = lower_case(player);

   if( !_alerts ) {
      _alerts = ([ ]);
   }

   if( !PLAYER_HANDLER->test_user(player) ) {
      return 0;
   }

   if( undefinedp( _alerts[player] ) ) {
      _alerts[player] = 1;
   } else {
      _alerts[player] = _alerts[player] + 1;
   }

   save_handler_data();
   return _alerts[player];
} /* increment_alerts_for() */

/**
 * @param player The name of the player.
 * @return The updated number of alerts for that player.
 */
int decrement_alerts_for( string player ) {
   player = lower_case(player);

   if( !_alerts ) {
      _alerts = ([ ]);
   }

   if( undefinedp( _alerts[player] ) ) {
      return 0;
   }

   _alerts[player] = _alerts[player] - 1; 

   if(_alerts[player] <= 0 ) {
      map_delete( _alerts, player );
   }

   save_handler_data();
   return _alerts[player];
} /* int decrement_alerts_for() */

/**
 * @return A list of the currently-online players who have unacknowledged alerts
 */
string * query_online_alerts() {
   if ( !_alerts ) {
      _alerts = ([ ]);
      return ({ });
   }

   return filter( keys(_alerts), (: find_player($1) :) );
} /* query_online_alerts() */

/**
 * @ignore yes
 * Added by Shrike, extended by Ceres. It fixes up the handling of alts.
 */
private void correct_alts_for(string player) {
  string main;
  string *alts, *tmp, alt;
  
  if(!player)
    return;
  
  player = lower_case(player);

  correcting_alts = 1;
  
  // Load the player's dossier...
  load_player(player);
  main = dossier->main_alt;
  alts = copy(dossier->alts);

  //  if(this_player()->query_name("ceres"))
  // write("Processing: " + player + " (" + main + ")\n");
  
  if(main && !no_recurse) {
    // non-main characters should not have alts.
    if(sizeof(alts)) {
      dossier->alts = ({ });
      save_player(player);
    }

    // The alt & the main char must exist.
    if((!PLAYER_HANDLER->test_user(player) ||
        !PLAYER_HANDLER->test_user(main))) {
      correcting_alts = 0;
      no_recurse = 1;
      correct_alts_for(main);
      load_player(player); // reload the original
    }
    return;
  }

  // This is the main alt and it nolonger exists.
  if(!PLAYER_HANDLER->test_user(player)) {
    // No alts so we're done.
    if(!sizeof(alts)) {
      if(this_player()->query_name("ceres"))
        write("No alts for : " + player + "\n");

      correcting_alts = 0;
      return;
    }

    // Need to pick a new main alt.
    tmp = filter(alts, (: PLAYER_HANDLER->test_user($1) :));
    if(sizeof(tmp)) {
      main = tmp[0];
    }
  }

  // We've picked a new main so clear our alts list & mark as as
  // having been an alt of the new main alt.
  if(main) {
    dossier->main_alt = main;
    dossier->alts = ({ });
    save_player(player);
  }
  
  // ... Load up the new main player and add to their alts as required...
  if(main)
    load_player(main);
  
  if(sizeof(alts)) {
    tmp = filter(alts, (: !find_player($1) &&
                        !PLAYER_HANDLER->test_user($1) :));
    tmp = uniq_array(dossier->old_alts + tmp);
  } else
    alts = ({ });

  alts = uniq_array(alts + dossier->alts) - ({ main });
  alts = filter(alts, (: find_player($1) || PLAYER_HANDLER->test_user($1) :));

  // If we have a new main char, the alts or old alts have changed
  // then we have some tidying up to do.
  if(main && (alts != dossier->alts || tmp != dossier->old_alts)) {
    dossier->alts = copy(alts);
    dossier->old_alts = copy(tmp);
    save_player(main);

    // ... Make sure all of this guy's alts point to them as the main...
    foreach(alt in alts) {
      if(dossier->main_alt != main) {
        load_player(alt);
        dossier->main_alt = main;
        save_player(alt);
      }
    }
    // ... Make sure all of this guy's alts point to them as the main...
    foreach(alt in tmp) {
      if(dossier->main_alt != main) {
        load_player(alt);
        dossier->main_alt = main;
        save_player(alt);
      }
    }
  }

  // ... and restore the original player.
  load_player(player);
  correcting_alts = 0;
}

void reregister_parent( string player ) {
   string main;
   string * alts;

   if ( !player ) {
      return;
   }
   player = lower_case(player);

   correcting_alts = 1;

   // Load the player's dossier...
   load_player( player );
   main = dossier->main_alt;

   if ( main ) {
      load_player(main);
      alts = dossier->alts;
      if ( !alts || !sizeof( alts ) ) {
         dossier->alts = ({ player });
      } else if ( member_array( player, alts ) == -1 ) {
         dossier->alts = alts + ({ player });
      } else {
         return;
      }
      save_player( main );
   }
} /* reregister_parent() */

/**
 * @ignore yes
 *
 * Register a players refresh. This is called by the refresh handler.
 */
void player_refreshed(mixed player, int totally) {
  class dbentry new_entry;
  string comment;
  
  if(objectp(player))
    player = player->query_name();

  switch (totally) {
  case PARTIAL_REFRESH:
    comment = "They did a partial refresh.";
    break;
  case TOTAL_REFRESH:
    comment = "They did a total and complete refresh.  (Even refreshed their "
      "breath)";
    break;
  default:
    comment = "They did some weird sort of unknown refresh.";
    break;
  }
  
  //
  // Slip an event into their playerinfo
  //
  load_player(player);
  new_entry = new(class dbentry,
                  time:       time(),
                  creator:    "Refresh Handler",
                  event:      "refresh",
                  comment:    comment,
                  extra:      0);
  do_debouncing(player, new_entry);
  save_player(player);
}

/**
 * @ignore yes
 *
 * Register a players deletion. This is called by the refresh handler.
 */
void player_deleted(mixed player, int deleted) {
  class dbentry new_entry;
  string *tmp, *tmp2, alt, main;
  
  if(objectp(player))
    player = player->query_name();

  // No record, then lets not create one eh?
  if(file_size(filename(player)) == -1)
    return;

  clear_alerts_for(player);
  load_player(player);
  new_entry = new(class dbentry,
                  time:       time(),
                  creator:    "Refresh Handler",
                  event:      "delete",
                  comment:    "Player deleted",
                  extra:      0);
  do_debouncing(player, new_entry);
  save_player(player);
  
  // move us from the alts list to the old_alts list for our main char.
  if(dossier->main_alt) {
    main = dossier->main_alt;
    dossier->main_alt = 0;
    save_player(player);
    load_player(main);
    dossier->alts -= ({ player });
    dossier->old_alts += ({ player });
    save_player(main);
    return;
  }

  // This was the main char. So we must pick a new main, transfer
  // all alts into it and then update the main_alt for all the other alts.
  if(dossier->alts && sizeof(dossier->alts)) {

    // choose a new main.
    tmp = filter(dossier->alts, (: PLAYER_HANDLER->test_user($1) :));
    if(sizeof(tmp))
      main = tmp[0];
    tmp2 = dossier->old_alts;

    // load and setup the new main.
    load_player(main);
    dossier->main_alt = 0;
    if(sizeof(tmp) > 1)
      dossier->alts = copy(tmp[1..]);
    dossier->old_alts = copy(tmp2 + ({ player }));
    save_player(main);

    // change all the other alts over to use this new main.
    foreach(alt in dossier->alts) {
      load_player(alt);
      dossier->main_alt = main;
      save_player(alt);
    }

    return;
  }
}

/** @ignore yes */
void player_created(string player) {
  if(file_size(filename(player)) == -1)
    return;
  
  load_player(player);
  if(dossier->main_alt) {
    dossier->main_alt = 0;
    dossier->alts = ({ });
    save_player(player);
  }
  return;
}

/** @ignore yes */
void fix_alts(mixed player) {
  string *alts, alt, main;

  if(objectp(player))
    player = player->query_name();
  
  // No record, not much we can do.
  if(file_size(filename(player)) == -1)
    return;

  load_player(player);

  if(dossier->main_alt) {
    main = dossier->main_alt;
    
    load_player(dossier->main_alt);
    if(!PLAYER_HANDLER->test_user(dossier->main_alt)) {
      if(sizeof(alts))
        main = alts[0];
    }
  } else {
    main = player;
  }

  // Make sure we're in the alts list and main isn't.
  // Put in some stricter type checking to deal with the situation
  // when ->alts or ->old_alts is 0
  alts = ({});
  
  if( dossier->alts ) {
     alts = alts + dossier->alts;
  }
  
  if( dossier->old_alts ) {
     alts = alts + dossier->old_alts;
  }  
  
  alts = uniq_array( alts + ({ player }));
  alts -= ({ main });
    
  // load and setup the new main.
  dossier->main_alt = 0;
  dossier->alts = filter(alts, (: PLAYER_HANDLER->test_user($1) :));
  dossier->old_alts = filter(alts, (: !PLAYER_HANDLER->test_user($1) :));
  
  // change all the other alts over to use this new main.
  foreach(alt in alts) {
    load_player(alt);
    dossier->main_alt = main;
    dossier->alts = 0;
    dossier->old_alts = 0;
    save_player(alt);
  }
}

void reset() {
    if ( sizeof( _dossier_cache ) > CACHE_SIZE ) {
        _dossier_cache = ([ ]);
    }
} /* reset() */ 

string query_access_history( string player ) {
  mapping history;
  string ret = "";

  load_player(player);
  
  //   if ( sizeof( dossier ) == NO_ACCESS_LOG ) 
  //     return "This player record has not been accessed since Tue May 27 01:29:16 2003.\n";
  
  history = dossier->access_log;
  
  ret += sprintf( "Access log for player %s:\n", capitalize( player ) );
  
  foreach( string name in sort_array( keys( history ), 
                                      (: $(history)[$2] - $(history)[$1] :) )) 
    ret += sprintf( "%12s:\t%s.\n", capitalize(name), 
                    query_time_string( time() - history[name], 2 ) + " ago");
  return ret;
}
mixed *stats() {
    return ({ 
        ({ "cache hits", _dossier_cache_hits }),
        ({ "total requests", _dossier_total }),
        ({ "cache hit %", to_int(_dossier_cache_hits * 100.0 /
                                 _dossier_total) }),
        ({ "current cache size", sizeof( _dossier_cache ) })
    });
} /* stats() */ 

// --- END [/mnt/home2/grok/lib/obj/handlers/playerinfo.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/top_ten_handler.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/top_ten_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628355   Available: 13575709
Inodes: Total: 5242880    Free: 4960134
20304 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/top_ten_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628355   Available: 13575709
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: top_ten_handler.c,v 1.23 2003/03/21 01:25:05 ceres Exp $
 * 
*/
/**
 * Top ten player lists - overall and for each guild.
 *<p>
 * archive and top_ten is of the format:
 *<code><p>
 *       ({ ({ name (guild), rating, level, age }), ... })
 *</code><p>
 * guild_top_tens is of the format:
 *<code><p>
 *       ([ guild: ({ ({ name, rating, level, age }), ... }), ... ])
 * </code>
 * @author Deutha
 */

#include <library.h>
#include <skills.h>
#include <top_ten_tables.h>
#include <clubs.h>
#include <player.h>
#include <player_handler.h>

#define SAVE_FILE "/save/top_ten_tables"
#define TOP_TEN_SIZE 15
#define GUILD_TOP_TEN_SIZE 10
#define ARCHIVE_TIME 50 * 24 * 60 * 60
#define ARCHIVE_RATING 30000

/* The Apex Club accepts members with a rating of 10k or greater */
#define APEX_LIMIT 10000

/* Age in days = age in seconds / 86400 */
#define AGE_DIVIDER 100
// #define AGE ( -thing->query_time_on() / 86400 )
#define AGE calculate_age_modifier( thing, 0 )
// #define AGE ( -( thing->query_time_on() - ( thing->query_refresh_time() ? ( time() - thing->query_refresh_time() ) + thing->query_time_on() : 0 ) ) / 86400 )

mapping guild_top_tens;
mixed *archive, *top_ten;
nosave int average;
nosave mixed *skills;
string _family_largest;
int _family_largest_num;
string _family_qp;
int _family_qp_num;
string _family_age;
int _family_age_num;
mapping _family_guilds;
mapping _family_guilds_num;
string _family_pk;
int _family_pk_num;
string _family_single_gender;
int _family_single_gender_num;
string _family_start_time;
int _family_start_time_num;
string _family_relationships;
int _family_relationships_num;

string _club_largest;
int _club_largest_num;
string _club_qp;
int _club_qp_num;
string _club_age;
int _club_age_num;
mapping _club_guilds;
mapping _club_guilds_num;
string _club_pk;
int _club_pk_num;
string _club_single_gender;
int _club_single_gender_num;
string _club_start_time;
int _club_start_time_num;

void calculate_family_and_club_info();

void create() {
    seteuid( (string)"/secure/master"->
      creator_file( file_name( this_object() ) ) );
    guild_top_tens = ([ ]);
    _family_guilds = ([ ]);
    _club_guilds = ([ ]);
    _family_guilds_num = ([ ]);
    _club_guilds_num = ([ ]);
    archive = ({ });
    top_ten = ({ });
    call_out( "check_tables", 5 );
    call_out( "check_family_and_club_info", 10 );
    if ( file_size( SAVE_FILE +".o" ) > 0 ) {
        unguarded( (: restore_object, SAVE_FILE :) );
        if (!_family_guilds_num) {
            _family_guilds_num = ([ ]);
        }
        if (!_club_guilds_num) {
            _club_guilds_num = ([ ]);
        }
    }
} /* setup() */

private void save_me() {
    unguarded( (: save_object, SAVE_FILE :) );
} /* save_me() */

/**
 * Some sort of weight average used in the rating calulation.
 * @return the weighted average
 */
int query_average() { return average; }
/**
 * The skils list with weights.  This is used to help generate the
 * rating.
 * @return the skils list with ratings
 */
mixed *query_skills() { return skills; }

/**
 * The mapping which is the guild top ten tables.
 * @return the guild top ten mapping
 */
mapping query_guild_top_tens() { return guild_top_tens; }

/** @ignore yes */
void set_guild_top_tens( mapping map ) {
    guild_top_tens = map;
    save_me();
} /* set_guild_top_tens() */

/**
 * Add in a new table.  This should be used when a new guild is created
 * and their table needs to be defined.
 * @param word the name of the table to create
 */
void add_guild_top_ten( string word ) {
    if ( guild_top_tens[ word ] ) {
        return;
    }
    guild_top_tens[ word ] = ({ });
    save_me();
} /* add_guild_top_ten() */

/**
 * The complete archived top ten table.
 * @return the archived top ten table
 */
mixed *query_archive() { return archive; }

/** @ignore yes */
void set_archive( mixed *args ) {
    archive = args;
    save_me();
} /* set_archive() */

/**
 * Return the complete list of top ten tables.
 * @return the array of arrays being the top ten tab;les
 */
mixed *query_top_ten() { return top_ten; }

/** @ignore yes */
void set_top_ten( mixed *args ) {
    top_ten = args;
    save_me();
} /* set_top_ten() */

/** @ignore yes */
int check_person( mixed *args, string guild ) {
    int i;
    string word;

    if ( !guild ) {
        sscanf( args[ 0 ], "%s (%s)", word, guild );
    } else {
        word = args[ 0 ];
    }

    if ( !PLAYER_HANDLER->test_user( word ) ||
      !PLAYER_HANDLER->test_active( word ) ||
      PLAYER_HANDLER->test_creator( word ) ||
      PLAYER_HANDLER->test_property( word, "no_score" ) ||
      PLAYER_HANDLER->test_property( word, "no score" ) ) {
        return 0;
    }

    if ( "/obj/handlers/player_handler"->test_guild( word, guild ) != "/std/guilds/"+ guild )
        return 0;
    if ( ( (int)PLAYER_HANDLER->test_last( word ) < time() - ARCHIVE_TIME ) ) {
        if ( args[ 1 ] > ARCHIVE_RATING ) {
            args[ 0 ] = word +" ("+ guild +")";
            for ( i = sizeof( archive ) - 1; i > -1; i-- ) {
                if ( archive[ i ][ 0 ] == args[ 0 ] ) {
                    if ( archive[ i ][ 1 ] > args[ 1 ] )
                        archive[ i ] = args + ({ time() });
                    break;
                }
            }
            if ( i == -1 ) {
                archive += ({ args + ({ time() }) });
            }
        }
        return 0;
    }
    return 1;
} /* check_person() */

/**
 * Wander over the top ten tables checking to see if everyone
 * still exists.
 */
void check_tables() {
    int i;
    string word;

    for ( i = sizeof( top_ten ) - 1; i > -1; i-- ) {
        if ( !check_person( copy( top_ten[ i ] ), 0 ) ) {
            top_ten = delete( top_ten, i, 1 );
        }
    }
    foreach ( word in keys( guild_top_tens ) ) {
        for ( i = sizeof( guild_top_tens[ word ] ) - 1; i > -1; i-- ) {
            if ( !check_person( copy( guild_top_tens[ word ][ i ] ), word ) ) {
                guild_top_tens[ word ] = delete( guild_top_tens[ word ], i, 1 );
            }
        }
    }
    save_me();
} /* check_tables() */

/**
 * Returns the ordered list of people on the top ten list.  If the table
 * name is 0 or it is "main" the main table is checked.  If the 
 * table name is "archive" then the archive is used.
 * @param table_name the name of the tanble to check
 * @return the array of arrays of the top ten information
 * @see /include/top_ten_tables.h
 */
mixed *query_ordered_table( string table_name ) {
    int i, highest_loc, highest_num;
    mixed *ret, *args;

    if ( !table_name || table_name == "main") {
        args = top_ten;
    } else {
        if ( table_name == "archive" ) {
            args = archive;
        } else {
            if ( !guild_top_tens[ table_name ] ) {
                return ({ });
            }
            args = guild_top_tens[ table_name ];
        }
    }
    ret = ({ });
    while ( sizeof( args ) ) {
        highest_loc = highest_num = 0;
        for ( i = 0; i < sizeof( args ); i++ ) {
            if ( args[ i ][ TOP_TEN_RATING ] > highest_num ) {
                highest_num = args[ i ][ TOP_TEN_RATING ];
                highest_loc = i;
            }
        }
        ret += ({ args[ highest_loc] });
        args = args[ 0 .. highest_loc - 1 ] + args[ highest_loc + 1 .. ];
    }
    return ret;
} /* query_orderd_table() */

/** @ignore yes */
mixed *remove_name( string word, mixed *args ) {
    int i;

    if ( !sizeof( args ) ) {
        return ({ });
    }
    for ( i = sizeof( args ) - 1; i > -1; i-- ) {
        if ( word == explode( args[ i ][ TOP_TEN_NAME ], " " )[ 0 ] ) {
            args = delete( args, i, 1 );
        }
    }
    return args;
} /* remove_name() */

/** @ignore yes */
int *find_lowest( mixed *args ) {
    int i, lowest_loc, lowest_num;

    if ( !sizeof( args ) ) {
        return ({ 0, 0 });
    }
    lowest_loc = 0;
    lowest_num = args[ 0 ][ TOP_TEN_RATING ];
    for ( i = 1; i < sizeof( args ); i++ ) {
        if ( lowest_num > args[ i ][ TOP_TEN_RATING ] ) {
            lowest_loc = i;
            lowest_num = args[ i ][ TOP_TEN_RATING ];
        }
    }
    return ({ lowest_loc, lowest_num });
} /* find_lowest() */

/** @ignore yes */
int query_skill_weight( string skill ) {
    int total;
    string *next;

    next = (string *)SKILL_OB->query_immediate_children( skill );
    if ( !sizeof( next ) ) {
        return 1;
    }
    foreach ( skill in next ) {
        total += query_skill_weight( skill );
    }
    return total;
} /* query_skill_weight() */

int calculate_age_modifier( object thing, int algorithm ) {

    if ( algorithm ) { 
        return ( -( thing->query_time_on() - ( thing->query_refresh_time() ? ( time() - thing->query_refresh_time() ) + thing->query_time_on() : 0 ) ) / 86400 );
    }
    return ( -thing->query_time_on() / 86400 );
} /* calculate_start_time() */ 

/**
 * Figure out the rating for the player.
 * @param thing the object to get the ratingof
 * @return the current rating
 */
int calculate_rating( object thing ) {
    int i, j, rating, *bonuses;

    rating = (int)thing->query_level();
    if ( !skills ) {
        skills = ({ });
        for ( i = 0; i < sizeof( STD_SKILLS ); i += SKILL_ARR_SIZE ) {
            skills += ({
              (string *)SKILL_OB->query_immediate_children( STD_SKILLS[ i ] )
            });
            skills += ({
              sizeof( skills[ <1 ] ),
              query_skill_weight( STD_SKILLS[ i ] )
            });
            average += skills[ <1 ];
        }
        average /= sizeof( skills ) / 3;
    }
    bonuses = allocate( sizeof( skills ) / 3 );
    for ( i = sizeof( bonuses ) - 1; i > -1; i-- ) {
        for ( j = skills[ 3 * i + 1 ] - 3; j > -1; j-- ) {
            bonuses[ i ] +=
            (int)thing->query_skill_bonus( skills[ 3 * i ][ j ], 1 );
        }
        bonuses[ i ] = ( ( bonuses[ i ] / skills[ 3 * i + 1 ] ) *
          skills[ 3 * i + 2 ] ) / average;
    }
    bonuses = sort_array( bonuses, -1 );
    j = sizeof( bonuses );
    for ( i = 0; i < j; i++ ) {
        rating = 2 * rating + bonuses[ i ];
        if ( !i && userp( thing ) ) {
            rating += (int)LIBRARY->
            query_quest_points( (string)thing->query_name() );
        }
    }

    if( rating > APEX_LIMIT && userp( thing ) ) {
        rating = AGE * (rating - APEX_LIMIT) / AGE_DIVIDER + APEX_LIMIT;
    }

    return rating;
} /* calculate_rating() */

/**
 * Called when a player advances their skills.
 * @param word the skill being advanced
 * @param thing the player which advanced their skils
 */
void player_skill_advance( string word, object thing ) {
    int rating, *lowest;
    string name;
    mixed *guild_top_ten;

    if ( thing->query_creator() ) {
        return;
    }
    if ( thing->query_property( "guest" ) ) {
        return;
    }
    if ( thing->query_property( "no_score" ) ) {
        return;
    }
    if ( thing->query_property( "no score" ) ) {
        return;
    }
    guild_top_ten = guild_top_tens[ word ];
    if ( !guild_top_ten ) {
        return;
    }
    name = (string)thing->query_name();
    rating = calculate_rating( thing );
    guild_top_ten = remove_name( name, guild_top_ten );
    lowest = find_lowest( guild_top_ten );
    if ( sizeof( guild_top_ten ) < GUILD_TOP_TEN_SIZE ) {
        guild_top_ten += ({
          ({ name, rating, (int)thing->query_level(),
            -(int)thing->query_time_on() }) });
    } else {
        if ( rating > lowest[ 1 ] ) {
            guild_top_ten[ lowest[ 0 ] ] =
            ({ name, rating, (int)thing->query_level(),
              -(int)thing->query_time_on() });
        }
    }
    guild_top_tens[ word ] = guild_top_ten;
    //   save_me();
    top_ten = remove_name( name, top_ten );
    lowest = find_lowest( top_ten );
    if ( sizeof( top_ten ) < TOP_TEN_SIZE ) {
        top_ten += ({
          ({ name +" ("+ word +")", rating,
            (int)thing->query_level(), -(int)thing->query_time_on() }) });
    } else {
        if ( rating > lowest[ 1 ] ) {
            top_ten[ lowest[ 0 ] ] =
            ({ name +" ("+ word +")", rating,
              (int)thing->query_level(), -(int)thing->query_time_on() });
        }
    }
    //   save_me();
} /* player_skill_advance() */

/**
 * Remove the named player from the named table.
 * @param word1 the name of the player
 * @param word2 the name of the table, 0 for the main table
 */
varargs void excise_name( string word1, string word2 ) {
    if ( !word2 ) {
        top_ten = remove_name( word1, top_ten );
    } else {
        if ( guild_top_tens[ word2 ] ) {
            guild_top_tens[ word2 ] = remove_name( word1,
              guild_top_tens[ word2 ] );
        }
    }
    save_me();
} /* excise_name() */

/**
 * Stuff to make sure that all the clubs still exist.
 */
void check_family_and_club_info() {
    int offset;
    string bing;
    string guild;

    _family_qp_num = 0;
    _family_age_num = 0;
    _family_largest_num = 0;
    if (!mapp(_family_guilds)) {
        _family_guilds = ([ ]);
    }

    if (!mapp(_club_guilds)) {
        _club_guilds = ([ ]);
    }

    // Do these first so that the table is not stuffed up.
    if (_family_qp && !CLUB_HANDLER->is_family(_family_qp)) {
        _family_qp = 0;
        _family_qp_num = 0;
    }
    if (_family_age && !CLUB_HANDLER->is_family(_family_age)) {
        _family_age = 0;
        _family_age_num = 0;
    }
    if (_family_largest && !CLUB_HANDLER->is_family(_family_largest)) {
        _family_largest = 0;
        _family_largest_num = 0;
    }
    if (_family_single_gender && !CLUB_HANDLER->is_family(_family_single_gender)) {
        _family_single_gender = 0;
        _family_single_gender_num = 0;
    }
    if (_family_pk && !CLUB_HANDLER->is_family(_family_pk)) {
        _family_pk = 0;
        _family_pk_num = 0;
    }

    if (_club_qp && !CLUB_HANDLER->is_club(_club_qp)) {
        _club_qp = 0;
        _club_qp_num = 0;
    }
    if (_club_age && !CLUB_HANDLER->is_club(_club_age)) {
        _club_age = 0;
        _club_age_num = 0;
    }
    if (_club_largest && !CLUB_HANDLER->is_club(_club_largest)) {
        _club_largest = 0;
        _club_largest_num = 0;
    }
    if (_club_single_gender && !CLUB_HANDLER->is_club(_club_single_gender)) {
        _club_single_gender = 0;
        _club_single_gender_num = 0;
    }
    if (_club_pk && !CLUB_HANDLER->is_club(_club_pk)) {
        _club_pk = 0;
        _club_pk_num = 0;
    }

    offset = 3;
    foreach (guild, bing in _family_guilds) {
        if (stringp(bing)) {
            if (!CLUB_HANDLER->is_family(bing)) {
                map_delete(_family_guilds, guild);
                map_delete(_family_guilds_num, guild);
            }
        } else {
            map_delete(_family_guilds, guild);
            map_delete(_family_guilds_num, guild);
        }
    }

    foreach (guild, bing in _club_guilds) {
        if (stringp(bing)) {
            if (!CLUB_HANDLER->is_club(bing)) {
                map_delete(_club_guilds, guild);
                map_delete(_club_guilds_num, guild);
            }
        } else {
            map_delete(_club_guilds, guild);
            map_delete(_club_guilds_num, guild);
        }
    }
    save_me();
} /* calculate_family_and_club_info() */

void inform_of_club(string club,
  int family,
  int type,
  mixed num) {
    string str;
    int bing;

    if (family) {
        switch (type) {
        case TOP_TEN_LARGEST_FAMILY:
            if (_family_largest_num < num ||
              _family_largest == club) {
                _family_largest_num = num;
                _family_largest = club;
                save_me();
            }
            break;
        case TOP_TEN_OLDEST_FAMILY:
            if (_family_age_num < num ||
              _family_age == club) {
                _family_age_num = num;
                _family_age = club;
                save_me();
            }
            break;
        case TOP_TEN_MOST_QUEST_POINTS:
            if (_family_qp_num < num ||
              _family_qp == club) {
                _family_qp_num = num;
                _family_qp = club;
                save_me();
            }
            break;
        case TOP_TEN_MOST_GUILD:
            foreach (str, bing in num) {
                if (_family_guilds_num[str] < bing ||
                  _family_guilds[str] == club) {
                    _family_guilds_num[str] = bing;
                    _family_guilds[str] = club;
                    save_me();
                }
            }
            break;
        case TOP_TEN_MOST_PKS:
            if (_family_pk_num < num ||
              _family_pk == club) {
                _family_pk_num = num;
                _family_pk = club;
                save_me();
            }
            break;
        case TOP_TEN_SINGLE_GENDER:
            if (_family_single_gender_num < num ||
              _family_single_gender == club) {
                _family_single_gender_num = num;
                _family_single_gender = club;
                save_me();
            }
            break;
        case TOP_TEN_OLDEST_LOGONS:
            if (_family_start_time_num < num ||
              _family_start_time == club) {
                _family_start_time_num = num;
                _family_start_time = club;
                save_me();
            }
            break;
        case TOP_TEN_MOST_RELATIONSHIPS:
            if (_family_relationships_num < num ||
              _family_relationships == club) {
                _family_relationships_num = num;
                _family_relationships = club;
                save_me();
            }
            break;
        }
    } else {
        switch (type) {
        case TOP_TEN_LARGEST_FAMILY:
            if (_club_largest_num < num ||
              _club_largest == club) {
                _club_largest_num = num;
                _club_largest = club;
                save_me();
            }
            break;
        case TOP_TEN_OLDEST_FAMILY:
            if (_club_age_num < num ||
              _club_age == club) {
                _club_age_num = num;
                _club_age = club;
                save_me();
            }
            break;
        case TOP_TEN_MOST_QUEST_POINTS:
            if (_club_qp_num < num ||
              _club_qp == club) {
                _club_qp_num = num;
                _club_qp = club;
                save_me();
            }
            break;
        case TOP_TEN_MOST_GUILD:
            foreach (str, bing in num) {
                if (_club_guilds_num[str] < bing ||
                  _club_guilds[str] == club ||
                  !_club_guilds[str]) {
                    _club_guilds_num[str] = bing;
                    _club_guilds[str] = club;
                    save_me();
                }
            }
            break;
        case TOP_TEN_MOST_PKS:
            if (_club_pk_num < num ||
              _club_pk == club) {
                _club_pk_num = num;
                _club_pk = club;
                save_me();
            }
            break;
        case TOP_TEN_SINGLE_GENDER:
            if (_club_single_gender_num < num ||
              _club_single_gender == club) {
                _club_single_gender_num = num;
                _club_single_gender = club;
                save_me();
            }
            break;
        case TOP_TEN_OLDEST_LOGONS:
            if (_club_start_time_num < num ||
              _club_start_time == club) {
                _club_start_time_num = num;
                _club_start_time = club;
                save_me();
            }
            break;
        }
    }
} /* inform_of_club() */

mixed *query_family_info() {
    return ({ _family_largest,
      _family_age,
      _family_qp,
      _family_guilds,
      _family_pk,
      _family_single_gender,
      _family_start_time,
      _family_relationships });
} /* query_family_info() */

mixed *query_club_info() {
    return ({ _club_largest,
      _club_age,
      _club_qp,
      _club_guilds,
      _club_pk,
      _club_single_gender,
      _club_start_time });
} /* query_club_info() */

/** @ignore yes */
void dest_me() {
    save_me();
    destruct(this_object());
} /* dest_me() */

/** @ignore yes */
void reset() {
    save_me();
} /* reset() */
// --- END [/mnt/home2/grok/lib/obj/handlers/top_ten_handler.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/snmp_handler.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/snmp_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628349   Available: 13575703
Inodes: Total: 5242880    Free: 4960134
1422 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/snmp_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628349   Available: 13575703
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "snmp.h"

void create()
{
}

buffer BufferiseInt(int p)
{
  buffer buf1;
  buf1=allocate_buffer(4);
  if(p<0)
  {
    buf1[0]=(4294967296+p)/16777216;
  } else {
    buf1[0]=p/16777216;
  }
  buf1[1]=p/65536;
  buf1[2]=p/256;
  buf1[3]=p%256;
  return buf1;
}

buffer GetData(buffer MIB)
{
  int i,j,k;
  object *tmp;
  
  buffer mibreply,mibdata,tmpbuf;
  mibreply=allocate_buffer(4);
  tmpbuf=allocate_buffer(1);
  mibreply[0]=48;
  mibreply[1]=0;
  mibreply[2]=OBJECT_IDENT;
  mibreply[3]=0;
  mibreply+=MIB;
  i=sizeof(mibreply);
  switch(MIB[6])
  {
    case 101 :
      j=sizeof(users());
      tmpbuf[0]=2;
      mibreply+=tmpbuf;
      tmpbuf[0]=0;
      mibreply+=tmpbuf;
      tmpbuf=BufferiseInt(j);
      mibreply+=tmpbuf;
      mibreply[i+1]=sizeof(tmpbuf); 
      break;
    case 102 :
      j=0;
      tmp=users();
      for(k=0;k<sizeof(tmp);k++)
        if(tmp[k] && (tmp[k])->query_creator())
          j++;
      tmpbuf[0]=2;
      mibreply+=tmpbuf;
      tmpbuf[0]=0;
      mibreply+=tmpbuf;
      tmpbuf=BufferiseInt(j);
      mibreply+=tmpbuf;
      mibreply[i+1]=sizeof(tmpbuf);
      break;
    case 100 :
      tmpbuf[0]=2;
      mibreply+=tmpbuf;
      tmpbuf[0]=1;
      mibreply+=tmpbuf;
      tmpbuf[0]=0;
      mibreply+=tmpbuf;
      break;
    default :
      mibreply[0]=255;
      break;
  }
  mibreply[1]=sizeof(mibreply)-2;
  mibreply[3]=sizeof(MIB);
  return mibreply;
}     
// --- END [/mnt/home2/grok/lib/obj/handlers/snmp_handler.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/change_skills.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/change_skills.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628349   Available: 13575703
Inodes: Total: 5242880    Free: 4960134
18155 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/change_skills.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628349   Available: 13575703
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: change_skills.c,v 1.9 2002/08/05 17:14:46 ceres Exp $
 * 
*/
/**
 * Handles updating the skill systems to new levels when the skill tree
 * is changed.
 * @author Deutha
 * @see /std/living/skills.c
 * @change 1/2/97 Pinkfish
 * Updated to include the new language skill tree
 */
#include <login_handler.h>
#include <language.h>
#include <tune.h>
#include <skills.h>
#include <combat.h>

#define ORIGINAL "alpha"
#define VERSION "beta"
#define VERSION_2 "gamma"
#define VERSION_3 "delta"
#define VERSION_4 "epsilon"
#define VERSION_5 "zeta"
#define VERSION_6 "eta"

#define OLD_SKILLS ({ \
      "magic.spells.offensive.area", \
      "magic.spells.offensive.target", \
      "magic.spells.defensive.area", \
      "magic.spells.defensive.self", \
      "magic.spells.defensive.target", \
      "magic.spells.misc.area", \
      "magic.spells.misc.self", \
      "magic.spells.misc.target", \
      "magic.spells.special", \
      "magic.items.held.wand", \
      "magic.items.held.rod", \
      "magic.items.held.staff", \
      "magic.items.held.broom", \
      "magic.items.worn.amulet", \
      "magic.items.worn.ring", \
      "magic.items.scroll", \
      "magic.points", \
      "occult.methods.brewing", \
      "occult.methods.dancing", \
      "occult.methods.chanting", \
      "occult.methods.flying", \
      "occult.spells.cursing", \
      "occult.spells.summoning", \
      "occult.spells.enchanting", \
      "occult.spells.charming", \
      "occult.spells.healing", \
   })

#define OTHER_SKILLS ({ \
      "magic", \
      "magic.spells", \
      "magic.spells.offensive", \
      "magic.spells.defensive", \
      "magic.spells.misc", \
      "magic.items", \
      "magic.items.held", \
      "magic.items.worn", \
      "occult", \
      "occult.methods", \
      "occult.spells", \
   })

#define ETA_CHANGES (["other.tracking" : "crafts.hunting.tracking", \
                      "other.swimming" : "other.movement.swimming", \
                      "other.riding" : "other.movement.riding", \
                      "other.riding.horse" : "other.movement.riding.horse", \
                      "other.riding.camel" : "other.movement.riding.camel", \
                      "other.climbing" : "other.movement.climbing", \
                      "other.climbing.tree" : "other.movement.climbing.tree", \
                      "other.climbing.rock" : "other.movement.climbing.rock", \
                      "other.climbing.rope" : "other.movement.climbing.rope", \
                      "other.valueing" : "other.trading.valueing", \
                      "other.valueing.gems" : "other.trading.valueing.gems", \
                      "other.valueing.jewellery" : "other.trading.valueing.jewellery", \
                      "other.valueing.weapons" : "other.trading.valueing.weapons", \
                      "other.valueing.armour" : "other.trading.valueing.armour"])

#define EFFECTS ({"magic.defensive.floating", "magic.shield.impact", \
                  "magic.defensive.skin.troll", "priest.shield" })

/** @ignore yes */
int query_level_in( mapping skills, string skill ) {
   string *bits;

   if ( !undefinedp( skills[ skill ] ) )
      return skills[ skill ];
   bits = explode( skill, "." );
   if ( sizeof( bits ) == 1 )
      return 0;
   bits = delete( bits, sizeof( bits ) - 1, 1 );
   skill = implode( bits, "." );
   return query_level_in( skills, skill );
} /* query_level_in() */

/**
 * Update the skills from the original skills system to the
 * beta skills system.
 * @param thing the person to update
 */
void change_skills( object thing ) {
   int i, total;
   mapping skills;

   skills = (mapping)thing->query_skills();
   if ( !m_sizeof( skills ) )
      return;
   for ( i = 0; i < sizeof( OLD_SKILLS ); i++ ) {
      total += query_level_in( skills, OLD_SKILLS[ i ] );
      if ( !undefinedp( skills[ OLD_SKILLS[ i ] ] ) )
         skills = m_delete( skills, OLD_SKILLS[ i ] );
   }
   for ( i = 0; i < sizeof( OTHER_SKILLS ); i++ )
      if ( !undefinedp( skills[ OTHER_SKILLS[ i ] ] ) )
         skills = m_delete( skills, OTHER_SKILLS[ i ] );
   if ( !total )
      return;
   thing->add_property( "magic levels", total );
   thing->set_skills( skills );
   tell_object( thing, "\n\nAn imp that only you can see flashes into "+
         "existence.\n" );
   tell_object( thing, "The imp tells you: The magic and occult skill "+
         "categories are being amalgamated and restructured.\n" );
   tell_object( thing, "The imp tells you: You have a total of "+ total +
         " levels that you can spend on the new magic skills.\n" );
   tell_object( thing, "The imp tells you: Go and find the black "+
         "monolith in the middle of Sator Square which you can use to "+
         "to spend them.\n" );
   tell_object( thing, "The imp flashes back to wherever it came from.\n\n" );
} /* change_skills() */

/**
 * Figure out thge minimum amount of xp that could have been used to
 * get the skill level.  This assumes a leaf skill
 * This appears to be the xp equation.  Using it anyway...
 * @param lvl the level to get to
 * @return the skill cost in xp
 */
int query_minimum_skill_xp(int lvl) {
   int i;
   int xp;

   xp = 0;
   for (i = 0; i < lvl; i++) {
      xp += ( DEFAULT_COST * STD_COST * 100 ) / (( LEVEL_DIV + 1) * 500);
   }
   return xp;
} /* query_minimum_skill_xp() */

/**
 * Changes the skill array up to the new tree involving the
 * languages.
 * @param thing the object to upgrade
 * @param lev the level we are changing up to.
 */
void change_language_skills( object thing, int lev ) {
   int i;
   int total_xp;
   mapping skills;
   string *bits;
   string start;
   string *langs;
   string health;
   
   skills = thing->query_skills();
   if (!sizeof(skills))
      return ;
   bits = keys(skills);

   health = skills["other.health"];
  
   /*
    * Instead of changing the skill levels directly...  We will just
    * call the appropriate functions on the player object to fiddle
    * them.
    */ 
   start = "other.language.";
   total_xp = 0;
   for (i = 0; i < sizeof(bits); i++) {
      if (bits[i][0..strlen(start)-1] == start) {
         /* Ok, now figure out how much xp to give back... */
         total_xp += query_minimum_skill_xp(skills[bits[i]]);
         map_delete(skills, bits[i]);
      }
   }
   
   langs = thing->query_languages();
   for (i = 0; i < sizeof(langs); i++) {
      thing->add_language(langs[i]);
      thing->remove_language( langs[i] );
   }
   if (skills["other.language"]) {
      total_xp += query_minimum_skill_xp(skills["other.language"]);
      map_delete(skills, "other.language");
   }

   /* Everyone gets common... */
   thing->add_language("common");

   if(thing->query_guild_ob() == "/std/guilds/wizard") {
     thing->add_language("wizard spells");
   }
   if(thing->query_guild_ob() == "/std/guilds/thief") {
     thing->add_language("thieves' cant");
   }

   if(skills["other.health"] != health) {
     tell_object(thing, "A fluffy cabbage tells you: Something has gone wrong "
                 "with your language adjustment, please tell Ceres or "
                 "Pinkfish\n");
     return;
   }
     
   /* thing->set_skills( skills ); */
   thing->adjust_xp( total_xp );
   tell_object(thing,
"A fluffy cabbage turns up and stares straight into your eyes.\n"
"You feel that the fluffy cabbage has shuffled around some bits of your mind.\n"
               );

   if (total_xp > 0 && lev < 2) {
      tell_object(thing,
"Your languages have been shifted, you appear to have gained "+total_xp+" xp.\n"
                 );
   }
} /* change_language_skills() */

mapping recalc_parents(mapping skills, string skill) {
  int i, j, lvl;
  string *tree, *bits, this_skill;

  bits = explode(skill, ".");
  for(i=sizeof(bits)-1; i>=0; i--) {
    this_skill = implode(bits[0..i], ".");
    
    tree = (string *)SKILL_OB->query_immediate_children(this_skill);
    lvl = 0;
    for(j=0; j<sizeof(tree); j++) {
      lvl += skills[tree[j]];
    }

    if(sizeof(tree))
      skills[this_skill] = lvl / sizeof(tree);
  }
  return skills;
}

/**
 * Update the skills from the original skills system to the
 * beta skills system.
 * @param thing the person to update
 */
void change_skills_epsilon( object thing ) {
  int lvl, rest;
   mapping skills;
   string *bits;
   
   skills = thing->query_skills();
   if (!sizeof(skills))
      return ;
   bits = keys(skills);

   tell_object(thing, "A squirrel appears and says: I'm just updating your "
               "skill tree, will be just a jiffy.\n");

   // Do sleight-of-hand first.
   lvl = skills["covert.sleight-of-hand"];
   if(lvl > 0) {
     m_delete(skills, "covert.sleight-of-hand");

     if(lvl > 300) { // they get skills up to 300 at 2:1
       rest = lvl - 300;
       lvl = 300;
       if(rest > 600) { // 300-600 at 1:1
         lvl += 300;
         rest -= 600;
         lvl += rest / 5; // >600 at 4:10
       } else
         lvl += rest / 2;
     }
     
     skills["covert.manipulation.stealing"] = lvl;
     skills["covert.manipulation.palming"] = lvl;
     skills["covert.manipulation.passing"] = lvl;
     skills["covert.manipulation.sleight-of-hand"] = lvl;
     skills["covert.manipulation"] = lvl;
     
     recalc_parents(skills, "covert");
   }
   
   // then sharp
   lvl = skills["fighting.combat.melee.sharp"];
   if(lvl > 0) {

     if(lvl > 300) { // they get skills up to 300 at 2:1
       rest = lvl - 300;
       lvl = 300;
       
       if(rest > 600) { // 300-600 at 1:1
         lvl += 300;
         rest -= 600;
         lvl += rest / 5; // >600 at 4:10
       } else
         lvl += rest / 2;
     }
     
     skills["fighting.combat.melee.sharp"] = lvl;
     skills["fighting.combat.melee.pierce"] = lvl;
     skills = recalc_parents(skills, "fighting.combat.melee");
   }

   // then parry
   lvl = skills["fighting.combat.parry.thrown"];
   rest = skills["fighting.combat.parry.fired"];
   if(lvl > 0 || rest > 0) {
     if(rest > lvl)
       lvl = rest + (lvl / 5);
     else
       lvl += (rest / 5);
     
     m_delete(skills, "fighting.combat.parry.thrown");
     m_delete(skills, "fighting.combat.parry.fired");
     skills["fighting.combat.parry.range"] = lvl;
     
     lvl = skills["fighting.combat.parry.held"];
     m_delete(skills, "fighting.combat.parry.held");
     skills["fighting.combat.parry.melee"] = lvl;
     skills = recalc_parents(skills, "fighting.combat.parry");
   }

   // then special
   lvl = skills["fighting.combat.special"];
   if(lvl > 0) {
     
     if(lvl > 300) { // they get skills up to 300 at 2:1
       rest = lvl - 300;
       lvl = 300;
       
       if(rest > 600) { // 300-600 at 1:1
         lvl += 300;
         rest -= 600;
         lvl += rest / 5; // >600 at 4:10
       } else
         lvl += rest / 2;
     }
     skills["fighting.combat.special.weapon"] = lvl;
     skills["fighting.combat.special.unarmed"] = lvl;
     skills["fighting.combat.special.tactics"] = lvl - lvl / 4;
     
     skills = recalc_parents(skills, "fighting.combat.special");
   }
   // do tracking
   lvl = skills["other.tracking.woodland"];
   m_delete(skills, "other.tracking.woodland");
   lvl += skills["other.tracking.desert"];
   m_delete(skills, "other.tracking.desert");
   lvl += skills["other.tracking.mountain"];
   m_delete(skills, "other.tracking.mountain");
   lvl += skills["other.tracking.road"];
   m_delete(skills, "other.tracking.road");
   lvl += skills["other.tracking.field"];
   m_delete(skills, "other.tracking.field");

   if(lvl > 0)
     skills["other.tracking"] = lvl;
   
   thing->set_skills( skills );
   tell_object(thing, "The squirrel says: Ok, all done now.\n");
}

/**
 * Calulate the new skill value for the skills version zeta
 */
int new_skill_value(int sk) {
  float f = 1000.0;
  float k = 0.3;

  if(sk == 0)
    return 0;
  
  return to_int(f * log( 1.0 + sk/(f + sk * k) ) + 0.5);
}

/**
 * Change everyones skill levels (downwards).
 * @param thing the person to update
 */
void change_skills_zeta( object thing ) {
   mapping skills;
   string *bits, bit;
   
   skills = thing->query_skills();
   if (!sizeof(skills))
      return ;
   bits = keys(skills);

   tell_object(thing, "A small blue frog appears and says: I'm just updating "
         "your skill levels, this won't take a second.\n");

   // go through all the skills one by one
   foreach(bit in bits) {
     // if it's not a language skill & it's a leaf skill recalculate it and
     // then recalculate it's parents.
     if(bit[0..13] != "other.language" &&
        SKILL_OB->query_immediate_children(bit) == ({ })) {

       skills[bit] = new_skill_value(skills[bit]);
       skills = recalc_parents(skills, bit);
     }
   }
   // set these skills as their new skills and we're done.
   thing->set_skills( skills );
   tell_object(thing, "The frog says: Ok, all done now.\n");
}

void fixup_stats(object thing) {
  mapping values;
  mapping changes;
  int stat_total;
  string str;

  changes = ([ ]);
  values = ([
    "con" : thing->query_real_con(),
    "dex" : thing->query_real_dex(),
    "int" : thing->query_real_int(),
    "wis" : thing->query_real_wis(),
    "str" : thing->query_real_str()
            ]);
  stat_total = values["con"] + values["dex"] + values["wis"] + values["str"] +
               values["int"];
  if (stat_total > 65) {
     if (thing->query_real_con() > 8) {
        thing->adjust_con(-1);
        stat_total--;
        values["con"]--;
        changes["con"]++;
     }
     if (stat_total > 65 && thing->query_real_dex() > 8) {
        thing->adjust_dex(-1);
        stat_total--;
        values["dex"]--;
        changes["dex"]++;
     }
     // Now find highest stat and adjust until correct.
     while (stat_total > 65) {
        string highest;
        int value;
        string stat;
        int v;

        value = 0;
        foreach (stat, v in values) {
           if (v > value) {
              value = v;
              highest = stat;
           }
        }
        call_other(thing, "adjust_" + highest, -1);
        values[highest]--;
        changes[highest]++;
        stat_total--;
     }
  }

  str = query_multiple_short(map(keys(changes), (: $1 + " changed by " + $2[$1] :), changes));

  tell_object(thing, "The armadillo says: Stats changed: " + str + "\n");
}

void change_skills_eta(object thing) {
  mapping skills;
  string bit, effect;
  class tactics tactics;
  int eff;

  // Initialise tactics since we have some new fields.
  tactics = new(class tactics,
                attitude : "neutral",
                response : "neutral",
                parry : "both",
                parry_unarmed : 0,
                mercy : "ask",
                focus_zone : 0,
                ideal_distance : 0);
  thing->set_tactics(tactics);
  
  skills = thing->query_skills();
  if(!sizeof(skills))
    return;

  tell_object(thing, "An armadillo appears out of nowhere and says: "
              "I'm just updating your skills, this won't take a second.\n");
  
  foreach(bit in keys(ETA_CHANGES)) {
    tell_object(thing, "Mapping " + bit + " to " + ETA_CHANGES[bit] + ".\n");
    skills[ETA_CHANGES[bit]] = skills[bit];
    map_delete(skills, bit);
  }

  tell_object(thing, "Adding new skills.\n");
  foreach(bit in
          "/std/skills"->query_immediate_children("crafts")) {
    if(!skills[bit]) {
      skills[bit] = 0;
    }
  }
  recalc_parents(skills, "crafts.hunting");
  recalc_parents(skills, "crafts");
  recalc_parents(skills, "other.movement.riding");
  recalc_parents(skills, "other.movement.climbing");
  recalc_parents(skills, "other.movement");
  recalc_parents(skills, "other.trading.valueing");
  recalc_parents(skills, "other.trading");
  recalc_parents(skills, "other");
  thing->set_skills( skills );

  foreach(effect in EFFECTS)
    foreach(eff in thing->effects_matching(effect))
      catch(thing->delete_effect(eff));

  tell_object(thing, "Fixing stats.\n");
  fixup_stats(thing);

  tell_object(thing, "Granting rearrange.\n");
   thing->add_known_command("rearrange");

  if ((thing->query_guild_ob() == "/std/guilds/assassin" &&
       thing->query_property("assassin") > 1) ||
      (thing->query_guild_ob() == "/std/guilds/wizard" &&
       "/obj/handlers/guild_things/wizard_orders"->query_order() == "last")) {
    tell_object(thing, "Returning PK flag.\n");
    thing->set_player_killer(1);
  }
  thing->remove_property(PKER);
  thing->remove_property(PKER_MISSPELL);
  thing->add_property("not real newbie", 1);

  tell_object(thing, "Removing old combat commands.\n");
  if(thing->query_known_command("strike"))
    thing->remove_known_command("strike");

  if(thing->query_guild_ob() != "/std/guilds/warrior") {
    thing->remove_known_command("impale");
    thing->remove_known_command("crush");
    thing->remove_known_command("behead");
  }
  
  thing->remove_known_command("punch");
  thing->remove_known_command("kick");

  tell_object(thing, "The armadillo says: Ok, all done now.\n");
  "/d/liaison/NEWBIE/choose_land"->fixup_player(this_player());
}

/**
 * Called by the login handler, checks to see if an upgrade
 * is neede.
 * @param name the name of the player logging in
 * @param type the type of the login
 * @see /obj/handlers/login_handler.c
 */
void entering( string name, string type ) {
   object thing;
   int lvl;

   if ( type != LOGIN )
      return;
   if ( !( thing = find_player( name ) ) )
      return;

   switch((string)thing->query_property( "skills version" )) {
   case VERSION:
     change_skills( thing );
   case VERSION_2:
     change_language_skills( thing, lvl );
   case VERSION_3:
     change_skills_epsilon( thing );
   case VERSION_4:
     change_skills_zeta(thing);
   case VERSION_5:
     change_skills_eta(thing);
   default:
     // If they don't have a skill version then they're a new player and
     // don't need any modification to their skill tree.
     thing->add_property("skills version", VERSION_6);
     return;
   }
} /* entering() */

/**
 * The current version of the skill tree.
 * @return the version of the skill system
 */
string query_version() { return VERSION_5; }
// --- END [/mnt/home2/grok/lib/obj/handlers/change_skills.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/news_handler.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/news_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628344   Available: 13575698
Inodes: Total: 5242880    Free: 4960134
1584 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/news_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628344   Available: 13575698
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * The News Handler
 * @author Taffyd
 * @started 19/09/2000
 */

#include <board.h>
#include <login_handler.h>

#define BOARD_NAME "announcements"

/**
 * Time in seconds before displaying a reminder message.
 */
#define DELAY_TIME 30

int has_unread_announcements( string player ) {
    mapping news_rc;
    mixed subjects;

    news_rc = BOARD_HAND->query_newsrc( player );

    if ( !news_rc ) {
        news_rc = ([ ]);
    }

    subjects = BOARD_HAND->get_subjects( BOARD_NAME );

    if ( !sizeof( subjects ) ) {
        return 0;
    }

    return subjects[ <1 ][ B_TIME ] > news_rc[ BOARD_NAME ];
} /* has_unread_announcements() */

void show_message( mixed person ) {
    object player;
   
    if ( stringp( person ) ) {
        player = find_player( person );
    }
    else {
        player = person;
    }

    if ( !player ) {
        return;
    }

    if ( has_unread_announcements( player->query_name() ) ) {
        tell_object( player, "\nThere are %^YELLOW%^NEW%^RESET%^ "
            "announcements!  You can read them with \"news\".\n\n" );
    }
} /* show_message() */

void login_event(mixed person, string type) {
    
    if ( type == LOGIN || type == RECONNECT ) {
        if ( objectp( person ) ) {
            person = person->query_name();
        }
        
        call_out( (: show_message :), DELAY_TIME, person );
    }
} /* login_event() */

void broadcast_announcement() {   
    foreach( object user in users() ) { 
        if ( interactive( user ) ) { 
            show_message( user );
        }
    }

} /* broadcast_announcement() */


// --- END [/mnt/home2/grok/lib/obj/handlers/news_handler.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/complaints_handler.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/complaints_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628344   Available: 13575698
Inodes: Total: 5242880    Free: 4960134
1881 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/complaints_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628344   Available: 13575698
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming

/**
 * This handler deals with complaints.  It manages posting to the "complaints"
 * board and numbering the posts sequentially (helps to follow threads if
 * anybody follows up the posts on the board).
 *
 * @see /std/room/inherit/complaints_room.c
 * @see /std/room/complaints_room.c
 * @author Arienne
 * @started Wed Apr  4 14:11:50 BST 2001
**/

#include <board.h>

#define SAVEFILE "/save/complaints/complaints_handler.o"
#define BOARD "complaints"

int _complaintNumber;

/**
 * @ignore
**/
void save_file() {
    unguarded( (: save_object( SAVEFILE ) :) );
} /* save_file() */

/**
 * @ignore
**/
void load_file() {
    unguarded( (: restore_object( SAVEFILE ) :) );
} /* load_file() */

/**
 * @ignore
**/
void create() {
    seteuid( getuid() );
    _complaintNumber = 1;
    load_file();
} /* create() */

/**
 * Submits a complaint to the complaints board anonymously.
 *
 * @param str The text of the complaint.
 * @return The note number, or 0 on failure.
**/
int do_submit_complaint( string str ) {
    int ret = 0;

    if ( str ) {
        ret = BOARD_HAND->
            add_message( BOARD, "Anonymous",
                         "Anonymous complaint #" + _complaintNumber,
                         sprintf( "%-=78s\n", str ) );

        _complaintNumber++;
        save_file();
    }
    
    return ret;
} /* do_submit_complaint() */

/**
 * @ignore
**/
int board_access_check( int type, string, object previous, string name ) {
    switch ( type ) {
    case B_ACCESS_READ:
        return ( "/secure/master"->query_lord( name ) );
        
    case B_ACCESS_WRITE:
        return ( ( previous == this_object() ) ||
                 ( "/secure/master"->query_lord( name ) ) );
        
    case B_ACCESS_DELETE :
        // Players can always delete their own notes, do not need to code
        // for that.
        return 0;
    }
} /* board_access_check() */
// --- END [/mnt/home2/grok/lib/obj/handlers/complaints_handler.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/script_processor.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/script_processor.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628343   Available: 13575697
Inodes: Total: 5242880    Free: 4960134
1923 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/script_processor.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628343   Available: 13575697
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: script_processor.c,v 1.1 1998/01/06 05:03:33 ceres Exp $
 * $Log: script_processor.c,v $
 * Revision 1.1  1998/01/06 05:03:33  ceres
 * Initial revision
 * 
*/
#define RATIO 20

inherit "/std/object";

string stage;
mapping actors;

void setup() {
   actors = ([ ]);
} /* setup() */

string query_stage() { return stage; }

void set_stage( string word ) { stage = word; }

mapping query_actors() { return actors; }

string query_actor( string word ) { return actors[ word ]; }

void set_actor( string name, string path ) { actors[ name ] = path; }

int perform_line( string script, int line ) {
   int length;
   string action, name, text;
   object actor;
   length = file_length( script );
   if ( length < 1 ) {
      write( "Length of file \""+ script +"\" is "+ length +".\n" );
      return -1;
   }
   if ( length < line )
      return -1;
   if ( !stage || ( stage == "" ) )
      return -2;
   text = read_file( script, line, 1 );
   if ( sscanf( text, "%s=%s\n", name, action ) == 2 ) {
      if ( !actors[ name ] )
         return -3;
      actor = find_object( actors[ name ] );
      if ( !actor )
         return -4;
      actor->do_command( action );
   } else {
      actor = find_object( stage );
      if ( !actor )
         return -4;
      tell_room( actor, text );
   }
   if ( length == line )
      return -5;
   return strlen( text ) / RATIO;
} /* perform_line() */

void perform_script( string script, int line ) {
   int next;
   next = perform_line( script, line );
   if ( next < 0 ) {
      if ( find_object( stage ) )
         stage->script_ended( next );
      return;
   }
   call_out( "perform_script", 2 + next, script, line + 1 );
} /* perform_script() */

int start_script( string script ) {
   if ( find_call_out( "perform_script" ) != -1 )
      return 0;
   call_out( "perform_script", 3, script, 1 );
   return 1;
} /* start_script() */
// --- END [/mnt/home2/grok/lib/obj/handlers/script_processor.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/soul_compiler.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/soul_compiler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628342   Available: 13575696
Inodes: Total: 5242880    Free: 4960134
17789 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/soul_compiler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628342   Available: 13575696
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*   -*- LPC -*-   */
/*
 * $Locker:  $
 * $Id: soul_compiler.c,v 1.4 2002/12/12 20:33:05 ceres Exp $
 * $Log: soul_compiler.c,v $
 * Revision 1.4  2002/12/12 20:33:05  ceres
 * Fixed
 *
 * Revision 1.3  2001/03/12 05:14:35  pinkfish
 *  Forcibly unlocked by ceres
 *
 * Revision 1.2   2000/06/15 02:24:35   pinkfish
 * Hopefully make it deal with files with a bad syntax.
 *
 * Revision 1.1   1998/01/06 05:03:33   ceres
 * Initial revision
 * 
*/
/**
 * This compiles the soul files into a non human readable format.   The
 * format is far more useful to the soul though :)
 */
#include "soul.h"
#include "user_parser.h"

private nosave string _current_file;
private nosave int _current_line;
private nosave int _file_len;
private nosave int _depth;
private nosave int _look_for;
private nosave int _last_chunk_compile;
private nosave mixed *_to_compile;
private nosave mixed *_arguments;
private nosave object _current_player;

void start_compile();
void parse_chunk(string chunk);
void make_into_soul_commands(mapping commands);

/* Number of lines in a chunk */
#define CHUNK_SIZE 20

#define OPEN_BRACKET 1
#define START_ARGUMENT 2
#define END_BRACKET 3
#define END_STRING 4
#define ARGUMENT_VALUE 5
#define ARGUMENT_NAME 6
#define REST_OF_ARGUMENT 7

void create() {
   _to_compile = ({ });
   seteuid("Root");
} /* create() */

/** @ignore yes */
int test_security(string fname) {
   return 1;
} /* test_security() */

/** @ignore yes */
void notify(string mess) {
   if (_current_player)
      tell_object(_current_player, mess);
} /* notify() */

/**
 * Compiles up the file into the useful soul format.   It also tells
 * the soul about it.
 * <p>
 * See the soul data files in /save/new_soul for details of the format
 * for the soul files.   The file has to come from the soul save
 * directory or the call will not work.
 * @param fname the name of the file to compile
 */
void compile_file(string fname) {
/*
 * First, do we have read access to the file.
 * and is it actually a file?
 */   
   if (file_size(SOUL_DIR+fname) == -1) {
      tell_object(this_player(), "The file "+
                         SOUL_DIR+fname+" does not exist.\n");
      return ;
   }
   if (file_size(SOUL_DIR+fname) == -2) {
      tell_object(this_player(), "The file "+
                         SOUL_DIR+fname+" is a directory exist.\n");
      return ;
   }
   _to_compile += ({ SOUL_DIR+fname, this_player() });
   start_compile();
} /* compile_file() */

/**
 * Compiles up a directory full of files.
 * @see compile_file() 
 * @param fname the directory name to compile
 */
void compile_directory(string fname) {
   string *bits, start;
   int i;

   if (file_size(SOUL_DIR+fname) != -2) {
      tell_object(this_player(), "The file "+
                         fname+" is not a directory exist.\n");
      return ;
   }
   bits = explode(fname, "/");
   start = implode(bits[0..<1], "/");
   if (start != "") {
      start += "/";
   }
   fname = SOUL_DIR+fname;
   if (fname[<1] == '/') {
      fname += "*.s";
   } else {
      fname += "/*.s";
   }
   bits = get_dir(fname);
   for (i=0;i<sizeof(bits);i++) {
      bits[i] = start+bits[i];
      compile_file(bits[i]);
   }
} /* compile_directory() */

/** @ignore yes */
void start_compile() {
/* We are already compiling */
   if ((_current_file || !sizeof(_to_compile)) &&
       (time() - _last_chunk_compile) > 10) {
      return ;
   }
   write("Starting to compile " + _to_compile[0] + "\n");
   _current_file = _to_compile[0];
   _current_player = _to_compile[1];
   _to_compile = _to_compile[2..];
   _current_line = 1;
   _depth = 0;
   _look_for = OPEN_BRACKET;
   _file_len = file_length(_current_file);
   _arguments = ({ 0, ([ ]) });
   call_out("compile_chunk", 2);
} /* start_compile() */

/** @ignore yes */
void compile_chunk() {
   string chunk;
   int end;

   _last_chunk_compile = time();
   if (_current_line+CHUNK_SIZE > _file_len) {
      end = _file_len+1;
   } else {
      end = _current_line+CHUNK_SIZE;
   }
   chunk = unguarded((: read_file, _current_file, _current_line,
                               end-_current_line :));
   _current_line = end;
   parse_chunk(chunk);
   if (end > _file_len) {
/* finished file */
      call_out("start_compile", 2);
      _current_file = 0;
      make_into_soul_commands(_arguments[1]);
   } else {
      call_out("compile_chunk", 2);
   }
} /* compile_chunk() */

/** @ignore yes */
void parse_chunk(string chunk) {
   /* Now.   What are we looking for? */
   /* Love, a nice place in the world, a happy bag full of groceries. */
   string *bits, s1, s2;
   int pos, chunk_size, start;

   chunk_size = strlen(chunk);
   pos = 0;
   bits = explode(chunk, "(");
   while (pos < chunk_size) {
      switch (_look_for) {
         case OPEN_BRACKET :
            if (sscanf(chunk[pos..], "%s(%s", s1, s2)) {
               chunk = s2;
               chunk_size = strlen(chunk);
               pos = 0;
               _depth++;
               _arguments += ({ 0, 0 });
               _look_for = ARGUMENT_NAME;
            } else {
               pos = chunk_size;
            }
            break;

         case ARGUMENT_NAME :
            /* We look for the first non-space, non-tab, non-nl */
            while (pos < chunk_size && (chunk[pos] == ' ' || 
                      chunk[pos] == '\t' || chunk[pos] == '\n')) {
               pos++;
            }
            if (pos == chunk_size) {
               break;
            }
            start = pos;
            /* Ok, now we search for the next one. */
            while (pos < chunk_size && chunk[pos] != ' ' && 
                      chunk[pos] != '\t' && chunk[pos] != '\n') {
               pos++;
            }
            /* Thats it.   Our argument name. */
            _arguments[_depth*2] = chunk[start..pos-1];
            _look_for = ARGUMENT_VALUE;
            break;

         case ARGUMENT_VALUE :
            while (pos < chunk_size && (chunk[pos] == ' ' || 
                      chunk[pos] == '\t' || chunk[pos] == '\n')) {
               pos++;
            }
            if (pos >= chunk_size) {
               break;
            }
            switch (chunk[pos]) {
               case '(' :
                  _arguments[_depth*2+1] = ([ ]);
                  _depth++;
                  _arguments += ({ 0, 0 });
                  _look_for = ARGUMENT_NAME;
                  pos++;
                  break;
               case '"' :
                  _arguments[_depth*2+1] = "";
                  _look_for = END_STRING;
                  pos++;
                  break;
               default :
/* A string, at most one space seperator between them... */
                  start = pos;
                  if (sscanf(chunk[pos..], "%s)%s", s1, s2) == 2) {
                     _arguments[_depth*2+1] = replace(implode(explode(replace(s1, 
                            ({ "\n", " ", "\r", "" })), " ")-({ "" }), " "), ", ", ",");
                     pos = 0;
                     chunk = ")"+s2;
                     _look_for = END_BRACKET;
                  } else {
                     _arguments[_depth*2+1] = chunk[pos..];
                     _look_for = REST_OF_ARGUMENT;
                     pos = 0;
                     chunk = "";
                  }
                  chunk_size = strlen(chunk);
                  break;
            }
            break;

         case REST_OF_ARGUMENT :
            if (sscanf(chunk[pos..], "%s)%s", s1, s2) == 2) {
               _arguments[_depth*2+1] = replace(implode(explode(
                                                    replace(_arguments[_depth*2+1]+s1, "\n", " "),
                                                                         " ") - ({ "" }),
                                                             " "), ", ", ",");
               pos = 0;
               chunk = ")"+s2;
               _look_for = END_BRACKET;
            } else {
               _arguments[_depth*2+1] += chunk[pos..];
               pos = 0;
               chunk = "";
            }
            chunk_size = strlen(chunk);
            break;

         case END_BRACKET :
            if (sscanf(chunk[pos..], "%s)%s", s1, s2)) {
               switch (_depth) {
                  case 2 : 
                  case 3 :
                     if (pointerp(_arguments[_depth*2-1][_arguments[_depth*2]]))
                        _arguments[_depth*2-1][_arguments[_depth*2]] += ({ _arguments[_depth*2+1] });
                     else
                        _arguments[_depth*2-1][_arguments[_depth*2]] = ({ _arguments[_depth*2+1] });
                     break;
                  case 1 :
                  case 4 :
                  case 5 :
                  case 6 :
                  case 7 :
                     _arguments[_depth*2-1][_arguments[_depth*2]] = _arguments[_depth*2+1];
                     break;
               }
               chunk = s2;
               chunk_size = strlen(s2);
               _depth--;
               pos = 0;
               _arguments = _arguments[0.._depth*2+1];
               if (_depth) {
                  _look_for = START_ARGUMENT;
               } else {
                  _look_for = OPEN_BRACKET;
               }
            }
            break;

         case START_ARGUMENT :
            while (pos < chunk_size && (chunk[pos] == ' '
                   || chunk[pos] == '\t' || chunk[pos] == '\n')) {
               pos++;
            }
            if (pos >= chunk_size) {
               break;
            }
            switch (chunk[pos]) {
               case ')' :
                  _look_for = END_BRACKET;
                  break;
               case '(' :
                  _look_for = OPEN_BRACKET;
                  break;
               default :
                  if (!sscanf(chunk[pos..], "%s\n%s", s1, s2)) {
                     s1 = chunk;
                  }
                  printf("Syntax error in file %s, near %s\n", _current_file, s1);
                  _look_for = END_BRACKET;
                  break;
            }
            break;

         case END_STRING :
            if (sscanf(chunk[pos..], "%s\"%s", s1, s2)) {
               if (strlen(s1) > 0 && s1[strlen(s1)-1] == '\\') {
                  _arguments[_depth*2+1] += replace(s1[0..strlen(s1)-2], "\n", "")+"\"";
                  chunk = s2;
                  pos = 0;
                  chunk_size = strlen(s2);
               } else {
                  _arguments[_depth*2+1] += replace(s1, "\n", "");
                  _look_for = END_BRACKET;
                  chunk = s2;
                  pos = 0;
                  chunk_size = strlen(s2);
               }
            } else {
               _arguments[_depth*2+1] += replace(chunk, "\n", "");
               pos = chunk_size;
            }
            break;

         default :
            notify("Horrible error "+_look_for+"\n");
            pos = chunk_size;
            break;
      }
   }
} /* parse_chunk() */

/** @ignore yes */
int check_sort(string pat1, string pat2) {
   int lvl1, lvl2;

   lvl1 = ((mixed *)PATTERN_OB->compile_pattern(pat1))[0];
   lvl2 = ((mixed *)PATTERN_OB->compile_pattern(pat2))[0];
   return lvl2-lvl1;
} /* check_sort() */

/** @ignore yes */
string *sort_patterns(string *inp) {
   if (!pointerp(inp)) {
      printf("%O\n", inp);
      return ({ });
   }
   return sort_array(inp, "check_sort", this_object());
/*
   string *ret;
   int *lvl, i, j, level;

   lvl = allocate(sizeof(inp));
   ret = ({ });
   for (i=0;i<sizeof(inp);i++) {
      level = ((mixed *)PATTERN_OB->compile_pattern(inp[i]))[0];
      for (j=0;j<sizeof(ret);j++) {
         if (lvl[j] < level) {
            if (j) {
               ret = ret[0..j-1]+({ inp[i] })+ret[j..];
               lvl = lvl[0..j-1]+({ level })+lvl[j..];
            } else {
               ret = ({ inp[i] })+ret[j..];
               lvl = ({ level })+lvl[j..];
            }
            break;
         }
      }
      if (j == sizeof(ret)) {
         ret += ({ inp[i] });
         lvl += ({ level });
      }
   }
   return ret;
 */
} /* sort_patterns() */

/** @ignore yes */
void make_into_soul_commands(mapping comms) {
   string *fluff;
   int i, failed, j;
   mapping ret, tmp;

   fluff = keys(comms);
   ret = ([ ]);
   for (i=0;i<sizeof(fluff);i++) {
/* No arguments and arguments... */
      ret[fluff[i]] = ({ comms[fluff[i]]["pattern"], 0, 0 });
/* Ok, now we see if we have a single bit */
      if (comms[fluff[i]]["single"]) {
/* Yes! */
         if (comms[fluff[i]]["single"][0]["no-arguments"]) {
            tmp = comms[fluff[i]]["single"][0]["no-arguments"][0];   
            if (!tmp["self"]) {
               notify("The 'self' type is missing in the no-argument, single for the soul command "+fluff[i]+"\n");
               failed = 1;
            } else if (!tmp["rest"]) {
               notify("The 'rest' type is missing in the no-argument, single for the soul command "+fluff[i]+"\n");
               failed = 1;
            } else {
               ret[fluff[i]][SINGLE] = ({ ({ tmp["self"], tmp["rest"],
                                                            tmp["position"] }),
                                                         0 });
            }
         }
         if (comms[fluff[i]]["single"][0]["arguments"]) {
            j = sizeof(comms[fluff[i]]["single"][0]["arguments"]);
            if (!ret[fluff[i]][SINGLE]) {
               ret[fluff[i]][SINGLE] = ({ 0, allocate(j*SMALL_ARG_SIZE) });
            } else {
               ret[fluff[i]][SINGLE][ARGUMENTS] = allocate(j*SMALL_ARG_SIZE);
            }
            for (j=0;j<sizeof(comms[fluff[i]]["single"][0]["arguments"]);j++) {
               tmp = comms[fluff[i]]["single"][0]["arguments"][j];
               if (!mapp(tmp)) {
                  notify("The soul command "+fluff[i]+" is totaly stuffed.\n");
                  failed = 1;
               } else if (!tmp["self"]) {
                  notify("The 'self' type is missing in the argument, single for the soul command "+fluff[i]+"\n");
                  failed = 1;
               } else if (!tmp["rest"]) {
                  notify("The 'rest' type is missing in the argument, single for the soul command "+fluff[i]+"\n");
                  failed = 1;
               } else if (!tmp["arguments"]) {
                  notify("The 'arguments' type is missing in the argument, single for the soul command "+fluff[i]+"\n");
                  failed = 1;
               } else {
                  ret[fluff[i]][SINGLE][ARGUMENTS][j*SMALL_ARG_SIZE+SELF] = tmp["self"];
                  ret[fluff[i]][SINGLE][ARGUMENTS][j*SMALL_ARG_SIZE+REST] = tmp["rest"];
                  ret[fluff[i]][SINGLE][ARGUMENTS][j*SMALL_ARG_SIZE+ARGS] = explode(tmp["arguments"], ",");
                  ret[fluff[i]][SINGLE][ARGUMENTS][j*SMALL_ARG_SIZE+POSITION_SINGLE] = tmp["position"];
               }
            }
         }
      }
      if (comms[fluff[i]]["targeted"]) {
/* Yes! */
         if (comms[fluff[i]]["targeted"][0]["no-arguments"]) {
            tmp = comms[fluff[i]]["targeted"][0]["no-arguments"][0];   
            if (!tmp["self"]) {
               notify("The 'self' type is missing in the no-argument, target for the soul command "+fluff[i]+"\n");
               failed = 1;
            } else if (!tmp["rest"]) {
               notify("The 'rest' type is missing in the no-argument, target for the soul command "+fluff[i]+"\n");
               failed = 1;
            } else {
               ret[fluff[i]][TARGET] = ({ ({ tmp["self"], tmp["rest"],
                                     tmp["target"], 0, tmp["force"], tmp["position"] }),
                                                         0 });
            }
         }
         if (comms[fluff[i]]["targeted"][0]["arguments"]) {
            j = sizeof(comms[fluff[i]]["targeted"][0]["arguments"]);
            if (!ret[fluff[i]][TARGET]) 
               ret[fluff[i]][TARGET] = ({ 0, allocate(j*ARG_SIZE) });
            else
               ret[fluff[i]][TARGET][ARGUMENTS] = allocate(j*ARG_SIZE);
            for (j=0;j<sizeof(comms[fluff[i]]["targeted"][0]["arguments"]);j++) {
               tmp = comms[fluff[i]]["targeted"][0]["arguments"][j];
               if (!tmp["self"]) {
                  notify("The 'self' type is missing in the argument, target for the soul command "+fluff[i]+"\n");
                  failed = 1;
               } else if (!tmp["rest"]) {
                  notify("The 'rest' type is missing in the argument, target for the soul command "+fluff[i]+"\n");
                  failed = 1;
               } else if (!tmp["arguments"]) {
                  notify("The 'arguments' type is missing in the argument, target for the soul command "+fluff[i]+"\n");
                  failed = 1;
               } else {
                  ret[fluff[i]][TARGET][ARGUMENTS][j*ARG_SIZE+SELF] = tmp["self"];
                  ret[fluff[i]][TARGET][ARGUMENTS][j*ARG_SIZE+REST] = tmp["rest"];
                  ret[fluff[i]][TARGET][ARGUMENTS][j*ARG_SIZE+TARG] = tmp["target"];
                  ret[fluff[i]][TARGET][ARGUMENTS][j*ARG_SIZE+ARGS] = explode(tmp["arguments"], ",");
                  ret[fluff[i]][TARGET][ARGUMENTS][j*ARG_SIZE+FORCE] = tmp["force"];
                  ret[fluff[i]][TARGET][ARGUMENTS][j*ARG_SIZE+POSITION] = tmp["position"];
               }
            }
         }
      }
   }
   fluff = keys(ret);
   for (i=0;i<sizeof(fluff);i++) {
      ret[fluff[i]][PATTERNS] = sort_patterns(ret[fluff[i]][PATTERNS]);
      SOUL_OBJECT->add_soul_command(fluff[i], ret[fluff[i]]);
      notify("Added soul command "+fluff[i]+".\n");
   }
} /* make_into_soul_commands() */

/** @ignore yes */
void blue() {
   printf("%O\n", sort_patterns(({ "[at] <indirect:object>", "<string>" })));
} /* blue() */
// --- END [/mnt/home2/grok/lib/obj/handlers/soul_compiler.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/library.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/library.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628338   Available: 13575692
Inodes: Total: 5242880    Free: 4960134
14161 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/library.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628338   Available: 13575692
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: library.c,v 1.19 2003/03/25 23:13:15 drakkos Exp $
 * 
*/
/**
 * The library is a sort of information center.
 * Currently it supports only the recording on stories about players and
 * recording the quests that they have done.
 * @author Furball
 * @see /include/library.h
 */

#include <quest_handler.h>
#include <player_handler.h>

#define XP 10000
#define XP_QUESTS ({"womble's brooch", "balance quest", "easy post quest", \
                    "hard post quest", "apprentice baker" })
#define RESTORE_PATH  "save/library/"

#define MAX_CACHE_SIZE 100
#define CACHE_TIMEOUT 900

inherit "/std/object";
 
int *times;
string player_name, *quests, text_file;
mapping player_quest_info;

nosave mapping qps;
nosave int requests, cache_hits;

class qinfo {
  int cached;
  
  string player_name;
  string *quests;
  int *times;
  string text_file;
  mapping player_quest_info;
}

nosave mapping player_cache = ([ ]);

int new_top_quest();
int query_quest_time(string, string);

private void init_data(string pl_name) {
  player_name = pl_name;
  quests = ({ });
  times = ({ });
  text_file = "";
  player_quest_info = ([ ]);
} /* init_data() */

void clean_cache() {
  string name;
  
  foreach(name in keys(player_cache))
    if(player_cache[name]->cached < time() - CACHE_TIMEOUT)
      map_delete(player_cache, name);
}

private int get_data_file(string name) {
  int success;
  class qinfo tmp;
  
  requests++;

  if(player_cache[name]) {
    player_cache[name]->cached = time();
    cache_hits++;
    return 1;
  }

  success = unguarded((: restore_object, RESTORE_PATH+name[0..0]+"/"+name :));
  if(!success)
    init_data(name);

  tmp = new(class qinfo,
            cached : time(),
            player_name : player_name,
            quests : quests,
            times : times,
            text_file : text_file,
            player_quest_info : player_quest_info);
  player_cache[name] = tmp;
  
  if((sizeof(player_cache) > MAX_CACHE_SIZE) &&
     (find_call_out("clean_cache") == -1))
    call_out("clean_cache", 60);

  return success;
}
 
private void save_data_file(string name) {
  if(!player_cache[name])
    return;

  player_name = player_cache[name]->player_name;
  quests = player_cache[name]->quests;
  times = player_cache[name]->times;
  text_file = player_cache[name]->text_file;
  player_quest_info = player_cache[name]->player_quest_info;

  unguarded((: save_object, RESTORE_PATH+name[0..0]+"/"+name :));
  return ;
} /* save_data_file() */

/**
 * This method returns the players current title.
 * @param name the name of the player
 * @return their current title, 0 if no title
 * @see /obj/handlers/quest_handler.c
 */
string query_title( string name ) {
  string quest;
  
  get_data_file( name );
  if(!player_cache[name]->quests || !sizeof(player_cache[name]->quests)) {
    return 0;
  }

  quest = player_cache[name]->
    quests[random(sizeof(player_cache[name]->quests))];

  return (string)QUEST_HANDLER->query_quest_title(quest);
}

/**
 * This method returns the set of currently completed quests by the
 * player.
 * @param name the name of the player
 * @return the array of completed quests
 */
string *query_quests(string name) {
  get_data_file(name);
  if(!player_cache[name]->quests ) {
    return ({ });
  }
  return player_cache[name]->quests + ({ });
}

/**
 * This method returns the most recently completed quest by the player.
 * @param name the player name
 * @return the most recently completed quest
 */
string get_most_recent_quest(string name) {
  int loop, highest;
  string quest_name;
  string *quests;
  int *times;
  
  if(!get_data_file(name))
    return "Sorry";

  quests = player_cache[name]->quests;
  times = player_cache[name]->times;
  
  if(sizeof(quests) == 0)
    return "None";

  for(highest = loop = 0; loop < sizeof(quests); loop++) {
    if(times[loop] > highest) {
      highest = times[loop];
      quest_name = quests[loop];
    }
  }
  return quest_name;
}

/**
 * This method get sthe most recent time a quest was complete by the
 * player.
 * @param name the name of the player 
 * @return the time of the most recently completed quest
 */
int get_most_recent_time(string name) {
  int loop, hightime;
  string *quests;
  int *times;
  if(!get_data_file(name)) {
    return -1;
  }
  quests = player_cache[name]->quests;
  times = player_cache[name]->times;
  
  if(sizeof(quests) == 0) {
    return 0;
  }
  for(hightime = loop = 0; loop < sizeof(quests); loop++) {
    if(times[loop] > hightime) {
      hightime = times[loop];
    }
  }
  return hightime;
}

/**
 * This method sets the player as having done the quest and if we
 * should give them xp for it
 * This function should be called when a quest is finished.  It will then
 * call the quest_completed function on the quest handler and do all
 * assorted modifications to the player object etc.  The name should be the
 * players name and the quest should be the name of the quest that is
 * stored in the quest handler.
 * <p>
 * The include file <library.h> should be used for calls to this
 * handler.
 * @return 0 if the quest is already completed
 * @see /obj/handlers/quest_handler->quest_completed()
 * @param pl_name name of the player
 * @param qu_name name of the quest
 * @param no_xp do not give out xp
 * @example
 * // Set the player as completing the womble friend quest, they get
 * // xp for it.
 * LIBRARAY->set_quest(this_player()->query_name(), "womble friend", 0);
 */
int set_quest(string pl_name, string qu_name, int no_xp) {
  int qu_level;
  object ob;
  object card;
  int i;

  // guests can't do quests.
  if(!find_player(pl_name) || find_player(pl_name)->query_property("guest"))
    return 0;

  i = QUEST_HANDLER->query_quest_status(qu_name);
  // Inactive quests automatically fail.

  ob = find_player (pl_name);
  
  if (i == 0 && ob->query_playtester()) {
    tell_object (ob, "%^BOLD%^If this quest weren't inactive, you'd be "
      "showered in riches right about now!\n%^RESET%^");       
  }
  
  if(i < 1) {    
   user_event( "inform", pl_name +" completes "+ qu_name + " (inactive)", "quest");
    
    return 0;
  }
  
  // Playtesters with playtester protection enabled do not get the 
  // quest.
  if (ob && ob->advancement_restriction()) {
    log_file ("/log/secure/playtesters/protection_log", "%s: %s "
      "completed quest %s while advancement restricted active.\n", ctime(time()),
      pl_name, qu_name);
    return 0;
  }
  
  // clean out the qps cache so that we don't get invalid data.
  if(qps && qps[pl_name])
    map_delete(qps, pl_name);

  get_data_file(pl_name);

  /* Already done the quest? */
  if ( member_array( qu_name, player_cache[pl_name]->quests ) != -1 )
    return 0;

  player_cache[pl_name]->quests += ({ qu_name });
  player_cache[pl_name]->times += ({ time() });

  /* Make sure the quest exists */
  qu_level = (int)QUEST_HANDLER->query_quest_level(qu_name);
  if ( qu_level < 1 )
    return 0;

  QUEST_HANDLER->quest_completed( pl_name, qu_name, previous_object() );

  save_data_file( pl_name );
  
  if ( !ob ) {
    return 0;
  }

  if(member_array(qu_name, XP_QUESTS) != -1) {
    ob->adjust_xp(XP*qu_level, 0);
    call_out("save_them", 1, ob);
  }

  ob->set_title( "quest",
                 (string)QUEST_HANDLER->query_quest_title( qu_name ) );

  card = clone_object ("/d/underworld/creator_cards/creator_card");
  
  card->move (ob, "$N appear$s in your inventory with a flash.");
  return 1;
}

/**
 * This method removes a quest from the players list of completed quests.
 * @param pl_name the player name
 * @param qu_name the quest name
 * @return 0 if they have not done the quest, 1 if they habe
 * @see /obj/handlers/quest_handler.c
 */
int unset_quest(string pl_name, string qu_name) {
  int qu_level;

  get_data_file(pl_name);
  /* Already done the quest? */
  if ( member_array( qu_name, player_cache[pl_name]->quests ) == -1 )
    return 0;
  
  /* Make sure the quest exists */
  qu_level = (int)QUEST_HANDLER->query_quest_level(qu_name);
  if ( qu_level < 1 )
    return 0;
  
  player_cache[pl_name]->quests -= ({ qu_name });
  player_cache[pl_name]->times -= ({ time() });

  save_data_file( pl_name );
  return 1;
}

/**
 * This method causes the player to be saved.
 * @param thing the player to save
 */
void save_them( object thing ) {
  if ( thing )
    thing->save_me();
}

/**
 * This method  sets the information related to the players quest.
 * This information is used for quests which have several parts to them
 * and information needs to be stored about the player as they attempt
 * to complete it.
 * @param pl_name the name of the player
 * @param qu_info the quest name
 * @param details the information associated with the quest.
 */
void set_player_quest_info( string pl_name, string qu_info, mixed *details ) {
  get_data_file( pl_name );
  
  if(!player_cache[pl_name]->player_quest_info )
    player_cache[pl_name]->player_quest_info = ([ ]);
  player_cache[pl_name]->player_quest_info[qu_info] = details;
  save_data_file(pl_name);
}

/**
 * This method returns all the quest information for a player.
 * This information is used for quests which have several parts to them
 * and information needs to be stored about the player as they attempt
 * to complete it.  The keys of the mapping are the quest names and the
 * values are the information associated with the quest.
 * @param pl_name the name of the player
 * @return the mapping containing all the quest info
 */
mapping query_all_player_quest_info( string pl_name ) {
  if(!get_data_file( pl_name ))
    return 0;
  if ( !player_cache[pl_name]->player_quest_info )
    return 0;
  return copy(player_cache[pl_name]->player_quest_info);
}

/**
 * This method returns the quest info for a specific quest.
 * This information is used for quests which have several parts to them
 * and information needs to be stored about the player as they attempt
 * to complete it.
 * @param pl_name the player name
 * @param qu_info the quest name
 * @return the information associated with the quest
 */
mixed *query_player_quest_info( string pl_name, string qu_info ) {
  if(!get_data_file( pl_name))
    return 0;
  if(!player_cache[pl_name]->player_quest_info)
    return 0;
  player_cache[pl_name]->player_quest_info =
    player_cache[pl_name]->player_quest_info + ([ ]);
  return player_cache[pl_name]->player_quest_info[qu_info];
}

/**
 * This method returns the time at which a quest is completed.
 * @param name the name of the player to get the time for
 * @param qu_name the name of the quest
 * @return the time at which it is completed
 */
int query_quest_time(string name, string qu_name) {
  int time;
 
  if(!get_data_file(name)) {
    return 0;
  }
  time = member_array(qu_name, player_cache[name]->quests);
  if(time < 0) {
    return 0;
  }
  return player_cache[name]->times[time];
}

/**
 * This method returns the story associated with the player.   This is
 * created from all the information about the quests they have done
 * joined together into a neato story.
 * @param name the player name
 * @return the story of the player
 * @see /obj/handlers/quest_handler->query_quest_story()
 */
string query_story(string name) {
  string story, *quests;
  int loop;
 
  if(!get_data_file(name)) {
    return "You can find nothing in the library on " + name + "\n";
  }
  story = "";
  if(player_cache[name]->text_file != "") {
    return unguarded((: read_file, text_file :));
  }
  quests = player_cache[name]->quests;
  if(!sizeof(quests)) {
    return "That person has lead a most unadventureous life";
  }
  for(loop = 0; loop < sizeof(quests); loop++) {
    story += capitalize(QUEST_HANDLER->query_quest_story(quests[loop])) +".\n";
  }
  return story;
}

/**
 * This method tells us if the player has completed the quest.
 * @param player the name of the player
 * @param quest the quest name
 * @return 1 if the quest has been done, 0 if it has not
 */ 
int query_quest_done(string player, string quest) {
  if(!get_data_file(player))
    return 0;
  
  return (member_array(quest, player_cache[player]->quests) != -1);
} /* query_quest_done() */

int flush_cache (string name) {
  qps[name] = 0;
}

/**
 * This method returns the current number of quest points gathered
 * by the player.
 * @param name the player
 * @return the current number of quest pointds
 * @see /obj/handlers/query_handler->query_quest_level()
 */
int query_quest_points( string name ) {
   int points;
   string word;
   string *quests;

   // qps is used to cache the count of quest points since it's expensive and
   // queried a lot.
   // the reason for storing points+1 is so that someone with 0 points still
   // comes up true under the test if(qps[name])
   if(!qps)
     qps = ([ ]);
   
   if(qps[name])
     return qps[name]-1;
   
   get_data_file( name );
   quests = player_cache[name]->quests;
   if ( !quests || !sizeof( quests ) )
      points = 0;
   else {
     foreach( word in quests ) {
       points += (int)QUEST_HANDLER->query_quest_level( word );
     }
   }
   
   qps[name] = points+1;
   
   return points;
} /* query_quest_points() */

/**
 * This method is called when a player refreshes totaly so they can
 * start again from scratch.
 * @param name the player name
 * @return 0 if they do not exists, 1 if they do
 */
int restart(mixed name) {
  class qinfo tmp;

  if(objectp(name))
    name = name->query_name();

  if(!PLAYER_HANDLER->test_user(name))
    return 0;
  
  init_data(name);
  tmp = new(class qinfo,
            cached : time(),
            player_name : player_name,
            quests : quests,
            times : times,
            text_file : text_file,
            player_quest_info : player_quest_info);
  player_cache[name] = tmp;
  save_data_file(name);
  return 1;
} /* restart() */

mixed *stats() {
  int percentage;

  if(requests)
    percentage = (cache_hits * 100) / requests;
  
  return ({
    ({ "cache size", sizeof(player_cache) }),
      ({ "requests", requests }),
      ({ "cache hits", cache_hits }),
      ({ "cache misses", requests - cache_hits }), 
      ({ "percentage hits", percentage }),
      });
}
 
// --- END [/mnt/home2/grok/lib/obj/handlers/library.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/english_handler.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/english_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628334   Available: 13575688
Inodes: Total: 5242880    Free: 4960134
5353 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/english_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628334   Available: 13575688
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 *
 * English Handler
 * @author Shaggy
 * 
 * This handler is a collection of methods that attempt to evaluate how much
 * like english a line of text is.  Some tests might be more expensive than
 * others but the general idea is to be much cheaper than a dictionary lookup.
 * 
 * The general principle it to return a value that is closer to 100 the better
 * the english with 50 being borderline (ie. likely to be gibberish).
 * The returned value is thus a bit like a percentage chance that it is
 * english.
*/

/* 
 * Frequencies of letters and 1/(standard deviations) in a 500K am board archive (titles removed) 
 * The format is pairs:  freq per line * 1000     1/(std dev) per line * 1000    
 * 1st-26th pairs:  letters a-z
 * 27th pair is spaces
 * 28th pair is other characters (excluding newline)
*/
float *freq=({ 0.070012, 15.782218, 0.011949, 43.328090, 0.021800, 31.780955,
                 0.041222, 22.534301, 0.081093, 11.110506, 0.016799, 34.952377,
                 0.019235, 35.094824, 0.031751, 21.939816, 0.055348, 15.959625,
                 0.001028, 116.456628, 0.007624, 57.669862, 0.029144,
                 22.558570, 0.028764, 31.148966, 0.047194, 18.490345, 0.054178,
                 15.319177, 0.014415, 36.228697, 0.001335, 116.456628,
                 0.047561, 18.817823, 0.050139, 17.975454, 0.058789, 13.617099,
                 0.020638, 32.978418, 0.005222, 63.346619, 0.011713, 42.180909,
                 0.001264, 116.456628, 0.014661, 40.185678, 0.000530,
                 116.456628, 0.171614, 40.0, 0.000666, 116.456628,
                 0.084311, 10.304674
});
/**
 * FreqTest is a routine that evaluates how like english a line of text is.  It
 * compares the frequency of the letters, spaces and non-letters to the typical
 * number in English (taken from the am board archive).  A typical sentence
 * should give a percentage change of being english in the range 50-100.
 * Short or unusual sentences can get borderline evaluations (<60) even if they
 * are english.
 * 
 * @param line line of text to evaluate
 * @return percentage chance of being english 50-100 ok < 50 might be gibberish 
 *
 * @example "/obj/handlers/english_handler"->FreqTest("Short english sentence")
 * Returns: 75
 * @example "/obj/handlers/english_handler"->FreqTest("Sqeal spezzial sentenz")
 * Returns: 1
 * @example "/obj/handlers/english_handler"->FreqTest("eeeeeeee dfs fsfdsfddf")
 * Returns: 37
 * @example "/obj/handlers/english_handler"->FreqTest("too short");  
 * Returns: 59
 * @example "/obj/handlers/english_handler"->FreqTest("Don't like l33t sp33k neither");  
 * Returns: 36
 * @example "/obj/handlers/english_handler"->FreqTest("a small excursion to the
 *                                                     zoo should be permissible");
 * Returns: 83 
*/
int FreqTest( string line ) {
  int len,i,ch;
  float badness,term;
  int *let;

  let=allocate(29);
  i = len = strlen(line);

  while (i--) { 
    ch = line[i]; 
    if ((ch>=65 && ch<65+26) || (ch>=97 && ch<97+26)) let[(ch&31)-1]++; 
    else if (ch==' ') let[26]++; 
    else if (ch>='0' && ch<='9') let[27]++; 
    else let[28]++; 
  }

  badness = 0.0;
  for (i=0;i<29;i++) {
    term = to_float((to_float(let[i]) - freq[i<<1] * len) * freq[(i<<1)+1]);
    badness += (term>0 ? term : -term);
  }
  badness /= (29.0*len);
  i = 100 - 50*badness*badness;
  if (i<1) i=1;

  return i;
}

/**
 * ProfaneTest is a routine that evaluates how likely the text is to
 * be profane/swearing/obscenity and so on.  These are the sorts of
 * things that would never be allowed as a player name.  Spaces, non
 * letters and repeating letters are worked around by this test.
 *
 * @param line line of text to evaluate
 * @return percentage chance of being offensive: chances over 100% can be returned
 *         indicating greater likelihood of offense and/or more than one suspect word.
 *         If you want it as lily white as possible you should insist on 0.
*/
int ProfaneTest( string strin ) {
  int i,profane=0;
  string str,s;

  if (sizeof(strin)<1) return 0;

  strin=lower_case(strin)+" ";

  str="";
  for (i=0;i<sizeof(strin);i++) {
    if (strin[i]>='a' && strin[i]<='z') str+=strin[i..i];
  }

  if (sizeof(str)<2) return 0;

  s=str[0..0];
  for (i=1;i<sizeof(str);i++) {
    if (s[<1]!=str[i]) s+=str[i..i];
  }

  /* moderate and also ambiguous */
  if (regexp(s,"bastard|tit|shaft|viag") 
     || regexp(str,"poo|ass|butt")) profane+=25;

  /* fairly dicey and less likely to be ambiguous */
  if (regexp(s,"arse|sex|sux|crap|testic|fart|orgasm|orgy|turd|porn|niple|nazi|jesus|christ|satan|sperm|smeg|toilet|genital")
     || regexp(str,"piss|root|buttw|assho")
     || regexp(strin,"butt |ass ")) profane+=50;

  /* almost certainly profane */
  if (regexp(s,"netsex|arse|shit|screw|urine|rectum|tampon|vibrator|rectal|scatol|semen|suck|lick|dyke|dike|wank|mutha|prost|fag|feck|gay|homo|fuq|horny|blowjob|cuni") 
     || regexp(str,"phall|hooter|poof")) profane+=100;

  /* profane --- and yes, Hortense thinks analytic is a rude word */
  if (regexp(s,"anal|rape|rapist|fuck|fuk|fuch|kuck|cunt|kunt|whor|slut|clit|masturb|masterb|penis|cock|dick|pusy|bitch|vagina")) profane+=200;

  //  tell_creator("shaggy","start shout: %s\n",strin);
  //tell_creator("shaggy","text: %s profane chance: %d\n",s,profane);
  
  return profane;
}
// --- END [/mnt/home2/grok/lib/obj/handlers/english_handler.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/converter.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/converter.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628333   Available: 13575687
Inodes: Total: 5242880    Free: 4960134
1854 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/converter.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628333   Available: 13575687
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: converter.c,v 1.1 1998/01/06 05:03:33 ceres Exp $
 * $Log: converter.c,v $
 * Revision 1.1  1998/01/06 05:03:33  ceres
 * Initial revision
 * 
*/
/* 
 * Mail converter.
 * By Turrican@Discworld, May 1995
 */

mixed *mail;
nosave string *names;
nosave int no_more;

int query_busy(string name);

void create() {
  seteuid("mailer");
  names = ({ });
  no_more = 0;
}

int ok_to_shut() {
  no_more = 1;
  return (sizeof(names) == 0);
}

void convert_it(string pname) {
  int i, bing;

  if (no_more) {
    write("Can't start converting mail, try again after the reboot.\n");
    return;
  }
  if (query_busy(pname)) {
    write("Argh ! Already busy converting mail for "+pname+".\n");
    return;
  }
  mail = ({ });
  if (file_size("/save/post/"+pname+".o") == -1)
    return;
  unguarded((: restore_object, "/save/post/"+pname :));
  bing = sizeof(mail);
  if (!bing) {
    unguarded((: rm, "/save/post/"+pname+".o" :));
    return;
  }
  write("Converting mail for "+pname+".\n");
  names += ({ pname });
  for (i = 0; i < bing; i++) {
    reset_eval_cost();
    call_out("do_it", (i+1)*3, (mail[i] + ({ pname })));
  }
  call_out("reset_busy", (i+1)*3, pname);
  unguarded((: rm, "/save/post/"+pname+".o" :));
}

void do_it(mixed *arg) {
  object handler = clone_object("/obj/handlers/folder_handler");
  handler->add_it((["to" : ({ arg[6] }),
    "cc" : ({ }), "from" : arg[1], "subject" : arg[3], "body" :
    "From "+arg[1]+" "+ctime(arg[0])+
    "\nDate: "+ctime(arg[0])+
    "\nFrom: "+arg[1]+
    "\nTo: "+arg[2]+
    "\nSubject: "+arg[3]+
    "\nCc: "+(arg[4]?arg[4]:"")+"\n\n"+
    arg[5] ]), 1);
}

int query_busy(string name) {
  return (member_array(name, names) != -1);
}

void reset_busy(string name) {
  names -= ({ name });
  if (no_more && !sizeof(names)) {
    "/obj/shut"->shut(2);
  }
}
// --- END [/mnt/home2/grok/lib/obj/handlers/converter.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/fairy_godmothers.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/fairy_godmothers.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628332   Available: 13575686
Inodes: Total: 5242880    Free: 4960134
11578 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/fairy_godmothers.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628332   Available: 13575686
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: fairy_godmothers.c,v 1.14 2002/09/02 11:39:59 taffyd Exp $
 * $Log: fairy_godmothers.c,v $
 * Revision 1.14  2002/09/02 11:39:59  taffyd
 * Changed non-existant set_social_points() method to new set_sp().
 *
 * Revision 1.13  2002/08/03 22:54:56  tilly
 * Changed it to query the player's start location instead of being hard coded for the Drum or CWC.
 *
 * Revision 1.12  2002/02/20 10:42:53  taffyd
 * Temporary tweak for Cwc.
 *
 * Revision 1.11  2002/01/25 13:24:12  tilly
 * Added a call_out to move the godmother to the rubbish room, because she vanished before moving the player and saying all her lines. Also added an exit message for when she vanishes.
 *
 * Revision 1.10  2001/12/27 01:06:48  drakkos
 * Added some logging and a playerinfo entry for when using the godmother costs a life.
 *
 * Revision 1.9  2001/03/24 00:08:47  ceres
 * Fixed death cost & GMs not speaking when they arrive.
 *
 * Revision 1.8  2001/03/09 21:55:47  ceres
 * Added entry message for godmothers
 *
 * Revision 1.6  2000/06/27 00:17:43  pinkfish
 * change to use the config.h file.
 *
 * Revision 1.5  2000/04/08 01:33:06  pinkfish
 * Fix up some errors in the godmother handler.
 *
 * Revision 1.4  1999/05/21 18:22:02  rywfol
 * Fixed bug/typo which prevented the "attacked godmother"
 * property from doing anything..
 *
 * Revision 1.3  1998/06/12 23:29:20  presto
 * Fixed typo
 *
 * Revision 1.2  1998/05/02 16:44:53  presto
 * Fixed typo, it's --> its
 *
 * Revision 1.1  1998/01/06 05:03:33  ceres
 * Initial revision
 * 
*/
/**
 * Keep track of all the fairy godmothers.  Make sure they don't do any
 * thing naughty.  This also controls the costs for the godmother
 * service.
 * @author Pinkfish
 */
#include <panic.h>
#include <config.h>
#include <playerinfo.h>
#include <cwc.h>

#define HARRY_SHADOW "/std/shadows/misc/harry_shadow"

object* _panicers;
object* _godmothers;
object* _queue;

#define FREE_NAME "free trip"
#define THRESHOLD 50
#define DAY (60*60*24)

/* Prototypes */

public  void   continue_panicing(string str, object panicer);
private object startup_godmother(object ob);
private void   finish_with_person(object ob, int ok);

/* Functions */

void create() {
  _panicers = ({ });
  _godmothers = allocate(NUM_GODMOTHERS);
  _queue = ({ });
} /* setup() */

/**
 * Return an array of all the godmothers.  This is the current set of
 * used godmothers.
 * @return an array of objects of godmothers
 */
object *query_godmothers() { return copy(_godmothers); }

/**
 * Check to see if there are any free godmothers.  Are you being
 * served?
 * @return 1 if there is a free one, 0 if there is not
 */
int free_godmothers() {
  int i;

  for (i=0;i<sizeof(_godmothers);i++) {
    if (!_godmothers[i]) {
      return 1;
    }
  }
  return 0;
} /* free_godmothers() */

/**
 * This method handles a player panicing.
 * <p>
 * This is the fairy godmother controller for panicing.
 * <p>
 * When someone panics it calls on this object to help fix them
 * up.
 * @param panicer the person panicing
 * @return 0 if they were unmable to panic, 1 if they were
 */
int do_startup(object panicer) {
  if (environment(panicer) &&
      environment(panicer)->query_property("no godmother")) {
    notify_fail(environment(panicer)->query_property("no godmother"));
    return 0;
  }

  if (panicer->query_property("attacked godmother") &&
      (panicer->query_property("attacked godmother") + DAY * 10) > time())
  {
    notify_fail("You attacked a godmother!  No help for you!\n");
    return 0;
  }

  if (sizeof(panicer->query_attacker_list())) {
    notify_fail("You cannot use a godmother whilst you are in a fight.\n");
    return 0;
  }

  panicer->remove_property("attacked godmother");

  _panicers -= ({ 0 });
  if (member_array(panicer, _panicers) != -1  ||
      member_array(panicer, _queue) != -1)
  {
    notify_fail("You are already requesting assistance.  Be patient.\n");
    return 0;
  }

  if (!panicer) {
    panicer = this_player();
  }

  if (panicer->query_level() < 10 ||
      !arrayp(environment(panicer)->query_exits()) ||
      !sizeof(environment(panicer)->query_exits()) ||
      !environment(panicer))
  {
    write("You feel help is on its way.\n");
    panicer->add_property("godmother", FREE_NAME);
    continue_panicing("y", panicer);
  }
  else {
    panicer->remove_property("godmother");
    if (panicer->query_level() < 50) {
      int max_gp;

      max_gp = panicer->query_max_gp();
      if (panicer->query_gp() < max_gp / 3) {
        notify_fail("You do not have enough guild points to summon "
                    "a godmother.  You need at least " +
                    (max_gp / 3) + ".\n");
        return 0;
      }
      write("This will cost you all of your current guild points and "
            "social points, and leave you feeling a little weak.  "
            "Do you wish to continue? ");
      input_to("continue_panicing", 0, panicer);
    }
    else {
      if (panicer->query_max_deaths() <= panicer->query_deaths()) {
        notify_fail("You do not have a life to spend on a godmother.\n");
        return 0;
      }
      write("This will cost you a life, do you wish to continue? ");
      input_to("continue_panicing", 0, panicer);
    }
  }
  return 1;
} /* do_startup() */


/** @ignore yes */
private void do_check_queue() {
   _queue -= ({ 0 });
   if (sizeof(_queue)) {
      if (startup_godmother(_queue[0])) {
         _queue = _queue[1..];
      }
   }
} /* do_check_queue() */


/** @ignore yes */
private void setup_harrass_callout() {
  int i;
  int check_queue;
  int waiting;
  int max_wait;

  for (i = 0; i < sizeof(_godmothers); i++) {
    if (_godmothers[i]) {
      waiting = _godmothers[i]->query_waiting();
      if (waiting > FIRST_WAIT_TIME && environment(_godmothers[i])) {
        _godmothers[i]->hurry_up();
      }
      if (!environment(_godmothers[i])) {
         _godmothers[i]->dest_me();
         check_queue = 1;
      }
      if (waiting > max_wait) {
        max_wait = waiting;
      }
    }
  }
  if (max_wait < FIRST_WAIT_TIME) {
    call_out("do_hurry_up", FIRST_WAIT_TIME-max_wait+2);
  }
  if (check_queue) {
    do_check_queue();
  }
} /* setup_harrass_callout() */


/** @ignore yes */
void continue_panicing(string str, object panicer) {
  str = lower_case(str);
  if (!str || str == "" || (str[0] != 'y' && str[0] != 'n')) {
    if (panicer->query_level() < 100) {
      write("This will cost you all of your current guild points and "
            "social points and leave you feeling a little weak.  "
            "Do you wish to continue? ");
      input_to("continue_panicing", 0, panicer);
      return ;
    }
    else {
      write("This will cost you a life, do you wish to continue? ");
      input_to("continue_panicing", 0, panicer);
      return ;
    }
  }

  if (str[0] == 'n') {
    write("Ok.  They do not show up to help you.  Good luck.\n");
    return ;
  }

  if (!startup_godmother(panicer)) {
    write("You hope a godmother will turn up sometime soon.\n");
    _queue += ({ panicer });
    setup_harrass_callout();
  }
} /* continue_panicing() */

void do_panic_callout(object godmother, object ob) {
  godmother->do_panic(ob);
}

private object startup_godmother(object ob) {
  object godmother;
  int    i, num;

  /* Which fairy godmother do you get? */
  /* Only done 2 so far... */
  i = random(NUM_GODMOTHERS);
  if (_godmothers[i]) {
    for (num = 1; num < NUM_GODMOTHERS; num++)  {
      i = (i + 1) % NUM_GODMOTHERS;
      if (!_godmothers[i])  break;
    }
  }

  /* See if they're all busy... */
  if (num == NUM_GODMOTHERS)
     return 0;

  switch (i) {
    case 0:
      godmother = clone_object(GODMOTHER_DIR + "granny");
      break;

    case 1:
      godmother = clone_object(GODMOTHER_DIR + "magrat");
      break;

    default:
      write("Something is hosed.  Please file a bug report.\n");
      break;
  }
  _godmothers[i] = godmother;
  godmother->move(environment(ob), "As if by magic $N appears.", "");
  call_out("do_panic_callout", 1, godmother, ob);
  _panicers += ({ ob });
  return godmother;
} /* startup_godmother() */

/**
 * Called by the godmother when the person has completed their
 * paniced transaction.
 * @param person the person who paniced
 * @param ok did they complete it ok?
 */
void finish_panic(object person, int ok) {
  int i;

  if (person)  {
     finish_with_person(person, ok);
  }

  _panicers -= ({ person });

  for (i = 0; i < sizeof(_godmothers); i++)  {
    if (_godmothers[i] == previous_object()) {
      call_out("do_move", 10, _godmothers[i] );
      break;
    }
  }

  do_check_queue();

  if (!sizeof(_queue)) {
     remove_call_out("do_hurry_up");
  }
} /* finish_panic() */


void do_move (object fairy) {
      fairy->move("/room/rubbish", "",
          "With a quick flick of her wand, the fairy godmother is gone.");
      fairy = 0;
} /* do_move */


private void finish_with_person(object person, int ok)  {
  if (member_array(person, _panicers) == -1) {
    log_file("GODMOTHER_ERROR", "person == %O, godmother == %s\n", person, previous_object()->query_short());
    write("Consistancy error, they never paniced.\n");
    return ;
  }
  if (ok) {
    if (person->query_property("godmother") == FREE_NAME) {
    }
    else if (person->query_level() < THRESHOLD) {
      person->adjust_tmp_con(-2);
      person->set_gp(0);
      person->set_sp(0);
    }
    else if (person->query_level() >= THRESHOLD &&
             person->query_max_deaths() > person->query_deaths()) {
      PLAYERINFO_HANDLER->add_entry(person,
        person->query_name(), "misc", "Lost a life to the Godmother");
      log_file("GODMOTHER_DEATH", "%s: %s lost a life to the Godmother\n", 
        ctime(time()), person->query_name());              
      person->adjust_deaths(1);
    }

    
    call_out(function(object person) {
      string destination;
      
      destination = person->query_nationality()->query_default_start_location();

      person->move_with_look(destination,
                             "$N appears out of nowhere.",
                             "$N disappears with a pop.");
      if (person->query_ghost()) {
        person->remove_ghost();
        clone_object(HARRY_SHADOW)->setup_shadow(person,
                                                 "a fairy godmother" );
      }
    }, 2, person);
  }

  person->remove_property("godmother");
} /* finish_with_person() */


/**
 * Give the players a nudge if they are taking to long.
 */
void do_hurry_up() {
  int i;
  int waiting;
  int max_wait;

  if (!sizeof(_queue)) {
    return ;
  }

  for (i = 0; i < sizeof(_godmothers); i++) {
    if (_godmothers[i]) {
      if (!environment(_godmothers[i])) {
        _godmothers[i]->dest_me();
        _godmothers[i] = 0;
      }
      else {
        waiting = _godmothers[i]->query_waiting();
        if (waiting > FIRST_WAIT_TIME) {
          if (waiting > FINISH_WAIT_TIME) {
            _godmothers[i]->finish_up();
          } else {
            _godmothers[i]->hurry_up();
          }
        }
        if (waiting > max_wait) {
          max_wait = waiting;
        }
      }
    }
  }
  if (max_wait > 0) {
    if (FINISH_WAIT_TIME - max_wait < 10) {
      call_out("do_hurry_up", 10);
    } else {
      call_out("do_hurry_up", FINISH_WAIT_TIME-max_wait);
    }
  }
} /* do_hurry_up() */


/** @ignore yes */
void dest_me() {
  int i;

  for (i = 0; i < sizeof(_godmothers); i++) {
    if (_godmothers[i]) {
      _godmothers[i]->dest_me();
    }
  }
  destruct(this_object());
} /* dest_me() */
// --- END [/mnt/home2/grok/lib/obj/handlers/fairy_godmothers.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/playtesters.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/playtesters.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628329   Available: 13575683
Inodes: Total: 5242880    Free: 4960134
29326 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/playtesters.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628329   Available: 13575683
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: playtesters.c,v 1.29 2002/08/11 16:26:47 drakkos Exp $
 * $Log: playtesters.c,v $
 * Revision 1.29  2002/08/11 16:26:47  drakkos
 * Various updates
 *
 * Revision 1.28  2002/07/19 02:16:35  drakkos
 * Adjust quota fix
 *
 * Revision 1.27  2002/07/16 22:35:49  pinkfish
 * Fix up the remove stuff to actually delete empty lists.
 *
 * Revision 1.26  2002/07/16 21:39:13  pinkfish
 * make it handle multiple destinations from the current location.
 *
 * Revision 1.25  2002/07/16 21:00:24  pinkfish
 * Add in jump points.
 *
 * Revision 1.24  2002/07/16 20:49:18  drakkos
 *  Forcibly unlocked by pinkfish
 *
 * Revision 1.23  2002/07/04 10:40:21  pinkfish
 * Fix up the logging.
 *
 * Revision 1.22  2002/07/04 10:35:22  drakkos
 *  Forcibly unlocked by pinkfish
 *
 * Revision 1.21  2002/02/21 21:27:20  arienne
 * Every IDEA report, every tenth BUG report and no TYPO reports are
 * now posted to the "playtesters" board.
 *
 *
 * Revision 1.20  2001/11/03 10:29:54  arienne
 * Added check that they actually are a playtester before putting them on
 * leave.  Ditto with off leave.
 *
 * Revision 1.17  2001/10/23 18:47:20  arienne
 * Added query_show_list_colour() -- like query_show_list(), except it Burns
 * your Eyes with Fluorescent Goodness.
 *
 * Revision 1.16  2001/05/13 16:59:42  arienne
 * Fixed up monthly roll-over so that it adds the new month to 'months'.
 *
 * Revision 1.11  2001/03/25 01:33:45  ceres
 * Stopped the 'ptesters' command loaded the player files of every playtesters
 *
 * Revision 1.9  2000/11/15 16:41:42  pinkfish
 * Make it wrap the other way.
 *
 * Revision 1.8  2000/11/14 20:28:51  pinkfish
 * Make it post wrapped note to the board.
 * .
 *
 * Revision 1.7  2000/11/14 20:22:53  terano
 *  Forcibly unlocked by pinkfish
 *
 * Revision 1.6  2000/03/29 06:05:21  ceres
 * rcsi /obj/handlers/playtesters.c
 * Modified to use the player handler directly.
 *
 * Revision 1.5  1999/12/01 09:28:21  taffyd
 * Added super new functions! Bonus functionality for no cost.
 *
 * Revision 1.4  1999/03/17 01:42:53  gruper
 * Added query_tester()
 *
 * Revision 1.3  1998/06/04 01:53:57  presto
 * Made it check the date every time a report is filed so that reports at the
 * beginning of a month go onto the correct total.  Long uptimes were causing
 * most of Jun 1st bugs to be filed under May, etc.
 *
 * Revision 1.2  1998/02/04 05:01:37  sin
 * test_age() sometimes returns a negative value (when the player is still logged in).  I added a wrapper that takes the absolute value.
 *
 * Revision 1.1  1998/01/06 05:03:33  ceres
 * Initial revision
 * 
*/
/**
 * Keeps track of all the current playtesters.  This keeps track of all
 * the current playtesters.
 */
#include <board.h>
#include <project_management.h>
#include <player_handler.h>
#include <playtesters.h>
#include <login.h>

#define SAVE_FILE "/save/playtesters"
#define LEVEL 150

#define NORMAL_PLAYTESTER 1
#define SENIOR_PLAYTESTER 2

// every IDEA report is being posted

// post every tenth BUG report
#define BUG_SKIP 10

// not posting any TYPO reports, or other sorts of report

// this is the counter for BUG reports, nothing else
private int count = 0;

private nosave int updating = 0;

private string* months = ({});
private mapping pts = ([]);
private mapping playtesters = ([]);
private mapping ages = ([]);
private mapping guilds = ([]);
private mapping bugs = ([]);
private mapping leave = ([]);
private mapping tmp_pts = ([ ]);
private mapping _jump_points;
private string *executives = ({ });

int query_leave (string);

/** @ignore yes */
void save_file() {
    unguarded( (: save_object, SAVE_FILE :) );
} /* save_file() */


void create() {
   seteuid( master()->creator_file( file_name( this_object() ) ) );

   months = ({ });
   pts = ([ ]);
   ages = ([ ]);
   guilds = ([ ]);
   bugs = ([ ]);
   playtesters = ([ ]); /// XXX temporary
   leave = ([ ]);
   tmp_pts = ([ ]);
   _jump_points = ([ ]);
   executives = ({ });
   
   if ( file_size( SAVE_FILE + ".o" ) > 0 )
      unguarded( (: restore_object, SAVE_FILE, 1 :) );
 
     
   call_out( "reset", 2 );
} /* create() */


/**
 * This method returns a list of the current play testers.  This is
 * a list of string names in an array.
 * @return the list of current playtesters
 */
string* query_playtesters() {
    return copy( keys( pts ) );
} /* query_playtesters() */

/**
 * This method tests to see if the given name is a playtester.
 * @return 1 if they are a playtester, 0 if they are not.
 * @see add_playtester()
 * @see remove_playtester()
 * @see query_senior_playtester()
 */
int query_playtester( string name ) {
  return !undefinedp( pts[ name ] );
} /* query_playtester() */

/**
 * This method should never ever be used.  Use of this call is meant to be
 * broken.  Old code that uses check_playtester() probably meant to use
 * query_playtester().  Use this instead (or better, query_tester()).  If you
 * wish to hire a playtester using this call (which is what it actually did!),
 * please look at hire_playtester() and add_playtester().
 * @see query_playtester()
 * @see query_tester()
 * @see hire_playtester()
 * @see add_playtester()
 * @return Always returns 0.
 */
int check_playtester( string ) {
    log_file( "PLAYTESTERS", file_name( previous_object() ) + " using "
              "deprecated check_playtester() call\n" );
    return 0;
} /* check_playtester() */

/**
 * This method tests to see if "person" is an authorized tester,
 * i.e. a playtester, creator or has the "test character" property.
 * @param person A string or object to determine tester status for.
 * @return 1 if they are a tester, 0 if they are not.
 * @see query_playtester()
 */
int query_tester( mixed person ) {
    object ob;
    string str;

    if ( stringp( person ) ) {
        ob = find_player( person );
        if ( !ob ) {
            return 0;
        }
        str = person;
    } else if ( objectp( person ) ) {
        ob = person;
        str = person->query_name();
    } else {
        return 0;
    }

    return ( ob->query_creator() ||
             ob->query_property( "test character" ) ||
             query_playtester( str ) );
} /* query_tester() */

/**
 * This method finds the age of the playtester from the player handler.  NOTE:
 * This causes the playerfile to be loaded if it hasn't been already - this
 * will cause LOTS OF LAG if done on a lot of playerfiles.
 * @param name the name of the playtester to check
 * @return an integer representing the age of the playtester in seconds.
 * Always >= 0.
 */ 
protected int get_age_raw( string name ) {
    int fu = PLAYER_HANDLER->test_age( name );
    if ( fu < 0 )
        fu = -fu;
    return fu;
} /* get_age_raw() */

/**
 * This method will get the age of a playtester from this handlers' cache.
 * @param name the name of the playtester to check
 * @return an integer representing the age of the playtester in
 * seconds.  Always >= 0.
 */
int get_age_cached( string name ) {
    if ( ages[ name ] < 0 )
        ages[ name ] = -ages[ name ];
    return ages[ name ];
} /* get_age_cached() */

/**
 * This method will update the playtesters' age if they are online and return
 * the value from the cache.
 * @param name the name of the playtester to check
 * @return an integer representing the age of the playtester in seconds.
 * Always >= 0.
 */
int get_age_uncached( string name ) {
    if ( find_player( name ) )
        ages[ name ] = find_player( name )->query_time_on();
    return get_age_cached( name );
} /* get_age_uncached() */

/**
 * This method will update the playtesters' age from the player handler.
 * NOTE: This causes the playerfile to be loaded if it hasn't been already -
 * this will cause LOTS OF LAG if done on a log of playerfiles.
 * @param name the name of the playtester to check
 * @return an integer representing the age of the playtester in seconds.
 * Always >= 0.
 */
int get_age_uncached_offline( string name ) {
    ages[ name ] = get_age_raw( name );
    return get_age_cached( name );
} /* get_age_uncached_offline() */

/**
 * This method determines if they are a senior playtester.
 * @param name the name of the playtester to check
 * @return 1 if they are a senior playteser, 0 if they are not
 * @see add_senior_playtester()
 * @see remove_senior_playtester()
 * @see query_playtester()
 */
int query_senior_playtester( string name ) {
    return ( pts[ name ] == SENIOR_PLAYTESTER );
} /* query_senior_playtester() */


/**
 * This method adds the playtester to the array of current play
 * testers.  NOTE: This uses get_age_raw(), which will cause lag if called on
 * lots of playerfiles.
 * @param name the name of the player to add
 * @return 1 if successful, 0 on failure
 * @see remove_playtester()
 * @see query_playtester()
 * @see add_senior_playtester()
 * @see valid_playtester()
 */
int add_playtester( string name ) {
    if ( pts[ name ] )
        return 0;
    log_file( "PLAYTESTERS", ctime( time() ) + ": " + name +
              " added as a playtester by %s\n", this_player()->query_name() );
    pts[ name ] = NORMAL_PLAYTESTER;
    ages[ name ] = get_age_uncached_offline( name );
    guilds[ name ] = PLAYER_HANDLER->test_guild( name );
    bugs[ name ] = ([ ]);
    if (tmp_pts[name]) {
      if (tmp_pts[name] == SENIOR_PLAYTESTER) {
        pts[name] = SENIOR_PLAYTESTER;
      }
      map_delete (tmp_pts, name);
    }
    PT_APPLICATION_HANDLER->delete_applicant (name);
    save_file();
    return 1;
} /* add_playtester() */

/**
 * This method adds the player as a senior playtester.  The playtester
 * needs to already be added as a normal playtester before becoming a
 * senior playtester.
 * @param name the name of the player to add
 * @return 1 on success, 0 on failure
 * @see remove_senior_playtester()
 * @see add_playtester()
 * @see query_senior_playtester()
 */
int add_senior_playtester( string name ) {
    if ( pts[ name ] != NORMAL_PLAYTESTER )
        return 0;
    log_file( "PLAYTESTERS", ctime( time() ) + ": " + name +
              " promoted to senior playtester by %s\n",
              this_player()->query_name() );
    pts[ name ] = SENIOR_PLAYTESTER;
    save_file();
    return 1;
} /* add_senior_playtester() */

/**
 * This method adds the player as a senior playtester.  The playtester
 * needs to already be added to become a senior playtester.
 * @param name the name of the player to remove
 * @return 1 on success, 0 on failure
 * @see add_senior_playtester()
 * @see remove_playtester()
 * @see query_senior_playtester()
 */
int remove_senior_playtester( string name, string reason ) {
    if ( pts[ name ] != SENIOR_PLAYTESTER )
        return 0;
    log_file( "PLAYTESTERS", ctime( time() ) + ": " + name +
              " demoted from senior playtester; Reason: " + reason +
              " by "+ this_player()->query_name() + "\n" );
    pts[ name ] = NORMAL_PLAYTESTER;
    save_file();
    return 1;
} /* remove_senior_playtester() */

/**
 * This method will remove the playtester from the current list of
 * play testers.
 * @param name the name of the player to remove
 * @param reason the reason for the removal
 * @return 1 on success, 0 on failure
 * @see add_playtester()
 * @see remove_senior_playtester()
 * @see query_playtester()
 */
int remove_playtester( string name, string reason ) {
    string str;
    if ( !query_playtester( name ) )
        return 0;
    str = ctime( time() ) +": "+ name + " removed as a playtester";
    if ( reason ) {
        str += "; Reason: " + reason;
    }
    str += " by "+ this_player()->query_name() + "\n" ;
    log_file( "PLAYTESTERS", str + "\n" );
    map_delete( pts, name );
    map_delete( ages, name );
    map_delete( guilds, name );
    map_delete( bugs, name );
    PROJECT_HANDLER->clear_playtesting_projects (({name }));
    save_file();
    return 1;
} /* remove_playtester() */

/**
 * THis method returns a string reason why they are an invalid play
 * tester.  NOTE: This uses the player_handler, which will cause lag if
 * called on lots of playerfiles.
 * @param name the player to check
 * @return the string reason, 0 if none
 * @see valid_playtester()
 */
string reason_invalid_playtester(string name) {
    if ( !PLAYER_HANDLER->test_user( name ) ) {
        return "not a user";
    }
    if ( PLAYER_HANDLER->test_creator( name ) ) {
        return "currently a creator";
    }
    if ( PLAYER_HANDLER->test_level( name ) < LEVEL ) {
        return "level is too low";
    }
    return 0; 
} /* reason_invalid_playtester() */

/**
 * This method determins if they are a valid playtester or not.  NOTE: This
 * uses reason_invalid_playtester(), which will cause lag if called on lots of
 * playerfiles.
 * @param name the name of the player to test
 * @return 1 if they are, 0 if they are not
 * @see reason_invalid_playtester()
 */
int valid_playtester( string name ) {
    return ( !stringp( reason_invalid_playtester( name ) ) );
} /* valid_playtester() */

/**
 * This method checks to make sure an object can be a playtester, and if so,
 * adds them.
 * @param thing The player object to add as a playtester
 * @return 1 on success, 0 on failure.
 */
int hire_playtester( object thing ) {
    string name;

    if ( !objectp( thing ) )
        return 0;
    name = thing->query_name();
    if ( !stringp( name ) )
        return 0;
    if ( !valid_playtester( name ) )
        return 0;
    return add_playtester( name );
} /* check_playtester() */

/**
 * This adjusts the quota of a playtester.
 *
 * @param name The query_name() of the playtester.
 * @param amount A integer to adjust by.
 */
void adjust_quota( string name, int amount ) {
    string* bits;
    string right_now;
    int* bing;
    int age;
    
    bits = explode( ctime( time() ), " " ) - ({ "" });
    right_now = bits[ 1 ] + " " + bits[ 4 ];

    if (!bugs[name][right_now]) {
      bugs[name][right_now] = 0;
    }
    bing = bugs[ name ][ right_now ];
    age = get_age_uncached( name );
    
    if ( arrayp( bing ) && ( sizeof( bing ) == 3 ) ) {
        bing[ 0 ] += amount;
        bing[ 1 ] += age - bing[ 2 ];
        bing[ 2 ] = age;
    } else {
        bing = ({ amount, 0, age });
    }
    bugs[ name ][ right_now ] = bing;
    save_file();
} /* adjust_quota() */

/**
 * This method determines if a playtester is valid or not, and if not will
 * automagically remove them (does not remove senior playtesters
 * automatically).  NOTE: This uses valid_playtester() and
 * reason_invalid_playtester(), which will cause lag if called on lots of
 * playerfiles.
 * @param name the name of the player to test
 * @see reason_invalid_playtester()
 */
protected void check_playtesters_one( string name ) {
    if ( !valid_playtester( name ) ) {
        remove_playtester( name, reason_invalid_playtester( name ) +
                           " [automatic]" );
    } else {
        adjust_quota( name, 0 );
    }
} /* check_playtesters_one() */

/**
 * This goes through the list of playtesters and checks to make
 * sure they are all still valid.  It does so slowly, using a call_out until
 * it gets to the end.
 * @param who A string* of the query_name()'s of the playtesters to check.
 * @see valid_playtester()
 * @see remove_playtester()
 */
void check_playtesters( string* who ) {
    string* bits;
    string right_now;
    
    if ( sizeof( who ) ) {
        check_playtesters_one( who[ 0 ] );
        if ( sizeof( who ) > 1 ) {
            call_out( "check_playtesters", random( 10 ) + 5, who[ 1.. ] );
        } else {
            bits = explode( ctime( time() ), " " ) - ({ "" });
            right_now = bits[ 1 ] + " " + bits[ 4 ];
            if ( member_array( right_now, months ) < 0 ) {
                months += ({ right_now });
                save_file();
            }
        }            
    }
} /* check_playtesters() */


/**
 * @ignore yes
 * This just fixes up the quotas to contain zeroes for months that they are
 * present but do not file reports.  It does this every 12 resets.
 */
void reset() {
    if ( !updating )
        call_out( "check_playtesters", 30, copy( keys( pts ) ) );
    
    updating++;
    updating %= 12;
} /* reset() */

/**
 * This is called when a playtester makes a bug report.
 * @param name the name of the playtester
 * @param type the type of report
 * @param file the file the report is on
 * @param text the text associated with the report
 */
void report_made( string name, string type, string file, string text ) {
    int post = 0;
   
    if ( !query_playtester( name ) )
        return;

    if ( regexp( type, "IDEA" ) ) {
        post = 1;
    } else if ( regexp( type, "BUG" ) ) {
        count = ( count + 1 ) % BUG_SKIP;
        post = ( count == 0 );
    }

    if ( post ) {
        BOARD_HAND->add_message( "playtester_bugs", capitalize( name ),
                                 type + " for " + file,
                                 sprintf( "%75-=s", text ) );
    }
    
    adjust_quota( name, 1 );
} /* report_made() */

/**
 * This is a nice way of showing a list of the current play testers.
 * It prints a table of the previous four and current months, with columns
 * of bug reports made and number of hours online spent.
 */
string query_show_list() {
    string result;

    result = "              ";
    foreach ( string month in months[ <5.. ] ) {
        result += "    " + month;
    }
    result += "\n";
   
    foreach ( string name in sort_array( query_playtesters(), 1 ) ) {
        if ( query_senior_playtester( name ) ) {
            result += "S ";
        } else {
            result += "  ";
        }
        
        if ( stringp( leave[ name ] ) )
            result += sprintf( "%-14s", "[" + name + "]" );
        else
            result += sprintf( " %-12s ", name );
        
        foreach ( string month in months[ <5.. ] ) {
            if ( sizeof( bugs[ name ][ month ] ) >= 2 )
                result += sprintf( "   %4d %4d", bugs[ name ][ month ][ 0 ],
                                   ( bugs[ name ][ month ][ 1 ] / 3600 ) );
            else
                result += "   ---- ----";
        }
        result += "\n";
    }
    return result;
} /* show_list() */

/**
 * This is a nice way of showing a list of the current play testers.
 * It prints a table of the previous four and current months, with columns
 * of bug reports made and number of hours online spent.
 */
string query_show_list_colour() {
    string result;
    string colour;
    int online, reports;
    string temp;

    result = "              ";
    foreach ( string month in months[ <5.. ] ) {
        result += "    " + month;
    }
    result += "\n";
   
    foreach ( string name in sort_array( query_playtesters(), 1 ) ) {
        reports = 0;
        online = 0;

        if ( query_senior_playtester( name ) ) {
            temp = "S ";
        } else {
            temp = "  ";
        }
        temp += sprintf( "%%s%-12s%%%%^RESET%%%%^", name );
        foreach ( string month in months[ <5.. ] ) {
	          if (query_leave (name)) {
                    colour = "%%^WHITE%%^";	            
	          }        			
            else if ( sizeof( bugs[ name ][ month ] ) >= 2 ) {

                reports += bugs[ name ][ month ][ 0 ];
                online += bugs[ name ][ month ][ 1 ];
                
                if ( bugs[ name ][ month ][ 1 ] == 0 )
                    colour = ( stringp( leave[ name ] ) ?
                               "%%^MAGENTA%%^" :
                               "%%^BOLD%%^%%^MAGENTA%%^" );
                else if ( bugs[ name ][ month ][ 0 ] >=
                     ( bugs[ name ][ month ][ 1 ] / 7200 ) )
                    colour = ( stringp( leave[ name ] ) ?
                               "%%^GREEN%%^" :
                               "%%^BOLD%%^%%^GREEN%%^" );
                else if ( bugs[ name ][ month ][ 0 ] <
                          ( bugs[ name ][ month ][ 1 ] / 24000 ) )
                    colour = ( stringp( leave[ name ] ) ?
                               "%%^RED%%^" :
                               "%%^BOLD%%^%%^RED%%^" );
                else
                    colour = ( stringp( leave[ name ] ) ?
                               "%%^ORANGE%%^" :
                               "%%^YELLOW%%^" );
                
                temp += sprintf( "   %s%4d %4d%%%%^RESET%%%%^",
                                 colour,
                                 bugs[ name ][ month ][ 0 ],
                                 ( bugs[ name ][ month ][ 1 ] / 3600 ) );
            } else
                temp += "   ---- ----";
        }
        temp += "\n";
        
        if ( online == 0 )
            colour = ( stringp( leave[ name ] ) ?
                       "%^BOLD%^%^WHITE%^" :
                       "%^BOLD%^%^MAGENTA%^" );
        else if ( reports >= ( online / 7200 ) )
            colour = ( stringp( leave[ name ] ) ?
                       "%^GREEN%^" :
                       "%^BOLD%^%^GREEN%^" );
        else if ( reports < ( online / 24000 ) )
            colour = ( stringp( leave[ name ] ) ?
                       "%^RED%^" :
                       "%^BOLD%^%^RED%^" );
        else
            colour = ( stringp( leave[ name ] ) ?
                       "%^ORANGE%^" :
                       "%^YELLOW%^" );
        
        result += sprintf( temp, colour );
    }
    return result;
} /* query_show_list_colour() */

/**
 * This method returns a mapping which contains which Guilds
 * the playtesters belong to.
 * @return a lovely mapping
 */
mapping query_playtester_guilds() {
    mapping r = ([]);
    foreach ( string pt, string guild in guilds ) {
        if ( arrayp( r[ guild ] ) )
            r[ guild ] += ({ pt });
        else
            r[ guild ] = ({ pt });
    }
    return r;
} /* query_playtester_guilds() */

/**
 * This method returns a mapping which contains which the playtesters mapped
 * to their guild objects.
 * @return a lovely mapping
 */
mapping query_guilds() {
    return copy( guilds );
} /* query_guilds() */

/** 
 * @ignore yes
 * This small utility function is used to update the guilds...
*/ 
void update_guilds() {
  string guild;
    foreach( string player, mapping data in playtesters ) { 
        if ( !sizeof (data[ "guild" ]) ) { 
            guild = PLAYER_HANDLER->test_guild( player );
            if (!sizeof (guild)) {
              guild = "/std/guilds/standard";
            }
            
            data[ "guild" ] = guild;
        }
    }

    save_file(); 
} /* update_guilds() */ 

/**
 * Returns the raw playtester data for processing!  DEPRECATED AND WILL NOT
 * RETURN UP TO DATE INFORMATION!
 * @see query_bugs()
 * @see query_months()
 */
mixed query_pt_data( string name ) {
    if ( !undefinedp( playtesters[ name ] ) )
        return copy( playtesters[ name ] );
    return 0;
} /* query_pt_data() */

/**
 * This will return bug information for a given playtester.  The mapping
 * returned will map months to arrays of ints.  The format of these arrays is:
 * ({ bugs, online_that_month, age_at_end_of_month }).
 * @see query_months()
 */
mapping query_bugs( string name ) {
    return copy( bugs[ name ] );
} /* query_bugs() */

/**
 * This returns a sorted list of months, earliest month first.
 */
string* query_months() {
    return copy( months );
} /* query_months() */

/**
 * This marks a playtester as "on leave", logs it, with a reason.
 */
int set_leave( string name, string reason ) {
    if ( pts[ name ] ) {
        leave[ name ] = reason;
        log_file( "PLAYTESTERS", ctime( time() ) + ": " + name + " marked as "
                  "on leave: " + reason + "\n" );
        save_file();
        return 1;
    } else {
        return 0;
    }
} /* set_leave */

/**
 * This marks a playtester as no longer "on leave", and logs it.
 */
int reset_leave( string name ) {
    if ( leave[ name ] ) {
        map_delete( leave, name );
        log_file( "PLAYTESTERS", ctime( time() ) + ": " + name + " no longer "
                  "marked as on leave\n" );
        save_file();
        return 1;
    } else {
        return 0;
    }
} /* reset_leave */

/**
 * This tests whether a playtester is "on leave".
 */
int query_leave( string name ) {
    return stringp( leave[ name ] );
} /* query_leave */



/* What follows is a load of spam for converting from the old playtesters'
   handler save file to the new one.  You should never ever ever need to call
   this lot.  That's why there's a dodgy #ifdef around it.  Cool?  Cool.
   -- Arienne */

#ifdef PLAYTESTERS_HANDLER_OLD_STYLE_CONVERSION

/**
 * @ignore yes
 * This is a utility to transfer over the data from the old-type (buggy and
 * inefficient handler) to the new type.
 */
void transfer_data_callout( string* pts ) {
    string pt;
    mixed bing;
    int lastage;
    int nowage;
    
    if ( sizeof( pts ) ) {
        pt = pts[ 0 ];
        
        nowage = get_age_uncached_offline( pt );
        lastage = nowage - playtesters[ pt ][ "age" ];

        guilds[ pt ] = PLAYER_HANDLER->test_guild( pt );
        ages[ pt ] = nowage;
        bugs[ pt ] = ([ ]);
        
        foreach ( string s in keys( playtesters[ pt ] ) -
                  ({ "senior", "age", "current age", "guild" }) ) {

            bing = playtesters[ pt ][ s ];

            if ( arrayp( bing ) ) {
                bugs[ pt ][ s ] = ({ bing[ 0 ], bing[ 1 ], nowage });
            } else if ( intp( bing ) ) {
                bugs[ pt ][ s ] = ({ bing, lastage, nowage });
            }
        }

        tell_creator( "arienne", "Done " + pt + "!\n" );
        
        if ( sizeof( pts ) > 1 ) {
            call_out( "transfer_data_callout", 5, pts[ 1.. ] );
        } else {
            save_file();
            tell_creator( "arienne", "Done the transfer!\n" );
        }
    }
}

/**
 * @ignore yes
 * This is a utility to transfer over the data from the old-type (buggy and
 * inefficient handler) to the new type.
 */
void transfer_data_to_new_system() {
    foreach ( string pt in keys( playtesters ) ) {
        if ( playtesters[ pt ][ "senior" ] )
            pts[ pt ] = SENIOR_PLAYTESTER;
        else
            pts[ pt ] = NORMAL_PLAYTESTER;
    }
    call_out( "transfer_data_callout", 5, copy( keys( playtesters ) ) );
} /* transfer_data_to_new_system() */

#endif

/**
 * This method returns the current mapping of jump points.
 * @return the jump points
 */
mapping query_jump_points() {
   if (!_jump_points) {
      _jump_points = ([ ]);
   }
   return copy(_jump_points);
}

/**
 * This method adds a jump point to the list.
 * @param from the from location
 * @param to the to location
 */
void add_jump_point(string from, string to) {
   if (!_jump_points[from]) {
      _jump_points[from] = ({ });
   }
   _jump_points[from] += ({ to });
   save_file();
}

/**
 * This method removes a specific jump point from the list.
 * @param from the specific jump point to remove
 */
void remove_jump_point_from(string from) {
   map_delete(_jump_points, from);
   save_file();
}

/**
 * This method removes a specific jump point from the list.
 * @param from the from location to remove
 * @param to the to location to remove
 */
void remove_jump_point(string from, string to) {
   if (_jump_points[from]) {
      _jump_points[from] -= ({ to });
      if (!sizeof(_jump_points[from])) {
         map_delete(_jump_points, from);
      }
      save_file();
   }
}

/**
 * This method finds the destination from the start location.
 * @param from the location to find the jump point too
 */
string* query_jump_destination(string from) {
   return _jump_points[from];
}

/**
 * This method adds the player as a playtester executive.  The playtester
 * needs to already be added as a playtester before becoming a
 * playtester executive.
 * @param name the name of the player to add
 * @return 1 on success, 0 on failure
 * @see remove_pt_exec()
 * @see add_playtester()
 * @see query_pt_exec()
 */
int add_pt_exec( string name ) {
    if ( undefinedp (pts[ name ]))
        return 0;
    log_file( "PLAYTESTERS", ctime( time() ) + ": " + name +
              " promoted to playtester executive by %s\n",
              this_player()->query_name() );
    executives += ({ name });
    save_file();
    return 1;
} /* add_senior_playtester() */

/**
 * This method removes the player as a playtester executive.  
 * @param name the name of the player to add
 * @return 1 on success, 0 on failure
 * @see add_pt_exec()
 * @see add_playtester()
 * @see query_pt_exec()
 */
int remove_pt_exec( string name ) {
    if ( !undefinedp (pts[ name ]))
        return 0;
    if (member_array (name, executives) == -1) {
      return 0;
    }
    
    log_file( "PLAYTESTERS", ctime( time() ) + ": " + name +
              " removed from playtester executive by %s\n",
              this_player()->query_name() );
    executives -= ({ name });
    save_file();
    return 1;
} /* add_senior_playtester() */

int query_pt_exec(string name) {
  if (member_array (name, executives) == -1) {
    return 0;
  }
  return 1;
}

int query_exec_access (string name) {
  if (master()->query_senior(name)) {
    return 1;
  }
  if (query_pt_exec (name)) {
    return 1;
  }
  if (query_senior_playtester (name)) {
    return 1;
  }
  if (load_object ("/d/playtesters/master")->query_deputy (name)) {
    return 1;
  }  

  return 0;
}
// --- END [/mnt/home2/grok/lib/obj/handlers/playtesters.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/login_handler.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/login_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628322   Available: 13575676
Inodes: Total: 5242880    Free: 4960134
29370 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/login_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628322   Available: 13575676
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker: ceres $
 * $Id: login_handler.c,v 1.35 2003/03/30 19:23:34 ceres Exp ceres $
 */
/**
 * The login handler lets you have a funct called as a player logs in or out.
 * The funct you setup will be called when the player logs in or out.  The
 * object will also give you a list of all the people who are logged in. This is
 * a by product of its method of operation rather than anything important. 
 * It is quite possibly more useful to call users().
 * <p>
 * The funct which is to be called only needs to be called once as
 * the objects state is saved.  When a player enters, logsout or goes
 * net dead the funct will be called on the specified object.  The
 * funct will have two parameters, the first will be the player
 * name logging in/out and the last will be a define from /include/login.h
 * specifying which sort of event has occured.
 * <p>
 * A new temporary method of adding a call back to the login_handler has been
 * added.  This will allow you to add a call that is not saved,
 * so you can use an object reference instead of a file name.
 * @author Furball
 * @see /secure/login
 * @see efun::users()
 * @see /include/login.h
 */
#include <login.h>

// #define LOGIN_DEBUG 1 

#ifdef LOGIN_DEBUG
#undef MAX_COMPRESSED_PLAYERS
#undef MAX_UNCOMPRESSED_PLAYERS
#undef MAX_PLAYERS

#define LOGIN_MAX_COMPRESSED_PLAYERS 2
#define MAX_UNCOMPRESSED_PLAYERS 1
#define MAX_PLAYERS (MAX_COMPRESSED_PLAYERS + MAX_UNCOMPRESSED_PLAYERS)
#endif

#ifdef LOGIN_DEBUG
#define is_compressed_login(x) (strsrch((x)->query_name(), "test") > -1)
#else
#define is_compressed_login(x) (compressedp(x))
#endif

#define COMPRESSED_INTAKE_COUNT 5
#ifdef USE_RAMDISK
#define SAVE_TIME 300
#else
#define SAVE_TIME 900
#endif

#define NEW_SAVE_TIME 15
#define SAVE_NAME "/save/login_handler"

#define BUFFER_TIME 30

#define LOCKDOWN_TIME 900
#define MAX_FAILURES 3

class login_information {
    /*
     *When saved, this can only be a string.  If not it can be an object of
     * funct pointer.
     */
    mixed ob;
    /* This is not used with a funct pointer */
    string funct;
}

mapping _static_login_calls;

nosave mapping _dynamic_login_calls;
nosave string _best;
nosave string _worst;

nosave string *_players_on;

nosave mapping _compressed_players_on;
nosave mapping _telnet_players_on;

// nosave object *_login_queue;
nosave object *_compressed_login_queue;
nosave object *_telnet_login_queue;
nosave int _compressed_login_count;


nosave string enter_log;
nosave int last_entry;
nosave mapping messages;
nosave mapping lockdowns;

nosave int _creators;
nosave int _players;
nosave int _login_q;
nosave int _next_user_log;
nosave int _title_call;
nosave int _save_call;
nosave int _out_q;
nosave int _q_time;

nosave int _last_queue_time;
nosave int _last_queue_result;

int is_discworld_full(int test_login_queue);
void write_log(string event, string name, int guest, string other);
void save_users();
private void store_user_count();
private void log_user_count();
protected void check_all_titles( string player );
private void do_all_calls(string player, string event);
private void do_call(class login_information login_inf,
  string player, int event);
int is_uncompressed_full( int );

void create() {
    object pl;
    string name;
    
    _static_login_calls = ([ ]);
    _dynamic_login_calls = ([ ]);

    seteuid( "Root" );
    unguarded((: restore_object, SAVE_NAME :));

    foreach(name in keys(_static_login_calls)) {
      if(!sizeof(_static_login_calls[name])) {
        map_delete(_static_login_calls, name);
      }
      catch(unguarded((: save_object, SAVE_NAME :)));
    }

    _compressed_players_on = ([ ]);
    _telnet_players_on = ([ ]);
    _players_on = ({ });

    foreach(pl in users()) {
        if (is_compressed_login(pl)) {
            _compressed_players_on[ pl->query_name() ] = 1;
        }
        else {
            _telnet_players_on[ pl->query_name() ] = 1;
        }

        _players_on += ({ pl->query_name() }); 
    }

    _compressed_login_queue = ({ });
    _telnet_login_queue = ({ }); 
    _compressed_login_count = 1;

    _save_call = call_out( "save_users", NEW_SAVE_TIME );
    _next_user_log = time() + 3601 - (time() % 3600);
    enter_log = "";
    last_entry = time();
    call_out("clean_lockdowns", 3600);
    write_log("Periodic", "", 0, "");
} /* create() */

/** @ignore yes */
mapping query_static_login_calls() {
    return copy(_static_login_calls);
} /* query_static_login_calls() */
/** @ignore yes */
mapping query_dynamic_login_calls() {
    return copy(_dynamic_login_calls);
} /* query_dynamic_login_calls() */

/**
 * This returns the player name with the best alignment.
 * @return player name with the best alignment
 */
string query_best() { return _best; }
/**
 * This returns the player name with the worst alignment.
 * @return player name with the worst alignment
 */
string query_worst() { return _worst; }
/**
 * This method returns a list of the current players who are
 * online.
 * @return the string names of the online players
 */
string *query_players_on() { 
    return keys( _compressed_players_on ) + keys( _telnet_players_on );
}
/**
 * This method returns the current list of people in the login
 * queue.
 * @return the objects in the login queue
 */
object *query_login_queue() { 
    return _compressed_login_queue + _telnet_login_queue; 
} /* query_login_queue() */ 

/**
 * This method adds an object to the login queue.  This is called from
 * inside /secure/login.c
 * @see /secure/login.c
 * @param login_ob the object to add to the queue
 */
void add_to_login_queue(object login_ob) {
    if ( is_compressed_login( login_ob ) ) {
        _compressed_login_queue += ({ login_ob }); 
    }
    else {
        _telnet_login_queue += ({ login_ob });
    }
} /* add_to_login_queue() */

/**
 * This method removes an object from the login queue, if they log out
 * or something.
 * @param ob the object to remove from the queue
 */
void remove_from_login_queue(object ob) {
    _compressed_login_queue -= ({ ob });
    _telnet_login_queue -= ({ ob });
} /* remove_from_login_queue() */

int can_jump_queue( object ob ) {
    return ob->query_creator() || ob->query_net_dead() || 
        ob->query_property( "test character" );
} /* can_jump_queue() */ 
/**
 * This method returns the top element of the login queue and removes
 * them from it.
 * @return the top element of the login queue, 0 if none
 */
object pop_from_login_queue() {
    object ob;
    object *login_queue;

    login_queue = query_login_queue();
    
    if ( !sizeof( login_queue ) ) {
        return 0;
    }
    
    // This keeps track of how many players have recently left, adding
    // them to the total players count so that lots of players don't
    // arrive at the same time causing lag.

    if(time() != _q_time){
      _q_time = time();
      _out_q = 0;
    }

    _out_q++;

    // tell_creator( "taffyd", "Checking for queue jumpers...\n" );
    
    // Look for our queue jumpers in both the compressed login queues
    // and the telnet login queues.
    foreach( ob in _compressed_login_queue ) { 
        if ( can_jump_queue( ob ) ) {
            remove_from_login_queue( ob );
            return ob; 
        }        
    }
    // The is_discworld_full seems to over evaluate :(
    reset_eval_cost();
    if(sizeof(_telnet_login_queue) &&
       !is_uncompressed_full(WITHOUT_LOGIN_QUEUE)) {
      foreach( ob in _telnet_login_queue ) { 
        if ( can_jump_queue( ob ) ) {
          remove_from_login_queue( ob );
          return ob; 
        }        
      }
    }
    
    // If we've taken less than COMPRESSED_INTAKE_COUNT of 
    // compressed logins, then take one from the compressed queue.

    if ( sizeof( _compressed_login_queue) &&
         _compressed_login_count < COMPRESSED_INTAKE_COUNT ) {
        _compressed_login_count++;
        ob = _compressed_login_queue[ 0 ]; 
        _compressed_login_queue = _compressed_login_queue[ 1.. ];
    } else {
        _compressed_login_count = 0;
        ob = _telnet_login_queue[ 0 ]; 
        _telnet_login_queue = _telnet_login_queue[ 1.. ]; 
    }
    
    // tell_creator( "taffyd", "Removed %O from the queue.\n", ob );

    return ob;
} /* pop_from_login_queue() */


/**
 * This method adds a funct to be called whenever a player logs
 * in.  The funct and object both need to be strings so that
 * they are saved correctly.  This will be saved to the save file
 * and restored over logins.
 * <p>
 * The function will be called with two parameters, the first is the
 * name of the player and the second is the type of the event.  The
 * event types are defined in /include/login.h  The event will be one
 * of RECONNECT, LOGIN, LOGOUT, NETDEATH.
 * @param player specfic player to look for "all" for everyone
 * @param func the funct to call
 * @param obj the object to call the funct on
 * @return 0 on failure and 1 on success
 * @see remove_static_login_call()
 * @see add_dynamic_login_call()
 */
int add_static_login_call(string player, mixed funct, mixed obj) {
  class login_information login_inf;

  if (!stringp(funct) || !stringp(obj) || !stringp(player)) {
    return 0;
  }

  // Don't allow calls to creators own files. They invariably get left
  // behind well after their usefulness is over and cause runtime errors.
  if(obj[0..3] == "/w/")
    return 0;
  
  // Check for dups, we get too many of those.
  if(_static_login_calls[player]) {
    foreach (login_inf in _static_login_calls[player]) {
      if (login_inf->ob == obj &&
    login_inf->funct == funct) {
  return 1;
      }
    }
  }
  
  if (!_static_login_calls[player]) {
    _static_login_calls[player] = ({ });
  }

  login_inf = new (class login_information, funct : funct, ob : obj);
  _static_login_calls[player] += ({ login_inf });
  
  catch(unguarded((: save_object, SAVE_NAME :)));
  return 1;
} /* add_static_login_call() */

/**
 * This method removes a login call.
 * @param player the player specifier
 * @param funct the funct name
 * @param obj the object to call the funct on
 * @return 0 on failure and 1 on success
 * @see add_static_login_call()
 * @see add_dynamic_login_call()
 */
int remove_static_login_call(string player, mixed funct, mixed obj) {
  class login_information login_inf;
  
  if (!stringp(funct) || !stringp(obj) || !stringp(player)) {
    return 0;
  }
  
  if (_static_login_calls[player]) {
    foreach (login_inf in _static_login_calls[player]) {
      if (login_inf->ob == obj &&
          login_inf->funct == funct) {
        _static_login_calls[player] -= ({ login_inf });
        // Clean it out if they don't have any left.
        if(!sizeof(_static_login_calls[player]))
          map_delete(_static_login_calls, player);
        catch(unguarded((: save_object, SAVE_NAME :)));
        return 1;
      }
    }
  }
  
  return 0;
} /* remove_static_login_call() */

/**
 * This method adds a funct to be called whenever a player logs
 * in.  The funct and object are stored only for this reboot
 * so they may be object references or funct pointers.
 * @param player specfic player to look for "all" for everyone
 * @param func the funct to call
 * @param obj the object to call the funct on
 * @return 0 on failure and 1 on success
 * @see remove_dynamic_login_call()
 * @see add_static_login_call()
 */
int add_dynamic_login_call(string player, mixed funct, mixed obj) {
    class login_information login_inf;

    if (stringp(obj) || objectp(obj)) {
        if (!stringp(funct)) {
            return 0;
        }
    } else if (!functionp(funct)) {
        return 0;
    }

    if (!_dynamic_login_calls[player]) {
        _dynamic_login_calls[player] = ({ });
    }
    login_inf = new (class login_information, funct : funct, ob : obj);
    _dynamic_login_calls[player] += ({ login_inf });

    return 1;
} /* add_dynamic_login_call() */

/**
 * This method removes a login call.
 * @param player the player specifier
 * @param funct the funct name
 * @param obj the object to call the funct on
 * @return 0 on failure and 1 on success
 * @see add_dynamic_login_call()
 * @see add_static_login_call()
 */
int remove_dynamic_login_call(string player, mixed funct, mixed obj) {
    class login_information login_inf;

    if (stringp(obj) || objectp(obj)) {
        if (!stringp(funct)) {
            return 0;
        }
    } else if (!functionp(funct)) {
        return 0;
    }

    if (_dynamic_login_calls[player]) {
        foreach (login_inf in _dynamic_login_calls[player]) {

            if (login_inf->ob == obj &&
              login_inf->funct == funct) {
                _dynamic_login_calls[player] -= ({ login_inf });
                return 1;
            }
        }
    }

    return 0;
} /* remove_dynamic_login_call() */

void update_players_on( string player ) {
    object ob = find_player( player );

    // tell_creator( "taffyd", "update_players_on(): %O, %O\n", player, ob );

    if ( !ob ) {
        return;
    }

    if ( is_compressed_login( ob ) ) {
        if ( undefinedp( _compressed_players_on[ player ] ) ) {
            _compressed_players_on[ player ] = 1;
        }
    }
    else {
        if ( undefinedp( _telnet_players_on[ player ] ) ) {
            _telnet_players_on[ player ] = 1;
        }
    }

    if ( member_array( player, _players_on ) == -1 ) {
        _players_on += ({ player });
    }
}

int tidy_players_on( string player ) {
    int pos; 
    int ret;

    ret = 0; 

    if ( _compressed_players_on[ player ] ) {
        map_delete( _compressed_players_on, player );
        ret = 1;
    }

    if ( _telnet_players_on[ player ] ) {
        map_delete( _telnet_players_on, player );
        ret = 1;
    }

    pos = member_array( player, _players_on );

    if ( pos != -1 ) { 
        //tell_creator( "taffyd", "Deleting %s from the players list.\n",
        //    _players_on[ pos ] );
        _players_on = _players_on[0..pos-1] + _players_on[pos+1..];
        ret = 1;
    }
    
    return ret;
} /* tidy_players_on() */ 



/** @ignore yes */
int player_logon(string player, int guest, string ip) {
    // tell_creator( "taffyd", "player_login(): %O, %O, %O\n", player, guest, ip );

    if(lower_case(player) != (string)previous_object()->query_name()) {
        return 0;
    }

    /* Update the players_on array. */
    
    update_players_on( player );

    /* Figure out if there are any functions to call. */
    do_all_calls(player, LOGIN);

    if (find_call_out(_title_call) == -1) {
        _title_call = call_out("check_all_titles", 5, player );
    }


    write_log("Enter", player, guest, ip);
} /* player_login() */

private void do_all_calls(string player, string event_t) {
  class login_information login_inf;
  
  if (_static_login_calls[player]) {
    foreach (login_inf in _static_login_calls[player]) {
      call_out((: do_call :), 1, login_inf,
               player, event_t );
    }
  }
  if (_static_login_calls["all"]) {
    foreach (login_inf in _static_login_calls["all"]) {
      call_out((: do_call :), 1, login_inf,
               player, event_t );
    }
  }
  if (_dynamic_login_calls[player]) {
    foreach (login_inf in _dynamic_login_calls[player]) {
      call_out((: do_call :), 1, login_inf,
               player, event_t );
    }
  }
  if (_dynamic_login_calls["all"]) {
    foreach (login_inf in _dynamic_login_calls["all"]) {
      call_out((: do_call :), 1, login_inf,
               player, event_t );
    }
  }
} /* do_all_calls() */

/** @ignore yes */
private void do_call(class login_information login_inf,
                     string player, int event_t) {
  object ob;
     
  if (!find_player(player) || find_player(player)->query_invis() < 2) {
    if (!functionp(login_inf->funct)) {
      if(login_inf->ob && login_inf->funct) 
        catch(ob = load_object(login_inf->ob));
      if ( ob ) { 
        catch(call_other(ob, login_inf->funct, player, 
                         event_t));
      } else {
        tell_creator("ceres", "failed to load %s", login_inf->ob);
      }
    } else {
      catch(evaluate(login_inf->funct, player, event_t));
    }
  }
} /* do_call() */

/** @ignore yes */
int player_logout(string player) {
    object ob;

    do_all_calls(player, LOGOUT);

    if ( tidy_players_on( player ) ) {
        if (find_call_out(_title_call) == -1) {
            _title_call = call_out("check_all_titles", 5, player );
        }
    }

    if(find_call_out(_save_call) == -1) {
        _save_call = call_out("save_users", NEW_SAVE_TIME );
    }

    /* always do this bit... */
    
    // tell_creator( "taffyd", "Queue checking...\n" );
    // tell_creator( "taffyd", "is_discworld_full(WITHOUT_LOGIN_QUEUE) = %d",
    //    is_discworld_full(WITHOUT_LOGIN_QUEUE) );

    while (sizeof(query_login_queue()) && 
        !is_discworld_full(WITHOUT_LOGIN_QUEUE) ) {

        // tell_creator( "taffyd", "Doing login queue checks...\n" );

        ob = pop_from_login_queue();

        if (ob) {
            // tell_creator( "Removing %O from the login queue\n" );
            ob->remove_from_login_queue();
        }
    }

    write_log("Exit", player, 0, "");
    return 1;
} /* player_logout() */

/** @ignore yes */
int player_net_dead(string player) {
    object ob;
    
    if ( tidy_players_on( player ) ) {
        do_all_calls(player, NETDEATH);

        if (find_call_out(_title_call) == -1) {
            _title_call = call_out("check_all_titles", 5, player );
        }
    }

    /* always do this bit... */
    while ( sizeof(query_login_queue()) && !is_discworld_full(WITHOUT_ANY_LOGINS) ) {
        // tell_creator( "taffyd", "is full netdead check\n" );

        ob = pop_from_login_queue();
        if (ob) {
            ob->remove_from_login_queue();
        }
    }

    write_log("NDead", player, 0, "");
    return 1;
} /* player_net_dead() */

/** @ignore yes */
int player_reconnected(string player) {
    update_players_on(player);
    do_all_calls(player, RECONNECT); 

    if (find_call_out(_title_call) == -1) {
        _title_call = call_out("check_all_titles", 5, player);
    }

    write_log("Recon", player, 0, query_ip_name(find_player(player)));
} /* player_reconnected() */

/** @ignore yes */
protected void check_all_titles( string player ) {
    int al, good, bad;
    object good_thing, bad_thing, thing, *things;

    good = -250;
    bad = 250;
    things = users();
    foreach( thing in things ) {
      if (!thing || thing->query_creator() ) {
        continue;
      }
      al = (int)thing->query_al();
      if ( al > bad ) {
        bad = al;
        bad_thing = thing;
      }
      if ( al < good ) {
        good = al;
        good_thing = thing;
      }
    }
    if ( bad_thing ) {
      if ( stringp( _worst ) && ( _worst != player ) ) {
        thing = find_player( _worst );
      } else {
        thing = 0;
      }
      if ( bad_thing != thing ) {
        if ( thing ) {
          thing->remove_title( "align" );
        }
        switch ( (int)bad_thing->query_gender() ) {
        case 1 :
          bad_thing->set_title( "align", "Lord of Darkness" );
          break;
        case 2 :
          bad_thing->set_title( "align", "Lady of Darkness" );
          break;
        default :
          bad_thing->set_title( "align", "Monster of Darkness" );
        }
        _worst = (string)bad_thing->query_name();
      }
    }
    if ( good_thing ) {
      if ( stringp( _best ) && ( _best != player ) ) {
        thing = find_player( _best );
      } else {
        thing = 0;
      }
      if ( good_thing != thing ) {
        if ( thing ) {
          thing->remove_title( "align" );
        }
        switch ( (int)good_thing->query_gender() ) {
        case 1 :
          good_thing->set_title( "align", "Lord of Light" );
          break;
        case 2 :
          good_thing->set_title( "align", "Lady of Light" );
          break;
        default :
          good_thing->set_title( "align", "Creature of Light" );
        }
        _best = (string)good_thing->query_name();
      }
    }
} /* check_all_titles() */

/** @ignore yes */
void save_users() {
    int number;
    int next_time; 
    string word;
    object thing;

    number = sizeof( _players_on );
    
    if ( !number ) {
//        log_file( "LOGIN_HANDLER", "No players on, resetting...\n" ); 
        _players_on = query_players_on();
        _save_call = call_out("save_users", NEW_SAVE_TIME );
        return;
    }
    
    store_user_count();

    // log the number of players and creators.
    if(_next_user_log < time()) {
        log_user_count();
    }
    
    word = _players_on[ 0 ];

    thing = find_player( word );

    if ( objectp( thing ) && ( number > 1 ) ) {
        if ( environment( thing ) ) {
//        log_file( "LOGIN_HANDLER", "%s: Saving player %s\n", 
//                ctime( time() ), thing->query_name() );
            thing->save_me();
        }
//        log_file( "LOGIN_HANDLER", "%s: Shuffling %s to the back of the queue, "
//            "next player is %s (TP: %O, number: %d, ob: %O)\n", ctime( time() ), 
//                word, _players_on[1],  this_player(), number, thing ); 
        _players_on = _players_on[1..] + ({ word });
        // _players_on[ 0 .. number - 2 ] = _players_on[ 1 .. ];
        //_players_on[ number - 1 ] = word;
    } else {
//        log_file( "LOGIN_HANDLER", "%s: Not saving %s, player doesn't "
//            "exist. (TP: %O, number: %d, ob: %O)\n", ctime( time() ), word, 
//                this_player(), number, find_player( word ) ); 
        _players_on = _players_on[1..] + ({ word });
    } 
    
    /* To try and resolve the weird auto-saving problems... */ 
    next_time = SAVE_TIME / number;
    
    if ( next_time > 10 ) {
        next_time = 10; 
    }

    _save_call = call_out( (: save_users :), next_time );
} /* save_users() */

int int_is_discworld_full(int logins) { 
    object *players;
    int compressed;
    int uncompressed;
    int ret;
    int ext;

    players = users();
    
    switch (logins) {
    case WITHOUT_LOGINS_NOT_IN_QUEUE :
        players = filter(players, (: objectp($1) && !$1->query_login_ob() &&
            !$1->query_creator() :)) + query_login_queue();
        break;
    case WITHOUT_LOGIN_QUEUE :
        players -= query_login_queue();
        players = filter(players, (: objectp($1) && !$1->query_creator() :));
        break;
    case WITHOUT_ANY_LOGINS :
        players = filter(players, (: objectp($1) && !$1->query_login_ob() &&
            !$1->query_creator() :));
        ext = _out_q;
        break;
    default :
        players = filter(players, (: objectp($1) && !$1->query_creator() :));
        break;
    }

    if(time() != _q_time){
      ext = 0;
      _out_q = 0;
      _q_time = time();
    }
    
    // Now, determine how many of those players are compressed, 
    // and how many are uncompressed.
    compressed = sizeof( filter( players, (: is_compressed_login($1) :) )  ) + ext;
    uncompressed = sizeof( players ) - compressed;

    ret = DISCWORLD_IS_EMPTY;
    
    // If we're compressed, then we set the COMPRESSED_FULL
    // flag.
    if ( compressed >= MAX_COMPRESSED_PLAYERS ) { 
        ret |= COMPRESSED_FULL;  
    }
    
    // Same for uncompressed.
    if ( uncompressed >= MAX_UNCOMPRESSED_PLAYERS ) { 
        ret |= UNCOMPRESSED_FULL;
    }

    // tell_creator( "taffyd", "%d, %d, %d\n", compressed, uncompressed, ret );
    // tell_creator( "taffyd", "int_is_discworld_full: %d, %O\n", ret, call_stack( 2 ));
    return ret;
} /* int_is_discworld_full() */ 

int is_compressed_full( int logins ) {
    return int_is_discworld_full( logins ) & COMPRESSED_FULL; 
} /* is_compressed_full() */ 

int is_uncompressed_full( int logins ) {
    return int_is_discworld_full( logins ) & UNCOMPRESSED_FULL; 
} /* is_compressed_full() */ 

/**
 * Try and figure out if the mud is full or not.  Counts the number
 * of players and returns a true or false value.
 * @see /include/login.h#WITHOUT_LOGINS_NOT_IN_QUEUE
 * @see /include/login.h#WITHOUT_LOGIN_QUEUE
 * @see /include/login.h#WITHOUT_ANY_LOGINS
 * @param logins a flag
 * @return 1 if the mud is full, 0 if it is not
 */
int is_discworld_full(int logins) {
    int ret;
    
    ret = int_is_discworld_full( logins );

    ret = (ret & COMPRESSED_FULL) && (ret & UNCOMPRESSED_FULL);

    // tell_creator( "taffyd", "is_discworld_full: %d, %O\n", ret, call_stack( 2 ));

    return ret;
} /* is_discworld_full() */

private void store_user_count() {
    object pl;
    int current_players, current_creators, current_login_q;
    string *logins_n;

    foreach(pl in users()) {
      if (pl && !pl->query_login_ob()) {
        if (pl->query_creator()) {
          current_creators++;
        } else {
          current_players++;
        }
      }
    }

    logins_n = map(LOGIN_HANDLER->query_login_queue(),
      (: $1->query_cap_name() :));
    logins_n = sort_array(logins_n, 1);
    current_login_q = sizeof(logins_n);

    if(current_players + current_login_q > _players + _login_q) {
        _players = current_players;
        _creators = current_creators;
        _login_q = current_login_q;
    }
} /* store_user_count() */

private void log_user_count() {
    log_file("USERS", "%s %d %d %d\n" ,ctime(time()), _creators, _players,
      _login_q);

    _creators = 0;
    _players = 0;
    _login_q = 0;
    _next_user_log = time() + 3601 - (time() % 3600);
} /* log_user_count() */

/**
 * This method is used to do delayed logging to the log files.  It will
 * store a bunch of entries until it is over a maximum size and then
 * save this to the log.
 * @param event the event generated
 * @param name the name of the player the event is for
 * @param guest if the person in question is a guest
 * @param other other information about the event
 */
void write_log(string event, string name, int guest, string other) {
    switch(event) {
    case "Enter":
        enter_log += sprintf( "%s [Enter] %-15s %s%s\n",
          ctime(time())[4..18], name,
          guest?"(guest) ":"",
          other);
        break;
    case "Su":
        enter_log += sprintf( "%s [Su]    %15-s %15-s\n",
          ctime(time())[4..18], name, other);
        break;
    case "Periodic":
        call_out("write_log", BUFFER_TIME, "Periodic", "", 0, "");
        if (sizeof(enter_log) && time() - last_entry > BUFFER_TIME) {
            unguarded((: write_file, "/d/admin/log/ENTER.log", enter_log :));
            enter_log = "";
            last_entry = time();
        }
        return;
    case "Recon":
        enter_log += sprintf( "%s [Recon] %15-s %s\n",
          ctime(time())[4..18], name, other);
        break;
    default:
        enter_log += sprintf("%s %-7s %15-s\n", ctime(time())[4..18],
          "["+event+"]", name);
        break;
    }

    last_entry = time();
    if(sizeof(enter_log) > 1024) {
        unguarded((: write_file, "/d/admin/log/ENTER.log", enter_log :));
        enter_log = "";
    }
} /* write_log() */

/** @ignore yes */
void dest_me() {
    unguarded((: write_file, "/d/admin/log/ENTER.log", enter_log :));
    enter_log = "";
    destruct(this_object());
} /* dest_me() */

/**
 * This function is used to cache the login messages used by /secure/login
 * it costs a bit in memory but saves us having to re-read the same text
 * file everytime someone logs in.
 * For security reasons this function will only work with files in /doc
 *
 * @param the filename of the file to be returned
 * @return the text of the file.
 */
string get_message(string mess_name) {
    if(!messages)
        messages = ([ ]);

    // Prevent it working on anything except in /doc to avoid any security risks.
    if(mess_name[0..4] != "/doc/")
        return 0;

    if(!messages[mess_name])
        messages[mess_name] = read_file(mess_name);

    return messages[mess_name];
}

void clear_messages() {
    messages = ([ ]);
}

int site_lockeddown(string ip_addr) {
    if(!lockdowns)
        lockdowns = ([ ]);

    if(lockdowns[ip_addr] &&
      (sizeof(lockdowns[ip_addr]) >= MAX_FAILURES) &&
      (lockdowns[ip_addr][0] > time() - LOCKDOWN_TIME))
        return 1;
    return 0;
}

void failed_login(string ip_addr) {
  int i;
  
  if(!lockdowns)
    lockdowns = ([ ]);
  if(!lockdowns[ip_addr])
    lockdowns[ip_addr] = ({ time() });
  else {
    // Trim the last failures
    for(i=0; i<sizeof(lockdowns[ip_addr]); i++)
      if(lockdowns[ip_addr][i] < time() - LOCKDOWN_TIME) {
        lockdowns[ip_addr] -= ({ lockdowns[ip_addr][i] });
        i--;
      }
      
    lockdowns[ip_addr] += ({ time() });
    if(sizeof(lockdowns[ip_addr]) > MAX_FAILURES) {
      lockdowns[ip_addr] =
        lockdowns[ip_addr][sizeof(lockdowns[ip_addr])-MAX_FAILURES..];
    }
  }
}

/*
 * periodically clean out the lockdowns mapping otherwise it can get
 * full of unnecessary entries.
 */
void clean_lockdowns() {
  string ip;
  
  call_out("clean_lockdowns", 1800);
  foreach(ip in keys(lockdowns)) {
    if(lockdowns[ip][sizeof(lockdowns[ip])-1] < time() - LOCKDOWN_TIME) {
      map_delete(lockdowns, ip);
    }
  }
}

void clear_lockdowns(string ip) {
  if(!ip)
    lockdowns = ([ ]);
  else if(lockdowns[ip])
    map_delete(lockdowns, ip);
}

void query_lockdowns() {
    printf("%O\n", lockdowns);
}

void reset() {
    if (find_call_out(_save_call) == -1) { 
        save_users(); 
    }
} /* reset() */

// --- END [/mnt/home2/grok/lib/obj/handlers/login_handler.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/nroff.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/nroff.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628314   Available: 13575668
Inodes: Total: 5242880    Free: 4960134
19232 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/nroff.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628314   Available: 13575668
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: nroff.c,v 1.9 2003/01/29 17:23:50 wyvyrn Exp $
 * $Log: nroff.c,v $
 * Revision 1.9  2003/01/29 17:23:50  wyvyrn
 * Fixed up justification on document title (.DT) for mud and web viewing
 *
 * Revision 1.7  2001/06/13 22:58:51  pinkfish
 * Fix up the columns stuff for the nroffing of files
 *
 * Revision 1.6  2001/02/05 20:20:02  pinkfish
 * Fix up columns.
 *
 * Revision 1.5  1999/10/28 02:22:21  ceres
 * can't remember
 *
 * Revision 1.4  1998/03/26 10:23:32  pinkfish
 * Make it handle html files neater.
 *
 * Revision 1.3  1998/03/26 10:11:54  pinkfish
 * Change the nroff system to not break when there is no
 * this_)player and doing a cat_file
 *
 * Revision 1.2  1998/03/06 10:22:50  pinkfish
 * Make the header stuff look better in html files.
 *
 * Revision 1.1  1998/01/06 05:03:33  ceres
 * Initial revision
 * 
*/
/**
 * An nroff like object for formating text files.
 *<p>
 * This creates a saveable file format thingy.
 *
 * @author Pinkfish
 */
#include <nroff.h>

mixed *nroffed_file;
string nroffed_file_name;
int modified_time;
nosave int new_string;
nosave int force_string;

void create() {
  nroffed_file = ({ });
  seteuid("Root"); /* Security risk?  nahhhhh */
} /* create() */

#define do_bounds(bing) (bing<0?bing+cols:bing)

/**
 * Creates a string from a nroffed file.
 * <p>
 * If update is non zero it will look to see if the source file has been 
 * modified since the saved nroff file was created.  If it has, this
 * function returns 0 and the nroff file needs to be recreated.
 *
 * @param fname the file to process
 * @param update force update if file is newer?
 * @return the string representation of the nroff file
 */
string cat_file(string fname, int update) {
   int i;
   int k;
   int cols;
   string ret;
   string pat;
   mixed* tmp;
   
   if (!master()->valid_read(fname, geteuid(previous_object()),
                             "restore_object")) {
      return 0;
   }
   nroffed_file_name = 0;
   modified_time = 0;
   if (!restore_object(fname))
      return 0;
   if (!nroffed_file_name && update)
      return 0;
   if (update) {
      mixed *something;
      
      if (!master()->valid_read(nroffed_file_name,
                                geteuid(previous_object()),
                                "restore_object"))
         return 0;
      if (file_size(nroffed_file_name) <= 0)
         return 0;
      something = stat(nroffed_file_name);
      if (something[1] > modified_time)
         return 0;
   }
   ret = "";
   if (this_player()) {
      cols = (int)this_player()->query_cols();
   } else {
      cols = 79;
   }
   for (i=0;i<sizeof(nroffed_file);i++) {
      if (stringp(nroffed_file[i])) {
         ret += nroffed_file[i];
      } else {     
         switch (nroffed_file[i]) {
          case V_HEADER :
            ret += sprintf("%%^BOLD%%^%s%%^RESET%%^\n", nroffed_file[i+1]);
            i++;
            break;
          case V_CENTER :
            ret += sprintf("%|=*s", cols, nroffed_file[i+1]);
            i++;
            break;
          case V_ALL :
            ret += "%^BOLD%^\n" + sprintf("%-s%*|s%*s\n",
                           nroffed_file[i+2],
                           cols - nroffed_file[i+1]*2,
                           nroffed_file[i+3],
                           nroffed_file[i+1],
                           nroffed_file[i+4]) + "%^RESET%^\n";
//if (this_player() == find_player("presto"))  write("middle == :" + nroffed_file[i + 3] + ":\n" + nroffed_file[i + 1] + "\n");
//if (this_player() == find_player("wyvyrn"))  write( "file: '" + nroffed_file[i+1] + "', left: '" + nroffed_file[i+2] + "', centre: '" + nroffed_file[i+3] + "', right: '" + nroffed_file[i+4] + "'\n");
            i += 4;
            break;
          case V_INDENT :
            ret += sprintf( "%*=s%-=*s", nroffed_file[ i + 1 ], "",
                           cols - nroffed_file[ i + 1 ], nroffed_file[ i + 2 ] );
            i += 2;
            break;
          case V_PARA :
            if (nroffed_file[i+1])
            ret += sprintf("%*=s%-=*s%=*s\n", nroffed_file[i+1], "",
                           cols-nroffed_file[i+1]-
                           nroffed_file[i+2], nroffed_file[i+3],
                           nroffed_file[i+2], "");
            else if (nroffed_file[i+2])
            ret += sprintf("%-=*s%=*s\n", cols-nroffed_file[i+2],
                           nroffed_file[i+3],
                           nroffed_file[i+2], "");
            else
            ret += sprintf("%-=*s\n", cols, nroffed_file[i+3]);
            i += 3;
            break;
          case V_LEFT :
            ret += sprintf("%-=*s", cols, nroffed_file[i+1]);
            i++;
            break;
          case V_TABLE :
            ret += sprintf("%-#*s", cols, nroffed_file[i+1]);
            i++;
            break;
          case V_COLUMN : {
             int j;
             
             switch (sizeof(nroffed_file[i+1])) {
              case 2 :
                for (j=0;j<sizeof(nroffed_file[i+2]);j++) {
                   ret += sprintf("%*-=s%*-=s\n", do_bounds(nroffed_file[i+1][0]),
                                  nroffed_file[i+2][j],
                                  do_bounds(nroffed_file[i+1][1]),
                                  nroffed_file[i+3][j]);
                }
                i += 3;
                break;
              case 3 :
                for (j=0;j<sizeof(nroffed_file[i+2]);j++) {
                   ret += sprintf("%*-=s%*-=s%*-=s\n",
                               do_bounds(nroffed_file[i+1][0]),
                               nroffed_file[i+2][j],
                               do_bounds(nroffed_file[i+1][1]),
                               nroffed_file[i+3][j],
                               do_bounds(nroffed_file[i+1][2]),
                               nroffed_file[i+4][j]);
                }
                i += 4;
                break;
             default :
                pat = implode(allocate(sizeof(nroffed_file[i+1]), "%*-=s"), "");
                for (j=0;j<sizeof(nroffed_file[i+2]);j++) {
                   tmp = ({ });
                   for (k = 0; k < sizeof(nroffed_file[i+1]); k++) {
                      tmp += ({ do_bounds(nroffed_file[i+1][k]),
                                nroffed_file[i+2+k][j] });
                   }
                   ret += sprintf(pat + "\n", tmp ... );
                }
                i += sizeof(nroffed_file[i+1]) + 1;
                break;
             }
             break;
          }
         }
      }
   }
   return " \n"+ret;
} /* cat_file() */

/**
 * @ignore yes
 */
private string htmlify(string  str) {
  return replace(str, ({ "&", "&amp;", "<", "&lt;", ">", "&gt;"}));
} /* htmlify() */

/**
 * Turns the nroff file into a html output.  This works on nroff files
 * creating a html output from the mud source.
 *
 * @param file the name to process
 * @param title the title to give the document
 * @return the html file
 */
string html_file(string file, string title) {
   int i, j, cols, in_bold, in_italic;
   int k;
   string ret, *bits;
   
   if (!master()->valid_read(file, geteuid(previous_object()),
                             "restore_object"))
      return 0;
   nroffed_file_name = 0;
   modified_time = 0;
   if (!restore_object(file))
      return 0;
   ret = "";
   cols = 78;

   for (i=0;i<sizeof(nroffed_file);i++)
     if (stringp(nroffed_file[i]))
       nroffed_file[i] = htmlify(nroffed_file[i]);
     else if(arrayp(nroffed_file[i])) {
       for (j=0;j<sizeof(nroffed_file[i]);j++)
         if(stringp(nroffed_file[i][j]))
           nroffed_file[i][j] = htmlify(nroffed_file[i][j]);
     }           

   
   for (i=0;i<sizeof(nroffed_file);i++) {
      if (stringp(nroffed_file[i])) {
         ret += "<h3>"+nroffed_file[i]+"</h3>";

#ifdef UNUSED         
         if(strsrch(nroffed_file[i], "See also") > -1) {
           for(j=i+1; j < sizeof(nroffed_file); j++) {
             if(stringp(nroffed_file[j])) {
               nroffed_file[j] = make_links(nroffed_file[j]);
             }
           }
         }
#endif         
      } else {
         switch (nroffed_file[i]) {
          case V_HEADER :
            ret += "<h3>"+replace_string(nroffed_file[i+1], "\n", "<br>")+
              "</h3>";
            i++;
            break;
          case V_CENTER :
            ret += "<center>"+replace(nroffed_file[i+1], "\n", "<br>")+
            "</center>";
            i++;
            break;
          case V_ALL :
            ret += "\n<table width=100%><tr>\n" + 
                   "<td nowrap width=* align=left><h2>" + 
                   nroffed_file[i+2] + "</h2></td>\n" + 
                   "<td nowrap align=center><h2>" + 
                   nroffed_file[i+3] + "</h2></td>\n" + 
                   "<td nowrap width=* align=right><h2>" + 
                   nroffed_file[i+4] + "</h2></td>\n" + 
                   "</tr></table>\n";
            i += 4;
            break;
          case V_INDENT :
            ret += replace(nroffed_file[i+2], ({"<", "&lt;", ">",
               "&gt;", "\n", "<br>"}));
            i += 2;
            break;
          case V_PARA :
            ret += replace(nroffed_file[i+3], "\n", "<p>");
            i += 3;
            break;
          case V_LEFT :
            ret += "<left>"+nroffed_file[i+1]+"</left>";
            i++;
            break;
          case V_TABLE :
            ret += "<ul><li>"+replace(nroffed_file[i+1], "\n", "<li>")+"</ul>";
            i++;
            break;
          case V_COLUMN : {
             ret += "<table cellpadding=10>";
             switch (sizeof(nroffed_file[i+1])) {
              case 2 :
                for (j=0;j<sizeof(nroffed_file[i+2]);j++) {
                  ret += "<tr>\n";
                  ret += "<td nowrap>"+nroffed_file[i+2][j] + "</td>";
                  ret += "<td>"+nroffed_file[i+3][j] + "</td>";
                  ret += "</tr>";
                }
                i += 3;
                break;
              case 3 :
                for (j=0;j<sizeof(nroffed_file[i+2]);j++) {
                  ret += "<tr>\n";
                  ret += "<td nowrap>"+nroffed_file[i+2][j] + "</td>";
                  ret += "<td nowrap>"+nroffed_file[i+3][j] + "</td>";
                  ret += "<td>"+nroffed_file[i+4][j] + "</td>";
                  ret += "</tr>";
                }
                i += 4;
                break;
             default :
                for (j=0;j<sizeof(nroffed_file[i+2]);j++) {
                   ret += "<tr>\n";
                   for (k = 0; k < sizeof(nroffed_file[i+1]); k++) {
                      ret += "<td nowrap>" + nroffed_file[i+2+k][j] + "</td>\n";
                   }
                   ret += "</tr>\n";
                }
                i += sizeof(nroffed_file[i+1]) + 1;
                break;
             }
             ret += "</table>";
             break;
          }
         }
      }
   }
   
   bits = explode(ret, "%^");
   ret = "";
   for (i=0;i<sizeof(bits);i+=2) {
      ret += bits[i];
    if (i+1 < sizeof(bits)) {
       switch (bits[i+1]) {
        case "BOLD" :
          if (!in_bold)
             ret += "<strong>";
          else
             ret += "</strong>";
          in_bold = !in_bold;
          break;
        case "RESET" :
          if (in_bold)
             ret += "</strong>";
          if (in_italic)
             ret += "</i>";
          in_bold = 0;
          in_italic = 0;
          break;
        default :
          if (!in_italic)
             ret += "<i>";
          else
             ret += "</i>";
          in_italic = !in_italic;
          break;
       }
    }
   }
   return ret;
} /* html_file() */

private void add_array(mixed *i) {
  if (!sizeof(nroffed_file)) {
    nroffed_file += ({ i });
  } else if (force_string) {
    nroffed_file += ({ "", i });
  } else {
    nroffed_file += ({ i });
  }
  force_string = 0;
  new_string = 0;
} /* add_array() */

private void add_int(int i) {
  if (!sizeof(nroffed_file)) {
    nroffed_file += ({ i });
  } else if (force_string) {
    nroffed_file += ({ "", i });
  } else {
    nroffed_file += ({ i });
  }
  force_string = 0;
  new_string = 0;
} /* add_int() */

private void add_string(string s) {
  if (!sizeof(nroffed_file) || new_string) {
    nroffed_file += ({ s });
  } else if (stringp(nroffed_file[<1])) {
    nroffed_file[<1] += s;
  } else {
    nroffed_file += ({ s });
  }
  new_string = 0;
  force_string = 0;
} /* add_string() */

/**
 * Makes the nroff saveable file.  Turns the input nroff file into a saved
 * output format.
 *
 * @param in_file the file name been processed
 * @param out_file the file to save it as
 * @return 1 if the operation was successful
 */
int create_nroff(string in_file, string out_file) {
  string text,
         tmp,
         *bits;
  string *bing;
  mixed  *cols;
  int strip_crs,
      col_mode,
      conv_tabs,
      i, j, k, fluff,
      num_cols;

  if (!master()->valid_read(in_file, geteuid(previous_object()),
                            "read_file"))
    return 0;
  nroffed_file_name = in_file;
  modified_time = time();
  text = read_file(in_file);
  if (!text) {
    return 0;
  }
  bits = explode("#\n"+text, "\n.");
  bits[0] = bits[0][1..];
  nroffed_file = ({ 0 });
  if (strlen(bits[0])) {
    add_string(bits[0]);
  }
  for (i=1;i<sizeof(bits);i++) {
     if (sscanf(bits[i], "%s\n%s", tmp, bits[i]) != 2) {
        tmp = bits[i];
        bits[i] = "";
        fluff = 1;
     } else {
        fluff = 0;
     }
     switch (tmp[0..1]) {
      case "SH" : /* Section header */
        add_int(V_HEADER);
        add_string(tmp[3..]);
        new_string = 1;
        break;
      case "SI" : /* Start indent */
        add_int(V_INDENT);
        j = 0;
        sscanf(tmp[2..], "%d%s", j, tmp);
        add_int(j);
        force_string = 1;
        break;
      case "EI" : /* End indent */
        add_string("");
        new_string = 1;
        break;
      case "SP" : /* Start paragraph */
        add_int(V_PARA);
        j = 0;
        sscanf(tmp[2..], "%d%s", j, tmp);
        add_int(j);
        j = 0;
        sscanf(tmp, " %d%s", j, tmp);
        add_int(j);
        force_string = 1;
        strip_crs = 1;
        break;
      case "EP" : /* End paragraph */
        add_string("");
        new_string = 1;
        strip_crs = 0;
        break;
      case "SC" : /* start centering */
        add_int(V_CENTER);
        force_string = 1;
        break;
      case "EC" : /* End centering */
        new_string = 1;
        break;
      case "SL" : /* Start left justify */
        add_int(V_LEFT);
        force_string = 1;
        break;
      case "EL " : /* End left justify */
        new_string = 1;
        break;
      case "ST" : /* Start table mode (Turn tabs into new lines) */
        add_int(V_TABLE);
        force_string = 1;
        conv_tabs = 1;
        break;
      case "ET" : /* End table mode */
        new_string = 1;
        conv_tabs = 0;
        break;
      case "DT" : /* Do title.  Take the next three lines... */
        bing = explode(bits[i], "\n");
        if (sizeof(bing) < 3) {
           if (this_player()->query_creator()) {
              tell_object(this_player(), "Text file "+in_file+
                          " did not have enough lines after the .DT directive.\n");
              tell_object(this_player(), sprintf("%O\n", bing));
           }
           return 0; /* failed! */
        }
        add_int(V_ALL);
        if (strlen(bing[0]) > strlen(bing[2]))
           add_int(strlen(bing[0]));
        else
           add_int(strlen(bing[2]));
        new_string = 1;
        add_string(bing[0]);
        new_string = 1;
        add_string(bing[1]);
        new_string = 1;
        add_string(bing[2]);
        new_string = 1;
        bits[i] = implode(bing[3..], "\n");
        break;
      case "SO" : /* starts column mode. The numbers after it
                   * are column size */
        num_cols = 0;
        tmp = tmp[2..];
        cols = ({ });
        while (sscanf(tmp, "%d%s", j, tmp) == 2) {
           cols += ({ j });
           num_cols++;
           while (strlen(tmp) && tmp[0] == ' ')
           tmp = tmp[1..];
        }
        add_int(V_COLUMN);
        if (sscanf(tmp, "%d", j) == 1) {
           cols += ({ j });
           num_cols++;
        }
        add_array(cols);
        cols = allocate(num_cols);
        for (j=0;j<num_cols;j++) {
           cols[j] = ({ });
        }
        col_mode = 1;
        break;
      case "EO" : /* End column mode */
        for (j=0;j<num_cols;j++) {
           add_array(cols[j]);
        }
        col_mode = 0;
        break;
      case "NF" : /* New File.  Take the next line and ignore everything
                   * else in the file */
        bing = explode(bits[i], "\n");
        if (sizeof(bing) < 1) {
           if (this_player()->query_creator()) {
              tell_object(this_player(), "Text file "+in_file+
                          " did not have enough lines after the .NF directive.\n");
              tell_object(this_player(), sprintf("%O\n", bing));
           }
           return 0; /* failed! */
        }
        /* read the new file and start again, but keep the old name */
        text = read_file(bing[ 0 ]);
        if (!text) {
          return 0;
        }
        bits = explode("#\n"+text, "\n.");
        bits[0] = bits[0][1..];
        nroffed_file = ({ 0 });
        if (strlen(bits[0])) {
           add_string(bits[0]);
        }
        strip_crs = col_mode = conv_tabs = fluff = num_cols = i = 0;
        break;
     }
     if (fluff) {
        continue;
     }
     if (conv_tabs) {
        bits[i] = replace(bits[i], "\t", "\n");
     }
     if (col_mode) {
        string *frog;
        
        frog = explode(bits[i], "\n");
        for (k = 0; k < sizeof(frog); k++) {
           bing = explode("#"+frog[k], "\t");
           bing[0] = bing[0][1..];
           for (j = 0; j < num_cols && j < sizeof(bing); j++) {
              cols[j] += ({ bing[j] });
           }
           for (j = sizeof(bing);j < num_cols; j++) {
              cols[j] += ({ "\n" });
           }
        }
     } else if (strip_crs) {
        bits[i] = replace_string(bits[i], "\n\n", "$%^NeW_LiNe^%$");
        bits[i] = replace_string(bits[i], ".\n", ".  ");
        bits[i] = replace_string(bits[i], "\n", " ");
        bits[i] = replace_string(bits[i], "$%^NeW_LiNe^%$", "\n\n");
        add_string(bits[i]+" ");
     } else {
        add_string(bits[i]+"\n");
     }
  }
  new_string = 0;
  force_string = 0;
  unguarded((: save_object, out_file :));
  return 1;
} /* create_nroff() */

/**
 * Will attempt to find the name of the nroffed file.  Will attempt to
 * find the name of the source file associated with the save file.
 *
 * @param fname the name of the file to check
 * @return the source file name or 0
 */
string query_file_name( string fname ) {
   if (!master()->valid_read(fname, geteuid(previous_object()),
                             "restore_object")) {
      return 0;
   }
   nroffed_file_name = 0;
   modified_time = 0;
   if (!restore_object(fname)) {
      return 0;
   }
   return nroffed_file_name;
} /* query_file_name() */

// --- END [/mnt/home2/grok/lib/obj/handlers/nroff.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/player_handler.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/player_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628309   Available: 13575663
Inodes: Total: 5242880    Free: 4960134
33532 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/player_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628309   Available: 13575663
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*
 * $Locker:  $
 * $Id: player_handler.c,v 1.61 2003/05/27 22:53:39 ceres Exp $
 */
/**
 * A hander to allow the testing of values on players when they aren't logged
 * in.  These methods used to exist in the login object but now they're here.
 * <p>
 * @author Ceres
 */

inherit "/global/family";
inherit "/std/living/nationality";

#include <alias.h>
#include <player.h>
#include <login_handler.h>
#include <access.h>

#define MAX_CACHE_SIZE MAX_PLAYERS
#define CACHE_TIMEOUT 900
#define INACTIVE_LIMIT 1209600
#define ILLEGAL ({ "black", "blood", "cyber", "dark", "penis", "cock", "pussy",\
  "fuck", "shit", "death", "deth", "dragon", "fish", "hell", "mage", "pink", "lord",\
  "shadow", "evil", "killer", "slayer" })

/* Basic player variables needed by the login object. */
private int gender;
private int creator;
private int time_on;
private int last_log_on;
private string last_on_from;
private int activity_counter;
private int start_time;
private string password;
private string deity;
private string guild_ob;
private string cap_name;
private mapping aliases;
private mapping map_prop;
private mapping new_skills;
private mapping player_info;
private mixed *guild_data; 
private int _flags;

private string home_dir;

string player_ob;

class player_record {
  int cached;
  int touched;
  int deleting;
  int appealing;
  int gender;
  int creator;
  int active;
  int level;
  string cap_name;
  mapping map_prop;
  mapping player_info;
  string deity;
  string guild;
  mixed *guild_data;
  int age;
  int last;
  int flags;
  string last_on_from;
  int start_time;
  string family_name;
  string player_title;
  string password;
  mixed *project;
  mixed *plan;
  mixed *reference;
  mixed *signature;

  string home_dir;
  string nationality;
  string nationality_region;
  mixed nationality_data;
}

nosave mapping player_cache;
nosave string prev, prev_find, prev_name;
nosave int prev_count, prev_finds, delay;

int requests,
  cache_hits;

void create() {
  seteuid("Root");
  player_ob = "/global/player";
  player_cache = ([ ]);
}                               /* create() */

object my_find_player(string player) {
  //Just guessing at what this should be initialised to.
  string *funs, stack = "";
  object *obs;
  int i;

  if(prev_name == player)
    return find_player(player);
  prev_name = player;
  
  if (base_name(previous_object()) == prev_find && delay > time() - 60 &&
      prev_name == player) {
    prev_finds++;
  } else {
    prev_finds = 1;
    delay = time();
    prev_find = base_name(previous_object());
  }

  if(!(prev_finds % 25)) {
    obs = call_stack(1);
    funs = call_stack(2);
    for(i=0; i<sizeof(obs); i++) {
      if(clonep(obs[i]))
        stack += base_name(obs[i]) + "#" + obs[i]->query_name();
      else
        stack += base_name(obs[i]);
      stack += "->" + funs[i] + "()\n";
    }
    log_file("GARBAGE", "%s %s checked %d players in %d seconds.\n%s",
             ctime(time())[4..18], prev_find, prev_finds, time() - delay,
             stack);
  }
  return find_player(player);
}

void clean_cache() {
  string name;
  
  foreach(name in keys(player_cache)) {
    if (player_cache[name]->cached < time() - CACHE_TIMEOUT) {
      map_delete(player_cache, name);
    }
  }
}

void remove_cache_entry(string name) {
  map_delete(player_cache, name);
}

private int validate_name(string name) {
  if (!stringp(name) || !name || name == "logon" || name[0] == '.' ||
      (sscanf(name, "%*s %*s") == 2) || strlen(name) < 2) {
    return 0;
  }
  if (sizeof(explode(name, "..")) > 1) {
    return 0;
  }

  return 1;
}

/**
 * This method returns the path to the player file.
 * This is the player files actual normal location, it was written to
 * allow moving the player files around easier.
 * @param name the name of the player whose file to find
 * @see test_user()
 * @see query_delete_player_file_name()
 */
string query_player_file_name(string name) {
#ifdef USE_RAMDISK  
  if(PLAYER_RAM_DIR) {
    if(file_size(PLAYER_RAM_DIR + name[0..0] + "/" + name + ".o.gz") == -1) {
      if(file_size(PLAYER_SAVE_DIR + name[0..0] + "/" + name + ".o.gz") > -1) {
        unguarded((: cp,
                   PLAYER_SAVE_DIR + name[0..0] + "/" + name + ".o.gz",
                   PLAYER_RAM_DIR + name[0..0] + "/" + name + ".o.gz" :));
      } else if((file_size(PLAYER_SAVE_DIR+name[0..0]+"/"+name+".o") >-1)) {
        unguarded((: cp,
                   PLAYER_SAVE_DIR + name[0..0] + "/" + name + ".o",
                   PLAYER_RAM_DIR + name[0..0] + "/" + name + ".o" :));
        unguarded((: compress_file,
                   PLAYER_RAM_DIR + name[0..0] + "/" + name + ".o" :));
      }
    }
    return PLAYER_RAM_DIR + name[0..0] + "/" + name;
  }
#endif
  return PLAYER_SAVE_DIR + name[0..0] + "/" + name;
}

string query_player_ram_file_name(string name) {
  return PLAYER_RAM_DIR + name[0..0] + "/" + name;
}

string query_player_disk_file_name(string name) {
  return PLAYER_SAVE_DIR + name[0..0] + "/" + name;
}

/**
 * This method returns the path to the deleted player file.
 * This is the deleted player files actual normal location, it was written to
 * allow moving the player files around easier.
 * @param name the name of the player whose file to find
 * @see test_user()
 * @see query_delete_player_file_name()
 */
string query_delete_player_file_name(string name) {
   return PLAYER_SAVE_DIR + DELETE_DIR + "/" + name;
}

/**
 * This method returns the path to the pending appeal player file.
 * This is the appeal player files actual normal location, it was written to
 * allow moving the player files around easier.
 * @param name the name of the player whose file to find
 * @see test_user()
 * @see query_delete_player_file_name()
 */
string query_appeal_player_file_name(string name) {
   return PLAYER_SAVE_DIR + APPEAL_DIR + "/" + name;
}

/**
 * This method will load in the player file.  It will return 0 if the player
 * file either does not exist or the input string is incorrect.
 * @param name the name to try and read in
 * @return 1 if the player file exists, 0 if not
 */
int load_player(string name) {
  class player_record tmp;
  mixed *file;
  int diff, deleting, appealing;
  string tstr, fname;
  object loaded_guild_ob;

  if (!validate_name(name)) {
    return 0;
  }

  requests++;

  // Check if we have a cached copy of this file. If so, only use the cached
  // copy if the cached time * 10 is less than the last touched time
  // ie. files which were modified recently should be cached for less time.
  if (player_cache[name]) {
    if (10 * (time() - player_cache[name]->cached) <
        (time() - player_cache[name]->touched)) {
      cache_hits++;
      return 1;
    }
  }

  // check if the file exists and get info about it.
  if(file = unguarded((: get_dir, query_player_ram_file_name(name) + ".o.gz",
                       -1 :)))
    fname = query_player_ram_file_name(name);
  if (!file || !sizeof(file) || file[0][1] < 0) {
    file = unguarded((: get_dir, query_player_disk_file_name(name) +
                      ".o.gz", -1 :));
    fname = query_player_disk_file_name(name);
  }
  
  if (!file || !sizeof(file) || file[0][1] < 0) {
    file = unguarded((: get_dir, query_player_disk_file_name(name) +
                      ".o", -1 :));
    fname = query_player_disk_file_name(name);
  }
  
  if (!file || !sizeof(file) || file[0][1] < 0) {
    file = unguarded((: get_dir, query_delete_player_file_name(name) + ".o.gz",
                      -1 :));
    fname = query_delete_player_file_name(name);
  }
  
  if (!file || !sizeof(file) || file[0][1] < 0) {
    file = unguarded((: get_dir, query_delete_player_file_name(name) + ".o",
                      -1 :));
    fname = query_delete_player_file_name(name);
  }
  
  if (!file || !sizeof(file) || file[0][1] < 0) {
    file = unguarded((: get_dir, query_appeal_player_file_name(name) + ".o.gz",
                      -1 :));
    fname = query_appeal_player_file_name(name);
  }
  
  if (!file || !sizeof(file) || file[0][1] < 0) {
    file = unguarded((: get_dir, query_appeal_player_file_name(name) + ".o",
                      -1 :));
    fname = query_appeal_player_file_name(name);
  }
  
  if(!file || !sizeof(file) || file[0][1] < 0)
    return 0;
  
  // If we've got a cached copy of this file see if the original's touched
  // time is the same as that for our copy, if so use the cached copy
  // and update the 'cached' time.
  if(player_cache[name] && player_cache[name]->touched == file[0][2]) {
    player_cache[name]->cached = time();
    cache_hits++;
    return 1;
  }
  
  // restore the file and setup the data.
  gender = 0;
  creator = 0;
  time_on = 0;
  last_log_on = 0;
  last_on_from = 0;
  activity_counter = 0;
  start_time = 0;
  password = 0;
  deity = 0;
  guild_ob = 0;
  cap_name = 0;
  player_info = ([ ]);
  aliases = ([ ]);
  new_skills = ([ ]);
  map_prop = ([ ]);
  guild_data = 0; 

  if (base_name(previous_object()) == prev && delay > time() - 60) {
    prev_count++;
  } else {
    prev_count = 1;
    delay = time();
    prev = base_name(previous_object());
  }
  
  if (!(prev_count % 25)) {
    tstr = prev;
    if (tstr == "/secure/login" && sizeof(previous_object(-1)) > 1) {
      tstr = base_name(previous_object(-1)[1]);
    }
    
    log_file("GARBAGE", "%s %s loaded %d player files in %d seconds.\n",
             ctime(time())[4..18], tstr, prev_count, time() - delay);
  }
#ifdef DEBUG
  string ob;
  if (base_name(previous_object()) != "/secure/login") {
    ob = base_name(previous_object());
  } else {
    ob = base_name(previous_object(-1)[1]);
  }
  log_file("CDEBUG", "%s: %O:%O\n", ob, call_stack(1), call_stack(2));
#endif


  if(!unguarded((: restore_object, fname, 1 :)))
    return 0;

  // Find out how long their deletion/appeal has to go before they're
  // removed.
  if(fname == query_appeal_player_file_name(name)) {
    appealing = file[0][2];
  } else if(fname == query_delete_player_file_name(name)) {
    deleting = file[0][2];
  }
             
  tmp = new (class player_record,
             cached: time(),
             touched: file[0][2],
             deleting: deleting,
             appealing: appealing,
             gender: gender,
             creator: creator,
             active: 0,
             level: 0,
             cap_name: cap_name,
             player_info: player_info,
             map_prop: map_prop,
             deity: deity,
             guild: guild_ob,
             guild_data: guild_data,
             flags: _flags,
             age: time_on,
             last: last_log_on,
             last_on_from: last_on_from,
             start_time: start_time,
             family_name: query_family_name(),
             player_title: query_player_title(),
             nationality: query_nationality(),
             nationality_region: query_nationality_region(),
             nationality_data: query_nationality_data(),
             password: password);

  if(aliases) {
    if (aliases[".project"])
      tmp->project = aliases[".project"][0..1023];
    if (aliases[".plan"])
      tmp->plan = aliases[".plan"][0..1023];
    if (aliases[".reference"])
      tmp->reference = aliases[".reference"][0..1023];
    if (aliases[".signature"])
      tmp->signature = aliases[".signature"][0..240];
  }
  // are they active.
  diff = (time() - last_log_on) / (3600 * 24 * 7);
  diff *= 10;
  tmp->active = (activity_counter - diff) > -50 ? 1 : 0;
  
  // calculate their level
  if (guild_ob) { 
    loaded_guild_ob = load_object( guild_ob );

    if ( loaded_guild_ob ) {
        tmp->level = (int) guild_ob->query_level(this_object());
    }
    else {
        tmp->level = 0;
    }
  }
  
  player_cache[name] = tmp;
  
  if ((sizeof(player_cache) > MAX_CACHE_SIZE) &&
      (find_call_out("clean_cache") == -1))
    call_out("clean_cache", 60);
  
  return 1;
}

/**
 * This method converts an alias into a string.  This is used by the
 * projects and plans and so on.
 * @param al the alias to turn into a string
 * @return the converted string
 */
string make_string(mixed *al, int max) {
  string str;
  int i;
  int lines;

  str = ALIAS_CMD->alias_string(al);
  sscanf(str, "%s $*$", str);
  str = replace(str, sprintf("%c", 7), "^G");
  str = replace(str, ({ "@@", "@ @ ", "\\;", "$escaped$", ";", "\n",
                          "$escaped$", ";" }));

  for (i = lines = 0; i < sizeof(str) && i < max*80 && lines < max; i++) {
    if (str[i] == '\n' || str[i] == ';') {
      lines++;
    }
  }
  return str[0..i - 1];
}

/**
 * This method figures out if the user exists even if they are not on.
 * @param str the name of the user
 * @return 1 if they exist, 0 if they do not
 */
int test_user(string str) {

  if (player_cache[str])
    return 1;

  if (!validate_name(str))
    return 0;

  return file_size(query_player_disk_file_name(str) + ".o.gz") > 0 ||
    file_size(query_player_disk_file_name(str) + ".o") > 0 ||
    file_size(PLAYER_RAM_DIR + str[0..0] + "/" + str + ".o.gz") > 0 ||
    file_size(PLAYER_RAM_DIR + str[0..0] + "/" + str + ".o") > 0 ||
    file_size(query_delete_player_file_name(str) + ".o.gz") > 0 ||
    file_size(query_delete_player_file_name(str) + ".o") > 0 ||
    file_size(query_appeal_player_file_name(str) + ".o.gz") > 0 ||
    file_size(query_appeal_player_file_name(str) + ".o") > 0;
}

/**
 * This method figures out if the user is marked for deletion.
 * @param str the name of the user
 * @return 1 if they are marked for deletion, 0 if they do not
 */
int test_deleting(string str) {

  if (player_cache[str])
    return player_cache[str]->deleting;

  if (!validate_name(str))
    return 0;

  if (file_size(query_delete_player_file_name(str) + ".o") > 0)
    return stat(query_delete_player_file_name(str) + ".o")[1];

  if(file_size(query_delete_player_file_name(str) + ".o.gz") > 0)
    return stat(query_delete_player_file_name(str) + ".o.gz")[1];

  return 0;
}

/**
 * This method figures out if the user is marked for deletion pending appeal.
 * @param str the name of the user
 * @return 1 if they are marked for deletion, 0 if they do not
 */
int test_appealing(string str) {

  if (player_cache[str])
    return player_cache[str]->appealing;

  if (!validate_name(str))
    return 0;

  if (file_size(query_appeal_player_file_name(str) + ".o") > 0)
    return stat(query_appeal_player_file_name(str) + ".o")[1];

  if(file_size(query_appeal_player_file_name(str) + ".o.gz") > 0)
    return stat(query_appeal_player_file_name(str) + ".o.gz")[1];

  return 0;
}
/**
 * This method determines the gender of the player even if they are
 * not currently on
 * @param str the name of the user
 * @return the players gender
 * @see /std/living/gender.c
 */
int test_gender(string str) {
  if (find_player(str)) {
    map_delete(player_cache, str);
    return find_player(str)->query_gender();
  }

  if (!load_player(str))
    return 0;

  return player_cache[str]->gender;
}

/**
 * This method determines if a player is still active.
 * If you need to perform this on a lot of players please use the noload
 * parameter. When noload is set to 1 test_active will not attempt to load
 * the player file if it isn't currently loaded and will instead just do a
 * simple calculation of the players last login time. This is less accurate
 * but avoids lagging the mud.
 *
 * @param player the name of the user
 * @param noload optional parameter to prevent test_active() loading the
 *               player 
 file.
 * @return active or inactive (1 or 0)
 */
varargs int test_active(string player, int noload) {
  mixed *file;

  if (find_player(player)) {
    map_delete(player_cache, player);
    return 1;
  }

  if (noload) {
    if (player_cache[player])
      return player_cache[player]->active;
    file =
      unguarded((: stat,
                 query_player_disk_file_name(player) + ".o" :));
    if (!file || !sizeof(file)) {
      file =
        unguarded((: stat,
                   query_player_disk_file_name(player) + ".o.gz" :));
    }

    return (sizeof(file) && file[1] > time() - INACTIVE_LIMIT);
  }
  
  if (!load_player(player))
    return 0;
  
  return player_cache[player]->active;
}

/**
 * This method returns a players cap_name.
 * @param str the name of the user
 * @return the players cap name
 */
string query_cap_name(string str) {
  if (find_player(str)) {
    map_delete(player_cache, str);
    return find_player(str)->query_cap_name();
  }

  if (!load_player(str))
    return 0;

  return player_cache[str]->cap_name;
}

/**
 * This method determines the level of the player even if they are
 * not currently on
 * @param str the name of the user
 * @return the players level
 * @see /std/living/gender.c
 */
int test_level(string str) {
  if (find_player(str)) {
    map_delete(player_cache, str);
    return find_player(str)->query_level();
  }

  if (!load_player(str))
    return 0;

  return player_cache[str]->level;
}

/**
 * This method is called by query_level() in the base guild
 * inheritable to determine the specialisation of the current
 * player.
 */ 
mixed query_guild_data() {
    return guild_data; 
} /* query_guild_data() */ 


/* Added by Presto 12/20/97.  Needed for test_level.
 == not sure about this -- Ceres == */
int query_skill(string skill) {
  if (mapp(new_skills)) {
    return new_skills[skill];
  }

  return 0;
}

/**
 * This method checks to see if the name is banished of not.
 * @param name the check for banishment.
 * @return 1 if it banished, 0 if not
 */
int test_banished(string name) {
  return file_size(BANISH_DIR + name[0..0] + "/" + name + ".o") != -1;
}

/**
 * Validate a name by checking if it, or bits of it are banished.
 * @param name The name to be validated.
 * @param full Should we do full checks or just the basics.
 * @return 1 if it's ok, 0 if not.
 */
varargs int test_valid(string name) {
  string *bits, bit, tname;

  name = lower_case(name);
  tname = replace(name, ({ "'", "", "_", " " }));
  bits = explode(tname, " ");

  name = replace(name, ({ "'", " ", "_", " " }));
  bits += explode(name, " ");

  foreach(bit in bits) {
    if (bit == "the" || bit == "von" || bit == "sto" || bit == "here" || 
    bit == "there" || bit == "time") {
      continue;
    }

    if (test_banished(bit))
      return 0;
  }

  name = replace(name, ({ " ", "" }));
  if (test_banished(name))
    return 0;

  foreach(bit in ILLEGAL) {
    if (strsrch(name, bit) != -1)
      return 0;
  }

  return 1;
}

/**
 * This method determines the real name of the player even if they are
 * not currently on
 * @param str the name of the user
 * @return the players real name
 * @see /std/living/gender.c
 */
string test_real_name(string str) {
  if (find_player(str)) {
    map_delete(player_cache, str);
    return find_player(str)->query_real_name();
  }

  if (!load_player(str))
    return "";

  return player_cache[str]->player_info["real_name"];
}

/**
 * This method determines the email of the player even if they are
 * not currently on.
 * @param str the name of the user
 * @return the players email
 */
string test_email(string str) {
  if(file_name(previous_object())[0..13] != "/secure/finger" &&
     file_name(previous_object())[0..12] != "/secure/login" &&
     file_name(previous_object())[0..13] != "/secure/nlogin")
    return "";
  
  if (find_player(str)) {
    map_delete(player_cache, str);
    return find_player(str)->query_email();
  }

  if (!load_player(str))
    return "";

  return player_cache[str]->player_info["email"];
}

/**
 * This method determines the birthday of the player even if they are
 * not currently on
 * @param str the name of the user
 * @return the players birthday (if set)
 */
string test_birthday(string str) {
  if (find_player(str)) {
    map_delete(player_cache, str);
    return find_player(str)->query_birthday();
  }

  if (!load_player(str))
    return "";

  return player_cache[str]->player_info["birthday"];
}

/**
 * This method determines the players location finger information even if they
 * are not currently on
 * @param str the name of the user
 * @return the players location
 */
string test_location(string str) {
  if (find_player(str)) {
    map_delete(player_cache, str);
    return find_player(str)->query_where();
  }

  if (!load_player(str))
    return "";

  return player_cache[str]->player_info["location"];
}

/**
 * This method determines the players homepage information even if they
 * are not currently on
 * @param str the name of the user
 * @return the players location
 */
string test_homepage(string str) {
  if (find_player(str)) {
    map_delete(player_cache, str);
    return find_player(str)->query_homepage();
  }

  if (!load_player(str))
    return "";

  return player_cache[str]->player_info["homepage"];
}

/**
 * This method determines the description of the player even if they are
 * not currently on
 * @param str the name of the user
 * @return the players description
 */
string test_desc(string str) {
  if (find_player(str)) {
    map_delete(player_cache, str);
    return find_player(str)->query_desc();
  }

  if (!load_player(str))
    return "";

  return player_cache[str]->player_info["desc"];
}

/**
 * This method returns the current value of the player flag on the
 * player, even if they are not currently on.
 * @param word the player name
 * @return 1 if they are a player killer, 0 if not
 */
mixed test_player_killer(string word, string str) {
  if (find_player(word)) {
    map_delete(player_cache, word);
    return find_player(word)->query_player_killer();
  }

  if (!load_player(word)) {
    return 0;
  }

  return player_cache[word]->flags & PLAYER_KILLER_FLAG;
}

/**
 * This method returns the current value of the property on the
 * player, even if they are not currently on.
 * @param word the player name
 * @param str the property to query
 * @return the value of the property
 */
mixed test_property(string word, string str) {
  if (find_player(word)) {
    map_delete(player_cache, word);
    return find_player(word)->query_property(str);
  }

  if (!load_player(word))
    return 0;

  return player_cache[word]->map_prop[str];
}

/**
 * This method updates the cached properties, it's called by
 * /secure/login.
 */
void special_add_property(string pname, string prop, mixed val) {
  if(player_cache[pname])
    player_cache[pname]->map_prop[prop] = val;
}


/**
 * This method determines the deity of the player even if they are
 * not currently on.
 * @param str the name of the user
 * @return the players deity
 */
string test_deity(string word) {
  if (find_player(word)) {
    map_delete(player_cache, word);
    return find_player(word)->query_deity();
  }

  if (!load_player(word))
    return 0;

  return player_cache[word]->deity;
}

/**
 * This method determines the guild of the player even if they are
 * not currently on.
 * @param str the name of the user
 * @return the players guild
 */
string test_guild(string word) {
  if (find_player(word)) {
    map_delete(player_cache, word);
    return find_player(word)->query_guild_ob();
  }

  if (!load_player(word))
    return "";

  return player_cache[word]->guild;
}

/**
 * This method determines the guild data of the player even if they are
 * not currently on.
 * @param str the name of the user
 * @return the players guild data
 */
mixed *test_guild_data(string word) {
  if (find_player(word)) {
    map_delete(player_cache, word);
    return find_player(word)->query_guild_data();
  }

  if (!load_player(word))
    return ({ });

  return player_cache[word]->guild_data;
}

/**
 * This method determines the age of the player even if they are
 * not currently on.
 * @param str the name of the user
 * @return the players age
 */
int test_age(string word) {
  if (find_player(word)) {
    map_delete(player_cache, word);
    return find_player(word)->query_time_on();
  }

  if (!load_player(word))
    return 0;

  return player_cache[word]->age;
}

/**
 * This method determines the last log on of the player even if they are
 * not currently on.
 * @param str the name of the user
 * @return the players last log on
 */
int test_last(string word, int noload) {
  mixed *file;
  
  if (find_player(word)) {
    map_delete(player_cache, word);
    return find_player(word)->query_last_log_on();
  }

  if (noload) {
    if (player_cache[word]) {
      return player_cache[word]->last;
    }
    word = replace(word, ({ "/", "", "\\", "" }) );
    file =
      unguarded((: stat, query_player_ram_file_name(word) + ".o" :));
    if (!file || !sizeof(file)) {
      file = unguarded((: stat,
                        query_player_disk_file_name(word)+".o.gz" :));
    }
    
    if(!file || !sizeof(file)) {
      file = unguarded((: stat, 
                        query_delete_player_file_name(word)+ 
                        ".o" :));
    }
    if (!file || !sizeof(file)) {
      file = unguarded((: stat,
                        query_delete_player_file_name(word)+
                        ".o.gz" :));
    }
    
    if(!file || !sizeof(file)) {
      file = unguarded((: stat, 
                        query_appeal_player_file_name(word)+ 
                        ".o" :));
    }
    if (!file || !sizeof(file)) {
      file = unguarded((: stat,
                        query_appeal_player_file_name(word)+
                        ".o.gz" :));
    }
    if (!sizeof(file))
      return 0;
    
    return file[1];
  }
  
  if (!load_player(word)) {
    return 0;
  }
  // This needs to be -ve to be consistant..
  return player_cache[word]->last;
}

/**
 * This method determines the last log on of the player even if they are
 * not currently on.
 * @param str the name of the user
 * @return the players last log on
 */
string test_last_on_from(string word) {
  if (find_player(word)) {
    map_delete(player_cache, word);
    return query_ip_name(find_player(word)) + " (" +
      query_ip_number(find_player(word)) + ") ";
  }

  if (!load_player(word)) {
    return 0;
  }
  // This needs to be -ve to be consistant..
  return player_cache[word]->last_on_from;
}

/**
 * This method determines the time the player started at.
 * @param str the name of the user
 * @return the players last log on
 */
int test_start_time(string word) {
  if (find_player(word)) {
    map_delete(player_cache, word);
    return find_player(word)->query_start_time();
  }

  if (!load_player(word))
    return 0;

  return player_cache[word]->start_time;
}

/**
 * This method determines if the player is a creator.
 * @param str the name of the user
 * @return the player to test
 * @see test_last()
 * @see test_user()
 * @see test_creator()
 */
int test_creator(string str) {
  str = lower_case (str);
  if (find_player(str)) {
    map_delete(player_cache, str);
    return find_player(str)->query_creator();
  }

  if (!load_player(str))
    return 0;

  return player_cache[str]->creator;
}

/**
 * This method returns the players home directory
 * @param str the name of the user
 * @return the player to test
 */
string test_home_dir(string str) {
  if (find_player(str)) {
    map_delete(player_cache, str);
    return find_player(str)->query_home_dir();
  }

  if (!load_player(str))
    return 0;

  return player_cache[str]->home_dir;
}

/**
 * This method returns the players family name
 * @param str the name of the user
 * @return the family name
 */
string test_family(string str) {
  if (find_player(str)) {
    map_delete(player_cache, str);
    return find_player(str)->query_family_name();
  }

  if (!load_player(str))
    return 0;

  return player_cache[str]->family_name;
}

/**
 * This method returns the players title.
 * @param str the name of the user
 * @return the title
 */
string test_player_title(string str) {
  if (find_player(str)) {
    map_delete(player_cache, str);
    return find_player(str)->query_player_title();
  }

  if (!load_player(str))
    return 0;

  return player_cache[str]->player_title;
}

/** @ignore yes */
int test_password(string name, string pass) {
  if (!load_player(name)) {
    return 0;
  }

  // Have to do this since its the only function that requires restoring
  // from a file if the player is active!
  if (find_player(name) && player_cache[name]->password == "") {
    if(file_size(query_player_ram_file_name(name) + ".o.gz") > 0) 
      unguarded((: restore_object, query_player_ram_file_name(name), 1 :));
    else
      unguarded((: restore_object, query_player_disk_file_name(name), 1 :));
    player_cache[name]->password = password;
  }

  return crypt(pass, player_cache[name]->password) ==
    player_cache[name]->password;
}

/** @ignore yes */
string get_password(string name) {
  if(file_name(previous_object()) != "/secure/ftp_auth")
    return "x";

  if(!load_player(name))
    return "x";

  if(find_player(name) && player_cache[name]->password == "") {
    unguarded((: restore_object,
               query_player_disk_file_name(name), 1 :));
    //player_cache[name]->password = password;
  }

  return player_cache[name]->password;
}

/**
 * This method returns the signature to use on posts for the player
 * even when they are off line.
 * @param name the name of the player
 * @return the signature, "" if none
 */
string query_signature(string name) {
  string sig;

  if (find_player(name)) {
    map_delete(player_cache, name);
    sig =
      make_string(find_player(name)->query_player_alias(".signature"), 
                  3);
  } else {
    if (!load_player(name))
      return "";

    sig = make_string(player_cache[name]->signature, 3);
  }

  if (sig && sig != "")
    sig = "\n--\n" + strip_colours(sig);

  return sig;
}

/**
 * This method returns the players .project even when they are off line.
 * @param name the name of the player
 * @return the project, "" if none
 */
string query_project(string name, int unused) {
  if (find_player(name)) {
    map_delete(player_cache, name);
    if (find_player(name)->query_player_alias(".project"))
      return make_string(find_player(name)->query_player_alias(".project"), 5);
    else
      return "";
  }

  if (!load_player(name))
    return "";

  return make_string(player_cache[name]->project, 5);
}

/**
 * This method returns the players .plan even when they are off line.
 * @param name the name of the player
 * @return the plan, "" if none
 */
string query_plan(string name, int unused) {
  if (find_player(name)) {
    map_delete(player_cache, name);
    if (find_player(name)->query_player_alias(".plan"))
      return make_string(find_player(name)->query_player_alias(".plan"),
                         5);
    else
      return "";
  }

  if (!load_player(name))
    return "";

  return make_string(player_cache[name]->plan, 5);
}

/**
 * This method returns the players .reference even when they are off line.
 * @param name the name of the player
 * @return the reference, "" if none
 */
string query_reference(string name) {
  if (find_player(name)) {
    map_delete(player_cache, name);
    if (find_player(name)->query_player_alias(".reference"))
      return make_string(find_player(name)-> 
                         query_player_alias(".reference"), 20);
    else
      return "";
  }
   
  if (!load_player(name))
    return "";
   
  return make_string(player_cache[name]->reference, 20);
}

/**
 * This method returns the players nationality.
 * @param str the name of the user
 * @return the nationality
 */
string test_nationality(string str) {
  if (find_player(str)) {
    map_delete(player_cache, str);
    return find_player(str)->query_nationality();
  }

  if (!load_player(str)) {
    return 0;
  }

  return ((class player_record)player_cache[str])->nationality;
}

/**
 * This method returns the players nationality region.
 * @param str the name of the user
 * @return the nationality region
 */
string test_nationality_region(string str) {
  if (find_player(str)) {
    map_delete(player_cache, str);
    return find_player(str)->query_nationality_region();
  }

  if (!load_player(str)) {
    return 0;
  }

  return player_cache[str]->nationality_region;
}

/**
 * This method returns the players nationality data.
 * @param str the name of the user
 * @return the nationality data
 */
string test_nationality_data(string str) {
  if (find_player(str)) {
    map_delete(player_cache, str);
    return find_player(str)->query_nationality_data();
  }

  if (!load_player(str)) {
    return 0;
  }

  return player_cache[str]->nationality_data;
}

/**
 * Check if a players personal allow list permits logins from this IP
 * @param name The player name.
 * @param ip The IP address.
 */
int test_ip_allowed(string name, string ip) {
  string *ips;
  
  // Always allow the localhost. If they're logged in via the shell let
  // them in :)
  if(ip == "127.0.0.1")
    return 1;
  
  if(find_player(name)) {
    map_delete(player_cache, name);
    ips = find_player(name)->query_rhosts();
  } else if (load_player(name))
    ips = player_cache[name]->player_info["allowed_ips"];
  
  if(!ips || !sizeof(ips))
    return 1;
    
  while(strlen(ip)) {
    if(member_array(ip, ips) != -1)
      return 1;
    ip = implode((string *)explode(ip, ".")[0..<2], ".");
  }
  return 0;
}

mixed *stats() {
  int percentage;

  if (requests)
    percentage = (cache_hits * 100) / requests;

  return ({ ({ "cache size", sizeof(player_cache) }),
              ({ "requests", requests }),
              ({ "cache hits", cache_hits }),
              ({ "cache misses", requests - cache_hits }),
              ({ "percentage hits", percentage }), });
}

nomask int query_prevent_shadow(object ob) { return 1; }
// --- END [/mnt/home2/grok/lib/obj/handlers/player_handler.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/applications_handler.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/applications_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628301   Available: 13575655
Inodes: Total: 5242880    Free: 4960134
20392 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/applications_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628301   Available: 13575655
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 *  Applications handler
 *  @author Drakkos
 *  @started 30/01/2003
 *
 */
#include <board.h>
#include <mail.h>
#include <player.h>
#include <playerinfo.h>
#include <player_handler.h>
#include <applications.h>
#include <library.h> 
 
int find_application (string, string);
int find_type (string);
void mail_message(int, int);
string post_application (int);
int complete_application (int); 
  
nosave class application_type *types = ({ });
class application *applications = ({ });
mapping domain_lockout = ([
     "liaison"      : 0,
     "am"           : 0,
     "ram"          : 0,
     "sur"          : 0,
     "klatch"       : 0,
     "forn"         : 0,
     "cwc"          : 0,
     "playtesters"  : 0
   ]);
   

void load_me() {
  unguarded ((: restore_object (APPLY_SAVE_FILE) :));
}

void save_me() {
  unguarded ((: save_object (APPLY_SAVE_FILE) :));
}
   
mapping query_vouches_for_all (string name) {
  mapping tmp = ([ ]);
  
  for (int i = 0; i < sizeof (applications); i++) {
    if (!undefinedp(applications[i]->vouches[name])) {
      tmp[applications[i]->name + " (" + applications[i]->type + ")"] 
        = applications[i]->vouches[name];
    } 
  }
  return tmp;
}
   
varargs void add_application_type (string t, int v, string b, int g, int q, int a, 
  int ti, string *qu, string intro, string responsibility) {
  class application_type tmp;
  
  tmp = new (class application_type, type: t, vouches_required: v, board: b,
    gl_requirement: g, qp_requirement: q, age_requirement: a, questions: qu, 
    intro_text: intro, timeout: ti, responsibility: responsibility);
    
  types += ({ tmp });
  

}

int toggle_domain_lock (string dom) {
  object ob = load_object ("/d/" + dom + "/master");
  
  if (ob->query_lord() != this_player()->query_name()) {
    return -1;
  }
  
  if (domain_lockout[dom]) {
    domain_lockout[dom] = 0;
  }
  else {
    domain_lockout[dom] = 1;
  }
  save_me();
}

int query_applications_accepted(string dom) {
  return (undefinedp (domain_lockout[dom]) ? -1 : domain_lockout[dom]);
}  

string query_responsibility (string type) {
  int i;
  object ob;
  string dom;
   
  i = find_type (type);
  
  if (i == -1) {
    dom = type;
    type = "creator";
    i = find_type (type);
  }
  else {
    dom = type;
  }
 
  
   
  if (undefinedp (types[i]->responsibility)) {
    ob = load_object ("/d/" + dom + "/master");
    
    if (!ob) {
      tell_creator ("drakkos", "%s.\n", dom, type);
      return 0;
    }
    return ob->query_lord();
  }
  else {
    ob = load_object ("/d/" + types[i]->responsibility+ "/master");
    
    if (!ob) {
      return "No-one";
    }
    return ob->query_lord();
  }    
}


mapping query_domain_status() {
  return copy (domain_lockout);
}
int add_application (string t, string n, string te, string dom) {
  class application tmp;
  int i;
  
  i = find_application (n, t);
  
  if (i != -1) {
    return 0;
  }
  
  tmp = new (class application, type: t, name: n, text: te, time: time(),
    domain: dom, vouches: ([ ]));
 
  applications += ({ tmp });
  i = find_application (n, t);
  
  complete_application (i);

  save_me();

  return 1;
    
}

void create() {
  seteuid (geteuid());
  load_me();
  add_application_type ("creator", 2, "applications", 150, 0,  5 * DAY, 14 * DAY, 
    ({
      "Why do you want to be a Creator on " + mud_name() + "?",
      "Do you have (or have you had) other characters on " + mud_name() + ", and if "
        "so what are their names?",
      "How many of the " + mud_name() + " books have you read?  How many do you "
        "own?",
      "Have you been into trouble with the Creators here on " + mud_name() + "?  "
        "Have you been suspended or banned from a MUD?  If so, why?",
      "Are you now, or have you been, a creator (or similar) on any other "
        "mud/mush/talker/etc.?",
      "How much time (in hours per week) do you think you can commit to "
        "" + mud_name() + "?",
      "What is your programming experience? Can you code in C or, more "
        "specifically, the variant of C known as LPC which the mud uses?",
      "What are you interested in creating on "
        "" + mud_name() + "?  Do you have any particular ideas or projects on "
        "which you would like to eventually work?",
      "Do you already know anyone who is a Creator here, who you "
        "have talked to about your application and has agreed to recommend "
        "you?  If so, who?",
      "Do you have anything else you'd like to tell us?",
        "To the best of your knowledge, is the information you have "
        "submitted in this application complete and correct?"
    }), 
    "You will be asked a number of questions.  There is no need "
      "to enter all your information during the first question, as you "
      "will be given plenty of opportunities to answer questions "
      "throughout your application.  If you would like to see what "
      "questions you will be asked, please read the list of questions.\n\n"
      "Please answer all the questions given, and you will get an "
      "opportunity at the end to let us know anything else about you "
      "that seems relevant.\n\n"
    "You will also be asked if the information you are submitting is "
      "true - lying on your creator application in an attempt to gain "
      "promotion under false pretenses is a serious offence... if you "
      "have withheld information that is pertinent to your application, "
      "or have willfully misrepresented the facts then you may find "
      "yourself subject to dismissal.  Please make an effort to be "
      "thorough and honest in your answers - in the long run, it will "
      "be much better for you than hiding anything you think may reflect "
      "badly on your application.\n");
  add_application_type ("liaison", 2, "applications", 150, 0,  5 * DAY, 14 * DAY,
   ({
      "Why do you want to be a Liaison on " + mud_name() + "?",
      "What experience do you already have from " + mud_name() + " which is relevant "
        "to this position?",
      "What experience do you have from the Roundworld (real life) which is "
        "relevant to this position?",
      "Do you have (or have you had) other characters on " + mud_name() + ", and if so "
        "what are their names?",
      "How many of the " + mud_name() + " books have you read?  How many do you "
        "own?",
      "Have you been into trouble with the Creators here on " + mud_name() + "?  "
        "Have you been suspended or banned from a MUD?  If so, why?",
      "Are you now, or have you been, a creator (or similar) on any other "
        "mud/mush/talker/etc.?",
      "How much time (in hours per week) do you think you can commit to "
        "" + mud_name() + "?  Also, please specify the approximate times that you "
        "usually log on and off (in Seattle time).",
      "Do you already know anyone who is a Creator here, who you "
        "have talked to about your application and has agreed to "
        "recommend you?  If so, who?",
      "Do you have anything else you'd like to tell us?",
      "To the best of your knowledge, is the information you have submitted "
        "in this application complete and correct?",
    }),
    "You will be asked a number of questions.  There is no need "
      "to enter all your information during the first question, as you "
      "will be given plenty of opportunities to answer questions "
      "throughout your application.  If you would like to see what "
      "questions you will be asked, please read the list of questions.\n\n"
      "Please answer all the questions given, and you will get an "
      "opportunity at the end to let us know anything else about you "
      "that seems relevant.\n\n"
    "You will also be asked if the information you are submitting is "
      "true - lying on your creator application in an attempt to gain "
      "promotion under false pretenses is a serious offence... if you "
      "have withheld information that is pertinent to your application, "
      "or have willfully misrepresented the facts then you may find "
      "yourself subject to dismissal.  Please make an effort to be "
      "thorough and honest in your answers - in the long run, it will "
      "be much better for you than hiding anything you think may reflect "
      "badly on your application.\n");
        
  add_application_type ("playtester", 3, "playtesters", 150, 0,  15 * DAY, 
    14 * DAY, 
    ({
      "Why do you want to be a playtester on " + mud_name() + "?",
      "Do you have (or have you had) other characters on " + mud_name() + ", and if so "
        "what are their names?",
      "What qualities do you feel you can bring to the role?",
      "Do you have any experience in a similar position in real life or "
        "on another MUD?",
      "Do you have anything else you'd like to tell us?",
      "To the best of your knowledge, is the information you have submitted "
        "in this application complete and correct?", 
    }), 
    "You will be asked a number of questions.  There is no need "
      "to enter all your information during the first question, as you "
      "will be given plenty of opportunities to answer questions "
      "throughout your application.  If you would like to see what "
      "questions you will be asked, please read the list of questions.\n\n"
      "Please answer all the questions given, and you will get an "
      "opportunity at the end to let us know anything else about you "
      "that seems relevant.\n\n"
    "You will also be asked if the information you are submitting is "
      "true - lying on your creator application in an attempt to gain "
      "promotion under false pretenses is a serious offence... if you "
      "have withheld information that is pertinent to your application, "
      "or have willfully misrepresented the facts then you may find "
      "yourself subject to dismissal.  Please make an effort to be "
      "thorough and honest in your answers - in the long run, it will "
      "be much better for you than hiding anything you think may reflect "
      "badly on your application.\n", 
      "playtesters");
   
} 

/**
 *  Find a particular application.
 *
 *  @param name The name of the candidate.
 *  @param type The type of application.
 *  @return the index of the candidate, or -1 if none found.
 *
 */
 
int find_application (string name, string type) {
  for (int i = 0; i < sizeof (applications); i++) {
    if (applications[i]->name == name && applications[i]->type == type) {
      return i;
    }
  }
  return -1;
}

/**
 *  Find a particular application type.
 *
 *  @param type The type of application.
 *  @return the index of the type, or -1 if none found.
 *
 */
 
 
int find_type(string type) {
  for (int i = 0; i < sizeof (types); i++) {
    if (types[i]->type == type) {
      return i;
    }
  }
  return -1;
}

void reset() {
  int j;
  class application *tmp = ({ });
  for (int i = 0; i < sizeof (applications); i++) {
    j = find_type (applications[i]->type);
    
    if (applications[i]->time + types[j]->timeout < time()) {
      tmp += ({ applications[i] });
      mail_message (0, i);
    }  
  }
  
  if (sizeof (tmp)) {
    applications -= tmp;
    save_me();
  }
  
}

int delete_vouch (string who, string name, string position) {
  int i = find_application (name, position);
  
  if (i == -1) {
    return 0;
  }
  if (undefinedp (applications[i]->vouches[who])) {
    return 0;
  }
  map_delete (applications[i]->vouches, who);
  save_me();
  return 1;
}
/**
 *  Deletes an application from the system.
 *
 *  @param name The name of the aplicant
 *  @param type The type of application.
 *  @return 1 for success, 0 for failure.
 *
 */
 
int delete_application (string t, string n) {
  int i = find_application (n, t);
  
  if (i == -1) {
    return 0;
  }
  
  applications -= ({ applications[i] });
  save_me();
  
  return 1;
}

/**
 *  Marks an application as completed... as in, all the vouches have been 
 *  received.
 *
 *  @param i The index of the application.
 *  @return 1 for success, 0 for failure.
 *
 */
 
private int complete_application (int i) {
  int vouches = sizeof (keys (applications[i]->vouches));
  int j;
  
  j = find_type (applications[i]->type);
  
  if (vouches >= types[j]->vouches_required) {
    post_application (i);
    delete_application (applications[i]->type, applications[i]->name);
    save_me();
    return 1;    
  }
  return 0;
}

/**
 *  Returns the number of vouches a player has received for an application.
 *
 *  @param i The index of the application.
 *  @return 1 for success, 0 for failure.
 *
 */
 
int number_of_vouches (string name, string type) {
  int i = find_application (name, type);
  
  if (i == -1) {
    return 0;
  }
  
  return sizeof (keys (applications[i]->vouches));
  
}

/**
 *  Query the vouch for a particular player in a particular category.
 *
 *  @param t The type of application.
 *  @param p The name of the player.
 *  @param n The name of the voucher.
 *  @return the text of the vouch or 0 if none exists.
 *
 */

string query_vouch (string t, string p, string n) {
  int i = find_application (p, t);
  
  if (i == -1) {
    return 0;
  }

  if (undefinedp (applications[i]->vouches[n])) {
    return "You have no vouch for this player in this position.\n";
  }
  return applications[i]->vouches[n];
}

int make_vouch (string t, string p, string n, string v) {
  int i = find_application (p, t);
  int newv = 1;
  
  if (i == -1) {
    return -1;
  }
  
  if (n == applications[i]->name) {
    return 0;
  }
  
  if (undefinedp (applications[i]->vouches[n])) {
    newv = 2;
  }
  applications[i]->vouches[n] = v;
  complete_application (i);
  save_me();
  return newv;
}

string* query_questions (string type) {
  int i = find_type (type);
  
  return types[i]->questions;
}

string query_intro_text (string type) {
  int i = find_type (type);
  
  return types[i]->intro_text;
}

int valid_application (string name, string type) {
  int i = find_type (type);
  object ob = find_player (name);

  if (ob->query_level() < types[i]->gl_requirement) {
    return 0;
  }
  if (-1 * ob->query_time_on() >= types[i]->age_requirement) {
    return 0;
  }
  
  if (LIBRARY->query_quest_points (name) < types[i]->qp_requirement) {
    return 0;
  }
  
  return 1;  
}

string application_requirements (string type) {
  int i = find_type (type);
  string ret = "";
  
  if (i == -1) {
    return "Applications of that category are not handled by this "
      "system.";
  }
  
  ret += "Applications for a " + types[i]->type + " position have the "
    "following requirements:\n\n";
  ret += "You need to be at least " + 
      query_time_string (types[i]->age_requirement) + " old.\n";
  ret += "You need to be at least guild level " + types[i]->gl_requirement + ".\n";
  ret += "You need to have at least " + types[i]->qp_requirement + " quest points.\n";
  ret += "You need to have " + types[i]->vouches_required + " vouches.\n";
  ret += "You have " + query_time_string (types[i]->timeout) + " to obtain your "
    "vouches.\n\n";
  ret += "Your application will not be posted for consideration until you have "
    "all your vouches completed.\n";
    

  return ret;  
}

mapping query_application_vouches (string type, string name) {
  int i = find_application (type, name);
  
  if (i == -1) {
    return 0;
  }
  else {
    return applications[i]->vouches;
  }
}


string format_application (int i) {
  string post;
  
  post = "%^BOLD%^Application:%^RESET%^\n"
         "=-=-=-=-=-=-\n\n" +  
         "Age: " + query_time_string(-1 * PLAYER_HANDLER->test_age 
         (applications[i]->name)) + "\n" + 
         "Application made: " + ctime (applications[i]->time) + "\n\n"
         + applications[i]->text + "\n\n";
         
  post += "\n\n%^BOLD%^Vouches:%^RESET%^\n"
          "=-=-=-=-\n";
          
  foreach (string v, string t in applications[i]->vouches) {
    post += "\n\n%^CYAN%^" + capitalize (v) + " (" + query_time_string (-1 * 
      PLAYER_HANDLER->test_age (v)) + "):%^RESET%^\n\n" + t;  
  }
  
  return post;
}

private string post_application (int i) {
  string post = "";
  int j = find_type (applications[i]->type);
  class reply_type rep;
  object ob, player;
  string response;

  post = format_application (i);

  rep= new(class reply_type);
  rep->type = B_REPLY_NAMED;
  rep->data = query_responsibility((applications[i]->domain ? applications[i]->domain : 
    applications[i]->type));
       
  ob = load_object ("/d/" + (applications[i]->domain ? 
    applications[i]->domain : types[j]->responsibility) + "/master");
  
  BOARD_HAND->add_message( types[j]->board, capitalize( applications[i]->name),
    capitalize( applications[i]->name ) + "'s " + (applications[i]->type == "creator" ? 
       applications[i]->domain + " domain" : capitalize (applications[i]->type)) + 
       " application", post, 0, rep );

  AUTO_MAILER->auto_mail( query_responsibility((applications[i]->domain ? 
    applications[i]->domain : applications[i]->type)), 
    applications[i]->name,
    "Application to " + capitalize( applications[i]->domain),
    "", post, 0, 0 );


  player = find_player (applications[i]->name);
  
  if (ob) {
    if (function_exists ("creator_application_callback", ob)) {
        response = call_other (ob, "creator_application_callback", 
        applications[i]->name, post);              
     }
   
    if (sizeof (response)) {
      tell_object (player, response);
    }
  }   

  if (applications[i]->type == "creator" ||  applications[i]->type == 
    "liaison") {
    PLAYERINFO_HANDLER->add_entry( this_object(), 
      applications[i]->name, "misc", "Applied to " 
        + applications[i]->domain + " domain." );  
  }
  else {
    PLAYERINFO_HANDLER->add_entry( player, 
      player->query_name(), "misc", "Applied as a " 
        + applications[i]->type+ "." );  
  }  
  
  mail_message (1, i);
  save_me();
  
  return post;
  
}

private void mail_message(int i, int j) {
  string ret = "";
  string mail;
  
  mail = "Greetings... this is an automated message from the "
    "" + mud_name() + " applications handler.\n\n$message$\n\n";
    
  switch (i) {
    case 0:
      ret = "You have not received the required number of vouches for "
        "your application for a " + applications[j]->type + " position "
        "within the specified time-frame.  Your application has been "
        "expired and if you wish to pursue further employment on the MUD "
        "you will need to resubmit an application.\n";
    break;
    case 1:
      ret = "You have received the required number of vouches for your "
        "application for a " + applications[j]->type + " position on the "
        "MUD.  Your application has been posted for consideration.  Thank "
        "you for your interest in pursuing employment within the MUD.\n";
    break;
  }            
  
  mail = replace (mail, ({"$message$", ret}));

  AUTO_MAILER->auto_mail( applications[j]->name, "Applications Procedure", 
    "Your " + applications[j]->type + " application", "",
    mail, 0, 0, 1 );
}

string list_applications() {
  string *ret = ({ });
  ret += ({"\n"});
  ret += ({"\n\n/---------------------------------------------------------------------------\\"});
  ret += ({sprintf ("| %|12s | %|12s | %|24s | %|2s  | %|10s |", 
  "Type", "Name", "Made At", "V", "Domain") });
  ret += ({"|---------------------------------------------------------------------------|"});

  for (int i = 0; i < sizeof (applications); i++) {
    ret += ({sprintf ("| %|12s | %|12s | %|s | %|2d  | %|10s |", 
    capitalize (applications[i]->type), 
      capitalize (applications[i]->name), ctime (applications[i]->time), 
        sizeof (applications[i]->vouches), 
        capitalize ((applications[i]->type == "creator" ? applications[i]->domain : 
        ""))) });
  }
  ret += ({"\\---------------------------------------------------------------------------/"});
  
  return implode (ret, "\n");
}

string *query_types() {
  return map (types, (: $1->type :));
}

int fix_name (string n, string n2) {
  int i;
  int c = 0;
  for (int j =0; j < sizeof (types); j++) {
    i = find_application (n, types[j]->type);
  
    if (i != -1) {
      applications[i]->name = n2;
      c++;
    }
  } 
  
  return c; 
}

string query_name() {
  return "Applications Handler";
}
// --- END [/mnt/home2/grok/lib/obj/handlers/applications_handler.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/weather.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/weather.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628296   Available: 13575650
Inodes: Total: 5242880    Free: 4960134
46473 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/weather.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628296   Available: 13575650
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: weather.c,v 1.32 2002/11/15 07:02:35 ceres Exp $
 * 
 */
/**
 * An attempt at a new weather handler for Discworld.
 * Ceres@Discworld 14/4/96
 *
 * Having thought about the way weather works (and Discworlds interesting
 * meteorology) I decided not to try and implement some model of realworld
 * weather. Instead regional variations in weather are handled by
 * regional climate properties. This system will handle diurnal and seasonal
 * variations and that's about it. Hopefully that will make it more
 * understandable, usable and efficient.<p>
 *
 * Basic Operation<br>
 * ---------------<br>
 * The weather is based on weather 'pattern's. The pattern lasts for several
 * hours and is calculated from the 'seasonal' norm and the 'variance'. The
 * 'current' weather will tend towards the pattern weather.<p>
 * 
 * The pattern depends on the climate. The climates are taken from the Koppen
 * Climate Classification system. The possible climates are:<br>
 * tropical<br>
 * - rainforest 'Af' eg. amazon, congo, malaysia<br>
 * - monsoon 'Am' <br>
 * - savanna 'Aw' eg. caribbean, tropical africa, central america<br>
 * desert<br>
 * - arid 'Bw'<br>
 * - semi-arid 'Bs' <br>
 * mediterranean (aka Moist Subtropical Mid-Latitude Climates)<br>
 * - humid subtropical 'Cfa' eg. Souteast US (florida)<br>
 * - mediterranean 'Cs' eg. california, south africa, western/central australia<br>
 * - marine 'Cfb' eg. US west coast, nw europe<br>
 * continental<br>
 * - dry winters 'Dw' <br>
 * - dry summers 'Ds'<br>
 * - wet 'Df'<br>
 * polar<br>
 * - tundra 'Et'<br>
 * - frozen 'Ef'<br>
 * highland 'H' <p>
 * 
 * The default for a room is mediterranean marine (Cfb).<p>
 * 
 * The actual temparture in a room will depend on the current weather for that
 * climate, local modifiers (climate property), diurnal variations and
 * variance.<p>
 *
 * Thus update_patttern() is called once every hour (CYCLE_SPEED) and
 * update_weather() is called every 5 minutes (UPDATE_SPEED).<p>
 *
 * Decisions<br>
 * ---------<br>
 * Calculation of the general weather has been moved into
 * update_weather. Rather than doing it on a room by room basis everytime
 * someone looks! Instead, local climate controls will be added verbatim to
 * the current global weather. This will improve efficiency massively, but will
 * reduce the overall weather variations.<p>
 *
 * Principles<br>
 * ----------<br>
 * Rain/sleet/snow depends on cloud density and temperature.<br>
 * If it's windy and lots of cloud density we might get a thunder storm.
 * Cloud cover should lower temperature as should wind.<p>
 *
 * Usage<br>
 * -----<br>
 * To alter the weather in a given room the easiest approach is to set the
 * climate. Individual room or area variations can be done by adding a
 * climate property.<br>
 * The property should contain three integers, temperature, cloud cover and
 * wind speed. These modify the default values for the room.<p>
 * For example:<br>
 * add_property("climate", ({10, -50, 0});<br>
 * This will increase the temperature by 10C, reduce the cloud cover
 * by 50% and make no change to the wind speed.<p>
 *
 * To completely alter the weather in a room you need to define the function
 * room_weather() as follows:<br>
 *   int *room_weather(int temp, int cloud, int wind, int rain);<br>
 * Your room_weather function will be called with the values the room would
 * ordinarily receive and should return the new temperature, cloud cover,
 * wind speed and rain type values that you desire.<p>
 *
 * If you need to make your room react to changes in the weather you can use
 * the weather_notify() system to be told when the weather changes.<br>
 * This should only be done for a small number of rooms or the lag will be
 * excessive.<p>
 *
 * Changed Jun 3 1996 by Grampa to include weather notifications for rooms.<p>
 * @index weather
 */
#include <climate.h>
#include <am_time.h>
#include <weather.h>

#define FILE_NAME "/save/nweather"
#define UPDATE_SPEED 300
#define CYCLE_SPEED  3600
#define DIY 400

// return the difference between two numbers.
#define DIF(x, y) (x > y) ? (x-y) : (y-x)

// this is the basic state of the weather. The local climate properties are
// then applied to these numbers, followed by the time of day and year to
// give us the actual weather right now.

// temp is the temperature in celcius.
// cloud is the amount of cloud cover. 100 is total cloud cover. >100 the
//          cloud gets denser and denser. Denser cloud makes rain more likely.
// windsp is the wind speed in mph.

// underlying temp etc.
private mapping _pattern;

// the current global values of temp etc.
private mapping _current;

// how much global variance do we want?
private int *_variance;

// Rooms to notify about weather changes.
// Keys are rooms, values are notification values.  Used so there will be
// no duplicates.
private nosave mapping _rooms;

private nosave int _lastupdate;
private nosave int _day;
private nosave int _sunrise;
private nosave int _sunset;
private nosave int _toy;
private int mooncycle;
private int moonupdate;

void set_day();
void update_pattern();
int calc_actual(object env, int type);
int cloud_index(object env);
int query_day(object env);
int query_rain_type(int temp, int rain);
string sun_direction(int which);
int temperature_index(object env);
int rain_index(object env);

/* Interface Functions (ones called from outside) */
/** @ignore yes */
void create() {
  string str;

  _rooms = ([ ]);
  
  unguarded((: restore_object, FILE_NAME :));

  if(!_pattern)
    _pattern = ([ ]);
  if(!_current)
    _current = ([ ]);
  if(!_variance)
    _variance = ({ 10, 75, 20 });
  foreach(str in CLIMATES) {
    if(!_pattern[str])
      _pattern[str] =  ({ 0, 0, 0 });
    if(!_current[str])
      _current[str] =  ({ 0, 0, 0 });
  }

  call_out("update_weather", UPDATE_SPEED);
  set_day();
  update_pattern();

}

/**
 * Add a room to the list of rooms to notify about weather.  Notifications
 * are an ORed (|) combination of the #defines in /include/climate.h
 * IE: To inform about temperature and rain changes, call
 * weather_notify( room, (NOTIFY_TEMPERATURE | NOTIFY_RAIN) );
 *
 * @param which_room the room to be notified
 * @param notifications a bitmap of notifications
 * @return success or failure (1 or 0)
 */
int weather_notify( object which_room, int notifications ) {
  if(notifications < 0 || notifications >
     (NOTIFY_TEMPERATURE | NOTIFY_CLOUD | NOTIFY_RAIN | NOTIFY_DAY)) {
    return 0;
  }

  _rooms[which_room] = notifications;
  return 1;
}

/** @ignore yes */
void test_notifications() {
  object room;
  string w;

  foreach( room in keys(_rooms)) {
    w = sprintf("%O notified of %s%s%s%s\n", room,
    ((_rooms[room] & NOTIFY_TEMPERATURE) ? "Temperature " : ""),
                ((_rooms[room] & NOTIFY_CLOUD) ? "Clouds " : ""),
                ((_rooms[room] & NOTIFY_RAIN) ? "Rain " : ""),
                ((_rooms[room] & NOTIFY_DAY) ? "Day" : ""));
    write( w );
  }
  write("test_notifications() done\n");
}

/**
 * Find out which day of the Disc (common) year it is.
 * @return the day of the year.
 */
int day_number() {
  return ( time() % AM_SECONDS_PER_HALF_YEAR ) / AM_SECONDS_PER_DAY;
}

/**
 * Find out which minute of the day (0 - 1439) it is.
 * @return the minute.
 */
int minute_number() {
  return (( time() % AM_SECONDS_PER_DAY ) / AM_SECONDS_PER_MINUTE);
}

/** 
 * Get the appropriate moon string. This is almost completely from the old
 * system. I don't understand the moon.
 *
 * @param env the room to check
 * @return the moon string.
 */
string query_moon_string(object env) {
  string str;

  // New, simplified moon string stuff
  if(mooncycle > 10)
    return "It is night and there is no moon.\n";
  
  if(calc_actual(env, CLOUD) > 70)
    str = "It is night and the %s is hidden by the clouds.\n";
  else if(env && env->query_water())
    str = "The water is lit up by the eerie light of the %s.\n";
  else
    str = "The land is lit up by the eerie light of the %s.\n";

  return sprintf(str, ({"waxing crescent moon",
                        "waxing quarter moon",
                        "waxing half moon",
                        "waxing three quarter moon",
                        "waxing gibbous moon",
                        "full moon",
                        "waning gibbous moon",
                        "waning three quarter moon",
                        "waning half moon",
                        "waning quarter moon",
                        "waning crescent moon",
                        "no moon",
                        "no moon",
                        "no moon",
                      })[mooncycle]);
}

/**
 * Query the state of the moon.
 *
 * @return an integer indicating the state of the moon.
 * 0 - no moon, 1 - crescent, 2 - quarter, 3 - half, 4 - three quarter,
 * 5 - gibbous, 6 - full.
 */
int query_moon_state() {
  if(mooncycle < 6)
    return mooncycle+1;
  if(mooncycle < 11)
    return (11 - mooncycle);
  return 0;
}

/**
 * Find out which phase of the moon we're currently in.
 *
 * @return a string for the phase of the moon.
 */
string query_moon_phase() {
  return ({"crescent",
           "quarter",
           "half",
           "three quarter",
           "gibbous",
           "full",
           "gibbous",
           "three quarter",
           "half",
           "quarter",
           "crescent",
           "",
           "",
           "",
         })[mooncycle];
}

/**
 * Return the number of currently visible stars as a percentage.
 * @return A number 0-100, 0 being no stars.
 */
int query_stars( object env ) {
    int clouds, stars ;
    
    clouds = cloud_index(env) ;
    
    // No stars in the daytime, or when it's overcast.
    if ( query_day(env) || clouds > 70 ) {
        return 0 ;
    }
    
    switch( clouds ) {
        case 0:
            stars = 100 ;
            break ;
        case 1..39:
            stars = 80 ;
            break ;
        case 40..59:
            stars = 40 ;
            break ;
        case 60..69:
            stars = 20 ;
            break ;
        default:
            stars = 10 ;
            break ;
    }
    
    return stars ;
}

/**
 * Returns a string describing the current visible stars.
 * @return a string for the visible stars.
 */
string query_star_string( object env ) {
    string str ;
    
    if ( query_day(env) ) {
        return "There are no stars visible during the day.\n" ;
    }
    
    switch( query_stars(env) ) {
        case 1..20:
            str = "one or two bright stars" ;
            break ;
        case 21..40:
            str = "a few stars" ;
            break ;
        case 41..60:
            str = "quite a few stars" ;
            break ;
        case 61..80:
            str = "lots of stars" ;
            break ;
        case 81..100:
            str = "countless stars" ;
            break ;
        default:
            str = "no stars" ;
            break ;
    }
    
    return "Tonight, there are " + str + " visible.\n" ;
}

/**
 * Return which of the 4 seasons we are in.
 * @return spring, summer, autumn or winter.
 */
string query_season() {
  switch(day_number()) {
  case 0..50: return "winter";
  case 51..150: return "spring";
  case 151..250: return "summer";
  case 251..350: return "autumn";
  case 351..400: return "winter";
  }
}

/**
 * Return a string for the period of the day
 *
 * @return night, morning, midday, afternoon or evening.
 */
string query_tod() {
  if((minute_number() < _sunrise) || (minute_number() > _sunset))
    return "night";
  switch(minute_number()) {
  case 0..700:
    return "morning";
  case 701..740:
    return "midday";
    break;
  case 741..1080:
    return "afternoon";
    break;
  default:
    return "evening";
  }
}

/** @ignore yes */
int query_day(object env) {
  return _day;
}

/**
 * return percentage of light
 * should be dependant on the base amount of light, day or night time and
 * cloud cover.
 *
 * @param the room
 * @return a percentage
 */
int query_darkness(object env) {
  int result, cloud, day;

  result = 10;
  day = query_day(env);
  
  if(day == 10)
    return 100;

  if(mooncycle <= 10) {
    if(mooncycle < 6)
      result += mooncycle * 10;
    else
      result += (5 - (mooncycle % 6)) * 10;
    }
  
  // now reduce this for cloud cover
  if((cloud = cloud_index(env)) > 0)
    result -= (cloud_index(env) / 15);
  if(result < 0)
    result = 0;

  if(day > 0)
    result += (100 - result) / (10 - day);

  return result;
}

/**
 * return percentage of visibility.
 * It should also depend on things like rain/snow etc, anything which
 * will effect visibility.
 *
 * @param the room
 * @return a percentage
 */
int query_visibility(object env) {
  int result;
  int temp;
  int rain;
  int rt;

  // This has to work in conjunction with darkness.
  result = 100;

  temp = temperature_index(env);
  rain = rain_index(env);
  rt = query_rain_type(temp, rain);

  if (rt ==  WEATHER_SNOW_TYPE) {
     // Snow decreases visibility a lot.
     rain += 50;
  } else if (rt == WEATHER_SLEET_TYPE) {
     // Sleet decreases visbility a bit.
     rain += 20;
  }

  if (rain > 0) {
     if (rain > 100) {
        result = 0;
     } else {
        result = (result * (100 - rain)) / 100;
     }
  }

  return result;
}

/** @ignore yes */
int calc_actual(object env, int type) {
  int *clim;
  string climate;

  if(env) {
    climate = env->query_climate();
    clim = (int *)env->query_property("climate");   
  }
  
  if(!climate)
    climate = DEFAULT_CLIMATE;
  
  if(!clim)
    return _current[climate][type];
  
  return _current[climate][type] + clim[type];
}

/** @ignore yes */
int temperature_index(object env) {
  int temp, tod, j, diurnal;
  string climate;
  temp = calc_actual(env, TEMP);

  if(env)
    climate = env->query_climate();
  
  if(!climate)
    climate = DEFAULT_CLIMATE;
  
  // gives us a number between 0 (midday) and 10 (night)
  tod = 10 - query_day(env);

  // add diurnal variations to temperature
  if(tod) {
    switch(climate) {
    case "Af":
    case "Am":
    case "Aw":
      diurnal = 10;
      break;
    case "Bw":
    case "Bs":
      // The hotter the days, the colder the nights.
      diurnal = 15 + (_pattern[climate][0] / 2);
      break;
    case "Cfa":
    case "Cs":
    case "Cfb":
    case "Dw":
    case "Ds":
    case "Df":
      diurnal = 15;
      break;
    case "Et":
    case "Ef":
    case "H":
      diurnal = 20;
      break;
    }

    // subtract from the temperature dependant on time of day and variance.
    temp -= (diurnal * tod) / 10;
  }

  // lower temperature dependant on cloud cover
  j = sqrt(_current[climate][CLOUD]);
  if(j < 0)
    j = 0;

  // when its cold clouds tend to raise the temperature at night
  // when its hot clouds tend to decrease the temperature during the day
  if(temp < 10 && tod == 10)
    temp += j;
  else if(temp > 30 && !tod)
    temp -= j;

  // lower temperature dependant on wind speed
  temp -= sqrt(_current[climate][WINDSP]);

  return temp;
}

/** @ignore yes */
int cloud_index(object env) {
  int cloud;

  cloud = calc_actual(env, CLOUD);
  if(cloud < 0)
    cloud = 0;
  return cloud;
}

/** @ignore yes */
int rain_index(object env) {
  int rain;

  rain = calc_actual(env, CLOUD) - (calc_actual(env, TEMP) / 2) - 100;
  return (rain > 0)? rain : 0;
}

/**
 * Return a temperature string equating to the temperature passed
 * @param int The temperature in Celcius
 * @return string a temperature string.
 */
string temp_string(int temp) {
  // lets start with the temperature since a lot of stuff falls out from that.
  switch(temp) {
    case 51..1000: return "incredibly, unbelievably hot"; break;
    case 46..50: return "amazingly hot"; break;
    case 41..45: return "damn hot"; break;
    case 36..40: return "very hot"; break;
    case 31..35: return "hot"; break;
    case 26..30: return "reasonably hot"; break;
    case 23..25: return "very warm"; break;
    case 20..22: return "warm"; break;
    case 16..19: return "pleasantly warm"; break;
    case 13..15: return "cool"; break;
    case 10..12: return "slightly chilly"; break;
    case 7..9: return "chilly"; break;
    case 4..6: return "very chilly"; break;
    case 1..3: return "cold"; break;                 
    case -3..0: return "very cold"; break;
    case -10..-4: return "freezing cold"; break;
    case -20..-11: return "damn cold"; break;
    case -30..-21: return "dangerously cold"; break;
    case -50..-31: return "incredibly, unbelievably cold"; break;
  }
}

private string precipitation_string(int rain, int rt, int wind) {
  switch(rain) {
  case -1000..20:
    return "lightly";
    break;
  case 21..40:
    if(wind < 20) {
      return "steadily";
    } else {
      return "hard";
    }
    break;
  case 41..60:
    return "heavily";
    break;
  case 61..500:
    if(rt == WEATHER_RAIN_TYPE) {
      return "torrentially";
    } else {
      return "very heavily";
    }
    break;
  }
}

/**
 * Creates a string showing how heavily it is raining.
 * @return the rain string
 * @param env the room room to check in
 */
string rain_string(object env) {
  int rt, rain, wind, temp;

  temp = temperature_index(env);
  rain = rain_index(env);
  rt = query_rain_type(temp, rain);
  if (rt != WEATHER_RAIN_TYPE) {
    return "There is no rain";
  }
  
  return "It is raining " + precipitation_string(rain, rt, wind);
}

/**
 * Creates a string showing how heavily it is snowing.
 * @return the snow string
 * @param env the room room to check in
 */
string snow_string(object env) {
  int rt, rain, wind, temp;

  temp = temperature_index(env);
  rain = rain_index(env);
  rt = query_rain_type(temp, rain);
  if (rt != WEATHER_SNOW_TYPE) {
    return "There is no snow";
  }
  return "It is snowing " + precipitation_string(rain, rt, wind);
}

/**
 * Creates a string showing how heavily it is sleeting.
 * @return the sleet string
 * @param env the room room to check in
 */
string sleet_string(object env) {
  int rt, rain, wind, temp;

  temp = temperature_index(env);
  rain = rain_index(env);
  rt = query_rain_type(temp, rain);
  if (rt != WEATHER_SLEET_TYPE) {
    return "There is no sleet";
  }
  return "It is sleeting " + precipitation_string(rain, rt, wind);
}

/**
 * A string giving a nice description of the cloud types.
 * @param env the environment to find the clouds for
 * @return the current clouds
 */
string cloud_string(object env) {
  int cloud;
  string str;

  cloud = cloud_index(env);
  switch(cloud) {
    case -1000..5:
       str = "a beautifully clear sky";
       break;
    case 6..10:
       str = "a few high level cirrus clouds";
       break;
    case 11..25:
       str = "scattered puffy clouds";
       break;
    case 26..40:
       str = "some puffy clouds";
       break;
    case 41..60:
       str = "many puffy clouds";
       break;
    case 61..80:
       str = "medium cloud cover";
       break;
    case 81..110:
       str = "dense cloud cover";
       break;
    case 111..130:
       str = "packed cloud cover";
       break;
    case 131..160:
       str = "thick black clouds";
       break;
    case 161..1000:
       str = "thick heavy storm clouds";
       break;
  }
  return str;
}

/**
 * Creates the weather string which is put into room descs.
 */
varargs string weather_string(object env, string obscured) {
  int temp, cloud, wind, rain, rt;
  int *warray;
  string str, tstr;

   if ( !env ) 
     return 0;
  temp = temperature_index(env);
  cloud = cloud_index(env);
  wind = calc_actual(env, WINDSP);
  rain = rain_index(env);

  if(function_exists("room_weather", env) &&
     !catch(warray = (int *)env->room_weather(temp, cloud, wind, rain))) {
    temp = warray[0];
    cloud = warray[1];
    wind = warray[2];
    rain = warray[3];
  }
  
  rt = query_rain_type(temp, rain);

  str = "It is ";
  tstr = temp_string(temp);
  switch(tstr[0]) {
  case 'a':
  case 'e':
  case 'i':
  case 'o':
  case 'u':
    str += "an ";
    break;
  default:
    str += "a ";
  }
  str += tstr + " ";
    
  switch((time() % (AM_SECONDS_PER_HALF_YEAR*2)) / AM_SECONDS_PER_DAY) {
  case 51..150:
    str += "spring prime";
    break;
  case 151..250:
    str += "summer prime";
    break;
  case 251..350:
    str += "autumn prime";
    break;
  case 351..450:
    str += "spindlewinter";
    break;
  case 451..550:
    str += "secundus spring";
    break;
  case 551..650:
    str += "secundus summer";
    break;
  case 651..750:
    str += "secundus autumn";
    break;
  default:
    str += "backspindlewinter";
  }

  str += "'s "+ query_tod() +" with ";

  switch(wind) {
    case -1000..5: str += "almost no wind"; break;
    case 6..10: str += "a gentle breeze"; break;
    case 11..15: str += "a steady breeze"; break;
    case 16..20: str += "a strong breeze"; break;
    case 21..30: str += "a steady wind"; break;
    case 31..40: str += "gusty winds"; break;
    case 41..50: str += "strong winds"; break;
    case 51..60: str += "gale-force winds"; break;
    case 61..1000: str += "storm-force winds"; break;
    default: str += "no wind at all"; break;
  }

  if (!obscured) {
    if(rain)
      str += ", ";
    else
      str += " and ";

    switch(cloud) {
      case -1000..5: str += "a beautifully clear sky"; break;
      case 6..10: str += "a few high level cirrus clouds"; break;
      case 11..25: str += "scattered puffy clouds"; break;
      case 26..40: str += "some puffy clouds"; break;
      case 41..60: str += "many puffy clouds"; break;
      case 61..80: str += "medium cloud cover"; break;
      case 81..110: str += "dense cloud cover"; break;
      case 111..130: str += "packed cloud cover"; break;
      case 131..160: str += "thick black clouds"; break;
      case 161..1000: str += "thick heavy storm clouds"; break;
    }
  }

  if(rain) {
    str += " and ";
    switch(rain) {
      case -1000..20: str += "light"; break;
      case 21..40:
        if(wind < 20)
          str += "steady";
        else
          str += "driving";
      break;
      case 41..60: str += "heavy"; break;
      case 61..500:
        if(rt == WEATHER_RAIN_TYPE)
          str += "torrential";
        else
          str += "very heavy";
      break;
    }

    str += " ";

    str += ({"", "snow", "sleet", "rain"})[rt];
  }

  if (obscured) {
    str += ".  " + obscured;
  }
  if((rain > 20) && (wind > 30)) {
    if (obscured)
      str += ".\nPeals of thunder echo overhead";
    else
      str += ".\nPeals of thunder and streaks of lightning rend the sky";
  }

  return str;
}

/** @ignore yes */
int next_update() {
  return _lastupdate + UPDATE_SPEED;
}

/** @ignore yes */
void dest_me() {
  unguarded((: save_object, FILE_NAME :));
}

/** @ignore yes */
int query_rain_type(int temp, int rain) {
  int type;

  if (rain > 0)
    switch(temp) {
    case -1000..-2:
      type = WEATHER_SNOW_TYPE;
      break;
    case -1..3:
      type = WEATHER_SLEET_TYPE;
      break;
    case 4..1000:
      type = WEATHER_RAIN_TYPE;
      break;
    }
  else
    type = WEATHER_NO_RAIN_TYPE;
  return type;
}

/**
 * Find out if its snowing in a given room.
 *
 * @param env the room
 * @return 1 or 0 for true or false.
 */
int query_snowing(object env) {
  int *warray;
  
  if(!env)
    return 0;

  if(function_exists("room_weather", env) &&
     !catch(warray = (int *)env->room_weather(temperature_index(env),
                                              cloud_index(env),
                                              calc_actual(env, WINDSP),
                                              rain_index(env))))
    return (query_rain_type(warray[0], warray[3]) == WEATHER_SNOW_TYPE)? 1 : 0;

  return (query_rain_type(temperature_index(env),
                          rain_index(env)) == WEATHER_SNOW_TYPE) ? 1 : 0;
}

/**
 * Find out if its raining in a given room.
 *
 * @param env the room
 * @return 1 or 0 for true or false.
 */
int query_raining(object env) {
  int *warray;
  
  if(!env)
    return 0; 

  if(function_exists("room_weather", env) &&
     !catch(warray = (int *)env->room_weather(temperature_index(env),
                                              cloud_index(env),
                                              calc_actual(env, WINDSP),
                                              rain_index(env))))
  {
    return (query_rain_type(warray[0], warray[3]) > WEATHER_SNOW_TYPE) ? 1 : 0;
  }

  return (query_rain_type(temperature_index(env),
                          rain_index(env)) > WEATHER_SNOW_TYPE) ? 1 : 0;
}

/**
 * Find out the temperature of a given room
 *
 * @param env the room
 * @return a temperature in Celcius
 */
int query_temperature(object env) {
  int *warray;

  if(!env)
    return 0;
  
  if(function_exists("room_weather", env) &&
     !catch(warray = (int *)env->room_weather(temperature_index(env),
                                              cloud_index(env),
                                              calc_actual(env, WINDSP),
                                              rain_index(env))))
    return warray[0];

  return temperature_index(env);
}

/**
 * Find out the cloud cover of a given room
 *
 * @param env the room
 * @return an open ended percentage. Greater than 100 means heavier cover.
 */
int query_cloud(object env) {
  int *warray;

  if(!env)
    return 0;
  
  if(function_exists("room_weather", env) &&
     !catch(warray = (int *)env->room_weather(temperature_index(env),
                                              cloud_index(env),
                                              calc_actual(env, WINDSP),
                                              rain_index(env))))
    return warray[1];

  return cloud_index(env);
}

/**
 * Find out the wind speed in a given room
 *
 * @param env the room
 * @return the wind speed in miles per hour.
 */
int query_windsp(object env) {
  int *warray;
  
  if(!env)
    return 0;

  if(function_exists("room_weather", env) &&
     !catch(warray = (int *)env->room_weather(temperature_index(env),
                                              cloud_index(env),
                                              calc_actual(env, WINDSP),
                                              rain_index(env))))
    return warray[2];

  return calc_actual(env, WINDSP);
}

/** @ignore yes */
int calc_variance(string climate, int type, int seasonal) {
  int diff, ret;

  diff = seasonal - _pattern[climate][type];
  if(diff < 0)
    ret = - random(diff * 2);
  else
    ret = random(diff * 2);

  if(random(2))
    ret += random(_variance[type]);
  else
    ret -= random(_variance[type]);
  
  return ret;
}

// basic system is for a 6am sunrise and 6pm _sunset.
// Days get longer until midsummer and shorter after it.
// I guess it's not really sunrise or sunset it's when it gets dark/light.
/** @ignore yes */
void set_day() {
  int min;
  
  // time of year. Climbs to 200 at mid-summer and then falls to year end
  _toy = (day_number() < (DIY / 2)) ? day_number() :
  (DIY / 2) - (day_number() % (DIY / 2));

  min = minute_number(); // the minute of the day

  _sunrise = 6 * AM_MINUTES_PER_HOUR;  // 6am the base sunrise time
  _sunset = 20 * AM_MINUTES_PER_HOUR;  // 8pm the base sunset time

  _sunrise += (100 - _toy);
  _sunset -= (100 - _toy);

  if((min <= _sunrise) || (min >= _sunset))
    _day = 0;
  else {
    // as it nears sunrise or sunset the light should fail so have the day
    // value drop in the last 100 minutes.
    if((min > _sunrise) && (min < _sunrise + 30))
      _day = (min-_sunrise) / 3;
    else if((min < _sunset) && (min > _sunset - 30))
      _day = (_sunset-min) / 3;
    else
      _day = 10;
  }
}

// change the current weather of type TYPE so that it becomes more like
// the pattern.
/** @ignore yes */
void migrate(string climate, int type) {
  int diff;

  diff = _pattern[climate][type] - _current[climate][type];
  if(diff > (_variance[type] / 2))
    diff = _variance[type] / 2;

  if(diff < 0)
    _current[climate][type] -= random(random(-diff));
  else
    _current[climate][type] += random(random(diff));
}

int check_umbrella(object ob) {
  if ( ob )
    return (int)ob->query_property( "umbrella" );
  return 0;
}

// send weather events to users
/** @ignore yes */
void do_inform(object who, int old_temp, int old_cloud, int old_rain,
               int old_day) {
  string str, where;
  int new_temp, new_cloud, new_wind, new_rain;
  int old_rain_type, new_rain_type;
  int *warray;

  new_temp = temperature_index(environment(who));
  new_rain = rain_index(environment(who));
  new_wind = calc_actual(environment(who), WINDSP);
  new_cloud = cloud_index(environment(who));

  if(function_exists("room_weather", environment(who)) &&
     !catch(warray = (int *)environment(who)->room_weather(new_temp, new_cloud,
                                                   new_wind, new_rain))) {
    new_temp = warray[0];
    new_cloud = warray[1];
    new_wind = warray[2];
    new_rain = warray[3];
  }

  if(who->query_name() == "ceres")
    tell_object(who, sprintf("%s: ot %d, or: %d, oc: %d, "
                             "nt %d, nr: %d, nc: %d, nw: %d",
                             who->query_name(), 
                             old_temp, old_rain, old_cloud, new_temp,
                             new_rain, new_cloud, new_wind));
  
  old_rain_type = query_rain_type(old_temp, old_rain);
  new_rain_type = query_rain_type(new_temp, new_rain);

  str = "";
  
  // sunrise and set messages
  if(_day != old_day) { // this test not needed, but should improve efficiency
    where = sun_direction( 1 ); /* sunset */
    if((old_day == 10)  && (_day < 10))
      str += "The sun starts to set slowly on the "+where+" horizon.\n";
    else if((old_day > 0) && (_day == 0))
      str += "The sun disappears from view below the "+where+" horizon.\n";
    else if((old_day > _day) && (_day < 9) && (_day > 0))
      str += "The sun sinks further below the "+where+" horizon.\n";

    where = sun_direction( 0 ); /* sunrise */
    if((_day > 0) && (old_day == 0))
      str += "The "+where+" sky starts to lighten as the sun peeks over the "+
        "horizon.\n";
    else if((_day == 10) && (old_day < 10))
      str += "The sun rises above the "+where+" horizon and greets you "+
        "for a new day.\n";
    else if((_day > old_day) && (_day < 9) && (_day > 0))
      str += "The sun rises further above the "+where+" horizon lightening "+
        "the sky as morning arrives.\n";
  }
  
  // clouds hiding the sun messages
  // in the 25-60 region the sun comes and goes quite a lot 
  if(_day && (old_cloud != new_cloud)) {
    if((old_cloud < 60) && (new_cloud > 20) && (!(new_cloud % 2)))
      str += "The " + query_tod()+ " sun disappears behind a cloud.\n";
    else if((old_cloud > 20) && (new_cloud < 60) && (new_cloud % 2))
      str += "The " + query_tod() + " sun peeks out from behind a cloud.\n";
  }

  // rain change messages
  if(old_rain_type != new_rain_type) {
    str += ({"", "It has stopped snowing", "It has stopped sleeting",
             "It has stopped raining"})[old_rain_type];
    if(old_rain_type && new_rain_type)
      str += " and started ";
    else if(new_rain_type)
      str += "It has started ";
    str += ({"", "snowing", "sleeting", "raining"})[new_rain_type];
    str += ".\n";
  } else if(new_rain_type > 0)
    str += "The "+({"", "snow", "sleet", "rain"})[new_rain_type]+
      " continues to fall.\n";

  // get them wet
  if(new_rain_type)
    if((!sizeof(filter_array(who->query_holding(), "check_umbrella",
                            this_object())) &&
       !sizeof(filter_array(who->query_wearing(), "check_umbrella",
                          this_object()))) || !random(50))
    {
      who->add_effect("/std/effects/other/wetness",
                      ((new_rain * new_rain_type) / 2) * (UPDATE_SPEED/60));
    }

  // tell them the output
  if(str != "")
    tell_object(who, who->colour_event("weather", "%^ORANGE%^")+str+
                "%^RESET%^");
}

// 0 for sunrise, 1 for sunset. Seasons in comments are for sunrise.
/** @ignore yes */
string sun_direction(int which) {
  switch(((time()+(AM_SECONDS_PER_HALF_YEAR * which)) %
          (AM_SECONDS_PER_HALF_YEAR*2)) / AM_SECONDS_PER_DAY) {
  case 0..174: // backspindle winter, spring prime, summer one
    return "widdershins";
  case 175..225: // summer one - small gods day
    return "hubwards";
  case 226..574: // summer one & two, autumn prime, spindlewinter,
                 //secundus spring
    return "turnwise";
  case 575..625: // summer two - alls falow
    return "rimward";
  default: //summer two, secundus autumn, backspindlewinter
    return "widdershins";
  }
}

// Send notifications to rooms
/** @ignore yes */
void do_room_inform(object what, int old_temp, int old_cloud, int old_rain,
        int old_day, int notifications) {
  int new_cloud, new_rain, new_wind, new_temp;
  int *warray;
  int has_changed = 0;

  new_temp = temperature_index(what);
  new_cloud = cloud_index(what);
  new_wind = calc_actual(what, WINDSP);
  new_rain = rain_index(what);

  if(function_exists("room_weather", what) && 
     !catch(warray = (int *)what->room_weather(new_temp, new_cloud,
                                       new_wind, new_rain))) {
    new_temp = warray[0];
    new_cloud = warray[1];
    new_wind = warray[2];
    new_rain = warray[3];
  }

  // Look at what's changed, and if the room wishes to be notified of those
  // changes.
  if(_day != old_day && (notifications & NOTIFY_DAY)) 
    has_changed += NOTIFY_DAY;
  if(old_temp != new_temp && (notifications & NOTIFY_TEMPERATURE))
    has_changed += NOTIFY_TEMPERATURE;
  if(old_cloud != new_cloud && (notifications & NOTIFY_CLOUD))
    has_changed += NOTIFY_CLOUD;
  if(old_rain != new_rain && (notifications & NOTIFY_RAIN))
    has_changed += NOTIFY_RAIN;

  // Now has_changed carries everything that has changed.  IE: If the clouds
  // and rain have changed,
  // has_changed = NOTIFY_CLOUD + NOTIFY_RAIN = NOTIFY_CLOUD | NOTIFY_RAIN
  // I like bitwise ORs and ANDs :) - Grampa
  if(has_changed) {
    // Using a call out to try to avoid bogging down should there be
    // a large amount of rooms who change a lot on weather notifications.
    call_out( "notify_room", 1, what, has_changed,
      _day, new_temp, new_cloud, new_rain );
  }
}

/** @ignore yes */
void notify_room( object what, int has_changed,
  int day, int temp, int cloud, int rain)
{
  // The room will have to query the changes, but it will know WHAT has
  // changed by ORing has_changed.  IE: If
  // (has_changed | NOTIFY_TEMPERATURE) == 1 then temperature has changed.
  // If it == 0, temperature has not changed.
  if(what)
    what->event_weather( has_changed, day, temp, cloud, rain);
}

/**
 * Find out when sunrise will be on a given day of the year.
 *
 * @param doy Day of the Discworld common year.
 * @return sunrise time (in seconds past midnite).
 * @see minute_number()
 * @see day_number()
 */
int query_sunrise(int doy) {
  int toy;

  toy = (doy < (DIY / 2)) ? doy : (DIY / 2) - (doy % (DIY / 2));
  return (6 * AM_MINUTES_PER_HOUR) + (100 - toy);
}

/**
 * Find out when sunset will be on a given day of the year.
 *
 * @param doy Day of the Discworld common year.
 * @return sunset time (in seconds past midnite).
 */
int query_sunset(int doy) {
  int toy;
  
  toy = (doy < (DIY / 2)) ? doy : (DIY / 2) - (doy % (DIY / 2));
  return (20 * AM_MINUTES_PER_HOUR) - (100 - toy);
}

/* Operational Functions (the ones that control everything) */

// set our target underlying temperature, cloudiness etc. for this cycle
// this target is for Ankh-Morpork. Other areas of the Disc set their variance
// from this "norm" by adding a property to the room.
// this function is called once every few hours so it's ok to be longish
/** @ignore yes */
void update_pattern() {
  int toy, temp, wind, cloud, tvar, wvar, cvar;
  string climate;
  
  call_out("update_pattern", CYCLE_SPEED);

  // time of year. Climbs to 200 at mid-summer and then falls to year end
  toy = (day_number() < (DIY / 2)) ? day_number() :
    (DIY / 2) - (day_number() % (DIY / 2));

  foreach(climate in CLIMATES) {
    switch(climate) {
    case "Af": // tropical rainforest
      temp = 30 + (toy / 40); // 30 - 35
      cloud = 50 + random(100);
      wind = random(10);
      break;
    case "Am": // tropical monsoon
      temp = 30 + (toy / 20); // 25 - 35
      cloud = -25 + sqrt(toy) * 10; // -25 - 115, rainy in the summer!
      wind = random(10);
      break;
    case "Aw": // tropical savannah
      temp = 20 + (toy / 10); // 20 - 40
      cloud = toy - 50; // -50 - 150, rainy in the summer!
      wind = random(10);
      break;

    case "Bw": // arid desert
      temp = 30 + (toy / 20); // 30 - 50
      cloud = (100 - toy/2) - 50; // -50 - 50, virtually never rains
      wind = random(10);
      break;
    case "Bs": // semi-arid desert
      temp = 25 + (toy / 20); // 25 - 45
      cloud = ((200 - toy) / 2) - 12; // -13 - 82
      wind = random(10);
      break;
      
    case "Cfa": // humid sub-tropical
      temp = (toy / 8) + 15; // 10 - 35
      cloud = ((225 - toy) / 2) - 25; // 0 - 100
      wind = 10 - (toy / 8);
      break;
      
    case "Cs": // mediterranean
      temp = (toy / 12) + 10; // 10 - 27
      cloud = ((225 - toy) / 2) - 50; // -25 - 75
      wind = 10 - (toy / 8);
      break;
    case "Cfb": // marine west coast (west coast us, 
      temp = (toy / 6) - 5; // -5 & +28 (celcius)
      cloud = ((225 - toy) / 2) - 25; // -12 - 87
      wind = 10 - (toy / 8);
      break;

    case "Dw": // continental dry, cold winters
      temp = (toy / 5) - 10; // gives us a no. between -10 & +30 (celcius)
      cloud = toy / 2; // 100 - 0
      wind = 15 - (toy / 8);
      break;
    case "Ds": // continental wet, cold winters
      temp = (toy / 5) - 10; // gives us a no. between -10 & +30 (celcius)
      cloud = (200 - toy) / 2; // 0 - 100
      wind = 15 - (toy / 8);
      break;
    case "Df": // continental, wet all the time. :)
      temp = (toy / 5) - 10; // gives us a no. between -10 & +30 (celcius)
      cloud = ((200 - toy) / 4) + 50; // 50 - 100
      wind = 15 - (toy / 8);
      break;
      
    case "Et": // tundra (permanently frozen)
      temp = (toy / 20) - 10;      // -10 - +0
      cloud = ((225 - toy) / 2) - 25; // 0 - 100
      wind = 25 - (toy / 8);
      break;
    case "Ef": // polar ice
      temp = (toy / 10) - 30;       // -30 - -10
      cloud = ((225 - toy) / 2) - 25; // 0 - 100
      wind = 25 - (toy / 8);
      break;
      
    case "H":
      temp = (toy / 10) - 10;      // -10 - +10
      cloud = ((225 - toy) / 2); // 20 - 125
      wind = 35 - (toy / 8);
      break;
    }


    tvar = calc_variance(climate, TEMP, temp);
    cvar = calc_variance(climate, CLOUD, cloud);
    wvar = calc_variance(climate, WINDSP, wind);

    _pattern[climate] =  ({ temp + tvar, cloud + cvar, wind + wvar });
  }
  unguarded((: save_object, FILE_NAME :));
}

// go through and update the moon and weather stuff.
// this function is called every UPDATE_SPEED seconds.
/** @ignore yes */
void update_weather() {
  int *warray, notifications;
  mapping list, roomlist, newrooms;
  object user, room;
  string climate;
  
  _lastupdate = time();
  call_out("update_weather", UPDATE_SPEED);

  // before we change it work out the weather where the outside players are
  // and store this information for use later.
  list = ([ ]);
  roomlist = ([ ]);
  foreach(user in filter(users(),
                         (: $1 && environment($1) &&
                          environment($1)->query_property("location") ==
                          "outside" :))) {
    // store the previous weather for a user.
    if(function_exists("room_weather", environment(user)) &&
       !catch(warray = (int *)environment(user)->room_weather(
                                 (int)temperature_index(environment(user)),
                                 (int)cloud_index(environment(user)),
                                 (int)calc_actual(environment(user), WINDSP),
                                 (int)rain_index(environment(user))))) {
      list[user] = ({ warray[0], warray[1], warray[3], _day});
    } else {
      list[user] = ({ (int)temperature_index(environment(user)),
                        (int)cloud_index(environment(user)),
                        (int)rain_index(environment(user)),
                        _day});
    }
  }
  
  newrooms = ([ ]);
  foreach (room, notifications in _rooms)  {
    if (room)
      newrooms[room] = notifications;
  }
  _rooms = copy(newrooms);

  // For rooms
  foreach(room, notifications in _rooms) {
    if(function_exists("room_weather", room) &&
       !catch(warray = (int *)room->room_weather((int)temperature_index(room),
                                                 (int)cloud_index(room),
                                               (int)calc_actual(room, WINDSP),
                                                 (int)rain_index(room) ))) {
      roomlist[room] = ({ warray[0], warray[1], warray[3], _day});
    } else {
      roomlist[room] = ({ (int)temperature_index(room),
                            (int)cloud_index(room),
                            (int)rain_index(room),
                            _day });
    }
  }

  // the mooncycle is updated every other day.
  if((moonupdate + (AM_SECONDS_PER_DAY * 2)) < time()) {
    mooncycle++;         // the moons phase changes each 
    mooncycle %= 14;
    moonupdate = time();
  }
  
  /* all current values will migrate towards their pattern values with some
     randomness thrown in for good measure. */
  
  // calculate the current temperature
  foreach(climate in CLIMATES) {
    migrate(climate, TEMP);
    migrate(climate, CLOUD);
    migrate(climate, WINDSP);
  }
  
  // see if the day has changed
  set_day();
  
  // housekeeping
  unguarded((: save_object, FILE_NAME :));

  // send appropriate messages to players who are outside
  foreach(user, warray in list) {
    do_inform(user, warray[0], warray[1], warray[2], warray[3]);
  }
  
  // send notifications to rooms.
  foreach(room, notifications in _rooms) {
      do_room_inform(room, roomlist[room][0], roomlist[room][1],
                     roomlist[room][2], roomlist[room][3], notifications);
      map_delete(_rooms, room);
  }
}

/* Debugging functions */
/** @ignore yes */
void print_stats(object here) {
  string climate, *weather;
  
  if(here)
    climate = here->query_climate();
  weather = ({ temperature_index(here), cloud_index(here),
                 calc_actual(here, WINDSP) });
  printf("Climate: %s toy: %d tod: %s [%d]\n"
         "here: %O\ncurrent: %O\npattern: %O\nvariance: %O\n",
         climate, _toy, query_tod(), 10 - query_day(here), weather,
         _current[climate], _pattern[climate], _variance);
  printf("Sunrise at: %d:%02d, sunset at: %d:%02d\n",
         _sunrise/60, _sunrise%60, _sunset/60, _sunset%60);
}

/** @ignore yes */
int *query_mooncycle() {
  return ({ mooncycle, 0});
}

/** @ignore yes */
void set_variance(int temp, int cloud, int wind) {
  _variance = ({temp, cloud, wind});
  unguarded((: save_object, FILE_NAME :));
}

/** @ignore yes */
// Reset the weather in case it's messed up.
void reset_weather() {
  int toy, temp, wind, cloud;
  string climate;

  // time of year. Climbs to 200 at mid-summer and then falls to year end
  toy = (day_number() < (DIY / 2)) ? day_number() :
    (DIY / 2) - (day_number() % (DIY / 2));

  foreach(climate in CLIMATES) {
    switch(climate) {
    case "Af": // tropical rainforest
      temp = 25 + (toy / 40);
      cloud = 50 + random(100);
      wind = random(10);
      break;
    case "Am": // tropical monsoon
      temp = 20 + (toy / 20); // 20 - 30
      cloud = -25 + sqrt(toy) * 10; // -25 - 115, rainy in the summer!
      wind = random(10);
      break;
    case "Aw": // tropical savannah
      temp = 20 + (toy / 20); // 20 - 30
      cloud = toy - 50; // -50 - 150, rainy in the summer!
      wind = random(10);
      break;

    case "Bw": // arid desert
      temp = 30 + (toy / 20); // 30 - 50
      cloud = (100 - toy/2) - 50; // -50 - 50, virtually never rains
      wind = random(10);
      break;
    case "Bs": // semi-arid desert
      temp = 25 + (toy / 20); // 25 - 45
      cloud = ((200 - toy) / 2) - 12; // -13 - 82
      wind = random(10);
      break;
      
    case "Cfa": // humid sub-tropical
      temp = (toy / 8) + 15; // 10 - 35
      cloud = ((225 - toy) / 2) - 25; // 0 - 100
      wind = 10 - (toy / 8);
      break;
      
    case "Cs": // mediterranean
      temp = (toy / 12) + 10; // 10 - 27
      cloud = ((225 - toy) / 2) - 50; // -25 - 75
      wind = 10 - (toy / 8);
      break;
    case "Cfb": // marine west coast (west coast us, 
      temp = (toy / 6) - 5; // -5 & +28 (celcius)
      cloud = ((225 - toy) / 2) - 25; // -12 - 87
      wind = 10 - (toy / 8);
      break;

    case "Dw": // continental dry, cold winters
      temp = (toy / 5) - 10; // gives us a no. between -10 & +30 (celcius)
      cloud = toy / 2; // 100 - 0
      wind = 15 - (toy / 8);
      break;
    case "Ds": // continental wet, cold winters
      temp = (toy / 5) - 10; // gives us a no. between -10 & +30 (celcius)
      cloud = (200 - toy) / 2; // 0 - 100
      wind = 15 - (toy / 8);
      break;
    case "Df": // continental, wet all the time. :)
      temp = (toy / 5) - 10; // gives us a no. between -10 & +30 (celcius)
      cloud = ((200 - toy) / 4) + 50; // 50 - 100
      wind = 15 - (toy / 8);
      break;
      
    case "Et": // tundra (permanently frozen)
      temp = (toy / 20) - 10;      // -10 - +0
      cloud = ((225 - toy) / 2) - 25; // 0 - 100
      wind = 25 - (toy / 8);
      break;
    case "Ef": // polar ice
      temp = (toy / 10) - 30;       // -30 - -10
      cloud = ((225 - toy) / 2) - 25; // 0 - 100
      wind = 25 - (toy / 8);
      break;
      
    case "H":
      temp = (toy / 10) - 10;      // -10 - +10
      cloud = ((225 - toy) / 2); // 20 - 125
      wind = 35 - (toy / 8);
      break;
    }
    
    _pattern[climate] =  ({ temp, cloud, wind });
    _current[climate] = ({ temp, cloud, wind });
  }
  unguarded((: save_object, FILE_NAME :));
}

/** @ignore yes */
mapping query_dynamic_auto_load() {
   return ([ "rooms" : _rooms ]);
}

/** @ignore yes */
void init_dynamic_arg(mapping map, object) {
   _rooms = map["rooms"];
   if (!_rooms) {
      _rooms = ([ ]);
   }
}
// --- END [/mnt/home2/grok/lib/obj/handlers/weather.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/room_handler.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/room_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628284   Available: 13575638
Inodes: Total: 5242880    Free: 4960134
22202 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/room_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628284   Available: 13575638
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: room_handler.c,v 1.54 2003/02/13 23:33:56 ceres Exp $
 */
/**
 * This file contains all the bits needed to handle rooms, plus the code to
 * handle following when moving.
 * @author Pinkfish
 * @revision Deutha Who knows
 * Severely changed, move the follow code in here from the living object
 * @see /std/room/basic_room.c
 */
#include <climate.h>
#include <living.h>
#include <move_failures.h>
#include <player.h>
#include <room.h>
#include <weather.h>
#include <position.h>

#define CHATSIZE 80
#define DOORSIZE 60 

mapping exit_types;
mapping door_types;
mapping opposite;
mixed *chatters, *doors;

void add_door( object thing );

/* ({ mess, obv, size, func }) */
void create() {
   seteuid( (string)"/secure/master"->
           creator_file( file_name( this_object() ) ) );
   exit_types = ([
"standard" :({ 0, 1,   400, 0 }),
"corridor" :({ 0, 1,   250, 0 }),
"plain"    :({ 0, 1, 10000, 0 }), /* very large */
"door"     :({ 0, 1,   300, 0 }),
"stair"    :({ 0, 1,   300, 0 }), /* going up? */
"hidden"   :({ 0, 0,   300, 0 }), /* hidden non door exit */
"secret"   :({ 0, 0,   300, 0 }), /* secret door */
"gate"     :({ 0, 1,   450, 0 }),
"road"     :({ 0, 1,  1300, 0 }),
"path"     :({ 0, 1,   800, 0 }),
"window"   :({ "$N climb$s through a window.\n", 0, 75, 0 }),
]);
   door_types = ([
"door"      : ({ 0, 0, "generic_key", 2, 0, 0, "door" }),
"secret"    : ({ 0, 0, "generic_key", 3, 1, 0, "door" }),
"gate"      : ({ 1, 0, "generic_key", 1, 0, 1, "door" }),
"window"    : ({ 1, 0, "generic_key", 1, 0, 1, "window" }),
]);
   opposite = ([
"north" : ({ 0, "$R$[the ]+south$R$" }),
"south" : ({ 0, "$R$[the ]+north$R$" }),
"east" : ({ 0, "$R$[the ]+west$R$" }),
"west" : ({ 0, "$R$[the ]+east$R$" }),
"northeast" : ({ 0, "$R$[the ]+southwest$R$" }),
"southwest" : ({ 0, "$R$[the ]+northeast$R$" }),
"southeast" : ({ 0, "$R$[the ]+northwest$R$" }),
"northwest" : ({ 0, "$R$[the ]+southeast$R$" }),
"up":({0,"below"}), "down":({0,"above"}),
"out":({0,"inside"}), "in":({0,"outside"}),
"exit":({0,"inside"}), "enter":({0,"outside"}),
"hubward":({0,"rimward"}), "rimward":({0,"hubward"}),
"turnwise":({0,"widdershins"}),
"widdershins":({0,"turnwise"}) ]);
   chatters = allocate( CHATSIZE );
   doors = allocate( DOORSIZE );
   call_out( "housekeeping", 4 );
} /* create() */

/**
 * This method returns the opposite direction to this exit.  This should
 * only be used for printing, since it is not a useful
 * real name.
 * @param dir the direction to get the opposite of
 * @return the opposite direction
 */
string query_opposite_direction(string dir) {
   if (opposite[dir]) {
      return opposite[dir][1];
   }
   return 0;
}

/**
 * This method returns the current list of rooms that are enabled for
 * chatting.
 * @return the current chatters
 */
mixed *query_chatters() { return chatters; }

/**
 * This method returns the current list of doors handled by the room
 * handler.
 * @return the current array of doors
 */
mixed *query_doors() { return doors; }

/**
 * This method adds an exit type to the current list of available exit types.
 * This is used when the room handler is setup to add all the used exit
 * types.
 * @param type the name of the exit type
 * @param message the message to display when going through the exit
 * @param obvious if the exit is obvious or not
 * @param size the size of the exit (used for heigh restrictions)
 * @param func the function to call when using the exit
 * @return 1 if successfuly added, 0 if not
 * @see remove_exit_type()
 */
int add_exit_type(string type, mixed message, mixed obvious,
                            int size, mixed func) {
  if (exit_types[type]) {
    return 0;
  }
  exit_types[type] = ({ message, obvious, size, func });
  return 1;
} /* add_exit_type() */

/**
 * This method remove the named exit from the type list.
 * @param type the name of the exit type to remove
 * @return always returns 1
 * @see add_exit_type()
 */
int remove_exit_type(string type) {
   map_delete(exit_types, type);
   return 1;
} /* remove_exit_type() */

/**
 * This method returns information about the door type, the door has
 * extra information associated with it than the standard exit type.
 * This function does a double job of trying to find the corresponding
 * door on the other side of the room.
 * @param type the type of the door
 * @param direc the direction the door points
 * @param dest the destination of the door
 * @return the door type array of information
 */
mixed *query_door_type(string type, string direc, string dest) {
   if (!door_types[type]) {
      return 0;
   }
   /* If there isnt a door on the other side.  We don't join. */
   call_out( "check_door", 1, ({ previous_object(), direc }) );
   return door_types[type];
} /* query_door_type() */

/**
 * This method checks to see if the door exists or not.
 * It is passed in the room we are going from and the direction the
 * exit faces in the array.<br>
 * <pre>({ room_from, direction })</pre><br>
 * This is the function which generates those door xx not found messages.
 * @param args the arguements passed into the function
 * @see query_door_type()
 */
void check_door( mixed args ) {
   string direc, dest;
   string door_name;
   
   if ( !args[ 0 ] ) {
      return;
   }
   args[ 0 ]->set_destination( args[ 1 ] );
   dest = (string)args[ 0 ]->query_destination( args[ 1 ] );
   if ( !dest ) {
      tell_room( args[ 0 ], "Error: "+ args[ 1 ] +
            " is no longer an exit.\n" );
      return;
   }
   if ( !find_object( dest ) ) {
      return;
   }

   door_name = args[0]->call_door(args[1], "query_door_name");
   direc = (string)dest->query_door( args[ 0 ], door_name );

   if ( !direc && 
       !args[ 0 ]->call_door( args[ 1 ], "query_one_way" ) ) {
      tell_room( args[ 0 ], "Error: "+ dest +
                "does not have a door coming back here.\n" );
      return;
   }
   args[ 0 ]->modify_exit( args[ 1 ], ({ "other", direc }) );

   /*
    * This makes sure that whatever the states of the two sides, they'll
    * both end up the same.  Think about it...
    */
   args[ 0 ]->modify_exit( args[ 1 ], ({
      "closed", (int)dest->call_door( direc, "query_closed" ),
      "locked", (int)dest->call_door( direc, "query_locked" ) }) );
   if ( !args[ 0 ]->call_door( args[ 1 ], "query_closed" ) &&
       ( (string)args[ 0 ]->query_property( "location" ) == "outside" ) ) {
      add_door( (object)args[ 0 ]->query_door_control( args[ 1 ], door_name ) );
   }
} /* check_door() */

/**
 * This method returns the information associated with the exit type.
 * @param type the exit type to query
 * @param dir the direction the type information is for
 * @return a huge amount of info as specified above
 */
mixed *query_exit_type(string type, string dir) {
  mixed s;

   if (!(s = opposite[dir])) {
      s = ({ 0, "elsewhere" });
   }
   if (!exit_types[type]) {
      return exit_types["standard"] + ({ s, 0, 0, 0, 0, 0, 0, 0, 0, 0 });
   }
   return exit_types[ type ] + ({ s, 0, 0, 0, 0, 0, 0, 0, 0, 0 });
} /* query_exit_type() */

/**
 * THis is the code that actually moves the thing around the place.
 * It handles all the weirdness involved with dragging things and other
 * such stuff.
 * @param thing what is being moved
 * @param dir the direction we are going
 * @param dest the destionation room
 * @param exit the exit name
 * @param enter the enter name
 * @param move the string to tell the object when it moves
 * @return 1 on success, 0 on failure
 */
int move_thing( object thing, string dir, string dest, mixed exit,
                mixed enter, string move ) {
  int ret;
  string arrive, leave;
  object dragging;
  
  dragging = (object)thing->query_dragging();

  if (dragging && environment(dragging) != environment(thing)) {
    thing->reset_dragging();
    dragging = 0;
  }

  if ( ( exit != "none" ) || objectp( dragging ) ) {
    if ( stringp( enter ) )
      enter = ({ 1, enter });
    else if ( functionp(enter) )
      enter = ({ 1, evaluate(enter, thing) });
    else if ( !pointerp( enter ) )
      enter = ({ 0, "somewhere" });
    
    switch ( enter[ 0 ] ) {
    case 0 :
      arrive = replace( (string)thing->query_msgin(), 
                        ({"$F", enter[ 1 ], 
                          "$r", thing->query_pronoun() }) );
      break;
    default :
      arrive = enter[ 1 ];
    }

    if ( stringp( exit) )
      leave = exit;
    else if ( functionp( exit ) )
      leave = evaluate(exit, thing);
    else if ( pointerp( exit ) )
      leave = exit[ 0 ];
    else
      leave = (string)thing->query_msgout();

    leave = replace( leave, ({"$T", "$R$-"+ dir +"$R$",
                              "$r", thing->query_pronoun() }) );
  }

  /* Check position... */
  thing->return_to_default_position(1);
  
  if ( arrive || objectp( dragging ) ) {
    thing->remove_hide_invis( "hiding" );
    if ( stringp( arrive ) && objectp( dragging ) ) {
      arrive += "\n$C$"+ (string)thing->query_pronoun() +" drags "+
        (string)dragging->a_short() +" in behind "+
        (string)thing->query_objective() +".";
    }

    if ( stringp( leave ) && objectp( dragging ) ) {
      leave += "\n$C$"+ (string)thing->query_pronoun() +" drags "+
        (string)dragging->the_short() +" away behind "+
        (string)thing->query_objective() +".";
    }

    if ( stringp( move ) ) {
      tell_object( thing, move );
    }

    ret = (int)thing->move( dest, arrive, leave );
    if ( ( ret == MOVE_OK ) && objectp( dragging ) ) {
      if(dragging->move(environment(thing)) == MOVE_OK) {
        tell_object( thing, "You drag "+
                     (string)dragging->the_short() +" behind you.\n" );
        thing->adjust_time_left( -DEFAULT_TIME );
        //dragging->adjust_cond(-100);
      } else {
        tell_object( thing, "You fail to drag "+
                     (string)dragging->the_short() +" behind you.\n" );
      }
    }
  } else {
    if ( stringp( move ) ) {
      tell_object( thing, move );
    }
    ret = (int)thing->move( dest );
  }

  if ( ret == MOVE_OK ) {
    thing->adjust_time_left( -DEFAULT_TIME );
    return 1;
  }

  return 0;
} /* move_thing() */

/** @ignore yes
 * This function performs the door checks for exit_move(). It is called
 * for the object moving and each of its followers.  It returns 1 if
 * the player can move or 0 if not.
 */
int exit_move_door_checks(object thing, mixed closed) {

  closed->force_other();
  
  if(closed->query_open())
    return 1;
  
  if(thing->query_property( "demon" ) || thing->query_property("dead")) {
    tell_object(thing, "You ghost through "+(string)closed->the_short()+
                ".\n");
    return 1;
  }

  // Too small to open the door or unlock it!
  if(thing->query_weight() < 300)
    return 0;
  
  if(closed->query_locked() && !closed->moving_unlock(thing)) {
    // It is locked and invisible...
    if(!closed->query_visible(thing)) {
      return 0;
    }
    
    tell_object(thing, (string)closed->the_short() +
                ({ " is ", " are " })[(int)closed->query_how_many()] +
                "locked.\n");
    return notify_fail("");
  }

  if(!closed->moving_open(thing)) {
    return 0;
  }

  return 1;
}

/** @ignore yes
 * This function performs the function checks for exit_move(). It returns 1 if
 * the player can move or 0 if not.
 */
int exit_move_func_checks(string verb, string special, object thing,
                          mixed func, object place) {
  if(stringp(func))
    return call_other(place, func, verb, thing, special);

  if(functionp(func))
    return evaluate(func, verb, thing, special);

  if(pointerp(func) && sizeof(func) > 1 && func[0] && func[1])
    return call_other(func[0], func[1], verb, thing, special);
  
  return 1;
}

/**
 * This is the main code for moving someone.  The move_thing code above
 * should not be called directly.  This code handlers all the followers
 * and any other things that need to be handled.
 * @param verb the movement verb
 * @param extra extra information
 * @param special special informaiton
 * @param thing the thing to move
 * @return 1 on success, 0 on failure
 */
int exit_move( string verb, string extra, mixed special, object thing ) {
   string leave;
   // Place is where we are right now.
   object place;
   object follower;
   object *okay;
   mixed closed;
   int locked;
   mixed func;
   mixed *dest_other;
   object *all_followers;
   object *tmp_followers;
   object *more_followers;

   /* Find the exit infomation. */
   place = environment( thing );
   verb = (string)place->expand_alias( verb );
   place->set_destination( verb );
   
   /* This checks that the destination is correctly set. */
   dest_other = (mixed *)place->query_dest_other( verb );
   if (!pointerp(dest_other))
      return 0;

   if(thing->cannot_walk( verb, dest_other ))
      return notify_fail( "" );
   
   /* This checks that the door exists if there should be one. */
   closed = (object)place->query_door_control( verb );

   // Force the other side of the door to load. Once this is done make
   // sure our door hasn't been destructed & replaced by another. I know
   // that sounds unlikely but it does happen sometimes.
   if(objectp(closed)) {
     closed->force_other();
     if(!closed)
       closed = (object)place->query_door_control( verb );
   }

   /* This checks to see if this is an NPC trying
    * to go through a "no follow" exit. */
   if (!interactive(thing) && living(thing)
         && sizeof(dest_other) > ROOM_NPC_STOP && dest_other[ROOM_NPC_STOP])
      return 0;

   if (objectp(closed)) {
      locked = closed->query_locked();
   }
   /* If the door is already open we don't need the closed thing coz
      we aren't going to do anything to the door. */
   if(objectp(closed) && closed->query_open()) {
     closed = 0;
   }

   if(objectp(closed) && !exit_move_door_checks(thing, closed)) {
     return 0;
   }
   
   //To allow the room to override exits from a central location.
   if ( place->block_exit_move( verb, thing ) ) {
     return notify_fail( "" );
   }

   /* Check exit functions. */
   func = dest_other[ROOM_FUNC];
   if(func && !thing->query_property( "demon" ) &&
      !exit_move_func_checks(verb, special, thing, func, place))
     return 0;
   
   if ( place->query_relative( verb ) )
     leave = (string)thing->find_rel( verb, 0 );
   else
     leave = verb;

   /* Check height. */
   if((int)thing->query_height() > dest_other[ ROOM_SIZE ] &&
      !(thing->query_crawling() &&
        (int)thing->query_height()/3 <= dest_other[ ROOM_SIZE ])) {
     tell_object( thing, "You are too tall to go that way.\n" );
     return notify_fail( "" );
   }

   /* Now actually move. */
   if ( !stringp( special ) ) {
      special = dest_other[ ROOM_EXIT ];
   }

   if ( !move_thing( thing, verb, dest_other[ ROOM_DEST ], special,
                     dest_other[ ROOM_ENTER ], dest_other[ ROOM_MESS ] ) ) {
     return 0;
   }

   thing->return_to_default_position(1);

   okay = ({ });
   if (place) {
     // Get all the followers of the followers.
     all_followers = thing->query_followers();
     more_followers = all_followers;
     do {
       tmp_followers = ({ });
       foreach (follower in more_followers) {
         //
         // Make sure that we only follow lists of people that are actually
         // here.
         //
         if (follower &&
             environment( follower ) == place ) {
           // Make sure we not end up with duplicates in this array.
           tmp_followers |= follower->query_followers();
         }
       }
       // Make sure we do not get repeated followers.
       more_followers = tmp_followers - all_followers;
       all_followers |= tmp_followers;
     } while (sizeof(more_followers));
     
     // Move all those people following us too!
     foreach ( follower in all_followers) {

       if ( !objectp( follower ) ) {
         thing->remove_follower( follower );
         continue;
       }
       
       /* Make sure they are in the start room and
        * if they are a user they are interactive and
        * the person they are following is visible and
        * they aren't passed out and can walk.
        */
       if(environment(follower) != place ||
          (userp(follower) && !interactive(follower)) ||
          (!thing->query_visible(follower) || (special == "none")) ||
          follower->query_property( PASSED_OUT) ||
          follower->cannot_walk( verb, dest_other ))
         continue;

       // do the door checks
       if(objectp(closed) && !exit_move_door_checks(follower, closed))
         continue;

       // do the function checks.
       if ( func && !follower->query_property( "demon" ) &&
            !exit_move_func_checks(verb, special, follower, func, place))
         continue;

       // do the NPC check.
       if (!interactive(follower) && living(follower)
           && sizeof(dest_other) > ROOM_NPC_STOP && dest_other[ROOM_NPC_STOP])
         continue;

       if ( place->query_relative( verb ) ) {
         leave = (string)follower->find_rel( verb, 0 );
         follower->reorient_rel( leave );
       } else {
         leave = verb;
         follower->reorient_abs( leave );
       }

       if ( (int)follower->query_height() > dest_other[ ROOM_SIZE ] ) {
         tell_object( follower, "You are too tall to follow "+
                      (string)thing->the_short() +" "+ leave +".\n" );
         continue;
       }

       if (function_exists("check_doing_follow", follower) &&
           !follower->check_doing_follow(thing, verb, special)) {
         continue;
       }

       if(move_thing( follower, verb, dest_other[ROOM_DEST], special,
                      dest_other[ROOM_ENTER], dest_other[ROOM_MESS]) &&
          living(follower)) {

         tell_object(follower, "You follow "+ (string)thing->the_short() +
                     " "+ leave +".\n");

         if(follower->query_visible(thing))
           okay += ({ follower });


         follower->return_to_default_position(1);

       } else {
         tell_object( follower, "You fail to follow "+
                      (string)thing->the_short() +" "+ leave +".\n" );
       }
     }
   }

   //
   // Move everyone then do the look.  Fix up problems with followers
   // that have light, like the fireflies and blue lights.
   //
   thing->room_look();
   if(sizeof(okay)) {
     okay->room_look();
     tell_object(thing, query_multiple_short(okay) +
                 " $V$0=follows,follow$V$ you.\n" );
   }

   if(objectp(closed)) {
      closed->moving_close(thing);

      if (locked)
        closed->moving_lock(thing);
   }

   return 1;
}

void housekeeping() {
   call_out( "check_chatters", 1 );
   call_out( "check_doors", 2 );
   call_out( "housekeeping", 4 );
} /* housekeeping() */

void add_chatter(object thing, int number) {
   number /= 4;
   if ( number > CHATSIZE - 1 )
      number = CHATSIZE - 1;
   if ( !pointerp( chatters[ number ] ) )
      chatters[ number ] = ({ thing });
   else
      chatters[ number ] += ({ thing });
} /* add_chatter() */

void check_chatters() {
   object thing, *things;
   things = chatters[ 0 ];
   chatters[ 0 .. <2 ] = chatters[ 1 .. <1 ];
   chatters[ <1 ] = 0;
   if ( !pointerp( things ) )
      return;
   foreach ( thing in things ) {
      if ( objectp( thing ) )
         thing->make_chat();
   }
} /* check_chatters() */

void add_door( object thing ) {
   int number;
   number = random( DOORSIZE );
   if ( !pointerp( doors[ number ] ) )
      doors[ number ] = ({ thing });
   else
      doors[ number ] += ({ thing });
} /* add_door() */

void check_doors() {
   int wind;
   string dest, other, mess;
   object mine, thing, *things;
   things = doors[ 0 ];
   doors[ 0 .. <2 ] = doors[ 1 .. <1 ];
   doors[ <1 ] = 0;
   if ( !pointerp( things ) )
      return;
   foreach ( thing in things ) {
      if ( !objectp( thing ) )
         continue;
      if ( thing->query_closed() )
         continue;
      if(thing->query_stuck())
         continue;
      
      dest = (string)thing->query_dest();
      other = (string)thing->query_other_id();
      mine = (object)thing->query_my_room();
      wind = (int)WEATHER->calc_actual( mine, WINDSP );
      if ( random( 25 ) > wind ) {
         add_door( thing );
         return;
      }
      switch ( wind ) {
       case -1000 .. 20 :
         mess = "blow$s shut in the breeze.\n";
         break;
       case 21 .. 40 :
         mess = "blow$s shut in the wind.\n";
         break;
       default :
         mess = "slam$s shut in the wind.\n";
      }
      if ( find_object( dest ) ) {
         dest->modify_exit( other, ({ "closed", 1 }) );
         if(thing->query_autolock())
           dest->modify_exit(other, ({ "locked", 1 }));
         dest->tell_door( other, "The $D "+ mess, 0 );
      }
      thing->set_closed( 1 );
      if(thing->query_autolock())
        thing->set_locked();
      thing->tell_door( "The $D "+ mess, 0 );
   }
} /* check_doors() */

/* these two are not here because the handler can be saved, but to keep
 * the info over updates.
 */
mapping query_dynamic_auto_load() {
   mapping tmp;
   tmp = ([ "exit_types" : exit_types,
            "door_types" : door_types,
            "opposite" : opposite,
            "chatters" : chatters,
            "doors" : doors,
          ]);
   return tmp;
} /* query_dynamic_auto_load() */

void init_dynamic_arg(mapping maps) {
   if (maps["exit_types"])
      exit_types = maps["exit_types"];
   if (maps["door_types"])
      door_types = maps["door_types"];
   if (maps["opposite"])
      opposite = maps["opposite"];
   if (maps["chatters"])
      chatters = maps["chatters"];
   if (maps["doors"])
      doors = maps["doors"];
} /* init_dynamic_arg() */

mixed *stats() {
   int door_count, chatter_count;
   mixed temp;
   foreach (temp in chatters)
      chatter_count += sizeof( temp );
   foreach (temp in doors)
      door_count += sizeof( temp );
   return ({
      ({ "exit types", sizeof( exit_types ) }),
      ({ "door types", sizeof( door_types ) }),
      ({ "opposites",  sizeof( opposite ) }),
      ({ "chatters",  chatter_count }),
      ({ "doors", door_count }),
   });
}

// --- END [/mnt/home2/grok/lib/obj/handlers/room_handler.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/co_ordinate_handler.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/co_ordinate_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628279   Available: 13575633
Inodes: Total: 5242880    Free: 4960134
3709 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/co_ordinate_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628279   Available: 13575633
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is the handler for co-ordinates.  Finds and sets co-ordinates for
 * outside rooms.  It works from specific fixed co-ordinate locations and
 * finds the rooms as a web of relative connections for there.
 * @author Pinkfish
 * @started Mon Nov  3 13:57:58 PST 2003
 */
#include <dirs.h>

class room_data {
   string other;
   string direction;
   int* coords;
   int last_update;
}

private mapping _rooms = ([ ]);
private nosave mapping _dirs;

int setup_room(string path);

void create() {
   mixed* bits;
   int i;

   bits = STD_ORDERS;
   _dirs = ([ ]);
   for (i = 0; i < sizeof(bits); i += 2) {
      _dirs[bits[i]] = bits[i + 1];
   }
}

private void setup_specific_room(string path, string new_path, string dir) {
   int* delta;
   int* co_ord;
   int k;
   class room_data data;

   // Figure out all the nifty offset things.
   delta = new_path->query_room_size_array() + path->query_room_size_array();
   co_ord = copy( _rooms[new_path]->coords);
   for ( k = 0; k < 3; k++ ) {
     co_ord[ k ] += _dirs[dir][ k ] *
                    ( delta[ k ] + delta[ k + 3 ] );
   }
   // Do it!
   data = new(class room_data);
   data->other = new_path;
   data->coords = co_ord;
   data->direction = dir;
   data->last_update = _rooms[new_path]->last_update;
   _rooms[path] = data;
}

/**
 * Find the room's co-ordinates.
 * @param room the room to lookup
 * @return the co-ordinates
 */
int* query_room_co_ords(string path) {
   class room_data data;

   data = _rooms[path];
   if (data) {
      if (!_rooms[data->other]) {
         map_delete(_rooms, path);
      } else {
         if (data->last_update != _rooms[data->other]->last_update) {
            setup_specific_room(path, data->other, data->direction);
         }
         return data->coords;
      }
   }
   if (setup_room(path)) {
      data = _rooms[path];
      return data->coords;
   }
   return 0;
}

/**
 * Sets up the room, based on a room with a known co-ordinate and an
 * exit direction.  We search around to try and find a fixed co-ordinate
 * room.
 * @param path the room being setup
 */
int setup_room(string path) {
   string* bits;
   int i;
   string new_path;

   // We only work with outside rooms that are not in a terrain
   if (path->query_property("location") != "outside" ||
       !path->query_terrain_handler()) {
      return 0;
   }

   bits = path->query_dest_dir();
   for (i = 0; i < sizeof(bits); i += 2) {
      if (find_object(bits[i+1])) {
         new_path = file_name(find_object(bits[i+1]));
      } else {
         new_path = bits[i+1];
      }
      // We have a room to base it off.
      if (_rooms[new_path]) {
         setup_specific_room(path, new_path, bits[i]);
         return 1;
      }
   }
   return 0;
}

/**
 * Sets up the specific co-ordinates for the specific room.
 * @param path the path for the main room
 * @param coords the coordinates to set
 */
void setup_fixed_room(string path, int* coords) {
   class room_data data;

tell_creator("pinkfish", "%O %O %O\n", path, path->query_property("location"),
               path->query_terrain_handler());
   // We only work with outside rooms that are not in a terrain
   if (path->query_property("location") != "outside" ||
       !path->query_terrain_handler()) {
      return 0;
   }

   if (_rooms[path]) {
      data = _rooms[path];
      if (data->coords[0] == coords[0] &&
          data->coords[1] == coords[1] &&
          data->coords[2] == coords[2]) {
         return ;
      }
   } else {
      data = new(class room_data);
   }
   data->coords = coords;
   data->last_update = time();
   _rooms[path] = data;
}

/**
 * Returns the current list of stored rooms.
 */
mapping query_rooms() {
   return _rooms;
}
// --- END [/mnt/home2/grok/lib/obj/handlers/co_ordinate_handler.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/hospital.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/hospital.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628277   Available: 13575631
Inodes: Total: 5242880    Free: 4960134
48909 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/hospital.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628277   Available: 13575631
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * @main
 * This is a generalised hospital inheritable for the creation of NPCs.
 * <p>
 * The NPCs within the hospital are defined in the configuration files which
 * are parsed by the hospital. The configuration files can define zones,
 * groups and npcs.
 * <p>
 * A zone is a region of the mud. It can have any name you choose and is then
 * used as the first parameter to load_random_npc(). A zone may be made up of
 * other zones, groups and npcs.
 * 
 * <p>
 * A group is a group of NPCs. It may be made up of other groups and npcs. A
 * group has a name by which it is referenced by zones and other groups.
 * <p>
 * An npc is the definition of a specific type of NPC.
 *
 * @example
 * A typical hospital setup would look like this:
 *
 * void setup() {
 *   set_save_file(SAVE + "/hospital");
 *   set_data_directory(DATA + "/hospital");
 *   set_log_directory(LOG + "/hospital");
 *   set_npc_path(CHARS + "/hospital");
 *   set_not_replaceable(1);
 *
 *   set_short("Our hospital");
 *   set_long("This is the hospital.\n");
 * }
 *
 * @example
 * These are examples of zones, groups & npcs.
 *
 * (zone
 *   (name "desert")
 *   (busy 5)
 *   (group
 *     (name "vultures")
 *     (chance 1)
 *   )
 *   (npc
 *     ("name "lizard")
 *     (chance 1)
 *   )
 * )
 *
 * (group
 *   (name "vultures")
 *   (transient "true")
 *   (npc
 *     (name "vulture")
 *     (quantity 1 + 1d5)
 *   )
 * )
 *
 * (npc
 *   (name "vulture")
 *   (path "vulture")
 *   (transient true)
 * )
 * (npc
 *   (name "lizard")
 *   (path "lizard")
 *   (transient true)
 *   (diurnal true)
 * )
 *
 * The above configuration file defines a zone "desert". The zone has a
 * business factor of 5 which means rooms in the zone will typically get a
 * chance at cloning npcs 5% of the time (every 20 rooms).
 * <p>
 * The zone is made up of a group called "vultures" and an npc called
 * "lizard".
 * <p>
 * The vultures group is transient (ie. the NPCs will be removed from the
 * room when the player leaves the room, rather like wandering monsters) and
 * contains 1 + 1d5 "vulture" npcs.
 * <p>
 * The vulture NPC is transient and can be found in the filename "vulture.c" in
 * the path defined by set_npc_path(). The lizard NPC is also transient and
 * diurnal (it only comes out during the day) and can be found in the filename
 * "lizard.c" in the path defined by set_npc_path().
 *
 * <p>
 * @author Taffyd
 * @changed Ceres November 14th 2002<br>
 * Altered to work as a hospital for terrain NPCs especially the transient
 * ones. It now handles transient npcs as well as conditions for
 * diurnal, nocturnal and seasonal npcs.
 * @changed Pinkfish March 10th<br>
 * Major rewrite of bits to make it use a lisp like data file format.
 * @changed Carmine April 9th<br>
 * Added some alignment-generation code.
 * @started December 3, 1998.
 * @index hospital
 */

#include <armoury.h>
#include <data.h>
#include <weather.h>

/* Comment this out if you want to disable hospital generation
   of NPC's through the new data compiler system. */
#define CREATE_NPCS 1

// #define REGENERATE_AFTER_DEATH

#define REGEN_TIME 1 * 60 * 60
#define DEFAULT_MAX_CACHE 10
#define DEFAULT_LOG_DIRECTORY "/log"
#define DEFAULT_POPULATION 3
#define MINIMUM_DEATH_REGEN 3

//
// How often we recheck the population to make sure 0's etc have not snuck
// in.
//
#define POPULATION_UPDATE_TIME 15 * 60

/*
 * These defines set the shape of the distribution of alignments handed out
 * by pick_al.  Using the standard normal distribution, split into ten steps
 * on each side of the average, we can safely disregard the probability of
 * values outside of the range of -3.0 to 3.0 (99.7% of values will fall
 * within this range of three * standard deviation from the average).
 *        Range           Prob.
 *  P( 0.0 < z < 0.3 ) = 0.1179
 *  P( 0.3 < z < 0.6 ) = 0.1078
 *  P( 0.6 < z < 0.9 ) = 0.0902
 *  P( 0.9 < z < 1.2 ) = 0.0690
 *  P( 1.2 < z < 1.5 ) = 0.0483
 *  P( 1.5 < z < 1.8 ) = 0.0309
 *  P( 1.8 < z < 2.1 ) = 0.0180
 *  P( 2.1 < z < 2.4 ) = 0.0097
 *  P( 2.4 < z < 2.7 ) = 0.0047
 *  P( 2.7 < z ) =       0.0035
 *
 *  These probabilites are then converted into cumulative limits out of
 *  a total chance, as integers:
*/
#define TOTAL_CHANCE 150
#define CENTRE 0
#define LIMIT_ONE     35
#define LIMIT_TWO     68
#define LIMIT_THREE   95
#define LIMIT_FOUR   115
#define LIMIT_FIVE   130
#define LIMIT_SIX    139
#define LIMIT_SEVEN  145
#define LIMIT_EIGHT  147
#define LIMIT_NINE   149


inherit "/std/room";

class regenerated_npc {
    string type;
    string load_position;
}

/**
 * This class stores all the information about a zone.
 * @param wealth The wealthiness of the zone (unused)
 * @param busy The business of the zone. ie. how frequently NPCs should be
 * created.
 * @param npc_chance The total chances for an npc in this zone.
 * @param npcs A list of the NPCs that are members of this zone.
 * @param group_chance The total chances for a group in this zone.
 * @param groups A list of the groups of NPCs in this zone.
 * @param zone_chance The total chances for a zone in this zone.
 * @param zones A list of the zones within this zone.
 */
class zone_info {
   int wealth;
   int busy;

   int npc_chance;
   mapping npcs;
   int group_chance;
   mapping groups;
   int zone_chance;
   mapping zones;
}

/**
 * This class stores all the information about unique NPCs.
 * @param next_regen_time When this npc will next regenerate.
 */
class unique_npc {
   int next_regen_time;
}

/**
 * This class stores all the information about a particular NPC.
 *
 * @param path The relative path of the NPC
 * @param unique Is the NPC unique?
 * @param delay The regeneration delay for this NPC
 * @param transient If this NPC is transient.
 * @param nocturnal If this NPC is nocturnal.
 * @param diurnal If this NPC is diurnal.
 * @param seasonal A list of seasons during which this NPC is active.
 * @param max_population How many of these NPCs can exist at a time.
 * @param move_zones The move zones for this NPC
 * @param commands Commands to be executed by the NPC when it is created.
 * @param population A cache of the current population
 * @param no_deaths The number of recorded deaths
 * @param no_created The number of these NPCs we've created
 * @param no_reused How many of these NPCs have been reused (recycled)
 * @param next_update When the population data will next be updated.
 */
class npc_info {
   string path;
   int unique;
   int delay; // used by unique npcs

   int transient;
   int nocturnal;
   int diurnal;

   string* seasonal;
   
   int max_population;
   string* move_zones;
   string* commands;

   // Tracking information
   object* population;
   int no_deaths;
   int no_created;
   int no_reused;
   int next_update;
}

/**
 * This class stores all the information about an NPC group.
 *
 * @param move_zones The move zones for this NPC
 * @param npcs A list of the NPCs within this group.
 * @param npc_commands A list of commands to be executed on each of the group
 * members when the group is created.
 * @param protect Should these group members protect each other.
 * @param defend Should these group members defend each other.
 * @param transient Should these group members be considered transient.
 * @param max_population How many of these NPCs can exist at a time.
 * @param storage A cache of the population of NPCs in this group.
 * @param no_creates The number of these NPCs we've created
 * @param next_update When the population data will next be updated.
 */
class group_info {
   string* move_zones;
   // This is a list of npcs with a name as the key and a quantity as the value.
   mapping npcs;
   mapping npc_commands;
   int protect;
   int defend;
   int transient;
   
   int max_population;

   // Tracking details.
   mixed* storage;
   int no_creates;
   int next_update;
}

object* load_random_npc(string zone, int wealth, int busy);
protected void load_file();
protected void save_file();
protected void set_save_file(string new_save);

public void hospital_log_file(string file, string format, mixed *args ...);
public int get_item(object destination, string *items);
public string query_save_file();
public int *query_npcs();
public mapping query_hospital_npcs();
public void add_npc_type(string type, string *data);
public void regen_after_death( object dead_npc );

private nosave string _save_file;
private nosave string _hospital_type;
private nosave mixed *_regenerated_npcs;
private nosave int _hospital_call_id;
private nosave mapping _log_file_info;
private nosave string _hospital_log_directory;
private nosave string _data_directory;
private nosave string _npc_path;
private nosave string _domain;
private nosave int _max_cache;

// Used when the system is in debug mode.
private nosave int _disable_npc_generation;

private mapping _unique_npcs;
private mapping _hospital_npcs;
private mapping _cache_inventory;

private int _last_npc_check;
private int _zone_npcs;

private mapping _group_info;
private mapping _npc_info;
private mapping _zone_info;
private mapping _path_to_npc;

// Details on the files to load.
private mapping _file_modified_time;

/** @ignore yes */
void create() {
    seteuid(master()->creator_file(file_name(this_object())));

    do_setup++;
    ::create();
    do_setup--;


    if (!_group_info) {
        _group_info = ([ ]);
    }

    if (!_npc_info) {
        _npc_info = ([ ]);
    }

    if (!_zone_info) {
        _zone_info = ([ ]);
    }

    if (!_path_to_npc) {
        _path_to_npc = ([ ]);
    }

    if (!_file_modified_time) {
        _file_modified_time = ([ ]);
    }

    if (!_unique_npcs) {
        _unique_npcs = ([ ]);
    }

    if (!_cache_inventory) {
      _cache_inventory = ([ ]);
    }
    
    _regenerated_npcs = ({ });
    _log_file_info = ([ ]);

    if(!_max_cache)
      _max_cache = DEFAULT_MAX_CACHE;
    
    if (!do_setup) {
        set_short( "Un-configured Hospital" );
        set_long("This is an unconfigured hospital.  Find the right one.\n");
        add_property("determinate", "the ");
        set_light(60);
        // Setup extra stuff if they wish
        this_object()->setup();
    }
} /* create() */

/** @ignore yes */
int ok_to_clone() {
   return 1;
}


/**
 * This function produces a random alignment for an npc, based on a
 * normal distribution around a supplied average, with a maximum and
 * minimum limit provided by a requested range.
 * <p>
 * The alignment produced will be within the range[ average - range,
 * average + range ]
 * @param average The average alignment for this npc
 * @param range The range request for alignment - the difference between
 * average and maximum possible alignment
 * <p>
 */
int pick_al( int average, int range ) {
   int choice, section, section_width, result;

   // Must be a positive range.
   if( range < 0 ) {
      range = -range;
   }

   // Must have a range of 10 at least.
   if( range < 10 ) {
      range = 10;
   }

   section_width = floor( range / 10 );

   choice = random( TOTAL_CHANCE );

   switch( choice ) {
      case CENTRE..LIMIT_ONE:
         section = 0;
         break;
      case ( LIMIT_ONE + 1 )..LIMIT_TWO:
         section = 1;
         break;
      case ( LIMIT_TWO + 1 )..LIMIT_THREE:
         section = 2;
         break;
      case ( LIMIT_THREE + 1 )..LIMIT_FOUR:
         section = 3;
         break;
      case ( LIMIT_FOUR + 1 )..LIMIT_FIVE:
         section = 4;
         break;
      case ( LIMIT_FIVE + 1 )..LIMIT_SIX:
         section = 5;
         break;
      case ( LIMIT_SIX + 1 )..LIMIT_SEVEN:
         section = 6;
         break;
      case ( LIMIT_SEVEN + 1 )..LIMIT_EIGHT:
         section = 7;
         break;
      case ( LIMIT_EIGHT + 1 )..LIMIT_NINE:
         section = 8;
         break;
      default:
         section = 9;
         break;
   }

   result = section * section_width;
   result = result + random( section_width );

   switch( random( 2 ) ) {
      case( 0 ):
         result = average + result;
         break;
      default:
         result = average - result;
         break;
   }

   result = result + average;
   return result;
} /* pick_al */


/**
 * This function returns an array of the gods in Ankh-Morpork
 * <p>
 */
public string *query_deities() {
   return ({ "fish", "pishe", "sek", "hat", "gapp",
      "gufnork", "sandelfon" });
}

/**
 * This function provides an interface to the armoury, selecting
 * an item at random from the 'items' array and attempting to
 * clone it.
 * <p>
 * Any items of jewellery, clothing, weapons, armour or scabbards
 * that are available in the armoury can be accessed using this
 * function.
 * <p>
 * @param destination where to place the item that is fetched
 * from the armoury.
 * @param items an array of items, of which one will be selected,
 * cloned, and then moved to destination.
 * <p>
 * @see /obj/handlers/armoury
 * @return 1 if the item was successfully created, 0 if it was not.
 */
public int get_item(object destination, string *items) {
    int i;
    object item;

    if (!objectp(destination)) {
        return 0;
    }

    while (!item) {
        i = random(sizeof(items));
        item = ARMOURY->request_item(items[i], 80 + random(21), _domain);

        if (!item) {
            item = ARMOURY->request_item(items[i], 80 + random(21) );
            if ( !item ) {
                items = items[0..i-1] + items[i+1..];
                continue;
            }
        }

        if (!sizeof(items)) {
            hospital_log_file("BROKEN_ITEMS", "Unable to select any items "
                "for %s in the Ankh-Morpork hospital.\n",
                previous_object()->short());
            break;
        }
    }

    if (objectp(item)) {
        item->move(destination);
        return 1;
    }

    return 0;
} /* get_item() */

/** @ignore yes */
protected void load_file() {
    class npc_info npc;
    class group_info group;
    string name;

    if (file_size(_save_file + ".o") > -1) {
        unguarded((: restore_object, _save_file :));
        if (!_group_info) {
            _group_info = ([ ]);
        } else {
            // Zap all the population data
            foreach (name, group in _group_info) {
                group->storage = 0;
            }
        }

        if (!_npc_info) {
            _npc_info = ([ ]);
        } else {
            // Zap all the population data
            foreach (name, npc in _npc_info) {
                npc->population = ({ });
            }
        }

        if (!_zone_info) {
            _zone_info = ([ ]);
        }

        if (!_path_to_npc) {
            _path_to_npc = ([ ]);
        }

        if (!_file_modified_time) {
            _file_modified_time = ([ ]);
        }

        if (!_unique_npcs) {
            _unique_npcs = ([ ]);
        }
    }
} /* load_file() */

/** @ignore yes */
protected void save_file() {
    unguarded((: save_object, _save_file :));
} /* save_file() */

/**
 * This method is used to set the save file for the hospital.  This
 * file is where all of the hospitals NPC data is stored while it is
 * not active and in between reboots.
 * <p>
 * If this file does not exist when the hospital is loaded, then the
 * variables will be initialised to their defaults and
 * <b>restore_default_npcs()</b> called.
 * <p>
 * @param new_save the file name to save the hospital data in
 */
protected void set_save_file(string new_save) {
    _save_file = new_save;
    load_file();
} /* set_save_file() */

/**
 * This returns the location where hospital data will be stored.
 *
 * @see set_save_file()
 */
public string query_save_file() {
    return _save_file;
} /* query_save_file() */

/**
 * This method sets the directory to scan for new files. The data directory
 * stores the configuration files for the hospital that define the zones,
 * groups and npcs.
 *
 * @param dir the directory to scan for new files
 */
void set_data_directory(string dir) {
   _data_directory = dir;
   call_out("scan_for_new_data", 2);
}

/**
 * This method returns the directory to scan for new files.
 *
 * @return the directory to scan new data
 * @see set_data_directory()
 */
string query_data_directory() {
   return _data_directory;
}

/**
 * This method sets the directory for npcs.  The filename for npcs defined
 * in the configuration files is realtive to this path.
 *
 * @param dir the director for npcs.
 */
void set_npc_path(string path) {
  _npc_path = path;
}

/**
 * This method sets the domain string used when requesting things
 * from the hospital.
 *
 * @param domain the domain name
 */
void set_domain(string domain) {
  _domain = domain;
}

/**
 * This method sets the maximum number of transient npcs of a given type
 * that the hospital will cache.
 *
 * @param num the maximum number
 */
void set_max_cache(int num) {
  _max_cache = num;
}

/**
 * This method sets the flag which enables or disables npc generation. This
 * is mostly used for debugging.
 *
 * @param value the new value of the flag
 */
void set_disable_npc_generation(int value) {
   _disable_npc_generation = value;
}

/**
 * This method returns the flag that disables the npc generation.
 *
 * @return the flag that disables the npc generation
 * @see set_disable_npc_generation
 */
int query_disable_npc_generation() {
   return _disable_npc_generation;
}

/**
 * This method returns whether or not it is time to regenerate a
 * unique NPC. The regeneration time is controlled by the REGEN_TIME
 * #define.
 * <p>
 * @param who this is the name or object reference of the NPC
 * @return 1 if it is time to make the unique NPC, or 0 if it is not.
 */
public int make_unique(mixed who) {
    int delay;

    if (!_unique_npcs) {
        return 0;
    }

    if (objectp(who)) {
        who = who->query_name();
    }

    if (!_unique_npcs[who]) {
        _unique_npcs[who] = new(class unique_npc);
    }

    if ( _unique_npcs[who]->next_regen_time > time() ) {
        return 0;
    }

    if (_npc_info[who] && _npc_info[who]->delay) {
        delay = _npc_info[who]->delay;
    } else {
        delay = REGEN_TIME;
    }
    _unique_npcs[who]->next_regen_time = time() + delay;
    save_file();
    return 1;
} /* make_unique() */

/**
 * This method resets the unique status of the npc so it can be tested for
 * loading over again.
 * @param npc the name of the npc
 */
public void reset_unique(string who) {
    if (!_unique_npcs[who]) {
        return ;
    }
    _unique_npcs[who]->next_regen_time = 0;
}

#ifdef REGENERATE_AFTER_DEATH
/**
 * This method is called by the npc.death effect after an NPC that is handled
 * by the hospital has died. It tells the room where it was generated to
 * make a new NPC and to all sorts of funky things.
 * <p>
 * This is not fully implemented yet.
 */
public void regen_after_death( object dead_npc ) {
    object *monsters, destination;
    class regenerated_npc new_npc;
    int i, max;

    if ( !dead_npc )
        return;

    _regenerated_npcs += ({ new( class regenerated_npc,
        type : dead_npc->query_property("monster_type"),
        load_position : previous_object()->query_property("start location") ) });

    if ( !ok_to_clone(_hospital_type) || sizeof(_regenerated_npcs) < MINIMUM_DEATH_REGEN )
        return;

    new_npc = _regenerated_npcs[0];

    if ( !classp( new_npc ) )
        return;

    _regenerated_npcs = _regenerated_npcs[1..];

    if (!new_npc->load_position || !new_npc->type );
        return;

    max = random(5);

    for ( i = 0; i < max; i++ ){
        destination = find_object( new_npc->load_position );

        if ( !objectp( destination ) )
            return;

        monsters = get_monster(new_npc->type);
        destination->replace_monster(previous_object(), monsters);

        call_out((: $1->announce_entry($2) :), 8 + random(6), destination,
            monsters);
    }
} /* regen_after_death() */
#endif

/**
 * This method expands the path for the given npc by combining the npc_path
 * set in set_npc_path with the relative path defined in the configuration
 * file.
 *
 * @param path the path to expand
 * @return the expanded path
 */
string npc_path(string str) {
   return _npc_path + "/" + str;
}

/**
 * This method provides log_file() functionality but for /d/am/log
 * instead.  You should use this method to record errors and whatever
 * that are domain specific instead of using log_file().
 * @example
 * hospital_log_file("BAD_HOSPITAL_NPC", "%s: Bad NPC hospital data, %O.\n",
 * ctime(time()), _regenerated_npcs);
 * // This would log to /d/am/log/BAD_HOSPITAL_NPC.
 * @param file the file name to log to. This will have /d/am/log/
 * inserted before it.
 * @param format the text to log, can contain sprintf() format specifiers.
 * @param args the arguments for any sprintf format thingies
 */
public void hospital_log_file(string file, string format, mixed *args ...) {
    string filename;

    filename = _hospital_log_directory;

    /* We are restricted to logging in our domain, let's be neat about it. */

    if (file[0] == '/') {
        file = file[ strsrch( file, "/", -1 ) + 1 .. ];
    }

    /* Link to sefun */

    log_file( _hospital_log_directory + "/" + file, ctime(time()) + ": " + format, args ...);
} /* hospital_log_file() */

/**
 * This method sets the directory in to which hospital_log_file will
 * log by default. If the directory does not exist, then it is set to
 * DEFAULT_LOG_DIRECTORY.
 * @param new_dir the directory to log to.
 * @example
 * set_log_directory( "/d/cwc/Bes_Pelargic/log" );
 * // log directory is now /d/cwc/Bes_Pelargic/log
 * @example
 * // (cre) MacChirton: ithinkmykeyboardisbroken
 * set_log_directory( "/d/cWc/BeS_pelarGic/lrg" );
 * // Displays: "/d/cwc/hospital/bes_pelargic: Invalid log
 * // directory, defaulting to /log"
 */
protected void set_log_directory(string new_dir) {

    if (file_size(new_dir) != -2) {
        tell_creator( previous_object( 1 ), "%s: Invalid "
            "log directory -- defaulting to %s.\n",
            file_name( this_object() ), DEFAULT_LOG_DIRECTORY );

        new_dir = DEFAULT_LOG_DIRECTORY;
    }

    _hospital_log_directory = new_dir;
} /* set_log_directory() */

/** @ignore yes */
private void parse_zone(string fname, mapping data) {
   string name;
   class zone_info info;
   mapping bing;
   int chance;
   string* bits;

   if (!data["name"]) {
      debug_printf("No name for zone %O\n", data);
      hospital_log_file("COMPILE_ERROR", "No name for zone %O\n", data);
      return 0;
   }

   name = data["name"];
   if (data["group"] && !arrayp(data["group"])) {
      data["group"] = ({ data["group"] });
   } else if (!arrayp(data["groups"])) {
      data["group"] = ({ });
   }
   if (data["npc"] && !arrayp(data["npc"])) {
      data["npc"] = ({ data["npc"] });
   } else if (!arrayp(data["npc"])) {
      data["npc"] = ({ });
   }
   if (data["zone"] && !arrayp(data["zone"])) {
      data["zone"] = ({ data["zone"] });
   } else if (!arrayp(data["zone"])) {
      data["zone"] = ({ });
   }

   info = new(class zone_info, npcs : ([ ]), groups : ([ ]), zones : ([ ]));
   chance = 0;
   foreach (bing in data["npc"]) {
      if (!mapp(bing) || !stringp(bing["name"]) || !intp(bing["chance"])) {
         debug_printf("Invalid data for zone (%s) %O\n", name, bing);
         hospital_log_file("COMPILE_ERROR", "Invalid data for zone (%s) %O\n", name,  bing);
      } else {
         info->npcs[bing["name"]] = bing["chance"];
         chance += bing["chance"];
      }
   }
   info->npc_chance = chance;

   chance = 0;
   foreach (bing in data["group"]) {
      if (!mapp(bing) || !stringp(bing["name"]) || !intp(bing["chance"])) {
         debug_printf("Invalid data for zone (%s) %O\n", name, bing);
         hospital_log_file("COMPILE_ERROR", "Invalid data for zone (%s) %O\n", name,  bing);
      } else {
         info->groups[bing["name"]] = bing["chance"];
         chance += bing["chance"];
      }
   }
   info->group_chance = chance;

   chance = 0;
   foreach (bing in data["zone"]) {
      if (!mapp(bing) || !stringp(bing["name"]) || !intp(bing["chance"])) {
         debug_printf("Invalid data for zone (%s) %O\n", name, bing);
         hospital_log_file("COMPILE_ERROR", "Invalid data for zone (%s) %O\n", name,  bing);
      } else {
         info->zones[bing["name"]] = bing["chance"];
         chance += bing["chance"];
      }
   }
   info->zone_chance = chance;
   info->busy = data["busy"];
   
   bits = keys(data) - ({ "zone", "group", "npc", "name", "busy" });
   if (sizeof(bits)) {
      debug_printf("Unknown keys %s in zone %s\n", query_multiple_short(bits),
                   name);
      hospital_log_file("COMPILE_ERROR", "Unknown keys %s in %s\n",
                         query_multiple_short(bits), name);
   }
   _zone_info[name] = info;
   save_file();
} /* parse_zone() */

private void parse_npc(string fname, mapping data) {
   string name;
   class npc_info info;
   string* bits;

   if (!data["name"]) {
      debug_printf("No name for npc %O\n", data);
      hospital_log_file("COMPILE_ERROR", "No name for npc %O\n", data);
      return 0;
   }
   name = data["name"];
   if (!data["path"]) {
      hospital_log_file("COMPILE_ERROR", "Required path field not present for npc %s\n", name);
      return 0;
   }

   if (file_size(npc_path(data["path"]) + ".c") < 0) {
      hospital_log_file("BAD_NPC_PATH", "Bad path for npc %s (%s)\n", name, data["path"]);
   }

   if (data["command"] && !arrayp(data["command"])) {
      data["command"] = ({ data["command"] });
   }
   if (data["move_zone"] && !arrayp(data["move_zone"])) {
      data["move_zone"] = ({ data["move_zone"] });
   }

   info = new(class npc_info, move_zones : ({ }), commands : ({ }));
   info->unique = data["unique"];
   info->path = data["path"];
   info->delay = data["delay"];
   info->max_population = data["population"];
   
   if(data["transient"])
     info->transient = 1;
   if(data["nocturnal"])
     info->nocturnal = 1;
   if(data["diurnal"])
     info->diurnal = 1;
   if(data["seasonal"]) {
     if(!arrayp(data["group"]))
       info->seasonal = ({ data["seasonal"] });
     else
       info->seasonal = data["seasonal"];
   }

   if (data["move_zone"]) {
      info->move_zones = data["move_zone"];
   }
   if (data["command"]) {
      info->commands = data["commands"];
   }

   bits = keys(data) - ({ "unique", "path", "move_zone", "population", "name", "delay", "transient", "nocturnal" });
   if (sizeof(bits)) {
      debug_printf("Unknown keys %s in npc %s\n", query_multiple_short(bits),
                   name);
      hospital_log_file("COMPILE_ERROR", "Unknown keys %s in npc %s\n",
                         query_multiple_short(bits), name);
   }
   if (_path_to_npc[info->path] && _path_to_npc[info->path] != name) {
      hospital_log_file("NPC_NAME_CLASH", "NPC path %s is used by %s and %s.\n",
                         info->path, name, _path_to_npc[info->path]);
   }
   _path_to_npc[info->path] = name;
   if (_npc_info[name]) {
      info->population = _npc_info[name]->population;
      info->no_created = _npc_info[name]->no_created;
      info->no_reused = _npc_info[name]->no_reused;
      info->no_deaths = _npc_info[name]->no_deaths;
   }
   _npc_info[name] = info;
   save_file();
} /* parse_npc() */

/** @ignore yes */
private void parse_group(string fname, mapping data) {
   string name;
   class group_info info;
   mapping bing;
   int chance;
   string* bits;

   if (!data["name"]) {
      debug_printf("No name for group %O\n", data);
      hospital_log_file("COMPILE_ERROR", "No name for group %O\n", data);
      return 0;
   }

   name = data["name"];

   if (data["npc"] && !arrayp(data["npc"])) {
      data["npc"] = ({ data["npc"] });
   } else if (!arrayp(data["npc"])) {
      data["npc"] = ({ });
   }

   info = new(class group_info, npcs : ([ ]), move_zones : ({ }),
                                npc_commands : ([ ]));
   chance = 0;
   foreach (bing in data["npc"]) {
      if (!mapp(bing) || !stringp(bing["name"]) ||
          (!intp(bing["quantity"]) && !classp(bing["quantity"]))) {
         debug_printf("Invalid data for group (%s) %O\n", name, bing);
         hospital_log_file("COMPILE_ERROR", "Invalid data for group (%s) %O\n", name,  bing);
      } else {
         info->npcs[bing["name"]] = bing["quantity"];
         if (bing["command"]) {
            if (arrayp(bing["command"])) {
               info->npc_commands[bing["name"]] = bing["command"];
            } else {
               info->npc_commands[bing["name"]] = ({ bing["command"] });
            }
         }
      }
   }
   if (data["move_zone"]) {
      info->move_zones = data["move_zone"];
   }
   info->max_population = data["population"];
   info->protect = data["protect"];
   info->defend = data["defend"];
   info->transient = data["transient"];
   
   bits = keys(data) - ({ "npc", "name", "population", "move_zone", "protect", "defend", "transient", });
   if (sizeof(bits)) {
      debug_printf("Unknown keys %s in group %s\n", query_multiple_short(bits),
                   name);
      hospital_log_file("COMPILE_ERROR", "Unknown keys %s in group %s\n",
                         query_multiple_short(bits), name);
   }
   if (_group_info[name]) {
     info->storage = _group_info[name]->storage;
   }
   _group_info[name] = info;
} /* parse_group() */

/**
 * This is called by the data compiler when the system has
 * finished compiling the data file.
 * @param data the data to deal with
 */
protected void finish_compiling(string fname, mapping data) {
   mixed* bits;
   mapping thing;
   string name;

   foreach (name, bits in data) {
      switch (name) {
      case "zone" :
         foreach (thing in bits) {
            parse_zone(fname, thing);
         }
         break;
      case "npc" :
         foreach (thing in bits) {
            parse_npc(fname, thing);
         }
         break;
      case "group" :
         foreach (thing in bits) {
            parse_group(fname, thing);
         }
         break;
      default :
         debug_printf("Unknown data area %s in %s\n", name, fname);
         hospital_log_file("COMPILE_ERROR", "Unknown data area %s in %s\n", name, fname);
         break;
      }
   }

   _file_modified_time[fname] = unguarded( (: stat($(fname)) :))[1];
   save_file();
}

/**
 * This method scans through all the files and sees if anything has
 * changed.
 */
void scan_for_new_data() {
   string *files;
   string fname;
   string *bits;

   debug_printf("Scan for new data.");
   if (unguarded( (: stat(__FILE__)[1] :)) !=
       _file_modified_time[__FILE__]) {
      _file_modified_time = ([ ]);
   }
   files = ({ _data_directory });
   while (sizeof(files)) {
      fname = files[0];
      files = files[1..];
      if (unguarded( (: file_size($(fname)) :)) == -2) {
         // Directory!
         bits = get_dir(fname + "/");
         if (bits) {
            bits -= ({ "RCS", ".", ".." });
            bits = filter(bits, (: $1[0] != '.' :));
            files += map(bits, (: $2 + "/" + $1 :), fname);
         }
      } else {
         if (unguarded( (: stat($(fname)) :))[1] != _file_modified_time[fname]) {
           debug_printf("Compiling %s", fname);
            DATA_HANDLER->compile_file(fname,
                     (: finish_compiling :));
         }
      }
   }
   _file_modified_time[__FILE__] =
                unguarded( (: stat(__FILE__)[1] :));
} /* scan_for_new_data() */

/**
 * This method rolls the dice, if a dice is specified.
 * @param dice the dice or number
 * @return the actual number
 */
int roll_dice(mixed die) {
   int result;
   int i;

   if (intp(die)) {
      return die;
   }

   if (classp(die)) {
      for (i = 0; i < die->number; i++) {
         result += random(die->die) + 1;
      }
      result += die->modifier;
      return result;
   }

   return 0;
}

/**
 * This method returns the maximum population of this npc.
 * @param npc the name of the npc
 * @return the npc population
 */
int query_npc_max_population( string npc) {
   if (!_npc_info[npc]) {
      return -1;
   }

   return ((class npc_info)_npc_info[npc])->max_population;
} /* query_npc_max_population() */

/**
 * This method returns the current population of this npc
 * @param npc the name of the npc
 * @return the npc population
 */
int query_npc_current_population( string npc, int clean) {
   class npc_info data;

   if (!_npc_info[npc]) {
      return -1;
   }
   data = _npc_info[npc];

   if (!data->population) {
      data->population = children(npc_path(data->path));
      data->next_update = time() + POPULATION_UPDATE_TIME;
   }

   if (clean || data->next_update < time()) {
      data->population = filter(data->population, (: objectp($1) :));
      data->next_update = time() + POPULATION_UPDATE_TIME;
   }

   return sizeof(data->population);
} /* query_npc_current_population() */

/**
 * THis method checks to see if the number of npcs of this
 * type is under the maximum population.
 * @param npc the npc to check to see if it is under population max
 * @return 1 if is under, 0 if is not
 */
int is_npc_under_max_population(string name) {
    class npc_info info;

    info = _npc_info[name];
    if (!info) {
       return 0;
    }

    // There are no population limits for transient NPCs since they
    // are (theoretically) destroyed as soon as the players leave their
    // room.
    if(info->transient)
      return 1;

    if (info->max_population) {
       return query_npc_current_population(name, 1) < info->max_population;
    }
    return 1;
} /* is_npc_under_max_population() */

/**
 * This method checks to see if the number of npcs of this
 * type is under the maximum population.
 * @param npc the npc to check to see if it is under population max
 * @return 1 if is under, 0 if is not
 */
int is_group_under_max_population(string name) {
    class group_info group;

    group = _group_info[name];
    if (!group) {
       return 0;
    }

    if (!group->max_population || group->transient) {
       return 1;
    }

    if (!group->storage) {
        group->storage = ({ });
    } else if (group->next_update < time()) {
        group->storage = map(group->storage, (: filter($1, (: objectp($1) :)) :));
        group->storage = filter(group->storage, (: sizeof($1) :));
        group->next_update = time() + POPULATION_UPDATE_TIME;
    }
    /*
     * If we have more NPC's than the population, then stop right now.
     */
    if (sizeof(group->storage) >= group->max_population) {
        return 0;
    }
    return 1;
} /* is_group_under_max_population() */

/**
 * This method loads the specific npc.  It will do everything it needs
 * to create the npc.  In the case of unique npcs they are not cloned.
 * @param npc_name the name of the npc to load
 * @return the npc object
 */
public object load_npc_object(string npc_name) {
    class npc_info info;
    object npc;
    string zone;
    string cmd;

    if ( undefinedp(_npc_info[npc_name])) {
        debug_printf("Unable to find npc %O", npc_name);
        return 0;
    }

    info = _npc_info[npc_name];

    // Validity checks for given NPCs.
    if(info->diurnal && !WEATHER->query_day(previous_object()))
      return 0;
    if(info->nocturnal && !WEATHER->query_day(previous_object()))
      return 0;
    if(info->seasonal &&
       member_array(WEATHER->query_season(), info->seasonal) == -1)
      return 0;
    
    if (stringp(info->path)) {
        if ( info->unique ) {
            npc = find_object( npc_path(info->path) );
            if ((!npc || !environment(npc)) && make_unique(npc_name)) {
               debug_printf("Unique npc %O", info);
               if (catch(npc = load_object( npc_path(info->path) ))) {
                   hospital_log_file("BAD_NPC_PATH", "Error loading %s (%s)\n", npc_name, info->path);
                   return 0;
               }
               if (!objectp(npc) || npc == 0) {
                   hospital_log_file("BAD_NPC_PATH", "Failed to load %s (%s)\n", npc_name, info->path);
                   return 0;
               }

               /* If the NPC has an environment, then we have to
                  bail because the NPC is already loaded somewhere. */

               if ( environment( npc ) ) {
                   debug_printf("NPC unique and already exists %O", npc_name);
                   return 0;
               }
            }
        } else if(info->transient) {
          if(!_cache_inventory)
            _cache_inventory = ([ ]);
          else if(_cache_inventory[npc_name])
            _cache_inventory[npc_name] -= ({ 0 });
          
          if(sizeof(_cache_inventory[npc_name])) {
            npc = _cache_inventory[npc_name][0];
            _cache_inventory[npc_name] -= ({ npc });
            info->no_reused++;
          } else {
            npc = clone_object( npc_path(info->path) );
            if(npc) {
              npc->add_property("transient", 1);
              npc->add_property("npc_id", npc_name);
              npc->add_property("hospital", base_name(this_object()));
              info->no_created++;
            } else
              debug_printf("Failed to clone %s", npc_path(info->path));
          }
        } else {
            if (is_npc_under_max_population(npc_name)) {
               npc = clone_object( npc_path(info->path) );
               info->no_created++;
               if (!npc) {
                  debug_printf("Npc path does not exist %O (%O)", npc, npc_path(info->path));
               }
            } else {
               debug_printf("NPC over max population %O", npc_name);
            }
        }
    } else {
        debug_printf("Broken npc data %O", info->path);
        return 0;
    }

    if (npc && !info->transient) {
        if( info->population == 0 )
            info->population = ({ });
        info->population += ({ npc });
        npc->add_property("npc_id", npc_name);
        foreach (zone in info->move_zones) {
            npc->add_move_zone(zone);
        }
        foreach (cmd in info->commands) {
            npc->init_command(cmd, 2);
        }
    }

    return npc;
} /* load_npc_object() */

/**
 * This method creates the npcs for the specificed group of npcs.
 * @param group_name the name of the group
 * @return the npcs
 */
object *load_group_npcs(string group_name) {
    class group_info group;
    int quantity;
    int i;
    object *npcs;
    string npc_name;
    object ob;
    object ob_bing;
    string cmd;

    if ( undefinedp(_group_info[group_name]) ||
         !is_group_under_max_population(group_name)) {
        return 0;
    }

    group = _group_info[group_name];

    /* Determine the population from the class, if this is undefined
     * then we make set it to DEFAULT_POPULATION.
     */

    npcs = ({ });
    foreach (npc_name, quantity in group->npcs) {
        quantity = roll_dice(quantity);
        for (i = 0; i < quantity; i++) {
            // If we have a problem loading one.  Dest them all.
            ob = load_npc_object(npc_name);
            if (!ob) {
               npcs->move("/room/rubbish");
               return ({ });
            }
            npcs += ({ ob });
            if (group->npc_commands[npc_name]) {
               foreach (cmd in group->npc_commands[npc_name]) {
                  ob->init_command(cmd, 2);
               }
            }
        }
    }

    if (!group->storage) {
        group->storage = ({ });
    }

    group->storage += ({ npcs });

    npcs->add_property("group_id", group_name);
    // Do any extra stuff on the npcs.
    foreach (ob in npcs) {
       foreach (ob_bing in npcs) {
          if (ob != ob_bing) {
             ob->add_follower(ob_bing);
             if (group->defend) {
               ob->add_defender(ob_bing);
             }
             if (group->protect) {
                ob->add_protector(ob_bing);
             }
          }
       }
    }

    return npcs;
} /* load_group_npcs() */

/**
 * This returns the npc info class for the npc in question.  THis should
 * only be used for debugging.
 * @param npc the name of the npc to get the info on
 * @return the class of the npc
 */
public class npc_info query_npc_info( string npc ) {
    if ( !_npc_info ) {
        return 0;
    }

    return _npc_info[ npc ];
} /* get_npc_info() */

/**
 * This returns all the npcs in the debug data array.
 * @return this returns the debug information for the npcs
 */
mapping query_debug_npc_info() {
   return _npc_info;
}

/**
 * This returns the group info class for the group in question.  THis should
 * only be used for debugging.
 * @param group the name of the group to get the info on
 * @return the class of the group
 */
public class group_info query_group_info( string group ) {
    if ( !_group_info ) {
        return 0;
    }

    return _group_info[ group ];
} /* query_group_info() */

/**
 * This method is called when a specific npc dies so we can do some
 * tracking on it.
 * @param npc_ob the npc object
 */
void npc_died(object ob) {
   string npc_id;
   class npc_info info;
   int i;
   mixed* stuff;

   npc_id = ob->query_property("npc_id");
   info = _npc_info[npc_id];
   if (!info || !npc_id) {
      return ;
   }

   info->population -= ({ ob });
   info->no_deaths++;

   // Find the npc in thr group if it is set.
   npc_id = ob->query_property("group_id");
   stuff = _group_info[npc_id]->storage;
   if (sizeof(stuff)) {
      for (i = 0; i < sizeof(stuff); i++) {
         stuff[i] -= ({ ob, 0 });
      }
      _group_info[npc_id]->storage = filter(_group_info[npc_id]->storage,
                                             (: sizeof($1) :));
   }
} /* npc_died() */

/** @ignore yes */
mapping query_all_npc_info() {
   return _npc_info;
}
/** @ignore yes */
mapping query_all_group_info() {
   return _group_info;
}
/** @ignore yes */
mapping query_all_zone_info() {
   return _zone_info;
}

private int count_chances_in_zone(string zone) {
    class zone_info info;
    int chance;

    info = _zone_info[zone];
    if (!zone) {
       return 0;
    }

    chance = info->npc_chance + info->group_chance + info->zone_chance;
    return chance;
} /* count_chance_in_zone() */

private object* create_npcs_in_zone(string zone, int pos) {
    class zone_info info;
    string extra;
    string npc;
    object ob;
    object* obs;
    int chance;

    info = _zone_info[zone];
    if (!zone) {
       return ({ });
    }
    
    if(_zone_info[zone]->busy &&
       _zone_info[zone]->busy < random(random(100)))
      return ({ });

    if (pos < info->npc_chance) {
       foreach (npc, chance in info->npcs) {
          if (pos < chance) {
             ob = load_npc_object(npc);
             if (ob) {
                return ({ ob });
             }
          }
          pos -= chance;
       }
    }
    pos -= info->npc_chance;
    if (pos < info->group_chance) {
       foreach (npc, chance in info->groups) {
          if (pos < chance) {
             obs = load_group_npcs(npc);
             if (sizeof(obs)) {
                return obs;
             }
          }
          pos -= chance;
       }
    }
    pos -= info->group_chance;
    foreach (extra, chance in info->zones) {
        if (pos < chance) {
           return load_random_npc(extra, -1, -1);
        }
    }
    return ({ });
} /* create_npcs_in_zone() */

/**
 * This method randomly selects an NPC or a group of NPC's from
 * the list of defined NPC's for the room/region.
 *
 * @param zone This is a zone (as defined in the configuration files).
 * @param wealth How wealthy this particular part of this zone is.
 * @param busy How busy this particular part of this zone is.
 * 
 * @return Returns a group of NPCs randomly selected.
 */
object* load_random_npc(string zone, int wealth, int busy) {
    int chance;
    int pos;

    if (_disable_npc_generation) {
        return ({ });
    }

    //
    // Try and see if we can find a specific zone for the
    // busyness/wealth of this zone
    //
    if (_zone_info[zone + "-w" + wealth + "-b" + busy]) {
       zone = zone + "-w" + wealth + "-b" + busy;
    } else if (_zone_info[zone + "-w" + wealth]) {
       zone = zone + "-w" + wealth;
    } else if (_zone_info[zone + "-b" + busy]) {
       zone = zone + "-b" + busy;
    }

    if (!_zone_info[zone]) {
        return ({ });
    }

    chance = count_chances_in_zone(zone);
    if (!chance) {
       return ({ });
    }
    pos = random(chance);
    return create_npcs_in_zone(zone, pos);
} /* load_random_npc() */

/**
 * Prints a report of all the npcs in the hospital currently.
 */
int do_report() {
    string name;
    class group_info group;
    class npc_info npc;
    string txt;
    int total;
    int max;
    int pop;

    txt = "";
    total = 0;

    txt += "%^WHITE%^NPCs%^RESET%^\n";
    foreach( name, npc in _npc_info ) {
      if(stringp(npc->path) && file_size(npc_path(npc->path) + ".c") > 0) {
        pop = query_npc_current_population(name, 0);
      } else {
        pop = 0;
      }
      if(npc->transient)
        txt += sprintf( "$I$5=Name: %s. (%s) (Transient) Reused %d Created %d Died %d\n", name + "",
                        (stringp(npc->path)?npc->path:"Broken!"),
                        npc->no_reused, npc->no_created, npc->no_deaths);
      else
        txt += sprintf( "$I$5=Name: %s. (%s) Population: (%d/%d) Created %d Died %d\n", name + "",
                        (stringp(npc->path)?npc->path:"Broken!"),
            pop, npc->max_population, npc->no_created, npc->no_deaths );
        total += pop;
        max += npc->max_population;
    }

    txt += "$I$0=%^WHITE%^Groups%^RESET%^\n";
    foreach( name, group in _group_info ) {
      if(group->transient)
        txt += sprintf( "$I$5=Name: %s. (%s) (Transient)\n", name,
            query_multiple_short(keys(group->npcs)));
      else
        txt += sprintf( "$I$5=Name: %s. (%s) Population: (%d/%d)\n", name,
            query_multiple_short(keys(group->npcs)),
            sizeof( group->storage ), group->max_population );
    }

    txt += "$I$0=%^WHITE%^Cache%^RESET%^\n";
    foreach(name in keys(_cache_inventory))
      _cache_inventory[name] -= ({ 0 });
      
    foreach(name, group in _cache_inventory)
      txt += sprintf("$I$5=Name: %s %d\n", name, sizeof(group));

    txt += "\nTotal NPCs in hospital: " + total + "/" +
            max + ".\n";
    write("$P$Report$P$" + txt );

    return 1;

} /* create_hospital_report() */

/** @ignore yes */
void init() {
  object ob;
  ob = this_player();

  add_command("report", "", (: do_report :));

  // Add returning npcs to our cache.
  if(ob->query_property("npc_id") && ob->query_property("hospital") &&
     ob->query_property("hospital") == base_name(this_object())) {
    if(!_cache_inventory[ob->query_property("npc_id")])
      _cache_inventory[ob->query_property("npc_id")] = ({ ob });
    else if(sizeof(_cache_inventory[ob->query_property("npc_id")]) >
            _max_cache)
      ob->move("/room/rubbish");
    else
      _cache_inventory[ob->query_property("npc_id")] += ({ ob });
  } else if(base_name(ob) == "/obj/corpse")
    ob->move("/room/rubbish");

} /* init() */

/** @ignore yes */
int no_attack() { return 1; }

/** @ignore yes */
mapping query_dynamic_auto_load() {
    string group_name;
    string npc;
    class group_info data;
    class npc_info npc_data;
    mapping tmp;
    mapping tmp2;

    tmp = allocate_mapping( sizeof( _group_info ) );

    foreach( group_name, data in _group_info ) {
        tmp[ group_name ] = data->storage;
    }

    tmp2 = allocate_mapping( sizeof( _npc_info) );
    foreach( npc, npc_data in _npc_info ) {
        tmp2[ npc ] = npc_data->population;
    }

    return ([ file_name( this_object() ) : tmp, "npcs" : tmp2 ]);

} /* query_dynamic_auto_load() */

/** @ignore yes */
void init_dynamic_arg( mapping tmp ) {
    string group_name;
    object *npcs;

    if ( tmp[ file_name( this_object() ) ] ) {
        foreach( group_name, npcs in tmp[ file_name( this_object() ) ] ) {
            if (_group_info[group_name]) {
               _group_info[ group_name ]->storage = npcs;
            }
        }
        foreach( group_name, npcs in tmp[ "npcs" ]) {
            if (_npc_info[group_name]) {
               _npc_info[ group_name ]->population = npcs;
            }
        }
    }
} /* init_dynamic_arg() */

/** @ignore yes
 * This is a debugging function. Beware, if you have a large hospital this
 * may lockup/crash the mud!
 */
mixed query_all_npcs() {
    return values( map( _group_info, (: $2->storage :) ) );
}
/** @ignore yes
 * This is a debugging function.
 */
mapping query_inventory_cache() {
  return copy(_cache_inventory);
}

/**
 * This function returns the ids of all the NPCs which are registered with the 
 * hospital, ie the ones that have to be specified with add_hospital_npc().
 *
 * @return All the ids.
 */
string* query_registered_npcs() {
    return keys( _npc_info );
} /* string* query_registered_npcs() */


// --- END [/mnt/home2/grok/lib/obj/handlers/hospital.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/nquest_handler.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/nquest_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628265   Available: 13575619
Inodes: Total: 5242880    Free: 4960134
14960 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/nquest_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628265   Available: 13575619
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: quest_handler.c,v 1.9 2000/07/29 14:49:21 taffyd Exp $
 * $Log: quest_handler.c,v $
 * Revision 1.9  2000/07/29 14:49:21  taffyd
 * Actually did what I said I did in 1.7 ;)
 *
 * Revision 1.8  2000/07/29 14:40:33  taffyd
 * Changed logging so that if there is no this_player() it uses
previous_object().  So that the web interface to the quests command works.
 *
 * Revision 1.7  2000/07/29 14:34:29  presto
 *  Forcibly unlocked by taffyd
 *
 * Revision 1.6  2000/07/29 02:18:20  pinkfish
 *  Forcibly unlocked by presto
 *
 * Revision 1.5  2000/03/17 20:55:07  ceres
 * Removed references to the old team handler
 *
 * Revision 1.4  1999/09/27 21:19:29  wodan
 * fixed ancient bug in query_fame_str and removed line that did nothing.
 *
 * Revision 1.3  1999/09/27 21:13:25  terano
 * Got it working.
 *
 * Revision 1.2  1999/05/20 01:02:27  ceres
 * Added status for quests
 *
 * Revision 1.1  1998/01/06 05:03:33  ceres
 * Initial revision
 * 
*/
/**
 * This class keeps track of the current set of quests availabe in the
 * game.
 * @author Furball
 */
#include <player_handler.h>

#define LIBRARY "/obj/handlers/nlibrary"
#define QUEST_LOG "QUESTS"
#define SAVE_FILE "/save/quests"
#define BACKUP_FILE "/save/quests/quests"

inherit "/std/object";

private int *quest_level;
private int *num_times_done;
private int *quest_status;
private string *quest_name;
private string *quest_title;
private string *quest_story;
private string *last_done_by;
private nosave int total_qp;

/**
 * This method reloads the quests from the save file.
 * @see save_quests()
 */
void load_quests() { unguarded( (: restore_object, SAVE_FILE :) ); }

/**
 * This method saves the current set of quests to the save file.
 * @see load_quests()
 */
void save_quests() { unguarded( (: save_object, SAVE_FILE :) ); }

void create() {
   int i;
   ::create();
   load_quests();
   if ( !quest_name ) {
      quest_name = ({ });
   }
   if ( !quest_level ) {
      quest_level = ({ });
   }
   if ( !quest_title ) {
      quest_title = ({ });
   }
   if ( !quest_story ) {
      quest_story = ({ });
   }
   if ( !last_done_by ) {
      last_done_by = ({ });
   }
   if ( !num_times_done ) {
      num_times_done = ({ });
   }
   if ( !quest_status ) {
     if(sizeof(quest_name)) {
       quest_status = allocate(sizeof(quest_name));
       for(i=0; i<sizeof(quest_name); i++) {
         quest_status[i] = 1;
       }
     } else {
       quest_status = ({ });
     }
   }
   
   for(i = 0; i<sizeof(quest_level); i++) {
     if(quest_status[i]) {
       total_qp += quest_level[i];
     }
   }
   
} /* create() */

/**
 * This returns the current total gp for all of the current quests.
 * @return the total gp
 */
int query_total_qp() { return total_qp; }

/**
 * This method adds a new quest into the system.  You only need to call
 * this ONCE.  The name of the quest must be unique.  The story is
 * what can be seen in the players books about the player.
 * @param name the name of the quest
 * @param level the level of the quest 0-100
 * @param title the title for finishing the quest, 0 for none
 * @param story the story about the quest
 * @return 1 if successful, 0 if not
 * @see delete_quest()
 * @see query_quest_level()
 * @see query_quest_title()
 * @see query_quest_story()
 */
int add_quest( string name, int level, string title, string story ) {
   string log_name;
    
   if ( member_array( name, quest_name ) != -1 )
      return 0;
      
   quest_name += ({ name });
   quest_level += ({ level });
   quest_title += ({ title });
   quest_story += ({ story });
   last_done_by += ({ "nobody" });
   num_times_done += ({ 0 });
   quest_status += ({ 1 }); //Make it active!   
   
   if ( this_player() ) {
      log_name = this_player()->query_name();
   }
   else {
      log_name = file_name( previous_object() );
   }
   
   log_file( QUEST_LOG, log_name +
         " added: "+ name +", "+ level +", "+ title +", "+ story +"\n" );
   save_quests();
   unguarded( (: cp, SAVE_FILE +".o", BACKUP_FILE +"."+ time() :) );
   total_qp += level;
   return 1;
} /* add_quest() */

/**
 * Change the status of a quest from active to inactive
 * and vice versa.
 * @param the name of a quest.
 */
int change_quest_status(string name) {
  int temp;

  temp = member_array(name, quest_name);
  if(temp == -1) {
    return -1;
  }
  quest_status[temp] = !quest_status[temp];
  return quest_status[temp];
}

/**
 * This method returns the status of a quest.
 * @param the name of a quest
 * @return 1 for active, 0 for inactive.
 */
int query_quest_status(string name) {
  int temp;

  temp = member_array(name, quest_name);
  if(temp == -1) {
    return -1;
  }
  return quest_status[temp];
}


/**
 * This method returns the level of the quest.
 * @param name the name of the quest
 * @return the level of the quest, -1 on failure
 * @see add_quest()
 * @see set_quest_level()
 */
int query_quest_level(string name) {
  int temp;

  temp = member_array(name, quest_name);
  if(temp == -1) {
    return -1;
  }
  return quest_level[temp];
} /* query_quest_level() */

/**
 * This method sets the level of the quest.
 * @param name the name of the quest
 * @param level the level of the quest
 * @return 0 on failure, 1 on success
 * @see add_quest()
 * @see query_quest_level()
 */
int set_quest_level(string name, int level) {
   int temp;
   string log_name;

   temp = member_array(name, quest_name);
   if(temp == -1) {
      return 0;
   }
   
   if ( this_player() ) {
      log_name = this_player()->query_name();
   }
   else {
      log_name = file_name( previous_object() );
   }
   
   log_file(QUEST_LOG, "%s : level set for %s to %d\n\n",
            log_name, name, level);
   quest_level[ temp ] = level;
   save_quests();
   return 1;
} /* set_quest_level() */

/**
 * This method returns the story associated with the quest.
 * @param name of the quest
 * @return the story of the quest
 * @see add_quest()
 * @see set_quest_story()
 */
string query_quest_story(string name) {
  int temp;

  temp = member_array(name, quest_name);
  if(temp == -1) {
    return "did nothing";
  }
  return quest_story[temp];
} /* query_quest_story() */

/**
 * This method sets the story associated with the quest.
 * @param name of the quest
 * @param story the new story of the quest
 * @see add_quest()
 * @see query_quest_story()
 */
int set_quest_story(string name, string story) {
   int temp;
   string log_name;

   temp = member_array(name, quest_name);
   if(temp == -1) {
      return 0;
   }
   
   if ( this_player() ) {
      log_name = this_player()->query_name();
   }
   else {
      log_name = file_name( previous_object() );
   }
   
   log_file(QUEST_LOG, "%s : story set for %s to %s\n\n",
            log_name, name, story);
   quest_story[ temp ] = story;
   save_quests();
   return 1;
} /* set_quest_story() */

/**
 * This method returns the title associated with the quest.
 * @param name of the quest
 * @return the title of the quest
 * @see add_quest()
 * @see set_quest_title()
 */
string query_quest_title(string name) {
  int temp;

  temp = member_array(name, quest_name);
  if(temp == -1 || quest_title[temp] == "") {
    return "Unknown Quester";
  }
  return quest_title[temp];
} /* query_quest_title() */

/**
 * This method sets the title associated with the quest.
 * @param name of the quest
 * @param title the new title of the quest
 * @see add_quest()
 * @see query_quest_title()
 */
int set_quest_title(string name, string title) {
   int temp;
   string log_name;

   temp = member_array(name, quest_name);
   if(temp == -1) {
      return 0;
   }
   
   if ( this_player() ) {
      log_name = this_player()->query_name();
   }
   else {
      log_name = file_name( previous_object() );
   }
   
   log_file(QUEST_LOG, "%s : title set for %s to %s\n\n",
            log_name, name, title);
   quest_title[ temp ] = title;
   save_quests();
   return 1;
} /* set_quest_title() */

/**
 * This method returns the number of times the quest has been
 * completed.
 * @param name thre name of the quest
 * @return the number of times completed
 * @see quest_completed()
 * @see add_quest()
 * @see query_quest_done()
 */
int query_quest_times( string name ) {
   int i;

   i = member_array( name, quest_name );
   if ( i == -1 )
      return -1;
   return num_times_done[ i ];
} /* query_quest_times() */

/**
 * This method returns the name of the last person to complete the
 * quest.
 * @param name thre name of the quest
 * @return the last person to complete the quest
 * @see quest_completed()
 * @see add_quest()
 * @see query_quest_times()
 */
mixed query_quest_done( string name ) {
   int i; 

   i = member_array( name, quest_name );
   if ( i == -1 )
      return -1;
   return last_done_by[ i ];
} /* query_quest_done() */

/**
 * This method removes the given quest from the system.
 * @see name the name of the quest to remove
 * @return 0 on failure, 1 on success
 * @see add_quest()
 */
int delete_quest(string name) {
   int temp;
   string log_name;
   
   if ( this_player() ) {
      log_name = this_player()->query_name();
   }
   else {
      log_name = file_name( previous_object() );
   }
   
   log_file(QUEST_LOG, log_name + " removed : " +
            name + "\n\n");
   temp = member_array(name, quest_name);
   if(temp == -1) {
      return 0;
   }
   total_qp -= quest_level[temp];
   quest_name = delete(quest_name, temp, 1);
   quest_level = delete(quest_level, temp, 1);
   quest_title = delete(quest_title, temp, 1);
   quest_story = delete(quest_story, temp, 1);
   last_done_by = delete( last_done_by, temp, 1 );
   num_times_done = delete( num_times_done, temp, 1 );
   save_quests();
   return 1;
} /* delete_quest() */

/**
 * This method returns the names of all the quests.
 * @return the names of all the quests
 * @see add_quest()
 * @see delete_quest()
 */
string *query_quest_names() {
  return quest_name + ({ });
} /* query_quest_names() */

/**
 * This method returns the levels of all the quests.
 * @return the levels of all the quests
 * @see add_quest()
 * @see delete_quest()
 */
int *query_quest_levels() {
  return quest_level + ({ });
} /* query_quest_levels() */

/**
 * This method returns the titles of all the quests.
 * @return the titles of all the quests
 * @see add_quest()
 * @see delete_quest()
 */
string *query_quest_titles() {
  return quest_title + ({ });
} /* query_quest_titles() */

/**
 * This method returns the stories of all the quests.
 * @return the stories of all the quests
 * @see add_quest()
 * @see delete_quest()
 */
string *query_quest_stories() {
  return quest_story + ({ });
} /* query_quest_stories() */

/**
 * This method should be called in the code when a quest is complete.
 * @param name name of the player
 * @param quest the quest completed
 * @param prev_ob the object which completed the quest
 * @see add_quest()
 * @see delete_quest()
 */
void quest_completed( string name, string quest, object prev_ob ) {
   int i;
   string word;

   log_file( QUEST_LOG, ctime( time() ) +" "+ name +" completed "+
         quest +"\n" );
   user_event( "inform", name +" completes "+ quest, "quest" );
   if ( file_name( previous_object() ) != LIBRARY ) {
      prev_ob = previous_object();
   }
   word = (string)prev_ob->query_name();
   if ( !word ) {
      word = file_name( prev_ob );
   } else {
      word += " ("+ file_name( prev_ob ) +")";
   }
   log_file( QUEST_LOG, "given by "+ word +"\n" );
   i = member_array( quest, quest_name );
   if ( i == -1 ) {
      log_file( QUEST_LOG, "non existent quest\n" );
      return;
   }
   last_done_by[ i ] = name;
   num_times_done[ i ]++;
   save_quests();
} /* query_completed() */

/* Fame functions - for use in halls of fame / libraries etc. */
/* Piecemaker 25/3/93                                         */

/**
 * This method returns the fame of the player.
 * Gets the fame percentage of the player. Quest points / total quest points
 * @param name the name of the player
 * @return the fame as a percentage (0-100)
 * @see query_player_story()
 * @see query_fame_string()
 * @see query_total_qp()
 */
int query_player_fame(string name){
   int playerqp, rank;

   /* do checking on the names */
   if (!name){
      return 0;
   }
   /* expand the nicknames if there are any */
   if (this_player()){
      name = (string)this_player()->expand_nickname(name);
   }
   /* are they a valid player ? */
   if (!PLAYER_HANDLER->test_user(name)){ 
      return 0;
   }   

   /* do the calculations */
   playerqp = (int)LIBRARY->query_quest_points(name);

   rank = ( playerqp * 125 ) / query_total_qp();
   return rank;
} /* query_player_fame() */

/**
 * This method returns a string associated with the fame level of the
 * player.
 * @param name the name of the player
 * @return the fame string
 * @see query_player_fame()
 * @see query_player_story()
 */
string query_fame_str( string name ) {
   switch ( query_player_fame( name ) ) {
      case 0 .. 4 :
         return "completely unknown";
      case 5 .. 14 :
         return "unknown";
      case 15 .. 24 :
         return "unknown";
      case 25 .. 34 :
         return "moderately well known";
      case 35 .. 44 :
         return "well known";
      case 45 .. 54 :
         return "very well known";
      case 55 .. 64 :
         return "known throughout the region";
      case 65 .. 74 :
         return "famous";
      case 75 .. 84 :
         return "renowned";
      case 85 .. 94 :
         return "Disc renowned";
      default :
         return "so renowned that no introduction is needed";
   }
} /* query_fame_str() */

/**
 * This method lists the stories for the quests the player has done.
 * @param name the name of the player
 * @return the story of the player
 * @see query_fame_string()
 * @see query_player_fame()
 */
string *query_player_story(string name){
   string *quests; 
   string *story;
   int i;

   story = ({ });
   /* do checking on the names */
   if (!name){
      return ({ });
   }
   /* expand the nicknames if there are any */
   if (this_player()){
      name = (string)this_player()->expand_nickname(name);
   }
   /* are they a valid player ? */
   if (!PLAYER_HANDLER->test_user(name)){ 
      return 0;
   }   

   /* right, we checked everything now. Lets do some real work. */
   quests = query_quest_names();
   if (sizeof(quests) == 1){
      story = ({"Is an under achiever."});
   }
   else{  
      for(i=0;i<sizeof(quests);i++){
         if (LIBRARY->query_quest_done(name, quests[i])){
            story = ({ query_quest_story( quests[ i ] ) }) + story;
         }
      }
   }
   return story;
} /* query_player_story() */

/**
 * This method prints out a lot of quest stats. For debugging purpsoes
 * only.
 */
void print_some_stats()  {
   int i;

   for (i = 0; i < sizeof(quest_name); i++)
      printf("%s: %6d, %3d\n", quest_name[i], num_times_done[i], quest_level[i]);
} /* print_some_stats() */
// --- END [/mnt/home2/grok/lib/obj/handlers/nquest_handler.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/data.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/data.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628261   Available: 13575615
Inodes: Total: 5242880    Free: 4960134
33433 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/data.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628261   Available: 13575615
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: data.c,v 1.14 2003/03/19 01:01:56 ceres Exp $
 * $Log: data.c,v $
 * Revision 1.14  2003/03/19 01:01:56  ceres
 * Increased compilation speed
 * .
 *
 * Revision 1.13  2002/11/18 01:40:54  ceres
 * modified to support binary true/false
 *
 * Revision 1.12  2002/08/16 01:12:06  pinkfish
 * Make it not call broken fps.
 *
 * Revision 1.11  2002/08/16 01:04:04  pinkfish
 * Make it skip compiling files with dested fps.
 *
 * Revision 1.10  2002/06/15 00:58:52  pinkfish
 * Fix up some issues.
 *
 * Revision 1.9  2002/03/11 03:21:49  pinkfish
 * Add in the file name to the call back.
 *
 * Revision 1.8  2002/03/10 23:52:10  pinkfish
 * Make it more resiliant to runtime errors and parse errors.
 *
 * Revision 1.7  2002/03/10 23:50:36  pinkfish
 * Add in a lisp like data compiler.
 *
 * Revision 1.6  2001/05/14 10:00:54  taffyd
 * Tweaks for better support for arrays.
 *
 * Revision 1.5  1999/11/16 03:35:50  jeremy
 * Fixed it so it breaks up the data into multiple functions,
 * so it should be able to handle much bigger data sets now.
 *
 * Also added the overwrite flag to write_file(); dunno why it
 * didn't bite us every time.
 *
 * Also removed all the #ifdef DEBUG and just #ifdef'd the
 * definition of Error().  I can't read code that has #ifdefs
 * all through it.
 *
 * Revision 1.4  1999/03/06 15:06:40  taffyd
 * Put in debug mode for now, till problem gets sorted out.
 *
 * Revision 1.3  1999/03/05 07:14:26  ceres
 * Made it log only when debugging
 *
 * Revision 1.2  1998/04/27 01:33:00  jeremy
 * Now preserves newlines in source file.  Makes the output easier to
 * debug and avoids "line too long" errors.
 *
 * Revision 1.1  1998/01/06 05:03:33  ceres
 * Initial revision
 * 
*/
/**
 * Universal data initialization handler.
 * The data initializer can be used to initialize databases for use in other
 * handlers.  The database is defined in a user-provided text file, with
 * a format similar to the virtual object compiler.  The input file is
 * converted to a temporary object, which allows fairly complicated
 * expressions to be used as data values.  The initializer can handle
 * arrays and mappings (nested to any level (theoretically)), with a base
 * element of any type, including mixed and classes.
 * <p>
 * Added in some code to allow it to compile lisp like files into a
 * mapping as well.
 * <p>
 * To initialize a variable, assign it the value returned by
 * compile_data() in the initializer.  compile_data() takes an array of
 * filenames as its only argument.
 * <p>
 * <b>File format</b>
 * The data file uses the following keywords.  Each keyword is followed
 * by the required data.  The data can be spread over multiple lines,
 * following the same rules as for LPC code, but the keywords must be at
 * the beginning of the line (preceded by optional whitespace).
 * <dl>
 * <dt>::data:: < array | mapping > [ of ] ... < base >
 * <dd>
 * This keyword defines the structure of the data.  The word "of" is
 * optional.  "array" and "mapping" may be repeated as many times as
 * desired.  "base" is the base type of the data.  For classes, it would
 * be of the form "class <classname>".  For types other than classes,
 * the base isn't really
 * used at this time, but something needs to be there to keep the parser
 * in line.  Some examples:
 * <b>
 * <pre>::data:: array of mapping of array of int
 * ::data:: mapping of mapping of mixed
 * ::data:: mapping of array of class myclass</pre>
 * There should only be one ::data:: keyword in the list of files passed
 * to compile_data().  Also, note that classes need to be defined before
 * this statement.  This can be done either with ::quote:: or
 * ::#include::.
 * <dt>::item <index> [,] ... :: [ value ]
 * <dd>This keyword defines the value for one item of the data.  <index> is
 * repeated as often as necessary, given the structure declared in the
 * ::data:: statement.  For mappings, the index can be any valid mapping key.
 * For arrays, the index can be either a number, or the strings i, i++,
 * or ++i, for current index, current index (incrementing afterwards), or
 * next index.  The value can (and probably should) be omitted for
 * classes, with the field values specified with the "->" keyword below.
 * Examples (corresponding to the three ::data:: examples above):
 * <pre>
 * ::item 0, "item 1", 2:: 42
 * ::item "a", "b":: ({ 1, "fred", ({ 2, 3 }) })
 * ::item "x" i++::
 * </pre>
 * <dt> ::-><field>:: <value>
 * <dd>This allows the fields of items of type class to be assigned
 * individually.  In general, the preceding ::item:: keyword should not
 * have been given a value.  The class must have been defined previously,
 * either with an ::#include:: directive, or with the ::quote:: keyword.
 * Examples:
 * <pre>
 * ::Quote::
 * class item_data {
 *     string *season;
 *     mixed  quant;
 *     string ob;
 * }
 * 
 * ::Data:: mapping of class item_data

 * :item "white clover"::
 * ::->season:: ({ "spring" })
 * ::->quant:: ({ 3, 4 })
 * ::->ob:: "/std/plant"
 * </pre>
 * These statements set the season, quant, and ob fields of the mapping
 * <dt>::quote:: <LPC code>
 * <dd>This keyword allows specific LPC statements to be inserted in the
 * object that creates the database.  To use this effectively requires a
 * little understanding of the translation process.  First, all lines
 * associated with a given keyword are folded into one line.  This means
 * that using the "//" comment delimiter in a ::quote:: will cause the
 * remainder of the quoted statements to be ignored.  Second, the
 * prototype of the function that returns the data isn't written until
 * the ::data:: keyword is encountered.  Therefore, any "global"
 * statements (such as class definitions) should be included or quoted
 * before the ::data:: line.  The easiest way to see what's going on is
 * to try a few examples and look at the resulting .c file (which is the
 * first data file name with ".c" stuck on the end).
 * </dl>
 * @example
 * mixed data;
 * data = "/obj/handlers/data"->compile_data(({ "/save/file1.dat",
 *      "/save/file2.dat" }));
 * // This will catenate the two files into one, translate it, and return
 * // the data.  Of course, someone has to create the data files also.
 * @author Jeremy
 */

#include <data.h>
#include <function.h>

#define CALLOUT_DELAY 0

#define DEBUG !
#define DC_DELIM 0
#define DC_ARRAY 1
#define DC_MAPPING 2
#define DC_OF 3
#define DC_CLASS 4
#define DC_STRING 5
#define DC_ITEM 6
#define DC_NUMBER 7
#define DC_GREY 8

// This is the number of characters it reads before starting a new
// function.  I set it to half of the biggest set of files that caused
// me problems.  It can be adjusted as needed.
#define MAX_SUBF_SIZE 16000

#define WHITESPACE(c) (c == 10 || c == 32 || c == '\n')

#ifdef DEBUG
#  define Error(s) write(s); log_file( "DATA_COMPILER", s);
#else
#  define Error(s) ;
#endif

string std_euid;

void create() {
    std_euid = "/secure/master"->creator_file(file_name(this_object()));
    seteuid(std_euid);
    //Error("Note: euid at creation is " + geteuid() + "\n");
}

int tmp_file_no;

private string strip_string( string str ) {
    int     i, j;
 
    if (!str || str == "") return "";
    j = strlen( str ) - 1;
    for( ; WHITESPACE( str[ i ] ) && i <= j; i++ ) ;
    for( ; WHITESPACE( str[ j ] ) && j > i; j-- ) ;
    return str[ i..j ];
} /* strip_space() */

private mixed cleanup_assoc( mixed parse ) {
    int j;

    // Clean out whitespace (seems like there should be an easier
    // way to do this...)
    for (j = 0; j < sizeof(parse[0]); j++) {
        if ((parse[1][j] == DC_DELIM) || (parse[1][j] == DC_OF)) {
            parse[0][j] = 0;
            parse[1][j] = 0;
        }
    }
    parse[0] -= ({ 0 });
    parse[1] -= ({ 0 });
    return parse;
} /* cleanup_assoc */

/**
 * Actualy compiles the files down.
 * See the header file for a more detailed explaination
 * @param path the files to parse
 */
mixed compile_data( string *path ) {
    string tmp_name, data = "", file_data = "", s1, tmp_val, base, keyword;
    string *segments, *ind, *val, cur_index;
    int i, j, t, debug_file, class_pending, stat, subfunc_cnt,
        subfunc_char_cnt, data_keyword_found, allocated_data;
    int *index_types;
    mixed parse, index_max;

    // Most of this is blatantly stolen from /global/virtual/compiler.c
    if (!sizeof(path))
      return 0;
    tmp_name = path[0] + "_dc.c";
    if( find_object( tmp_name ) )
        tmp_name->dest_me();
    if (file_size(tmp_name) > 0) {
        if ((stat = seteuid("Root")) == 0) {
            // This always happens.  But everything seems to work,
            // so I'll just take it out.
            // Error("Error: couldn't set euid to Root (" + stat + ", " +
            //       "secure/master"->valid_seteuid(this_object(), "Root") +
            //       ")\n");
        }
        stat = unguarded((: rm, tmp_name :));
        if (!stat) {
            Error("Error: couldn't remove old .c file (" +
                  geteuid(this_object()) + ", " +
                  "secure/master"->valid_seteuid(this_object(), "Root") +
                  ")\n");
            seteuid(std_euid);
            return 0;
        }
        //Error("Note: " + tmp_name + " removed (supposedly).\n");
    }
    seteuid(std_euid);
    for (i = 0; i < sizeof(path); i++) {
        if (file_size(path[i]) <= 0)
          continue;
        data += read_file( path[i] );
    }
    if (!data) {
        Error("Error: file(s) not found.\n");
        return 0;
    }
    /* Lines beginning with a # are a comment... */
    /* Break into segments at comments */
    segments = explode( "$\n" + data, "\n#" );
    if( !segments ) {
        Error( "prop_to_fun() : Nothing but comments?\n" );
        return 0;
    }
    /* Remove dummy $ (?) */
    segments[ 0 ] = segments[ 0 ][ 1..(sizeof(segments[ 0 ]) - 1) ];
    /* Remove comment lines */
    for( i = 1; i < sizeof( segments ); i++ ) {
        if( sscanf( segments[ i ], "%s\n%s", s1, segments[ i ] ) != 2 ) {
            segments[ i ] = "";
        }
    }
    /* Join segments together again */
    data = implode( segments, "\n" );
    
    /* See example file for explanation of syntax. */
 
    segments = explode( strip_string( data ), "::" );
    /* sizeof(segments) can be odd if the last line has no argument */
    if (sizeof( segments ) % 2) {
      segments += ({""});
    }
    ind = allocate( sizeof( segments ) / 2 );
    val = allocate( sizeof( segments ) / 2 );

    allocated_data = 0;
 
    for( i = 0; i < sizeof( ind ); i++ ) {
        ind[ i ] = segments[ i * 2 ];
        //val[ i ] = replace( segments[ i * 2 + 1 ], "\n", " " );
        // This preserves the newlines; it makes it more readable and avoids
        // line length problems.
        val[ i ] = strip_string( segments[ i * 2 + 1 ] );
        /* look for virtual compiler meta char */
        if( ind[ i ][ 0..0 ] == "#" ) {
            ind[ i ] = lower_case( ind[ i ] );
            if( ind[ i ] == "#debug" ) {
                /* debug errent virtual programs, ie, don't rm */
                /* the .c file if debug_file is non-zero */
                sscanf( val[ i ], "%d", debug_file );
            } else if( ind[ i ] == "#include" ) {
                /* include the file in setup(), just before the */
                /* object is cloned.  */
                tmp_val = val[i];
                file_data += "#include " + replace( tmp_val, " ", "" ) + "\n";
            }
        }
    }
    for( i = 0; i < sizeof( ind ); i++ ) {
        keyword = lower_case( ind[ i ] );
        if( keyword[ 0..0 ] == "#" ) {
            /* it's a virtual keyword don't stick it in the .c file */
            continue;
        }
        // Keep track of how big the function is.  The easiest way
        // to judge the amount of code is by counting the characters.
        subfunc_char_cnt += sizeof(ind[i]) + sizeof(val[i]);
        if (keyword == "data") {
            if (data_keyword_found) {
                Error("Error: more than one data keyword found.\n");
                return 0;
            }
            data_keyword_found = 1;
            // This declares the structure of the database
            file_data += "void dest_me() { destruct( this_object() ); }\n\n";
            // Break up code into multiple functions; big files can
            // run into trouble compiling.
            parse = reg_assoc(val[i],
                              ({ "array", "mapping", "of", "class +[^\t ]+",
                                 "[^\t ]+" }),
                              ({ DC_ARRAY, DC_MAPPING, DC_OF, DC_CLASS,
                                 DC_GREY }),
                              DC_DELIM);
            parse = cleanup_assoc( parse );
            //printf("parse = %O\n", parse);
            for (j = 0; (j < sizeof(parse[0])) && !index_max; j++) {
                switch (parse[1][j]) {
                  case DC_ARRAY:
                    break;
                  case DC_MAPPING:
                    break;
                  case DC_CLASS:
                    base = implode(parse[0][j..], " ");
                    file_data += base + " item;\n";
                  case DC_GREY:
                    index_types = parse[1][0..j-1];
                    index_max = allocate(sizeof(index_types));
                    break;
                  default:
                    Error("Error: data parse error 1 (" + parse[0][j] + ")\n");
                    return 0;
                }
            }
            if (index_types[0] == DC_MAPPING)
              file_data += "mapping data = ([ ]);\n\n";
            else
              file_data += "mixed data;\n\n";
            for (j = 0; j < sizeof(index_types); j++) {
                switch (index_types[j]) {
                  case DC_ARRAY:
                    index_max[j] = -1;
                    break;
                  case DC_MAPPING:
                    //index_max[j] = ([ ]);
                    break;
                  default:
                    Error("Error: illegal index type found ("
                          + index_types[j] + ")\n");
                    return 0;
                }
            }
            file_data += "mixed data_return_" + subfunc_cnt + "() {\n";
            subfunc_cnt++;
            continue;
        }
        if (keyword[0..3] == "item") {
            // This is where the actual array values get assigned
            // First take care of pending class assignments
            if (class_pending) {
                file_data += "  data" + cur_index + " = item;\n";
                class_pending = 0;
            }
            // Check to see if we should break to a new function (this
            // is the safest place, since we can't break up an item
            // definition).
            if (subfunc_char_cnt > MAX_SUBF_SIZE) {
                // This could theoretically fail if we somehow got more than
                // MAX_SUBF_SIZE characters before the first "data" keyword.
                // So it goes...
                file_data += "}\n\n";
                file_data += "mixed data_return_" + subfunc_cnt + "() {\n";
                subfunc_cnt++;
                subfunc_char_cnt = 0;
            }
            parse = reg_assoc( ind[i], ({ "\"[^\"]*\"", "item", "[0-9]+",
                                      "[^,\t ]+"}),
                              ({ DC_STRING, DC_ITEM, DC_NUMBER, DC_GREY }));
            parse = cleanup_assoc( parse );
            //printf("parse = %O\nindex_max = %O\n", parse, index_max);
            cur_index = "";
            for (j = 0; j < sizeof(index_types); j++) {
                switch (index_types[j]) {
                  case DC_ARRAY:
                    // Index can be a number, "i", "i++", or "++i"
                    if (parse[1][j+1] != DC_NUMBER) {
                        if (parse[0][j+1] == "i") {
                            parse[0][j+1] = index_max[j] + "";
                        } else if (parse[0][j+1] == "i++") {
                            parse[0][j+1] = index_max[j] + "";
                            index_max[j]++;
                        } else if (parse[0][j+1] == "++i") {
                            index_max[j]++;
                            parse[0][j+1] = index_max[j] + "";
                        } else {
                          Error("Error: illegal index for array (" +
                                  parse[0][j+1] + ")\n");
                            return 0;
                        }
                    }
                    if ((t = to_int(parse[0][j+1])) > index_max[j]) {
                        file_data += "  data" + cur_index
                          + " = allocate(" + (t-index_max[j]) + ");\n";
                        index_max[j] = t;
                        allocated_data = 1; 
                    }
                    break;
                  case DC_MAPPING:
                    if (j) {
                        file_data += "  if (!mapp(data" + cur_index + "))"
                          + " data" + cur_index + " = ([]);\n";
                    }
                    break;
                  default:
                    Error("Error: illegal index type found (" + index_types[j]
                          + ")\n");
                    return 0;
                } /* switch */
                cur_index += "[" + parse[0][j+1] + "]";
            } /* for */
            if (strip_string(val[i]) != "") {
                //printf("val[i] = %O\n", val[i]);
                file_data += "  data" + cur_index + " = " + val[i] + ";\n";
            }
            continue;
        } /* if */
        if (keyword[0..1] == "->") {
            // This is for handling fields of classes
            if (!class_pending) {
                file_data += "  item = new( " + base + " );\n";
                class_pending = 1;
            }
            file_data += "  item->" + ind[i][2..] + " = " + val[i] + ";\n";
            continue;
        }
        if (keyword == "quote") {
            // A backdoor for putting in specific LPC lines
            file_data += val[i] + "\n";
            continue;
        }
    } /* for */
    if (class_pending) {
        file_data += "  data" + cur_index + " = item;\n";
    }
    file_data += "}\n\n";
    file_data += "mixed data_return() {\n";

    if ( !allocated_data ) { 
        for (j = 0; j < sizeof(index_types); j++) {
            switch (index_types[j]) {
                case DC_ARRAY:
                    file_data += "  data = allocate(" + (to_int(index_max[j]) + 1) + ");\n";
                break;
            }
        } 
    }

    for (i = 0; i < subfunc_cnt; i++) {
        file_data += "  data_return_" + i + "();\n";
    }
    file_data += "  return data;\n}\n";
    seteuid("Root");
    unguarded((: write_file, tmp_name, file_data, 1 :));
    seteuid(std_euid);
    return tmp_name->data_return();
} /* compile_data() */

class data_node {
   int type;
   mixed value;
}

class queue_node {
   string name;
   class data_node data;
}

class compile_data {
   string file_name;
   function call_back;
   int current_line;
   int look_for;
   int last_chunk_compile;
   int file_len;
   class queue_node* depths;
}


private nosave class compile_data* _to_compile = ({ });

void start_compile();
void parse_chunk(class compile_data data, string chunk);

#define DATA_UNKNOWN 0
#define DATA_CHILDREN 1
#define DATA_NUMBER 2
#define DATA_STRING 3
#define DATA_LIST 4


#define OPEN_BRACKET 1
#define START_ARGUMENT 2
#define END_BRACKET 3
#define END_STRING 4
#define START_LIST 5
#define END_NUMBER 6
#define ARGUMENT_VALUE 7
#define ARGUMENT_NAME 8
#define REST_OF_ARGUMENT 9
#define END_STRING_LIST 10
#define END_NUMBER_LIST 11
#define END_LIST 12

#define CHUNK_SIZE 10

/**
 * Compiles up the file into the useful soul format.   It also tells
 * the soul about it.
 * <p>
 * See the soul data files in /save/new_soul for details of the format
 * for the soul files.   The file has to come from the soul save
 * directory or the call will not work.
 * @param fname the name of the file to compile
 */
void compile_file(string fname, function call_back) {
   class compile_data data;
/*
 * First, do we have read access to the file.
 * and is it actually a file?
 */   
   if (file_size(fname) == -1) {
      tell_object(this_player(), "The file "+
                         fname+" does not exist.\n");
      return ;
   }
   if (file_size(fname) == -2) {
      tell_object(this_player(), "The file "+
                         fname+" is a directory exist.\n");
      return ;
   }
   data = new(class compile_data);
   data->file_name = fname;
   data->call_back = call_back;
   data->look_for = OPEN_BRACKET;
   _to_compile += ({ data });
   start_compile();
} /* compile_file() */

/** @ignore yes */
void start_compile() {
   class compile_data data;

   /* We are already compiling */
   if (!sizeof(_to_compile) || _to_compile[0]->last_chunk_compile) {
      return ;
   }
   data = _to_compile[0];
   data->last_chunk_compile = time();
   data->current_line = 1;
   data->look_for = OPEN_BRACKET;
   data->file_len = file_length(data->file_name);
//current_result = new(class compile_node, type : 0, children : ([ ]) );
   data->depths = ({ new(class queue_node,
                  data : new(class data_node, type : 0, value : ([ ]) )) });
   call_out("compile_chunk", CALLOUT_DELAY);
} /* start_compile() */

/** @ignore yes */
void compile_chunk() {
   string chunk;
   int end;
   class compile_data data;

   data = _to_compile[0];
   data->last_chunk_compile = time();
   if (data->current_line > data->file_len ||
       functionp(data->call_back) & FP_OWNER_DESTED) {
      call_out("start_compile", CALLOUT_DELAY);
      _to_compile = _to_compile[1..];
      if (!(functionp(data->call_back) & FP_OWNER_DESTED)) {
         evaluate(data->call_back, data->file_name, data->depths[0]->data->value);
      }
      return ;
   }
   if (data->current_line+CHUNK_SIZE > data->file_len) {
      end = data->file_len+1;
   } else {
      end = data->current_line+CHUNK_SIZE;
   }
   chunk = unguarded((: read_file, data->file_name, data->current_line,
                               end-data->current_line :));
   data->current_line = end;
   call_out("compile_chunk", CALLOUT_DELAY);
   parse_chunk(data, chunk);
} /* compile_chunk() */

/**
 * This will return a normal integer, or a dice class.  The dice class
 * allows for things of the form 5d6+10 or 3d11-10.
 * @return the dice class
 */
mixed to_diceint(string str) {
   class data_dice dice;
   string s1;

   if (strsrch(str, "d") != -1) {
      dice = new(class data_dice);
      if (sscanf(str, "%dd%s", dice->number, s1) == 2) {
         if (strsrch(s1, "+")) {
            if (sscanf(s1, "%d+%d", dice->die, dice->modifier) != 2) {
               dice->die = to_int(s1);
            }
         } else if (strsrch(s1, "-")) {
            if (sscanf(s1, "%d-%d", dice->die, dice->modifier) != 2) {
               dice->die = to_int(s1);
            } else {
               dice->modifier = - dice->modifier;
            }
         } else {
            dice->die = to_int(s1);
         }
      }
      return dice;
   }

   return to_int(str);
} /* to_diceint() */

/** @ignore yes */
void parse_chunk(class compile_data data, string chunk) {
   /* Now.   What are we looking for? */
   /* Love, a nice place in the world, a happy bag full of groceries. */
   string *bits;
   string s1;
   string s2;
   string s3;
   int pos;
   int chunk_size;
   int start;
   class data_node node;

   // Scan out all the comments.
   while (sscanf(chunk, "%s#%s\n%s", s1, s2, s3) == 3) {
      chunk = s1 + s3;
   }

   chunk_size = strlen(chunk);
   pos = 0;
   bits = explode(chunk, "(");
   while (pos < chunk_size) {
      switch (data->look_for) {
         case OPEN_BRACKET :
            while (pos < chunk_size && (chunk[pos] == ' ' || 
                      chunk[pos] == '\t' || chunk[pos] == '\n')) {
               pos++;
            }
            if (pos == chunk_size) {
               break;
            }
            if (chunk[pos] == ')') {
               data->look_for = END_BRACKET;
               break;
            }
            if (chunk[pos] == '(') {
               chunk = chunk[pos+1..];
               chunk_size = strlen(chunk);
               pos = 0;
               node = new(class data_node, type : 0);
               data->depths += ({ new(class queue_node, data : node) });
               data->look_for = ARGUMENT_NAME;
            } else {
               pos = chunk_size;
            }
            break;

         case ARGUMENT_NAME :
            /* We look for the first non-space, non-tab, non-nl */
            while (pos < chunk_size && (chunk[pos] == ' ' || 
                      chunk[pos] == '\t' || chunk[pos] == '\n')) {
               pos++;
            }
            if (pos == chunk_size) {
               break;
            }
            start = pos;
            /* Ok, now we search for the next one. */
            while (pos < chunk_size && chunk[pos] != ' ' && 
                      chunk[pos] != '\t' && chunk[pos] != '\n') {
               pos++;
            }
            /* Thats it.   Our argument name. */
            data->depths[<1]->name = chunk[start..pos-1];
            data->look_for = ARGUMENT_VALUE;
            break;

         case ARGUMENT_VALUE :
         case START_LIST :
            while (pos < chunk_size && (chunk[pos] == ' ' || 
                      chunk[pos] == '\t' || chunk[pos] == '\n')) {
               pos++;
            }
            if (pos >= chunk_size) {
               break;
            }
            switch (chunk[pos]) {
               case '(' :
                  if (data->look_for == START_LIST) {
                     debug_printf("Error, found a bracket inside a list.\n");
                     pos = chunk_size;
                     break;
                  }
                  // Change it to look for a bracket.
                  data->look_for = OPEN_BRACKET;
                  data->depths[<1]->data->type = DATA_CHILDREN;
                  data->depths[<1]->data->value = ([ ]);
                  break;
               case '"' :
                  if (data->look_for == START_LIST) {
                     data->look_for = END_STRING_LIST;
                     data->depths[<1]->data->value += ({ "" });
                  } else {
                     data->look_for = END_STRING;
                     data->depths[<1]->data->value = "";
                  }
                  pos++;
                  data->depths[<1]->data->type = DATA_STRING;
                  break;
               case '0'..'9' :
                  // Number.
                  if (data->look_for == START_LIST) {
                     data->look_for = END_NUMBER_LIST;
                     data->depths[<1]->data->value += ({ "" });
                  } else {
                     data->look_for = END_NUMBER;
                     data->depths[<1]->data->value = "";
                  }
                  data->depths[<1]->data->type = DATA_NUMBER;
                  break;
               case '}' :
                  if (data->look_for == START_LIST) {
                     data->look_for = END_BRACKET;
                     pos++;
                     data->depths[<1]->data->type = DATA_LIST;
                  } else {
                     debug_printf("End of list without a start of list.\n");
                     pos = chunk_size;
                  }
                  break;
               case '{' :
                  if (data->look_for == START_LIST) {
                     debug_printf("Cannot have nested lists.\n");
                     pos = chunk_size;
                  } else {
                     data->look_for = START_LIST;
                  }
                  data->depths[<1]->data->value = ({ });
                  data->depths[<1]->data->type = DATA_LIST;
                  pos++;
                  break;
               default :
                 if(chunk[pos] = 't')
                  if(chunk[pos..pos+3] == "true" || chunk[pos..pos+2] == "yes") {
                    if(chunk[pos..pos+3] == "true")
                      pos += 3;
                    else
                      pos += 2;
                    
                    data->depths[<1]->data->value = 1;
                    data->depths[<1]->data->type = DATA_NUMBER;
                    data->look_for = END_BRACKET;
                    break;
                  }
                  debug_printf("Unknown data type %s in %s\n",
                               chunk[pos..pos+5], chunk);
                  pos = chunk_size;
                   
                  break;
            }
            break;

         case END_LIST :
            while (pos < chunk_size && (chunk[pos] == ' ' || 
                      chunk[pos] == '\t' || chunk[pos] == '\n')) {
               pos++;
            }
            if (pos >= chunk_size) {
               break;
            }
            switch (chunk[pos]) {
               case ',' :
                  pos++;
                  data->look_for = START_LIST;
                  break;
               case '}' :
                  data->look_for = START_LIST;
                  break;
               default :
                  debug_printf("Expected , or } not %s\n", chunk[pos..pos+5]);
                  pos = chunk_size;
                  break;
            }
            break;

         case END_BRACKET :
            if (sscanf(chunk[pos..], "%s)%s", s1, s2)) {
               if (arrayp(data->depths[<2]->data->value[data->depths[<1]->name])) {
                  data->depths[<2]->data->value[data->depths[<1]->name] += ({ 
                       data->depths[<1]->data->value });
               } else if (sizeof(data->depths) == 2) {
                  data->depths[<2]->data->value[data->depths[<1]->name] = ({ 
                       data->depths[<1]->data->value });
               } else if (!undefinedp(data->depths[<2]->data->value[data->depths[<1]->name])) {
                  data->depths[<2]->data->value[data->depths[<1]->name] = ({ 
                       data->depths[<2]->data->value[data->depths[<1]->name],
                       data->depths[<1]->data->value });
               } else {
                  data->depths[<2]->data->value[data->depths[<1]->name] = data->depths[<1]->data->value;
               }
               data->depths = data->depths[0..<2];
               chunk = s2;
               chunk_size = strlen(s2);
               pos = 0;
               data->look_for = OPEN_BRACKET;
            }
            break;

         case END_NUMBER_LIST :
         case END_NUMBER :
            // Look for the first non-number.
            start = pos;
            while (pos < chunk_size && ((chunk[pos] >= '0' && 
                      chunk[pos] <= '9') ||
                      chunk[pos] == 'd' || chunk[pos] == '+' ||
                      chunk[pos] == '-')) {
               pos++;
            }
            if (data->look_for == END_NUMBER) {
               data->depths[<1]->data->value += chunk[start..pos - 1];
            } else {
               data->depths[<1]->data->value[<1] += chunk[start..pos - 1];
            }
            if (pos < chunk_size) {
               if (data->look_for == END_NUMBER) {
                  data->depths[<1]->data->value = to_diceint(data->depths[<1]->data->value);
                  data->look_for = END_BRACKET;
               } else {
                  data->depths[<1]->data->value[<1] = to_diceint(data->depths[<1]->data->value[<1]);
                  data->look_for = END_LIST;
               }
            }
            break;

         case END_STRING_LIST :
         case END_STRING :
            if (sscanf(chunk[pos..], "%s\"%s", s1, s2)) {
               if (strlen(s1) > 0 && s1[strlen(s1)-1] == '\\') {
                  if (data->look_for == END_STRING) {
                     data->depths[<1]->data->value += replace(s1[0..strlen(s1)-2], "\n", "")+"\"";
                  } else {
                     data->depths[<1]->data->value[<1] += replace(s1[0..strlen(s1)-2], "\n", "")+"\"";
                  }
                  chunk = s2;
                  pos = 0;
                  chunk_size = strlen(s2);
               } else {
                  if (data->look_for == END_STRING) {
                     data->depths[<1]->data->value += replace(s1, "\n", "");
                     data->look_for = END_BRACKET;
                  } else {
                     data->depths[<1]->data->value[<1] += replace(s1, "\n", "")+"\"";
                     data->look_for = END_LIST;
                  }
                  chunk = s2;
                  pos = 0;
                  chunk_size = strlen(s2);
               }
            } else {
               if (data->look_for == END_STRING) {
                  data->depths[<1]->data->value += replace(chunk, "\n", "");
               } else {
                  data->depths[<1]->data->value[<1] += chunk;
               }
               pos = chunk_size;
            }
            break;

         default :
            debug_printf("Horrible error "+data->look_for+" (" +
                         data->file_name + ") " + data->current_line + " " +
                         chunk[pos..] + "\n");
            pos = chunk_size;
            break;
      }
   }

   //debug_printf("%O\n", data);
} /* parse_chunk() */
// --- END [/mnt/home2/grok/lib/obj/handlers/data.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/inhume.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/inhume.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628253   Available: 13575607
Inodes: Total: 5242880    Free: 4960134
837 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/inhume.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628253   Available: 13575607
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: inhume.c,v 3.16 2001/04/28 09:49:45 shrike Exp $
 *
*/
/*
 * Note: This is no longer the inhume handler.  I have moved the handler
 * to /obj/handlers/secure_handlers, which is a secure directory, To
 * prevent cheating creators from being able to share information with
 * their player friends.  If you believe you need access to the handler,
 * please speak to me or to your lord, who will be able to grant you access
 * to query the handler for info.
 *
 * --
 * Shrike
 */
#include <inhume.h>

void create() {
   string * prev;
   string msg;

   prev = map( previous_object(-1), (: file_name($1) :) );
   msg = sprintf( "%s: /obj/handlers/inhume loaded: previous_object(-1) = %O",
     ctime( time() ), prev );
   tell_creator( "shrike", msg );
   log_file( LOG, msg );
} /* create() */// --- END [/mnt/home2/grok/lib/obj/handlers/inhume.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/broadcaster.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/broadcaster.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628253   Available: 13575607
Inodes: Total: 5242880    Free: 4960134
14833 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/broadcaster.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628253   Available: 13575607
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: broadcaster.c,v 1.12 2002/06/15 00:58:52 pinkfish Exp $
 * $Log: broadcaster.c,v $
 * Revision 1.12  2002/06/15 00:58:52  pinkfish
 * Fix up some issues.
 *
 * Revision 1.11  1999/09/15 02:44:36  pinkfish
 * Make it handle unguardeding the save/loads.
 *
 * Revision 1.10  1999/06/04 00:46:34  pinkfish
 * Make it handle lots of people online when someone shouts.
 *
 * Revision 1.9  1999/05/15 23:43:34  ceres
 * Modified to only colour shouts (hopefully)
 *
 * Revision 1.7  1999/04/19 20:25:37  pinkfish
 * Fix up an error that was causing a runtime.
 *
 * Revision 1.6  1999/01/30 23:12:38  pinkfish
 * Make it remove empty channels and add in a method to determine if a
 * channel exists or not.
 *
 * Revision 1.5  1998/10/23 08:41:00  pinkfish
 * Added in a channel history feasture.
 *
 * Revision 1.3  1998/10/11 12:34:35  pinkfish
 * Add in code to the broadcaster to deal with channels.
 *
 * Revision 1.2  1998/04/06 07:02:48  sin
 * Installed Shaggy's change to keep track of NPCs who want to hear shouts.
 *
 * Revision 1.1  1998/01/06 05:03:33  ceres
 * Initial revision
 * 
*/
/**
 * Basic sight and sound broadcaster.
 */

#define DIR_ARRAY ({ "east", "northeast", "north", "northwest", \
                     "west", "southwest", "south", "southeast", "east" })

#define SAVE_FILE "/save/broadcaster"
#define BROADCAST_HISTORY_LENGTH 10

void broadcast_event( object *things,   /* things that get told about it */
                      int *centre,      /* coords where event occurs */
                      string message,   /* what the things get told */
                      int range,        /* range of telling in room units */
                      int inside,       /* tell things if indoors */
                      int underwater ); /* tell things if underwater */
void npc_hear_shouts(object newlistener);
int npc_unhear_shouts(object oldlistener);
void npc_shout_event( object shouter,
                      string start, 
                      string message,
                      string lang, 
                      int *coord, 
                      int range ); /* arguments for event_person_shout */
private void load_me();
private void save_me();
  
private nosave object *_listeners;
private nosave mapping _channels;
private nosave mapping _channel_history;
private mapping _channel_ids;

void create() {
   _listeners = ({ });
   _channels = ([ ]);
   _channel_ids = ([ ]);
   _channel_history = ([ ]);
   load_me();
} /* create() */

/**
 * This method returns the square distance, the name of the direction
 * the sound comes from and the up down offset.  It is used by the shout
 * code and by various other things that require this inofmraiont.
 * The return array is formated as:<br>
 * ({ square_distance, name_of_direction, z_offset })
 * @param co_ord1 the first co-ordinate
 * @param co_ord2 the co-ordinate to compare against
 * @return the array as described above
 */
mixed *get_direc_dist( int *co_ord1, int *co_ord2 ) {
   int dx, dy, dz, sector;

   if (!pointerp(co_ord1) ||
       !pointerp(co_ord2)) {
      // Make it right here...
      return ({ 0, DIR_ARRAY[0], 0 });
   }

   dx = co_ord1[ 0 ] - co_ord2[ 0 ];
   dy = co_ord1[ 1 ] - co_ord2[ 1 ];
   dz = co_ord1[ 2 ] - co_ord2[ 2 ];
   if ( dx > 0 ) {
      if ( ( 1000 * dy ) > ( 2414 * dx ) ) {
         sector = 0;
      } else {
         if ( ( 1000 * dy ) > ( 414 * dx ) ) {
            sector = 1;
         } else {
            if ( ( 1000 * dy ) > ( -414 * dx ) ) {
               sector = 2;
            } else {
               if ( ( 1000 * dy ) > ( -2414 * dx ) ) {
                  sector = 3;
               } else {
                  sector = 4;
               }
            }
         }
      }
   } else {
      if ( ( 1000 * dy ) < ( 2414 * dx ) ) {
         sector = 4;
      } else {
         if ( ( 1000 * dy ) < ( 414 * dx ) ) {
            sector = 5;
         } else {
            if ( ( 1000 * dy ) < ( -414 * dx ) ) {
               sector = 6;
            } else {
               if ( ( 1000 * dy ) < ( -2414 * dx ) ) {
                  sector = 7;
               } else {
                  sector = 8;
               }
            }
         }
      }
   }
   return ({ dx * dx + dy * dy + dz * dz, DIR_ARRAY[ sector ], dz });
} /* get_direc_dist() */

/**
 * Sends an event out to all the things.  It checks to make sure they
 * can hear the event and all that stuff.
 *
 * @param things things that get told about it 
 * @param centre coords where event occurs 
 * @param message what the things get told 
 * @param range range of telling in room units 
 * @param inside tell things if indoors 
 * @param underwater tell things if underwater 
 */
void broadcast_event( object *things, int *centre, string message,
      int range, int inside, int underwater ) {
   int *to;
   string text;
   object thing, place;
   mixed *dir_direc;

   if ( !pointerp( things ) ||
        !pointerp( centre ) ||
        sizeof( centre ) != 3 ) {
      return;
   }
   foreach ( thing in things ) {
      if ( !living( thing ) ) {
         continue;
      }
      /* Maybe something to inform non-living things later */
      place = environment( thing );
      if ( !place ) {
         continue;
      }
      to = (int *)place->query_co_ord();
      if ( !pointerp( to ) || sizeof( to ) != 3 ) {
         continue;
      }
      switch ( (string)place->query_property( "location" ) ) {
         case "inside" :
            if ( !inside ) {
               continue;
            }
            break;
         case "underwater" :
            if ( !underwater ) {
               continue;
            }
            break;
         default :
      }
      dir_direc = get_direc_dist( centre, to );
      if ( dir_direc[ 0 ] < 0 ) {
         /* So far away it's hit two's complement. */
         continue;
      }
      /* Lo, no need for square roots. */
      if ( dir_direc[ 0 ] > range * range ) {
         continue;
      }
      // This code is huge and fluffy, need to reset the cost in here a
      // little.
      //reset_eval_cost();
      switch ( dir_direc[ 0 ] ) {
         case 0 :
            /* They're in the same room - they should get told elsewhere. */
            continue;
         case 1 .. 2500 :
            /* Very close: 1 to 50 units */
            if ( ( dir_direc[ 2 ] * dir_direc[ 2 ] ) > ( dir_direc[ 0 ] / 2 ) ) {
               if ( dir_direc[ 2 ] > 0 ) {
                  text = "Right above you, "+ message +"\n";
               } else {
                  text = "Right below you, "+ message +"\n";
               }
            } else {
               text = "Very close to the "+ dir_direc[ 1 ] + ", "+
                     message +"\n";
            }
            break;
         case 2501 .. 40000 :
            /* Nearby: 50 to 200 units */
            text = "Nearby to the "+ dir_direc[ 1 ] + ", "+ message +"\n";
            break;
         case 40001 .. 640000 :
            /* 200 to 800 units */
            text = "To the "+ dir_direc[ 1 ] + ", "+ message +"\n";
            break;
         case 640001 .. 10240000 :
            /* In the distance: 800 to 1600 units */
            text = "In the distance to the "+ dir_direc[ 1 ] + ", "+
                  message +"\n";
            break;
         default:
            /* Too far away */
            continue;
      }
      if(interactive(thing) && query_verb() == "shout") {
        text = thing->colour_event("shout", "") + text + "%^RESET%^";
      }
      thing->add_message( "$I$5="+ text, ({ }) );
   }
} /* broadcast_event() */

/**
 * Adds an NPC to the list of NPC's who are to receive shout events.
 * The NPC need not be removed from this list when he dies -- desting
 * the NPC object has the same effect as calling npc_unhear_shouts().
 * event_person_shout() is activated on the NPC for all shouts.
 * NPC's do not normally detect shouts.
 * event_person_shout() on the NPC should be replaced with similar code 
 * to that in the broadcaster to determine if the shouter is within 
 * range and to generate the desired response.
 *
 * @param newlistener NPC object to be added to the list
 *
 * @see /global/events->event_person_shout()
 * @see npc_unhear_shouts()
 */
void npc_hear_shouts(object newlistener) {
  int i;

  if (member_array(newlistener,_listeners)!=-1) {
     return;
  }
  i = member_array(0,_listeners);
  if (i != -1) {
    _listeners[i]=newlistener;
  } else {
    _listeners=_listeners+({newlistener});
  }
} /* npc_hear_shouts() */

/**
 * Removes an NPC from the list of NPC's who are to receive shout events.
 * The NPC need not be removed from this list when he dies -- desting
 * the NPC object has the same effect as calling npc_unhear_shouts().
 *
 * @param oldlistener NPC object to be removed from the list
 * @return 1 if successfully removed
 *
 * @see /global/events->event_person_shout()
 * @see npc_hear_shouts()
 */
int npc_unhear_shouts(object oldlistener) {
  int i;

  if (sizeof(_listeners)==0) {
    return 0;
  }

  i = member_array(oldlistener,_listeners);
  if (i == -1) {
    return 0;
  }

  // Remove the listener
  _listeners = _listeners[0..i] + _listeners[i+1..];
  return 1;
} /* npc_unhear_shouts() */

/**
 * This method is called by the shout command to filter the shouts onto
 * the npcs that are listening.
 * @param shouter the person who shouted
 * @param start the start of the message
 * @param message the message shouted
 * @param lang the language the message is in
 * @param coord the co-ordinate it was shouted from
 * @param range the range of the shout
 */
void npc_shout_event( object shouter, string start, string message,
      string lang, int *coord, int range ) {
  
  if (_listeners) {
    _listeners -= ({ 0 });
    _listeners->event_person_shout(shouter, start, message,
                                  lang, coord, range );
  }
} /* npc_shout_event() */

/**
 * This method adds an object to the list of objects to be told about the
 * specfied channel.  The method called on the object for the channel
 * will be event_channel_message.  The method will be called with
 * three arguements, the first is the object generating the event
 * the second is the channel the event is generated on and the
 * third is the message being sent to the channel.
 * @param channel_name the name of the channel
 * @param ob the object to add to the list
 */
void add_object_to_channel(string channel_name,
                           object ob) {
   if (!_channels[channel_name]) {
      _channels[channel_name] = ({ });
   }
   _channels[channel_name] += ({ ob });
} /* add_object_to_channel() */

/**
 * This method removes an object from the list of objects to be told about the
 * specified channel.
 * @param channel_name the name of the channel
 * @param ob the object to add to the channel
 */
int remove_object_from_channel(string channel_name,
                               object ob) {
   if (_channels[channel_name]) {
      if (member_array(ob, _channels[channel_name]) != -1) {
         _channels[channel_name] -= ({ ob });
         if (!sizeof(_channels[channel_name])) {
           map_delete(_channels, channel_name);
         }
         return 1;
      }
   }
   return 0;
} /* remove_object_from_channel() */

/**
 * Inform channel of message.  The message will get sent to all the objects
 * added to the list to the method event_channel_message.  The method
 * will be called with three arguements, first is the object that started
 * the event, the second the channel it is being send to and the last is the
 * message being sent to the channel.
 * @param ob the object creating the channel event
 * @param channel the channel to inform people about
 * @param message the message to tell the channel about
 */
void broadcast_to_channel(mixed ob,
                          string channel,
                          mixed message) {
   string str;

   if (!ob) {
      return ;
   }
   if (objectp(ob)) {
      str = ob->query_cap_name();
   }
   if (_channels[channel]) {
      _channels[channel] -= ({ 0 });
      _channels[channel]->event_channel_message(ob, channel, message);

      // Put the message into the history list.
      if (!_channel_history[channel]) {
         _channel_history[channel] = ({ });
      }
      _channel_history[channel] += ({ ({ str, message, time() }) });
      if (sizeof(_channel_history[channel]) > BROADCAST_HISTORY_LENGTH) {
         _channel_history[channel] = _channel_history[channel][1..];
      }
   }
} /* broadcast_to_channel() */

/**
 * This message returns the current history list for the channel.  The
 * array is:<br>
 * ({ ({ person, message }), ... })
 * @param channel the channel to get the history of
 * @return the history of the channel
 * @see broadcast_to_channel()
 */
mixed *query_channel_history(string channel) {
   return _channel_history[channel];
} /* query_channel_history() */

/**
 * This method must only be used for debugging purposes.
 * @param channel the channel which has all these things on it
 * @return the array of objects in the channel
 * @see is_channel()
 */
object *query_channel_members(string channel) {
   return _channels[channel];
} /* query_channel_members() */

/**
 * This method checks to see if the channel exists.
 * @param channel the channel name to check for
 * @return 1 if the channel eixsts, 0 if not
 * @see query_channel_members()
 */
int is_channel(string channel) {
  return !undefinedp(_channels[channel]);
} /* is_channel() */

/** @ignore yes.  THis is definately definately not allowed to be used
 * in code, it is only allow to be used specifically for debugging
 * purposes.
 * @return the nice mapping
 */
mapping query_all_channels() {
   return _channels;
} /* query_all_channels() */

/**
 * This method keeps track of an ever increasing number for a specified
 * channel type.  THis is used in the wizards spell (for instance) to
 * keep track of unique ids for wizard channels.
 * @param channel the name of the channel
 * @return the next number in the series
 */
int query_next_channel_number(string channel) {
   int next_num;

   next_num = ++_channel_ids[channel];
   save_me();
   return next_num;
} /* query_next_channel_number() */

private void save_me() {
   unguarded( (: save_object(SAVE_FILE) :) );
} /* save_me() */

private void load_me() {
   unguarded( (: restore_object(SAVE_FILE, 1) :) );
} /* load_me() */

/** @ignore yes */
mapping query_dynamic_auto_load() {
   return ([ "channels" : _channels,
       "history" : _channel_history ]);
} /* query_dynamic_auto_load() */

void init_dynamic_arg(mapping arg) {
   _channels = arg["channels"];
   if (!_channels) {
      _channels = ([ ]);
   }
   _channel_history = arg["history"];
   if (!_channel_history) {
      _channel_history = ([ ]);
   }
} /* init_dynamic_arg() */
// --- END [/mnt/home2/grok/lib/obj/handlers/broadcaster.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/options_handler.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/options_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628249   Available: 13575603
Inodes: Total: 5242880    Free: 4960134
34504 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/options_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628249   Available: 13575603
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This handler deals will the options a player has.  It will return the
 * list of options, set options and control how the options can be
 * set.
 * @author Pinkfish
 * @started Thu Jun  8 17:13:47 PDT 2000
 */
#include <cmds/options.h>
#include <cmds/teach.h>
#include <colour.h>
#include <clubs.h>
#include <ls.h>
#include <obj_parser.h>
#include <player.h>
#include <creator.h>
#include <terrain_map.h>
#include <error_handler.h>

class option {
   mixed type;
   int restriction;
   function set;
   function query;
   mapping suboptions;
   string help;
}

private mapping _options;
private string* _colours;
private mapping _cache_input;

protected int add_option(string path, mixed type, int cre_only,
                         function set_function, function query_function,
                         string help);
private int set_player_brief(object player, string variable, int value);
private int query_player_brief(object player, string variable);
private mapping get_inform_colours(object player);
private mapping get_club_colours(object player);
private int change_bool_property(string prop, object player, int new_value);
private int change_earmuffs(object player, string ear, int new_value);
private int setup_earmuffs(object player, string value);
private int valid_birthday(string str);
private string convert_birthday(string birthday);
private int change_error_reports(object player, string ear, int new_value);

void create() {
   string womble;

   _options = ([ ]);
   _cache_input = ([ ]);
   _colours = ({
    "BOLD",
    "FLASH",
    "BLACK",
    "RED",
    "BLUE",
    "CYAN",
    "MAGENTA",
    "ORANGE",
    "YELLOW",
    "GREEN",
    "WHITE",
    "B_RED",
    "B_ORANGE",
    "B_YELLOW",
    "B_BLACK",
    "B_CYAN",
    "B_WHITE",
    "B_GREEN",
    "B_MAGENTA" });

   //
   // Output brief/verbose.
   //
   add_option("output look", OPTIONS_TYPE_BRIEF, OPTIONS_TYPE_ALL,
              (: $1->set_verbose($2[<1], $3), 1 :),
              (: $1->query_verbose($2[<1]) :),
              "Display room descriptions briefly or in full");
   add_option("output combat", OPTIONS_TYPE_BRIEF, OPTIONS_TYPE_ALL,
              (: $1->set_verbose($2[<1], $3), 1 :),
              (: $1->query_verbose($2[<1]) :),
              "Display all combat messages or only those involving damage");
   add_option("output errors", OPTIONS_TYPE_BRIEF, OPTIONS_TYPE_CRE_ONLY,
              (: $1->set_verbose($2[<1], $3), 1 :),
              (: $1->query_verbose($2[<1]) :),
              "Display errors in the error handler briefly");
   add_option("output score", OPTIONS_TYPE_BRIEF, OPTIONS_TYPE_ALL,
              (: $1->set_verbose($2[<1], $3), 1 :),
              (: $1->query_verbose($2[<1]) :),
              "Amount of detail to be displayed by the 'score' command");
   add_option("output accent", ({ "mangle", "unadulterated" }),
              OPTIONS_TYPE_ALL,
              (: $1->set_mangle_accent($3 == "mangle"), 1 :),
              (: $1->query_mangle_accent() ? "mangle" : "unadulterated" :),
              "Show others speech with or without regional accents");
   add_option("output names", OPTIONS_TYPE_BRIEF, OPTIONS_TYPE_ALL,
              (: $1->set_verbose($2[<1], $3), 1 :),
              (: $1->query_verbose($2[<1]) :),
              "Display player names with or without title and surname");
   add_option("output htell", OPTIONS_TYPE_BRIEF, OPTIONS_TYPE_ALL,
              (: $1->set_verbose($2[<1], $3), 1 :),
              (: $1->query_verbose($2[<1]) :),
              "Cause the 'htell' command to display times for tells or not");
   add_option("output msgout", OPTIONS_TYPE_STRING, OPTIONS_TYPE_CRE_ONLY,
              (: $1->set_msgout($3) :),
              (: $1->query_msgout() :),
              "The message that is displayed when you walk out of a room");
   add_option("output msgin", OPTIONS_TYPE_STRING, OPTIONS_TYPE_CRE_ONLY,
              (: $1->set_msgin($3) :),
              (: $1->query_msgin() :),
              "The message that is displayed when you walk into a room");
   add_option("output mmsgout", OPTIONS_TYPE_STRING, OPTIONS_TYPE_CRE_ONLY,
              (: $1->set_mmsgout($3) :),
              (: $1->query_mmsgout() :),
              "The message that is displayed when you trans out of a room");
   add_option("output mmsgin", OPTIONS_TYPE_STRING, OPTIONS_TYPE_CRE_ONLY,
              (: $1->set_mmsgin($3) :),
              (: $1->query_mmsgin() :),
              "The message that is displayed when you trans into of a room");
   add_option("output usercolour",
              OPTIONS_TYPE_BOOLEAN, 0,
              (: $3?$1->add_property(PLAYER_ALLOW_COLOURED_SOULS, 1):
                    $1->remove_property(PLAYER_ALLOW_COLOURED_SOULS), 1 :),
              (: $1->query_property(PLAYER_ALLOW_COLOURED_SOULS) :),
              "Display user chosen colours in souls");
   add_option("output plainmaps",
              OPTIONS_TYPE_BOOLEAN, 0,
              (: $3?$1->add_property(PLAYER_PLAIN_MAPS, 1):
                    $1->remove_property(PLAYER_PLAIN_MAPS), 1 :),
              (: $1->query_property(PLAYER_PLAIN_MAPS) :),
              "Display terrain maps without colour");
   add_option("output lookmap", OPTIONS_TYPE_BOOLEAN,
              OPTIONS_TYPE_PLAYTESTER_ONLY,
              (: $3?$1->add_property(TERRAIN_MAP_IN_LOOK_PROP, 1):
                    $1->remove_property(TERRAIN_MAP_IN_LOOK_PROP), 1 :),
              (: $1->query_property(TERRAIN_MAP_IN_LOOK_PROP) :),
              "Display room a map in the terrain long or not");

   add_option( "output tabstops", OPTIONS_TYPE_INTEGER, OPTIONS_TYPE_CRE_ONLY,
              (: $1->add_property( TABSTOP_PROP, $3 ) :),
              (: $1->query_property( TABSTOP_PROP ) :),
               "Show tabstops as <TAB> or as spaces");
   add_option( "output shorthand", OPTIONS_TYPE_BOOLEAN, 0,
               (: $1->add_property( SHORTHAND_OUTPUT_PROP, $3 ) :),
               (: $1->query_property( SHORTHAND_OUTPUT_PROP ) :),
               "Convert others shorthand text into long form");
   
   //
   // Colours.
   //
   foreach (womble in USER_COLOUR_LIST) {
      add_option("colour " + womble, OPTIONS_TYPE_COLOUR, 0,
                 (: $1->set_my_colours($2[<1], $3), 1 :),
                 (: $1->colour_event($2[<1], "default") :),
                 "The colour for " + womble + " messages");
   }
   foreach (womble in ADDITIONAL_CHANNELS) {
     add_option("colour " + womble, OPTIONS_TYPE_COLOUR, OPTIONS_TYPE_CRE_ONLY,
                (: $1->set_my_colours($2[<1], $3), 1 :),
                (: $1->colour_event($2[<1], "default") :),
                "The colour for " + womble + " messages");
   }
   foreach (womble in "/secure/master"->query_domains() - NO_CHANNELS) {
     add_option("colour " + womble, OPTIONS_TYPE_COLOUR, OPTIONS_TYPE_CRE_ONLY,
                (: $1->set_my_colours($2[<1], $3), 1 :),
                 (: $1->colour_event($2[<1], "default") :),
                "The colour for " + womble + " messages");
   }
   
   add_option("colour inform", OPTIONS_TYPE_DYNAMIC_GROUP, 0,
              0, (: get_inform_colours :),
              "The colours of various informational messages");
   add_option("colour club", OPTIONS_TYPE_DYNAMIC_GROUP, 0,
              0, (: get_club_colours :),
              "The colour for club messages");

   //
   // Terminal stuff.
   //
   add_option("terminal type", OPTIONS_TYPE_TERMINAL, 0,
              (: $1->set_term_type($3), 1 :),
              (: $1->query_term_name() :),
              "The type of terminal you are using");
   add_option("terminal rows", OPTIONS_TYPE_INTEGER, 0,
              (: $1->set_rows($3), 1 :),
              (: $1->query_rows() :),
              "The number of rows in your terminal");
   add_option("terminal cols", OPTIONS_TYPE_INTEGER, 0,
              (: $1->set_cols($3), 1 :),
              (: $1->query_cols() :),
              "The number of coloumns in your terminal");

   //
   // Combat stuff.  Wimpy etc.
   //
    
    add_option("combat wimpy", OPTIONS_TYPE_INTEGER, 0,
              (: $1->set_wimpy($3) :),
              (: $1->query_wimpy() :),
               "The percentage of your hitpoints at which you will run away");
   add_option("combat monitor", MONITOR_OPTIONS, 0,
              (: $1->set_monitor(member_array($3, MONITOR_OPTIONS)), 1 :),
              (: MONITOR_OPTIONS[$1->query_monitor()] :),
              "The frequency of display of your combat monitor");
   add_option("combat tactics attitude",
              ({ "insane", "offensive", "neutral", "defensive", "wimp" }), 0,
              (: $1->set_combat_attitude($3), 1 :),
              (: $1->query_combat_attitude() :),
              "Your combat attitude (see help tactics)");
   add_option("combat tactics response",
              ({ "dodge", "neutral", "parry" }), 0,
              (: $1->set_combat_response($3), 1 :),
              (: $1->query_combat_response() :),
              "Your combat response (see help tactics)");
   add_option("combat tactics parry",
              ({ "left", "right", "both" }), 0,
              (: $1->set_combat_parry($3), 1 :),
              (: $1->query_combat_parry() :),
              "Which hand you will parry with (see help tactics)");
   add_option("combat tactics unarmed_parry",
              OPTIONS_TYPE_BOOLEAN, 0,
              (: $1->set_unarmed_parry($3), 1 :),
              (: $1->query_unarmed_parry() :),
              "Which hand you will parry with (see help tactics)");
   add_option("combat tactics attack",
              ({ "left", "right", "both" }), 0,
              (: $1->set_combat_attack($3), 1 :),
              (: $1->query_combat_attack() :),
              "Which hand you will attack with (see help tactics)");
#ifdef USE_SURRENDER
   add_option("combat tactics mercy",
              ({ "always", "ask", "never" }), 0,
              (: $1->set_combat_mercy($3), 1 :),
              (: $1->query_combat_mercy() :),
              "Whether or not you will show mercy to opponents");
#endif   
   add_option("combat tactics focus",
              ({"upper body", "lower body", "head", "neck", "chest",
                  "abdomen", "arms", "hands", "legs", "feet", "none"}), 0,
              (: $1->set_combat_focus($3), 1 :),
              (: $1->query_combat_focus() :),
              "Which body part you will focus on in combat (see help tactics)");
#ifdef USE_DISTANCE
   add_option("combat tactics distance",
              ({"long", "medium", "close", "hand-to-hand", "none" }), 0,
              (: $1->set_combat_distance($3), 1 :),
              (: $1->query_combat_distance() :),
              "Your ideal combat distance (see help tactics)");
#endif   
   add_option("combat killer",
              OPTIONS_TYPE_BOOLEAN, 1,
              (: $1->set_player_killer($3) :),
              (: $1->query_player_killer() :),
              "Whether or not you are a registered player killer");
   //
   // Input options.
   //
   add_option("input ambiguous", OPTIONS_TYPE_BOOLEAN, 0,
              (: change_bool_property(OBJ_PARSER_AMBIGUOUS_PROP, $1, !$3) :),
              (: !$1->query_property(OBJ_PARSER_AMBIGUOUS_PROP) :),
              "Should the parser notify you of ambiguities");
   add_option("input andascomma", OPTIONS_TYPE_BOOLEAN, 0,
              (: change_bool_property(OBJ_PARSER_USE_AND_AS_BREAK_PROP, $1, !$3) :),
          (: !$1->query_property(OBJ_PARSER_USE_AND_AS_BREAK_PROP) :),
              "Should 'and' be treated as a comma (an inclusive list)");
   add_option("input editor", ({ "menu", "magic", "command", "ed" }), 0,
              (: $1->set_editor($3) :),
              (: $1->query_editor() :),
              "Your preferred editor");
   add_option( "input shorthand", OPTIONS_TYPE_BOOLEAN, 0,
               (: $1->add_property( SHORTHAND_PROP, $3 ) :),
               (: $1->query_property( SHORTHAND_PROP ) :),
               "Convert your shorthand typing into long form");

   //
   // Earmuffs.
   //
   foreach (womble in ({ "shout", "newbie", "cryer", "remote-soul",
                           "multiple-soul", "multiple-tell",  "teach",
                           "tell", "remote", "multiple-remote" })) {
     add_option("earmuff events "  + womble, OPTIONS_TYPE_BOOLEAN, 0,
                (: change_earmuffs($1, $2[<1], $3) :),
                (: member_array($2[<1], ($1->query_property("earmuffs")?$1->query_property("earmuffs"):({}))) != -1 :),
                "Should you be informed of " + womble + " messages");
   }
   foreach(womble in ADDITIONAL_CHANNELS) {
     add_option("earmuff events "  + womble, OPTIONS_TYPE_BOOLEAN, OPTIONS_TYPE_CRE_ONLY,
                (: change_earmuffs($1, $2[<1], $3) :),
                (: member_array($2[<1], ($1->query_property("earmuffs")?$1->query_property("earmuffs"):({}))) != -1 :),
                "Should you be informed of " + womble + " messages");
   }
   foreach(womble in "/secure/master"->query_domains() - NO_CHANNELS) {
     add_option("earmuff events "  + womble, OPTIONS_TYPE_BOOLEAN, OPTIONS_TYPE_CRE_ONLY,
                (: change_earmuffs($1, $2[<1], $3) :),
                (: member_array($2[<1], ($1->query_property("earmuffs")?$1->query_property("earmuffs"):({}))) != -1 :),
                "Should you be informed of " + womble + " messages");
   }
   
   foreach(womble in ({ "lord", "intermud-all", "intercre",
                          "intergossip", "dwcre", "dwchat", "remote-spam" })) {
     add_option("earmuff events "  + womble, OPTIONS_TYPE_BOOLEAN, OPTIONS_TYPE_CRE_ONLY,
                (: change_earmuffs($1, $2[<1], $3) :),
                (: member_array($2[<1], ($1->query_property("earmuffs")?$1->query_property("earmuffs"):({}))) != -1 :),
                "Should you be informed of " + womble + " messages");
   }
   add_option("earmuff state", 
              ({ "on", "off", "allowfriends" }), 0,
              (: setup_earmuffs($1, $3) :),
              (: $1->query_earmuffs()? ($1->query_earmuffs() == PLAYER_ALLOW_FRIENDS_EARMUFF ? "allowfriends" : "on") : "off" :),
              "Enable or disable earmuffs always or just for friends");

   add_option("earmuff cut-through", ({ "off", "ask", "auto"}), 1,
              (: $1->add_property("cut earmuffed tells",
                    member_array($3, ({ "off", "ask", "auto"}))) :),
              (: ({ "off", "ask", "auto" })[$1->query_property(
                                             "cut earmuffed tells")] :),
              "Cut through a players tell earmuffs");
   //
   // Creator Command options
   //

   add_option("command ls use_nickname", OPTIONS_TYPE_BOOLEAN, OPTIONS_TYPE_CRE_ONLY,
              (: $3 ? change_bool_property( LS_COMMAND_NICKNAME_PROPERTY, $1, 1 ) : change_bool_property( LS_COMMAND_NICKNAME_PROPERTY, $1, 0 ) :),
              (: $1->query_property( LS_COMMAND_NICKNAME_PROPERTY ) :),
              "Should 'ls' check for nicknames");
   foreach(womble in ERROR_TYPE) {
      womble = lower_case(womble);
      add_option("command look error " + womble, OPTIONS_TYPE_BOOLEAN,
              OPTIONS_TYPE_CRE_ONLY,
              (: change_error_reports($1, $2[<1], $3) :),
              (: member_array(upper_case($2[<1]), ($1->query_property(PLAYER_SHOW_ERRORS_PROP)?$1->query_property(PLAYER_SHOW_ERRORS_PROP):({}))) != -1 :),
              "Show the errors of type " + lower_case(womble) +
              " when doing a look.");
   }

   //
   // Player options.
   //
   add_option("personal description", OPTIONS_TYPE_STRING, 0,
              (: strlen($3) > 30?0:($1->set_desc($3 == "none"?0:$3), 1) :),
              (: (($1->query_desc())?($1->query_desc()):"none") :),
              "Ain't you perdy");
   add_option("personal real_name", OPTIONS_TYPE_STRING, 0,
              (: strlen($3) > 30?0:($1->set_real_name($3 == "none"?0:$3), 1) :),
              (: (($1->query_real_name())?($1->query_real_name()):"none") :),
              "The real name displayed in your finger information");
   add_option("personal location", OPTIONS_TYPE_STRING, 0,
              (: strlen($3) > 30?0:($1->set_where($3 == "none"?0:$3), 1) :),
              (: (($1->query_where())?($1->query_where()):"none") :),
              "The location displayed in your finger information");
   add_option("personal home_page", OPTIONS_TYPE_STRING, 0,
              (: strlen($3) > 30?0:($1->set_homepage($3 == "none"?0:$3), 1) :),
              (: (($1->query_homepage())?($1->query_homepage()):"none") :),
              "The url displayed in your finger information");
   add_option("personal email", OPTIONS_TYPE_STRING, 0,
              (: strlen($3) > 30?0:($1->set_email($3 == "none"?0:$3), 1) :),
              (: (($1->query_email())?($1->query_email()):"none") :),
              "The email address displayed in your finger information");
   add_option("personal birthday", OPTIONS_TYPE_STRING, 0,
              (: (!valid_birthday($3) || $1->query_birthday())? 0:($1->set_birthday($3 == "none"?0:convert_birthday($3)), 1) :),
              (: (($1->query_birthday())?($1->query_birthday()):"none") :),
              "Your birthday");
   add_option("personal execinclude", OPTIONS_TYPE_STRING, 0,
              (: ($3=="none"?$1->remove_property(OPTION_EXEC_INCLUDE):$1->add_property(OPTION_EXEC_INCLUDE, $3)), 1 :),
              (: ($1->query_property(OPTION_EXEC_INCLUDE)?$1->query_property(OPTION_EXEC_INCLUDE):"none") :),
              "The path of files to be included in exec commands?");
   add_option("personal auto teach", OPTIONS_TYPE_BOOLEAN, 0,
              (: $3?$1->add_property(TEACH_COMMAND_AUTO_PROPERTY,$3):$1->remove_property(TEACH_COMMAND_AUTO_PROPERTY) :),
              (: $1->query_property(TEACH_COMMAND_AUTO_PROPERTY) :),
              "Are you available to auto-teach");

   add_option("personal travel",
              ({ "walk", "journey" }), 0,
              (: $3 == "walk" ?$1->remove_property(TERRAIN_MAP_LONG_JUMP_PROPERTY):$1->add_property(TERRAIN_MAP_LONG_JUMP_PROPERTY,1), 1 :),
              (: $1->query_property(TERRAIN_MAP_LONG_JUMP_PROPERTY)?"journey":"walk" :),
              "By default should you walk or journey across terrains");

   //
   // Playtester options.
   //
   add_option("playtester protection", OPTIONS_TYPE_BOOLEAN,
              OPTIONS_TYPE_PLAYTESTER_ONLY,
              (: $3 ? $1->enable_personal_pt_protection() : $1->disable_personal_pt_protection() :),
              (: $1->query_pt_protection() :),
              "Enable or disable playtester protection");

   add_option("personal roleplaying", OPTIONS_TYPE_BOOLEAN, OPTIONS_TYPE_PLAYTESTER_ONLY,
              (: $1->set_role_playing($3), 1 :),
              (: $1->query_role_playing() :),
              "Enable or disable roleplaying mode");

} /* create() */

/**
 * This method adds in an option for the player to be able to set to
 * a mapping.  This method should be used by all the dynamic tree
 * methods to create leaves.
 * @param array the mapping to add the elements to
 * @param path the path to the option eg: ({ "output", "look" })
 * @param type the type of the option eg: OPTIONS_TYPE_BRIEF
 * @param set_function the function to call to set the option
 * @param query_function the function to call to query the option
 * @return 1 if successful, 0 if not
 */
protected void add_option_to_mapping(mapping array, string name, mixed type,
                                     int cre_only, function set_function,
                                     function query_function, string help) {
   class option fluff;

   //
   // Got to the end.
   //
   fluff = new(class option);
   fluff->type = type;
   fluff->set = set_function;
   fluff->query = query_function;
   fluff->restriction = cre_only;
   fluff->suboptions = ([ ]);
   fluff->help = help;
   array[name] = fluff;
} /* add_option() */

/**
 * This method adds in an option for the player to be able to set.
 * The set function will be called with two parameters, the value to
 * set it to and the variable being set.  The set function must return
 * 1 if the value was successfuly set.
 * <p>
 * int set_function(variable, value);
 * @param path the path to the option eg: ({ "output", "look" })
 * @param type the type of the option eg: OPTIONS_TYPE_BRIEF
 * @param set_function the function to call to set the option
 * @param query_function the function to call to query the option
 * @return 1 if successful, 0 if not
 */
protected int add_option(string name, mixed type, int cre_only,
                         function set_function, function query_function,
                         string help) {
   string option;
   mapping stuff;
   string *path;

   path = explode(name, " ");
   stuff = _options;
   foreach (option in path[0..<2]) {
      if (!stuff[option]) {
         //stuff[option] = ([ ]);
         add_option_to_mapping(stuff, option, OPTIONS_TYPE_GROUP, cre_only,
                               0, 0, help);
      } else if (((class option)stuff[option])->type != OPTIONS_TYPE_GROUP) {
         return 0;
      }
      stuff = stuff[option]->suboptions;
   }

   add_option_to_mapping(stuff, path[<1], type, cre_only, set_function,
                         query_function, help);
   return 1;
} /* add_option() */

private mixed query_sub_option(object player, string name, mapping tree) {
   mixed tmp;

   if (mapp(tree[name])) {
      return tree[name];
   }

   if (classp(tree[name])) {
      switch (tree[name]->restriction) {
      case OPTIONS_TYPE_CRE_ONLY:
         if (!player->query_creator()) {
            return 0;
         }
         break;
      case OPTIONS_TYPE_LORD_ONLY:
         if (!player->query_lord()) {
            return 0;
         }
         break;
      case OPTIONS_TYPE_PLAYTESTER_ONLY:
         if (!player->query_playtester()) {
            return 0;
         }
         break;
      }
      if (((class option)tree[name])->type == OPTIONS_TYPE_DYNAMIC_GROUP) {
         tmp = evaluate(tree[name]->query, player, name);
         return tmp;
      }
      if (((class option)tree[name])->type == OPTIONS_TYPE_GROUP) {
         return tree[name]->suboptions;
      }
      return tree[name];
   }
   return 0;
} /* query_sub_option() */

private mixed query_bottom_sub_option(object player, string* path) {
   string option;
   mixed stuff;

   if (!sizeof(path)) {
      return _options;
   }
   stuff = _options;
   foreach (option in path[0..<2]) {
      stuff = query_sub_option(player, option, stuff);
      if (!mapp(stuff)) {
         return 0;
      }
   }
   stuff = query_sub_option(player, path[<1], stuff);
   if (classp(stuff)) {
      switch (stuff->restriction) {
      case OPTIONS_TYPE_CRE_ONLY:
         if (!player->query_creator()) {
            return 0;
         }
         break;
      case OPTIONS_TYPE_LORD_ONLY:
         if (!player->query_lord()) {
            return 0;
         }
         break;
      case OPTIONS_TYPE_PLAYTESTER_ONLY:
         if (!player->query_playtester()) {
            return 0;
         }
         break;
      }
   }
   return stuff;
} /* query_bottom_sub_option() */

/**
 * This method checks to see if the specified option path exists.  This
 * will only return true if it is an actual option, not an option group.
 * @param player the player this is relative to
 * @param name the option path to check
 * @return 1 if it is an option, 0 if not
 */
int is_option(object player, string name) {
   mixed stuff;
   string *path;

   path = explode(name, " ");
   stuff = query_bottom_sub_option(player, path);
   if (!classp(stuff)) {
      return 0;
   }
   return 1;
} /* is_option() */

/**
 * This method checks to see if the specified option group path exists.  This
 * will only return true if it is an option group, not an actual option.
 * @param player the player this is relative to
 * @param name the option path to check
 * @return 1 if it is an option group, 0 if not
 */
int is_option_group(object player, string name) {
   mixed stuff;
   string *path;
 
   path = explode(name, " ");
   stuff = query_bottom_sub_option(player, path);
   if (!mapp(stuff)) {
      return 0;
   }
   return 1;
} /* is_option() */

/**
 * This method returns all the sub options and option groups at this
 * level.
 * @param player the player this is relative to
 * @param name the path to return the suboptions of
 * @return the sub options of the path
 */
string *query_sub_options(object player, string name) {
   mapping stuff;
   string *path;
 
   path = explode(name, " ");
   stuff = query_bottom_sub_option(player, path);
   if (mapp(stuff)) {
      return filter(keys(stuff),
                    (: query_bottom_sub_option($2, $3 + ({ $1 })) :),
                    player, path);
   }
   return ({ });
} /* query_sub_options() */

/**
 * This method returns the different values this option can be
 * set to.
 * @param player the player this is relative to
 * @param name the name of the option
 * @return the allowed parameters
 */
string* query_option_values(object player, string name) {
   mixed stuff;
   class option opt;
   string *path;

   path = explode(name, " ");
   stuff = query_bottom_sub_option(player, path);
   if (classp(stuff)) {
      opt = stuff;
      if (intp(opt->type)) {
         switch (opt->type) {
         case OPTIONS_TYPE_BOOLEAN :
            return ({ "on", "off" });
         case OPTIONS_TYPE_BRIEF :
            return ({ "brief", "verbose" });
         case OPTIONS_TYPE_INTEGER :
            return ({ "integer" });
         case OPTIONS_TYPE_STRING :
            return ({ "string" });
         case OPTIONS_TYPE_PERCENTAGE :
            return ({ "0..100" });
         case OPTIONS_TYPE_COLOUR :
            return ({ "none", "default", "colour" });
         }
      } else {
         return opt->type;
      }
   }
   return ({ });
} /* query_option_values() */

/**
 * This method returns the value of the specified option.
 * @param player the player to find the value on
 * @param path the path to the option
 */
string query_option_value(object player, string path) {
   string* bits;
   mixed value;
   class option stuff;

   bits = explode(path, " ");
   stuff = query_bottom_sub_option(player, bits);
   if (classp(stuff)) {
      value = evaluate(stuff->query, player, bits);
      if (intp(stuff->type)) {
         switch (stuff->type) {
         case OPTIONS_TYPE_BRIEF:
            if (value) {
               value = "verbose";
            } else {
               value = "brief";
            }
            break;
         case OPTIONS_TYPE_BOOLEAN :
            if (value) {
               value = "on";
            } else {
               value = "off";
            }
            break;
         case OPTIONS_TYPE_COLOUR :
            if (value == "") {
               value = "[none]";
            } else if (value == "default") {
               value = "[default]";
            } else {
               value = "[" + value + "" + 
                       lower_case(replace(value, ({ "%^%^", " ", "%^", "" }))) +
                       "%^RESET%^]";
            }
            break;
         default :
         }
      }
      return value + "";
   }
} /* query_option_value() */

/**
 * This method returns the help string of the specified option.
 * @param player the player to find the value on
 * @param path the path to the option
 */
string query_option_help(object player, string path) {
  string *bits;
  mixed stuff;
  
  bits = explode(path, " ");
  stuff = query_bottom_sub_option(player, bits);
  if (classp(stuff)) {
    return copy(stuff->help);
  }
  return "";
}

/**
 * This method sets an option value on the player.
 * @param player the player to find the value on
 * @param path the path to the option
 * @param value the value directly from the command line
 */
int set_option_value(object player, string path, string value) {
   string* bits;
   string* bad;
   mixed set_value;
   class option stuff;

   bits = explode(path, " ");
   stuff = query_bottom_sub_option(player, bits);
   if (classp(stuff)) {
      if (pointerp(stuff->type)) {
         if (member_array(value, stuff->type) == -1) {
            add_failed_mess("You must set your type to one of " +
                            query_multiple_short(stuff->type) + ".\n");
            return 0;
         }
         set_value = value;
      } else switch (stuff->type) {
      case OPTIONS_TYPE_BRIEF:
         if (value == "verbose") {
            set_value = 1;
         } else if (value == "brief") {
            set_value = 0;
         } else {
            return 0;
         }
         break;
      case OPTIONS_TYPE_BOOLEAN :
         if (value == "on" || value == "true") {
            set_value = 1;
         } else if (value == "off" || value == "false") {
            set_value = 0;
         } else {
            return 0;
         }
         break;
      case OPTIONS_TYPE_PERCENTAGE :
      case OPTIONS_TYPE_INTEGER :
         if (sscanf(value, "%d", set_value) != 1) {
            return 0;
         }
         if (stuff->type == OPTIONS_TYPE_PERCENTAGE &&
             (set_value < 0 || set_value > 100)) {
            add_failed_mess("Value must be between 0 and 100.\n");
            return 0;
         }
         break;
      case OPTIONS_TYPE_COLOUR :
         if (value == "none" || value == "default") {
            set_value = value;
         } else {
            set_value = map(explode(value, " "),
                         (: upper_case($1) :));
            bad = filter(set_value, (: member_array($1, _colours) == -1 :));
            if (sizeof(bad)) {
               add_failed_mess("Bad colours " + implode(bad, " ") + ".\n");
               return 0;
            }
            set_value = "%^" + implode(set_value, (: $1 + "%^ %^" + $2 :)) + "%^";

         }
         break;
      default :
         set_value = value;
         break;
      }
      return evaluate(stuff->set, player, bits, set_value);
   }
   return 0;
} /* set_option_value() */

private mapping get_inform_colours(object player) {
   string* colours;
   string womble;
   mapping ret;
   string index;

   if (player->query_creator()) {
      index = "colour 1";
   } else if (player->query_lord()) {
      index = "colour 2";
   } else {
      index = "colour 0";
   }

   if (_cache_input[index]) {
      return _cache_input[index];
   }

   colours = player->query_inform_types();
   ret = ([ ]);
   foreach (womble in colours) {
      add_option_to_mapping(ret, womble, OPTIONS_TYPE_COLOUR, 0,
                            (: $1->set_my_colours($2[<1], $3), 1 :),
                            (: $1->colour_event($2[<1], "default") :),
                            "The colour of " + womble + " informs");
   }
   _cache_input[index] = ret;
   return ret;
} /* get_inform_colours() */

private mapping get_club_colours(object player) {
   string* colours;
   string womble;
   mapping ret;
   string index;

   index = "colour " + player->query_name();
   if (_cache_input[index]) {
      return _cache_input[index];
   }

   colours = map(this_player()->query_player_clubs(),
                 (: CLUB_HANDLER->normalise_name($1) :) );
   ret = ([ ]);
   foreach (womble in colours) {
      add_option_to_mapping(ret, womble, OPTIONS_TYPE_COLOUR, 0,
                            (: $1->set_my_colours("club_" + $2[<1], $3), 1 :),
                            (: $1->colour_event("club_" + $2[<1], "default") :),
                            "The colour for " + womble + " club messages");
   }
   _cache_input[index] = ret;
   call_out((: map_delete(_cache_input, $1) :), 5 * 60, index);
   return ret;
} /* get_inform_colours() */

private int change_bool_property(string prop, object player, int new_value) {
   if (new_value) {
      player->add_property(prop, 1);
   } else {
      player->remove_property(prop);
   }
   return 1;
} /* change_bool_property() */

private int setup_earmuffs(object player, string ear) {
   switch (ear) {
   case "on" :
      if (!player->query_earmuffs()) {
         player->toggle_earmuffs();
      } else if (player->query_earmuffs() == PLAYER_ALLOW_FRIENDS_EARMUFF) {
         player->toggle_earmuffs();
         player->toggle_earmuffs();
      }
      break;
   case "off" :
      if (player->query_earmuffs()) {
         player->toggle_earmuffs();
      }
      break;
   case "allowfriends" :
      player->set_allow_friends_earmuffs();
      break;
   }
   return 1;
} /* setup_earmuffs() */

private int change_error_reports(object player, string error, int new_value) {
   string *on;

   on = player->query_property(PLAYER_SHOW_ERRORS_PROP);
   if (!on) {
      on = ({ });
   }
   error = upper_case(error);
   if (new_value) {
      if (member_array(error, on) == -1) {
         on += ({ error });
         player->add_property(PLAYER_SHOW_ERRORS_PROP, on);
      }
   } else {
      on -= ({ error });
      player->add_property(PLAYER_SHOW_ERRORS_PROP, on);
   }
   return 1;
} /* change_earmuffs() */

private int change_earmuffs(object player, string ear, int new_value) {
   string *on;

   on = player->query_property("earmuffs");
   if (!on) {
      on = ({ });
   }
   if (new_value) {
      if (member_array(ear, on) == -1) {
         on += ({ ear });
         player->add_property("earmuffs", on);
      }
   } else {
      on -= ({ ear });
      player->add_property("earmuffs", on);
   }
   return 1;
} /* change_earmuffs() */

private int valid_birthday(string str) {
#define LENGTHS ({ 0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 })

  int tot, month, day;

  if(strlen(str) != 4) {
    return 0;
  }
  if(!sscanf(str, "%d", tot)) {
    return 0;
  }
  month = tot % 100;
  day = tot / 100;
  if(month > 12 || month < 1) {
    return 0;
  }
  if(day < 1) {
    return 0;
  }
  return day <= LENGTHS[month];
} /* valid_birthday() */



string convert_birthday(string str) {
#undef MONTHS
#define MONTHS ({ "January", "February", "March", "April", "May", "June", \
      "July", "August", "September", "October", "November", "December" })
  /* we assume it is 4 characters long */

  int day, month, tot;
  string retval;

  sscanf(str, "%d", tot);
  day = tot / 100;
  month = tot % 100;
  switch(day) {
    case 11:
      retval = "11th"; break;
    case 12:
      retval = "12th"; break;
    case 13:
      retval = "13th"; break;
    default:
      switch(day%10) {
        case 1:
          retval = day+"st"; break;
        case 2:
          retval = day+"nd"; break;
        case 3:
          retval = day+"rd"; break;
        default:
          retval = day+"th";
      }
  }
  return retval + " of " + MONTHS[month-1];
} /* convert_birthday() */
// --- END [/mnt/home2/grok/lib/obj/handlers/options_handler.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/room_rental.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/room_rental.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628240   Available: 13575594
Inodes: Total: 5242880    Free: 4960134
8548 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/room_rental.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628240   Available: 13575594
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * A Room Rental Handler
 * <p>
 * This keeps track of who rented what rooms where
 * and for how much.
 * <p>
 * After including <room/room_rental.h> there are two options
 * available for room inherits.  ROOM_RENTAL_INHERIT_BASIC_ROOM 
 * includes the basic room inherit while ROOM_RENTAL_INHERIT_ROOM
 * is for use in areas that have their own base room inherits.
 * <p> 
 * The most important function is the one that checks that someone
 * is allowed to enter.
 * <br>
 * int check_entry( object player, object room )
 * <br>
 * it returns:
 * RENTAL_SUCCESS if the player rents the room successfully
 * RENTAL_NO_SUCH_ROOM if the room isn't on the books
 * RENTAL_ALREADY_RENTED if the room is rented to someone else
 * RENTAL_AVAILABLE if the player doesn't rent the room but it is available
 *
 * @author goldenthread
 * @started 3 Sep y2k1
 *
 */

#include <money.h>
#include <room/room_rental.h>


protected void do_load();
protected void do_save();
protected void evict_tenant( object room_ob );

private nosave int loaded = 0;
private mapping rented_rooms = ([]);
private mapping rental = ([]);
private mapping eviction_times = ([]);
private mapping locations = ([]);

/* maps room shorts to paths */
private mapping paths = ([]);

/** @ignore yes */
void create() {
  do_load();
} /* create() */

/** @ignore yes */
void reset() {
   string room;
   int now = time();

   foreach( room in keys( rented_rooms ) ) {
      if ( stringp( rented_rooms[ room ] ) ) {
         if ( ( eviction_times[ room ] < now ) &&
              ( eviction_times[ room ] > -1 ) ) {
            /* chuck out the tenant! */
            evict_tenant( find_object( room ) );

            tell_creator( "goldenthread", "RENTAL: %s no longer rents %s\n",
                          rented_rooms[ room ], room );
            rented_rooms[ room ] = 0;
            eviction_times[ room ] = -1;
         }
      }
   }

   do_save();
} /* reset() */


/** @ignore yes */
protected void do_load() {
   if ( !loaded )
      unguarded( (: restore_object( ROOM_RENTAL_SAVE_FILE, 1 ) :) );
   loaded = 1;
} /* do_load */

/** @ignore yes */
protected void do_save() {
   unguarded( (: save_object( ROOM_RENTAL_SAVE_FILE , 0 ) :) );
} /* do_save */


/**
 * Evicts the tenant ( and guests ).
 *
 * @param room_ob the room object
 */
void evict_tenant( object room_ob ) {
   object *occupants;

   occupants = filter( all_inventory( room_ob ), (: living :) );
   room_ob->evict_tenant( occupants );
}

/**
 * Adds a room to the handler with a rental cost.
 *
 * @see delete_room()
 *
 * @param room the path of the room to add to the handler
 * @param cost the rental cost per day of this room
 * @param office the current office
 *
 * @example
 *    add_room( "/w/goldenthread/workroom", 1000000 )
 */
int add_room( string room, int cost, object office ) {
   object room_ob;
   if( !room_ob = load_object( room ) )
      return 0;
      
   rented_rooms[ room ] = 0;
   rental[ room ] = cost;
   eviction_times[ room ] = -1;
   locations[ room ] = office->query_location();
   paths[ room_ob->short() ] = room;
   
   do_save();
   
   return 1;
} /* add_room */

/**
 * Returns the name of whoever is renting the room specified.
 *
 * @param room the short of the room you want to check
 * @param office the current office
 *
 * @return the short of the player who's renting the room
 */
string query_who_rents( string room, object office ) {
   if ( locations[room] == office->query_location() ) {
      if ( stringp( rented_rooms[room] ) )
         return rented_rooms[room];
      else
         return "nobody";
   } else
      return "no such room in this location";
} /* query_who_rents */

/**
 * Checks if a particular player is renting a particular room.
 *
 * @param player_ob the player object who you think might be renting the room
 * @param room_ob   the room object that you think the player might be renting
 *
 * @return value dependent on success of check.  See below for details
 *
 * @main
 * returns:
 * RENTAL_SUCCESS if the player rents the room successfully
 * RENTAL_NO_SUCH_ROOM if the room isn't on the books
 * RENTAL_ALREADY_RENTED if the room is rented to someone else
 * RENTAL_AVAILABLE if the player doesn't rent the room but it is available
 */
int check_tenant( object player_ob, object room_ob, object office ) {
   string player = player_ob->short();
   string room = room_ob->short();

   if ( player == query_who_rents( room, office ) )
      return RENTAL_SUCCESS;
   else if ( player == "nobody" )
      return RENTAL_AVAILABLE;
   else if ( player == "no such room!" )
      return RENTAL_NO_SUCH_ROOM;
   else
      return RENTAL_ALREADY_RENTED;
} /* check_tenant */

/**
 * Deletes a room from the handler
 *
 * @see add_room()
 *
 * @param room the path of the room that will be deleted from the handler
 * @param office the current office
 *
 * @return 0 on success, 1 on failure
 */
int delete_room( string room, object office ) {
  string room_short = load_object( room )->short();

  if ( locations[room] == office->query_location() ) {
    map_delete( rented_rooms, room );
    map_delete( rental, room );
    map_delete( eviction_times, room );
    map_delete( locations, room );
    map_delete( paths, room_short );

    do_save();

    return 1;
  } else
    return 0;
} /* delete_room */

/**
 * Clears the list of rooms available for rent.
 *
 * @param office the current office
 *
 * WARNING: This clears all rooms bookable from this office.
 */
int clear_rooms( object office ) {
   object room_ob;
   
   foreach( string room in keys( filter( locations,
            (: $2 == $( office->query_location() ) :) ) ) ) {
      room_ob = load_object( room );
    map_delete( rented_rooms, room );
    map_delete( rental, room );
    map_delete( eviction_times, room );
    map_delete( locations, room );
    map_delete( paths, room_ob->query_short() );
  }

  do_save();

  return 1;
} /* clear_rooms */


/**
 * Returns a list of rooms available in a particular location.
 *
 * @return a string ready for presentation to a player containing a
 * list of all rooms available in that office.
 *
 * @param office the office
 */
string *query_rooms_to_rent( object office ) {
  return keys( filter( locations,
               (: $2 == $( office->query_location() ) :) ) );
} /* query_rooms_to_rent */


/**
 * Handles the actual renting of the room.  If the prospective
 * tenant is already renting the room, it extends the rental.
 *
 * @see remove_rental()
 *
 * @param player_ob the player who is renting the room
 * @param room_short the short of the room that is to be rented
 * @param office the current office
 *
 * @return value dependent on success of rental. See below for details
 *
 * @main
 * returns:
 * RENTAL_SUCCESSFUL if the rental is successful
 * RENTAL_NO_SUCH_ROOM if the room isn't on the books
 * RENTAL_ALREADY_RENTED if someone else is renting the room already
 * RENTAL_NO_MONEY if the player hasn't enough money
 */
int do_rental( object player_ob, string room_short, object office ) {
   int result;
   string domain = office->query_domain();
   string room = paths[ room_short ];
   
   /* is the room available for rent */
   if ( locations[room] == office->query_location() ) {
      if ( !rented_rooms[room] ||
           ( rented_rooms[room] == player_ob->short()) ) {
         if ( (int)player_ob->query_value_in( domain ) < rental[room] )
            return RENTAL_NO_MONEY;

         rented_rooms[room] = player_ob->short();
         eviction_times[room] = time() + ONE_DAY;
         result = RENTAL_SUCCESS;
      } else
         result = RENTAL_ALREADY_RENTED;
   } else
      result = RENTAL_NO_SUCH_ROOM;
   
   do_save();

   return result;
} /* do_rental() */

/**
 * Returns the amount needed to pay for a rental
 *
 * @param room the room being queried
 * @return rental amount
 */
int query_rental_value( string room ) {
   return rental[ room ];
} /* query_rental_value() */

/**
 * Removes the rented status from a room.  Should be called when the
 * time limit of the rental is over.
 *
 * @see do_rental()
 *
 * @param room_ob the room object that is currently rented
 *
 * @return 0 on success, 1 on failure
 */
int remove_rental( object room_ob ) {
   int result;
   string room_short = room_ob->short();
   string room = paths[ room_short ];

   if ( !undefinedp( rented_rooms[room] ) ) {
      rented_rooms[room] = 0;
      result = RENTAL_SUCCESS;
   } else
      result = RENTAL_NO_SUCH_ROOM;
   
   do_save();
   
   return result;
} /* remove_rental() */







// --- END [/mnt/home2/grok/lib/obj/handlers/room_rental.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/twiki.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/twiki.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628238   Available: 13575592
Inodes: Total: 5242880    Free: 4960134
6857 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/twiki.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628238   Available: 13575592
Inodes: Total: 5242880    Free: 4960134
2025-03-06 11:10:43.889800032 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This handler will do any mud base manipulations of the twiki
 * database.
 * @author Pinkfish
 * @started Wed May 24 17:19:06 PDT 2000
 */
#include <board.h>

void do_check_changes();

#define SAVE_FILE "/save/twiki"
#define CHECK_TIME (7 * 24 * 60 * 60)

#define TWIKI_CHANGE_FILE "/.changes"
#define TWIKI_DATA_DIRECTORY "/twiki/data/"

private nosave string* _databases;

private int _last_check;
private mapping _last_change;

void create() {
   _databases = ({ "Main", "Am", "Ram", "Cwc", "Sur", "Klatch",
                   "Forn", "Underworld", "Other", "Playtesters" });
   seteuid(getuid());
   restore_object(SAVE_FILE);
   if (_last_check + CHECK_TIME < time()) {
      do_check_changes();
   }
   call_out("do_check_changes", _last_check + CHECK_TIME - time());

   if (!_last_change) {
      _last_change = ([ ]);
   }
   call_out("do_change_inform", 60 * 5);
} /* setup() */

/**
 * This method finds the pages that have changed since the specified time.
 * @param limit the time after which to find the changes
 * @return the mapping of pages to who changed them
 */

mapping find_changed_pages(int limit, string database) {
  string content;
  string* lines;
  int i;
  int tim;
  string page;
  string author;
  mixed* bits;
  mapping changes_pages;

  content = read_file(TWIKI_DATA_DIRECTORY + database + TWIKI_CHANGE_FILE);
  if (!stringp(content)) content = ""; // Handle missing file
  lines = explode(content, "\n"); // Convert to array
  changes_pages = ([ ]);
  for (i = 1; i < sizeof(lines); i++) {
    bits = reg_assoc(lines[<i], ({ "([a-zA-Z][a-zA-Z0-9]+)", "[0-9]+" }), ({ 1, 2 }));
      bits = reg_assoc(lines[<i], ({ "([a-zA-Z][a-zA-Z0-9]+)", "[0-9]+" }), ({ 1, 2 }) );
      if (sizeof(bits[0]) == 9 || sizeof(bits[0]) == 7) {
         page = bits[0][1];
         author = bits[0][3];
         sscanf(bits[0][5], "%d", tim);
         if (tim > limit) {
            //
            // Ignore all the user page changes...
            //
            if (page[0..4] != "TWiki" &&
                page[0..9] != "Underworld" &&
                author != "PeterThoeny" &&
                page != author &&
                page != "WebPreferences") {
               //
               // Read the page and determine from that.
               //
               if (file_size("/twiki/data/" + database + "/" + page + ".txt") > 0 &&
                   strsrch(read_file("/twiki/data/" + database + "/" + page + ".txt"),
                           "\t* Login Name:") == -1) {
                  if (!changes_pages[page]) {
                     changes_pages[page] = ({ });
                  }
                  if (member_array(author, changes_pages[page]) == -1) {
                     changes_pages[page] += ({ author });
                  }
               }
            }
         } else {
            break;
         }
      } else {
         break;
      }
   }

   return changes_pages;
} /* find_changed_pages() */

/**
 * This method prints out any changes since the specified limit.
 * @param limit the time after which to show any changes
 * @return the changes since that time
 */
string find_changes(int limit) {
   mapping changes_pages;
   string ret;
   string page;
   string database;

   ret = "Changes since " + ctime(limit) + " in\n"
         "http://discworld.imaginary.com/twiki/bin/view/Main/WebHome\n\n";

   foreach (database in _databases) {
      changes_pages = find_changed_pages(limit, database);

      foreach (page in sort_array(keys(changes_pages), 1)) {
         ret += sprintf("%-30s changed by %s\n", database + "." + page,
                         query_multiple_short(changes_pages[page]));
      }
   }
   return ret;
} /* find_changes() */

/**
 * This method prints out any changes since the specified limit.
 * @param database the database to find the changes in
 * @param limit the time after which to show any changes
 * @return the changes since that time
 */
string find_changes_in_database(string database, int limit) {
   mapping changes_pages;
   string ret;
   string page;

   if (database == "Playtesters") {
      ret = "Changes since " + ctime(limit) + " in\n"
         "http://discworld.imaginary.com/twiki/pt/bin/view/Playtesters/WebHome\n\n";
   } else {
      ret = "Changes since " + ctime(limit) + " in\n"
         "http://discworld.imaginary.com/twiki/bin/view/Main/WebHome\n\n";
   }

   changes_pages = find_changed_pages(limit, database);

   foreach (page in sort_array(keys(changes_pages), 1)) {
      ret += sprintf("%-30s changed by %s\n", database + "." + page,
                      query_multiple_short(changes_pages[page]));
   }
   return ret;
} /* find_changes() */

/**
 * This method finds the specified file and shows it to us.
 * @param fname the file name to find
 * @return the text of the file, 0 if the file is not found
 */
string query_file(string fname) {
   if (strsrch(fname, ".") > 0) {
      fname = "/twiki/data/" + replace_string(fname, ".", "/") + ".txt";
   } else {
      fname = "/twiki/data/Main/" + fname + ".txt";
   }

   if (sizeof(stat(fname))) {
      return read_file(fname);
   }
   return 0;
} /* query_file() */

/** @ignore yes */
void do_check_changes() {
   string changes;

   changes = find_changes(_last_check);

   BOARD_HAND->add_message("commonroom", "Twiki Database",
                           "Changes in the Twiki database",
                           changes);
   _last_check = time();
   save_object(SAVE_FILE);
   call_out("do_check_changes", _last_check + CHECK_TIME - time());
} /* do_changes() */

/** @ignore yes */
void do_change_inform() {
   int changed;
   mapping changed_pages;
   string page;
   string* changers;
   int dosave;
   string database;

   //
   // See if the file has changed.
   //
   if (!mapp(_last_change)) {
      _last_change = ([ ]);
   }
   foreach (database in _databases) {
      if (!_last_change[database]) {
         _last_change[database] = time();
         dosave = 1;
      } else {
         changed = stat(TWIKI_DATA_DIRECTORY + database + TWIKI_CHANGE_FILE)[1];
         if (changed != _last_change[database]) {
            //
            // Do an inform about it...
            //
            changed_pages = find_changed_pages(_last_change[database], database);
            _last_change[database] = changed;
            dosave = 1;
            foreach (page, changers in changed_pages) {
               user_event( "inform",
                           sprintf( "%s changes the twiki page %s.%s",
                                    query_multiple_short(changers), database,
                                    page),
                           "message",
                           this_player() );
      
            }
         }
      }
   }
   if (dosave) {
      save_object(SAVE_FILE);
   }
   call_out("do_change_inform", 60 * 5);
} /* do_change_inform() */
// --- END [/mnt/home2/grok/lib/obj/handlers/twiki.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/pattern_compiler.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/pattern_compiler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628236   Available: 13575590
Inodes: Total: 5242880    Free: 4960134
14466 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/pattern_compiler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628236   Available: 13575590
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*   -*- LPC -*-   */
/*
 * $Locker:  $
 * $Id: pattern_compiler.c,v 1.10 2000/11/22 08:30:15 ceres Exp $
 */
/**
 * Compiles up the patterns for use by the add_command system.
 * @see /global/new_parse->add_command()
 * @author Pinkfish
 * @change 29-Jul-97, Jeremy
 *         changed default search order to ME-HERE, since
 *         this is what the "look" and "locate" commands use.
 */
#include <user_parser.h>

#define PATTERN_CACHE_SIZE 200

nosave mapping patterns;
nosave mapping pattern_short;
nosave string *pattern_order;
nosave int hits, reqs, cache_callout;

nomask mixed *compile_pattern(string str);

void create() {
   patterns = ([ "" : ({ 100 }) ]);
   pattern_short = ([ "" : "" ]);
   //pattern_order = ({ });
} /* create() */

void clean_cache() {
  int i;

  for(i=0; i<(sizeof(pattern_order)-PATTERN_CACHE_SIZE); i++) {
    map_delete(patterns, pattern_order[i]);
    map_delete(pattern_short, pattern_order[i]);
  }
  pattern_order = pattern_order[i..];
  cache_callout = 0;
}

/**
 * Returns the compiled pattern to the caller.   This checks to see if they
 * pattern is in its internal cache and if it is, it uses that.
 * @param pattern the pattern to compiler
 * @return the compiler pattern
 * @see /include/user_parser.h
 */
nomask mixed *query_pattern(string pattern) {
  if (!patterns[pattern]) {
    patterns[pattern] = compile_pattern(pattern);
  }
  /*
    else
    hits++;
  pattern_order -= ({ pattern });
  pattern_order += ({ pattern });
  if(!cache_callout && (sizeof(pattern_order) > PATTERN_CACHE_SIZE))
    cache_callout = call_out("clean_cache", 300);
  reqs++;
  */
  return patterns[pattern];
} /* query_pattern() */

/**
 * Compiles the pattern.   Does no cache checking.  This returns
 * only the compiled pattern, it also creates the short pattern as a
 * side effect.  The short pattern can be queried by using
 * query_short_pattern()
 * @param str the pattern to compile
 * @return the compiled pattern
 * @see /include/user_parser.h
 * @see query_short_pattern()
 * @see /global/new_parse.c
 */
nomask mixed *compile_pattern(string str) {
   mixed *pattern;
   mixed *bits;
   int i;
   int failed;
   int type;
   int weight;
   mixed env;
   string short;
   string short_bit;
   int pos;
   int pos2;
   int j;
   int k;

   bits = explode(str, " ") - ({ 0, "" });
   pattern = ({ });
   short = "";
   for (i = 0; i < sizeof(bits) && !failed; i++) {
      switch (bits[i][0]) {
      case '<' :
         pos = strsrch(bits[i], "'");
         if (pos != -1) {
             // Try to find the next one...
             pos2 = strsrch(bits[i][pos + 1..], "'", pos + 1);
             if (pos2 == -1) {
                /* Oh dear...  Look for it man! */
                for (j = i + 1; j < sizeof(bits); j++) {
                   pos2 = strsrch(bits[j], "'");
                   if (pos2 != -1) {
                      break;
                   }
                }
                if (j < sizeof(bits)) {
                   // Ok, found the dreadful thing.
                   for (k = i + 1; k <= j; k++) {
                      bits[i] += " " + bits[k];
                   }
                   // Nip up to the new one.
                   bits[j] = bits[i];
                   i = j;
                   pos2 = strsrch(bits[i], "'", -1);
                }
             } else {
                pos2 += pos + 1;
             }
             // We have it!  Cut out chunks.
             if (pos2 != -1) {
                short_bit = bits[i][pos+1..pos2-1];
                bits[i] = bits[i][0..pos-1] + bits[i][pos2+1..];
             } else {
                short_bit = 0;
             }
         } else {
             short_bit = 0;
         }
         bits[i] = bits[i][1..<2];
         bits[i] = explode(bits[i], ":");
         if (!bits[i]) {
            bits[i] = ({ "" });
         }
         switch (bits[i][0]) {
         case "direct" :
            weight += 7;
            if (sizeof(bits[i]) > 1) {
               switch (bits[i][1]) {
               case "living" :
                  type = LIVING;
                  break;
               case "distant-living" :
                  type = DISTANT_LIVING;
                  break;
               case "any-living" :
                  type = ANY_LIVING;
                  break;
               case "object" :
                  type = ANY_OBJECT;
                  break;
               case "player" :
                  type = TARGET_PLAYER;
                  break;
               default :
                  failed = 1;
                  printf("Unknown type of direct (%s).\n", bits[i][1]);
                  break;
               }
               if (!short_bit) {
                   short += "<"+bits[i][1]+"> ";
               } else {
                   short += "<" + short_bit + "> ";
               }
            } else {
               type = ANY_OBJECT;
               bits[i] += ({ "object" });
               if (!short_bit) {
                  short += "<object> ";
               } else {
                   short += "<" + short_bit + "> ";
               }
            }
            //env = ENV_HERE_ME;
            env = ENV_ME_HERE;
            if (sizeof(bits[i]) > 2)
               switch (bits[i][2]) {
               case "here" :
                  env = ENV_HERE;
                  break;
               case "me" :
                  env = ENV_ME;
                  break;
               case "direct-obs" :
                  env = ENV_DIRECT_OBS;
                  break;
               case "me-here" :
                  env = ENV_ME_HERE;
                  break;
               case "here-me" :
                  env = ENV_HERE_ME;
                  break;
               default :
                  env = bits[i][2];
                  break;
               }
            pattern += ({ DIRECT_OBJECT, type, env });
            break;
         case "indirect" :
            weight += 7;
            if (sizeof(bits[i]) > 1) {
               switch (bits[i][1]) {
               case "living" :
                  type = LIVING;
                  break;
               case "distant-living" :
                  type = DISTANT_LIVING;
                  break;
               case "any-living" :
                  type = ANY_LIVING;
                  break;
               case "object" :
                  type = ANY_OBJECT;
                  break;
               case "player" :
                  type = TARGET_PLAYER;
                  break;
               case "wiz-present" :
                  type = WIZ_PRESENT_TARGET;
                  break;
               default :
                  failed = 1;
                  printf("Unknown type of indirect (%s).\n", bits[i][1]);
                  break;
               }
               if (!short_bit) {
                  short += "<"+bits[i][1]+"> ";
               } else {
                   short += "<" + short_bit + "> ";
               }
            } else {
               type = ANY_OBJECT;
               bits[i] += ({ "object" });
               if (!short_bit) {
                  short += "<object> ";
               } else {
                   short += "<" + short_bit + "> ";
               }
            }
            //env = ENV_HERE_ME;
            env = ENV_ME_HERE;
            if (sizeof(bits[i]) > 2)
               switch (bits[i][2]) {
               case "here" :
                  env = ENV_HERE;
                  break;
               case "me" :
                  env = ENV_ME;
                  break;
               case "direct-obs" :
                  env = ENV_DIRECT_OBS;
                  break;
               case "me-here" :
                  env = ENV_ME_HERE;
                  break;
               case "here-me" :
                  env = ENV_HERE_ME;
                  break;
               default :
                  env = bits[i][2];
                  break;
               }
            pattern += ({ INDIRECT_OBJECT, type, env });
            break;
         case "string" :
            if (sizeof(bits[i]) > 1) {
               switch (bits[i][1]) {
               case "small" :
                  if (!short_bit) {
                     short += "<string> ";
                  } else {
                     short += "<" + short_bit + "> ";
                  }
                  weight += 6;
                  pattern += ({ SHORT_STRING });
                  break;
               case "long" :
                  if (!short_bit) {
                     short += "<string> ";
                  } else {
                     short += "<" + short_bit + "> ";
                  }
                  weight += 5;
                  pattern += ({ STRING });
                  break;
               case "quoted" :
                  if (!short_bit) {
                     short += "\"<string>\" ";
                  } else {
                     short += "\"<" + short_bit + ">\" ";
                  }
                  weight += 8;
                  pattern += ({ QUOTED_STRING });
                  break;
               default :
                  printf("Invalid type of string (%s).\n", bits[i][1]);
                  failed = 1;
                  break;
               }
            } else {
               if (!short_bit) {
                  short += "<string> ";
               } else {
                  short += "<" + short_bit + "> ";
               }
               weight += 5;
               pattern += ({ STRING });
            }
            break;
         case   "number" :
            if (!short_bit) {
               short += "<number> ";
            } else {
               short += "<" + short_bit + "> ";
            }
            weight += 10;
            pattern += ({ NUMBER });
            break;
         case "word" :
            if (!short_bit) {
               short += "<word> ";
            } else {
               short += "<" + short_bit + "> ";
            }
            weight += 7;
            pattern += ({ SINGLE_WORD });
            break;
         case "fraction" :
            if (!short_bit) {
               short += "<fraction> ";
            } else {
               short += "<" + short_bit + "> ";
            }
            weight += 10;
            pattern += ({ FRACTION });
            break;
         default :
            /* Only allows for made up word lists. */
            weight += 10;
            bits[i] = implode(bits[i], ":");
            if (master()->query_word_list(bits[i]) 
                  || this_player()->query_word_list(bits[i])) {
               if (!short_bit) {
                  short += "<"+bits[i]+"> ";
               } else {
                  short += "<" + short_bit + "> ";
               }
               pattern += ({ WORD_LIST, bits[i] });
            } else {
               printf("Unknown word list name (%s)\n", bits[i]);
               failed = 1;
            }
            /*
               else
               pattern += ({ WORD_LIST, explode(bits[i], "|") });
               */
            break;
         }
         break;
      case '{' :
         weight += 10;
         if (bits[i][<1] == '}') {
            pattern += ({ WORD_LIST, explode(bits[i][1..<2], "|") });
            short += bits[i]+" ";
         } else {
            int old = i;
            string elm, *res;

            for (++i; bits[i][<1] != '}'; i++);
            res = ({});
            foreach (elm in explode(implode(bits[old..i], " ")[1..<2], "|"))
               res += ({ explode(elm, " ") });
            pattern += ({ WORD_LIST_SPACES, res });
            short += implode(bits[old..i], " ")+" ";
         }
         break;
      case '[' :
         weight += 4;
         if (bits[i][1] == '<') {
            /* This is a possible wombat.   Hmm, what do we allow inside here? */
            /* For now don't allow things which have a return value */
            if (MASTER->query_word_list(bits[i][2..<3])
                  || this_player()->query_word_list(bits[i][2..<3]))
               pattern += ({ OPTIONAL, bits[i][2..<3] });
            else {                
               printf("Unknown word list name (%s)\n", bits[i]);
               failed = 1;
               pattern += ({ OPTIONAL, bits[i][2..<3] });
            }
            short += bits[i]+" ";
         } else if (bits[i][1] == '{') {
            if (bits[i][<1] == ']') {
               pattern += ({ OPTIONAL, explode(bits[i][2..<3], "|") });
               short += bits[i]+" ";
            } else {
               int old = i;
               string elm, *res;

               for (++i; bits[i][<1] != ']'; i++);
               res = ({});
               foreach (elm in explode(implode(bits[old..i], " ")[2..<3], "|"))
                  res += ({ explode(elm, " ") });
               pattern += ({ OPTIONAL_SPACES, res });
               short += implode(bits[old..i], " ")+" ";
            }
         } else if (bits[i][<1] == ']') {
            pattern += ({ OPTIONAL, explode(bits[i][1..<2], "|") });
            short += bits[i]+" ";
         } else {
            int old = i;
            string elm, *res;

            for (++i; bits[i][<1] != ']'; i++);
            res = ({});
            foreach (elm in explode(implode(bits[old..i], " ")[1..<2], "|"))
               res += ({ explode(elm, " ") });
            pattern += ({ OPTIONAL_SPACES, res });
            short += implode(bits[old..i], " ")+" ";
         }
         break;
      default :
         /* This is one of the few allowable things to stop a variable size 
             argument if they do not put {}'s around it.   It is as-is */
         weight += 10;
         short += bits[i]+" ";
         pattern += ({ WORD_LIST, ({ bits[i] }) });
         break;
      } /* switch() */
   } /* for() */
   if (failed) {
      return 0;
   }
   pattern_short[str] = short;
   return ({ weight }) + pattern;
} /* compile_pattern() */

/**
 * Returns the short pattern for the given pattern string.   The short pattern
 * is the message which is shown to the players.
 * @param str the pattern to get the short for
 * @return the short pattern
 */
string query_short_pattern(string str) {

  reqs++;
  if(!pattern_short[str])
    compile_pattern(str);
  else
    hits++;
  
  return pattern_short[str];
} /* query_short_pattern() */

mixed *stats() {
  return  ({
    ({ "patterns", sizeof(keys(pattern_short)), }),
        ({ "requests", reqs, }),
          ({ "cache hit percent", (hits * 100) / reqs, }),
            });
}
// --- END [/mnt/home2/grok/lib/obj/handlers/pattern_compiler.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/nmoney_handler.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/nmoney_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628232   Available: 13575586
Inodes: Total: 5242880    Free: 4960134
42417 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/nmoney_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628232   Available: 13575586
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*   -*- LPC -*-   */
/*
 * $Locker: presto $
 * $Id: money_handler.c,v 1.33 2002/03/03 06:15:45 presto Exp presto $
 */
/**
 * This handles all the methods for determining values of coins and
 * the current valid set of coins.   It also handles change calculation.
 * This was written originaly by Pinkfish, reworked significantly by
 * Deutha to add in the multiple currency areas.
 * @see /std/living/money.c
 * @author Pinkfish
 */
#include <money.h>

#define DEF_VALUE 1
#define SAVE_FILE "/save/money_handler"
#undef USE_VAULT

mapping values;
mapping symbols;
mapping details;
mapping aliases;
mapping adjectives;

mixed *merge_money_arrays(mixed *m_array1, mixed *m_array2);
varargs object *filter_legal_money_array(mixed *m_array, string where);


void create() {
   seteuid( (string)"/secure/master"->
      creator_file( file_name( this_object() ) ) );
   values = ([ "default": ({ "brass", 1, "copper", 10, "silver", 100,
                                          "gold", 2000, "platinum", 6000 }) ]);
   symbols = ([ ]);
   details = ([
      "brass": ({ "heads", "tails", "a head", "a tail", "brass", 0 }),
      "copper": ({ "heads", "tails", "a head", "a tail", "copper", 0 }),
      "silver": ({ "heads", "tails", "a head", "a tail", "silver", 0 }),
      "gold": ({ "heads", "tails", "a head", "a tail", "gold", 0 }),
      "platinum": ({ "heads", "tails", "a head", "a tail", "platinum", 0 }) ]);
   aliases = ([ ]);
   adjectives = ([ ]); 
   if ( file_size( SAVE_FILE +".o" ) > 0 ) {
      unguarded((: restore_object, SAVE_FILE :));
   }
   if ( !symbols ) {
      symbols = ([ ]);
   }
   if ( !aliases ) {
      aliases = ([ ]);
   }
   if ( !adjectives ) {
      adjectives = ([ ]);
   }
} /* create() */

/**
 * This method saves the current state of the money object.
 */
void save_me() { unguarded( (: save_object, SAVE_FILE :) ); }

/**
 * This method returns the mapping containing all the values of the
 * currently valid money types.   The mapping has keys of the domain
 * of the money and has a value of an array.   The array contains
 * alternating name, value pairs.
 * <pre>
 * ([ "default": ({ "brass", 1, "copper", 10, "silver", 100,
 *                                             "gold", 2000, "platinum", 6000 }) ])
 * </pre>
 * @return the mapping of values
 * @see query_values()
 * @see query_values_in()
 */
mapping query_all_values() { return copy( values ); }

/**
 * This method returns the current set of areas in which types can
 * be found.
 * @return the set of places
 */
string *query_all_places() {
   return keys(values);
} /* query_all_places() */

/**
 * This method returns the values in the default area.
 * This method returns the array as given in the value above.
 * It contains name, value pairs and is for the "default"
 * area.
 * @return the array of values
 * @see query_all_values()
 * @see query_values_in()
 */
mixed *query_values() { return copy( values[ "default" ] ); }

/**
 * This method returns the values in the specified area.
 * It contains name, value pairs and is for the "default"
 * area.
 * @return the array of values
 * @param where the area in which to return the values for
 * @see query_all_values()
 * @see query_values()
 * @see add_type()
 * @see query_mapped_values_in()
 */
mixed *query_values_in( string where ) {
   if ( !where || ( where == "" ) ) {
      where = "default";
   }
   return copy( values[ where ] );
} /* query_values_in() */

/**
 * This returns the smallest value in the specified area.  Used to
 * make sure we are not charging too little or too much when doing
 * comparisons.
 * @return the smallest value in the specified area
 * @param where the area to check
 */
int query_smallest_value_in(string where) {
   mixed* values;
   int value;
   int i;

   if (! where) {
      where = "default";
   }
   values = query_values_in(where);
   value = values[1];
   for (i = 2; i < sizeof(values); i += 2) {
      if (values[i + 1] < value) {
         value = values[i + 1];
      }
   }
   return value;
} /* query_smallest_value_in() */

/**
 * This adds a type of money to the money handler.
 * @param where the area in which to add the type of money
 * @param type the name of the money to add
 * @param value the value of the money
 * @see query_values_in()
 * @see remove_type()
 */
void add_type( string where, string type, int value ) {
   int i;

   if ( !values[ where ] ) {
      values[ where ] = ({ type, value });
      save_me();
      return;
   }
   if ( member_array( type, values[ where ] ) != -1 ) {
      return;
   }
   for ( i = 0; i < sizeof( values[ where ] ); i += 2 ) {
      if ( value < values[ where ][ i + 1 ] ) {
         values[ where ] = values[ where ][ 0 .. i - 1 ] + ({ type, value })
                           + values[ where ][ i .. sizeof( values ) ];
         save_me();
         return;
      }
   }
   values[ where ] += ({ type, value });
   save_me();
} /* add_type() */

/**
 * This method removes the type of money from the handler.
 * @param where the area to remove it from
 * @param type the type to remove
 * @see add_type()
 */
void remove_type( string where, string type ) {
   int i;

   if ( !values[ where ] ) {
      return;
   }
   i = member_array( type, values[ where ] );
   if ( i == -1 ) {
      return;
   }
   values[ where ] = delete( values[ where ], i, 2 );
   if ( !sizeof( values[ where ] ) ) {
      map_delete( values, where );
   }
   save_me();
} /* remove_type() */

/**
 * This method returns all the details for the current set of
 * coins.   The details are information which is shown when the coin
 * is looked at.   Stuff about heads and tails and things.
 * <pre>
 *   ([
 *      "brass": ({ "heads", "tails", "a head", "a tail", "brass", 0 }),
 *      "copper": ({ "heads", "tails", "a head", "a tail", "copper", 0 }),
 *      "silver": ({ "heads", "tails", "a head", "a tail", "silver", 0 }),
 *      "gold": ({ "heads", "tails", "a head", "a tail", "gold", 0 }),
 *      "platinum": ({ "heads", "tails", "a head", "a tail", "platinum", 0 }) ])
 * </pre>
 * The places correspond to:
 * <pre>
 * ({ forward short, reverse short,
 *      forward long, reverse long, composition, plural })
 * </pre>
 * @return the details array
 */
mapping query_details() { return copy( details ); }

/**
 * This method returns the details for a specified type of money.
 * It will return an array of the form:
 * <pre>
 * ({ "heads", "tails", "a head", "a tail", "brass", 0 })
 * </pre>
 * The places correspond to:
 * <pre>
 * ({ forward short, reverse short,
 *      forward long, reverse long, composition, plural })
 * </pre>
 * @param word the money type to get the type for
 * @see add_details()
 */
mixed *query_details_for( string word ) {
   if ( !details[ word ] ) {
      return ({ "heads", "tails", "a head", "a tail", "unknown", 0 });
   }
   return copy( details[ word ] );
} /* query_details_for() */

/**
 * This method adds the details for the given coin type into the current
 * list.
 * @param word the coin type the details are for
 * @param hd_sht the heads side short
 * @param tl_sht the tail side short
 * @param hd_lng the head side long
 * @param tl_lnd the tail side long
 * @param composition the composition of the money
 * @param plural the plural value of the object, if 0 then use default plural
 * @see query_details_for()
 * @see remove_details()
 */
void add_details( string word, string hd_sht, string tl_sht, string hd_lng,
                  string tl_lng, mixed composition, string plural ) {
   if ( details[ word ] ) {
      return;
   }
   details[ word ] = ({ hd_sht, tl_sht, hd_lng, tl_lng, composition, plural });
   save_me();
} /* add_details() */

/**
 * This method removes the specified detail. 
 * @param word the type of money to remove the details for
 * @see add_detail()
 * @see query_details_for()
 */
void remove_details( string word ) {
   if ( !details[ word ] ) {
      return;
   }
   map_delete( details, word );
   save_me();
} /* remove_details() */

/**
 * This method returns all the symbols for the current money areas in the
 * handler.   The return value is mapping with the key being the
 * money area and the value being the symboliser for the money.
 * The symboliser is called with a value to get the money to
 * print itself out nicely.   This is used when the quantity of
 * actual coins is not known and only the value of them is
 * known.
 * @return all of the symbols
 * @see query_symbol_for()
 * @see add_symbol()
 * @see remove_symbol()
 */
mapping query_symbols() { return copy( symbols ); }

/**
 * This method returns the symboliser for the specified money area.
 * @param word the area in which the money is occuring
 * @return the syboliser for the money area
 * @see query_symbols()
 * @see add_symbol()
 * @see remove_symbol()
 */
string query_symbol_for( string word ) {
   if ( !symbols[ word ] ) {
      return 0;
   }
   return copy( symbols[ word ] );
} /* query_symbol_for() */

/**
 * This method adds in a symboliser for a specified money area.
 * @example
 * add_symbol("Ankh-Morpork", "/d/am/money");
 * @example
 * // This is an example of a symboliser object
 * string symbolise_value( int value ) {
 *    int dollars, pence;
 * 
 *    dollars = value / 400;
 *    pence = ( value % 400 ) / 4;
 *    if ( !pence ) {
 *       return "A$"+ dollars;
 *    }
 *    if ( !dollars ) {
 *       return pence +"p";
 *    }
 *    if ( pence < 10 ) {
 *       return "A$"+ dollars +".0"+ pence;
 *    }
 *    return "A$"+ dollars +"."+ pence;
 * } /\* symbolise_value() *\/
 * @param word the money area to add the symbol for
 * @param symboliser the path to the symboliser object
 * @see query_symbols()
 * @see query_symbol_for()
 * @see remove_symbol()
 */
void add_symbol( string word, string symboliser ) {
   if ( symbols[ word ] ) {
      return;
   }
   symbols[ word ] = symboliser;
   save_me();
} /* add_symbol() */

/**
 * This method removes the symboliser for the particular money area.
 * @see query_symbols()
 * @see query_symbol_for()
 * @see add_symbol()
 * @param word the money area to remove the symbol for
 */
void remove_symbol( string word ) {
   if ( !symbols[ word ] ) {
      return;
   }
   map_delete( symbols, word );
   save_me();
} /* remove_symbol() */

/** @ignore yes */
string query_alias_for( string type ) {
   log_file("OBSOLETE_CALLS",
      sprintf("%O %s: %O called query_alias_for\n",
         this_object(),
         ctime(time()),
         previous_object()
         ));
   if ( !details[ type ] ) return "coin";
   if ( !details[ type ][ 5 ] ) return "coin";
   return explode( type, " " )[ sizeof( explode( type, " " ) ) - 1 ];
} /* query_alias_for() */

/**
 * This method sets the aliases for the specified money type.
 * @param type the type of money to set the aliases for
 * @param words the aliases for the money
 * @see query_aliases_for()
 * @param type the type of money to set the aliases for
 * @param words the aliases for the money
 */
void set_aliases_for(string type, string *words) {
   if (!words || !sizeof(words)) {
      if (aliases[type]) {
         map_delete(aliases, type);
      }
   } else {
      aliases[type] = words;
   }
   save_me();
   return;
} /* set_aliases_for() */

/**
 * This method returns all the current aliases for the given type
 * of money.
 * @param type the type of money to get the aliases for
 * @return the aliases for the money type
 * @see set_aliases_for()
 */
string *query_aliases_for( string type ) {
   string *ret;

   if ( !details[ type ] || !details[ type ][ MONEY_DETAILS_PLURAL ] ) {
      ret = ({ "coin" });
   } else {
      ret = ({ explode(type, " ")[<1] });
   }
   if ( aliases[ type ] ) {
      ret += aliases[ type ];
   }
   return ret;
} /* query_aliases_for() */

/**
 * This method sets the adjectives for the specified money type.
 * @param type the type of money to set the adjectives for
 * @param words the adjectives for the money
 * @see query_adjectives_for()
 * @param type the type of money to set the adjectives for
 * @param words the adjectives for the money
 */
void set_adjectives_for(string type, string *words) {
   if (!words || !sizeof(words)) {
      if (adjectives[type]) {
         map_delete(adjectives, type);
      }
   } else {
      adjectives[type] = words;
   }
   save_me();
   return;
} /* set_adjectives_for() */

/**
 * This method returns all the current adjectives for the given type
 * of money.
 * @param type the type of money to get the aliases for
 * @return the adjectives for the money type
 * @see set_adjectives_for()
 */
string *query_adjectives_for( string type ) {
   string *ret;

   if ( adjectives[ type ] ) {
      ret = adjectives[ type ];
   }
   else {
      ret = ({ });
   }
   
   return ret;
} /* query_adjectives_for() */

/**
 * This method returns the short description of the money type.
 * @param type the money type to get the short description for
 * @return the short description for the money object
 * @see query_main_plural_for()
 */
string query_short_for( string type ) {
   if ( !details[ type ] ) {
      return type +" coin";
   }
   if ( !details[ type ][ MONEY_DETAILS_PLURAL ] ) {
      return type +" coin";
   }
   return type;
} /* query_short_for() */

/**
 * This method returns the short plural description of the money type.
 * This returns just the one word, like 'coins' or 'talons'.
 * @param type the money type to get the short plural description for
 * @return the short plural description for the money object
 * @see set_plural_for()
 * @see query_main_plural_for()
 */
string query_plural_for( string type ) {
   if ( !details[ type ] ) {
      return "coins";
   }
   if ( !details[ type ][ MONEY_DETAILS_PLURAL ] ) {
      return "coins";
   }
   return details[ type ][ MONEY_DETAILS_PLURAL ];
} /* query_plural_for() */

/**
 * This method sets the plural for the specified money type.
 * @param type the money to set the plural for
 * @param plural the new plural for the money
 * @see query_plural_for()
 * @see query_main_plural_for()
 */
void set_plural_for( string type, string plural ) {
   if ( !details[ type ] ) {
      return;
   }
   details[ type ][ MONEY_DETAILS_PLURAL ] = plural;
   save_me();
} /* set_plural_for() */

/**
 * This method returns the main short plural description of the money type.
 * This returns the expanded plural version like 'Ankh-Morpork pennies'.
 * @param type the money type to get the short plural description for
 * @return the short plural description for the money object
 * @see set_plural_for()
 * @see query_plural_for()
 * @see query_short_for()
 */
string query_main_plural_for( string type ) {
   string *type_exp;

   if ( !details[ type ] ) {
      return type +" coins";
   }
   if ( !details[ type ][ MONEY_DETAILS_PLURAL ] ) {
      return type +" coins";
   }
   type_exp = explode(type, " ");
   return implode(type_exp[0 .. <2] +
      ({ details[ type ][ MONEY_DETAILS_PLURAL ] }), " " );
} /* query_main_plural_for() */

/**
 * This method returns the value of a specified type of money in a certain
 * money area.
 * @param type the type of money to get the value for
 * @param where the money area the money is in
 * @return the integer value of the money
 * @see query_total_value()
 */
varargs int query_value( string type, string where ) {
   int i, j, count, total;
   string *places;

   if ( !where || ( where == "" ) ) {
      where = "default";
   }
   if ( where == "mean" ) {
      places = m_indices( values );
      for ( i = 0; i < sizeof( places ); i++ ) {
         if ( ( j = member_array( type, values[ places[ i ] ] ) ) != -1 ) {
            count++;
            total += values[ places[ i ] ][ j + 1 ];
         }
      }
      if ( !count ) {
         return 0;
      }
      if ( !( total / count ) ) {
         return 0;
      }
      return total / count;
   }
   if ( !values[ where ] ) {
      return 0;
   }
   i = member_array( type, values[ where ] );
   if ( i == -1 ) {
      return 0;
   }
   return values[ where ][ i + 1 ];
} /* query_value() */

/**
 * This method determines the total value of a specified money array.
 * A money array consists of pairs of values ({ type, number })
 * @param mon_array the array to find the value of
 * @param where the money area to get the value in
 * @return the total value as an integer
 * @see query_value()
 */
varargs int query_total_value( mixed mon_array, string where ) {
   int i, amt;

   if ( !where || ( where == "" ) ) {
      where = "default";
   }
   for ( i = 0; i < sizeof( mon_array ); i += 2 ) {
      amt += mon_array[ i + 1 ] * query_value( mon_array[ i ], where );
   }
   return amt;
} /* query_total_value() */

/**
 * This method converts a money array into a string so it can be displayed.
 * @param mon_array the money array to convert into a string
 * @see money_value_string()
 */
string money_string( mixed mon_array ) {
   int i;
   string ret;

   if ( !sizeof( mon_array ) ) {
      return "nothing";
   }
   ret = "";
   while( i < sizeof( mon_array ) ) {
      if ( !mon_array[ i + 1 ] ) {
         mon_array = delete( mon_array, i, 2 ); 
      } else {
         i += 2;
      }
   }
   for ( i = 0; i < sizeof( mon_array ); i += 2 ) {
      ret += mon_array[ i + 1 ] +" ";
      if ( mon_array[ i + 1 ] == 1 ) {
         ret += query_short_for( mon_array[ i ] );
      } else {
         ret += query_main_plural_for( mon_array[ i ] );
      }
      if ( i == sizeof( mon_array ) - 4 ) {
         ret += " and ";
      } else if ( i != sizeof( mon_array ) - 2 ) {
         ret += ", ";
      }
   }
   return ret;
} /* money_string() */

/**
 * This method creates a money array from a certain value in a particular
 * money area. A money array consists of ({ type, number }) pairs in an
 * array.   ie: ({ "brass", 12, "copper", 24 }).
 * @example 
 * place = query_property("place");
 * if (!place) {
 *      place = "default";
 * }
 * mon_array = create_money_array( 1000, place);
 * @param value the value to get the money array for
 * @param where the money area to get the value in
 * @return a money array for the value in the area
 * @see money_value_string()
 */
varargs mixed *create_money_array( int value, string where ) {
   int i, amt;
   mixed *mon_array;

   if ( !where || ( where == "" ) ) {
      where = "default";
   }
   if ( !value ) {
      return ({ });
   }
   mon_array = ({ });
   for ( i = sizeof( values[ where ] ) - 2; i >= 0; i -= 2 ) {
      if ( value >= values[ where ][ i + 1 ] ) {
         mon_array += ({ values[ where ][ i ], amt = value /
                         values[ where ][ i + 1 ] });
         value -= amt * values[ where ][ i + 1];
      }
   }
   return mon_array;
} /* create_money_array() */

/**
 * This method returns a string which is based on the value of
 * the money in a certain money area.
 * @param value the value to get the string for
 * @param where the place to get the string for
 * @return a string of the money value in the certain money area
 * @see create_money_array()
 * @see money_string()
 * @see value_from_string()
 */
varargs string money_value_string( int value, string where ) {
   string symboliser;

   if ( !where || ( where == "" ) ) {
      where = "default";
   }
   if ( !symbols[ where ] ) {
      if (value < 0) {
         return "negative " + money_string( create_money_array( -value,
                                                                where ) );
      } else {
         return money_string( create_money_array( value, where ) );
      }
   }
   symboliser = symbols[ where ];
   return (string)symboliser->symbolise_value( value );
} /* money_value_string() */

/**
 * This method attempts to find a money value from a string.  It will
 * attempt to do fuzzy matching of the type.  This means it will match on
 * partial matches, this could lead to somewhat weird behaviour...  So it
 * goes...  It will return a money array, rather than a value
 * @param str the string to find the value of
 * @return a money array of the types matched
 * @see money_value_string()
 */
mixed* money_array_from_string(string str, string where) {
   int value;
   int number;
   int i;
   int pos;
   int frog;
   int match;
   int max_match;
   string plural;
   string *bits;
   string type;
   string match_name;
   mixed *stuff;
   mixed* ret_arr;

   if (!where) {
      where = "default";
   }

   if (symbols[ where ]) {
      value = symbols[ where ]->unsymbolise_string( str );
      if (value) {
         return create_money_array(value, where);
      }
   }
   ret_arr = ({ });
   stuff = values[ where ];
   if (!value && stuff) {
      /* Try and figure it out long hand. */
      bits = explode(str, " ") - ({ "and", ",", "" });
      for (i = 0; i < sizeof(bits); i++) {
         /* First we search for a number. */
         if (sscanf(bits[i], "%d", number) == 1 &&
             i + 1 < sizeof(bits)) {
            /*
             * Cool, now see if the next thing is a money type.  Go for longest
             * possible matching string
             */
            i++;
            type = bits[i];
            max_match = 0;
            do {
               match = 0;
               if (type[<1] == ',') {
                  type = type[0..<2];
               }
               type = lower_case(type);
               for (pos = 0; pos < sizeof(stuff); pos += 2) {
                  plural = query_plural_for(stuff[pos]);
                  // Find the last space and splice ourselves in.
                  frog = strsrch(stuff[pos], " ", -1);
                  if (frog) {
                     plural = stuff[pos][0..frog] + plural;
                  }
                  // Do fuzzy matching.
                  if (lower_case(stuff[pos]) == type ||
                      strsrch(lower_case(stuff[pos]), type) != -1 ||
                      lower_case(plural) == type ||
                      strsrch(lower_case(plural), type) != -1) {
                     match = stuff[pos + 1];
                     match_name = stuff[pos];
                  }
               }
               if (match) {
                  i++;
                  max_match = match;
                  if (i < sizeof(bits)) {
                     type += " " + bits[i];
                  }
               }
            } while (match && i < sizeof(bits));
            if (max_match) {
               ret_arr += ({ match_name, number });
            }
            i--;
         } else {
            i++;
         }
      }
   }
   return ret_arr;
} /* value_from_string() */

/**
 * This method attempts to find a money value from a string.  It will
 * attempt to do fuzzy matching of the type.  This means it will match on
 * partial matches, this could lead to somewhat weird behaviour...  So it
 * goes...
 * @param str the string to find the value of
 * @see money_value_string()
 * @example
 * // This will tell us the integer money value of the string.
 * write(MONEY_HAND->value_from_string("1 dollar and 12 pence",
 *                                     "Ankh-Morpork"));
 */
int value_from_string(string str, string where) {
   return query_total_value(money_array_from_string(str, where), where);
} /* value_from_string() */

/**
 * This method calculates the change of a certain value from a
 * given money array.   This makes sure that the change does not include
 * money that does not actually exist.
 * @param value the value of the change to calculate
 * @param mon_array the money array to determine the change from
 * @return the money array containing the change to use
 * @see make_payment()
 * @see pay_amount_from()
 */
mixed *calc_change( int value, mixed *mon_array ) {
   int i, num;
   mixed *ret;

   ret = ({ });
   for ( i = sizeof( mon_array ) - 2; i >= 0; i -= 2 ) {
      if ( value >= mon_array[ i + 1 ] ) {
         num = value / mon_array[ i + 1 ];
         value = value % mon_array[ i + 1 ];
         ret += ({ mon_array[ i ], num });
         if ( !value ) {
            return ret;
         }
      }
   }
   return ret;
} /* calc_change() */

/**
 * This method makes a payment from a money array.  It returns the
 * depleted money array, the amount taken out and the change
 * needed.  If the type is not set, then the best fit for the value
 * is found from the array.
 * <p>
 * The return array is formated as:<br>
 * ({ depleted_money_array, change, taken_from })<br>
 * The change is an integer value.
 * @example
 * ret = make_money_array_payment("Lancre Crown", 2, mon_array, "Lancre", 0);
 * @param type the type of money to take out (ie: "Lancre Crown")
 * @param value the amount of the type to take out
 * @param mon_array the money array to use
 * @param where the money area
 * @param use_default allow the use of the default money type
 * @return the return array as formated above
 */
mixed *make_money_array_payment( string type,
                                 int value,
                                 mixed *mon_array,
                                 string where,
                                 int use_default) {
   
   int i;
   int j;
   int num;
   int total;
   int cur_match;
   string mon_name;
   mixed *poss_values;
   mixed *ret;

   /* Figure out the money type. */
   if ( !where || ( where == "" ) ) {
      where = "default";
   }

   /* See if the money is there and its all easy. */
   if (type) {
      i = member_array( type, mon_array );
      if ( i != -1 ) {
         if ( value <= mon_array[ i + 1 ] ) {
            mon_array[ i + 1] -= value;
            return ({ ({ type, value }), 0, mon_array });
         }
      }

      /*
       * Damn, its not easy.  Figure out the real value and see if we can
       * get it out of the arrays.
       */
      value *= query_value( type, where );
   }

   // Cannot make a 0 value payment.
   if (!value) {
      return 0;
   }

   /* Check to make sure the total is ok. */
   total = query_total_value( mon_array, where );
   if (use_default  &&  where != "default") {
      total += query_total_value( mon_array, "default" );
   }
   /* If the value is more than the total...  */
   if ( value > total ) {
      return 0;
   }

   /* Get the possible values. */
   poss_values = ({ });
   if ( where != "default" && use_default ) {
      poss_values += values[ "default" ];
   }
   poss_values += values[ where ];

   /* Determine the return array */
   ret = ({ });
   /* This attempts an exact match of coins. */
   for ( i = ( sizeof( poss_values ) - 2 ); i >= 0; i -= 2 ) {
      j = member_array( poss_values[ i ], mon_array );
      if ( j != - 1 ) {
         if ( poss_values[ i + 1 ] <= value ) {
            num = value / poss_values[ i + 1 ];
            if ( num > mon_array[ j + 1 ] ) {
               num = mon_array[ j + 1 ];
            }
            mon_array[ j + 1] -= num;
            value -= num * poss_values[ i + 1 ];
            ret += ({ poss_values[ i ], num });
            if ( !value ) {
               return ({ ret, value, mon_array });
            }
         }
      }
   }

   /* No exact match...   So we need to figure out how much change to give. */
   /* One zoom through the array finding which one has the closest match. */
   cur_match = value + 10000000;
   for (i = 0; i < sizeof(poss_values); i +=2 ) {
      j = member_array( poss_values[ i ], mon_array);
      if (j != -1 &&
          mon_array[j + 1] > 0 &&
          poss_values[i + 1] >= value &&
          poss_values[i + 1] - value <= cur_match - value) {
         cur_match = poss_values[i + 1];
         mon_name = poss_values[i];
      }
   }

   if (mon_name) {
      j = member_array(mon_name, mon_array);
      i = member_array(mon_name, poss_values);
      mon_array[j + 1] -= 1;
      value = poss_values[i + 1] - value;
      ret += ({ poss_values[ i ], 1 });
   } else {
      return 0;
   }

   return ({ ret, value, mon_array });
} /* make_money_array_payment() */

/**
 * This method makes a payment of a particular amount in a particular
 * money area.   Please note that player or living objects can double
 * as money objects in this circumstance.  The first element of the
 * payment array is the values which should be used to take off
 * the player, the second element is the change needed to be payed
 * back.
 * @param type the type of money to pay in (ie: "Lancre Crown")
 * @param value the number of the type to pay
 * @param thing the thing which is doing the payment (money object)
 * @param where the money area the payment will occur in
 * @return the payment array
 * @see pay_amount_from()
 * @see calc_change()
 */
varargs mixed *make_payment( string type, int value, object thing,
                             string where ) {
   mixed *mon_array;
   mixed *stuff;

   if (!type) {
     return 0;
   }

   mon_array = copy(thing->query_money_array());
   stuff = make_money_array_payment( type, value, mon_array, where, 1);
   if (!stuff) {
      return stuff;
   }
   if (stuff[MONEY_PAY_CHANGE]) {
      return ({ stuff[MONEY_PAY_RETURN], calc_change(stuff[MONEY_PAY_CHANGE],
                                                     values[where]) });
   }
   return ({ stuff[MONEY_PAY_RETURN], stuff[MONEY_PAY_CHANGE] });
} /* make_payment() */

/**
 * This method makes a payment from a specified money object.
 * @param value the amount to pay
 * @param money the money object to pay from
 * @param where the money area the payment occurs in
 * @return the change object
 * @see make_payment()
 * @see calc_change()
 */
varargs object pay_amount_from(int value, object money, string where) {
   int i;
   object change;
   mixed *m_array, *p_array;
   mixed *change_array;
   mixed *pay_array;

   if (!where || where == "") {
      where = "default";
   }
   change_array = ({ });
   pay_array = ({ });
   m_array = create_money_array(value, where);
   for (i = 0; i < sizeof(m_array); i += 2) {
      p_array = make_payment(m_array[i], m_array[i + 1], money, where);
      if (!pointerp(p_array)) {
         continue;
      }

      if (sizeof(p_array[0]) > 0)
         pay_array = merge_money_arrays(pay_array, p_array[0]);
      if (sizeof(p_array[1]) > 0) {
         change_array = merge_money_arrays(change_array, p_array[1]);
      }
   }

   if (sizeof(pay_array) > 0)  {
      for (i = 0; i < sizeof(pay_array); i += 2) {
         pay_array[i + 1] = -pay_array[i + 1];
      }
      money->adjust_money(pay_array);
   }

   if (sizeof(change_array) == 0) {
      return 0;
   }

#ifdef USE_VAULT
   change = MONEY_VAULT->get_money_ob();
   change->set_money_array(change_array);
#else
   change = clone_object(MONEY_OBJECT);
#endif
   return change;

} /* pay_amount_from() */

/**
 * This method creates a money object of a certain value in a certain
 * money area.
 * @param value the value to create the new money object with
 * @param where the area to create the new money object in
 * @return the new money object
 */
varargs object make_new_amount( int value, string where ) {
   object money;

   if ( !where || ( where == "" ) ) {
      where = "default";
   }
#ifdef USE_VAULT   
   money = MONEY_VAULT->get_money_ob();
#else
   money = clone_object( MONEY_OBJECT );
#endif
   money->set_money_array( create_money_array( value, where ) );
   if ( !(int)money->query_value_in( where ) ) {
      money->dest_me();
      return 0;
   }
   return money;
} /* make_new_amount() */

/**
 * This method figures out the legal and illegal tender money from
 * the specified money object in the specified money area.   This method
 * returns a two element array which consists of the legal and illegal
 * tender for the given money area.   ({ legal, illegal }).  WARNING:
 * This method destructs the money object passed to it.
 * @param money the money object to get the legal tender from
 * @param where the money area the tender is for
 * @return an two element array of objects ({ legal, illegal })
 * @see parse_money()
 */
varargs object *filter_legal_tender(object money, string where) {
   mixed *m_array;

   m_array = (mixed *)money->query_money_array();
   money->dest_me();

   return filter_legal_money_array(m_array, where);

} /* filter_legal_tender() */


/**
 * This method is identical to filter_legal_tender, except that it takes
 * a money array rather than a money object
 * @param m_array the money array to get the legal tender from
 * @param where the money area the tender is for
 * @return an two element array of objects ({ legal, illegal })
 * @see parse_money()
 * @see filter_legal_tender()
 */
varargs object *filter_legal_money_array(mixed *m_array, string where) {
   int i;
   object good, no_good;
   mixed *poss_values;
   mixed *good_array = ({ });
   mixed *no_good_array = ({ });

   if (sizeof(m_array) == 0) {
      return ({ 0, 0 });
   }
   if (!(poss_values = values[where])) {
      poss_values = ({ });
   }
   if (!where || where == "") {
     where = "default";
   }

   for (i = 0; i < sizeof(m_array); i += 2) {
      if (member_array(m_array[i], poss_values) != -1) {
         good_array += ({ m_array[i], m_array[i + 1] });
      } else {
         no_good_array += ({ m_array[i], m_array[i + 1] });
      }
   }

   if (sizeof(good_array) == 0) {
      good = 0;
   }
   else  {
#ifdef USE_VAULT     
      good = MONEY_VAULT->get_money_ob();
#else
      good = clone_object(MONEY_OBJECT);
#endif
      good->set_money_array(good_array);
   }

   if (sizeof(no_good_array) == 0) {
      no_good = 0;
   }
   else  {
#ifdef USE_VAULT
     no_good = MONEY_VAULT->get_money_ob();
#else
     no_good = clone_object(MONEY_OBJECT);
#endif
     no_good->set_money_array(no_good_array);
   }

   return ({ good, no_good });

} /* filter_legal_money_array() */


/**
 * This method merges two money arrays together and returns the
 * merged array
 * @param m_array1 the first money array
 * @param m_array2 the second money_array
 * @return a money array of m_array1 and m_array2 joined
 */
mixed *merge_money_arrays(mixed *m_array1, mixed *m_array2)  {
   int i;
   int idx;
   mixed *new_m_array;

   if (!m_array1)
      m_array1 = ({ });
   if (!m_array2)
      m_array2 = ({ });

   /* Loop over smallest array for efficiency */
   if (sizeof(m_array1) < sizeof(m_array2))  {
      new_m_array = copy(m_array2);
      for (i = 0; i < sizeof(m_array1); i += 2)  {
         idx = member_array(m_array1[i], new_m_array);
         if (idx > -1)  {
            new_m_array[idx + 1] += m_array1[i + 1];
            if (new_m_array[idx + 1] <= 0)
               new_m_array = delete(new_m_array, idx, 2);
         }
         else
            new_m_array += ({ m_array1[i], m_array1[i + 1] });
      }
   }
   else  {
      new_m_array = copy(m_array1);
      for (i = 0; i < sizeof(m_array2); i += 2)  {
         idx = member_array(m_array2[i], new_m_array);
         if (idx > -1)  {
            new_m_array[idx + 1] += m_array2[i + 1];
            if (new_m_array[idx + 1] <= 0)
               new_m_array = delete(new_m_array, idx, 2);
         }
         else
            new_m_array += ({ m_array2[i], m_array2[i + 1] });
      }
   }
   return new_m_array;

} /* merge_money_arrays() */


/**
 * This method determines all the money from the player object and moves
 * it into a container.  It then figured out the legal tender for
 * specified money area and tells the player if the given money is
 * legal tender for the current area.  It will automatically return the
 * illegal tender and send a message to the player about it.
 * @param words the string to match the money on
 * @param player the player who is attempting the transaction
 * @param place the money area the transaction is taking place
 * @return a money object consisting of the legal tender
 * @see filter_legal_tender()
 */
varargs mixed parse_money(string words, object player, string place) {
   object  thing;
   object *monies;
   object *things;
   mixed  *m_array;
   mixed  *m_array2;
   int     i;

   things = match_objects_for_existence(words, ({ player }));
   if (sizeof(things) == 0) {
      // If not here, try a money_array_from_string thing.
      m_array = money_array_from_string(words, place);
       if (sizeof(m_array) == 0) {
         return NO_MATCH;
      }
      // Now, check and see if the money exists.
      thing = present(MONEY_ALIAS, player);
      if (!thing) {
         return NO_MATCH;
      }
      for (i = 0; i < sizeof(m_array); i += 2) {
         if (thing->query_money(m_array[0]) < m_array[1]) {
            return NO_MATCH;
         }
      }
   }
   else {
      things = filter(things, (: $1->query_property("money") :));
      if (sizeof(things) == 0)
         return NO_MONEY;

      m_array = ({ });
      foreach (thing in things)  {
         m_array = merge_money_arrays(m_array, thing->query_money_array());
#ifdef USE_VAULT
         // Not sure if this is correct.
         MONEY_VAULT->add_to_list(thing);
#endif
      }
   }

   monies = filter_legal_money_array(m_array, place);

   /* Illegal money */
   if (monies[1])  {
      tell_object(player, monies[1]->the_short() +
            (monies[1]->query_number_coins() == 1 ? " is" : " are") +  
            " not legal tender here.\n");
      m_array = monies[1]->query_money_array();
#ifdef USE_VAULT
      MONEY_VAULT->add_to_list(monies[1]);
#endif
   }
   else
      m_array = ({ });

   /* Legal money */
   if (monies[0])  {
      m_array2 = copy(monies[0]->query_money_array());
      for (i = 0; i < sizeof(m_array2); i += 2)
         m_array2[i + 1] = -m_array2[i + 1];
      merge_money_arrays(m_array, m_array2);
      this_player()->adjust_money(m_array);
      return monies[0];
   }
   else return NO_LEGAL;

} /* parse_money() */


/**
 * This method makes a payment from one person to another.
 * This method figures out what money should be given to the player
 * and what should be taken from the other to make a payment of the
 * correct value in the correct place.
 * @param value the value to pay
 * @param place the place to make the payment in
 * @param payer the person the money is payed from
 * @param payee the person the money is payed to
 * @return two element array, or 0 if it cannot be done
 */
mixed *query_person_payments(int value, string place,
                             object payer, object payee) {
   mixed *stuff;
   mixed *mon_array;
   mixed *rabbit;

   mon_array = copy(payer->query_money_array());
   stuff = make_money_array_payment( 0, value, mon_array, place, 0);
   if (!stuff) {
      return 0;
   }
   if (stuff[MONEY_PAY_CHANGE]) {
      /*
       * Ok, now check to see if we can get the change from the other
       * guy.
       */
      mon_array = copy(payee->query_money_array());
      rabbit = make_money_array_payment( 0, stuff[MONEY_PAY_CHANGE],
                                         mon_array, place, 0);
      if (!rabbit || rabbit[MONEY_PAY_CHANGE]) {
         return 0;
      }
      return ({ stuff[MONEY_PAY_RETURN], rabbit[MONEY_PAY_RETURN] });
   }
   return ({ stuff[MONEY_PAY_RETURN], ({ }) });
} /* query_person_payments() */

/**
 * This returns a list of valid coin types
 * @return an array of valid coin types
 */
string * query_valid_types(){
  mixed *tmp;
  string *elem, *valid_types = ({ });
  int i;
      
  tmp = values(query_all_values());
  foreach( elem in tmp ){ 
    for( i = 0; i < sizeof( elem ); i += 2 ){
      if ( stringp( elem[i] ) )
        valid_types += ({ elem[i] });
    }
  } return valid_types;
}/* query_valid_types() */

/**
 * This takes a coin type and returns the place it is associated with.
 * @param type the coin type i.e. "Ankh-Morpork dollar"
 * @return the place i.e. "Ankh-Morpork"
 */
string query_origin_of( string type ){
  string elem, *places;
  
  if( member_array( type, query_valid_types() ) == -1 )
    return 0;
  
  places = query_all_places();
  
  foreach( elem in places ){
    if( member_array( type,query_values_in( elem ) ) != -1 )
      return elem;
  }
}/* query_origin_of() */

/**
 * This converts a currency type's alias (i.e. "royal" ) and returns
 * its 'real' names (i.e. "Ankh-Morpork royal"
 * @param word the alias to find the real name of
 * @return an array of real names, or 0 if it's not a real alias
 */
string * query_aliases_of( string word ){
  string *types, elem, *aliases = ({ });
  
  types = query_valid_types();
  
  foreach( elem in types ){
    if( member_array( word,query_aliases_for( elem ) ) != -1 )
      aliases += ({ elem });
  } return aliases;
}/* query_alias_of */

/**
 *This returns the value of a currency type.
 * @param type currency type
 * @return an int of the currency type's value
 */
int query_value_of( string type ){
  if( member_array( type, query_valid_types() ) == -1 )
    return 0;
   return query_value( type, query_origin_of( type ) );
}/* query_value_of() */


/**
 * This returns the smallest unit of currency in this place.
 * @param place The place to query.
 * @return A string of the smallest unit of currency
 * @see smallest_value_in()
 */
string smallest_in( string place ) {
   int i, smallest, r;
   mixed *values;

   values = query_values_in( place );
   for ( i = 1; i < sizeof( values ); i += 2 ) {
      if ( !smallest || ( values[i] < smallest ) ) {
         smallest = values[i];
         r = i;
      }
   }
   return values[r-1];
}
/* smallest_in() */


/**
 * This returns the smallest value of currency in this place.
 * @param place The place to query.
 * @return the value of the smallest unit of currency
 * @see smallest_in()
 */
int smallest_value_in( string place ) {
   int i, smallest, r;
   mixed *values;

   values = query_values_in( place );
   for ( i = 1; i < sizeof( values ); i += 2 ) {
      if ( !smallest || ( values[i] < smallest ) ) {
         smallest = values[i];
         r = i;
      }
   }
   return values[r];
}
/* smallest_value_in() */


/**
 * This method returns the values in the specified area.
 * It contains name, value pairs and is for the "default"
 * area.  It is returned as a mapping for easier sorting
 * & manipulation.
 * @param where the area in which to return the values for
 * @see query_all_values()
 * @see query_values()
 * @see add_type()
 * @see query_values_in()
 */
mapping query_mapped_values_in( string where ) {
   mapping values = ([]);
  mixed * array;
  int i;

   if ( !where || ( where == "" ) )
      where = "default";
  array = query_values_in(where);
   for ( i = 1; i < sizeof(array); i += 2 )
  {
      values += ([array[i-1]:array[i]]);
   }
   return values;
} /* query_mapped_values_in() */
// --- END [/mnt/home2/grok/lib/obj/handlers/nmoney_handler.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/folder_handler.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/folder_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628222   Available: 13575576
Inodes: Total: 5242880    Free: 4960134
22996 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/folder_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628222   Available: 13575576
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker: taffyd $
 * $Id: folder_handler.c,v 1.20 2003/03/20 23:16:18 ceres Exp taffyd $
 * 
 */
/**
 *  Folder handler for the mailer.
 *  Actually it does a lot more :-)
 * <p>
 *  Thanks to Wodan and Pinkfish for ideas and help. <br>
 *  By Turrican@Discworld, May 1995.
 * @author Turrican
 * @started May 1995
 */
#pragma strict_types

#include <board.h>
#include <comms.h>
#include <mail.h>
#include <network.h>
#include <mime.h>
#include <player_handler.h>

#define MAIL_PATH "/save/mail/"
int *mesg_numbers;
class mail_header *info;
int new_thingy;
nosave int link;

class mail_header *get_messages(string pname, string fname);
string load_message(string pname, string fname, int number); 
void delete_it(string pname, string fname, int *deleted);
string check_local(string arg);
private int load_counter();
private void save_counter(int counter);
void dest_me();
void delete_account(string player);

void create() {
  seteuid("Mailer");
} /* create() */

private string folder_filename(string name) {
  if(file_size(MAIL_PATH + name) != -1) {
    unguarded((: rename, MAIL_PATH + name,
         MAIL_PATH + name[0..0] + "/" + name :));
  } else if(file_size(MAIL_PATH + name + ".o") != -1) {
    unguarded((: rename, MAIL_PATH + name + ".o",
         MAIL_PATH + name[0..0] + "/" + name + ".o" :));
  }

  return MAIL_PATH+name[0..0] + "/"  + name;
}

private string message_filename(int num, string prefix) {

  if(file_size(MAIL_PATH+"new_mesg/" + (num % 50)) == -1) {
    unguarded((: mkdir, MAIL_PATH+"new_mesg/" + (num % 50) :));
  }
  if(file_size(MAIL_PATH+"new_mesg/"+(num % 50)+"/"+((num / 50) % 50)) == -1) {
    unguarded((: mkdir, MAIL_PATH+"new_mesg/" + (num %50) + "/" +
         ((num / 50) % 50) :));
  }
#ifdef 0
  if(file_size(MAIL_PATH + "mesg/" + prefix + num) != -1) {
    unguarded((: rename, MAIL_PATH + "mesg/" + prefix + num, 
     MAIL_PATH+"new_mesg/"+ (num % 50) + "/" + ((num / 50) % 50) +
     "/" + prefix + num :));
  }
#endif
  
  return MAIL_PATH+"new_mesg/"+  (num % 50) + "/" + ((num / 50) % 50) +
    "/" + prefix + num;
}

/**
 * Can a folder with a certain name be created?
 * @param player the player creating the folder
 * @param folder the name of the folder to be created
 * @return 1 if the folder can be created, 0 if it can't.
 */
nomask int can_create_folder(string player, string folder) {
    return file_size(folder_filename(player) + folder + ".o") == -1;
} /* can_create_folder() */ 

/**
 * This method converts the links.  It will remove the old 'links' file and
 * wrap it into the first line of the message itself.
 * <p>
 * So I think I should put a poem here instead...
 * <p>
 * <b>Thinking of you</b> (by Pinkfish)
 * <p>
 * Thinking of you always<br>
 * Puts me a good mood<br>
 * I dream of your voice<br>
 * Your words and face
 * <p>
 * I long to be with you<br>
 * At last to touch<br>
 * To feel your warmth<br>
 * And stare into your eyes
 * @param number the message number to check
 */
private void convert_links(int number) {
  string message;
  int tmplink;

  message = unguarded((: read_file, message_filename(number, "l"), 1, 1 :));
  if (!message || sscanf(message, "%d", tmplink) != 1) {
    return;
  }
  sscanf(message, "%d", tmplink);
  message = unguarded((: read_file, message_filename(number, "") :));
  unguarded((: rm, message_filename(number, "") :));
  unguarded((: rm, message_filename(number, "l") :));
  unguarded((: write_file, message_filename(number, ""),
               "" + tmplink + "\n" + message :));
} /* convert_links() */

/**
 * This method returns the message data of the message.
 * @param number the message number to read
 */
private string query_message_data(int number) {
   string data;

   convert_links(number);

   data = unguarded((: read_file, message_filename(number, "") :));
   if(!data)
     return data;
   
   // Strip off the first line.
   sscanf(data, "%*d\n%s", data);
   return data;
} /* query_message_data() */

/**
 * This method creates a new message.
 * @param number the message number
 * @param data the message data
 * @param links the number of links
 */
private void create_new_message(int number, string data, int links) {
   unguarded((: rm, message_filename(number, "") :));
   unguarded((: write_file, message_filename(number, ""),
                            "" +links + "\n" + data :));
} /* create_new_message() */

/**
 * This method increments the links of links on the specified message
 * number.
 * @param number the message number to increment
 */
private void increment_links(int number) {
  string message;
  int num_links;

  convert_links(number);
  message = unguarded((: read_file, message_filename(number, "") :));
  if (!message) {
     return ;
  }

  sscanf(message, "%d\n%s", num_links, message);
  num_links++;
  unguarded((: rm, message_filename(number, "") :));
  unguarded((: write_file, message_filename(number, ""),
               "" + num_links + "\n" + message :));
} /* increment_links() */

/**
 * This method increments the links of links on the specified message
 * number.
 * @param number the message number to increment
 */
private void decrement_links(int number) {
  string message;
  int num_links;

  convert_links(number);
  message = unguarded((: read_file, message_filename(number, "") :));
  if (!message) {
     return ;
  }

  sscanf(message, "%d\n%s", num_links, message);
  num_links--;
  unguarded((: rm, message_filename(number, "") :));
  if (num_links > 0) {
     unguarded((: write_file, message_filename(number, ""),
                  "" + num_links + "\n" + message :));
  }
} /* decrement_links() */

private int check() {
  string base;

  base = base_name(previous_object());
  if (base != "/obj/handlers/mailer" &&
      base != "/obj/handlers/folder_handler" &&
      base != "/obj/handlers/converter" &&
      base != "/net/daemon/pop3" &&
      base != "/net/daemon/imap4" &&
      base != "/secure/bulk_delete") {
    printf("Folder handler: Illegal access ! (%O)\n", base);
    return 1;
  } else
    return 0;
} /* check() */

private void convert_class(string pname, string fname) {
  class mail_header hdr;
  int i;

  i = sizeof(info);
  while (i--) {
    hdr = new(class mail_header);
    hdr->number = ((mapping)info[i])["number"];
    hdr->status = ((mapping)info[i])["status"];
    hdr->subject = ((mapping)info[i])["subject"];
    hdr->from = ((mapping)info[i])["from"];
    info[i] = hdr;
  }
  unguarded((: save_object, folder_filename(lower_case(pname)+fname) :));
} /* convert_class() */



/**
 * This method returns the messages for the player in the specified
 * folder.  The return is an array of messages of type 'class mail_header'.
 * @param pname the players name
 * @param fname the folder name
 * @return a list of messages
 */
class mail_header *get_messages(string pname, string fname) {

  if (check())
    return ({ });

  mesg_numbers = ({ });
  info = ({ });
  new_thingy = 0;
  unguarded((: restore_object, folder_filename(lower_case(pname)+fname) :));
  if (sizeof(info) && mapp(info[0])) {
    convert_class(pname, fname);
  }
  return info;
} /* get_messages() */

/**
 * This method loads a message for the specified player in the specified
 * folder.
 * @param pname the players name
 * @param fname the folder name
 * @param number the message number to open
 * @return the text of the message
 */
string load_message(string pname, string fname, int number) {
  string message;

  if (check()) {
    return " ";
  }
  if (file_size(message_filename(number, "l")) > 0)  {
    convert_links(number);
  }
  message = query_message_data(number);
  if (!message) {
    printf("* Failed to load message.\n", number);
  }
  return message;
} /* load_message() */

/**
 * This method will attempt to the delete the specified messages from
 * the folder.  The array deleted must be an array of integers where each
 * number is a message number to be deleted.
 * @param pname the players name
 * @param fname the folder name
 * @param deleted the array of message numbers to delete from the folder
 */
void delete_it(string pname, string fname, int *deleted) {
  int i, idx;

  if (check()) {
    return;
  }
  if (!PLAYER_HANDLER->test_user(pname)) {
    return;
  }
  if (sizeof(deleted) > 1) {
    deleted = uniq_array(deleted);
    deleted = sort_array(deleted, 1);
  }
  mesg_numbers = ({ });
  info = ({ });
  new_thingy = 0;
  unguarded((: restore_object, folder_filename(lower_case(pname)+fname) :));
  if (sizeof(info) && mapp(info[0])) {
    convert_class(pname, fname);
  }
  i = sizeof(deleted);
  while (i--) {
    reset_eval_cost();
    if ((idx = member_array(deleted[i], mesg_numbers)) > -1) { 
      if (file_size(message_filename(mesg_numbers[idx], "l")) > 0) {
        convert_links(mesg_numbers[idx]);
      }
      decrement_links(mesg_numbers[idx]);
      mesg_numbers = delete(mesg_numbers, idx, 1);
      if (idx < sizeof(info) && info[idx] &&
          ((class mail_header)info[idx])->status == "N") {
        new_thingy--;
      }
      info = delete(info, idx, 1); 
    }
  }
  unguarded((: save_object, folder_filename(lower_case(pname)+fname) :));
} /* delete_it() */

private void send_frog(object player, string to, string from) {
   object ob;

   if (!player || !environment(player)->send_message(to)) {
      catch(ob = clone_object(POST_FROG));
      write("A small frog with a post office hat wanders up and takes "
            "your mail.\n");
      say("A small frog with a post office hat wanders up to "+
          player->query_cap_name()+" and takes "+
          player->query_possessive()+" mail.\n");
      if (find_player(to) && sscanf(from, "%*s@%*s") == 2) {
        catch(ob->move(COMM_ROOM, ob->query_mmsgin(), ob->query_mmsgout()));
      } else {
        catch(ob->move(environment(player)));
      }
      catch(ob->send_mail(to, from));
   }
} /* send_frog() */

private void send_notification(string to,
                               string from) {
    if (find_player(from) ||
        sscanf(from, "%*s@%*s") == 2) {
       call_out((: send_frog :), 0, find_player(from), to, from);
    }
} /* send_notification() */

/**
 * This method adds a message into all the correct folders and stuff.
 * This is the method that is called when a piece of mail is actually
 * sent.
 * @param mesg the message to send
 * @param flag if this is set to a non-zero value then no delivery messages will
 * occur
 * @see delete_it()
 */
void add_it(class mail_message mesg, int flag) {
  int i, counter, bong, ptpost;
  string *local_to, *remote_to, *fail_to, str;
  class mail_header hdr;

  if (check()) {
    return;
  } 
  if (sizeof(mesg->cc)) {
    mesg->to += mesg->cc;
  }
  mesg->to = MIME->get_email_addrs(implode(mesg->to, ","))[0];
  local_to = ({ });
  remote_to = ({ });
  fail_to = ({ });
  str = "";
  bong = sizeof(mesg->to);
  for (i = 0; i < bong; i++) {
    if ((str = check_local(mesg->to[i]))) {
      if (MAIL_TRACK->query_list(str)) {
        local_to += MAIL_TRACK->query_members(str) - ({ mesg->from });
        if ( str == "playtesters" ) {
          ptpost = 1;
        }
      } else {
        local_to += ({ str });
      }
    } else {
      remote_to += ({ mesg->to[i] });
    }
  }
  local_to = uniq_array(local_to);
  remote_to = uniq_array(remote_to);
  if ((i = sizeof(local_to))) {
    if (!(counter = load_counter())) {
      if (!flag) {
        printf("Aborting send of message...\n");
      }
      return;
    }
    if (file_size(message_filename(counter, "")) > 0) {
      if (!flag) {
        printf("Fatal error when sending message: File %d exists.\n"
               "Please contact Turrican.\n", counter);
      }
      return;
    }
    for (i = 0; i < sizeof(local_to); i++) {
      if (!flag) {
        printf("Sending to: %s.\n", capitalize(local_to[i]));
      }
      
      if(MAIL_TRACK->find_mailer(local_to[i]) ||
         PLAYER_HANDLER->test_user(local_to[i])) {
        mesg_numbers = ({ });
        info = ({ });
        new_thingy = 0;
        unguarded((: restore_object, folder_filename(local_to[i]+"inbox") :));
        if (sizeof(info) && mapp(info[0]))
          convert_class(local_to[i], "inbox");
      
        // No more mail for people whose folder is full!
        if(sizeof(mesg_numbers) > MAX_FOLDER_SIZE) {
          write("Sorry, mailbox is full for " + local_to[i] + ".\n");
          mesg->to -= ({ local_to[i] });
          mesg->cc -= ({ local_to[i] });
          local_to = delete(local_to, i--, 1);
          continue;
        }
        
        if(!PLAYER_HANDLER->test_active(local_to[i])) {
          write("Sorry, " + local_to[i] + " is inactive and so unable to "
                "receive mail.\n");
          mesg->to -= ({ local_to[i] });
          mesg->cc -= ({ local_to[i] });
          local_to = delete(local_to, i--, 1);
          continue;
        }
        
        mesg_numbers += ({ counter });
        new_thingy++;
        hdr = new(class mail_header);
        hdr->number = counter;
        hdr->status = "N";
        hdr->subject = mesg->subject;
        hdr->from = mesg->from;
        info += ({ hdr });
        if (!unguarded((: save_object, folder_filename(local_to[i]+"inbox") :))) {
          if (!flag) {
            printf("Couldn't save mailbox for %s...\n",
                   capitalize(local_to[i]));
          }
          
          mesg->to -= ({ local_to[i] });
          mesg->cc -= ({ local_to[i] });
          local_to = delete(local_to, i--, 1);
          continue;
        }
        
        if(this_player() && environment(this_player()))
          send_notification(local_to[i], mesg->from);
      } else {
        fail_to += ({ local_to[i] });
        mesg->to -= ({ local_to[i] });
        mesg->cc -= ({ local_to[i] });
        local_to = delete(local_to, i--, 1);
      }
    }
    if (i) {
      ++counter;
      save_counter(counter);
      create_new_message(counter - 1, mesg->body, i);
    }
  }
  if ((i = sizeof(fail_to))) {
    /* ohhhh...the recipient doesn't exist...make it bounce. */
    while (i--) {
      MAILER->do_mail_message(mesg->from, "postmaster", "Error! User "+
                              fail_to[i]+" unknown", 0,
                              "Original message included:\n\n> "+
                              replace_string(mesg->body, "\n", "\n> "), 1, 0);
    }
  }
  if (sizeof(remote_to) && !flag) {
    for (i = 0; i < sizeof(remote_to); i++) {
      sscanf(remote_to[i], "%*s@%s", str);
      if (str && INTERMUD_D->GetMudName(str)) {
        printf("Sorry, Intermud mail is not currently supported.  "
               "Didn't send mail to %s.\n", remote_to[i]);
        remote_to = delete(remote_to, i--, 1);
        continue;
      }
    }
    SMTP->eventSendMail(remote_to, mesg->from, mesg->body);
  }
  if (ptpost) {
    BOARD_HAND->add_message("playtesters", capitalize(mesg->from),
                            mesg->subject, sprintf( "%-=78s\n", 
                            mesg->body ));
  }
} /* add_it() */

/**
 * This method marks the messages which are not in the unread array
 * in the specified folder as being read.
 * @param pname the player name
 * @param fname the folder name
 * @param unread the list of messages that are still unread
 */
void mark_read(string pname, string fname, int *unread) {
  int i;

  if (check()) {
    return;
  }
  if (!PLAYER_HANDLER->test_user(pname)) {
    return;
  }
  unread = uniq_array(unread);
  mesg_numbers = ({ });
  info = ({ });
  new_thingy = 0;
  unguarded((: restore_object, folder_filename(lower_case(pname)+fname) :));
  if (sizeof(info) && mapp(info[0])) {
    convert_class(pname, fname);
  }
  if (new_thingy == sizeof(unread)) {
    return;
  }
  new_thingy = 0;
  i = sizeof(mesg_numbers);
  while (i--) {
    if (member_array(i, unread) > -1) {
      ((class mail_header)info[i])->status = "N";
      new_thingy++;
    }
    else if(i < sizeof(info))
      ((class mail_header)info[i])->status = " ";
    else
      write("\nErk, problems. The arrays don't quite match.\n");
    reset_eval_cost();
  }
  unguarded((: save_object, folder_filename(lower_case(pname)+fname) :));
  new_thingy = 0;
} /* mark_read() */

/**
 * This method moves the specified message from one folder to another.
 * @param pname the player name
 * @param from the folder to move from
 * @param to the folder to move to
 * @param number the message number to move
 */
int move_it(string pname, string from, string to, int number) {
  class mail_header tmphdr;

  if (check())
    return 1;
  mesg_numbers = ({ });
  info = ({ });
  new_thingy = 0;
  unguarded((: restore_object, folder_filename(lower_case(pname)+to) :));
  if (sizeof(info) && mapp(info[0])) {
    convert_class(pname, to);
  }
  if (member_array(number, mesg_numbers) > -1) {
    return 1;
  }
  if(sizeof(mesg_numbers) > MAX_FOLDER_SIZE) {
    return 2;
  }
  if (file_size(message_filename(number, "l")) > 0) {
    convert_links(number);
  }
  increment_links(number);
  mesg_numbers = ({ });
  info = ({ });
  new_thingy = 0;
  unguarded((: restore_object, folder_filename(lower_case(pname)+from) :));
  if (sizeof(info) && mapp(info[0])) {
    convert_class(pname, from);
  }
  tmphdr = info[member_array(number, mesg_numbers)];
  mesg_numbers = ({ });
  info = ({ });
  new_thingy = 0;
  unguarded((: restore_object, folder_filename(lower_case(pname)+to) :));
  mesg_numbers += ({ number });
  info += ({ tmphdr });
  if (tmphdr->status == "N") {
    new_thingy++;
  }
  unguarded((: save_object, folder_filename(lower_case(pname)+to) :));
  return 0;
} /* move_it() */

/**
 * This method checks to see if the specified players folder is empty.
 * @param pname the player name to check
 * @param fname the folder name to check
 */
int check_empty(string pname, string fname) {
  mesg_numbers = ({ });
  info = ({ });
  new_thingy = 0;
  unguarded((: restore_object, folder_filename(lower_case(pname)+fname) :));
  if (!sizeof(mesg_numbers)) {
    unguarded((: rm, folder_filename(lower_case(pname)+fname)+".o" :));
    return 1;
  }
  return 0;
} /* check_empty() */

/**
 * This method checks to see if the address is local.
 * @param str the address to check
 * @return local name for local messages, 0 for remote messages
 */
string check_local(string str) {
  string name;

  if (sscanf(lower_case(str),
             "%*([\n \t]*([ \t!-;=?-~]+<)?)%([A-Za-z]+)"
             "%*((.discworld(@|$))|$)",
             name) == 3) {
    return name;
  }
  return 0;
} /* check_local() */

/**
 * This method returns a 2 item array for the amount of mail in a persons
 * inbox.  This first index is the total number of messages and the second
 * is the number that are unread.
 *
 * @param pname the players name.
 * @return a two item array.
 */
int *mail_count(string pname) {
  int num;
  
  mesg_numbers = ({ });
  info = ({ });
  new_thingy = 0;
  unguarded((: restore_object, folder_filename(pname+"inbox") :));
  if(sizeof(info) && mapp(info[0]))
    convert_class(pname, "inbox");

  num = sizeof(mesg_numbers);

  if (!mesg_numbers || !num)
    return ({ 0, 0 });

  return ({ num, new_thingy});
}

/**
 * This method returns the nice string used when fingering a player to
 * determine their mail status.
 * @param pname the player name to finger
 * @return the string associated with the inbox of the player
 */
string finger_mail(string pname) {
  string ret;
  int *tmp;

  tmp = mail_count(pname);

  if(!tmp[0])
    return "No mail.\n";
  if (tmp[0] == 1) {
    ret = "1 mail message";
  } else {
    ret = tmp[0] + " mail messages";
  }
  
  if(tmp[1] <= 0)
    ret += ".\n";
  else
    ret += ", " + tmp[1] + " of them unread.\n";
  return ret;
}

/**
 * This method is called when the player logs on to determine if they have
 * any new mail or not.
 * @param pname the players name to check
 */
string check_mail(string pname) {
  int *tmp;
  string ret;
  
  tmp = mail_count(pname);
  switch(tmp[1]) {
  case 0:
    ret = "";
    break;
  case 1:
    ret = "\nYou have %^YELLOW%^1 NEW%^RESET%^ mail message.  Go to a "
      "post office to read it.\n\n";
    break;
  default:
    ret = "\nYou have %^YELLOW%^" + tmp[1] + " NEW%^RESET%^ mail messages.  "
      "Go to a post office to read them.\n\n";
  }
  
  if(tmp[0] > MAX_FOLDER_SIZE) {
    ret = "\n%^BOLD%^%^RED%^You have " + tmp[0] + " messages in your inbox.  "
      "You will receive no more mail until this number is reduced below "
      "acceptable limits.%^RESET%^" + ret;
  } else if(tmp[0] > WARN_FOLDER_SIZE) {
    ret = "\n%^BOLD%^%^RED%^You have " + tmp[0] + " messages in your inbox.  "
      "This is far too many.\n  Please delete some immediately!%^RESET%^" +
      ret;
  }
  
  return ret;
}

private void save_counter(int counter) {
  if (check())
    return;
  unguarded((: rm, MAIL_PATH+"counter.save" :));
  unguarded((: rename, MAIL_PATH+"counter", MAIL_PATH+"counter.save" :));
  unguarded((: write_file, MAIL_PATH+"counter", ""+counter :));
} /* save_counter() */

private int load_counter() {
  string bing;
  int ret;

  if (check()) {
    return 0;
  }
  if (bing = unguarded((: read_file, MAIL_PATH+"counter" :))) {
    sscanf(bing, "%d", ret);
  } else {
    printf("The mail counter was lost. Please contact Turrican.\n");
    return 0;
  }
  return ret;
} /* load_counter() */

/**
 * This method sets the current message counter.  This will return a
 * message if the counter was not valid.  This should be called in the
 * event that a recovery is needed if the counter screws up.
 * @param x the new value for the counter
 */
void set_counter(int x) {
  if(file_size(message_filename(x, "")) > 0) {
    printf("Invalid counter value: File exists.\n");
    return;
  }
  save_counter(x);
} /* set_counter() */

/** @ignore yes */
void dest_me() {
  destruct(this_object());
} /* dest_me)) */

/**
 * This method totaly removes the account for a particular player.  This
 * will be called when a player is deleted for whatever reason.
 * @param pname the player name to delete
 */
void delete_account(string pname) {
  string folder;
  string *folders;
  int message;
  object mailer;

  if(previous_object() != find_object( "/secure/related_files") &&
     previous_object() != find_object( "/secure/bulk_delete"))
    return;
  
  mailer = clone_object(MAILER);
  folders = (string *)mailer->query_folders(pname);
  destruct(mailer);
  if (!folders && file_size(folder_filename(pname+"inbox.o")) == -1)
    return;
  if (!folders)
    folders = ({"inbox"});
  foreach (folder in folders) {
    mesg_numbers = ({ });
    unguarded( (: restore_object, folder_filename(pname+folder) :) );
    if (pointerp(mesg_numbers)) {
      foreach (message in mesg_numbers) {
        reset_eval_cost();
        if (file_size(message_filename(message, "l")) > 0) {
          convert_links(message);
        }
        decrement_links(message);
      }
    }
    unguarded( (: rm, folder_filename(pname + folder + ".o") :) );
  }
  unguarded( (: rm, folder_filename(pname +".o") :) );
} /* delete_account() */
// --- END [/mnt/home2/grok/lib/obj/handlers/folder_handler.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/virtuals.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/virtuals.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628216   Available: 13575570
Inodes: Total: 5242880    Free: 4960134
3787 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/virtuals.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628216   Available: 13575570
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This handler fixes up virtual objects if their files change, so that their static variables will be adjusted.
 * @author Dragonkin

 */

#define SAVE_FILE "/save/virtuals"
#define MAX_NUMBERS 50

mapping load_data;
string *paths;
string *missing_paths;
string *forbidden_paths;

/** @ignore yes */
void create() {
   seteuid( "/secure/master"->creator_file( file_name( this_object() ) ) );
   load_data = ([ ]);
   paths = ({ });
   missing_paths = ({ });
   forbidden_paths = ({ });
   if ( file_size( SAVE_FILE +".o" ) > 0 )
      unguarded( (: restore_object, SAVE_FILE :) );
} /* create() */

/** @ignore yes */
void save_me() { unguarded( (: save_object, SAVE_FILE :) ); }

/**
 * Adds a path and its static auto load information to the mapping
 * and cleans the mapping and paths array.
 * @param path the path of the object to add
 */
void add_data( string path ) {
  object junk_item;
  string tmp_str;
  int tmp_int;

  junk_item = clone_object( path );
  load_data[ path ] = ({ stat( path )[1], junk_item->query_static_auto_load() });
  destruct( junk_item );

  paths -= ({ path });
  paths += ({ path });

  if( sizeof( paths ) > MAX_NUMBERS ) {
    tmp_int = sizeof( paths ) - (MAX_NUMBERS + 1);
    paths = paths[tmp_int+1..tmp_int+MAX_NUMBERS];
  }
  foreach( tmp_str in keys( load_data ) ) {
    if( member_array( tmp_str, paths ) == -1 ) {
      map_delete( load_data, tmp_str );
    }
  }
  save_me();
}

/**
 * Called by virtual objects as they are being cloned, if their timestamp is older than their file.
 * @param path the path of the virtual object
 * @return the object's static auto load info if any, otherwise 0
 */
mapping new_data( string path ) {
  if( ( !load_data[path] ) || ( !sizeof( stat( path ) ) ) || ( load_data[path][0] < stat( path )[1] ) ) {
    if( !sizeof( stat( path ) ) ) {
      return 0;
    }
    add_data( path );
  }
  return load_data[path][1];
} /* new_data() */

/**
 * A function to see what items have faulty paths
 * @return all faulty paths in the handler
 */
string *query_missing_paths() { return missing_paths; }

/**
 * Called by the handler to add a faulty path to the list
 * @param path the path of the virtual object
 * @return 1 if added, 0 if not (because it's already in the list or in a /w directory)
 */
int add_missing( string path ) {
  if( !missing_paths )
    missing_paths = ({ });
  if( member_array( path, missing_paths ) != -1 )
    return 0;
  if( path[0..2] == "/w/" )
    return 0;
  missing_paths += ({ path });
  save_me();
  return 1;
}

/**
 * Called to remove a faulty path from the list.
 * @param path the path of the virtual object
 */
void remove_missing( string path ) {
  missing_paths -= ({ path });
  save_me();
}

/**
 * A function to see if a path is forbidden
 * @param path the path of the virtual object to check
 * @return 1 if forbidden, 0 if not
 */
int query_forbidden( string path ) {
  return ( member_array( path, forbidden_paths ) != -1 );
}

/**
 * A function to see what paths are forbidden
 * @return all forbidden paths in the handler
 */
string *query_forbidden_paths( ) { return forbidden_paths; }

/**
 * Called to add a path to the list of forbidden paths.  A forbidden virtual object being loaded will transform into a receipt.
 * @param path the path of the virtual object to forbid
 * @return 1 if the path is added, 0 if it is already in the list
 */
int add_forbidden( string path ) {
  if( !forbidden_paths )
    forbidden_paths = ({ });
  if( member_array( path, forbidden_paths ) != -1 )
    return 0;
  forbidden_paths += ({ path });
  save_me();
  return 1;
}

/**
 * Called to remove a forbidden path from the list.
 * @param path the path of the virtual object
 */
void remove_forbidden( string path ) {
  forbidden_paths -= ({ path });
  save_me();
}

// --- END [/mnt/home2/grok/lib/obj/handlers/virtuals.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/random_names.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/random_names.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628215   Available: 13575569
Inodes: Total: 5242880    Free: 4960134
5047 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/random_names.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628215   Available: 13575569
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*   -*- LPC -*-   */
/*
 * $Locker:  $
 * $Id: random_names.c,v 1.5 2002/03/29 04:19:07 ceres Exp $
 * $Log: random_names.c,v $
 * Revision 1.5  2002/03/29 04:19:07  ceres
 * Modified to use test_valid() for name checking
 *
 * Revision 1.4  2002/03/29 04:15:03  pinkfish
 *  Forcibly unlocked by ceres
 *
 * Revision 1.3  2000/10/20 18:44:55  pinkfish
 * Fix up an error in the loading.
 *
 * Revision 1.2  2000/10/20 18:41:53  pinkfish
 * Add in a method to have test languages/rules in the system.
 *
 * Revision 1.1   1998/01/06 05:03:33   ceres
 * Initial revision
 * 
*/
/**
 * Generates random names for whatever reason.
 * <p>
 * Werd - a perl script that generates random words according to some
 *            simple rules (inspired by phrase structure trees in Syntax).
 * <p>
 * Based on a program by Mark Rosenfelder (markrose@spss.com)
 *            called psrGrammar
 * <p>
 * Rewritten in perl by Chris Pound (pound@rice.edu)
 * <p>
 * Rewritten in lpc by Pinkfish@Discworld MUD.
 *            10th of January 1996.
 */
#include <random_names.h>
#include <player_handler.h>

private mapping rules;
private string* _test_rules;

void create() {
   seteuid("Room");
   rules = ([ ]);
   _test_rules = ({ });
   unguarded((: restore_object, RANDOM_NAME_SAVE_FILE :));
   if (!_test_rules) {
      _test_rules = ({ });
   }
} /* create() */

private void save_me() {
   unguarded((: save_object, RANDOM_NAME_SAVE_FILE :));
} /* save_me() */

/**
 * Read in a random name grammer from the data dir.   Any line with
 * # at the start is considered a comment, and anything after
 * a # on a line is ignored.   Every line in the file will have
 * 3 fields seperated by a :.   The first field is the name
 * the second is a one letter expansion string, the third is a
 * a space separeted list of things to expand it to.
 * <p>
 * The word starts off as a "W", this is looked up in the expansion
 * first string list.   If it is found then that is expanded to 
 * a random selection of the space seperated data elements.   This
 * process is repeated until there are no bits in the word that can
 * be expanded.
 * @param f the name of the file to read
 */
void open_file(string f) {
   string str, *bits, *stuff, lang;
   int i;

   bits = explode(f, ".");
   if (sizeof(bits) > 1) {
      lang = implode(bits[0..sizeof(bits)-2], ".");
   } else {
      lang = f;
   }
   lang = replace(lang, "_", " ");

   str = unguarded((: read_file, RANDOM_NAME_DATA_DIR+f :));
   bits = explode(str, "\n");
   rules[lang] = ([ ]);
   for (i=0;i<sizeof(bits);i++) {
      sscanf(bits[i], "%s#%*s", bits[i]);
      if (strlen(bits[i])) {
         stuff = explode("G"+bits[i], ":");
         if (sizeof(stuff) >= 3) {
            rules[lang][stuff[1]] = stuff[2];
         } else {
            write("Incorrect file format at line "+i+", less than 3 "
                  ": seporated bits.\n");
         }
      }
   }
   save_me();
} /* open_file() */

/**
 * Generate a random name in the given language.
 * @param lang the language to generate teh name int
 * @return the random name
 */
string random_name(string lang) {
   string word = "W", *bing;
   int some_caps = 1, i;

   do {
      some_caps = 0;
      for (i = 0; i < strlen(word); i++)
         if (word[i] >= 'A' && word[i] <= 'Z') {
            bing = explode(rules[lang][word[i..i]], " ") - ({ "" });
            word = word[0..i-1] + bing[random(sizeof(bing))] + word[i+1..];
            some_caps = 1;
         }
   } while (some_caps);
   return word;
} /* random_name() */

/**
 * The list of all the current languages known.
 * @return an array of the language names.
 */
string *query_languages() { return keys(rules) - _test_rules; }

/**
 * This is the list of test rules in the handler.
 * @return the list of test rules
 */
string *query_test_languages() {
   return _test_rules;
} /* query_test_languages() */

/**
 * This method adds in a language as a test language.
 * @param lang the test language to add
 */
void add_test_language(string lang) {
   _test_rules += ({ lang });
   save_me();
} /* add_test_language() */

/**
 * This method removes a language as a test language.
 * @param lang the test language to remove
 */
void remove_test_language(string lang) {
   _test_rules -= ({ lang });
   save_me();
} /* remove_test_language() */

/**
 * Return a name that is not banished or a player name already.
 * It is > 2 and < 11 chars, it is not banished, a player or
 * in the game.
 * @param lang the language to generat ethe name in
 * @return the generated name
 */
string unique_name(string lang) {
   string str;
   int ok;

   do {
      ok = 1;
      str = random_name(lang);
      if (strlen(str) < 2 || strlen(str) > 11)
         ok = 0;
      if (ok && PLAYER_HANDLER->test_user(str))
         ok = 0;
      if (ok && !PLAYER_HANDLER->test_valid(str))
         ok = 0;
      if (ok && find_living(str))
         ok = 0;
   } while (!ok);
   return str;
} /* unique_name() */

/** @ignore yes */
void dest_me() {
   destruct(this_object());
} /* dest_me() */
// --- END [/mnt/home2/grok/lib/obj/handlers/random_names.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/club_handler.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/club_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628213   Available: 13575567
Inodes: Total: 5242880    Free: 4960134
664 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/club_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628213   Available: 13575567
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is the handler for all things clubby, a club being a group of
 * players.  Each club must have a unique name.  It also handles elections
 * for various club positions.
 * @author Pinkfish
 * @started Sun Sep 27 03:35:42 EDT 1998
 */

inherit "/obj/handlers/inherit/club_inherit";

void create() {
   ::create();

   // Check the clubs immediately.
	 // No, lets not, lets leave it for 30 minutes so things have stabilised
	 // a bit and our load is under control.
   //setup_call_check_clubs(1800, 1);
   setup_call_check_clubs(0, 1);
} /* create() */

/** @ignore yes */
void dest_me() {
   save_cache();
   destruct(this_object());
} /* dest_me() */
// --- END [/mnt/home2/grok/lib/obj/handlers/club_handler.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/potion_space.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/potion_space.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628213   Available: 13575567
Inodes: Total: 5242880    Free: 4960134
4591 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/potion_space.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628213   Available: 13575567
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: potion_space.c,v 1.1 1998/01/06 05:03:33 ceres Exp $
 * $Log: potion_space.c,v $
 * Revision 1.1  1998/01/06 05:03:33  ceres
 * Initial revision
 * 
*/
#define SAVE_FILE "/save/potion_space"

/* ok guys, gals and geeks, this is the potion space handler

   Started by Ember the Ebullient on 30-June-1992

   There is one array.  It contains an object name, and limits on the
   volume it occupies in the potion space.  The potion space will
   initially start at 3 dimensions, and we see what happens from there.

   Ok, well, here goes ...
*/

mixed *effect_vols;

void create() {
  seteuid("Room");
  unguarded((: restore_object, SAVE_FILE :));
}

int add_effect(string ob, int x1, int x2, int y1, int y2) {
   if (!stringp(ob)) {
      tell_object(this_player(), "Effect object must be a string.\n");
      return 0;
   }
   effect_vols = ({ ob, x1, x2, y1, y2 }) + effect_vols;
/* backwards so we get 'masking' */
   unguarded((: save_object, SAVE_FILE :));
   return 1;
}

int remove_effect(object ob) {
   int i;

   for (i = 0; i < sizeof(effect_vols); i+=5)
      if (effect_vols[i] == ob) {
         effect_vols = effect_vols[0..i-1] + effect_vols[i+5..sizeof(effect_vols)];
         break;
      }

   unguarded((: save_object, SAVE_FILE :));
   return 1;
}

string *query_effect_at(int *coord) {
   int i;
   string *obs;

   obs = ({ });

   for (i = 0; i < sizeof(effect_vols); i+=5) {
      if (coord[0] >= effect_vols[i+1] && coord[0] <= effect_vols[i+2] &&
          coord[1] >= effect_vols[i+3] && coord[1] <= effect_vols[i+4]) 
         obs += ({ effect_vols[i] });
   }
   return obs;
}

mixed *query_attrs_at(int *coord){
   string *effects;
   int sum, i, pass_through;
   mixed *attrs, *temp_attrs;
   
   effects = query_effect_at(coord);
   if (!sizeof(effects)) return ({ 0, 100, ({ }), ({ }), ({ }), ({ }) });
   
   attrs = effects[0]->query_attrs(coord);
   sum = 100;
   pass_through = effects[0]->query_pass_through(coord);
   i = 1;
   while (pass_through && i < sizeof(effects)) {
   /* if 'backdrop' returns true, then it should only be efficacious if there */
   /* is no masking function ... regardless of pass through */
      if (effects[i]->backdrop()) break;
      temp_attrs = effects[i]->query_attrs(coord);
      attrs = "/obj/container"->merge_potions(attrs, temp_attrs, 
                                   sum, pass_through, sum + pass_through);
      sum += pass_through;
      pass_through = effects[i]->query_pass_through(coord);
      i++;
   }
   
   return attrs;
}

void potion_drunk(mixed ob, int *coord, int quantity) {
   string *effects;
   int i, pass_through;
   
   effects = query_effect_at(coord);
   pass_through = 100;
   for (i = 0; i < sizeof(effects) && pass_through; i++) {
      if (i > 0 && effects[i]->backdrop()) break;
      effects[i]->action_drunk(ob, coord, quantity * pass_through / 100);
      pass_through = pass_through * effects[i]->query_pass_through(coord) / 100;
   }
   return;
}

void potion_touch(mixed ob, int *coord, int quantity) {
   string *effects;
   int i, pass_through;
   
   effects = query_effect_at(coord);
   pass_through = 100;
   for (i = 0; i < sizeof(effects) && pass_through; i++) {
      if (i > 0 && effects[i]->backdrop()) break;
      effects[i]->action_touch(ob, coord, quantity * pass_through / 100);
      pass_through = pass_through * effects[i]->query_pass_through(coord) / 100;
   }
   return;
}

void potion_smell(mixed ob, int *coord, int quantity) {
   string *effects;
   int i, pass_through;
   
   effects = query_effect_at(coord);
   pass_through = 100;
   for (i = 0; i < sizeof(effects) && pass_through; i++) {
      if (i > 0 && effects[i]->backdrop()) break;
      effects[i]->action_smell(ob, coord, quantity * pass_through / 100);
      pass_through = pass_through * effects[i]->query_pass_through(coord) / 100;
   }
   return;
}

void potion_create(mixed ob, int *coord, int quantity) {
   string *effects;
   int i, pass_through;
   
   effects = query_effect_at(coord);
   pass_through = 100;
   for (i = 0; i < sizeof(effects) && pass_through; i++) {
      if (i > 0 && effects[i]->backdrop()) break;
      effects[i]->action_create(ob, coord, quantity * pass_through / 100);
      pass_through = pass_through * effects[i]->query_pass_through(coord) / 100;
   }
   return;
}

mixed *query_effect_vols() {
   return effect_vols + ({ });
}

/* Dangerous fucntion....
reset_effect_vols()
{
   effect_vols = ({ });
   unguarded((: save_object, SAVE_FILE :));
}
 */

int *neutral_coordinate() {
   return ({ 0, 0 });
}
// --- END [/mnt/home2/grok/lib/obj/handlers/potion_space.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/report_handler.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/report_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628212   Available: 13575566
Inodes: Total: 5242880    Free: 4960134
8404 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/report_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628212   Available: 13575566
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This handler manages reports about alleged misdemeanors and other
 * Sherlock Holmes type stuff.  It's main uses are holding cases so
 * they are not overlooked and forgotten about, recording decisions
 * on various offences and allowing a case history of a player to
 * be retrieved.
 *
 * @author Gototh
 */
// Gototh 22/02/98

#include <report_handler.h>

inherit "/std/object";

void move_to_recent_cases(mixed *thing);

mixed *new_cases, *recent_cases;

/**
 * @ignore yes
 */
void setup() {
  set_short("report handler");
  add_property("determinate", "the ");
  set_long("This is a rather tacky statue of a woman holding "
    "a sword and some wonky scales.\n");
  if(file_size(NEWCASES) > -1) {
    new_cases = restore_variable(read_file(NEWCASES));
  }
  if(file_size(RECENT) > -1) {
    recent_cases = restore_variable(read_file(RECENT));
  }
} /* setup() */

// New cases.

/**
 * @ignore yes
 */
void save_new_cases() {
  unguarded((: rm, NEWCASES :));
  unguarded((: write_file, NEWCASES, save_variable(new_cases)+"\n" :));
} /* save_me() */

/**
 * @ignore yes
 */
mixed query_new() {
  return new_cases;
} /* query_new() */

/**
 * @ignore yes
 */
int sizeof_new_cases() {
  if(!new_cases) {
    new_cases = restore_variable(read_file(NEWCASES));
  }
  return sizeof(new_cases);
} /* sizeof_new_cases() */

/**
 * @ignore yes
 */
string query_new_cases() {
  int i, j;
  string reports = "";
  for(i = 0; i < sizeof(new_cases); i++) {
    if(i < 10) {
      reports += "   "+(i + 1)+": ";
    } else {
      reports += "  "+(i + 1)+": ";
    }
    reports += "%^CYAN%^Player%^RESET%^: "+capitalize(new_cases[i][NAME]);
    for(j = 0; j < (12 - sizeof(new_cases[i][NAME])); j++) {
      reports += " ";
    }
    reports += "%^CYAN%^Category%^RESET%^: "+new_cases[i][CATEGORY]+"\n";
  }
  return reports;
} /* query_new_cases() */

/**
 * @ignore yes
 */
string query_new_case(int i) {
  string report = "";
  mixed *stuff;
  if(!new_cases) {
    new_cases = restore_variable(read_file(NEWCASES));
  }
  if(i < 1 || i > sizeof(new_cases)) {
    return 0;
  }
  stuff = new_cases[i - 1];
  report += "  %^CYAN%^Suspect%^RESET%^: "+capitalize(stuff[NAME])+"\n";
  if(!sizeof(stuff[CHARS])) {
    report += "  %^CYAN%^Other Characters%^RESET%^: Unknown.\n";
  } else {
    report += "  %^CYAN%^Other Characters%^RESET%^: "
      "$I$5="+query_multiple_short(stuff[CHARS])+"$I$0=\n";
  }
  report += "  %^CYAN%^Creator%^RESET%^: "+stuff[CREATOR]+"\n"
    "  %^CYAN%^Time%^RESET%^: "+stuff[TIME]+"\n"
    "  %^CYAN%^Category%^RESET%^: "+stuff[CATEGORY]+"\n"
    "  %^CYAN%^Report%^RESET%^: $I$5="+stuff[REPORT]+"$I$0=";
  return report;
} /* query_new_case() */

/**
 * @ignore yes
 */
void add_report(string *stuff) {
  if(!new_cases) {
    new_cases = restore_variable(read_file(NEWCASES));
  }
  new_cases += ({ stuff });
  save_new_cases();
} /* add_report() */

/**
 * @ignore yes
 */
void deal_with_it(int num, string name, string decision) {
  mixed *thing;
  num--;
  thing = new_cases[num];
  thing += ({ name });
  thing += ({ decision });
  new_cases -= ({new_cases[num]});
  move_to_recent_cases(thing);
} /* deal_with_it() */

/**
 * @ignore yes
 */
void save_recent_cases() {
  unguarded((: rm, RECENT :));
  unguarded((: write_file, RECENT, save_variable(recent_cases)+"\n" :));
} /* save_me() */

/**
 * @ignore yes
 */
void move_to_recent_cases(mixed *thing) {
  int i, j;
  mixed *c_record, *chars;
  for(i = sizeof(recent_cases) - NO_RECENT; i > -1; i--) {
    chars = ({recent_cases[i][NAME]});
    if(arrayp(recent_cases[i][CHARS])) {
      chars += recent_cases[i][CHARS];
    }
    uniq_array(chars);
    for(j = 0; j < sizeof(chars); j++) {
      if(file_size((SAVEPATH+chars[j]+".o")) > -1) {
        c_record = restore_variable(read_file((SAVEPATH+chars[j]+".o")));
        c_record += ({recent_cases[j]});
      } else {
        c_record = ({recent_cases[j]});
      }
      unguarded((: rm, (SAVEPATH+chars[j]+".o") :));
      unguarded((: write_file, (SAVEPATH+chars[j]+".o"),
        save_variable(c_record)+"\n" :));
    }
    recent_cases -= ({recent_cases[i]});
  }
  recent_cases += ({ thing });
  save_new_cases();
  save_recent_cases();
} /* move_to_recent_cases() */

/**
 * @ignore yes
 */
mixed query_recent() {
  if(!recent_cases) {
    recent_cases = restore_variable(read_file(RECENT));
  }
  return recent_cases;
} /* query_recent() */

/**
 * @ignore yes
 */
string query_recent_cases() {
  int i, j;
  string reports = "";
  for(i = 0; i < sizeof(recent_cases); i++) {
    if(i < 10) {
      reports += "   "+(i + 1)+": ";
    } else {
      reports += "  "+(i + 1)+": ";
    }
    reports += "%^CYAN%^Suspect%^RESET%^: "+capitalize(recent_cases[i][NAME]);
    for(j = 0; j < (12 - sizeof(recent_cases[i][NAME])); j++) {
      reports += " ";
    }
    reports += "%^CYAN%^Category%^RESET%^: "+recent_cases[i][CATEGORY]+"\n";
  }
  return reports;
} /* query_recent_cases() */

/**
 * @ignore yes
 */
string query_recent_case(int i) {
  string report = "";
  mixed *stuff;
  if(!recent_cases) {
    recent_cases = restore_variable(read_file(RECENT));
  }
  if(i < 1 || i > sizeof(recent_cases)) {
    return 0;
  }
  stuff = recent_cases[i - 1];
  report += "  %^CYAN%^Suspect%^RESET%^: "+capitalize(stuff[NAME])+"\n";
  if(!sizeof(stuff[CHARS])) {
    report += "  %^CYAN%^Other Characters%^RESET%^: Unknown.\n";
  } else {
    report += "  %^CYAN%^Other Characters%^RESET%^: "
      "$I$5="+query_multiple_short(stuff[CHARS])+"$I$0=\n";
  }
  report += "  %^CYAN%^Creator%^RESET%^: "+capitalize(stuff[CREATOR])+"\n"
    "  %^CYAN%^Time%^RESET%^: "+stuff[TIME]+"\n"
    "  %^CYAN%^Offence%^RESET%^: "+stuff[CATEGORY]+"\n"
    "  %^CYAN%^Report%^RESET%^: $I$5="+stuff[REPORT]+"$I$0="
    "  %^YELLOW%^High Lord%^RESET%^: "+stuff[HIGHLORD]+"\n"
    "  %^YELLOW%^High Lord Decision%^RESET%^: "+stuff[DECISION];
  for(i = 8; i < sizeof(stuff); i += 2) {
    report += "  %^YELLOW%^Comment from "+stuff[i]+"%^RESET%^: "
      +stuff[i + 1];
  }
  return report;
} /* query_recent_cases() */

/**
 * @ignore yes
 */
string case_history(string name) {
  int i, j;
  mixed *history, *cases, *stuff, *all_cases, *check_case;
  string report, *other_chars = ({ });
  history = get_dir(SAVEPATH+lower_case(name)+".o");
  all_cases = get_dir(SAVEPATH);
  all_cases -= ({"recent.o", "new.o"});
  for(i = 0; i < sizeof(all_cases); i++) {
    check_case = restore_variable(read_file((SAVEPATH+all_cases[i])));
    for(j = 0; j < sizeof(check_case); j++) {
      if(arrayp(check_case[j][CHARS])) {
        if(member_array(capitalize(name), check_case[j][CHARS]) != -1) {
          other_chars += check_case[j][CHARS];
          other_chars += ({check_case[j][NAME]});
        }
      }
    }
  }
  if(sizeof(other_chars)) {
    uniq_array(other_chars);
    for(i = 0; i < sizeof(other_chars); i++) {
      other_chars[i] = capitalize(other_chars[i]);
    }
    other_chars -= ({capitalize(name)});
    other_chars = uniq_array(other_chars);
    write(capitalize(name)+" is also "
      +query_multiple_short(other_chars)+".\n");    
  }
  if(!sizeof(history)) {
    return 0;
  }
  write("%^CYAN%^Case History for "+capitalize(name)+"%^RESET%^:\n");
  report = "";
  cases = restore_variable(read_file(SAVEPATH+lower_case(name)+".o"));
  for(i = 0; i < sizeof(cases); i++) {
    stuff = cases[i];
    report += "  %^CYAN%^Suspect%^RESET%^: "+capitalize(stuff[NAME])+"\n";
    if(!sizeof(stuff[CHARS])) {
      report += "  %^CYAN%^Other Characters%^RESET%^: Unknown.\n";
    } else {
      report += "  %^CYAN%^Other Characters%^RESET%^: "
        "$I$5="+query_multiple_short(stuff[CHARS])+"$I$0=\n";
    }
    report +=  "  %^CYAN%^Creator%^RESET%^: "+capitalize(stuff[CREATOR])+"\n"
      "  %^CYAN%^Time%^RESET%^: "+stuff[TIME]+"\n"
      "  %^CYAN%^Offence%^RESET%^: "+stuff[CATEGORY]+"\n"
      "  %^CYAN%^Report%^RESET%^: $I$5="+stuff[REPORT]+"$I$0="
      "  %^YELLOW%^High Lord%^RESET%^: "+stuff[HIGHLORD]+"\n"
      "  %^YELLOW%^High Lord Decision%^RESET%^: "+stuff[DECISION];
    for(j = 8; j < sizeof(stuff); j += 2) {
      report += "  %^YELLOW%^Comment from "+stuff[j]+"%^RESET%^: "
        +stuff[j + 1];
    }
  }
  return report;
} /* case_history() */

/**
 * @ignore yes
 */
void add_comment(int i, string name, string comment) {
  i--;
  recent_cases[i] += ({ capitalize(name), comment });
  save_recent_cases();
} /* add_comment() */

// --- END [/mnt/home2/grok/lib/obj/handlers/report_handler.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/chime_handler.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/chime_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628209   Available: 13575563
Inodes: Total: 5242880    Free: 4960134
4034 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/chime_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628209   Available: 13575563
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: chime_handler.c,v 1.6 2002/03/16 14:56:23 wodan Exp $
 * 
 */
#define CREATOR "Ceres"

/**
 * This handler deals with clocks which chime. It uses a single 15 minute
 * callout to make all clocks on Discworld which choose to chime chime the
 * quarter, half or hours.
 *
 * @author Ceres
 */
#include <am_time.h>
#include <chime.h>

#define FIFTEEN_MINS (AM_SECONDS_PER_MINUTE * 15)

class chime {
  object ob;
  int type;
  string mess;
}

void do_chime(class chime record, int type);

class chime *chime_list;
int last_strike;

/** @ignore yes */
void create() {
  int next_chime;

  chime_list = ({ });

  // time to the next quarter
  next_chime = 301 - (time() % 300);
  remove_call_out("check_time");
  call_out("check_time", next_chime);
}

/**
 * Register a clock to do chimes. The num parameter specifes when to
 * chime.  If it is 1 then the clock chimes every hour, if it is
 * 2 the clock chimes ever half hour, if it is 4 the
 * clock chimes every quarter hour.  Anything else and
 * the clock never chimes.  NB: if you set it to chime the quarter hours
 * it will only chime the quarter hours, it will not chime the hours
 * or the half hours.  You need to call this function three times to
 * get your clock to chime the hour, half and quarter hours.
 * <p>
 * The function "chime" will be called on the clock
 * when the chime occurs.  The message will be passed in as the first
 * argument, the second will be the type of chime (CHIME_HOUR, CHIME_HALF_HOUR,
 * CHIME_QUARTER_HOUR).
 *
 * @param ob the object being registered
 * @param num when to chime
 * @param mess the message to chime with
 *
 * @return 1 for success, 0 for failure.
 */
int register_for_chimes(object ob, int num, string mess) {
  class chime record;

  // check if this object is already registered. If they use a new
  // message it's considered a new chime.
  foreach(record in chime_list) {
    if(record->ob == ob && record->type == num && record->mess == mess) {
      record->type = num;
      record->mess = mess;
      return 1;
    }
  }
  
  record = new(class chime);
  record->ob = ob;
  record->type = num;
  record->mess = mess;
  chime_list += ({ record });
  
  return 1;
}

/** @ignore yes
 *
 * This function checks the registered objects and sets up a call to
 * do_chime() for each one that needs a call.
 */
void check_time() {
  int next_chime, minute;
  class chime record;

  minute = AM_TIME_HANDLER->query_am_minute(time());
  
  foreach(record in chime_list) {
    catch{
      if(minute % 60 < 5)
        do_chime(record, CHIME_HOUR);
      else if(minute % 30 < 5 && record->type > CHIME_HOUR)
        do_chime(record, CHIME_HALF_HOUR);
      else if(minute % 15 < 5 && record->type == CHIME_QUARTER_HOUR)
        do_chime(record, CHIME_QUARTER_HOUR);
    };
  }

  next_chime = (FIFTEEN_MINS + 1) - (time() % FIFTEEN_MINS);
  remove_call_out("check_time");
  call_out("check_time", next_chime);
}

/** @ignore yes
 *
 * This actually calls the chime function in an object.
 */
void do_chime(class chime record, int type) {
  if(!record || !record->ob)
    return;
  (record->ob)->chime(record->mess, type);
}

/** @ignore yes
 * Restart the chime callout, just in case it got dropped on the floor.
 */
void reset() {
  int next_chime;
  class chime record;

  next_chime = (FIFTEEN_MINS + 1) - (time() % FIFTEEN_MINS);
  remove_call_out("check_time");
  call_out("check_time", next_chime);

  // Clean up the chime_list.
  foreach(record in chime_list) {
    if(!record->ob)
      chime_list -= ({ record });
  }
  
}

/** @ignore yes
 * these two are not here because the handler can be saved, but to keep
 * the info over updates.
 */
mapping query_dynamic_auto_load() {
   mapping tmp;
   tmp = ([ "chime_list" : chime_list ]);
   return tmp;
}

/** @ignore yes */
void init_dynamic_arg(mapping maps) {
   if (maps["chime_list"])
      chime_list = maps["chime_list"];
}

/** @ignore yes */
mixed stats() {
  return ({ ({ "chime count", sizeof(chime_list) }) });
}
// --- END [/mnt/home2/grok/lib/obj/handlers/chime_handler.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/player_council.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/player_council.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628208   Available: 13575562
Inodes: Total: 5242880    Free: 4960134
519 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/player_council.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628208   Available: 13575562
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/obj/handlers/inherit/player_council";
#define NOMIC_SYSTEM_NO_CLASSES
#include <nomic_system.h>

//#define SAVE_FILE "/save/nomic/main.o"

void load_me();
void save_me();

void create() {
   player_council::create();

   load_me();
} /* create() */

void save_me() {
   unguarded( (: save_object(NOMIC_SYSTEM_SAVE_FILE) :) );
} /* save_me() */

void load_me() {
   unguarded( (: restore_object(NOMIC_SYSTEM_SAVE_FILE, 1) :) );
} /* load_me() */

void dest_me() {
   destruct(this_object());
} /* dest_me() */
// --- END [/mnt/home2/grok/lib/obj/handlers/player_council.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/multiplayer.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/multiplayer.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628208   Available: 13575562
Inodes: Total: 5242880    Free: 4960134
12184 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/multiplayer.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628208   Available: 13575562
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* $Id: multiplayer.c,v 1.17 2003/05/30 06:23:05 ceres Exp $ */
/**
 * Keeps track of the marked multi players.
 * Called by the login handler, checking people against a list of
 * previous multiplayers, and if they are on the list, check if
 * they are already on.
 * <pre><code>
 * vars are:
 *  string *gits: an array of names of suspected multiplayers
 *  string *denied_parcels: an array of names of multiplayers prevented from
 *                          using the parcel system for sending parcels
 *  mapping allowed: the keys are the names of verified non-multiplayers,
 *                   the values are the names of people they are allowed to
 *                   play with.
 * </pre></code>
 */

#include <login_handler.h>
#include <playerinfo.h>

#define SAVE_FILE   "/save/multiplayer"
#define ALIST "/secure/alist"
#define ALLOWED_ITEMS ({ "/obj/misc/club_badge", "/obj/misc/al_receipt" })
string *denied_parcels;
mapping allowed;

protected void create() {
  string denied_parcel;
  int changed = 0;

  denied_parcels = ({ });
  allowed = ([ ]);
  seteuid(master()->creator_file(file_name()));
  if (file_size(SAVE_FILE + ".o") > 0) {
    unguarded((: restore_object, SAVE_FILE, 1 :));
  }

  foreach (denied_parcel in denied_parcels) {
    if (!PLAYER_HANDLER->test_user(denied_parcel)) {
      denied_parcels -= ({ denied_parcel });
      changed = 1;
    }
  }
  if (changed) {
    unguarded((: save_object, SAVE_FILE :));
  }
}

private void save_me() {
  unguarded((: save_object, SAVE_FILE :));
}

/**
 * Called by the player object to see if a logon inform should be given
 * about duplicate players from the same IP address.
 * @param user the player being checked
 * @param others the others logged on from the same IP
 * @return array of not allowed dups
 */
string *check_allowed(mixed user, mixed *others) {
  string *not_allowed;
  mixed tmp, alt;

  if(objectp(user))
    user = user->query_name();

  // See if they're an alt of someone. If so check if their alt
  // has an allowed list.
  if(!allowed[user] && PLAYERINFO_HANDLER->query_alt_of(user) != "")
    user = PLAYERINFO_HANDLER->query_alt_of(user);

  not_allowed = ({ });
  foreach(tmp in others) {
    if(objectp(tmp))
      tmp = tmp->query_name();
    alt = PLAYERINFO_HANDLER->query_alt_of(tmp);
    if(!alt)
      alt = tmp;
    if(!allowed[user] || member_array(alt, allowed[user]) == -1)
      not_allowed += ({ tmp }); 
  }

  return not_allowed;
}

/**
 * Adds a player to the multiplayer list.
 * @param git the name of the suspected multiplayer
 * @return 0 if they are not a user, 1 if they are
 */
int add_git(string git) {
  PLAYERINFO_HANDLER->add_entry(this_player(), git, "multiplay",
                                "Caught multiplaying.\n");
  return 1;
}

/**
 * Adds a player to the allowed multi IP list.
 * @param user the name of the player
 * @param other the name of another user which is not an alt
 * @return 0 if they are not a user, 1 if they are
 */
int add_allowed(string user, string other) {
  int oldsize, changed;

  if (!(PLAYER_HANDLER->test_user(user) && PLAYER_HANDLER->test_user(other))) {
    return 0;
  }
  if(PLAYERINFO_HANDLER->query_alt_of(user))
    user = PLAYERINFO_HANDLER->query_alt_of(user);
  if(PLAYERINFO_HANDLER->query_alt_of(other))
    other = PLAYERINFO_HANDLER->query_alt_of(other);

  if (undefinedp(allowed[user])) {
    allowed[user] = ({ other });
  } else {
    oldsize = sizeof(allowed[user]);
    allowed[user] |= ({ other });
  }
  if (!oldsize || (oldsize != sizeof(allowed[user]))) {
    changed = 1;
    PLAYERINFO_HANDLER->add_entry(this_player(), user, "multiplay",
                                  "Added to multiplayer handler as allowed "
                                  "together with " + other + ".\n");
  }

  if (undefinedp(allowed[other])) {
    allowed[other] = ({ user });
  } else {
    oldsize = sizeof(allowed[other]);
    allowed[other] |= ({ user });
  }
  if (!oldsize || (oldsize != sizeof(allowed[other]))) {
    changed = 1;
    PLAYERINFO_HANDLER->add_entry(this_player(), other, "multiplay",
                                  "Added to multiplayer handler as allowed "
                                  "together with " + user + ".\n");
  }
  if (changed) {
    call_out((: save_me :), 1);
  }
  return 1;
} /* add_allowed() */

/**
 * Remove a person from allowed multi IP list.
 * @param user the name of the player to remove
 * @return 0 if they are not in the list, 1 if they are
 */
int delete_allowed(string user) {
  if(PLAYERINFO_HANDLER->query_alt_of(user))
    user = PLAYERINFO_HANDLER->query_alt_of(user);
  if (undefinedp(allowed[user]))
    return 0;
  map_delete(allowed, user);
  call_out((: save_me :), 1);
  PLAYERINFO_HANDLER->add_entry(this_player(), user, "multiplay",
                                "Deleted from multiplayer handler "
                                "(allowed).\n");
  return 1;
} /* delete_allowed() */

/**
 * Returns the current allowed multi player IP list
 * @return the list of allowed multi players
 */
mapping query_allowed() {
  return copy(keys(allowed));
} /* query_allowed() */

/**
 * Adds a user to the list of users not allowed to use the parcel system
 * Only Lords and Liaison deputies are allowed to add a user to this array
 * @param user the name of the player
 */
int add_denied_parcel(string user) {
  if (!"/secure/master"->query_lord(geteuid(previous_object())) &&
      !"/d/liaison/master"->query_deputy(geteuid(previous_object()))) {
    write("You do not have permission to add a user to this list.\n");
    return 0;
  }
  if (member_array( user, denied_parcels) != -1) {
    denied_parcels -= ({ user });
  }
  if (!PLAYER_HANDLER->test_user(user)) {
    return 0;
  }
  denied_parcels += ({ lower_case(user) });
  call_out((: save_me :), 1);
  PLAYERINFO_HANDLER->add_entry(this_player(), user, "multiplay",
                            "Denied the use of the parcel system.\n");
  return 1;
} /* add_denied_parcel() */

/**
 * Removes a user from the list of users not allowed to use the parcel system
 * Only Lords and Liaison deputies are allowed to remove a user from this array
 * @param user the name of the player
 * @return 0 if they are not in the list, 1 if they are
 */
int remove_denied_parcel(string user) {
  if (!"/secure/master"->query_lord(geteuid(previous_object())) &&
      !"/d/liaison/master"->query_deputy(geteuid(previous_object()))) {
    write("You do not have permission to remove a user to this list.\n");
    return 0;
  }
  if (member_array(user, denied_parcels) == -1)
    return 0;
  denied_parcels -= ({ user });
  call_out((: save_me :), 1);
  PLAYERINFO_HANDLER->add_entry(this_player(), user, "multiplay",
                           "Allowed the use of the parcel system.\n");
  return 1;
} /* remove_denied_parcel() */

/**
 * Checks user against the parcels array
 * @param user the name of the player
 * @returns 0 if they are not in the list, 1 if they are
 */
int member_denied_parcel( string user ) {
  if (member_array(user, denied_parcels) == -1)
    return 0;
  return 1;
} /* member_denied_parcel() */

/**
 * Returns the current list of players denied use of the parcel system.
 * @return the list of denied parcel users
 */
string *query_denied_parcels() {
  return copy(denied_parcels);
} /* query_denied_parcels() */

/** @ignore yes */
varargs void mark_log(string user, string comment) {
  if (!comment) {
    log_file("MULTIPLAYERS", ctime(time())
             + " " + user
             + " Previous log entries handled.\n");
    PLAYERINFO_HANDLER->add_entry(this_player(), user, "multiplay",
                                  "Previous log entries handled.\n");
  } else {
    log_file("MULTIPLAYERS", ctime(time())
             + " " + user
             + ": " + comment + "\n" );
    PLAYERINFO_HANDLER->add_entry(this_player(), user, "multiplay", 
                                  comment + "\n");
  }
} /* mark_log() */

/** @ignore yes */
string query_name() {
  return "Multiplayer handler";
}

void record_object(string action, object player, object item) {
  mixed stuff;

  stuff = item->query_property("dropped");
  if(sizeof(stuff) && player->query_name() != stuff[0])
    stuff = ({ player->query_name(), query_ip_number(player), time(),
                 stuff[0] });
  else
    stuff = ({ player->query_name(), query_ip_number(player), time() });
  item->add_property("dropped", stuff, 1800);
}

int check_multiplayers(string action, object player, object item) {
  mixed stuff;
  string direction, verb, res, is;
  
  if(objectp(player) && !interactive(player))
    return 0;
  
  stuff = item->query_property("dropped");
  if(!stuff)
    return 0;

  is = "";
  switch(action) {
  case "get":
    verb = " got ";
    direction = " from ";
    break;
  case "give":
    verb = " was given ";
    direction = " by ";
    is = "is ";
    break;
  case "slip":
    verb = " was slipped ";
    direction = " by ";
    is = "is ";
    break;
  case "palm":
    verb = " palmed ";
    direction = " from ";
    break;
  case "plant":
    verb = " planted "; 
    direction = " on ";
    is = "is ";
    break;
  case "recover":
    verb = " recovered ";
    direction = " from ";
    break;
  }
    
  if(stuff[0] != player->query_name() &&
     query_ip_number(player) == stuff[1] &&
     sizeof(check_allowed(player, ({ stuff[0]}) ))) {
    // Simple IP check.
    res = capitalize(player->query_name()) + verb + item->a_short() +
      direction + stuff[0] + " who " + is +"logged in from the same "
      "address.";
  } else if(direction != " by " &&
            player->query_name() == stuff[0] &&
            player->query_refresh_time() > stuff[2]) {
    // Refresh check.
    res = capitalize(player->query_name()) + verb + item->a_short() +
      " after a refresh.";
  } else if(ALIST->query_alt(player->query_name(), stuff[0]) == 100) {
    // Registered alt check.
    res = capitalize(player->query_name()) + verb + item->a_short() +
      direction + stuff[0] + " who is " + player->query_possessive() +
      " alt.";
  } else if(ALIST->query_alt(player->query_name(), stuff[0]) >= 60) {
    // Possible alt check.
    res = capitalize(player->query_name()) + verb +  item->a_short() +
      direction + stuff[0] + " who is POSSIBLY " +
      player->query_possessive() + " alt.";
  } else if(sizeof(stuff) == 4) {
    // Do third party checks.

    if(player->query_name() == stuff[3]) {
      if(player->query_refresh_time() > stuff[2]) {
        // Indirect refresh check.
        res = capitalize(player->query_name()) + verb + item->a_short() +
          " after a refresh" + direction + stuff[0] + ".";
      }
    } else if(ALIST->query_alt(player->query_name(), stuff[3]) == 100) {
      // Indirect registered alt check.
      res = capitalize(player->query_name()) + verb + item->a_short();
      if(stuff[0] != player->query_name())
        res += " via " + stuff[0];
      res += direction + stuff[3] + " who is " + player->query_possessive() +
        " alt.";
    } else if(ALIST->query_alt(player->query_name(), stuff[3]) >= 60) {
      // Indirect possible alt check.
      res = capitalize(player->query_name()) + verb + item->a_short();
      if(stuff[0] != player->query_name())
        res += " via " + stuff[0];
      res += direction + stuff[3] + " who is _POSSIBLY_ " +
        player->query_possessive() + " alt.";
    }
  } else if((PLAYER_HANDLER->test_creator(stuff[0]) ||
             PLAYER_HANDLER->test_property(stuff[0], "test character")) &&
            !player->query_creator() &&
            !player->query_property("test character") &&
            member_array(base_name(item), ALLOWED_ITEMS) == -1 &&
            base_name(item)[0..14] != "/d/liaison/TOYS") {

    res = capitalize(player->query_name()) + verb + item->a_short() +
      direction + stuff[0];
    user_event("inform", res, "cheat");
    log_file("/d/admin/log/CHEAT", ctime(time()) + ": " +
             player->convert_message(res) + "\n");
    return 0;
  }
  if(res) {
    user_event("inform", res, "multiplayer");
    log_file("MULTIPLAYERS", ctime(time()) + ": " +
             player->convert_message(res) + "\n");
  }

  return 0;
}
// --- END [/mnt/home2/grok/lib/obj/handlers/multiplayer.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/random_num.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/random_num.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628205   Available: 13575559
Inodes: Total: 5242880    Free: 4960134
2297 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/random_num.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628205   Available: 13575559
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: random_num.c,v 1.2 1999/02/20 05:47:17 jeremy Exp $
 * $Log: random_num.c,v $
 * Revision 1.2  1999/02/20 05:47:17  jeremy
 * Added an 'lseed' parameter to random() to allow passing in
 * a seed.
 *
 * Revision 1.1  1998/01/06 05:03:33  ceres
 * Initial revision
 * 
*/
/**
 * Generate reproducible sequences of random numbers.
 * This is designed to produce a random number from the same
 * seed.  This will make sequences of reproduceable random
 * numbers.
 *
 * Useful for things like garbling of text and stuff so the garble
 * always looks the same...
 */

int seed = 100;

varargs int random(int max, mixed lseed);

#define Q           51924
#define R           10855
#define MULT        41358
#define MOD   21474836647

#define MAX_VALUE (MOD-1)

/* Throw away this many random numbers on startup */
#define STARTUP_RANDS  16

/**
 * Set the seed for the generator.
 * @param new_seed the seed to use.
 */
void set_seed(int new_seed) {
  int i;

  if (seed <= 0)
    seed = efun::random(200);
  else
    seed = new_seed;

/* Throw away some initial values */
  for (i=0;i<STARTUP_RANDS;i++)
    random(200);
} /* set_seed() */

/**
 * Generate a random number.  If lseed is an int, it is used as the seed.
 * If lseed is a one-element array of ints, lseed[0] is used as the seed
 * and the new seed is passed back.  Otherwise, the previously set seed
 * is used.
 * @param max the maximum value for the number.
 * @param lseed the seed to use, either an int or a one-element array
 * of int.
 * @return a number from 0..max-1 (inclusive)
 */
varargs int random(int max, mixed lseed) {
  int k, residue, curseed, mode;

  if (undefinedp(lseed)) {
    curseed = seed;
  } else if (intp(lseed)) {
    curseed = lseed;
    mode = 1;
  } else if (arrayp(lseed) && (sizeof(lseed) == 1) && (intp(lseed[0]))) {
    curseed = lseed[0];
    mode = 2;
  } else {
    curseed = seed;
  }
  k = curseed / Q;
  residue = MULT * (curseed - Q*R) - R*k;
  if (residue < 0)
    residue += MOD;
  if (mode == 0) {
    seed = residue;
  } else if (mode == 2) {
    lseed[0] = residue;
  }
  return residue % max;
} /* random() */

/**
 * Returns the currently specified seed.
 * @return the current seed
 */
int query_seed() {
  return seed;
} /* query_seed() */
// --- END [/mnt/home2/grok/lib/obj/handlers/random_num.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/error_handler.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/error_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628204   Available: 13575558
Inodes: Total: 5242880    Free: 4960134
464 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/error_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628204   Available: 13575558
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * The main error database handler.  This should be used for all calls
 * into the error system, setting up queries and for making changes to
 * the bugs.
 * @author Pinkfish
 * @started Thu Feb  6 17:28:47 PST 2003
 */
inherit "/obj/handlers/inherit/error_handler";

void create() {
  //seteuid(getuid());
  seteuid("Root");
   ::create();
}

void setup_error_handler(string user, string db, string password) {
   ::setup_error_handler(user, db, password);
}
// --- END [/mnt/home2/grok/lib/obj/handlers/error_handler.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/philosophies.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/philosophies.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628204   Available: 13575558
Inodes: Total: 5242880    Free: 4960134
14106 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/philosophies.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628204   Available: 13575558
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: philosophies.c,v 1.6 2000/03/21 02:43:56 ceres Exp $
 * $Log: philosophies.c,v $
 * Revision 1.6  2000/03/21 02:43:56  ceres
 * Fixed bug that meant you could only learn one argument!
 *
 * Revision 1.5  1999/09/18 14:56:31  ringo
 * Think I've fixed the duplication problem now.
 * Will not display dupes from query_all_known and will remove any dupes when add_known or remove_known are called.
 * remove_known() and reset_known() added for Lords
 *
 * Revision 1.4  1999/09/12 19:30:45  ringo
 * Added overwrite flag to write_file in add_known()
 * Also added basic dupe checking in query_all_known
 * Still needs major re-work to fix dupes
 *
 * Revision 1.3  1998/09/05 19:30:39  ceres
 * Moved the files into subdirectories.
 *
 * Revision 1.2  1998/05/11 08:04:46  pinkfish
 * Add in documentation.
 *
 * Revision 1.1  1998/01/06 05:03:33  ceres
 * Initial revision
 * 
 */
/**
 * This handler contains all the information on the philosophies used
 * in philosphical debates.
 * @author Deutha
 */

#define SAVE_FILE "/save/philosophies"
#define SAVE_DIR "/save/philosophies/"

#define PHILOSOPHY_TYPE 0
#define PHILOSOPHY_BONUS 1
#define PHILOSOPHY_NEEDED 2
#define PHILOSOPHY_EFFECT 3
#define PHILOSOPHY_ARGUMENTS 4

nosave string current_person, current_philosophies;
mapping philosophies;

/*
 * Philosophies mapping has elements of the form:
 *    name : ({
 *       [string] type (i.e. type.points is used),
 *       [int] bonus (i.e. bonus in type.points that is needed),
 *       [string] what is needed/increased to start,
 *       [string] debate effect file name,
 *        [mapping] arguments
 *     })
 *
 *  All of these except for the arguments are set when the
 *  philosophy is added; the arguments are added once the
 *  philosophy exists.
 */
void create() {
  seteuid( (string)"/secure/master"->
           creator_file( file_name( this_object() ) ) );
   philosophies = ([ ]);
   if ( file_size( SAVE_FILE +".o" ) > 0 )
      unguarded( (: restore_object, SAVE_FILE :) );
} /* create() */

/**
 * This method saves the current state of the object.
 */
void save_me() { unguarded( (: save_object, SAVE_FILE :) ); }

/**
 * This method returns the current set of philosphies available.
 * The mapping consists of the value being the name of the philosphy
 * and the value being an array consisting of 5 elements.  You should
 * be using this call for anything except debugging purposes.  It
 * would create a bad dependancy otherwise.
 * <pre>
 * name : ({
 *       [string]  type (i.e. type.points is used),
 *       [int]     bonus (i.e. bonus in type.points that is needed),
 *       [string]  what is needed/increased to start,
 *       [string]  debate effect file name,
 *       [mapping] arguments
 *     })
 * </pre>
 * @return a mapping of values
 * @see query_philosophy_names()
 */
mapping query_philosophies() { return philosophies; }

/**
 * This method returns the names of all the current philosophies.
 * @return an array of strings of the names of philosophies
 * @see query_philosophy()
 * @see add_philosophy()
 * @see remove_philosophy()
 */
string *query_philosophy_names() { return keys( philosophies ); }

/**
 * This method determines if the named philosphy exists.
 * @return 1 if it exists, 0 if it does not
 * @param name the name of the philosphy to test
 * @see query_philosophy_names()
 * @see add_philosophy()
 * @see remove_philosophy()
 */
int query_philosophy( string name ) {
   if ( !philosophies[ name ] ) {
      return 0;
   }
   return 1;
} /* query_philosophy() */

/**
 * This method adds a philosphy into the current list of philosphies.
 * @param name the name of the philosophy
 * @param type the type of the philosophy
 * @param bonus the bonus of the philosophy
 * @param needed the string describing what you need
 * @param effect the effect of the philosphy
 * @example
 * add_philosophy("theology", "faith", 50, "the power of your faith",
 *                "/std/effects/religious/theological_debate");
 * @see query_philosophy()
 * @see query_philosophy_names()
 * @see remove_philosophy()
 */
void add_philosophy( string name, string type, int bonus, string needed,
      string effect ) {
   philosophies[ name ] = ({ type, bonus, needed, effect, ([ ]) });
   save_me();
} /* add_philosophy() */

/**
 * This method removes the specified philosophy from the current list.
 * @param name the name of the philosphy to remove
 * @see query_philosophy()
 * @see query_philosophy_names()
 * @see add_philosophy() 
 */
void remove_philosophy( string name ) {
   if ( !philosophies[ name ] ) {
      return;
   }
   map_delete( philosophies, name );
   save_me();
} /* remove_philosophy() */

/**
 * This method returns the type of the philosophy.  An example of the
 * return value from this is "faith".
 * @param name the name of the philosophy to get the type of
 * @return the type of the philosophy
 * @see query_philosphy_bonus()
 * @see query_philosphy_effect()
 * @see query_philosphy_needed()
 * @see query_philosphy_argument()
 */
string query_philosophy_type( string name ) {
   if ( !philosophies[ name ] ) {
      return 0;
   }
   return philosophies[ name ][ PHILOSOPHY_TYPE ];
} /* query_philosophy_type() */

/**
 * This method returns the bonus of the philosophy.  An example of the
 * return value from this is 50.
 * @param name the name of the philosophy to get the bonus of
 * @return the bonus of the philosophy
 * @see query_philosphy_type()
 * @see query_philosphy_effect()
 * @see query_philosphy_needed()
 * @see query_philosphy_argument()
 */
int query_philosophy_bonus( string name ) {
   if ( !philosophies[ name ] ) {
      return 0;
   }
   return philosophies[ name ][ PHILOSOPHY_BONUS ];
} /* query_philosophy_bonus() */

/**
 * This method returns the needed string of the philosophy.  An example of the
 * return value from this is "the power of your faith".
 * @param name the name of the philosophy to get the needes string for
 * @return the needed string for the philosophy
 * @see query_philosphy_bonus()
 * @see query_philosphy_effect()
 * @see query_philosphy_type()
 * @see query_philosphy_argument()
 */
string query_philosophy_needed( string name ) {
   if ( !philosophies[ name ] ) {
      return 0;
   }
   return philosophies[ name ][ PHILOSOPHY_NEEDED ];
} /* query_philosophy_needed() */

/**
 * This method returns the effect of the philosophy.  An example of the
 * return value from this is "/std/effects/religious/theological_debate".
 * @param name the name of the philosophy to get the effect of
 * @return the effect of the philosophy
 * @see query_philosphy_bonus()
 * @see query_philosphy_type()
 * @see query_philosphy_needed()
 * @see query_philosphy_argument()
 */
string query_philosophy_effect( string name ) {
   if ( !philosophies[ name ] ) {
      return 0;
   }
   return philosophies[ name ][ PHILOSOPHY_EFFECT ];
} /* query_philosophy_effect() */

/**
 * This method returns the arguments of the philosophy.  This returns
 * a mapping containing the argument values.  This should not be
 * used except for debuggin purposes.
 * @param name the name of the philosophy to get the arguments for
 * @return the arguments for the philosophy
 * @see query_philosphy_bonus()
 * @see query_philosphy_type()
 * @see query_philosphy_needed()
 * @see query_philosphy_effect()
 * @see query_philosphy_argument()
 */
mapping query_philosophy_all_arguments( string name ) {
   if ( !philosophies[ name ] ) {
      return 0;
   }
   return copy( philosophies[ name ][ PHILOSOPHY_ARGUMENTS ] );
} /* query_philosophy_arguments() */

/**
 * This method returns the values for the specific argument in
 * philosophy.   The returned array consists of three values, they
 * are ({ skill, something, something }).
 * @param name the name of the philosphy to get the arguments for
 * @param argument the name of the argument to return
 * @return an array of the arguments values
 * @see query_philosphy_bonus()
 * @see query_philosphy_type()
 * @see query_philosphy_needed()
 * @see query_philosphy_effect()
 * @see add_philosphy_argument()
 * @see remove_philosphy_argument()
 */
mixed query_philosophy_argument( string name, string argument ) {
   if ( !philosophies[ name ] ) {
      return 0;
   }
   return philosophies[ name ][ PHILOSOPHY_ARGUMENTS ][ argument ];
} /* query_philosophy_argument() */

/**
 * This method adds in a philosophy argument to the specified philosophy.
 * @param name the name of the philosophy to add
 * @param argument the name of the argument to add
 * @param args the parameters for the argument
 * @see query_philosophy_argument()
 * @see remove_philosophy_argument()
 */
void add_philosophy_argument( string name, string argument, mixed args ) {
   if ( !philosophies[ name ] ) {
      return;
   }
   if ( !undefinedp( philosophies[ name ][ PHILOSOPHY_ARGUMENTS ][ argument ] ) ) {
      return;
   }
   philosophies[ name ][ PHILOSOPHY_ARGUMENTS ][ argument ] = args;
   save_me();
} /* add_philosophy_argument() */

/**
 * This method removes a specified argument from the philosophy.
 * @param name the name of the philosphy to remove the argument form
 * @param argument the argument name to remove
 * @see add_philosophy_argument()
 * @see query_philosoph_argument()
 */
void remove_philosophy_argument( string name, string argument ) {
   if ( !philosophies[ name ] ) {
      return;
   }
   if ( undefinedp( philosophies[ name ][ PHILOSOPHY_ARGUMENTS ][ argument ] ) ) {
      return;
   }
   map_delete( philosophies[ name ][ PHILOSOPHY_ARGUMENTS ], argument );
   save_me();
} /* remove_philosophy_argument() */

/*
 * A person will not forget an argument (unless they refresh, in which
 *    case all of them are forgotten, i.e. the file is wiped), so let
 *    a person learn to use an argument by adding a new line to their
 *     file consisting of its name and to see if they know an argument,
 *     check in their file for its name. This method doesn't require
 *     a library-type handler.
 */

/**
 * This method returns all the arguments known to the person.
 * @param person the person to get the arguments for
 * @return the list of all the known arguments
 * @see query_known()
 * @see add_known()
 */
string *query_all_known( string person ) {
   string *oldstuff, *newstuff = ({}), key;

  if ( person != current_person ) {  
     if(unguarded((: file_length, SAVE_DIR + person[0..0]+"/"+person :)) < 1) {
       current_philosophies = "";
     } else {
       current_philosophies = unguarded((:read_file,
         SAVE_DIR+person[0..0]+"/"+person:));
     }
  }

  /* Get rid of duplications */
  oldstuff = explode(current_philosophies, "\n");
  foreach ( key in oldstuff ) {
     if ( member_array( key, newstuff ) == -1 ) {
          newstuff += ({ key });
      }
  }
  current_person = person;
  return newstuff;
} /* query_all_known() */
 
/**
 * This method checks to see if the person knows the argument.
 * @param person the person to check the argument for
 * @param argument the argument to check to see if it is known
 * @return 1 if it is known, 0 if not.
 * @see add_known()
 * @see query_all_known()
 */
int query_known( string person, string argument ) {
  if(person != current_person) {
    current_philosophies = "";
    if( unguarded( (: file_length,
		    SAVE_DIR + person[0..0]+"/"+person :) ) < 1 ) {
      current_person = person;
      return 0;
    }
    current_person = person;
    current_philosophies =
      unguarded( (: read_file, SAVE_DIR +  person[0..0]+"/"+person :) );
  }

  return (member_array(argument,explode(current_philosophies ,"\n")) != -1);
} /* query_known() */


/**
 * This method adds an argument to the specified person.
 * @param person the person to add the argument to
 * @param argument the argument to add to the person
 * @see query_known()
 * @see query_all_known()
 */
void add_known( string person, string argument ) {
   string *oldstuff, *newstuff = ({}), key;

   if ( !query_known( person, argument ) ) {
      if( !current_philosophies ) {
         current_philosophies = "";
      }
      current_philosophies += argument +"\n";
   }

   current_person = person;

   /* Get rid of duplications */
   oldstuff = explode(current_philosophies, "\n");
   foreach ( key in oldstuff ) {
     if ( member_array( key, newstuff ) == -1 ) {
       newstuff += ({ key });
     }
   }

   unguarded( (: write_file, SAVE_DIR +  person[0..0]+"/"+person,
      current_philosophies, 1 :));
} /* add_known() */


/**
 * This method removes an argument from the specified person.
 * @param person the person to remove the argument from
 * @param argument the argument to remove from the person
 * @see query_known()
 * @see query_all_known()
 */
int remove_known( string person, string argument ) {
   string *oldstuff, *newstuff = ({}), key;

   if ( !this_player()->query_lord() &&
      this_player()->query_name() != "ringo" ) {
      /* And me, coz I need to test it */
      tell_object(this_player(), "Lords only...\n");
      return 1;
   }
   oldstuff = query_all_known( person );
   current_person = person;
   current_philosophies = "";

   /* Get rid of duplications */
   foreach ( key in oldstuff ) {
      if ( member_array( key, newstuff ) == -1 &&
        key != argument ) {
          newstuff += ({ key });
          current_philosophies += sprintf( "%s\n", key );
       }
   }
   unguarded( (: write_file, SAVE_DIR +  person[0..0]+"/"+person,
      current_philosophies, 1 :));
} /* remove_known() */


/**
 * This method resets the argument list for the specified person.
 * @param person the person to remove the argument from
 * @see query_known()
 * @see query_all_known()
 */
int reset_known( string person ) {
   if ( !this_player()->query_lord() &&
      this_player()->query_name() != "ringo" ) {
      /* And me, coz I need to test it */
      tell_object(this_player(), "Lords only...\n");
      return 1;
   }
   current_person = person;
   current_philosophies = "";
   unguarded( (: write_file, SAVE_DIR +  person[0..0]+"/"+person,
      current_philosophies, 1 :));
} /* remove_known() */
// --- END [/mnt/home2/grok/lib/obj/handlers/philosophies.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/peopler.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/peopler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628200   Available: 13575554
Inodes: Total: 5242880    Free: 4960134
11876 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/peopler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628200   Available: 13575554
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Id: peopler.c,v 1.5 2000/09/07 01:04:11 ceres Exp $
 */

/**
 * This prints out nicely formated lists of information.  It ius used
 * by the people, finger etc commands.
 * @author Pinkfish
 */
#include <peopler.h>

#define MULTIPLAYER "/obj/handlers/multiplayer"

string *de_names,
       *abbrev,
       *var_names;

void create() {
  de_names = DE_NAMES;
  abbrev = ABBREV;
  var_names = ({ 
      "dirs",
      "netstat",
      "people",
      "qpeople",
      "terms",
      "netdups",
    });
} /* create() */

/**
 * This method returns the list of people using the 'str' as a 
 * constraint.  So it only shows the people who match with the
 * str.
 * @param str the constraint string
 * @return the array of people
 */
object *get_people(string str) {
  object *ob;
  int i;
  string s1;

  ob = users();
  
  for(i = 0; i<sizeof(ob); i++) {
    if (str && (sscanf(ob[i]->query_name(),str+"%s", s1) != 1)) {
      ob = ob[0..i - 1] + ob[i+1..];
      i--;
    }
  } 
  return ob;
} /* get_people() */

private string create_title(mixed *bits) {
  int i, pos;
  string str;

  str = "";
  for (i=0;i<sizeof(bits);i+=2) {
    if ((pos = (bits[i]&~MASK)) == STRING)
      str += bits[i+1];
    else
      if (strlen(de_names[pos]) > bits[i+1])
        str += sprintf("%"+bits[i+1]+"."+bits[i+1]+"s", "");
      else
        switch (bits[i]&MASK) {
          case CENTER :
            str += sprintf("%"+bits[i+1]+"."+bits[i+1]+"|s", de_names[pos]);
            break;
          case RIGHT :
            str += sprintf("%"+bits[i+1]+"."+bits[i+1]+"s", de_names[pos]);
            break;
          default :
            str += sprintf("%"+bits[i+1]+"."+bits[i+1]+"-s", de_names[pos]);
            break;
        }
  }
  return str;
} /* create_title() */

private string review_thingy(mixed *bing) {
  int i;
  string str;

  str = "";
  for (i = 0; i < sizeof(bing); i += 2) {
    if (bing[i] == STRING) {
      str += bing[i+1];
    } else {
      switch (bing[i]&MASK) {
        case CENTER :
          str += "%|"+bing[i+1]+abbrev[bing[i]&~MASK];
          break;
        case RIGHT :
          str += "%"+bing[i+1]+abbrev[bing[i]&~MASK];
          break;
        default :
          str += "%-"+bing[i+1]+abbrev[bing[i]&~MASK];
          break;
      }
    }
  }
  return str;
} /* review_thingy() */

/**
 * This method prints out the entries given the input pattern.
 * Ok, the method for doing the format is...
 *    ({ type, width,  ... })
 * With strings the width is the string...
 */
private void print_entrys(object *obs, mixed *format, int with_dups,
                          string constraint) {
  int age, j;
  mixed g;
  string form, str, mess, *not_allowed;
  object ob, env, *dups;
  mapping per_ip;

  reset_eval_cost();

  if (with_dups) {
    per_ip = unique_mapping(obs, (: query_ip_number($1) :));
  }
  mess = sprintf("%s\n", create_title(format));
  foreach(ob in obs) {
    str = "";
    for (j=0;j<sizeof(format);j+=2) {
      switch (format[j]&MASK) {
        case RIGHT :
          form = "%"+format[j+1]+"."+format[j+1];
          break;
        case CENTER :
          form = "%|"+format[j+1]+"."+format[j+1];
          break;
        default :
          form = "%-"+format[j+1]+"."+format[j+1];
          break;
      }
      switch (format[j]&~MASK) {
        case STRING :
/* Ignore width for this one... */
          str += format[j+1];
          break;
        case C_NAME :
          str += sprintf(form+"s", capitalize( (string)ob->query_name() ) );
          break;
        case GENDER :
          str += sprintf(form+"s", ob->query_gender_string());
          break;
        case NAME :
          str += sprintf(form+"s", (ob->query_in_editor()?"*":"")+
              ( ob->query_invis() ? "("+ (string)ob->query_name() +")" :
              (string)ob->query_name() ) );
          break;
        case GUILD :
          if(ob)
            str += sprintf(form+"s",
                           ((g=(object)ob->query_guild_ob())?
                            g->query_name():"No guild"));
          else
            str += sprintf(form+"s", "Broken guild");
          break;
        case LEVEL :
          str += sprintf(form+"s", ""+ ob->query_level());
          break;
        case ROWS :
          str += sprintf(form+"s", ""+ ob->query_rows());
          break;
        case COLS :
          str += sprintf(form+"s", ""+ ob->query_cols());
          break;
        case TERMINAL :
          str += sprintf(form+"s",
                         ((g = ob->query_term_name()) ?
                          g + (g == "network" ? " (" +
                               ob->query_cur_term() + ")" : "") : ""));
          break;
        case IP_NUMBER :
          str += sprintf(form+"s", query_ip_number(ob));
          break;
        case IP_NAME :
          str += sprintf(form+"s",
                           (query_ident(ob)?query_ident(ob)+"@":"")+
                           query_ip_name(ob));
          break;
        case TYPE :
          str += sprintf(form+"s", ob->query_object_type()+"");
          break;
        case AGE :
          age = (int)ob->query_time_on();
          if (age < -86400)
            str += sprintf(form+"s", (age/-86400)+"D");
          else if (age < -3600)
            str += sprintf(form+"s", (age/-3600)+"h");
          else if (age < -60)
            str += sprintf(form+"s", (age/-60)+"m");
          else
            str += sprintf(form+"s", (age/-1)+"s");
          break;
        case ROOM :
          env = environment(ob);
          str += sprintf(form+"s",env?file_name(env):"No environment");
          break;
        case EUID :
          env = environment(ob);
          str += sprintf(form+"s",env?geteuid(env):"No environment");
          break;
        case UID :
          env = environment(ob);
          str += sprintf(form+"s",env?getuid(env):"No environment");
          break;
        case CFILE :
          env = environment(ob);
          str += sprintf(form+"s",env?"/secure/master"->creator_file(env)
                         :"No environment");
          break;
        case CUR_DIR :
          str += sprintf(form+"s", (ob->query_current_path()?
                                    ob->query_current_path():"No dir"));
          break;
        case ND_ALLOWED :
          dups = per_ip[query_ip_number(ob)] - ({ ob });
          not_allowed = MULTIPLAYER->check_allowed(ob, dups);
          str += sprintf(form+"s", (sizeof(not_allowed) ?
                                    query_multiple_short(not_allowed) :
                                    ""));
          break;
      }
    } /* for j... */
    if(!constraint || strsrch(str, constraint) != -1)
      mess += sprintf("%s\n", str);
  } /* for i... */
  this_player()->more_string( mess );
} /* print_entrys() */

/**
 * This method is the main access point to the peopler.  It prints out
 * the commands.  The optional sort function allows you to sort on 
 * somethign other than the name of the player.
 * <p>
 * The format of the pattern string is an array with every second element
 * being the type and the other element being the width of the printable
 * string.
 * <pre>
 *    ({ type, width,  ... })
 * </pre>
 * With strings the width is the string...
 * @param pattern the pattern to print with
 * @param constraint All the names should start with this, 0 fo rnone
 * @param sort_func the function to sort with (optional)
 * @param only_duplicates only print entries whicxh are the same (using the
 *         sort_func
 * @return 0 on failure, 1 on success
 * @see help::people
 * @see help::netstat
 * @see help::snetstat
 * @see help::netdups
 * @see help::terms
 * @see help::dirs
 */
int do_command(mixed *pattern, string constraint, function sort_func,
               int only_duplicates) {
   object *obs;
   object *tmpobs;
   int i;

   obs = get_people("");
   if (!sizeof(obs)) {
      notify_fail("Nobody seems to start with '" + constraint + "'.\n");
      return 0;
   }
   if (!sort_func) {
      sort_func = (: strcmp($1->query_name(), $2->query_name()) :);
   }

   obs = sort_array(obs, sort_func);

   if (only_duplicates) {
      tmpobs = ({ });
      for (i = 1; i <sizeof(obs); i++) {
         if (!evaluate(sort_func, obs[i - 1], obs[i])) {
            if (member_array(obs[i - 1], tmpobs) == -1) {
               tmpobs += obs[i - 1..i];
            } else {
               tmpobs += ({ obs[i] });
            }
         }
      }
      if (!sizeof(tmpobs)) {
         notify_fail("Unable to find any duplicates.\n");
         return 0;
      }
      obs = tmpobs;
   }
   print_entrys(obs, pattern, only_duplicates, constraint);
   return 1;
} /* do_command() */

/**
 * The review command.  Prints out the current settings for
 * the commands.
 * @param str the player name restriction string
 * @return 0 if it failed, 1 if it succeeded
 * @see help::review
 */
int review() {
  mixed *bing;

  bing = (mixed *)this_player()->query_property("people list");
  if (!bing)
    bing = P_DEFAULT;
  write("People : "+review_thingy(bing)+"\n");
  bing = (mixed *)this_player()->query_property("qpeople list");
  if (!bing)
    bing = QP_DEFAULT;
  write("Qpeople: "+review_thingy(bing)+"\n");
  bing = (mixed *)this_player()->query_property("netstat list");
  if (!bing)
    bing = N_DEFAULT;
  write("Netstat: "+review_thingy(bing)+"\n");
  bing = (mixed *)this_player()->query_property("term list");
  if (!bing)
    bing = T_DEFAULT;
  write("Terms  : "+review_thingy(bing)+"\n");
  bing = (mixed *)this_player()->query_property("dir list");
  if (!bing)
    bing = D_DEFAULT;
  write("Dirs   : "+review_thingy(bing)+"\n");
  bing = (mixed *)this_player()->query_property("netdup list");
  if (!bing)
    bing = ND_DEFAULT;
  write("Netdups: "+review_thingy(bing)+"\n");
} /* review() */

private mixed *create_review(string str) {
  string *bits, rest;
  int i, bing, width, tmp;
  mixed *ret;

  bits = explode("$"+str, "%");
  bits[0] = bits[0][1..];
  if (!strlen(bits[0]))
    ret = ({ });
  else
    ret = ({ STRING, bits[0] });
  for (i=1;i<sizeof(bits);i++) {
    bing = RIGHT;
    rest = bits[i];
    if (rest[0] == '|') {
      bing = CENTER;
      rest = rest[1..];
    } else if (rest[0] == '-') {
      bing = 0;
      rest = rest[1..];
    }
    if (sscanf(rest, "%d%s", width, rest) == 2) {
      tmp = member_array(rest[0..0], abbrev);
      if (tmp == -1) {
        write("Unknown thingy '"+rest[0..0]+"'\n");
        return 0;
      }
      ret += ({ tmp+bing, width });
      rest = rest[1..];
      if (strlen(rest))
        ret += ({ STRING, rest });
    } else {
      ret += ({ STRING, bits[i] });
    }
  }
  return ret;
} /* create_review() */

private void list_matches() {
  int i;

  for (i=0;i<sizeof(de_names);i++) {
    if (i == STRING) continue;
    printf("%s: %s\n", abbrev[i], de_names[i]);
  }
} /* list_matches() */

/**
 * Sets a variable.  Sets the variable to the specified value.
 * @param the name and arg of the varible
 * @return 0 on failure, 1 on success
 */
int set_var(string str) {
  string name, type;
  mixed *bing;

  if (str == "help") {
    write("The non helpful help.\nThis is the list of things that go after "+
          "the %'s in the value.\n");
    list_matches();
    return 1;
  }
  if (!str || sscanf(str, "%s %s", name, type) != 2) {
    notify_fail("Syntax: "+query_verb()+" <var_name> <value>\n"+
                "        "+query_verb()+" help\n");
    return 0;
  }
  if (member_array(name, var_names) == -1) {
    notify_fail("You cannot set the var "+name+", it has to be one of "+
                implode(var_names[0..<2], ", ")+" or " + var_names[<1] +
                ".\n");
    return 0;
  }
  bing = create_review(type);
  if (!bing)
    return 1;
  this_player( 1 )->add_property( name +" list", bing );
  write("Ok, set var "+name+" to "+type+".\n");
  return 1;
} /* set_var() */
// --- END [/mnt/home2/grok/lib/obj/handlers/peopler.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/cpi_handler.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/cpi_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628197   Available: 13575551
Inodes: Total: 5242880    Free: 4960134
4176 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/cpi_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628197   Available: 13575551
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: cpi_handler.c,v 1.4 2001/02/22 09:05:51 sojan Exp $
 * $Log: cpi_handler.c,v $
 * Revision 1.4  2001/02/22 09:05:51  sojan
 * coprrected typo
 *
 * Revision 1.3  2001/02/22 08:57:46  sojan
 * added a query types function
 * .
 *
 * Revision 1.2  1999/08/17 17:21:46  wodan
 * converted to add_command
 *
 * Revision 1.1  1998/01/06 05:03:33  ceres
 * Initial revision
 * 
*/
#define RESTORE_PATH "/save/cpi_indices/"
#define STOCK_EXCHANGE find_object( "/d/am/am/gomerchants" )
 
inherit "/std/object";

string material_name;
mapping prices;
 
void setup() {
  set_name( "board" );
  set_short( "price board" );
  set_long( "This is a large board with many small, wooden flaps attached "+
            "to it.  Painted onto the flaps are numbers and letters, and "+
            "the display is occasionally changed by means of a small imp "+
            "that seems to live inside somewhere.  The board lists the "+
            "purchasing prices of almost everything from gold and silk "+
            "to beef and chicken livers at various places where the "+
            "Merchants' Guild does business.\n" );
  add_adjective( "price" );
  set_main_plural( "price boards" );
  add_plural( "boards" );
  reset_get();
} /* setup */

int look_up(string);

void init() {
  add_command("find", "<word'thing'>", (:look_up($4[0]):));
} /* init() */

void imp_effect( string phrase ) {
  tell_room( STOCK_EXCHANGE, "A tiny door opens in the board, a warty imp "+
            "climbs out, clambers across the surface and "+ phrase +
            ".  The imp scowls a bit for the look of the thing, and then "+
            "disappears back inside the board.\n" );
} /* imp_effect() */

void init_data( string word ) {
  material_name = word;
  prices = ([ ]);
} /* init_data() */

int get_data_file( string word ) {
  if ( material_name != word ) {
    if ( file_size( RESTORE_PATH + word +".o" ) > 0 )
      unguarded((: restore_object, RESTORE_PATH + word :));
    else {
      init_data( word );
      return 0;
    }
  }
  return 1;
} /* get_data_file() */
 
void save_data_file( string word ) {
  unguarded((: save_object, RESTORE_PATH + word :));
} /* save_data_file() */

int query_price( string word1, string word2 ) {
   if ( !stringp( word1 ) )
      return 0;
   get_data_file( word1 );
   if ( !prices )
      return 0;
   return prices[ word2 ];
} /* query_price() */

int add_price( string word1, string word2, int number ) {
  get_data_file( word1 );
  if ( prices[word2] != 0 ) return 0;
  prices += ([ word2 : number ]);
  imp_effect( "adds the price of "+ word1 +" in "+ word2 +" to the lists" );
  save_data_file( material_name );
  return 1;
} /* add_price() */

int modify_price( string word1, string word2, int number ) {
  get_data_file( word1 );
  if ( prices[word2] == 0 ) return 0;
  prices[word2] = number;
  imp_effect( "updates the price of "+ word1 +" in "+ word2 );
  save_data_file( material_name );
  return 1;
} /* modify_price() */

int remove_price( string word1, string word2 ) {
  get_data_file( word1 );
  if ( prices[word2] == 0 ) return 0;
  prices = m_delete( prices, word2 );
  imp_effect( "removes the price of "+ word1 +" in "+ word2 +
              " from the lists" );
  save_data_file( material_name );
  return 1;
} /* remove_price() */

int look_up( string word ) {
  int i;

  get_data_file( word );

  if ( !m_sizeof( prices ) ) {
    notify_fail( "You can't find any prices for "+ word +" on the board.\n" );
    return 0;
  }

  if ( m_sizeof( prices ) == 1 ) {
    write( "The only price on the board for "+ word +" is "+
              m_values( prices )[0] +" in "+ m_indices( prices )[0] +".\n" );
  } else {
    write( "You find the following price list for "+ word +":\n\n" );
    for ( i = 1; i < m_sizeof( prices ); i++ ) {
      printf( "%6-s %7d %4|s %40-s \n", "", m_values( prices )[i], "in",
                m_indices( prices )[i] +"," );
    }
    printf( "%6-s %7d %4|s %40-s \n", "  and ", m_values( prices )[0], "in",
              m_indices( prices )[0] +"." );
  }
  return 1;
} /* look_up() */

string *query_available_datatypes()
{
  return get_dir(RESTORE_PATH);
}
// --- END [/mnt/home2/grok/lib/obj/handlers/cpi_handler.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/taskmaster.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/taskmaster.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628196   Available: 13575550
Inodes: Total: 5242880    Free: 4960134
30004 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/taskmaster.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628196   Available: 13575550
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: taskmaster.c,v 2.13 2003/02/26 02:29:47 ceres Exp $
 */

/**
 * This handler gives access to the functions needed for the taskmaster
 * system.
 *
 * Rewritten by Shrike to include degrees of success.
 *
 * @author Deutha
 * @see help::tasks
 */
#include <tasks.h>

#define TIME_PER_USER 1800
#define SAVE_FILES "/save/tasks/"

//#define DEBUG "ceres"
//#define WATCH_PLAYER "serec"
//#define MIN_LEVEL 200
#define LOG_STATS 2
#undef LOGGING

mapping stats;
nosave int last_save;

nosave int last;
nosave string skill;
nosave mixed *control;
nosave int * critical_chances;

varargs mixed perform_task( object person, string skill, int difficulty,
                         int tm_type, int degree );
varargs mixed attempt_task( int difficulty, int bonus, int upper,
                            mixed extra, int degree );
varargs mixed attempt_task_e( int difficulty, int bonus, int upper,
                              int half, int degree );
int is_critical( int margin );

/** @ignore yes */
void create() {
   float a, b;

   seteuid( "Root" );

   // It's fairly processor intensive to calculate exponential values,
   // So we'll do them once and keep them in a lookup table. Equation
   // is y = a*e^(b*i), with constants chosen such that
   // y(1) = 1 and y(100) = 1000. (these numbers are chance out of 10000
   // that a critical will occur)
   critical_chances = allocate(100);
   a = 0.93260;
   b = 0.06978;
   for( int i = 0; i < 100; i++ ) {
      critical_chances[i] = a * exp( b * ( i + 1 ) );
   }
} /* create() */

/** @ignore yes */
mapping query_stats( string s_name ) {
  if ( skill != s_name ) {
    skill = s_name;
    if ( file_size( SAVE_FILES + skill +".o" ) > 0 )
      unguarded( (: restore_object, SAVE_FILES + skill :) );
    else
      stats = 0;
  }
  if ( !stats )
    stats = ([ ]);
  return copy( stats );
} /* query_stats() */

/** @ignore yes */
int query_last() { return last; }

/** @ignore yes */
mixed *query_control() { return control; }

/**
 * This function should only be used in the very rare situations
 * where the last skill checked with query_skill_bonus() wasn't the
 * one relevant for the task attempt.
 *
 * @param args an array consisting of ({ object player, string skill })
 */
void set_control( mixed *args ) { control = args; }

/** @ignore yes */
void reset_control() { control = 0; }

/** @ignore yes */
void award_made( string p_name, string o_name, string s_name, int level ) {
  user_event( "inform", p_name +" gains a level in "+ s_name +" from "+
              o_name + " at level " + level, "skill" );
#ifdef LOG_STATS
#if LOG_STATS == 1
  query_stats( s_name );
  if ( !stats[ level ] )
    stats[ level ] = ([ ]);
  stats[ level ][ explode( o_name, "#" )[ 0 ] ]++;
#else
  query_stats("summary");

  // these two just skew the stats so we don't record them.
  if(s_name[<7..] == ".points" || s_name[0..13] == "other.language")
    return;

  s_name = explode(s_name, ".")[0];
  if(!stats[s_name])
    stats[s_name] = ({ ({ 0 , 0 }),  ({ 0, 0 }),  ({ 0, 0 }) , ({0,0})});

  switch(level) {
  case 0..149:
    stats[s_name][0] = ({ stats[s_name][0][0], stats[s_name][0][1]+1 });
    break;
  case 150..299:
    stats[s_name][1] = ({ stats[s_name][1][0], stats[s_name][1][1]+1 });
    break;
  case 300..599:
    stats[s_name][2] = ({ stats[s_name][2][0], stats[s_name][2][1]+1 });
    break;
  default:
    stats[s_name][3] = ({ stats[s_name][3][0], stats[s_name][3][1]+1 });
    break;
  }

  if(last_save < time() - 300) {
    unguarded( (: save_object, SAVE_FILES + "summary" :) );
    last_save = time();
  }
#endif
#endif
} /* award_made() */

#if LOG_STATS == 2
/** @ignore yes */
void skill_checked(string s_name, int level) {
  query_stats("summary");
  if(s_name[<7..] == ".points" || s_name[0..13] == "other.language")
    return;
  s_name = explode(s_name, ".")[0];
  if(!stats[s_name])
    stats[s_name] = ({ ({0,0}), ({0,0}), ({0,0}), ({0,0}), ({0,0}) });

  switch(level) {
  case 0..49:
    stats[s_name][0] = ({ stats[s_name][0][0]+1, stats[s_name][0][1] });
    break;
  case 50..149:
    stats[s_name][1] = ({ stats[s_name][1][0]+1, stats[s_name][1][1] });
    break;
  case 150..299:
    stats[s_name][2] = ({ stats[s_name][2][0]+1, stats[s_name][2][1] });
    break;
  case 300..599:
    stats[s_name][3] = ({ stats[s_name][3][0]+1, stats[s_name][3][1] });
    break;
  default:
    stats[s_name][4] = ({ stats[s_name][4][0]+1, stats[s_name][4][1] });
    break;
  }
  if(last_save < time() - 300) {
    unguarded( (: save_object, SAVE_FILES + "summary" :) );
    last_save = time();
  }
}
#endif

/** @ignore yes */
string *query_skill_files() {
  return unguarded( (: get_dir, SAVE_FILES +"*.o" :) );
} /* query_skill_files() */

/** @ignore yes */
void clear_skill_files() {
  string word;
  foreach ( word in unguarded( (: get_dir, SAVE_FILES +"*.o" :) ) )
    unguarded( (: rm, SAVE_FILES + word :) );
  skill = 0;
} /* clear_skill_files() */

/**
 * This function will compare the skills of two objects and return which one
 * won and if the winner got a TM.
 * With equal skills the chances are 50/50 as to who will win. As the balance
 * shifts so do the chances. Additionally a modifier can be applied to
 * account for conditions favouring one or the other. This should be
 * considered a percentage eg. -50 will add 50% to the defenders chances of
 * winning.
 * If
 *
 * @param offob The attacking object
 * @param offskill The name of the skill the attacker is using
 * @param deffob The defending object
 * @param deffskill The name of the skill the defender is using
 * @param modifier The percentage modifier
 * @param off_tm_type This should be one of the standard definitions in
 * /include/tasks.h and is for the attacker
 * @param def_tm_type This should be one of the standard definitions in
 * /include/tasks.h and is for the defender
 * @param degree Enable the degree-of-success code.  If this is used, the
 *  return value becomes a class instead of an int.
 *
 * @example
 * This is an example of the simpler, binary success/failure behaviour.
 *
 * switch(TASKER->compare_skills(attacker, "fighting.combat.melee.sharp",
 *                               defender, "fighting.combat.parry.unarmed",
 *                               25, TM_COMMAND, TM_FREE) {
 * case OFFAWARD:
 *   tell_object(attacker, "%^YELLOW%^You manage to grasp one of the "
 *                         "principles of slicing people up more firmly."
 *                         "%^RESET%^\n");
 * case OFFWIN:
 *   say(defender->one_short() + " loses an arm!\n");
 *   break;
 * case DEFAWARD:
 *   tell_object(defender, "%^YELLOW%^You feel better able to keep your arms "
 *                         "attached when parrying unarmed.%^RESET%^\n");
 * case DEFWIN:
 *   say(defender->one_short() + " keeps " + defender->query_possesive() +
 *       " arm attached.\n");
 *   break;
 * }
 *
 * @example
 * This is an example of the finer grained degree-of-success behaviour.
 *
 * class tasker_result tr;
 *
 * tr = (class tasker_result)TASKER->compare_skills(
 *   attacker, "fighting.combat.melee.sharp",
 *   defender, "fighting.combat.parry.unarmed",
 *   25, TM_COMMAND, TM_FREE, 1 );
 *
 * switch( tr->result ) {
 * case OFFAWARD:
 *   tell_object(attacker, "%^YELLOW%^You manage to grasp one of the "
 *                         "principles of slicing people up more firmly."
 *                         "%^RESET%^\n");
 * case OFFWIN:
 *   switch( tr->degree ) {
 *   case TASKER_MARGINAL:
 *     say( "You just barely scrape your opponent's hand.\n" );
 *     break;
 *   case TASKER_NORMAL:
 *     say( "You slice into your opponent's arm.\n" );
 *     break;
 *   case TASKER_EXCEPTIONAL:
 *     say( "You slice deeply into your opponent's muscle and sinew, and "
 *       "he screams in pain!\n" );
 *     break;
 *   case TASKER_CRITICAL:
 *     say( "You slice your opponent's arm clean off.  Blood spurts "
 *       "everywhere like a cherry slurpee machine gone insane!\n" );
 *     break;
 *   }
 *   break;
 * case DEFAWARD:
 *   tell_object(defender, "%^YELLOW%^You feel better able to keep your arms "
 *                         "attached when parrying unarmed.%^RESET%^\n");
 * case DEFWIN:
 *   switch( tr->degree ) {
 *      ...
 *      similar code in here...
 *      ...
 *   }
 *   break;
 * }
 *
 * @see perform_task()
 * @see tasker_result
 *
 */
varargs mixed compare_skills( object offob, string offskill,
                              object defob, string defskill,
                              int modifier, int off_tm_type,
                              int def_tm_type, int degree )
{
  int offbonus, defbonus;
  int perc, chance;
  int success_margin, res, deg;

  // Make sure that we actually have two objects and the associated skills
  // to check against..
  if( !offob || !defob || !offskill || !defskill )
    return BARF;

  offbonus = offob->query_skill_bonus(offskill);
  defbonus = defob->query_skill_bonus(defskill);

  if( !defbonus ) {
    defbonus = 1;
  }
  if( !offbonus ) {
    offbonus = 1;
  }

  // This gives us a sliding scale where off == def is 50 and it climbs
  // from there hitting 0 at def = 2*off and 100 at off = 2*def.
  (offbonus > defbonus) ?
    perc = (50 * offbonus * offbonus) / (offbonus * defbonus) :
    perc = 100 - (50 * defbonus * defbonus) / (offbonus * defbonus);

  perc += modifier; // the difficulty may be weighted.

  // Always got a small chance :)
  if(perc > 99)
    perc = 99;
  if(perc < 1)
    perc = 1;

  chance = random(100);
  success_margin = perc - chance;
  if( success_margin > 0 ) {
    // winner is 1 now do a TM check.
    switch( perform_task( offob, offskill, defbonus-modifier,
                          off_tm_type, 0 ) )
    {
    case AWARD:
      res = OFFAWARD;
      break;
    default:
      res = OFFWIN;
    }

    if( degree ) {
      if( is_critical(success_margin) ) {
        deg = TASKER_CRITICAL;
      } else {
         if( success_margin < TASKER_MARGINAL_UPPER ) {
           deg = TASKER_MARGINAL;
         } else if( success_margin < TASKER_NORMAL_UPPER ) {
           deg = TASKER_NORMAL;
         } else {
           deg = TASKER_EXCEPTIONAL;
         }
      }

      return new( class tasker_result,
                  result : res,
                  degree : deg,
                  raw    : success_margin );
    } else {
      return res;
    }
  } else {
    // winner is 2
    switch( perform_task( defob, defskill, offbonus-modifier,
                          def_tm_type, 0 ) ) {
    case AWARD:
      res = DEFAWARD;
      break;
    default:
      res = DEFWIN;
    }

    if( degree ) {
      if( is_critical(success_margin) ) {
        deg = TASKER_CRITICAL;
      } else {
         if( -success_margin < TASKER_MARGINAL_UPPER ) {
           deg = TASKER_MARGINAL;
         } else if( -success_margin < TASKER_NORMAL_UPPER ) {
           deg = TASKER_NORMAL;
         } else {
           deg = TASKER_EXCEPTIONAL;
         }
      }

      return new( class tasker_result,
                  result : res,
                  degree : deg,
                  raw    : success_margin );
    } else {
      return res;
    }
  }
}

/**
 * This function will perform a task.  It handles all the stuff about
 * looking up the skill, and giving the tm advance, but doesn't give
 * any messages to the player, you'll have to do that.
 * If you set the 'degree' parameter to 1, it will return a 3-element
 * class instead of the standard binary success/failure result.
 *
 * @param person the one attempting the task (could be any living thing)
 * @param skill the skill tested against
 * @param difficulty the lowest bonus where the attempt can succeed
 * @param tm_type This should use one of the standard definitions in 
 * /include/tasks.h. They are:
 *        TM_FIXED - for use where the difficulty is a fixed value
 *        TM_FREE  - for use when the tm attempt doesn't cost anything.
 *        TM_CONTINUOUS - for use in continuous actions eg. combat or sneak
 *        TM_COMMAND - for use with guild commands
 *        TM_RITUAL - when the action is a ritual
 *        TM_SPELL - when the action is a spell
 *        TM_NONE - when you want there to be no chance of a tm
 * @param degree Whether or not to use the degree of success code
 *
 * @return BARF if something screwed up, AWARD if the task succeeded, and
 * should give an advance, SUCCEED if it succeeded, FAIL if it failed. If
 * the degree of success code is used, it will pass out a 3-element class.
 *
 * @example
 * This is an example of the simpler, binary success/failure behaviour.
 *
 * switch(TASKER->perform_task( person, "covert.manipulation.stealing",
 *                              300, TM_COMMAND ) ) {
 *  case AWARD :
 *    tell_object( person, "%^YELLOW%^You manage to grasp the principles "
 *                "of stealing more firmly.%^RESET%^\n" );
 *    // Note, no break;
 *  case SUCCEED :
 *    // Whatever happens when it succeeds
 *    break;
 *  default :
 *    // Whatever happens when it fails
 * }
 *
 * @example
 * This is an example of the finer grained degree-of-success behaviour.
 *
 * class tasker_result tr;
 *
 * tr = (class tasker_result)TASKER->perform_task( person,
 *   "other.direction", 300, TM_FREE, 1 );
 * switch( tr->result ) {
 * case AWARD:
 *   tell_object(attacker, "%^YELLOW%^You feel very aligned!%^RESET%^\n" );
 * case SUCCEED:
 *    switch( tr->degree ) {
 *    case TASKER_MARGINAL:
 *       say( "You think he went thataway. Maybe.\n" );
 *       break;
 *    case TASKER_NORMAL:
 *       say( "You're pretty sure he went that way.\n" );
 *       break;
 *    case TASKER_EXCEPTIONAL:
 *       say( "He definitely went thataway!\n" );
 *       break;
 *    case TASKER_CRITICAL:
 *       say( "Your surity that he went thataway is so powerful that even "
 *         "if he didn't go thataway, he'll be in that direction.\n" );
 *       break;
 *   }
 *   break;
 * case FAIL:
 *   switch( tr->degree ) {
 *      ...
 *      Boy, it's a good thing I've already explained this, or I'd be
 *      pretty hard-pressed to think of an example of a critical failure
 *      for other.direction.  You get the idea.
 *      ...
 *   }
 *   break;
 * }
 *
 * @see compare_skills()
 * @see tasker_result
 *
 */
varargs mixed perform_task( object person, string skill, int difficulty,
                            int tm_type, int degree ) {
  mixed result;
  int bonus, upper;
  
  // Make sure that we actually have an object and a skill to check against..
  if( !person || !skill )
    return BARF;
  
  bonus = person->query_skill_bonus( skill );
  
  switch(tm_type) {
  case TM_FIXED:
    result = attempt_task( difficulty, bonus, 100, 0, degree );
    break;
  case TM_FREE:
    result = attempt_task( difficulty, bonus, 25, 0, degree );
    break;
  case TM_CONTINUOUS:
    result = attempt_task( difficulty, bonus, 50, 0, degree );
    break;
  case TM_COMMAND:
    if( explode( skill, "." )[0] == "covert" )
      result = attempt_task_e 
  ( difficulty, bonus, 60, 40, degree );
    else
      result = attempt_task( difficulty, bonus, 100, 0, degree );
    break;
  case TM_RITUAL:
    result = attempt_task_e( difficulty, bonus, 50, 25, degree );
    break;
  case TM_SPELL:
    result = attempt_task_e( difficulty, bonus, 60, 40, degree );
    break;
  case TM_NONE:
    result = attempt_task_e(difficulty, bonus, 1, 0, degree);
    if(classp(result) && ( (class tasker_result)result )->result == AWARD) {
      result->result = SUCCEED;
    } else if( result == AWARD ) {
      result = SUCCEED;
    }
    break;
  default:                     // this is for backward compatibility
#ifdef LOGGING
    if(file_name(previous_object())[0..2] != "/w/")
      log_file("ATTEMPT_TASK",
               "%s Object %s using old perform_task [%d, %d]\n",
               ctime(time()), base_name(previous_object()), tm_type, degree );
#endif
    upper = tm_type;
    if ( !upper )
      upper = 100;
    result = attempt_task( difficulty, bonus, upper, 0, degree );   
  }
  
  
  if(classp(result) && ( (class tasker_result)result )->result == AWARD ||
     result == AWARD) {
    
    if(person->advancement_restriction() ||
       !person->add_skill_level(skill, 1, previous_object())) {
      if(classp(result))
        result->result = SUCCEED;
      else
        result = SUCCEED;
    }
  }
  return result;
} /* perform_task() */

/*
 * This function will attempt a task and return whether it succeedd.<br>
 * <br>
 * Chance of      /|\<br>
 * success  100% __|            ______..<br>
 *                 |           /<br>
 *                 |          /<br>
 *                 |         /<br>
 *            0% __| .._____/<br>
 *                 |_____________________\   Player's bonus<br>
 *                          |   |        /<br>
 *                 difficulty   difficulty + margin<br>
 * <br>
 * Chance of       /|\<br>
 * gaining  upper __|        .<br>
 *                  |        |\<br>
 *                  |        | \<br>
 *                  |        |  \<br>
 *             0% __| .._____|   \_____..<br>
 *                  |_____________________\  Player's bonus<br>
 *                           |   |        /   <br>
 *                  difficulty   difficulty + margin<br>
 * <br>
 * @param difficulty the lowest bonus where the attempt can succeed
 * @param bonus the bonus the player has in the relevant skill
 * @param upper the maximum chance of getting an advance
 * @param extra the margin control. If it is an int, the margin is set
 * to extra. It it's 0 the margin will be calculated automatically from
 * the difficulty as 3*sqrt(difficulty), if it's an array, it'll be
 * calculated as extra[0]+extra[1]*sqrt(difficulty)
 * @param degree set to one if we want to get a degree of success value
 * returned.
 * @return BARF if something screwed up, AWARD if the task succeeded, and
 * should give an advance, SUCCEED if it succeeded, FAIL if it failed. If
 * degree is one, return an array, where element 0 is one of the above
 * codes, and element 1 is the percentage by which the task was succeeded
 * or failed.
 */
/**
 * Do not use this function. Use perform_task instead.
 * @see perform_task()
 */
varargs mixed attempt_task( int difficulty, int bonus, int upper,
                            mixed extra, int degree )
{
   int margin, success_margin, deg, res;
   float tmp;

#ifdef LOGGING
   if( call_stack(2)[1] != "perform_task" &&
       base_name( previous_object() ) != "/std/effects/fighting/combat" &&
       file_name( previous_object() )[0..2] != "/w/" )
   {
     log_file("ATTEMPT_TASK", "%s Object %s is using old attempt_task "
              "[%O]\n",
              ctime( time() ), base_name( previous_object() ), call_stack(2) );
   }
#endif

#if LOG_STATS == 2
   if(pointerp(control) && control[1]) {
      skill_checked(control[1], control[0]->query_skill(control[1]));
   }
#endif

   /* If the bonus is below the difficulty, they fail. */
   if ( bonus < difficulty ) {
#ifdef DEBUG
      if(pointerp(control) && control[0]->query_name() == WATCH_PLAYER &&
         find_player(DEBUG))
      {
         tell_creator( DEBUG, "%^RED%^"
           + sprintf( "TM: %s Skill: %s [%d] [%d] Failed\n",
                      control[0]->query_name(), control[1], bonus, difficulty )
           + "%^RESET%^" );
      }
#endif
      if( degree ) {
         return new( class tasker_result,
                     result : FAIL,
                     degree : ( is_critical( -100 ) ?
                                TASKER_CRITICAL :
                                TASKER_EXCEPTIONAL ),
                     raw    : -100 );
      } else {
         return FAIL;
      }
   }

   /* Work out the margin between total failure and total success. */
   if ( !extra )
      margin = 3 * sqrt( difficulty );
   else {
      if ( intp( extra ) )
         margin = extra;
      if ( pointerp( extra ) )
         margin = extra[ 0 ] + extra[ 1 ] * sqrt( difficulty );
   }
   if ( !margin )
      return BARF;

   /* If the bonus is above the margin, they succeed. */
   if ( bonus > difficulty + margin ) {
#ifdef DEBUG
     if(pointerp(control) &&
        WATCH_PLAYER || control[0]->query_name() == WATCH_PLAYER &&
        find_player(DEBUG))
       tell_object(find_player(DEBUG), "%^RED%^" + sprintf("TM: %s Skill: %s [%d] [%d] [%d] Succeeded\n", control[0]->query_name(), control[1], bonus, difficulty, margin) + "%^RESET%^");
#endif
      if( degree ) {
         return new( class tasker_result,
                     result : SUCCEED,
                     degree : ( is_critical(100) ?
                                TASKER_CRITICAL :
                                TASKER_EXCEPTIONAL ),
                     raw    : 100 );
      } else {
         return SUCCEED;
      }
   }

   /* In the margin, they might fail. */
   if(!margin)
     margin = 1;

   success_margin = ( ( 100 * ( bonus - difficulty ) ) / margin ) - random(100);
   if ( success_margin <= 0 ) {
#ifdef DEBUG
     if(pointerp(control) &&
        control[0]->query_name() == WATCH_PLAYER &&
        find_player(DEBUG))
       tell_object(find_player(DEBUG), "%^RED%^" + sprintf("TM: %s Skill: %s [%d] [%d] Failed (2)\n", control[0]->query_name(), control[1], bonus, difficulty) + "%^RESET%^");
#endif

      if( degree ) {
         if( is_critical(success_margin) ) {
            deg = TASKER_CRITICAL;
         } else {
            if( -success_margin < TASKER_MARGINAL_UPPER ) {
               deg = TASKER_MARGINAL;
            } else if( -success_margin < TASKER_NORMAL_UPPER ) {
               deg = TASKER_NORMAL;
            } else {
               deg = TASKER_EXCEPTIONAL;
            }
         }

         return new( class tasker_result,
                     result : FAIL,
                     degree : deg,
                     raw    : success_margin );
      } else {
         return FAIL;
      }
   }

   /* If information is available, adjust the chance to award based on stats.*/
   if ( pointerp( control ) ) {
#ifdef DEBUG
     if(find_player(DEBUG) && bonus >= MIN_LEVEL)
       tell_object(find_player(DEBUG), "%^RED%^" +
                   sprintf("TM: %s Skill: %s [%d,%d] OU: %d ",
                           control[0]->query_name(),
                           control[1], bonus,
                           control[0]->query_skill(control[1]),
                           upper));
#endif

     // Reduce the upper dependaont on their stats.
     upper = (int)control[ 0 ]->stat_modify(upper, control[ 1 ] );

#ifdef DEBUG
     if(find_player(DEBUG) && bonus >= MIN_LEVEL)
       tell_object(find_player(DEBUG),
                   sprintf("SU: %d ", upper));
#endif

     // Reduce the upper dependant on their level.
     tmp = exp((control[0]->query_skill(control[1])-BASE) / DECAY);
     upper = to_int(upper / tmp) - MODIFIER;

#ifdef DEBUG
     if(find_player(DEBUG) && bonus >= MIN_LEVEL)
       tell_object(find_player(DEBUG), sprintf("LU: %d ", upper));
#endif

     // prevent upper going negative
     if(upper < 0)
       upper = 0;

#ifdef DEBUG
      if(find_player(DEBUG) && bonus >= MIN_LEVEL)
       tell_object(find_player(DEBUG), sprintf("FU: %d\n",
                                                 upper) + "%^RESET%^");
#endif
   }
#ifdef DEBUG
   else
     if(find_player(DEBUG))
       tell_object(find_player(DEBUG), sprintf("No control: %O\n",
                                                 previous_object(-1)));
#endif
   /* If they succeed, they might be awarded a level. */
     if(!margin)
        margin = 1;

   if( random(100) < ( upper * ( difficulty + margin - bonus ) ) / margin )
      res = AWARD;
   else
      res = SUCCEED;

   if( degree ) {
      if( is_critical(success_margin) ) {
         deg = TASKER_CRITICAL;
      } else {
         if( success_margin < TASKER_MARGINAL_UPPER ) {
            deg = TASKER_MARGINAL;
         } else if( success_margin < TASKER_NORMAL_UPPER ) {
            deg = TASKER_NORMAL;
         } else {
            deg = TASKER_EXCEPTIONAL;
         }
      }

      return new( class tasker_result,
                  result : res,
                  degree : deg,
                  raw    : success_margin );
   } else {
      return res;
   }
} /* attempt_task() */

/*
 * This one acts like the other one except that the failure chance
 * starts at 100% at the difficulty and is halved every (half) bonus levels.
 *
 * @param difficulty the lowest bonus where the attempt can succeed
 * @param bonus the bonus the player has in the relevant skill
 * @param upper the maximum chance of getting an advance
 * @param half every time the bonus rise by half, the failure
 * change is halved
 *
 * @return BARF if something screwed up, AWARD if the task succeeded and
 * should give an advance, SUCCEED if it succeeded, FAIL if it failed.
 */
/**
 * Do not use this function. Use perform_task instead.
 * @see perform_task()
 */
varargs mixed attempt_task_e( int difficulty, int bonus, int upper,
                              int half, int degree )
{
   float fail_chance;
   float tmp;
   int success_margin, deg, res;

#ifdef LOGGING
   if(call_stack(2)[1] != "perform_task" &&
      base_name(previous_object()) != "/std/effects/fighting/combat" &&
      file_name(previous_object())[0..2] != "/w/") {
     log_file("ATTEMPT_TASK", "%s Object %s is using old attempt_task "
              "[%O]\n",
              ctime(time()), base_name(previous_object()), call_stack(2));
   }
#endif

#if LOG_STATS == 2
   if(pointerp(control) && control[1]) {
     skill_checked(control[1], control[0]->query_skill(control[1]));
   }
#endif

   /* If the bonus is below the difficulty, they fail. */
   if ( bonus < difficulty ) {
      if( degree ) {
         return new( class tasker_result,
                     result : FAIL,
                     degree : ( is_critical( -100 ) ?
                                TASKER_CRITICAL :
                                TASKER_EXCEPTIONAL ),
                     raw    : -100 );
      } else {
         return FAIL;
      }
   }

   if( !half ) /* Approximate old behaviour. */
      half = 6 * sqrt( difficulty );
   // We don't want to divide by 0...
   if( !half )
      half = 1;

   fail_chance = exp( ( -0.693 * ( bonus - difficulty ) ) / half );
   success_margin = ( random( 1000 ) - ( 1000 * fail_chance ) ) / 10;

   if ( success_margin < 0 ) {
      if( degree ) {
         if( is_critical(success_margin) ) {
            deg = TASKER_CRITICAL;
         } else {
            if( -success_margin < TASKER_MARGINAL_UPPER ) {
               deg = TASKER_MARGINAL;
            } else if( -success_margin < TASKER_NORMAL_UPPER ) {
               deg = TASKER_NORMAL;
            } else {
               deg = TASKER_EXCEPTIONAL;
            }
         }

         return new( class tasker_result,
                     result : FAIL,
                     degree : deg,
                     raw    : success_margin );
      } else {
         return FAIL;
      }
   }

   /* If information is available, adjust the chance to award based on stats.*/
   if ( pointerp( control ) ) {

#ifdef DEBUG
     if(find_player(DEBUG) && bonus >= MIN_LEVEL)
       tell_object(find_player(DEBUG), "%^RED%^" +
                   sprintf("TM: %s Skill: %s [%d,%d] OU: %d ",
                           control[0]->query_name(),
                           control[1], bonus,
                           control[0]->query_skill(control[1]),
                           upper));
#endif

     // Reduce the upper dependaont on their stats.
     upper = (int)control[ 0 ]->stat_modify( upper, control[ 1 ] );

#ifdef DEBUG
     if(find_player(DEBUG) && bonus >= MIN_LEVEL)
       tell_object(find_player(DEBUG),
                   sprintf("SU: %d ", upper));
#endif

     // Reduce the upper dependant on their level.
     tmp = exp((control[0]->query_skill(control[1])-BASE) / DECAY);
     upper = to_int(upper / tmp) - E_MODIFIER;

#ifdef DEBUG
     if(find_player(DEBUG) && bonus >= MIN_LEVEL)
       tell_object(find_player(DEBUG), sprintf("LU: %d ", upper));
#endif

     // prevent upper going negative and round down to zero from 10
     if(upper < 0)
       upper = 0;
#ifdef DEBUG
      if(find_player(DEBUG) && bonus >= MIN_LEVEL)
       tell_object(find_player(DEBUG), sprintf("FU: %d\n",
                                                 upper) + "%^RESET%^");
#endif

   }

   /* If they succeed, they might be awarded a level. */
   if ( random(1000) < ( upper * fail_chance * 10 )
    &&  bonus < difficulty + ( half * 5 ) ) {
      res = AWARD;
   } else {
      res = SUCCEED;
   }

   if( degree ) {
      if( is_critical(success_margin) ) {
         deg = TASKER_CRITICAL;
      } else {
         if( success_margin < TASKER_MARGINAL_UPPER ) {
            deg = TASKER_MARGINAL;
         } else if( success_margin < TASKER_NORMAL_UPPER ) {
            deg = TASKER_NORMAL;
         } else {
            deg = TASKER_EXCEPTIONAL;
         }
      }

      return new( class tasker_result,
                  result : res,
                  degree : deg,
                  raw    : success_margin );
   } else {
      return res;
   }
} /* attempt_task_e() */

/**
 * Figure out whether a given margin of success/failure will result
 * in a critical or not.  Takes an integer between -100 and 100,
 * representing the margin by which a skillcheck succeeded, and does
 * some logarithmic-type equations to figure out whether it should
 * result in a critical or not.
 * @param margin the margin of success.
 * @return 1 if the result is a critical, 0 otherwise.
*/
int is_critical( int margin ) {
   if ( margin < 0 ) {
      margin *= -1;
   }

   if ( margin > 100 ) {
      margin = 100;
   }

   if ( margin == 0 ) {
      return 0;
   }

   // critical chances are calculated above in create() so that the chance
   // at a margin of 1 is 1/10000 and the chance at a margin of 100 is 1/10.
   return random(10000) < critical_chances[ margin - 1 ];
} /* is_critical() */
// --- END [/mnt/home2/grok/lib/obj/handlers/taskmaster.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/mime.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/mime.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628188   Available: 13575542
Inodes: Total: 5242880    Free: 4960134
9064 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/mime.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628188   Available: 13575542
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: mime.c,v 1.2 2000/02/18 17:24:08 turrican Exp $
 */

/**
 * A parser for RFC 822 compliant messages, with emphasis on
 * the headers in them, also known as MIME headers.
 * <p>
 * RFC 822 describes the format of all Internet messages. This
 * includes things like email, usenet news and HTTP protocol
 * messages.
 * @author Turrican
 * @started 22 May 1998
 */
#include <mime.h>

#define HEADER_NAME 1
#define HEADER_VAL  2
#define MUDMAIL     3
#define TOK_QP      4
#define TOK_QUOTE   5
#define TOK_OP      6
#define TOK_CP      7
#define TOK_LT      8
#define TOK_GT      9
#define TOK_SEP     10
#define TOK_AMP     11
#define SPECIAL     12
#define LWS         13
#define ATOM        14
#define COMMENT     15
#define EMAIL       16
#define QUOTE       17

/*
 * This function parses a string into RFC 822 tokens.
 */
private mixed *tokenize(string header_field) {
  int i, quoted, paren_count, angle_count;
  int *tokens, state;
  mixed *bits;

  bits = reg_assoc(header_field,
                   ({ "\\\\.", "\"", "\\(", "\\)", "<", ">",
                      ",", "@",
                      "[]()<>@,;:\\\\\".[]",
                      "(\n?[ \t])+",
                      "[!#-'*+/-9=?A-Z^-~-]+" }),
                   ({ TOK_QP, TOK_QUOTE, TOK_OP, TOK_CP, TOK_LT, TOK_GT,
                      TOK_SEP, TOK_AMP, SPECIAL, LWS, ATOM }));
  tokens = ({ 0 });
  for (i = 1; i < sizeof(bits[0]); i += 2) {
    switch(bits[1][i]) {
    case LWS:
      if (quoted) {
        tokens += ({ state, 0 });
      } else {
        tokens += ({ 0, 0 });
      }
      break;
    case TOK_QUOTE:
      quoted = !quoted;
      if (!state && quoted) {
        state = QUOTE;
      }
      tokens += ({ state, 0 });
      if (state == QUOTE && !quoted) {
        state = 0;
      }
      break;
    case TOK_OP:
      if (!quoted) {
        paren_count++;
        state = COMMENT;
      }
      tokens += ({ state, 0 });
      break;
    case TOK_CP:
      if (!quoted) {
        paren_count--;
        if (paren_count < 0) {
          printf("Unbalanced ')'\n");
          return ({ });
        }
      }
      tokens += ({ state, 0 });
      if (!paren_count) {
        state = 0;
      }
      break;
    case TOK_LT:
      tokens += ({ state, 0 });
      if (!(quoted || paren_count)) {
        angle_count++;
        state = EMAIL;
      }
      break;
    case TOK_GT:
      if (!(quoted || paren_count)) {
        angle_count--;
        if (angle_count != 0) {
          printf("Unbalanced '%c'\n", (angle_count < 0?'>':'<'));
          return ({ });
        }
        state = 0;
      }
      tokens += ({ state, 0 });
      break;
    default:
      if (!state) {
        tokens += ({ bits[1][i], 0 });
      } else {
        tokens += ({ state, 0 });
      }
      break;
    }
    if (paren_count < 0) {
      printf("Unbalanced ')'\n");
      return ({ });
    }
  }
  if (paren_count != 0) {
    printf("Unbalanced '%c'\n", (paren_count < 0?')':'('));
    return ({ });
  }
  bits += ({ tokens });
  return bits;
} /* tokenize() */

/**
 * This method extracts valid email adresses from the given
 * header field or string.
 *
 * @param arg the string to parse
 * @return an array consisting of an array of machine usable email adresses
 * (no whitespace and comments) and an array of the full addresses
 * @see rewrite_field()
 */
mixed *get_email_addrs(string arg) {
  string *addrs, *full_addrs;
  int i, idx, state;
  mixed *bits;

  if (!arg) {
    return ({ ({ }), ({ }) });
  }
  bits = tokenize(arg);
  if (!sizeof(bits)) {
    return ({ ({ }), ({ }) });
  }
  addrs = allocate(1);
  addrs[0] = "";
  full_addrs = allocate(1);
  full_addrs[0] = "";
  idx = 0;
  for (i = 1; i < sizeof(bits[2]); i += 2) {
    switch (bits[2][i]) {
    case TOK_SEP:
      idx++;
      addrs += ({ "" });
      full_addrs += ({ "" });
      break;
    case EMAIL:
      if (state != EMAIL) {
        addrs[idx] = bits[0][i];
        state = EMAIL;
      } else {
        addrs[idx] += bits[0][i];
      }
      full_addrs[idx] += bits[0][i];
      break;
    case COMMENT:
    case LWS:
    case 0:
      full_addrs[idx] += bits[0][i];
      break;
    default:
      addrs[idx] += bits[0][i];
      full_addrs[idx] += bits[0][i];
      break;
    }
  }
  return ({ addrs, full_addrs });
} /* get_email_addrs() */

/**
 * This method rewrites local email addresses (as found in mudmail)
 * to be usable outside Discworld, for instance from an email client.
 * @param header_field the string to rewrite
 * @return the new string
 * @see get_email_addrs()
 */
string rewrite_field(string header_field) {
  int i, idx, state;
  mixed *bits, *addrs, *indices;

  if (!header_field) {
    return "";
  }
  bits = tokenize(header_field);
  if (!sizeof(bits)) {
    return "";
  }
  addrs = allocate(1);
  addrs[0] = ({ });
  indices = allocate(1);
  indices[0] = ({ });
  idx = 0;
  for (i = 1; i < sizeof(bits[2]); i += 2) {
    switch (bits[2][i]) {
    case TOK_SEP:
      if (sizeof(addrs[idx]) && member_array(TOK_AMP, addrs[idx]) == -1) {
        if (bits[0][indices[idx][<1]] == "discworld") {
          bits[0][indices[idx][<1]] += "@discworld.imaginary.com";
        } else {
          bits[0][indices[idx][<1]] += ".discworld@discworld.imaginary.com";
        }
      }
      idx++;
      addrs += ({ ({ }) });
      indices += ({ ({ }) });
      break;
    case EMAIL:
      if (state != EMAIL) {
        addrs[idx] = ({ bits[1][i] });
        indices[idx] = ({ i });
        state = EMAIL;
      } else {
        addrs[idx] += ({ bits[1][i] });
        indices[idx] += ({ i });
      }
      break;
    case COMMENT:
    case LWS:
    case 0:
      break;
    default:
      addrs[idx] += ({ bits[1][i] });
      indices[idx] += ({ i });
      break;
    }
  }
  if (sizeof(addrs[<1]) && member_array(TOK_AMP, addrs[<1]) == -1) {
    if (bits[0][indices[<1][<1]] == "discworld") {
      bits[0][indices[<1][<1]] += "@discworld.imaginary.com";
    } else {
      bits[0][indices[<1][<1]] += ".discworld@discworld.imaginary.com";
    }
  }
  return implode(bits[0], "");
} /* rewrite_field() */

/**
 * This method parses an RFC 822 compliant message and extracts all
 * the headers into a class mime_header. This class contains a mapping
 * with the header field names as keys, so you can easily select
 * the headers you need.
 * @param message the message to be parsed
 * @return a class mime_header with the headers from the message
 */
class mime_header parse_headers(string message) {
  string *bits, bit, cont, headers;
  int idx, len;
  class mime_header hdr;

  if ((idx = strsrch(message, "\n\n")) == -1) {
    return hdr;
  }
  headers = message[0..idx];
  hdr = new(class mime_header, header_m : ([]), header_k : ({}));
  bits = explode(headers, "\n") - ({ "", 0 });
  foreach (bit in bits[1..]) {
    if (cont && ((bit[0] == ' ') || (bit[0] == '\t'))) {
      hdr->header_m[cont] += "\n" + bit[1..];
      continue;
    }
    len = strlen(bit);
    if ((idx = strsrch(bit, ':')) == -1) {
      continue;
    }
    cont = bit[0..idx-1];
    if (undefinedp(hdr->header_m[lower_case(cont)])) {
      hdr->header_k += ({ cont });
    }
    cont = lower_case(cont);
    ++idx;
    while ((idx < len) && isspace(bit[idx])) {
      ++idx;
    }
    if (undefinedp(hdr->header_m[cont])) {
      hdr->header_m[cont] = bit[idx..];
    } else {
      hdr->header_m[cont] += sprintf(", %s", bit[idx..]);
    }
  }
  return hdr;
} /* parse_headers() */

/**
 * This method rewrites all the fields from an RFC 822 compliant message
 * to make the message suited for Internet transport. It uses the
 * rewrite_field() method to achieve this. The affected header fields
 * are:
 * <UL>
 * <LI> To:
 * <LI> From:
 * <LI> Cc:
 * <LI> Bcc:
 * <LI> Reply-To:
 * </UL>
 * @param message the message to rewrite
 * @return the possibly modified message, suited for Internet transport
 * @see rewrite_field()
 */
string rewrite_header(string message) {
  mixed *ra;
  int i;
  string header, field;

  if ((i = strsrch(message, "\n")) == -1) {
    return message;
  }
  message = message[i+1..];
  if ((i = strsrch(message, "\n\n")) == -1) {
    return message;
  }
  header = message[0..i];
  message = message[i+1..];
  ra = reg_assoc(header,
                 ({ "^[!-9;-~]+:", "((\n?[ \t])+[^\n]*(\n|$))+" }),
                 ({ HEADER_NAME, HEADER_VAL }));
  for (i = 1; i + 2 < sizeof(ra[0]); i += 2) {
    if (ra[1][i] == HEADER_NAME && ra[1][i+2] == HEADER_VAL) {
      switch(lower_case(ra[0][i])) {
      case "to:":
      case "from:":
      case "cc:":
      case "bcc:":
      case "reply-to:":
        field = rewrite_field(ra[0][i+2]);
        if (field != "") {
          ra[0][i+2] = field;
        }
        break;
      default:
        break;
      }
    }
  }
  return implode(ra[0], "") + message;
} /* rewrite_header() */

/** @ignore yes */
void dest_me() {
  destruct(this_object());
} /* dest_me() */

/** @ignore yes */
int cleanup(int inherited) {
  if (!inherited) {
    dest_me();
  }
  return 1;
}
// --- END [/mnt/home2/grok/lib/obj/handlers/mime.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/newbiehelpers.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/newbiehelpers.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628186   Available: 13575540
Inodes: Total: 5242880    Free: 4960134
14668 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/newbiehelpers.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628186   Available: 13575540
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * Newbie Helpers Handler
 *
 * @author Dasquian
 * @started on 26 March 2002
 *
 */
 
#include <playerinfo.h>
#include <player_handler.h>
#include <mail.h>

#define PI_TYPE "misc"
#define SAVE_FILE "/save/newbiehelpers"
#define TO this_object()
#define TP this_player()

private mapping admin;
private mapping helpers;
private mapping applicants;
private int minimum_apply_age, minimum_vouch_age;

protected void log_message( string message );
protected void load_file();
protected void save_file();

void create() {

    admin = ([ ]);
    helpers = ([ ]);
    applicants = ([ ]);
    minimum_apply_age = 0;
    minimum_vouch_age = 0;
    
    load_file();

} /* create() */


string query_list( object lister ) {
    string list_mess, person;

    if( !sizeof( admin ) ) {
        list_mess = "There are no newbie helpers admin at present.\n";
    }
    else {
        list_mess = "Current newbie helpers admin:\n";
        foreach( person in keys(admin) ) {
            list_mess += "    $C$" + person + "\n";   
        }
    }
    
    list_mess += "\n";

    if( !sizeof( helpers ) ) {
        list_mess += "There are no newbie helpers at present.\n";
    }
    else {
        list_mess += "Current newbie helpers:\n";
        foreach( person in keys(helpers) ) {
            list_mess += "    $C$" + person + "\n";   
        }
    }
    
    // Only admin can see who is applying
    if( admin[lister->query_name()] ) {
    
        list_mess += "\n";
    
        if( !sizeof( applicants ) ) {
            list_mess += "There are no outstanding newbie helper "
                "applications at present.\n";
        }
        else {
            list_mess += "Current applications to newbie helpers:\n";
            foreach( person in keys(applicants) ) {
                list_mess += "    $C$" + person + "\n";   
            }
        }    
    
    }
    
    return list_mess;
    
} /* do_list() */


private string helper_info( string name, object tp ) {
    string helper_mess, *vouches;

    helper_mess = "Details for $C$" + name + ":\n";
    
    helper_mess += "    Hired by $C$" + helpers[name]["employer"] + 
        ", " + ctime(helpers[name]["time"]) + ".\n";

    if( helpers[name] ) {
    
        vouches = helpers[name]["vouches"];
        if( !vouches || !sizeof(vouches) ) {
            helper_mess += "    No vouches.\n";
        }
        else {
            helper_mess += "    Vouches were: " + 
                query_multiple_short( map( vouches, (: "$C$" + $1 :) ) ) +
                ".\n";
        }    

        if( !helpers[name]["guild"] || helpers[name]["guild"] == "unknown" ) {
            helper_mess += "    Guild: Unknown.\n";
        }
        else {
            helper_mess += "    Guild: " + helpers[name]["guild"] + 
                ".\n";
        }  
        
        if( !helpers[name]["nationality"] || 
            helpers[name]["nationality"] == "unknown" ) {
            
            helper_mess += "    Nationality: Unknown.\n";
        }
        else {
            helper_mess += "    Nationality: " + helpers[name]["nationality"] 
                + ".\n";
        }  

          
    }
    
    if( admin[name] ) {    
        helper_mess += "    $C$" + name + " is a newbie helpers admin.\n";
    }
    
    return helper_mess;
    
} /* helper_info() */

private string applicant_info( string name, object tp ) {
    string app_mess, voucher;
    mapping vouches;

    app_mess = "Details for $C$" + name + ":\n";
    
    app_mess += "    Applied: " + 
        ctime(applicants[name]["time"]) + ".\n";
    app_mess += "    Age: " + query_time_string(applicants[name]["age"],-1) +
        ".\n";
    app_mess += "    Guild: " + applicants[name]["guild"] + ".\n";
    app_mess += "    Nationality: " + applicants[name]["nationality"] + ".\n";
    
    vouches = applicants[name]["vouches"];
    if( !vouches || !sizeof(vouches) ) {
        app_mess += "    No vouches.\n";
    }
    else {
        app_mess += "    Vouches:\n";
        foreach( voucher in keys(vouches) ) {
            app_mess += "        $C$" + voucher + " (" + 
                query_time_string( 
                    applicants[name]["vouches"][voucher]["age"], -1 
                ) + " old)\n";
        }
    }    
    
    
    app_mess += "\n";    
    app_mess += "    $C$" + name + "'s application:$I$8=\n\n";
    app_mess += applicants[name]["statement"] + "$I$0=\n\n";
    
    if( !vouches || !sizeof(vouches) ) {
        app_mess += "    No vouches.\n";
    }
    else {
        foreach( voucher in keys(vouches) ) {
            app_mess += "    Vouch by $C$" + voucher + " made " +  
                ctime(applicants[name]["vouches"][voucher]["time"]) +
                ":$I$8=\n\n";
            app_mess += applicants[name]["vouches"][voucher]["statement"] + 
                "$I$0=\n\n";
        }
    }   
     
    if( admin[name] ) {    
        app_mess += "    $C$" + name + " is a newbie helpers admin.\n";
    }
        
    return app_mess;
    
} /* applicant_info() */


string query_check_player( object checker, string player ) {

    if( !helpers[player] && !admin[player] && !applicants[player] ) {
        return "$C$" + player + " is not registered with the newbie "
            "helpers handler.\n";
    }
    
    if( !admin[checker->query_name()] ) {
        return "You are not a member of newbiehelpers admin.\n";
    }

    TP->add_succeeded_mess(TO, "", ({ }) );

    if( helpers[player] ) {
        return helper_info( player, TP );
    }
    
    if( applicants[player] ) {
        return applicant_info( player, TP );
    }
    
    return "$C$" + player + " is just an admin.\n";

} /* check_player() */



int add_helper( object adder, string player ) {
    string *player_vouches, player_guild, player_nationality, name;
    
    name = adder->query_name();
    
    if( !admin[name] ) {
        tell_object( TP, "You are not a member of newbiehelpers admin.\n" );
        return 0;    
    }
    
    if( !PLAYER_HANDLER->test_user(player) ) {
        tell_object( TP, "There is no player $C$" + player + "!\n" );
        return 0;
    }

    if( helpers[player] ) {
        tell_object( TP, "$C$" + player + " is already a newbie "
            "helper.\n" );
        return 0;
    }

    if( applicants[player] ) {
        player_vouches = keys( applicants[player]["vouches"] );
        player_guild = applicants[player]["guild"];
        player_nationality = applicants[player]["nationality"];
        map_delete( applicants, player );
            AUTO_MAILER->auto_mail(player, name, "Your newbie helpers "
                "application", "", "Hello,\n\nI am pleased to inform you "
                "that your newbie helpers application was successful, and "
                "that you have now been hired as a newbie helper.  This was "
                "an automatic mail.\n\n$C$" + name, 0, 0);
    }
    else {
        player_vouches = ({ });
        player_guild = "unknown";
        player_nationality = "unknown";
    }


    helpers[player] = ([ ]);
    helpers[player]["time"] = time();
    helpers[player]["employer"] = name;
    helpers[player]["vouches"] = player_vouches;
    helpers[player]["guild"] = player_guild;
    helpers[player]["nationality"] = player_nationality;
    save_file();

    log_message( player + " added as a helper by " + name );
    if ( PLAYERINFO_HANDLER->add_entry( this_object(), player, PI_TYPE,
        "Added as a newbiehelper.", 0 ) ) {
        log_message( player + "'s playerinfo updated" );
    }
    else {
        log_message( player + "'s playerinfo NOT updated (an error "
            "occurred)" );
    }
    
    return 1;

} /* add_helper() */



string remove_helper( object remover, string player, string reason ) {
    string name;
    
    name = remover->query_name();
    
    if( !admin[name] ) {
        tell_object( TP, "You are not a member of newbiehelpers admin.\n" );
        return 0;    
    }

    if( !helpers[player] ) {
        return "$C$" + player + " is not a newbie helper.\n";
    }

    map_delete( helpers, player );
    save_file();
    
    
    log_message( player + " removed as a helper by " + name + ", reason: " + 
        reason );    
    if ( PLAYERINFO_HANDLER->add_entry( this_object(), player, PI_TYPE,
        "Removed as a newbiehelper (" + reason + ").", 0 ) ) {
      
        log_message( player + "'s playerinfo updated" );
    }
    else {
        log_message( player + "'s playerinfo NOT updated (an error "
            "occurred)" );
    }


    return "You remove $C$" + player + "'s helper status.\n";
    
} /* remove_helper() */


void submit_vouch(string statement, mixed args) {
    string name, player;
    object voucher;
    
    voucher = args[0];
    player = args[1];
    name = voucher->query_name();
    
    applicants[player]["vouches"][name] = ([ ]);
    applicants[player]["vouches"][name]["time"] = time();
    applicants[player]["vouches"][name]["age"] = -voucher->query_time_on();
    applicants[player]["vouches"][name]["statement"] = statement;
    save_file();
    
    log_message( name + " submits a vouch for " + player );
    
} /* submit_vouch() */


string no_vouch_reason( object voucher, string applicant ) {
    string name;
    
    name = voucher->query_name();
    
    if( !applicants[applicant] ) {
        return "$C$" + applicant + " isn't applying to be a newbie helper, "
            "so you can't vouch for them.\n";
    }

    if( applicants[applicant]["vouches"][name] ) {
        return "You already have already vouched for $C$" + applicant + " on "
            "this application, you cannot vouch again.\n";
    }  
     
    if( applicant == name ) {
        return "You cannot vouch for yourself!\n";
    }
    
    if( -voucher->query_time_on() < minimum_vouch_age ) {
        return "You cannot vouch for $C$ " + applicant + " as you are too "
            "young to vouch.  You need to be " + 
            query_time_string( minimum_vouch_age, -1 ) + " old before you "
            "can vouch on people's applications to be a newbie helper.\n";
    }

    return 0;

} /* no_vouch_reason() */


void submit_application(string statement, object player) {
    string name;
    
    name = player->query_name();
    
    applicants[name] = ([ ]);
    applicants[name]["time"] = time();
    applicants[name]["age"] = -player->query_time_on();
    applicants[name]["statement"] = statement;
    applicants[name]["vouches"] = ([ ]);
    applicants[name]["guild"] = 
        (load_object(player->query_guild_ob()))->query_short();
    if( player->query_nationality() ) {
        applicants[name]["nationality"] = "$C$" +
            (load_object(player->query_nationality()))->query_name();
        }
    else {
        applicants[name]["nationality"] = "unknown";
    }
    save_file();

    log_message( name + " submits an application to newbiehelpers" );
    
} /* submit_application() */


string no_apply_reason( object player ) {
    string name;
    
    name = player->query_name();
    
    if( helpers[name] ) {
        return "You are already a newbie helper, why are you applying "
            "again?\n";
    }   
    if( applicants[name] ) {
        return "You already have a newbie helper application open, you "
            "should wait to hear back about it.\n";
    }   
    if( -player->query_time_on() < minimum_apply_age ) {
        return "You cannot apply to be a newbie helper as you are too "
            "young.  You need to be " + 
            query_time_string( minimum_apply_age, -1 ) + " before you can "
            "apply to be a newbie helper.\n";
    }
    
    return 0;

} /* no_apply_reason() */


void reject_application( object rejecter, string player, string reason, 
    string mail ) {
    
    string name;
    
    name = rejecter->query_name();
    
    if( !admin[name] ) {
        return;
    }
    
    if( !applicants[player] ) {
        return;
    }   

    AUTO_MAILER->auto_mail(player, name, "Your newbie helpers "
        "application", "", mail, 0, 0);
    map_delete( applicants, player );
    save_file();

    log_message( name + " rejects " + player + "'s application, reason: " + 
        reason );
    if ( PLAYERINFO_HANDLER->add_entry( this_object(), player, PI_TYPE,
        "Rejected as a newbiehelper (" + reason + ").", 0 ) ) {
        log_message( player + "'s playerinfo updated" );
    }
    else {
        log_message( player + "'s playerinfo NOT updated (an error "
            "occurred)" );
    }

} /* reject_application() */

string no_reject_reason( object rejecter, string player ) {
    string name;
    
    name = rejecter->query_name();
    
    if( !admin[name] ) {
        return "You are not a member of newbiehelpers admin.\n";
    }
    
    if( !applicants[player] ) {
        return "$C$" + player + " isn't applying to be a newbie helper, so "
            "you can't reject them.\n";
    }   

    return 0;

} /* no_reject_reason() */


int query_helper( string name ) {

    if( helpers[name] ) { 
        return 1;
    }
    else { 
        return 0;
    }

} /* query_helper() */


int add_admin( string name ) {

    if( !admin[TP->query_name()] ) {
        return 0;
    }

    if( !admin[name] ) {
        admin[name] = 1;
        save_file();
        log_message( name + " added as admin by " + TP->query_name() );
        return 1;
    }
    else {
        return 0;
    }
    
} /* add_admin() */

int remove_admin( string name ) {

    if( !admin[TP->query_name()] ) {
        return 0;
    }   

    if( !admin[name] ) {
        return 0;
    }
    else {
        map_delete(admin, name);
        save_file();
        log_message( name + " removed from admin by " + TP->query_name() );
        return 1;
    }
    
} /* remove_admin() */

int query_admin( string name ) {

    if( admin[name] ) { 
        return 1;
    }
    else { 
        return 0;
    }

} /* query_admin() */

int query_can_chat( object who ) {
    if( query_helper( who->query_name() ) || 
        query_admin( who->query_name() ) ||
        who->query_creator() ) {
        return 1;
    }
    return 0;
} /* query_can_chat */

string query_name() { return "Newbiehelpers Handler"; } /* query_name() */

// Log a message
protected void log_message( string message ) {
    log_file("/log/NEWBIEHELPERS", ctime(time()) + ": " + message + "\n");
} /* log_message() */

// Save the memory list.
protected void save_file() {
    unguarded( (: save_object, SAVE_FILE, 1 :) );
} /* save_file() */

// Load the memory list.
protected void load_file() {
    if (file_size(SAVE_FILE + ".o") > 0)
        unguarded( (: restore_object, SAVE_FILE, 1 :) );
} /* load_file() */

// --- END [/mnt/home2/grok/lib/obj/handlers/newbiehelpers.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/project_management.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/project_management.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628182   Available: 13575536
Inodes: Total: 5242880    Free: 4960134
57432 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/project_management.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628182   Available: 13575536
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
 /**
 *  Project Management System
 *  @author Drakkos
 *  @started 19/08/2001
 *
 */

#include "project_management.h"
#include <playtesters.h>
#include <permissions.h>
#include <board.h>
#include <mail.h>
#include <cmds/twiki.h>

int query_project_completeness(string);
string* query_project_tasks(string);
int valid_operation (string name, string action, string project);
int find_project (string);
void do_save();
int nuke_creator_project_cache(string*); 
string* query_projects_for_creator (string);
int clear_file_cache (string nfile);
void do_mail (string*, string);
int clear_playtesting_projects (string*);
class project* filter_by_query (mapping);
void catch_status_change (string, int);
 
class file_access_cache {
  string id;
  mapping accesses;
}
 
string *pt_post_cache = ({ });
 
class project *projects = ({ });
class project_tmp *tmp_projects = ({ });
int touched;

int last_summary;
mapping summary;
mapping num_assignments;
nosave mapping inform = ([ ]); 
nosave mapping creator_project_cache = ([ ]);
nosave mapping pt_assignment_cache = ([ ]);
nosave class file_access_cache *cache = ({ });
nosave string *excluded = ({
  "bfg",
  "dionysus",
  "melian",
});    

mapping project_locks = ([ ]);
  
/**
 *  Call out the do_save function.  If lots of projects are being touched 
 *` within a short time scale, this should reduce the hard-drive grinding.
 *  @ignore yes
 *
 */
   
void save_file() {
  if (find_call_out ("do_save") == -1) {
    call_out ("do_save", 10);
  }
}

/**
 *  Log text to the project management logfile.
 *  @ignore yes
 *
 */
 
void do_log (string text) {
  log_file (PROJECT_LOG, text);
}

/**
 *  Save the file.
 *  @ignore yes
 *
 */
 
void do_save() {
  seteuid ("Root");
  touched = 1;
  unguarded ((: save_object, PROJECT_SAVE :));
//  unguarded ((: save_object, TMP_SAVE:));

  touched = 0;
}

/**
 *  Load the file.
 *  @ignore yes
 *
 */
 
void do_load() {
  unguarded ((: restore_object, PROJECT_SAVE :));

}

 
/**
 *  The create method, natch.
 *  @ignore yes
 *
 */  
 
void create() {
  string *creators = ({ });
  
  do_load();
  
  if (!last_summary) {
    last_summary = time();
  }
  
  if (!summary) {
    summary = ([ ]);
  }
  
  if (!tmp_projects) {
    tmp_projects = ({ });
  }
  
  if (!creator_project_cache) {
    creator_project_cache = ([ ]);
  }
  
  if (!cache) {
    cache = ({ });
  }
  
  if (!pt_post_cache) {
    pt_post_cache = ({ });
  }
  
  if (!num_assignments) {
    num_assignments = ([ ]);
  }
  
    
  foreach (class project p in projects) {
    creators += p->creators;
  }
  
  creators = uniq_array (creators);
  
  foreach (string c in creators) {
    query_projects_for_creator (c);    
  }
  
  
}

/**
 *  Touch a project.  We use this project to set when a project
 *  was last touched, by whom and what they did.  We also save
 *  the data file at this point.
 *  @param id the project ID
 *  @param reason the way the project was touched
 *  @param name the name of the person touching the project
 *  
 */
 
void touch_project (string id, string reason, string name) {
  int i = find_project (id);
  object ob;
  
  if (i == -1) {
    return;
  }
  
  projects[i]->last_touched = time();
  projects[i]->what_touched = reason;
  projects[i]->touched_by = name;
  save_file();
  
  if (find_call_out ("do_inform") == -1) {
    call_out ("do_inform", 120);
  }
                             
  if (undefinedp (summary[id])) {
    summary[id] = ({ name });
  }
  else {
    summary[id] += ({ name });
  }

  if (undefinedp (inform[id])) {
    inform[id] = ({ name });
  }
  else {
    inform[id] += ({ name });
  }
  
  foreach (string d in projects[i]->domains) {
    ob = load_object ("/d/" + d + "/master");    
    if (ob) {
      ob->nuke_creator_project_cache (projects[i]->creators);
    }
    nuke_creator_project_cache (projects[i]->creators);
  }
      
                                     
  do_log (sprintf ("%s:  Project %s touched by %s:  %s\n", 
    ctime (time()), id, name, reason));
}

/**
 *  Compile the information for the creator inform.
 *
 */
 
void do_inform() {
  int i;
  
  foreach (string id, string *names in inform) {    
    i = find_project (id);
    
    user_event ("inform", sprintf ("%s: Project %s touched by %s", 
      query_multiple_short(map (projects[i]->domains, (: capitalize ($1) :))), 
      id, query_multiple_short (map (uniq_array (names), 
      (: capitalize ($1) :)))), "message", this_player());
  }
  
  inform = ([ ]);
}



string* query_projects_for_creator (string c) {
  if (!creator_project_cache[c]) {
    creator_project_cache[c] = map (filter_by_query ((["creators": c])),
      (: $1->id :));
      
//    map (filter (projects, (: member_array ($(c), 
//      $1->creators) != -1 :)), (: $1->id :));
  }
  
  return creator_project_cache[c];
}


string* query_projects_for_creator_in_domain (string creator, string domain) {
  return sort_array (map (filter_by_query ((["creators": creator, "domains" : domain])),
      (: $1->name :)), 1);
}


/**
 *  Return a formatted string saying when the project was last touched.
 *  @param id the project ID.
 *  @returns the last touched string.
 *
 */
 
string query_touched (string id) {
  int i = find_project (id);
  
  if (i == -1) {
    return 0;
  }
  
  if (!projects[i]->last_touched) {
    return "This project has not been touched since it was added.";
  }
  
  return sprintf ("%s last touched project %s on %s:  %s.",
    (projects[i]->touched_by ? capitalize (projects[i]->touched_by) :
    "Someone"), id, 
    ctime (projects[i]->last_touched), projects[i]->what_touched);    
}


mapping query_summary_mapping() {
  return summary;
}

int query_last_summary() {
  return last_summary;
}


/**
 *  Return the details of projects that have been touched since the
 *  last summary.
 *  @returns the recent project changes.
 *
 */
 
string query_summary_page() {
  string ret = "Project changes since " + ctime (last_summary) + "\n\n";
  
  foreach (string proj, string *names in summary) {
    ret += sprintf ("%-30s touched by %s\n", 
      proj, query_multiple_short (uniq_array (names)));
  }

  
  return ret;
}

/**
 *  Insert an element into the projects array.  It will do this 
 *  alphabetically to ensure that the binary search algorithim
 *  can locate projects.
 *  @param temp the element to insert
 *  @returns the index of the inserted element.
 */
 
int insert_into_projects (mixed temp) {
  int index = 0;

  if (!sizeof (projects)) {
    projects = ({ temp });
    return 0;
  }
    
  while (index < sizeof (projects) && temp->id > projects[index]->id) {       
    index++;
  } 
          
  if (index == sizeof (projects)) {
    projects = projects + ({ temp });
  }
  else if (index == 0) {
    projects = ({ temp }) + projects;
  }
  else {
    projects = projects[0..index-1] + ({ temp }) + 
      projects[index..sizeof(projects)];
  }

  
  return index;
}

int insert_into_cache (mixed temp) {
  int index = 0;

  if (!sizeof (cache)) {
    cache = ({ temp });
    return 0;
  }
    
  while (index < sizeof (cache) && temp->id > cache[index]->id) {       
    index++;
  } 
          
  if (index == sizeof (cache)) {
    cache = cache + ({ temp });
  }
  else if (index == 0) {
    cache = ({ temp }) + cache ;
  }
  else {
    cache = cache[0..index-1] + ({ temp }) + 
      cache[index..sizeof(cache)];
  }

  
  return index;
}

/**
 *  Insert an element into the tasks array.  It will do this 
 *  alphabetically to ensure that the binary search algorithim
 *  can locate projects.
 *  @param i the index of the project to insert into.
 *  @param temp the element to insert
 *  @returns the index of the inserted element.
 */
 

int insert_into_tasks (int i, mixed temp) {
  int index = 0;

  if (!sizeof (projects[i]->tasks)) {
    projects[i]->tasks = ({ temp });
    return 0;
  }
    
  while (index < sizeof (projects[i]->tasks) && 
    temp->id > projects[i]->tasks[index]->id) {       
      index++;
  } 
          
  if (index == sizeof (projects[i]->tasks)) {
    projects[i]->tasks = projects[i]->tasks + ({ temp });
  }
  else if (index == 0) {
    projects[i]->tasks = ({ temp }) + projects[i]->tasks;
  }
  else {
    projects[i]->tasks = projects[i]->tasks[0..index-1] + ({ temp }) 
      + projects[i]->tasks[index..sizeof(projects[i]->tasks)];
  }
 
  return index;
}


/**
 *  Insert an element into the notes array.  It will do this 
 *  alphabetically to ensure that the binary search algorithim
 *  can locate projects.
 *  @param i the index of the project to insert into.
 *  @param temp the element to insert
 *  @returns the index of the inserted element.
 */
 
int insert_into_notes (int i, mixed temp) {
  int index = 0;

  if (!sizeof (projects[i]->notes)) {
    projects[i]->notes = ({ temp });
    return 0;
  }
    
  while (index < sizeof (projects[i]->notes) && 
    temp->id > projects[i]->notes[index]->id) {       
      index++;
  } 
          
  if (index == sizeof (projects[i]->notes)) {
    projects[i]->notes = projects[i]->notes + ({ temp });
  }
  else if (index == 0) {
    projects[i]->notes = ({ temp }) + projects[i]->notes;
  }
  else {
    projects[i]->notes = projects[i]->notes[0..index-1] + ({ temp }) 
      + projects[i]->notes[index..sizeof(projects[i]->notes)];
  }
 
  return index;
}


/**
 *  Find the occurance of a particular ID in a particular array.  This
 *  is done via a binary search of the array.
 *  @param id the ID to match on
 *  @array array the array to search through.
 *  @returns the index of the matched element, or -1 if none is found.
 *  @ignore yes
 */
 

protected int find_index (string id, mixed array) {
  int mid, right, left;
  
  if (!sizeof (array)) {
    return -1;
  }
  
  right = sizeof (array);
  mid = (left + right) / 2;
  left = 0;
  
  do {
    
    if (array[mid]->id == id) {
      return mid;
    }
    
    if (id > array[mid]->id) {  
      left = mid + 1;
      mid = (left + right) / 2;
    }
    else if (id < array[mid]->id) {
      right = mid;
      mid = (left + right) / 2;

    }
        
  } while (left < right);
  
  return -1;
} 


/**
 *  Return a brief summary of the pertinent details of a particular project.
 *  @param p the project to summarise.
 *  @returns the string summary.
 *
 */
 
string parse_details(class project p) {
  string ret = sprintf ("$I$5=The %s (%s) project belongs to the %s %s and is "
    "in %s, with assigned creators of: %s.\n", 
    p->id, p->name, query_multiple_short (p->domains), 
    (sizeof (p->domains) == 1 ? "domain" : "domains"), STATUS[p->status], 
    query_multiple_short (p->creators));      

//  if (file_name(previous_object())[0..3] == "/www" ) {
    ret = replace (ret, ({"$I$5=", "<p>"}));
//  }

  return ret;
}      

/**
 *  Find the index of a particular project.
 *  @param id the project to search for.
 *  @returns the index of the project, or -1 if none is found.
 *
 */
 
int find_project (string id) {
  int i = find_index (id, projects);
  
  return i;
}

/**
 *  Find the index of a particular note for a project.
 *  @param i the project to search for
 *  @param id the note to search for.
 *  @returns the index of the note, or -1 if none is found.
 *
 */
 
int find_note(mixed i, string id) {
  int j;
  
  if (!intp(i)) {
    i = find_project (i);
  }
  
  j = find_index (id, projects[i]->notes);
  
  return j;
}

/**
 *  Find the index of a particular task for a project.
 *  @param i the project to search for
 *  @param id the task to search for.
 *  @returns the index of the task, or -1 if none is found.
 *
 */
 
int find_task(mixed i, string id) {
  int j;
  
  if (!intp(i)) {
    i = find_project (i);
  }
  
  j = find_index (id, projects[i]->tasks);
  
  return j;
}

/**
 *  Find the occurance of a particular file for a project.
 *  @param i the project to search for
 *  @param file the file to search for.
 *  @returns the index of the task, or -1 if none is found.
 *
 */
 
class file* find_file(mixed i, string nfile, string task) {
  int j;
  class file *tmp = ({ });
  
  if (!intp(i)) {
    i = find_project (i);
  }
    
  if (!sizeof (projects[i]->files)) {
    return tmp;
  }
  
  
  for (j=0; j < sizeof (projects[i]->files); j++) {
    if (projects[i]->files[j]->file == nfile) {
      if (sizeof (task)) {
        if (task == "leader" || projects[i]->files[j]->task == task) {
          tmp += ({ projects[i]->files[j] });
        }
      }
                
      else if (!sizeof (projects[i]->files[j]->task)) {
          tmp += ({ projects[i]->files[j] });
      }
    }
  }
  
  
  return tmp;
}

/**
 *  Find the cache entry for a particular file.
 *  @param id the project to search for.
 *  @returns the index of the project, or -1 if none is found.
 *
 */
 
int find_cache_file (string file) {
  int i = find_index (file, cache);
  
  return i;
}


/**
 *  Delete a project from the array.
 *  @param id the note to search for.
 *  @param name the name of the person deleting.
 *  @returns 1.
 *
 */
 
int delete_project (string id, string name) {
  int i = find_index (id, projects);
  
  if (i == -1) {
    return 0;
  }
        
  projects -= ({ projects[i] });
  do_log (sprintf ("%s:  %s deleted project %s.\n", 
    ctime(time()), name, id));
  save_file();
  return 1;
}

/**
 *  Delete a task from a project.
 *  @param id the project to search for.
 *  @param task_id the task to search for
 *  @param name the name of the person deleting.
 *  @returns 1.
 *
 */
 
int delete_task (string id, string task_id, string name) {
  int i = find_project (id);
  int j;
  
  if (i == -1) {
    return 0;
  }
  
  j = find_task (i, task_id);
  
  if (j == -1) {
    return 0;
  }
  
      
  projects[i]->tasks -= ({ projects[i]->tasks[j] });
  touch_project (id, "Deleted task " + task_id, name);
  return 1;
}

/**
 *  Delete a note from a project.
 *  @param id the project to search for.
 *  @param note_id the note to search for
 *  @param name the name of the person deleting.
 *  @returns 1.
 *
 */
 
int delete_note (string id, string note_id, string name) {
  int i = find_project (id);
  int j;
  
  if (i == -1) {
    return 0;
  }
  
  j = find_note (i, note_id);
  
  if (j == -1) {
    return 0;
  }
  
      
  projects[i]->notes -= ({ projects[i]->notes[j] });
  touch_project (id, "Deleted note " + note_id, name);
  
  return 1;
}

/**
 *  Add a project to the database.
 *  @param id the project to add.
 *  @param nname the name of the project
 *  @param lead the project leader.
 *  @param desc the description of the project
 *  @param dom the domains the project belongs to
 *  @param cre the creators assigned to the project
 *  @param add_name the person adding the project.
 *  @returns the index of the added project, or -1 if the project already 
 *    exists
 *
 */

int add_project (string id, string nname, string lead, string desc, 
  string *dom, string *cre, string add_name, int size, int complexity,
  string *guilds) {  
  int i;
  
  class project tmp;

  if (find_project (id) != -1) {
    return -1;
  }
    
  tmp = new (class project, id: id, name: nname, leader: lead,
    date_added: time(), added_by: add_name, 
    date_completed: 0, status: 0, estimated_completion: 0, 
    description: desc, domains: dom, creators: (sizeof (cre) ? cre :
    ({})), playtesters: ({ }), tasks: ({ }),
    files: ({ }), twiki: ({ }), percent_complete: 0, sub_projects: ({ }),
    notes: ({ }), size: size, complexity: complexity, guild_specific : 
    guilds);
    
  i = insert_into_projects (tmp);

  touch_project (id, "Project added", add_name);

  return i;
}
  
int add_cache_file (string id) {  
  int i;
  
  class file_access_cache tmp;

  if (find_cache_file (id) != -1) {
    return -1;
  }
    
  tmp = new (class file_access_cache, id: id, accesses: ([ ]));
    
  i = insert_into_cache (tmp);

  return i;
}  
 
int set_completion_date (string id, int date) {
  int i = find_project (id);
  
  if (i == -1) {
    return 0;
  }
  
  projects[i]->estimated_completion = date;
}
   
int add_creator (string id, string creator) {
  int i = find_project (id);
  
  if (i == -1) {
    return 0;
  }
  
  if (!sizeof (projects[i]->creators)) {
    projects[i]->creators = ({ creator });
  }
  else if (member_array (creator, projects[i]->creators) == -1) {
    projects[i]->creators += ({ creator });
  }

  return 1;  
}   

int add_twiki (string id, string twiki) {
  int i = find_project (id);
  
  if (i == -1) {
    return 0;
  }
  
  if (!sizeof (projects[i]->twiki)) {
    projects[i]->twiki = ({ twiki });
  }
  else {
    projects[i]->twiki += ({ twiki });
  }

  return 1;  
}   

string* query_twiki (string id) {
  int i = find_project (id);
  
  if (i == -1) {
    return 0;
  }
    
  return copy (projects[i]->twiki);
  
}  


class file* query_files (string id) {
  int i = find_project (id);
  
  if (i == -1) {
    return 0;
  }
    
  return copy (projects[i]->files);
  
}  


int add_file (string id, string file, int access, string name, string task) {
  int i = find_project (id);
  int k;
  mixed ob;
  class file tmp;
  class file *files = ({ });
  
  
  if (i == -1) {
    return 0;
  }
  
  if (access == GRANT_MASK || access == LOCK_MASK) {
    ob = find_player (name);
    
    if (!ob) {
      return 0;
    }
  }
  
  if (!ob) {
    ob = name;
  }
  
  
  k = master()->valid_grant (ob, file, access);
  
  if (!k) {
    log_file ("CHEAT", ctime(time()) + ": " + name + " tried to add "
      "level " + access + " access to file " + file + "\n");
    return 0;
  }
  
  tmp = new (class file, file: file, access: access, task: task);

   
  if (!sizeof (projects[i]->files)) {
    projects[i]->files = ({ tmp });
  }
  else {
    files = find_file (i, file, task);
    
    foreach (class file f in files) {
      if (f->access == access && f->task == task) {
        return 0;
      }
    }
    
    projects[i]->files += ({ tmp });  
  }
  
  clear_file_cache (file);
  
  touch_project (id, "Added a file permission", name);
  
  return 1;  
}   

int remove_file (string id, string file, string task, string name) {
  int i = find_project (id);
  class file *tmp = ({ });
    
  if (i == -1) {
    return 0;
  }  
  
  tmp = find_file (i, file, task);
  
  if (!sizeof (tmp)) {
    return 0;
  }
  
  foreach (class file f in tmp) {
    if (f->task == task) {
      projects[i]->files -= ({ f });
      break;
    }
    
  }
  
  clear_file_cache (file);
  touch_project (id, "Removed a file permission", name);

  return 1;
}

int reset_files (string id) {
  int i = find_project (id);
  projects[i]->files = ({ });
}

int add_domain (string id, string domain) {
  int i = find_project (id);
  
  if (i == -1) {
    return 0;
  }
  
  if (!sizeof (projects[i]->domains)) {
    projects[i]->domains = ({ domain });
  }
  else {
    projects[i]->domains += ({ domain });
  }

  return 1;  
}   

int set_project_leader (string id, string leader) {
  int i = find_project (id);
  
  if (i == -1) {
    return 0;
  }
  
  projects[i]->leader= leader;
}

string query_project_leader (string id) {
  int i = find_project (id);
  
  if (i == -1) {
    return 0;
  }
  
  return projects[i]->leader;
}

string* query_project_subprojects (string id) {
  int i = find_project (id);
  
  if (i == -1) {
    return 0;
  }
  
  return projects[i]->sub_projects;
}


string* query_projects() {
  return map (projects, (: $1->id :));
}

int set_status (string id, int stat) {
  int i = find_project (id);
  
  if (i == -1) {
    return 0;
  }
  
  if (stat >= sizeof (STATUS)) {
    return 0;
  }
  
  projects[i]->status = stat;
  catch_status_change (id, stat);
}  


int query_status (string id) {
  int i = find_project (id);
  
  if (i == -1) {
    return 0;
  }
  
  return projects[i]->status;
}


string query_all_projects_info() {
  string ret = "";
  
  foreach (class project p in projects) {
    ret += parse_details (p);    
  }
  
  
  return ret;          
}

string* query_project_tasks (string id) {
  int i = find_project (id);
  
  if (i == -1) {
    return 0;
  }
  
  return map (projects[i]->tasks, (: $1->id :));
}

string* query_project_notes (string id) {
  int i = find_project (id);
  
  if (i == -1) {
    return 0;
  }
  
  if (!sizeof (projects[i]->notes)) {
    return 0;
  }
  
  return map (projects[i]->notes, (: $1->id :));
}

string* query_project_domains (string id) {
  int i = find_project (id);
  
  if (i == -1) {
    return 0;
  }
  
  return projects[i]->domains;
}


int set_description (string id, string desc) {
  int i = find_project (id);
  
  if (i == -1) {
    return 0;
  }
  
  projects[i]->description = desc;
  return 1;
}


string query_description (string id) {
  int i = find_project (id);
  
  if (i == -1) {
    return 0;
  }
  
  return projects[i]->description;
}

int set_status_change(string id, int time) {
  int i = find_project (id);
  
  if (time) {
    projects[i]->last_status_change = time;
  }
  
}

string project_info (string id) {
  int i = find_project (id);
  string ret = "";
    
  if (i == -1) {
    return "There is no project with that ID.\n";
  }
  
  
  ret += sprintf ("\n$I$5=Project %s (%s) belongs to the %s %s.\n", 
    id, projects[i]->name, query_multiple_short 
      (projects[i]->domains), (sizeof(projects[i]->domains) == 1 ?
      "domain" : "domains"));
  if (sizeof (projects[i]->description)) {
    ret += sprintf ("$I$5=Project %s has the following description: \n", 
      id, projects[i]->description);
  }        
  ret += sprintf ("$I$5=Project %s is %s percent complete.\n", 
    id, query_num (query_project_completeness (id)));
  ret += sprintf ("$I$5=Project %s has a project leader of: %s.\n",
    id, projects[i]->leader);
  ret += sprintf ("$I$5=Project %s has the following assigned creators:  %s.\n", 
    id, query_multiple_short (projects[i]->creators));
  ret += sprintf ("$I$5=Project %s is currently: in %s.\n", 
    id, STATUS[projects[i]->status]);
  ret += sprintf ("$I$5=Project %s was added at: %s by %s.\n",
    id, ctime (projects[i]->date_added), projects[i]->added_by);

  if (sizeof (projects[i]->twiki)) {
    ret += sprintf ("$I$5=Project %s has the following twiki pages: %s.\n", 
      id, query_multiple_short (projects[i]->twiki));
  }

  if (sizeof (projects[i]->tasks)) {  
    ret += sprintf ("$I$5=Project %s has the following tasks: %s.\n", 
      id, query_multiple_short (query_project_tasks (id)));
  }
  
  if (projects[i]->estimated_completion) {
    
    ret += sprintf ("$I$5=Project %s will be completed by the estimated date "
      "of: %s.\n", id, ctime (projects[i]->estimated_completion));
  }
  
//  if (file_name(previous_object())[0..3] == "/www" ) {
    ret = replace (ret, ({"$I$5=", "<p>"}));
//  }
  
  return ret;        
}

string task_info (string id, string task_id) {

  int i = find_project (id);
  int j;
  string ret = "";
    
  if (i == -1) {
    return "There is no project with that ID.\n";
  }
  
  j = find_task (i, task_id);
  
  if (j == -1) {
    return "There is no task with that ID for project " + id + ".\n";
  }
  
  ret += sprintf ("Project %s:  task %s.\n", id, task_id);
  ret += sprintf ("task %s is %s percent complete.\n", 
    task_id, query_num (projects[i]->tasks[j]->percent_complete));
  ret += sprintf ("task %s has the following assigned creators:  %s.\n", 
    query_multiple_short (projects[i]->tasks[j]->assigned_to));
  
  return ret;
}

int set_project_completeness (string id, int percent) {
  int i = find_project (id);
  
  if (i == -1) {
    return -1;
  }
  
  projects[i]->percent_complete = percent;
}

int set_project_name (string id, string name) {
  int i = find_project (id);
  
  if (i == -1) {
    return 0;
  }
  
  projects[i]->name = name;
}

string query_project_name (string id) {
  int i = find_project (id);
  
  if (i == -1) {
    return 0;
  }
  
  return projects[i]->name;
}


int query_project_completeness (string id) {
  int i = find_project(id);
  int percent = 0;
  int counter = 0;
  string p;
  
  if (i == -1) {
    return 0;
  }
  
  if (projects[i]->percent_complete) {
    return projects[i]->percent_complete;
  }
  
  if (!sizeof (projects[i]->tasks)) {
    return 0;
  }
  
  if (sizeof (projects[i]->sub_projects)) {
    foreach (p in projects[i]->sub_projects) {
      if (p == id) {
        continue;
      }
      
      percent += query_project_completeness (p);
      counter++;
    }
    
  }
  
    
  foreach (class task bing in projects[i]->tasks) {
      if (!intp (bing->percent_complete)) {
        bing->percent_complete = to_int (bing->percent_complete);
      }
      
      percent += bing->percent_complete;
      counter++;
  }
  
  return percent / counter;
}

int update_project_task_completeness (string id, string task, int percent) {
  int i = find_project (id);
  int j;
  
  if (i == -1) {
    return -1;
  }
  
  j = find_task (i, task);
  
  if (j == -1) {
    return -1;
  }
  
  projects[i]->tasks[j]->percent_complete = percent;
}

int assign_project_task_creator (string id, string task, string creator) {
  int i = find_project (id);
  int j;
  string *cres;
  
  if (i == -1) {
    return -1;
  }
  
  j = find_task (i, task);
  
  if (j == -1) {
    return -1;
  }
  
  cres = projects[i]->tasks[j]->assigned_to;
  
  if (!sizeof (cres)) {
    cres = ({ creator });
  }
  else {
    cres += ({ creator });
  }
  
  projects[i]->tasks[j]->assigned_to = cres;
  
  if (member_array (creator, projects[i]->creators) == -1) {
    add_creator (id, creator);
  }
  
  return 1;
}

int add_task_to_project (string id, string task_id, string name, string aim) {
  int i = find_project (id);
  int j;
  class task tmp;
  
  if (i == -1) {
    return 0;
  }
  
  j = find_task (i, task_id);
  
  if (j != -1) {
    return 0;
  }
  
  tmp = new (class task, id: task_id, added_by: name, 
    date_added: time(), aims: aim);
  
  touch_project (id, "Added task " + task_id, name);
  return insert_into_tasks (i, tmp);  
}

int add_note_to_project (string id, string note_id, string note, string name) {
  int i = find_project (id);
  int j;
  class note tmp;
  
  if (i == -1) {
    return 0;
  }
  
  j = find_note (i, note_id);
  
  if (j != -1) {
    return 0;
  }
  
  tmp = new (class note, id: note_id, note: note, added_by: name, 
    date_added: time());
  
  touch_project (id, "Added note " + note_id, name);
  return insert_into_notes (i, tmp);  
}


int set_task_name (string id, string task_id, string name) {
  int i = find_project (id);
  int j;
  
  if (i == -1) {
    return 0;
  }
  
  j = find_task (i, task_id);
  
  if (j == -1) {
    return 0;
  }
  
  projects[i]->tasks[j]->task_name = name;
  
  return 1;  
}

int set_task_aims (string id, string task_id, string aims) {
  int i = find_project (id);
  int j;
  
  if (i == -1) {
    return 0;
  }
  
  j = find_task (i, task_id);
  
  if (j == -1) {
    return 0;
  }
  
  projects[i]->tasks[j]->aims = aims;
  
  return 1;  
}

string query_task_aims (string id, string task_id) {
  int i = find_project (id);
  int j;
  
  if (i == -1) {
    return 0;
  }
  
  j = find_task (i, task_id);
  
  if (j == -1) {
    return 0;
  }
  
  return projects[i]->tasks[j]->aims;
  }


string query_task_name (string id, string task_id) {
  int i = find_project (id);
  int j;
  
  if (i == -1) {
    return 0;
  }
  
  j = find_task (i, task_id);
  
  if (j == -1) {
    return 0;
  }
  
  return projects[i]->tasks[j]->task_name;
  
}  

class task* project_task_data (string id) {
  int i = find_project (id);
  
  if (i == -1) {
    return ({ });
  }
  
  return projects[i]->tasks;
}

class note* project_note_data (string id) {
  int i = find_project (id);
  
  if (i == -1) {
    return ({ });
  }
  
  return projects[i]->notes;
}



int set_task_comments (string id, string task_id, string comments) {
  int i = find_project (id);
  int j;
  
  if (i == -1) {
    return 0;
  }
  
  j = find_task (i, task_id);
  
  if (j == -1) {
    return 0;
  }
  
  projects[i]->tasks[j]->comments = comments;
  
  return 1;  
}

string query_task_comments (string id, string task_id) {
  int i = find_project (id);
  int j;
  
  if (i == -1) {
    return 0;
  }
  
  j = find_task (i, task_id);
  
  if (j == -1) {
    return 0;
  }
  
  return projects[i]->tasks[j]->comments;
  
}  

int add_task_creator (string id, string task_id, string creator) {
  int i = find_project (id);
  int j;
  
  if (i == -1) {
    return 0;
  }
  
  j = find_task (i, task_id);
  
  if (j == -1) {
    return 0;
  }

  if (!sizeof (projects[i]->tasks[j]->assigned_to)) {
    projects[i]->tasks[j]->assigned_to= ({ creator });
  }
  else {
    projects[i]->tasks[j]->assigned_to+= ({ creator });
  }
    
  return 1;  
}

string* query_task_creators (string id, string task_id) {
  int i = find_project (id);
  int j;
  
  if (i == -1) {
    return 0;
  }
  
  j = find_task (i, task_id);
  
  if (j == -1) {
    return 0;
  }
  
  return projects[i]->tasks[j]->assigned_to;
  
}  

int set_task_completion (string id, string task_id, int percent) {
  int i = find_project (id);
  int j;
  
  if (i == -1) {
    return 0;
  }
  
  j = find_task (i, task_id);
  
  if (j == -1) {
    return 0;
  }

  projects[i]->tasks[j]->percent_complete = percent;
      
  return 1;  
}

int query_task_competion (string id, string task_id) {
  int i = find_project (id);
  int j;
  
  if (i == -1) {
    return 0;
  }
  
  j = find_task (i, task_id);
  
  if (j == -1) {
    return 0;
  }
  
  return projects[i]->tasks[j]->percent_complete;
  
}  

int set_task_completion_date(string id, string task_id, int date) {
  int i = find_project (id);
  int j;
  
  if (i == -1) {
    return 0;
  }
  
  j = find_task (i, task_id);
  
  if (j == -1) {
    return 0;
  }

  projects[i]->tasks[j]->completion_date = date;
      
  return 1;  
}

int query_task_completion_date (string id, string task_id) {
  int i = find_project (id);
  int j;
  
  if (i == -1) {
    return 0;
  }
  
  j = find_task (i, task_id);
  
  if (j == -1) {
    return 0;
  }
  
  return projects[i]->tasks[j]->completion_date;
  
}

class project* filter_by_query (mapping query) {
  string tmp_str, *tmp_arr;
  int match, unassigned = 0;
  class project *tmp = ({ });
  string *un = ({"unassigned", "none", "no-one", "noone", "nobody"});

  if (member_array (query["creators"], un) != -1) {
    unassigned = 1;
  }
      
  foreach (class project p in projects) {
    
    match = 0;

    tmp_str = query ["projid"];
    
    if (sizeof (tmp_str)) {
      if (p->id == query["projid"]) {
        match = 1;
      }
      else {
        continue;
      }
    }
    
    tmp_str = query ["domains"];
  
    if (sizeof (tmp_str)) {      
      tmp_arr = explode (replace (tmp_str, ({" ", ""})), ",");
      
      if (sizeof (map (tmp_arr, (: lower_case ($1) :)) 
        & map (p->domains, (: lower_case ($1) :))) == sizeof (tmp_arr)) {
        match = 1;
      }
      else {
        continue;
      }
      
    }
    
    tmp_str = query["creators"];

    if (sizeof (tmp_str)) {      
      
      tmp_arr = explode (replace (tmp_str, ({" ", ""})), ",");
      
      if (sizeof (map (tmp_arr, (: lower_case ($1) :)) 
        & map (p->creators, (: lower_case ($1) :))) == sizeof (tmp_arr)) {
        match = 1;
      }
      else if (unassigned && !sizeof (p->creators)) {
        match = 1;
      }
      
      else {
        continue;
      }      
    }
       
    if (sizeof (query["status"])) {
     
      if (query["status"] == "all") {
        match = 1;
      }
      else if (p->status == member_array (query["status"], STATUS)) {
        match = 1;
      }
      else {
        continue;
      }
    }
    
    if (sizeof (query["leader"])) {
      if (lower_case (p->leader) == lower_case (query["leader"])) {
        match = 1;
      }
      else {
        continue;
      }      
    }
    
    
    if (query["touched"]) {
      if (p->last_touched > time() - query["touched"] ) {
        match = 1;
      }
      else {
        continue;
      }
    }  

    if (query["completeness"]) {
      if (query_project_completeness (p->id) 
        >= to_int (query["completeness"])) {
        match = 1;
      }
      else {
        continue;
      }
    }  
    
    tmp_str = query["playtesters"];

    if (sizeof (tmp_str)) {      
      
      tmp_arr = explode (replace (tmp_str, ({" ", ""})), ",");
      
      if (sizeof (tmp_arr & p->playtesters) == sizeof (tmp_arr)) {
        match = 1;
      }      
      else {
        continue;
      }      
    }    
    
    if (match) {
      tmp += ({ p });
    }
        
  }
  
  return tmp;        
}


class task* filter_tasks_by_query (string id, mapping query) {
  string tmp_str, *tmp_arr;
  int match, i, j;
  class task *tmp = ({ });
  
  i = find_project (id);
  
  if (i == -1) {
    return 0;
  }
  
  
  foreach (class task p in projects[i]->tasks) {
    
    match = 0;
    
    tmp_str = query["creators"];

    if (sizeof (tmp_str)) {      
      
      tmp_arr = explode (replace (tmp_str, ({" ", ""})), ",");
      
      if (sizeof (tmp_arr & p->assigned_to) == sizeof (tmp_arr)) {
        match = 1;
      }
      else {
        continue;
      }      
    }
       
    if (sizeof (query["completed"])) {

      j = to_int (query["completed"]);
      
      if (p->percent_complete > j) {           
        match = 1;
      }
      else {
        continue;
      }
    }
    
    if (match) {
      tmp += ({ p });
    }
        
  }
  
  return tmp;        
}


class project get_project_file (string id) {
  int i = find_project (id);
  
  if (i == -1) {
    return 0;
  }
  
  return projects[i];
}



void set_project_file (string id, class project tmp, string name) {
  int i = find_project (id);
  
  
  if (i == -1) {
    return 0;
  }
  
  projects[i] = tmp;
  touch_project (id, "Updated project file", name);
  catch_status_change (id, tmp->status);
}

class project* data_dump() {
  mapping dom_proj = ([ ]);   
  string d; 
  class project *tmp = ({ });
  string *dom;
  
  
  foreach (class project p in projects) {
    foreach (d in p->domains) {      
      if (undefinedp (dom_proj [d])) {
        dom_proj [d] = ({ p });
      }
      else {
        dom_proj [d] += ({ p });
      }      
    }
  }
  
  
  dom = sort_array (keys (dom_proj), 1);
  
  foreach (d in dom) {
    tmp += dom_proj[d];
  }
  
  
  return uniq_array (tmp);

}

class task get_task_file (string id, string t) {
  int i = find_project (id);
  int j;
  
  if (i == -1) {
    return 0;
  }
  
  j = find_task (i, t);
  
  if (j == -1) {
    return 0;
  }
    
  return projects[i]->tasks[j];
}

void set_task_file (string id, string t, class task tmp, string name) {
  int i = find_project (id);
  int j;
  
  if (i == -1) {
    return 0;
  }
  
  j = find_task (i, t);
  
  if (j == -1) {
    return 0;
  }
    
  projects[i]->tasks[j] = tmp;
  touch_project (id, "Updated task " + t, name);

}

class note get_note_file (string id, string t) {
  int i = find_project (id);
  int j;
  
  if (i == -1) {
    return 0;
  }
  
  j = find_note (i, t);
  
  if (j == -1) {
    return 0;
  }
    
  return projects[i]->notes[j];
}

void set_note_file (string id, string t, class note tmp, string name) {
  int i = find_project (id);
  int j;
  
  if (i == -1) {
    return 0;
  }
  
  j = find_note(i, t);
  
  if (j == -1) {
    return 0;
  }
    
  projects[i]->notes[j] = tmp;
  touch_project (id, "Updated note " + t, name);

}


int is_creator_on_project (string name, string id) {
  int i = find_project (id);
  
  if (i == -1) {
    return 0;
  }
  
  if (member_array ("all", projects[i]->creators) != -1) {
    return 1;
  }
  
  if (member_array (name, projects[i]->creators) != -1) {
    return 1;
  }
  
  return 0;
}

varargs int valid_operation (string name, string action, string project, 
  string* dom) {  
  object ob;
  string *domains;
  int i = find_project (project);
  int j;
    
  if (master()->high_programmer (name)) {
    return 1;
  }
  
  if (name == "drakkos") {
    return 1;
  }  
    
  if (i != -1) {
    domains = query_project_domains (project);
  }
  else if (dom) {
    domains = dom;
  }
  
  if (is_creator_on_project (name, project)) {
    return 1;
  }
  
  if (action == PLAYTESTING) {
    ob = find_object ("/d/playtesting/master");
    
    if (ob->query_lord() == name) {
      return 1;
    }
    
    if (ob->query_deputy (name)) {
      return 1;
    }
          
  }
  
  if (!sizeof (domains)) {
    return 0;
  }
  
  foreach (string d in domains) {
    ob = find_object ("/d/" + d + "/master");


    if (function_exists (CALLBACK, ob)) {
      j = call_other (ob, CALLBACK, name, action, project);
      if (j != -1) {
        return j;
      }
      
    }
  
    if (ob->query_lord() == name) {
      return 1;
    }
  
    if (ob->query_deputy (name) && action != PLAYTESTING) {
      return 1;
    }
  }
    
  if (action == PROJECT) {
    return 1;
//    return (lower_case (name) == lower_case (query_project_leader (project)));
    return sizeof (filter (domains, (: 
      find_object ("/d/" + $1 + "/master")->query_member ($(name)) :)));
  }
  
  if (action == TASK || action == NOTE) {
    return is_creator_on_project (name, project);
  }
  
  return 0;  
}


void catch_status_change (string id, int status) {
  
  object ob;
  int i = find_project (id);
    
  foreach (string d in projects[i]->domains) {
    ob = load_object ("/d/" + d + "/master");
    
    if (!ob) {
      continue;
    }
      
    if (function_exists ("project_status_change", ob)) {
      ob->project_status_change (id, status);
    }
  }
    
  if (status == member_array ("play", STATUS)) {
    WHATWHAT->add_project (projects[i]->name, projects[i]->domains,
      projects[i]->creators, projects[i]->description, "play");
  }
  
  if (status != member_array ("playtesting", STATUS)) {
    clear_playtesting_projects (projects[i]->playtesters);
    projects[i]->playtesters = ({ });
    save_file();
  }
  projects[i]->last_status_change = time();
  
}

int assign_playtesters (string id, string *pt, string name) {
  int i = find_project (id);
  
  if (i == -1) {
    return 0;
  }

  pt = map(pt, (: lower_case ($1) :));  
  pt = filter (pt, (: PLAYTESTER_HAND->query_playtester ($1) :));
  
  projects[i]->playtesters = pt;
  save_file();
  foreach (string p in pt) {
    if (pt_assignment_cache [p]) {
      map_delete (pt_assignment_cache, p);
    }
  }
  
  return 1;
  
  
}

string* add_playtester (string id, string *pt) {
  int i = find_project (id);
  string *names;
  
  if (i == -1) {
    return 0;
  }

  pt = map(pt, (: lower_case ($1) :));  
  pt = filter (pt, (: PLAYTESTER_HAND->query_playtester ($1) :));
  
  names = projects[i]->playtesters;
  
  projects[i]->playtesters = uniq_array (names += pt);
  clear_playtesting_projects (pt);

  save_file();
  do_mail (pt, projects[i]->id);
  return pt;
}

int remove_playtester (string id, string *pt) {
  int i = find_project (id);
  
  if (i == -1) {
    return 0;
  }

  pt = map(pt, (: lower_case ($1) :));  
  
  projects[i]->playtesters -= pt;
  clear_playtesting_projects (pt);

  save_file();
  return 1;
}


void do_load_tmp() {
  unguarded ((: restore_object, TMP_SAVE :));

}


void do_setup() {
  projects = ({ });
  foreach (class project p in tmp_projects) {
    projects += ({ p });
  }
  tmp_projects = ({ });
  do_save();
  
}

int clear_file_cache (string nfile) {
  int i = find_cache_file (nfile);
  
  if (i == -1) {
    return 0;
  }
  
  cache -= ({ cache[i] });
  
  return 1;
}


int query_permission (string project, string name, string nfile, int access) {
  int i = find_project (project);
  int j;
  string *tasks = ({ });
  class file *tmp = ({ });
    
  if (i == -1) {
    return 0;
  }
  
  if (projects[i]->leader != name && 
    member_array (name, projects[i]->creators) == -1) {
    return 0;
  }
    
  if (projects[i]->leader == name) {
    tasks = map (projects[i]->tasks, (: $1->id :));
    tasks += ({"leader"});
  }
  else {
    tasks = map (filter (projects[i]->tasks, (: member_array ($(name), 
      $1->assigned_to) != -1 :)), (: $1->id :));
  }
    
  tasks += ({""});

  foreach (string t in tasks) {   
    tmp += find_file (i, nfile, t);
  }
  
  if (!sizeof (tmp)) {
    return 0;
  }
   
  tmp = uniq_array (tmp);    
  
  foreach (class file f in tmp) {
    j = find_cache_file (f->file);
    
    if (j == -1) {
      j = add_cache_file (f->file);
    }
    
    
    if (!sizeof (f->task)) {
      if (f->access == access) {
        if (cache[j]->accesses[name] < access) {
          cache[j]->accesses[name] = access;
        }
        return 1;
      }
      
    }
    else if (member_array (f->task, tasks) != -1) {
        if (f->access == access) {
          if (cache[j]->accesses[name] < access) {
            cache[j]->accesses[name] = access;
          }
          
          return 1;
        }
        
    }
  }
  
  return 0;      
}

int nuke_creator_project_cache(string *creators) {
  
  if (!creator_project_cache) {
    return 0;
  }
  
  foreach (string c in creators) {
    map_delete (creator_project_cache, c);
    return 1;
  }
}



int query_file_permission (string name, string nfile, int access) {
  string *a_projects = query_projects_for_creator (name);
  int i, j, k, l = 0;
  
  if (!sizeof (a_projects)) {
    return 0;
  }

  j = find_cache_file (nfile);
    
  if (j != -1 ) {
    k = cache[j]->accesses[name];
    
    if (k == -1) {
      return 0;
    }
    
    if (k >= access) {
      return 1;
    }
  }
        
  foreach (string p in a_projects) {
    
    i = query_permission (p, name, nfile, access);
 
    if (!l && i) {
      l = 1;
    }
    
  }
    
  return l;
    
}


void set_project_lock (string project) {
  project_locks[project] = time();
}

int query_project_lock (string project) {
  if (project_locks[project] + PROJECT_LOCK > time()) {
    return 1;
  }
  
  map_delete (project_locks, project);
  return 0;
}

string generate_pt_report() {
  string *new_cache = ({ });
  string missing_projects = "";
  string ret = "";
  string *det = ({ });
  string project_list = "";
  string tmp;
  string post = "";
  int i;
  class project *in_pt = ({ });
  class project *out_pt = ({ });
  class project *new_pt = ({ });
  string *del = ({ });
 
  class project *playtesting = filter_by_query ((["status": "playtesting"]));
  


  foreach (class project p in playtesting) {
      new_cache += ({ p->id });
      if (member_array (p->id, pt_post_cache) == -1) {
        new_pt += ({ p });
      }
      else {
        in_pt += ({ p });
      }
    }
    
  if (sizeof (pt_post_cache)) {
    foreach (string id in pt_post_cache) {
      if (member_array (id, new_cache) == -1) {
        i = find_project (id);
        if (i == -1) {
          del += ({ id });
        }
        else {
          out_pt += ({ projects[i] });
        }
      }
    }
  }    
  
  if (sizeof (new_pt)) {  
    ret += "The following projects have entered playtesting:\n\n";
    foreach (class project p in new_pt) {
      det = ({ });
      det += ({sprintf ("*  %s (%s): %s.\n   Description: %s\n   "
        "Project leader: %s.\n   "
        "Creators: %s.\n   Notes: %s.\n", p->id, p->name, 
          query_multiple_short (p->domains), (p->description ? replace 
            (p->description, ({"\n", ""})) : 
          "None"), (p->leader ? p->leader : 
          "No-one"), (p->creators ? query_multiple_short (p->creators) :
          "None"), (sizeof (p->pt_notes) ? replace (p->pt_notes, 
          ({"\n", ""})) : "None")) });
          
      ret += implode (det, "\n\n");          
    } 
    ret += "\n\n";
  }      
  
  if (sizeof (in_pt)) {  
    ret += "The following projects are still in playtesting:\n\n";
    det = ({ });
    foreach (class project p in in_pt) {
      det += ({sprintf ("*  %s (%s): %s.", p->id, p->name, 
        query_multiple_short (p->domains)) });          
    } 
    ret += implode (det, "\n");    
    ret += "\n\n";      
  }   

  if (sizeof (out_pt)) {  
    det = ({ });
    ret += "The following projects have been removed from playtesting:\n\n";
    foreach (class project p in out_pt) {
      det += ({sprintf ("*  %s (%s): %s.", p->id, p->name, 
        STATUS[p->status]) });
          
    } 
    ret += implode (det, "\n\n");          
    ret += "\n\n";
  }    
  
  if (sizeof (del)) {    
    ret += "The following projects have been deleted from the handler:\n\n";
    foreach (string d in del) {
      det += ({sprintf ("*  %s.", d) });
    }
    ret += implode (det, "\n\n");        
    ret += "\n\n";
  }
  
  pt_post_cache = new_cache;  
    
  if (!sizeof (ret)) {
    ret= "Wow, absolutely nothing is officially in playtesting at the "
      "moment.  You can all have the week off.\n\n";
  }
  else {
    ret += "Remember that you can use the 'playtesting' command for more "
      "information on projects that are currently in playtesting.\n\n";
  }
    
  
  return ret;
     
      
}  

int make_post() {
  int ret;

  ret = BOARD_HAND->add_message("ptforum",
         "The Project Tracker", "What's in Playtesting?",
         generate_pt_report() +
         TWIKI_HANDLER->find_changes_in_database("Playtesters", last_summary));

  last_summary = time();
  save_file();    
}

string* query_pt_cache() {
  return pt_post_cache;
}

string* query_pt_projects (string name) {
  class project *tmp;

  if (!undefinedp (pt_assignment_cache [name])) {
    return pt_assignment_cache [name];
  }
    
  tmp = filter_by_query ((["playtesters" : name ]));
  
  if (!tmp) {
    pt_assignment_cache[name] = ({ });
  }
  else {
    pt_assignment_cache[name] = map (tmp, (: $1->id :));
  }
  
  return pt_assignment_cache[name];
}


int query_number_of_pts (mixed proj) {
  int i;
  int t;
  
  if (!intp (proj)) {
    i = find_project (proj);
  }
  else {
    i = proj;
  }
  
  if (i == -1) {
    return -1;
  }  

  switch (projects[i]->size) {
    case 0:
      t = 2;
    break;
    case 1:
      t = 3;
    break;
    case 2:
      t = 4;
    break;
    case 3:
      t = 5;
    break;
    case 4:
      t = 6;
    break;
    case 5:
      t = 8;
    break;
    case 6:
      t = 0;
    break;
    default:
      t = 2;
    break;
  }  

  return t;
}

int next_rotation_time(mixed proj) {
  int i, t;
  
  if (!intp (proj)) {
    i = find_project (proj);
  }
  else {
    i = proj;
  }

  if (i == -1) {
    return -1;
  }

  if (projects[i]->complexity == member_array ("special", COMPLEXITY)) {
    return 0;
  }
    
  switch (projects[i]->size) {
    case 0:
      t = WEEK;
    break;
    case 1:
      t = WEEK * 2;
    break;
    case 2:
      t = WEEK * 2;
    break;
    case 3:
      t = WEEK * 4;
    break;
    case 4:
      t = WEEK * 4;
    break;
    case 5:
      t = WEEK * 6;
    break;
    case 6:
      t = WEEK * 6;
    default:
      t = WEEK;
  }  
 
  if (!projects[i]->current_rotation) {
    projects[i]->last_rotation = time();
    projects[i]->current_rotation = 1;
    save_file();
  }
  
  return projects[i]->last_rotation + t;
}

int query_time_to_rotate (mixed proj) {
  int i;
  
  i = next_rotation_time(proj);
      
  if (i < time()) {
    return 1;
  }
  else {
    return 0;
  }
}
      
int query_number_rotations(mixed proj) {
  int i ;

  if (!intp (proj)) {
    i = find_project (proj);
  }
  else {
    i = proj;
  }
    
  if (i == -1) {
    return -1;
  }
  
  if (projects[i]->complexity == member_array ("special", COMPLEXITY)) {
    return projects[i]->current_rotation + 1;
  }
  return projects[i]->complexity + 2;
}

int query_rotation (mixed proj) {
  int i = (!intp (proj) ? find_project (proj) : proj);  
  
  if (i == -1) {
    return 0;
  }
  
  return projects[i]->current_rotation;
}

string* query_playtesters (mixed proj) {
  int i = (!intp (proj) ? find_project (proj) : proj);  
  
  if (i == -1) {
    return 0;
  }
  
  return projects[i]->playtesters;
}



int set_complexity (mixed proj, int com) {
  int i = (!intp (proj) ? find_project (proj) : proj);  
  
  if (i == -1) {
    return 0;
  }
  
  projects[i]->complexity = com;
  return 1;
}

int set_size(mixed proj, int siz) {
  int i = (!intp (proj) ? find_project (proj) : proj);  
  
  if (i == -1) {
    return 0;
  }
  
  projects[i]->size = siz;
  return 1;
}

int query_size(mixed proj) {
  int i = (!intp (proj) ? find_project (proj) : proj);  
  
  if (i == -1) {
    return 0;
  }
  
  return projects[i]->size;
}



int set_guild_specific (mixed proj, string *guilds) {
  int i = (!intp (proj) ? find_project (proj) : proj);  
  
  if (i == -1) {
    return 0;
  }
  
  projects[i]->guild_specific = guilds;
  return 1;
}

string *query_guild_specific(mixed proj) {
  int i = (!intp (proj) ? find_project (proj) : proj);  
  
  if (i == -1) {
    return 0;
  }
  
  return projects[i]->guild_specific;

}

int clear_playtesting_projects (string *names) {
  foreach (string v in names) {
    if (pt_assignment_cache[v]) {
      map_delete (pt_assignment_cache, v);
    }

    if (!num_assignments[v]) {
      num_assignments[v] = 1;
    }
    else {
      num_assignments[v] += 1;
    }
  }  
  save_file();
}

class project* get_playtesting_projects () {
  class project *tmp;
  
  tmp = filter_by_query ((["status": "playtesting"]));
   
  return tmp;
}

void set_rotations (string proj, int rot) {
  int i = find_project (proj);
  
  if (i == -1) {
    return;
  }
  
  projects[i]->current_rotation = rot;
}

string* assign_pts_to_project (mixed proj) {
  int i = (!intp (proj) ? find_project (proj) : proj);
  int needed, tmp;
  int min = sizeof (projects) + 1, max = -1;
  mapping guilds;
  mapping tmp_assign_cache = ([ ]);
  string tpt;
  string *valid = ({ });
  string *selected = ({ });
  string *virgins = ({ });
  string *ordered = ({ });
  string *last = ({ });
  string *nvalid = ({ });
  string *unassigned = ({ });
  string *assigned = ({ });
  
  
  if (i == -1) {
    return 0;
  }


  if (projects[i]->size != member_array ("special", SIZE)) {
    needed = query_number_of_pts (proj);
  }
  else {
    return ({ });
  }  
  
  if (sizeof (projects[i]->guild_specific)) {
    guilds = PLAYTESTER_HAND->query_guilds();
    
    foreach (string g in projects[i]->guild_specific) {
      foreach (string name, string gu in guilds) {
        if (load_object (gu)->query_name() == g) {
          valid += ({ name });
        }
      }      
    }
  }
  else {
    valid = PLAYTESTER_HAND->query_playtesters();
  }

  
  foreach (string v in valid) {
    if (!sizeof (query_pt_projects (v))) {
      unassigned += ({ v });
    }
    else {
      assigned += ({ v });
    }
  }
  
  if (sizeof (unassigned) >= needed) {
    valid = unassigned;
  }
  else {
    valid = unassigned;
    while (sizeof (valid) < needed) {
      tmp = random (sizeof (assigned));
      valid += ({ assigned[tmp] });
      assigned -= ({ assigned[tmp] });
    }
  }
    
  foreach (string va in valid) {
    if (member_array (lower_case (va), excluded) != -1) {
      nvalid += ({ va });
    }
    if (PLAYTESTER_HAND->query_leave (va)) {
      nvalid += ({ va });
    }
  }

  valid -= nvalid;  
  virgins = valid - (projects[i]->last_pt_cohort ? projects[i]->last_pt_cohort : ({ }));
  
  if (sizeof (projects[i]->last_pt_cohort)) {
    clear_playtesting_projects (projects[i]->last_pt_cohort);
  }
  last = projects[i]->last_pt_cohort;
  projects[i]->last_pt_cohort = ({ });
  projects[i]->last_rotation = time();


  foreach (string v in valid) {
    tmp_assign_cache[v] = sizeof (query_pt_projects (v)) + num_assignments[v];    
  }
  
  foreach (string pt, int val in tmp_assign_cache) {
    if (val < min) {
      min = val;
    }
    if (val > max) {
      max = val;
    }
  }
      
  for (int v = min; v <= max; v++) {
    ordered = ({ });
    
    foreach (string pt, int val in tmp_assign_cache) {
      if (val == v) {
        ordered += ({ pt });
      }        
    }
     
    if ((sizeof (selected) + sizeof (ordered))  >= needed) {
      do {
        tpt = ordered[random(sizeof(ordered))];
        selected += ({ tpt });
        ordered-= ({ tpt });
      } while (sizeof (selected) < needed);
      projects[i]->playtesters = selected;
      save_file();
      if (!last) {
        last = ({ });
      }
      clear_playtesting_projects ((selected ? selected : ({ })) + (last? last : ({ })));
      do_mail (selected, projects[i]->id);         
      return selected;      
    }    
    else {
      selected += ordered;
    }
  }
  
  valid = uniq_array (valid);
  
  projects[i]->last_pt_cohort = projects[i]->playtesters;
  if (sizeof (projects[i]->playtesters)) {
    if (sizeof (projects[i]->all_pts)) {
      projects[i]->all_pts += ({ projects[i]->playtesters });
    }
    else {
      projects[i]->all_pts = ({ projects[i]->playtesters });
    }
    
  }
  
  projects[i]->playtesters = selected;
    
  clear_playtesting_projects ((selected ? selected : ({ })) + (last? last : ({ })));
  
  do_mail (selected, projects[i]->id);
  
  save_file();
  return selected;       
}

void rotate_project (mixed tmp) {
  int i;
  
  if (intp (tmp)) {
    i = tmp;
  }
  else {
    i = find_project (tmp);
  }
  
  if (projects[i]->current_rotation == query_number_rotations (i)) {
    // Set it to Limbo
    AUTO_MAILER->auto_mail( "drakkos", "The Playtester Wheel Of Fate", 
      "Your project in playtesting", projects[i]->leader, 
      "Bing!\n\nThe project " + projects[i]->id + " has reached the end of "
      "its automatic playtesting lifetime and has been put back into a state "
      "of limbo.  If you wish for the project to continue in playtesting, then "
      "please set the project back into playtesting and give Drakkos a nudge!\n\n"
      "Thx bye,\nThe Playtester Wheel Of Fate.\n", 0, 0, 1 );       
    
    AUTO_MAILER->auto_mail( "drakkos", "The Playtester Wheel Of Fate", 
      "Your project in playtesting", implode (projects[i]->playtesters, ","), 
      "Bing!\n\nThe project " + projects[i]->id + " has reached the end of "
      "its automatic playtesting lifetime and has been put back into a state "
      "of limbo.  Thank you for your work on the last stage of its current "
      "playtesting phase.\n\n"
      "Thx bye,\nThe Playtester Wheel Of Fate.\n", 0, 0, 1 );             
    set_status(projects[i]->id, 4);
    projects[i]->current_rotation = 0;
    return;
  }
  projects[i]->current_rotation = projects[i]->current_rotation+1;
  projects[i]->last_rotation = time();
  assign_pts_to_project(i);
  
}



void reset() {
  if (!last_summary) {
    last_summary = time();
  }
  
  if ((last_summary + TIME_BETWEEN_POSTINGS) < time()) {
    make_post();
  }
  
  for (int i = 0; i < sizeof (projects); i++) {
    if (projects[i]->status != member_array ("playtesting", STATUS)) {
      continue;
    }
    
    if (query_time_to_rotate (i)) {
      rotate_project (i);
    }
  }
  
}
  

/*

int validate_structure() {
  int i;
  class project_tmp updated;
  
  tmp_projects = ({ });
  
  for (i = 0; i < sizeof (projects); i++) {
      updated = new (class project_tmp);
      updated->id = projects[i]->id;
      updated->name = projects[i]->name;
      updated->leader = projects[i]->leader;
      updated->added_by = projects[i]->added_by;
      updated->description = projects[i]->description;
      updated->pt_notes = "";
      updated->domains = projects[i]->domains;
      updated->creators = projects[i]->creators;
      updated->sub_projects = projects[i]->sub_projects;
      updated->files = ({ });
      updated->last_rotation = 0;
      updated->size = 1;
      updated->complexity = 1;
      updated->current_rotation = 0;
      updated->last_pt_cohort = ({ });
      updated->all_pts = ({ });
      updated->guild_specific = ({ });
      updated->twiki = projects[i]->twiki;
      updated->playtesters = projects[i]->playtesters;
      updated->what_touched = projects[i]->what_touched;
      updated->touched_by = projects[i]->touched_by;
      updated->date_added = projects[i]->date_added;
      updated->date_completed = projects[i]->date_completed;
      updated->status = projects[i]->status;
      updated->percent_complete = projects[i]->percent_complete;
      updated->estimated_completion = projects[i]->estimated_completion;
      updated->last_touched = projects[i]->last_touched;
      updated->last_status_change = time();
      updated->tasks = projects[i]->tasks;
      updated->notes = projects[i]->notes;
    
      tmp_projects += ({ updated });
  }
  
  save_object (TMP_SAVE);
  return 1;
}



int migrate() {
  projects = tmp_projects;
  tmp_projects = ({ });
  save_file();
  return 1;
}

*/

void do_mail (string *playtesters, mixed proj) {
  string text = "Hello!\n\nYou have been assigned to project " +
    proj + " on its latest rotation.  You can use " 
    "'playtesting details " + proj + " to find out more about "
    "the project if neccessary.\n\nRegards,\nThe Playtester Wheel "
    "Of Fate.\n";
  
  AUTO_MAILER->auto_mail( "drakkos", "The Playtester Wheel Of Fate", 
    "Your new playtester assignment", implode (playtesters, ","), 
    text, 0, 0, 1 );        
}


void clear() {
  string *names;
  
  for (int i = 0; i < sizeof (projects); i++) {
    projects[i]->all_pts = ({ });
    projects[i]->last_pt_cohort = ({ });
    projects[i]->playtesters = ({ });    
  }
  
  names = PLAYTESTER_HAND->query_playtesters();
  
  clear_playtesting_projects (names);
  save_file();
  
}

void test_num() {
  printf ("%O\n", pt_assignment_cache);
}// --- END [/mnt/home2/grok/lib/obj/handlers/project_management.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/start_positions.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/start_positions.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628168   Available: 13575522
Inodes: Total: 5242880    Free: 4960134
3669 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/start_positions.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628168   Available: 13575522
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: start_positions.c,v 1.2 2001/06/20 15:27:05 shrike Exp $
 *
 *
 */

#include <login_handler.h>

#define SAVE_FILE "/save/start_position_handler"
#define CHECKED_PROP "checked start positions"

private int _last_added;
private string * _buggy_starts;

/** @ignore */
void load_file() {
   if ( file_size( SAVE_FILE + ".o" ) > 0 ||
        file_size( SAVE_FILE + ".o.gz" ) > 0 )
   {
      unguarded( (: restore_object, SAVE_FILE :) );
   }
} /* load_file() */

/** @ignore */
void save_file() {
   unguarded( (: save_object, SAVE_FILE :) );
} /* save_file() */

/** @ignore */
void create() {
   _last_added = 0;
   _buggy_starts = ({ });

   load_file();

   if ( !_buggy_starts ) {
      _buggy_starts = ({ });
   }
} /* create() */

/**
 * Add a filename to the array of buggy start positions to be removed.
 * Returns 1 if successful, -1 if the start position was already in the
 * list, or 0 for an error.
 * @param fname The filename of the room.  '.c' will be stripped.
 * @return The integer success code.
 */
int add_buggy_start( string fname ) {
   if ( !fname ) {
      return 0;
   }
   fname = lower_case( fname );

   if ( fname[ <2 .. ] == ".c" ) {
      fname = fname[ 0 .. <3 ];
   }

   if ( member_array( fname, _buggy_starts ) != -1 ) {
      return -1;
   }

   _buggy_starts += ({ fname });
   _last_added = time();
   save_file();
   return 1;
} /* add_buggy_start() */

/**
 * Remove a filename from the array of buggy start positions.
 * Returns 1 if successful, -1 if the start position was not in the list,
 * or 0 for an error.
 * @param fname The filename of the room.  '.c' will be stripped.
 * @return The integer success code.
 */
int delete_buggy_start( string fname ) {
   if ( !fname ) {
      return 0;
   }
   fname = lower_case( fname );

   if ( fname[ <2 .. ] == ".c" ) {
      fname = fname[ 0 .. <3 ];
   }

   if ( member_array( fname, _buggy_starts ) == -1 ) {
      return -1;
   }

   _buggy_starts -= ({ fname });
   save_file();
   return 1;
} /* delete_buggy_start() */

/**
 * Get a list of all the currently registered buggy start positions.
 * @return The list of filenames.
 */
string * list_buggy_starts() {
   return copy( _buggy_starts );
} /* list_buggy_starts() */

/**
 * Process a player and remove start positions as required.
 * @param player The player object to check.
 */
void remove_buggy_starts( object player ) {
   string * starts;

   if ( !player ) {
      return;
   }

   starts = copy( player->query_starts() );
   for( int i = 0; i < sizeof( starts ); i += 2 ) {
      if ( member_array( starts[i], _buggy_starts ) != -1 ) {
         player->remove_start( starts[i] );
      }
   }
   player->add_property( CHECKED_PROP, time() );
} /* remove_buggy_starts() */

/**
 * This is the callback function registered with the login handler.  It
 * takes two arguments: the player and the type of login event.  It checks
 * a property on the player so that it doesn't process the list of buggy
 * starts once for each player every single time they log in.
 * @param player the player's name to check.
 * @param type the type of login event, as defined in <login_handler.h>.
 */
void login_callback( string player, string type ) {
   object playerob;

   if ( !player ||
        !type ||
        type != LOGIN )
   {
      return;
   }
   player = lower_case( player );

   if ( !( playerob =  find_player( player ) ) ||
        ( playerob->query_property( CHECKED_PROP ) >= _last_added ) )
   {
      return;
   }

   remove_buggy_starts( playerob );
} /* login_callback() */

/** @ignore */
void dest_me() {
   destruct( this_object() );
} /* dest_me() */
// --- END [/mnt/home2/grok/lib/obj/handlers/start_positions.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/error_tracker.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/error_tracker.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628167   Available: 13575521
Inodes: Total: 5242880    Free: 4960134
399 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/error_tracker.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628167   Available: 13575521
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/dom/error_tracker_master";

void create() {
    set_domain( "mudlib" );
    set_name( "The Mudlib's Lord of the Whinge" );
    set_other_dirs( ({
        "/std%",
        "/obj%",
        "/global%",
        "/cmds%",
        "/mudlib%",
        "/include%",
        "/net%",
        "/soul%",
        "/room%",
        "/www%",
      }) );
    set_period( 604800 );
    ::create();
}
// --- END [/mnt/home2/grok/lib/obj/handlers/error_tracker.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/bits_controller.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/bits_controller.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628166   Available: 13575520
Inodes: Total: 5242880    Free: 4960134
1874 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/bits_controller.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628166   Available: 13575520
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: bits_controller.c,v 1.2 1998/01/06 22:22:10 sin Exp $
 * $Log: bits_controller.c,v $
 * Revision 1.2  1998/01/06 22:22:10  sin
 * made_the_do_update_routine_more_resilient,_added_a_kickstart_routine.
 *
 * Revision 1.1  1998/01/06 05:03:33  ceres
 * Initial revision
 * 
*/
/**
 * Decays all the decable objects in the game.
 * @author Ember
 * @changed 17 Dec 1997 -- Sin
 *    I added a reset_eval_cost() call into the do_update() routine
 *    so that it wouldn't quit when there were a whole bunch of
 *    bits to decay.
 * @changed 6 Jan 1998 -- Sin
 *    I modified the do_update() routine so it'll register a callback
 *    even if one of the bits fails to decay.  That should help prevent
 *    the callout from disappearing.  If it does disappear, I added
 *    a kickstart function.
 * @see /obj/food.c
 * @see /std/bit.c
 * @see /obj/corpse.c
 */
#include <bits_controller.h>
object *bits;

private void do_update();

void create() {
  bits = ({ });
} /* create() */

/**
 * Adds in a decable object into ther decaying array.
 * @param ob the bit to decay
 */
void add_bit(object ob) {
  if (!sizeof(bits))
    call_out( (: do_update() :), TIME_OUT);
  bits += ({ ob });
} /* add_bit() */

/**
 * Removes the decable object from the decaying array.
 * @param ob the bit to remove
 */
void remove_bit(object ob) {
  int i;

  if ((i = member_array(ob, bits)) == -1)
    return ;
  bits = delete(bits, i, 1);
} /* remove_bit() */

private void do_update() {
  int i;

  bits = bits - ({ 0 });
  if (sizeof(bits))
    call_out((: do_update() :), TIME_OUT);
  for (i = sizeof(bits) - 1; i > -1; i--) {
    reset_eval_cost();
    bits[i]->do_decay();
  }
  bits = bits - ({ 0 });
} /* do_update() */

int query_num_bits() { return sizeof(bits); }
object *query_bits() { return bits; }
void kickstart() {
  do_update();
}
// --- END [/mnt/home2/grok/lib/obj/handlers/bits_controller.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/book_handler.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/book_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628166   Available: 13575520
Inodes: Total: 5242880    Free: 4960134
9139 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/book_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628166   Available: 13575520
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This handler object deals with all the books that have been published.
 * It keeps a save file of every book and a current book number.
 * It will allow for easy finding again of preprinted books and for the
 * easy removal of any books that happen to contain things like quest
 * solutions and stuff.
 *
 * @author Pinkfish
 * @started Sun Feb  1 20:24:33 CST 1998
 * @see /std/book.c
 * @see /std/print_shop.c
 */

#include <book_handler.h>
#include <language.h>

#define SAVE_DIR "/save/book_handler/"
#define SAVE_FILE (SAVE_DIR "main_save")

#define OWNER_INDEX "owner"
#define PAGES_INDEX "pages"

int current_book_number;
mapping banished_books;

int compare_page(object page1, object page2);
void load_it();
void save_it();
int check_book_same(object book, int num);
protected string *query_pages(object book);
int compare_pages(string *pages1, string *pages2);
string *query_book_pages(int book_num);

void create() {
   banished_books = ([ ]);
   seteuid(getuid());
   load_it();
} /* create() */

/**
 * This tests to see if the given book number exists.
 * @param book_num the number to test.
 * @return 1 if it exists, 0 if it does not.
 */
int query_book_exists(int book_num) {
   return unguarded((: file_size(SAVE_DIR + $(book_num) + ".o") :)) > 0;
} /* query_book_exists() */

/**
 * Adds a newly minted book into our nice list of stuff.  This returns the
 * book number for this book.  You can use this to add a book if you already
 * know its book number, if it does not match to the saved book number then
 * it will return a new number.  If it does match it will return the
 * same number.
 * @param book the book to add
 * @param num the possible book number it already has
 * @see check_book_same()
 */
int add_book(object book, int num, string pl_name) {
   string *stuff;
   mapping bing;

   if (num) {
      if (check_book_same(book, num)) {
         return num;
      }
   }

   /* Make sure if the save file gets stuffed up we don't overwrite things. */
   while (query_book_exists(current_book_number)) {
      current_book_number++;
   }
   stuff = query_pages(book);
   bing = ([ OWNER_INDEX : pl_name, PAGES_INDEX : stuff ]);
   unguarded( (: write_file(SAVE_DIR + current_book_number + ".o",
              save_variable($(bing))) :) );
   num = current_book_number++;
   save_it();
   return num;
} /* add_book() */

/**
 * Checks to see if the passed in book is the same as the current book
 * number that is set on it.  We only look at the text and ignore the
 * type and language with which it is written.
 * @param book the book to check
 * @param num the book number to check against
 * @see compare_pages()
 * @see add_book()
 */
int check_book_same(object book, int num) {
   string *bing;
   string *fluff;
   int old_open_page;
   int same;

   old_open_page = book->query_open_page();
   same = 0;
   if (query_book_exists(num) > 0) {
      bing = query_book_pages(num);
      fluff = query_pages(book);
      if (compare_pages(bing, fluff) > 90) {
         same = 1;
      }
   } else {
      same = 0;
   }
   book->set_open_page(old_open_page);
   return same;
} /* check_book_same() */

/**
 * This method returns the pages associated with the book of a given
 * number.
 * @return the pages for the book
 * @param book_num the book number to get the pages for
 * @see query_book_owner()
 */
string *query_book_pages(int book_num) {
   mapping bing;
   string tmp;

   tmp = unguarded((: read_file(SAVE_DIR + $(book_num) + ".o") :));
   if (tmp) {
      bing = restore_variable(tmp);
      return bing[PAGES_INDEX];
   }
   return 0;
} /* query_book_pages() */

/**
 * This method returns the owner associated with the book of a given
 * number.
 * @return the owner of the book
 * @param book_num the book number to get the pages for
 * @see query_book_pages()
 */
string query_book_owner(int book_num) {
   mapping bing;
   string tmp;
 
   tmp = unguarded((: read_file(SAVE_DIR + $(book_num) + ".o") :));
   if (tmp) {
      bing = restore_variable(tmp);
      return bing[OWNER_INDEX];
   }
   return 0;
} /* query_book_owner() */

/**
 * This method returns the array of useful pages in a book.  It removes
 * torn out pages and pages which are added by specific things in the
 * game, like the print shop adding a fly leaf.  It just returns the text
 * for the pages, since this is what we are interested in.
 * @param book the book to get the pages from
 * @return the array of pages
 */
string *query_pages(object book) {
   int i;
   string *ret;
   mixed *stuff;
   mixed *group;
   string text;
   int old_open_page;
   object ob;

   ret = ({ });
   old_open_page = book->query_open_page();
   for (i = 0; i < book->query_num_pages(); i++) {
      book->set_open_page(i);
      ob = book->query_current_page();
      /* Make sure it is not torn out and that it is not auto generated. */
      if (!book->is_current_page_torn_out() &&
          !ob->query_property(BH_IGNORE_PAGE)) {
         stuff = ob->query_read_mess();
         text = "";
         foreach (group in stuff) {
            text += group[READ_MESS];
         }
         ret += ({ text  });
      }
   }
   book->set_open_page(old_open_page);
   return ret;
} /* query_pages() */

/**
 * This method will try and figure out the percentage changed between the
 * two page arrays.
 * @param pages1 the first page array
 * @param pages2 the second page array
 * @return the percentage the same
 */
int compare_pages(string *pages1, string *pages2) {
   int no_chars;
   int no_same;
   int pos;
   int start;
   string page;
   string *tmp;

   pos = 0;
   if (sizeof(pages1) > sizeof(pages2)) {
      tmp = pages1;
      pages1 = pages2;
      pages2 = tmp;
   }
   /* Now we go through the smaller array... */
   foreach (page in pages1) {
      /*
       * Ok, now see if we can find where this page might start in the
       * other book.
       *
       * We will assume that all books will start the same.  Therefor
       * if we cannot find a match for the first page...  The rest of the
       * book does not match.  We assume that the one stored in the
       * book handler is the complete one.
       */
      pos = 0;
      do {
         start = strsrch(page, pages2[pos]);
         if (start == -1) {
            start = strsrch(pages2[pos], page);
            if (start == -1) {
               pos++;
            } else {
               no_same += strlen(page);
            }
         } else {
            no_same += strlen(pages2[pos]);
         }
      } while ((start == -1) && (pos < sizeof(pages2)));
      no_chars += strlen(page);
   }

   /* Calculate the percentage the same and return it. */
   if (no_chars > 0) {
      return (no_same * 100) / no_chars;
   }
   return 0;
} /* compare_pages() */

/**
 * Compares the open pages of two books to see if the text is the
 * same.  It ignores language and style of writing.  This would also
 * work on two pieces of paper.
 * @param page1 the first book
 * @param page2 the second book
 * @see check_book_same()
 * @see add_book()
 */
int compare_page(string page1, string page2) {
   mixed *stuff1;
   mixed *stuff2;
   string text1;
   string text2;
   int i;

   stuff2 = page2->query_read_mess();
   text1 = "";
   for (i = 0; i < sizeof(stuff1); i++) {
      text1 += stuff1[READ_MESS];
   }

   text2 = "";
   for (i = 0; i < sizeof(stuff2); i++) {
      text2 += stuff2[READ_MESS];
   }

   return (text1 == text2);
} /* compare_page() */

/**
 * This method banishes a book number for a certain reason.
 * @param book_num the book number to banish
 * @param reason the reason it was banished
 * @return 1 on success and 0 on failure.
 * @see query_banished_book()
 * @see query_all_banished_books()
 */
int add_banished_book(int book_num, string reason) {
   if (!stringp(reason) || !intp(book_num)) {
      /* Need a reason. */
      return 0;
   }
   if (!query_book_exists(book_num)) {
      /* Does not exist. */
      return 0;
   }

   banished_books[book_num] = reason;
} /* banish_book_num() */

/**
 * This method returns the banish string for the book.
 * @param book_num the book number to check
 * @return the banish reason, or 0 if none
 * @see add_banished_book()
 * @see query_all_banished_books()
 */
string query_banished_book(int book_num) {
   return banished_books[book_num];
} /* query_banished_book() */

/**
 * This method returns all the banished books.  The keys are the
 * numbers which are banished and the values are the reason for
 * the banishment.
 * @return the banished books mapping
 * @see add_banished_book()
 * @see query_banished_book()
 */
mapping query_all_banished_books() {
   return banished_books;
} /* query_all_banished_books() */

/**
 * Saves the current state information to the save file.
 * @see save_it()
 */
void save_it() {
   unguarded((: save_object(SAVE_FILE) :));
} /* save_it() */

/**
 * Loads the state information from the save file.
 * @see load_it()
 */
void load_it() {
   unguarded((: restore_object(SAVE_FILE) :));
   if (!current_book_number) {
      current_book_number = 1;
   }
   if (!banished_books) {
      banished_books = ([ ]);
   }
} /* load_it() */
// --- END [/mnt/home2/grok/lib/obj/handlers/book_handler.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/autodoc/autodoc_nroff.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/autodoc/autodoc_nroff.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628163   Available: 13575517
Inodes: Total: 5242880    Free: 4960134
24122 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/autodoc/autodoc_nroff.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628163   Available: 13575517
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: autodoc_nroff.c,v 1.15 2002/07/15 18:50:53 pinkfish Exp $
 * $Log: autodoc_nroff.c,v $
 * Revision 1.15  2002/07/15 18:50:53  pinkfish
 * Fix up the use of the <li> tag.
 *
 * Revision 1.14  2001/08/12 03:57:41  pinkfish
 * Add in some fixes to <dl> mode and add support for underline.
 *
 * Revision 1.13  2001/06/30 10:14:16  pinkfish
 * Fix up the formatting in with the <pre> flags.
 *
 * Revision 1.12  2001/05/10 07:02:45  pinkfish
 * Add in support for center.
 *
 * Revision 1.11  2001/05/10 01:03:35  pinkfish
 * Fix up some autodoc stuff.
 *
 * Revision 1.10  2000/03/03 20:22:18  pinkfish
 * Fix up the autodoc stuff.
 *
 * Revision 1.9  1999/06/30 03:58:56  pinkfish
 * Reverting the changes to the autodoc stuff because the writing out to
 * one file stuff was totaly broken.  It wrote all the normal files into
 * the main file as well.
 *
 * Revision 1.7  1999/05/05 00:35:57  pinkfish
 * Fix it up to print out the name correctly.
 *
 * Revision 1.6  1999/03/22 23:08:31  pinkfish
 * Fix it up to display class data in the help files.
 *
 * Revision 1.5  1999/02/10 10:15:10  pinkfish
 * Add in support for defines and classes.
 *
 * Revision 1.4  1999/02/10 06:11:08  pinkfish
 * Fix up a little.
 *
 * Revision 1.3  1998/11/24 07:50:49  pinkfish
 * Add in stuff to do parameters.
 *
 * Revision 1.2  1998/03/25 13:18:06  pinkfish
 * Added a defined in section so you can see where the function
 * came from
 *
 * Revision 1.1  1998/01/06 05:04:22  ceres
 * Initial revision
 * 
*/
/**
 * This creates an nroff document from the generated automatic documentation.
 * It also writes out the single file descriptions for the methods with
 * documentation attached.
 *
 * @author Pinkfish
 * @started Tue Oct 28 11:39:47 EST 1997
 */

#include <autodoc.h>

private void write_single_description(string func, mixed *stuff,
                                      string output, string fn);
private string query_methods(string *funcs, function data,
                           string base_single, string fn);
private string query_func_def(mixed *stuff, string func);
private string query_method_description(mapping docs);
private string parse_string(string inp);
string convert_html(string text, int depth, int preformat, int edge_width);
private string query_defines(mapping defines);
private string query_class_def(mixed *stuff, string name);
private string query_class_description(mapping docs);
private void write_single_class_description(string func, mixed *stuff,
                                            string output, string fn);
private string query_classes(string base_single,
                           mapping classes,
                           string fn);

void create() {
   seteuid(getuid());
} /* create() */

/**
 * Writes the data from the autodoc file object out to a file in nroff
 * format.
 *
 * @param file the autodoc file object
 * @param output the output file to write to
 *
 * @see /obj/handlers/autodoc/autodoc_handler
 */
void create_nroff_file(object file, string output) {
   mapping stuff;
   string *funcs;
   string *bits;
   string name;
   string base_single;
   string *files;
   string ret;
   int pos;

   /*
    * Ok, we do the alphabetised list, first a short list with the
    * first sentance of each description, then a longer expanded list..
    */
   bits = explode(file->query_file_name(), "/");
   name = bits[sizeof(bits)-1];
   ret = "";
   ret += ".DT\n";
   ret += name + "\n" + mud_name() + " autodoc help\n" + name + "\n\n";
   stuff = file->query_main_docs();
   if (stuff["main"]) {
      ret += ".SH Description\n";
      ret += convert_html(implode(stuff["main"], " "), 5, 0, 5);
      ret += ".SP 10 5\n";
      if (stuff["author"]) {
         ret += "\n\nWritten by " +
                    parse_string(query_multiple_short(stuff["author"]));
      }
      if (stuff["started"]) {
         ret += "\n\nStarted " +
                    parse_string(query_multiple_short(stuff["started"]));
      }
      ret += "\n.EP\n\n";
      if (stuff["see"]) {
         ret += "\n\n.SH See also\n.SP 5 5\n" +
                            query_multiple_short(stuff["see"]) + "\n.EP\n";
      }
      if (stuff["changed"]) {
         ret += ".SH Change history\n.SP 5 5\n" +
                            parse_string(implode(stuff["changed"], "\n\n")) +
                            "\n.EP\n\n";
      }
      if (stuff["example"]) {
        ret += ".SH Example\n.SI 5\n" +
               parse_string(implode(stuff["example"], "\n")) + "\n.EI\n";
      }
   }

   if (sizeof(file->query_inherits())) {
      ret += ".SH Inherits\n.SP 5 5\n";
      ret += "This class inherits the following classes " +
                         query_multiple_short(keys(file->query_inherits())) +
                         ".\n.EP\n\n";
   }

   if (sizeof(file->query_includes())) {
      ret += ".SH Includes\n.SP 5 5\n";
      ret += "This class includes the following files " +
                         query_multiple_short(file->query_includes()) +
                         ".\n.EP\n\n";
   }


   /*
    * Filter out create and setup as they are not real useful functions
    * to document :)
    */
   funcs = filter(keys(file->query_public_functions()),
                  (: $1 != "create" && $1 != "setup" &&
                   !$(file)->query_public_functions()[$1][AUTO_DOCS]["ignore"] :));
   base_single = file->query_file_name();
   pos = strsrch(base_single, ".", -1);
   if (pos > 0) {
      base_single = base_single[0..pos-1];
   }
   base_single = NROFF_DOC_SINGLE + base_single + "/";
   files = get_dir(base_single + "*");
   /*
    * Remove all the old files first, in case a function has changed name
    * or something.
    */
   if (pointerp(files)) {
      foreach (name in files) {
         if (file_size(base_single + name) >= 0) {
            rm(base_single + name);
         }
      }
   }

   if (sizeof(file->query_class_docs())) {
      ret += ".SH Classes\n\n";
      ret += query_classes(base_single,
                    file->query_class_docs(),
                    file->query_file_name());
      ret += "\n";
   }

   if (sizeof(funcs)) {
      ret += ".SH Public Functions\n" +
                         ".SP 5 5\nThese are functions that everyone can "
                         "access.\n.EP\n\n";
      ret += query_methods(funcs, 
                    (: $(file)->query_public_functions()[$1] :),
                    base_single, 
                    file->query_file_name());
      ret += "\n";
   }

   /*
    * Filter out create and setup as they are not real useful functions
    * to document :)
    */
   funcs = filter(keys(file->query_protected_functions()),
                  (: !$(file)->query_protected_functions()[$1][AUTO_DOCS]["ignore"] :));
   if (sizeof(funcs)) {
      ret += ".SH Protected Functions\n"
                         ".SP 5 5\nThese are functions that only "
                         "objects inheriting the class can access.\n.EP\n\n";
      ret += query_methods(funcs, (: $(file)->query_protected_functions()[$1] :),
                    base_single, file->query_file_name());
      ret += "\n";
   }

   bits = explode(file->query_file_name(), "/");
   name = bits[sizeof(bits)-1];
   /* Ignore private functions, because they are less than useful anyway. */
   if (sscanf(name, "%*s.h") == 1 &&
       sizeof(file->query_define_docs())) {
      ret += ".SH Defines\n";
      ret += query_defines(file->query_define_docs());
      ret += "";
   }
   write_file(output, ret);
} /* create_nroff() */

private string query_defines(mapping docs) {
   string name;
   string *names;
   string ret;

   names = sort_array(keys(docs), (: strcasecmp :));
   ret = "";
   foreach (name in names) {
      ret += ".SI 3\n* %^BOLD%^" + name + "%^RESET%^\n" +
                         ".EI\n";
      if (docs[name]["main"]) {
         ret += query_method_description(docs[name]);
      }
      ret += "\n";
   }
   return ret;
} /* write_defines() */

private string query_classes(string base_single,
                           mapping classes,
                           string fn) {
   string name;
   string *names;
   string ret;

   names = sort_array(keys(classes), (: strcasecmp :) );
   ret = "";
   foreach (name in names) {
      reset_eval_cost();
      ret += ".SI 3\n* %^BOLD%^" + name + "%^RESET%^\n";
      ret += query_class_def(classes[name], name) + "\n.EI\n";
      if (classes[name][AUTO_CLASS_DOCS]["main"]) {
         ret += query_class_description(classes[name][AUTO_CLASS_DOCS]);
         write_single_class_description(name, 
                                        classes[name], 
                                        base_single + name, 
                                        fn);
      }
      ret += "\n";
   }
   return ret;
} /* write_classes() */

private string query_methods(string *funcs, 
                           function data, 
                           string base_single, 
                           string fn) {
   int i;
   mixed *stuff;
   string ret;

   funcs = sort_array(funcs, (: strcmp($1, $2) :));
   ret = "";
   for (i = 0; i < sizeof(funcs); i++) {
      stuff = evaluate(data, funcs[i]);
      ret += ".SI 3\n* %^BOLD%^" + funcs[i] + "%^RESET%^\n" +
                         ".EI\n.SI 5\n" + query_func_def(stuff, funcs[i]) +
                         "\n.EI\n";
      if (stuff[AUTO_DOCS]["main"]) {
         ret += query_method_description(stuff[AUTO_DOCS]);
         write_single_description(funcs[i], stuff, base_single + funcs[i], fn);
      }
      ret += "\n";
   }
   return ret;
} /* write_methods() */

private string query_class_def(mixed *stuff, string name) {
   string ret;
   int pad;
   int i;

   ret = "class " + name + " {\n";
   pad = strlen(ret);
   for (i = 0; i < sizeof(stuff[AUTO_CLASS_MEMBERS]); i++) {
      ret += sprintf("%-" + pad + "s", "");
      ret += implode(stuff[AUTO_CLASS_MEMBERS][i][AUTO_CLASS_TYPE], " ") +
             " " + stuff[AUTO_CLASS_MEMBERS][i][AUTO_CLASS_NAME] + ";\n";
   }
   ret += "}\n";
   return ret;
} /* query_class_def() */

private string query_func_def(mixed *stuff, string func) {
   string ret;
   int i;

   ret = implode(stuff[AUTO_TYPE], " ") + " " + func+"(";
   for (i = 0; i < sizeof(stuff[AUTO_ARGS]); i += 2) {
      if (i) {
         ret += ", ";
      }
      ret += implode(stuff[AUTO_ARGS][i + AUTO_ARGS_TYPE], " ") + " " +
             stuff[AUTO_ARGS][i + AUTO_ARGS_NAME];
   }
   ret += ")";
   return ret;
} /* query_func_def() */

private string query_long_func_def(mixed *stuff, string func) {
   string ret;
   int i;
   int pad;

   ret = implode(stuff[AUTO_TYPE], " ") + " " + func+"(";
   pad = strlen(ret);
   for (i = 0; i < sizeof(stuff[AUTO_ARGS]); i += 2) {
      if (i) {
         ret += sprintf(",\n%-"+pad+"s", "");
      }
      ret += implode(stuff[AUTO_ARGS][i + AUTO_ARGS_TYPE], " ") + " " +
             stuff[AUTO_ARGS][i + AUTO_ARGS_NAME];
   }
   ret += ")";
   return ret;
} /* query_long_func_def() */

private string query_class_description(mapping docs) {
   int i;
   string name;
   string desc;
   string ret;

   ret = "";

   if (docs["main"]) {
      ret += convert_html(implode(docs["main"], " "), 7, 0, 5);
   }

   if (docs["member"]) {
      ret += ".SI 7\n%^BOLD%^Members:%^RESET%^\n.EI\n";
      for (i = 0; i < sizeof(docs["member"]); i++) {
         if (sscanf(docs["member"][i], "%s %s", name, desc) == 2) {
            ret +=  ".SP 9 5\n" + name + " - " +
                               parse_string(desc) + "\n.EP\n";
         }
      }
   }
   return ret;
} /* query_class_description() */

private string query_method_description(mapping docs) {
   int i;
   string name;
   string desc;
   string ret;

   ret = "";
   if (docs["main"]) {
      ret += convert_html(implode(docs["main"], " "), 7, 0, 5);
   }

   if (docs["param"]) {
      ret += ".SI 7\n%^BOLD%^Parameters:%^RESET%^\n.EI\n";
      for (i = 0; i < sizeof(docs["param"]); i++) {
         if (sscanf(docs["param"][i], "%s %s", name, desc) == 2) {
            ret += ".SP 9 5\n" + name + " - " +
                               parse_string(desc) + "\n.EP\n";
         }
      }
   }

   if (docs["return"]) {
      ret +=".SI 7\n%^BOLD%^Returns:%^RESET%^\n.EI\n.SP 9 5\n" +
                         parse_string(implode(docs["return"], " ")) +
                         "\n.EP\n";
   }
   return ret;
} /* query_method_description() */

private void write_single_description(string func, mixed *stuff,
                                      string output, string fn) {
   mapping fluff;
   string blue;
   int i;
   int end;
   string *bits;
   string name;
   string desc;
   string ret;

   reset_eval_cost();
   bits = explode(output, "/");
   blue = "/";
   /* Create the directory if it does not exist... */
   for (i = 0; i < sizeof(bits) - 1; i++) {
      blue += bits[i] + "/";
      if (file_size(blue) != -2) {
         mkdir(blue);
      }
   }

   fluff = stuff[AUTO_DOCS];
   ret = "";
   ret += ".DT\n" + func + "\n" + mud_name() + " creator help\n" +
                      func + "\n\n";
   ret += ".SH Name\n.SP 5 5\n";
   blue = implode(fluff["main"], "\n");
   end = strlen(blue);
   i = strsrch(blue, ".");
   if (i > 0) {
      end = i;
   }
   i = strsrch(blue, "!");
   if (i > 0 && i < end) {
      end = i;
   }
   i = strsrch(blue, "?");
   if (i > 0 && i < end) {
      end = i;
   }
   ret += "" + func + " - " + replace(blue[0..end], "\n", " ") +
                      "\n.EP\n\n";
   ret += ".SH Syntax\n.SI 5\n" + query_long_func_def(stuff, func) +
                      "\n.EI\n\n";
   if (fluff["param"]) {
      ret += ".SH Parameters\n.SI 5\n";
      for (i = 0; i < sizeof(fluff["param"]); i++) {
         if (sscanf(fluff["param"][i], "%s %s", name, desc) == 2) {
            ret += "%^BOLD%^" + name + "%^RESET%^ - " +
                               (desc) + "\n";
         }
      }
      ret += ".EI\n\n";
   }

   if (fluff["return"]) {
      ret += ".SH Returns\n.SI 5\n";
      ret += implode(fluff["return"], " ");
      ret += ".EI\n\n";
   }

   ret += ".SH Defined in\n.SI 5\n" + fn + "\n.EI\n\n";
   ret += ".SH Description\n" + convert_html(blue, 5, 0, 5) + "\n";
   if (fluff["example"]) {
      i = 1;
      foreach (blue in fluff["example"]) {
         ret += ".SH Example " + i + "\n.SI 5\n" +
                            parse_string(blue) + "\n.EI\n\n";
         i++;
      }
   }

   if (fluff["see"]) {
      ret += ".SH See also\n.SP 5 5\n" +
                         implode(fluff["see"], ", ") + "\n.EP\n\n";
   }
   write_file(output, ret);
} /* write_single_description() */

private void write_single_class_description(string func, mixed *stuff,
                                            string output, string fn) {
   mapping fluff;
   string blue;
   int i;
   int end;
   string *bits;
   string name;
   string desc;
   string ret;

   reset_eval_cost();
   bits = explode(output, "/");
   blue = "/";
   /* Create the directory if it does not exist... */
   for (i = 0; i < sizeof(bits) - 1; i++) {
      blue += bits[i] + "/";
      if (file_size(blue) != -2) {
         mkdir(blue);
      }
   }

   fluff = stuff[AUTO_DOCS];
   ret = "";
   ret += ".DT\n" + func + "\n" + mud_name() + " creator help\n" +
                      func + "\n\n";
   ret +=  ".SH Name\n.SP 5 5\n";
   blue = implode(fluff["main"], "\n");
   end = strlen(blue);
   i = strsrch(blue, ".");
   if (i > 0) {
      end = i;
   }
   i = strsrch(blue, "!");
   if (i > 0 && i < end) {
      end = i;
   }
   i = strsrch(blue, "?");
   if (i > 0 && i < end) {
      end = i;
   }
   ret += "" + func + " - " + replace(blue[0..end], "\n", " ") +
                      "\n.EP\n\n";
   ret += ".SH Definition\n.SI 5\n" + 
              query_class_def(stuff, func) +
                      "\n.EI\n\n";
   if (fluff["member"]) {
      ret += ".SH Members\n.SI 5\n";
      for (i = 0; i < sizeof(fluff["member"]); i++) {
         if (sscanf(fluff["member"][i], "%s %s", name, desc) == 2) {
            ret += "%^BOLD%^" + name + "%^RESET%^ - " +
                               (desc) + "\n";
         }
      }
      ret += ".EI\n\n";
   }


   ret += ".SH Defined in\n.SI 5\n" + fn + "\n.EI\n\n";
   ret += ".SH Description\n" + convert_html(blue, 5, 0, 5) + "\n";
   if (fluff["example"]) {
      i = 1;
      foreach (blue in fluff["example"]) {
         ret += ".SH Example " + i + "\n.SI 5\n" +
                            parse_string(blue) + "\n.EI\n\n";
         i++;
      }
   }

   if (fluff["see"]) {
      ret += ".SH See also\n.SP 5 5\n" +
                         implode(fluff["see"], ", ") + "\n.EP\n\n";
   }
   write_file(output, ret);
} /* write_single_class_description() */

/*
 * This handles all the changes needed to parse the string, like
 * emulating the accepted html tags and suchlike.
 */
private string parse_string(string str) {
   return replace(str, ({ "<p>", "\n\n", "<br>", "\n\n",
                          "<b>", "%^BOLD%^", "</b>", "%^RESET%^",
                          "<i>", "%^CYAN%^", "</i>", "%^RESET%^",
                          "<pre>", "\n\n", "</pre>", "\n\n" }));
} /* parse_string() */

/*
 * Tags for the types of list...
 */
#define LIST_NONE 0
#define LIST_DYNAMIC 1
#define LIST_ORDERED 2
#define LIST_UNORDERED 3

/*
 * Tags into the list array...
 */
#define LIST_TYPE 0
#define LIST_DEPTH 1
#define LIST_START 2
#define LIST_ADDITIONAL 3
#define LIST_NUM 4

/**
 * Converts the html tags into nroff format...
 *
 * @param text the text to convert
 * @param depth the current depth we are at
 * @param preformat is this text preformated?
 * @param edge_width the width to use as a buffer on the edge
 * @return a nroff format file string
 */
string convert_html(string text, int depth, int preformat, int edge_width) {
   string ret;
   string *bits;
   mixed *lists;
   string* before_centers;
   string start;
   string new_start;
   string additional;
   string add;
   int i;
   string tag;
   string rest;

   ret = "";
   //text = replace_string(text, "\n", " ");
   //text = replace_string(text, "\n.", "\n .");
   if (text[0] == '.') {
      text = " " + text;
   }
   bits = explode("#" + text, "<");
   bits[0] = bits[0][1..];
   start = ".SP " + depth + " " + edge_width;
   ret = start + "\n" + bits[0];
   additional = "";
   lists = ({ ({ LIST_NONE, depth, start, additional }) });
   before_centers = ({ });
   for (i = 1; i < sizeof(bits); i++) {
         if (sscanf(bits[i], "%s>%s", tag, rest) == 2) {
            new_start = start;
            add = 0;
            switch (lower_case(tag)) {
               case "p" :
                  ret += "\n\n" + additional;
                  break;
               case "br" :
                  ret += "\n.E" + start[2..2] + "\n" + start + "\n" + additional;
                  break;
               case "dl" :
                  /* Start a thingy list... */
                  lists += ({ ({ LIST_DYNAMIC, depth, start, additional }) });
                  break;
               case "/dl" :
                  if (lists[<1][LIST_TYPE] == LIST_DYNAMIC) {
                     lists = lists[0..<2];
                     new_start = lists[<1][LIST_START];
                     additional = lists[<1][LIST_ADDITIONAL];
                  }
                  break;
               case "u" :
                  ret += "_";
                  break;
               case "/u" :
                  ret += "_";
                  break;
               case "center" :
                  before_centers += ({ start });
                  new_start = ".SC";
                  break;
               case "/center" :
                  new_start = before_centers[<1];
                  before_centers = before_centers[0..<2];
                  break;
               case "ol" :
                  /* Start a thingy list... */
                  lists += ({ ({ LIST_ORDERED, depth, start, additional, 1 }) });
                  break;
               case "/ol" :
                  if (lists[<1][LIST_TYPE] == LIST_ORDERED) {
                     lists = lists[0..<2];
                     new_start = lists[<1][LIST_START];
                     additional = lists[<1][LIST_ADDITIONAL];
                  }
                  break;
               case "ul" :
                  /* Start a thingy list... */
                  lists += ({ ({ LIST_UNORDERED, depth, start, additional }) });
                  break;
               case "/ul" :
                  if (lists[<1][LIST_TYPE] == LIST_UNORDERED) {
                     lists = lists[0..<2];
                     new_start = lists[<1][LIST_START];
                     additional = lists[<1][LIST_ADDITIONAL];
                  }
                  break;
               case "dd" :
                  if (lists[<1][LIST_TYPE] == LIST_DYNAMIC) {
                     new_start = ".SP " + (lists[<1][LIST_DEPTH] + 3) + " " +
                                 edge_width;
                     depth = lists[<1][LIST_DEPTH] + 3;
                     start = start[0..3]; // Evil hack!  Don't look!      
                     additional = "";
                  }
                  break;
               case "dt" :
                  if (lists[<1][LIST_TYPE] == LIST_DYNAMIC) {
                     new_start = ".SP " + (lists[<1][LIST_DEPTH] + 0) + " " +
                                 edge_width;
                     depth = lists[<1][LIST_DEPTH] + 0;
                     start = start[0..3]; // Evil hack!  Don't look!
                     additional = "";
                  } 
                  break;
               case "li" :
                  if (lists[<1][LIST_TYPE] != LIST_DYNAMIC) {
                     switch (lists[<1][LIST_TYPE]) {
                        case LIST_ORDERED :
                           new_start = ".SO " + (lists[<1][LIST_DEPTH] + 1) +
                                 " 3 -" + (6 + lists[<1][LIST_DEPTH]);
                           add = "\n\t" + (lists[<1][LIST_NUM]++) + ". \t";
                           additional = "\t\t";
                           depth = (lists[<1][LIST_DEPTH] + 3);
                           break;
                        case LIST_UNORDERED :
                           new_start = ".SO " + (lists[<1][LIST_DEPTH] + 1) +
                                 " 2 -" + (5 + lists[<1][LIST_DEPTH]);
                           add = "\n\t*\t";
                           additional = "\t\t";
                           depth = (lists[<1][LIST_DEPTH] + 3);
                           break;
                     }
                  }
                  break;
               case "pre" :
                  preformat++;
                  break;
               case "b" :
                  ret += "%^BOLD%^";
                  break;
               case "i" :
                  ret += "%^CYAN%^";
                  break;
               case "/b" :
               case "/i" :
                  ret += "%^RESET%^";
                  break;
               case "/pre" :
                  preformat--;
                  break;
               case "code" :
               case "/code" :
                  break;
               default :
                  rest = "<" + tag + ">" + rest;
                  break;
            }
            if (new_start != start) {
               ret += "\n.E" + start[2..2] + "\n" + new_start + "\n";
               start = new_start;
            }
            if (add) {
               ret += add;
            }
            if (preformat) {
               ret += replace(rest, "\n", "\n.E" + start[2..2] + "\n" +
                                    start + "\n" + additional);
            } else {
               rest = replace(rest, "\n", " ");
               while (strlen(rest) && rest[0] == ' ') {
                  rest = rest[1..];
               }
               while (strsrch(rest, "  ") != -1) {
                  rest = replace_string(rest, "  ", " ");
               }
               ret += rest;
            }
         } else {
            ret += ">" + bits[i];
         }
   }
   ret += "\n.E" + start[2..2] + "\n";
   return ret;
} /* convert_html() */
// --- END [/mnt/home2/grok/lib/obj/handlers/autodoc/autodoc_nroff.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/autodoc/autodoc_file.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/autodoc/autodoc_file.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628157   Available: 13575511
Inodes: Total: 5242880    Free: 4960134
28141 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/autodoc/autodoc_file.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628157   Available: 13575511
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: autodoc_file.c,v 1.11 2001/11/13 21:32:51 pinkfish Exp $
 * $Log: autodoc_file.c,v $
 * Revision 1.11  2001/11/13 21:32:51  pinkfish
 * Fix up a runtime.
 *
 * Revision 1.10  1999/06/23 01:42:09  pinkfish
 * Stop the autodoc handler getting too deep recusion errors.
 *
 * Revision 1.9  1999/06/22 02:44:24  pinkfish
 * Fix up an error that was causing too deep recursions.
 *
 * Revision 1.8  1999/06/22 01:33:26  pinkfish
 * Fix up the errors in the way it was noticing changed files.
 *
 * Revision 1.7  1999/05/05 00:33:28  pinkfish
 * Fix up the autodoc to use ignore in class files.
 *
 * Revision 1.6  1999/03/22 23:08:07  pinkfish
 * Fixes to make it work properly with classes.
 *
 * Revision 1.5  1999/02/10 09:15:29  pinkfish
 * Fix up to use classes.
 *
 * Revision 1.4  1998/05/13 16:25:34  pinkfish
 * Make it check to see if the file has been deleted.
 *
 * Revision 1.3  1998/02/20 05:39:24  pinkfish
 * Again fixing up the includ stuff.
 * A bit neater this time around...
 *
 * Revision 1.2  1998/02/16 15:04:04  pinkfish
 * Stopped it from ripping comments in from include files and using them for the main file.
 *
 * Revision 1.1  1998/01/06 05:04:22  ceres
 * Initial revision
 * 
 */
/**
 * The automatic document generator.  It takes source files from various
 * directories and creates help files from the comments embeded in the
 * code.
 *
 * @see /obj/handlers/autodoc/autodoc_handler
 * @author Pinkfish
 * @started Fri Oct 24 16:03:57 EDT 1997
 */

#define MASTER_OB "/secure/master.c"
#define EOF -1
#define SAVE_DIR "/save/autodoc/"

nosave mapping private_functions;
mapping public_functions;
mapping protected_functions;
mapping inherits;
mapping main_docs;
mapping define_docs;
mapping includes;
mapping class_docs;
string file_name;
int last_changed;
int num_failed_tries;

/* temporary... */
nosave string current_comment;
nosave string current_file;
nosave int current_position;
nosave int changed;
/*
 * We will only handle simple defines.  Function ones we will ignore
 */
nosave mapping defines;
nosave mixed *exclude_methods;

private void setup();
private mapping parse_comment(string stuff);
private void do_parse_file(function func);
private int query_file_position();
private void handle_inherit(mixed *bits);

/**
 * The start constructor of the file.  This sets up all the basic variables
 * and all that rubbish.
 */
void create() {
   seteuid(getuid());
   setup();
} /* create() */

private void setup() {
   changed = 0;
   main_docs = 0;
   file_name = "";
   private_functions = ([ ]);
   public_functions = ([ ]);
   protected_functions = ([ ]);
   inherits = ([ ]);
   defines = ([ ]);
   define_docs = ([ ]);
   includes = ([ ]);
   class_docs = ([ ]);
   current_comment = 0;
   current_file = "";
   current_position = 0;
   last_changed = 0;
   exclude_methods = ({ "setup", "create", "init", "dest_me", "reset" });
} /* setup() */

private int query_file_position() {
   return current_position;
} /* query_file_position() */

private int lookahead_character(int num) {
   if (current_position + num - 1 < strlen(current_file)) {
      return current_file[current_position + num - 1];
   }
   return EOF;
} /* lookahead_character() */

private int next_character() {
   if (current_position < strlen(current_file)) {
      return current_file[current_position++];
   }
   return EOF;
} /* next_character() */

private int pop_character(int num) { 
   current_position += num;
} /* pop_character() */

/*
 * Throw away everything to the end of the line.
 */
private void skip_to_end_of_line() {
   int ch;

   do {
      ch = next_character();
   } while (ch != '\r' && ch != '\n' && ch != EOF);
} /* skip_to_end_of_line() */

/*
 * Throw away all the characters until the end of the comment.
 */
private string skip_to_end_of_comment() {
   string data;
   int ch;
   int ok;

   /*
    * This will pull all the stuff out of a comment and stick them into
    * a nice string.  Wheeee!
    */

   data = "";
   do {
      ok = 1;
      ch = next_character();
      if (ch == '*' && lookahead_character(1) == '/') {
         /* End of comment... */
         ok = 0;
         pop_character(1);
      } else if (ch == '\r' || ch == '\n') {
         data += "\n";
         if (lookahead_character(1) == ' ') {
            pop_character(1);
         }
         if (lookahead_character(1) == '*' && lookahead_character(2) != '/') {
            pop_character(1);
            if (lookahead_character(1) == ' ') {
               pop_character(1);
            }
         }
      } else if (ch == EOF) {
         ok = 0;
      } else if (ch == '\\' && (lookahead_character(1) == '/' ||
                               lookahead_character(1) == '*' ||
                               lookahead_character(1) == '\\')) {
         /* Build up our comment stuff... */
      } else {
         data += sprintf("%c", ch);
      }
   } while (ok);

   return data;
} /* skip_to_end_of_comment() */

/*
 * Skips all the spaces and comments that are in our way.
 */
private void skip_spaces_and_comments() {
   int ok;

   do {
     switch (lookahead_character(1)) {
        case ' ' :
        case '\t' :
        case '\n' :
        case '\r' :
           ok = 1;
           /* Move our index up one... */
           pop_character(1);
           break;
        case '/' :
           /* Could be a comment... */
           if (lookahead_character(2) == '/') {
              ok = 1;
              skip_to_end_of_line();
           } else if (lookahead_character(2) == '*') {
              ok = 1;
              if (lookahead_character(3) != '*' ||
                  lookahead_character(4) == '*') {
                 /* Make sure it is not a code comment... */
                 pop_character(2);
                 skip_to_end_of_comment();
                 current_comment = 0;
              } else {
                 pop_character(3);
                 if (lookahead_character(1) == ' ') {
                    pop_character(1);
                 }
                 if (!main_docs) {
                    main_docs = parse_comment(skip_to_end_of_comment());
                 } else {
                    current_comment = skip_to_end_of_comment();
                 }
              }
           } else {
              ok = 0;
           }
           break;
        default :
           ok = 0;
           break;
     }
   } while (ok);
} /* skip_spaces_and_comments() */

/*
 * Expands the defines...
 */
private string expand_token(string token) {
   if (defines[token]) {
      return defines[token];
   }
   return 0;
} /* expand_token() */

/*
 * Gets the next token...
 */
private string get_word() {
   string data;
   int ok;
   int ch;

   skip_spaces_and_comments();
   ok = 1;
   data = "";
   ch = lookahead_character(1);
   if ((ch >= 'a' && ch <= 'z') ||
       (ch >= 'A' && ch <= 'Z') ||
       (ch == '_')) {
      do {
         ch = lookahead_character(1);
         if ((ch >= 'a' && ch <= 'z') ||
             (ch >= 'A' && ch <= 'Z') ||
             (ch >= '0' && ch <= '9') ||
             (ch == '_')) {
            ch = next_character();
            data += sprintf("%c", ch);
         } else {
            ok = 0;
         }
      } while (ok);
      if (expand_token(data)) {
         current_file = expand_token(data) + current_file[current_position..];
         current_position = 0;
         return get_word();
      }
   } else if ((ch >= '0' && ch <= '9') ||
              (ch == '-')) {
      if (ch == '-') {
         data += sprintf("%c", next_character());
      }
      /* Number, only search for number bits... */
      do {
         ch = lookahead_character(1);
         if ((ch >= '0' && ch <= '9') ||
             (ch >= '.')) {
            ch = next_character();
            data += sprintf("%c", ch);
         } else {
            ok = 0;
         }
      } while (ok);
   } else if (ch == '\"' || ch == '\'') {
      int end_ch;

      end_ch = ch;
      ch = next_character();
      data += sprintf("%c", ch);
      do {
         ch = next_character();
         if (ch == end_ch) {
            ok = 0;
            data += sprintf("%c", ch);
         } else if (ch == '\\') {
            /* Skip the next character... */
            ch = next_character();
            data += sprintf("\\%c", ch);
         } else if (ch == EOF) {
            ok = 0;
         } else {
            data += sprintf("%c", ch);
         }
      } while (ok);
   } else if (ch == '(') {
      if (lookahead_character(2) == '{' ||
          lookahead_character(2) == '[') {
         return sprintf("%c%c", next_character(), next_character());
      }
      return sprintf("%c", next_character());
   } else if (ch == '}' || ch == ']') {
      if (lookahead_character(2) == ')') {
         return sprintf("%c%c", next_character(), next_character());
      }
      return sprintf("%c", next_character());
   } else if (ch == ';' ||
              ch == ')' ||
              ch == '=' ||
              ch == '{' ||
              ch == '}') {
      /* open brace, semi colon, close brace... is a special thingy... */
      return sprintf("%c", next_character());
   } else if (ch == EOF) {
      return "";
   } else {
      /* All non-space, non alphanumeric...  Dump together... */
      do {
         ch = lookahead_character(1);
         if ((ch >= 'a' && ch <= 'z') ||
             (ch >= 'A' && ch <= 'Z') ||
             (ch >= '0' && ch <= '9') ||
             (ch == '_') ||
             (ch == ' ') ||
             (ch == '\t') ||
             (ch == '\n') ||
             (ch == '(') ||
             (ch == ')') ||
             (ch == EOF) ||
             (ch == ';') ||
             (ch == '=') ||
             (ch == '{') ||
             (ch == '}') ||
             (ch == '\'') ||
             (ch == '\"') ||
             (ch == '\r')) {
            ok = 0;
         } else {
            ch = next_character();
            data += sprintf("%c", ch);
         }
      } while (ok);
   }

   return data;
} /* get_word() */

/*
 * Attempts to get a complete statement...
 */
private mixed *get_statement(string start) {
   mixed *bits;
   string curr;
   int depth;
   string temp_comment;
   int last_pos;
   int in_class;

   /* If it starts with the class keyword, then is must be a class... */

   /* We rip until a semi colon or an open brace... */
   /*
    * If we find a semi colon...  Then it is a predef or an inherit
    * statement...
    */
   bits = ({ start });
   do {
      last_pos = query_file_position();
      curr = get_word();
      bits += ({ curr });
      if (last_pos != query_file_position()) {
         /* Make sure it is doing something... */
         reset_eval_cost();
      }
   } while (curr != ";" && curr != "{" && curr != "");

   if (curr == "{") {
      if (member_array("class", bits) != -1 &&
          member_array("(", bits) == -1) {
         /*
          * We have a class, now we need to parse this in a useful way.
          * Sadly this cannot fit into the normal way of parsing.  It is an
          * exception to one of those rules :)
          */
         in_class = 1;
      }
      /* Grab the rest...  but ignore it... */
      /* Keep the current comment though... */
      temp_comment = current_comment;
      depth = 1;
      do {
        last_pos = query_file_position();
        curr = get_word();
        if (curr == "{") {
           depth++;
        } else if (curr == "}") {
           depth--;
        } else if (curr == "") {
           /* End of file... */
           depth = 0;
        }
        if (last_pos != query_file_position()) {
           /* Make sure it is doing something... */
           reset_eval_cost();
        }
        if (in_class) {
           bits += ({ curr });
        }
      } while (depth > 0);
      current_comment = temp_comment;
   }

   return bits;
} /* get_statement() */

/*
 * This parses the comment into the appropriate bits...
 */
private mapping parse_comment(string stuff) {
   string *bits;
   int i;
   mapping frog;
   string name;
   int j;
   int rabbit;

   if (!stuff) {
      return ([ ]);
   }

   if (stuff[0] == '@') {
      stuff = "\n" + stuff;
   } else {
      stuff = "\n@main " + stuff;
   }
   bits = explode(stuff, "\n@");
   frog = ([ ]);
   for (i = 0; i< sizeof(bits); i++) {
      j = strsrch(bits[i], " ");
      rabbit = strsrch(bits[i], "\n");
      if (j == -1 || (rabbit != -1 && rabbit < j)) {
         j = rabbit;
      }
      if (j > 0) {
         name = bits[i][0..j - 1];
         stuff = bits[i][j+1..];
         if (!frog[name]) {
            frog[name] = ({ stuff });
         } else {
            frog[name] += ({ stuff });
         }
      }
   }
   return frog;
} /* parse_comment() */

/*
 * Handles a class...
 */
private void handle_class(mixed *bits) {
   string name;
   int i;
   string *types;
   mapping comm;

   name = bits[1];
   types = ({ });
   i = member_array("{", bits);
   if (i != -1) {
      /* Ok, figure out all the elements and types. */
      bits = bits[i + 1..];
      while (sizeof(bits)) {
         i = member_array(";", bits);
         if (i != -1) {
            types += ({ ({ bits[i - 1], bits[0..i - 2] }) });
            bits = bits[i + 1..];
         } else {
            bits = ({ });
         }
      }
      comm = parse_comment(current_comment);
      if (!comm["ignore"]) {
         class_docs[name] = ({ 0, types,
                               parse_comment(current_comment) });
      }
   }
} /* handle_class() */

/*
 * Handles an inherit...  Sticks all the needed stuff in like the
 * thing being inherited and the state of it and stuff.
 */
private void handle_inherit(mixed *bits) {
   int pos;
   string name;

   pos = member_array("inherit", bits);
   if (pos >= 0) {
      /* Need to strip off the last thingy which should be a semi colon. */
      name = implode(map(bits[pos+1.. sizeof(bits)-2], 
                         function(string str) {
                            if (str[0] == '\"') {
                               sscanf(str, "\"%s\"", str);
                               return str;
                            }
                            return "";
                         } ), "");
      inherits[name] = bits[0..pos-1];
   }
} /* handle_inherit() */

/*
 * We have found a function definition...  Create the information
 * we need from it.
 */
private void handle_function_definition(mixed *bits) {
   int pos;
   int end_pos;
   int new_pos;
   string name;
   string *type;
   mixed *args;
   mapping comm;

   pos = member_array("(", bits);
   if (pos > 0) {
      name = bits[pos-1];
      if (member_array(name, exclude_methods) == -1) {
         type = bits[0..pos-2];
         if (sizeof(type) == 0) {
            type = ({ "int" });
         }
         end_pos = member_array(")", bits, pos);
         args = ({ });
         if (end_pos > pos + 1) {
            /* Whoo, there are some arguments... */
            pos++;
            while (member_array(",", bits, pos) != -1) {
               new_pos = member_array(",", bits, pos);
               args += ({ bits[pos..new_pos-2], bits[new_pos-1] });
               pos = new_pos + 1;
            }
            args += ({ bits[pos..end_pos -2], bits[end_pos-1] });
         }
         comm = parse_comment(current_comment);
         if (!comm["ignore"]) {
            if (member_array("private", type) != -1) {
               type -= ({ "private" });
               private_functions[name] = ({ type, args,
                                          comm });
            } else if (member_array("protected", type) != -1) {
               type -= ({ "protected" });
               protected_functions[name] = ({ type, args,
                                           comm });
            } else {
               type -= ({ "public" });
               public_functions[name] = ({ type, args,
                                           comm });
            }
         }
      }
      current_comment = 0;
   }
} /* handle_function_definition() */

/*
 * Gets the rest of the line.  Mostly used by the hash stuff...
 */
private string get_rest_of_line() {
   string value;
   int ch;
   int last_pos;

   value = "";
   /* Skip the spaces at the start... */
   ch = lookahead_character(1);
   while (ch == ' ' || ch == '\t') {
      pop_character(1);
      ch = lookahead_character(1);
   }
   /* Get the whole definition */
   do {
      last_pos = query_file_position();
      ch = next_character();
      if (ch == '\\') {
         /* Skip one!  This is escaped... */
         ch = next_character();
         if (ch == '\r' && lookahead_character(1) == '\n') {
          /* Handle MSDOS sillyness */
            ch = next_character();
         }
         ch = ' ';
      }
      if (last_pos != query_file_position()) {
         reset_eval_cost();
      }
      value += sprintf("%c", ch);
   } while (ch != '\n' && ch != '\r' && ch != EOF);

   return value;
} /* get_rest_of_line() */

/*
 * Handles the hairy #define's and #includes.
 */
private void handle_hash() {
   int i;
   string token;
   string name;
   string value;
   string *bits;
   string stuff;
   string inc_name;
   string curr_comm;
   mapping comm;

   token = get_word();
   /* Not really sure what to do about these right now... */
   switch (token) {
      case "define" :
      case "defin" :
         /* Ok, with a define...  we... get a name and a substitution value. */
         curr_comm = current_comment;
         value = get_rest_of_line();
         if (sscanf(value, "%s %s", name, value) == 2) {
            defines[name] = value;
            if (token == "define") {
               comm = parse_comment(curr_comm);
               if (!comm["ignore"]) {
                  define_docs[name] = comm;
               }
               current_comment = 0;
            }
         }
         break;
      case "include" :
         /*
          * Eeeek!  This will be evil... At the moment assume they don't
          * do arithmetic in the #include line...
          */
         value = get_rest_of_line();
         if (value[0] == '\"') {
            /* This means a local inherit... */
            bits = explode(file_name, "/");
            sscanf(value, "\"%s\"", name);
            stuff = read_file(implode(bits[0..<2], "/") +
                              "/" + name);
            if (stuff) {
               inc_name = "/" + implode(bits[0..<2], "/") +
                              "/" + name;
            }
         } else if (value[0] == '<') {
            /* This means it could be a global inherit... */
            sscanf(value, "<%s>", name);
         }

         if (name[0] == '/') {
            stuff = read_file(name);
            if (stuff) {
               inc_name = name;
            }
         }

         bits = MASTER_OB->define_include_dirs();
         while (!stuff && i < sizeof(bits)) {
            stuff = read_file(sprintf(bits[i], name));
            if (stuff) {
               /* Remove all the autodoc comments from the include file... */
               stuff = replace_string(stuff, "/**", "/* ");
               /* Ignore included classes. */
               stuff = replace_string(stuff, "class ", "clas ");
               stuff = replace_string(stuff, "#define ", "#defin ");
               inc_name = sprintf(bits[i], name);
            }
            i++;
         }

         if (inc_name) {
            /* Zap double '//'s */
            inc_name = replace(inc_name, "//", "/");
            if (inc_name[0] != '/') {
               inc_name = "/" + inc_name;
            }
         }

         if (stuff && !includes[inc_name]) {
            /* We found it! */
            /* Stick the include bit in where it is needed... */
            current_file = stuff + current_file[current_position..];
            current_position = 0;
            includes[inc_name] = unguarded( (: stat($(inc_name)) :) )[1];
         }
         break;
      default :
         /* Pragma's and other silly hash things */
         skip_to_end_of_line();
         break;
   }
} /* handle_hash() */

/*
 * Gets the next token...  This is state dependant, we need to know
 * what state we are in to figure out what sort of token we are probably
 * looking for...
 */
private void next_statement() {
   string token;
   string *bits;

   token = get_word();
   if (token[0] == '#') {
      /* A hash directive... */
      return handle_hash();
   } else if (token == ";") {
      return ;
   } else if (token != "") {
      bits = get_statement(token);
      if (member_array("inherit", bits) != -1) {
         /* An inherit statement. */
         return handle_inherit(bits);
      } else if (bits[0] == "class" &&
                 member_array("(", bits) == -1) {
         return handle_class(bits);
      } else if (bits[sizeof(bits) - 1] == "{" &&
                 member_array("=", bits) == -1) {
         return handle_function_definition(bits);
      } else {
         /* It was a predef or a variable declaration... */
         return ;
      }
   }
} /* next_statement() */

/**
 * Loads up the currently set file name from the archives.
 */
void load_file() {
   unguarded((: restore_object(SAVE_DIR + replace_string(file_name, "/", ".")) :));
   if (!includes) {
      includes = ([ ]);
   }
   if (!class_docs) {
      class_docs = ([ ]);
   }
} /* load_file() */

/**
 * Saves the current file name to the archives.
 */
void save_file() {
   unguarded((: save_object(SAVE_DIR + replace_string(file_name, "/", ".")) :));
} /* save_file() */

/**
 * Parses the input file figuring out all the documentation bits of it.
 *
 * @param name the name of the file to parse
 * @param func the function to call when the parsing is finished
 * @param only_load a flag telling us to only load the information
 */
void parse_file(string name, function func, int only_load) {
   int curr_change;
   int my_change;
   string my_name;
   int reload;

   setup();
   file_name = name;
   load_file();

   if (!only_load) {
      if (sizeof(unguarded( (: stat($(name)) :) )) > 1) {
         curr_change = unguarded( (: stat($(name)) :) )[1];
         my_name = file_name(this_object());
         sscanf(my_name, "%s#%*s", my_name);
         my_name += ".c";
         my_change = unguarded( (: stat($(my_name)) :) )[1];
         reload = curr_change > last_changed;
         if (my_change > last_changed &&
             my_change > curr_change) {
            curr_change = my_change;
            reload = 1;
         }

         if (!reload) {
            /* Check to see if the include files have changed. */
            foreach (my_name, my_change in includes) {
               if ( unguarded( (: stat($(my_name)) :) )[1] != my_change) {
                  reload = 1;
                  break;
               }
            }
         }
         if (reload) {
            setup();
            num_failed_tries = 0;
            file_name = name;
            changed = 1;
            last_changed = curr_change;
            current_file = read_file(name);
            current_position = 0;
            if (catch(do_parse_file(func))) {
               evaluate(func);
            }
         } else {
            if (num_failed_tries) {
               num_failed_tries = 0;
               save_file();
            }
            call_out( (: evaluate($1) :), 2, func);
         }
      } else {
         num_failed_tries++;
         save_file();
         call_out( (: evaluate($1) :), 2, func);
      }
   } else {
      call_out( (: evaluate($1) :), 2, func);
   }
} /* parse_file() */

private void do_parse_file(function func) {
   int num;

   if (unguarded( (: stat(file_name) :))[1] > last_changed) {
      /* Darn, changed while we were reading it. */
      return parse_file(file_name, func, 0);
   }

   num = 0;
   while (lookahead_character(1) != EOF && num < 2) {
      next_statement();
      num++;
   }

   if (lookahead_character(1) == EOF) {
      save_file();
      call_out((: evaluate($1) :), 2, func);
   } else {
      call_out((: do_parse_file($1) :), 2, func);
   }
} /* do_parse_file() */

/**
 * Returns the inherits mapping of the system.  This returns a mapping of the
 * form ([ inherit_name : ({ flags }) ]).  Where the name of the inherit is
 * something like "/std/object" and the flags are things you can apply to
 * an inherit, like "protected" or "private".  If there are no flags then
 * the flags will be an empty array.
 *
 * @return a mapping of things inherited by this file
 */
mapping query_inherits() { return inherits; }

/**
 * The mapping of private functions.
 * The mapping is of the form ([ func_name : ({ type, args, docs }) ]).
 * The type bit is an array of the type name, ie: ({ "int" }) or
 * ({ "mixed", "*" }).  The args bit looks like ({ "name", type }),
 * where the type is the same as in the previous array.  The docs is
 * a mapping of the form ([ "tag" : ({ data }) ]), where each reference
 * to a tag creates a new element in the data array.
 *
 * @return a mapping containing the private functions
 */
mapping query_private_functions() { return private_functions; }

/**
 * The mapping of public functions.
 * The mapping is of the form ([ func_name : ({ type, args, docs }) ]).
 * The type bit is an array of the type name, ie: ({ "int" }) or
 * ({ "mixed", "*" }).  The args bit looks like ({ "name", type }),
 * where the type is the same as in the previous array.  The docs is
 * a mapping of the form ([ "tag" : ({ data }) ]), where each reference
 * to a tag creates a new element in the data array.
 *
 * @return a mapping containing the public functions
 */
mapping query_public_functions() { return public_functions; }

/**
 * The mapping of protected functions.
 * The mapping is of the form ([ func_name : ({ type, args, docs }) ]).
 * The type bit is an array of the type name, ie: ({ "int" }) or
 * ({ "mixed", "*" }).  The args bit looks like ({ "name", type }),
 * where the type is the same as in the previous array.  The docs is
 * a mapping of the form ([ "tag" : ({ data }) ]), where each reference
 * to a tag creates a new element in the data array.
 *
 * @return a mapping containing the protected functions
 */
mapping query_protected_functions() { return protected_functions; }

/**
 * Returns the main docs for the class.  The mapping is of
 * the form ([ "tag" : ({ data }) ]), where each reference
 * to a tag creates a new element in the data array.
 *
 * @return a mapping containing the main docs for the file
 */
mapping query_main_docs() {
   if (main_docs) {
      return main_docs;
   }
   return ([ ]);
} /* query_main_docs() */

/**
 * The file name being processed.
 *
 * @return the name of the file being processed
 */
string query_file_name() { return file_name; }

/**
 * The defines which were setup in the class.  This is the mapping of the
 * defines which were processed.  The format of the mapping is
 * ([ "name" : "value" ]), where the name is the name of the define and
 * the value is what to replace it with.
 *
 * @return the mapping of defines
 */
mapping query_defines() { return defines; }

/**
 * Did the file change?  Checks to see if the file changed since it
 * was last read.
 *
 * @return 1 if it changed, 0 if it has not changed
 */
int query_changed() { return changed; }

/**
 * This method returns the number of times the file was attempted to
 * be read and it was discovered not to exist at all.
 * @return the number of times it was unable to be read
 */
int query_num_failed_tries() { return num_failed_tries; }

/**
 * The files included by this one.
 *
 * @return an array of included files
 */
string *query_includes() { return keys(includes); }

/**
 * The documentation for the defines.  This is mostly used by the include
 * file documentation system.
 *
 * @return the mapping of define names to documentation
 */
mapping query_define_docs() { return define_docs; }

/**
 * The documentation for the classes.
 * @return the mapping of the class names to documentation
 */
mapping query_class_docs() { return class_docs; }

/**
 * Allow this object to be destructed nicely...
 */
void dest_me() {
   destruct(this_object());
} /* dest_me() */
// --- END [/mnt/home2/grok/lib/obj/handlers/autodoc/autodoc_file.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/autodoc/autodoc_handler.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/autodoc/autodoc_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628150   Available: 13575504
Inodes: Total: 5242880    Free: 4960134
20265 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/autodoc/autodoc_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628150   Available: 13575504
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: autodoc_handler.c,v 1.19 1999/10/26 00:57:49 pinkfish Exp $
 * 
*/
/**
 * Documentation system for removing documentation from source files.
 * <p>
 * The documentation will be created in the directory /doc/autodoc.  Extra
 * documentation should be placed into the other help directories and will
 * be accessed via the help system.  The html documentation will be placed
 * into the /www/autodoc directory.  The files in theses directories will
 * be named with the '/'s replaced with '.'s.  ie: /obj/handlers/room_handler.c
 * would be in the file /doc/autodoc/obj.handlers.room_handler.c and
 * /www/autodoc/obj.handlers.room_handler.c.html.  An index of the methods
 * and object names will be generated from the input files and linked into the
 * help system.  An alphabetical index will also be produced that is linked
 * to the html stuff.
 * <p>
 * The first comment which follows the comment format below and occurs right
 * before a function will be used as the documentation for that function.  The
 * comment must start with two '*'s to distinguish it from a normal comment.
 * A special tag at the start of one of the first comments in the file will
 * signify that it is a comment for the class.
 * <p>
 * Only comments before a real function declaration will be used, comments
 * before a predeclaration will be ignored.
 * <p>
 * Any function which is not declared as private and does not have the @ignore
 * tag in its description will be placed into the resulting documentation
 * file.  This will be done even if no comment was found.
 * <p>
 * In the text part of the comment the main section is a free form
 * documentation, it is merely a description of the whole function.  After
 * this several tags can be added to the comment which allows other things
 * to be documented.  All the text after the tag is taken as part of that
 * tags information.  The main tag should never actually be used, it
 * is implied as being the tag associated with the first section of
 * comment.
 * <p>
 * HTML tags will be used in the comments to allow certain things to
 * happen.  The tags 'p', 'b', 'i', 'code', 'ul', 'ol', 'dl', 'dd', 'dt', 'pre'
 * and 'li' will be supported.
 * <p>
 * The sequences '\\/', '\\\\' and '\<' will be processed by the comment
 * handling code so that they do not get placed into the output code.
 * <p>
 * White space is ignored...  Both html and dw nroff format files will be
 * created from the documentation maker.
 * <p>
 * The supported tags are:
 * <dl>
 * <dt>@param
 * <dd>Specify the parameter and what it does.  This should be one short
 *     sentance only.  There needs to be one of these for every
 *     parameter, the first word of the sentance is the name of the 
 *     paramater and the rest is the descrption.  There should be no full
 *     stop on the end of the sentance.
 * <dt>@member
 * <dd>This is used with classes and defines the members of the class.  The
 *     definition is the same as for the @param element above.
 * <dt>@return
 * <dd>Specify what the return value is.  This should be one short
 *     sentance only.  Theres should only be one of these in every
 *     function.  There should be no full stop on the end of the sentance.
 * <dt>@see
 *   <dd>Specify an object or function to see.  The format must be one of:
 *   <ul>
 *   <li> object_name<br><i>@see /global/new_parse</i>
 *   <li> function_name()<br><i>@see frog()</i>
 *   <li> object_name->function_name()<br><i>@see /global/new_parse->add_command()</i>
 *   <li> efun::name()<br><i>@see efun::sort_array()</i>
 *   <li> help::name<br>@see help::effects
 *   </ul>
 * <dt>@ignore
 *   <dd>Do not document this function, the whole comment is ignored.
 * <dt>@main
 *   <dd>The main documentation section.
 * <dt>@classification
 *    <dd>Used in the effects files to classifiy the effect.  So a tree
 *      of the classifications can be derived.
 * <dt>@index
 *        <dd>Adds in a new index refernece on this name.  This should be one
 *            word only.
 * <dt>@change
 *   <dd>Placed in the class documentation to reference a change list.
 *            First line after the tag is the date and the author and
 *            then follows a description of the change.
 * <dt>@example
 *   <dd>If you wish to embed an example in the code.
 * <dt>@started
 *   <dd>When the file was started.
 * <dt>@author
 *   <dd>The author of the file.
 * </dl>
 *
 * The output format will look something like the API documentation for
 * java.  If you have not seen this before, go to http://www.javasoft.com
 * and look in the JDK and then the API section.
 * <p>
 * Comment format:
 * <pre>
 * /\**
 *  *  <text>
 *  *    ..
 *  *  <text>
 *  *
 *  *\/
 * </pre>
 *
 * ie: it starts with a /\** and ends with a *\/ on a line by themselves and
 * every intervening line has a * at the start.  By using a \\ you can
 * make characters escaped.  This means they are not processed by
 * the internal system, so to make a end comment appear inside a
 * the text you go : *\\/
 *
 * @example
 * inherit "/std/object";
 *
 * /\**
 *  *   This class is a nice shade of blue and allows all other shades of
 *  *   green and yellow to mix well.
 *  * @see yellow
 *  * @see blue
 *  * @change 12/3/97 Pinkfish
 *  *    Pushed some of the yellow stuff down a hole and ate a bagel.
 *  *\/
 *
 * /\**
 *  * This method mixes the green in with our blue.
 *  * @param  green   the green object to mix.
 *  *\/
 * void mixGreen(object green) {
 *   /\* Something wild and exciting! *\/
 * } /\* mixGreen() *\/
 *
 * /\**
 *  * This method mixes the yellow in with our blue.
 *  * @param  yellow the yellow object to mix.
 *  * @return returns a TRUE or FALSE depending on if the mix succeeded.
 *  * @example
 *  *   mixYellow(12);
 *  *\/
 * int mixYellow(object yellow) {
 * } /\* mixYellow() *\/
 *
 * @index autodoc
 * @see /obj/handlers/autodoc/autodoc_file
 * @see /obj/handlers/autodoc/autodoc_nroff
 * @see /obj/handlers/autodoc/autodoc_html
 * @author Pinkfish
 * @started Tue Oct 28 13:25:09 EST 1997
 *
 */

#include <autodoc.h>

#define MAIN_FILE 0
#define INDEX_FILE 1

#define SAVE_FILE (SAVE_DIR "main_rubbish")

string *files;
int file_pos;
int something_changed;
int last_created_index;
nosave function *filters;
nosave int call_id;
nosave mapping summary_map;
nosave mixed *extra_indexes;
mapping help_map;

private void create_nroff_file(object ob, int type);
private void create_html_file(object ob, int type);
private void after_thingy(int no_index);
private void start_processing();
private void do_parse_next_file();
private void create_index();
private void add_to_index(object ob);
private void load();
private void save();
string *query_files();
int remove_file(string fname);

void create() {
   seteuid(getuid());
   filters = ({ (: create_nroff_file($1, $2) :),
                (: create_html_file($1, $2) :) });
   file_pos = 0;
   something_changed = 0;
   files = ({ });
   load();
   do_parse_next_file();
   /* For testing... */
   //create_index();
} /* create() */

private void create_nroff_file(mixed ob, int type) {
   string fname;
   mixed *stuff;
   mixed *index_stuff;
   int i;

   if (type == MAIN_FILE) {
      /* Now we create the nroff file... */
      fname = replace(ob->query_file_name(), "/", ".");
      if (fname[0] == '.') {
         fname = fname[1..];
      }
      rm(NROFF_DOC_DIR + fname);
      AUTODOC_NROFF->create_nroff_file(ob, NROFF_DOC_DIR + fname);
   } else if (type == INDEX_FILE) {
      /* Create an index file... */
      /* Divide into letters... */
      index_stuff = ob;
      stuff = map(query_files(), function (string name) {
           string *bits;

           bits = explode(name, "/");
           return ({ bits[sizeof(bits)-1], name });
        } );
      stuff = unique_array(index_stuff + stuff, (: lower_case($1[0])[0] :));
      for (i = 0; i < sizeof(stuff); i++) {
         fname = NROFF_DOC_DIR + "index_" + lower_case(stuff[i][0][0][0..0]);
         AUTODOC_NROFF->create_nroff_index_file(stuff[i], fname);
      }
   }
} /* create_nroff_file() */

private void create_html_file(mixed ob, int type) {
   string fname;
   mixed *stuff;
   mixed *index_stuff;
   int i;
   mapping chars;

   if (type == MAIN_FILE) {
      /* Now we create the nroff file... */
      fname = replace(ob->query_file_name(), "/", ".");
      if (fname[0] == '.') {
         fname = fname[1..];
      }
      fname += ".html";
      rm(HTML_DOC_DIR + fname);
      AUTODOC_HTML->create_html_file(ob, HTML_DOC_DIR + fname);
   } else if (type == INDEX_FILE) {
      /* Create an index file... */
      index_stuff = ob;
      stuff = map(query_files(), function (string name) {
           string *bits;

           bits = explode(name, "/");
           return ({ bits[sizeof(bits)-1], name, "", summary_map[name] });
        } );
      stuff = unique_array(index_stuff + stuff, (: lower_case($1[0])[0] :));
      chars = ([ ]);
      for (i = 0; i < sizeof(stuff); i++) {
         fname = "index_" + lower_case(stuff[i][0][0][0..0]) + ".html";
         rm(HTML_DOC_DIR + fname);
         AUTODOC_HTML->create_html_index_file(stuff[i], stuff[i][0][0][0..0],
                                       HTML_DOC_DIR + fname);
         reset_eval_cost();
         chars[capitalize(stuff[i][0][0][0..0])] =  fname;
      }
      /* The differnt sorts of index will be genertated in the html file */
      fname = HTML_DOC_DIR; // + "index.html";
      //rm(fname);
      AUTODOC_HTML->create_main_index(chars, fname);
   }
} /* create_html_file() */

private void after_thingy(int no_index) {
   int i;

   if (no_index) {
      printf("Finished recreating the documentation for %O\n",
              previous_object()->query_file_name(),
             previous_object());
   }

   if (previous_object()->query_changed()) {
      something_changed = 1;
   }

   if (previous_object()->query_num_failed_tries() > 1) {
      /*
       * This means that the file has been deleted...  Argh!  Auto remove
       * it and log it.
       */
      remove_file(files[file_pos - 1]);
      //log_file("AUTODOC", ctime(time()) + ": Removing: " + files[file_pos - 1] + " \n");
   } else if (previous_object()->query_changed() || no_index) {
      //log_file("AUTODOC", ctime(time()) + ": Parsing: " + files[file_pos - 1] + " \n");
      for (i = 0; i < sizeof(filters); i++) {
         call_out((: evaluate($1, $2, $3) :), 0, filters[i],
                  previous_object(), MAIN_FILE);
      }
   }

   call_out((: $1->dest_me() :), 20, previous_object());
   save();
} /* after_thingy() */

private void do_parse_next_file() {
   /* Give it a minute to do this file... */
   call_id = call_out((: start_processing() :), 60);
   if (file_pos >= sizeof(files)) {
      file_pos = 0;
   }
   new(AUTODOC_FILE)->parse_file(files[file_pos++], (: after_thingy(0) :));
} /* do_parse_next_file() */
 
private void start_processing() {
   if (sizeof(files) == 0) {
      return ;
   }

   /* Ok, now we skip onto the next file and zoom it... */
   if (last_created_index + SAVE_INDEX_DELAY < time()) {
      if (something_changed) {
         call_out( (: create_index() :), 2);
      }
      something_changed = 0;
      save();
   }

   call_id = call_out((: do_parse_next_file() :), 360);
} /* start_processing() */

private string query_short_args_def(mixed *args) {
   string ret;
   int i;

   ret = "";
   for (i = 0; i < sizeof(args); i += 2) {
      if (i != 0) {
         ret += ", ";
      }
      ret += implode(args[AUTO_ARGS_TYPE], " ");
   }
   return "(" + ret + ")";
} /* query_short_args_def() */

/*
 * This will add it into the help array stuff too..
 */
private string *process_stuff(string name,
                              string fname,
                              string fn,
                              mapping docs) {
   string blue;
   int i;
   int end;
   mixed *ret;
   mapping fluff;

   if (name != "create" && name != "setup" && name != "init") {
      if (help_map[name]) {
         help_map[name] += ({ fn });
      } else {
         help_map[name] = ({ fn });
      }
   }
   if (docs[name]) {
      if (arrayp(docs[name])) {
         /* Its a function! */
         fluff = docs[name][AUTO_DOCS];
         ret =  ({ name, fname, query_short_args_def(docs[name][AUTO_ARGS]) });
      } else {
         ret = ({ name, fname, "" });
         fluff = docs[name];
      }
   } else {
      ret = ({ name, fname, "" });
      if (mapp(docs)) {
         fluff = docs;
      } else {
         fluff = ([ ]);
      }
   }
   if (fluff["main"]) {
      blue = implode(fluff["main"], "\n");
      end = strlen(blue);
      i = strsrch(blue, ".");
      if (i > 0) {
         end = i;
      }
      i = strsrch(blue, "!");
      if (i > 0 && i < end) {
         end = i;
      }
      i = strsrch(blue, "?");
      if (i > 0 && i < end) {
         end = i;
      }
      blue = blue[0..end];
   }
   ret += ({ blue });
   if (fluff["index"]) {
      foreach (blue in fluff["index"]) {
         blue = replace(blue, ({ " ", "", "\n", "" }));
         if (help_map[blue]) {
            help_map[blue] += ({ fn });
         } else {
            help_map[blue] = ({ fn });
         }
         extra_indexes += ({ ({ blue, fname, "", ret[AUTO_INDEX_SUMMARY] }) });
      }
   }
   return ret;
} /* process_stuff() */

private void create_index() {
   int i;
   mixed *index_stuff;
   mixed *rabbit;
   string fname;
   string fn;
   string *bits;
   object parse;

   //log_file("AUTODOC", ctime(time()) + ": Created index.\n");
   /* Build up the list... */
   index_stuff = ({ });
   help_map = ([ ]);
   extra_indexes = ({ });
   summary_map = ([ ]);
   parse = clone_object(AUTODOC_FILE);
   for (i = 0; i < sizeof(files); i++) {
      /* Do not process it...  Merely load it from disk */
      parse->parse_file(files[i], 0, 1);
      fname = parse->query_file_name();
      if (fname) {
         fn = replace(fname, "/", ".");
         if (fn[0] == '.') {
            fn = fn[1..];
         }
         fn = NROFF_DOC_DIR + fn;
         bits = explode(fname[0..strlen(fname)-3], "/");
         rabbit = process_stuff(bits[sizeof(bits) - 1], "", fn,
                                parse->query_main_docs());
         if (rabbit[AUTO_INDEX_SUMMARY]) {
            summary_map[fname] = rabbit[AUTO_INDEX_SUMMARY];
         } else {
            map_delete(summary_map, fname);
         }
         /* We loaded it... */
         index_stuff += map(keys(parse->query_public_functions()),
                            (: process_stuff($1, $(fname), $(fn),
                               $(parse)->query_public_functions()) :) );
         index_stuff += map(keys(parse->query_protected_functions()),
                            (: process_stuff($1, $(fname), $(fn),
                               $(parse)->query_protected_functions()) :) );
         index_stuff += map(keys(parse->query_class_docs()),
                            (: process_stuff($1, $(fname), $(fn),
                               $(parse)->query_class_docs()) :) );
         if (sscanf(fname, "%*s.h") == 1) {
            index_stuff += map(keys(parse->query_define_docs()),
                               (: process_stuff($1, $(fname), $(fn),
                               $(parse)->query_define_docs()) :) );
         }
      }
      reset_eval_cost();
   }
   index_stuff += extra_indexes;
   extra_indexes = ({ });

   /* Don't call this out.  We would be copying huge arrays around.  Eeek. */
   for (i = 0; i < sizeof(filters); i++) {
      reset_eval_cost();
      catch(evaluate(filters[i], index_stuff, INDEX_FILE));
   }
   summary_map = ([ ]);
   last_created_index = time();
   save();
} /* create_index() */

/**
 * Recreate documentation for one fiel immediately.  This does not update
 * the index, it merely creates the base files for this file.  It does it
 * at a random delay of up to 30 seconds.
 *
 * @param fname the file name to update
 */
int recreate_documentation(string fname) {
   object ob;

   if (member_array(fname, files) != -1) {
      ob = clone_object(AUTODOC_FILE);
      ob->parse_file(fname, (: after_thingy(1) :));
      return 1;
   }
   return 0;
} /* recreate_documentation() */

/**
 * Regenerate the index files.
 */
void recreate_indexes() {
   unguarded( (: create_index() :));
} /* recreate_indexes() */

/**
 * Adds a file into the list of files to process for autodocumentation.
 * This file will be processed every time around in the autodocumentation
 * loop to check to see if it has been changed and the results will be
 * placed into the index.  It automaticly calls recreate_documentation
 * in random(60) seconds.
 *
 * @see recreate_documentation()
 *
 * @param fname the name of the file to add
 *
 * @return 1 if the add succeeds, 0 otherwise.
 */
int add_file(string fname) {
   fname = "/" + implode(explode(fname, "/") - ({ "" }), "/");
   if (member_array(fname, files) == -1) {
      if (sizeof(unguarded( (: stat($(fname)) :) ))) {
         files += ({ fname });
         save();
         if (sizeof(files) == 1) {
            start_processing();
         } else {
            call_out((: recreate_documentation($1) :), random(60), fname);
         }
         return 1;
      }
   }
   return 0;
} /* add_file() */

/**
 * Removes a file from the list of files to be processed for autodocumentation.
 *
 * @param fname the name of the file to remove
 *
 * @return 1 if the remove succeeds, 0 otherwise.
 */
int remove_file(string fname) {
   string fn;
   string dfn;
   string *our_files;
 
   if (member_array(fname, files) != -1) {
      files -= ({ fname });
      file_pos = 0;

      /* Delete the files associated with it, start with the html files. */
      fn = HTML_DOC_DIR + replace(fname, "/", ".");
      unguarded((: rm($(fn)) :));
      /* Delete the nroff files. */
      fn = NROFF_DOC_DIR + replace(fname, "/", ".");
      unguarded((: rm($(fn)) :));
      /* Delete the nroff single function files. */
      fn = NROFF_DOC_SINGLE + fname[0..<3] + "/";
      our_files = get_dir(fn);
      if (sizeof(our_files)) {
         foreach (dfn in our_files) {
            dfn =  fn + dfn;
            unguarded( (: rm($(dfn)) :) );
         }
      }
      /* Remove the directory if it exists. */
      if (file_size(fn[0..<2]) != -1) {
         unguarded((: rm($(fn[0..<2])) :));
      }

      save();
      if (!sizeof(files)) {
         remove_call_out(call_id);
      }
      return 1;
   }
   return 0;
} /* remove_file() */

private void load() {
   unguarded( (: restore_object( SAVE_FILE ) :) );
} /* load() */

private void save() {
   unguarded( (: save_object( SAVE_FILE ) :) );
} /* save() */

/**
 * Returns the list of files we are current processing.
 *
 * @return an array of strings being the file names
 */
string *query_files() { return files; }

/**
 * Returns the help mapping.  This is the mapping from function names to
 * files.  Each element in the mapping referes to an array of file
 * names which contain the function or define.
 *
 * @return a mapping of arrays of files
 */
mapping query_help_map() { return help_map; }

/**
 * This method returns the file name of the help for the specified
 * function in the specified file.
 * @param file the file name to find the help in
 * @param func the function to look for help on in the file
 * @return the full path to the help file, 0 if it does not exist
 */
string query_help_on(string file, string func) {
   if (file[0] == '/') {
      file = file[1..];
   }
   if (sscanf(file, "%*s.c") == 1) {
      file = file[0..<3];
   }
   file = NROFF_DOC_SINGLE + file + "/" + func;
   if (file_size(file) > 0) {
      return file;
   }
   return 0;
} /* query_help_on() */

/**
 * Retuirns the mapping of file names to a summary.  This is only
 * valid during the index creation cycle of the documentation generation
 * system.  It is used to create a more useful index page.
 * @return the mapping of file names to summarys
 */
mapping query_summary_map() { return summary_map; }

/**
 * This method tells us if the file is currently in the autodoc set.
 * @return 1 if the file is found, 0 if not
 */
int is_autodoc_file(string name) {
   return member_array(name, files) != -1;
} /* is_autodoc_file() */
// --- END [/mnt/home2/grok/lib/obj/handlers/autodoc/autodoc_handler.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/autodoc/autodoc_html.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/autodoc/autodoc_html.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628145   Available: 13575499
Inodes: Total: 5242880    Free: 4960134
25587 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/autodoc/autodoc_html.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628145   Available: 13575499
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: autodoc_html.c,v 1.14 2000/06/29 01:08:31 pinkfish Exp $
 * $Log: autodoc_html.c,v $
 * Revision 1.14  2000/06/29 01:08:31  pinkfish
 * Make it use a config define for it's address...
 *
 * Revision 1.13  2000/05/19 22:56:04  pinkfish
 * Fix it up to point to the right directory.
 *
 * Revision 1.12  2000/04/19 18:14:02  pinkfish
 * Fix up an error that was causing the code to runtime.
 *
 * Revision 1.11  1999/10/25 23:07:02  pinkfish
 * Fix up an output issue.
 *
 * Revision 1.10  1999/06/22 02:06:01  pinkfish
 * Update to use less writes when creating a file.
 *
 * Revision 1.9  1999/05/05 00:37:26  pinkfish
 * Fix up how the class names are output.
 *
 * Revision 1.8  1999/02/10 09:15:08  pinkfish
 * Fix up to use classes.
 *
 * Revision 1.7  1998/05/13 15:29:54  pinkfish
 * Fixed up the args printing stuff.
 *
 * Revision 1.6  1998/02/23 06:12:13  pinkfish
 * Put the different index types at the top of the main generated files.
 *
 * Revision 1.5  1998/02/23 05:53:41  pinkfish
 * Fixed up problems with the Change history stuff.
 *
 * Revision 1.4  1998/02/23 05:38:13  pinkfish
 * Make a standard index file...
 *
 * Revision 1.3  1998/02/23 05:30:09  pinkfish
 * Brinke the index up into creatro, effect and main lindexes.
 * Easier to find stuff...
 *
 * Revision 1.2  1998/02/22 13:00:53  pinkfish
 * changes to make the html a bit nicer and some biug fixing.
 *
 * Revision 1.1  1998/01/06 05:04:22  ceres
 * Initial revision
 * 
*/
/**
 * This creates an html document from the generated automatic documentation.
 *
 * @see /obj/handlers/autodoc/autodoc_handler
 * @author Pinkfish
 * @started Tue Oct 28 11:39:47 EST 1997
 */

#include <autodoc.h>
#include <config.h>

private string query_func_def(mixed *stuff, string func);
private string query_methods(string *funcs, function data,
                           int prot);
private string query_method_description(mapping docs);
private string create_href(string str);
private string query_method_summary(string *funcs, object file);
private string query_defines(string *defs, mapping docs);
private string query_class_summary(mapping classes);
private string query_classes(mapping classes);
private string query_class_def(mixed *stuff, string name);
private string query_class_description(mapping docs);

void create() {
   seteuid(getuid());
} /* create() */

/**
 * Writes the data from the autodoc file object out to a file in html
 * format.
 *
 * @param file the autodoc file object
 * @param output the output file to write to
 *
 * @see /obj/handlers/autodoc/autodoc_handler
 */
void create_html_file(object file, string output) {
   int i;
   mapping stuff;
   string *pub_funcs;
   string *pro_funcs;
   string *defs;
   string *bits;
   string name;
   string bing;

   /*
    * Ok, we do the alphabetised list, first a short list with the
    * first sentance of each description, then a longer expanded list..
    */
   bits = explode(file->query_file_name(), "/");
   name = bits[sizeof(bits)-1];
   bing = "<html><head><title>";
   bing += "File " + name +
           "\n</title></head><body bgcolor=\"#ffffff\" TEXT=\"#000030\" LINK=\"#4a529c\" VLINK=\"#b57339\">";
   bing += "[ <a href=\"index.html\">Package Index</a></code> | ";
   bing += "<a href=\"index_std.html\">Mudlib Index</a></code> | ";
   bing += "<a href=\"index_eff.html\">Effect Index</a></code> ]<br>";
   stuff = file->query_main_docs();
   if (stuff["main"]) {
      bing += "<h2>File " + file->query_file_name() +
                         "</h2>";
      bing += implode(stuff["main"], " ");
      if (stuff["see"]) {
         bing += "<p><b>See also:</b><br>" +
                            query_multiple_short(
                            map(stuff["see"], (: create_href($1) :)));
      }
      if (stuff["author"]) {
         bing += "<p>Written by " +
                    query_multiple_short(stuff["author"]);
      }
      if (stuff["started"]) {
         bing += "<p>Started " +
                    query_multiple_short(stuff["started"]);
      }

      if (stuff["example"]) {
         if (sizeof(stuff["example"]) > 1) {
            for (i = 0; i < sizeof(stuff["example"]); i++) {
               bing += "<h3>Example " + (i + 1) + "</h3>\n";
               bing += "<pre>"+stuff["example"][i]+"</pre>\n";
            }
         } else {
            bing +=  "<h3>Example</h3>\n<pre>" + stuff["example"][0] +
                             "</pre>\n";
         }
      }

      if (stuff["changed"]) {
         bing += "<h3>Change history</h3>\n<dl>" +
                            implode(map(stuff["changed"], function (string str) {
                   string start;
                   string rest;

                   if (sscanf(str, "%s\n%s", start, rest) == 2) {
                      return "<dt>" + start + "<dd>" + rest;
                   }
                   return "<dd>" + str;
             } ), "\n") + "</dl>\n";
      }
   }

   if (sizeof(file->query_inherits())) {
      bing += "<hr><h2>Inherits</h2>\n";
      bing += "This class inherits the following classes " +
                         query_multiple_short(
               map(keys(file->query_inherits()), (: create_href :)));
   }

   if (sizeof(file->query_includes())) {
      bing += "<hr><h2>Includes</h2>\n";
      bing += "This class includes the following files " +
                         query_multiple_short(
               map(file->query_includes(), (: create_href :)));
   }

   if (sizeof(file->query_class_docs())) {
       bing += query_class_summary(file->query_class_docs());
   }

   /*
    * Filter out create and setup as they are not real useful functions
    * to document :)
    */
   pub_funcs = keys(file->query_public_functions());
   pro_funcs = keys(file->query_protected_functions());

   /*
    * Create a summary list of the methods at the top of the file.
    * with pointers to a more indepth explantion.
    */
   bing += query_method_summary(pub_funcs + pro_funcs, file);

   /*
    * Create the more indepth explanation.
    */
   if (sizeof(pub_funcs)) {
      bing += "<hr><h2>Public Functions</h2>\n";
      bing += "These are functions that everyone can "
                         "access.<p><dl>\n.";
      bing += query_methods(pub_funcs, (: $(file)->query_public_functions()[$1] :),
                    0);
      bing += "</dl>\n";
   }

   if (sizeof(pro_funcs)) {
      bing += "<hr><h2>Protected Functions</h2>\n";
      bing += "These are functions that only "
                         "objects inheriting the class can access.<p>\n";
      bing += query_methods(pro_funcs, (: $(file)->query_protected_functions()[$1] :),
                    1);
      bing +=  "\n";
   }

   /* If it is an include file.  Do fun stuff with defines. */
   if (sscanf(name, "%*s.h") == 1 &&
       sizeof(file->query_define_docs())) {
      defs = sort_array(keys(file->query_define_docs()),
                        (: strcasecmp($1, $2) :));
      bing +=  "<hr><h2>Defines</h2>\n";
      query_defines(defs, file->query_define_docs());
      bing = "";
   }

   if (sizeof(file->query_class_docs())) {
      bing += "<hr><h2>Classes</h2>\n";
      bing += "These are nice data types for dealing with...  Data!"
                         "<p>\n";
      bing += query_classes(file->query_class_docs());
   }

   write_file(output, bing, 1);
   /* Ignore private functions, because they are less than useful anyway. */
   bing = "/www/footer"->www_function(output);
   write_file(output, bing + "</body></html>");
} /* create_html_file() */

/**
 * Creates a html index file from the input index information.
 * This will contain all the functions starting with a certain letter
 * and the corresponding files they are mentioned in.
 *
 * @param index the values in the index
 * @param letter the letter this is an index of
 * @param output the file to write the output to
 */
void create_html_index_file(string *index, string letter, string output) {
   int i;
   string name;
   string bing;

   bing = "<html><head><title>\nIndex of " + letter +
                      "\n</title></head><body bgcolor=\"#ffffff\" TEXT=\"#000030\" LINK=\"#4a529c\" VLINK=\"#b57339\">\n";
   bing += "<img align=left src=\"" + CONFIG_EXTERNAL_WEB_ADDRESS +
                       "pics/dw4.gif\">\n"
                      "<p align=right><code><a href=\"index.html\">"
                      "Main Index</a></code></p>\n"
                      "<h2>Index of " + letter + "</h2>\n"
                      "<h3><i>Letters can change the world, remove the l "
                      "from world and you have word</i></h3>\n"
                      "<br clear=both>\n"
                      "<hr><dl>\n";
   index = sort_array(index, (: strcasecmp($1[0], $2[0]) ? strcasecmp($1[0], $2[0]) :
                                        strcasecmp($1[1], $2[1]) :) );
   for (i = 0; i < sizeof(index); i++) {
      name = replace(index[i][AUTO_INDEX_FILE_NAME], "/", ".");
      if (name[0] == '.') {
         name = name[1..];
      }
      if (sscanf(index[i][AUTO_INDEX_NAME], "%*s.%*s") == 2) {
         bing += "<dt><img src=\"images/magenta-ball-small.gif\" "
                            "height=6 width=6 alt=\" . \"><b><a href=\"" +
                            name + ".html\">" + index[i][AUTO_INDEX_NAME] +
                            "</a></b>.\n";
      } else {
         bing += "<dt><img src=\"images/magenta-ball-small.gif\" "
                            "height=6 width=6 alt=\" . \"><b><a href=\"" +
                            name + ".html#" + index[i][AUTO_INDEX_NAME] +
                            "\">" + index[i][AUTO_INDEX_NAME] + "</a></b>" +
                            index[i][AUTO_INDEX_ARGS] +
                            "; <a href=\"" + name + ".html\">" +
                            index[i][AUTO_INDEX_FILE_NAME] + "</a>\n";
      }

      if (index[i][AUTO_INDEX_SUMMARY]) {
         bing += "<dd>"+index[i][AUTO_INDEX_SUMMARY]+"\n";
      }
      reset_eval_cost();
   }
   write_file(output, bing + "</dl>", 1);
   write_file(output, "/www/footer"->www_function(output) + "</body></html>");
} /* create_html_index_file() */

// Move these out to let us use function pointers on them.
private string bing_cre;
private string bing_eff;
private string bing_index;

/**
 * Creates the basic index file which points to all the other index
 * files...  The input letters array is a paired array, the first element
 * is the letter and the second is the file name.
 *
 * @param letters the names of all the other index files
 * @param output_dir the directory to write stuff to
 */
void create_main_index(mapping chars, string output_dir) {
   int i;
   string output_index;
   string output_eff;
   string output_cre;
   //string output_file;
   string *files;
   mixed *stuff;
   string str;
   string fname;
   string *index;
   mapping summaries;
   function write_all;
   string bing_file;
   string fluff;

   summaries = AUTODOC_HANDLER->query_summary_map();
   output_index = output_dir + "index_std.html";
   output_eff = output_dir + "index_eff.html";
   output_cre = output_dir + "index_cre.html";
   bing_cre = "";
   bing_eff = "";
   bing_file = "";
   bing_index = "";
 
   /* Rm the files so we write new ones... */
   rm (output_eff);
   rm (output_index);
   rm (output_cre);

   write_all = (: bing_eff += $1,
                  bing_cre += $1,
                  bing_index += $1 :);
   evaluate(write_all, "<html><head><title>\n");
   evaluate(write_all, "" + mud_name() + " autodoc index\n</title></head>\n"
                            "<body bgcolor=\"#ffffff\" TEXT=\"#000030\" "
                             "LINK=\"#4a529c\" VLINK=\"#b57339\">\n");
   bing_index += "<img align=left src=\"" + CONFIG_EXTERNAL_WEB_ADDRESS +
                      "/pics/dw4.gif\">\n"
                      "<h2>" + mud_name() + " Documentation</h2>\n"
                      "<h3><i>Where cabbages evaporate in the sun</i></h3>\n"
                      "<br clear=both>\n";
   bing_eff += "<img align=left src=\"" + CONFIG_EXTERNAL_WEB_ADDRESS + 
                      "/pics/dw4.gif\">\n"
                      "<h2>" + mud_name() + " Effect Documentation</h2>\n"
                      "<h3><i>Where your consequences are vanquished</i></h3>\n"
                      "<br clear=both>\n";
   bing_cre += "<img align=left src=\"" + CONFIG_EXTERNAL_WEB_ADDRESS +
                      "pics/dw4.gif\">\n"
                      "<h2>" + mud_name() + " Creator Documentation</h2>\n"
                      "<h3><i>Blue fluff?  No red and scruffy!</i></h3>\n"
                      "<br clear=both>\n";

   evaluate(write_all, "<h2>Function index</h2>\n");
   files = AUTODOC_HANDLER->query_files();
   files = sort_array(files, (: strcasecmp :) );
   index = sort_array(keys(chars), (: strcasecmp :) );
   for (i = 0; i < sizeof(index); i++) {
      if (i > 0) {
         evaluate(write_all, ", ");
      }
      evaluate(write_all, "<a href=\"" + chars[index[i]] + "\">" + index[i] +
                         "</a>\n");
   }

   /* Main index */
   bing_index += ", <a href=\"index_eff.html\">Effects</a>";
   bing_index += ", <a href=\"index_cre.html\">Creator</a>";
   /* Effect index */
   bing_eff += ", <a href=\"index.html\">Main</a>";
   bing_eff += ", <a href=\"index_cre.html\">Creator</a>";
   /* Creator index */
   bing_cre += ", <a href=\"index.html\">Main</a>";
   bing_cre += ", <a href=\"index_eff.html\">Effects</a>";

   evaluate(write_all, "<hr><h2>Class index</h2>\n");
   evaluate(write_all, "<dl>\n");

   stuff = unique_array(files, (: $1[0..strsrch($1, "/", -1)] :));
   for (i = 0; i < sizeof(stuff); i++) {
      str = stuff[i][0][0..strsrch(stuff[i][0], "/", -1)];
      if (str[0..12] == "/std/effects/") {
         bing_eff += "<dt><img src=\"images/cyan-ball.gif\" height=12 "
                            "width=12><b><a href=\"#" + str + "\">"+
                            str + "</a></b>\n";
      } else if (str[0..2] == "/w/") {
         bing_cre += "<dt><img src=\"images/cyan-ball.gif\" "
                            "height=12 "
                            "width=12><b><a href=\"#" + str + "\">"+
                            str + "</a></b>\n";
      } else {
         bing_index += "<dt><img src=\"images/cyan-ball.gif\" height=12 "
                            "width=12><b><a href=\"#" + str + "\">"+
                            str + "</a></b>\n";
      }
   }
   evaluate(write_all, "</dl>\n");
   
   for (i = 0; i < sizeof(stuff); i++) {
      fluff = "";
      str = stuff[i][0][0..strsrch(stuff[i][0], "/", -1)];
      fluff += "<h2><a name=\"" + str + "\">" + str + "</a></h2>\n<dl>\n";
      reset_eval_cost();
      foreach (str in stuff[i]) {
         fname = replace(str, "/", ".")[1..];
         fluff += "<dt><img src=\"images/cyan-ball-small.gif\" "
                            "height=6 width=6><a href=\"" + fname + ".html\">" +
                            str[strsrch(str, "/", -1) + 1..] + "</a>\n";
         if (summaries[str]) {
            fluff += "<dd>" + summaries[str] + "\n";
         }
      }
      fluff += "</dl>\n";
      if (stuff[i][0][0..12] == "/std/effects/") {
         bing_eff += fluff;
      } else if (stuff[i][0][0..2] == "/w/") {
         bing_cre += fluff;
      } else {
         bing_index += fluff;
      }
   }
   //evaluate(write_all, "@@/footer:footer@@</body></html>\n");
   write_file(output_eff, bing_eff, 1);
   write_file(output_eff,
              "/www/footer"->www_function(output_eff) + "</body></html");
   write_file(output_index, bing_index, 1);
   write_file(output_index,
              "/www/footer"->www_function(output_index) + "</body></html");
   write_file(output_cre, bing_cre, 1);
   write_file(output_cre,
              "/www/footer"->www_function(output_cre) + "</body></html");
} /* create_main_index() */

private string query_classes(mapping classes) {
   string name;
   string *names;
   string bing;

   names = sort_array(keys(classes), (: strcasecmp :) );
   bing = "<dl>\n";
   foreach (name in names) {
      reset_eval_cost();
      bing += "<dt><a name=\"class_" + name + "\">\n";
      bing += "<img src=\"images/cyan-ball.gif\" width=12 "
                         "height=12 alt=\" * \">";
      bing += "<b>" + name +
              "</b></a><pre>\n" +
              query_class_def(classes[name], name) + "\n</pre>";
      if (classes[name][AUTO_CLASS_DOCS]["main"]) {
         bing += query_class_description(classes[name][AUTO_CLASS_DOCS]);
      }
      bing += "\n";
   }
   return bing + "</dl>\n";
} /* query_classes() */

private string query_methods(string *funcs, function data,
                           int prot) {
   int i;
   mixed *stuff;
   string bing;

   funcs = sort_array(funcs, (: strcasecmp($1, $2) :));
   bing = "";
   for (i = 0; i < sizeof(funcs); i++) {
      reset_eval_cost();
      stuff = evaluate(data, funcs[i]);
      bing += "<dt><a name=\"" + funcs[i] + "\">\n";
      if (prot) {
        bing += "<img src=\"images/magenta-ball.gif\" width=12 "
                           "height=12 alt=\" * \">";
      } else {
        bing += "<img src=\"images/cyan-ball.gif\" width=12 "
                           "height=12 alt=\" * \">";
      }
      bing += "<b>" + funcs[i] +
                         "</b></a><pre>\n" +
                         query_func_def(stuff, funcs[i]) +
                         "\n</pre>";
      if (stuff[AUTO_DOCS]["main"]) {
         bing += query_method_description(stuff[AUTO_DOCS]);
      }
      bing += "\n";
   }
   return bing;
} /* query_methods() */

private string query_func_def(mixed *stuff, string func) {
   string ret;
   int i;
   int pad;

   ret = implode(stuff[AUTO_TYPE], " ") + " " + func+"(";
   pad = strlen(ret);
   for (i = 0; i < sizeof(stuff[AUTO_ARGS]); i += 2) {
      if (i) {
         ret += sprintf(",\n%-"+pad+"s", "");
      }
      ret += implode(stuff[AUTO_ARGS][i + AUTO_ARGS_TYPE], " ") + " " +
             stuff[AUTO_ARGS][i + AUTO_ARGS_NAME];
   }
   ret += ")";
   return ret;
} /* query_func_def() */

private string query_class_def(mixed *stuff, string name) {
   string ret;
   int pad;
   int i;

   ret = "class " + name + " {\n";
   pad = strlen(ret);
   for (i = 0; i < sizeof(stuff[AUTO_CLASS_MEMBERS]); i++) {
      ret += sprintf("%-" + pad + "s", "");
      ret += implode(stuff[AUTO_CLASS_MEMBERS][i][AUTO_CLASS_TYPE], " ") +
             " " + stuff[AUTO_CLASS_MEMBERS][i][AUTO_CLASS_NAME] + ";\n";
   }
   ret += "}\n";
   return ret;
} /* query_class_def() */

private string query_method_description(mapping docs) {
   int i;
   string name;
   string desc;
   string bing;

   bing = "";
   if (docs["main"]) {
      bing += "<dd>" + implode(docs["main"], " ")
                         +"<p>\n";
   }

   if (docs["param"] || docs["return"] || docs["see"] || docs["example"]) {
      bing += "<dd><dl>\n";
   }

   if (docs["param"]) {
      bing += "<dt><b>Parameters:</b>\n";
      for (i = 0; i < sizeof(docs["param"]); i++) {
         if (sscanf(docs["param"][i], "%s %s", name, desc) == 2) {
            bing += "<dd>" + name + " - " + (desc) + "\n";
         }
      }
   }

   if (docs["return"]) {
      bing += "<dt><b>Returns:</b>\n<dd>" + implode(docs["return"], " ") +
                         "\n";
   }

   if (docs["see"]) {
      bing += "<dt><b>See also:</b>\n<dd>" +
                         query_multiple_short(
                         map(docs["see"], (: create_href($1) :)));
   }

   if (docs["example"]) {
      bing += "<dt><b>Example:</b>\n<dd><pre>" + 
                 implode(docs["example"], "</pre><dd><pre>\n") +
                        "</pre>";
   }

   if (docs["param"] || docs["return"] || docs["see"] || docs["example"]) {
      bing += "</dl>\n";
   }

   return bing;
} /* query_method_description() */

private string query_class_description(mapping docs) {
   int i;
   string name;
   string desc;
   string bing;

   bing = "";
   if (docs["main"]) {
      bing += "<dd>" + implode(docs["main"], " ")
                         +"<p>\n";
   }

   if (docs["member"] || docs["see"]) {
      bing += "<dl>\n";
   }

   if (docs["member"]) {
      bing += "<dt><b>Members:</b>\n";
      for (i = 0; i < sizeof(docs["member"]); i++) {
         if (sscanf(docs["member"][i], "%s %s", name, desc) == 2) {
            bing += "<dd>" + name + " - " +
                               (desc) + "\n";
         }
      }
   }

   if (docs["see"]) {
      bing += "<dt><b>See also:</b>\n<dd>" +
                         query_multiple_short(
                         map(docs["see"], (: create_href($1) :)));
   }

   if (docs["member"] || docs["see"]) {
      bing += "</dl>\n";
   }

   return bing;
} /* query_class_description() */

/*
 * This creates a reference string from the input reference...
 */
private string create_href(string str) {
   string name;
   string ref_name;
   string func;

   if (sscanf(str, "%s#%s", name, func) == 2) {
      ref_name = replace(name, "/", ".");
      if (ref_name[0] == '.') {
         ref_name = ref_name[1..];
      }
      return "<a href=\"" + ref_name + ".c.html#" + func + "\">" +
             name + "->" + func + "()</a>";
   } else if (sscanf(str, "%s->%s", name, func) == 2) {
      sscanf(func, "%s(%*s)", func);
      ref_name = replace(name, "/", ".");
      if (ref_name[0] == '.') {
         ref_name = ref_name[1..];
      }
      return "<a href=\"" + ref_name + ".c.html#" + func + "\">" + str + "</a>";
   } else if (sscanf(str, "%s()", func) == 1) {
      return "<a href=\"#" + func + "\">" + str + "</a>";
   } else if (str[0..4] == "http:") {
      return "<a href=\"" + str + "\">" + str + "</a>";
   } else {
      ref_name = replace(str, "/", ".");
      if (ref_name[0] == '.') {
         ref_name = ref_name[1..];
      }
      if (sscanf(str, "%*s.%*s") != 2) {
         ref_name += ".c";
         str += ".c";
      }
      if (member_array(str, AUTODOC_HANDLER->query_files()) != -1) {
      /* Its an object reference */
         return "<a href=\"" + ref_name + ".html\">" + str + "</a>";
      }
      return str;
   }
} /* create_href() */

private string query_short_args_def(mixed *args) {
   string ret;
   int i;

   ret = "";
   for (i = 0; i < sizeof(args); i += 2) {
      if (i != 0) {
         ret += ", ";
      }
      ret += implode(args[i + AUTO_ARGS_TYPE], " ");
   }
   return "(" + ret + ")";
} /* query_short_args_def() */

private string query_short_desc(mapping docs) {
   mixed main;
   int pos;
   int tmp_pos;

   main = docs["main"];
   if (!main) {
      return 0;
   }

   /* Look for the first sentance... */
   main = implode(main, " ");
   pos = strlen(main);
   tmp_pos = strsrch(main, ".");
   if (tmp_pos < pos && tmp_pos != -1) {
      pos = tmp_pos;
   }
   tmp_pos = strsrch(main, "?");
   if (tmp_pos < pos && tmp_pos != -1) {
      pos = tmp_pos;
   }
   tmp_pos = strsrch(main, "!");
   if (tmp_pos < pos && tmp_pos != -1) {
      pos = tmp_pos;
   }
   
   return main[0..pos];
} /* query_short_desc() */

private string query_class_summary(mapping classes) {
   string *names;
   string name;
   string short_desc;
   string bing;

   names = sort_array(keys(classes), (: strcasecmp :));
   bing = "<hr><h2>Class Index</h2>\n";
   bing += "<dl>";
   foreach (name in names) {
      bing += "<dt><img src=\"images/cyan-ball-small.gif\" "
                         "height=6 width=6 alt=\" o \">\n";
      
      bing += "<a href=\"#class_" + name + "\"><b>" + name +
                         "</b></a>\n";
      short_desc = query_short_desc(classes[name][AUTO_CLASS_DOCS]);
      if (short_desc) {
         bing += "<dd>" + short_desc + "\n";
      }
   }
   bing += "</dl>";
   return bing;
} /* query_class_summary() */

private string query_method_summary(string *funcs,
                                  object file) {
   int i;
   mixed *stuff;
   string short_desc;
   int prot;
   string bing;

   bing = "";
   if (sizeof(funcs)) {
      bing += "<hr><h2>Method index</h2>\n<dl>";
      funcs = sort_array(funcs, (: strcasecmp :) );
      for (i = 0; i < sizeof(funcs); i++) {
         if (file->query_public_functions()[funcs[i]]) {
            stuff = file->query_public_functions()[funcs[i]];
            prot = 0;
         } else if (file->query_protected_functions()[funcs[i]]) {
            stuff = file->query_protected_functions()[funcs[i]];
            prot = 1;
         }

       
         if (prot) {
           bing += "<dt><img src=\"images/magenta-ball-small.gif\" "
                              "height=6 width=6 alt=\" o \">\n";
         } else {
           bing += "<dt><img src=\"images/cyan-ball-small.gif\" "
                              "height=6 width=6 alt=\" o \">\n";
         }
         bing += "<a href=\"#" + funcs[i] + "\"><b>" + funcs[i] +
                            "</b></a>" + query_short_args_def(stuff[AUTO_ARGS])
;
         short_desc = query_short_desc(stuff[AUTO_DOCS]);
         if (short_desc) {
            bing += "<dd>" + short_desc + "\n";
         }
      }
      bing += "</dl>";
   }
   return bing;
} /* query_method_summary() */

private string query_defines(string *defs, mapping docs) {
   int i;
   string bing;

   bing = ""; 
   for (i = 0; i < sizeof(defs); i++) {
      bing +=  "<dt><a name=\"" + defs[i] + "\">\n";
      bing += "<img src=\"images/red-ball.gif\" width=12 "
                         "height=12 alt=\" * \"><b>" + defs[i] + "</b></a>\n";
      if (docs[defs[i]]["main"]) {
         bing += query_method_description(docs[defs[i]]);
      }
   }
   return bing;
} /* query_defines() */
// --- END [/mnt/home2/grok/lib/obj/handlers/autodoc/autodoc_html.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/firework.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/firework.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628139   Available: 13575493
Inodes: Total: 5242880    Free: 4960134
4561 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/firework.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628139   Available: 13575493
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: firework.c,v 1.5 2002/09/20 11:15:06 tilly Exp $
 * $Log: firework.c,v $
 * Revision 1.5  2002/09/20 11:15:06  tilly
 * Typo.
 *
 * Revision 1.4  1998/06/08 00:50:08  presto
 * fixed typo, removed unused variable.
 *
 * Revision 1.3  1998/04/19 19:59:45  pinkfish
 * Add in the missed $
 *
 * Revision 1.2  1998/04/19 18:33:47  pinkfish
 *  Added documentation.
 *
 * Revision 1.1  1998/01/06 05:03:33  ceres
 * Initial revision
 * 
 */
/**
 * This handler helps control the fireworks used in the wizards spells.
 */
#define BROADCASTER "/obj/handlers/broadcaster"
#define MAX_RANGE 1600
#define SHIFT 30 /* needs to be more, once broadcaster is better */
#define TIME 15

class firework_running {
   string *messages;
   int index;
   string caster;
   string text;
   int *co_ord;
}

mixed *_effects;
class firework_running *_fireworks;

protected void do_effects();

void create() {
  _effects = ({
    ({
      "A small dot flashes up high into the sky.",
      "The dot suddenly bursts open revealing bright multicoloured streams "
          "of flame that pour down towards the ground.",
      "Just as you thought the streams had faded to nothing, they shoot back "
          "up into the air giving a final brilliant yellow colour before "
          "vanishing entirely.",
      "As it fades you think you see the letters \"$arg$\" in the gradually "
          "disappearing smoke.",
    }),
    ({
      "A brilliant trail of yellow sparks follows a small dot up into the "
          "sky.",
      "The dot slowly slows down until it has stopped moving, and hovers for "
          "a few seconds.",
      "Suddenly the dot explodes, sending out bright red streamers of light "
          "in all directions and lighting up the sky for a few seconds.",
      "The red light fades to nothingness, and the last colour left in the "
          "sky shows the letters \"$arg$\" which slowly disappear.",
    }),
    ({
      "A light flashes up high into the sky trailing grey smoke behind it.",
      "The light wizzes around in circles making a high pitched whizzing "
          "noise.",
      "The dot bursts open sending brilliant green streamers of light to "
          "all the corners of the sky.",
      "With a sudden resounding bang, the streamers rush back together to form "
          "\"$arg$\" which hangs in the sky before slowly vanishing."
    }),
  });
  _fireworks = ({ });
} /* create() */

/**
 * This method creates a random firework at the casters location from the
 * current list of fireworks.  If the text field is not filled in then
 * the casters name is used.
 * @param caster the caster of the spell
 * @param text the text to print in the firework
 * @see do_effect()
 */
varargs void random_firework( object caster, string text ) {
  mixed *co_ord;
  class firework_running new_firework;

  co_ord = (mixed *)environment( caster )->query_co_ord();
  if ( sizeof( co_ord ) < 3 ) {
    co_ord = ({ 0, 0, 0 });
  }
  if ( !text || ( text == "" ) ) {
    text = (string)caster->query_name();
  }
  new_firework = new(class firework_running);
  new_firework->messages = _effects[random(sizeof(_effects))];
  new_firework->index = 0;
  new_firework->text = capitalize(text);
  new_firework->co_ord = ({ co_ord[ 0 ], co_ord[ 1 ], co_ord[ 2 ] + SHIFT });
  if ( !sizeof(_fireworks)) {
    call_out( (: do_effects :), TIME );
  }
  _fireworks += ({ new_firework });
} /* random_firework() */

/**
 * This method broadcasts the actual firework messages.
 * @see random_firework()
 */
protected void do_effects() {
  class firework_running firework;

  foreach (firework in _fireworks) {
    BROADCASTER->broadcast_event( users(), firework->co_ord, "you see:\n"+
        replace( firework->messages[firework->index] , "$arg$",
        firework->text ), MAX_RANGE, 0, 0 );
    firework->index++;
    if ( firework->index >= sizeof( firework->messages ) ) {
      _fireworks -= ({ firework });
    }
  }
  if ( sizeof( _fireworks ) ) {
    call_out( (: do_effects :), TIME );
  }
} /* do_effects() */

/**
 * This method returns the list of fireworks currently available.
 * The list constists of an array of firework effects.  Each effect
 * consists of a list of strings.  The strings are printed one by
 * one with a delay between each. <br>
 * ie:
 * <pre>
 * ({
 *   ({
 *      mess1,
 *      mess2,
 *      ...
 *    }),
 *   ({
 *      /\* Second effect *\/
 *    })
 * });
 * </pre>
 * @return the effects array
 */
mixed *query_effects() {
   return _effects;
} /* query_effects() */
// --- END [/mnt/home2/grok/lib/obj/handlers/firework.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/route_handler.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/route_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628137   Available: 13575491
Inodes: Total: 5242880    Free: 4960134
3217 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/route_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628137   Available: 13575491
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker: wodan $
 * $Id: route_handler.c,v 1.11 2002/03/16 22:08:01 wodan Exp wodan $
 * $Log: route_handler.c,v $
 * Revision 1.11  2002/03/16 22:08:01  wodan
 * don't do routes for npcs in /room/virtual
 *
 * Revision 1.10  1999/07/28 18:00:25  wodan
 * don't do anything for no longer existing npcs
 *
 * Revision 1.9  1999/06/09 13:02:37  wodan
 * used same variable name twice, oops :)
 *
 * Revision 1.8  1999/04/15 13:39:17  wodan
 * removed old route stuff.
 *
 * Revision 1.7  1999/04/15 13:33:49  wodan
 * changed to use the clusters handler
 *
 * Revision 1.6  1999/04/14 12:06:11  ceres
 *  Forcibly unlocked by wodan
 *
 * Revision 1.5  1998/12/17 08:05:16  terano
 * not quite sure :)
 *
 * Revision 1.4  1998/09/07 15:54:40  terano
 * Took out the cluster stuff after it was taking newbies to the UU via the sto lat plains
 *
 * Revision 1.3  1998/09/04 13:39:55  wodan
 * changed the search_room call to a call to the clusters handler.
 *
 * Revision 1.2  1998/01/14 13:34:26  wodan
 * changed it so it searches 3000 rooms instead of 200 like it says in the comment, 200 isn't enough for any practical use
 *
 * Revision 1.1  1998/01/06 05:03:33  ceres
 * Initial revision
 * 
*/
/**
 * Figures out the route between two destinations for an npc to travel.
 * @author Wodan
 */
/* routes handler */

int use_count;

/**
 * Try and figure out a route between two locations.  It figures out
 * the route bwteen the two locations and then calls the
 * call_back function with the found route, or not found route.
 * If the route is not found, an empty array will be returend.  The
 * function in the npc object move_me_to() handles the call
 * to this function transparently.
 * @param end the end location
 * @param start where to start from
 * @param call_back the function to call when finished
 * @see /obj/monster->move_me_to()
 * @example
 * // Find how to get from here back to the drum.
 * // Then print the route out.
 * ROUTE_HANDLER->get_route("/d/am/am/mendeddrum",
 *                          file_name(environment(this_object())),
 *                          (: printf("%O\n", $1) :));
 */
varargs void get_route(string end, string start, function call_back, int count) {
  string *result;

  if(start == "/room/virtual"){
    call_out((: evaluate($(call_back), ({ })) :), 1);
    return;
  }
  
  if(!(stringp(start) && stringp(end)))
    error("illegal argument 1 or 2 to get_route");
  
  if(!function_owner(call_back))
    return; //don't bother

  if ((end == start) || (count > 3)){
    call_out((: evaluate($(call_back), ({ })) :), 1);
    if(end != start)
      log_file("ROUTEHANDLER","route for %s from %s to %s failed\n",
               file_name(function_owner(call_back)), start, end);
    return;
  }

  result = "/obj/handlers/clusters"->get_route(start, end);
  
  if(!result){
    call_out((:get_route($(end), $(start), $(call_back), $(count + 1)):), 10);
    return;
  }

  use_count++;
  call_out((: evaluate($(call_back), $(result)) :), 1);
  return;
} /* get_route */

/** @ignore yes */
void dest_me() {
  destruct(this_object());
} /* dest_me() */

/** @ignore yes */
mixed *stats() {
  return  ({
    ({ "routes done", use_count }),
  });
}
// --- END [/mnt/home2/grok/lib/obj/handlers/route_handler.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/new_soul.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/new_soul.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628136   Available: 13575490
Inodes: Total: 5242880    Free: 4960134
37267 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/new_soul.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628136   Available: 13575490
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker: presto $
 * $Id: new_soul.c,v 1.30 2003/04/09 01:27:20 presto Exp presto $
 */
/**
 * The soul handler for Discworld.  Handles the soul definitions and
 * the mangling needed to print the output for the players.
 *
 * @author Pinkfish
 */
#include <player.h>
#include <soul.h>
#include <user_parser.h>

#define SAVE_FILE "/save/soul"
#define SOUL_DATA_DIR "/save/soul/data/"

#define POS_SELF   0
#define POS_TARGET 1
#define POS_REST   2

#define PCACHE_MAX_SIZE 30
#define SCACHE_MAX_SIZE 100
#define CLEAN_UP_DELAY 300

/*
 * The soul driver itself...
 */
mixed soul_commands;
mapping soul_command_names;

nosave mapping pattern_cache;
nosave mapping soul_cache;
nosave string *pcache_order,
 *scache_order;
nosave int scache_hits, scache_reads, pcache_hits, pcache_reads, cache_callout;

void load_it();
void save_it();
void print_messages(string verb, mixed obs, string arg, string self,
                    string rest, string target, string force,
                    mapping position);
protected void save_soul_command(string name, mixed *data);

void create() {
  soul_commands = 0;
  soul_command_names = ([ ]);
  pattern_cache = ([ "" : NO_ARGUMENT ]);
  pcache_order = ({ });
  scache_order = ({ });
  soul_cache = ([ ]);
  seteuid("Room");
  load_it();
}


void clean_cache() {
  int i;
  
  for (i = 0; i < (sizeof(pcache_order) - PCACHE_MAX_SIZE); i++) {
    map_delete(pattern_cache, pcache_order[i]);
  }
  pcache_order = pcache_order[i..];
  
  
  for (i = 0; i < (sizeof(scache_order) - SCACHE_MAX_SIZE); i++) {
    map_delete(soul_cache, scache_order[i]);
  }
  scache_order = scache_order[i..];
  cache_callout = 0;
}

/**
 * Adds in a soul command.  Only allows additions from
 * the soul compiler.
 *
 * @see /obj/handlers/soul_compiler.c
 * @param name the name of the soul command
 * @param data the data associated with the soul command
 */
void add_soul_command(string name, mixed data) {
  if (file_name(previous_object()) != SOUL_COMPILER)
    return;
  save_soul_command(name, data);
  map_delete(soul_cache, name);
  save_it();
}

/**
 * Deletes the soul command.  This is used to remove soul commands
 * that are no longer used.
 * 
 * @param name the soul command name to delete
 */
void delete_soul_command(string name) {
  map_delete(soul_cache, name);
  map_delete(soul_command_names, name);
  unguarded((: rm, SOUL_DATA_DIR + name + ".os" :));
  save_it();
}

/**
 * The name of all the soul commands.
 *
 * @return an array containing the names of all the soul commands
 */
string *query_soul_commands() {
  return keys(soul_command_names);
}

/**
 * Used internally to get the soul command data.
 *
 * @param str the soul command to get data for
 * @return the soul command data
 * @see query_soul_command_stuff()
 */
protected mixed *query_soul_command_data(string str) {
  scache_reads++;
  /* This function will load in the rubbish from the disk. */
  if (!soul_cache[str] && soul_command_names[str]) {
    string tmp;
    
    tmp = unguarded((: read_file, SOUL_DATA_DIR + str + ".os" :));
    soul_cache[str] = restore_variable(tmp);
    
    if (!cache_callout && (sizeof(scache_order) > SCACHE_MAX_SIZE))
      cache_callout = call_out("clean_cache", CLEAN_UP_DELAY);
  } else {
    scache_order -= ({ str });
    scache_hits++;
  }
  
  scache_order += ({ str });
  return soul_cache[str];
}

/**
 * Returns the data associated with soul command.
 * Probably not very useful, but useful for debugging.
 *
 * @param str the soul command to get the data for
 * @return the data associated with the soul command
 */
mixed *query_soul_command_stuff(string str) {
  return query_soul_command_data(str) + ({ });
}

/**
 * @ignore yes
 */
protected void save_soul_command(string name, mixed *data) {
  string str;
  
  str = save_variable(data);
  unguarded((: rm, SOUL_DATA_DIR + name + ".os" :));
  unguarded((: write_file, SOUL_DATA_DIR + name + ".os", str :));
  soul_command_names[name] = 1;
}

/**
 * Saves the current state of the soul object.
 */
void save_it() {
  unguarded((: save_object, SAVE_FILE :));
}

/**
 * Loads the previous state of the soul object off the disc.
 */
void load_it() {
  string *names;
  int i;
  
  unguarded((: restore_object, SAVE_FILE :));
  if (mapp(soul_commands)) {
    /* Ok, we convert it to the new format... */
    soul_command_names = ([ ]);
    names = keys(soul_commands);
    for (i = 0; i < sizeof(names); i++) {
      reset_eval_cost();
      save_soul_command(names[i], soul_commands[names[i]]);
    }
    soul_commands = 0;
    save_it();
  }
}

private mixed create_pattern_cache(string pattern) {
  mixed *bing, ret;
  string s1, s2;

  bing = explode("#" + pattern, "<indirect:");
  if (sizeof(bing) == 1)
    if (sscanf(bing[0], "%s<word>%s", s1, s2) ||
        sscanf(bing[0], "%s<string>%s", s1, s2))
      ret = ONLY_ARGUMENT;
    else
      ret = NO_ARGUMENT;
  else if (sscanf(bing[0], "%s<word>%s", s1, s2) ||
           sscanf(bing[0], "%s<string>%s", s1, s2))
    ret = ARGUMENT_FIRST;
  else if (sscanf(bing[1], "%s<word>%s", s1, s2) ||
           sscanf(bing[1], "%s<string>%s", s1, s2))
    ret = ARGUMENT_SECOND;
  else
    ret = ONLY_TARGET;
  return ret;
}

/**
 * This returns the arrays that are used by the pattern
 * matcher in the player object. Called from inside add_command interface.
 *
 * @param name the souul command name to find
 * @return 0 if no command found, otherwise an array of patterns
 * @see /global/new_parse->add_command()
 */
mixed *query_soul_command(string name) {
  mixed *data;
  mixed *ret;
  string pat;
  int i;
  
  if (!soul_command_names[name]) {
    return 0;
  }
  data = query_soul_command_data(name);
  if (!data) {
    return 0;
  }
  ret = ({ ({ ({ }), "", 0, this_object(), 0 }) });
  for (i = 0; i < sizeof(data[PATTERNS]); i++) {
    pat = data[PATTERNS][i];
    
    pcache_reads++;
    if (!pattern_cache[pat]) {
      pattern_cache[pat] = create_pattern_cache(pat);
      if (!cache_callout && sizeof(pcache_order) > PCACHE_MAX_SIZE) {
        cache_callout = call_out("clean_cache", CLEAN_UP_DELAY);
      }
    } else {
      pcache_hits++;
      pcache_order -= ({ pat });
    }
    pcache_order += ({ pat });
    
    ret += ({ ({ ((mixed *) PATTERN_OB->query_pattern(pat))[1],
                   pat, 0, this_object(), 0 }) });
  }
  return ret;
}

/**
 * The main soul handling bit.  This is called by the add_command code
 * when a soul command is matched.
 *
 * @param verb the verb matched
 * @param obs the objects to do the soul command on
 * @param in_dir_match the name which was matched for the peoples names
 * @param args the values of the string and stuff
 * @param pattern the pattern which was matched.
 * @return 1 if the command succeeded, 0 if it failed
 */
int command_control(string verb, object * obs, string, string in_dir_match,
                    string *args, string pattern) {
  int i;
  int j;
  string arg;
  mixed *stuff;
  object *wom;
  object *rem;
  mixed *data;
  
  if (!soul_command_names[verb]) {
    return 0;
  }
  if (pattern != "") {
    stuff = PATTERN_OB->query_pattern(pattern);
    for (i = 1; i < sizeof(stuff); i++) {
      switch (stuff[i]) {
      case INDIRECT_OBJECT:
        /* Ok, in here we check for remote and multiple soul earmuffs... */
        i += 2;
        wom = obs;
        if (previous_object()->query_property("no soul")) {
          previous_object()->add_failed_mess(this_object(),
                                           "You cannot use directed souls.\n",
                                             ({ }));
          return 0;
        }
        
        // check for ignoring people
        if ((sizeof(obs) == 1) &&
            !previous_object()->query_creator() &&
            obs[0]->query_property("ignoring") &&
            member_array((string) previous_object()->query_name(),
                         (string *)obs[0]->query_property("ignoring")) != -1) {
          return 0;
        }
        
        /* prevent multiple souls to people with multiple-soul earmuffed or
         * creators who are invis
         */
        if (sizeof(obs) > 1) {
          obs = filter(obs, (: !$1->check_earmuffs("multiple-soul") :));
          if (!sizeof(obs)) {
            previous_object()->add_failed_mess(this_object(),
               "Everyone seems to have their multiple souls earmuffed.  "
               "I'm depressed, are you depressed?\n",
                                               ({ }));
            return 0;
          }
        }
        
        /*
         * prevent remote souls to npcs, to people you cant see and to
         * people who are role-playing and not in your environment
         */
        rem = filter(obs,
                     (:
                      (!interactive($1) &&
                       environment(previous_object(1)) != environment($1)) ||
                      //!$1->query_visible(previous_object(1)) ||
                      (interactive($1) && $1->query_role_playing() &&
                       environment($1) != environment(previous_object(1)))
                      :));
        obs -= rem;
        obs -= previous_object()->query_ignoring(obs);
        
        /*
         * people who are roleplaying cannot use remote souls or souls to
         * people they don't know.
         */
         if(previous_object()->query_role_playing())
           obs -= filter(obs,
                         (:
                          environment($1) != environment(previous_object(1)) ||
                          (interactive($1) &&
                           !previous_object(1)->is_friend($1->query_name()))
                          :));
         
         if (!sizeof(obs)) {
           return 0;
         }
         if (previous_object()->check_earmuffs("remote-soul")) {
           if (previous_object()->query_earmuffs() ==
               PLAYER_ALLOW_FRIENDS_EARMUFF) {
             rem = filter(obs,
                          (:
                          environment(previous_object(1)) != environment($1) &&
                           !previous_object(1)->is_friend($1->query_name())
                           :));
           } else {
             rem = filter(obs,
                          (:
                           environment(previous_object(1)) != environment($1)
                           :));
           }
           if (sizeof(rem) == sizeof(obs)) {
             previous_object()->add_failed_mess(this_object(),
               "You cannot do a remote soul when you have remote souls "
                                                "earmuffed.\n", ({ }));
             return 0;
           }
           obs = obs - rem;
         } else {
           obs = filter(obs, (: !$1->check_earmuffs("remote-soul") ||
                              (environment(previous_object(1)) ==
                               environment($1)) :));
           if (!sizeof(obs)) {
             previous_object()->add_failed_mess(this_object(),
               "Remote soul earmuffs enabled for $I.\n", wom);
             return 0;
           }
         }
         j++;
         break;
       case STRING:
       case SINGLE_WORD:
       case SHORT_STRING:
         arg = args[j++];
         break;
       case NUMBER:
         j++;
         break;
       case FRACTION:
         j += 2;
         break;
       case OPTIONAL:
       case OPTIONAL_SPACES:
         i++;
         break;
       case WORD_LIST:
       case WORD_LIST_SPACES:
         i++;
         if (pointerp(stuff[i]) && sizeof(stuff[i]) > 1)
           j++;
         break;
       }
     }
   }
   /*
    * Ok.  We have this soul command.  Lets find out what sort of
    * pattern we have
    */
   if (!pattern_cache[pattern]) {
     return 0;
   }
   if (!previous_object()->query_creator()) {
     if ((int) previous_object()->adjust_sp(-SOUL_COST *
                                            (1 + sizeof(obs))) < 0) {
       previous_object()->add_failed_mess(this_object(), NO_POWER, ({ }));
       return 0;
     }
   }
   data = query_soul_command_data(verb);
   switch (pattern_cache[pattern]) {
   case NO_ARGUMENT:
     /*
      * This case.  Means we try the no_argument thing first.  Otherwise
      * we pick the first argument one and use that.
      */
     if (data[SINGLE])
       if (data[SINGLE][NO_ARGUMENTS]) {
         if (sizeof(data[SINGLE][NO_ARGUMENTS]) > POSITION_SINGLE) {
           print_messages(verb, 0, "", data[SINGLE][NO_ARGUMENTS][SELF],
                          data[SINGLE][NO_ARGUMENTS][REST],
                          0, 0,
                          data[SINGLE][NO_ARGUMENTS][POSITION_SINGLE]);
         } else {
           print_messages(verb, 0, "", data[SINGLE][NO_ARGUMENTS][SELF],
                          data[SINGLE][NO_ARGUMENTS][REST], 0, 0, 0);
         }
         return 1;
       } else {
         if (!data[SINGLE][ARGUMENTS])
           return 0;
         arg = data[SINGLE][ARGUMENTS][ARGS][0];
       } else
         return 0;
   case ONLY_ARGUMENT:
     if (arg == "?") {
       /* Find a random arguement... */
       j = 0;
       for (i = 0; i < sizeof(data[SINGLE][ARGUMENTS]); i += SMALL_ARG_SIZE)
         j += sizeof(data[SINGLE][ARGUMENTS][i + ARGS]);
       j = random(j);
       for (i = 0; i < sizeof(data[SINGLE][ARGUMENTS]); i += SMALL_ARG_SIZE)
         if (j < sizeof(data[SINGLE][ARGUMENTS][i + ARGS])) {
           if (data[SINGLE][ARGUMENTS][i + ARGS][j] == "#") {
             if (j > 0)
               j--;
             else {
               j++;
               if (j >= sizeof(data[SINGLE][ARGUMENTS][i + ARGS])) {
                 j -= sizeof(data[SINGLE][ARGUMENTS][i + ARGS]);
                 continue;
               }
             }
           }
           print_messages(verb, 0, data[SINGLE][ARGUMENTS][i + ARGS][j],
                          data[SINGLE][ARGUMENTS][i + SELF],
                          data[SINGLE][ARGUMENTS][i + REST], 0, 0,
                          data[SINGLE][ARGUMENTS][i + POSITION_SINGLE]);
           return 1;
         } else {
           j -= sizeof(data[SINGLE][ARGUMENTS][i + ARGS]);
         }
     }
     /* Ok, now to find the argument... */
     for (i = 0; i < sizeof(data[SINGLE][ARGUMENTS]); i += SMALL_ARG_SIZE) {
       if ((j = member_array(arg, data[SINGLE][ARGUMENTS][i + ARGS], 0, 1))
           != -1) {
         /* Found... */
         print_messages(verb, 0, data[SINGLE][ARGUMENTS][i + ARGS][j],
                        data[SINGLE][ARGUMENTS][i + SELF],
                        data[SINGLE][ARGUMENTS][i + REST],
                        0, 0,
                        data[SINGLE][ARGUMENTS][i + POSITION_SINGLE]);
         return 1;
       }
     }
     /* No argument.  SO we check for a wildcard */
     for (i = 0; i < sizeof(data[SINGLE][ARGUMENTS]); i += SMALL_ARG_SIZE)
       if ((j = member_array("#", data[SINGLE][ARGUMENTS][i + ARGS], 0, 1))
           != -1) {
         /* Found... */
         print_messages(verb, 0, arg,
                        data[SINGLE][ARGUMENTS][i + SELF],
                        data[SINGLE][ARGUMENTS][i + REST], 0, 0,
                        data[SINGLE][ARGUMENTS][i + POSITION_SINGLE]);
         return 1;
       }
     /* No argument found... */
     previous_object()->add_failed_mess(this_object(),
                                        arg +
                                        " is not a valid argument to the soul "
                                        "command \"" + verb + "\".\n",
                                        ({ }));
     return 0;
   case ARGUMENT_FIRST:
   case ARGUMENT_SECOND:
     break;
   case ONLY_TARGET:
     if (data[TARGET][NO_ARGUMENTS]) {
       obs->event_soul_command(this_object(), verb, previous_object(),
                               in_dir_match, 0);
       print_messages(verb, obs, "",
                      data[TARGET][NO_ARGUMENTS][SELF],
                      data[TARGET][NO_ARGUMENTS][REST],
                      data[TARGET][NO_ARGUMENTS][TARGET],
                      data[TARGET][NO_ARGUMENTS][FORCE],
                      data[TARGET][NO_ARGUMENTS][POSITION]);
       return 1;
     }
     /* Ok.  Now, we return 0 if there is no argument one */
     if (!data[TARGET][ARGUMENTS]) {
       return 0;
     }
     arg = data[TARGET][ARGUMENTS][ARGS][0];
     break;
   }
   if (arg == "?") {
     /* Find a random argument... */
     j = 0;
     for (i = 0; i < sizeof(data[TARGET][ARGUMENTS]); i += ARG_SIZE) {
       j += sizeof(data[TARGET][ARGUMENTS][i + ARGS]);
     }
     j = random(j);
     for (i = 0; i < sizeof(data[TARGET][ARGUMENTS]); i += ARG_SIZE) {
       if (j < sizeof(data[TARGET][ARGUMENTS][i + ARGS])) {
         if (data[TARGET][ARGUMENTS][i + ARGS][j] == "#") {
           if (j > 0) {
             j--;
           } else {
             j++;
             if (j >= sizeof(data[TARGET][ARGUMENTS][i + ARGS])) {
               j -= sizeof(data[TARGET][ARGUMENTS][i + ARGS]);
               continue;
             }
           }
         }
         obs->event_soul_command(this_object(), verb, previous_object(),
                                 in_dir_match, arg);
         print_messages(verb, obs, data[TARGET][ARGUMENTS][i + ARGS][j],
                        data[TARGET][ARGUMENTS][i + SELF],
                        data[TARGET][ARGUMENTS][i + REST],
                        data[TARGET][ARGUMENTS][i + TARGET],
                        data[TARGET][ARGUMENTS][i + FORCE],
                        data[TARGET][ARGUMENTS][i + POSITION]);
         return 1;
       } else {
         j -= sizeof(data[TARGET][ARGUMENTS][i + ARGS]);
       }
     }
   }
   for (i = 0; i < sizeof(data[TARGET][ARGUMENTS]); i += ARG_SIZE) {
     if ((j =
          member_array(arg, data[TARGET][ARGUMENTS][i + ARGS], 0,
                       1)) != -1) {
       /* Found... */
       obs->event_soul_command(this_object(), verb, previous_object(),
                               in_dir_match, arg);
       print_messages(verb, obs, data[TARGET][ARGUMENTS][i + ARGS][j],
                      data[TARGET][ARGUMENTS][i + SELF],
                      data[TARGET][ARGUMENTS][i + REST],
                      data[TARGET][ARGUMENTS][i + TARGET],
                      data[TARGET][ARGUMENTS][i + FORCE],
                      data[TARGET][ARGUMENTS][i + POSITION]);
       return 1;
     }
   }
   /* No argument found.  Check for wildcard */
   for (i = 0; i < sizeof(data[TARGET][ARGUMENTS]); i += ARG_SIZE) {
     if ((j =
          member_array("#", data[TARGET][ARGUMENTS][i + ARGS], 0,
                       1)) != -1) {
       /* Found... */
       obs->event_soul_command(this_object(), verb, previous_object(),
                               in_dir_match, arg);
       print_messages(verb, obs, arg,
                      data[TARGET][ARGUMENTS][i + SELF],
                      data[TARGET][ARGUMENTS][i + REST],
                      data[TARGET][ARGUMENTS][i + TARGET],
                      data[TARGET][ARGUMENTS][i + FORCE],
                      data[TARGET][ARGUMENTS][i + POSITION]);
       return 1;
     }
   }
   /* No argument found... */
   return 0;
}

string get_name(object ob, int use_name, int type) {
  if(ob == previous_object())
    return ob->query_objective() + "self";
  if(userp(ob) && use_name && environment(ob) != environment(previous_object()))
    return "$mirror_short:" + file_name(ob) + "$";
  return ob->one_short(use_name);
}

private string create_message(mixed targets, string args, string pattern,
                              int type, string verb, string position,
                              string actor_position, mixed me,
                              int use_name) {
  string *bits;
  string *rabbit;
  string singular;
  string plural;
  int i;
  int word_break;

  if(arrayp(targets) && sizeof(targets) == 1)
    targets = targets[0];
  
//if (previous_object() == find_player("presto"))
//tell_creator("presto", "pattern == %s, verb = %s, type == %d, use_name == %d\n", pattern, verb, type, use_name);
  if (stringp(verb) && type && (sizeof(explode(pattern, "$V$")) < 2)) {
    if (pointerp(targets) && sizeof(targets) > 0) {
      pattern = replace_string(pattern, pluralize(verb), "$V$1=" +
                               pluralize(verb) + "," + verb + "$V$");
    } else {
      pattern = replace_string(pattern, pluralize(verb), "$V$0=" +
                               pluralize(verb) + "," + verb + "$V$");
    }
  }
  if(pattern) {
    pattern = replace_string(pattern, "$V$", "VERBFROG");
    bits = explode("%" + replace(pattern, ({ "$arg$", args })), "$");
  }
  if (!me) {
    me = previous_object();
  }
//if (me == find_player("presto"))
//tell_creator("presto", "%O\n", bits);
  for (i = 1; i < sizeof(bits); i += 2) {
    switch (bits[i]) {
    case "article":
      if (vowel(args[0])) {
        bits[i] = "an";
      } else {
        bits[i] = "a";
      }
      break;
    case "hcname":
      if (stringp(targets)) {
        bits[i] = targets;
        break;
      }

      if (objectp(targets)) {
        if ((targets == me)) {
          if (type) {
            bits[i] = (string) targets->query_objective() + "self";
          } else {
            bits[i] = "yourself";
          }
        } else {
          bits[i] = (string) get_name(targets, use_name, type);
        }
        break;
      }
      if(arrayp(targets)) {
        bits[i] = "$M$" + implode(map(targets, (: get_name :), use_name, type), "") +
                  "$M$";
      }
      break;
    case "mhcname":
      /* Stoopid stuff could be revised at some point, if done nicely. */
      if (stringp(targets)) {
        bits[i] = targets + "'s";   /* This will look really stoopid. */
        break;
      }
      if (objectp(targets)) {
        if ((targets == me))
          if (type)
            bits[i] = (string) targets->query_possessive();
          else
            bits[i] = "your";
        else
          bits[i] = (string) targets->the_poss_short();
        break;
      }
      /* This will look really stoopid. */
      bits[i] = "$M$" + implode(map(targets,
        (: objectp($1) ? $1->the_poss_short($(use_name)) : $1 + "'s" :)), "") +
        "$M$";
      break;
    case "hposs":
      if (objectp(targets))
        bits[i] = (string) targets->query_possessive();
      else
        bits[i] = "their";
      break;
    case "hpronoun":
      if (objectp(targets))
        bits[i] = (string) targets->query_pronoun();
      else
        bits[i] = "they";
      break;
    case "hobj":
      if (objectp(targets))
        bits[i] = (string) targets->query_objective();
      else
        bits[i] = "them";
      break;
    case "mcname":
      if(stringp(me))
        bits[i] = me;
      else if (me != previous_object()) {
        /* Must be from the help... */
        bits[i] = (string) me->short(0, 0);
      } else if(userp(me) && use_name) {
        bits[i] = me->short(0, 0);
      } else 
        bits[i] = me->the_short();
      break;
    case "mposs":
      if (type && objectp(me)) {
        bits[i] = (string) me->query_possessive();
      } else {
        bits[i] = "your";
      }
      break;
    case "mpronoun":
      bits[i] = (string) me->query_pronoun();
      break;
    case "mobj":
      if(objectp(me))
        bits[i] = (string) me->query_objective();
      else
        bits[i] = "you";
      break;
    case "position":
      if (position) {
        rabbit = explode("%" + position, "$");
        rabbit[0] = rabbit[0][1..];
        /* Make sure the size is even... */
        if ((sizeof(rabbit) % 2) == 1) {
          rabbit += ({ "" });
        }
        bits = bits[0..i] + rabbit + bits[i + 1..];
      }
      bits[i] = "";
      break;
    case "aposition":
      if (actor_position) {
        rabbit = explode("%" + actor_position, "$");
        rabbit[0] = rabbit[0][1..];
        /* Make sure the size is even... */
        if ((sizeof(rabbit) % 2) == 1) {
          rabbit += ({ "" });
        }
        bits = bits[0..i] + rabbit + bits[i + 1..];
      }
      bits[i] = "";
      break;
    case "s":
      if (i == 0)
        break;

      word_break = strsrch(bits[i - 1], ' ', -1);
      if (word_break == -1)
        break;

      if (me == previous_object())  { /* Not from 'help' */
        if (use_name)
          bits[i] = pluralize(bits[i - 1][word_break + 1 .. ]);
        else  {
          if (pointerp(targets)  &&  sizeof(targets) > 0)
            bits[i] = "$V$1=";
          else
            bits[i] = "$V$0=";
          bits[i] +=  pluralize(bits[i - 1][word_break + 1 .. ]) + "," +
                    bits[i - 1][word_break + 1 .. ] + "$V$";
        }
        bits[i - 1] = bits[i - 1][0 .. word_break];
      }
      break;
    case "verb":
      if (i + 1 < sizeof(bits))  {
        if (sscanf(bits[i + 1], "%s,%s", singular, plural) == 2)
        {
          if (me == previous_object())  {
            if (use_name)
              bits[i] = singular;
            else  {
              if (pointerp(targets)  &&  sizeof(targets) > 0)
                bits[i] = "$V$1=";
              else
                bits[i] = "$V$0=";
              bits[i] +=  singular + "," + plural + "$V$";
            }
          }
          else bits[i] = singular;
          bits = bits[0 .. i] + bits[i + 2 .. ];
        }
      }
      break;
    case "dollar":
      bits[i] = "$";
      break;
    }
  }
  pattern = implode(bits, "")[1..] + "\n";
  pattern = replace_string(pattern, "VERBFROG", "$V$");
//if (me == find_player("presto")) tell_creator("presto", "pattern == %s\n", pattern);
  return pattern;
}

private string position_command(mixed bing) {
  if (stringp(bing)) {
    return bing;
  }
  if (mapp(bing)) {
    return bing["cmd"];
  }
  return 0;
}

private void do_position_stuff(object ob, mapping position) {
  string cur_pos;
  string new_pos;
  
  /* Ok, the position stuff... */
  if (position) {
    cur_pos = ob->query_position();
    if (position[cur_pos]) {
      /* Ok, do it... */
      new_pos = position_command(position[cur_pos]);
    } else if (position["default"]) {
      new_pos = position_command(position["default"]);
    }
    if (new_pos && new_pos != "ignore" &&
        !ob->query_cannot_change_position() &&
        ("/cmds/living/" + new_pos)->query_position_command()) {
      ("/cmds/living/" + new_pos)->position(ob, position["silent"]);
    }
  }
}

private string *position_string(object ob, mapping position, int) {
  string *str;
  string cur_pos;
  mixed new_pos;

  str = ({ 0, 0, 0 });
  if (position) {
    cur_pos = ob->query_position();
    if (position[cur_pos]) {
      new_pos = position[cur_pos];
    } else if (position["default"]) {
      new_pos = position["default"];
    }
    if (mapp(new_pos)) {
      return ({ new_pos["self"], new_pos["target"], new_pos["rest"] });
    }
    if (new_pos && new_pos != "ignore" &&
        !ob->query_cannot_change_position() &&
        ("/cmds/living/" + new_pos)->query_position_command()) {
      str = ({ " making you " + new_pos + " " +
                 ("/cmds/living/" + new_pos)->query_up_down(),
                 " making $hobj$ " + new_pos + " " +
                 ("/cmds/living/" + new_pos)->query_up_down(),
                 " making $hobj$ " + new_pos + " " +
                 ("/cmds/living/" + new_pos)->query_up_down()
                 });
    }
  }
  return str;
}

private string position_of(object ob, mapping position) {
  string tmp;

  tmp = ob->query_position();
  if (position[tmp]) {
    tmp = position_command(position[tmp]);
    if (tmp) {
      return tmp;
    }
  }
  if (position["default"]) {
    tmp = position_command(position["default"]);
    if (tmp) {
      return tmp;
    }
  }
  return "";
}

private string env_position_of(object ob, mapping position) {
  return file_name(ob->query_current_room()) + position_of(ob, position);
}

private void print_messages(string verb, mixed obs, string arg, string self,
                            string rest, string target, string force,
                            mapping position) {

  object *here, *targ;
  string *pos_stuff, *actor_pos_stuff;

  if(!obs)
    obs = ({ });
  
  if(!position)
    position = ([ ]);
  
  switch(sizeof(obs)) {
  case 0:
    pos_stuff = position_string(previous_object(), position, 0);
    actor_pos_stuff = ({ "", "", ""});

    // Change positions.
    do_position_stuff(previous_object(), position);
    
    break;
  case 1:
    pos_stuff = position_string(obs[0], position, 0);
    actor_pos_stuff = position_string(previous_object(), position["actor"], 0);

    // Change positions
    do_position_stuff(obs[0], position);
    if (position && position["actor"])
      do_position_stuff(previous_object(), position["actor"]);

    break;
  default:
    actor_pos_stuff = position_string(previous_object(), position["actor"], 0);
    pos_stuff = ({ "", "", "" });
    
    // Change positions.
    if (position && position["actor"])
      do_position_stuff(previous_object(), position["actor"]);
  }

  here = filter(obs, (: environment(previous_object(1)) == environment($1) :));
  targ = obs - here - ({ previous_object() });
  
//if (previous_object() == find_player("presto")) tell_creator("presto", "targ == %O, p_o == %O\n", targ, previous_object(1)->short());
  if(!sizeof(obs) || sizeof(here))
    previous_object()->remove_hide_invis("hiding");

  // Souler. This is used if the souler isn't a target.
  if(member_array(previous_object(), obs) == -1) {
    previous_object()->event_soul(previous_object(),
                                 create_message(obs, arg, self, 0, 0,
                                                 pos_stuff[POS_TARGET],
                                                 actor_pos_stuff[POS_TARGET],
                                                 0, 1), ({ }), verb, arg, 0);
  } else {
    // Remove ourselves if this is a multiple soul, otherwise keep ourselves
    // in it.
    if(sizeof(obs) > 1)
      obs -= ({ previous_object() }); 

    previous_object()->event_soul(previous_object(),
                                  create_message(obs, arg, self, 0, 0,
                                                 pos_stuff[POS_SELF],
                                                 actor_pos_stuff[POS_SELF],
                                                 0, 1), ({ }), verb, arg, 0);
  }
  
  // Convert arg to 3rd person.
  if(arg)
    arg = replace(arg,
                  ({ "yourself", previous_object()->query_objective() + "self",
                       "your", previous_object()->query_possessive() }));

  // Remote targets
  if(sizeof(targ)) {
    /*
     * This is so that souls to multiple remote targets will show up as
     * "Womble bings happily at you and Cabbage".
     */
    target = replace(target, ({ " you.", " $hcname$.",
                                " you ", " $hcname$ ",
                                " you!", " $hcname$!",
                                " your ", " $mhcname$ " }));
    targ->event_soul(previous_object(),
                     create_message(obs, arg, target, 1, 0,
                                    pos_stuff[POS_SELF],
                                    actor_pos_stuff[POS_TARGET], 0, 1), 
                     ({ }), verb, arg, 0);
  }
  
  // Strip the souler.
  obs -= ({ previous_object() });


  // Spectators and local targets (except the souler)
  if(!sizeof(obs) || sizeof(here)) {
    if(sizeof(here) > 1)
      here -= ({ previous_object() });
    if(environment(previous_object()))
      event(environment(previous_object()), "soul",
            create_message(here, arg, rest, 1, 0, pos_stuff[POS_REST],
                           actor_pos_stuff[POS_REST], 0, 0),
            ({ previous_object() }) + targ, verb, arg,
            sizeof(here)>=1?here[0]:0);
  }
  
#ifdef DISABLED
  // Do soul forces.
  if(sizeof(obs) && stringp(force)) {
    force = replace(force, "$mcname$", previous_object()->query_name());
    foreach(ob in obs)
      call_out("do_force", 2, ({ ob, force }));
  }
#endif
}

/**
 * @ignore yes
 */
string add_start(string pat, string verb) {
  return verb + " " + pat;
}

/**
 * The list of soul comands in the look at soul function.
 *
 * @return the list of all the soul commands formated for the screen
 */
string help_list() {
  return "$P$Soul$P$The commands available in this soul currently number " +
    sizeof(soul_command_names) +
    ".\nHere is a nice list of them.\nGood luck!\n" +
    sprintf("%-#*s\n\n", (int) this_player()->query_cols(),
            implode(sort_array(keys(soul_command_names), 1), "\n"));
}

/**
 * Returns the help string for the soul ocmmand.  Creates a nice helkp
 * message for the passed soul command.
 *
 * @param verb the soul command to get help on
 * @return the soul command help string
 */
string help_string(string verb) {
  string ret, arg;
  int i;
  mixed target;
  mixed *data;
  
  if (!soul_command_names[verb])
    return 0;
  data = query_soul_command_data(verb);
  ret = sprintf("Allowed command patterns:\n%-#*s\n\n",
                (int) this_player()->query_cols(),
                implode(map_array(data[PATTERNS],
                                  "add_start", this_object(), verb), "\n"));
  if (data[SINGLE]) {
    if (data[SINGLE][NO_ARGUMENTS]) {
      ret += "Has a no arguments mode.\nSelf:   " +
        create_message(0, "", data[SINGLE][NO_ARGUMENTS][SELF], 0, 0,
                       0, 0, this_player(), 0) +
        "Others: " +
        create_message(0, "", data[SINGLE][NO_ARGUMENTS][REST], 1, 0,
                       0, 0, this_player(), 0) + "\n";
    }
    if (data[SINGLE][ARGUMENTS]) {
      for (i = 0; i < sizeof(data[SINGLE][ARGUMENTS]); i += SMALL_ARG_SIZE) {
        arg = data[SINGLE][ARGUMENTS][i + ARGS][0];
        ret += sprintf("For the arguments: [%-=*s",
                       (int) this_player()->query_cols() - 20,
                       implode(data[SINGLE][ARGUMENTS][i + ARGS],
                               ", ") + "]") + "\nSelf:   " +
          create_message(0, arg, data[SINGLE][ARGUMENTS][i + SELF], 0, 0,
                         0, 0, this_player(), 0)
          + "Others: " + create_message(0, arg,
                                        data[SINGLE][ARGUMENTS][i + REST], 1,
                                        0, 0, 0, this_player(), 0)
          + "\n";
      }
    }
  }
  if (data[TARGET]) {
    target = query_multiple_short(({ "Womble", "Cabbage" }));
    if (data[TARGET][NO_ARGUMENTS]) {
      ret += "Has a no arguments, targeted mode.\nSelf:   " +
        create_message(target, "", data[TARGET][NO_ARGUMENTS][SELF], 0, 0,
                       0, 0,
                       this_player(), 0) + "Target: " +
        (data[TARGET][NO_ARGUMENTS][TARGET] ?
         create_message(target, "", data[TARGET][NO_ARGUMENTS][TARGET], 2,
                        0, 0, 0, this_player(), 0) :
         create_message(target, "", data[TARGET][NO_ARGUMENTS][REST],
                        1, 0, 0, 0,this_player(), 0)) +
        "Others: " + create_message(target, "",
                                    data[TARGET][NO_ARGUMENTS][REST], 1,
                                    0, 0, 0, this_player(), 0) + "\n";
    }
    if (data[TARGET][ARGUMENTS]) {
      for (i = 0; i < sizeof(data[TARGET][ARGUMENTS]); i += ARG_SIZE) {
        arg = data[TARGET][ARGUMENTS][i + ARGS][0];
        ret += sprintf("For the arguments: [%-=*s",
                       (int) this_player()->query_cols() - 20,
                       implode(data[TARGET][ARGUMENTS][i + ARGS],
                               ", ") + "]") + "\nSelf:   " +
          create_message(target, arg, data[TARGET][ARGUMENTS][i + SELF],
                         0, 0, 0, 0,
                         this_player(), 0) + "Target: " +
          (data[TARGET][ARGUMENTS][TARGET + i] ?
           create_message(target, arg,
                          data[TARGET][ARGUMENTS][i + TARGET], 2, 0, 0,
                          0, this_player(), 0) :
           create_message(target, arg,data[TARGET][ARGUMENTS][i + REST],
                          1, 0, 0, 0,this_player(), 0)) +
          "Others: " + create_message(target, arg,
                                      data[TARGET][ARGUMENTS][i + REST],
                                      1, 0, 0, 0, this_player(), 0);
      }
    }
  }
  return this_player()->convert_message(ret);
}

/**
 * Attempts to do the force on the player.
 * @param arr the args used to force
 */
void do_force(mixed *arr) {
  string cmd;
  
  cmd = explode(arr[1], " ")[0];
  /* Only allow them to use soul commands on the force... */
  if (soul_command_names[cmd] &&
      !arr[0]->query_property("dead") &&
      userp(arr[0]))
    arr[0]->eventForce(arr[1]);
}

int query_pcache_size() {
  return sizeof(keys(pattern_cache));
}

int query_scache_size() {
  return sizeof(keys(soul_cache));
}

mixed *stats() {
  return ({ ({ "souls read", scache_reads, }),
              ({ "soul cache hit percent",
                   (scache_hits * 100) / scache_reads, }),
              ({ "souls in cache", sizeof(keys(soul_cache)), }),
              ({ "patterns read", pcache_reads, }),
              ({ "pattern cache hit percent",
                   (pcache_hits * 100) / pcache_reads, }),
              ({ "patterns in cache", sizeof(keys(pattern_cache)) - 1, }), });
}
// --- END [/mnt/home2/grok/lib/obj/handlers/new_soul.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/potion.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/potion.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628127   Available: 13575481
Inodes: Total: 5242880    Free: 4960134
4199 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/potion.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628127   Available: 13575481
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: potion.c,v 1.1 1998/01/06 05:03:33 ceres Exp $
 * $Log: potion.c,v $
 * Revision 1.1  1998/01/06 05:03:33  ceres
 * Initial revision
 * 
*/
/**
 *  This class is the potion information handler.
 * <p>
 *  This will handle all the information related to potions: the skill
 *  required, the failure result, etc. (more to be added as necessary).
 *  Each potion will be an object in itself (generally a virtual object).
 *  There will be an index file which gives the pathname of the object
 *  for each potion "title".  This will be loaded into a mapping on
 *  creation of the handler.  The actual potion objects will be created
 *  as they are referenced (assuming they're in the index) and stored
 *  as the value of another mapping.
 * @author Jeremy
 * @started ??/??/95
 */

inherit "/std/object";

mapping paths = allocate_mapping(10);
mapping potions = allocate_mapping(10);

#define POTION_DIR "/obj/potions/"

// This is a list of directories containing potions.  This allows the
// different classes of potions to be broken up.  Each directory must
// have an index file, as described above.

string *directories = ({
    POTION_DIR,
});


void create() {
    string dir, s, dummy, title, path, index;
    int d, i;

    seteuid("Room");
    for (d = 0; d < sizeof(directories); d++) {
        dir = directories[d];
        index = dir + "index";
        i = 1;
        if (file_size(index) > 0) {
            while (s = read_file(index, i++, 1)) {
                if ((s == "") || (sscanf(s, "#%s", dummy))) {
                    continue;
                }
                if (sscanf(s, "\"%s\"%*s\"%s\"", title, path) != 3) {
                    continue;
                }
                paths[title] = path;
                potions[title] = 0;
            }
        }
    }
    ::create();
} /* create() */

/**
 * This method returns the minimum level of the potion name.  The
 * expand_nickname function will be done on the input name before
 * looking it up.
 * @param s the name to lookup
 * @return the minimum level
 * @see query_chant()
 */
int query_min_level(string s) {
    s = this_player()->expand_nickname(s);
    if (undefinedp(paths[s])) {
        return -1;
    }
    if (!potions[s]) {
        potions[s] = clone_object(paths[s]);
    }
    return potions[s]->query_min_level();
} /* query_min_level() */

/**
 * This method returns the chant of the potion name.  The
 * expand_nickname function will be done on the input name before
 * looking it up.
 * @param s the name to lookup
 * @return the chant
 * @see query_min_level()
 */
string query_chant(string s) {
    s = this_player()->expand_nickname(s);
    if (undefinedp(paths[s])) {
        return 0;
    }
    if (!potions[s]) {
        potions[s] = clone_object(paths[s]);
    }
    return potions[s]->query_chant();
} /* query_chant() */

// Sort of a hack...
/**
 * This method clones up a potion object.  It does not setup the reagent
 * in the potion.
 * @see clone_reagent()
 * @return the potion object
 * @param s the potion to create
 */
object query_potion(string s) {
    s = this_player()->expand_nickname(s);
    if (undefinedp(paths[s])) {
       return 0;
    }
    if (!potions[s]) {
       potions[s] = clone_object(paths[s]);
    }
    return potions[s];
} /* query_potion() */

/**
 * This method creates a reagent object.  It creates the potion object and
 * then creates the reagent on it.
 * @param potion the potion to create
 * @return the regent object
 */
mixed clone_reagent(string s) {
    object pot;
    string potion;

    potion = this_player()->expand_nickname(s);
    if (undefinedp(paths[potion])) {
      return -1;
    }
    pot = query_potion(s);
    printf("Verb = %O\n", query_verb());
    return pot->clone_reagent(query_verb());
} /* clone_reagent() */

/**
 * This method returns the paths that are searched for potion
 * objects.
 * @return the mapping of paths
 */
mapping query_paths() {
    return paths;
} /* query_paths() */

/**
 * This method returns the potion mapping.  This the list of known
 * potions.
 * @return the potion mapping
 */
mapping query_potions() {
    return potions;
} /* query_potions() */
// --- END [/mnt/home2/grok/lib/obj/handlers/potion.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/corpse_handler.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/corpse_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628126   Available: 13575480
Inodes: Total: 5242880    Free: 4960134
6840 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/corpse_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628126   Available: 13575480
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * A small handler to keep track of corpses.
 * @author Pinkfish
 * @started Thu Jun 13 17:22:06 PDT 2002
 */
#include <player_handler.h>

#define CORPSE_SAVE_DIR "/save/corpses/"
#define CORPSE_RAM_DIR "/save/ramdisk/corpses/"
#define CORPSE_SAVE_FILE "/save/corpses/main"
#define CORPSE_OBJECT "/obj/corpse"

private mapping _corpses;
private nosave mapping _to_save;
private nosave int _save_things_id;
private int _corpse_id;

class corpse_data {
   int id;
}

void create() {
   seteuid(getuid());
   _corpses = ([ ]);
   _corpse_id = 1;
   _to_save = ([ ]);
   unguarded( (: restore_object(CORPSE_SAVE_FILE,  1) :));
   call_out("check_corpses", 10);
}

private void save_me() {
   unguarded( (: save_object(CORPSE_SAVE_FILE,  3) :));
}

/**
 * This method returns the corpse data associated with the name and
 * id of the corpse
 * @param name the name of the player
 * @param id the corpse id
 */
private class corpse_data find_corpse_data(string name, int id) {
   class corpse_data corpse;

   if (!_corpses[name]) {
      return 0;
   }
   foreach (corpse in _corpses[name]) {
      if (corpse->id == id) {
         return corpse;
      }
   }
   return 0;
}

/**
 * This method returns the corpse data associated with the specific
 * corpse objecy.
 * @param ob the corpse object to find the data for
 * @return the corpse data, 0 if not found
 */
private class corpse_data find_corpse_ob_data(object ob) {
   string name;
   int id;

   name = ob->query_ownership();
   id = ob->query_corpse_id();
   return find_corpse_data(name, id);
}

/**
 * Finds all of the corpses for the player.
 * @param player the name of the player to find the corpses of
 * @return the list of player corpses
 */
object* find_player_corpses(string player) {
   object* corpses;

   corpses = filter( children( "/obj/corpse" ),
             (: $1 && $1->query_property( "player" ) &&
                $1->query_ownership() == $2 :), player );
   return corpses;
}

private void really_save_corpses() {
  object ob, player;
  class corpse_data corpse;
  string data;
  string fname;
  
  // Zip through the list to find the corpses to save.
  foreach (ob, corpse in _to_save) {
    if(!ob)
      continue;
    
    data = ob->query_save_data();
    if (stringp(data)) {
#ifdef USE_RAMDISK
      fname = CORPSE_RAM_DIR + corpse->id;
#else
      fname = CORPSE_SAVE_DIR + corpse->id;
#endif
      unguarded((: write_file($(fname), $(data), 1) :));
    } else {
      tell_creator("pinkfish", "Bad corpse save %O %O\n", ob, data);
    }
      
    // Save the player when we save the corpse.
    player = find_player(ob->query_owner());

    if(player)
      player->save_me();
  }
  _to_save = ([ ]);
}

/**
 * This method will save the corpse data out to a nice file.
 * @param ob the object to save
 */
void save_corpse(object ob) {
   class corpse_data corpse;

   if (!ob->query_property("player") || !ob->query_ownership()) {
      return ;
   }
   corpse = find_corpse_ob_data(ob);
   if (!corpse) {
      tell_creator("pinkfish", "Cannot find the corpse to save %O [%O].\n",
                   ob, ob->query_ownership());
      return ;
   }
   _to_save[ob] = corpse;
   if (_save_things_id) {
      remove_call_out(_save_things_id);
   }
   _save_things_id = call_out((: really_save_corpses :), 2);
}

/**
 * This method creates the specific corpse.
 * @param name the player name to create it for
 * @param id the id to create
 * @return the new corpse
 */
object create_corpse(string name, int id) {
   class corpse_data corpse;
   string data, fname;
   object ob;
   
   corpse = find_corpse_data(name, id);

#ifdef USE_RAMDISK
   if(unguarded( (: file_size(CORPSE_RAM_DIR + $(corpse->id)) :)) > 0)
     fname = CORPSE_RAM_DIR + corpse->id;
#endif

   if(!fname)
     fname = CORPSE_SAVE_DIR + corpse->id;
   
   data = unguarded( (: read_file($(fname)) :));
   if (data) {
     ob = clone_object(CORPSE_OBJECT);
     ob->setup_corpse_from_save(data, name, id);
     return ob;
   }
   return 0;
}

/**
 * This goes through the current list of corpses and tries to find them,
 * if not it creates them.
 */
void check_corpses() {
   class corpse_data* corpses;
   string name;
   object* obs;
   int i;
   int j;

   //
   // We check each corpse we have in the list with the ones we can
   // find and see if there are any missing ones.
   //
   foreach (name, corpses in _corpses) {
      obs = find_player_corpses(name);
      for (i = 0; i < sizeof(corpses); i++) {
         for (j = 0; j < sizeof(obs); j++) {
            if (obs[j]->query_corpse_id() == corpses[i]->id) {
               corpses = corpses[0..i -1] + corpses[i+1..];
               i--;
            }
         }
      }
      if (sizeof(corpses)) {
         // We need to make some.
         for (i = 0; i < sizeof(corpses); i++) {
            create_corpse(name, corpses[i]->id);
         }
      }
   }
}

/**
 * This method returns the next corpse id.
 * @return the next corpse id
 */
int query_next_corpse_id() {
   int id;

   id = _corpse_id++;
   save_me();
   return id;
}

/**
 * This method registers the corpse with us.
 * @param corpse the corpse to register
 */
void register_corpse(object ob) {
   string name;
   int id;
   class corpse_data corpse;

   tell_creator("Registering %O (%O)\n", ob, ob->query_ownership());
   name = ob->query_ownership();
   if(PLAYER_HANDLER->test_creator(name)) {
     tell_creator("pinkfish", "Not registering creator corpse %O (%O)\n",
                  ob, ob->query_ownership());
     return;
   }
   id = ob->query_corpse_id();
   corpse = find_corpse_ob_data(ob);
   if (corpse) {
      save_corpse(ob);
      return ;
   }

   corpse = new(class corpse_data);
   corpse->id = id;
   if (!_corpses[name]) {
      _corpses[name] = ({ corpse });
   } else {
      _corpses[name] += ({ corpse });
   }
   save_me();
   save_corpse(ob);
}

/**
 * This method deregisters the corpse from us.  We forget about it and
 * it wombles off into the ether.
 * @param corpse the corpse to deregister
 */
void deregister_corpse(object ob) {
   string name;
   int id;
   class corpse_data corpse;
   int i;

   if (!ob->query_property("player")) {
      return ;
   }
   name = ob->query_ownership();
   id = ob->query_corpse_id();

   for (i = 0; i < sizeof(_corpses[name]); i++) {
      corpse = _corpses[name][i];
      // check and see if we already have it.
      if (corpse->id == id) {
         _corpses[name] = _corpses[name][0..i-1] + _corpses[name][i+1..];
         if (!sizeof(_corpses[name])) {
            map_delete(_corpses, name);
         }
         save_me();
         unguarded( (: rm(CORPSE_SAVE_DIR + $(id)) :));
#ifdef USE_RAMDISK
         unguarded( (: rm(CORPSE_RAM_DIR + $(id)) :));
#endif         
         return ;
      }
   }
}

mixed *stats() {
  return ({ ({ "corpses", keys(_corpses) }) });
}
// --- END [/mnt/home2/grok/lib/obj/handlers/corpse_handler.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/term.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/term.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628124   Available: 13575478
Inodes: Total: 5242880    Free: 4960134
21392 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/term.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628124   Available: 13575478
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Id: term.c,v 1.8 2003/02/21 00:53:43 pinkfish Exp $
 */
/**
 * This object handles all the terminal related stuff.  Figuring out to 
 * display each colour and verifying that the colours are correct.
 * The terminal handler.  This has all sorts of utterly useless junk on it
 * Share and enjoy.
 * Thrown up by Pinkfish.

    Modified by Godot to add the xterm terminal. (10/16/92)
    Added vt100 Chrisy 15 may 93

    Definitions:

        <colour>    foreground colour
        B_<colour>  background colour
        BOLD        bold or bright letters
        ENDTERM     unknown
        FLASH       flashing or blinking letters
        INITTERM    unknown
        RESET       return to the normal font -- not a terminal reset.
        STATUS      unknown
        WINDOW      unknown
        REVERSE     reverse video mode
        UNDERLINE   underline mode
 */

#define ANSI(p) sprintf("%c["+(p)+"m", 27)
#define ESC(p) sprintf("%c"+(p), 27)
#define CHAR(p) sprintf("%c", (p))

#define TERMINAL_DUMB "dumb"

private nosave mapping aliases, terms;

void create() {
  aliases = ([ "xterm-debian" : "xterm",
               "zmud" : "vt220",
               "amiga" : "vt220",
               "linux" : "vt220",
               "xterm-color" : "xterm",
               "vt102" : "vt100",
               "dec-vt100" : "vt100",
               "vt300" : "vt220",
               "vt100a" : "vt100",
               "vt100-ansi" : "vt100",
               "dec-vt220" : "vt220",
               "vt400" : "vt220",
               "vs100" : "xterm",
               "sun-cmd" : "vt220-nc",
               "unknown" : TERMINAL_DUMB,
               "ibm" : TERMINAL_DUMB,
               "iris-ansi-net" : "vt220",
               "network" : TERMINAL_DUMB,
               "vt320" : "vt220",
               "dtterm" : "vt220",
               "screen" : "vt220",
               "dec-vt320" : "vt220",
               "dec-vt100i" : "vt100",
               "ansii" : "ansi",
               "vt100i" : "vt100",
               "vt200-80" : "vt220",
               "ibm-3279-2-e" : TERMINAL_DUMB,
               "ibm-3279-2" : TERMINAL_DUMB,
               "vt200" : "vt220",
               "dec-vt200" : "vt220",
               "hft" : "vt220",
               "mac" : "vt220-nc",
               "vt340" : "vt220",
               "vt340-am" : "vt220",
               "ibm-3278-2" : TERMINAL_DUMB,
               "ibm-3278-2-e" : TERMINAL_DUMB,
               "kterm" : "xterm",
               "sun" : "vt220-nc",
               "sun1" : "vt220-nc",
               "xterms" : "xterm",
               "vs100s" : "xterm",
               "vt52" : TERMINAL_DUMB,
               "vt420" : "vt220",
               "dec-vt420" : "vt220",
               "aixterm-m" : "aixterm",
               "ibm-3151" : "ibm3151",
               "ibm-3278-5" : TERMINAL_DUMB,
               "du" : TERMINAL_DUMB,
               "dialup" : TERMINAL_DUMB,
               "dec-vt52" : TERMINAL_DUMB,
               "vt100-pro" : "vt100",
            ]);
  terms = ([ TERMINAL_DUMB : ([ "RESET" : "",
                         "BOLD" : "",
                         "FLASH" : "",
                         "BLACK" : "",
                         "RED" : "",
                         "BLUE" : "",
                         "CYAN" : "",
                         "MAGENTA" : "",
                         "ORANGE" : "",
                         "YELLOW" : "",
                         "GREEN" : "",
                         "WHITE" : "",
                         "BLACK" : "",
                         "B_RED" : "",
                         "B_ORANGE" : "",
                         "B_YELLOW" : "",
                         "B_BLACK" : "",
                         "B_CYAN" : "",
                         "B_WHITE" : "",
                         "B_GREEN" : "",
                         "B_MAGENTA" : "",
                         "STATUS": "",
                         "WINDOW": "",
                         "INITTERM": "",
                         "ENDTERM": "",
                         "REVERSE": "",
                         "UNDERLINE": "",
                         "%" : "%^",
                         ]),
             "ansi" : ([ "RESET" : ANSI("39;49")+ANSI("0;10"),
                         "BOLD" : ANSI(1),
                         "FLASH" : ANSI(5),
                         "BLACK" : ANSI(30),
                         "RED" : ANSI(31),
                         "GREEN" : ANSI(32),
                         "ORANGE" : ANSI(33),
                         "YELLOW" : ANSI("1;33"),
                         "BLUE" : ANSI(34),
                         "CYAN" : ANSI(36),
                         "MAGENTA" : ANSI(35),
                         "BLACK" : ANSI(30),
                         "WHITE" : ANSI(37),
                         "B_RED" : ANSI(41),
                         "B_GREEN" : ANSI(42),
                         "B_ORANGE" : ANSI(43),
                         "B_YELLOW" : ANSI("1;43"),
                         "B_BLUE" : ANSI(44),
                         "B_CYAN" : ANSI(46),
                         "B_BLACK" : ANSI(40),
                         "B_WHITE" : ANSI(47), /* 47? */
                         "B_MAGENTA" : ANSI(45),
                         "STATUS": "",
                         "WINDOW": "",
                         "INITTERM": "",
                         "ENDTERM": "",
                         "REVERSE" : ANSI(7),
                         "UNDERLINE" : ANSI(4),
                         "%" : "%^",
                         ]),
             "ansi-no-flash" : ([ "RESET" : ANSI("39;49")+ANSI("0;10"),
                         "BOLD" : ANSI(1),
                         "FLASH" : "",
                         "BLACK" : ANSI(30),
                         "RED" : ANSI(31),
                         "GREEN" : ANSI(32),
                         "ORANGE" : ANSI(33),
                         "YELLOW" : ANSI("1;33"),
                         "BLUE" : ANSI(34),
                         "CYAN" : ANSI(36),
                         "MAGENTA" : ANSI(35),
                         "BLACK" : ANSI(30),
                         "WHITE" : ANSI(37),
                         "B_RED" : ANSI(41),
                         "B_GREEN" : ANSI(42),
                         "B_ORANGE" : ANSI(43),
                         "B_YELLOW" : ANSI("1;43"),
                         "B_BLUE" : ANSI(44),
                         "B_CYAN" : ANSI(46),
                         "B_BLACK" : ANSI(40),
                         "B_WHITE" : ANSI(47), /* 47? */
                         "B_MAGENTA" : ANSI(45),
                         "STATUS": "",
                         "WINDOW": "",
                         "INITTERM": "",
                         "ENDTERM": "",
                         "REVERSE" : ANSI(7),
                         "UNDERLINE" : ANSI(4),
                         "%" : "%^",
                         ]),
             "freedom" : ([ "RESET" : ESC("G0"),
                         "BOLD" : ESC("G@"),
                         "FLASH" : ESC("G2"),
                         "BLACK" : "",
                         "RED" : "",
                         "GREEN" : "",
                         "ORANGE" : "",
                         "YELLOW" : "",
                         "BLUE" : "",
                         "CYAN" : "",
                         "MAGENTA" : "",
                         "BLACK" : "",
                         "WHITE" : "",
                         "B_RED" : ESC("GD"),
                         "B_GREEN" : ESC("GD"),
                         "B_ORANGE" : ESC("G4"),
                         "B_YELLOW" : ESC("G4"),
                         "B_BLUE" : ESC("G4"),
                         "B_CYAN" : ESC("GD"),
                         "B_BLACK" : ESC("GD"),
                         "B_WHITE" : ESC("G4"), /* 47? */
                         "B_MAGENTA" : ESC("G4"),
                         "STATUS": "",
                         "WINDOW": "",
                         "INITTERM": "",
                         "ENDTERM": "",
                         "REVERSE" : ESC("G4"),
                         "UNDERLINE" : ESC("G8"),
                         "%" : "%^",
                         ]),
             "ansi-status": ([
                         "RESET" : ANSI("39;49")+ANSI("0;10"),
                         "BOLD" : ANSI(1),
                         "FLASH" : ANSI(5),
                         "BLACK" : ANSI(30),
                         "RED" : ANSI(31),
                         "GREEN" : ANSI(32),
                         "ORANGE" : ANSI(33),
                         "YELLOW" : ANSI("1;33"),
                         "BLUE" : ANSI(34),
                         "CYAN" : ANSI(36),
                         "MAGENTA" : ANSI(35),
                         "BLACK" : ANSI(30),
                         "WHITE" : ANSI(37),
                         "B_RED" : ANSI(41),
                         "B_GREEN" : ANSI(42),
                         "B_ORANGE" : ANSI(43),
                         "B_YELLOW" : ANSI("1;43"),
                         "B_BLUE" : ANSI(44),
                         "B_CYAN" : ANSI(46),
                         "B_BLACK" : ANSI(40),
                         "B_WHITE" : ANSI(47), /* 47? */
                         "B_MAGENTA" : ANSI(45),
                         "STATUS" : ESC("[23;24r") + ESC(8),
                         "WINDOW" : ESC(7)+ESC("[0;22r")+ESC("[22H\n"),
                         "INITTERM" : ESC("[H")+ESC("[J")+
                                      ESC("[23;24r")+ESC("23H\n"),
                         "ENDTERM" : ESC("[0r")+ESC("[H")+ESC("[J"),
                         "REVERSE" : ANSI(7),
                         "UNDERLINE" : ANSI(4),
                         "%" : "%^",
                         ]),
             "xterm": ([ "RESET" : ANSI("39;49")+ESC("[m"),
                         "BOLD" : ANSI(1),
                         "FLASH" : ANSI(5),
                         "BLACK" : ANSI(30),
                         "RED" : ANSI(31),
                         "GREEN" : ANSI(32),
                         "ORANGE" : ANSI(33), /* Can't do brown */
                         "YELLOW" : ANSI("1;33"),
                         "BLUE" : ANSI(34),
                         "CYAN" : ANSI(36),
                         "MAGENTA" : ANSI(35),
                         "BLACK" : ANSI(30),
                         "WHITE" : ANSI(37),
                         "B_RED" : ANSI(41),
                         "B_GREEN" : ANSI(42),
                         "B_ORANGE" : ANSI(43), /* Can't do brown */
                         "B_YELLOW" : ANSI("1;43"),
                         "B_BLUE" : ANSI(44),
                         "B_CYAN" : ANSI(46),
                         "B_BLACK" : ANSI(40),
                         "B_WHITE" : ANSI(47), /* 47? */
                         "B_MAGENTA" : ANSI(45),
                         "WINDOW" : "",
                         "INITTERM" : "",
                         "ENDTERM" : "",
                         "REVERSE" : ANSI(7),
                         "UNDERLINE" : ANSI(4),
                         "%" : "%^",
                         ]),
             "vt100" : (["RESET" : ANSI("39;49")+ESC("[m")+CHAR(15),
                         "BOLD" : ANSI(1),
                         "FLASH" : ANSI(5),
                         "BLACK" : ANSI(30),
                         "RED" : ANSI(31),
                         "GREEN" : ANSI(32),
                         "ORANGE" : ANSI(33),
                         "YELLOW" : ANSI("1;33"),
                         "BLUE" : ANSI(34),
                         "CYAN" : ANSI(36),
                         "MAGENTA" : ANSI(35),
                         "WHITE" : ANSI(37),
                         "B_RED" : ANSI(41),
                         "B_GREEN" : ANSI(42),
                         "B_ORANGE" : ANSI(43),
                         "B_YELLOW" : ANSI("1;43"),
                         "B_BLUE" : ANSI(44),
                         "B_CYAN" : ANSI(46),
                         "B_BLACK" : ANSI(40),
                         "B_WHITE" : ANSI(47), /* 47? */
                         "B_MAGENTA" : ANSI(45),
                         "STATUS": "",
                         "WINDOW": "",
                         "INITTERM": "",
                         "ENDTERM": "",
                         "REVERSE" : ANSI(7),
                         "UNDERLINE" : ANSI(4),
                         "%" : "%^",
                         ]),
             "hpterm" : (["RESET" : ESC("&v0S")+ESC("&d@"),
                         "BOLD" : ESC("&dB"),
                         "FLASH" : "",
                         "BLACK" : "",
                         "RED" : ESC("&dB"),
                         "GREEN" : ESC("&dD"),
                         "ORANGE" : "",
                         "YELLOW" : ESC("&dB"),
                         "BLUE" : "",
                         "CYAN" : "",
                         "MAGENTA" : "",
                         "WHITE" : "",
                         "B_RED" : "",
                         "B_GREEN" : "",
                         "B_ORANGE" : "",
                         "B_YELLOW" : "",
                         "B_BLUE" : "",
                         "B_CYAN" : "",
                         "B_BLACK" : "",
                         "B_WHITE" : "",
                         "B_MAGENTA" : "",
                         "STATUS": "",
                         "WINDOW": "",
                         "INITTERM": "",
                         "ENDTERM": "",
                         "REVERSE" : ESC("&dB"),
                         "UNDERLINE" : ESC("&dD"),
                         "%" : "%^",
                         ]),
           "aixterm" : ([ "RESET" : ANSI("0;10")+ESC("(B"),
                         "BOLD" : ANSI(1),
                         "FLASH" : "",
                         "BLACK" : "",
                         "RED" : ANSI(1),
                         "BLUE" : "",
                         "CYAN" : "",
                         "MAGENTA" : "",
                         "ORANGE" : "",
                         "YELLOW" : ESC('p'),
                         "GREEN" : ESC('W'),
                         "WHITE" : "",
                         "BLACK" : "",
                         "B_RED" : "",
                         "B_ORANGE" : "",
                         "B_YELLOW" : "",
                         "B_BLACK" : "",
                         "B_CYAN" : "",
                         "B_WHITE" : "",
                         "B_GREEN" : "",
                         "B_MAGENTA" : "",
                         "STATUS": "",
                         "WINDOW": "",
                         "INITTERM": "",
                         "ENDTERM": "",
                         "REVERSE": ESC('p'),
                         "UNDERLINE": ESC('W'),
                         "%" : "%^",
                         ]),
           "ibm3151" : ([ "RESET" : ESC("4@"),
                         "BOLD" : ESC("4H"),
                         "FLASH" : ESC("4D"),
                         "BLACK" : "",
                         "RED" : ESC("4H"),
                         "BLUE" : "",
                         "CYAN" : "",
                         "MAGENTA" : "",
                         "ORANGE" : "",
                         "YELLOW" : ESC("4A"),
                         "GREEN" : ESC("4B"),
                         "WHITE" : "",
                         "BLACK" : "",
                         "B_RED" : "",
                         "B_ORANGE" : "",
                         "B_YELLOW" : "",
                         "B_BLACK" : "",
                         "B_CYAN" : "",
                         "B_WHITE" : "",
                         "B_GREEN" : "",
                         "B_MAGENTA" : "",
                         "STATUS": "",
                         "WINDOW": "",
                         "INITTERM": "",
                         "ENDTERM": "",
                         "REVERSE": ESC("4A"),
                         "UNDERLINE": ESC("4B"),
                         "%" : "%^",
                         ]),
             "vt220": ([ "RESET" : ANSI("39;49")+ESC("[m"),
                         "BOLD" : ANSI(1),
                         "FLASH" : ANSI(5),
                         "BLACK" : ANSI(30),
                         "RED" : ANSI(31),
                         "GREEN" : ANSI(32),
                         "ORANGE" : ANSI(33), /* Can't do brown */
                         "YELLOW" : ANSI("1;33"),
                         "BLUE" : ANSI(34),
                         "CYAN" : ANSI(36),
                         "MAGENTA" : ANSI(35),
                         "BLACK" : ANSI(30),
                         "WHITE" : ANSI(37),
                         "B_RED" : ANSI(41),
                         "B_GREEN" : ANSI(42),
                         "B_ORANGE" : ANSI(43), /* Can't do brown */
                         "B_YELLOW" : ANSI("1;43"),
                         "B_BLUE" : ANSI(44),
                         "B_CYAN" : ANSI(46),
                         "B_BLACK" : ANSI(40),
                         "B_WHITE" : ANSI(47),
                         "B_MAGENTA" : ANSI(45),
                         "WINDOW" : "",
                         "INITTERM" : "",
                         "ENDTERM" : "",
                         "REVERSE" : ANSI(7),
                         "UNDERLINE" : ANSI(4),
                         "%" : "%^",
                         ]),
             "vt100-nc" : ([ "RESET" : ESC("[m")+CHAR(15),
                         "BOLD" : ANSI(1),
                         "FLASH" : ANSI(5),
                         "BLACK" : ANSI(30),
                         "RED" : ANSI("37;7"),
                         "GREEN" : ANSI(1),
                         "ORANGE" : ANSI(37),
                         "YELLOW" : ANSI("1;4"),
                         "BLUE" : ANSI(37),
                         "CYAN" : ANSI(4),
                         "MAGENTA" : ANSI(37),
                         "WHITE" : ANSI(37),
                         "B_RED" : ANSI(41),
                         "B_GREEN" : ANSI(42),
                         "B_ORANGE" : ANSI(43),
                         "B_YELLOW" : ANSI("1;43"),
                         "B_BLUE" : ANSI(44),
                         "B_CYAN" : ANSI(46),
                         "B_BLACK" : ANSI(40),
                         "B_WHITE" : ANSI(47),
                         "B_MAGENTA" : ANSI(45),
                         "STATUS": "",
                         "WINDOW": "",
                         "INITTERM": "",
                         "ENDTERM": "",
                         "REVERSE" : ANSI(7),
                         "UNDERLINE" : ANSI(4),
                         "%" : "%^",
                         ]),           
             "vt220-nc" : ([ "RESET" : ESC("[m"),
                         "BOLD" : ANSI(1),
                         "FLASH" : ANSI(5),
                         "BLACK" : ANSI(30),
                         "RED" : ANSI("37;7"),
                         "GREEN" : ANSI(1),
                         "ORANGE" : ANSI(37),
                         "YELLOW" : ANSI("1;4"),
                         "BLUE" : ANSI(37),
                         "CYAN" : ANSI(4),
                         "MAGENTA" : ANSI("7;4"),
                         "WHITE" : ANSI(37),
                         "B_RED" : ANSI(41),
                         "B_GREEN" : ANSI(42),
                         "B_ORANGE" : ANSI(43),
                         "B_YELLOW" : ANSI("1;43"),
                         "B_BLUE" : ANSI(44),
                         "B_CYAN" : ANSI(46),
                         "B_BLACK" : ANSI(40),
                         "B_WHITE" : ANSI(47),
                         "B_MAGENTA" : ANSI(45),
                         "STATUS": "",
                         "WINDOW": "",
                         "INITTERM": "",
                         "ENDTERM": "",
                         "REVERSE" : ANSI(7),
                         "UNDERLINE" : ANSI(4),
                         "%" : "%^",
                         ]),           
          ]);
}

/**
 * This returns the mapping of colours based on the terminal type
 * entered in here.
 * @param str the terminal type
 * @return mapping of colours to escape codes
 */
mixed set_network_term_type(string str) {
  string type;

  str = lower_case(str);
  if (!terms[str] && !(type = aliases[str])) {
#ifdef DEBUG
    log_file("TERMTYPES", "No entry for \"%s\" (%s).\n", str,
             this_player()->query_name());
#endif    
    return 0;
  }
  if (type) {
     return terms[type];
  }
  return terms[str];
} /* set_network_term_type() */

/**
 * This returns the mapping of colours based on the terminal type
 * entered in here.
 * @param str the terminal type
 * @return mapping of colours to escape codes
 */
mapping set_term_type(string str) {
  if (!terms[str] && !(str = aliases[str])) {
    efun::tell_object(this_player(), "No entry for "+str+", using dumb.\n");
    str = TERMINAL_DUMB;
  }
  return terms[str];
} /* set_term_type() */

/**
 * This method returns all the currently available types of terminals.
 * @return the array of terminal types
 */
string *query_term_types() {
  return m_indices(terms);
} /* query_term_types() */

/**
 * This method returns the array of usable colours.
 * @return the array of usable colours
 */
string *query_colour_codes() {
   return keys(terms[TERMINAL_DUMB]);
} /* query_colour_codes() */
// --- END [/mnt/home2/grok/lib/obj/handlers/term.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/finderror_helper.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/finderror_helper.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628118   Available: 13575472
Inodes: Total: 5242880    Free: 4960134
8301 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/finderror_helper.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628118   Available: 13575472
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Id: finderror_helper.c,v 1.7 2003/03/25 20:02:45 taffyd Exp taffyd $
 */

/**
 * This handler contains the methods to handle the creators list of
 * directories to control bugs in.
 */
#include <log.h>
#include <config.h>
#include <db.h>

nosave inherit "/std/object";

private void recursive_add_directory( string word, string dir );

// Class used for caching error data. 
class error_data { 
    string name; 
    string *dirs; 

    int no_calls; 
} 

// Exciting global. 

nosave mapping _error_cache; 

// These are intermediary variables that are set with data by 
// restore_object() and save_object() and then
// stored in the _error_cache mapping after loading.

string name, *dirs;

void create() { 
    ::create();
    set_name( "finderror_helper" ); 
    set_short( "finderror helper" );

    _error_cache = ([ ]);
} /* create() */ 

/** 
 * Make sure the data in the directories is in the right format
 * We must strip off any trailing /'s that get in there
 * by mistake. 
 * @param file the name of the file to trim
 * @return the trimed file name
 */ 
private string strip_extension( string file ) {
    if ( file[<1] == '/' ) {
        return file[0..<2];
    }

    return file;
} /* strip_extension() */ 

// Retrieve the finderrors data for the given player name. 
private class error_data get_data_file( string word ) { 
    string file; 

    if ( _error_cache[ word ] ) {
        return _error_cache[ word ]; 
    } 
    
    seteuid( word ); 
    
    file = "/w/" + word + "/finderror.o"; 

    if ( file_size( file ) > 0 ) {
        unguarded( (: restore_object, file :) ); 
        
        _error_cache[ word ] = new( class error_data,
            name : name,
            dirs : map( dirs, (: strip_extension :) ),
            no_calls : 0 ); 
    }
    else { 
        _error_cache[ word ] = new( class error_data,
            name : word, 
            dirs : ({ }), 
            no_calls : 0 );
    }

    return _error_cache[ word ]; 
} /* get_data_file() */ 

// Save to disk. 
private int save_data_file( string word ) { 
    
    seteuid( word ); 

    if ( _error_cache[ word ] ) { 
        name = _error_cache[ word ]->name;
        dirs = _error_cache[ word ]->dirs;
        unguarded( (: save_object, "/w/" + word + "/finderror" :) );    
        return 1;
    }

    return 0; 
} /* save_data_file() */ 

string escape( string txt ) {
    return replace( txt, ({ "'", "\\'" }) );
} /* escape() */

private string assemble_dirs_sql( string *dirs ) {

    dirs = map( dirs, (: escape :) );

    return "(" + implode( map( dirs, 
            (: "Directory" + ( strsrch( $1, "%" ) > -1 ? " LIKE " : " = " ) 
            +  "'" + $1 + "'" :) ), " OR " ) + ")"; 
} /* assemble_dirs_sql() */ 

void finished_query( int status, mixed data, function func, object player ) { 
    evaluate( func, player, status, data );
} /* finished_query() */ 

/**
 * This method returns the error counts for all the directories in the
 * list of directories to watch.
 * @param word the creator to get the dir count for
 */
public int query_dirs_count(mixed player, function finish_func ) {
  class error_data info; 
  string query;
  string txt; 
  string word;

    if ( objectp( player ) ) {
  word = player->query_name(); 
    }
    else {
        word = player;
        player = this_object(); 
    }

  info = get_data_file( word );

  if ( sizeof( info->dirs ) ) { 
        txt = assemble_dirs_sql( info->dirs ); 
        
        query = "SELECT Directory, Type, COUNT(Id) FROM errors WHERE " + txt + " AND "
            "Status = 'OPEN' GROUP BY Directory, Type;";

        DB_HANDLER->make_sql_request("errors", CONFIG_DB_ERRORS_USER, "",
            query, (: finished_query( $1, $2, $(finish_func), $(player) ) :) );
        return 1;
  }
    
  return 0; 
} /* query_dirs_count() */

/**
 * This method returns the error counts for all the directories in the
 * list of directories to watch.
 * @param word the creator to get the dir count for
 */
public int query_errors_in_dirs(string *directories, function finish_func ) {
    string query;
    string txt; 

    if ( directories ) { 
        directories = map( directories , (: escape :) );
        txt = "(" + implode( map( directories, 
            (: "Directory" + ( strsrch( $1, "%" ) > -1 ? " LIKE " : " = " ) 
            +  "'" + $1 + "'" :) ), " OR " ) + ")"; 

        query = "SELECT Directory, Type, COUNT(Id) AS C FROM errors WHERE " + txt + " AND "
            "Status = 'OPEN' GROUP BY Directory, Type";
    
        DB_HANDLER->make_sql_request("errors", CONFIG_DB_ERRORS_USER, "",
            query, (: finished_query( $1, $2, $(finish_func), $(this_player()) ) :) );
        return 1;
    }

    return 0; 
} /* query_dirs_count() */

public void query_next_dir( object player, function finish_func ) { 
    string query;
    string txt;
    string word;
    class error_data info; 

    word = player->query_name();

    info = get_data_file( word ); 
    
    if ( sizeof( info->dirs ) ) { 
        txt = assemble_dirs_sql( info->dirs ); 
        query = "SELECT Directory, COUNT(Id) AS C FROM errors WHERE " + txt + 
            " AND Status = 'OPEN' GROUP BY Directory HAVING C > 0 LIMIT 1;";

        DB_HANDLER->make_sql_request( "errors", CONFIG_DB_ERRORS_USER, "",
            query, (: finished_query( $1, $2, $(finish_func), $(player) ) :) );
    }
    else { 
        tell_object( player, "You have no finderrors directories defined.  Add "
            "them with 'finderrors add'\n" ); 
    }
} /* query_next_dir() */ 

public string *query_directories( string player ) {
    class error_data data;

    data = get_data_file( player ); 

    return copy( data->dirs );
} /* query_directories() */ 

/**
 * This method adds the directory to the creators directory list to check.
 * @param player the creator to add the directory to
 * @param dir the directory to add
 * @param recursive to add the directory recursively
 */
public int add_directory( object player, string dir, int recursive ) {
    int res;
    class error_data info; 
    string word;

    word = player->query_name();
   
    info = get_data_file( word );
    res = member_array( dir, info->dirs );

    if ( recursive )  {
        /* This means it will do a "like" test. */ 
        dir += "%";
        //info->no_calls++;
        //call_out( (: recursive_add_directory :), 1, player, dir );
    }

    if ( res == -1 ) {
        if ( dir[ <1 ] == '/') { 
            dir = dir[ 0 .. <2 ];
        }
        info->dirs = ({ dir }) + info->dirs; 
        tell_object( player, "Added " + dir + 
            (recursive ? " (recursive)" : "") + "\n" ); 
        save_data_file( word );
    }
 
    return 1;
}  /* add_directory() */

/**
 * This method adds all the subdirectories of the specified dir into the
 * search list.
 * @param player the creator to add to the list of
 * @param dir the directory to recursively add to
 */
private void recursive_add_directory( object player, string dir ) {
    mixed *directories, *file;
    class error_data info; 
    string word;

    word = player->query_name();

    info = get_data_file( word ); 
    info->no_calls--; 
    
    directories = get_dir( dir, -1 );
    
    if ( directories ) {
        foreach ( file in directories ) {
            if ( file[ 1 ] == -2 && file[ 0 ] != "Maps") {
                add_directory( player, dir + file[ 0 ] +"/", 1 );
            }
        }
    }
    
    if ( info->no_calls == 0 ) {
        tell_object( player, 
            "All subdirectories have been added to the list.\n" );   
        save_data_file( word );
    }
}  /* recursive_add_dir() */

public int remove_directory( object player, string directory, int recursive ) {
    class error_data info;
    string word;
    int pos;

    word = player->query_name();
    info = get_data_file( word );
    
    if ( recursive ) { 
        pos = sizeof( directory ) - 1;
        info->dirs = filter( info->dirs, 
            (: $1[ 0..$(pos) ] != $(directory) :));
    }
    else {
        pos = member_array( directory, info->dirs ); 

        if ( pos == -1 ) {
            return 0;
        }

       info->dirs = info->dirs[ 0..pos - 1 ] + info->dirs[ pos+1.. ]; 
    }

    save_data_file( word ); 
    return 1; 
} /* remove_directory() */ 

// --- END [/mnt/home2/grok/lib/obj/handlers/finderror_helper.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/trig.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/trig.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628116   Available: 13575470
Inodes: Total: 5242880    Free: 4960134
2494 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/trig.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628116   Available: 13575470
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: trig.c,v 1.1 1998/01/06 05:03:33 ceres Exp $
 * $Log: trig.c,v $
 * Revision 1.1  1998/01/06 05:03:33  ceres
 * Initial revision
 * 
*/
/* this is [als]'s wonder trig object */

int *sintab, *pow;

create()
{
   pow = ({ 296296, 308556, 321324, 334621, 348467, 362887, 377903, 
            393541, 409825, 426784, 444444, 462835, 481987, 501931, 
            522701, 544331, 566855, 590311, 614738, 640176, 666666,
            694253, 722981, 752897, 784052, 816496, 850283, 885467,
            922107, 960264, 1000000, 
            1041379, 1084471, 1129346, 1176079, 1224744, 1275424, 
            1328201, 1383161, 1440396, 1500000, 1562069, 1626707, 
            1694020, 1764118, 1837117, 1913136, 1992301, 2074742, 
            2160595, 2250000, 2343104, 2440061, 2541030, 2646177, 
            2755675, 2869705, 2988452, 3112114, 3240892, 3375000
   });
   sintab = ({
      0, 17452, 34899, 52335, 69756, 87155, 104528, 121869, 139173, 156434,
      173648, 190808, 207911, 224951, 241921, 258819, 275637, 292371, 
      309016, 325568, 342020, 358367, 374606, 390731, 406736, 422618, 
      438371, 453990, 469471, 484809, 500000, 515038, 529919, 544639, 
      559192, 573576, 587785, 601815, 615661, 629320, 642787, 656059, 
      669130, 681998, 694658, 707106, 719339, 731353, 743144, 754709, 
      766044, 777145, 788010, 798635, 809016, 819152, 829037, 838670, 
      848048, 857167, 866025, 874619, 882947, 891006, 898794, 906307, 
      913545, 920504, 927183, 933580, 939692, 945518, 951056, 956304, 
      961261, 965925, 970295, 974370, 978147, 981627, 984807, 987688, 
      990268, 992546, 994521, 996194, 997564, 998629, 999390, 999847, 1000000
   });
}

int sin(int angle)
/* return sin(angle in degrees) * 1000000 */
{
/* for 'huge' angles this may be slow, but for the small angles we are expecting
   it is fine */

   while (angle < 0) angle += 360;
   while (angle >= 360) angle -= 360;
   
   if (angle >= 270) return -sintab[360 - angle];
   if (angle >= 180) return -sintab[angle - 180];
   if (angle >= 90) return sintab[180 - angle];
   return sintab[angle];
}

int cos(int angle)
{
   return sin(90 - angle);
}

int tan(int angle)
{
/* 1000 * 1e6 is the maximum ... so we have to divide the bottom by 1000 :(
   losing accuracy along the way of course. */

   return 1000 * sin(angle) / (sin(90 - angle) / 1000);
}

int pow1_5(int n)
{
   if (n > 30) n = 30;
   else if (n < -30) n = -30;
   return pow[30-n];
}
// --- END [/mnt/home2/grok/lib/obj/handlers/trig.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/vhandler.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/vhandler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628115   Available: 13575469
Inodes: Total: 5242880    Free: 4960134
1274 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/vhandler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628115   Available: 13575469
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*
   Saved Variable handler - very basic atm - will tidy up given time.
   Written by Sojan [sojan@ukcis.demon.co.uk] - 27/12/95

   Instructions for Use ..
	call set_variable_value with a string parameter identifying the variable and a
		second mixed value which is the value you want to store
	to query it simply call query_variable_status with a string parameter that 
		Identifies the variable

    Things I know thats wrong with it atm ...

	*NO checking for existing variables so you can overwrite other peoples - use your
		name as part of the identifier or something atm ....

	*It DOESN'T clear up variables that are no longer required - nor currently has code
		to do so.

    Both these things will be fixed in a few days - I wrote this off the cuff for a creator
    With an unprounoucable name but I guess other people will find it useful.

    Any comments/criticisms to me ....

    Sojan
*/


mapping stored_variables;

void create()
{
  seteuid(geteuid(this_object()));
  stored_variables=([ ]);
  restore_object(file_name(this_object()));
}

mixed query_variable_status(string vname)
{
  return stored_variables[vname];
}

int set_variable_status(string vname, mixed vvalue)
{
  stored_variables[vname]=vvalue;
  save_object(file_name(this_object()));
}

// --- END [/mnt/home2/grok/lib/obj/handlers/vhandler.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/cmr_handler.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/cmr_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628115   Available: 13575469
Inodes: Total: 5242880    Free: 4960134
9720 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/cmr_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628115   Available: 13575469
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: cmr_handler.c,v 1.4 1998/10/04 23:31:43 ceres Exp $
 * $Log: cmr_handler.c,v $
 * Revision 1.4  1998/10/04 23:31:43  ceres
 * improved autodoc
 *
 * Revision 1.3  1998/10/04 23:14:03  ceres
 * Updated the documentation
 *
 * Revision 1.2  1998/10/04 22:43:41  ceres
 * Added documentation and fixed error with using obsolete functions.
 *
 * Revision 1.1  1998/01/06 05:03:33  ceres
 * Initial revision
 * 
*/
#include <cmr.h>
#include <colour.h>
#include <library.h>

#define SAVE_FILE "/save/cmr_handler"

inherit "/std/object";

/**
 * This handler deals with identifying materials and colours. Your skill and
 * experience are used to determine if you can successfully identify a
 * particular material or colour.
 *
 * @author Deutha
 */
string *colour_names;
mapping colour_details;
string *material_names;
mapping material_details;

void load_cmr_handler();
void save_cmr_handler();
void create();
string add_colour( string word, int fine, int crude, int qp_thresh,
                int sp_thresh );
int *query_colour_details( string word );
int delete_colour( string word );
string *query_colour_names();
string identify_colour( string word, object player );
string add_material( string word, int colour, int type, int skill_reqd,
                  int skill_thresh );
int *query_material_details( string word );
int delete_material( string word );
string *query_material_names();
string identify_material( string word, object player, int article );
string query_material_adjective( string word );

/**
 * @ignore yes
 */
void load_cmr_handler() {
  if ( file_size( SAVE_FILE +".o" ) > 0 )
    unguarded((: restore_object, SAVE_FILE :));
} /* load_cmr_handler() */

/**
 * @ignore yes
 */
void save_cmr_handler() {
  unguarded((: save_object, SAVE_FILE :));
} /* save_cmr_handler() */

/**
 * @ignore yes
 */
void create() {
  colour_names = ({ });
  colour_details = ([ ]);
  material_names = ({ });
  material_details = ([ ]);
  ::create();
  load_cmr_handler();
} /* create() */

/**
 * This function is used to add a known colour to the handler.
 *
 * @param word The name of the colour
 * @param fine Not sure
 * @param crude Not sure
 * @param qp_thresh Quest points required to help identify this colour
 * @param sp_thresh Social points required to help identify this colour
 */
string add_colour( string word, int fine, int crude, int qp_thresh,
                int sp_thresh ) {
  int temp;
  temp = member_array( word, colour_names );
  if ( temp != -1 ) return "colour already exists";
  colour_names += ({ word });
  colour_details += ([ word : ({ fine, crude, qp_thresh, sp_thresh }) ]);
  save_cmr_handler();
  return "the colour "+ word +", a shade of "+ ( ( fine == crude )?
         "pure ":MODIFIERS[fine] ) + COLOURS[crude] +", with thresholds of "+
         qp_thresh +" xp and "+ sp_thresh +" sp";
} /* add_colour() */

/**
 * Returns the array of information stored about a particular colour. The
 * array is setup using add_colour.
 *
 * @param word The colour in question
 * @see add_colour
 */
int *query_colour_details( string word ) {
  int temp;
  temp = member_array( word, colour_names );
  if ( temp == -1 ) return ({ -1 });
  return colour_details[word];
} /* query_colour_details() */

/**
 * Remove a colour from the handler.
 *
 * @param word The colour to remove.
 */
int delete_colour( string word ) {
  int temp;
  temp = member_array( word, colour_names );
  if ( temp == -1 ) return 0;
  colour_names -= ({ word });
  colour_details = m_delete( colour_details, word );
  save_cmr_handler();
  return 1;
} /* delete_colour() */

/**
 * List all the known colours in the handler.
 *
 * @return An array of strings of colour names.
 */
string *query_colour_names() { return colour_names + ({ }); }

/**
 * Used to determine if a player can identify a particular colour. The
 * function returns the colours name or a string giving a rough description
 * if they're unable to identify it.
 *
 * @param word The colour they're trying to identify.
 * @param player The player trying to identify the colour.
 * @return Description.
 */
string identify_colour( string word, object player ) {
  int temp, *args;

  temp = member_array( word, colour_names );

  if ( temp == -1 )
    return "unknown colour";

  args = allocate( 4 );
  args = colour_details[word];

  if ( !player )
    return word;
  
  switch ( ( ( LIBRARY->query_quest_points(player->query_name()) ) > args[2] )+
           ( ( player->query_max_gp() ) > args[3] ) ) {
  case 0:
    return COLOURS[args[1]];
  case 1:
    return ( ( ( args[0] == args[1] )?"pure ":MODIFIERS[args[0]] ) +
             COLOURS[args[1]] );
  default:
    return word;
  }
} /* identify_colour() */

/**
 * Add a new material to the handler.
 * The colour of the material is an index into the COLOUR array defined in
 * colour.h. The type of material is an index into the MATERIALS array defined
 * in cmr.h. skill_reqd is an index into the SKILLS array defined in cmr.h but
 * can also take the special value of 99 to indicate that the material can only
 * be identified if someone has told the person what the material is or 0 to
 * indicate that everyone knows what the material is.
 * If the skill_reqd is a skill the skill_thresh is the bonus needed in that
 * skill to identify the material.
 *
 * @param word The name of the material
 * @param colour The index into the colour array for the colour of the
                 material. (see colour.h)
 * @param type Type of material
 * @param skill_reqd Index into the array of skills (see cmr_handler.h)
 * @param skill_thresh The bonus required in the appropriate skill.
 */
string add_material( string word, int colour, int type, int skill_reqd,
                  int skill_thresh ) {
  int temp;
  string text;
  temp = member_array( word, material_names );
  if ( temp != -1 ) return "material already exists";
  material_names += ({ word });
  material_details += ([ word : ({ colour, type, skill_reqd,
                         skill_thresh }) ]);
  save_cmr_handler();
  if ( !skill_reqd )
    text = " that is always recognised";
  else
    if ( skill_reqd == LEARNT )
      text = " that is recognised through knowledge";
    else
      text = " that has a threshold of "+ skill_thresh +" in "+
             SKILLS[skill_reqd];
  return word +", a"+ ( ( colour == COL_ORANGE )?"n ":" " ) +
         COLOURS[colour] +" "+ MATERIALS[type] + text;
} /* add_material() */

/**
 * Return the details of a material set with add_material
 *
 * @param word The material in question
 * @return An integer array of material details.
 */
int *query_material_details( string word ) {
  int temp;
  temp = member_array( word, material_names );
  if ( temp == -1 ) return ({ -1 });
  return material_details[word];
} /* query_material_details() */

/**
 * Remove a material from the handler.
 *
 * @param word The name of the material to remove.
 */
int delete_material( string word ) {
  int temp;
  temp = member_array( word, material_names );
  if ( temp == -1 ) return 0;
  material_names -= ({ word });
  material_details = m_delete( material_details, word );
  save_cmr_handler();
  return 1;
} /* delete_material() */

/**
 * List all the known materials by name.
 */
string *query_material_names() { return material_names + ({ }); }

/**
 * Used to determine if a player can identify a particular material.
 * The function returns the materials name or a string giving a rough
 * description if they're unable to identify it.
 *
 * Some materials can be identified by being high enough at a particular skill
 * (defined in cmr.h) while others are only learned by being taught and others
 * are known to everyone.
 *
 * @param word The name of the material
 * @param player The player trying to identify it.
 * @param article Definite or indefinite article.
 * @return Description.
 *
 * @see cmr_library
 * @see cmr
 */
string identify_material( string word, object player, int article ) {
  int temp, *args;
  string prefix;
  temp = member_array( word, material_names );
  if ( temp == -1 ) return "unknown material";
  args = allocate( 4 );
  args = material_details[word];
  prefix = ( ( article )?"a"+ ( ( args[0] == COL_ORANGE )?"n ":" " ):"" );
   if ( !args[ 2 ] || !player )
      return word;
  if ( args[2] == LEARNT )
    if ( member_array( word,
        (string *)CMR_LIBRARY->query_known_materials( player->query_name() ) )
        == -1 )
      return prefix + COLOURS[ args[ 0 ] ] +" "+
          MATERIALS[ args[ 1 ] ];
    else
      return word;
  if ( ( player->query_skill_bonus( SKILLS[args[2]] ) ) > args[3] )
    return word;
  else return prefix + COLOURS[args[0]] +" "+ MATERIALS[args[1]];
} /* identify_material() */

/**
 * Not sure about this. Seems to return a colour and adjective for a material.
 * eg. slate returns 'grey mineral'.
 * @param The name of the material.
 * @return A description.
 */
string query_material_adjective( string word ) {
  int temp, *args;
  temp = member_array( word, material_names );
  if ( temp == -1 ) return "an unknown material";
  args = allocate( 4 );
  args = material_details[word];
  return COLOURS[args[0]] +" "+ MATERIAL_ADJECTIVES[args[1]];
} /* query_material_adjective() */

/**
 * Returns the ansi colour associated with the material eg. yellow for gold,
 * red for a red mineral pebble etc.
 * @param word the material's name.
 * @return ansi colour sequence for that colour.
 */
string query_material_ansi_colour( string word ) {
  int temp, *args;
  temp = member_array( word, material_names );
  if ( temp == -1 ) return "";
  args = allocate( 4 );
  args = material_details[word];
  return ANSI_COLOURS[args[0]];
} /* query_material_ansi_colour() */
// --- END [/mnt/home2/grok/lib/obj/handlers/cmr_handler.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/item_tracker.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/item_tracker.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628112   Available: 13575466
Inodes: Total: 5242880    Free: 4960134
6464 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/item_tracker.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628112   Available: 13575466
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/**
 * This handler keeps track of unique (hopefully) per player items in the game.
 * @author Shaggy
 */
#include <library.h>
#include <quest_handler.h>

inherit "/std/object";

#define QUEST_INFO_IDENT  "items"
#define MAX_COPIES    10

/* cached item data */
mapping item_cache;
mapping player_items;

/** @ignore yes */
void create() 
{
   ::create();
   item_cache = ([ ]); 
} /* create() */

/**
 * This method returns the state/location of a specific quest item
 * owned by a player.
 * <p>
 * If the item isn't actually owned by the player it returns 0
 * @param pl_name   player object or name
 * @param item      item object or identifier
 * @returns string array of state information
 * @see set_item_state()
 * @see delete_item()
 */
mixed query_item_state( mixed pl_name, mixed item ) 
{
  if (objectp(pl_name)) {
    if (!interactive(pl_name)) return 0;
    pl_name = pl_name->query_name();
  }

  if (objectp(item)) {
    if (item->query_tracked_item_owner() != pl_name) return 0;
    item = item->query_full_tracked_item_identifier();
  }
  if (!item) return 0;

  player_items = item_cache[ pl_name ];

  if (!player_items) {
    player_items = copy(LIBRARY->query_player_quest_info( pl_name, QUEST_INFO_IDENT ));
    if (!player_items) player_items = ([ ]);
    item_cache[ pl_name ] = player_items;
  }

  return player_items[ item ];
}

/**
 * This method deletes the state/location information of a specific quest item
 * owned by a player.
 * <p>
 * If the item isn't actually owned by the player it returns 0
 * @param pl_name   player object or name
 * @param item      item object or identifier
 * @returns 1 on success
 * @see set_item_state()
 */
int delete_item( mixed pl_name, mixed item ) 
{
  if (objectp(pl_name)) {
    if (!interactive(pl_name)) return 0;
    pl_name = pl_name->query_name();
  }

  if (objectp(item)) {
    if (item->query_tracked_item_owner() != pl_name) return 0;
    item = item->query_full_tracked_item_identifier();
  }
  if (!item) return 0;

  player_items = item_cache[ pl_name ];

  if (!player_items) {
    player_items = copy(LIBRARY->query_player_quest_info( pl_name, QUEST_INFO_IDENT ));
    if (!player_items) player_items = ([ ]);
    item_cache[ pl_name ] = player_items;
  }

  map_delete( player_items, item );
  return 1;
}

/**
 * This method returns the total number of known copies of a specific quest item
 * owned by a player.
 * <p>
 * If the item isn't actually owned by the player it doesn't matter.
 * @param pl_name   player object or name
 * @param item      item object or identifier
 * @returns number of copies
 * @see set_item_state()
 * @see delete_item()
 */
int query_item_copies( mixed pl_name, mixed item ) 
{
  int copy_number,n_copies;

  if (objectp(pl_name)) {
    if (!interactive(pl_name)) return 0;
    pl_name = pl_name->query_name();
  }

  if (objectp(item)) {
    item = item->query_tracked_item_identifier();
  }
  if (!item) return 0;

  player_items = item_cache[ pl_name ];

  if (!player_items) {
    player_items = copy(LIBRARY->query_player_quest_info( pl_name, QUEST_INFO_IDENT ));
    if (!player_items) player_items = ([ ]);
    item_cache[ pl_name ] = player_items;
  }

  n_copies = 0;
  for (copy_number = 1; copy_number < MAX_COPIES; copy_number++) {
    if (player_items[ item+"/"+copy_number ]) n_copies++;
  }

  return n_copies;
}

/**
 * This method sets the state/location of a specific quest item
 * owned by a player.
 * <p>
 * If the item isn't actually owned by the player it returns 0
 * @param pl_name   player object or name
 * @param item      item object or identifier
 * @returns 1 if successful
 * @see query_item_state()
 * @see delete_item()
 * @see save_all_item_states()
 */
int set_item_state( mixed pl_name, mixed item, mixed state ) 
{
  if (objectp(pl_name)) {
    if (!interactive(pl_name)) return 0;
    pl_name = pl_name->query_name();
  }

  if (objectp(item)) {
    if (item->query_tracked_item_owner() != pl_name) return 0;
    item = item->query_full_tracked_item_identifier();
  }
  if (!item) return 0;

  player_items = item_cache[ pl_name ];

  if (!player_items) {
    player_items = copy(LIBRARY->query_player_quest_info( pl_name, QUEST_INFO_IDENT ));
    if (!player_items) player_items = ([ ]);
    item_cache[ pl_name ] = player_items;
  }

  player_items[ item ] = state;
  return 1;
}

/**
 * This method returns all the information about quest items
 * owned by a player.
 * @param pl_name   player object or name
 * @returns state/location of items mapping for player
 * @see set_item_state()
 * @see delete_item()
 */
mixed query_all_item_states( mixed pl_name ) 
{
  if (objectp(pl_name)) {
    if (!interactive(pl_name)) return 0;
    pl_name = pl_name->query_name();
  }

  player_items = item_cache[ pl_name ];

  if (!player_items) {
    player_items = copy(LIBRARY->query_player_quest_info( pl_name, QUEST_INFO_IDENT ));
    if (!player_items) player_items = ([ ]);
    item_cache[ pl_name ] = player_items;
  }

  return player_items;
}

/**
 * This method saves the mapping of state/location 
 * information for items owned by a player to disk.
 * @param pl_name   player object or name
 * @param item      item object or identifier
 * @return 1 if successful
 * @see set_item_state()
 * @see query_item_state()
 * @see delete_item()
 * @see save_all_item_states_and_delete_from_cache()
 */
int save_all_item_states( mixed pl_name ) 
{
  if (objectp(pl_name)) {
    if (!interactive(pl_name)) return 0;
    pl_name = pl_name->query_name();
  }

  player_items = item_cache[ pl_name ];

  if (!player_items) {
    return 0;
  }

  LIBRARY->set_player_quest_info( pl_name, QUEST_INFO_IDENT, player_items );
  return 1;
}

/**
 * This method saves the mapping of state/location 
 * information for items owned by a player to disk and deletes
 * the entry in the cache.
 * @param pl_name   player object or name
 * @param item      item object or identifier
 * @return 1 if successful
 * @see set_item_state()
 * @see query_item_state()
 * @see delete_item()
 * @see save_all_item_states()
 */
int save_all_item_states_delete_cache( mixed pl_name ) 
{
  if (objectp(pl_name)) {
    if (!interactive(pl_name)) return 0;
    pl_name = pl_name->query_name();
  }

  player_items = item_cache[ pl_name ];

  if (!player_items) {
    return 0;
  }

  LIBRARY->set_player_quest_info( pl_name, QUEST_INFO_IDENT, player_items );
  map_delete( item_cache, pl_name );
  return 1;
}







// --- END [/mnt/home2/grok/lib/obj/handlers/item_tracker.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/mail_track.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/mail_track.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628111   Available: 13575465
Inodes: Total: 5242880    Free: 4960134
12623 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/mail_track.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628111   Available: 13575465
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*   -*- LPC -*-   */
/*
 * $Locker:  $
 * $Id: mail_track.c,v 1.10 2003/03/21 01:28:01 ceres Exp $
 */
/**
 * This handler keeps track of who has a mailer at the moment and sends the
 * mail to there instead.  This also keeps track of the current mailing
 * lists in the system.
 * @author Pinkfish
 * @started 1991 sometime
 * @index mailing_list
 */
inherit "std/object";

#include <mail.h>
#include <mail_track.h>
#include <player_handler.h>

#define SECURITY if (!master()->query_leader(previous_object(-1))) return 0;

int add_member(string list, string mem);
private void load_me();
private void save_me();
int query_list(string list);
int create_list(string list, string creator);

/*
 * this object keeps track of who has a mailer at the moment and sends the
 * mail to there instead.
 * bounce.
 */

/*
 * Hmmm, well I think I will add mailing list support. Sounds cute huh?
 */

nosave mixed *our_mailers;
mapping mailing_lists;

/** @ignore yes */
void setup() {
   set_name("tracker");
   set_short("mail tracker");
   add_property("determinate", "the ");
   add_property("there", "mounted on one wall");
   add_adjective("mail");
   set_long("This thing tracks mail.   Clever, innit?\n");
   reset_get();
   reset_drop();
   our_mailers = ({ });
   mailing_lists = ([ ]);
   seteuid("Root");
   load_me();
   if (!query_list("postmaster")) {
      create_list("postmaster", "pinkfish");
   }
   move(MAIL_ROOM);
} /* setup() */

/**
 * This method adds in a mailer for a specific player into the current
 * list of mailers.
 * @param ob the mailer for the player
 * @param str the player the mailer is for
 * @return return 1 if successful
 */
int add_mailer(object ob, string str) {
   int i;

   if (!stringp(str) || !objectp(ob)) {
      return 0;
   }
   i = member_array(str, our_mailers);
   if (i == -1) {
      our_mailers += ({ ob, str });
   } else {
      write(i);
      if (our_mailers[i-1]) { /* make sure it hasn't already died somehow */
         our_mailers[i-1]->dest_me(); /* we don't want two of them */
      }
      our_mailers += ({ ob, str });
   }
   return 1;
} /* add_mailer() */

/**
 * This method finds the mailer associated with a particular player.
 * @param str the player whose mailer to find.
 * @return the mailer object associated with the player
 * @see add_mailer()
 * @see delete_mailer()
 */
object find_mailer(string str) {
   int i;

   if (!stringp(str)) {
      return 0;
   }
   i = member_array(str, our_mailers);
   if (i == -1) {
      return 0;
   }
   return our_mailers[i-1];
} /* find_mailer() */

/**
 * This method removes a mailer from the current list of mailers.
 * It removes the mailer based on the object itself
 * @param ob the mailer object to remove
 * @return 0 if unable to remove
 * @see add_mailer()
 * @see find_mailer()
 */
int delete_mailer(object ob) {
   int i;

   if (!objectp(ob)) {
      return 0;
   }
   i = member_array(ob, our_mailers);
   if (i == -1) {
      return 0;
   }
   our_mailers = delete(our_mailers, i, 2);
} /* delete_mailer() */

/** @ignore yes */
void we_are_done(object me) {
   if (objectp(me)) {
      me->dest_me();
   }
} /* we_are_done() */

/**
 * This is the main mail function.  It tries to start up a mailer with
 * the default address and subject.  If their is no default address then
 * the mailer uses it's menu mode, otherwise it sends one mail and then
 * leaves.
 * @param str 0 or "" for no default address
 * @param sub the default subject
 */
int mail(string str, string sub) {
   object mailer;

   mailer = clone_object(MAILER);
   mailer->set_do_this_last(({ this_object(), "we_are_done", mailer }));
   mailer->read_mail(str, sub);
   return 2;
} /* mail() */

private void save_me() {
   unguarded((: save_object, "/save/mail_track" :));
} /* save_me() */

private void load_me() {
   string *list_names, name;
   mixed *list;
   
   unguarded((: restore_object, "/save/mail_track" :));
   list_names = keys(mailing_lists);
   if (sizeof(list_names) && !classp(mailing_lists[list_names[0]])) {
      foreach (name, list in mailing_lists) {
         mailing_lists[name] = new(class mailing_list, members : list[0],
                                                controllers : list[1], creator : list[2]);
      }
      save_me();
   }
} /* load_me() */

/**
 * This method returns the current mailing lists available on the
 * handler.
 * @return the array of available mailing lists
 */
string *query_mailing_lists() {
   return keys(mailing_lists) +
     "/secure/master"->query_domains() + 
      ({ "seniors", "lords", "hlords" });
} /* query_mailing_lists() */

/**
 * This method checks to see if the specified list exists or not.
 * @return 1 if the list exists, 0 if not
 * @param list the list name to check
 * @see query_mailing_lists()
 * @see query_members()
 * @see query_member()
 */
int query_list(string list) {
   return member_array(list, query_mailing_lists()) != -1;
} /* query_list() */

/**
 * This returns the current members of the specified mailing list.
 * @return the members of the mailing list
 * @param list the mailing list to get the memebrs of
 * @see query_mailing_lists()
 * @see query_list()
 * @see query_member()
 */
string *query_members(string list) {
  string *tmp;
  
  switch (list) {
  case "playtesters" :
    tmp = (string *)"/obj/handlers/playtesters"->query_playtesters();
    return ({ "/d/playtesters/master"->query_lord() }) + sort_array(tmp, 1);
  case "seniors" :
    tmp = (string *)master()->query_all_seniors();
    return tmp;
  case "lords" :
    tmp = (string *)master()->query_all_leaders();
    return tmp;
  case "hlords" :
    tmp = ((string *)master()->query_administrators() -
           ({ "Admin", "Root", "offler" }));
    return tmp;
  default :
  }
  if (file_size("/d/"+ list) == -2) {
    tmp = (string *)("/d/"+ list +"/master")->query_members() +
      ({ (string)("/d/"+ list +"/master")->query_lord() });
  }
  else if (mailing_lists[list]) {
    tmp = copy(mailing_lists[list]->members);
  }

  if(tmp)
    return filter_array(tmp, (: PLAYER_HANDLER->test_active($1, 1) :));
  
  return ({ });
}

/**
 * This method checks to see if the given player is in the selected
 * mailing list.
 * @param list_name the mailing list name
 * @param name the name of the player in the list
 * @return 1 if the player is a member, 0 if not
 * @see query_mailing_lists()
 * @see query_list()
 * @see query_members()
 */
int query_member(string list_name, string name) {
   class mailing_list list;

   list = mailing_lists[list_name];

   if (list) {
      return member_array(name, list->members) != -1;
   }
   if (file_size("/d/" + list_name) == -2) {
      return (int)("/d/" + list_name + "/master")->query_member(name);
   }
   if (list_name == "seniors") {
      return (int)master()->query_senior(name);
   }
   if (list_name == "lords") {
      return (int)master()->query_leader(name);
   }
   if (list_name == "hlords") {
      return (int)master()->query_administrator(name);
   }
} /* query_member() */

/**
 * This method returns all the current controllers of the mailing list.
 * Controllers can add and remove members from a list.
 * @param list the mailing list to query the controllers for
 * @return the array of controllers
 */
string *query_controllers(string list) {
   if (file_size("/d/"+ list) == -2) {
      return ({ (string)("/d/"+ list +"/master")->query_lord() });
   }
   if (mailing_lists[list]) {
      return copy(mailing_lists[list]->controllers);
   }
   return ({ });
} /* query_controllers() */

/**
 * This method checks to see if the given player is a controller.
 * @param list_name the name of the list
 * @param name the name to check to see if they are a controller
 * @see query_controllers()
 * @see query_member()
 */
int query_controller(string list_name, string name) {
   class mailing_list list = mailing_lists[list_name];
   if (!list) {
      return 0;
   }
   return member_array(name, list->controllers) != -1;
} /* query_controller() */

/**
 * This method determines the creator of the list.
 * @return the creator of the list
 * @param list_name the list to get the creator of
 * @see create_list()
 */
string query_creator(string list_name) {
   class mailing_list list = mailing_lists[list_name];
   
   if (!classp(list)) {
      return 0;
   }
   return list->creator;
} /* query_creator() */

/**
 * This method attempts to create a mailing list.
 * @return 1 if successful, 0 if not
 * @param list the name of the list to create
 * @param creator the creator of the list
 * @see query_creator()
 * @see query_members()
 * @see query_controllers()
 */
int create_list(string list, string creator) {
   SECURITY
   if (mailing_lists[list]) {
      return 0;
   }
   if (file_size("/d/" + list) == -2) {
      return 0;
   }
   if (PLAYER_HANDLER->test_user(list)) {
      return 0;
   }
   mailing_lists[list] = new(class mailing_list, members : ({ creator }),
                                          controllers : ({ creator }), creator : creator);
   save_me();
   return 1;
} /* create_list() */

/**
 * This method will delete a mailing list.
 * @param list the mailing list to delete
 * @see create_list()
 * @return 0 if failed and 1 on success
 */
protected int delete_list(string list) {
   if (!mailing_lists[list]) {
      return 0;
   }
   map_delete(mailing_lists, list);
   save_me();
   return 1;
} /* delete_list() */

/**
 * This method adds a controller to the specified mailing list.
 * @param list_name the controller to add
 * @param mem the controller to add
 * @see query_controllers()
 */
int add_controller(string list_name, string mem) {
   class mailing_list list = mailing_lists[list_name];
   
   SECURITY
   if (!classp(list)) {
      return 0;
   }
   if (member_array(mem, list->controllers) != -1) {
      return 0; /* already a controller... */
   }
   list->controllers += ({ mem });
   add_member(list_name, mem);
   save_me();
   return 1;
} /* add_controller() */

/**
 * This method removes a controller from the specified mailing list.
 * @param list_name the mailing list to remove the member from
 * @param name the member to remove
 * @see add_controller()
 * @see query_controller()
 */
int remove_controller(string list_name, string name) {
   int i;
   class mailing_list list = mailing_lists[list_name];

   SECURITY
   if (!classp(list)) {
      return 0;
   }
   if ((i = member_array(name, list->controllers)) == -1) {
      return 0;
   }
   list->controllers = delete(list->controllers, i, 1);
   save_me();
   return 1;
} /* remove_controller() */

/**
 * This method adds a member to the specified mailing list.
 * @param list_name the mailing list to add a member too
 * @param mem the member to add
 * @return 1 if successful, 0 if not
 * @see remove_member()
 * @see add_member()
 */
int add_member(string list_name, string mem) {
   class mailing_list list = mailing_lists[list_name];
   
   if (file_name(previous_object()) != MAIL_ROOM) {
      return 0;
   }
   if (!classp(list)) {
      return 0;
   }
   if (member_array(mem, list->members) != -1) {
      return 0; /* already a member... */
   }
   list->members += ({ mem });
   save_me();
   return 1;
} /* add_member() */

/**
 * This method removes a member from the specified mailing list.
 * @param list_name the mailing list to remove the member from
 * @param mem the members name to remove
 * @return 1 on success, 0 on failure
 * @see add_member()
 * @see query_member()
 * @see delete_member()
 */
int remove_member(string list_name, string mem) {
   int i;
   class mailing_list list = mailing_lists[list_name];
   
   if (file_name(previous_object()) != MAIL_ROOM) {
      return 0;
   }
   if (!classp(list)) {
      return 0;
   }
   if ((i = member_array(mem, list->members)) == -1) {
      return 0; /* not a member... */
   }
   list->members = delete(list->members, i, 1);
   if (!sizeof(list->members)) {
      delete_list(list_name);
   }
   save_me();
   return 1;
} /* remove_member() */

/**
 * This method removes a member from the list if they are either a
 * controller or a member.
 * @param list_name the list to remove the member from
 * @param mem the member to remove from the list
 * @return 1 on succes, 0 on failure
 * @see remove_member() 
 * @see remove_controller()
 */
int delete_member(string list_name, string mem) {
   class mailing_list list = mailing_lists[list_name];

   SECURITY
   if (!remove_member(list_name, mem)) {
      return 0;
   }
   remove_controller(list_name, mem);
   if (!sizeof(list->members)) {
      delete_list(list_name);
   }
   save_me();
   return 1;
} /* delete_member() */
// --- END [/mnt/home2/grok/lib/obj/handlers/mail_track.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/terrain_handler.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/terrain_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628107   Available: 13575461
Inodes: Total: 5242880    Free: 4960134
25293 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/terrain_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628107   Available: 13575461
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: terrain_handler.c,v 1.6 1999/11/10 09:50:40 taffyd Exp $
 */
/**
 * This is the terrain handler method documentation. For a more general
 * introduction to the terrain handler, please see the help for terrains.
 *
 * @author Sin
 * @author Turrican
 * @author others...
 *
 * @change 9 Nov 1997, Sin
 *    added support for inherit statements to
 *    get_room_size(), this fixes a bug in the terrain handler in
 *    regards to the placement of set_room_size() functions.  Added
 *    a limit of 4 inherits, so infinite loops aren't a problem.
 * @change 25 Nov 1997, Sin
 *    changed the calculate_exits() call so that it
 *    starts at the border of the current room instead of starting
 *    at the center of the current room.  This makes sense because
 *    it already knows the room size for the current room.  :)
 * @change 29 Nov 1997, Sin
 *    changed query_room_size() to cache results
 *    temporarily and to check the map handler before trying to
 *    parse on its own.
 * @see help::terrains
 */
#include <dirs.h>
#include <terrain.h>
#include <map.h>

#undef DEBUG_ROOM_SIZE
#undef DEBUG_CALC_EXITS
#define TP(x) tell_object(find_player("taffyd"), x);

#define BACKUP_TIME_OUT 1000000
inherit "/std/object";

string terrain_name;
mapping fixed_locations;
mixed *floating_locations;

private nosave int in_map;
private nosave mapping size_cache, cloned_locations, float_cache;
private nosave mapping std_types = ([ "north" : "path", "south" : "path",
  "east" : "path", "west" : "path", "northeast" : "hidden",
  "southwest" : "hidden", "southeast" : "hidden",
  "northwest" : "hidden", "up" : "stair", "down" : "stair" ]);

/** @ignore yes */
void setup() {
  size_cache = ([ ]);
  cloned_locations = ([ ]);
  float_cache = ([ ]);
  set_name("map");
  set_short("terrain map");
  add_adjective("terrain");
  set_long("This is a large map showing a large expanse of forest, desert, "
           "mountain or ocean.  A few locations of interest are marked on "
           "it, with most of the gaps between them blank or marked "
           "\"Here bee Draggons\" and the like, suggesting that the map-"
           "maker didn't know what was there either.\n" );
  add_adjective("terrain");
} /* setup() */

/**
 * This method checks wether there is a cloned location which matches the
 * given coordinates.
 * @param co_ords the coordinates to find the room for
 * @return the file name of the room with the given coordinates, or 0 if
 * it is not found
 * @see member_fixed_locations()
 * @see member_floating_locations()
 */
string member_cloned_locations(int *co_ords) {
  mapping tmp;

  if ((tmp = cloned_locations[terrain_name]) && (tmp = tmp[co_ords[0]]) &&
      (tmp = tmp[co_ords[1]])) {
      return tmp[co_ords[2]];
  }
  return 0;
} /* member_cloned_locations() */

/**
 * This method checks wether there is a fixed location which matches the
 * given coordinates.
 * @param co_ords the coordinates to find the room for
 * @return the file name of the room with the given coordinates, or 0 if
 * it is not found
 * @see member_cloned_locations()
 * @see member_floating_locations()
 */
string member_fixed_locations(int *co_ords) {
  int *loc_co_ords;
  string location;

  foreach (location, loc_co_ords in fixed_locations) {
    if ((co_ords[0] == loc_co_ords[0]) && (co_ords[1] == loc_co_ords[1]) &&
        (co_ords[2] == loc_co_ords[2])) {
      return location;
    }
  }
  return 0;
} /* member_fixed_locations() */

private int between(int limit1, int val, int limit2)
{
  if (limit1 < limit2) {
    return ((limit1 <= val) && (val <= limit2));
  } else {
    return ((limit2 <= val) && (val <= limit1));
  }
}

/**
 * This method checks wether there are floating locations which match the
 * given coordinates.
 * @param co_ords the coordinates to find the rooms for
 * @return an array with the file names of the rooms and the levels, or
 * the empty array if none are found
 * @see member_cloned_locations()
 * @see member_fixed_locations()
 */
mixed *member_floating_locations(int *co_ords) {
  int *data;
  mixed *right_locations, *location;
  
  right_locations = ({ });
  foreach (location in floating_locations) {
    data = location[1];
    if (sizeof(data) == 6) { 
      /* element is ({ file, ({ 6 coords bounding box }), priority }) */
      if (between(data[0], co_ords[0], data[3]) &&
          between(data[1], co_ords[1], data[4]) &&
          between(data[2], co_ords[2], data[5])) {
        right_locations += ({ location[0], location[2] });
      }
    } else {
      /* element is ({ file, ({ 3 coords of location }), priority }) */
      if ((co_ords[0] == data[0]) && (co_ords[1] == data[1]) &&
          (co_ords[2] == data[2])) {
        right_locations += ({ location[0], location[2] });
      }
    }
  }
  return right_locations;
} /* member_floating_locations() */

/**
 * This method searches the top level floating location for the given
 * coordinates.
 * @param co_ords the coordinates to find the top level for
 * @return the file name of the top level room with the given coordinates,
 * or 0 if none was found
 * @see member_floating_locations()
 */
string top_floating_location(int *co_ords) {
  int i, highest_level;
  string highest_location;
  mixed *right_locations;

  right_locations = member_floating_locations(co_ords);
  if (!sizeof(right_locations))
    return 0;
  highest_level = right_locations[1];
  highest_location = right_locations[0];
  for (i = 0; i < sizeof(right_locations); i += 2) {
    if (right_locations[i + 1] > highest_level) {
      highest_level = right_locations[i + 1];
      highest_location = right_locations[i];
    }
  }
  if (highest_location == "nothing")
    return 0;
  return highest_location;
} /* top_floating_location() */

private void init_data(string word) {
  terrain_name = word;
  fixed_locations = ([ ]);
  floating_locations = ({ });
} /* init_data() */

/**
 * This method loads the data file for a given terrain.
 * @param word the terrain to load the data for
 * @return 1 if the terrain exists, 0 if it didn't
 */
int get_data_file(string word) {
  if (terrain_name != word) {
    if (file_size(RESTORE_PATH + word + ".o") > 0) {
      unguarded((: restore_object, RESTORE_PATH + word :));
    } else {
      init_data(word);
      return 0;
    }
  }
  return 1;
} /* get_data_file() */
 
private void save_data_file(string word) {
  int number, last;
  string line, *lines;

  if (file_size(RESTORE_PATH + word +".o") > 0) {
    unguarded((: rename, RESTORE_PATH + word +".o",
               RESTORE_PATH +"backups/"+ word +"."+ time() :));
    lines = unguarded((: get_dir, RESTORE_PATH +"backups/"+ word +".*" :));
    if (sizeof(lines) > 3) {
      last = time() - BACKUP_TIME_OUT;
      foreach(line in lines) {
        sscanf(line, word +".%d", number);
        if (number < last)
          unguarded((: rm, RESTORE_PATH +"backups/"+ line :));
      }
    }
  }
  unguarded((: save_object, RESTORE_PATH + word :));
} /* save_data_file() */

/**
 * This method returns the cloned_locations mapping for a given terrain.
 * @param word the terrain name
 * @return the cloned_locations mapping; keys are the file names, values are
 * the coordinates for the files. There are also keys on x coordinates to
 * facilitate faster coordinate lookups.
 * @see query_fixed_locations()
 * @see query_floating_locations()
 */
mapping query_cloned_locations(string terrain) {
  return cloned_locations[terrain];
} /* query_cloned_locations() */

/**
 * This method returns the fixed_locations mapping for the given terrain.
 * @param word the terrain name
 * @return the fixed_locations mapping; keys are the file names, values are
 * the coordinates for the files
 * @see query_cloned_locations()
 * @see query_floating_locations()
 */
mapping query_fixed_locations(string word) {
  get_data_file(word);
  return fixed_locations;
} /* query_fixed_locations() */

/**
 * This method returns the floating_locations array for the given terrain.
 * @param word the terrain name
 * @return the floating_locations array; this is an array of arrays where each
 * array consists of the file name, an array of 6 coordinates forming a
 * bounding box or normal coordinates for the location and the level of the
 * floating location
 * @see query_cloned_locations()
 * @see query_fixed_locations()
 */
mixed *query_floating_locations(string word) {
  get_data_file(word);
  return floating_locations;
} /* query_floating_locations() */

/**
 * This method returns the coordinates for a given terrain and fixed location
 * filename.
 * @param terrain the terrain name
 * @param file the file name of the location
 * @return the coordinates
 */
int *query_co_ord(string terrain, string file) {
  get_data_file(terrain);
  return fixed_locations[file];
} /* query_co_ord() */

/**
 * This method returns the connecting room for the given coordinates and
 * direction.
 * @param terrain the terrain name
 * @param co_ords the coordinates
 * @param direc the direction to find the room for
 * @return the file name of the connecting room or 0 if none was found
 * @see query_connected()
 */
string query_connection(string terrain, int *co_ords, string direc) {
  mapping connection_info, tmp;
  string connections;

  if (!float_cache[terrain] ||
      !(connection_info = float_cache[terrain][co_ords[0]])) {
    if (file_size(RESTORE_PATH + terrain) != -2) {
      return 0;
    }
    if (file_size(RESTORE_PATH + terrain +"/"+ co_ords[0]) == -1) {
      return 0;
    }
    connections = unguarded((: read_file,
                              RESTORE_PATH + terrain +"/"+ co_ords[0] :));
    connection_info = restore_variable(connections);
    if (!mapp(float_cache[terrain])) {
      float_cache[terrain] = ([ co_ords[0] : connection_info ]);
    } else {
      float_cache[terrain][co_ords[0]] = connection_info;
    }
  }
  if ((tmp = connection_info[co_ords[1]]) && (tmp = tmp[co_ords[2]])) {
    return tmp[direc];
  }
  return 0;
} /* query_connection() */

/**
 * This method returns wether the given coordinates is connected to another
 * room in the terrain handler system.
 * @param terrain the terrain name
 * @param co_ords the coordinates
 * @return 1 if it is found, 0 otherwise
 * @see query_connection()
 */
int query_connected(string terrain, int *co_ords) {
  mapping connection_info, tmp;
  string connections;

  if (!float_cache[terrain] ||
      !(connection_info = float_cache[terrain][co_ords[0]])) {
    if (file_size(RESTORE_PATH + terrain) != -2) {
      return 0;
    }
    if (file_size(RESTORE_PATH + terrain +"/"+ co_ords[0]) == -1) {
      return 0;
    }
    connections = unguarded((: read_file,
                              RESTORE_PATH + terrain +"/"+ co_ords[0] :));
    connection_info = restore_variable(connections);
    if (!mapp(float_cache[terrain])) {
      float_cache[terrain] = ([ co_ords[0] : connection_info ]);
    } else {
      float_cache[terrain][co_ords[0]] = connection_info;
    }
  }
  if ((tmp = connection_info[co_ords[1]]) && tmp[co_ords[2]]) {
    return 1;
  }
  return 0;
} /* query_connected() */

/**
 * This method adds a new fixed location for a terrain.
 * @param terrain the terrain name
 * @param file the file name
 * @param co_ords the coordinates for the location
 * @return 1 if it succeeds, 0 if it fails (wrong coordinates or location
 * already present)
 * @see add_floating_location()
 * @see modify_fixed_location()
 */
int add_fixed_location(string terrain, string file, int *co_ords) {
  get_data_file(terrain);
  if (fixed_locations[file]) {
    return 0;
  }
  if (sizeof(co_ords) != 3) {
    return 0;
  }
  fixed_locations[file] = co_ords;
  save_data_file(terrain_name);
  return 1;
} /* add_fixed_location() */

private int add_connection(string terrain, int *co_ords, string direc,
                           string file) {
  mapping connection_info, tmp;
  string connections;

  if (!query_connection(terrain, co_ords, direc)) {
    if (file_size(RESTORE_PATH + terrain) != -2) {
      unguarded((: mkdir, RESTORE_PATH + terrain :));
    }
    if (file_size(RESTORE_PATH + terrain +"/"+ co_ords[0]) == -1) {
      connection_info = ([ co_ords[1] : ([ co_ords[2] : ([ direc : file ]) ])
                        ]);
      unguarded((: write_file, RESTORE_PATH + terrain + "/" + co_ords[0],
                   save_variable(connection_info), 1 :));
    } else {
      connections = unguarded((: read_file,
                                 RESTORE_PATH + terrain +"/"+ co_ords[0] :));
      connection_info = restore_variable(connections);
      if ((tmp = connection_info[co_ords[1]])) {
        if ((tmp = tmp[co_ords[2]])) {
          tmp[direc] = file;
        } else {
          connection_info[co_ords[1]][co_ords[2]] = ([ direc : file ]);
        }
      } else {
        connection_info[co_ords[1]] = ([ co_ords[2] : ([ direc : file ]) ]);
      }
      unguarded((: write_file, RESTORE_PATH + terrain + "/" + co_ords[0],
                   save_variable(connection_info), 1 :));
    }
    if (!mapp(float_cache[terrain])) {
      float_cache[terrain] = ([ co_ords[0] : connection_info ]);
    } else {
      float_cache[terrain][co_ords[0]] = connection_info;
    }
  }
} /* add_connection() */

/**
 * This method adds a new floating location for a terrain.
 * @param terrain the terrain name
 * @param file the file name
 * @param co_ords the coordinates for the location (either a single coordinate
 * or 2 forming a bounding rectangle)
 * @param level the level of this location
 * @return 1 if it succeeds, 0 if it fails (wrong coordinates or location
 * already present)
 * @see add_fixed_location()
 */
int add_floating_location(string terrain, string file, int *co_ords,
                          int level) {
  get_data_file(terrain);
  if ((sizeof(co_ords) != 6) && (sizeof(co_ords) != 3)) {
    return 0;
  }
  if (member_array(({ file, co_ords, level }), floating_locations) != -1) {
    return 0;
  }
  floating_locations += ({ ({ file, co_ords, level }) });
  save_data_file(terrain_name);
  return 1;
} /* add_floating_location() */

private void add_cloned_location(string terrain, string file, int *co_ords) {
  mapping tmp, location_m;

  if (!(location_m = cloned_locations[terrain])) {
    cloned_locations[terrain] = ([ file : co_ords,
                                   co_ords[0] : ([ co_ords[1] :
                                                   ([ co_ords[2] : file ]) ])
                                ]);
  } else {
    location_m[file] = co_ords;
    if ((tmp = location_m[co_ords[0]])) {
      if ((tmp = tmp[co_ords[1]])) {
        tmp[co_ords[2]] = file;
      } else {
        location_m[co_ords[0]][co_ords[1]] = ([ co_ords[2] : file ]);
      }
    } else {
      location_m[co_ords[0]] = ([ co_ords[1] : ([ co_ords[2] : file ]) ]);
    }
  }
} /* add_cloned_location() */

/**
 * This method modifies an existing fixed location for a terrain.
 * @param terrain the terrain name
 * @param file the file name
 * @param co_ords the coordinates for the location
 * @return 1 if it succeeds, 0 if it fails (wrong coordinates or location
 * not found)
 * @see add_fixed_location()
 */
int modify_fixed_location(string terrain, string file, int *co_ords) {
  get_data_file(terrain);
  if (!fixed_locations[file]) {
    return 0;
  }
  if (sizeof(co_ords) != 3) {
    return 0;
  }
  fixed_locations[file] = co_ords;
  save_data_file(terrain_name);
  return 1;
} /* modify_fixed_location() */

/**
 * This method deletes a cloned location for a terrain from the cache.
 * It is meant to be called when a cloned location is destructed.
 * @param terrain the terrain name
 * @param file the file name
 * @return 1 if it succeeds, 0 if it fails (location not present)
 * @see delete_fixed_location()
 * @see delete_floating_location()
 */
int delete_cloned_location(string terrain, string file) {
  int *co_ords;
  mapping tmp, location_m;
  
  if (!((location_m = cloned_locations[terrain]) &&
        (co_ords = location_m[file]))) {
    return 0;
  }
  map_delete(location_m, file);
  tmp = location_m[co_ords[0]][co_ords[1]];
  map_delete(tmp, co_ords[2]);
  if (!sizeof(tmp)) {
    tmp = location_m[co_ords[0]];
    map_delete(tmp, co_ords[1]);
    if (!sizeof(tmp)) {
      map_delete(location_m, co_ords[0]);
      if (!sizeof(location_m)) {
        map_delete(cloned_locations, terrain);
      }
    }
  }
  return 1;
} /* delete_cloned_location() */

/**
 * This method deletes a fixed location for a terrain.
 * @param terrain the terrain name
 * @param file the file name
 * @return 1 if it succeeds, 0 if it fails (location not present)
 * @see delete_cloned_location()
 * @see delete_floating_location()
 */
int delete_fixed_location(string terrain, string file) {
  get_data_file(terrain);
  if (!fixed_locations[file]) {
    return 0;
  }
  map_delete(fixed_locations, file);
  save_data_file(terrain_name);
  return 1;
} /* delete_fixed_location() */

/**
 * This method deletes a floating location for a terrain.
 * @param terrain the terrain name
 * @param file the file name
 * @param co_ords the coordinates for the location (either a single coordinate
 * or 2 forming a bounding rectangle)
 * @return 1 if it succeeds, 0 if it fails (location not present)
 * @see delete_cloned_location()
 * @see delete_fixed_location()
 */
int delete_floating_location(string terrain, string file, int *co_ords) {
  int i, j, flag_d, flag_m, *data;

  get_data_file(terrain);
  for (i = 0; i < sizeof(floating_locations); i++) {
    if (floating_locations[i][0] == file) {
      data = floating_locations[i][1];
      if (sizeof(data) != sizeof(co_ords)) {
        continue;
      }
      flag_m = 0;
      for (j = 0; j < sizeof(data); j++) {
        if (data[j] != co_ords[j]) {
          flag_m = 1;
          break;
        }
        if (!flag_m) {
          floating_locations = delete(floating_locations, i, 1);
          flag_d = 1;
        }
      }
    }
  }
  save_data_file(terrain_name);
  return flag_d;
} /* delete_floating_location() */

/**
 * This method clears the cloned locations cache for a given terrain.
 * @param terrain the terrain name
 * @see clear_connections()
 */
void clear_cloned_locations(string terrain) {
  map_delete(cloned_locations, terrain);
} /* clear_cloned_locations() */

/**
 * This method clears all connections for a given terrain. This needs to
 * be done when a terrain was modified.
 * @param terrain the terrain name
 * @see clear_cloned_locations()
 */
void clear_connections(string terrain) {
  string line, *lines;

  if (file_size(RESTORE_PATH + terrain) != -2) {
    return;
  }
  lines = unguarded((: get_dir, RESTORE_PATH + terrain +"/*" :)) -
    ({ ".", ".." });
  foreach(line in lines) {
    unguarded((: rm, RESTORE_PATH + terrain +"/"+ line :));
  }
} /* clear_connections() */

private int right_co_ords(int *new_co_ords, int *co_ords, int delta,
                          int *vector) {
  int i;

  for (i = 0; i < 3; i++) {
    if (new_co_ords[i] + delta * vector[i] != co_ords[i]) {
      return 0;
    }
  }
  return 1;
} /* right_co_ords() */

/**
 * This method returns the room size for a given room. It uses a cache
 * to speed things up.
 * @param file the file name of the room
 * @param level the recursion level
 * @return the size of the room
 */
int get_room_size(string file, int level) {
  int i, number, roomsize, *mapsize;
  string bname, parent, *lines;

  bname = base_name(file);
  if (size_cache[bname]) {
#ifdef DEBUG_ROOM_SIZE
    TP(sprintf("GRS says (cached) %s is %d\n", file, size_cache[bname]));
#endif
    return size_cache[bname];
  }

  if (find_object(file)) {
    size_cache += ([ bname : file->query_room_size() ]);
#ifdef DEBUG_ROOM_SIZE
    TP(sprintf("GRS says (loaded) %s is %d\n", file, size_cache[bname]));
#endif
    return size_cache[bname];
  }

  if (!in_map) {
    in_map = 1;
    mapsize = MAP_HANDLER->query_room_size(bname);
    in_map = 0;
  } else {
#ifdef DEBUG_ROOM_SIZE
    TP("GRS says recursion!\n");
#endif
    mapsize = 0;
  }
  if (mapsize) {
    size_cache += ([ bname : mapsize[0] ]);
#ifdef DEBUG_ROOM_SIZE
    TP(sprintf("GRS says (map) %s is %d\n", file, size_cache[bname]));
#endif
    return mapsize[0];
  }
  
  /* May I please throw up violently? - Turrican */
  file = bname + ".c";
  if (file_size(file) < 0) {
    return 10;
  }
  lines = explode(read_file(file), "\n");
  roomsize = 10;
  for (i = 0; i < sizeof(lines); i++) {
    if (level < 4 &&
        sscanf(lines[i], "%*sinherit%*s\"%s\"%*s;", parent) == 4) {
      if (parent[<2..] != ".c") {
        parent += ".c";
      }
      roomsize = get_room_size(parent, level + 1);
    } else if (sscanf(lines[i], "%*sset_room_size(%*s%d%*s", number) == 4) {
      roomsize = number;
      break;
    }
  }
  size_cache += ([ bname : roomsize ]);
#ifdef DEBUG_ROOM_SIZE
  TP(sprintf("GRS says (parsed) %s is %d\n", file, size_cache[bname]));
#endif
  return roomsize;
} /* get_room_size() */

private void add_exit(object place, string direc, string dest) {
  string type;

  type = (string)place->query_exit_type(direc, dest);
  if (!type) {
    type = std_types[direc];
  } else {
    if (type == "none") {
      return;
    }
  }
  place->add_exit(direc, dest, type);
} /* add_exit() */

private void calculate_exits(object place, int *co_ords) {
  int i, j, k, connected, delta, *new_co_ords;
  string actual, *exit_dirs;

  connected = query_connected(terrain_name, co_ords);
  exit_dirs = (string *)place->query_direc();
  for (i = 0; i < 20; i += 2) {
    if (member_array(STD_ORDERS[i], exit_dirs) != -1) {
      continue;
    }
    actual = query_connection(terrain_name, co_ords, STD_ORDERS[i]);
    if (actual) {
#ifdef DEBUG_CALC_EXITS
      TP(sprintf("actual room %s found\n", actual));
#endif
      add_exit(place, STD_ORDERS[i], actual);
      continue;
    }
    if (connected) {
#ifdef DEBUG_CALC_EXITS
      TP("connected, but no actual room\n");
#endif
      continue;
    }
    new_co_ords = copy(co_ords);
    for (k = 0; k < 3; k++) {
      new_co_ords[k] -= place->query_room_size() * STD_ORDERS[i+1][k];
    }
    reset_eval_cost();
    for (j = 0; j < 100; j++) {
      for (k = 0; k < 3; k++) {
        new_co_ords[k] -= 5 * STD_ORDERS[i+1][k];
      }
      if ((actual = member_fixed_locations(new_co_ords)) ||
          (actual = member_cloned_locations(new_co_ords)) ||
          (actual = top_floating_location(new_co_ords))) {
        delta = (int)place->query_room_size() + get_room_size(actual, 0);
        if (!right_co_ords(new_co_ords, co_ords, delta, STD_ORDERS[i+1])) {
          continue;
        }
#ifdef DEBUG_CALC_EXITS
        TP(sprintf("adding connection for %s\n", actual));
#endif
        add_connection(terrain_name, co_ords, STD_ORDERS[i],
                       base_name(actual));
        add_exit(place, STD_ORDERS[i], actual);
        break;
      }
    }
  }
} /* calculate_exits() */

/**
 * This method is the main entry point for the terrain handler. It loads
 * the room that is associated with the given terrain and coordinates.
 * @param terrain the terrain name
 * @param co_ords the coordinates to look up
 * @return the room that was found or loaded
 * @see setup_location()
 */
object find_location(string terrain, int *co_ords) {
  string dest_name;
  object destination;
   
  if (!(get_data_file(terrain)) || (sizeof(co_ords) != 3)) {
    return 0;
  }
  reset_eval_cost();
  if ((dest_name = member_fixed_locations(co_ords))) {
    if (!(destination = find_object(dest_name))) {
      destination = load_object(dest_name);
    }
    return destination;
  }
  if (dest_name = member_cloned_locations(co_ords)) {
    if ((destination = find_object(dest_name))) {
      return destination;
    } else {
      delete_cloned_location(terrain, dest_name);
    }
  }
  if (dest_name = top_floating_location(co_ords)) {
    destination = clone_object(dest_name);
    destination->set_co_ord(co_ords);
    destination->set_terrain(terrain_name);
    calculate_exits(destination, co_ords);
    add_cloned_location(terrain, file_name(destination), co_ords);
    return destination;
  }
  return 0;
} /* find_location() */

/**
 * This method is called when a normal room is loaded which is part of
 * a terrain. The terrain handler needs to know about this to be able
 * to calculate the exits into the floating portion of the terrain.
 * It also sets the coordinates of the room to the values as saved in the
 * terrain.
 * @param place the room object which is a fixed location in the terrain
 * @param terrain the terrain name
 * @see find_location()
 */
void setup_location(object place, string terrain) {
  int *co_ords;

  get_data_file(terrain);
  if (!fixed_locations[base_name(place)]) {
    return;
  }
  co_ords = fixed_locations[base_name(place)];
  place->set_co_ord(co_ords);
  calculate_exits(place, co_ords);
} /* setup_location() */

/** @ignore yes */
mixed *stats() {
  return ::stats() + ({
    ({ "roomsize cache size", sizeof(size_cache) }),
      ({ "cloned_locations", sizeof(cloned_locations) }),
        ({ "float_cache", sizeof(float_cache) }),
          ({ "terrain name", terrain_name }),
            ({ "fixed locations", sizeof(fixed_locations) }),
              ({ "floating locations", sizeof(floating_locations) }),
  });
}
// --- END [/mnt/home2/grok/lib/obj/handlers/terrain_handler.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/handlers/player_shop.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/handlers/player_shop.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628101   Available: 13575455
Inodes: Total: 5242880    Free: 4960134
4986 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/handlers/player_shop.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628101   Available: 13575455
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is the handler for player-run shops.
 *
 * <p><b>Description</b></p>
 *</p>
 * <p>This handler ensures that the very short name (and therefore save file
 * directories) are unique for each shop.  Anybody may add a new shop but
 * only a Lord may remove or update an existing shop's details.
 *</p>
 * </p>
 * @author Ringo
 * @started 28th January 2001
 */
#include <player_shop.h>
#include <mail.h>

#define REFRESH_HANDLER "/obj/handlers/refresh"
#define save_me() unguarded((:write_file, "/save/player_shops", \
                  save_variable(_shops), 1:));


private nosave mapping _shops = 0;

/**
 * @ignore yes
 */
void create()
{
    seteuid("Root");
    if (file_size("/save/player_shops") > 0)
    {
        _shops = restore_variable(unguarded((:read_file,
              "/save/player_shops":)));
    }
}
/* create() */

/**
 * Add a shop to the handler.
 * @param short_name The shop name passed to set_very_short()
 * @param office_path The path to the shop's office.
 * @return 1 on success, 0 if this shop already exists or no such path.
 * @see /std/shops/player_shop/office.c
 */ 
int add_shop(string short_name, string office_path)
{
    string savedir;
    object ob;

    if (!(ob = find_object(office_path)))
    {
        tell_object(this_player(), "No such object "+ office_path+ ".\n");
        return 0;
    }
    if (_shops)
    {
        if (_shops[short_name])
        {
            tell_object(this_player(), "Shop already exists.\n");
            return 0;
        }
        _shops += ([short_name:""]);
    }
    else
    {
        _shops = ([short_name:""]);
    }
    _shops[short_name] = office_path;
    REFRESH_HANDLER->register_refresh(office_path);
    REFRESH_HANDLER->register_delete(office_path);

    /* Make the save directory */
    savedir = sprintf("/save/player_housing/%s/",
      lower_case(geteuid(ob)));
    if (!sizeof(get_dir(savedir)))
        unguarded((: mkdir, savedir :));
    savedir += sprintf("/player_shops");
    if (!sizeof(get_dir(savedir)))
        unguarded((: mkdir, savedir :));
    savedir += sprintf("/%s", short_name);
    if (!sizeof(get_dir(savedir)))
        unguarded((: mkdir, savedir :));

    save_me();
    return 1;
}
/* add_shop() */

/**
 * Remove a shop from the handler.
 * Lords only.
 * @param short_name The shop name passed to set_very_short()
 * @return 1 on success, 0 if this shop doesn't exist.
 * @see /std/shops/player_shop/office.c
 */ 
int remove_shop(string short_name)
{
    if (!_shops || !_shops[short_name])
    {
        tell_object(this_player(), "Shop doesn't exist.\n");
        return 0;
    }
    if (!this_player()->query_lord() && 
      this_player()->query_name() != CREATOR)
    {
        tell_object(this_player(), "Permission denied.\n");
        return 0;
    }
    map_delete(_shops, short_name);
    save_me();
    return 1;
}
/* remove_shop() */

/**
 * Update a shop's path.
 * Lords only.
 * @param short_name The shop name passed to set_very_short()
 * @param office_path The path to the shop's office.
 * @return 1 on success, 0 if this shop doesn't exists or no such path.
 * @see /std/shops/player_shop/office.c
 */ 
int update_shop(string short_name, string office_path)
{
    if (!_shops || !_shops[short_name])
    {
        tell_object(this_player(), "Shop doesn't exist.\n");
        return 0;
    }
    if (!this_player()->query_lord() && 
      this_player()->query_name() != CREATOR)
    {
        tell_object(this_player(), "Permission denied.\n");
        return 0;
    }
    if (!find_object(office_path))
    {
        tell_object(this_player(), "No such object "+ office_path+ ".\n");
        return 0;
    }
    REFRESH_HANDLER->register_refresh(office_path);
    REFRESH_HANDLER->register_delete(office_path);
    _shops[short_name] = office_path;
    save_me();
    return 1;
}
/* update_shop() */

/**
 * Query a shop's path.
 * Used by the office to check this is a valid shop.
 * @param short_name The shop name passed to set_very_short()
 * @return The path to the office, or a blank string if no such shop.
 * @see /std/shops/player_shop/office.c
 */ 
string query_shop(string short_name)
{
    if (!_shops || !_shops[short_name])
        return "";
    if (!find_object(_shops[short_name]))
        return "No such file "+ _shops[short_name]+ ".";
    return _shops[short_name];
}
/* query_shop() */

/**
 * Query the list of shops.
 * @return The shops mapping.
 */
mapping query_shops() { return copy(_shops); }

/**
 * Send mail
 */
void auto_mail(string to, string from, string sub, string cc, string body)
{
    if (_shops)
    {
        foreach (string shop in keys(_shops))
        {
            if (_shops[shop] == file_name(previous_object()))
            {
                return MAILER->do_mail_message(to, from, sub, cc, body, 0, 0, 1);
            }
        }
    }
    unguarded((: write_file, "/log/CHEAT",
        "Illegal access to AUTO_MAILER.\n" "Backtrace: " +
        back_trace() :));
}
/* auto_mail() */
// --- END [/mnt/home2/grok/lib/obj/handlers/player_shop.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/shovel.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/shovel.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628099   Available: 13575453
Inodes: Total: 5242880    Free: 4960134
3346 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/shovel.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628099   Available: 13575453
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: shovel.c,v 1.4 1998/03/25 12:39:18 pinkfish Exp $
 * $Log: shovel.c,v $
 * Revision 1.4  1998/03/25 12:39:18  pinkfish
 * Fixe dup the index in a sepaerate thingy problem.
 *
 * Revision 1.3  1998/03/25 04:59:42  jeremy
 * More autodoc updating.
 *
 * Revision 1.1  1998/03/24 07:20:53  pinkfish
 * Initial revision
 *
 * 
 */
/**
 * This is a clonable shovel object (a "shovel" in this case being anything
 * that can be used for digging, from a garden trowel to a steam shovel).
 * The "dig" command is defined with the following syntax:
 * <ul>
 * <li> "with <direct:object> in <string>"
 * <li> "with <direct:object> in <indirect:object>"
 * <li> "with <direct:object>"
 * <li> "[in] <string> with <direct:object>"
 * <li> "[in] <indirect:object> with <direct:object>"
 * </ul><br>
 * The do_dig() function tries to call a function dig() on this_player()'s
 * environment, which should be defined as
 * <p><code>
 * int dig( object indir, string indir_s )
 * </code><p>
 * where
 * <ul>
 * <li> <i>indir</i> is the <indirect:object> matched (if any)
 * <li> <i>indir_s</i> is the <string> matched, or the string that
 *      matched <indirect:object>
 * </ul><br>
 * Note that the command can match either actual objects or just strings;
 * also note that, although it will match room items, the object passed
 * won't really be of much use (which is why the string is passed also).
 *
 * @index dig
 */

inherit "/obj/weapon";

string *patterns = ({
  "with <direct:object> in <string>",
  "with <direct:object> in <indirect:object>",
  "with <direct:object>",
  "[in] <string> with <direct:object>",
  "[in] <indirect:object> with <direct:object>"
});

/**
 * @ignore yes
 */
void init(){
  this_player()->add_command("dig", this_object(), patterns);
} /* init() */

/**
 * @ignore yes
 */
int do_dig( object *things, string dir_match, string
            indir_match, mixed *args, string pattern) {
  object *obj, indir;
  string indir_s;

  if (!objectp(environment(this_player()))) {
    return 0;
  }
  obj=this_player()->query_holding();
  if(member_array(this_object(), obj) == -1){
    this_player()->add_failed_mess(this_object(), "You must hold the $D to "
                                   "dig with it.\n", ({}));
    return 0;
  }
  if (pattern == patterns[4]) {
    if (!objectp(indir = things[0])) {
      return 0;
    }
    indir_s = args[0];
  } else if (pattern == patterns[3]) {
    indir_s = args[0];
    indir = 0;
  } else if (pattern == patterns[2]) {
    indir_s = 0;
    indir = 0;
  } else if (pattern == patterns[1]) {
    if (!objectp(indir = things[0])) {
      return 0;
    }
    indir_s = args[1];
  } else if (pattern == patterns[0]) {
    indir_s = args[1];
    indir = 0;
  } else {
    return 0;
  }
  // This is causing multiple failure messages, so I'll take it out until
  // the problem is sorted out.
  //this_player()->add_failed_mess(this_object(), "This doesn't appear to "
  //                               "be a good place for digging.\n", ({ }));
  return environment(this_player())->dig(indir, indir_s);
} /* do_dig() */

/** @ignore yes */
mapping query_static_auto_load() {
   if ( explode( file_name( this_object() ), "#" )[ 0 ] == "/obj/shovel" )
      return int_query_static_auto_load();
   return ([ ]);
} /* query_static_auto_load() */
// --- END [/mnt/home2/grok/lib/obj/shovel.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/rings/low_gp_ring.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/rings/low_gp_ring.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628098   Available: 13575452
Inodes: Total: 5242880    Free: 4960134
1472 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/rings/low_gp_ring.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628098   Available: 13575452
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* Ringo - May 1997 */

#define GP_AWARD 50

inherit "/obj/ring";

void setup() {
    set_name( "ring" );
    set_short( "pink crystal ring" );
    add_adjective( ({ "pink", "crystal" }) );
    set_main_plural( "pink crystal rings" );
    set_long( "The ring is a single piece of $material$, cut and polished "+
      "until its facets sparkle in the light.\n" );
    set_material( "rosy-quartz" );
    set_value( 250 );
    set_value_info( "artifact", 5000 );
    set_weight( 1 );
    set_enchant( 3 );
    add_property( "artifact form", ([
        "ring of energy" : 4
      ]) );
    adjust_charges( 1 + random( 11 ) );
    set_level( 25 );
    set_zapper( file_name( this_object() ) );
} /* setup() */

string query_ring_name() { return "ring of energy"; }

void zap( object dummy, object person, object ring ) {
    tell_object( person, "You feel slightly more powerful.\n" );
    if ( ( (string)person->query_gp() + GP_AWARD ) >
      (string)person->query_max_gp() ) {
        person->set_gp( person->query_max_gp() );
        return;
    }
    person->adjust_gp( GP_AWARD );
} /* zap() */

int failed_zap( object dummy, object person, object ring ) {
    tell_object( person, "You feel slightly less powerful.\n" );
    person->add_succeeded_mess( ring, "$N $V $D.\n", ({ }) );
    if ( person->query_gp() < ( GP_AWARD / 3 ) ) {
        person->set_gp( 0 );
        return 1;
    }
    person->adjust_gp( 0 - ( GP_AWARD / 3 ) );
    return 1;
} /* failed_zap() */
// --- END [/mnt/home2/grok/lib/obj/rings/low_gp_ring.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/rings/invisibility.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/rings/invisibility.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628098   Available: 13575452
Inodes: Total: 5242880    Free: 4960134
1101 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/rings/invisibility.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628098   Available: 13575452
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/obj/ring";

void setup() {
   set_name( "ring" );
   set_short( "clear crystal ring" );
   add_adjective( ({ "clear", "crystal" }) );
   set_main_plural( "clear crystal rings" );
   set_long( "The ring is made from a colourless stone that seems to refract "+
         "light in a strange way.  The outer edge has eight sides.\n" );
   set_material( "calcite" );
   set_value( 200 );
   set_value_info( "artifact", 5000 );
   set_weight( 1 );
   set_enchant( 2 );
   add_property( "no recycling", 1 );
   add_property( "fluff'n'stuff", 1 );
   add_property( "artifact form", ([
      "ring of invisibility" : 2
   ]) );
   adjust_charges( 1 + random( 7 ) );
   set_level( 60 );
   set_zapper( file_name( this_object() ) );
} /* setup() */

string query_ring_name() { return "ring of invisibility"; }

void zap( object dummy, object person, object ring ) {
   person->add_effect( "/std/effects/magic/invisibility",
         roll_MdN( 7, (int)ring->query_level() ) );
} /* zap() */

/*
int failed_zap( object dummy, object person, object ring ) {
Should make them go blind...
} failed_zap() */
// --- END [/mnt/home2/grok/lib/obj/rings/invisibility.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/rings/high_gp_ring.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/rings/high_gp_ring.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628097   Available: 13575451
Inodes: Total: 5242880    Free: 4960134
1472 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/rings/high_gp_ring.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628097   Available: 13575451
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* Ringo - May 1997 */

#define GP_AWARD 250

inherit "/obj/ring";

void setup() {
    set_name( "ring" );
    set_short( "pink crystal ring" );
    add_adjective( ({ "pink", "crystal" }) );
    set_main_plural( "pink crystal rings" );
    set_long( "The ring is a single piece of $material$, cut and polished "+
      "until its facets sparkle in the light.\n" );
    set_material( "rosy-quartz" );
    set_value( 750 );
    set_value_info( "artifact", 15000 );
    set_weight( 1 );
    set_enchant( 5 );
    add_property( "artifact form", ([
        "ring of power" : 6
      ]) );
    adjust_charges( 1 + random( 11 ) );
    set_level( 75 );
    set_zapper( file_name( this_object() ) );
} /* setup() */

string query_ring_name() { return "ring of power"; }

void zap( object dummy, object person, object ring ) {
    tell_object( person, "You feel slightly more powerful.\n" );
    if ( ( (string)person->query_gp() + GP_AWARD ) >
      (string)person->query_max_gp() ) {
        person->set_gp( person->query_max_gp() );
        return;
    }
    person->adjust_gp( GP_AWARD );
} /* zap() */

int failed_zap( object dummy, object person, object ring ) {
    tell_object( person, "You feel slightly less powerful.\n" );
    person->add_succeeded_mess( ring, "$N $V $D.\n", ({ }) );
    if ( person->query_gp() < ( GP_AWARD / 3 ) ) {
        person->set_gp( 0 );
        return 1;
    }
    person->adjust_gp( 0 - ( GP_AWARD / 3 ) );
    return 1;
} /* failed_zap() */
// --- END [/mnt/home2/grok/lib/obj/rings/high_gp_ring.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/rings/med_gp_ring.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/rings/med_gp_ring.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628097   Available: 13575451
Inodes: Total: 5242880    Free: 4960134
1474 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/rings/med_gp_ring.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628097   Available: 13575451
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* Ringo - May 1997 */

#define GP_AWARD 150

inherit "/obj/ring";

void setup() {
    set_name( "ring" );
    set_short( "pink crystal ring" );
    add_adjective( ({ "pink", "crystal" }) );
    set_main_plural( "pink crystal rings" );
    set_long( "The ring is a single piece of $material$, cut and polished "+
      "until its facets sparkle in the light.\n" );
    set_material( "rosy-quartz" );
    set_value( 500 );
    set_value_info( "artifact", 10000 );
    set_weight( 1 );
    set_enchant( 4 );
    add_property( "artifact form", ([
        "ring of vigour" : 5
      ]) );
    adjust_charges( 1 + random( 11 ) );
    set_level( 50 );
    set_zapper( file_name( this_object() ) );
} /* setup() */

string query_ring_name() { return "ring of vigour"; }

void zap( object dummy, object person, object ring ) {
    tell_object( person, "You feel slightly more powerful.\n" );
    if ( ( (string)person->query_gp() + GP_AWARD ) >
      (string)person->query_max_gp() ) {
        person->set_gp( person->query_max_gp() );
        return;
    }
    person->adjust_gp( GP_AWARD );
} /* zap() */

int failed_zap( object dummy, object person, object ring ) {
    tell_object( person, "You feel slightly less powerful.\n" );
    person->add_succeeded_mess( ring, "$N $V $D.\n", ({ }) );
    if ( person->query_gp() < ( GP_AWARD / 3 ) ) {
        person->set_gp( 0 );
        return 1;
    }
    person->adjust_gp( 0 - ( GP_AWARD / 3 ) );
    return 1;
} /* failed_zap() */
// --- END [/mnt/home2/grok/lib/obj/rings/med_gp_ring.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/rings/recall.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/rings/recall.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628096   Available: 13575450
Inodes: Total: 5242880    Free: 4960134
2775 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/rings/recall.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628096   Available: 13575450
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <drinks.h>
#include <cwc.h>
#include <config.h>

inherit "/obj/ring";

void setup() {
  set_name( "ring" );
  set_short( "blue crystal ring" );
  add_adjective( ({ "blue", "crystal" }) );
  set_main_plural( "blue crystal rings" );
  set_long( "The ring is a single piece of $material$, cut and polished "+
      "until its facets sparkle in the light.\n" );
  set_material( "sapphire" );
  set_value( 500 );
  set_value_info( "artifact", 10000 );
  set_weight( 1 );
  set_enchant( 3 );
  add_property( "artifact form", ([
    "ring of recall" : 3
  ]) );
  adjust_charges( 1 + random( 11 ) );
  set_level( 30 );
  set_zapper( file_name( this_object() ) );
} /* setup() */

string query_ring_name() { return "ring of recall"; }

string find_start_location( object person ) {
    string pos;

    if ( file_name( environment( person ) )[0..19] == "/d/cwc/Bes_Pelargic/" ) {
        return CWC_START_LOCATION;
    }

    pos = person->query_start_pos();

    if ( pos[ 0..19 ] == "/d/cwc/Bes_Pelargic/" && file_name( environment( person ) )[ 0..19 ] != "/d/cwc/Bes_Pelargic/" ) {
        return CONFIG_START_LOCATION;
    }
    
    return pos;
} /* find_start_location() */ 

void zap( object dummy, object person, object ring ) {
   string place;
   place = query_property( "destination" );
   if ( !place ) { 
      call_out( "move_person", 0, person, find_start_location( person ) );
   }
   else {
      call_out( "move_person", 0, person, place );
   }
} /* zap() */

int failed_zap( object dummy, object person, object ring ) {
  //call_out( "move_person", 0, person, ({
  //    "/d/klatch/tsort/desert/roads/road3",
  //    "/d/sur/Sheepridge/firkin",
  //})[ random( 2 ) ] );
  person->add_succeeded_mess( ring, "$N $V $D, but nothing happens.\n", ({ }) );
  return 1;
} /* failed_zap() */

void move_person( object person, string place ) {
  tell_creator( "taffyd", "%O, %s\n", person, place );

  if ( !find_object( place ) )
    place->force_load();
  if ( !find_object( place ) ) {
    tell_object( person, "Please contact a creator and ask that \""+ place +
        "\" be checked.  You are also owed a charge on this ring.\n" );
    return;
  }
  if ( environment( person ) == find_object( place ) ) {
    tell_object( person, "You momentarily feel dislocated from reality; "+
        "the feeling passes, but something has changed...\n" );
    person->adjust_volume( D_ALCOHOL, ( 500 + random( 500 ) ) * ( 1 -
        2 * random( 2 ) ) );
    return;
  }
  tell_object( person, "You suddenly feel as if something yanks you "+
      "across the dimensions.\n" );
  person->move_with_look( place, "A spot of blue appears, enlarges and "+
      "turns into $N.", "$N shrinks and becomes red, then disappears "+
      "altogether." );
} /* move_person() */
// --- END [/mnt/home2/grok/lib/obj/rings/recall.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/multiple_scabbard.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/multiple_scabbard.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628095   Available: 13575449
Inodes: Total: 5242880    Free: 4960134
3362 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/multiple_scabbard.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628095   Available: 13575449
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:56.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <move_failures.h>

inherit "/obj/scabbard";

int capacity, throwable;

int query_clothing() { return 1; }
int query_throwable() { return throwable; }
int query_capacity() { return capacity; }
string query_pocket_mess() { return "$ob_short$"; }
void set_throwable(int i) { throwable = i; }
void set_capacity(int i) { capacity = i; }

void create() {
   do_setup++;
   ::create();
   do_setup--;
   set_no_types_in_long(1);
   if( !do_setup )
      this_object()->setup();
} /* create() */

void throw( object * knives, object * targets ) {
   ( "cmds/living/th_row" )->cmd( ({ knives, targets }), 0, "at" );
}

int do_hurl( object * knives, object * targets, int targeted ) {
   object knife, target;

   if( this_player()->query_property( "dead" ) ) {
      add_failed_mess( "You're dead!\n" );
      return -1;
   }

   if( this_object()->query_worn_by() != this_player() ) {
      add_failed_mess( "You must be wearing " + this_object()->the_short()
        + " to hurl weapons from it.\n" );
      return targeted ? -1 : 0;
   }

   if( sizeof( targets ) > 1 ) {
      add_failed_mess( "You can only throw at one target at a time.\n" );
      return -1;
   }
   target = targets[0];

   if( target == this_player() ) {
      add_failed_mess( "Don't be silly.\n" );
      return -1;
   }

   if( target->query_property( "dead" ) ) {
      add_failed_mess( target->the_short(1) + " is dead.\n" );
      return -1;
   }

   if( pk_check( this_player(), target ) ) {
      add_failed_mess( "You really shouldn't do that.\n" );
      return 0;
   }

   if( sizeof( knives ) > 1 ) {
      add_failed_mess( "You can only throw one weapon at a time.\n" );
      return 0;
   }
   knife = knives[0];

   if( knife->move( this_player() ) != MOVE_OK ) {
      add_failed_mess( "You can't draw " + knife->the_short() + " from "
        + the_short() + ".\n" );
      return targeted ? -1 : 0;
   }

   if( this_player()->query_free_limbs() < 1 ) {
      knife->move( this_object() );
      add_failed_mess( "You need a free hand.\n" );
      return -1;
   }

   if( !sizeof( knife->hold_item( this_player() ) ) ) {
      knife->move( this_object() );
      add_failed_mess( "You cannot hold " + knife->the_short() + ".\n" );
      return -1;
   }

   add_succeeded_mess( "$N snatch$es " + knife->a_short() + " from $D.\n" );
   call_out( "throw", 0, knives, targets );
   return 1;
} /* do_hurl() */

/** @ignore yes */
int test_add( object thing, int flag, int noprint ) {
   int foo;

   if(flag)
      return 0;

   if( !environment( thing ) )
      return ::test_add( thing, flag );
   if( sizeof( all_inventory( this_object() ) ) >= capacity ) {
      if( !noprint )
         write( the_short() + " is already full.\n" );
      return 0;
   }

   foo = test_type_ok( thing, flag );
   if(foo)
      return foo;
   if( !noprint )
      write( thing->the_short() + " doesn't fit very well in "
        + the_short() + ".  " + sheath );
   return 0;
} /* test_add() */

void init() {
   if( query_throwable() ) {
      add_command( "hurl",
        "<indirect:object:direct-obs'weapon'> at <indirect:living:here>",
        (: do_hurl( $1[0], $1[1], 0 ) :) );
      add_command( "hurl",
        "<indirect:object:direct-obs'weapon'> at <indirect:living:here> "
          "from <direct:object:me>",
        (: do_hurl( $1[0], $1[1], 1 ) :) );
   }
} /* init() */
// --- END [/mnt/home2/grok/lib/obj/multiple_scabbard.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/plants/inherit/grain.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/plants/inherit/grain.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628094   Available: 13575448
Inodes: Total: 5242880    Free: 4960134
3161 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/plants/inherit/grain.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628094   Available: 13575448
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming

/**
 * This is an inherit for grains that can be processed into flour.
 *
 * @creator Vashti
 * @started 21st January 2003
 */
 
// eat mess
// chew command

#include <move_failures.h>
#include <state_change.h>

#define TO this_object()
#define TP this_player()

#define THRESHOLD 5

inherit "/obj/food";

int _max_strip;

/** @ignore yes
 * Grains pretty much all work alike, but all of this can be overridden.
 */
void create() {
  do_setup++;
  ::create();
  do_setup--;

  set_name( "grain" );
  set_short( "broken grain" );
  set_long( "This is some funky, but broken, grain.\n" );
  
  _max_strip = THRESHOLD;
  
  remove_help_file( "food" );
  add_help_file( "grain" );
  
  add_alias( "plant" );
  add_plural( "plants" );

  set_collective();
  
  set_amount( 1 );
  set_weight_unit( ({ 1, 10 }) );

  set_eat_mess( ({
    "$N choke down $D. It absorbs all the moisture from your mouth and sticks "
      "in your throat.  Looks like you just aren't designed to eat unmilled "
      "grain.\n",
    "$N chokes down $D, coughing and rubbing $p throat unhappily.\n"
  }) );
  
  if ( ! do_setup ) {
    TO->setup();
    TO->reset();
  }
} /* create */


/** @ignore yes */
void init() {
  ::init();
  
  TP->add_command( "chew", TO );
  TP->add_command( "strip", TO );
} /* init */


/**
 * This sets the maximum number of items that can be stripped by
 * hand at once.
 */
void set_max_strippable( int num ) {
  _max_strip = num;
} /* set_max_strippable */


/**
 * This returns the maximum number of items that can be stripped
 * by hand at once.
 */
int query_max_strippable() {
  return _max_strip;
} /* query_max_strippable */


/** @ignore yes */
int do_chew() {
  int size;
  
  size = query_amount();
  
  if ( ! size ) {
    add_failed_mess( "You can't chew thin air.\n" );
    return 0;
  }
  
  if ( size > 1 ) {
    add_failed_mess( "You can't chew more than one " + short(0)
      + " at a time.\n" );
    return 0;
  }

  TP->set_position( "idly chewing " + TO->a_short() );
  
  add_succeeded_mess(
    "$N place$s $D between $p teeth, and chew$s it idly.\n" );
  
  return 1;
} /* do_chew */


/** @ignore yes */
int do_strip() {
  int i;
  object stripped;
  
  /* Are they being Silly? */
  if ( query_amount() > query_max_strippable() ) {
    add_failed_mess( "That's far too much $D for you to strip by hand.  "
      "Perhaps you should look for a tool of some kind.\n" );
    return 0;
  }
  
  stripped = STATE_CHANGE->transform( TO, "thresh" );
  if ( ! objectp( stripped ) ) {
    add_failed_mess( "For some reason, you can't strip $D.\n" );
    return 0;
  }
  
  i = stripped->move( TP );
  if ( i != MOVE_OK ) {
    stripped->move( environment( TP ) );
    add_succeeded_mess( "$N strip$s the grain from $D with $p fingers, "
      "spilling some onto the "
      + ( environment( TP )->query_property( "location" ) == "inside" ? "floor"
      : "ground" ) + ".\n" );
  } else {
    add_succeeded_mess( "$N strip$s the grain from $D with $p fingers.\n" );
  }
  
  move( "/room/rubbish" );
  return 1;
} /* do_strip */


mapping query_static_auto_load() {
  return int_query_static_auto_load();
} /* query_static_auto_load */
// --- END [/mnt/home2/grok/lib/obj/plants/inherit/grain.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/gatherables/handler.dat_dc.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/gatherables/handler.dat_dc.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628093   Available: 13575447
Inodes: Total: 5242880    Free: 4960134
12022 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/gatherables/handler.dat_dc.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628093   Available: 13575447
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
class item_data {
    string skill;
    int    difficulty;
    string *season;
    mixed  quant;
    string ob;
}
void dest_me() { destruct( this_object() ); }

class item_data item;
mapping data = ([ ]);

mixed data_return_0() {
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/floppy_madman.ob";
  data["floppy madman"] = item;
  item = new( class item_data );
  item->skill = "";
  item->difficulty = 0;
  item->season = ({ "spring", "summer" });
  item->quant = (: random(4) + 5 :);
  item->ob = "/obj/plants/pink_clover.ob";
  data["pink clover"] = item;
  item = new( class item_data );
  item->season = ({ "spring" });
  item->quant = (: random(2) + 3 :);
  item->ob = "/std/plant";
  data["white clover"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn" });
  item->quant = (: random(6) + 20 :);
  item->ob = "/obj/plants/grass.ob";
  data["green grass"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/yarrow.ob";
  data["yarrow"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/comfrey.ob";
  data["comfrey"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/sage.ob";
  data["sage"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/parsley.ob";
  data["parsley"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/basil.ob";
  data["basil"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/rosemary.ob";
  data["rosemary"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/eyebright.ob";
  data["eyebright"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: 15 + random( 15 ) :);
  item->ob = "/obj/plants/fennel_seed.ob";
  data["fennel seeds"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: 15 + random( 15 ) :);
  item->ob = "/obj/plants/oregano.ob";
  data["oregano"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(4) + 2 :);
  item->ob = "/obj/plants/ivy_seed.ob";
  data["ivy seeds"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = 1;
  item->ob = "/obj/plants/thyme.ob";
  data["thyme"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = 1;
  item->ob = "/obj/plants/foxglove.ob";
  data["foxglove"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random( 3 ) + 3 :);
  item->ob = "/obj/plants/violet.ob";
  data["violets"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/stinking_mayweed.ob";
  data["stinking mayweed"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/klatchian_fleabane.ob";
  data["Klatchian fleabane"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = 1;
  item->ob = "/obj/plants/wild_garlic.ob";
  data["wild garlic"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = 1;
  item->ob = "/obj/plants/convolvus.ob";
  data["convolvus"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(1)+3 :);
  item->ob = "/obj/food/fruits/golden_disagreeable.food";
  data["Golden Disagreeable apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(1)+2 :);
  item->ob = "/obj/food/fruits/blackheart_apple.food";
  data["Lancre Blackheart apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = 1;
  item->ob = "/obj/food/fruits/green_billet.food";
  data["Green Billet apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(1)+1 :);
  item->ob = "/obj/food/fruits/peachface_apple.food";
  data["Blackglass Peachface apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(1)+1 :);
  item->ob = "/obj/food/fruits/gammer_smith.food";
  data["Gammer Smith apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(1)+2 :);
  item->ob = "/obj/food/fruits/ogg_apple.food";
  data["Gytha Ogg apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = 1;
  item->ob = "/obj/food/vegetables/cabbage.food";
  data["cabbage"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = 1;
  item->ob = "/obj/food/vegetables/dirty_potato.food";
  data["potato"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = 1;
  item->ob = "/obj/food/vegetables/tomato.food";
  data["tomato"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = 1;
  item->ob = "/obj/food/vegetables/small_radish.food";
  data["small radish"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = 1;
  item->ob = "/obj/food/vegetables/celery.food";
  data["celery"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = 1;
  item->ob = "/obj/food/vegetables/carrot.food";
  data["carrot"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = 1;
  item->ob = "/obj/food/vegetables/small_onion.food";
  data["small onion"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = 1;
  item->ob = "/obj/food/vegetables/lettuce.food";
  data["lettuce"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = 1;
  item->ob = "/obj/food/vegetables/rhubarb.food";
  data["rhubarb"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = 1;
  item->ob = "/obj/food/vegetables/parsnip.food";
  data["parsnip"] = item;
  item = new( class item_data );
  item->skill = "crafts.hunting.foraging";
  item->difficulty = 100;
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random( 3 ) + 3 :);
  item->ob = "/obj/plants/foxglove.ob";
  data["foxglove"] = item;
  item = new( class item_data );
  item->skill = "crafts.hunting.foraging";
  item->difficulty = 100;
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random( 3 ) + 3 :);
  item->ob = "/obj/plants/bryony.ob";
  data["bryony"] = item;
  item = new( class item_data );
  item->skill = "crafts.hunting.foraging";
  item->difficulty = 100;
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random( 3 ) + 3 :);
  item->ob = "/obj/plants/wormwood.ob";
  data["wormwood"] = item;
  item = new( class item_data );
  item->skill = "crafts.hunting.foraging";
  item->difficulty = 100;
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random( 3 ) + 3 :);
  item->ob = "/obj/plants/monkshood.ob";
  data["monkshood"] = item;
  item = new( class item_data );
  item->skill = "crafts.hunting.foraging";
  item->difficulty = 100;
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random( 3 ) + 3 :);
  item->ob = "/obj/plants/hemlock.ob";
  data["hemlock"] = item;
  item = new( class item_data );
  item->skill = "crafts.hunting.foraging";
  item->difficulty = 100;
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random( 3 ) + 3 :);
  item->ob = "/obj/plants/belladonna.ob";
  data["belladonna"] = item;
  item = new( class item_data );
  item->skill = "crafts.hunting.foraging";
  item->difficulty = 100;
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random( 3 ) + 3 :);
  item->ob = "/obj/plants/hellebore.ob";
  data["hellebore"] = item;
  item = new( class item_data );
  item->skill = "crafts.hunting.foraging";
  item->difficulty = 100;
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random( 3 ) + 3 :);
  item->ob = "/obj/plants/cereus.ob";
  data["cereus"] = item;
  item = new( class item_data );
  item->skill = "crafts.hunting.foraging";
  item->difficulty = 100;
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random( 3 ) + 3 :);
  item->ob = "/obj/plants/clematis.ob";
  data["clematis"] = item;
  item = new( class item_data );
  item->skill = "crafts.hunting.foraging";
  item->difficulty = 100;
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random( 3 ) + 3 :);
  item->ob = "/obj/plants/skullcap.ob";
  data["skullcap"] = item;
  item = new( class item_data );
  item->skill = "crafts.hunting.foraging";
  item->difficulty = 100;
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random( 3 ) + 3 :);
  item->ob = "/obj/plants/angels_trumpet.ob";
  data["angel's trumpet"] = item;
  item = new( class item_data );
  item->skill = "crafts.hunting.foraging";
  item->difficulty = 120;
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random( 3 ) + 3 :);
  item->ob = "/obj/plants/achorion.ob";
  data["achorion mould"] = item;
  item = new( class item_data );
  item->skill = "crafts.hunting.foraging";
  item->difficulty = 100;
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random( 3 ) + 3 :);
  item->ob = "/obj/plants/tyler_weed.ob";
  data["tyler weed"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/wheat.ob";
  data["wheat"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = 1;
  item->ob = "/obj/food/spices/m_garlic.food";
  data["garlic"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random( 3 ) + 3 :);
  item->ob = "/obj/plants/delphinium.ob";
  data["delphinium"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = 1;
  item->ob = "/obj/food/fruits/jelly_orange.food";
  data["jelly orange"] = item;
}

mixed data_return() {
  data_return_0();
  return data;
}
// --- END [/mnt/home2/grok/lib/obj/gatherables/handler.dat_dc.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/gatherables/handler.dat_old.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/gatherables/handler.dat_old.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628090   Available: 13575444
Inodes: Total: 5242880    Free: 4960134
26187 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/gatherables/handler.dat_old.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628090   Available: 13575444
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
class item_data {
    string skill;
    int    difficulty;
    int    upper;
    mixed  extra;
    string *season;
    mixed  quant;
    string ob;
}
void dest_me() { destruct( this_object() ); }
mixed data_return() {
  class item_data item;
  mapping data = ([ ]);

  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/floppy_madman.ob";
  data["floppy madman"] = item;
  item = new( class item_data );
  item->skill = "";
  item->difficulty = 0;
  item->upper = 0;
  item->extra = 0;
  item->season = ({ "spring", "summer" });
  item->quant = (: random(4) + 5 :);
  item->ob = "/obj/plants/pink_clover.ob";
  data["pink clover"] = item;
  item = new( class item_data );
  item->season = ({ "spring" });
  item->quant = (: random(2) + 3 :);
  item->ob = "/std/plant";
  data["white clover"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn" });
  item->quant = (: random(6) + 20 :);
  item->ob = "/obj/plants/grass.ob";
  data["green grass"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/yarrow.ob";
  data["yarrow"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/comfrey.ob";
  data["comfrey"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = 1;
  item->ob = "/obj/plants/ivy_seed.ob";
  data["ivy seeds"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/stinking_mayweed.ob";
  data["stinking mayweed"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/klatchian_fleabane.ob";
  data["Klatchian fleabane"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/wild_garlic.ob";
  data["wild garlic"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(1)+3 :);
  item->ob = "/d/ram/Lancre_Kingdom/Blackglass/apples/golden_disagreeable.food";
  data["Golden Disagreeable apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(1)+2 :);
  item->ob = "/d/ram/Lancre_Kingdom/Blackglass/apples/blackheart_apple.food";
  data["Lancre Blackheart apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = 1;
  item->ob = "/d/ram/Lancre_Kingdom/Blackglass/apples/green_billet.food";
  data["Green Billet apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(1)+1 :);
  item->ob = "/d/ram/Lancre_Kingdom/Blackglass/apples/peachface_apple.food";
  data["Blackglass Peachface apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(1)+1 :);
  item->ob = "/d/ram/Lancre_Kingdom/Blackglass/apples/gammer_smith.food";
  data["Gammer Smith apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = 1;
  item->ob = "/obj/food/cabbage.food";
  data["cabbage"] = item;
  return data;
}
class item_data {
    string skill;
    int    difficulty;
    int    upper;
    mixed  extra;
    string *season;
    mixed  quant;
    string ob;
}
void dest_me() { destruct( this_object() ); }
mixed data_return() {
  class item_data item;
  mapping data = ([ ]);

  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/floppy_madman.ob";
  data["floppy madman"] = item;
  item = new( class item_data );
  item->skill = "";
  item->difficulty = 0;
  item->upper = 0;
  item->extra = 0;
  item->season = ({ "spring", "summer" });
  item->quant = (: random(4) + 5 :);
  item->ob = "/obj/plants/pink_clover.ob";
  data["pink clover"] = item;
  item = new( class item_data );
  item->season = ({ "spring" });
  item->quant = (: random(2) + 3 :);
  item->ob = "/std/plant";
  data["white clover"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn" });
  item->quant = (: random(6) + 20 :);
  item->ob = "/obj/plants/grass.ob";
  data["green grass"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/yarrow.ob";
  data["yarrow"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/comfrey.ob";
  data["comfrey"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = 1;
  item->ob = "/obj/plants/ivy_seed.ob";
  data["ivy seeds"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/stinking_mayweed.ob";
  data["stinking mayweed"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/klatchian_fleabane.ob";
  data["Klatchian fleabane"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/wild_garlic.ob";
  data["wild garlic"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(1)+3 :);
  item->ob = "/d/ram/Lancre_Kingdom/Blackglass/apples/golden_disagreeable.food";
  data["Golden Disagreeable apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(1)+2 :);
  item->ob = "/d/ram/Lancre_Kingdom/Blackglass/apples/blackheart_apple.food";
  data["Lancre Blackheart apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = 1;
  item->ob = "/d/ram/Lancre_Kingdom/Blackglass/apples/green_billet.food";
  data["Green Billet apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(1)+1 :);
  item->ob = "/d/ram/Lancre_Kingdom/Blackglass/apples/peachface_apple.food";
  data["Blackglass Peachface apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(1)+1 :);
  item->ob = "/d/ram/Lancre_Kingdom/Blackglass/apples/gammer_smith.food";
  data["Gammer Smith apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = 1;
  item->ob = "/obj/food/cabbage.food";
  data["cabbage"] = item;
  return data;
}
class item_data {
    string skill;
    int    difficulty;
    int    upper;
    mixed  extra;
    string *season;
    mixed  quant;
    string ob;
}
void dest_me() { destruct( this_object() ); }
mixed data_return() {
  class item_data item;
  mapping data = ([ ]);

  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/floppy_madman.ob";
  data["floppy madman"] = item;
  item = new( class item_data );
  item->skill = "";
  item->difficulty = 0;
  item->upper = 0;
  item->extra = 0;
  item->season = ({ "spring", "summer" });
  item->quant = (: random(4) + 5 :);
  item->ob = "/obj/plants/pink_clover.ob";
  data["pink clover"] = item;
  item = new( class item_data );
  item->season = ({ "spring" });
  item->quant = (: random(2) + 3 :);
  item->ob = "/std/plant";
  data["white clover"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn" });
  item->quant = (: random(6) + 20 :);
  item->ob = "/obj/plants/grass.ob";
  data["green grass"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/yarrow.ob";
  data["yarrow"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/comfrey.ob";
  data["comfrey"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = 1;
  item->ob = "/obj/plants/ivy_seed.ob";
  data["ivy seeds"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/stinking_mayweed.ob";
  data["stinking mayweed"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/klatchian_fleabane.ob";
  data["Klatchian fleabane"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/wild_garlic.ob";
  data["wild garlic"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(1)+3 :);
  item->ob = "/d/ram/Lancre_Kingdom/Blackglass/apples/golden_disagreeable.food";
  data["Golden Disagreeable apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(1)+2 :);
  item->ob = "/d/ram/Lancre_Kingdom/Blackglass/apples/blackheart_apple.food";
  data["Lancre Blackheart apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = 1;
  item->ob = "/d/ram/Lancre_Kingdom/Blackglass/apples/green_billet.food";
  data["Green Billet apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(1)+1 :);
  item->ob = "/d/ram/Lancre_Kingdom/Blackglass/apples/peachface_apple.food";
  data["Blackglass Peachface apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(1)+1 :);
  item->ob = "/d/ram/Lancre_Kingdom/Blackglass/apples/gammer_smith.food";
  data["Gammer Smith apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = 1;
  item->ob = "/obj/food/cabbage.food";
  data["cabbage"] = item;
  return data;
}
class item_data {
    string skill;
    int    difficulty;
    int    upper;
    mixed  extra;
    string *season;
    mixed  quant;
    string ob;
}
void dest_me() { destruct( this_object() ); }
mixed data_return() {
  class item_data item;
  mapping data = ([ ]);

  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/floppy_madman.ob";
  data["floppy madman"] = item;
  item = new( class item_data );
  item->skill = "";
  item->difficulty = 0;
  item->upper = 0;
  item->extra = 0;
  item->season = ({ "spring", "summer" });
  item->quant = (: random(4) + 5 :);
  item->ob = "/obj/plants/pink_clover.ob";
  data["pink clover"] = item;
  item = new( class item_data );
  item->season = ({ "spring" });
  item->quant = (: random(2) + 3 :);
  item->ob = "/std/plant";
  data["white clover"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn" });
  item->quant = (: random(6) + 20 :);
  item->ob = "/obj/plants/grass.ob";
  data["green grass"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/yarrow.ob";
  data["yarrow"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/comfrey.ob";
  data["comfrey"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = 1;
  item->ob = "/obj/plants/ivy_seed.ob";
  data["ivy seeds"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/stinking_mayweed.ob";
  data["stinking mayweed"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/klatchian_fleabane.ob";
  data["Klatchian fleabane"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/wild_garlic.ob";
  data["wild garlic"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(1)+3 :);
  item->ob = "/d/ram/Lancre_Kingdom/Blackglass/apples/golden_disagreeable.food";
  data["Golden Disagreeable apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(1)+2 :);
  item->ob = "/d/ram/Lancre_Kingdom/Blackglass/apples/blackheart_apple.food";
  data["Lancre Blackheart apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = 1;
  item->ob = "/d/ram/Lancre_Kingdom/Blackglass/apples/green_billet.food";
  data["Green Billet apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(1)+1 :);
  item->ob = "/d/ram/Lancre_Kingdom/Blackglass/apples/peachface_apple.food";
  data["Blackglass Peachface apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(1)+1 :);
  item->ob = "/d/ram/Lancre_Kingdom/Blackglass/apples/gammer_smith.food";
  data["Gammer Smith apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = 1;
  item->ob = "/obj/food/cabbage.food";
  data["cabbage"] = item;
  return data;
}
class item_data {
    string skill;
    int    difficulty;
    int    upper;
    mixed  extra;
    string *season;
    mixed  quant;
    string ob;
}
void dest_me() { destruct( this_object() ); }
mixed data_return() {
  class item_data item;
  mapping data = ([ ]);

  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/floppy_madman.ob";
  data["floppy madman"] = item;
  item = new( class item_data );
  item->skill = "";
  item->difficulty = 0;
  item->upper = 0;
  item->extra = 0;
  item->season = ({ "spring", "summer" });
  item->quant = (: random(4) + 5 :);
  item->ob = "/obj/plants/pink_clover.ob";
  data["pink clover"] = item;
  item = new( class item_data );
  item->season = ({ "spring" });
  item->quant = (: random(2) + 3 :);
  item->ob = "/std/plant";
  data["white clover"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn" });
  item->quant = (: random(6) + 20 :);
  item->ob = "/obj/plants/grass.ob";
  data["green grass"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/yarrow.ob";
  data["yarrow"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/comfrey.ob";
  data["comfrey"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = 1;
  item->ob = "/obj/plants/ivy_seed.ob";
  data["ivy seeds"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/stinking_mayweed.ob";
  data["stinking mayweed"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/klatchian_fleabane.ob";
  data["Klatchian fleabane"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/wild_garlic.ob";
  data["wild garlic"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(1)+3 :);
  item->ob = "/d/ram/Lancre_Kingdom/Blackglass/apples/golden_disagreeable.food";
  data["Golden Disagreeable apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(1)+2 :);
  item->ob = "/d/ram/Lancre_Kingdom/Blackglass/apples/blackheart_apple.food";
  data["Lancre Blackheart apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = 1;
  item->ob = "/d/ram/Lancre_Kingdom/Blackglass/apples/green_billet.food";
  data["Green Billet apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(1)+1 :);
  item->ob = "/d/ram/Lancre_Kingdom/Blackglass/apples/peachface_apple.food";
  data["Blackglass Peachface apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(1)+1 :);
  item->ob = "/d/ram/Lancre_Kingdom/Blackglass/apples/gammer_smith.food";
  data["Gammer Smith apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = 1;
  item->ob = "/obj/food/cabbage.food";
  data["cabbage"] = item;
  return data;
}
class item_data {
    string skill;
    int    difficulty;
    int    upper;
    mixed  extra;
    string *season;
    mixed  quant;
    string ob;
}
void dest_me() { destruct( this_object() ); }
mixed data_return() {
  class item_data item;
  mapping data = ([ ]);

  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/floppy_madman.ob";
  data["floppy madman"] = item;
  item = new( class item_data );
  item->skill = "";
  item->difficulty = 0;
  item->upper = 0;
  item->extra = 0;
  item->season = ({ "spring", "summer" });
  item->quant = (: random(4) + 5 :);
  item->ob = "/obj/plants/pink_clover.ob";
  data["pink clover"] = item;
  item = new( class item_data );
  item->season = ({ "spring" });
  item->quant = (: random(2) + 3 :);
  item->ob = "/std/plant";
  data["white clover"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn" });
  item->quant = (: random(6) + 20 :);
  item->ob = "/obj/plants/grass.ob";
  data["green grass"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/yarrow.ob";
  data["yarrow"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/comfrey.ob";
  data["comfrey"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = 1;
  item->ob = "/obj/plants/ivy_seed.ob";
  data["ivy seeds"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/stinking_mayweed.ob";
  data["stinking mayweed"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/klatchian_fleabane.ob";
  data["Klatchian fleabane"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/wild_garlic.ob";
  data["wild garlic"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(1)+3 :);
  item->ob = "/d/ram/Lancre_Kingdom/Blackglass/apples/golden_disagreeable.food";
  data["Golden Disagreeable apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(1)+2 :);
  item->ob = "/d/ram/Lancre_Kingdom/Blackglass/apples/blackheart_apple.food";
  data["Lancre Blackheart apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = 1;
  item->ob = "/d/ram/Lancre_Kingdom/Blackglass/apples/green_billet.food";
  data["Green Billet apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(1)+1 :);
  item->ob = "/d/ram/Lancre_Kingdom/Blackglass/apples/peachface_apple.food";
  data["Blackglass Peachface apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(1)+1 :);
  item->ob = "/d/ram/Lancre_Kingdom/Blackglass/apples/gammer_smith.food";
  data["Gammer Smith apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = 1;
  item->ob = "/obj/food/cabbage.food";
  data["cabbage"] = item;
  return data;
}
class item_data {
    string skill;
    int    difficulty;
    int    upper;
    mixed  extra;
    string *season;
    mixed  quant;
    string ob;
}
void dest_me() { destruct( this_object() ); }
mixed data_return() {
  class item_data item;
  mapping data = ([ ]);

  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/floppy_madman.ob";
  data["floppy madman"] = item;
  item = new( class item_data );
  item->skill = "";
  item->difficulty = 0;
  item->upper = 0;
  item->extra = 0;
  item->season = ({ "spring", "summer" });
  item->quant = (: random(4) + 5 :);
  item->ob = "/obj/plants/pink_clover.ob";
  data["pink clover"] = item;
  item = new( class item_data );
  item->season = ({ "spring" });
  item->quant = (: random(2) + 3 :);
  item->ob = "/std/plant";
  data["white clover"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn" });
  item->quant = (: random(6) + 20 :);
  item->ob = "/obj/plants/grass.ob";
  data["green grass"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/yarrow.ob";
  data["yarrow"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/comfrey.ob";
  data["comfrey"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = 1;
  item->ob = "/obj/plants/ivy_seed.ob";
  data["ivy seeds"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/stinking_mayweed.ob";
  data["stinking mayweed"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/klatchian_fleabane.ob";
  data["Klatchian fleabane"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/wild_garlic.ob";
  data["wild garlic"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(1)+3 :);
  item->ob = "/d/ram/Lancre_Kingdom/Blackglass/apples/golden_disagreeable.food";
  data["Golden Disagreeable apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(1)+2 :);
  item->ob = "/d/ram/Lancre_Kingdom/Blackglass/apples/blackheart_apple.food";
  data["Lancre Blackheart apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = 1;
  item->ob = "/d/ram/Lancre_Kingdom/Blackglass/apples/green_billet.food";
  data["Green Billet apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(1)+1 :);
  item->ob = "/d/ram/Lancre_Kingdom/Blackglass/apples/peachface_apple.food";
  data["Blackglass Peachface apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(1)+1 :);
  item->ob = "/d/ram/Lancre_Kingdom/Blackglass/apples/gammer_smith.food";
  data["Gammer Smith apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = 1;
  item->ob = "/obj/food/cabbage.food";
  data["cabbage"] = item;
  return data;
}
// --- END [/mnt/home2/grok/lib/obj/gatherables/handler.dat_old.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/gatherables/rock.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/gatherables/rock.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628084   Available: 13575438
Inodes: Total: 5242880    Free: 4960134
707 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/gatherables/rock.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628084   Available: 13575438
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: rock.c,v 1.1 1998/08/06 02:20:31 jeremy Exp $
 *
 *
 */

/*
 * rock.c - base hidden object for gathering rocks.
 */

inherit "/obj/gatherable";

void setup() {
    set_name("rock");
    // The short is a problem.  Currently it only shows up if they
    // try to "get" it (I think), which is handled in /obj/gatherable.
    set_short("hidden rock");
    set_long("There are rocks of all shapes and sizes here.  Use "
             "\"gather\" to collect specific types.\n");
    set_get_failure_mess("There are all sorts of rocks and minerals "
                         "around here.  Use \"gather\" to get "
                         "specific varieties.\n");
}
// --- END [/mnt/home2/grok/lib/obj/gatherables/rock.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/gatherables/plant.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/gatherables/plant.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628083   Available: 13575437
Inodes: Total: 5242880    Free: 4960134
712 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/gatherables/plant.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628083   Available: 13575437
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: plant.c,v 1.1 1998/08/06 02:20:31 jeremy Exp $
 *
 *
 */

/*
 * plant.c - base hidden object for gathering plants.
 */

inherit "/obj/gatherable";

void setup() {
    set_name("plant");
    // The short is a problem.  Currently it only shows up if they
    // try to "get" it (I think), which is handled in /obj/gatherable.
    set_short("hidden plant");
    set_long("There are all sorts of herbs and flowers here.  Use "
             "\"gather\" to collect specific types.\n");
    set_get_failure_mess("There are all sorts of flowers and herbs "
                         "around here.  Use \"gather\" to get "
                         "specific varieties.\n");
}
// --- END [/mnt/home2/grok/lib/obj/gatherables/plant.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/staff.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/staff.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628083   Available: 13575437
Inodes: Total: 5242880    Free: 4960134
3263 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/staff.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628083   Available: 13575437
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: staff.c,v 1.4 1999/05/13 20:57:18 rywfol Exp $
 * 
*/
#include <artifacts.h>
#include <tasks.h>

inherit "/obj/weapon";
inherit "/std/basic/artifact";

int query_magic_staff() { return 1; }

void create() {
  weapon::create();
  set_artifact_type( "staff" );
  set_no_limbs( 2 );
} /* create() */

void set_weight( int number ) {
  weapon::set_weight( number );
  new_weapon( 80 * number );
    add_attack( "thwack", 50, ({ weight / 3, 4, weight }), "blunt",
         "blunt", 0 );
    add_attack( "prod", 50, ({ weight / 2, 4, weight / 2 }), "blunt",
         "blunt", 0 );
} /* set_weight() */

string long( int word, int dark ) {
  return artifact::long( word, dark ) + weapon::long( word, dark );
} /* long() */

void init() {
  this_player()->add_command( "invoke", this_object() );
} /* init() */

int do_invoke() {
  int outcome;
  if ( query_wielded() != this_player() ) {
    this_player()->add_failed_mess( this_object(), "You must be holding "+
        "$D to $V it.\n", ({ }) );
    return 0;
  }

  outcome = (int)TASKER->perform_task(this_player(), STAFF_SKILL, level,
                                      TM_FREE);
  if ( outcome == FAIL ) {
    this_player()->add_failed_mess( this_object(), "You failed "+
        "to $V $D.\n", ({ }) );
    return 0;
  }
  if ( !charges ) {
    this_player()->add_failed_mess( this_object(), "It appears that there "+
        "are no charges in $D.\n", ({ }) );
    return 0;
  }
  if ( outcome == AWARD ) {
    write("%^YELLOW%^"+
          ({ "A piece of lore concerning staves becomes clearer for "+
             "you.\n", "You manage to grasp one of the principles of magic "+
             "staves more firmly.\n", "A sudden flash of insight allows you "+
             "to understand the staff a little better.\n" })[ random( 3 ) ] +
          "%^RESET%^");
    
  }
  charges--;
  if ( random( 100 ) < level / 10 ) {
    if ( !zapper->failed_zap( environment( this_player() ), this_player(),
        this_object() ) )
      this_player()->add_succeeded_mess( this_object(), "$N $V $D but "+
          "nothing happens!\n", ({ }) );
    return 1;
  }
  zapper->zap( environment( this_player() ), this_player(), this_object() );
  return 1;
} /* do_zap() */

mixed *stats() {
  return weapon::stats() + artifact::stats();
} /* stats() */

mapping query_dynamic_auto_load() {
  return ([
    "::" : weapon::query_dynamic_auto_load(),
    "artifact" : artifact::query_dynamic_auto_load(),
  ]);
} /* query_dynamic_auto_load() */

mapping query_static_auto_load() {
   if ( explode( file_name( this_object() ), "#" )[ 0 ] != "/obj/staff" )
      return ([ ]);
  return ([
    "::" : int_query_static_auto_load(),
    "artifact" : artifact::query_static_auto_load(),
  ]);
} /* query_static_auto_load() */

void init_dynamic_arg( mapping map ) {
  if ( map[ "::" ] )
    weapon::init_dynamic_arg( map[ "::" ] );
  if ( map[ "artifact" ] )
    artifact::init_dynamic_arg( map[ "artifact" ] );
} /* init_dynamic_arg() */

void init_static_arg( mapping map ) {
   if ( !mapp( map ) )
      return;
  if ( map[ "::" ] )
    weapon::init_static_arg( map[ "::" ] );
  if ( map[ "artifact" ] )
    artifact::init_static_arg( map[ "artifact" ] );
} /* init_static_arg() */
// --- END [/mnt/home2/grok/lib/obj/staff.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/wand.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/wand.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628082   Available: 13575436
Inodes: Total: 5242880    Free: 4960134
4569 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/wand.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628082   Available: 13575436
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: wand.c,v 1.6 2001/11/10 04:26:30 tannah Exp $
 * $Log: wand.c,v $
 * Revision 1.6  2001/11/10 04:26:30  tannah
 * Aquilo's new version wot deals with collective targets.
 *
 * Revision 1.5  2001/07/31 21:33:18  pinkfish
 * Add in some autodocs.
 *
 * Revision 1.4  2001/03/17 14:54:38  taffyd
 * Fixed add_command() patterns.
 *
 * Revision 1.3  1999/10/28 02:23:13  ceres
 * Can't remember
 *
 * Revision 1.1  1998/01/06 04:58:17  ceres
 * Initial revision
 * 
*/
/**
 * A magic wand object for use with all magic wands.
 */
#include <artifacts.h>
#include <tasks.h>

inherit "/obj/weapon";
inherit "/std/basic/artifact";

/**
 * This method will return true for all magic wands.
 * @return 1 for all wands
 */
int query_magic_wand() { return 1; }

void create() {
  weapon::create();
  set_artifact_type( "wand" );
} /* create() */

/** @ignore yes */
void set_weight( int number ) {
  weapon::set_weight( number );
  new_weapon( 80 * number );
   add_attack( "prod", 90, ({ 0, 5, weight }), "blunt", "blunt", 0 );
} /* set_weight() */

/** @ignore yes */
string long( int word, int dark ) {
  return artifact::long( word, dark ) + weapon::long( word, dark );
} /* long() */

void init() {
  this_player()->add_command( "zap", this_object(), "<direct:object> at <indirect:object>" );
  this_player()->add_command( "zap", this_object(), "<indirect:object> with <direct:object>" );
} /* init() */

/** @ignore yes */
int do_zap( object *things ) {
  int outcome;
  if ( query_wielded() != this_player() ) {
    this_player()->add_failed_mess( this_object(), "You must be holding "+
        "$D to $V it.\n", ({ }) );
    return 0;
  }
  if( ( sizeof( things ) > 1 ) || 
      ( sizeof( filter( things, (: $1->query_amount() > 1 :)) ) )
    ){
    this_player()->add_failed_mess( this_object(), "You can only zap $D "+
        "at one object at a time.\n", ({ }) );
    return 0;
  }
  if ( things[ 0 ] == this_object() ) {
    this_player()->add_failed_mess( this_object(), "You cannot zap $D at "+
        "itself!\n", ({ }) );
    return 0;
  }
/*
 * Knowing how to aim and fire the wand depends on the player's
 *     knowledge (rather than how well they can apply it), so the
 *     skill level determines ability to use it (rather than skill
 *     bonus).
 */
  outcome = (int)TASKER->perform_task(this_player(), WAND_SKILL, level,
                                      TM_FREE);
  if ( outcome == FAIL ) {
    this_player()->add_failed_mess( this_object(), "You failed "+
        "to $V $D.\n", ({ }) );
    return 0;
  }
  if ( !charges ) {
    this_player()->add_failed_mess( this_object(), "It appears that there "+
        "are no charges in $D.\n", ({ }) );
    return 0;
  }
   if ( outcome == AWARD ) {
      write( "%^YELLOW%^"+ ({ "A piece of lore concerning wands becomes "
            "clearer for you", "You manage to grasp one of the principles "
            "of magic wands more firmly", "A sudden flash of insight allows "
            "you to understand the wand a little better" })[ random( 3 ) ] +
            ".%^RESET%^\n" );
      
   }
  charges--;
  if ( random( 100 ) < level / 10 ) {
    if ( !zapper->failed_zap( things[ 0 ], this_player(), this_object() ) )
      this_player()->add_succeeded_mess( this_object(), "$N $V $D at $I but "+
          "nothing happens!\n", things );
    return 1;
  }
  zapper->zap( things[ 0 ], this_player(), this_object() );
  this_player()->add_succeeded( things[ 0 ] );
  return 1;
} /* do_zap() */

/** @ignore yes */
mixed *stats() {
  return weapon::stats() + artifact::stats();
} /* stats() */

/** @ignore yes */
mapping query_dynamic_auto_load() {
  return ([
    "::" : weapon::query_dynamic_auto_load(),
    "artifact" : artifact::query_dynamic_auto_load(),
  ]);
} /* query_dynamic_auto_load() */

/** @ignore yes */
mapping query_static_auto_load() {
  if ( explode( file_name( this_object() ), "#" )[ 0 ] != "/obj/wand" )
    return ([ ]);
  return ([
    "::" : int_query_static_auto_load(),
    "artifact" : artifact::query_static_auto_load(),
  ]);
} /* query_static_auto_load() */

/** @ignore yes */
void init_dynamic_arg( mapping map ) {
  if ( map[ "::" ] )
    weapon::init_dynamic_arg( map[ "::" ] );
  if ( map[ "artifact" ] )
    artifact::init_dynamic_arg( map[ "artifact" ] );
} /* init_dynamic_arg() */

/** @ignore yes */
void init_static_arg( mapping map ) {
  if ( map[ "::" ] )
    weapon::init_static_arg( map[ "::" ] );
  if ( map[ "artifact" ] )
    artifact::init_static_arg( map[ "artifact" ] );
} /* init_static_arg() */
// --- END [/mnt/home2/grok/lib/obj/wand.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/clothing_transport.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/clothing_transport.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628081   Available: 13575435
Inodes: Total: 5242880    Free: 4960134
3429 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/clothing_transport.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628081   Available: 13575435
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:56.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: clothing_transport.c,v 1.1 2000/07/14 22:08:51 pinkfish Exp $
 * $Log: clothing_transport.c,v $
 * Revision 1.1  2000/07/14 22:08:51  pinkfish
 * Initial revision
 *
 * Revision 1.8  1999/11/02 20:04:30  pinkfish
 * Fix up the formatting a little.
 *
 * Revision 1.7  1999/10/25 12:45:16  dragonkin
 * Can't remember...
 *
 * Revision 1.6  1999/05/07 01:44:43  dragonkin
 * Added cloner support
 *
 * Revision 1.5  1999/05/06 17:32:55  dragonkin
 * Added support for the virtuals handler
 *
 * Revision 1.4  1998/05/14 18:22:55  pinkfish
 * Fix up the static arg stuff.
 *
 * Revision 1.3  1998/03/12 08:06:57  pinkfish
 * Added documentation.
 *
 * Revision 1.2  1998/02/27 04:56:32  pinkfish
 * CHanged to stop people being able to pick up
 * pigns and stuff and put them into
 * containers.
 *
 * Revision 1.1  1998/01/06 04:58:17  ceres
 * Initial revision
 * 
*/
/**
 * This is the clothing file for transports.
 * @author Pinkfish
 * @started Wed Nov 17 00:39:37 PST 1999
 * @see /std/npc/types/transport.c
 */
inherit "/obj/clothing";

private int _mount_difficulty_modifier;
private int _direction_difficulty_modifier;
private string _race;

void create() {
   clothing::create();
} /* create() */

/**
 * This method sets the race the clothing is for.
 * @param race the race that the clothing is for
 * @return the race the clothing is for
 */
void set_worn_by_race(string race) {
   _race = race;
} /* set_worn_by_race() */

/**
 * This method queries the race the clothing is for.
 * @return the race the clothing is for
 */
string query_worn_by_race() {
   return _race;
} /* query_worn_by_race() */

/**
 * This method set the mount difficulty modifier.
 * @param diff the mount difficulty modifier
 */
void set_mount_difficulty_modifier(int diff) {
   _mount_difficulty_modifier = diff;
} /* set_moun_difficult_modifier() */

/**
 * This method queries the mount difficulty modifier.
 * @return the mount difficulty modifier
 */
int query_mount_difficulty_modifier() {
   return _mount_difficulty_modifier;
} /* query_mount_difficulty_modifier() */

/**
 * This method sets the direction difficulty modifier.
 * @param diff the direction difficulty modifier
 */
void set_direction_difficulty_modifier(int diff) {
   _direction_difficulty_modifier = diff;
} /* set_direction_difficulty_modifier() */

/**
 * This method queries the direction difficulty modifier.
 * @return the direction difficulty modifier
 */
int query_direction_difficulty_modifier() {
   return _direction_difficulty_modifier;
} /* query_direction_difficulty_modifier() */

/** @ignore yes */
mapping int_query_static_auto_load() {
   return ([
      "::" : clothing::int_query_static_auto_load(),
      "worn by race" : _race,
      "mount difficulty" : _mount_difficulty_modifier,
      "direction difficulty" : _direction_difficulty_modifier
   ]);
} /* query_static_auto_load() */

/** @ignore yes */
mapping query_static_auto_load() {
   if ( base_name(this_object()) != __FILE__[0..<3]) {
      return ([ ]);
   }
   return int_query_static_auto_load();
} /* query_static_auto_load() */

/** @ignore yes */
void init_static_arg(mapping map) {
   if (map["::"]) {
      clothing::init_static_arg(map["::"]);
   }
   _race = map["worn by race"];
   _mount_difficulty_modifier = map["mount difficulty"];
   _direction_difficulty_modifier = map["direction difficulty"];
} /* init_static_arg() */
// --- END [/mnt/home2/grok/lib/obj/clothing_transport.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/vessel.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/vessel.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628080   Available: 13575434
Inodes: Total: 5242880    Free: 4960134
54652 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/vessel.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628080   Available: 13575434
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Id: vessel.c,v 1.65 2003/07/15 07:33:16 pinkfish Exp $
 */
/**
 * This is a container specifically for holding liquids.  The hope is
 * to reduce the memory requirements by taking all of the liquid stuff
 * out of /obj/container, since most of the containers are sacks and
 * chests.  Also, the reaction handler will replace the potion space.
 * <p>
 * Some additional notes:
 * <ol>
 *    <li>As is (hopefully) documented elsewhere, the base units of
 *        volume for most continuous media are drops and pinches, both of
 *        which are roughly 1/4 of a cc.  This means that water has
 *        200 drops per weight unit (1g/cc).  Non-continuous objects
 *        are assumed to be the same density as water.
 * </ol>
 * @@author Jeremy
 */


#define REACTION_HANDLER ("/obj/handlers/reaction")
#define TASTE_AMT 200

#include <tasks.h>
#include <move_failures.h>
#include <volumes.h>

inherit "/obj/baggage";

private int leak_rate;
private int hb_count;
private int sub_query_contents;
private int volume;
private int max_volume;
private int cont_volume;
private int is_liquid;
private nosave int* _fraction;
private nosave object* _liquids;

int drink_amount(int drinking, object player);
private int query_fighting(object player);


/**
 * This method sets the leak rate of the container.  The leak rate is how
 * fast stuff leaks out of the container.
 * @param i the new leak rate of the container
 * @see query_leak_rate() */
void set_leak_rate(int i) { leak_rate = i; }


/**
 * This method returns the leak rate of the container
 * @see set_leak_rate()
 * @return the current leak rate */
int query_leak_rate() { return leak_rate; }


/**
 * This method sets the maximum volume of the container.
 * @param v the new maximum volume
 * @see add_volume()
 * @see query_max_volume() */
void set_max_volume(int v) { max_volume = v; }


/**
 * This method returns the current maxium volume associated with this
 * container.
 * @return the current maximum volume */
int query_max_volume() { return max_volume; }


string *leak_verb = ({ " drips slowly",
                       " drips",
                       " dribbles",
                       " trickles slowly",
                       " trickles",
                       " trickles rapidly",
                       " pours sluggishly",
                       " pours",
                       " streams",
                       " gushes",
                       " fountains"
                     });


string *drink_pat = ({ "[from] <direct:object>",
                       "<fraction> {of|from} <direct:object>"
                   });                   
string *splash_pat = ({ "[from] <direct:object> {on|to|onto} <indirect:living>",
                       "<fraction> {of|from} <direct:object> {on|to|onto} "
                       "<indirect:living>"
                   });                   
string *apply_pat = ({ "[from] <direct:object> {on|to} <indirect:living>",
                       "<fraction> {of|from} <direct:object> {on|to} "
                       "<indirect:living>"
                   });                   
string *pour_pat = ({ "<direct:object> {from|into} <indirect:object>",
                      "<fraction> of <direct:object> {from|into} <indirect:object>"
                  });                  
string *fill_pat = ({ "<indirect:object> <fraction> full {from|into} <direct:object>",
                      "<indirect:object> <fraction> up {from|into} <direct:object>",
                      "<indirect:object> {from|into} <direct:object>"
                  });
                  
                  
void create() {
    do_setup++;
    ::create();
    do_setup--;
    if ( !do_setup ) {
      this_object()->setup();
    }
    add_help_file("vessel");
} /* create() */


/** @ignore yes */
void init() {
    ::init();
    add_command("drink", drink_pat);
    add_command("quaff", drink_pat);
    add_command("splash", splash_pat);
    add_command("rub", apply_pat);
    add_command("apply", apply_pat);
    add_command("pour", pour_pat);
    add_command("taste", "<direct:object>");
    add_command("sip", "<direct:object>");
    //add_command("smell",
    add_command("fill", fill_pat);
    add_command("empty", "<direct:object>");
} /* init() */


/**
 * This returns an adjective for how full the current object is with
 * liquid.  This is used in the parse command handling code.
 * @return the fullness adjective
 * @see query_max_volume() */
string *fullness_adjectives() {
   if (!max_volume) return ({ "totally", "empty" });
   switch (100 * volume / max_volume) {
   case 0..4: return ({ "totally", "empty" });
   case 5..13: return ({ "empty" });
   case 65..94: return ({ "full" });
   case 95..100: return ({ "totally", "full" });
   default: return ({ });
   }
} /* fullness_adjectives() */


/** @ingore yes */
mixed stats() {
  return ::stats() + ({
      ({ "leak_rate", leak_rate }),
      ({ "volume", volume }),
      ({ "cont_volume", cont_volume }),
      ({ "liquid", is_liquid }),
      ({ "max_volume", max_volume })
    });
} /* stats() */


int cmp_amount_r(object a, object b) {
    return ((int)b->query_amount() - (int)a->query_amount());
} /* cmp_amount() */


int cmp_weight_r(object a, object b) {
    if (a->query_weight() || b->query_weight())
      return ((int)b->query_weight() - (int)a->query_weight());
    return cmp_amount_r(a, b);
} /* cmp_weight() */


private void figure_out_liquids() {
   _liquids = filter(all_inventory(this_object()), (: $1->query_liquid() :));
   _liquids = sort_array(_liquids, "cmp_amount_r", this_object());
} /* figure_out_liquids() */


/**
 * This method returns the description of the liquid inside the vessel.
 * @return the current liquids description */
string query_liquid_desc() {
    object *contents, *solids = ({});
    int i;
    string desc, *shorts;
    mixed *others;

    contents = all_inventory(this_object());
    if( !sizeof( contents ) ) {
       return (string) 0;
    }

    figure_out_liquids();
    solids = contents - _liquids;
    if (sizeof(_liquids)) {
       _liquids = sort_array(_liquids, "cmp_amount_r", this_object());
       others = unique_array(_liquids->a_short(),
                          (: "/global/events"->convert_message($1) :));
       shorts = ({ });
       for (i = 0; i < sizeof(others); i++) {
          shorts += ({ others[i][0] });
       }
       desc = shorts[0];
       if (sizeof(shorts) > 1) {
          desc += ", mixed with ";
          if (sizeof(shorts) > 4) {
             desc += "other liquids";
          } else {
             desc += query_multiple_short(shorts[1..]);
          }
       }
    } else {
       desc = "";
    }
    if (!sizeof(solids)) {
        return desc;
    }
    solids = sort_array(solids, "cmp_weight_r", this_object());
    others = unique_array(solids,
                          (: $1->query_continuous()?
                           this_player()->convert_message($1->a_short()) :
                           $1 :) );

    for (i = 0; i < sizeof(others); i++) {
       if( arrayp( others ) ) {
          others[i] = others[i][0];
       } else {
          // Er...  OK, so wtf is it?
          tell_creator( "gruper", "others is %O.\n", others );
       }
    }

    if (sizeof(_liquids)) {
       desc += ", with ";
    }
    if (sizeof(others) > 10) {
        desc += "various undissolved substances";
    } else {
        desc += query_multiple_short(others);
    }
    if (sizeof(_liquids)) {
       desc += " floating in it";
    }
    return desc;
} /* query_liquid_desc() */


/**
 * This method returns the fullness description of the vessel.
 * @return the fullness description of the vessel */
string query_fullness_desc() {
   int full;
   
/* Ok, here comes a terrible kludge, but it's all I can think of 
 * that will fix a buglet without introducing more serious Bugs.
 * It's a hack around continous objects and their volumes.   - Tilly */
   
   full = (100 * volume) / max_volume;
   if( full < 1 && query_liquid_desc() ) {
      full = 1;
   }
   switch (full) {
      case 0:       return "";
      case 1..12:   return "It is almost empty.";
      case 13..37:  return "It is about one-quarter full.";
      case 38..62:  return "It is about half full.";
      case 63..87:  return "It is about three-quarters full.";
      case 88..95:  return "It is almost full.";
      case 96..100: return "It is completely full.";
      default:      return "Its capacity defies the laws of physics.  " 
                           "Please submit a bug report.";
    }
}


/* This is a bit of a kludge, but I need a way to inhibit query_contents()
 * in long() of /obj/baggage.  It may be that I could permanently
 * replace query_contents() with query_liquid_desc(), but I'm not sure... */
/** @ignore yes */
varargs string query_contents(string str, object *obs ) {
    string s, c;

/* This next bit used to check for volume, but to deal with the buglet 
 * mentioned in the previous function, I changed it to check for the 
 * presence of some kind of contents instead.  - Tilly */
    if ( query_liquid_desc() ) {
        c = "\n"+ query_fullness_desc() +"\n";
    } else {
        c = "";
    }

    s = query_liquid_desc();
    if (sub_query_contents) {
        if (s) {
            return str + capitalize(s) + "." + c;
        }
        return ::query_contents(str, obs) + c;
    }
    return ::query_contents(str, obs);
} /* query_contents */

/** @ignore yes */
string short(int dark) {
  object *inv;

  if(query_opaque())
    return ::short(dark);

  inv = all_inventory(this_object());
  if(!sizeof(inv))
    return ::short(dark);

  return ::short(dark) + " of " + 
    "/global/events"->convert_message(query_multiple_short(map(inv, 
    (: $1->query_short() :))));
}

/** @ignore yes */
string long(string str, int dark) {
    string ret;

    sub_query_contents = 1;
    ret = ::long(str, dark);
    sub_query_contents = 0;
    return ret;
} /* long() */

int query_cont_volume() { return cont_volume; }


/**
 * This method returns if this vessel is currenly a liquid.  This means
 * it has a liquid inside it.
 * @see calc_liquid()
 * @return 1 if it is a liquid, 0 if not */
int query_liquid() { return is_liquid; }


/* This method determines if we have any liquids inside us at all. */
void calc_liquid() {
    if (sizeof(filter(all_inventory(), (: $1->query_liquid() :)))) {
      is_liquid = 1;
    } else {
      is_liquid = 0;
    }
}


/**
 * This method returns the current amount of liquid in the container.
 * @return the current amount of liquid in the container */
int query_volume() { return volume; }


/**
 * This method returns the amount of volume left for liquids to be
 * added into.
 * @return the amount of volume left
 * @see add_volume()
 * @see transfer_liquid_to() */
int query_volume_left() {
  if (!query_max_weight()) {
    return max_volume - volume;
  }
  return max_volume - volume - (max_volume*query_loc_weight())/query_max_weight();
} /* query_volume_left() */


/**
 * This method returns the amount of volume left for liquids to be
 * added into.
 * @param vol the amount of volume added
 * @return 1 if the addition was successful, 0 if not
 * @see add_volume() */
int add_volume(int vol) {
   if ((vol <= 0) || !max_volume || (vol + volume <= max_volume)) {
      volume += vol;
      if (previous_object()->query_continuous()) {
          cont_volume += vol;
      }
      return 1;
    }
    // Should spillage be handled here, or in the caller?
    return 0;
} /* add_volume() */


/** @ignore yes */
int add_weight(int n) {
    int v;

    // Debugging.  Can be removed if I forget -- Jeremy
    if (this_player() && (this_player()->query_name() == "pinkfish")) {
      tell_creator("pinkfish", "vessel::add_weight(%O)\n", n);
    }
    if (previous_object()->query_continuous()) {
       return (::add_weight(n));
    }
    //if (!(v = previous_object()->query_amount()))
      v = n*200;
    if (max_volume && (v + volume > max_volume)) {
       return 0;
    }
    if (::add_weight(n)) {
        //printf("Increasing volume by %d (add_weight)\n", v);
        volume += v;
        return 1;
    }
    return 0;
} /* add_weight() */


/**
 * This method removes some volume of liquid from the container.
 * @param vol_lost the amount of volume removed
 * @see add_volume()
 * @see query_volume() */
int remove_volume(int vol_lost)
{
    // Removes equal proportions of all continuous matter.
    int amt_lost, i, orig_cv;
    object *contents;

    if (!cont_volume) {
        return 0;
    }
    orig_cv = cont_volume;
    contents = all_inventory(this_object());
    for (i = 0; i < sizeof(contents); i++) {
        if (contents[i]->query_continuous()) {
            amt_lost = -to_int((int)contents[i]->query_amount()
                               * (to_float(vol_lost) / orig_cv));
            if (!amt_lost) {
                // Always take at least one unit
                amt_lost++;
            }
            contents[i]->adjust_amount(amt_lost);
        }
    }
    return vol_lost;
} /* remove_volume() */


/**
 * This method transfers a given amount of a liquid to a new container.
 * @param dest the destination of the liquid
 * @param vol_xferred the amount of volume transfered */
int xfer_volume(int vol_xferred, object dest) {
    // Transfers equal portions of all continuous matter to dest.
    // If successful, returns 0; if it failed for some reason, it returns
    // the volume not transferred (note that full checks should be done
    // by the caller).
    int vol_to_go;
    int i;
    int amt_xferred;
    int tmp;
    int orig_cv;
    object *contents;
    object copy;
    string file_path;
    mapping map;

    vol_to_go = vol_xferred;
    if (!cont_volume) {
        return 0;
    }
    orig_cv = cont_volume;
    contents = filter(all_inventory(this_object()),
                      (: $1->query_continuous() :));
    for (i = 0; i < sizeof(contents) && vol_to_go > 0; i++) {
        // This should prevent roundoff errors.
        if (i == sizeof(contents) - 1) {
            amt_xferred = vol_to_go;
        } else {
            amt_xferred = to_int((int)contents[i]->query_amount()
                                 * (to_float(vol_xferred) / orig_cv));
        }
        if (!amt_xferred) {
            // Always take at least one unit
            amt_xferred++;
        }
        file_path = explode( file_name(contents[i]), "#" )[ 0 ];
        copy = clone_object(file_path);
        map = (mapping)contents[i]->query_dynamic_auto_load();
        copy->init_dynamic_arg( map );
        map = (mapping)contents[i]->query_static_auto_load();
        if (map) {
            copy->init_static_arg( map );
        }
        copy->set_amount(amt_xferred);
        tmp = copy->move(dest);
        if (tmp == MOVE_OK) {
            // There should probably be enough checks before here to
            // make sure the move succeeds, or an explanation why it
            // didn't.
            vol_to_go -= amt_xferred;
            contents[i]->adjust_amount(-amt_xferred);
        } else {
            copy->dest_me();
        }
    }
    return vol_to_go;
} /* xfer_volume() */


/** @ignore yes */
void heart_beat() {
    // Note that having a leak rate can be expensive, so it should only
    // be done if it's important to the application (such as using it
    // to impose a time restriction).
    int lost, off;

    if (leak_rate == 0 || !is_liquid) {
        set_heart_beat(0);
        return;
    }
    if (hb_count--) return ;
    hb_count = 10;
    lost = leak_rate;
    if (lost > cont_volume)
      lost = cont_volume;
    off = lost/100;
    if (off > 10)
        off = 10;
 // tell_room(environment(),
 //     capitalize(query_liquid_desc())+leak_verb[off]+" out of the "+
 //     short(1)+".\n");
 /* This is hacked because as far as I can tell there is no way to get a 'generic short'
  * for a continuous liquid, ie: some water, instead of two pints of water. */
    if ( interactive( environment() ) )
        tell_object( environment(), "$C$Some " + query_multiple_short( map( all_inventory(),
        (: $1->query_short() :) ) ) + leak_verb[off] + " out of the "+ short(1) + ".\n" );
    else 
      tell_room( environment(), "$C$Some " + query_multiple_short( map( all_inventory(),
        (: $1->query_short() :) ) ) + leak_verb[off] + " out of the "+ short(1) + ".\n" );
  
  (void)remove_volume(lost);
  if (!cont_volume) {
    set_heart_beat(0);
  }
} /*heart_beat() */


/** @ignore yes */
int do_pour(object *to, mixed *args_b, mixed *args_a, mixed *args) {
    int m, n, volume_needed, their_volume, their_max, ovf, xfer_result;

    if (query_fighting(this_player())) {
       add_failed_mess("You cannot attempt to do this while in combat.\n");
       return 0;
    }

    if (environment(this_object()) != this_player()) {
        add_failed_mess("You aren't carrying $D.\n");
        return 0;
    }
    if (sizeof(args) == 5) {
        //m = args[1];
        //n = args[2];
        sscanf(args[0] + " " + args[1], "%d %d", m, n);
        if ((m > n) || (m < 0) || (n <= 0)) {
            add_failed_mess("Interesting fraction you have there!\n");
            return 0;
        }
    } else {
        m = 1;
        n = 1;
    }

    if (query_locked()) {
        add_failed_mess("$C$$D $V$0=is,are$V$ locked!\n");
        return 0;
    }
    if (query_closed()) {
        if (do_open()) {
            write("You open the " + short(0) + ".\n");
        } else {
            add_failed_mess("You cannot open $D.\n");
            return 0;
        }
    }

    if (cont_volume <= 0) {
        add_failed_mess("$C$$D has nothing to pour!\n");
        return 0;
    }

    if (sizeof(to) > 1) {
        add_failed_mess("You can only pour into one object at a time.\n");
        return 0;
    }

    their_volume = (int)to[0]->query_volume();
    their_max = (int)to[0]->query_max_volume();
    if (their_max <= 0) {
        add_failed_mess("$C$" + to[0]->the_short(0) +
            " doesn't look like it can be filled!\n");
        return 0;
    }

    if (their_volume >= their_max) {
        add_failed_mess("The " + to[0]->short(0)
              + " $V$0=is,are$V$ full to the brim already.\n");
        their_volume = their_max;
    }
    if ((m == 1) && (n == 1)) {
        volume_needed = volume;
    } else {
        volume_needed = max_volume * m / n;
    }
    if (volume < volume_needed) {
        add_failed_mess("$C$$D $V$0=is,are$V$ less than " + m + "/" + n +
              " full.\n");
        return 0;
    }
    if (volume_needed > 120) {
        // +/- 1 ounce (could make this skill-dependent...)
        volume_needed += random(240) - 120;
    }
    if (volume_needed > (their_max - their_volume)) {
        volume_needed = their_max - their_volume;
        ovf = 1;
    }

    if (volume_needed > cont_volume) {
        add_failed_mess("You drain the " + short(0) + " into the "
              + to[0]->short(0) + " but it $V$0=is,are$V$ not enough.\n");
        volume_needed = cont_volume;
        this_player()->add_succeeded(to[0]);
    } else {
        this_player()->add_succeeded(to[0]);
    }

    xfer_result = xfer_volume( volume_needed, to[0] );

    //If the result is less then needed, then it worked.
    //If it is exactly the same, then 0 was transferred.
    if (xfer_result < volume_needed) {
        this_player()->add_succeeded_mess(this_object(), "$N $V $D into $I.\n", ({to[0]}));
    }
    else {
        add_failed_mess( "You were unable to $V $D into $I.\n", ({to[0]}));
        return 0;
    }
    if (ovf) {
        this_player()->add_succeeded_mess(this_object(), "$N $V $D into $I, " +
            "spilling some in the process.\n", ({to[0]}));
    }
    return 1;
} /* do_pour() */

/** @ignore yes */
int do_fill(object *to, mixed *args_b, mixed *args_a, mixed *args) {
    int m;
    int n;
    int i;
    int run_out;
    int volume_needed;
    int their_volume;
    int their_max;
    int amount_not_poured;
    int ok;

    if (query_fighting(this_player())) {
       add_failed_mess("You cannot attempt to do this while in combat.\n");
       return 0;
    }

    if (sizeof(args) == 4) {
        //m = args[1];
        //n = args[2];
        sscanf(args[1] + " " + args[2], "%d %d", m, n);
        if ((m > n) || (m < 0) || (n <= 0)) {
            add_failed_mess("Interesting fraction you have there!\n");
            return 0;
        }
    } else {
        m = 1;
        n = 1;
    }

    if (query_closed() &&
        query_locked()) {
        add_failed_mess("$C$$D $V$0=is,are$V$ locked!\n");
        return 0;
    }

    if (query_closed()) {
        if (do_open()) {
            write("You open the " + short(0) + ".\n");
        } else {
            add_failed_mess("You cannot open $D.\n");
            return 0;
        }
    }

    if (cont_volume <= 0) {
        add_failed_mess("$C$$D has nothing to pour!\n");
        return 0;
    }

    run_out = 0;
    for (i = 0; i < sizeof(to) && !run_out; i++) {
        if ((environment(this_object()) != this_player()) &&
            (environment(to[i]) != this_player())) {
            write("You're not carrying " + the_short() + " or " +
                  to[i]->the_short() + ".\n");
            continue;
        }

        if (to[i]->query_closed()) {
            add_failed_mess("$I $V$0=is,are$V$ closed.\n", to[i..i]);
            continue;
        }

        their_volume = (int)to[i]->query_volume();
        their_max = (int)to[i]->query_max_volume();
        if (their_max <= 0) {
            add_failed_mess("$I doesn't look like it can be filled!\n",
                            to[i..i]);
            continue;
        }

        if (their_volume >= their_max) {
            add_failed_mess("$I $V$0=is,are$V$ full to the brim already.\n", to[i..i]);
            continue;
        }

        volume_needed = their_max * m / n;
        if (their_volume >= volume_needed) {
            add_failed_mess("$I $V$0=is,are$V$ more than " + m + "/" + n +
                  " full already.\n", to[i..i]);
            continue;
        }
        if (volume_needed > 120) {
            // +/- 1 ounce (could make this skill-dependent...)
            volume_needed += random(240) - 120;
        }
        if (volume_needed > their_max) {
            volume_needed = their_max;
        }
        ok++;
        volume_needed -= their_volume;

        if (volume_needed > cont_volume) {
            add_failed_mess("You drain " + the_short() + " into "
                  + to[i]->the_short() + " but it $V$0=is,are$V$ not enough.\n");
            volume_needed = cont_volume;
            run_out = 1;
            this_player()->add_succeeded(to[i]);
        } else {
            this_player()->add_succeeded(to[i]);
        }
        amount_not_poured = xfer_volume(volume_needed, to[i]);
        if (amount_not_poured) {
           ok--;
        }
    }

    if (!ok) {
       add_failed_mess("You cannot seem to do anything useful with this "
                       "container, it seems unwilling to accept what you "
                       "offer.\n");
    }

    return ok;
} /* do_fill() */


/**
 * This method checks to see if they are fighting anyone and if anyone
 * (that can see them) is fighting them.
 * @param player the player to check */
private int query_fighting(object player) {
   object ob;

   if (!player || !environment(player)) {
      return 0;
   }

   if (player->query_fighting()) {
      return 1;
   }

   foreach (ob in all_inventory(environment(player))) {
      if (living(ob)) {
         if (ob->query_attacker_list() &&
             member_array(this_player(), ob->query_attacker_list()) != -1) {
            return 1;
         }
      }
   }

   if (environment(ob)->query_mirror_room()) {
      foreach (ob in all_inventory(environment(player)->query_mirror_room())) {
         if (living(ob)) {
            if (member_array(this_player(), ob->query_attacker_list()) != -1) {
               return 1;
            }
         }
      }
   }
} /* query_fighting() */


/**
 * This method checks to see if the person doing the drinking can hold onto
 * their bottle without loosing it while in combat.  Warning!  This code
 * may be used in other objects to deal with handling drinking while in
 * combat.
 * @return 1 if the bottle is stopped, 0 if it is not
 * @param player the player doing the drinking
 * @param me the object being drunk */
int is_fighting_bottle_smashed(object player,
                               object me) {
   object* fighting;
   object ob;
   object weapon;
   string skill;
   string my_skill;
   int bonus;
   int stopped;

   stopped = 0;

// See if we are in combat and give a chance to drop the item if we
// are.  Chance is higher if we have no free hands. */
   if (query_fighting(player)) {
   // Ok, we are in combat.  Check out free hands.  The more people
   // we are fighting the harder it is.
      fighting = filter(player->query_attacker_list(),
                        (: environment($1) == $2 :), environment(player));
      if (query_holder()) {
         bonus = 0;
         bonus += -10 * player->query_free_limbs();
      } else {
         bonus = 20;
      }
      if (sizeof(fighting)) {
         bonus += (sizeof(fighting) - 1) * 20;
      }
      if (player->query_free_limbs() < 2 &&
          !query_holder()) {
         bonus += 50 - player->query_free_limbs() * 25;
      }

   // Check against the other persons fighting skill.
      foreach (ob in fighting) {
      // If they are using a weapon use the weapon skill, otherwise unarmed.
         if (sizeof(ob->query_holding() - ({ 0 }))) {
            weapon = (ob->query_holding() - ({ 0 }))[0];
            skill = weapon->query_weapon_type();
            if (skill == "mixed" ||
                (skill != "sharp" && skill != "blunt" && skill != "pierce")) {
               skill = ({ "sharp", "blunt", "pierce" })[random(3)];
            }
            skill = "fighting.combat.melee." + skill;
         } else {
            skill = "fighting.combat.melee.unarmed";
         }
         my_skill = "fighting.combat.special.unarmed";
         switch (player->query_combat_response()) {
         case "parry" :
            my_skill = "fighting.combat.parry.melee";
            break;
         case "dodge" :
            my_skill = "fighting.combat.dodging.melee";
            break;
         case "neutral" :
            my_skill = "fighting.combat." + 
            (({ "parry", "dodging" })[random(2)]) + ".melee";
         }
         
         switch (TASKER->compare_skills(player,
                                       my_skill,
                                       ob,
                                       skill,
                                       -bonus,
                                       TM_FREE,
                                       TM_FREE)) {
         case OFFAWARD :
            if (player->query_combat_response() == "dodge") {
               tell_object(player,
                           "%^YELLOW%^You nimbly dodge an attack to avoid "
                           "getting " +
                           me->poss_short() +
                           " smashed out of your hand and feel better about "
                           "attempting it next time.\n%^RESET%^");
            } else {
               tell_object(player,
                           "%^YELLOW%^You nimbly parry an attack to avoid "
                           " getting " +
                           me->poss_short() +
                           " smashed out of your hand and feel better about "
                           "attempting it next time.\n%^RESET%^");
            }
         case OFFWIN :
            tell_room(environment(player),
                      player->the_short() + " avoids getting " +
                      me->poss_short() + " smashed by " +
                      query_multiple_short(({ ob })) + ".\n",
                               ({ player }));
            tell_object(player,
                        "You avoid getting " + me->poss_short() +
                        " smashed by " + query_multiple_short(({ ob })) +
                        ".\n");

         // Do less, but still damage it.
            do_damage("crush", 20 + random(50));
            break;
         case DEFAWARD :
            tell_object(ob,
                        "%^YELLOW%^You feel much more able to smash "
                        "bottles out of peoples hands than "
                        "before.\n%^RESET%^");
         case DEFWIN :
            if (!query_holder() &&
                me->move(environment(player)) == MOVE_OK) {
               tell_room(environment(player),
                   ob->the_short() + " smashes " + the_short() + " out of " +
                   player->the_short() + "'s hands onto the ground "
                   "causing some of the liquid to splash out.\n", 
                   ({ player, me }));
               tell_object(player,
                   ob->the_short() + " smashes " + the_short() + " out of " +
                   "your hands onto the ground "
                   "causing some of the liquid to splash out.\n");
               tell_object(me,
                   ob->the_short() + " smash " + the_short() + " out of " +
                   player->the_short() + "'s hands onto the ground "
                   "causing some of the liquid to splash out.\n");    
               
            } else {
               tell_room(environment(player),
                   ob->the_short() + " smashes " + the_short() + " away "
                   "from " + player->the_short() + "'s mouth causing "
                   "some of the liquid to splash out.\n", ({ player, me }));
               tell_object(player,
                   ob->the_short() + " smashes " + the_short() + " away "
                   "from " + "your mouth causing some of the liquid to "
                   "splash out.\n");
               tell_object(me,
                   ob->the_short() + " smash " + the_short() + " out of " +
                   player->the_short() + "'s hands onto the ground "
                   "causing some of the liquid to splash out.\n"); 
            }
            stopped = 1;
            break;
         }
         if (stopped) {
            break;
         }
      }
   }
   return stopped;
} /* is_fighting_bottle_smashed() */


/**
 * @ignore
 * This method returns a description of what and how much of the
 * contents of the vessel that was consumed. */
private string consumed_desc( int consumed_amount ) {
   string amount_desc;
   object* contents;
   string* contents_descs = ({ });
   string contents_desc;

   contents = all_inventory( this_object() );

   if( !consumed_amount || !sizeof( contents ) )
      return "nothing much";

// Bugger accuracy!
   switch( consumed_amount ) {
   case 1..30:
      amount_desc = "a teaspoon";
      break;
   case 31..80:
      amount_desc = "a tablespoon";
      break;
   case 81..140:
      amount_desc = "an ounce";
      break;
   case 141..800:
      amount_desc = "a few ounces";
      break;
   case 801..1200:
      amount_desc = "a cup";
      break;
   case 1201..2000:
      amount_desc = "a couple of cups";
      break;
   case 2001..3500:
      amount_desc = "a pint";
      break;
   case 3501..7000:
      amount_desc = "a couple of pints";
      break;
   case 7001..15000:
      amount_desc = "several pints";
      break;
   case 15001..25000:
      amount_desc = "about a gallon";
      break;
   default:
      amount_desc = "several gallons";
   }

// They only drink the liquids, no matter what they have been mixed with. 
   contents = filter( contents, (: $1->query_liquid() :) );

// Try to describe contents in nice way.  Er...  So that the desc will look 
// nice, not the code (obviously).
   foreach( string* frog in unique_array( contents->short(), (: $1 :) ) ) {
      if( sizeof( frog ) > 1 ) {
         contents_descs += ({ pluralize( frog[0] ) });
      } else {
         contents_descs += ({ frog[0] });
      }
   }

   contents_desc = query_multiple_short( contents_descs );

   return amount_desc +" of "+ contents_desc;

} /* consumed_desc() */


/**
 * This method drinks a certain amount of the liquid in the container.
 * It will do all the fudging for being in combat and drinking too
 * much, as well as dropping the bottle and so on.
 * @param drinking the amount to drink 
 */
int drink_amount(int drinking,
                 object player) {
   int cap_amount;
   int amt_to_drink;
   int amount_can_be_drunk;
   object* contents;
   object ob;
   int orig_cv;

   amt_to_drink = drinking;

   if (amt_to_drink > cont_volume) {
      amt_to_drink = cont_volume;
   }

   if (max_volume / 20 > VOLUME_WINE) {
      cap_amount = max_volume / 20;
   } else {
      cap_amount = VOLUME_WINE;
   }

/* Ok, now fudge the values around if they are in combat or trying
 * to drink really small amounts. */
   if (amt_to_drink < cap_amount) {
      if (query_fighting(player)) {
         amt_to_drink += random(2 * (cap_amount - amt_to_drink)) -
                         cap_amount - amt_to_drink;
         if (amt_to_drink < VOLUME_MINIMUM_DRINKABLE * 2) {
            amt_to_drink = VOLUME_MINIMUM_DRINKABLE * 2;
         }
      } else {
         amt_to_drink += random((cap_amount - amt_to_drink) / 6) -
                         (cap_amount - amt_to_drink) / 12;
      }
   }

   if (amt_to_drink < VOLUME_MINIMUM_DRINKABLE) {
      amt_to_drink = VOLUME_MINIMUM_DRINKABLE;
   }

   if (amt_to_drink < (max_volume / 100)) {
      amt_to_drink = max_volume / 100;
   }

/* Make sure that we don't try to drink more than there actually
 * is, after all of this rounding. */
   if( amt_to_drink > cont_volume ) {
      amt_to_drink = cont_volume;
   }

   amount_can_be_drunk = (8000 - (int)this_player()->query_volume(2)) *
     (int)this_player()->query_con() / 12;
   /* should do some fudging to add +/- 5 mls or something
    * possibly skill/stat dependent */
   if (amt_to_drink > amount_can_be_drunk) {
       write("You drink some of the liquid, "
             "but simply cannot fit it all in.\n");
       amt_to_drink = amount_can_be_drunk;
   }

   if (is_fighting_bottle_smashed(this_player(), this_object())) {
   // Ok, now do the spilling if it has been done.
   // Throw out at least as much as they wanted to drink and up to
   // 10 times more.
      amt_to_drink *= (1 + random(15));
      if (amt_to_drink > volume) {
         amt_to_drink = volume;
      }

      orig_cv = cont_volume;
      foreach (ob in all_inventory(this_object())) {
         if (ob->query_continuous()) {
            if (amt_to_drink == cont_volume) {
               ob->adjust_amount(-ob->query_amount());
            } else {
               ob->adjust_amount(-(ob->query_amount() * amt_to_drink / orig_cv));
            }
         }
      }
      add_succeeded_mess("");
      
   // Drop the condition of the object by 10% as well.  Opps, no condition
   // at the moment.
      do_damage("crush", 50 + random(300));
      return 1;
   }


   contents = all_inventory(this_object());

/* If the contents has an eat message of its own, we'll use that.
 * And if it doesn't, we'll use a more generic one.  It's a bit of 
 * a cheap hack since it only checks the first of possibly several
 * things in the contents, but I couldn't be arsed.   - Tilly  */
   if( sizeof( contents[0]->query_eat_mess() ) ) {
      add_succeeded_mess( contents[0]->query_eat_mess() );
   } else {
      add_succeeded_mess("$N $V "+ consumed_desc( amt_to_drink ) +
                         " from $D.\n");
   }

   if (amt_to_drink - drinking > (max_volume / 40) &&
       amt_to_drink - drinking > VOLUME_MINIMUM_DRINKABLE) {
      add_succeeded_mess(({ "Whoops!  You seemed to have gulped "
                            "too much down.\n",
                            "" }));
   }


/* if (modifier - m < -5) {
 *    add_succeeded_mess(({ "You don't think that was quite as much as you "
 *                          "wanted to drink.\n",
 *                          "" }));
 * } */

/* Note that contents has been set just a few lines above, we don't need
 * to do that again. */
   orig_cv = cont_volume;
   foreach (ob in contents) {
       if (ob->query_continuous()) {
           if (amt_to_drink == orig_cv) {
               ob->consume(this_player(), ob->query_amount());
           } else {
               // Consume proportionate amounts of all food.
               ob->consume(this_player(),
                           ob->query_amount() * amt_to_drink / orig_cv);
           }
       }
   }

   return 1;
} /* drink_amount() */


/** @ignore yes */
int do_drink(object *dest, mixed me, mixed him, mixed args, string pattern)
{
    int amt_to_drink;
    int m;
    int n;

    //printf("indirect_o=%O\nindir_s=%O\ndir_s=%O\nargs=%O\npattern=%O\n",
    //       dest, me, him, args, pattern);
    if (sizeof(dest)) {
        add_failed_mess("Drinking is a very simple operation "
              "- please don't complicate matters.\n");
        return 0;
    }
    if (environment(this_object()) != this_player()) {
        add_failed_mess("You aren't carrying $D.\n");
        return 0;
    }
    if (!ensure_open()) {
       return 0;
    }
    if (!is_liquid) {
        add_failed_mess("$C$$D $V$0=is,are$V$ bone dry!\n");
        return 0;
    }
    // add_command() mucks around with the pattern strings...
    if (pattern == drink_pat[1]) {
        m = to_int(args[0]);
        n = to_int(args[1]);
        //sscanf(args[0] + " " + args[1], "%d %d", m, n);
        /** Yes, its a kludge. T. **/
        if ( n > 100 ) {
          add_failed_mess( "You can't drink with that much precision!\n" );
          return 0;
        }
        if ((m > n) || (m < 0) || (n <= 0)) {
            add_failed_mess("Interesting fraction you have there!\n");
            return 0;
        }
    } else {
        m = 1;
        n = 1;
    }

    if (_fraction) {
        m = _fraction[0];
        n = _fraction[1];
    }

    if ((m == 1) && (n == 1)) {
        amt_to_drink = cont_volume;
    } else {
        amt_to_drink = (max_volume*m)/n;
        if (amt_to_drink > volume) {
            add_failed_mess("$C$$D $V$0=is,are$V$ less than " + m + "/" + n +
                  " full.\n");
            return 0;
        }

        if (amt_to_drink > cont_volume) {
            amt_to_drink = cont_volume;
        }
    }

    if (!drink_amount(amt_to_drink, this_player())) {
       return 0;
    }

    switch ((this_player()->query_volume(2) + 100) / 200) {
      case 0:
      case 1:
      case 2:
      case 3:
      case 4:
        break;
      case 5:
        write("You feel mildly full of liquid.\n");
        break;
      case 6:
        write("You feel very full of liquid.\n");
        break;
      case 7:
        write("You feel all the liquid sloshing around inside you.\n");
        break;
      case 8:
        write("You are awash with liquid.\n");
        break;
      case 9:
        write("You are full to the brim with liquid.\n");
        break;
      default:
        write("You feel you would burst if you drank any more.\n");
        break;
    }
    return 1;
} /* do_drink() */

/** @ignore yes */
int do_quaff(object *dest, mixed me, mixed him, mixed args, string pattern) {
   return do_drink(dest, me, him, args, pattern);
}

/** @ignore yes */
int do_empty(object *dest, string me, string him, string prep)
{
   if (environment(this_object()) != this_player()) {
       add_failed_mess("You are not carrying $D.\n");
       return 0;
   }
   if (sizeof(dest)) {
       write("Passing on to pour ... bad move.\n");
       //return do_pour(dest, me, him, prep);
   }
   /* this completely fails to work :( ^^^ */

   if (!ensure_open()) {
      add_failed_mess("$C$$D $V$0=is,are$V$ not open.\n");
      return 0;
   }

   if (cont_volume == 0 &&
       !sizeof(all_inventory())) {
       add_failed_mess("$C$$D $V$0=is,are$V$ already empty.\n");
       return 0;
   }

   (void)remove_volume(cont_volume);

   // Remove the inventory too.
   all_inventory()->move(environment(this_player()));

   /* should check spillage */
   return 1;
} /* do_empty */


/** @ignore yes */
int check_splashable(object ob, object splasher, object splashee){
  return ob->query_splashable(splasher, splashee);
}


/** @ignore yes */
int do_splash(object *dest, mixed me, mixed him, mixed args, string pattern) {
    int amt_to_splash, i, m, n, orig_cv;
    object *contents;

    if (!sizeof(dest)) {
        add_failed_mess("Splash it on who?\n");
        return 0;
    }
    if(sizeof(dest) >1){
        add_failed_mess("You may only splash one person at a time.\n");
        return 0;
    }
    if (environment(this_object()) != this_player()) {
        write("You aren't carrying the " + short(0) + ".\n");
        return 0;
    }
    if (!ensure_open()) return 0;
    if (!is_liquid) {
        add_failed_mess("The " + short(0) + " $V$0=is,are$V$ bone dry!\n");
        return 0;
    }

 // add_command() mucks around with the pattern strings...
    if (pattern == splash_pat[1]) {
        m = to_int(args[0]);
        n = to_int(args[1]);
        if ((m > n) || (m < 0) || (n <= 0)) {
            notify_fail("Interesting fraction you have there!\n");
            return 0;
        }
    } else {
        m = 1;
        n = 1;
    }
    contents = filter( all_inventory(this_object()), (:check_splashable:),
          this_player(), dest[0]);

    if( !sizeof(contents) ){
       add_failed_mess("You can't splash anything in $D.\n");
       return 0;
    }

    orig_cv = cont_volume;
    if ( m == n ){
        amt_to_splash = cont_volume;
    } else {
        amt_to_splash = (max_volume*m)/n;
        if (amt_to_splash > volume) {
            add_failed_mess("The " + short(0) + " $V$0=is,are$V$ less than "
               + m + "/" + n + " full.\n");
            return 0;
        }
        if (amt_to_splash > cont_volume) {
            amt_to_splash = cont_volume;
        }
    }
    if(this_player() == dest[0]){
       this_player()->add_succeeded_mess(this_object(),
                     "$N $V " + query_multiple_short(contents) +
                     " from $D onto "+this_player()->query_objective() +
                     "self.\n", ({}));
    }else{
       this_player()->add_succeeded_mess(this_object(),
                     "$N $V " + query_multiple_short(contents) +
                     " from $D onto $I.\n", dest);
    }
 // Call consume() on food objects, I guess ignore the others.
    for (i = 0; i < sizeof(contents); i++) {
        if (amt_to_splash == cont_volume) {
           contents[i]->consume(dest[0],
           contents[i]->query_amount(), "splash");
        } else {
           // Consume proportionate amounts of all food.
           contents[i]->consume(dest[0],
              (int)contents[i]->query_amount()
              * amt_to_splash / orig_cv, "splash");
        }
    }
    return 1;
} /* do_splash() */


/** @ignore yes */
int check_applicable(object ob, object applier, object appliee){
  return ob->query_applicable(applier, appliee);
}


/** @ignore yes */
int do_rub(object *dest, mixed me, mixed him, mixed args, string pattern) {
    int amt_to_apply, i, m, n, orig_cv;
    object *contents;

    if (!sizeof(dest)) {
        add_failed_mess("Rub it on who?\n");
        return 0;
    }
    if(sizeof(dest) >1){
        add_failed_mess("You may only rub stuff on one person at a time.\n");
        return 0;
    }
    if (environment(this_object()) != this_player()) {
        write("You aren't carrying the " + short(0) + ".\n");
        return 0;
    }
    if (!ensure_open()) return 0;
    if (!is_liquid) {
        add_failed_mess("The " + short(0) + " $V$0=is,are$V$ bone dry!\n");
        return 0;
    }

 // add_command() mucks around with the pattern strings...
    if (pattern == apply_pat[1]) {
        m = to_int(args[0]);
        n = to_int(args[1]);
        if ((m > n) || (m < 0) || (n <= 0)) {
            notify_fail("Interesting fraction you have there!\n");
            return 0;
        }
    } else {
        m = 1;
        n = 1;
    }
    contents = filter( all_inventory(this_object()), (:check_applicable:),
        this_player(), dest[0]);
    if( !sizeof(contents) ){
       add_failed_mess("You can't rub anything in $D on $I.\n",dest);
    }
    orig_cv = cont_volume;
    if ( m == n ){
        amt_to_apply = cont_volume;
    } else {
        amt_to_apply = (max_volume*m)/n;
        if (amt_to_apply > volume) {
            add_failed_mess("The " + short(0) + " $V$0=is,are$V$ less than " 
               + m + "/" + n + " full.\n");
            return 0;
        }
        if (amt_to_apply > cont_volume) {
            amt_to_apply = cont_volume;
        }
    }
    if (this_player() == dest[0]){
       this_player()->add_succeeded_mess(this_object(),
                     "$N $V " + query_multiple_short(contents) +
                     " from $D onto "+this_player()->query_objective()+"self.\n", ({}));
    } else {
       this_player()->add_succeeded_mess(this_object(),
                     "$N $V " + query_multiple_short(contents) +
                     " from $D onto $I.\n", dest);
    }
 // Call consume() on food objects, I guess ignore the others.
    for (i = 0; i < sizeof(contents); i++) {
        if (amt_to_apply == cont_volume) {
           contents[i]->consume(dest[0],
                          contents[i]->query_amount(),"apply");
        } else {
        // Consume proportionate amounts of all food.
           contents[i]->consume(dest[0],
              (int)contents[i]->query_amount()
              * amt_to_apply / orig_cv, "apply");
        }
    }
    return 1;
} /* do_rub() */


/** @ignore yes */
int do_apply(object *dest, mixed me, mixed him, mixed args, string pattern){
   return do_rub(dest, me, him, args, pattern);
} /* do_apply() */


/** @ignore yes */
int do_taste() {
    int amount_tasted;
    /* be kind to tasters! */

    if (environment(this_object()) != this_player()) {
        write("You aren't carrying the " + short(0) + ".\n");
        return 0;
    }
    if (!ensure_open()) {
       return 0;
    }
    if (!cont_volume || !is_liquid) {
        add_failed_mess("The " + short(0) + " $V$0=is,are$V$ bone dry!\n");
        return 0;
    }

 // Put code here to give description of contents' taste.
    amount_tasted = VOLUME_SHOT;
    if (cont_volume < amount_tasted) {
        amount_tasted = cont_volume;
    }

    if (amount_tasted < max_volume / 100) {
       amount_tasted = max_volume / 100;
    }

    return drink_amount(amount_tasted, this_player());
} /* do_taste() */


/** @ignore yes */
int do_sip() {
   int amount_tasted;
/* be kind to tasters! */

   if (environment(this_object()) != this_player()) {
      write("You aren't carrying the " + short(0) + ".\n");
      return 0;
   }
   if (!ensure_open()) {
      return 0;
   }
   if (!cont_volume || !is_liquid) {
      add_failed_mess("The " + short(0) + " $V$0=is,are$V$ bone dry!\n");
      return 0;
   }

 // Put code here to give description of contents' taste.
   amount_tasted = VOLUME_SHOT * 2;
   if (cont_volume < amount_tasted) {
      amount_tasted = cont_volume;
   }

   if (amount_tasted < max_volume / 70) {
      amount_tasted = max_volume / 70;
   }

   return drink_amount(amount_tasted, this_player());
} /* do_sip() */


/** @ignore yes */
int do_smell() {
/* be kind to smellers! */

   if (!ensure_open()) {
      return 0;
   }

// Put code here to give description of contents' smell.
   write("Smelling isn't implemented yet.  Sorry.\n");

// Put code here to handle effects of smelling contents.
   return 1;
} /* do_smell() */


/** @ignore yes */
protected int handle_restore_inventory(object ob) {
   int ret;

   ret = ::handle_restore_inventory(ob);
   if (ret == MOVE_OK) {
      return MOVE_OK;
   }

// If it is a liquid or continuous object, we squeeze into the bottle.
   if (ob->query_liquid()) {
      ob->set_amount( query_max_volume() - query_volume() );
      ret = ::handle_restore_inventory(ob);
      if (ret == MOVE_OK) {
         return MOVE_OK;
      }
   }
   return ret;
} /* handle_restore_inventory() */


/** @ignore yes */
mapping int_query_static_auto_load() {
  mapping tmp;

  tmp = ::int_query_static_auto_load();
  return ([ "::" : tmp, "leak rate" : leak_rate,
           "max volume" : max_volume,
          ]);
} /* int_query_static_auto_load() */


/** @ignore yes */
mapping query_static_auto_load() {
  if ( !query_name() || ( query_name() == "object" ) ) {
    return 0;
  }
  if ( explode( file_name( this_object() ), "#" )[ 0 ] == "/obj/vessel" ) {
    return int_query_static_auto_load();
  }
  return ([ ]);
} /* query_static_auto_load() */

/** @ignore yes */
void init_static_arg(mapping args) {
  if (args["::"])
    ::init_static_arg(args["::"]);
  if (!undefinedp(args["leak rate"]))
    leak_rate = args["leak rate"];
  if (!undefinedp(args["max volume"]))
    max_volume = args["max volume"];
} /* init_static_arg() */


/* Added so you cant get things in or out of a close container. */
/** @ignore yes */
int test_add(object ob, int flag) {
    int new_vol;

    if ( !::test_add( ob, flag ) ) {
        return 0;
    }
    if (ob->query_continuous()) {
        new_vol = ob->query_amount();
    } else if (ob->query_property("density")) {
     // A hook for later use (maybe :)
        new_vol = (int)ob->query_weight()*(int)ob->query_property("density");
    } else {
     // Density is nominally that of water
     //new_vol = (int)ob->query_weight()*200;
     // The above is essentially correct.  However, through some odd
     // sequence of events, the weight (and hence, the calculated volume)
     // get added before this function.  So new_vol should be 0 here.
        new_vol = 0;
    }
    if ((new_vol + volume) > max_volume) {
     //write("Failed: new_vol = " + new_vol + ", volume = " + volume +
     //      ", max_volume = " + max_volume + "\n");
        return 0;
    }
    return 1;
} /* test_add() */


/** @ignore yes */
void event_enter(object ob, string message, object from) {
    int ob_vol, ob_cont;

    if (environment(ob) == this_object()) {
     // Adjust volume
        if (ob->query_continuous() ) {
            ob_vol = ob->query_amount();
            ob_cont = 1;
        } else if (ob->query_property("density")) {
         // A hook for later use (maybe :)
            ob_vol = (int)ob->query_weight()*
              (int)ob->query_property("density");
        } else {
         // Density is nominally that of water
         //ob_vol = (int)ob->query_weight()*200;
         // The above is essentially correct.  However, through some odd
         // sequence of events, the weight (and hence the calculated volume)
         // get added before this function.  So ob_vol should be 0 here.
            ob_vol = 0;
        }
        if (ob->query_liquid()) {
           is_liquid = 1;
           _liquids = ({ });
        }
#ifdef DEBUG        
        debug_printf("Increasing volume by " + ob_vol + ".\n");
#endif
        volume += ob_vol;
        if (ob_cont) cont_volume += ob_vol;
        // Check for reactions
        REACTION_HANDLER->check_reaction(ob);
        if (leak_rate > 0) {
            set_heart_beat(1);
        }
    }
} /* event_enter() */


/** @ignore yes */
void event_exit(object ob, string mess, object to) {
    int ob_vol, ob_cont;

    if (environment(ob) == this_object()) {
     // Adjust volume
        if (ob->query_continuous()) {
            ob_vol = ob->query_amount();
            ob_cont = 1;
        } else if (ob->query_property("density")) {
         // A hook for later use (maybe :)
            ob_vol = (int)ob->query_weight()*
              (int)ob->query_property("density");
        } else {
         // Density is nominally that of water
         //ob_vol = (int)ob->query_weight()*200;
         // The above is essentially correct.  However, through some odd
         // sequence of events, the weight (and hence the calculated volume)
         // get added before this function.  So ob_vol should be 0 here.
            ob_vol = 0;
        }
#ifdef DEBUG
        debug_printf("Decreasing volume by " + ob_vol + ".\n");
#endif
        volume -= ob_vol;
        if (ob_cont) cont_volume -= ob_vol;
        if (volume <= 0) is_liquid = 0;
    }
} /* event_exit() */


/** @ignore yes */
void break_me() {
  object *liquid;

// Dest all the liquid...
   liquid = filter(all_inventory(), (: $1->query_liquid() :));
   if (sizeof(liquid)) {
      tell_room(environment(),
         query_multiple_short(liquid) + " splashes all over the place "
         "as " + the_short() + " breaks.\n");
       liquid->move("/room/rubbish");
   }
   ::break_me();
} /* break_me() */


/** @ignore yes */
mixed* parse_match_object(string* input, object player,
                          class obj_match_context context) {
   int result;

   result = ::is_matching_object(input, player, context);
   if (result) {
      _fraction = context->fraction;
      if (update_parse_match_context(context, 1, result)) {
         return ({ result, ({ this_object() }) });
      }
   }
   return 0;
} /* parse_match_object() */


/** @ignore yes */
string *parse_command_adjectiv_id_list() {
   string *ret;

   ret =  fullness_adjectives() + ::parse_command_adjectiv_id_list();
   if (is_liquid && !query_opaque()) {
      object liquid;

      if (!sizeof(_liquids)) {
         figure_out_liquids();
      }
      _liquids -= ({ 0 });
      foreach (liquid in _liquids) {
         ret += liquid->parse_command_adjectiv_id_list();
      }
      return ret;
   }
   return ret;
} /* parse_command_adjectiv_id_list() */


/** @ignore yes */
string* parse_command_id_list() {
   if (is_liquid && !query_opaque()) {
      string* ret;
      object liquid;

      if (!sizeof(_liquids)) {
         figure_out_liquids();
      }
      _liquids -= ({ 0 });
      ret = ::parse_command_id_list();
      foreach (liquid in _liquids) {
         ret += liquid->parse_command_id_list();
      }
      return ret;
   }
   return ::parse_command_id_list();
} /* parse_command_id_list() */


/** @ignore yes */
string* parse_command_plural_id_list() {
   if (is_liquid && !query_opaque()) {
      string* ret;
      object liquid;

      if (!sizeof(_liquids)) {
         figure_out_liquids();
      }
      _liquids -= ({ 0 });
      ret = ::parse_command_plural_id_list();
      foreach (liquid in _liquids) {
         ret += liquid->parse_command_plural_id_list();
      }
      return ret;
   }
   return ::parse_command_plural_id_list();
} /* parse_command_plural_id_list() */


int query_vessel() { return 1; }
// --- END [/mnt/home2/grok/lib/obj/vessel.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/boring_stick.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/boring_stick.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628066   Available: 13575420
Inodes: Total: 5242880    Free: 4960134
4321 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/boring_stick.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628066   Available: 13575420
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/held";
#include <move_failures.h>

/*
 * This stick doesn't actually do anything.  But who cares?
 *
 * Written by Pinkfish -- Today is Setting Orange, the 38th day
 *                        of The Aftermath in the YOLD 3162
 */

int state;

void set_state(int state);

void setup() {
  set_name("stick");
  set_state(0);
  set_weight(2);
  set_value(10);
} /* setup() */

void init() {
  this_player()->add_command("turn", this_object(),
                                "<direct:object> {on|off}");
  this_player()->add_command("flick", this_object(),
                                "switch on <direct:object>");
  this_player()->add_command("press", this_object(),
                                "switch on <direct:object>");
  this_player()->add_command("push", this_object(),
                                "switch on <direct:object>");
  this_player()->add_command("flick", this_object(),
                                "<direct:object>");
  this_player()->add_command("turn", this_object(),
                                "switch {on|off} on <direct:object>");
  this_player()->add_command("switch", this_object(),
                                "<direct:object> {on|off}");
} /* init() */

void set_state(int new_state) {
  state = new_state;
  if (state) {
    set_long(
"The long straight black stick vibrates slightly in your hands, you "
"get a nice massage from it.  There is something which looks a bit "
"like a switch down near the base of the stick.  Flashing lights "
"rush up and down the side of the stick in a mad progression.\n");
  } else {
    set_long(
"The long straight black stick vibrates slightly in your hands, you "
"get a nice massage from it.  There is something which looks a bit "
"like a switch down near the base of the stick.\n");
  }
  if (environment())
    if (state) {
      if (living(environment()))
        environment()->add_extra_look(this_object());
    } else
      environment()->remove_extra_look(this_object());
} /* set_state() */

string extra_look() {
  return capitalize(previous_object()->query_pronoun())+
         " is surrounded by an aura of bees.\n";
} /* extra_look() */

int do_turn(mixed *indirect_obs, string indir_match,
            string dir_match, mixed *args, string pattern) {
  int new_state;
  
  new_state = 0;
  if ("<direct:object> {on|off}" == pattern) {
    if (args[1] == "on")
      new_state = 1;
  } else {
    if (args[0] == "on")
      new_state = 1;
  }

  if (state == new_state) {
    this_player()->add_failed_mess(this_object(),
                   "$D is already turned "+(state?"on":"off")+".\n", ({ }));
    return 0;
  }
  set_state(new_state);
  this_player()->add_succeeded_mess(this_object(),
    "$N $V $D "+(state?"on":"off")+".\n", ({ }));
  return 1;
} /* do_turn() */

int do_flick() {
  set_state(!state);
  this_player()->add_succeeded_mess(this_object(),
    "$N $V the switch on $D to the "+(state?"on":"off")+" position.\n", ({ }));
  return 1;
} /* do_flick() */

int do_press() {
  return do_flick();
} /* do_press() */

int do_push() {
  return do_flick();
} /* do_push() */

int do_switch(mixed *indirect_obs, string indir_match,
              string dir_match, mixed *args, string pattern) {
  int new_state;

  if (args[1] == "on")
    new_state = 1;
  if (state == new_state) {
    this_player()->add_failed_mess(this_object(),
                   "$D is already turned "+(state?"on":"off")+".\n", ({ }));
    return 0;
  }
  set_state(new_state);
  this_player()->add_succeeded_mess(this_object(),
    "$N $V $D "+(state?"on":"off")+".\n", ({ }));
  return 1;
} /* do_switch() */

mapping query_dynamic_auto_load() {
   return ([ "state" : state,
             "::" : held::query_dynamic_auto_load()
          ]);
} /* query_dynamic_auto_load() */

void init_dynamic_arg(mapping map) {
   set_state(map["state"]);
   if ( map[ "::" ] )
      held::init_dynamic_arg( map[ "::" ] );
} /* init_dynamic_arg() */

varargs int move(mixed dest, string str1, string str2) {
  int ret;
  object old;

  old = environment();
  ret = ::move(dest, str1, str2);
  if (ret == MOVE_OK) {
    if (state) {
      if (old) 
        old->remove_extra_look(this_object());
      if (living(environment())) {
        environment()->add_extra_look(this_object());
      }
    }
  }
  return ret;
} /* move() */
// --- END [/mnt/home2/grok/lib/obj/misc/boring_stick.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/perfume_bottle.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/perfume_bottle.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628065   Available: 13575419
Inodes: Total: 5242880    Free: 4960134
3751 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/perfume_bottle.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628065   Available: 13575419
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <move_failures.h>

inherit "/std/object";
inherit "/std/basic/holdable";

int squirts;
string glass, scent, scent_plural;

void create() {
   object::create();
   holdable::create();
} /* create() */

void setup() {
   set_name( "bottle" );
   set_short( "perfume bottle" );
   add_adjective( "perfume" );
   set_value( 4000 );
   set_weight( 2 );
   squirts = 12;
} /* setup() */

void set_glass( string word ) {
   set_short( word +" perfume bottle" );
   add_adjective( word );
   set_main_plural( word +" perfume bottles" );
   glass = word;
} /* set_glass() */

void set_scent( string words ) { scent = words; }
void set_scent_plural( string words ) { scent_plural = words; }

string long( string word, int dark ) {
   string words;
   words = "This is a perfume bottle made out of "+ glass +" crystal.  "+
         "It is ";
   switch( squirts ) {
      case 0 :
         return words +"empty.\n";
      case 1 .. 3 :
         words += "about a quarter full";
         break;
      case 4 .. 6 :
         words += "about half full";
         break;
      case 7 .. 9 :
         words += "about three-quarters full";
         break;
      default :
         words += "almost full";
   }
   words += " of "+ scent +" perfume which can be sprayed onto "+
         "someone.\n";
   return words;
} /* long() */

void init() {
   this_player()->add_command( "spray", this_object(), "<direct:object> at <indirect:object>" );
} /* init() */

int do_spray( object *things ) {
  if ( query_wielded() != this_player() ) {
    this_player()->add_failed_mess( this_object(), "You must be holding "+
        "$D to use it.\n", ({ }) );
    return 0;
  }
  if ( sizeof( things ) > 1 ) {
    this_player()->add_failed_mess( this_object(), "You can only spray $D "+
        "at one person at a time.\n", ({ }) );
    return 0;
  }
  if ( things[ 0 ] == this_object() ) {
    this_player()->add_failed_mess( this_object(), "You cannot spray $D at "+
        "itself!\n", ({ }) );
    return 0;
  }
  if ( !living( things[ 0 ] ) ) {
    this_player()->add_failed_mess( this_object(), "SI would probably not "+
        "benefit from being sprayed.\n", ({ things[ 0 ] }) );
    return 0;
  }
  if ( !squirts ) {
    this_player()->add_failed_mess( this_object(), "There is no perfume in "+
        "$D to spray at $I.\n", ({ things[ 0 ] }) );
    return 0;
  }
  squirts--;
  things[ 0 ]->add_effect( "/std/effects/other/perfume", ({ 300, scent, 
      scent_plural }) );
  this_player()->add_succeeded( things[ 0 ] );
  return 1;
} /* do_spray() */

mapping query_dynamic_auto_load() {
  return ([
    "::" : ::query_dynamic_auto_load(),
    "squirts" : squirts
  ]);
} /* query_dynamic_auto_load() */

mapping query_static_auto_load() {
  if ( explode( file_name( this_object() ), "#" )[ 0 ] !=
      "/obj/misc/perfume_bottle" )
    return 0;
  return ([
    "::" : int_query_static_auto_load(),
    "glass" : glass,
    "scent" : scent,
    "scent_plural" : scent_plural
  ]);
} /* query_static_auto_load() */

void init_dynamic_arg( mapping map ) {
  if ( map[ "::" ] )
    ::init_dynamic_arg( map[ "::" ] );
  squirts = map[ "squirts" ];
} /* init_dynamic_arg() */

void init_static_arg( mapping map ) {
  if ( map[ "::" ] )
    ::init_static_arg( map[ "::" ] );
  if ( map[ "glass" ] )
    set_glass( map[ "glass" ] );
  if ( map[ "scent" ] )
    scent = map[ "scent" ];
  if ( map[ "scent_plural" ] )
    scent_plural = map[ "scent_plural" ];
} /* init_static_arg() */


void dest_me() {
   holdable::dest_me();
   object::dest_me();
} /* dest_me() */

varargs int move( mixed ob, string mess1, string mess2 ) {
   int ret;

   ret = holdable::move(ob);
   if (ret != MOVE_OK) {
      return ret;
   }
   return object::move( ob, mess1, mess2 );
}
// --- END [/mnt/home2/grok/lib/obj/misc/perfume_bottle.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/dead_duck.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/dead_duck.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628064   Available: 13575418
Inodes: Total: 5242880    Free: 4960134
2369 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/dead_duck.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628064   Available: 13575418
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: dead_duck.c,v 1.5 2001/11/27 12:03:41 siel Exp $
 *
 *
 */


#include <move_failures.h>

#define DUCK_FEATHER "/obj/misc/duck_feather.ob"
#define MIN_FEATHERS 3
#define MAX_FEATHERS 5

inherit "/obj/food";

void    setup();
void    init();
int     do_pluck( object *indirect_obs, string indir_match, string dir_match, 
                 mixed *args, string pattern );
mixed   query_dynamic_auto_load();
void    init_dynamic_arg(mapping arg, object);

int plucked; /* Is the duck already plucked? */

void setup()
{
  set_name( "duck" );
  set_short( "dead duck" );
  add_alias( ({ "corpse", "duck corpse" }) );
  add_adjective( "dead" );
  set_main_plural( "dead ducks" );
  set_long( function()
            {
              if( plucked ) 
                return
                  "This is the dead body of a bedraggled duck.  Judging "
                  "from the lack of feathers it is ready to be "
                  "cooked.\n";
              return
                  "This is the dead body of a bedraggled duck.  "
                  "Most people would pluck it and then cook it.\n";
            } );
  set_weight( 10 );
  set_value( 400 );
  set_weight_per_bite( 2 );
}

void init()
{
  ::init();
  this_player()->add_command( "pluck", this_object(),
        "<direct:object:me-here>" );
}

int do_pluck( object *indirect_obs, string indir_match, string dir_match, 
   mixed *args, string pattern )
{
  object pluck;
  int feathers = random( MAX_FEATHERS - MIN_FEATHERS ) + MIN_FEATHERS;

  if ( plucked ) return notify_fail( "The duck is already plucked and "
    "bare of any feathers.\n" );

  plucked = 1;
  for ( int i = 0; i < feathers; i++ ) {
    pluck = clone_object( DUCK_FEATHER );
    if( MOVE_OK != pluck->move( this_player() ) )
        pluck->move( environment() );
  }
  tell_room( environment( this_player() ),
        this_player()->one_short() + " plucks a dead duck with reckless "
          "abandon.\n",
        this_player() );
  return notify_fail( "You pluck the bedraggled, dead duck cheerfully.\n" );
}

mixed query_dynamic_auto_load() {

  return ([ "::" : ::query_dynamic_auto_load(),
            "plucked" : plucked ]);
} /* query_dynamic_auto_load() */

void init_dynamic_arg(mapping arg, object) {

  ::init_dynamic_arg(arg["::"]);
  plucked = arg["plucked"];

} /* init_dynamic_arg() */
// --- END [/mnt/home2/grok/lib/obj/misc/dead_duck.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/newspaper.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/newspaper.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628063   Available: 13575417
Inodes: Total: 5242880    Free: 4960134
5016 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/newspaper.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628063   Available: 13575417
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*
 * A guide for new home owners.
 */
inherit "/std/book";
#include <room/newspaper.h>

#define AUTO_LOAD_TAG "newspaper"

private string _paper;
private int _edition;

void setup() {
  set_name("newspaper");
  set_short("newspaper");
  add_alias("paper");
  add_plural("papers");
  set_long("A bunch of nice newspapers.\n");
  set_main_plural("newspapers");
  set_weight(10);
  set_value(10);
  set_ignore_saved_pages(1);
}

int query_binding_force() {
  return 100;
}

void setup_paper() {
   class article* articles;
   class advert* adverts;
   class advert data;
   string* bits;
   int i;
   int j;
   string header;
   string index;
   string fluff;
   int page;
   mixed* stuff;
   object ob;

   if (_paper && _edition) {
      bits = explode(_paper, " ");
      if (bits[0] != "The") {
         set_short("copy of the " + _paper);
         add_adjective( ({ "the" }) );
         set_main_plural("copies of the " + _paper);
      } else {
         set_short("copy of " + _paper);
         set_main_plural("copies of " + _paper);
         add_plural_adjective("copies");
      }
      bits = map(bits, (: lower_case($1) :));
      add_adjective( ({ "copy", "of" }) );
      add_adjective(bits[0..<2]);
      add_alias(lower_case(bits[<1]));
      //if (bits[0] == "the") {
      add_property("determinate", "a ");
      //} else {
         //add_property("determinate", "The ");
      //}
      page = query_open_page();
      articles = NEWSPAPER_HANDLER->query_edition_articles(_paper, _edition);
      set_no_pages(sizeof(articles) + 1);
      index = "Edition #" + _edition + " of " + _paper + ".\n%^BOLD%^" +
              NEWSPAPER_HANDLER->query_paper_headline(_paper, _edition) +
              "%^RESET%^\n\n";
      index += sprintf("%2d .... %70-=s\n", 1, "Contents");
      for (i = 0; i < sizeof(articles); i++) {
         set_open_page(i + 2);
         ob = query_current_page();
         ob->set_value(0);
         if (articles[i]->colour) {
            index += "%^" + articles[i]->colour + "%^";
         }
         switch (articles[i]->type) {
         case NEWSPAPER_ARTICLE_TYPE_ADVERTS :
            header = "%^BOLD%^%^CYAN%^'Adverts'%^RESET%^\n\n";
            adverts = NEWSPAPER_HANDLER->query_edition_adverts(_paper, _edition);
            stuff = unique_array(adverts, (: $1->category :) );
            foreach (adverts in stuff) {
               header += "\n$I$0=" + adverts[0]->category + "\n$I$3=   ";
               foreach (data in adverts)  {
                  header += data->text + "\n-- " + data->author + "\n\n";
               }
            }
            index += sprintf("%2d .... %70-=s\n", i + 2, articles[i]->title);
            break;
         case NEWSPAPER_ARTICLE_TYPE_SECTION :
            header = "%^BOLD%^" + articles[i]->title + "'%^RESET%^\n\n";
            for (j = i + 1; j < sizeof(articles); j++) {
               if (articles[j]->type == NEWSPAPER_ARTICLE_TYPE_SECTION) {
                  break;
               }
               header += sprintf("%2d .... %70-=s\n", i + 2, articles[j]->title);
            }
            index += sprintf("%2d -=== %65|=s ===-\n", i + 2, articles[i]->title);
            break;
         case NEWSPAPER_ARTICLE_TYPE_HTML :
         case NEWSPAPER_ARTICLE_TYPE_PLAIN :
            header = "%^BOLD%^%^CYAN%^'" + articles[i]->title + "'%^RESET%^ at " +
                     ctime(articles[i]->date_written)[0..10] + "\n" +
                     "by " + articles[i]->shown_name;
            header += NEWSPAPER_HANDLER->query_article_text_plain(articles[i]);
            index += sprintf("%2d .... %70-=s\n", i + 2, articles[i]->title);
            break;
         }
         if (articles[i]->colour) {
            index += "%^RESET%^";
         }
         set_read_mess( header, NEWSPAPER_HANDLER->query_language_for( _paper ),
             0 );
      }
      set_open_page(1);
      set_read_mess( index, NEWSPAPER_HANDLER->query_language_for( _paper ), 0);
      ob = query_current_page();
      ob->set_value(0);

      fluff = NEWSPAPER_HANDLER->query_paper_long(_paper);
      if (fluff[<1] != '\n') {
         fluff += "\n";
      }
      set_long(fluff + "Edition " + _edition + " of " + _paper + ".\n");
      set_open_page(page);
   }
} /* setup_paper() */

void set_paper(string paper) {
   _paper = paper;
   set_long(NEWSPAPER_HANDLER->query_paper_long(_paper));
   setup_paper();
} /* set_paper() */

void set_edition(int edition) {
   _edition = edition;
   setup_paper();
} /* set_edition() */

mapping query_dynamic_auto_load() {
   mapping map;

   map = ::query_dynamic_auto_load();
   add_auto_load_value(map, AUTO_LOAD_TAG, "paper", _paper);
   add_auto_load_value(map, AUTO_LOAD_TAG, "edition", _edition);
   return map;
} /* query_dynamic_auto_load() */

void init_dynamic_arg(mapping map, object player) {
   ::init_dynamic_arg(map);
   set_paper(query_auto_load_value(map, AUTO_LOAD_TAG, "paper"));
   set_edition(query_auto_load_value(map, AUTO_LOAD_TAG, "edition"));
} /* init_dynamic_arg() */
// --- END [/mnt/home2/grok/lib/obj/misc/newspaper.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/golem_shard.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/golem_shard.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628062   Available: 13575416
Inodes: Total: 5242880    Free: 4960134
397 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/golem_shard.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628062   Available: 13575416
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*
 * $Id$
 */

/* Clay shard (remains of a golem) */

inherit "/std/object";

void setup() {
    set_name( "shard" );
    set_short( "cracked clay shard" );
    add_adjective( ({"clay"}) );
    set_long( "This is a heavily cracked clay shard." );
    set_main_plural( "cracked clay shards" );
    set_weight( 5 );
    set_value( 0 );
    add_property( "no recycling", 1 );
} /* void setup() */


// --- END [/mnt/home2/grok/lib/obj/misc/golem_shard.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/eel_skin.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/eel_skin.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628061   Available: 13575415
Inodes: Total: 5242880    Free: 4960134
429 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/eel_skin.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628061   Available: 13575415
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: eel_skin.c,v 1.1 2001/09/27 11:43:37 siel Exp $
 *
 *
 */

inherit "/std/object";

void setup()
{
  set_name( "skin" );
  set_short( "eel skin" );
  add_adjective( "eel" );
  set_main_plural( "eel skins" );
  set_long( "This is the skin of an eel.  It is very greasy and "
        "glistens prettily when you tilt it towards the light.\n" );
  set_weight( 3 );
  set_value( 100 );
}
// --- END [/mnt/home2/grok/lib/obj/misc/eel_skin.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/al_receipt.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/al_receipt.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628061   Available: 13575415
Inodes: Total: 5242880    Free: 4960134
8696 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/al_receipt.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628061   Available: 13575415
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* the receipt given out for missing items */
/*
 * Modified by Jeremy, 22-Feb-97
 *    - added "kiss" command and associated changes
 */

#include <virtual.h>
#include <player.h>
#include <move_failures.h>
#include <armoury.h>

inherit "/std/object";

private int _timestamp;
private string _obname;
private string _obpath;
private string _virt_name;
private mixed _static_save;

void setup()
{
   set_name("receipt");
   set_short( "missing item receipt" );
   _obname = "unknown object";
   _obpath = "***";
   set_value(5);
   set_weight(1);
   add_adjective(({"missing", "item"}));
   add_property("writeable", 1);
   add_property("sale_value", 1);
   add_property("paper", 1);
   add_property("nosteal", 1);
   set_max_size(1000);
   _timestamp = time();
} /* setup() */

void init() {
    this_player()->add_command("kiss", this_object());
} /* init() */

/**
 * Sets the name of the object.  This will be used so the item recipt
 * can be identified.
 * @param s the object name
 */
void set_obname(string s) { _obname = s; }

/**
 * Sets the path to the object.  The path of the object for the recipt to
 * work with.
 * @param s the object path
 */
void set_object(string s) { _obpath = s; }

/**
 * This method is identical to set_object()
 * @param s the object path
 */
void set_obpath(string s) { set_object(s); }

/**
 * This method sets the virtual object name of the item.
 * @param s the virtual object name
 */
void set_virtobname(string s) { _virt_name = s; }

/**
 * This method is identical to set_virtobname()
 * @param s the virtual object name
 */
void set_virtname(string s) { set_virtobname(s); }


/**
 * This method sets the save information for the file.  It actually sets
 * both the static and dynamic information.  This assumes it is passed
 * an array of two elements, the first is the static save information and
 * the second is the dynamic save information.
 * @param m the data as defined above
 */
void set_static_save(mixed m) {
  mixed p;

  _static_save = m;
  if (_obname != "unknown object") {
    return;
  }

  // Try to find the short in here somewhere
  p = m[0];
  while (mapp(p)) {
    if (!undefinedp(p["short"])) {
      _obname = p["short"];
      return;
    }
    p = p["::"];
  }
}

/**
 * This method sets up the receipt for the specified object.
 * @param ob the object to setup the reciept for
 */
void setup_receipt(object ob) {
   mixed* bits;

   bits = AUTO_LOAD_OB->fragile_auto_str_ob(ob);
   set_obname(ob->query_name());
   set_object(bits[1]);
   set_static_save(bits[2]);
   set_value(ob->query_value());

   if(_obpath == "/obj/misc/al_receipt") {
     log_file("BAD_RECEIPTS", "%s: set by %s\n",
              ctime(time())[4..18], base_name(previous_object()));
     call_out("dest_me", 2);
   }
} /* setup_receipt() */

/**
 * When the item is sold, kill ourselves.
 */
void being_sold()
{
    call_out("dest_me", 4);
} /* being_sold() */

/** @ignore yes */
string long(string str, int light)
{
   return "This is a receipt for your missing " + _obname + ".  You can either "
      "sell it for something which may be close to replacement value (and may 
not), "
      "or give it to a creator and ask very nicely to have it replaced.\n"
      "You can also try kissing it - who knows, you may get lucky.\n";
} /* long() */

/** @ignore yes */
mapping query_dynamic_auto_load()
{
   return ([ "::" : ::query_dynamic_auto_load(),
             "obname" : _obname,
             "obpath" : _obpath,
             "obvalue" : value,
             "virt" : _virt_name,
             "timestamp" : _timestamp,
             "static" : _static_save ]);
} /* query_dynamic_auto_load() */

/** @ignore yes */
void init_dynamic_arg(mapping arg, object) {
   _obname = arg["obname"];
   if ( stringp( _obname ) ) {
      add_adjective( explode( lower_case( _obname ), " " ) );
   }
   _obpath = arg["obpath"];
   set_value(arg["obvalue"]);
   _virt_name = arg["virt"];
   _timestamp = arg["timestamp"];
   _static_save = arg["static"];
   ::init_dynamic_arg(arg["::"]);

   if(_obpath == "/obj/misc/al_receipt") {
     call_out("dest_me", 2);
   }
}

/**
 * This method returns the name of the object.
 * @return the name of the object
 */
string query_obname() { return _obname; }
/**
 * This method returns the path of the object.
 * @return the path of the object
 */
string query_obpath() { return _obpath; }
/**
 * This method returns the timestamp of the reciept.  This is the time the
 * receipt was created.
 * @return the timestamp
 */
int query_timestamp() { return _timestamp; }
/**
 * This method returns the virtual object path name of the item.
 * @return the virtual object name
 */
string query_virt_obname() { return _virt_name; }
/**
 * This method returns the save information for the object.  THis is not
 * just the static save information, it is an array of two elements.  The
 * first is the static save information and the second is the dynamic
 * save information.
 * @return the save information
 */
mixed query_static_save() { return _static_save; }

/**
 * This will return 1 if the item is a missing item receipt.
 * @return 1 if the item is a missing item receipt
 */
int query_missing_item_receipt() {
   return 1;
}

/** @ignore yes */
mixed *stats()
{
  mixed *stuff;

  stuff = ::stats() + ({
      ({ "obname", _obname }),
      ({ "obpath", _obpath }),
      ({ "timestamp", _timestamp + " (" + ctime(_timestamp) + ")" }),
   });
  if (_virt_name)
    stuff += ({ ({ "virtname", _virt_name }) });
  return stuff;
} /* stats() */

/** @ignore yes */
int do_kiss() {
    object thing;

    if (sizeof(_static_save) < 2) {
        if (this_player()->query_creator()) {
            write("This receipt has no auto-load information, possibly "
                  "because the object was broken when the player logged "
                  "out.  It will have to be replaced by hand.\n");
        } else {
            write("Sorry, but this object is too broken to repair "
                  "with a kiss.  You'll have to contact a creator.\n");
        }
        return 1;
    }
    if ((query_cloned_by() != this_player()->query_name())
        && !this_player()->query_creator()) {
        write("The receipt whispers: I don't belong to you!\n");
        return 1;
    }

    // If we have virtual names, try and fiddle with this.
    if (_virt_name) {
       _virt_name = CLONER->other_file( _virt_name );
       if (file_size(_virt_name) <= 0) {
          // try and rewrite through the armoury
          _virt_name = ARMOURY->remap_file_path(_virt_name);
       }
       if (file_size(_virt_name) <= 0) {
           write("The receipt whispers: Sorry, I'm still broken.  "
                 "Try again some other time, or contact a creator.\n");
           return 1;
       }
    }

    if ( !catch( thing = (object)CLONER->clone( _obpath ) ) ) {
        if ( thing ) {
            thing->init_static_arg(_static_save[0]);
            thing->init_dynamic_arg(_static_save[1]);
            if (!thing->move( environment(this_object()) )
                || !thing->move( environment(environment(this_object())) )) {
                thing->add_property(VIRTUAL_NAME_PROP, _virt_name);
                write(the_short() + " suddenly transforms itself into " +
                      thing->a_short() + ".\n");
                tell_room(environment(this_player()),
                          this_player()->the_short() +
                          " kisses a piece of paper, which suddenly "
                          "transforms into " + thing->a_short() + ".\n",
                          ({ this_player() }));
                this_player()->add_succeeded_mess(this_object(), "", ({ }));
                move("/room/rubbish");
            } else {
                write("The receipt whispers: I'm going to need some "
                      "creator help.\n");
                thing->dest_me();
            }
        } else {
            write("The receipt whispers: Sorry, I'm still broken.  "
                  "Try again some other time, or contact a creator.\n");
        }
    } else {
        write("The receipt whispers: Sorry, I'm still broken.  "
              "Try again some other time, or contact a creator.\n");
    }
    return 1;
} /* do_kiss() */


varargs int move(mixed dest, string messin, string messout)  {
   if (!objectp(dest))  {
      if (!stringp(dest)  ||  (dest = find_object(dest)) == 0)  {
         return MOVE_EMPTY_DEST;
      }
   }

   if (::move(dest, messin, messout) != MOVE_OK)  {
      if (environment(dest))  {
         return move(environment(dest), messin, messout);
      }
      else  {
         return MOVE_INVALID_DEST;
      }
   }
   return MOVE_OK;
} /* move() */
// --- END [/mnt/home2/grok/lib/obj/misc/al_receipt.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/active_toy.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/active_toy.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628059   Available: 13575413
Inodes: Total: 5242880    Free: 4960134
3752 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/active_toy.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628059   Available: 13575413
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/** 
 * Active Toy object.
 * @author Hobbes
 */

inherit "/std/object";
inherit "/std/basic/item_chat";

string hug, pet, cuddle, fondle, snuggle, squeeze, spank;

void set_hug( string words ) { hug = words; }

void set_pet( string words ) { pet = words; }

void set_cuddle( string words ) { cuddle = words; }

void set_fondle( string words ) { fondle = words; }

void set_snuggle( string words ) { snuggle = words; }

void set_squeeze( string words ) { squeeze = words; }

void set_spank( string words ) { spank = words; }

void init() {
   item_chat::init();
   this_player()->add_command( "hug", this_object() );
   this_player()->add_command( "pet", this_object() );
   this_player()->add_command( "cuddle", this_object() );
   this_player()->add_command( "fondle", this_object() );
   this_player()->add_command( "snuggle", this_object() );
   this_player()->add_command( "squeeze", this_object() );
   this_player()->add_command( "spank", this_object() );
} /* init() */

int do_hug() {
  if (!sizeof (hug)) {
    return 0;
  }  
   this_player()->add_succeeded_mess( this_object(), replace_string( hug,
         "$poss_short$", poss_short() ), ({ }) );
   return 1;
} /* do_hug() */

int do_pet() {
  if (!sizeof (pet)) {
    return 0;
  }  
   this_player()->add_succeeded_mess( this_object(), replace_string( pet,
         "$poss_short$", poss_short() ), ({ }) );
   return 1;
} /* do_pet() */

int do_cuddle() {
  if (!sizeof (cuddle)) {
    return 0;
  }  
   this_player()->add_succeeded_mess( this_object(), replace_string( cuddle,
         "$poss_short$", poss_short() ), ({ }) );
   return 1;
} /* do_cuddle() */

int do_fondle() {
  if (!sizeof (fondle)) {
    return 0;
  }    
   this_player()->add_succeeded_mess( this_object(), replace_string( fondle,
         "$poss_short$", poss_short() ), ({ }) );
   return 1;
} /* do_fondle() */

int do_snuggle() {
  if (!sizeof (snuggle)) {
    return 0;
  }  
   this_player()->add_succeeded_mess( this_object(), replace_string( snuggle,
         "$poss_short$", poss_short() ), ({ }) );
   return 1;
} /* do_snuggle() */

int do_squeeze() {
  if (!sizeof (squeeze)) {
    return 0;
  }    
   this_player()->add_succeeded_mess( this_object(), replace_string( squeeze,
         "$poss_short$", poss_short() ), ({ }) );
   return 1;
} /* do_squeeze() */

int do_spank() {
  if (!sizeof (spank)) {
    return 0;
  }    
   this_player()->add_succeeded_mess( this_object(), replace_string( spank,
         "$poss_short$", poss_short() ), ({ }) );
   return 1;
} /* do_spank() */

mapping query_static_auto_load() {
//   if ( explode( file_name( this_object() ), "#" )[ 0 ] !=
//         "/obj/misc/active_toy" )
//      return 0;
   return ([
      "::" : int_query_static_auto_load(),
      "hug" : hug,
      "pet" : pet,
      "cuddle" : cuddle,
      "fondle" : fondle,
      "snuggle" : snuggle,
      "squeeze" : squeeze,
      "spank" : spank
   ]);
} /* query_static_auto_load() */

mapping query_dynamic_auto_load() {
   mapping tmp;

   tmp = ([ "::" : object::query_dynamic_auto_load(),
            "chat" : item_chat::query_dynamic_auto_load(),
          ]);
   return tmp;
} /* query_dynamic_auto_load() */

void init_dynamic_arg(mapping map) {
   if ( !map )
      return;
   if (map["::"])
      object::init_dynamic_arg(map["::"]);
   if (map["chat"])
      item_chat::init_dynamic_arg(map["chat"]);
} /* init_dynamic_arg() */

void init_static_arg( mapping map ) {
   if ( !map )
      return;
   if ( map[ "::" ] )
      ::init_static_arg( map[ "::" ] );
   hug = map[ "hug" ];
   pet = map[ "pet" ];
   cuddle = map[ "cuddle" ];
   fondle = map[ "fondle" ];
   snuggle = map[ "snuggle" ];
   squeeze = map[ "squeeze" ];
   spank = map[ "spank" ];
} /* init_static_arg() */
// --- END [/mnt/home2/grok/lib/obj/misc/active_toy.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/camera.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/camera.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628058   Available: 13575412
Inodes: Total: 5242880    Free: 4960134
7316 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/camera.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628058   Available: 13575412
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/* change log */

/*  26/6/93   Add in codes by LIFE so that the object can actually be
 *            used to take photos instead of just a useless lump.
 *            Godot's original setup() is mostly kept but all the rest
 *            are my own code. 
 */

#include <weather.h>

inherit "/std/object";

int  colour;
int  black_white;
int  scene;

void setup() {
  colour = 2;
  black_white = 4;
  scene = 1;

  set_name( "box" );
  add_adjective( ({ "heavy" , "black" }) );
  set_short( "heavy black cube" );
  set_main_plural( "heavy black cubes" );
  set_long( "You see a heavy black box with a window on one side.  "
            "Looking through the window, you notice a tiny demon sitting "
            "patiently next to a miniscule painter's easel.\n" );
  set_weight( 10 );
  add_alias( ({ "cube" , "camera" }) );
  add_plurals(({ "cubes", "cameras"}));
  adjust_money( 1 , "gold" );
  add_help_file("camera");
/*
  set_read_mess("To make the demon paint the picture, simply \"use"
                " camera on <subject>\".\n", "common", 1);
 */
}
 

void init() {   
    add_command("use", "<direct:object> on <indirect:object>");
    add_command("use", "<direct:object>");
}

int query_colour()      { return colour;  }
int query_black_white() { return black_white;  }

int do_use(object *obs) {   
  int i;
  string view;
  string photo_of;
  string chars_sorted;
  string things_sorted;
  object *players;
  object *chars;
  object *things;
  object  photo;
  object  env;
  object *yes;
   
  players = ({ });
  chars = ({ });
  things = ({ });
  yes = ({ });
  view = "";
  photo_of = "";
  chars_sorted = "";
  things_sorted = "";
 
  env = environment(this_player()) ;
  photo_of = "This is a beautiful "; 

  if (env->query_light() < 60) {
    this_player()->add_failed_mess(this_object(),
                                   "The little imp whispers: Hey! "
                                   "Not everyone like you can see "
                                   "in the dark you know.\n",({ }));
    return 0;
  }
  
  if (env->query_light() >180) {
    this_player()->add_failed_mess(this_object(),
                                   "The little demon said quietly: "
                                   "Could I have a pair of sunspecs "
                                   "please! Not too much to ask, is it?\n",
                                   ({ }));
    return 0;
  }
  
  if (black_white <= 0) {
    call_out("out_of_paint", 0, env);
    this_player()->add_failed_mess(this_object(), 
                                   "The little imp gives up painting "
                                   "for you.\n",({ }));
    return 0;
  }
  
  if (colour > 1) {
    photo_of += "colour ";
    colour --;
  } else if (colour == 1) {
    photo_of += "colour ";
    call_out("out_of_colour", 2, env); 
    colour --;
  } else {
    photo_of += "black and white ";
    black_white --;
  }

  if (sizeof(obs)) {
    for (i=0;i<sizeof(obs);i++) {
      if (obs[i]->query_property("player")) {
        players += ({ obs[i] });
        this_player()->add_succeeded(obs[i]);
        yes  += ({ obs[i] });
      } else if (obs[i]->query_property("npc")) {
        chars   += ({ obs[i] });
        this_player()->add_succeeded(obs[i]);
        yes  += ({ obs[i] });
      } else {
        if (environment(obs[i]) != this_player()) {
          things  += ({ obs[i] });
          this_player()->add_succeeded(obs[i]);
          yes  += ({ obs[i] });
        }
      }
      
    }
    chars_sorted = query_multiple_short(chars);

    things_sorted = query_multiple_short(things);
    
    if (chars_sorted || things_sorted || sizeof(players)) {
      scene = 0;
    }
  }

  view = env->query_long();

  if(view[sizeof(view)-1] != 10)
    view += "\n";
  
  if(env->query_property("location") == "outside" &&
     !env->query_weather_obscured(WEATHER->query_day())) {
    view = WEATHER->weather_string(env) + ".  " + view;
  }
  
  photo_of += "picture of " + env->a_short() + ".";

  if (scene == 0) {
    if ((sizeof(chars)+sizeof(players)) == 1) {
      if (sizeof(chars) == 1) {
        view += capitalize( (string)chars[0]->query_short() ) +
          " is here smiling.\n";
      } else if (sizeof(players) == 1) {
        view += players[0]->one_short() +" is here smiling.\n";
      }
    } else if ((sizeof(players)+sizeof(chars)) > 1) {
      for(i=0;i<sizeof(players);i++) {
        view += players[i]->one_short() ;
        if (i < (sizeof(players)-1)) {
          view += ", ";
        }
      }

      if (chars_sorted != "" && sizeof(players) > 0) {
        view += ", " + chars_sorted ;
      } else if (chars_sorted != "") {
        view += capitalize(chars_sorted) ;
      }
      view += " are smiling here.\n";
    }   

    if (sizeof(things) == 1) {
      
      view += "There is a "+ things_sorted +" in the photo.\n";
    } else if ( sizeof( things ) ) {
      view += "There are " + things_sorted+" lying here in the photo.\n" ;
    }
  }
  
  photo = clone_object("/std/object");
  photo->set_name("glass");
  photo->add_adjective( ({"tiny", "square"}) );
  photo->set_short("tiny square of glass");
  photo->set_main_plural("tiny squares of glass");
  photo->set_long("/global/events"->convert_message(view));
  photo->set_read_mess(photo_of);
  photo->add_property("photographer", (string)this_player()->query_name()) ;
  photo->move(this_player());
  
  if (scene == 0) {
    this_player()->add_succeeded_mess(this_object(),
                                      "$N $V $D on $I. After some frantic "
                                      "sounds of pens scratching and "
                                      "brushes brushing, a tiny "
                                      "demon inside hands a piece of painted "
                                      "glass to $N.\n", yes);
  } else {
    this_player()->add_succeeded_mess(this_object(),
                                      "$N $V $D on the scenery. After some "
                                      "frantic sounds of pens scratching "
                                      "and brushes brushing, a "
                                      "tiny demon inside hands a piece "
                                      "of painted glass to $N.\n");
  }
  
  return 1;
}

mapping query_static_auto_load() {
  return ([ "colour" : colour,
          "black_white" : black_white ]);
}

void init_static_arg(mapping map) {
  colour = map["colour"];
  black_white = map["black_white"];
}

void out_of_paint(object room) {    
  tell_object(this_player(), "The tiny demon whispers sarcastically: "
              "Without any more paints, I can still paint "
              "you invisible picture if you like!\n");
  tell_room(room, "The tiny demon in the cube whispers something about "
            "paints to "+ this_player()->one_short() +".\n",
            this_player());
  
}

void out_of_colour(object room) {
  tell_object(this_player(), "The tiny demon whispers: There are no more "
              "colour paints. This picture is the "
              "last colour one. I can only do you "
              "black and white pictures from now!\n");
  tell_room(room, "The tiny demon in the cube whispers something about "
            "colour to "+ this_player()->one_short() +".\n",
            this_player());
}

// --- END [/mnt/home2/grok/lib/obj/misc/camera.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/envelope.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/envelope.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628056   Available: 13575410
Inodes: Total: 5242880    Free: 4960134
4807 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/envelope.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628056   Available: 13575410
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * Paper envelopes that can be written on, closed, sealed and unsealed.  Use
 * a call to "make_envelope()" to set the size and description of the
 * envelope.
 * @author Lemming
 * @started 7/1/2000
 */

#define SMALL   3
#define MEDIUM  5
#define LARGE   8

#define UNSEALED  1
#define SEALED    2
#define OPENED    3

inherit "/obj/baggage";

nosave int status;

/**
 * This is the method used to define the envelope.  It works just like the
 * "make_bottle()" call on "/obj/bottle.c", and must be done whenever one is
 * created.  The description should be short and should not include the size
 * of the envelope - this will be inferred from the size specified.  A size
 * of 3 or less will be "small", 4 to 5 will be "medium", 6 to 8 is "large"
 * and anything over that will be a "large packet".  The default and minimum
 * size is 2.
 * @param description a brief description of the envelope
 * @param size the maximum weight of the envelope plus contents
 * @example
 * // Make "a small pink envelope".
 * make_envelope( "pink", 3 );
 * @example
 * // Make "a large frog flavoured packet"
 * make_envelope( "frog flavoured", 10 );
 * @see query_envelope_status()
 */
void make_envelope( string description, int size ) {
   string adjective, noun;

   if( size < 2 )
      size = 2;

   switch( size ) {
      case 0..SMALL:
         adjective = "small";
         noun = "envelope";
         break;
      case SMALL + 1..MEDIUM:
         adjective = "medium sized";
         noun = "envelope";
         break;
      case MEDIUM + 1..LARGE:
         adjective = "large";
         noun = "envelope";
         break;
      default:
         adjective = "large";
         noun = "packet";
         add_alias("packet");
   }

   set_name( "envelope" );
   set_short( adjective + " " + description + " " + noun );
   add_adjective( adjective );
   add_adjective( explode( description, " " ) );
   set_long( "This is a " + adjective + " " + description + " envelope.  " );
   set_weight( 1 );
   set_value( 300 + size * 20 );
   set_max_weight( size );
   set_material( "paper" );
   add_property( "writeable", 1 );
   add_extra_look( this_object() );

   status = UNSEALED;
} /* setup() */

/** @ignore */
void init() {
   ::init();
   this_player()->add_command( "seal", this_object(),
      "<direct:object:me>" );
   this_player()->add_command( "unseal", this_object(),
      "<direct:object:me>" );
} /* init() */

/** @ignore */
string long( string str, int dark ) {
   string desc;

   switch( status ) {
   case UNSEALED :
      desc = "It has a sticky flap at one end with which you could "
         "probably seal it if you wanted to, though it might be wise to put "
         "something into it first or you're going to feel rather silly.\n";
      break;
   case SEALED :
      desc = "The sticky flap seems to have been sealed down.\n";
      break;
   case OPENED :
      desc = "It looks like it has been sealed and then opened up.\n";
      break;
   default :
      desc = "It is completely broken - you'd better tell a liaison.\n";
   }

   return ::long( str, dark ) + desc;
} /* long() */

/** @ignore */
int do_seal() {
   if( status != UNSEALED ) {
      return notify_fail( this_object()->the_short() + " has already been "
         "sealed.\n" );
   }

   do_close();
   set_stuck( 1 );
   status = SEALED;
   this_player()->add_succeeded_mess( this_object(), "$N lick$s the flap on "
      "$D and seal$s it down.\n", ({ }) );
   return 1;
} /* do_seal() */

/** @ignore */
int do_unseal() {
   if( status != SEALED ) {
      return notify_fail( this_object()->the_short() + " has not been "
         "sealed.\n" );
   }

   set_stuck( 0 );
   do_open();
   status = OPENED;
   this_player()->add_succeeded_mess( this_object(), "$N tear$s back the "
      "flap on $D and open$s it.\n", ({ }) );
   return 1;
} /* do_seal() */

/**
 * This is the method used to query what status the envelope is in.
 * @return 1 for unsealed, 2 for sealed, 3 for sealed and then torn open
 * @see make_envelope()
 */
int query_envelope_status() {
   return status;
} /* query_envelope_status() */

/** @ignore */
mixed *stats() {
   return ::stats() + ({
      ({ "status", status, }),
   });
} /* stats() */

/** @ignore */
mapping int_query_static_auto_load() {
   return ([
      "::" : ::int_query_static_auto_load(),
      "status" : status,
   ]);
} /* int_query_static_auto_load() */

/** @ignore */
void init_static_arg( mapping map ) {
   if( map["::"] )
      ::init_static_arg( map["::"] );
   if( !undefinedp( map["status"] ) )
      status = map["status"];
} /* init_static_arg() */

/** @ignore */
mixed query_static_auto_load() {
   if( base_name( this_object() ) + ".c" == __FILE__ )
      return int_query_static_auto_load();
   return ([ ]);
} /* query_static_auto_load() */
// --- END [/mnt/home2/grok/lib/obj/misc/envelope.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/bank_credit_note.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/bank_credit_note.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628054   Available: 13575408
Inodes: Total: 5242880    Free: 4960134
4987 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/bank_credit_note.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628054   Available: 13575408
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * A credit note for transfering money to and from a franchise and a
 * master shop.
 * @author Pinkfish
 * @started Thu Jun 28 16:46:26 PDT 2001
 */
inherit "/std/object";
#include <money.h>

#define OBJECT_TAG "credit note"

private int _id;
private int _amount;
private string _franchise;
private string _bank;

void setup() {
   set_name("note");
   set_short("bank credit note");
   add_adjective( ({ "bank", "credit" }) );
   set_long("A small piece of paper which looks like some sort of "
            "bank transaction slip.\n");
   set_value(0);
   set_weight(1);
} /* setup() */

/**
 * This method is called to setup the read messages for the note once it
 * is made.
 */
void setup_read_messages() {
   string extra;
   string place;

   place = query_property("place");
   if (_amount < 0) {
     extra = "Agrees to pay " +
             MONEY_HAND->money_value_string(-_amount, place) +
             " to the master bank.\n";
   } else {
     extra = "Slip for a withdrawl of " +
             MONEY_HAND->money_value_string(-_amount, place) +
             " from the master bank.\n";
   }
   add_read_mess("Credit note #" + _id + " for the bank " +
                    _bank + " from the franchise " +
                    _franchise->query_address() + ".\n\n" + extra,
                    0, "common", 0);
} /* setup_read_messages() */

/**
 * This method sets the credit number id for the credit note.  This will
 * be unique for each franchise.
 * @param num the credit id
 */
void set_credit_num(int num) {
   _id = num;
} /* set_credit_num() */

/**
 * This method returns the credit number id for the credit not.
 * @return the credit id
 */
int query_credit_num() {
   return _id;
} /* query_credit_num() */

/**
 * This method sets the bank name of the credit note.
 * @param bank set the bank name
 */
void set_bank_name(string bank) {
   _bank = bank;
} /* set_bank_name() */

/**
 * This method returns the bank name for the credit note.
 * @return the bank name
 */
string query_bank_name() {
   return _bank;
} /* query_bank_name() */

/**
 * This method sets the franchise that will be used as the main base for
 * this credit note.
 * @param franchise the franchise as the base
 */
void set_franchise(string franchise) {
   _franchise = franchise;
} /* set_franchise() */

/**
 * This method returns the franchise for the credit note
 * @return this returns the franchise for the note
 */
string query_franchise() {
   return _franchise;
} /* query_franchise() */

/**
 * This method sets the amount the credit note is for.  +ve means that
 * we are transporting money to the master bank, -ve means we are taking
 * money out of the master bank.
 * @param amount the amount the note is for
 */
void set_amount(int amount) {
   _amount = amount;
} /* set_amount() */

/**
 * This method returns the amount the credit note is for.
 * @return the amount the note is for
 */
int query_amount() {
   return _amount;
} /* query_amount() */

/**
 * This checks to see if the note is valid still or not.
 */
int is_valid_note() {
   object bank;
   object* obs;
   object ob;
   int ret;

   bank = load_object(query_franchise());
   obs = bank->find_commercial_items("bank");
   //obs = filter(obs, (: $1->query_bank() :));
   if (sizeof(obs)) {
      foreach (ob in obs) {
         ret = ob->is_valid_note(query_credit_num());
         if (ret) {
            return 1;
         }
      }
   }
   return 0;
} /* is_valid_note() */

/**
 * This marks this credit note as processed.
 */
int do_process() {
   object bank;
   object* obs;
   object ob;
   int ret;

   bank = load_object(query_franchise());
   obs = bank->find_commercial_items("bank");
   //obs = filter(obs, (: $1->query_bank() :));
   if (sizeof(obs)) {
      foreach (ob in obs) {
         ret = ob->process_note(query_credit_num());
         if (ret) {
            return 1;
         }
      }
   }
   return 0;
} /* do_process() */

/** @ignore yes */
mixed* stats() {
   return ::stats() +
          ({ ({ "credit amount", query_amount() }),
             ({ "franchise", query_franchise() }),
             ({ "credit id", query_credit_num() }), });
} /* stats() */

/** @ignore yes */
mapping query_dynamic_auto_load() {
   mapping map;

   map = ::query_dynamic_auto_load();
   add_auto_load_value(map, OBJECT_TAG, "amount", query_amount());
   add_auto_load_value(map, OBJECT_TAG, "franchise", query_franchise());
   add_auto_load_value(map, OBJECT_TAG, "id", query_credit_num());
   add_auto_load_value(map, OBJECT_TAG, "bank", query_bank_name());
   return map;
} /* query_dynamic_auto_load() */

/** @ignore yes */
void init_dynamic_arg(mapping map) {
   ::init_dynamic_arg(map);

   set_amount(query_auto_load_value(map, OBJECT_TAG, "amount"));   
   set_franchise(query_auto_load_value(map, OBJECT_TAG, "franchise"));   
   set_credit_num(query_auto_load_value(map, OBJECT_TAG, "id"));   
   set_bank_name(query_auto_load_value(map, OBJECT_TAG, "bank"));   
} /* init_dynamic_arg() */
// --- END [/mnt/home2/grok/lib/obj/misc/bank_credit_note.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/golem_eye.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/golem_eye.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628053   Available: 13575407
Inodes: Total: 5242880    Free: 4960134
433 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/golem_eye.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628053   Available: 13575407
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*
 * $Id$
 */

/* Eye of a golem */

inherit "/std/object";

void setup() {
    set_name( "triangle" );
    set_short( "clay triangle" );
    add_adjective( ({"clay"}) );
    set_long( "This is a cracked piece of clay.  A hole in the shape of a "
       "triangle is in its middle.\n" );
    set_main_plural( "clay triangles" );
    set_weight( 5 );
    set_value( 0 );
    add_property( "no recycling", 1 );
} /* void setup() */


// --- END [/mnt/home2/grok/lib/obj/misc/golem_eye.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/juicer.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/juicer.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628053   Available: 13575407
Inodes: Total: 5242880    Free: 4960134
5588 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/juicer.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628053   Available: 13575407
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include  <bit.h>

inherit "/obj/vessel";

int juice_bit( object ob, string fn );

mapping juice_funs = ([
  "/std/bit" : (: juice_bit :),
]);

void setup() {
  set_name( "juicer" );
  set_short( "juicer" );
  set_main_plural( "juicers" );
  set_long( "This is a device for extracting the juice or liquid from " +
            "objects.  It has a hole at the top for inserting things, " +
            "and a small bowl at the bottom to catch the juice.  You " +
            "could probably \"juice\" something and then \"pour\" " +
            "the juicer into another container.\n" );
  set_value( 4000 );
  set_weight( 100 );
  set_max_volume( 19200 );
} /* setup() */

void init() {
  ::init();
  this_player()->add_command( "juice", this_object(), "%I 'in' %D" );
} /* init() */

int do_juice( object *things ) {
  int i, amount, *weight_unit, percent;
  string medium_short, *types, fn;
  mapping amount_types;

  if ( living( environment() ) ) {
    this_player()->add_failed_mess( this_object(), "You have to put down "+
        "$D to use it.\n", ({ }) );
    return 0;
  }
  for ( i = 0; i < sizeof( things ); i++ )
    if ( environment( things[ i ] ) != this_player() ) {
      things = delete( things, i, 1 );
      i--;
    }
  if ( !sizeof( things ) ) {
    this_player()->add_failed_mess( this_object(), "You should be carrying "+
        "whatever you want to $V in $D", ({ }) );
    return 0;
  }
  if ( sizeof( things ) > 1 ) {
    this_player()->add_failed_mess( this_object(), "You should only $V "+
        "one thing at a time in $D in case they get mixed up.\n", ({ }) );
    return 0;
  }
  if ( !function_exists( "query_continuous", things[ 0 ] ) ) {
    if ( fn = things[ 0 ]->query_property("juice")
        && functionp( juice_funs[ fn ] )) {
      return evaluate( juice_funs[ fn ], things[ 0 ], fn );
    }
    fn = explode(file_name(things[ 0 ]), "#")[ 0 ];
    if (functionp( juice_funs[ fn ] )) {
      return evaluate( juice_funs[ fn ], things[ 0 ], fn );
    }
    this_player()->add_failed_mess( this_object(), "You cannot $V $I "+
        "in $D.  Trust me on this.\n", ({ things[ 0 ] }) );
    return 0;
  }
  if ( !(percent = things[ 0 ]->query_property("%liquid")) ) {
    this_player()->add_failed_mess( this_object(), "$I apparently doesn't " +
        "contain much juice.\n", ({ things[ 0 ] }) );
    things[ 0 ]->move("/room/rubbish");
    return 0;
  }
  things[ 0 ]->add_plural( (string)things[ 0 ]->query_name() );
/* The weight unit has been set or is still the default.  Either is fine. */
  if ((amount = (int)things[ 0 ]->query_amount()) == 0) {
    weight_unit = (int *)things[ 0 ]->query_weight_unit();
    amount = ( weight_unit[ 1 ] * (int)things[ 0 ]->query_weight() ) /
      weight_unit[ 0 ];
    amount = ( ( 50 + random( 21 ) ) * amount ) / 80;
  }
  things[ 0 ]->set_amount( amount*percent/100 );
  things[ 0 ]->set_weight_per_bite( 0 );
  things[ 0 ]->set_bites_gone( 0 );
  medium_short = (string)things[ 0 ]->query_medium_short();
  if ( !medium_short )
    medium_short = (string)things[ 0 ]->query_short();
  if ( !things[ 0 ]->query_medium_alias() )
    things[ 0 ]->set_medium_alias( "Ground"+ capitalize( medium_short ) );
/* In fact, if the continuous medium details are not set and the object
 *     returns ([ ]) to query_static_auto_load() the object will fail
 *     dismally on autoloading next time.  Hope the person who created
 *     the object knows this and set it up properly...
 */
  amount_types = ([ "drop" : ({ 1, "drops" }), "ounce" :
        ({ 120, "ounces" }), "pint" : ({ 2400, "pints" }) ]);
  things[ 0 ]->set_amount_types( amount_types );
  types = m_indices( amount_types );
  for ( i = 0; i < sizeof( types ); i++ )
    things[ 0 ]->add_adjective( ({ types[ i ],
        amount_types[ types[ i ] ][ 1 ] }) );
  things[ 0 ]->add_adjective( "of" );
  if ( !sizeof( (mixed *)things[ 0 ]->query_pile_types() ) )
    things[ 0 ]->set_pile_types( ({ 50, "small", 2400, "medium", 19200,
        "large", "huge" }) );
  things[ 0 ]->add_property( "determinate", "some " );
  things[ 0 ]->grind();
  things[ 0 ]->move( this_object() );
  this_player()->add_succeeded_mess( this_object(), "$N $V $D to make $I.\n",
      ({ things[ 0 ] }) );
  return 1;
} /* do_grind() */

int juice_bit( object ob, string fn ) {
    object juice_ob;
    mixed *bit_data;
    string *m, s;
    int i;
    
    juice_ob = clone_object("/obj/reagents/generic_liquid.ob");
    juice_ob->set_name("juice");
    // Create medium alias
    if (s = ob->query_race_name())
      s = capitalize(s);
    bit_data = ob->query_bit_data();
    m = explode(bit_data[ BIT_NAME ], " ");
    for ( i = 0; i < sizeof(m); i++ )
      s += capitalize(m[i]?m[i]:"");
    juice_ob->set_medium_alias(s+"Juice");
    switch ( bit_data[ BIT_ALIAS ] ) {
      case "eye":
        juice_ob->add_adjective("eye");
        juice_ob->add_alias("ichor");
        juice_ob->set_short("clear liquid");
        juice_ob->set_long("This is a clear liquid, slightly tinged" +
                           "with blood.\n");
        juice_ob->set_amount(10*(int)ob->query_weight() + 10);
        break;
      default:
        // For things I haven't foreseen...
        juice_ob->set_short("liquid");
        juice_ob->set_long("This is a non-descript liquid.  It's probably " +
                           "useless.\n");
        break;
    }
    juice_ob->move(this_object());
    ob->move("/room/rubbish");
    this_player()->add_succeeded_mess( this_object(), "$N $V $D to make $I.\n",
                                      ({ juice_ob }) );
    return 1;
}
// --- END [/mnt/home2/grok/lib/obj/misc/juicer.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/trap.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/trap.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628051   Available: 13575405
Inodes: Total: 5242880    Free: 4960134
5802 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/trap.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628051   Available: 13575405
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* A simple trap object that can be used to trap any item that uses
 * /std/basic/trap
 */
#include <move_failures.h>
#include <tasks.h>

inherit "/std/object";

int difficulty;
string trigger;
string description;
mixed message;
mixed effect;

/** @ignore yes */
void create() {
  add_help_file("door_trap");
  do_setup++;
  ::create();
  do_setup--;
  if ( !do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }
}

void make_trap(int diff, string trig, string desc, mixed mess, mixed eff) {
  difficulty = diff;
  trigger = trig;
  description = desc;
  message = mess;
  effect = eff;
}

/** @ignore yes */
void init() {
  this_player()->add_command("rig", this_object(),
           "<indirect:object:here> with <direct:object:me>");
}

int do_rig(mixed *in_dir, string direct, string indirect, mixed *args,
             string) {
  object ob;
  object other;

  if(sizeof(in_dir) > 1) {
    this_player()->add_failed_mess(this_object(), "A trap can only be rigged "
                                   "on a single item.\n");
    return 0;
  }

  if(!difficulty) {
    this_player()->add_failed_mess(this_object(), "$D appears to be "
                                   "broken.\n");
    return 0;
  }
    
  ob = in_dir[0];
  
  if(ob->query_trap_difficulty() && ob->query_trap_armed()) {
    this_player()->add_failed_mess(this_object(),
                                   "$I already has an armed trap on it.\n",
                                   ({ in_dir[0] }));
    return 0;
  }

  if(!function_exists("setup_trap", ob, 0)) {
    this_player()->add_failed_mess(this_object(), "$I cannot be $Ved with "
                                   "$D.\n", ({ ob }));
    return 0;
  }
    
  if((trigger == "pick" || trigger == "unlock") && 
     (!ob->query_key() || ob->query_key() == "generic_key")) {
    this_player()->add_failed_mess(this_object(), "$I doesn't have a lock "
                                   "so $Vging it with $D which is triggered "
                                   "by " + trigger + "ing makes no sense.\n",
                                   ({ ob }));
    return 0;
  }

  switch(TASKER->perform_task(this_player(), "covert.items.traps", difficulty,
                              TM_FREE)) {
  case AWARD:
    write("%^YELLOW%^You feel you have learned something about rigging "
          "traps.%^RESET%^\n");
  case SUCCEED:
    difficulty +=
      random(this_player()->query_skill_bonus("covert.items.traps") / 10);
    break;
  default:

    // Either it goes off, or they succeed but botch it somewhat :)
    if(random(difficulty) >
       this_player()->query_skill_bonus("covert.items.traps") ||
       difficulty >
       this_player()->query_skill_bonus("covert.items.traps") * 2) {

      // display the message
      if(arrayp(message)) {
        write(message[0]);
        say(message[1], this_player());
      } else
        write(message);

      // numeric, just reduce their hps.
      if(intp(effect)) {
        if(effect > this_player()->query_hp())
          this_player()->do_death();
        else
          this_player()->adjust_hp(-(effect));
      } else if(arrayp(effect)) { // array, then add an effect with params
        switch(sizeof(effect)) {
        case 1:
          this_player()->add_effect(effect[0]);
          break;
        case 2:
          this_player()->add_effect(effect[0], effect[1]);
          break;
        default:
          this_player()->add_effect(effect[0], effect[1..]);
        }
      } else
        this_player()->add_effect(effect);

      this_object()->move("/room/rubbish");
      this_player()->add_succeeded_mess(this_object(), "As $N attempt$s to "
                                        "$V $D it goes off!\n");
      return 1;
    } else {
      difficulty -= random(difficulty -
                    this_player()->query_skill_bonus("covert.items.traps"));
    }
  }

  ob->setup_trap(difficulty, trigger, description, message, effect);

  if(function_exists("query_my_room", ob)) {
    other = load_object( (string)( ob->query_dest() ) );
    other = other->query_door_control( (string)( ob->query_other_id() ) );
    
    other->setup_trap(difficulty, trigger, description, message, effect);
    environment(this_player())->update_doors();
  }
    
  this_player()->add_succeeded_mess(this_object(), "$N carefully $V $I "
                                    "with $D.\n",
                                    ({ ob }));
  call_out("break_me", 1);
  return 1;
}

void break_me() {
  object ob;

  ob = clone_object("/std/object");
  ob->set_name("trap");
  ob->set_short("busted trap");
  ob->set_long("A broken trap.\n");
  ob->set_value(0);
  ob->set_weight(this_object()->query_weight());
  ob->move(environment());
  if(this_object()->move("/room/rubbish") != MOVE_OK)
    this_object()->dest_me();
}

mapping int_query_static_auto_load() {
  mapping tmp;
  
  tmp = ::int_query_static_auto_load();

  return ([ "::" : tmp,
            "difficulty" : difficulty,
            "trigger" : trigger,
            "description" : description,
            "message" : message,
            "effect" : effect
            ]);
}

/** @ignore yes */
mixed query_static_auto_load() {
  if ( base_name(this_object()) + ".c" == __FILE__ )
    return int_query_static_auto_load();
  return ([ ]);
}

/** @ignore yes */
void init_static_arg(mapping map) {
  if(!mapp(map))
    return;

  if(!undefinedp(map["::"]))
    ::init_static_arg(map["::"]);
  
  if(!undefinedp(map["difficulty"]))
    difficulty = map["difficulty"];
  
  if(!undefinedp(map["trigger"]))
    trigger = map["trigger"];

  if(!undefinedp(map["description"]))
    description = map["description"];

  if(!undefinedp(map["message"]))
    message = map["message"];

  if(!undefinedp(map["effect"]))
    effect = map["effect"];
}
// --- END [/mnt/home2/grok/lib/obj/misc/trap.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/case.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/case.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628049   Available: 13575403
Inodes: Total: 5242880    Free: 4960134
1949 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/case.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628049   Available: 13575403
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: case.c,v 1.1 1998/10/14 06:53:20 terano Exp $
 *
 *
 */

/*
 * $Locker:  $
 * $Id: case.c,v 1.1 1998/10/14 06:53:20 terano Exp $
 *
 *
 */

/**
 * Auction room display case
 * @author Terano
 * @started Late 1997
 */

#define READ "/cmds/living/r_ead"
inherit "/obj/baggage";

void setup() {

  set_name("case");
  set_long("This is a nice glass display case that looks out of place "
           "here, you could \"peruse\" things in it perhaps.\n");
  add_alias("container");
  add_adjective("display");
  set_transparent();
  set_weight(1000);
  set_main_plural("cases");
  set_max_weight(500000);
  reset_get();
  reset_drop();

}// end setup()

void init() {
 
  this_player()->add_command( "peruse", this_object(), 
                              "<indirect:object:direct-obs> in <direct:object>");
}

int do_peruse( object *obs ) {

  obs = filter( obs, (: environment( $1 ) == this_object() :) );

  if ( !sizeof( obs ) ) {
    add_failed_mess( "You have to browse something in the display case.\n" );
    return 0;
  }

  if ( sizeof( obs ) > 1 ) {
    add_failed_mess( "You can only browse 1 thing at a time.\n" );
    return 0;
  }
 
  write( "You peruse the "+ obs[0]->query_short() +".\n" );
  write( obs[0]->long() );
  READ->cmd( ({ obs[0] }) );
  this_player()->add_succeeded_mess( this_object(), "" );
  return 1;

}

int test_add( object item, int flag ) {

  if ( base_name( previous_object( 1 ) )[0..4] == "/cmds" ) {
    if ( this_player()->query_creator() )
      return 1;
    else return 0;
  }
  return 1;
}//end test_add


int test_remove( object item, int flag ) {
  if ( base_name( previous_object( 1 ) )[0..4] == "/cmds" ) {
    if ( this_player()->query_creator() )
      return 1;
    else return 0;
  }
  return 1;
}//end test_remove

void setup_case( string name, string long ) {
  add_alias( name );
  set_long( long + "You feel you could \"peruse\" things in it.\n" );
}// --- END [/mnt/home2/grok/lib/obj/misc/case.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/bug.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/bug.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628049   Available: 13575403
Inodes: Total: 5242880    Free: 4960134
1599 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/bug.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628049   Available: 13575403
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/object";

int no_shots;

void setup() {
   no_shots = 10;

   set_name( "bug");
   set_long( "It sits there, happier than a clam, its long black silvery "
             "legs sticking out the side.  The legs look fixed in place and "
             "there are some silvery words carved onto the top.  When you "
             "shake it, it sounds like it has something rattling around "
             "inside.  There appears to be a spray nozzle at one end.\n");
   add_read_mess("68000\n", "silver writing", "general", 0);
} /* setup() */

void init() {
  add_command("shake", "<direct:object>");
  add_command("spray", "<indirect:object> with <direct:object>");
} /* init() */

int do_shake() {
   this_player()->add_succeeded_mess(this_object(),
      "$N $V $D and you can hear something rattling around inside.\n", ({ }));
   return 1;
} /* do_shake() */

int do_spray(object *obs) {
   int i;
   int done;

   if (no_shots <= 0) {
      return 0;
   }

   done = 0;
   for (i = 0; i < sizeof(obs); i++) {
      if (no_shots > 0 && obs[i] != this_object()) {
         obs[i]->add_effect("/std/effects/object/bug_effect", 0);
         no_shots--;
         this_player()->add_succeeded(obs[i]);
         done = 1;
      }
   }
   return done;
} /* do_spray() */

mapping query_dynamic_auto_load() {
   mapping map;

   map = ([ "::" : ::query_dynamic_auto_load(),
            "shots" : no_shots ]);
   return map;
} /* query_dynamic_auto_load() */

void init_dynamic_arg(mapping map, object foo) {
   ::init_dynamic_arg(map["::"]);
   no_shots = map["shots"];
} /* init_dynamic_arg() */
// --- END [/mnt/home2/grok/lib/obj/misc/bug.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/wedding_ring.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/wedding_ring.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628048   Available: 13575402
Inodes: Total: 5242880    Free: 4960134
2459 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/wedding_ring.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628048   Available: 13575402
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "obj/armour";

string owner, giver;

void setup() {
   set_name( "ring" );
   set_short( "wedding ring" );
   add_adjective( "wedding" );
   set_long( "This is a wedding ring crafted from the purest gold from the "+
      "mines of Rimward Klatch.\n" );
   set_main_plural( "wedding rings" );
   set_type( "ring" );
   add_property( "shop type", "jewellers" );
   add_property( "no recycling", 1 );
   set_weight( 1 );
   setup_armour( 1000 );
   set_percentage( 100 );
   set_damage_chance( 0 );
   owner = giver = "nobody";
   set_wear_remove_func( file_name( this_object() ), "wear_remove" );
} /* setup() */

void do_inscription() {
   string language;
   object player;

   /*
    * Inscribed in the language of the giver, unless
    * they're not online.
    */
   player = find_player( giver );

   if( !player ) {
      player = find_player( owner );
   }
   
   language = player->query_default_language();

   set_read_mess( "\"For you, "+ capitalize( owner ) +
         ", with eternal love, "+ capitalize( giver ) +".\"", language );
} /* do_inscription() */

string query_owner() { return owner; }

void set_owner( string word ) {
  owner = lower_case( word );
  do_inscription();
} /* set_owner() */

string query_giver() { return giver; }

void set_giver( string word ) {
  giver = lower_case( word );
  do_inscription();
} /* set_giver() */

void wear_remove( int wear ) {
   // This is to prevent people getting "The ring feels uncomfortable
   // on your finger" when they kill a married PK or steal their ring.
   if( environment() != this_player() )
      return;

   if ( living( environment() )  &&  wear ) {
      if ( (string)this_player()->query_name() != owner )
         write( "The ring feels uncomfortable on your finger.\n" );
      else
         write( "You are warmed anew by "+ capitalize( giver ) +"'s love.\n" );
   }
} /* wear_remove() */

mixed *stats() {
   return ::stats() + ({
      ({ "owner", owner }),
      ({ "giver", giver }),
   });
} /* stats() */

void init_dynamic_arg( mapping args ) {
   if ( args[ "::" ] )
      ::init_dynamic_arg( args[ "::" ] );
   if ( args[ "owner" ] )
      owner = lower_case( args[ "owner" ] );
   if ( args[ "giver" ] )
      giver = lower_case( args[ "giver" ] );
} /* init_dynamic_args() */

mapping query_dynamic_auto_load() {
   return ([
      "::" : ::query_dynamic_auto_load(),
      "owner" : owner,
      "giver" : giver
   ]);
} /* query_dynamic_auto_load() */
// --- END [/mnt/home2/grok/lib/obj/misc/wedding_ring.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/newspaper_box.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/newspaper_box.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628047   Available: 13575401
Inodes: Total: 5242880    Free: 4960134
3488 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/newspaper_box.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628047   Available: 13575401
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * A dispenser for papers.  It will sell papers to people for money!
 * @author Pinkfish
 * @started Thu May 24 15:51:25 PDT 2001
 */
inherit "/std/object";
#include <room/newspaper.h>
#include <money.h>
#include <move_failures.h>

private string _paper;

void setup() {
   set_name("box");
   set_short("newspaper box");
   add_adjective("box");
   add_help_file("newspaper_box");
   reset_get();
} /* setup() */

/**
 * This sets the current paper that will be dispensed.
 * @param paper the paper to dispense
 */
void set_paper(string paper) {
   int cost;
   string place;
   string* bits;

   _paper = paper;

   place = query_property("place");
   if (!place) {
      if (environment()) {
         place = environment()->query_property("place");
      } else if (previous_object()) {
         place = previous_object()->query_property("place");
      }
   }
   cost = NEWSPAPER_HANDLER->query_paper_cost(paper);
   set_short(_paper + " box");
   set_long("This is a battered looking metal box that is full of copies of " +
            (lower_case(paper)[0..3] == "the "?"":"the ") +
            paper + ".  There is a door on the front you could pull open "
            "beside which is small white writing saying " +
            MONEY_HAND->money_value_string(cost, place) + ".\n");
   if (lower_case(_paper)[0..3] == "the ") {
      add_property("determinate", "");
   }
   bits = explode(lower_case(_paper), " ");
   add_adjective(bits);
} /* set_paper() */

/** @ignore yes */
int do_buy() {
   int cost;
   int edition;
   string place;
   object ob;
   int *editions;

   place = query_property("place");
   if (!place) {
      place = environment()->query_property("place");
   }
   cost = NEWSPAPER_HANDLER->query_paper_cost(_paper);
   edition = NEWSPAPER_HANDLER->query_last_edition_num(_paper);
   if (!edition) {
      add_failed_mess("There is no edition to buy.\n");
      return -1;
   }

   if (this_player()->query_value_in(place) < cost) {
      add_failed_mess("You do not have enough money to pay for " +
                      _paper + ", you need " +
                      MONEY_HAND->money_value_string(cost, place) +
                      ".\n");
      return -1;
   }

   this_player()->pay_money(MONEY_HAND->create_money_array(cost, place), place);

   ob = clone_object("/obj/misc/newspaper");
   ob->set_paper(_paper);
   ob->set_edition(edition);
   if (ob->move(this_player()) != MOVE_OK) {
      ob->move(environment(this_player()));
      write("Unable to move the paper into your inventory, putting it on "
            "the ground.\n");
   }

   editions = this_player()->query_property("Paper " + _paper);
   if (!editions) {
      editions = ({ });
   }
   if (member_array(edition, editions) == -1) {
      editions += ({ edition });
      this_player()->add_property("Paper " + _paper, editions);
      // We only keep track of unique sales.
      NEWSPAPER_HANDLER->add_edition_paper_sold(_paper, edition,
                        NEWSPAPER_HANDLER->query_paper_cost(_paper));
   } else {
      NEWSPAPER_HANDLER->add_edition_revenue(_paper, edition,
                        NEWSPAPER_HANDLER->query_paper_cost(_paper));
   }

   add_succeeded_mess("$N $V a paper from $D.\n");
   return 1;
} /* do_buy() */

void init() {
   add_command("buy", "paper from <direct:object>", (: do_buy() :));
   add_command("pull", "[door] [on] <direct:object>", (: do_buy() :));
   add_command("pull", "open <direct:object>", (: do_buy() :));
} /* init() */
// --- END [/mnt/home2/grok/lib/obj/misc/newspaper_box.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/oddsnends/paint_brush.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/oddsnends/paint_brush.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628046   Available: 13575400
Inodes: Total: 5242880    Free: 4960134
474 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/oddsnends/paint_brush.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628046   Available: 13575400
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*
Davyd
Item
For General Item Stores
*/

inherit "/std/object";

void setup(){
    set_name("brush");
    set_short("camel hair brush");
    add_adjective("hair");
    add_adjective("camel");
    add_adjective("paint");
    set_long("This is a small paint brush with fine camel hairs sticking "
             "out.  It looks to be better suited to the finer arts than for"
             " painting wagons with.\n");
    set_value(15);
    set_weight(15);
}// --- END [/mnt/home2/grok/lib/obj/misc/oddsnends/paint_brush.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/oddsnends/buffing_cloth.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/oddsnends/buffing_cloth.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628046   Available: 13575400
Inodes: Total: 5242880    Free: 4960134
369 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/oddsnends/buffing_cloth.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628046   Available: 13575400
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*
Davyd
Item
For General Item Stores
*/

inherit "/std/object";

void setup(){
    set_name("cloth");
    set_short("buffing cloth");
    set_main_plural("buffing cloths");
    add_adjective( "buffing" );
    set_long("This is a small, soft cloth that might be used for polishing"
	     " metal objects.\n" );
    set_value(32);
    set_weight(2);
}
// --- END [/mnt/home2/grok/lib/obj/misc/oddsnends/buffing_cloth.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/oddsnends/shoelace.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/oddsnends/shoelace.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628046   Available: 13575400
Inodes: Total: 5242880    Free: 4960134
425 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/oddsnends/shoelace.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628046   Available: 13575400
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*
Davyd
Item
For General Item Stores
*/

inherit "/std/object";

void setup(){
    set_name("lace");
    set_short("shoe lace");
    add_adjective("shoe");
    add_alias("shoelace");
    set_main_plural("shoe laces");
    add_plural("shoelaces");
    set_long("A bright yellow coloured shoelace, "
             "just the kind of thing a teenage kid would wear.\n");
    set_value(15);
    set_weight(2);
}// --- END [/mnt/home2/grok/lib/obj/misc/oddsnends/shoelace.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/oddsnends/shoehorn.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/oddsnends/shoehorn.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628045   Available: 13575399
Inodes: Total: 5242880    Free: 4960134
250 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/oddsnends/shoehorn.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628045   Available: 13575399
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*
Davyd
Item
For General Item Stores
*/

inherit "/std/object";

void setup(){
    set_name("horn");
    set_short("shoe horn");
    add_adjective("shoe");
    set_long("A normal shoe horn.\n");
    set_value(10);
    set_weight(5);
}// --- END [/mnt/home2/grok/lib/obj/misc/oddsnends/shoehorn.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/oddsnends/nail.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/oddsnends/nail.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628045   Available: 13575399
Inodes: Total: 5242880    Free: 4960134
314 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/oddsnends/nail.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628045   Available: 13575399
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*
Davyd
Item
For General Item Stores
*/

inherit "/std/object";

void setup(){
    set_name("nail");
    set_short("nail");
    set_main_plural("nails");
    set_long("A typical nail for nailing bits of wood together."
	     "  Quite exciting really.\n" );
    set_value(4);
    set_weight(1);
}
// --- END [/mnt/home2/grok/lib/obj/misc/oddsnends/nail.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/oddsnends/glass.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/oddsnends/glass.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628045   Available: 13575399
Inodes: Total: 5242880    Free: 4960134
488 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/oddsnends/glass.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628045   Available: 13575399
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*
Davyd
Item
For General Item Stores
*/

#include <volumes.h>

inherit "/obj/vessel";

void setup(){
    set_name("glass");
    set_short("glass");
    set_long("This is a limited edition authentic "
             "scumble measure glass, as produced by the "
             "ancient scumble brewers.  It is very exclusive.\n");
    set_max_volume(VOLUME_HALFPINT);
    set_max_weight(10);
    set_leak_rate(0);
    set_value(30);
    set_weight(5);
    set_stuck(1);
}// --- END [/mnt/home2/grok/lib/obj/misc/oddsnends/glass.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/oddsnends/wedge.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/oddsnends/wedge.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628045   Available: 13575399
Inodes: Total: 5242880    Free: 4960134
350 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/oddsnends/wedge.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628045   Available: 13575399
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*
Davyd
Item
For General Item Stores
*/

inherit "/std/object";

void setup(){
    set_name("wedge");
    set_short("door wedge");
    add_adjective("door");
    set_main_plural("door wedges");
    set_long("A common wooden door wedge.  "
             "You use them to hold a door open.\n");
    set_value(10);
    set_weight(10);
}// --- END [/mnt/home2/grok/lib/obj/misc/oddsnends/wedge.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/oddsnends/book_end.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/oddsnends/book_end.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628044   Available: 13575398
Inodes: Total: 5242880    Free: 4960134
339 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/oddsnends/book_end.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628044   Available: 13575398
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*
Davyd
Item
For General Item Stores
*/

inherit "/std/object";

void setup(){
    set_name("end");
    set_short("book end");
    set_main_plural("book ends");
    set_long("A glittering book end wrought in iron.  Just the thing"
	     " for Auntie's Hogswatchday present.\n" );
    set_value(35);
    set_weight(40);
}
// --- END [/mnt/home2/grok/lib/obj/misc/oddsnends/book_end.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/oddsnends/small_keyring.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/oddsnends/small_keyring.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628044   Available: 13575398
Inodes: Total: 5242880    Free: 4960134
390 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/oddsnends/small_keyring.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628044   Available: 13575398
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*
Davyd
Item
For General Item Stores
*/

inherit "/obj/misc/keyring";

void setup(){
    set_name("keyring");
    set_short("small keyring");
    set_main_plural("small keyrings");
    add_adjective( "small" );
    set_long("This is a small keyring, suitable for holding a few "
     "small keys.\n" );
    set_weight(1);
    set_max_weight( 10 );
    set_value( 200 );
}
// --- END [/mnt/home2/grok/lib/obj/misc/oddsnends/small_keyring.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/oddsnends/safety_clip.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/oddsnends/safety_clip.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628044   Available: 13575398
Inodes: Total: 5242880    Free: 4960134
413 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/oddsnends/safety_clip.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628044   Available: 13575398
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*
Davyd
Item
For General Item Stores
*/

inherit "/std/object";

void setup(){
    set_name("clip");
    set_short("safety clip");
    add_adjective("safety");
    set_long("This is a high technology item.  "
             "It is designed to be used as a buckle, and "
             "will safeguard you from much harm if used "
             "properly.\n");
    set_value(25);
    set_weight(2);
}// --- END [/mnt/home2/grok/lib/obj/misc/oddsnends/safety_clip.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/oddsnends/bottleopener.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/oddsnends/bottleopener.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628043   Available: 13575397
Inodes: Total: 5242880    Free: 4960134
378 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/oddsnends/bottleopener.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628043   Available: 13575397
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*
Davyd
Item
For General Item Stores
*/

inherit "/std/object";

void setup(){
    set_name("opener");
    set_short("bottle opener");
    add_adjective("bottle");
    set_main_plural("bottle openers");
    set_long("This is a multipurpose bottle opener that "
             "works for left- and right-handed people.\n");
    set_value(15);
    set_weight(5);
}// --- END [/mnt/home2/grok/lib/obj/misc/oddsnends/bottleopener.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/oddsnends/hair_brush.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/oddsnends/hair_brush.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628043   Available: 13575397
Inodes: Total: 5242880    Free: 4960134
447 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/oddsnends/hair_brush.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628043   Available: 13575397
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*
Davyd
Item
For General Item Stores
*/

inherit "/std/object";

void setup(){
    set_name("brush");
    set_short("stiff hair brush");
    add_adjective("hair");
    add_adjective("stiff");
    set_long("This is a small brush with rather stiff tines "
             "sticking out from it.  It looks like just the thing to "
             "straighten out your hair after a sandstorm.\n");
    set_value(10);
    set_weight(20);
}// --- END [/mnt/home2/grok/lib/obj/misc/oddsnends/hair_brush.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/oddsnends/picframe.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/oddsnends/picframe.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628043   Available: 13575397
Inodes: Total: 5242880    Free: 4960134
339 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/oddsnends/picframe.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628043   Available: 13575397
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*
Davyd
Item
For General Item Stores
*/

inherit "/obj/container";

void setup(){
    set_name("frame");
    set_short("picture frame");
    add_adjective("picture");
    set_long("A lovely gold painted picture frame.\n");
    set_value(20);
    set_weight(30);
    set_max_weight(1);
    set_open();
    set_stuck(1);
}// --- END [/mnt/home2/grok/lib/obj/misc/oddsnends/picframe.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/oddsnends/beeswax_candle.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/oddsnends/beeswax_candle.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628042   Available: 13575396
Inodes: Total: 5242880    Free: 4960134
874 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/oddsnends/beeswax_candle.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628042   Available: 13575396
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: beeswax_candle.c,v 1.1 2002/03/26 01:47:04 belle Exp $
 *
 *
 */

inherit "/std/lightable";

void setup() {
   set_name( "candle" );
   set_short( "beeswax candle" );
   add_adjective( "beeswax" );
   set_long( "This is a small candle, like you'd "
         "see on a birthday cake.  It is quite soft and "
         "squidgy.\n" );
   set_fuel_messages( ({
         "It is almost burnt to a stub.", 10,
         "It is more than halfway burnt.", 50,
         "It is not yet halfway burnt.", 85,
	 "It is almost new.", 99,
         "It is new.", 100
         }) );
   set_empty_mess( "is burnt to a stub." );
   set_max_fuel( 900 );
   set_fuel( 900 );
   set_brightness( 60 );
   set_value( 24 );
   set_hold_required( 1 );
   add_property( "no recycling", 1 );
   new_weapon( 10 );
   set_weight( 1 );
   set_hide_cond( 1 );
}
// --- END [/mnt/home2/grok/lib/obj/misc/oddsnends/beeswax_candle.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/present.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/present.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628042   Available: 13575396
Inodes: Total: 5242880    Free: 4960134
6560 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/present.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628042   Available: 13575396
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <move_failures.h>

#define PAPER_LONG "This is a lovely big piece of " + _colour + " " + _type + " paper.  It looks like it could be used to wrap up something as a present.  Try \"wrap <objects> in paper\".\n"
#define PRESENT_LONG "This lovely piece of " + _colour + " paper has been used to wrap up something as a present.  Try \"unwrap\".\n"

inherit "/obj/baggage";

int do_wrap( object *things );
int do_unwrap();

private int wrapped;
private string _colour;
private string _type;

/* @ignore yes */
void setup() {

   set_name( "wrappingpaper" );

   set_short( "piece of wrapping paper" );
   add_alias( "paper" );
   add_adjective( ({ "piece of", "wrapping" }) );
   set_main_plural( "pieces of wrapping paper" );
   add_plural( ({ "pieces of wrapping paper", "pieces of paper",
                  "papers" }) );
   set_long( PAPER_LONG );

   set_weight( 2 );
   set_max_weight( 225 ); /* 25 pounds */ 
   set_value( 600 );
   set_stuck(1);
   add_property( "writeable", 1 );
   add_property( "paper", 1);
} /* setup() */

/**
 * This method sets the colour of the present.
 * @param word the colour of the present
 */
void set_colour( string word ) {
   if( _colour ) {
      return;
   }
   _colour = word;
   if (!_colour) {
      return;
   }

   set_short( "piece of " + _colour + " " + _type + " paper" );
   add_adjective( explode( _colour, " " ) );
   set_main_plural( "pieces of " + _colour + " " + _type + " paper" );
   set_long( PAPER_LONG );

} /* set_colour() */

/**
 * This method sets the type of the present.
 * @param word the type of the present
 */
void set_type( string word ) {
   if( _type ) {
      return;
   }
   _type = word;
   if (!_type) {
      return;
   }

   set_short( "piece of " + _colour + " " + _type + " paper" );
   add_adjective( explode( _type, " " ) );
   set_main_plural( "pieces of " + _colour + " " + _type + " paper" );
   set_long( PAPER_LONG );

} /* set_type() */

#ifdef MY_TEST_FUNC
/** @ignore yes */
int test_remove( object thing, int flag ) {
   if( ( query_verb() == "get" ) || ( query_verb() == "take" ) ) {
      return !wrapped;
   }
   return 1;
} /* test_remove() */

/** @ignore yes */
int test_add( object thing, int flag ) {
   if( ( query_verb() == "put" ) || ( query_verb() == "give" ) ) {
      return 0;
   }
   return 1;
} /* test_add() */
#endif

/** @ignore yes */
void init() {
   add_command( "wrap", "<indirect:object:me> in <direct:object'present'>" );
   add_command( "unwrap", "<direct:object:'present'>", (: do_unwrap :) );
   add_command( "open", "<direct:object:'present'>", (: do_unwrap :) );
} /* init() */

/**
 * This is the main entry point and wraps up the given objects into the
 * wrapping paper.
 * @param things the things to wrap up
 * @return 1 on success, 0 on failure
 */
int do_wrap( object *things ) {
   object *valid, *failed;

   things -= ({ this_object() });

   if( wrapped ) {
      add_failed_mess( "The paper has already been used to wrap something.\n" );
      return 0;
   }

   if( !( sizeof( things ) ) ) {
      add_failed_mess( "You must wrap something!\n" );
      return 0;
   }

   valid = filter( things, (: !living( $1 ) &&
                              $1->move( this_object() ) == MOVE_OK :) );
   failed = things - valid;

   if( sizeof( failed ) ) {
      tell_object( this_player(), "You could not wrap " +
         query_multiple_short( failed ) + " in " + the_short() + ".\n" );
   }

   if( sizeof( valid ) ) {
      wrapped = 1;

      remove_alias( "paper" );
      remove_adjective( "piece of" );
      remove_adjective( "wrapping" );
      remove_plural( "pieces of wrapping paper" );
      remove_plural( "pieces of paper" );
      remove_plural( "papers" );

      call_out( "set_short", 1, _colour + " present" );
      add_alias( "present" );
      set_main_plural( _colour + " presents" );
      add_plural( "presents" );
      set_long( PRESENT_LONG );
        
      add_succeeded_mess( "$N $V $I in $D.\n", valid );
   } else {
      add_succeeded_mess( "" );
   }

   return 1;
} /* do_wrap() */

/**
 * This method unwraps the wrapping paper and sets up all the exiting
 * bits which pop out of it.
 * @return 1 on success, 0 on failure
 */
int do_unwrap() {
   int i;
   object *things;

   if( !wrapped ) {
      write( "There is nothing wrapped in the paper.\n" );
      return 0;
   }

   wrapped = 0;

   things = all_inventory();
   write( "You open the present and find "+ query_multiple_short( things ) +
      " inside.\n" );

   for( i = 0; i < sizeof( things ); i++ ) {
      if( things[ i ]->move( environment() ) ) {
         if( environment( environment() ) ) {
            things[ i ]->move( environment( environment() ) );
            write( "The " + things[ i ]->short() + " falls onto the " +
               "floor as you unwrap the present.\n" );
         }
      }
   }

   remove_alias( "present" );
   remove_plural( "presents" );

   call_out( "set_short", 1, "piece of " + _colour + " " + _type + " paper" );
   add_alias( "paper" );
   add_adjective( ({ "piece of", "wrapping" }) );
   set_main_plural( "pieces of " + _colour + " " + _type + " paper" );
   add_plural( ({ "pieces of " + _type + " paper", "pieces of paper",
                  "papers" }) );
   set_long( PAPER_LONG );

   add_succeeded_mess("$N unwrap$s $D.\n");

   return 1;
} /* do_unwrap() */

/** @ignore yes */
mixed *stats() {
    return ::stats() + ({
      ({ "colour", _colour }),
      ({ "type", _type }),
      ({ "wrapped", wrapped }),
    });
} /* stats() */

/** @ignore yes */
mapping query_static_auto_load() {
    return ([
      "colour": _colour,
      "type": _type,
      "::": ::int_query_static_auto_load(),
    ]);
} /* query_static_auto_load() */

/** @ignore yes */
void init_static_arg( mapping args ) {
    _colour = args[ "colour" ];
    ::init_static_arg( args[ "::" ] );
} /* init_static_arg() */

/** @ignore yes */
mapping query_dynamic_auto_load() {
    return ([
      "colour": _colour,
      "type": _type,
      "wrapped": wrapped,
      "::": ::query_dynamic_auto_load(),
    ]);
} /* query_dynamic_auto_load() */

/** @ignore yes */
void init_dynamic_arg( mapping args ) {

    _colour = args[ "colour"  ];
    _type   = args[ "type"    ];
    wrapped = args[ "wrapped" ];
    ::init_dynamic_arg( args[ "::" ] );

    if(!_colour) { 
        _colour = "plain";
    }
    if(!_type) {
        _type = "wrapping";
    }
    
} /* init_dynamic_arg() */

int query_closed() {
    return 1;
} /* query_closed() */

string long_status() {
    return "";
} /* long_status() */
// --- END [/mnt/home2/grok/lib/obj/misc/present.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/dead_chicken.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/dead_chicken.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628040   Available: 13575394
Inodes: Total: 5242880    Free: 4960134
2454 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/dead_chicken.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628040   Available: 13575394
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: dead_chicken.c,v 1.6 2001/11/27 12:03:32 siel Exp $
 *
 *
 */


#include <move_failures.h>

#define CHICKEN_FEATHER "/obj/misc/chicken_feather"
#define MIN_FEATHERS 3
#define MAX_FEATHERS 5

inherit "/obj/food";

void    setup();
void    init();
int     do_pluck( object *indirect_obs, string indir_match, string dir_match, 
                 mixed *args, string pattern );
mixed   query_dynamic_auto_load();
void    init_dynamic_arg(mapping arg, object);

int plucked; /* Is the chicken already plucked? */

void setup()
{
  set_name( "chicken" );
  set_short( "dead chicken" );
  add_alias( ({ "corpse", "chicken corpse" }) );
  add_adjective( "dead" );
  set_main_plural( "dead chickens" );
  set_long( function()
            {
              if( plucked ) 
                return
                  "This is the dead body of a bedraggled chicken.  "
                  "Judging from the total lack of feathers it is "
                  "ready to be cooked.\n";
              return
                  "This is the dead body of a bedraggled chicken.  "
                  "Most people would pluck the few feathers on it "
                  "and then cook it.\n";
            } );
  set_weight( 8 );
  set_value( 300 );
  set_weight_per_bite( 2 );
}

void init()
{
  ::init();
  this_player()->add_command( "pluck", this_object(),
        "<direct:object:me-here>" );
}

int do_pluck( object *indirect_obs, string indir_match, string dir_match, 
   mixed *args, string pattern )
{
  object pluck;
  int feathers = random( MAX_FEATHERS - MIN_FEATHERS ) + MIN_FEATHERS;

  if ( plucked ) return notify_fail( "The chicken is already plucked and "
    "bare of any feathers.\n" );

  plucked = 1;
  for ( int i = 0; i < feathers; i++ ) {
    pluck = clone_object( CHICKEN_FEATHER );
    if( MOVE_OK != pluck->move( this_player() ) )
        pluck->move( environment() );
  }
  tell_room( environment( this_player() ),
        this_player()->one_short() + " plucks a dead chicken with reckless "
          "abandon.\n",
        this_player() );
  return notify_fail( "You pluck the bedraggled, dead chicken cheerfully.\n" );
}

mixed query_dynamic_auto_load() {

  return ([ "::" : ::query_dynamic_auto_load(),
            "plucked" : plucked ]);
} /* query_dynamic_auto_load() */

void init_dynamic_arg(mapping arg, object) {

  ::init_dynamic_arg(arg["::"]);
  plucked = arg["plucked"];

} /* init_dynamic_arg() */
// --- END [/mnt/home2/grok/lib/obj/misc/dead_chicken.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/quest_info_utils.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/quest_info_utils.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628039   Available: 13575393
Inodes: Total: 5242880    Free: 4960134
1879 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/quest_info_utils.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628039   Available: 13575393
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*
  INCLUDE  : Quest Info Utils
  Author   : Dek
  Date     : March 2001
  Function : General inheritable for use by anything really.
             Using quest_info stuff is a bit of a pain. This
             is just syntactic sugar to make it a lot more
             friendly.


Quest info is saved as a mapping, so you can index any info you like
under named keys.

Functions:
----------
set_quest_name(string quest_name)
   sets the name of the quest this item applies to.

void set_quest_param(mixed player, string key, mixed value)
   Sets the quest info value addressed by <key> to <value>
   Value can be of any type.

mixed query_quest_param(mixed player, string key)
   gets the quest info value addressed by <key>

void clear_quest_info(mixed player)
   Clears all the quest info associated with <player>
   for the current quest


*/

#include <library.h>

string _quest_name;

// call this function in setup. I'm making the assumption that one
// item only deals with one quest, but it's a fairly safe assumption.
void set_quest_name(string quest_name)

{
   _quest_name = quest_name;
}


void set_quest_param(mixed player, string key, mixed value)

{
   mixed info;
   
   if (!stringp(player))
      player = player->query_name();
   
   info = LIBRARY->query_player_quest_info(player, _quest_name);
   
   if (!mapp(info))
      info = ([ ]);
   
   info[key] = value;

   LIBRARY->set_player_quest_info(player, _quest_name, info);
}


mixed query_quest_param(mixed player, string key)

{
   mixed info;

   if (!stringp(player))
      player = player->query_name();

   info = LIBRARY->query_player_quest_info(player, _quest_name);

   if (!mapp(info))
      return 0;
      
   return info[key];
}


void clear_quest_info(mixed player)

{
   if (!stringp(player))
      player = player->query_name();

   LIBRARY->set_player_quest_info(player, _quest_name, 0);
}// --- END [/mnt/home2/grok/lib/obj/misc/quest_info_utils.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/shop_owners_guide.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/shop_owners_guide.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628039   Available: 13575393
Inodes: Total: 5242880    Free: 4960134
736 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/shop_owners_guide.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628039   Available: 13575393
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*
 * A guide for new home owners.
 */
inherit "/std/book_dir";

void setup() {
  set_name("book");
  set_short("brilliant vermillion book");
  add_adjective(({"brilliant", "vermillion"}));
  add_alias("guide");
  set_long("This is a brilliant vermillion coloured book with lots of "
           "pictures of money on the front cover.\n");
  set_read_mess("                   DIY\n\n"
                "          A guide for shop owners.\n");
  set_main_plural("brilliant vermillion books");
  set_weight(10);
  set_value(10);
  
  set_book_language( "general");
  set_book_dir("/save/books/shop_owner/page");

  set_open_page(0);
  set_ignore_saved_pages(1);
}

int do_tear() {
  return 0;
}

int query_binding_force() {
  return 100;
}
// --- END [/mnt/home2/grok/lib/obj/misc/shop_owners_guide.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/quill.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/quill.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628038   Available: 13575392
Inodes: Total: 5242880    Free: 4960134
11455 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/quill.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628038   Available: 13575392
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*
 * Ink/dipping can be added once vessels/liquids is finished.
 * Writing size can be added once that's worked out.
 *
 * Added 'copy' command - Jeremy, 10-Dec-95
 */

#include <language.h>

inherit "/obj/weapon";

int do_scribble( object *things, string mess);

object writing_on;
string type;

void setup() {
   set_name( "quill" );
   set_long( "This is a nice, long, feathery quill.  You could \"write\" "
         "on things with it.\n");
   set_weight( 3 );
   set_value( 1000 );
   new_weapon( 240 );
   add_help_file("quill");
   set_damage_chance( 100 );
   add_attack( "stab", 90, ({ 10, 2, 10 }), "pierce", "sharp", 0 );
   add_property( "paper writer", 1 );
   type = "ink";
} /* setup() */

void init() {
   add_command( "write", "on <indirect:object> with <direct:object>" );
   add_command( "write", "with <direct:object> on <indirect:object>" );
   add_command( "sign", "<indirect:object> with <direct:object>");
   add_command( "scribble",
                "<string'message'> on <indirect:object> with <direct:object>",
                (: do_scribble($1, $4[0]) :));
/*
   this_player()->add_command( "copy", this_object(),
                              ({"<indirect:object> 'to' <indirect:object> 'with' <direct:object>",
                                "<indirect:object> 'to' <indirect:object> 'with' <direct:object> 'in' <word>"}));
 */
} /* init() */

int do_scribble( object *things, string mess) {
   string language;

   if ( query_wielded() != this_player() ) {
      this_player()->add_failed_mess( this_object(), "You need to be "+
            "holding $D to $V with it.\n", ({ }) );
      return 0;
   }
   things = filter(things, (: is_in_me_or_environment($1, this_player()) :));
   if (!sizeof(things)) {
      add_failed_mess("You can only $V on objects you are holding or are "
                      "in the room with $D.\n");
      return 0;
   }

   if ( sizeof( things ) > 1 ) {
      add_failed_mess("You can only $V on one object at once with $D.\n");
      return 0;
   }
   if ( !things[ 0 ]->query_property( "writeable" ) ) {
      add_failed_mess("You cannot $V on $I with $D.\n", things );
      return 0;
   }
   language = (string)this_player()->query_current_language();
   if ( !LANGUAGE_HAND->query_language_written( language ) ) {
      add_failed_mess("You cannot $V on "+
            "$I with $D when you're not using a language that can be "+
            "written.\n", things );
      return 0;
   }

   if (things[0]->is_current_page_torn_out()) {
      add_failed_mess( "The page of " + things[0]->the_short() +
            " you were writing on appears to have been torn out.\n" );
      return 0;
   }

   things[0]->add_read_mess( mess, type, language, 0 );
   add_succeeded_mess("$N $V something on $I.\n", things);
   return 1;
} /* do_scribble() */

int do_write( object *things ) {
   string language;

   if ( query_wielded() != this_player() ) {
      this_player()->add_failed_mess( this_object(), "You need to be "+
            "holding $D to $V with it.\n", ({ }) );
      return 0;
   }
   things = filter(things, (: is_in_me_or_environment($1, this_player()) :));
   if (!sizeof(things)) {
      add_failed_mess("You can only $V on objects you are holding or are "
                      "in the room with $D.\n");
      return 0;
   }

   if ( sizeof( things ) > 1 ) {
      add_failed_mess("You can only $V on one object at once with $D.\n");
      return 0;
   }
   if ( !things[ 0 ]->query_property( "writeable" ) ) {
      add_failed_mess("You cannot $V on $I with $D.\n", things );
      return 0;
   }
   language = (string)this_player()->query_current_language();
   if ( !LANGUAGE_HAND->query_language_written( language ) ) {
      add_failed_mess("You cannot $V on "+
            "$I with $D when you're not using a language that can be "+
            "written.\n", things );
      return 0;
   }
   if ( writing_on ) {
      add_failed_mess("You are already writing on $I with $D.\n", ({ writing_on }) );
      return 0;
   }
   add_succeeded_mess("$N start$s writing on $I with $D.\n", things );
   writing_on = things[ 0 ];
   call_out( "begin_writing", 0, this_player() );
   return 1;
} /* do_write() */

void begin_writing( object writer ) {
   if ( !writer ) {
      writing_on = 0;
      return;
   }
   writer->do_edit( 0, "end_writing" );
} /* begin_writing() */

void end_writing( string words ) {
   string language;

   if ( !words || ( words == "" ) ) {
      write( "You don't write anything on "+
            (string)writing_on->the_short() +".\n" );
      say( (string)this_player()->the_short() +" doesn't "+
            "write anything after all.\n" );
      writing_on = 0;
      return;
   }
   language = (string)this_player()->query_current_language();
   if ( !LANGUAGE_HAND->query_language_written( language ) ) {
      write( "You seem to have changed to using a non-written language.\n" );
      say( (string)this_player()->the_short() +" seems "+
            "linguistically-challenged.\n" );
      writing_on = 0;
      return;
   }
   if ( !writing_on ) {
      write( "You seem to have lost what you were writing on.\n" );
      say( (string)this_player()->the_short() +" looks around "+
            "in puzzlement.\n" );
      return;
   }
   if ( member_array( environment( writing_on ), ({ environment(),
         environment( this_player() ) }) ) == -1 ) {
      write( (string)writing_on->the_short() +
            " seems to have run away from you.\n" );
      say( (string)this_player()->the_short() +" looks like "+
            (string)this_player()->query_pronoun() +"'s lost something.\n" );
      writing_on = 0;
      return;
   }
   if (writing_on->is_current_page_torn_out()) {
      write( "The page of " + (string)writing_on->the_short() +
            " you were writing on appears to have been torn out.\n" );
      say( (string)this_player()->the_short() +" looks like "+
            (string)this_player()->query_pronoun() +"'s lost something.\n" );
      writing_on = 0;
      return;
   }

   writing_on->add_read_mess( words, type, language, 0 );
   write( "You finish writing on "+
         (string)writing_on->the_short() +".\n" );
   say( (string)this_player()->the_short() +" finishes writing "+
         "on "+ (string)writing_on->a_short() +".\n" );
   writing_on = 0;
} /* end_writing() */

int do_sign(object* things) {
   object ob;
   string language;

   if ( query_wielded() != this_player() ) {
      add_failed_mess( "You need to be "+
            "holding $D to $V with it.\n", ({ }) );
      return 0;
   }
   things = filter(things, (: is_in_me_or_environment($1, this_player()) :));
   if (!sizeof(things)) {
      add_failed_mess("You can only $V on objects you are holding or are "
                      "in the room with $D.\n");
      return 0;
   }

   if ( sizeof( things ) > 1 ) {
      add_failed_mess("You can only $V on one object at once with $D.\n");
      return 0;
   }
   if ( !things[ 0 ]->query_property( "writeable" ) ) {
      add_failed_mess("You cannot $V on $I with $D.\n", things );
      return 0;
   }
   
   language = (string)this_player()->query_current_language();
   if ( !LANGUAGE_HAND->query_language_written( language ) ) {
      add_failed_mess("You cannot $V $I with $D when you're not "
            "using a language that can be written.\n", things );
      return 0;
   }

   things[ 0 ]->add_read_mess(this_player()->short(0, 1), "cursive, "
        "signed by", language, 0);
   add_succeeded_mess("$N $V $I with $D.\n", things);
   return 1;
} /* do_sign() */

int do_copy( mixed *in_dir, string direct, string indirect, mixed *args ) {
    // This will need a lot of checks.  For now it is just a "proof of
    // concept".
    mixed src_mess, mess;
    string lang, cur_lang;
    int i, c, siz, perr;

    //printf("-------- in_dir\n%O\n------- args\n%O\n", in_dir, args);
    // This is to keep the parser from matching "quill in <word>" on
    // a second attempt when the language checks fail.  Maybe this won't
    // be necessary some day.
    if ( !present(direct, this_player()) ) return 0;
    if ( query_wielded() != this_player() ) {
        this_player()->add_failed_mess( this_object(), "You need to be "
                                       "holding $D to $V with it.\n", ({ }) );
        return 0;
    }
    if ((sizeof(in_dir) != 2) ||
        (sizeof(in_dir[0]) != 1) || (sizeof(in_dir[1]) != 1)) {
        //write("You can only copy to/from one object at a time.\n");
        this_player()->add_failed_mess(this_object(),
                                       "You can only $V to/from one object "
                                       "at a time.\n", ({ }));
        return 0;
    }
    if ( !in_dir[1][0]->query_property( "writeable" ) ) {
        this_player()->add_failed_mess( this_object(), "You can't write on "
                                       "$I.\n", in_dir[1] );
        return 0;
    }
    if ( sizeof(args) == 4 ) {
        if ( !LANGUAGE_HAND->query_language_written(args[3]) ) {
            this_player()->add_failed_mess(this_object(),
                               args[3] + " is not a written language.\n",
                               ({ }));
            return 0;
        }
        if ( LANGUAGE_HAND->query_language_magic(args[3])) {
            this_player()->add_failed_mess(this_object(),
                               "You can't write " + args[3] + " like this.\n",
                               ({ }));
            return 0;
        }
        if ( !this_player()->query_language(args[3]) ) {
            this_player()->add_failed_mess(this_object(),
                               "You don't know " + args[3] + ".\n", ({ }));
            return 0;
        }
        cur_lang = args[3];
    }
    src_mess = in_dir[0][0]->query_read_mess();
    if (!sizeof(src_mess)) {
        write("There is nothing written on " + in_dir[0][0]->the_short() +
              ".\n");
        this_player()->add_failed_mess(this_object(),
                                       "There is nothing written on $I.\n",
                                       in_dir[0]);
        return 0;
    }
    // Copy each read_mess
    for (i = 0; i < sizeof(src_mess); i++) {
        mess = src_mess[i][0];
        lang = src_mess[i][2];
        siz = src_mess[i][3];
        if (LANGUAGE_HAND->query_language_magic(lang)) {
            mess = "A series of unintelligible scribbles.";
            lang = "common";
        } else if (!this_player()->query_language(lang) && stringp(mess)) {
            // Introduce a few copying errors, based on intelligence
            // and dexterity
            perr = this_player()->query_int() + this_player()->query_dex()
              - 20;
            for (c = random(perr); c < sizeof(mess); c += random(perr)+1) {
                if ((mess[c] >= 'a') && (mess[c] <= 'z')) {
                    mess[c] = 'a' + random(26);
                } else if ((mess[c] >= 'A') && (mess[c] <= 'Z')) {
                    mess[c] = 'A' + random(26);
                }
            }
        } else if ( stringp(cur_lang) ) {
            lang = cur_lang;
        }
        //printf("%O\n", src_mess[i]);
        //printf("--------\n%O\n", in_dir);
        in_dir[1][0]->add_read_mess(mess, type, lang, siz);
    }
    this_player()->add_succeeded_mess(this_object(),
                                      "$N $V the writing on $I with $D.\n",
                                      in_dir[0]);
    return 1;
}
// --- END [/mnt/home2/grok/lib/obj/misc/quill.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/plate.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/plate.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628035   Available: 13575389
Inodes: Total: 5242880    Free: 4960134
1948 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/plate.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628035   Available: 13575389
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
* This is an inheritable for a plate, including cutlery.  You can put things
* on it.  You can also eat food directly from the plate.  It was designed
* for the pub_shop.c inheritable, for use with the meals that can be sold
* there.
* @author Lemming
* @started 26/12/1999
*/


inherit "/std/surface";


/** @ignore */
void init() {
  this_player()->add_command( "eat", this_object(),
    "<indirect:object:direct-obs> {from|on} <direct:object:me>" );
  this_player()->add_command( "eat", this_object(),
    "from <direct:object:me>" );
} /* init() */


/** @ignore yes */
void create() {
  do_setup++;
  ::create();
  do_setup--;

/*  I'm commenting these two out, because for reasons beyond me
**  they mess up the main plurals of the objects inheriting
**  this file. And I can't imagine this file being cloned directly
**  anywhere, so they shouldn't be needed.   -- Tilly
**  set_name( "plate" );
**  set_short( "plate" );
*/
  set_long( "This is a nice plate for keeping food on.\n" );


  if ( ! do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }
} /* create */



/** @ignore */
int do_eat( object *obs, string dir, string indir, mixed *args ) {
  object ob;
  object *food;

  if( sizeof( obs ) )
    food = copy( obs );
  else
    food = all_inventory();

  if( sizeof( food ) ) {
    food = filter( food, (: $1->query_edible() :) );
  } else {
    this_player()->add_failed_mess( this_object(),
      "There's nothing on $D\n", ({ }) );
    return 0;
  }

  if( !sizeof( food ) ) {
    if( sizeof( obs ) )
      this_player()->add_failed_mess( this_object(),
        "You can't eat $I on $D!\n", obs );
    else
      this_player()->add_failed_mess( this_object(),
        "There's nothing edible on $D\n", ({ }) );
    return 0;
  }

  foreach( ob in food ) {
    ob->do_eat();
  }

  return 1;
} /* do_eat() */


/** @ignore yes */
mapping query_static_auto_load() {
  return int_query_static_auto_load();
}
// --- END [/mnt/home2/grok/lib/obj/misc/plate.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/shops/item_shop_safe.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/shops/item_shop_safe.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628035   Available: 13575389
Inodes: Total: 5242880    Free: 4960134
740 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/shops/item_shop_safe.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628035   Available: 13575389
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/obj/baggage";

void set_max_float( int );
int query_max_float();

void setup() {
  set_name( "safe" );
  set_short( "cash safe" );
  set_long( "This safe is used to keep the shop's float in.  It's securely set "
    "in the wall.\n" );
  add_adjective( "float" );
  add_property( "there", "in the wall" );
  set_difficulty( 10 );

  reset_get(); 
  set_closed();
  set_locked();

  set_key( "non-existent key" );
  add_property( "no recycling", 1 );
  set_pick_skill( "covert.lockpick.safes" );

  set_weight( 2000 );
  set_max_weight( 5000 );

  set_value( 120000 );
} /* setup() */

int pick_unlock( object player ){
  this_object()->set_unlocked();
    return 1;
} /* pick_unlock() */

int query_accept_money() {
  return 1;
}
// --- END [/mnt/home2/grok/lib/obj/misc/shops/item_shop_safe.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/paper_packet.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/paper_packet.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628034   Available: 13575388
Inodes: Total: 5242880    Free: 4960134
2725 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/paper_packet.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628034   Available: 13575388
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/obj/baggage";

void setup() {
   set_name( "packet" );
   set_short( "waxed paper packet" );
   add_adjective( ({ "waxed", "paper" }) );
   set_main_plural( "waxed paper packets" );
   set_long( "This is a small packet, rather like an envelope, of thick "+
         "paper that has been waxed to make it more resilient.\n" );
   set_weight( 1 );
   set_value( 10 );
   set_max_weight( 3 );
   set_transparent();
   add_property("writeable", 1);
} /* setup() */

int test_add( object thing, int flag ) {
   string word;
   object *things;
   if ( !this_player() )
      return ::test_add( thing, flag );
   things = all_inventory( this_object() );
   if ( !sizeof( things ) )
      return ::test_add( thing, flag );
   word = (string)things[ 0 ]->query_medium_alias();
   if ( word == (string)thing->query_medium_alias() )
      return ::test_add( thing, flag );
   write( "You don't want to contaminate "+ ( stringp( word ) ?
         (string)things[ 0 ]->the_short() :
         (string)thing->the_short() ) +", do you?\n" );
   return 0;
} /* test_add() */

object query_substance() {
   object *things;
   things = all_inventory( this_object() );
   if ( !sizeof( things ) )
      return 0;
   if ( !stringp( (string)things[ 0 ]->query_medium_alias() ) )
      return 0;
   return things[ 0 ];
} /* query_substance() */

string short( int dark ) {
   object thing = query_substance();
   if ( dark || !objectp( thing ) )
      return ::short( dark );
   return ::short( dark ) +" of "+ (string)thing->short( dark );
} /* short() */

string query_plural( int dark ) {
   object thing = query_substance();
   if ( dark || !objectp( thing ) )
      return ::query_plural( dark );
   return ::query_plural( dark ) +" of "+ (string)thing->short( dark );
} /* query_plural() */

string *parse_command_id_list() {
   object thing = query_substance();
   if ( !objectp( thing ) )
      return ::parse_command_id_list();
   return ::parse_command_id_list() +
         ({ ::short( 0 ) +" of "+ (string)thing->short( 0 ) });
} /* parse_command_id_list() */

string *parse_command_plural_id_list() {
   object thing = query_substance();
   if ( !objectp( thing ) )
      return ::parse_command_plural_id_list();
   return ::parse_command_plural_id_list() +
         ({ ::query_plural( 0 ) +" of "+ (string)thing->short( 0 ) });
} /* parse_command_plural_id_list() */

string *parse_command_adjectiv_id_list() {
   object thing = query_substance();
   if ( !objectp( thing ) )
      return ::parse_command_adjectiv_id_list();
   return ::parse_command_adjectiv_id_list() +
         (string *)thing->parse_command_adjectiv_id_list() +
         (string *)thing->parse_command_id_list();
} /* parse_command_adjectiv_id_list() */
// --- END [/mnt/home2/grok/lib/obj/misc/paper_packet.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/golem_toe.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/golem_toe.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628034   Available: 13575388
Inodes: Total: 5242880    Free: 4960134
449 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/golem_toe.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628034   Available: 13575388
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*
 * $Id$
 */

/* Toe of a golem */

inherit "/std/object";

void setup() {
    set_name( "toe" );
    set_short( "remains of a clay toe" );
    add_adjective( ({"remains", "of", "a", "clay"}) );
    set_long( "This looks part of a toe made of clay.\n" );
    set_main_plural( "remains of clay toes" );
    set_weight( 5 );
    set_value( 0 );
    add_property( "no recycling", 1 );
    add_property( "determinate", "the " );
} /* void setup() */

// --- END [/mnt/home2/grok/lib/obj/misc/golem_toe.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/animusser.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/animusser.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628033   Available: 13575387
Inodes: Total: 5242880    Free: 4960134
1915 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/animusser.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628033   Available: 13575387
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <skills.h>

inherit "/std/object";

string *skill_names;
mapping new_skills, old_skills;

void setup() {
   set_name( "lever" );
   set_short( "blue lever" );
   add_adjective( "blue" );
   set_long( "This blue lever is apparently an animus recalculation "+
         "device.  You're not totally sure how you know this, but "+
         "there you are.  You could pull it to have your animus "+
         "recalculated, I suppose.\n" );
   reset_get();
   skill_names = ({ });
   new_skills = ([ ]);
   old_skills = ([ ]);
} /* setup() */

void init() {
   this_player()->add_command( "pull", this_object() );
} /* init() */

int find_level( string skill ) {
   int i, sublevel, total;
   string *others;
   others = (string *)SKILL_OB->query_immediate_children( skill );
   if ( !sizeof( others ) )
      if ( undefinedp( old_skills[ skill ] ) )
         return (int)this_player()->query_skill( skill );
      else
         return old_skills[ skill ];
   for ( i = 0; i < sizeof( others ); i++ ) {
      sublevel = find_level( others[ i ] );
      total += sublevel;
      new_skills[ others[ i ] ] = sublevel;
      skill_names -= ({ others[ i ] });
   }
   return total / sizeof( others );
} /* find_level() */

int do_pull() {
   int i, adjust;
   new_skills = ([ ]);
   old_skills = (mapping)this_player()->query_skills();
   skill_names = m_indices( old_skills );
   while ( sizeof( skill_names ) ) {
      new_skills[ skill_names[ 0 ] ] = find_level( skill_names[ 0 ] );
      skill_names = delete( skill_names, 0, 1 );
   }
   reset_eval_cost();
   skill_names = m_indices( old_skills );
   for ( i = 0; i < sizeof( skill_names ); i++ ) {
      adjust = new_skills[ skill_names[ i ] ] - old_skills[ skill_names[ i ] ];
      if ( adjust )
         write( "Adjusting "+ skill_names[ i ] +" by "+ adjust +".\n" );
   }
   this_player()->set_skills( new_skills + ([ ]) );
   return 1;
} /* do_pull() */
// --- END [/mnt/home2/grok/lib/obj/misc/animusser.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/glass.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/glass.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628033   Available: 13575387
Inodes: Total: 5242880    Free: 4960134
4212 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/glass.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628033   Available: 13575387
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: glass.c,v 1.2 2002/08/28 16:46:00 carmine Exp $
 *
 *
 */

/** 
 * A nice little inheritable and constructible glass object thing.
 * 
 * @author Taffyd
 */

inherit "/obj/vessel";

nosave string description, actual_drink, actual_glass_size;

/** @ignore yes */
void create() {
    do_setup++;
    ::create();
    do_setup--;

    set_name("glass");
    set_weight(1);
    set_value(400);
    set_stuck(1);
    set_leak_rate(0);
    set_material("glass");
    add_property("fragile", 200);   

    if (!do_setup) {
        this_object()->setup();
    } 
} /* setup() */

/** 
 * This function is used to transform the glass into a new type of glass, changing the 
 * short descriptions and adding aliases and adjectives.
 *
 * If the 'contents' parameter is 1, then the glass is automatically filled
 * up with a drink made from /obj/reagents/generic_liquid.ob
 *
 * @param drink The name of the drink to be created
 * @param glass_description The description given when there is something in the glass.
 * @param glass_size The size of the glass, (in words), for example "large glass",
 * @param amount The amount of liquid the glass should hold.
 * @param has_contents Fill the glass up with 'drink'.
 * @see /obj/bottle
 * @example
 * // Create a large glass of tomato juice
 *
 * glass = clone_object("/obj/glass");
 * glass->make_glass("tomato juice", "Red, thick, delicious.\n",
 *      "large glass", 4000, 1);
 * glass->move(this_object());
 *
 * @example
 * inherit "/obj/glass";
 *
 * void setup() {
 * // Do your own configuration of the glass, then call make_glass
 *
 *     ...
 *     make_glass("chocolate milkshake", "Yumm...", "shot glass", 100, 0);
 *     ...
 * // Place your own contents in, do other funky stuff.
 * }
 */ 
void make_glass(string drink, string glass_description, string glass_size, 
   int amount, int has_contents) 
{ 
    string *glass_adjectives;
    object contents;
    
    description = glass_description;
    actual_drink = drink;
    actual_glass_size = glass_size;
    
    glass_adjectives = explode( glass_size, " " )[0..<2];

    set_short( glass_size );          
    set_long( (: this_object()->query_volume() ? description : "This is "
        "a dirty " + actual_glass_size + ", one that used to hold some "
        " " + actual_drink + ".\n" :) );

    glass_adjectives = explode( glass_size, " " );

    if (sizeof(glass_adjectives) > 1)
        add_alias(glass_adjectives[<1..]);
    else
        add_alias(glass_size);

    add_adjective(glass_adjectives);
    set_max_volume(amount);
        
    if (has_contents) {
        contents = clone_object("/obj/reagents/generic_liquid.ob");
        contents->set_name("drink");
        contents->set_short(drink);
        contents->set_long("This is some delicious looking " + drink + ".\n" );
        contents->add_adjectives(explode(drink, " ")[0..<2]);
        contents->add_alias( explode( drink, " " )[ sizeof( 
           explode( drink, " " ) ) - 1 ] );
        contents->set_amount(amount);
        contents->move(this_object());
    }        
} /* setup_drink() */    

/** @ignore yes */
mapping int_query_static_auto_load() {
    return ([
        "::": ::int_query_static_auto_load(),
        "description": description,
        "actual_drink" : actual_drink,
        "actual_glass_size" : actual_glass_size,
    ]);
} /* int_query_static_auto_load() */

void init_static_arg(mapping map) {
    if (map["::"])
        ::init_static_arg(map["::"]);
    if (!undefinedp(map["description"]))
        description = map["description"];
    if (!undefinedp(map["actual_drink"]))
        actual_drink = map["actual_drink"];        
    if (!undefinedp(map["actual_glass_size"]))
        actual_glass_size = map["actual_glass_size"];

    set_long((: this_object()->query_volume() ? description : "This is "
        "a dirty " + actual_glass_size + ", one that used to hold some "
        "sort of " + actual_drink + ".\n" :));

} /* init_static_arg() */

/** @ignore yes */
mixed query_static_auto_load() {
    if (base_name(this_object()) == "/obj/misc/glass" )
        return int_query_static_auto_load();
    return ([ ]);
} /* query_static_auto_load() */
// --- END [/mnt/home2/grok/lib/obj/misc/glass.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/fire_cracker.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/fire_cracker.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628031   Available: 13575385
Inodes: Total: 5242880    Free: 4960134
2619 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/fire_cracker.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628031   Available: 13575385
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/object";

#define EFFECT "/w/dogbolter/cracker_eff"
#define DURATION 180

void setup() {
    set_name( "firecracker" );
    add_alias( "cracker" );
    add_adjective( "fire" );
    add_plural( "crackers" );
    set_short( "fire cracker" );
    set_long( "This is a large red fire cracker of Auriental manufacture"
      ".  It's the sort of thing that is thrown at weddings.  You may "
      "'light' it, and 'throw' it.\n" );
    set_weight( 2 ); // Velly Big Clackah!
    set_value( 500 );
    set_read_mess("ACME Firecracker", "agatean");
    //add_property( "no recycling", 1 );
}

void explosion() {
    object victim;
    if( !environment() )
        return;

    if( living( environment() ) ) {
        victim = environment();
        // A living is holding the clackah when it explodes.  Tell them
        // and tell the room.
        tell_object( environment(), "%^BOLD%^%^RED%^$C$"+ the_short()
          +" explodes in your face!\nMeep meep!%^RESET%^\n" );
        environment()->add_effect (EFFECT, DURATION);
            
        if( environment( environment() ) ) {
            tell_room( environment( environment() ), "%^BOLD%^%^RED%^$C$"+
              the_short() +" explodes in "+
              environment()->the_short() +"'s face!\nMeep meep!%^RESET%^\n",
              environment() );

            // Hurt them by adjusting heir hp downwards.
          //  victim->adjust_hp( -5000000 );
            // Check if they were killed
            // Make the cracker "attack" the victim to show up in death inform
          //  if( victim->query_hp() < 0 )
          //      victim->attack_by( this_object() );
                
        }
    } else {
        tell_room( environment(), "%^BOLD%^%^RED%^$C$"+ the_short()
          +" explodes!%^RESET%^\n" );
    }

    move( "/room/rubbish" );
}

int do_light() {
    call_out( (: explosion :), 10 );

    add_succeeded_mess( "$N $V $D and smoke begins to pour out.\n",
      ({ }) );
    return 1;
}





int do_throw() {
    if( environment() && environment( environment() ) ) {
        add_succeeded_mess( "$N $V $D on the ground.\n", ({ }) );
        move( environment( environment() ) );
        return 1;
    } else {
        add_failed_mess( "There is no ground to $V $D on.  How very odd\n",
          ({ }) );
        return 0;
    }
}

void init() {
    add_command( "light", "<direct:object:me>", (: do_light :) );
    add_command( "throw", "<direct:object:me>", (: do_throw :) );
}
string query_death_reason() {
    return "being blown up by a fire cracker, in true Road Runner Style.\n"
    "%^BOLD%^Meep meep!%^RED%^";
}




// --- END [/mnt/home2/grok/lib/obj/misc/fire_cracker.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/board.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/board.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628030   Available: 13575384
Inodes: Total: 5242880    Free: 4960134
14936 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/board.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628030   Available: 13575384
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <mail.h>
#include <board.h>;

inherit "/std/object";

string board_name;

mapping being_written;
int action_pri;

class info_written {
   string subject;
   int note_num;
}

int do_read_next();
int do_read_new();
int do_read(int num);
int do_followup(int num);
int do_reply(int num);
int do_eat(int num);
int do_post(string str);

void setup() {
   set_name("board");
   set_short("bulletin board");
   add_adjective("bulletin");
   set_main_plural("boards");
   reset_get();
   add_property("there", "mounted on one wall");
   add_property("survive fire", 1);
   add_help_file("board");
   board_name = "frog";
   being_written = ([ ]);
   action_pri = 0;
} /* setup() */

string query_plural() {
   mixed *stuff;

   stuff = (mixed *)BOARD_HAND->get_subjects(board_name);
   switch (sizeof(stuff)) {
   case 0:
      return pluralize(::short(0))+" [ Empty ]";
   case 1:
      return pluralize(::short(0))+" [ 1 note ]";
   }
   return pluralize(::short(0))+" [ "+sizeof(stuff)+" notes ]";
} /* query_plural() */

string short(int dark) {
   mixed *stuff;

   stuff = (mixed *)BOARD_HAND->get_subjects(board_name);
   switch (sizeof(stuff)) {
   case 0:
      return ::short(dark)+" [ Empty ]";
   case 1:
      return ::short(dark)+" [ 1 note ]";
   default:
      return ::short(dark)+" [ "+sizeof(stuff)+" notes ]";
   }
} /* short() */

string the_date(int i) {
   return ctime(i)[4..9];
} /* the_date() */

int do_subjects(string search) {
   int i, size;
   mixed *stuff;
   string ret;
   mapping news_rc;

   search = lower_case(search);
   
   stuff = (mixed *)BOARD_HAND->get_subjects(board_name);
   if (!sizeof(stuff)) {
      add_failed_mess("The board is completely empty.\n");
      return 0;
   }
   news_rc = BOARD_HAND->query_newsrc(this_player()->query_name());
   if (!news_rc) {
      news_rc = ([ ]);
   }
   ret = "";
   size = sizeof(stuff);
   for (i=0; i < size; i++) {
     if(search != "" && strsrch(lower_case(stuff[i][B_SUBJECT]), search) == -1)
       continue;
     
     if (news_rc[board_name] < stuff[i][B_TIME]) {
       ret += sprintf("N %2d: %-=*s\n", i+1,
                      (int)this_player()->query_cols()-6,
                      stuff[i][B_SUBJECT]+" ("+
                      stuff[i][B_NAME]+" "+the_date(stuff[i][B_TIME])+")");
     } else {
       ret += sprintf("  %2d: %-=*s\n", i+1,
                      (int)this_player()->query_cols()-6,
                      stuff[i][B_SUBJECT]+" ("+
                      stuff[i][B_NAME]+" "+the_date(stuff[i][B_TIME])+")");
     }
   }
   this_player()->set_finish_func(0);
   this_player()->more_string(ret);
   return 1;
} /* subjects() */

string long(string str, int dark) {
   int i,newones, size;
   mixed *stuff;
   string ret;
   mapping news_rc;

   stuff = (mixed *)BOARD_HAND->get_subjects(board_name);
   ret = "A bulletin board ("+board_name+").\n";
/*
   ret += sprintf("%#-*s\n\n", this_player()->query_cols(),
                             "read [note number]\nsubjects\n"+
                      (this_player()->query_property("guest")?"":
                             "post <subject>\neat <note number>\n"+
                             "reply <note number>\nfollowup <note number>\n"));
 */
   if (!sizeof(stuff)) {
      return ret+"The board is completely empty.\n";
   }
   news_rc = BOARD_HAND->query_newsrc(this_player()->query_name());
   if (!news_rc) {
      news_rc = ([ ]);
   }
   newones = 0;
   size = sizeof(stuff);
   for (i = 0; i < size; i++) {
      if (news_rc[board_name] < stuff[i][B_TIME]) {
         ret += sprintf("N %2d: %-=*s\n", i+1,
                     (int)this_player()->query_cols()-6,
                     stuff[i][B_SUBJECT]+" ("+
                     stuff[i][B_NAME]+" "+the_date(stuff[i][B_TIME])+")");
         newones +=1;
      } else if (news_rc[board_name] < stuff[i][B_TIME]+(2*24*60*60)) {
         ret += sprintf("  %2d: %-=*s\n", i+1,
                     (int)this_player()->query_cols()-6,
                     stuff[i][B_SUBJECT]+" ("+
                     stuff[i][B_NAME]+" "+the_date(stuff[i][B_TIME])+")");
      }
   }
   if (!newones) {
      ret += "\nNo new messages\n";
   }
   return ret;
} /* long() */

void add_commands() {
   add_command("read", "[new]", (: do_read_new :));
   add_command("r", "[new]", (: do_read_new :));
   add_command("read", "<number>", (: do_read($4[0]) :));
   add_command("r", "<number>", (: do_read($4[0]) :));
   add_command("read", "next", (: do_read_next :));

   if (!this_player()->query_property("guest")) {
      add_command("post", "<string'subject'>", (: do_post($4[0]) :));
      add_command("note", "<string'subject'>", (: do_post($4[0]) :)); 
      add_command("eat", "<number'message number'>", (: do_eat($4[0]) :));
      add_command("followup", "<number'message number'>",
                  (: do_followup($4[0]) :));
      add_command("reply", "<number'message number'>", (: do_reply($4[0]) :));
   }
   add_command("subjects", "", (: do_subjects("") :));
   add_command("subjects", "<string'search'>", (: do_subjects($4[0]) :));
} /* add_commands() */

void init() {
  if (!present("board master", this_player())) {
    add_commands();
  }
} /* init() */

void mark_mine(mixed *stuff, mapping news_rc) {
   int i;
   string their_name;

   i = sizeof(stuff)-1;
   their_name = this_player()->query_name();
   while (i > 0 && stuff[i][B_TIME] > news_rc[board_name])
      i--;
   while ((i+1) < sizeof(stuff) && lower_case(stuff[i+1][B_NAME]) == their_name)
      i++;
   if (i >= sizeof(stuff)) {
      news_rc[board_name] = stuff[sizeof(stuff)-1][B_TIME];
      return;
   }
   if (news_rc[board_name] > stuff[i][B_TIME])
      return;
   news_rc[board_name] = stuff[i][B_TIME];
} /* mark_mine() */


int do_read_next()  {
   mapping  news_rc;
   mixed   *stuff;
   string   their_name, sub, next_sub;
   int      num, last_time;

   news_rc = BOARD_HAND->query_newsrc(this_player()->query_name());
   if (undefinedp(news_rc["last board"])  ||
       news_rc["last board"] != board_name)
   {
      add_failed_mess("You have not read a note on this board yet!\n");
      return 0;
   }

   stuff = BOARD_HAND->get_subjects(board_name);
   num = sizeof(stuff);
   their_name = this_player()->query_name();

write("last time: " + ctime(news_rc["last time"]) + "\n");
   last_time = news_rc["last time"];
   while (num  &&  stuff[num - 1][B_TIME] > last_time)  {
      num--;
   }

   sub = news_rc["last sub"];
   sscanf(sub, "Re:#%*d %s", sub);

   for (++num; num <= sizeof(stuff); num++)  {
      next_sub = stuff[num - 1][B_SUBJECT];
      sscanf(next_sub, "Re:#%*d %s", next_sub);
      if (next_sub == sub)  {
         return do_read(num);
      }
   }

   add_failed_mess("No further notes in the thread \"" + sub + "\".\n");
   return 0;
} /* do_read_next() */
      
   
int do_read_new() {
   int num;
   string their_name;
   mapping news_rc;
   mixed *stuff;

   news_rc = BOARD_HAND->query_newsrc(this_player()->query_name());
   if (!news_rc) {
      news_rc = ([ ]);
   }
   stuff = (mixed *)BOARD_HAND->get_subjects(board_name);
   num = sizeof(stuff);
   their_name = (string)this_player()->query_name();
   while(num && (stuff[num - 1][B_TIME] > news_rc[board_name])) {
      num--;
   }
   while ((num < sizeof(stuff)) &&
          (lower_case(stuff[num][B_NAME]) == their_name)) {
      num++;
   }
   if (num == sizeof(stuff)) {
      add_failed_mess("No unread messages.\n");
      return 0;
   }
   num++;
   return do_read(num);
} /* do_read_new() */

int do_read(int num) {
   mapping news_rc;
   mixed *stuff;

   news_rc = BOARD_HAND->query_newsrc(this_player()->query_name());
   if (!news_rc) {
      news_rc = ([ ]);
   }
   stuff = (mixed *)BOARD_HAND->get_subjects(board_name);
   if (num < 0) {
      num = sizeof(stuff) + num + 1;
   }
   if (num < 1 || (num > sizeof(stuff))) {
      add_failed_mess("No note of that number.\n");
      return 0;
   }
   num--;
   news_rc["last board"] = board_name;
   news_rc["last time"] = stuff[num][B_TIME];
   news_rc["last sub"] = stuff[num][B_SUBJECT];
   if (news_rc[board_name] < stuff[num][B_TIME]) {
      news_rc[board_name] = stuff[num][B_TIME];
   }
   BOARD_HAND->set_newsrc(this_player()->query_name(), news_rc);

   this_player()->more_string(sprintf("%s\nNote #%d by %s posted at %s%s\nTitle: "
                                     "\"%s\"\n\n%s",
                                     "%^BOLD%^",
                                     (num + 1),
                                     stuff[num][B_NAME],
                                     ctime(stuff[num][B_TIME]),
                                     "%^RESET%^",
                                     stuff[num]
                                     [B_SUBJECT][0..(int)this_player()->
                                                 query_cols() - 10],
                                     (string)BOARD_HAND->
                                       get_message(board_name, num)),
                             "[Note "+ (num + 1) +"]");
   //add_succeeded_mess(({ "", "$N $V a note.\n" }), ({ }));
   add_succeeded_mess("", ({ }));

   return 1;
} /* do_read() */

int do_post(string str) {
   class info_written bing;

   if (board_name=="announcements" && !this_player()->query_creator()) {
      add_failed_mess("Sorry. You can't post messages here.  "
            "It's for announcements "
            "from the creators only.  If you have a comment or flame, try "
            "the 'flame' board or the 'frog' board.  Bing\n");
      return 0;
   }
   if (!str) {
      return 0;
   }

   if (this_player()->query_sp() < BOARD_SOCIAL_POINT_COST) {
      add_failed_mess("You need " + BOARD_SOCIAL_POINT_COST +
                      " social points to post a note.\n");
      return 0;
   }

   /*
    * ok shove the editing stuff in here.  Lets make it function string_edit
    * sound froggy?
    */
   /*
    string_edit("");
    body = string_edit_res;
    */
   if (!BOARD_HAND->test_can_write(board_name,
                                   this_object(),
                                   this_player()->query_name())) {
      add_failed_mess("You cannot write to this board.\n");
      return 0;
   }
   bing = new(class info_written);
   bing->subject = str;
   bing->note_num = 0;
   being_written[this_player()->query_name()] = bing;
   this_player()->do_edit(0, "end_of_thing");
   add_succeeded_mess(({ "", "$N looks like $r is "
                                        "contemplating a note.\n" }), ({ }) );
   return 1;
} /* do_post() */

void end_of_thing(string body) {
  class info_written bing;

  if (body && body != "" &&
      being_written[this_player()->query_name()]) {
    if(board_name != "announcements")
      body = sprintf( "%-=78s", body ) + this_player()->append_signature(); 
    
    bing = (class info_written)being_written[ this_player()->query_name() ];  
    if ( !BOARD_HAND->add_message( board_name,
         capitalize( (string)this_player()->query_name() ),
         bing->subject,
         body,
         bing->note_num ) ) {
      printf( "Error writing message.\n" );
    } else {
      printf("Message posted.\n");
      this_player()->adjust_sp(-50);
    }
  } else {
    printf( "No message posted.\n" );
  }
  map_delete(being_written, this_player()->query_name());
  return ;
} /* end_of_thing() */

int do_eat(int num) {
   if (!BOARD_HAND->delete_message(board_name, num-1)) {
      add_failed_mess("Failed to eat note.\n");
      return 0;
   }
  
   printf("You viciously tear off and eat note %d.\n", num);
   say( (string)this_player()->one_short() +
         " viciously tears off and eats note "+ num +".\n" );
   event( users(), "inform", (string)this_player()->query_name() +
         " eats a note off "+ board_name, "message", this_player() );
   return 1;
} /* eat() */

int do_followup(int num) {
   int i;
   mixed stuff;
   string s;
   class info_written bing;

   stuff = (mixed *)BOARD_HAND->get_subjects(board_name);

   if (num < 0) {
      num = sizeof(stuff) + num + 1;
   }

   if (num < 1 || num > sizeof(stuff)) {
      add_failed_mess("No note of that number.\n", ({ }));
      return 0;
   }

   if (this_player()->query_sp() < BOARD_SOCIAL_POINT_COST) {
      add_failed_mess("You need " + BOARD_SOCIAL_POINT_COST +
                      " social points to post a note.\n");
      return 0;
   }

   /*
    * If there is a reply type, means we do something other than 
    * post to this board.
    */
   if (!stuff[num - 1][B_REPLY_TYPE] &&
       !BOARD_HAND->test_can_write(board_name,
                                   this_object(),
                                   this_player()->query_name())) {
      add_failed_mess("You cannot followup to this board.\n", ({ }));
      return 0;
   }

   bing = new(class info_written);
   if (sscanf(stuff[num - 1][B_SUBJECT], "Re:#%d %s", i, s) != 2) {
      bing->subject = "Re:#1 "+ stuff[num - 1][B_SUBJECT];
   } else {
      bing->subject = "Re:#"+ ( i + 1 ) +" "+ s;
   }
   bing->note_num = stuff[num - 1][B_NUM];
   being_written[(string)this_player()->query_name()] = bing;
   printf("Include original post? (y/[n]) ");
   input_to("include_post", 0, num - 1, stuff[num - 1]);
   add_succeeded_mess(({ "", "$N looks like $r is "
                                        "contemplating a note.\n" }), ({ }) );
   return 1;
} /* do_followup() */

void include_post(string str, int num, mixed *stuff) {
  if (!str || str == ""  || lower_case(str)[0] != 'y') {
    printf("No.\n");
    this_player()->do_edit(0, "end_of_thing");
    return;
  }

  if (this_player()->query_name() == "macchirton") {
    printf("No including notes for pointless and repeated abuse.\n");
    this_player()->do_edit(0, "end_of_thing");
    return;
  }

  this_player()->
    do_edit("On " + ctime(stuff[B_TIME]) + ", " + stuff[B_NAME] +
            " wrote:\n> " +
            replace_string(BOARD_HAND->get_message(board_name, num),
                                  "\n", "\n> ") + "\n", "end_of_thing");
} /* include_post() */
  
int do_reply(int num) {
   mixed stuff;

   stuff = (mixed *)BOARD_HAND->get_subjects(board_name);
   if (num < 1 || num > sizeof(stuff)) {
      add_failed_mess("No note of that number.\n", ({ }));
      return 0;
   }
   MAIL_TRACK->mail(stuff[num-1][B_NAME], stuff[num-1][B_SUBJECT]);
   add_succeeded_mess(({ "", "$N looks like $r is "
                                        "contemplating a note.\n" }), ({ }) );
   return 1;
} /* reply() */

void set_board_name(string str) { board_name = str; }
void set_datafile(string str) { board_name = str; }

int query_new_messages() {
   mixed *notes;
   mapping news_rc;

   news_rc = BOARD_HAND->query_newsrc(this_player()->query_name());
   if (!news_rc)
      news_rc = ([ ]);
   notes = (mixed *)BOARD_HAND->get_subjects(board_name);
   if (!sizeof(notes))
      return 0;
   return (notes[sizeof(notes)-1][B_TIME] > news_rc[board_name]);
} /* query_new_messages() */
// --- END [/mnt/home2/grok/lib/obj/misc/board.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/locks/basic_door_lock.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/locks/basic_door_lock.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628027   Available: 13575381
Inodes: Total: 5242880    Free: 4960134
375 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/locks/basic_door_lock.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628027   Available: 13575381
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/obj/misc/lock";

void setup() {
   set_name("lock");
   set_short("basic door lock");
   add_adjective( ({ "basic", "door" }));
   set_long("A basic brass door lock.\n");
   add_property("difficulty", 2);
   set_weight(19);
   set_value(20000);
}

void set_key_number(int num) {
   add_property("key prop", "door_lock_"+num);
   add_property("locktype", "door");
}
// --- END [/mnt/home2/grok/lib/obj/misc/locks/basic_door_lock.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/locks/flimsy_door_lock.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/locks/flimsy_door_lock.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628026   Available: 13575380
Inodes: Total: 5242880    Free: 4960134
378 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/locks/flimsy_door_lock.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628026   Available: 13575380
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/obj/misc/lock";

void setup() {
   set_name("lock");
   set_short("flimsy door lock");
   add_adjective( ({ "flimsy", "door" }));
   set_long("A flimsy brass door lock.\n");
   add_property("difficulty", 1);
   set_weight(19);
   set_value(10000);
}

void set_key_number(int num) {
   add_property("key prop", "door_lock_"+num);
   add_property("locktype", "door");
}
// --- END [/mnt/home2/grok/lib/obj/misc/locks/flimsy_door_lock.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/locks/standard_door_lock.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/locks/standard_door_lock.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628026   Available: 13575380
Inodes: Total: 5242880    Free: 4960134
384 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/locks/standard_door_lock.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628026   Available: 13575380
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/obj/misc/lock";

void setup() {
   set_name("lock");
   set_short("standard door lock");
   add_adjective( ({ "standard", "door" }));
   set_long("A standard brass door lock.\n");
   add_property("difficulty", 4);
   set_weight(19);
   set_value(40000);
}

void set_key_number(int num) {
   add_property("key prop", "door_lock_"+num);
   add_property("locktype", "door");
}
// --- END [/mnt/home2/grok/lib/obj/misc/locks/standard_door_lock.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/locks/furniture_key.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/locks/furniture_key.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628026   Available: 13575380
Inodes: Total: 5242880    Free: 4960134
621 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/locks/furniture_key.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628026   Available: 13575380
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/key";

void set_lock_number(int num) {
   set_key("small furniture", "furniture_lock_" + num);
   set_long("A small key, it looks like it would be "
            "suitable for a piece of furniture.\n");
   set_value(10);
} /* set_lock_number() */

// This is the func name other keys and the shops use...
void set_key_number( int num ){
  set_lock_number(num);
}

mapping query_static_auto_load() {
   return int_query_static_auto_load();
} /* query_static_auto_load() */

/**
 * Allows the keys to be duplicated if it returns 1.
 * @return always returns 1
 */
int query_duplicatable_key() {
   return 1;
}
// --- END [/mnt/home2/grok/lib/obj/misc/locks/furniture_key.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/locks/chubby_special_door_lock.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/locks/chubby_special_door_lock.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628025   Available: 13575379
Inodes: Total: 5242880    Free: 4960134
759 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/locks/chubby_special_door_lock.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628025   Available: 13575379
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/obj/misc/lock";

void setup() {
   set_name("lock");
   set_short("chubby special door lock");
   add_adjective( ({ "chubby", "special", "door" }));
   set_long("A chubby special brass door lock.  These high-quality "
                     "locks are made by Grabthroat Shinkicker and Sons.  "
                     "Contrary to popular belief the locks are called "
                     "chubby's not because of their thickness but because "
                     "Grabthroat's real name is Charles and his "
                     "nickname is Chubby.\n");
   add_property("difficulty", 8);
   set_weight(19);
   set_value(160000);
}

void set_key_number(int num) {
   add_property("key prop", "door_lock_"+num);
   add_property("locktype", "door");
}
// --- END [/mnt/home2/grok/lib/obj/misc/locks/chubby_special_door_lock.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/locks/brass_door_key.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/locks/brass_door_key.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628025   Available: 13575379
Inodes: Total: 5242880    Free: 4960134
485 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/locks/brass_door_key.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628025   Available: 13575379
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/key";

void set_key_number(int num) {
   set_key("small brass", "door_lock_" + num);
   set_long("A small brass key.  It has a serial number " +
            num + " engraved on it.\n");
   set_value(10);
} /* set_key_num() */

mapping query_static_auto_load() {
   return int_query_static_auto_load();
} /* query_static_auto_load() */

/**
 * Allows the keys to be duplicated if it returns 1.
 * @return always returns 1
 */
int query_duplicatable_key() {
   return 1;
}
// --- END [/mnt/home2/grok/lib/obj/misc/locks/brass_door_key.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/locks/basic_furniture_lock.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/locks/basic_furniture_lock.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628025   Available: 13575379
Inodes: Total: 5242880    Free: 4960134
400 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/locks/basic_furniture_lock.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628025   Available: 13575379
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/obj/misc/lock";

void setup() {
   set_name("lock");
   set_short("basic furniture lock");
   add_adjective( ({ "basic", "furniture" }));
   set_long("A basic brass furniture lock.\n");
   add_property("difficulty", 1);
   set_weight(19);
   set_value(10000);
}

void set_key_number(int num) {
   add_property("key prop", "furniture_lock_"+num);
   add_property("locktype", "furniture");
}
// --- END [/mnt/home2/grok/lib/obj/misc/locks/basic_furniture_lock.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/locks/chubby_standard_door_lock.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/locks/chubby_standard_door_lock.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628024   Available: 13575378
Inodes: Total: 5242880    Free: 4960134
785 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/locks/chubby_standard_door_lock.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628024   Available: 13575378
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/obj/misc/lock";

void setup() {
   set_name("lock");
   set_short("chubby standard door lock");
   add_adjective( ({ "chubby", "standard", "door" }));
   set_long("A chubby standard brass door lock.  These "
                     "high-quality "
                     "locks are made by Grabthroat Shinkicker and Sons.  "
                     "Contrary to popular belief the locks are called "
                     "chubby's not because of their thickness but because "
                     "Grabthroat's real name is Charles and his "
                     "nickname is Chubby.\n");
   add_property("difficulty", 6);
   set_weight(19);
   set_value(80000);
}

void set_key_number(int num) {
   add_property("key prop", "door_lock_"+num);
   add_property("locktype", "door");
}
// --- END [/mnt/home2/grok/lib/obj/misc/locks/chubby_standard_door_lock.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/locks/chubby_ultra_door_lock.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/locks/chubby_ultra_door_lock.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628024   Available: 13575378
Inodes: Total: 5242880    Free: 4960134
754 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/locks/chubby_ultra_door_lock.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628024   Available: 13575378
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/obj/misc/lock";

void setup() {
   set_name("lock");
   set_short("chubby ultra door lock");
   add_adjective( ({ "ultra", "chubby", "door" }));
   set_long("A chubby ultra brass door lock.  These high-quality "
                     "locks are made by Grabthroat Shinkicker and Sons.  "
                     "Contrary to popular belief the locks are called "
                     "chubby's not because of their thickness but because "
                     "Grabthroat's real name is Charles and his "
                     "nickname is Chubby.\n");
   add_property("difficulty", 10);
   set_weight(19);
   set_value(300000);
}

void set_key_number(int num) {
   add_property("key prop", "door_lock_"+num);
   add_property("locktype", "door");
}
// --- END [/mnt/home2/grok/lib/obj/misc/locks/chubby_ultra_door_lock.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/locks/standard_furniture_lock.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/locks/standard_furniture_lock.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628024   Available: 13575378
Inodes: Total: 5242880    Free: 4960134
409 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/locks/standard_furniture_lock.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628024   Available: 13575378
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/obj/misc/lock";

void setup() {
   set_name("lock");
   set_short("standard furniture lock");
   add_adjective( ({ "standard", "furniture" }));
   set_long("A standard brass furniture lock.\n");
   add_property("difficulty", 2);
   set_weight(19);
   set_value(10000);
}

void set_key_number(int num) {
   add_property("key prop", "furniture_lock_"+num);
   add_property("locktype", "furniture");
}
// --- END [/mnt/home2/grok/lib/obj/misc/locks/standard_furniture_lock.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/housing_creator.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/housing_creator.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628023   Available: 13575377
Inodes: Total: 5242880    Free: 4960134
7134 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/housing_creator.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628023   Available: 13575377
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*
 * House creation object
 */
inherit "/std/object";

#include <housing.h>

#define ORIENTATION ({ "north", "northeast", "east", "southeast", "south", "southwest", "west", "northwest", "up" })
#define OPP_ORIENTATION ({ "south", "southwest", "west", "northwest", "north", "northeast", "east", "southeast", "down" })

#define PATH "/std/houses/"

int do_create(string type, string orientation, string location, string out,
              string region, string address, int overwrite,
              int test);
string list_plans();

void setup() {
  set_name("ball");
  set_short("small jade ball");
  add_adjective(({"small", "jade"}));
  set_long("This non-descript jade ball can be used to make player houses.\n");
  set_read_mess((: list_plans() :));
  set_weight(1);
  set_value(0);
  seteuid("Room");
}

void init() {
  this_player()->add_command("make", this_object(),
           "<word'floor plan'> <word'orientation'> "
           "<word'location'> <word'outside'> <word'region'> <string:quoted'address'>",
           (: do_create($4[0], $4[1], $4[2], $4[3], $4[4], $4[5], 0, 1) :) );
  this_player()->add_command("makereal", this_object(),
           "<word'floor plan'> <word'orientation'> "
           "<word'location'> <word'outside'> <word'region'> <string:quoted'address'>",
           (: do_create($4[0], $4[1], $4[2], $4[3], $4[4], $4[5], 0, 0) :) );
  this_player()->add_command("maketest", this_object(),
           "<word'floor plan'> <word'orientation'> "
           "<word'location'> <word'outside'> <word'region'> <string:quoted'address'>",
           (: do_create($4[0], $4[1], $4[2], $4[3], $4[4], $4[5], 1, 1) :) );
}

string list_plans() {
  string ret, str;
  string plan;
  
  ret = "To create a house use:\n"
    "  'make <floor plan> <orientation> <location> <outside> <region>\n"
    "        <address>' where:\n"
    "  'makereal <floor plan> <orientation> <location> <outside> <region>\n"
    "        <address>' where:\n"
    "  'makeforce <floor plan> <orientation> <location> <outside> <region>\n"
    "        <address>' where:\n"
    "  floor plan is one of the standard floor plans\n"
    "  orientation is its orientation (ie. the direction you enter it to)\n"
    "  location is the directory to write the houses files into\n"
    "  address is a the unique address for the house\n"
    "  region is the region of the house\n"
    "The 'makereal' command will add the house into the housing handler, "
    "the 'make' command will do a normal test make and the 'makeforce' "
    "will overwrite any existing housing files.\n\n"
    "Example:\n"
    "$I$5=   makereal twobedhouse south /d/am/fluff/housing OUT+room1 am \"12 Fluff Street\"\n\n$I$0="
    "The following floorplans are available:\n";

  str = "";
  foreach(plan in get_dir(PATH + "*")) {
    if(plan != "." && plan != ".." && file_size(PATH + plan) == -2 )
      str += plan + "\n";
  }
  
  ret += sprintf("%-#*s", this_player()->query_cols(), str);
  return ret;
}

int do_create(string type, string orientation, string location, string out,
              string region, string address, int overwrite,
              int test) {
  string room;
  string tmp;
  string fname;
  mapping files;
  mapping main_file;
  string number;
  int orient;
  int i;
  
  if(file_size(PATH+type) != -2) {
    return notify_fail("No such floor plan\n");
  }

  orient = member_array(orientation, ORIENTATION);
  if(orient == -1) {
    return notify_fail("No such orientation.\n");
  }

  if(file_size(location) != -2) {
    return notify_fail("No such location.\n");
  }
  
  // Get the number from the address.
  if (address[0] < '0' || address[0] > '9') {
     add_failed_mess("Address must start with a number.\n");
     return 0;
  }

  i = 0;
  do {
     i++;
  } while (address[i] != ' ');
  number = address[0..i-1];
  address = address[i..];

  // Try and figure out the real 'out' exit.
  if (out[0] == '/') {
     if (out[<2..] == ".c") {
        out = out[0..<3];
     }
     out = "\"" + out + "\"";
  } else {
     // If there is a '+' in here assume we have a define.
     // Otherwise put a PATH + in front.
     if (member_array('+', out) == -1) {
        out = "PATH+\"" + out + "\"";
     }
  }

  files = ([ ]);
  main_file = ([ ]);
  if (type[<1] != 'M') {
     main_file[""] = 0;
  }

  foreach(room in get_dir(PATH+type+"/*.c")) {
    fname = location + "/" + replace_string(room, "N", number);
    if(file_size(fname) != -1 && !overwrite) {
      write("Error: file already exists: " + fname + ".\n");
      continue;
    }
    
    tmp = read_file(PATH+type+"/"+room);
    if(!tmp || tmp == 0) {
      return notify_fail("Error reading " + PATH+type+"/"+room + ".\n");
    }

    // exit and wall stuff, figuring out correct orientation.
    for(i=0; i<sizeof(ORIENTATION); i++) {
      tmp = replace_string(tmp, "%"+i+"%", ORIENTATION[(i + orient) % 8]);
    }

    // House number
    tmp = replace_string(tmp, "%N%", number);
    // Save directory
    tmp = replace_string(tmp, "%savedir%", "SAVE_DIR");
    if (strsrch(tmp, "MAIN ROOM") != -1) {
       if (type[<1] == 'M') {
          main_file[room[1..1]] = fname;
       } else {
          main_file[""] = fname;
       }
    } else {
       if (type[<1] == 'M') {
          if (!files[room[1..1]]) {
             files[room[1..1]] = ({ });
          }
          files[room[1..1]] += ({ fname });
       } else {
          if (!files[""]) {
             files[""] = ({ });
          }
          files[""] += ({ fname });
       }
    }
    tmp = replace_string(tmp, "%out%", out);
    tmp = replace_string(tmp, "%orientation%", "" + (orient % 2));
    write("Writing " + fname + ".\n");
    write_file(fname, tmp, 1);
  }

  // Add the house into the housing handler.
  if (!test) {
     foreach (tmp, room in main_file) {
        if (tmp == "-") {
           continue;
        }
        if (!room) {
           room = files[tmp][0];
           files[tmp] = files[tmp][1..];
        }
        if (room[<2..] == ".c") {
           room = room[0..<3];
        }
        if (files[tmp]) {
           files[tmp] = map(files[tmp], (: ($1[<2..] == ".c"?$1[0..<3]:$1) :));         } else {
           files[tmp] = ({ });
        }
        HOUSING->add_house(room, files[tmp], number + tmp + address, region, 1);
        HOUSING->set_for_sale(room);
     }
  }


  if (!main_file["-"]) {
     tmp = main_file[""];
  } else {
     tmp = main_file["-"];
  }

  write("You need to put the following code into " + out + " if the "
        "house entrance is a door (NB "
        "if you are doing this as an up/down exit then change the "
        "direction set below):\n");
  write("   add_exit(\"" + orientation + "\", \"" + tmp + "\", \"door\");\n");
  write("   \"" + tmp + "\"->setup_doors(); // this may not be needed check\n\n");
  write("You need to put the following code into " + out + " if the "
        "house entrance is not a door:\n");
  write("   add_exit(\"" + orientation + "\", \"" + tmp + "\", \"path\");\n");
  return 1;
}

void init_dynamic_arg(mapping map) {
   ::init_dynamic_arg(map);
   set_read_mess( (: list_plans() :) );
} /* init_dynamic_arg() */
// --- END [/mnt/home2/grok/lib/obj/misc/housing_creator.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/nroff_paper.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/nroff_paper.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628021   Available: 13575375
Inodes: Total: 5242880    Free: 4960134
1375 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/nroff_paper.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628021   Available: 13575375
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/obj/misc/paper";
#include "nroff.h"

/* This will nroff to a file in the same dir. */

private nosave mixed *stuff = ({ });

string file_name = 0;
string language = 0;

void create() {
  seteuid(getuid());
  ::create();
}

void set_file_name(string fname) {
  file_name = fname;
}

string query_file_name() { return file_name; }

void set_language(string lang) { language = lang; }

string query_language() { return language; }

mixed *query_read_mess() {
  string str;

  if(sizeof(stuff) == 0) {
    if (file_name) {
      str = unguarded( (: NROFF_HAND->cat_file(file_name+"_nroff", 1) :) );
      if (!str) {
        unguarded((: NROFF_HAND->create_nroff(file_name, file_name+"_nroff") :));
        str = unguarded( (: NROFF_HAND->cat_file(file_name+"_nroff", 1) :) );
      }
      
      if(!str)
        return ::query_read_mess() +
          ({ ({ "Unable to nroff file.\n", 0, "common", 0 }) });
      
      if( language ) {
         return stuff = ({ ({ str, 0, language, 0 }) });
      }
      
      return stuff = ({ ({ str, 0, "common", 0 }) });
    }
  }
  
  return stuff + ::query_read_mess();
}


mapping query_dynamic_auto_load() {
   mapping map;

   map = ::query_dynamic_auto_load();
   map["read mess"] = ::query_read_mess();

   return map;
   
} /* query_dynamic_auto_load() */
// --- END [/mnt/home2/grok/lib/obj/misc/nroff_paper.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/paper.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/paper.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628021   Available: 13575375
Inodes: Total: 5242880    Free: 4960134
4614 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/paper.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628021   Available: 13575375
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * Generic piece of writing paper
 * @author unknown, lost in the rivers of time
 */

#include <playtesters.h>

#define AUTO_LOAD_TAG "paper"

inherit "/std/object";

/* Function prototypes */
int do_uncrumple();
int do_crumple();
int do_eat();

/* Global variables */

private int _crumpled;
private string _old_short;

void create() {
   do_setup++;
   ::create();
   do_setup--;

   set_name( "paper" );
   set_short( "piece of writing paper" );
   add_adjective( ({ "piece of", "writing" }) );
   set_main_plural( "pieces of writing paper" );
   add_plural( "pieces of writing paper" );
   add_adjective(({ "piece", "pieces", "of", "writing" }));
   set_long( "This is a nice sheet of writing paper.\n" );
   set_value( 25 );
   set_weight( 0 );
   add_property( "writeable", 1 );
   add_property( "paper", 1 );
   set_max_size( 1000 );

   if ( !do_setup ) {
      this_object()->setup();
   }

} /* create() */

void init() {
   if ( !this_player() ) {
       return;
   }

   add_command( "eat", "<direct:object>", (: do_eat :) );
   add_command( "crumple", "<direct:object>", (: do_crumple :) );
   add_command( "untangle", "<direct:object>", (: do_uncrumple :) );
   add_command( "uncrumple", "<direct:object>", (: do_uncrumple :) );

/*
   if ( PLAYTESTER_HAND->query_tester( this_player() ) ) {
      ORIGAMI_HANDLER->add_origami_commands( this_player(), this_object() );
   }*/

} /* init() */

/**
 * This method checks to see whether or not this piece of paper is
 * edible.
 * @return 1 if the object is edible.
 */
public int query_edible() {
    return 1;
} /* query_edible() */

/**
 * This method checks to see whether or not this item is a piece of
 * paper.
 * @return 1 if the item is a piece of paper
 */
public int query_paper() {
   return 1;
} /* query_paper() */

/** @ignore yes */
int do_crumple() {
   if (_crumpled) {
      add_failed_mess("$D is already crumpled.\n");
      return 0;
   }
   _old_short = query_short();

   call_out( (: set_short :), 1, "crumpled up " + query_short() );
   _crumpled = 1;
   return 1;
} /* do_crumple() */

/** @ignore yes */
int do_uncrumple() {
    if (!_crumpled) {
        add_failed_mess("$D is already uncrumpled.\n");
        return 0;
    }

    // We do this in the call_out to make sure that the messages are
    // set properly.

    call_out( (: set_short :), 1, _old_short );
   _crumpled = 0;
   return 1;
} /* do_untangle() */

int do_eat() {
   string *flavours = ({ "red ink", "green ink", "black ink",
       "blue ink", "orange", "apple", "cinnamon", "banana",
       "monkey", "cabbage", "hat" });

   add_succeeded_mess( ({ "You open your mouth up widely and pop $D into "
      "your mouth.  After a moment's deliberation, you chew and consume "
      "$D.\n", "$N $V $D.\n" }) );

   call_out( (: tell_object( $1, $2 ) :), 1,
       this_player(), "Mmm! " +
       capitalize( flavours[random( sizeof( flavours ) ) ] ) +
       " flavoured!\n" );

   move( "/room/rubbish" );
   return 1;
} /* do_eat() */

/** @ignore yes */
string query_readable_message(object player, int ignore_labels) {
   if (!_crumpled) {
      return ::query_readable_message(player, ignore_labels);
   }
   return "Only bits of ink can be seen on the crumpled paper.\n";
} /* query_readable_message() */

/** @ignore yes */
string *parse_command_adjectiv_id_list() {
   if (_crumpled) {
      return ::parse_command_adjectiv_id_list() + ({ "crumpled", "up" });
   }
   return ::parse_command_adjectiv_id_list();
} /* parse_command_adjectiv_id_list() */

/** @ignore yes */
mapping query_dynamic_auto_load() {
    mapping map;

    map = ::query_dynamic_auto_load();

    add_auto_load_value( map, AUTO_LOAD_TAG, "crumpled", _crumpled );
    add_auto_load_value( map, AUTO_LOAD_TAG, "old short", _old_short );

    return map;
} /* query_dynamic_auto_load() */

/** @ignore yes */
void init_dynamic_arg( mapping map, object ) {
    ::init_dynamic_arg(map);

    if (map) {
        _crumpled = query_auto_load_value( map, AUTO_LOAD_TAG, "crumpled" );
        _old_short = query_auto_load_value( map, AUTO_LOAD_TAG, "old short" );

        // These can be removed at a later date.

        if ( map[ "paper - crumpled" ] ) {
            _crumpled = map[ "paper - crumpled" ];
        }

        if ( map[ "paper - short" ] ) {
            _old_short = map[ "paper - short" ];
        }
    }
} /* init_dynamic_arg() */

/** @ignore yes */
mapping query_static_auto_load() {
   if ( explode( file_name( this_object() ), "#" )[ 0 ] != "/obj/misc/paper" )
      return ([ ]);
   return int_query_static_auto_load();
} /* query_static_auto_load() */

// --- END [/mnt/home2/grok/lib/obj/misc/paper.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/lantern.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/lantern.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628019   Available: 13575373
Inodes: Total: 5242880    Free: 4960134
1680 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/lantern.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628019   Available: 13575373
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*      lantern.c
        
        This file was constructed by Godot (Marshall Buhl).  If you
        make any changes to it, please leave comments in the code
        detailing the changes and let him know about them.  This file
        is not the original, so it is important that he be informed.
        If not, he may unknowingly throw away your changes by
        uploading an new version.
 
        This is a modification of the standard torch.
 
    Change log:
 
        11/26/92 - Created by Godot.
        11/28/92 - Modified by Godot to add prototype for init_arg().
        2 May 93 - Modified by Pinkfish to use failed_mess and succeeded_mess.
        13 Apr 95 - Fixed by Ceres for bug reports
        15 Okt 96 - Mostly rewritten by Turrican to make it a bit nicer.
         5 Jun 97 - Rewritten for the fuel_handler
        August 2001 - Siel: Placed the code in an inherit named
                      /obj/handlers/non_refuelling_lantern.c and kept the 
                      descriptions here only.
*/

inherit "/obj/lantern";

void setup() {
   fuel_left = 3600;
   is_lit    = 0;
   
   set_name( "lantern" );
   set_main_plural( "lanterns");
   set_short( "lantern" );
   add_help_file("torch");
   
   set_long(function() {
     string str;
     
     str = "This is a camping lantern, which smells of lamp oil.\n";
     if ( is_lit ) {
       return str + "The wick flickers inside spreading a dull "
         "glow.\n";
     }
     str += "The lantern is not lit, and ";
     if ( !fuel_left )
       return str + "is out of oil.\n";
     return str + "has some oil left in it.\n";
   } );
   set_weight( 60 );
   set_value( 150 );
}

// --- END [/mnt/home2/grok/lib/obj/misc/lantern.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/club_badge.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/club_badge.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628019   Available: 13575373
Inodes: Total: 5242880    Free: 4960134
2670 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/club_badge.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628019   Available: 13575373
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * The club badge.  What fun!
 * @author Pinkfish
 * @started Sun Oct  4 04:23:52 EDT 1998
 */
#include <clubs.h>
#include <broadcaster.h>
inherit "/obj/clothing";
inherit "/std/basic/club_insignia";

protected int club_members(int online);
protected int do_recruit(object *players, string club);
protected int club_chat(string str, int emote);
protected int club_members(int online);
protected int club_info();
protected int do_history();

private string *extra_adjs;

/** @ignore yes */
void setup() {
   extra_adjs = ({ });

   set_name("badge");
   add_adjective("club");
   set_type("badge");
   set_short("club badge");
   setup_clothing(1000);
   set_damage_chance(5);
   set_long("The badge is a nice blue colour with a fringe "
            "like a bunny rabbit.\n");
   add_extra_look(this_object());
} /* setup() */

/**
 * Print out some terribly using extra information.
 * @return the useful extra information
 */
string extra_look() {
   string tmp_name;

   if (query_club() &&
       CLUB_HANDLER->is_member_of(query_club(), this_player()->query_name())) {
      tmp_name = replace(lower_case(query_club()), " ", "_");
      return "  You feel like the command '" + tmp_name + "' does something.\n";
   }
   return "\n";
} /* extra_look() */

/**
 * @ignore yes
 */
void init() {
   //clothing::init();
   club_insignia::init();
} /* init() */

/** @@ignore yes */
mapping query_dynamic_auto_load(mapping map) {
   map = clothing::query_dynamic_auto_load();
   map = club_insignia::query_dynamic_auto_load(map);
   map["verSion"] = 1;
   return map;
} /* query_dynamic_auto_load() */

/** @@ignore yes */
void init_dynamic_arg(mapping map) {
   if (map["verSion"] != 1) {
      clothing::init_dynamic_arg(map["::"]);
   } else {
      clothing::init_dynamic_arg(map);
   }
   club_insignia::init_dynamic_arg(map);
} /* init_dynamic_arg() */

/** @ignore yes */
void set_club(string name) {
   if (!name) {
      extra_adjs = ({ });
      set_short("club badge");
   } else {
      if (CLUB_HANDLER->is_club(name)) {
         name = CLUB_HANDLER->query_club_name(name);
         extra_adjs = explode(lower_case(name), " ");
         // Keep track of the extra adjectives.
         //if (!CLUB_HANDLER->query_club_secret(name)) {
            //set_short(name + " club badge");
         //} else {
            set_short("club badge");
         //}
      }
   }
   ::set_club(name);
} /* set_club() */

/** @ignore yes */
string *parse_command_adjectiv_id_list() {
   return ::parse_command_adjectiv_id_list() +
           extra_adjs;
} /* parse_command_adjectiv_id_list() */

mixed *stats()
{
  return clothing::stats() + 
    club_insignia::stats();
}
// --- END [/mnt/home2/grok/lib/obj/misc/club_badge.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/papers/paper_file.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/papers/paper_file.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628018   Available: 13575372
Inodes: Total: 5242880    Free: 4960134
527 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/papers/paper_file.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628018   Available: 13575372
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* This will deal with happy and fluffy files. and turn them into a page. */
inherit "/obj/misc/paper";

string file_name;

void create() {
  seteuid(getuid());
  ::create();
} /* create() */

void set_file_name(string fname) {
  file_name = fname;
} /* set_file_name() */

string query_file_name() {
  return file_name;
} /* query_file_name() */

mixed *query_read_mess() {
  return read_file(file_name);
} /* query_read_mess() */

void init() {
  this_player()->add_command("read", this_object());
  ::init();
} /* init() */
// --- END [/mnt/home2/grok/lib/obj/misc/papers/paper_file.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/menu.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/menu.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628018   Available: 13575372
Inodes: Total: 5242880    Free: 4960134
819 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/menu.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628018   Available: 13575372
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/object";
#include <language.h>

//int do_read();

object our_pub;

void create() {
  ::create();
  set_name("menu");
  set_long("This is a menu.\n");
  reset_get();
}

void set_pub(object pub) { 
  our_pub = pub; 
  add_read_mess(our_pub->read(), "printed letters", our_pub->query_language());
}

object query_pub() { return our_pub; }

void init() {
  this_player()->add_command( "list", this_object(), "" );
}

string query_readable_message(object player) {
   string lang;
   string mess;

   mess = our_pub->read();
   lang = our_pub->query_language();

   mess = LANGUAGES->garble_text(lang, mess, this_object(), player);
   return mess;
} /* query_reable_message() */

int do_list() {
  write(query_readable_message(this_player()));
  add_succeeded_mess(({ "", "$N read$s $D.\n" }));
  return 1;
}

// --- END [/mnt/home2/grok/lib/obj/misc/menu.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/golem_finger.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/golem_finger.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628017   Available: 13575371
Inodes: Total: 5242880    Free: 4960134
454 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/golem_finger.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628017   Available: 13575371
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*
 * $Id$
 */

/* Finger of a golem */

inherit "/std/object";

void setup() {
    set_name( "fingertip" );
    set_short( "broken clay fingertip" );
    add_adjective( ({"broken", "clay"}) );
    set_long( "This looks like a crude fingertip made of clay.  It is broken "
       "in the middle.\n" );
    set_main_plural( "broken clay fingertips" );
    set_weight( 5 );
    set_value( 0 );
    add_property( "no recycling", 1 );
} /* void setup() */


// --- END [/mnt/home2/grok/lib/obj/misc/golem_finger.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/wallpaper_glue.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/wallpaper_glue.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628017   Available: 13575371
Inodes: Total: 5242880    Free: 4960134
1654 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/wallpaper_glue.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628017   Available: 13575371
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
  *  Wallpaper glue.  Used in conjunction with /obj/misc/wallpaper and a paint   
  *  brush to decorate the walls of playerhouses.
  *
  *  One pot used per wall.
  *
  *  When adding this object to shops, please call add_glue() on the pot.  
  *  This will give it one application's worth of glue.
  *
  *  @author Una
  *  @date August 27th, 2002
  *
  **/

inherit "/obj/vessel";
 
#define VOLUME 5000
  
object add_glue();  
  
void setup() {
  
    set_name("glue");
    set_short("pot of wallpapering glue");
    add_adjective( ({ "pot", "of", "wallpapering", "wallpaper" }) );
    add_alias("pot");
    add_plural("pots");
    set_max_volume(VOLUME);
    set_long("This is a small pot of wallpapering glue, essential "
        "for anybody who's going to be doing anything involving "
        "sticking paper to walls or playing mean tricks on their "
        "friends.\n");
    set_value(480);
    set_closed();
       
} /* setup() */

object add_glue() {

    object glue;
    
    glue = clone_object( "/obj/reagents/generic_liquid.ob" );
    glue->set_name( "glue" );
    glue->set_short( "sticky white wallpapering glue" );
    glue->add_adjective( ({ "sticky", "white", "wallpapering", 
        "wallpaper"  }));
    glue->set_amount( VOLUME );
    glue->set_continuous();
    glue->set_long( "This is some thick and gloopy wallpapering glue.  "
        "Along with some wallpaper and a brush, you could probably "
        "do some fine home decorating.\n");
    glue->set_pile_name( "puddle" );
    glue->add_eat_effect( "/std/effects/ingested/poison", 10 );
    glue->move( this_object() );
    
    return glue;

} /* add_glue() */
// --- END [/mnt/home2/grok/lib/obj/misc/wallpaper_glue.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/top_ten_tables.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/top_ten_tables.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628016   Available: 13575370
Inodes: Total: 5242880    Free: 4960134
2921 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/top_ten_tables.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628016   Available: 13575370
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <top_ten_tables.h>

inherit "/std/object";

string generate_list( mixed *args );
string generate_table_message();

nosave string table_name;
nosave string language = "morporkian";

void setup() {
   table_name = 0;
   set_name( "table" );
   set_short( "top ten table" );
   set_long( "This is a perfectly rectangular wooden board, "
     "nailed to another piece of wood.\n" );
   add_adjective( ({ "top", "ten", "score" }) );
   reset_get();
   add_property( "there", "in one corner" );
   add_property( "survive fire", 1 );
   //You have 5 seconds to change the language to something else.
   call_out( "setup_read_mess", 5 );
   call_out("dest_me", 30);
} /* setup() */

string query_table_name() { return table_name; }

void set_table_name( string word ) { table_name = word; }

void set_language( string lang ) {
  language = lang;
}

void setup_read_mess() {
   add_read_mess((: generate_table_message() :), 0, language, 0);
}

string generate_table_message() {
   string long;
   mixed *args;

   long = "\nHigh Score Table: ";
   args = (mixed *)TOP_TEN_HANDLER->query_ordered_table( table_name );
   if ( !table_name ) {
      long += "All Players";
      if ( !sizeof( args ) )
         return long +": There is no overall top ten at present.\n";
   } else {
      if ( file_size( "/std/guilds/"+ table_name +".c" ) < 0 )
         return "*Barf!* Can't find /std/guilds/"+ table_name +".\n";
      long += capitalize( (string)( "/std/guilds/"+ table_name )->
                     query_name() ) + "' Guild";
      if ( !sizeof( args ) )
         return long +": There is no top ten for this guild at present.\n";
   }
   return sprintf( "%|*s\n", table_name ? 40 : 50, long ) +
          sprintf( "%|*s\n", table_name ? 40 : 50, "Sorted by rating" ) +
          sprintf( "%|*s\n\n", table_name ? 40 : 50, 
                   "-=- " + ctime(time()) + " -=-" ) +
          generate_list(args) + "\n";
}

string convert_age( int number ) {
   if ( number > 86400 )
      return ( number / 86400 ) +"D";
   if ( number > 3600 )
      return ( number / 3600 ) +"h";
   if ( number > 60 )
      return ( number / 60 ) +"m";
   return number +"s";
} /* convert_age() */

string generate_list( mixed *args ) {
   int i, number, sum;
   string format, list;

   if ( table_name )
      format = "  %2d. %-13s: level %4d  %5s";
   else
      format = "  %2d. %-23s: level %4d  %5s";
   format += "\n";
   list = "";
   number = sizeof( args );
   sum = 0;
   for ( i = 0; i < number; i++ )  {
      list += sprintf( format, i + 1, capitalize( args[ i ][ TOP_TEN_NAME ] ),
            args[ i ][ TOP_TEN_LEVEL ],
            convert_age( args[ i ][ TOP_TEN_AGE ] ) );
      if ( i > 0  &&  i < number - 1 )  {
         sum += args[i][TOP_TEN_RATING];
      }
   }
   //list += "\nA rating of " + sum / (number - 2) +
           //" would put you firmly in the middle.\n";
   return list;
} /* generate_list() */
// --- END [/mnt/home2/grok/lib/obj/misc/top_ten_tables.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/chicken_feather.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/chicken_feather.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628015   Available: 13575369
Inodes: Total: 5242880    Free: 4960134
408 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/chicken_feather.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628015   Available: 13575369
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: chicken_feather.c,v 1.1 2001/09/27 11:33:39 siel Exp $
 *
 *
 */


inherit "/std/object";

void setup() {
 set_name("feather");
 set_short("chicken feather");
 set_main_plural("chicken feathers");
 add_adjective("chicken");
 add_plural("feathers");
 add_adjective("chicken");
 set_weight(1);
 set_long("This is a feather that was plucked from a chicken.\n");
}

// --- END [/mnt/home2/grok/lib/obj/misc/chicken_feather.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/ink_well.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/ink_well.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628015   Available: 13575369
Inodes: Total: 5242880    Free: 4960134
360 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/ink_well.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628015   Available: 13575369
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/obj/container";
 
void create() {
  ::create();
  set_name("well");
  add_adjective("ink");
  set_short("ink well");
  set_long("A nice, small ink well.\n");
  set_value( 500 );
  set_leak_rate(0);
  set_max_volume(250);
  set_volume(200);
  set_water_volume(200);
  set_ps_coord_quantity((int *)"/std/effects/other/ink"->query_coordinate(), 200);
}
// --- END [/mnt/home2/grok/lib/obj/misc/ink_well.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/watch.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/watch.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628015   Available: 13575369
Inodes: Total: 5242880    Free: 4960134
5668 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/watch.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628015   Available: 13575369
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/obj/clock";

int our_offset,
    their_offset,
    last_time,
    cur_alarm,
    offset_alarm,
    alarm;
mixed *alarms; 
string *alarm_write,
       alarm_name;
object our_player;

varargs int get_text(string line);

void setup() {
  set_name("watch");
  add_adjective("demonic");
  add_alias("watch");
  set_main_plural("demonic watches");
  set_short("demonic watch");
  set_long("A small wrist attackable living quaters for a demon "+
           "the demon looks pretty harried about giveing out the "+
           "time all the time, and the pay is lousy..\n");
  set_value(20000);
  our_offset = 0;
  their_offset = 8;
  last_time = time();
  call_out("check_alarm",60);
  alarms = ({ });
}
/*
string long(string word, int dark) {
  if (our_offset == their_offset)
    return ::long()+".\n"+get_time()+".\n";
  else
    return ::long()+"\n"+get_time()+"\nMud time: "+ctime(time())+".\n";
}

string query_read() {
  if (our_offset == their_offset)
    return get_time()+".\n";
  else
    return get_time()+"\nMud time: "+ctime(time())+".\n";
}
*/

void init() {
  add_command("time", "");
  add_command("gmt", "<word'offset'>", (:this_object()->set_gmt($4[0]):));
  add_command("use", "<direct:object>", (:this_object()->use():));
  this_player()->add_command("read", this_object());
}

int use(string arg) {
  if (!alarms)
    alarms = ({ });
  printf("%-=80s","You look into the watch and fiddle with several buttons, "+
                  "Finally a light lights up in the top corner say you have "+
                  "the security clearance to modify the settings.\n"+
                  "You can \"set\" an alarm \"remove\" an alarm \"list\" the "+
                  "set alarms. You can \"quit\" also.\n");
  write("What do you wish to do ? ");
  input_to("the_command");
  return 1;
}

int the_command(string arg) {
  string s1;
  int i;

  if (arg == "quit") {
    write("Thank you for using this wonderful watch.\n");
    return 1;
  }
  if (sscanf(arg,"set%s",s1)) {
    int hour, min;
    string name;
    if (sscanf(s1," %s %d:%d%s",name,hour,min,s1)!=4)
      write("Usage: set <name> <hour>:<min> [+]\n");
    else {
      if ((i=member_array(name,alarms))<0)
        alarms += ({ name, hour, min, 0 });
      else
        if (i%4)
          write("Oooooopps, you cannot use that name as an alarm\n");
        else {
          alarms[i+1] = hour;
          alarms[i+2] = min;
        }
      if (s1 == " +") {
        if (i==-1)
          i = sizeof(alarms)-4;
        cur_alarm = i;
        get_text();
        return 1;
      }
    }
  }
  if (sscanf(arg,"remove%s",s1)) {
    string frog;
    if (sscanf(s1," %s",frog)!=1)
      write("Usage: remove <name>\n");
    else
      if ((i=member_array(frog,alarms))<0)
        write("You must remove an existing alarm\n");
      else
        if (i%4)
          write("Ohhh dear.\n");
        else {
          alarms = delete(alarms,i);
          alarms = delete(alarms,i);
          alarms = delete(alarms,i);
          alarms = delete(alarms,i);
        }
  }
  if (sscanf(arg,"list%s",s1)) {
    string chicken;
    if (sscanf(s1," %s",chicken)!=1) {
      for (i=0;i<sizeof(alarms);i+=4) {
        write("Alarm "+alarms[i]+" is set for "+alarms[i+1]+":"+alarms[i+2]+"\n");
      }
    } else {
      if ((i=member_array(chicken,alarms))<0)
        write("That alarm does not exist.\n");
      else
        if (i%4)
          write("Bing basicly");
        else
          write("You have set alarm "+chicken+" to go off at "+alarms[i+1]+":"+
                 alarms[i+2]+"\n");
    }
  }
  return 1;
}

varargs int get_text(string line) {
   string text;
  if (!line) {
    text = "";
    write(sprintf("%-=80s","Please enter the text you wish to be displayed "+
          "when the alarm goes off (. to finish)"));
  } else if (line==".") {
    alarms[cur_alarm+3] = text+"\n";
    write("What do you wish to do ? ");
    input_to("the_command");
    return 1;
  } else
    text += line+"\n";
  write("] ");
  input_to("get_text");
  return 1;
}

mixed query_auto_load() {
  mixed ret;

  if (!alarms)
    alarms = ({ });
  ret = ({ their_offset, alarms });
  return ret;
}

void init_arg(mixed *arg) {
  their_offset = arg[0];
  alarms = arg[1];
  if (!alarms)
    alarms = ({ });
}

void check_alarm() {
   int the_time, offset, i;
   int tmp;
   
   the_time = time();
   offset = (the_time/(3600*24))*3600*24 - our_offset*3600;
   for (i=0;i<sizeof(alarms);i+=4) {

      tmp = offset + (alarms[i+1]-our_offset+their_offset)*3600 + alarms[i+2]*60;
      if (the_time>tmp && tmp>last_time) {
         /* we go off. bounce */
         alarm = 6;
         alarm_name = alarms[i];
         if (alarms[i+3])
         alarm_write = explode(alarms[i+3],"\n");
      else
         alarm_write = ({
            "Beep Beep Beep, Your "+alarms[i]+" alarm has gone off.\n",
            "Beep Beep Beep, Your "+alarms[i]+" alarm has gone off.\n",
            "Beep Beep Beep, Your "+alarms[i]+" alarm has gone off.\n",
            "Beep Beep Beep, Your "+alarms[i]+" alarm has gone off.\n",
            "Beep Beep Beep, Your "+alarms[i]+" alarm has gone off.\n",
            "Beep Beep Beep, Your "+alarms[i]+" alarm has gone off.\n",
         });
         offset_alarm = 0;
         set_heart_beat(1);
      }
   }
   last_time = the_time;
   call_out("check_alarm",60);
}

void heart_beat() {
   if (our_player)
     our_player->event_say(this_object(), "The watch goes: "+
                           alarm_write[offset_alarm++]+"\n");
   if (offset_alarm>sizeof(alarm_write))
     set_heart_beat(0);
}

int move(object ob) {
  int i;

  i = ::move(ob);
  our_player = environment();
  return i;
}
// --- END [/mnt/home2/grok/lib/obj/misc/watch.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/grinder.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/grinder.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628013   Available: 13575367
Inodes: Total: 5242880    Free: 4960134
4401 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/grinder.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628013   Available: 13575367
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <move_failures.h>
#define STATE_CHANGE "/obj/handlers/state_change"


inherit "/obj/container";

int test_add(object ob, int flag);
int do_grind( string what );
int do_empty(object *dest, string me, string him, string prep);
void set_max_grindable( int i );
int query_max_grindable();
string long_status();

private int _max_grind = 0;


void setup() {
  set_name( "grinder" );
  set_short( "food grinder" );
  add_adjective( "food" );
  set_main_plural( "food grinders" );
  set_long( "This is a mechanical contraption to grind food into small "
      "pieces.  There is a funnel-type piece at the top, a crank on one "
      "side and on the other a pipe where the ground food comes out and "
      "is caught in a small tray.\n" );
  set_value( 4000 );
  set_weight( 100 );
  set_max_weight( 100 );
} /* setup() */


void init() {
  this_player()->add_command( "grind", this_object(),
      "<string'object'> in <direct:object'" + query_short() + "'>",
      (: do_grind( $4[0] ) :) );
/*
  this_player()->add_command( "grind", this_object(),
      "<indirect:object:me> in <direct:object>",
      (: do_grind( $1[0] ) :) );
*/
  add_command( "empty", "<direct:object>" );
} /* init() */


int test_add(object ob, int flag) {
  object stuff = first_inventory();
  if (stuff) {
    add_failed_mess( "There is already some " + stuff->query_short()
      + " in the grinder.  You'll have to empty it first.\n");
    return 0;
  } else return 1;
} /* test_add() */


int do_grind( string what ) {
  object *things, thing;
  object ground;
  object contents;

  things = match_objects_for_existence( what, ({ this_object(),
                                                 this_player() }) );
  if( !sizeof( things ) ) {
    add_failed_mess( "You must be holding something or put it in $D in "
                     "order to $V it.\n" );
    return -1;
  }

  thing = things[0];

  /* If there's already something in the grinder, don't let more be ground
   * until it's removed. */

  if( ( contents = first_inventory() ) && contents != thing ) {
   // tell_creator( this_player(), "contents: %O\tthing: %O\n",
   //               contents, thing );
    add_failed_mess( "$D isn't empty.\n" );
    return -1;
  }

  /* If there's a limit on the amount that can be ground at once, make
   * sure that we haven't exceeded it.  Non-continuous things are checked
   * by weight. */

  if( query_max_grindable() &&
      ( thing->query_amount() > query_max_grindable() ||
        thing->query_weight() > query_max_grindable() ) ) {
    add_failed_mess( "You cannot grind that much with $D at once.\n" );
    return -1;
  }

  ground = STATE_CHANGE->transform( thing, "grind" );
  if ( !objectp( ground ) ) {
    add_failed_mess( "You cannot $V $I in $D.\n", ({ thing }) );
    return -1;
  }

  thing->move( "/room/rubbish" );

  if( ground->move( this_object() ) != MOVE_OK ) {
    // couldn't be moved into the grinder
    ground->move( environment( this_player() ) );
    add_succeeded_mess( "$N grind$s $I with $D, spilling it onto the " +
        ( environment( this_player() )->query_property( "location" ) ==
        "inside" ? "floor" : "ground" ) + ".\n" );
    return 1;
  }

  this_player()->add_succeeded_mess( this_object(), "$N grind$s $I "
    "in $D.\n", ({ thing }) );
  return 1;
} /* do_grind() */


int do_empty(object *dest, string me, string him, string prep) {
  /* There shouldn't ever be more than one thing in the grinder. */
  object ground = first_inventory( this_object() );

  if( !ground ) {
    add_failed_mess( "There is nothing in $D.\n" );
    return 0;
  }
  /* If the player can't hold it, empty it onto the floor */
  if( ground->move( this_player() ) != MOVE_OK ) {
    ground->move( environment( this_player() ) );
    add_succeeded_mess( "$N $V $D onto the " +
        ( environment( this_player() )->query_property( "location" ) ==
        "inside" ? "floor" : "ground" ) + ".\n" );
    return 1;
  }

  /* standard success msg */
  return 1;
} /* do_empty() */


/**
 * To set a maximum amount of an object that can be ground at once.
 * If left with the default value of 0, there is no maximum amount.
 */

void set_max_grindable( int i ) { _max_grind = i; }


/**
 * Returns the maximum amount grindable at once
 */

int query_max_grindable() { return _max_grind; }


/* This gets rid of the "It is open." message */
string long_status() { return ""; }
// --- END [/mnt/home2/grok/lib/obj/misc/grinder.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/top_clubs.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/top_clubs.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628012   Available: 13575366
Inodes: Total: 5242880    Free: 4960134
2560 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/top_clubs.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628012   Available: 13575366
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This keeps track of the top families in various areas.
 * @author Pinkfish
 * @started May 16th
 */
#include <top_ten_tables.h>
#include <clubs.h>
inherit "/std/object";

private string _lang = "morporkian";

string _long();

void setup() {
   set_name( "table" );
   set_short( "top club table" );
   set_long("This is a table listing those clubs that are most "
            "advanced in certain aspects.\n");
   add_adjective( ({ "top", "club", "score" }) );
   reset_get();
   add_property( "there", "in one corner" );
   add_property( "survive fire", 1 );
   /* A call_out for the read mess, to give you time to set the
    * language.  Done this way to be consistent with
    * /obj/misc/top_ten_tables.c  
    */
   call_out("setup_read_mess", 5);
} /* setup() */

void setup_read_mess() {
   add_read_mess((: _long() :), 0, _lang, 0);
} /* setup_read_mess() */

void set_language(string lang) {
  _lang = lang;
} /* set_language() */

string query_language() { return _lang; }

string club_name(string str) {
   if (!str) {
      return "Unknown";
   }
   return CLUB_HANDLER->query_club_name(str);
} /* club_name() */

string _long() {
   mixed *stuff;
   string bing, str;
   string guild;
   string *g_sorted;
   mapping g_info;

   stuff = TOP_TEN_HANDLER->query_club_info();

   str = "The club with:\n"
         "The most members          : " +
         club_name(stuff[TOP_TEN_LARGEST_FAMILY])  + "\n"
         "The oldest average age    : " +
         club_name(stuff[TOP_TEN_OLDEST_FAMILY]) + "\n"
         "Most average quest points : " +
         club_name(stuff[TOP_TEN_MOST_QUEST_POINTS]) + "\n"
         "Most player killers       : " +
         club_name(stuff[TOP_TEN_MOST_PKS]) + "\n"
         "Largest single gender     : " +
         club_name(stuff[TOP_TEN_SINGLE_GENDER]) + "\n"
         "Oldest start DW time      : " +
         club_name(stuff[TOP_TEN_OLDEST_LOGONS]) + "\n"
         ;

   g_info = stuff[TOP_TEN_MOST_GUILD];
   g_sorted = sort_array(filter(keys(g_info), (: stringp($1) &&
                                                 file_size($1 + ".c") > 0 :)),
                         (: strcmp($1->query_name(), $2->query_name()) :));
   foreach (guild in g_sorted) {
      if (stringp(guild)) {
         bing = g_info[guild];
         str += sprintf("%-26s: %s\n",
               "Most " + (guild->query_name()),
               club_name(bing));
      }
   }

   str += "\nTo get onto the average list the club must have more than "
          "3 members that are not creators.\n";
   return str;
} /* _long() */
// --- END [/mnt/home2/grok/lib/obj/misc/top_clubs.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/wallpaper.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/wallpaper.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628011   Available: 13575365
Inodes: Total: 5242880    Free: 4960134
4545 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/wallpaper.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628011   Available: 13575365
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
  *  A wallpaper object for playerhousing
  *
  *  To create a roll with a pattern, just call make_roll( <design> )
  *  on one.
  *
  *  To apply this wallpaper to a playerhousing wall, you also need 
  *  a pot of glue and a paint brush.
  *
  *  @author Una
  *  @27th August, 2002
  *
  **/

inherit "/std/object";

private nosave string _design;

varargs int do_paper(string indirect, object pot);

void setup() {

    set_name( "wallpaper" );
    set_short( "roll of wallpaper" );
    set_main_plural( "rolls of wallpaper");
    add_adjective( ({ "roll", "of"}));
    add_plural_adjective("rolls");
    add_alias(({"paper"}));
    set_long( "This is a large roll of wallpaper, probably enough to "
        "cover a single wall completely.\n");
    set_value( 480 );
    set_weight( 10 );
    
} /* setup() */


void make_roll( string design ) {

    _design = design;
    set_short( "roll of " + _design + " wallpaper" );
    set_main_plural( "rolls of " + _design + " wallpaper");
    add_adjective( ({ _design })) ;
    set_long( "This is a large roll of " + _design + " wallpaper.  It "
        "looks like there's just enough of it to cover a single wall "
        "completely.  If you had some wallpaper glue you could probably "
        "paste it to the wall.\n");
  
} /* make_roll() */


/** @ignore yes */
void init() {
    
    this_player()->add_command("paste", this_object(),
       "<direct:object> to <indirect:object:here'cardinal direction'> using <indirect:object'pot'>", (: do_paper( $4[1], $1[1][0] ) :));
  
} /* init() */


string query_paper_mess() {

    if( _design ) {
        return _design + " wallpaper";
    }
    else {
        return "strangely featureless wallpaper";
    }
    
} /* query_paper_mess() */


varargs int do_paper(string indirect, object pot) {
    object *obs;
  
    if(!indirect && pot) {
        if(function_exists("what_to_paint", pot))
            printf(pot->what_to_paint());
        else
            printf("Help: paste " + pot->short() + " with wallpaper\n");
            return 1;
    }

    obs = match_objects_for_existence("glue", pot);

    if(pot->query_closed()) {
        this_player()->add_failed_mess(this_object(), "$I is "
            "closed.\n", ({ pot }));
        return 0;
    }

    if(!pot->query_volume(obs) || !sizeof(obs)) {
        this_player()->add_failed_mess(this_object(), "$I appears to "
            "be empty.\n", ({ pot }));
        return 0;
    }

    if(!sizeof(filter(this_player()->query_holding() - ({ 0 }),
        (: $1->id("brush") :)))) {
        this_player()->add_failed_mess(this_object(), "You must be holding a "
            "paint brush to paint the walls with glue.\n", ({ }));
        return 0;

    }

    if(!environment( this_player() )->test_occupier( this_player()->
        query_name() ) ) {
    
        this_player()->add_failed_mess(this_object(), "You don't own this "
            "house.\n", ({ }));
        return 0;
    }
  

    if(!function_exists("decorate_surface", environment(this_player()))) {

        this_player()->add_failed_mess(this_object(), "You can't $V the "
            "walls here.\n", ({ }));
        return 0;
    }
  
    if(!environment(this_player())->decorate_surface(indirect, 
        "papered with " + query_paper_mess())) {
        
        this_player()->add_failed_mess(this_object(), "You can't $V the $D" 
            " to the " + indirect + " using $I for some reason.\n", 
            ({ pot }));
        return 0;
    }
  
    pot->remove_volume(pot->query_volume());
    this_object()->move("/room/rubbish");
    
    this_player()->add_succeeded_mess(this_object(), "$N $V $D to the " + 
        indirect + ", dawbing it with paste from $I and pressing it firmly "
        "against the surface.\n", ({ pot }) );
    return 1;
    
    
    
} /* do_paper() */


/** @ignore yes */ 
mapping int_query_static_auto_load() {
    mapping tmp;

    tmp = ::int_query_static_auto_load();
    return ([ "::" : tmp,
              "design" : _design,
            ]);
} /* int_query_static_auto_load() */


/** @ignore yes */ 
mapping query_static_auto_load() {

    if ( base_name(this_object()) + ".c" == __FILE__ )
        return int_query_static_auto_load();
    return ([ ]);
    
} /* query_static_auto_load() */


/** @ignore yes */ 
void init_static_arg(mapping args) {
    if (args["::"])
    
    ::init_static_arg(args["::"]);
  
    if(!undefinedp(args["design"]))
        _design = args["design"];
    
    if(_design)
        make_roll(_design);
} /* init_static_arg() */
// --- END [/mnt/home2/grok/lib/obj/misc/wallpaper.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/detabber.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/detabber.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628010   Available: 13575364
Inodes: Total: 5242880    Free: 4960134
615 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/detabber.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628010   Available: 13575364
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/object";

void setup()
{   set_name("detabber");
    set_long("A long stick with absoulutely no tabs in it.\n"
             "Usage:  detab <filename>.\n");
    
}

void init()
{   this_player()->add_command("detab",this_object(),"<string>");
  
}


int do_detab(object *indirect_obs, string *dir_match, string indir_match, mixed *args, string pattern)
{   
    string file;
    string tb;
    
    tb = sprintf("\t");

    file = read_file(args[0]);

    if(file)
        {file = replace_string(file,"\t","    ");
         write_file(args[0],file,1);    
         return 1;
         }

    return 0;
}// --- END [/mnt/home2/grok/lib/obj/misc/detabber.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/golem_corpse.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/golem_corpse.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628010   Available: 13575364
Inodes: Total: 5242880    Free: 4960134
1923 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/golem_corpse.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628010   Available: 13575364
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*
 *$Id$
 */

/* Remains of a dead golem */

#include <armoury.h>

inherit "/obj/container";

void make_fragments();


void setup() {
    set_name( "rubble" );
    set_short( "heap of clay rubble" );
    add_alias( ({"heap", "clay"}) );
    add_adjective( ({"heap of", "clay"}) );
    set_main_plural( "heaps of clay rubble" );
    add_plural( "heaps" );

    set_weight( 40000 );
    set_max_weight( 50000 );
    set_value( 0 );
    set_stuck( 1 );
    make_fragments();
    add_property( "no recycling", 1 );
} /* void setup() */


void make_fragments() {
    int amount = random( 8 );
    int i;

    for( i = 1; i <= amount; i++ )
        switch( random( 11 ) ) {
           case 0..5:
               ARMOURY->request_item( "golem shard", 100 )->
                   move( this_object() );
               break;
           case 6..7:
               ARMOURY->request_item( "golem finger", 100 )->
                   move( this_object() );
               break;
           case 8..9:
               ARMOURY->request_item( "golem toe", 100 )->
                   move( this_object() );
               break;
           case 10:
               ARMOURY->request_item( "golem eye", 100 )->
                   move( this_object() );
               break;
        }
} /* void make_fragments() */


string long( string word, int dark ) {
    string inv = query_multiple_short( all_inventory( this_object() ) );
    string tmp = "";
    switch( sizeof( all_inventory( this_object() ) ) ) {
        case 0:
           break;
        case 1:
            tmp = "Something that looks like " + inv + " protrudes from it.  ";
            break;
        default:
            tmp = "It looks like " + inv + " are buried in it.  ";
    }
    return "This is a large heap of shattered clay.  " + tmp + "Whatever this "
        "was before, it is destroyed thouroughly and beyond any means of "
        "repair.\n";
} /* string long() */


// --- END [/mnt/home2/grok/lib/obj/misc/golem_corpse.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/football.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/football.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628009   Available: 13575363
Inodes: Total: 5242880    Free: 4960134
2916 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/football.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628009   Available: 13575363
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming

inherit "/std/object";

string me, him;
void setup() {
     set_name("football");
     set_short("leather football");
     add_adjective("leather");
     add_alias("ball");
     set_long("This is a leather football, pumped up hard.  Looks like you could"
             " kick it to people.\n");
     set_weight(10);
     set_value(1);
     add_plural("footballs");
     add_plural("balls");
} /* setup() */

void init() {
  this_player()->add_command("kick", this_object(),
        "<direct:object:me> to <indirect:player>");
  add_command( "kickup", "<direct:object>" );
  /*  ::init(); */
} /* init() */

int do_kickup()  {
   write( "You kick the football into the air a few times, stopping it from "
   "hitting the floor by bouncing it off your knee, your chest and your feet."
   "  A rare display of skill!\n" );
tell_room( environment( this_player() ),
     this_player()->query_cap_name() + " expertly kicks the ball into the "
     "air, heads it back up, bounces it a few times on their chest and displays "
     "an uncanny level of skill.\n", this_player());
   return 1;
}

int do_kick(object *in_dir) {
  if (!sizeof(in_dir))
    return 0;

  if (move(in_dir[0])) {
    tell_object(in_dir[0], this_player()->query_cap_name()+" kicks "+
        this_object()->query_short()+" at you, but it falls on the floor.\n");
    tell_room(environment(in_dir[0]), "A leather football flies "
        "through the air, "+ in_dir[0]->query_name()+" tries to trap it "
        "but fails and it lands next to them.", ({ in_dir[0], this_player() }) );
    move(environment(in_dir[0]));
  } else {
    tell_object(in_dir[0], this_player()->query_cap_name()+" kicks a "
           "leather football at you.  It curls towards you at speed but you "
           "manage to " +
           ({ "trap it with your foot.",
           "bounce it off your chest and trap it underfoot.",
           "head it to the ground, juggle it a few times and eventually stand"
           " on it",
           "catch it. HANDBALL!",
           "look like the famous footballer Fele and trap it.",
           "trap it easily.  You should sign up for Ankh Morpork Wanderers."})
           [random (6) ]+"\n"); 
    tell_room(environment(in_dir[0]), "A leather football curls "
           "gracefully towards "+ in_dir[0]->query_cap_name()+", who "+
                "manages to "+
                ({ "trap it with their foot.",
           "bounce it off their chest and trap it underfoot.",
           "head it to the ground, juggle it a few times and eventually stands"
           " on it",
           "catches it. HANDBALL!",
           "look like the famous footballer Fele and trap it.",
           "trap it easily.  They should sign up for Ankh Morpork Wanderers."})
           [random (6) ]+
                "\n",
          ({ in_dir[0], this_player() }));
  }
  this_player()->add_succeeded(in_dir[0..0]);
  return 1;
} /* do_kick() */
// --- END [/mnt/home2/grok/lib/obj/misc/football.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/wearable_pet.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/wearable_pet.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628008   Available: 13575362
Inodes: Total: 5242880    Free: 4960134
4597 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/wearable_pet.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628008   Available: 13575362
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  Wearble Pet Inherit  *
 *        Wobin          *
 *       13/12/00        */

/**
 * Note, expand_mon_string will possibly be required to be modified
 */

#include <gossip.h>
#include <armoury.h>
#define CHAT_FREQ 200

inherit "/obj/monster";
inherit "/std/basic/wearable";

varargs int wear_remove_function(object);

void expand_mon_string( mixed str ) {
    object room;
    string *args, *stuff;

    if ( functionp( str ) ) {
        evaluate( str, this_object() );
    }

    if(strsrch(str, "$name$") > 0) {
        stuff = GOSSIP_HANDLER->query_random_gossip();
        str = replace(str, ({ "$name$", stuff[0],
            "$mess$", stuff[1] }));
    }
    str = expand_string(str, 0);

    switch( str[0] ) {
    case '#':
        args = explode(str[ 1..], ":");
        switch (sizeof(args)) {
        case 1 :
            call_other( this_object(), args[0] );
            return;
        case 2 :
            call_other( this_object(), args[0], args[1] );
            return;
        case 3 :
            call_other( this_object(), args[0], args[1], args[2] );
            return;
        case 4 :
            call_other( this_object(), args[0], args[1], args[2],
              args[3] );
            return;
        default :
            call_other( this_object(), args[0], args[1], args[2],
              args[3], args[4] );
            return;
        }

    case ':' :
        str = str[1..];
        break;
    case '\'' :
        str = "says " + str;
        break;
    case '"' :
        str = "says loudly " + str;
        break;
    }
    if(living(environment())) {
        room = environment(environment());
        str = capitalize(environment()->poss_short()) +" "
        + this_object()->query_short()  + " " + str;
        tell_room( room,  str +"\n" );
    } else {
        room = environment();
        str = "The " + this_object()->query_short() + " " + str;
        tell_room( room, expand_string( str, 0 ) +"\n" );
    }


} /* expand_mon_string() */

int check_anyone_here() {
object holder, *people;

    if(!(::check_anyone_here()))
        if ( living(holder = environment(this_object())) ) {
            if(environment(holder) && 
                    sizeof(people = all_inventory(environment(holder))))
            if(sizeof(filter(people, (: userp($1) :))))
                return 1;
            else
                return 0;
    }
    return ::check_anyone_here();
} /* check_anyone_here() */

varargs int wear_remove_function(object pet, object thing) {
    object *wearing;
    object worn;

    if(pet && thing) {
        wearing = this_player()->query_wearing();
        foreach(worn in wearing) {
            if( (worn != previous_object()) 
                && inherits("/obj/misc/wearable_pet", worn)) {
                previous_object()->init_command(sprintf("kill %O",worn));
            }
        }
    }
}

/**		
 * Inheritance overriding to organise the shared functions
 */

void create() {
    wearable::create();
    monster::create();
} /* create() */

string long(string str, int dark) {
    return monster::long(str, dark);
} /* long() */

void init_dynamic_arg(mapping map) {
    wearable::init_dynamic_arg(map);
    monster::init_dynamic_arg(map);
} /* init_dynamic_arg() */

mapping query_dynamic_auto_load() {
    return
    wearable::query_dynamic_auto_load() +
    monster::query_dynamic_auto_load();
} /* query_dynamic_auto_load() */

void init_static_arg(mapping map) {
    wearable::init_static_arg(map);
    monster::init_static_arg(map);
} /* init_static_arg() */

mixed query_static_auto_load() {
    wearable::query_static_auto_load() +
    monster::query_static_auto_load();
} /* query_static_auto_load() */

// Let them have a value.
int query_value() {
    return query_base_value();
}

mixed stats() {
    return wearable::stats() + monster::stats();
} /* stats() */

/** 
 *Now to add in the Living/Clothing interfaces. We want all our pets to act as 
 * clothing worn and take damage, but respond as a living and die if 'broken'
 */

void break_me() {
    do_death();   
} /* break_me() */

string cond_string() {
   health_string();
} /* cond_string() */

int adjust_cond( int i ) {
    adjust_hp( i );
} /* adjust_cond() */

/* Now the tricky back de doody */
varargs int adjust_hp( int number, object attacker, object weapon, 
    string attack ) {
    if(::adjust_cond( number ))
      return ::adjust_hp( number, attacker, weapon, attack);
}

int set_max_hp( int number ) {
    set_max_cond(number);
    set_cond(number);
    set_damage_chance( 15 );
    set_lowest_cond(1);
    return ::set_max_hp(number);
}
// --- END [/mnt/home2/grok/lib/obj/misc/wearable_pet.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/frisbee.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/frisbee.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628007   Available: 13575361
Inodes: Total: 5242880    Free: 4960134
1681 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/frisbee.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628007   Available: 13575361
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/object";

string me, him;

void setup() {
  set_name("frisbee");
  set_short("black frisbee");
  add_adjective("black");
  set_long("This is a small black frisbee.  It looks like you could "
           "throw it to "
           "people.\n");
  add_property("feeding_frenzy", "frisbee");
  set_weight(10);
  set_value(200);
  set_main_plural("black frisbees");
  add_plural("frisbees");
} /* setup() */

void init() {
  this_player()->add_command("throw", this_object(),
                             "<direct:object:me> to <indirect:player>");
} /* init() */

int do_throw(object *in_dir) {
  /* Make sure there really is someone in that array */
  if (!sizeof(in_dir))
    return 0;

  /*
   * Ok, move it to the destination.  Don't need to a print a message to
   * this_player as that is done automaticly.
   */
  if (move(in_dir[0])) {
    tell_object(in_dir[0], this_player()->one_short()+" throws "+
                this_object()->short()+" at you, but it falls on the floor.\n");
    tell_room(environment(in_dir[0]), "A frisbee arcs through the air, "+
              in_dir[0]->query_name()+" tries to catch it but fails and it "+
              "falls on the floor.\n", ({ in_dir[0], this_player() }) );
    move(environment(in_dir[0]));
  } else {
    tell_object(in_dir[0], this_player()->one_short()+" throws a frisbee "+
                "at you, you catch it... just.\n");
    tell_room(environment(in_dir[0]), in_dir[0]->one_short()+
          " fumbles the catch of the "+
          short(0)+" but manages to keep hold of it.\n",
          ({ in_dir[0], this_player() }));
  }
  this_player()->add_succeeded(in_dir[0..0]);
  return 1;
} /* do_throw() */
// --- END [/mnt/home2/grok/lib/obj/misc/frisbee.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/mailer_ob.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/mailer_ob.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628006   Available: 13575360
Inodes: Total: 5242880    Free: 4960134
578 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/mailer_ob.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628006   Available: 13575360
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/object";

int do_mail(string str);

void setup() {
  set_name("mailer");
  set_short( "mailer object" );
  set_long("It is a small black box with pictures of small red demons "
           "painted on "+
           "the front.  Though, some of them look suspicously like frogs.\n");
  set_weight(1);
  reset_drop();
} /* setup() */

void init() {
  add_command("mail", "", (: do_mail(0) :) );
  add_command("mail", "<string>", (: do_mail($4[0]) :) );
} /* init() */

int do_mail(string str) {
  return (int)"/obj/handlers/mail_track"->mail(str);
} /* do_mail() */

// --- END [/mnt/home2/grok/lib/obj/misc/mailer_ob.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/lock.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/lock.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628006   Available: 13575360
Inodes: Total: 5242880    Free: 4960134
4149 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/lock.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628006   Available: 13575360
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* A lock object so people can change the lock in
   a container. */

inherit "/std/object";

#include <move_failures.h>

/** @ignore yes */
void create() {
  add_help_file("door_lock");
  do_setup++;
  ::create();
  do_setup--;
  if ( !do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }
}

/** @ignore yes */
void init() {
  this_player()->add_command("change", this_object(),
      "[lock in] <indirect:object:here'door or furniture'> for "
                             "<indirect:object:me'lock'>");
}

int do_change(mixed *in_dir, string direct, string indirect, mixed *args,
              string) {
  object lock;
  object ob;
  object item;
  object other;
  string other_id;


  item = in_dir[0][0];
  lock = in_dir[1][0];

  if(function_exists("query_my_room", item) &&
     (query_property("locktype") != "door"))
    return notify_fail("This lock is not suitable for a door.\n");

  if(item->query_furniture()) {
    switch(item->query_pick_skill()) {
    case "covert.lockpick.door":
      if(query_property("locktype") != "furniture")
        return notify_fail("This lock is not suitable for furniture.\n");
    case "covert.lockpick.safes":
      if(query_property("locktype") != "safe")
        return notify_fail("This lock is not suitable for safes.\n");
    }
  }

  if(function_exists("query_my_room", item) &&
     !function_exists("test_occupier", environment(this_player())))
    return notify_fail("You cannot change the locks here.\n");
  
  if(function_exists("test_occupier", environment(this_player())) &&
     !environment(this_player())->test_occupier(this_player()->query_name())
     && !this_player()->query_creator())
    return notify_fail("Sorry, only the owner of the house can change the "
                       "locks on items in the house.\n");

  if(!function_exists("pick_lock", item))
    return notify_fail("Sorry, that object can't take a lock.\n");

  if(!item->query_unlocked())
    return notify_fail("Sorry, the item must be unlocked in order to change "
                       "its lock.\n");

  if(!lock->query_property("key prop")) {
    this_player()->add_failed_mess(this_object(),
      "$I doesn't appear to have a key.\n", ({ lock }));
    return 0;
  }
  
  if(!lock->query_property("difficulty")) {
    this_player()->add_failed_mess(this_object(),
      "$I doesn't appear to have a difficulty.\n", ({ lock }));
    return 0;
  }

  item->set_key(lock->query_property("key prop"));
  item->set_difficulty(lock->query_property("difficulty"));
  item->set_lock_owner(environment(this_player())->query_owner());
  item->set_trap_armed(0);
  
  // if it's a door we have to do the other side too.
  if(function_exists("query_my_room", item)) {
    other = load_object(item->query_dest());
    other_id = item->query_other_id();

    other->modify_exit(other_id, ({ "key", lock->query_property("key prop")}));
    other->modify_exit(other_id, ({ "difficulty",
                                      lock->query_property("difficulty")}));
    other->modify_exit(other_id, ({ "lock owner",
                                      environment(this_player())->query_owner()
                                      }));
    
    environment(this_player())->update_doors();
    other->update_doors();
    environment(this_player())->do_save();
    other->do_save();
  }

  ob = clone_object("/std/object");
  ob->set_name("lock");
  ob->set_short("busted lock");
  ob->add_adjective("busted");
  ob->set_main_plural("busted locks");
  ob->set_long("A broken door lock.\n");
  ob->set_value(0);
  ob->set_weight(lock->query_weight());
  ob->move(environment());
  if(lock->move("/room/rubbish") != MOVE_OK)
    lock->dest_me();
  
  this_player()->add_succeeded_mess(this_object(),
                                    "$N remove$s the existing, and now "
                                    "broken, lock from $I and replace$s it "
                                    "with the new one.\n", ({ item }));
  return 1;
}

/** @ignore yes */
mixed query_static_auto_load() {
  if ( base_name(this_object()) + ".c" == __FILE__ )
    return int_query_static_auto_load();
  return ([ ]);
}

// --- END [/mnt/home2/grok/lib/obj/misc/lock.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/fountain.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/fountain.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628005   Available: 13575359
Inodes: Total: 5242880    Free: 4960134
3677 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/fountain.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628005   Available: 13575359
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * Cool fountain with a variable refill rate!
 *
 * @author Terano.
 *
 * To use:
 *   1) Clone!
 *   2) Call initialise with appropriate args!
 *   3) Something!
 *   4) Big profits!
 *
 */

#include <volumes.h>

#define FOUNTAIN_SIZE 150000 
#define DEFAULT_CYCLE_TIME 60 * ( 2 + random( 2 ) )         

inherit "/obj/vessel";

string _liquid_path;   //Path of liquid to refill with.
int _liquid_volume;    //Amount to gush, every cycle!
int _time;             //Time between gushes!

/**
 * Some initial stuff.
 * @ignore
 */
void setup() {
  set_name( "fountain" );
  set_short( "fountain" );
  set_long( "This is a fountain.\n" );
  set_max_volume( FOUNTAIN_SIZE ); //3 times the size of the scullery sink.
  set_weight( 100000 );
  set_stuck( 1 );
}

/**
 * Initialise the fountain, the path is the path of the reagent to fill
 * the fountain with, the amount to refill per cycle, and the frequency of cycles.
 * rate to.
 * @arg path   Path of reagent
 * @arg amount Amount to gush every cycle.
 * @arg time   Time to gush!
 */
varargs void initialise( string path, int amount, int time) {

  if ( !stringp( path ) )
    error( "Path not set in initialise.\n" );

  if ( !intp( amount ) )
    amount = VOLUME_LITRE;

  if ( !time )
    time = DEFAULT_CYCLE_TIME;

  _liquid_path = path;
  _liquid_volume = amount;
  _time = time;
  call_out( "make_water", 5 );
  return;
}

/**
 * Initialise the fountain, the path is the path of the reagent to fill
 * the fountain with, the amount to refill per cycle, and the frequency of cycles.
 * rate to.
 * @arg path   Path of reagent
 * @arg amount Amount to gush every cycle.
 * @arg time   Time to gush!
 */
varargs void reinitialise( string path, int amount, int time) {

  if ( !stringp( path ) )
    error( "Path not set in initialise.\n" );

  if ( !intp( amount ) )
    amount = VOLUME_LITRE;

  if ( !time )
    time = DEFAULT_CYCLE_TIME;

  _liquid_path = path;
  _liquid_volume = amount;
  _time = time;
  return;
}

/**
 * @ignore
 */
void make_water() {
object water;

  if ( !( query_max_volume() - query_volume() ) ) {
    tell_room( environment(), sprintf( "Some of the %s in %s sloshes over the sides.\n",
      query_multiple_short( all_inventory() ), this_object()->the_short() ) );
    remove_volume( -VOLUME_QUART * random( 4 ) * 2 );
  }

  water = clone_object( _liquid_path );
  water->set_amount( _liquid_volume );
 
  //Call out adding water to resolve messages.
  call_out( (: $(water)->move( this_object() ) :), 1 );

  switch( water->query_amount() ) {
	case 0 .. VOLUME_SHOT:
      tell_room( environment(), sprintf( "$C$%s %s into %s.\n",
  	  water->a_short(), ({ "trickles", "seeps", "dribbles" })[random(3)],
	  this_object()->the_short() ) );
      break;
    case VOLUME_SHOT + 1 .. VOLUME_PINT:
      tell_room( environment(), sprintf( "$C$%s %s into %s.\n",
		water->a_short(),  ({ "flows", "splashes", "pours" })[random(3)],
		this_object()->the_short() ) );
      break;
    case VOLUME_PINT + 1 .. VOLUME_LITRE:
      tell_room( environment(), sprintf( "$C$%s %s into %s.\n",
		water->a_short(), ({ "streams", "cascades", "sloshes" })[random(3)],
		this_object()->the_short() ) );
      break;
    case VOLUME_LITRE + 1 .. VOLUME_QUART:
      tell_room( environment(), sprintf( "$C$%s %s into %s.\n",
	    water->a_short(), ({ "gushes", "courses", "swirls" })[random(3)],
        this_object()->the_short() ) );
      break;
    default: //surge, flood
      tell_room( environment(), sprintf( "$C$%s %s into %s.\n",
        water->a_short(), ({ "floods", "surges", "washes" })[random(3)],
  	    this_object()->the_short() ) );
      break;
  }
  call_out( "make_water", _time );
}

// --- END [/mnt/home2/grok/lib/obj/misc/fountain.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/shell.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/shell.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628004   Available: 13575358
Inodes: Total: 5242880    Free: 4960134
5805 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/shell.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628004   Available: 13575358
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "potion_attrs.h"
#include "library.h"
inherit "/std/object";
#define MY_ROOM "/d/sur/Sto_Plains/n_caravan/picnic_area"

object *demons, cauldron, coin;

void setup() {
  set_weight(10);
  set_value(5);
  set_name("shell");
  add_adjective("sea");
  add_alias("seashell");
  set_short("sea shell");
  set_long("A large conch shell.  It looks like it has been hollowed "+
           "out so that it can be played.  Perhaps if you blew into "+
           "it it might work.\n");
}

void init() {
  this_player()->add_command("blow", this_object());
}

int finish_quest();

int do_blow(object *indir, string s1, string s2, string prep) {
  if (sizeof(indir)) {
    write("Blow "+short(0)+" "+prep+" "+indir->short(0)+"????\n");
    return 0;
  }
  if (file_name(environment(this_player())) == MY_ROOM)
    return finish_quest();
  add_succeeded_mess("$N $V $D and make$s a horrible noise.\n");
  return 1;
}

int finish_quest() {
  object *obs, *obs2, *obs3, ob, fish, frisbee, ladle;
  mixed *attrs;
  string failure;
  int i, j;

  write("The "+short(0)+" blows amazing loudly.\n");
  say(this_player()->one_short()+" blows the "+short(0)+
      " amazingly loudly.\n");
  if (demons) {
    write("Demons glare at you.\n");
    say("Demons glare at "+this_player()->one_short()+".\n");
    return 1;
  }
  obs = all_inventory(environment(this_player()));
  obs3 = obs;
  obs = map_array(obs, "bingle_bit", this_object());
  if ((i=member_array("ladle", obs)) == -1) {
    failure = "no ladle";
  } else {
    ladle = obs3[i];
  }
  if ((i=member_array("frisbee", obs)) == -1) {
    failure = "no frisbee";
  } else {
    frisbee = obs3[i];
  }
  if ((i=member_array("cauldron", obs)) == -1) {
    failure = "no caldron";
  } else {
    cauldron = obs3[i];
      obs2 = match_objects_for_existence("cauldrons", environment(this_player()));
    for (i=0;i<sizeof(obs2);i++) {
      if ((int)obs2[i]->query_volume() < 100 ||
          (int)obs2[i]->query_volume() < (int)obs2[i]->query_max_volume() / 2) continue;
      attrs = (mixed *)obs2[i]->query_misc_attrs();
      if (pointerp(attrs)) attrs = attrs[POTION_NAMES];
      if (pointerp(attrs) && sizeof(attrs) && attrs[0][0] == "yucky ankh water") {
        j++;
      }
    }
    if (!j) {
      failure = "no cauldron full of anhk river water";
    }
  }
  if ((i = member_array("coin", obs)) == -1) {
    failure = "no coin";
  } else {
    coin = obs3[i];
  }
  if ((i=member_array("fish", obs)) == -1) {
    failure = "no fish";
  } else {
    fish = obs3[i];
  }
      obs2 = match_objects_for_existence("toadstools", environment(this_player()));
  obs2 = filter_array(obs2, "bongle_array", this_object());
  if (sizeof(obs2) < 4) {
    failure = "not enough toadstools to sit on";
  }
  if (failure) {
    write("A bunch of hungry looking demons show up.\n");
    write("They look around the clearing.\n");
    write("Mutter to themselves about there being "+failure+".\n");
    write("Demon glares at you.\n");
    say("A bunch of hungry looking demons show up.\n");
    say("They look around the clearing.\n");
    say("Mutter to themselves about there being "+failure+".\n");
    say("Demon glares at "+this_player()->one_short()+".\n");
    return 1;
  }
  demons = allocate(4);
  for (i=0;i<sizeof(demons);i++) {
    demons[i] = clone_object("/std/container");
    demons[i]->set_name("demon");
    demons[i]->reset_get();
    demons[i]->set_long("A small demon with a manic look in his eyes "+
                        "cooking soup.\n");
    demons[i]->move(environment(this_player()));
    obs2[i]->move(demons[i]);
  }
  coin->reset_get();
  cauldron->reset_get();
  fish->dest_me();
  ladle->move(demons[2]);
  frisbee->move(demons[1]);
  say("The demons grab the fish and stick it into the cauldron.  "+
        "They then put the frisbee on the top of the cauldron as a "+
        "lid.  One of the demons grabs the ladle and stirs the "+
        "mixture around a bit whilst the other demons blow on "+
        "cauldron to heat it up.\n");
  call_out("do_finish_it", 10);
  write("The demons grab the fish and stick it into the cauldron.  "+
        "They then put the frisbee on the top of the cauldron as a "+
        "lid.  One of the demons grabs the ladle and stirs the "+
        "mixture around a bit whilst the other demons blow on "+
        "cauldron to heat it up.\n");
  return 1;
}

void do_finish_it() {
  object *obs;
  int i, j;

  say("The soup is obviously hot now, and all the demons sit down "+
        "on their toadstools to enjoy the meal.  After finishing the "+
        "meal, they smile happily.  You hear one of the say on the "+
        "way out, \"Great way to get a meal, it works every time\".\n"+
       "The demons leave taking the table, cauldron and ladle with them.\n");
  write("The soup is obviously hot now, and all the demons sit down "+
        "on their toadstools to enjoy the meal.  After finishing the "+
        "meal, they smile happily and leave.  You hear one of the "+
        "demons say on the "+
        "way out, \"Great way to get a meal, it works every time\".\n"+
       "The demons leave taking the table, cauldron and ladle with them.\n");
  cauldron->dest_me();
  coin->dest_me();
  obs = all_inventory(environment(demons[0]));
  for (i=0;i<sizeof(obs);i++)
    if (interactive(obs[i])) {
      if (!LIBRARY->set_quest(obs[i]->query_name(), "feeding frenzy"))
        continue;
      obs[i]->adjust_xp(5000);
    }
  for (i=0;i<sizeof(demons);i++) {
    obs = all_inventory(demons[i]);
    for (j=0;j<sizeof(obs);j++)
      obs[j]->dest_me();
    demons[i]->dest_me();
  }
  demons = 0;
}

mixed bingle_bit(object ob) {
  return (mixed)ob->query_property("feeding_frenzy");
}

int bongle_array(object ob) {
  return (int)ob->query_property("feeding_frenzy") != 0;
}
// --- END [/mnt/home2/grok/lib/obj/misc/shell.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/suggestion_box.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/suggestion_box.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628002   Available: 13575356
Inodes: Total: 5242880    Free: 4960134
3493 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/suggestion_box.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628002   Available: 13575356
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* This is a [hopefully] generic suggestion box. 
 * it logs its suggstions to a file
 *
 * Belle March 2002
 */


inherit "/std/object";
int do_fill();
string _savedir, _savefile;

/**
 * @@ignore_yes
 */
void setup() {
  set_short( "suggestion box" );
  set_long( "This is a suggestion box.  It is sitting on a pole which puts"
	    " the box at a convienient height for writing.  It has a pile "
	    "of small papers on it on which you can write suggestions.  "
	    "There is a slot in the top for stuffing the suggestion in "
	    "when you're done.\n" );
  set_name( "box" );
  set_main_plural( "boxes" );
  set_read_mess( "\nPlease fill in a suggestion form", "common" );
  add_property( "there", "sitting in the middle of the floor" );
  set_weight( 1000 ); 
  reset_get();
}

/**
 * @@ignore_yes
 */
void init() {
  add_command( "fill", "in a suggestion form", (: do_fill() :) );
}


/**
 * This function gives the suggestion box a file to write its suggestions to
 * @param string file The path of the directory to write suggestions to 
 * it had better end in / or you will be sorry.
 */
void set_save_file ( string file ) {
  _savefile = file;
  return;
}


/**
 * This function gives the suggestion box a directory to write its 
 * suggestions to. Either a save file *or* a save directory is required.
 * or your suggestions will not save.  If both are set then the save file
 * will be used.
 * @param string dir The path of the directory to write suggestions to 
 * it had better not end in / or you will be sorry.
 * @see set_save_file()
 */
void set_save_dir ( string dir ) {
  _savedir = dir;
  return;
}

/**
 * This function can be used to query what save file is in use for the
 * suggestion box.  Either a save file *or* a save directory is required.
 * or your suggestions will not save.  If both are set then the save file
 * will be used.
 * @return the full path to the file where the suggestions are kept
 * @see query_save_dir() 
 */

string query_save_file () {
  return _savefile;
}

/**
 * This function can be used to query what save directory is in use for the
 * suggestion box.  Either a save file *or* a save directory is required.
 * or your suggestions will not save.  If both are set then the save file
 * will be used.  If a save dir is used, the file name will be in the form of
 * save_dir/player_name-time.txt
 * @return the full path to the file where the suggestions are kept
 * @see query_save_file() 
 */

string query_save_dir () {
  return _savedir;
}

/**
 * @@ignore_yes
 */
int do_fill() { 
  tell_object( this_player(), "Please fill in your suggestion below.\n" );
  this_player()->do_edit( 0, "end_suggestion", this_object() );
  
  add_succeeded_mess( ({"", "$N fill$s in a suggestion form and stuff$s "
			  "it in the box.\n" }) );

  return 1;
}

/**
 * @@ignore_yes
 */
void end_suggestion( string text ) {
  string player, file;

  if( _savefile ) {
    // save to a file
    file = _savefile;
  } else if( _savedir ) {
    player = previous_object()->query_name();
    file = sprintf( query_save_dir() + "/%s-%d.txt", player, time() );
  } 

  debug_printf( "File: %s", file );

  if( !(unguarded( (: write_file, file, text :) ) ) ) {
    tell_object( previous_object(), "Sorry, your suggestion was not recorded."
		 "  Please use the 'bug object' command to bug report the "
		 "suggestion box.\n" );
    return;
  }

  tell_object( previous_object(), "You fill in a suggestion form and stuff "
	       "it in the box.\n" );
}
  
// --- END [/mnt/home2/grok/lib/obj/misc/suggestion_box.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/board_rab.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/board_rab.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628001   Available: 13575355
Inodes: Total: 5242880    Free: 4960134
15974 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/board_rab.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14628001   Available: 13575355
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <mail.h>
#include <board.h>

inherit "/obj/misc/board";

int do_transfer(int num, string str);

int do_store(int num, string str);
int do_storeall(string str);
int do_minimum(int num);
int do_maximum(int num);
int do_timeout(int num);
int do_add(string str);
int do_remove(string str);
int do_board(string str);
int do_archive(string str);
int do_killfile(string str);
int do_unkillfile(string str);

void setup() {
  ::setup();
  add_alias("board master");
  action_pri = 3;
  reset_drop();
  set_get();
} /* setup() */

/*
 * Need to redefine this to add all the extra bits and wombles to it.
 */
string long(string str, int dark) {
  int i, irp;
  mixed *stuff;
  string ret;
  mapping news_rc;

  stuff = (mixed *)BOARD_HAND->get_subjects(board_name);
  ret = "A bulletin board ("+board_name+").\n";
  irp = (int)BOARD_HAND->query_minimum(board_name);
  if (irp)
    ret += "Minimum number of messages left by automagic deletion is "+ irp +
           ".\n";
  irp = (int)BOARD_HAND->query_maximum(board_name);
  if (irp)
    ret += "Maximum number of messages on this board is "+irp+".\n";
  irp = (int)BOARD_HAND->query_timeout(board_name);
  if (irp)
    ret += "Messages will automagically time out in "+ irp +" days.\n";
  irp = (int)BOARD_HAND->query_archive(board_name);
  if (irp)
    ret += "Deleted messages are archived in "+irp+".\n";
  ret += sprintf("%#-*s\n\n", this_player()->query_cols(),
                            "read <note number>\npost <subject>\n"+
                            "boards\n"+
                            "store <note number> <file>\n"+
          "storeall <file> (optional)\n"+
          "eat <note number>\n"+
                            "reply <note number>\nfollowup <note number>\n"+
                            "summary [all]\nnext\nprev\nnew\n"+
                            "board <board name>\n"+
                            "timeout <time>\nminimum <num>\nmaximum <num>\n"+
                            "archive <name|none>\n"+
                            "security\nsadd <name>\nsremove <name>\n"+
                            "killfile <board name>\nunkillfile <board name>\nlistkillfile\ntransfer <note> <board>");
  if (!sizeof(stuff))
    return ret+"The board is completely empty.\n";
  news_rc = (mapping)this_player()->query_property(NEWS_RC);
  if (!news_rc)
    news_rc = ([ ]);
  for (i=0;i<sizeof(stuff);i++)
    if (news_rc[board_name] < stuff[i][B_TIME])
      ret += sprintf("N %2d: %-=*s\n", i+1, (int)this_player()->query_cols()-6,
             stuff[i][B_SUBJECT]+" ("+
             stuff[i][B_NAME]+" "+the_date(stuff[i][B_TIME])+")");
    else
      ret += sprintf("  %2d: %-=*s\n", i+1, (int)this_player()->query_cols()-6,
             stuff[i][B_SUBJECT]+" ("+
             stuff[i][B_NAME]+" "+the_date(stuff[i][B_TIME])+")");
  return ret;
} /* long() */

void init() {
   /* Add the standard board commands... */
   if (environment() == this_player() &&
       this_player()->query_creator()) {
      add_commands();
      add_command("store", "<number> <word>", (: do_store($4[0], $4[1]) :));
      add_command("storeall", "<word>", (: do_storeall($4[0]) :));
      add_command("next", "");
      add_command("prev", "");
      add_command("new", "");
      add_command("board", "<string>", (: do_board($4[0]) :));
      add_command("boards", "");
      add_command("killfile", "<string>", (: do_killfile($4[0]) :));
      add_command("unkillfile", "<string>",(: do_unkillfile($4[0]) :)); 
      add_command("listkillfile", "");
      add_command("security", "");
      add_command("sadd", "<word>", (: do_add($4[0]) :));
      add_command("sremove", "<word>", (: do_remove($4[0]) :));
      add_command("timeout", "<number>", (: do_timeout($4[0]) :));
      add_command("minimum", "<number>", (: do_minimum($4[0]) :));
      add_command("maximum", "<number>", (: do_maximum($4[0]) :));
      add_command("archive", "<word>", (: do_archive($4[0]) :));
      add_command("summary", "");
      add_command("skip", "");
      add_command("arts", "");
      add_command("transfer", "<number> <string>",
                     (: do_transfer($4[0], $4[1]) :));
   }
} /* init() */

int do_storeall(string file) {
  int which;
  mixed *stuff;
  int i, j, no, amt, cnt=0;
  string *boards, their_name;
  mapping news_rc;

  seteuid( geteuid( this_player() ) );
  their_name = this_player()->query_name();
  //if (!str || (sscanf(str, "%s", file) != 1)) 
    //file = "/w/"+their_name+"/boards.txt";

  boards = (string *)BOARD_HAND->list_of_boards();
  /* start from the begining and search for one with new notes. */
  news_rc = (mapping)this_player()->query_property(NEWS_RC);
  if (!write_file(file, "File created on "+ctime(time())+
                        " - Seattle time\n", 1)) {
    add_failed_mess("Unable to save the file "+file+"\n");
    return 0;
  }
  for (i=0;i<sizeof(boards);i++) {
    if (!this_player()->query_property("news_kill_"+lower_case(boards[i]))) {
      stuff = (mixed *)BOARD_HAND->get_subjects(boards[i]);
      if (!sizeof(stuff))
        continue;
      for (amt=sizeof(stuff)-1;amt >= 0 &&
                               (stuff[amt][B_TIME] > news_rc[boards[i]] &&
                               lower_case(stuff[amt][B_NAME]) != their_name);
                 amt--);
      if (amt != sizeof(stuff)-1) {
        write_file(file,"\n----> Bulletin Board Name: "+boards[i]+"\n\n\n");
        news_rc[boards[i]] = stuff[sizeof(stuff)-1][B_TIME];
        for(j = amt+1;j<sizeof(stuff);j++) {
          write_file(file,"***** Note #" +(j+1)+ " by " +stuff[j][B_NAME]+
       " posted at " +ctime(stuff[j][B_TIME])+ "\nTitle: "+
       stuff[j][B_SUBJECT][0..(int)this_player()->
                                                 query_cols() - 10]+"\n\n"+
                         BOARD_HAND->get_message(boards[i], j)+"\n\n\n");

          if (cnt == 0)
             printf("Storing ");
          cnt++;
          printf(".");
        }
      }
    }
  }
  add_succeeded_mess(this_object(), ({
                   "\n"+cnt+" new messages are now saved in "+file+"\n",
                   "$N appears to scribble something a lot.\n" }), ({ }));
  if (cnt == 0) {
    this_player()->add_property(NEWS_RC, news_rc);
  }
  return 1;
} /* do_storeall() */

int do_store(int which, string file) {
  mixed *stuff;

  stuff = (mixed *)BOARD_HAND->get_subjects(board_name);
  if (which < 1 || which > sizeof(stuff)) {
    add_failed_mess("Invalid note number.\n");
    return 0;
  }
  which--; /* 1..n */
  file += ".note";
  if (!write_file(file,stuff[which][B_SUBJECT]+"\n\n"+
                  BOARD_HAND->get_message(board_name, which))) {
    add_failed_mess("The master object appears and prevents you.\n");
    return 0;
  }
  add_succeeded_mess(this_object(), ({ "Ok.\n", "$N copies some stuff off "
                                       "the board.\n" }), ({ }) );
  return 1;
} /* do_store() */

void set_board_name(string str) { board_name = str; }
void set_datafile(string str) { board_name = str; }

int do_next() {
  int i;
  string *boards;

  boards = (string *)BOARD_HAND->list_of_boards();
  if ((i = member_array(board_name, boards)) == -1)
    i = 0;
  else
    i = (i+1)%sizeof(boards);
  board_name = boards[i];
  add_succeeded_mess(this_object(), ({ "Gone to board:"+board_name+".\n",
                      "$N turns their board over.\n" }), ({ }) );
  return 1;
} /* next() */

int prev() {
  int i;
  string *boards;

  boards = (string *)BOARD_HAND->list_of_boards();
  if ((i = member_array(board_name, boards)) == -1)
    i = 0;
  else
    i = (i-1+sizeof(boards))%sizeof(boards);
  board_name = boards[i];
  add_succeeded_mess(this_object(), ({ "Gone to board:"+board_name+".\n",
                      "$N turns their board over.\n" }), ({ }) );
  return 1;
} /* prev() */

int do_killfile(string arg) {
  this_player()->add_property( "news_kill_" +lower_case( arg ), 1 );
  add_succeeded_mess(this_object(), ({ "Board "+arg+" killed.\n", "" }), ({}));
  return 1;
} /* kfile() */

int do_unkillfile(string arg) {
  if (!this_player()->query_property( "news_kill_" +lower_case( arg ) )) {
     add_failed_mess("Board "+arg+" is not kill file anyway.\n");
     return 0;
  } else {
     this_player()->remove_property( "news_kill_" +lower_case( arg ) );
     add_succeeded_mess(this_object(), ({ "Board "+arg+" unkilled.\n", "" }),
                       ({ }));
  }
  return 1;
} /* ukfile() */

int do_listkillfile(string arg) {
   string property, s1, *boards=({ });
   mixed value;
   
   foreach ( property, value in this_player()->query_properties() )
      if ( sscanf(property,"news_kill_%s",s1) == 1 &&
           value )
         boards += ({ s1 });
   if ( sizeof( s1 ) )
      tell_object( this_player(), "You have the following boards killfiled: "+
                  query_multiple_short( boards ) +".\n" );
   add_succeeded_mess(this_object(), "", ({ }));
   return 1;
} /* lkfile() */

int do_new() {
  int i, amt;
  string *boards, their_name;
  mixed *stuff;
  mixed otherstuff;
  mapping news_rc;

  boards = (string *)BOARD_HAND->list_of_boards();
  their_name = this_player()->query_name();
  /* start from the begining and search for one with new notes. */
  news_rc = (mapping)this_player()->query_property(NEWS_RC);

  for (i=0;i<sizeof(boards);i++) {
    if (!this_player()->query_property("news_kill_"+lower_case(boards[i]))) {
      stuff = (mixed *)BOARD_HAND->get_subjects(boards[i]);

      if (!sizeof(stuff))
        continue;

      for (amt=sizeof(stuff)-1;amt >= 0 &&
                               (stuff[amt][B_TIME] > news_rc[boards[i]] &&
                                lower_case(stuff[amt][B_NAME]) != their_name);
                 amt--);
      if (amt != sizeof(stuff)-1) {
        board_name = boards[i];
        add_succeeded_mess(this_object(), ({
          "The "+ boards[ i ] +" board has "+ ( sizeof( stuff ) - amt -
          1 ) +" new message"+ ( ( ( sizeof( stuff ) - amt ) > 2 ) ? "s" : "" )
          +".\n", "$N turns over their board.\n" }), ({ }));
        return 1;
      }
    }
  }
  add_failed_mess("No boards with new messages.\n");
  return 0;
} /* do_new() */

int do_board(string str) {
  int i;
  string *boards;

  boards = (string *)BOARD_HAND->list_of_boards();
  i = member_array(str, boards);
  if (i == -1) {
    add_failed_mess("The board "+str+" does not exist sorry.\n");
    return 0;
  }
  add_succeeded_mess(this_object(), ({ "Okay, changed to board "+ str +".\n",
                                   "$N turns over their board.\n" }), ({ }));
  board_name = str;
  return 1;
} /* board() */

int do_boards() {
   write( "The current boards are:\n\""+
         implode( (string *)BOARD_HAND->list_of_boards(), "\", \"" ) +
         "\".\n" );
  return 1;
} /* boards() */

int do_security() {
   write( "The current people in this boards security array are:\n"+
        implode((string *)BOARD_HAND->query_security(board_name), ", ")+"\n");
  return 1;
} /* do_security() */

int do_add(string name) {
  if (this_player() != this_player(1) ||
      !interactive(previous_object()))
    return 0;
  return (int)BOARD_HAND->add_allowed(board_name, name);
} /* do_add() */

int do_remove(string name) {
  if (this_player() != this_player(1) ||
      !interactive(previous_object()))
    return 0;
  return (int)BOARD_HAND->remove_allowed(board_name, name);
} /* do_remove() */

int do_timeout(int i) {
  if (this_player() != this_player(1) ||
      !interactive(previous_object()))
    return 0;
  return (int)BOARD_HAND->set_timeout(board_name, i);
} /* do_timeout() */

int do_minimum(string i) {
  if (this_player() != this_player(1) ||
      !interactive(previous_object()))
    return 0;
  return (int)BOARD_HAND->set_minimum(board_name, i);
} /* do_minimum() */

int do_maximum(int i) {
  if (this_player() != this_player(1) ||
      !interactive(previous_object()))
    return 0;
  return (int)BOARD_HAND->set_maximum(board_name, i);
} /* do_maximum() */

int do_archive(string name) {
  if (!name)
    return 0;
  if (name != "none")
    return (int)BOARD_HAND->set_archive(board_name, name);
  return (int)BOARD_HAND->set_archive(board_name);
} /* do_archive() */

varargs int move(object dest, string s1, string s2) {
  int ret;

  if (!objectp(dest))
    return ::move(dest, s1, s2);
  if (interactive(dest)) {
    ret = ::move(dest, s1, s2);
    if (ret)
      return ret;
    seteuid(geteuid(dest));
    return 0;
  }
  return ::move(dest, s1, s2);
} /* move() */

mixed query_static_auto_load() {
  return board_name;
} /* query_static_auto_load() */

void init_static_arg(mixed board) {
  if (stringp(board))
    board_name = board;
} /* init_static_auto_load() */

int do_summary(string str) {
  int i, no, amt;
  string *boards, their_name;
  mapping news_rc;
  mixed *stuff;

  boards = (string *)BOARD_HAND->list_of_boards();
  /* start from the begining and search for one with new notes. */
  news_rc = (mapping)this_player()->query_property(NEWS_RC);
  their_name = this_player()->query_name();
  for (i=0;i<sizeof(boards);i++) {
    if (!this_player()->query_property("news_kill_"+lower_case(boards[i]))) {
      stuff = (mixed *)BOARD_HAND->get_subjects(boards[i]);
      if (!sizeof(stuff))
        continue;
      for (amt=sizeof(stuff)-1;amt >= 0 &&
                               (stuff[amt][B_TIME] > news_rc[boards[i]] &&
                               lower_case(stuff[amt][B_NAME]) != their_name);
                 amt--);
      if (amt != sizeof(stuff)-1) {
        printf( "The "+ boards[ i ] +" board has "+ ( sizeof( stuff ) - amt -
          1 ) +" new message"+ ( ( ( sizeof( stuff ) - amt ) > 2 ) ? "s" : "" )
          +".\n" );
        no++;
      } else if (str == "all") {
        printf("The "+boards[i]+" board has no new messages.\n");
        no++;
      }
    }
  }
  if (no) {
    add_succeeded_mess(this_object(), ({ "", "$N runs their finger over "
                                             "thier board.\n" }), ({ }));
  } else {
    add_failed_mess("No boards with new messages.\n");
  }
  return no;
} /* do_summary() */

/* Skip does the same as a new, but marks the board as read. */
int do_skip() {
  mapping news_rc;
  mixed *otherstuff;

  news_rc = (mapping)this_player()->query_property(NEWS_RC);
  otherstuff = (mixed *)BOARD_HAND->get_subjects(board_name);
  if (sizeof(otherstuff)) {
    news_rc[board_name] = otherstuff[sizeof(otherstuff)-1][B_TIME];
    this_player()->add_property(NEWS_RC, news_rc);
  }
  printf("Marked all of "+board_name+" as read.\n");
  if (!do_new()) {
    printf("No new messages.\n");
  }
  add_succeeded_mess(this_object(), "", ({ }));
  return 1;
} /* do_skip() */

int do_arts() {
  int i;
  mixed *otherstuff;

  otherstuff = (mixed *)BOARD_HAND->get_subjects(board_name);
  for (i=0;i<sizeof(otherstuff);i++)
    printf("%2d# %-20s %d\n", i, otherstuff[i][B_NAME], otherstuff[i][B_NUM]);
  add_succeeded_mess(this_object(), "", ({ }));
  return 1;
} /* do_arts() */

int do_transfer(int num, string str) {
  string mess;
  string *boards;
  mixed *otherstuff;
  int i;

  boards = (string *)BOARD_HAND->query_boards();
  otherstuff = (mixed *)BOARD_HAND->get_subjects(board_name);
  if (member_array(str, boards) == -1) {
    add_failed_mess("Cannot find the board '"+str+"'.\n");
    return 0;
  }
  if (num < 1 || num > sizeof(otherstuff)) {
    add_failed_mess("There is no note '"+num+"' on the board '"+
                        board_name+".\n");
    return 0;
  }
  mess = BOARD_HAND->get_message(board_name, num-1);
  if (mess && BOARD_HAND->add_message(str, otherstuff[num-1][B_NAME],
                              otherstuff[num-1][B_SUBJECT],
                              mess)) {
    write("Transfered note "+num+" to board '"+str+
                   "', local copy retained.\n");
    return 1;
  }
  add_failed_mess("Unable to transfer note "+num+" to the board '"+
                      board_name+", no security privilages?\n");
  return 0;
} /* do_transfer() */
// --- END [/mnt/home2/grok/lib/obj/misc/board_rab.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/crystal_phial.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/crystal_phial.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627997   Available: 13575351
Inodes: Total: 5242880    Free: 4960134
2059 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/crystal_phial.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627997   Available: 13575351
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/obj/vessel";

void setup() {
   set_name( "phial" );
   set_short( "crystal phial" );
   add_adjective( "crystal" );
   set_main_plural( "crystal phials" );
   set_long( "This is a small tube-like bottle made of some sort of "+
         "crystal.  A stopper is attached at one end on a bit of wire.\n" );
   set_weight( 1 );
   set_value( 1000 );
   set_max_weight( 1 );
   set_max_volume( 10 );
   set_transparent();
} /* setup() */

int test_add( object thing, int flag ) {
   string word;
   object *things;
   if ( !this_player() )
      return ::test_add( thing, flag );
   things = all_inventory( this_object() );
   if ( !sizeof( things ) )
      return ::test_add( thing, flag );
   word = (string)things[ 0 ]->query_medium_alias();
   if ( word == (string)thing->query_medium_alias() )
      return ::test_add( thing, flag );
   write( "You don't want to contaminate "+ ( stringp( word ) ?
         (string)things[ 0 ]->the_short() :
         (string)thing->the_short() ) +", do you?\n" );
   return 0;
} /* test_add() */

object query_substance() {
   object *things;
   things = all_inventory( this_object() );
   if ( !sizeof( things ) )
      return 0;
   if ( !stringp( (string)things[ 0 ]->query_medium_alias() ) )
      return 0;
   return things[ 0 ];
} /* query_substance() */

string short( int dark ) {
   object thing = query_substance();
   if ( dark || !objectp( thing ) )
      return ::short( dark );
   return ::short( dark ) +" of "+ (string)thing->short( dark );
} /* short() */

string query_plural( int dark ) {
   object thing = query_substance();
   if ( dark || !objectp( thing ) )
      return ::query_plural( dark );
   return ::query_plural( dark ) +" of "+ (string)thing->short( dark );
} /* query_plural() */

string *parse_command_adjectiv_id_list() {
   object thing = query_substance();
   if ( !objectp( thing ) )
      return ::parse_command_adjectiv_id_list();
   return ::parse_command_adjectiv_id_list() + ({ "of" }) +
      (string *)thing->query_adjectives();
} /* parse_command_adjectiv_id_list() */
// --- END [/mnt/home2/grok/lib/obj/misc/crystal_phial.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/board_mas.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/board_mas.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627996   Available: 13575350
Inodes: Total: 5242880    Free: 4960134
16707 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/board_mas.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627996   Available: 13575350
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <mail.h>
#include <board.h>

inherit "/obj/misc/board";

int do_store(int num, string str);
int do_storeall(string str);
int do_minimum(int num);
int do_maximum(int num);
int do_timeout(int num);
int do_add(string str);
int do_remove(string str);
int do_board(string str);
int do_archive(string str);
int do_killfile(string str);
int do_unkillfile(string str);
int do_transfer(int num, string str);
int do_summary();
int do_skip(string str, int move_on);

int calc_new(object player, string board);

void setup() {
  ::setup();
  add_alias("board master");
  action_pri = 3;
  reset_drop();
  set_get();
} /* setup() */

/*
 * Need to redefine this to add all the extra bits and wombles to it.
 */
string long(string str, int dark) {
  int i, irp;
  mixed *stuff;
  string ret;
  mapping news_rc;

  stuff = (mixed *)BOARD_HAND->get_subjects(board_name);
  ret = "A bulletin board ("+board_name+").\n";
  irp = (int)BOARD_HAND->query_minimum(board_name);
  if (irp)
    ret += "Minimum number of messages left by automagic deletion is "+ irp +
           ".\n";
  irp = (int)BOARD_HAND->query_maximum(board_name);
  if (irp)
    ret += "Maximum number of messages on this board is "+irp+".\n";
  irp = (int)BOARD_HAND->query_timeout(board_name);
  if (irp)
    ret += "Messages will automagically time out in "+ irp +" days.\n";
  irp = (int)BOARD_HAND->query_archive(board_name);
  if (irp)
    ret += "Deleted messages are archived in "+irp+".\n";
  ret += sprintf("%#-*s\n\n", this_player()->query_cols(),
                 "read <note number>\npost <subject>\n"+
                 "boards\n"
                 "store <note number> <file>\n"
                 "storeall <file> (optional)\n"
                 "eat <note number>\n"
                 "reply <note number>\n"
                 "followup <note number>\n"
                 "summary [all]\n"
                 "next\n"
                 "prev\n"
                 "skip [<board name>]\n"
                 "board <board name>\n"
                 "timeout <time>\n"
                 "minimum <num>\n"
                 "maximum <num>\n"
                 "archive <name|none>\n"
                 "security\n"
                 "sadd <name>\n"
                 "sremove <name>\n"
                 "killfile <board name>\n"
                 "unkillfile <board name>\n"
                 "listkillfile\ntransfer <note> <board>");
  if (!sizeof(stuff))
    return ret+"The board is completely empty.\n";
  news_rc = BOARD_HAND->query_newsrc(this_player()->query_name());
  if (!news_rc)
    news_rc = ([ ]);
  for (i=0;i<sizeof(stuff);i++)
    if (news_rc[board_name] < stuff[i][B_TIME])
      ret += sprintf("N %2d: %-=*s\n", i+1, (int)this_player()->query_cols()-6,
             stuff[i][B_SUBJECT]+" ("+
             stuff[i][B_NAME]+" "+the_date(stuff[i][B_TIME])+")");
    else
      ret += sprintf("  %2d: %-=*s\n", i+1, (int)this_player()->query_cols()-6,
             stuff[i][B_SUBJECT]+" ("+
             stuff[i][B_NAME]+" "+the_date(stuff[i][B_TIME])+")");
  return ret;
} /* long() */

int calc_new(object who, string board) {
  mapping news_rc;
  mixed *stuff;
  int amt;

  news_rc = BOARD_HAND->query_newsrc(who->query_name());
  if ( !news_rc )
    news_rc = ([ ]);
  
  stuff = (mixed *)BOARD_HAND->get_subjects(board);
  if ( !sizeof( stuff ) )
    return 0;
  
  amt = sizeof( filter_array( stuff, (: ( $1[ B_TIME ] > $2 ) &&
              ( lower_case( $1[ B_NAME ] ) != $3 ) :), news_rc[ board ],
                              (string)who->query_name() ) );
  return amt;
}

void init() {
   /* Add the standard board commands... */
   if (this_player()->query_creator()) {
      add_commands();
      add_command("store", "<number> <word>", (: do_store($4[0], $4[1]) :));
      add_command("storeall", "<word>", (: do_storeall($4[0]) :));
      add_command("next", "");
      add_command("prev", "");
      add_command("new", "");
      add_command("board", "<string>", (: do_board($4[0]) :));
      add_command("boards", "");
      add_command("killfile", "<string>", (: do_killfile($4[0]) :));
      add_command("unkillfile", "<string>",(: do_unkillfile($4[0]) :)); 
      add_command("listkillfile", "");
      add_command("security", "");
      add_command("sadd", "<word>", (: do_add($4[0]) :));
      add_command("sremove", "<word>", (: do_remove($4[0]) :));
      add_command("timeout", "<number>", (: do_timeout($4[0]) :));
      add_command("minimum", "<number>", (: do_minimum($4[0]) :));
      add_command("maximum", "<number>", (: do_maximum($4[0]) :));
      add_command("archive", "<word>", (: do_archive($4[0]) :));
      add_command("summary", "");
      add_command("skip", "", (: do_skip(0, 1) :));
      add_command("catchup", "", (: do_skip(0, 0) :));
      add_command("skip", "<string>", (: do_skip($4[0], 1) :));
      add_command("catchup", "<string>", (: do_skip($4[0], 0) :));
      add_command("arts", "");
      add_command("transfer", "<number> <string>",
                     (: do_transfer($4[0], $4[1]) :));
   }
} /* init() */

int do_storeall(string file) {
  mixed *stuff;
  int i, j, amt, cnt=0;
  string *boards, their_name;
  mapping news_rc;

  seteuid( geteuid( this_player() ) );
  their_name = this_player()->query_name();
  //if (!str || (sscanf(str, "%s", file) != 1)) 
    //file = "/w/"+their_name+"/boards.txt";

  boards = (string *)BOARD_HAND->list_of_boards();
  /* start from the begining and search for one with new notes. */
  news_rc = BOARD_HAND->query_newsrc(this_player()->query_name());
   if ( !news_rc )
      news_rc = ([ ]);
  if (!write_file(file, "File created on "+ctime(time())+
                        " - Seattle time\n", 1)) {
    add_failed_mess("Unable to save the file "+file+"\n");
    return 0;
  }
  for (i=0;i<sizeof(boards);i++) {
    reset_eval_cost();
    if (!BOARD_HAND->query_killfile(this_player()->query_name(), lower_case(boards[i]))) {
      stuff = (mixed *)BOARD_HAND->get_subjects(boards[i]);
      if (!sizeof(stuff))
        continue;
      for (amt=sizeof(stuff)-1;amt >= 0 &&
                               (stuff[amt][B_TIME] > news_rc[boards[i]] &&
                               lower_case(stuff[amt][B_NAME]) != their_name);
                 amt--);
      if (amt != sizeof(stuff)-1) {
        write_file(file,"\n----> Bulletin Board Name: "+boards[i]+"\n\n\n");
        news_rc[boards[i]] = stuff[sizeof(stuff)-1][B_TIME];
        for(j = amt+1;j<sizeof(stuff);j++) {
          write_file(file,"***** Note #" +(j+1)+ " by " +stuff[j][B_NAME]+
       " posted at " +ctime(stuff[j][B_TIME])+ "\nTitle: "+
       stuff[j][B_SUBJECT][0..(int)this_player()->
                                                 query_cols() - 10]+"\n\n"+
                         BOARD_HAND->get_message(boards[i], j)+"\n\n\n");

          if (cnt == 0)
             printf("Storing ");
          cnt++;
          printf(".");
        }
      }
    }
  }
  write("\n"+cnt+" new messages are now saved in "+file+"\n");
  if (cnt == 0) {
    BOARD_HAND->set_newsrc(this_player()->query_name(), news_rc);
  }
  return 1;
} /* do_storeall() */

int do_store(int which, string file) {
  mixed *stuff;

  stuff = (mixed *)BOARD_HAND->get_subjects(board_name);
  if (which < 1 || which > sizeof(stuff)) {
    add_failed_mess("Invalid note number.\n");
    return 0;
  }
  which--; /* 1..n */
  file += ".note";
     seteuid( geteuid( this_player() ) );
  if (!write_file(file,stuff[which][B_SUBJECT]+"\n\n"+
                  BOARD_HAND->get_message(board_name, which))) {
    add_failed_mess("The master object appears and prevents you.\n");
    return 0;
  }
  write("Ok.\n");
  return 1;
} /* do_store() */

void set_board_name(string str) { board_name = str; }
void set_datafile(string str) { board_name = str; }


int do_next() {
  int start, i, j, k, found;
  string *boards;
  
  if(calc_new(this_player(), board_name))
    return do_read_new();

  boards = (string *)BOARD_HAND->list_of_boards();
  if ((start = member_array(board_name, boards)) == -1)
    start = 0;
  for(i=0; i<sizeof(boards); i++) {
    j = (i + start) % sizeof(boards);
    if(!BOARD_HAND->query_killfile(this_player()->query_name(),
                                     lower_case(boards[j])) &&
       k = calc_new(this_player(), boards[j])) {
      found = 1;
      break;
    }
  }

  if(found) {
    board_name = boards[j];
    write("Okay, changed to board "+board_name+" with " + k +
          " new notes.\n");
    return do_read_new();
  } else
    write("No boards with new messages.\n");
  
  return 1;
} /* next() */

int do_prev() {
  int i;
  string *boards;

  boards = (string *)BOARD_HAND->list_of_boards();
  if ((i = member_array(board_name, boards)) == -1)
    i = 0;
  else
    i = (i-1+sizeof(boards))%sizeof(boards);
  board_name = boards[i];
  write("Okay, changed to board "+board_name+".\n");
  return 1;
} /* prev() */

int do_killfile(string arg) {
    string *bits, board;

    bits = explode( arg, "," );

    foreach ( board in bits ) {        
        if ( sizeof( BOARD_HAND->get_subjects( board ) ) ) {
          BOARD_HAND->set_killfile(this_player()->query_name(),
                lower_case( board ));
            tell_object( this_player(), "Board " + board  + " killed.\n" );
        }
        else { 
            tell_object( this_player(), "There is no such board " + 
                board + ".\n" );  
        }
    }
    
    return 1;
} /* do_kill_file() */



int do_unkillfile(string arg) {
  if (!BOARD_HAND->query_killfile(this_player()->query_name(),
                                  lower_case( arg ) )) {
     add_failed_mess("Board "+arg+" is not kill file anyway.\n");
     return 0;
  } else {
    BOARD_HAND->remove_killfile(this_player()->query_name(),
                                lower_case(arg));
     write("Board "+arg+" unkilled.\n");
  }
  return 1;
} /* ukfile() */

int do_listkillfile() {
   string *boards;

   boards = BOARD_HAND->list_killfile(this_player()->query_name());
   if ( sizeof( boards ) )
     write("You have the following boards killfiled: "+
           query_multiple_short( boards ) +".\n" );
   return 1;
} /* lkfile() */

int do_board(string str) {
  int i;
  string *boards;

  boards = (string *)BOARD_HAND->list_of_boards();
  i = member_array(str, boards);
  if (i == -1) {
    add_failed_mess("The board "+str+" does not exist sorry.\n");
    return 0;
  }
  write("Okay, changed to board "+ str);
  i = calc_new(this_player(), boards[i]);
  if(i)
    write(" with " + i + " new notes.\n");
  else
    write(" with no new notes.\n");

  board_name = str;
  return 1;
} /* board() */

int do_boards() {
   write( "The current boards are:\n\""+
         implode( (string *)BOARD_HAND->list_of_boards(), "\", \"" ) +
         "\".\n" );
  return 1;
} /* boards() */

int do_security() {
   write( "The current people in this boards security array are:\n"+
        implode((string *)BOARD_HAND->query_security(board_name), ", ")+"\n");
  return 1;
} /* do_security() */

int do_add(string name) {
  if (this_player() != this_player(1) ||
      !interactive(previous_object()))
    return 0;
  return (int)BOARD_HAND->add_allowed(board_name, name);
} /* do_add() */

int do_remove(string name) {
  if (this_player() != this_player(1) ||
      !interactive(previous_object()))
    return 0;
  return (int)BOARD_HAND->remove_allowed(board_name, name);
} /* do_remove() */

int do_timeout(int i) {
  if (this_player() != this_player(1) ||
      !interactive(previous_object()))
    return 0;
  return (int)BOARD_HAND->set_timeout(board_name, i);
} /* do_timeout() */

int do_minimum(string i) {
  if (this_player() != this_player(1) ||
      !interactive(previous_object()))
    return 0;
  return (int)BOARD_HAND->set_minimum(board_name, i);
} /* do_minimum() */

int do_maximum(int i) {
  if (this_player() != this_player(1) ||
      !interactive(previous_object()))
    return 0;
  return (int)BOARD_HAND->set_maximum(board_name, i);
} /* do_maximum() */

int do_archive(string name) {
  if (!name)
    return 0;
  if (name != "none")
    return (int)BOARD_HAND->set_archive(board_name, name);
  return (int)BOARD_HAND->set_archive(board_name);
} /* do_archive() */

varargs int move(object dest, string s1, string s2) {
  int ret;

  if (!objectp(dest))
    return ::move(dest, s1, s2);
  if (interactive(dest)) {
    ret = ::move(dest, s1, s2);
    if (ret)
      return ret;
    seteuid(geteuid(dest));
    return 0;
  }
  return ::move(dest, s1, s2);
} /* move() */

mixed query_static_auto_load() {
  return board_name;
} /* query_static_auto_load() */

void init_static_arg(mixed board) {
  if (stringp(board))
    board_name = board;
} /* init_static_auto_load() */

int do_summary() {
   int i, no, amt;
   string *boards;

   boards = (string *)BOARD_HAND->list_of_boards();
   for ( i = sizeof( boards ) - 1; i > -1; i-- )
      if ( !BOARD_HAND->query_killfile(this_player()->query_name(),
                                      lower_case( boards[ i ] ) ) ) {
        amt = calc_new(this_player(), boards[i]);
         if ( amt ) {
            printf( "The %s board has %d new message%s.\n", boards[ i ],
                  amt, amt > 1 ? "s" : "" );
            no++;
         }
      }
   if ( !no )
      add_failed_mess( "No boards with new messages.\n" );
   return no;
} /* do_summary() */

int do_new() {
   int i, amt;
   string *boards;
   boards = (string *)BOARD_HAND->list_of_boards();
   for ( i = sizeof( boards ) - 1; i > -1; i-- )
     if ( !BOARD_HAND->query_killfile(this_player()->query_name(),
                                      lower_case( boards[ i ] ) ) ) {
        amt = calc_new(this_player(), boards[i]);
         if ( amt ) {
            board_name = boards[ i ];
            printf( "The %s board has %d new message%s.\n", boards[ i ],
                  amt, amt > 1 ? "s" : "" );
            return 1;
         }
      }
   add_failed_mess( "No boards with new messages.\n" );
   return 0;
} /* do_new() */

/* Skip does the same as a new, but marks the board as read. */
int do_skip(string str, int move_on) {
  mapping news_rc;
  mixed *otherstuff;
  int i, j, k, start, found;
  string *boards;
  
  if(!str) {
    str = board_name;
  }

  boards = (string *)BOARD_HAND->list_of_boards();
  if(member_array(str, boards) == -1)
    return notify_fail("No such board " + str + ".\n");

  news_rc = BOARD_HAND->query_newsrc(this_player()->query_name());
   if ( !news_rc )
      news_rc = ([ ]);
  otherstuff = (mixed *)BOARD_HAND->get_subjects(str);
  if (sizeof(otherstuff)) {
    news_rc[str] = otherstuff[sizeof(otherstuff)-1][B_TIME];
    BOARD_HAND->set_newsrc(this_player()->query_name(), news_rc);
  }
  printf("Marked all of "+str+" as read.\n");

  if(move_on) {
    // Needed coz skipping a large number of messages can be a little costly.
    reset_eval_cost();
    if ((start = member_array(board_name, boards)) == -1)
      start = 0;
    for(i=0; i<sizeof(boards); i++) {
      j = (i + start) % sizeof(boards);
      if(!BOARD_HAND->query_killfile(this_player()->query_name(),
                                     lower_case(boards[j])) &&
         k = calc_new(this_player(), boards[j])) {
        found = 1;
        break;
      }
    }
    
    if(found) {
      board_name = boards[j];
      write("Okay, changed to board "+board_name+" with " + k +
            " new notes.\n");
    } else
      write("No boards with new messages.\n");
  }
  return 1;
} /* do_skip() */

int do_arts() {
  int i;
  mixed *otherstuff;

  otherstuff = (mixed *)BOARD_HAND->get_subjects(board_name);
  for (i=0;i<sizeof(otherstuff);i++)
    printf("%2d# %-20s %d\n", i, otherstuff[i][B_NAME], otherstuff[i][B_NUM]);
  return 1;
} /* do_arts() */

int do_transfer(int num, string str) {
  string mess;
  string *boards;
  mixed *otherstuff;

  boards = (string *)BOARD_HAND->query_boards();
  otherstuff = (mixed *)BOARD_HAND->get_subjects(board_name);
  if (member_array(str, boards) == -1) {
    add_failed_mess("Cannot find the board '"+str+"'.\n");
    return 0;
  }
  if (num < 1 || num > sizeof(otherstuff)) {
    add_failed_mess("There is no note '"+num+"' on the board '"+
                        board_name+".\n");
    return 0;
  }
  mess = BOARD_HAND->get_message(board_name, num-1);
  if (mess && BOARD_HAND->add_message(str, otherstuff[num-1][B_NAME],
                              otherstuff[num-1][B_SUBJECT],
                              mess)) {
    write("Transfered note "+num+" to board '"+str+
                   "', local copy retained.\n");
    return 1;
  }
  add_failed_mess("Unable to transfer note "+num+" to the board '"+
                      board_name+", no security privilages?\n");
  return 0;
} /* do_transfer() */
// --- END [/mnt/home2/grok/lib/obj/misc/board_mas.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/tin_of_paint.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/tin_of_paint.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627992   Available: 13575346
Inodes: Total: 5242880    Free: 4960134
5504 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/tin_of_paint.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627992   Available: 13575346
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* A tin of paint. */

inherit "/obj/vessel";

#define VOLUME 5000

private nosave string _colour;

varargs int do_paint(string, object);

void setup() {
  set_name( "tin" );
  set_short( "tin of paint" );
  set_main_plural( "tins of paint");
  add_adjective( ({ "tin", "of"}));
  add_alias(({"paint"}));
  set_long( "A tin of paint.  It has a picture of a man with "
            "a big smile on his face painting a wall.\n");
  set_leak_rate( 0 );
  set_max_volume( VOLUME );
  set_value( 30 );
  set_weight( 10 );
  set_max_weight( 30 );
}

void setup_attribs() {
  set_short( "tin of " + _colour + " paint" );
  set_main_plural( "tins of " + _colour + " paint");
  add_adjective( ({ _colour}));
  set_long( "A tin of " + _colour + " paint.  It has a picture of a man with "
            "a big smile on his face painting a wall.\n");
}

void make_tin( string colour ) {
  object liquid;
  liquid = clone_object( "/obj/reagents/generic_liquid.ob" );
  liquid->set_name( "paint" );
  liquid->set_short( colour + " paint" );
  liquid->add_adjective(({colour }));
  liquid->set_amount( VOLUME );
  liquid->set_continuous();
  liquid->set_long( "This is " + colour + " paint, it's thick and gloopy.\n");
  liquid->set_pile_name( "puddle" );
  liquid->add_eat_effect( "/std/effects/ingested/poison", 10 );
  liquid->move( this_object() );

  set_closed();
  _colour = colour;
  setup_attribs();
}

/** @ignore yes */
void init() {
  ::init();
  this_player()->add_command("paint", this_object(),
           "<indirect:object:here'cardinal direction'> with <direct:object'paint'>",
                        (: do_paint( $4[0] ) :));
  this_player()->add_command("paint", this_object(),
                        "<string'part'> on <indirect:object:here> with <direct:object'paint'>",
                        (: do_paint( $4[0], $1[0] ) :));
  this_player()->add_command("paint", this_object(),
            "<indirect:object:here> help",
            (: do_paint( 0, $1[0] ) :));
}

varargs int do_paint(string indirect, object target) {
  object *obs;
  
  if(!indirect && target) {
      if(function_exists("what_to_paint", target))
          printf(target->what_to_paint());
      else
          printf("Help: paint " + target->short() + " with paint\n");
      return 1;
  }

  obs = match_objects_for_existence("paint", this_object());

  if(!query_volume() || !sizeof(obs)) {
    this_player()->add_failed_mess(this_object(), "$D appears to be empty.\n",
                                   ({ }));
    return 0;
  }

  if(query_closed()) {
    this_player()->add_failed_mess(this_object(), "$D is closed.\n", ({ }));
    return 0;
  }

  if(!sizeof(filter(this_player()->query_holding() - ({ 0 }),
                    (: $1->id("paint brush") :)))) {
    this_player()->add_failed_mess(this_object(), "You must be holding a "
                                   "paint brush to paint the walls.\n", ({ }));
    return 0;
  }

  if(!environment(this_player())->test_occupier(this_player()->query_name())) {
    this_player()->add_failed_mess(this_object(),
                                   "You don't own this house.\n", ({ }));
    return 0;
  }
  
  if(target) {
      if(!target->query_short()) return 0;

          if(!function_exists("decorate_part", target)) {
                  this_player()->add_failed_mess(this_object(), "You can't $V the " +
                                indirect + " on the " + target->query_short() + "!\n", ({ }));
                  return 0;
          }
          
          if(!target->decorate_part( indirect, obs[0]->query_short() )) {
                  this_player()->add_failed_mess(this_object(), "You can't $V the " +
                                                                        indirect + ".\n", ({ }));
                  return 0;
          }
          this_player()->add_succeeded_mess(this_object(), "$N $V the " +
                                    indirect + " on the " + target->query_short() + 
                                                                        " with the brush using light, smooth strokes.\n", ({ }));
          return 1;
  }

  if(!function_exists("decorate_surface", environment(this_player()))) {
    this_player()->add_failed_mess(this_object(), "You can't $V the walls "
                                   "here.\n", ({ }));
    return 0;
  }
  
  if(!environment(this_player())->
     decorate_surface(indirect, "covered with " + obs[0]->query_short())) {
    this_player()->add_failed_mess(this_object(), "You can't $V the " +
                                   indirect + ".\n", ({ }));
    return 0;
  }
  
  remove_volume(query_volume());

  this_player()->add_succeeded_mess(this_object(), "$N $V the " +
                                    indirect + " with $D using "
                                    "broad, smooth strokes.\n", ({ }));
  return 1;
}

/** @ignore yes */ 
mapping int_query_static_auto_load() {
  mapping tmp;

  tmp = ::int_query_static_auto_load();
  return ([ "::" : tmp,
          "colour" : _colour,
          ]);
} /* int_query_static_auto_load() */

/** @ignore yes */ 
mapping query_static_auto_load() {
  if ( base_name(this_object()) + ".c" == __FILE__ )
    return int_query_static_auto_load();
  return ([ ]);
} /* query_static_auto_load() */

/** @ignore yes */ 
void init_static_arg(mapping args) {
  if (args["::"])
    ::init_static_arg(args["::"]);
  if (!undefinedp(args["colour"]))
    _colour = args["colour"];
  if(_colour)
    setup_attribs();
} /* init_static_arg() */
// --- END [/mnt/home2/grok/lib/obj/misc/tin_of_paint.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/torch.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/torch.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627990   Available: 13575344
Inodes: Total: 5242880    Free: 4960134
9528 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/torch.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627990   Available: 13575344
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming

#include <fuel_handler.h>
#include <move_failures.h>
inherit "/std/object";
inherit "/std/basic/holdable";

#define BRIGHTNESS 30
#define MAX_FUEL 2000
#define FUEL_PER_TICK ( FUEL_TIME * 2 )

private int amount_of_fuel;
private int is_lit;

int finish_it();

void setup_shorts();

void create() {
   object::create();
   holdable::create();
} /* create() */
 
void setup() {
   amount_of_fuel = MAX_FUEL; 
   set_name( "torch" ); 
   add_plural( "torches" );
   setup_shorts();
   add_help_file("torch");
   set_long( function() {
      string str;
      
      if ( is_lit && amount_of_fuel) {
         call_out( (: setup_shorts() :), 2 );
         str = "This is a fire burning out of control on the end "
            "of a stick of wood.  There is a lot of smoke coming "
            "off the fire, of the kind that, no matter which "
            "way you turn, will go up your nose.";
         switch ( amount_of_fuel / ( MAX_FUEL / 10 ) ) {
          case 10 :
          case 9  :
            return str+"  The torch looks brand new, it will burn for "
               "ages yet.\n";
          case 8 :
          case 7 :
          case 6 :
            return str+"  Not yet burning for very long, this torch is "
               "pretty happy with itself.  It doesn't seem "
               "to care about its short life span.\n";
          case 5 :
          case 4 :
            return str+"  The torch is happily burning.  It is in the "
               "prime of its life.\n";
          case 3 :
            return str+"  The torch has a little way to go yet, as it is "
               "now burning the light wood.\n";
          case 2 :
            return str+"  It looks like this torch won't "
               "last much longer.  Buying a new one would "
               "probably be a good investment.\n";
          case 1 :
          case 0 :
            return str+"  The torch is spluttering, there are huge "
               "amounts of smoke coming off it.  It looks like "
               "it is about to go out.\n";
         }
      }
      if ( amount_of_fuel >= MAX_FUEL ) 
         return "This lump of what looks like some sort of tree has a few "
         "dirty rags wrapped around the end of it, and it looks as "
         "though it might be possible to light them.  The dirty rags "
         "have some sort of stuff covering them, probably "
         "to make them burn better.\n";
      if ( amount_of_fuel > MAX_FUEL / 2 )
         return "Someone has cut down a tree, chopped it up into smaller "
         "chunks and then wrapped the end in some rags.  "
         "The rags are blackened and it looks like someone set "
         "fire to them.  Perhaps you can too?\n";
      str = "This lump of what looks like some sort of tree has a few "
         "dirty rags wrapped around the end.  ";
      if ( !amount_of_fuel )
         return str +"The end is completely blackened.  You would "
         "have to be extremely clever to get this torch "
         "going again.\n";
      switch (amount_of_fuel/(MAX_FUEL/10)) {
       case 5 :
       case 4 :
         return str +"The end has been blackened quite a bit, "
            "but it looks like there is a fair bit of "
            "go still left in it.\n";
       case 3 :
       case 2 :
         return str +"A few rags here and there cling to a meager "
            "existence.  You could set fire to them and "
            "make their life hell for a little while, but "
            "not for very long.\n";
       case 1 :
       case 0 :
         return str +"You can just see the remains of some rags "
            "attached to the blackened and burnt end of "
            "the torch.  It will last only for a short while "
            "longer.\n";
      }
      return "Whoops.  Tell a creator if you see this.\n";
   }
            );
   is_lit = 0;
   set_weight( 6 );
   set_value( 50 );
} /* setup() */

void set_fuel(int f) { 
   amount_of_fuel = f;
   if(amount_of_fuel < 0)
     amount_of_fuel = 0;
   setup_shorts();
} /* set_fuel() */

void init() {
  this_player()->add_command( "light", this_object() );
  this_player()->add_command( "extinguish", this_object() );
  this_player()->add_command( "dowse", this_object() );
} /* init() */

void setup_shorts() {
   if ( is_lit && amount_of_fuel) {
      set_short( "lit torch" );
      set_main_plural( "lit torches" );
      remove_adjective( ({ "lightable", "burnt", "out" }) );
      add_adjective( "lit" );
   } else if ( amount_of_fuel > 0 ) {
      set_short( "lightable torch" );
      set_main_plural( "lightable torches" );
      remove_adjective( ({ "lit", "burnt", "out" }) );
      add_adjective( "lightable" );
   } else {
      set_short( "burnt torch" );
      set_main_plural( "burnt torches" );
      remove_adjective( ({ "lit", "lightable" }) );
      add_adjective( ({ "burnt", "out" }) );
   }
} /* setup_shorts() */

int do_light() {
   if (environment(this_object()) != this_player()) {
      this_player()->add_failed_mess( this_object(),
                                     "You are not carrying $D.\n", ({ }) );
      return 0;
   }
   
   if (amount_of_fuel <= 0) {
      this_player()->add_failed_mess( this_object(), "$D is burnt out.\n",
                                     ({ }) );
      return 0;
   }
   if (is_lit) {
      this_player()->add_failed_mess( this_object(), "$D is already lit.\n",
                                     ({ }) );
      return 0;
   }
   if (!query_holder() && 
       !sizeof( this_object()->hold_item( this_player(), -1 ) ) ) {
     this_player()->add_failed_mess( this_object(), "Unable to hold $D, "
         "your arms are probably full.\n", ({ }) );
      return 0;
   }
   is_lit = 1;
   FUEL_HANDLER->add_burner( this_object() );
   set_light( BRIGHTNESS );
   call_out( "setup_shorts", 2);
   return 1;
} /* do_light() */

void out_of_fuel() {
   is_lit = amount_of_fuel = 0;
   set_light( 0 );
   set_value( 0 );
   FUEL_HANDLER->remove_burner( this_object() );
   tell_room( environment(), one_short() +" splutters violently "
     "for the last time before it crumbles to dust.\n" );
   call_out( "finish_it", 2 );

} /* out_of_fuel() */

void do_warning() {
   tell_room( environment(), poss_short() +" starts to sputter and smoke a "
             "lot as it is now burning the light wood.  It is on its last "
             "legs.\n");
   return;
} /* do_warning() */

void consume_fuel() {
   amount_of_fuel -= FUEL_PER_TICK;
   if(amount_of_fuel < 0)
     amount_of_fuel = 0;
   
   switch ( amount_of_fuel ) {
    case (200-FUEL_PER_TICK) .. 200:
      do_warning();
      break;
    case 0:
      out_of_fuel();
      break;
    default:
      /* do nothing */
   }
} /* consume_fuel() */

int do_extinguish(object *, string, string, string) {
   if ( !is_lit && objectp( this_player() ) ) {
      this_player()->add_failed_mess(this_object(), "$D is not lit.\n", ({ }) );
      return 0;
   } else if ( !is_lit ) {
      return 0;
   }
   FUEL_HANDLER->remove_burner( this_object() );
   is_lit = 0;
   set_light( 0 );
   call_out( "setup_shorts", 2);
   return 1;
} /* do_extinguish() */

int do_dowse() {
   return do_extinguish(({ }), 0, 0, 0);
} /* do_dowse() */

void dest_me() {
   FUEL_HANDLER->remove_burner( this_object() );
   set_light( 0 );
   holdable::dest_me();
   object::dest_me();
} /* dest_me() */

mixed *stats() {
  return ::stats() + ({
    ({ "fuel" , amount_of_fuel, }),
    ({ "is lit", is_lit, }),
   });
} /* stats() */

mixed query_dynamic_auto_load() {
  return ([ "::" : object::query_dynamic_auto_load(),
            "amount of fuel" : amount_of_fuel,
            "hold" : holdable::query_dynamic_auto_load(),
            "is lit" : is_lit,
          ]);
} /* query_dynamic_auto_load() */

int held_this_item(int type, object holder, mixed arg) {
   if (!type) {
      if (holder && is_lit) {
         tell_object( holder,
                     "You extinguish the "+ short() +" as you put it down.\n");
         tell_room( environment(holder ),
                   holder->short() +" extinguishes the "+
                   short() +" as "+ holder->query_pronoun()
                   +" puts it down.\n", ({ holder }));
      }
      do_extinguish( ({ }), "", "", "");
   } else if (type == 2) {
      if (arg && holder && amount_of_fuel > 0) {
         set_light( BRIGHTNESS );
         FUEL_HANDLER->add_burner( this_object() );
         is_lit = 1;
      } else {
         is_lit = 0;
      }
      setup_shorts();
   }
   return 1;
} /* held_this_item() */

void init_dynamic_arg( mapping arg ) {
   amount_of_fuel = arg["amount of fuel"];
   is_lit = arg["is lit"];
   if (arg["hold"]) {
      holdable::init_dynamic_arg(arg["hold"], arg["is lit"]);
   }
   ::init_dynamic_arg(arg["::"]);
} /* init_dynamic_arg() */

void init_static_arg(mapping arg) {
} /* init_static_arg() */

mapping query_static_auto_load() {
   return 0;
} /* query_static_auto_load() */

varargs int move( mixed ob, string mess1, string mess2 ) {
   int ret;

   ret = holdable::move(ob);
   if (ret != MOVE_OK) {
      return ret;
   }
   return object::move( ob, mess1, mess2 );
} /* move() */

void self_light() {
   is_lit = 1;
   FUEL_HANDLER->add_burner( this_object() );
   set_light( BRIGHTNESS );
   call_out( (: setup_shorts() :), 2);
   return;
}/*self_light*/

  int finish_it () {

    this_object()->move( "/room/rubbish" );
    
    return 1;

} /* finish_it*/

int query_torch() {
  return 1;
}

int query_lit() {
  return is_lit;
}

int query_fuel() {
  return amount_of_fuel;
}
// --- END [/mnt/home2/grok/lib/obj/misc/torch.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/teddy.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/teddy.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627988   Available: 13575342
Inodes: Total: 5242880    Free: 4960134
995 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/teddy.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627988   Available: 13575342
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  Created by Dragonlord  -  5 October 1996  */

#define TP this_player()
#define TPCAP this_player()->one_short()
#define TO this_object()

inherit "std/object";

void setup(){
   set_name("bear");
   set_short("teddy bear");
   add_alias("teddy");
   add_adjective("teddy");
   set_long("This is a cute and cuddly teddy bear.  Just the sort to give "
     +"someone you love to remind them of you.  It looks very soft and "
     +"huggable.\n");
   set_weight(10);
   set_value(25);
   set_main_plural("teddy bears");
   add_plural(({"bears", "teddys"}));
}  /* setup() */

void init() {
   TP->add_command("hug", TO);
   TP->add_command("cuddle", TO);
}

int do_hug() {
   write("You hug the teddy bear close to you and feel all warm and fuzzy "
     "inside.\n");
   say(TP->one_short()+ " hugs the teddy bear close and smiles happily.\n");
   TP->add_succeeded_mess(TO, "", ({ }) );
   return 1;
}

int do_cuddle() {
  do_hug();
   TP->add_succeeded_mess(TO, "", ({ }) );
   return 1;
}


// --- END [/mnt/home2/grok/lib/obj/misc/teddy.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/abscond_trigger.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/abscond_trigger.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627987   Available: 13575341
Inodes: Total: 5242880    Free: 4960134
759 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/abscond_trigger.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627987   Available: 13575341
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: abscond_trigger.c,v 1.1 2001/04/21 11:26:33 shrike Exp $
 *
 *
 */

/* This object serves one purpose: to make sure that this_player() is
 * correct in the abscond command.  See the code in
 * /std/effects/other/abscond for a more complete explanation.
 */

#define CLASS "fighting.combat.special.abscond"

#include <effect.h>

inherit "/std/object";

void init() {
   if( !environment()
    || file_name( environment( this_object() ) ) == "/room/rubbish" ) {
      return;
   }

   if( this_player()
    && this_player() == query_property( "abscond player" ) ) {
      this_player()->submit_ee2( this_player()->effects_matching(CLASS)[0],
                                 "after_command", 0, EE_REMOVE );
   }
}
// --- END [/mnt/home2/grok/lib/obj/misc/abscond_trigger.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/top_families.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/top_families.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627987   Available: 13575341
Inodes: Total: 5242880    Free: 4960134
2666 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/top_families.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627987   Available: 13575341
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This keeps track of the top families in various areas.
 * @author Pinkfish
 * @started May 16th
 */
#include <top_ten_tables.h>
#include <clubs.h>
inherit "/std/object";

private string _lang = "morporkian";

string _long();

void setup() {
   set_name( "table" );
   set_short( "top family table" );
   set_long("This is a table listing those families that are most "
            "advanced in certain aspects.\n");
   add_adjective( ({ "top", "family", "score" }) );
   reset_get();
   add_property( "there", "in one corner" );
   add_property( "survive fire", 1 );
   /* A call_out for the read mess, to give you time to set the
    * language.  Done this way to be consistent with
    * /obj/misc/top_ten_tables.c  
    */
   call_out("setup_read_mess", 5);
} /* setup() */

void setup_read_mess() {
   add_read_mess((: _long() :), 0, _lang, 0);
} /* setup_read_mess() */

void set_language(string lang) {
  _lang = lang;
} /* set_language() */

string query_language() { return _lang; }

string club_name(string str) {
   if (!str) {
      return "Unknown";
   }
   return CLUB_HANDLER->query_club_name(str);
} /* club_name() */

string _long() {
   mixed *stuff;
   string bing, str;
   string guild;
   mapping g_info;
   string *g_sorted;

   stuff = TOP_TEN_HANDLER->query_family_info();

   str = "The family with:\n"
         "The most members          : " +
         club_name(stuff[TOP_TEN_LARGEST_FAMILY])  + "\n"
         "The oldest average age    : " +
         club_name(stuff[TOP_TEN_OLDEST_FAMILY]) + "\n"
         "Most average quest points : " +
         club_name(stuff[TOP_TEN_MOST_QUEST_POINTS]) + "\n"
         "Most player killers       : " +
         club_name(stuff[TOP_TEN_MOST_PKS]) + "\n"
         "Largest single gender     : " +
         club_name(stuff[TOP_TEN_SINGLE_GENDER]) + "\n"
         "Oldest start DW time      : " +
         club_name(stuff[TOP_TEN_OLDEST_LOGONS]) + "\n"
         "Most average relationships: " +
         club_name(stuff[TOP_TEN_MOST_RELATIONSHIPS]) + "\n";
   g_info = stuff[TOP_TEN_MOST_GUILD];
   g_sorted = sort_array(filter(keys(g_info), (: stringp($1) &&
                                                 file_size($1 + ".c") > 0 :)),
                         (: strcmp($1->query_name(), $2->query_name()) :));

   foreach (guild in g_sorted) {
      if (stringp(guild)) {
         bing = g_info[guild];
         str += sprintf("%-26s: %s\n",
               "Most " + (guild->query_name()),
               club_name(bing));
      }
   }

   str += "\nTo get onto the average list the family must have more than "
          "3 members that are not creators.\n";
   return str;
} /* _long() */
// --- END [/mnt/home2/grok/lib/obj/misc/top_families.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/tray.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/tray.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627986   Available: 13575340
Inodes: Total: 5242880    Free: 4960134
2555 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/tray.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627986   Available: 13575340
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * A small tray, to give to vendors!
 * This tray weighs 250 grams and can hold up to 2 kilos worth of items!
 * Lets hear it for.. small wooden tray!
 * @author Terano.
 */

#include <move_failures.h>

inherit "/std/surface";
inherit "/std/basic/holdable";
inherit "/std/basic/wearable";

void create() {
  wearable::create();
  holdable::create();
  surface::create();
}

void setup() {	
  set_name( "tray" );
  set_short( "wooden tray" );
  set_long( "This is a small wooden tray, similar in style to the ones used by "
    "many vendors and travelling salespeople. Only a small quantity of items will "
    "fit on top of it.\n" );

  add_adjective(({ "small", "wooden" }));
  set_material("wood");

  //Surface stuff.
  set_weight(5);
  set_max_weight(40);

  //Hold stuff.
  set_no_limbs(2);
  
  //Wear stuff.
  set_type("sash");
  set_cond(1000);
  set_max_cond(1000);
  add_wear_effect( "/std/effects/attached/single_shoulder" );
}

string long( string word, int dark ) {
  return surface::long() + wearable::long();
}

varargs int move( mixed dir, string messin, string messout ) {
  if ( holdable::move( dir, messin, messout ) == MOVE_OK ) {
	  return surface::move( dir, messin, messout );
  }
  return MOVE_NO_UNHOLD;
}

mapping query_static_auto_load() {
mapping map = ([ ]);
  
  map["holdable"] = holdable::query_static_auto_load();
  map["surface"] = surface::query_static_auto_load();
  map["wearable"] = wearable::query_static_auto_load();
  return map;
}

void init_static_arg( mapping map ) {
  if (!undefinedp( map["holdable"] ) )
	holdable::init_static_arg( map["holdable"] );

  if ( !undefinedp( map["surface"] ) && map["surface"] )
	surface::init_static_arg( map["surface"] );

  if ( !undefinedp( map["wearable"] ) && map["wearable"] )
	surface::init_static_arg( map["wearable"] );

}

void dest_me() {
  holdable::dest_me();
  surface::dest_me();
}

mapping query_dynamic_auto_load() {
mapping map = ([ ]);
  
  map["holdable"] = holdable::query_dynamic_auto_load();
  map["surface"] = surface::query_dynamic_auto_load();
  map["wearable"] = wearable::query_dynamic_auto_load();
  return map;
}

varargs void init_dynamic_arg( mapping map, mixed new_arg ) {
  if (!undefinedp( map["holdable"] ) )
	holdable::init_dynamic_arg( map["holdable"] );

  if ( !undefinedp( map["surface"] ) && map["surface"] )
	surface::init_dynamic_arg( map["surface"] );

  if ( !undefinedp( map["wearable"] ) && map["wearable"] )
	surface::init_dynamic_arg( map["wearable"] );
}

mixed stats() { 
	return surface::stats() + wearable::stats();
}// --- END [/mnt/home2/grok/lib/obj/misc/tray.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/balance.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/balance.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627985   Available: 13575339
Inodes: Total: 5242880    Free: 4960134
15324 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/balance.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627985   Available: 13575339
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*
** The way this used to be, if the player trying to work the quest 
** suddenly buggered off in the middle of it, the quest related 
** weights would still be there, but if another player came along and 
** moved one of the weights, the quest related one would vanish. This 
** has puzzled players, and cased at least one bug report.  I've changed 
** it so that the quest related weight hangs around until a player resets 
** the weights or actually starts the quest using the figure command. 
**
** Also removed some code that has been commented out for two years, and 
** some other bits that were redundant because of this piece of unused 
** code. And did some general Spring Cleaning. It seems to be working fine, 
** but feel free to revert it if it breaks horribly.  --Tilly  
*/ 


#include <library.h>

#define DEFAULT_PANS ([ \
  "left" : ([ ]), \
  "middle" : ([ \
  "very small" : ({ "1/9", 1 }), \
  "small" : ({ "1/3", 3 }), \
  "medium" : ({ "1", 9 }), \
  "large" : ({ "3", 27 }), \
  "very large" : ({ "9", 81 }) ]), \
  "right" : ([ ]) ])

inherit "/std/object";

private nosave int balance;
private nosave string *doing;
private nosave mapping pans;


/* Start of function prototypes */
void setup();
void init();
string *query_doing();
mapping query_pans();
string long( string words, int dark );
string pans_look();
void recalculate_balance();
int reset_weights();
string weight_string( int weight );
int weigh_something( object* obs );
int figure_it_out();
int move_a_specific_weight( string weight_size, string pan_to );
int move_a_weight( string weight_size, string pan_from, string pan_to );
void it_is_balanced( object person );
/* End of function prototypes */


void setup() {
  set_name( "balance" );
  set_short( "weighing balance" );
  add_adjective( "weighing" );
  add_alias( ({ "pan", "pans", "weight", "weights" }) );
  set_weight( 200 );
  reset_get();
  doing = ({ });
  pans = DEFAULT_PANS;
} /* setup() */


void init() {
  add_command("weigh", "<indirect:object:me'thing(s)'> on <direct:object>",
    (:this_object()->weigh_something($1):));
  add_command("reset", "weights on balance", (: reset_weights() :));
  add_command("figure", "", (:this_object()->figure_it_out():));
  add_command("move",
          "<string'size'> weight to <string'position'> pan",
          (:this_object()->move_a_specific_weight($4[0], $4[1]):));
} /* init() */


string *query_doing() { return doing; }

mapping query_pans() { return pans; }


string long( string words, int dark ) {
  int i, j;
  string long;
  string *bits;
  string *places;
  string *weights;

  if (!words) {
    words = "balance";
  }
  bits = explode( words, " " );
  switch ( bits[ sizeof( bits ) - 1 ] ) {
    case "balance" :
      return "This is a largish bronze balance, securely bolted in "
        "place.  The main part of the balance is a long arm which "
        "pivots at its centre.  There is a pan hanging from each "
        "end of the arm such that it will be level when the weights "
        "in the pans are equal.  A third pan is fixed to a stationary "
        "part of the balance where the weights can be held when not "
        "in use.\n" + pans_look() + "You could probably use the balance "
        "to weigh something.\nThere appears to be something "
        "written on it.\n";
    case "pan" :
    case "pans" :
      return "There are three pans.  One pan hangs from the left end of "
        "the arm, one from the right end and there is a third pan "
        "in the middle.\n"+ pans_look();
    case "weight" :
    case "weights" :
      long = "There are weights of many different sizes in the pans.  "
        "They are:\n";
      bits = ({ });
      places = m_indices( pans );
      for ( i = 0; i < sizeof( places ); i++ ) {
        if ( !m_sizeof( pans[ places[ i ] ] ) ) {
          continue;
        }
        weights = m_indices( pans[ places[ i ] ] );
        for ( j = 0; j < sizeof( weights ); j++ ) {
          if ( sizeof( doing ) ) {
            if ( doing[ 1 ] == weights[ j ] ) {
              continue;
            }
          }
          bits += ({ add_a( weights[ j ] ) + " weight marked with \""
            + pans[ places[ i ] ][ weights[ j ] ][ 0 ] +" lb\"" });
        }
      }
      long += "    " + implode( bits[ 0 .. sizeof( bits ) - 2 ],
        ",\n    " ) +",\n  and "+ bits[ sizeof( bits ) - 1 ] + ".\n";
      long += "The weights can be moved from one pan to another and "
        "reset back to their starting positions.\n";
      return long;
  }
  return "You're not quite sure what you're looking at.\n";
} /* long() */


string pans_look() {
  int i;
  int j;
  string pans_status;
  string *places;
  string *weights;

  pans_status = "";
  places = m_indices( pans );
  for ( i = 0; i < sizeof( places ); i++ ) {
    pans_status += "The "+ places[ i ] +" pan ";
    if ( !m_sizeof( pans[ places[ i ] ] ) )
      pans_status += "is empty.\n";
    else {
      weights = m_indices( pans[ places[ i ] ] );
      for ( j = 0; j < sizeof( weights ); j++ )
        weights[ j ] = add_a( weights[ j ] ) +" weight";
      pans_status += "holds "+ query_multiple_short( weights ) +".\n";
    }
  }
  switch ( balance ) {
    case -1 :
      pans_status += "The left pan hangs lower than the right pan.\n";
      break;
    case 0 :
      pans_status += "The left pan hangs level with the right pan.\n";
      break;
    case 1 :
      pans_status += "The left pan hangs higher than the right pan.\n";
      break;
  }
  return pans_status;
} /* pans_look() */


void recalculate_balance() {
  int i;
  int j;
  int old_balance;
  string *places;
  string *weights;
  mapping pan_weights;

  pan_weights = ([ ]);
  places = m_indices( pans );
  for ( i = 0; i < sizeof( places ); i++ ) {
    pan_weights[ places[ i ] ] = 0;
    if ( !m_sizeof( pans[ places[ i ] ] ) ) {
      continue;
    }
    weights = m_indices( pans[ places[ i ] ] );
    for ( j = 0; j < sizeof( weights ); j++ ) {
      pan_weights[ places[ i ] ] +=
        pans[ places[ i ] ][ weights[ j ] ][ 1 ];
    }
  }
  old_balance = balance;
  if ( pan_weights[ "left" ] > pan_weights[ "right" ] ) {
    balance = -1;
  } else {
    if ( pan_weights[ "left" ] == pan_weights[ "right" ] ) {
      balance = 0;
    } else {
      balance = 1;
    }
  }
  if ( old_balance == balance ) {
    switch ( balance ) {
      case -1 :
        tell_room( environment(), "The arm rocks a bit but steadies, "
          "with the left pan still hanging lowest.\n" );
        break;
      case 1 :
        tell_room( environment(), "The arm rocks a bit but steadies, "
          "with the right pan still hanging lowest.\n" );
        break;
    }
    return;
  }
  switch ( balance ) {
    case -1 :
      tell_room( environment(), "The arm of the balance tips and the "
        "left pan ends up hanging lowest.\n" );
      break;
    case 0 :
      tell_room( environment(), "The arm of the balance levels out, "
        "with the left and right pans hanging level.\n" );
      break;
    case 1 :
      tell_room( environment(), "The arm of the balance tips and the "
        "right pan ends up hanging lowest.\n" );
      break;
  }
} /* recalculate_balance() */


int reset_weights() {
  pans = DEFAULT_PANS;
  if (sizeof(doing)) {
    pans[ "left" ][ doing[ 1 ] ] = ({ "?", 1 + random( 121 ) });
  }
  add_succeeded_mess("$N $V the weights on $D.\n");
  recalculate_balance();
  return 1;
} /* reset_weights() */


string weight_string( int weight ) {
  int wholes;
  int ninths;

  wholes = weight / 9;
  ninths = weight % 9;
  if ( wholes && ninths ) {
    return wholes + " " + ninths + "/9 lb";
  }
  if ( wholes ) {
    return wholes + " lb";
  }
  return ninths + "/9 lb";
} /* weight_string() */


int weigh_something( object* obs ) {
  int i;
  int info;
  int weight;
  object person;

  if ( sizeof( doing ) ) {
    person = find_player( doing[ 0 ] );
    if ( person == this_player() ) {
      add_failed_mess( "Hold your horses, you're trying to get the hang "
        "of it still.\n" );
      return 0;
    }
    if ( person && ( environment( person ) == environment() ) ) {
      add_failed_mess( (string)person->one_short() + " is using "
        "the balance at the moment.  Come back when "
        + (string)person->query_pronoun() + " has finished.\n" );
      return 0;
    }
    doing = ({ });
    pans = DEFAULT_PANS;
  }
  info = (int)LIBRARY->query_player_quest_info(
    (string)this_player()->query_name(), "balance" );
  switch ( info ) {
    case 0 :
      add_failed_mess( "You don't know how the balance works to weigh "
        "anything.\nTry looking at the balance, the pans and "
        "the weights, and then maybe you can figure it out.\n" );
      return 0;
    case 1 :
      add_failed_mess( "You're still not too sure how the balance works "
        "to weigh anything.\nTry looking at the balance, the pans and "
        "the weights, and then maybe you can figure it out.\n" );
      return 0;
    case 2 :
      add_failed_mess( "You're very nearly sure how the balance works, "
        "but maybe you should try to figure it out once more before "
        "you weigh anything.\n" );
      return 0;
  }
  for ( i = 0; i < sizeof( obs ); i++ ) {
    weight = obs[ i ]->query_complete_weight();
    if ( !weight ) {
      write( obs[ i ]->the_short() + " doesn't weigh anything.\n" );
      continue;
    }
    if ( weight > 121 ) {
      write( obs[ i ]->the_short() +
        " is heavier than all the weights available put together.\n" );
      continue;
    }
    write( obs[ i ]->the_short() +
      " weighs "+ weight_string( weight ) +".\n" );
  }
  add_succeeded_mess(({ "", "$N $V $I on $D.\n" }), obs);
  return 1;
} /* weigh_something() */


int figure_it_out() {
  int info;
  object person;

  if ( sizeof( doing ) ) {
    person = find_player( doing[ 0 ] );
    if ( person == this_player() ) {
      notify_fail( "You're already engaged in figuring out how the "
        "balance can be used to weigh something.\n" );
      return 0;
    }
    if ( person && ( environment( person ) == environment() ) ) {
      notify_fail( (string)person->one_short() + " is using "
        "the balance at the moment.  Come back when "
        + (string)person->query_pronoun() + " has finished.\n" );
      return 0;
    }
    doing = ({ });
    pans = DEFAULT_PANS;
  }
  info = (int)LIBRARY->query_player_quest_info(
    (string)this_player()->query_name(), "balance" );
  if ( info > 2 ) {
    write( "You already know how the balance works.\n" );
    return 1;
  }
  doing = ({ (string)this_player()->query_name(), ({ "red", "green",
    "blue" })[ info ] });
  write( "You see " + add_a( doing[ 1 ] ) + " weight in the middle pan "
    "that you hadn't noticed before.  Maybe you could use this to "
    "experiment, so you place it in the left pan.\n" );
  say( (string)this_player()->one_short() + " moves "
    + add_a( doing[ 1 ] ) + " weight from the middle pan to the "
    "left pan.\n" );
  pans[ "left" ][ doing[ 1 ] ] = ({ "?", 1 + random( 121 ) });
  recalculate_balance();
  return 1;
} /* figure_it_out() */


int move_a_specific_weight( string weight_size, string pan_to ) {
  object person;
  string pan_from;

  if ( sizeof( doing ) ) {
    person = find_player( doing[ 0 ] );
    if ( !person ) {
      doing = ({ });
    } else {
      if ( person != this_player() ) {
        if ( environment( person ) == environment() ) {
          add_failed_mess( (string)person->one_short() + " is "
            "using the balance at the moment.  Come back when "
            + (string)person->query_pronoun() + " has finished.\n" );
          return 0;
        } else {
          doing = ({ });
          pans = DEFAULT_PANS;
        }
      }
    }
  }

  if ( !pans[ pan_to ] ) {
    add_failed_mess( "There is a left pan, a middle pan and a right pan, "
      "but no " + pan_to + " pan.\n" );
    return 0;
  }
  foreach (pan_from in keys(pans)) {
    if ( pans[ pan_from ][ weight_size ] ) {
      return move_a_weight(weight_size, pan_from, pan_to);
    }
  }
  add_failed_mess("Unable to find the " + weight_size + " weight.\n");
  return 0;
} /* move_a_specific_weight() */


int move_a_weight( string weight_size, string pan_from, string pan_to ) {

  if ( pan_from == pan_to ) {
    add_failed_mess( "The " + weight_size + " weight is already in the "
      + pan_to + " pan.\n" );
    return 0;
  }
  if ( sizeof( doing ) ) {
    if ( weight_size == doing[ 1 ] ) {
      notify_fail( "You don't feel like moving the " + doing[ 1 ]
        + " weight since that's what you're trying to weigh.\n" );
      return 0;
    }
  }
  pans[ pan_to ][ weight_size ] = pans[ pan_from ][ weight_size ];
  pans[ pan_from ] = m_delete( pans[ pan_from ], weight_size );
  write( "You move the "+ weight_size +" weight from the "+ pan_from
    + " pan to the "+ pan_to + " pan.\n" );
  say( (string)this_player()->one_short() + " moves "
    + add_a( weight_size ) +" weight from the "+ pan_from + " pan "
    "of the balance to the " + pan_to + " pan.\n" );
  recalculate_balance();
  if ( sizeof( doing ) && !balance ) {
    call_out( "it_is_balanced", 0, this_player() );
  }
  return 1;
} /* move_a_weight() */


void it_is_balanced( object person ) {
  int info;

  tell_object( person, "You feel a small surge of self-esteem to have found "
    "that the "+ doing[ 1 ] +" weight weighs "
    + weight_string( pans[ "left" ][ doing[ 1 ] ][ 1 ] ) +".\n" );
  info = (int)LIBRARY->query_player_quest_info( (string)person->query_name(),
    "balance" );
  info++;
  switch ( info ) {
    case 1 :
      tell_object( person, "You've made a good start at working out "
        "how the balance operates.  You think you should practice "
        "with it a couple of times more to get the hang of it, "
        "though.\n" );
      person->adjust_xp( 5000 );
      break;
    case 2 :
      tell_object( person, "You're definitely getting to understand how "
        "the balance operates.  You think you should practice with "
        "it once more to get used to it completely, though.\n" );
      person->adjust_xp( 10000 );
      break;
    case 3 :
      tell_object( person, "You're now adept at using the balance and "
        "can use it to weigh anything.\n" );
/* Quest!
 * Name: balance quest
 * Title: Expert Balancer
 * Story: discovered how to weigh things using powers of three
 * Level: 3
 */
      if ( interactive( person ) ) {
        if ( !LIBRARY->query_quest_done( (string)person->query_name(),
          "balance quest" ) ) {
          LIBRARY->set_quest( (string)person->query_name(),
            "balance quest" );
        }
      }
      break;
    case 4:
      info--;
      break; //if people want to keep moving the weights, let them.
    default :
      tell_object( person, "Something has gone wrong with the balance.  "
        "Please contact Wodan about it.\n" );
  }
  LIBRARY->set_player_quest_info( (string)person->query_name(), "balance",
    info );
  tell_object( person, "You put all the weights back into the middle "
    "pan.\n" );
  tell_room( environment(), (string)person->the_short() +
     " seems satisfied with "+ (string)person->query_objective() +"self, "
    "and returns all of the weights to the middle pan.\n", person );
  doing = ({ });
  pans = DEFAULT_PANS;
} /* it_is_balanced() */
// --- END [/mnt/home2/grok/lib/obj/misc/balance.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/delete_thyself.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/delete_thyself.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627981   Available: 13575335
Inodes: Total: 5242880    Free: 4960134
418 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/delete_thyself.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627981   Available: 13575335
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * Make an object the will automaticly delete itself.  Useful for getting rid
 * of things out of vaults and so on.
 * @author Pinkfish
 */
inherit "/std/object";

void create() {
   ::create();
   if (clonep(this_object())) {
      call_out((: move("/room/rubbish") :), 3);
   }
} /* create() */

void init_dynamic_arg(mapping map) {
} /* init_dynamic_arg() */

void init_static_arg() {
} /* init_static_arg() */
// --- END [/mnt/home2/grok/lib/obj/misc/delete_thyself.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/label.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/label.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627981   Available: 13575335
Inodes: Total: 5242880    Free: 4960134
1652 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/label.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627981   Available: 13575335
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/object";

void create() {
   do_setup++;
   ::create();
   do_setup--;
   set_name( "label" );
   set_short( "small label" );
   add_adjective( "small" );
   set_main_plural( "small labels" );
   set_long( "This is a small label made from paper with some sort of "+
         "dried glue smeared on one side.  You could probably \"stick\" "+
         "it onto something.\n" );
   set_value( 100 );
   add_property( "writeable", 1 );
   add_property( "label", 1 );
   set_max_size( 200 );
   if ( !do_setup )
      this_object()->setup();
} /* create() */

void init() {
   this_player()->add_command( "stick", this_object(),
         "<direct:object:me> to <indirect:object>" );
} /* init() */

int do_stick( mixed *things ) {
   if ( sizeof( things ) > 1 ) {
      add_failed_mess("You can't stick $D to more than one thing at a time.\n");
      return 0;
   }
   if ( things[ 0 ] == this_object() ) {
      add_failed_mess("You cannott stick $D to itself!\n");
      return 0;
   }
   things[ 0 ]->add_effect( "/std/effects/object/label", this_object() );
/* 
   write( "You lick "+ the_short() +" and stick it to "+
         (string)things[ 0 ]->the_short() +".\n" );
   say( (string)this_player()->one_short() +" licks "+ a_short() +
         " and sticks it to "+ (string)things[ 0 ]->the_short() +".\n" );
*/
   add_succeeded_mess("$N lick$s $D and stick$s it to $I.\n", things[0..0]);
   return 1;
} /* do_stick() */

mapping query_static_auto_load() {
   if ( explode( file_name( this_object() ), "#" )[ 0 ] != "/obj/misc/label" ) {
      return ([ ]);
   }
   return int_query_static_auto_load();
} /* query_static_auto_load() */
// --- END [/mnt/home2/grok/lib/obj/misc/label.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/deplusser.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/deplusser.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627980   Available: 13575334
Inodes: Total: 5242880    Free: 4960134
2304 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/deplusser.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627980   Available: 13575334
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/object.c";

void setup()  {
   set_short("deplusser");
   set_name("deplusser");
   set_long("It's shaped like a plus sign set in a circle, with a diagonal "
             "slash across it.  Type 'deplus <path>' to use.");
   set_weight(9);
}

void init()  {
   add_command("deplus", "<string'file'>", (:this_object()->deplus($4[0]):));
}

int deplus( string fname )  {
   string *files, *lines, last_line, this_line, next_line, old;
   int i, j, sz;

   seteuid(geteuid(this_player()));
   files = get_dir( this_player()->get_path( fname ) );
   if ( !sizeof(files) )
      return notify_fail( "No files found\n" );
   for (i = 0; i < sizeof(files); i++ )  {
      if ( file_size( this_player()->get_path( files[i] ) ) == -2 )  continue;
      old = read_file( this_player()->get_path( files[i] ) );
      lines = explode( replace_string( old, "\t", "   " ), "\n" );
      if ( ( sz = sizeof( lines ) ) < 2 )  continue;
      last_line = implode( explode( lines[0], " " ), "" );
      this_line = implode( explode( lines[1], " " ), "" );
      if ( sz > 2 )
         next_line = implode( explode( lines[2], " " ), "" );
      else next_line = "";
      for (j = 1, sz = sizeof(lines); j < sz - 1; j++ )  {
         if ( last_line[<2 .. <1] == "\"+"  &&
             strlen( this_line )  &&  this_line[0] == '\"' )
            lines[j-1] = lines[j-1][0 .. strsrch(lines[j-1], "+", -1) - 1];
         else if ( this_line[0 .. 1] == "+\""  &&
                   strlen(last_line)  && last_line[<1] == '\"' )
            lines[j] = " " + delete( lines[j], strsrch(lines[j], "+"), 1 );
         last_line = this_line;
         this_line = next_line;
         if ( j < sz - 2 )
            next_line = implode( explode( lines[j+2], " " ), "" );
      }
      if ( !rm( this_player()->get_path(files[i]) ) )
         write("Couldn't remove old file: " + files[i] + "\n" );
      else if ( !write_file(this_player()->get_path(files[i]),
                            implode(lines, "\n" ) + "\n" ) )  {
         write("Could not write new file: " + files[i] + "\n" );
         if ( !write_file(this_player()->get_path(files[i]), old ) )
            return notify_fail("Uh-oh, could not replace old file either.\n");
      }
      else write("File deplussed: " + files[i] + "\n");
   }
   return 1;
}
// --- END [/mnt/home2/grok/lib/obj/misc/deplusser.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/button.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/button.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627980   Available: 13575334
Inodes: Total: 5242880    Free: 4960134
860 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/button.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627980   Available: 13575334
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "std/object";

void setup() {
   set_name( "button" );
   set_short( "red button" );
   add_adjective( "red" );
   set_long( "This red button destructs all non-user objects in "
         "the room.  USE WITH EXTREME CAUTION.\n");
   reset_get();
   add_property( "there", "embedded into the wall" );
} /* setup() */

void init() {
   this_player()->add_command( "press" , this_object() );
} /* init() */

int do_press() {
   object thing, *things;
   things = (object *)environment()->query_non_destable();
   if ( !things )
      things = ({ this_object() });
   else
      things += ({ this_object() });
   foreach ( thing in all_inventory( environment() ) - things )
      if ( !userp( thing ) )
         thing->dest_me();
   write( "You clean up.\n" );
   say( (string)this_player()->one_short() +" cleans up.\n" );
   return 1;
} /* do_press() */
// --- END [/mnt/home2/grok/lib/obj/misc/button.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/player_shop/shop_notice.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/player_shop/shop_notice.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627979   Available: 13575333
Inodes: Total: 5242880    Free: 4960134
1949 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/player_shop/shop_notice.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627979   Available: 13575333
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * Player-run shop policy notice object.
 * This object is used by player-run shops to track management policy.
 * Essentially, it is only there to be looked at.
 * This object should not be inherited by anything, but is created by the
 * player_shop office.
 * @author Ringo
 * @started 21st September 1999
 */
inherit "/std/object";

private nosave string _office, _stock_policy;
private nosave int _type = 0;

void setup()
{
   set_name("notice");
   set_short("policy notice");
   set_long("");
   add_adjective("policy");
   reset_get();
}
/* setup() */


/**
 * @ignore yes
 * Chart display
 */
string long(string word, int dark)
{
   mapping policies= _office->get_policies(_type);
   int i = 1;
   string display;
   
   if (!_type)
   {
      display = sprintf("This is the list of shop's policies.  The policies "
         "on this notice are definitive and final.  This shop deals strictly "
         "in %s.  Items that do not fit this description should not be "
         "stocked.\n\n", "%^BOLD%^"+ _stock_policy+ "%^RESET%^");
   }
   else
   {
      display = "This is the list of management policies.\n\n";
   }
   
   if (!m_sizeof(policies))
   {
      return display;
   }
   foreach(string policy in m_indices(policies))
   {
      if(_office->query_manager(this_player()->query_name()) || 
         _office->query_retired(this_player()->query_name()) ||
         this_player()->query_creator())
      {
         display += sprintf("%d [%s]. %s\n", i++, policy,
            policies[policy][0]);  
      }
      else
      {
         display += sprintf("%d. %s\n", i++, policies[policy][0]);  
      }    
   }
   return display;
}
/* long() */


/**
 * @ignore yes
 * Where to get the data from?
 */
void set_office(string office)
{ 
   _office = office;
   _stock_policy = _office->get_stock_policy();
}
/* set_office() */


/**
 * @ignore yes
 * 1 for normal, 0 for managers
 */
void set_type(int type) { _type = type; }
// --- END [/mnt/home2/grok/lib/obj/misc/player_shop/shop_notice.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/player_shop/shop_cabinet.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/player_shop/shop_cabinet.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627979   Available: 13575333
Inodes: Total: 5242880    Free: 4960134
3002 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/player_shop/shop_cabinet.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627979   Available: 13575333
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * Player-run shop stock cabinet object.
 * This object is used by player-run shops to store the shop's stock.
 * Each cabinet will save its own inventory, and offers a method of
 * splitting the stock up into smaller chunks.  This will help prevent
 * the Tarnach's experience where 650k of stock is being saved every
 * time there is a change in the contents.
 * This object should not be inherited by anything, but should be created
 * by the player_shop storeroom.
 * @author Ringo
 * @started 1st August 1999
 */
#include <move_failures.h>

inherit "/std/container";

private mapping _stock = ([]);

private nosave string _save_file = "";

private nosave int _call_save = 0;

private void do_save();

void create()
{
   do_setup++;
   ::create();
   do_setup--;
   if (!do_setup)
   {
      this_object()->setup();
      this_object()->reset();
   }
}
/* create() */


/**
 * Used to add items to the stock.
 * @param items The items to add.
 * @param player The player adding the items.
 * @return An array of objects that could not be added.
 */
object *add_items(object *items, object player)
{
   object *failed = ({});

   foreach( object item in items )
   {
      if (item->move(this_object()) != MOVE_OK)
      {
         failed += ({ item });
      }
   }
   if (sizeof(failed))
   {
      failed->move(player);
   }
   remove_call_out(_call_save);
   _call_save = call_out((: do_save() :), 1);
   return failed;
}
/* add_items() */


/** @ignore yes */
void dest_me()
{
   if (remove_call_out(_call_save) != -1)
   {
      do_save();
   }
   ::dest_me();
}
/* dest_me() */


/** @ignore yes */
private void do_load()
{
   if (_save_file)
   {
      if (file_size(_save_file + ".o") > 0)
      {
         unguarded((: restore_object, _save_file :));
         if (sizeof(_stock))
         {
            init_dynamic_arg(_stock,0);
         }
      }
   }
}
/* do_load() */


/** @ignore yes */
private void do_save()
{
   if (_save_file && _save_file != "")
   {
#ifdef DEBUG
      debug_printf("Saving cabinet data to %s.\n", _save_file);
#endif
      _stock = query_dynamic_auto_load();
      unguarded((: save_object, _save_file :));
   }
}
/* do_save() */


/**
 * Used to remove items from the stock.
 * @param items The items to remove.
 * @param player The player removing the items.
 * @return An array of the objects that were dropped by the player.
 */
object *remove_items(object *items, object player)
{
   object *failed = ({});

   foreach(object item in items)
   {
      if (item->move(player) != MOVE_OK)
      {
         failed += ({ item });
      }
   }
   if (sizeof(failed))
   {
      failed->move(environment(player));
   }
   remove_call_out(_call_save);
     _call_save = call_out((: do_save() :), 1);
   return failed;
}
/* remove_items() */


/**
 * Set the filename that this cabinet should use to save its inventory to.
 * @param filename The file.
 */
void set_save_file(string filename)
{
   _save_file = filename;
   do_load();
}
/* set_save_file() */
// --- END [/mnt/home2/grok/lib/obj/misc/player_shop/shop_cabinet.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/player_shop/shop_chart.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/player_shop/shop_chart.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627978   Available: 13575332
Inodes: Total: 5242880    Free: 4960134
2077 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/player_shop/shop_chart.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627978   Available: 13575332
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * Player-run shop stock chart.
 * This object is used by player-run shops to keep track of stock.
 * Essentially, it is only there to be looked at.
 * This object should not be inherited by anything, but is created by the
 * player_shop office.
 * @author Ringo
 * @started 20th September 1999
 */
#include <player_shop.h>
#include <money.h>

inherit "/std/object";

private nosave string _office;

void setup()
{
   set_name("chart");
   set_short("items chart");
   add_adjective("items");
   reset_get();
}
/* setup() */

/**
 * @ignore yes
 * Chart display
 */
string long(string word, int dark)
{
   mapping list = _office->query_list_mapping();
   string chart, *items = sort_array(keys(list),1);
   
   if (!m_sizeof(list))
   {
      return "There are no items on the list.\n";
   }
   chart = sprintf("\n%-2s  %-25s  %-3s  %-5s  %-4s  %-4s  %-3s  %-4s  %-8s\n",
      "no", "items", "max", "stock", "avst", "avsl", "buy", "sell", "cabinets");
   chart += sprintf("%-2s  %-25s  %-3s  %-5s  %-4s  %-4s  %-3s  %-4s  %-8s\n",
      "--", "-----", "---", "-----", "----", "----", "---", "----", "--------");
   for (int i = 0; i < sizeof( items ); i++)
   {
     /* This can be a long loop if there is a lot of stock,
      * and we don't want 'too long eval' errors popping up...
      */
      reset_eval_cost();
      
      chart += sprintf("%2d  %-25s  %3d  %5d  %4d  %4d  %3d  %4d  %8s\n",
         i + 1, items[i], list[items[i]][CHART_MAX],
         _office->query_stock(items[i]), list[items[i]][CHART_AVE],
         list[items[i]][CHART_AVESALE], list[items[i]][CHART_BUY],
         list[items[i]][CHART_SELL],
         implode(list[items[i]][CHART_CAB], (: $1+","+$2 :), "")[1..]);
   }
   return sprintf("%s%s", ::long(word,dark), chart);
}
/* long() */


/**
 * @ignore yes
 * Where to get the data from?
 */
void set_office(string office)
{
   _office = office;
   set_long("This chart lists the items of interest to the shop.  All "
      "prices are in "+ pluralize(MONEY_HAND->smallest_in(_office->
      query_place()))+ ".\n");
} /* set_office() */
// --- END [/mnt/home2/grok/lib/obj/misc/player_shop/shop_chart.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/player_shop/shopping_bag.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/player_shop/shopping_bag.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627977   Available: 13575331
Inodes: Total: 5242880    Free: 4960134
1388 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/player_shop/shopping_bag.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627977   Available: 13575331
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * Player-run shop shopping bag object.
 * This object is given to customers of player-run shops.
 * This object should not be inherited by anything, but is created by the 
 * player_shop storeroom.
 * @author Ringo
 * @started 1st August 1999
 */
#include <move_failures.h>
#include <player_shop.h>

inherit "/obj/baggage";

void setup()
{
   set_name("bag");
   set_short("shopping bag");
   add_adjective("shopping");
   set_main_plural("shopping bags");
   set_long("This is a small paper shopping bag, designed to "
      "hold a number of small items.  It doesn't look very sturdy.\n");
   set_value(3);
   set_transparent();
   add_property("no recycling",1);

   /* Weight: 1 unit = 50g */
   set_weight(1);
   set_max_weight(MAX_BAG_WEIGHT);
}
/* setup() */

void change_condition()
{
   adjust_cond(-(10 + random(10)));
}

int test_add(object thing, int flag)
{
   if (sizeof(all_inventory()) >= MAX_BAG_ITEMS)
   {
      tell_object(this_player(), "The bag can only hold "+ 
         query_num(MAX_BAG_ITEMS)+ " items.\n");
      return 0;
   }
   if (!query_cond()) set_cond(20);
   call_out((: change_condition() :), 1);
   return ::test_add(thing,flag);
}
/* test_add() */

int test_remove(object thing, int flag, mixed dest)
{
   if (!query_cond()) set_cond(20);
   call_out((: change_condition() :), 1);
   return ::test_remove(thing,flag,dest);
}
/* test_remove() */
// --- END [/mnt/home2/grok/lib/obj/misc/player_shop/shopping_bag.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/player_shop/staff_book.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/player_shop/staff_book.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627976   Available: 13575330
Inodes: Total: 5242880    Free: 4960134
16046 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/player_shop/staff_book.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627976   Available: 13575330
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * Player-run shop staff handbook object.
 * This object is claimable by staff of player-run shops.
 * It is intended to describe the duties & offer guidance to staff.
 * This object should not be inherited by anything, but is created by the
 * player_shop office.
 *
 * @author Ringo
 * @started 1st August 1999
 */
#include <player_shop.h>

inherit "/std/book";

private string _office = "";

void setup()
{
   set_name( "book" );
   add_alias( "handbook" );
   set_short( "staff handbook");
   set_main_plural( "staff handbooks" );
   add_adjective( "staff" );
   set_weight( 5 );
   set_value( 5 );
   set_no_pages( 12 );
   add_property( "no recycling", 1 );
}
/* setup() */

/** @ignore yes */
private string cap_name(string name) 
{
   if (test_player(name))
      return PLAYER_HANDLER->query_cap_name(name);
   else return capitalize(name);
}

/** @ignore yes */
void set_office( string office )
{
   _office = office;
   if ( !query_property( "office" ) )
   {
      add_property( "office", office );
   }
   set_long( "This is a handbook for staff of "+ 
     office->query_shop_name()+ ", " + office->query_place()+ 
     ".  It covers all aspects of the job.\n"
     "You may <read book>, <open book to page #> and "
     "<turn a page of book>.\n" );

   set_open_page( 1 );
   set_read_mess( "\n"     
     "                            TABLE OF CONTENTS                    Page 1\n"
     "                    .o0o.o0o.o0o.o0o.o0o.o0o.o0o.o0o.\n\n"
     "       Introduction............................................2-4\n"
     "       The job.................................................5-6\n"
     "       The office..............................................6-7\n"
     "       The counter.............................................8\n"
     "       The storeroom...........................................9\n"
     "       The shopkeeper..........................................10\n"
     "       Promotion and pay.......................................11\n"
     "       Termination of employment...............................12\n\n",
     "common", 100 );

   set_open_page( 2 );
   set_read_mess( "\n"
     "                               Introduction                      Page 2\n"
     "                           -=-=-=-=-==-=-=-=-=-\n\n"
     " Welcome to "+ office->query_shop_name()+ ".\n"
     " This is a player-run shop, designed to operate interactively with its\n"
     " employees with minimal input from creators.\n"
     " Players are able to sell items to and buy them from the shop, just like\n"
     " a regular shop, but prices should be set such that it is advantageous\n"
     " to deal with us,  rather than some other general shop.\n\n"
     " A list of items in which the shop deals is maintained in the shop's\n"
     " office, where a chart shows the buying and selling prices of items,\n"
     " as well as how many are in stock, the maximum number that the shop\n"
     " will keep in stock and the average number that has recently been in\n"
     " stock; the stock itself is saved over a reboot.        (Continued...)",
     "common", 100 );

   set_open_page( 3 );
   set_read_mess( "\n"
     "                                                                 Page 3\n\n"
     " The most important feature of the shop is that it is run by players,\n"
     " with a non-player employee who stands in when there are no player\n"
     " employees about.  Players who work faithfully for the shop will be\n"
     " promoted to supervisor and then to manager, as well as receiving a\n"
     " regular wage which increases with employment level.\n\n"
     " As well as hiring new employees, managers are also responsible for\n"
     " firing employees who break trust.  Supervisors (and managers) are\n"
     " responsible for keeping the shop running efficiently by adding new\n"
     " items to those in which the shop deals, by adjusting selling and\n"
     " buying prices and inventory limits to reflect supply and demand and\n"
     " by removing items in which it is no longer reasonable to deal.\n\n"
     " Supervisors are also given access to the shop's log books which\n"
     " contain details of everything that happens.           (Continued...)",
     "common", 100 );

   set_open_page( 4 );
   set_read_mess( "\n"
     "                                                                 Page 4\n\n"
     " Finally, while it is intended, and hoped, that the shop will run\n"
     " autonomously under player control, it is inevitable that problems\n"
     " will arise from time to time which cannot be solved by the shop's\n"
     " player managers and supervisors.  Should such problems arise, please\n"
     " don't hesitate to contact myself or another creator.\n"
     " Enjoy your time with "+ _office->query_shop_name()+ ".\n "+
     cap_name( _office->query_creator() )+ " (caretaker)\n", "common", 100 );  

   set_open_page( 5 );
   set_read_mess( "\n"
     "                                 The Job                         Page 5\n"
     "                               -=-=-=-=-=-\n\n"
     " It is the responsibility of employees to ensure that the shop is\n"
     " kept as fully stocked as possible.  This may be achieved by buying\n"
     " items from players, or by collecting the items yourself.  Although\n"
     " you are not expected to come running to the shop every time a\n"
     " customer walks in, once you are clocked in, you should not leave\n"
     " the shop until you clock out again.\n\n"
     " All of the commands that are available to the shop's employees\n"
     " should be obvious from the various rooms of the shop; those available\n"
     " in the office are described by giving the command %^B_RED%^office%^RESET%^.\n"
     " Possibly the most important command is %^B_RED%^log%^RESET%^, which must be "
     "used to record\n"
     " each transaction.  All activity within the shop is logged, and so it is\n"
     " vital to record each sale and purchase in the correct manner so that the\n"
     " shop's supervisors and managers can see what happened when they examine\n"
     " the logs.  Examples of the \"log\" command are given in the section\n"
     " dealing with the counter.\n",
     "common", 100 );  

   set_open_page( 6 );
   set_read_mess( "\n"
     "                               The Office                          Page 6\n"
     "                             -=-=-=-==-=-=-\n\n"
     " The office of the shop is the nerve-centre.  This is where you can\n"
     " obtain most of your information, and is where you clock in and out.\n"
     " A description of the \"office\" commands you can use from here is\n"
     " given below.\n\n"
     " clock - Clock in or out of work.  You are only paid for the work\n"
     "         you do whilst you are clocked in.\n"
     " claim - Claim a staff badge, a copy of this book, or your monthly\n"
     "         bonus.  The badge itself has some nifty functions - look\n"
     "         at one for further information.\n"
     " list - List the employees of the shop, and find out your current\n"
     "        standing for promotion.  This shows the percentage of points\n"
     "        you have achieved towards your next promotion.\n"
     " bank - Change, or check your banking details.  Your pay can be paid\n"
     "        into the bank of your choice.  Your bonus is given in cash when\n"
     "        you \"claim\" it.\n"
     " promotion - Allows you to specify whether to be automatically promoted\n"
     "             or not.  If not, you will not be promoted once gaining the\n"
     "             required points until you specify otherwise.\n" 
     " resign - End your employment with the shop.             (Continued...)\n",
     "common", 100 );

   set_open_page( 7 );
   set_read_mess( "\n"
     "                                                                 Page 7\n\n"
     " Supervisors receive two additional commands - \"chart\" and \"logs\".\n"
     " The \"logs\" command allows a supervisor to review the logs, whilst the\n"
     " \"chart\" command allows them to add and remove items from the shop's\n"
     " list, set the maximum stock level, buy & sell prices, and assign them\n"
     " to a cabinet.  If an item is not assigned to a cabinet, it cannot be\n"
     " stored.  The \"check\" command allows supervisors to check which items\n"
     " are allocated to each cabinet.\n"
     " It is important to note that an item can be assigned to more than one\n"
     " cabinet, and that a cabinet can be assigned more than one item.  It is\n"
     " the supervisor's responsibility to ensure that items are judiciously\n"
     " assigned to ensure that the most efficient use is made of the available\n"
     " storage space.\n"
     " To view details of items stocked by the shop, simply \"look\" at the\n"
     " chart in the office.\n\n"
     " In addition, if there is no notice board in the shop, employees may use\n"
     " the \"memo\" command to send a mail to all the employees of the shop.\n",
     "common", 100 );

   set_open_page( 8 );
   set_read_mess( "\n"
     "                               The Counter                        Page 8\n"
     "                             -=-=-=-=-=-=-=-\n\n"
     " The counter houses the shop's cash register, and allows employees to\n"
     " \"log\" transactions.  There is also a \"calc\"ulator for use in those\n"
     " difficult situations.  All monies entering or exiting the register are\n"
     " logged, so if you are tempted, please bear in mind that supervisors can\n"
     " see exactly who took that $1000 from the till ;-)\n\n"
     " The log command can be confusing, so the following examples have been\n"
     " provided.  All entries are made from the point of view of the shop with\n"
     " the syntax: %^B_RED%^log shop bought|sold <quantity> <item> for <amount>%^RESET%^.\n"
     " Examples:\n\n"
     " A customer sells 5 gizmos to the shop at 20 pence each. The log entry is:\n"
     " %^B_RED%^log shop bought 5 gizmos for 100p%^RESET%^ (or $1 instead of 100p)\n\n"
     " A customer buys 20 elephants from the shop at 10 pence each.\n"
     " The log entry is:\n"
     " %^B_RED%^log shop sold 20 elephants for 200p%^RESET%^ (or $2 instead of 200p)\n\n"
     " If you do happen to make an error whilst logging a transaction, you\n"
     " may use the \"correction\" facility to note the error.  This will\n"
     " not erase the error, but will clarify that an error has been made.\n"
     " The syntax is the same as that of \"log\".\n\n"
	  " Please note that these are examples only, and you may be using a different\n"
	  " currency.\n\n",
     "common", 100 );

   set_open_page( 9 );
   set_read_mess( "\n"
     "                               The Storeroom                      Page 9\n"
     "                             -=-=-=-=-=-=-=-=-\n\n"
     " The storeroom, unsurprisingly, is where the shop's stock is stored.\n"
     " The stock itself is stored in several store cabinets, located in this\n"
     " room.  Each cabinet has a maximum stock capacity of "+ STOCK_PER_CABINET+ ".\n"
     " There are three commands available for dealing with the stock:\n\n"
     "   add - add items to the stock\n"
     "   remove - remove items from the stock\n"
     "   list - list all stock, or individual items\n\n"
     " These commands can be used relative to the whole stock, or by an\n"
     " individual cabinet.  For example, to add 10 beans to the stock, you\n"
     " could let the storeroom decide where to put the items by saying:\n"
     "   \"add 10 beans\"\n"
     " or specify a cabinet in which to place the beans:\n"
     "   \"add 10 beans to cabinet 1\"\n"
     " Generally, it is easier to use the first syntax and let the storeroom\n"
     " decide things for you.  Be aware that it will not let you place an item\n"
     " in the wrong cabinet, or in a cabinet that is full.\n"
     " For more information, see \"syntax <command>\"\n\n", "common", 100 );
     

    set_open_page( 10 );
    set_read_mess( "\n"
     "                              The Shopkeeper                     Page 10\n"
     "                           -=-=-=-=-=-=-=-=-=-\n\n"
     " With regard to the shopkeeper, when you leave the shop for other\n"
     " activities, it is important to clock out in order that they can be\n"
     " summoned from their home to staff the shop.  Conversely, when you clock\n"
     " in for work, say to them that you'll take over, and they will return\n"
     " home. Please also make sure that the cash register always contains\n"
     " plenty of the lowest denomination coins as, for religious reasons,\n"
     " they are incapable of handling the larger denominations of coinage.\n",
     "common", 100 );

   set_open_page( 11 );
   set_read_mess( "\n"
     "                              Promotion and pay                  Page 11\n"
     "                           -=-=-=-=-=-=-=-=-=-=-=-\n\n"
     " Promotion within the shop depends entirely on how much work an\n"
     " employee does.  Once an employee has done the required amount,\n"
     " they will be promoted automatically unless they have requested\n"
     " otherwise.  When you are promoted to supervisor, you will gain\n"
     " access to the shop's logs and also be able to add/remove items\n"
     " from the chart as well as adjust the buy/sell and maximum stock\n"
     " level of those items.  After even more work, the dedicated employees\n"
     " will be promoted to manager.\n"
     " Pay is also based on the amount of work that you do.  You will be\n"
     " paid each month directly into your bank account at whichever bank\n"
     " you specify in the office.  As a supervisor or manager, you will\n"
     " enjoy a higher rate of pay.\n"
     " Managers are responsible for allocating funds towards the monthly\n"
     " bonus fund.  This fund will be divided up between employees at the\n"
     " end of each month as long as those employees have been employed for\n"
     " the full month, and have not had their bonus suspended.\n"
     " It is up to each individual to claim their bonus during that month.\n"
     " All unclaimed bonuses will be added to the next month's fund.\n", 
     "common", 100 );

   set_open_page( 12 );
   set_read_mess( "\n"
     "                         Termination of employment                Page 12\n"
     "                      -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n\n"
     " If you no longer wish to work at the shop then you can resign from\n"
     " your position.  This can be done from the shop office.  If you do\n"
     " resign, please remember to return your employee badge.\n\n"
     " Managers have the power to fire employees for breach of trust.\n"
     " Reasons for dismissal include (but are not restricted to):\n"
     "     Dishonesty (Stealing items or cash from the shop)\n"
     "     Inactivity (Not working in the shop for prolonged periods)\n"
     "     The killing of any employee on duty\n"
     "     The killing of anybody whilst on duty\n"
     "     Not returning to the shop whilst on duty\n"
     "     Teleporting into or encoding the location of employee areas\n\n"
     " If you are fired without good reason, then you can appeal to any\n"
     " manager.  Bear in mind though, that all decisions taken with regard\n"
     " to the hiring and firing of employees will normally have been\n"
     " discussed by the managers beforehand and will usually have been\n"
     " preceded by a warning.\n", "common", 100 );

   set_open_page( 0 );
}
/* set_office() */


void init ()
{
   set_open_page( 0 );
   if ( !_office || _office == "" )
   {
      if ( !query_property( "office" ) )
      {
         return;
      }
      _office = query_property( "office" );
      set_office( _office );
   }
   if ( !_office->query_employee( environment( this_object() )->query_name() ) &&
     !_office->query_retired( environment( this_object() )->query_name() ) &&
     !environment( this_object() )->query_creator() )
   {
      return;
   }
   ::init();
}
/* init() */
// --- END [/mnt/home2/grok/lib/obj/misc/player_shop/staff_book.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/player_shop/mgr_book.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/player_shop/mgr_book.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627972   Available: 13575326
Inodes: Total: 5242880    Free: 4960134
13397 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/player_shop/mgr_book.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627972   Available: 13575326
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * Player-run shop manager handbook object.
 * This object is claimable by managers of player-run shops.
 * It is intended to describe the duties & offer guidance to these managers.
 * This object should not be inherited by anything, but is created by the
 * player_shop office.
 *
 * @author Ringo
 * @started 1st August 1999
 */
#include "player_shop.h"

inherit "/std/book";

private string _office;

void setup() {
    set_name( "book" );
    add_alias( "handbook" );
    set_short( "manager handbook");
    set_main_plural( "manager handbooks" );
    add_adjective( "manager" );
    set_weight( 5 );
    set_value( 5 );
    set_no_pages( 11 );
    add_property( "no recycling", 1 );
}
/* setup() */

/** @ignore yes */
private string cap_name(string name) 
{
   if (test_player(name))
      return PLAYER_HANDLER->query_cap_name(name);
   else return capitalize(name);
}

/** @ignore yes */
void set_office( string office ) { 
   _office = office;
   if ( !query_property( "office" ) ) {
      add_property( "office", office );
   }
   set_long( "This is a handbook for Managers of "+ office->query_shop_name()+
     ", "+ office->query_place()+ ".  It covers those aspects of "
     "the managers' job not covered by the staff handbook.\n"
     "You may <read book>, <open book to page #> and "
     "<turn a page of book>.\n" );

    set_open_page( 1 );
    set_read_mess( "\n"     
      "                            TABLE OF CONTENTS                    Page 1\n"
      "                    .o0o.o0o.o0o.o0o.o0o.o0o.o0o.o0o.\n\n"
      "       Introduction............................................2\n"
      "       The job.................................................3\n"
      "       The way things work.....................................4\n"
      "       Specific commands.......................................5-7\n"
      "       Hiring new employees....................................8-9\n"
      "       Disciplinary procedures.................................10-11\n",
      "common", 100 );

    set_open_page( 2 );
    set_read_mess( "\n"
      "                               Introduction                      Page 2\n"
      "                           -=-=-=-=-==-=-=-=-=-\n\n"
      " This handbook has been written specifically for managers to detail\n"
      " your role in the shop.  You will find details of commands specific\n"
      " to managers, and a more detailed explanation of the workings of the\n"
      " shop.  This book is to be treated as a confidential document, and its\n"
      " contents only to be discussed with other managers.\n",
      "common", 100 );

    set_open_page( 3 );
    set_read_mess( "\n"
      "                                 The Job                         Page 3\n"
      "                               -=-=-=-=-=-\n\n"
      " It is the responsibility of managers to ensure the smooth operation\n"
      " of the shop.  This includes staff motivation, advertising, pay and\n"
      " staffing levels, accounts, discipline and personnel.\n"
      " Motivation and advertisements are left to the judgement of managers,\n"
      " whilst the personnel issues should follow strict guidelines detailed\n"
      " later.\n\n"
      " As you should be aware, since you now hold the highest position in the\n"
      " store, there is nothing to work towards regarding your promotion.  You\n"
      " are paid at a higher rate, however, so there are still benefits to be\n"
      " obtained from carrying out the more 'mundane' tasks within the shop.\n\n"
      " Finally, managers are allowed to \"retire\" and continue in an advisory\n"
      " capacity.  Whilst having very limited functional control over the\n"
      " shop, retired managers are still able to keep their badge, and use\n"
      " the notice board and \"memo\" facility.\n",
      "common", 100 );  

    set_open_page( 4 );
    set_read_mess( "\n"
      "                           The way things work                   Page 4\n"
      "                         -=-=-=-=-=-=-=-=-=-=-=-\n\n"
      " On being hired, employees are paid according to the amount of work\n"
      " they do.  Along with their pay, they accumulate points towards\n"
      " promotion in the shop.  The pay and points depend on the amount of\n"
      " work done, and not on the amount of time spent in the shop.  Precisely,\n"
      " employees receive a set amount per transaction, with a maximum of one\n"
      " paid transaction every minute.\n"
      " Each employee's status is reviewed every 3 DW days, their points added,\n"
      " and their pay awarded.  This pay is transferred into their bank account\n"
      " every month, and a written confirmation of the amount is sent.\n"
      " Employees are paid according to their status.  This is done in a ratio\n"
      " of 2:3:4 so that managers will be paid twice as much as employees, with\n"
      " supervisors halfway in between.  The bonuses are calculated in the same\n"
      " way.\n",
      "common", 100 );

    set_open_page( 5 );
    set_read_mess( "\n"
      "                              Specific commands                  Page 5\n"
      "                           -=-=-=-=-=-=-=-=-=-=-=-\n\n"
      " There are a number of additional commands once promotion to manager\n"
      " is gained.  The majority of these are rather self-explanatory, and\n"
      " so will only be covered briefly.  The remainder merit an explanation.\n\n"
      " accounts - Check the current value of the accounts\n"
      " list - As in the main office, with the addition of baddies & applicants\n"
      " mail - Yes, you now have access to your mail from the managers' office\n"
      " memo - Send a memo to the other managers of the shop\n"
      " retire - The alternative to resignation\n"
      " view - View a person's record with this shop.  This is extremely useful\n"
      "        when deciding on disciplinary matters, or before hiring applicants\n"
      " query - Check the current settings for maximum number of employees and\n"
      "         pay rates\n"
      " project - Gives a projection of the months' pay packet based on the\n"
      "           employees' activity so far, and also the projected bonus amounts\n"
      "           based on the current value of the bonus fund.  Useful when setting\n"
      "           these values\n"
      " transfer - Transfer money between two accounts                (Continued...)\n",
      "common", 100 );

    set_open_page( 6 );
    set_read_mess( "\n"
      "                                                                 Page 6\n\n"
      " set - This command sets the maximum number of employees (speaks for\n"
      "       itself), or the base pay rate.  The base pay rate is the amount\n"
      "       that each employee will receive per transaction.  This rate is\n"
      "       then adjusted accordingly for supervisors and managers.\n"
      "       Changing this amount will not affect transactions already made\n"
      "       by employees, but will affect all subsequent transactions.\n"
      " buy/sell - These commands are used to buy and sell storeroom cabinets.\n"
      "            Cabinets are sold for 50% of the buying price, so make sure\n"
      "            you really do want a cabinet before buying it as they can be\n"
      "            expensive.\n"
      " (un)ban - These commands are used to ban or unban a person from the shop.\n"
      "           A person can be banned automatically, and will also be unbanned\n"
      "           automatically after 28 days.  If, however, you wish to unban\n"
      "           someone sooner, you may do so with this command.\n"
      " vote - Allows you to vote for, against, or abstain on an applicant.  This\n"
      "        will be your only chance to vote on this applicant, so make sure it\n"
      "        is the right decision.\n"
      " check - Allows you to check your current votes               (Continued...)\n",
      "common", 100 );

    set_open_page( 7 );
    set_read_mess( "\n"
      "                                                                 Page 7\n\n"
      " leave - Allows you to place an employee on leave for up to 14 days\n"
      " commend - Allows you to commend an outstanding employee.  This will\n"
      "           place an entry in their employment record, and award them\n"
      "           extra promotion points.\n"
      " warn - Officially reprimand an employee.  Will place an entry in their\n"
      "        record, and deduct promotion points.\n"
      " suspend - Suspend an employee's bonus entitlement for a specified\n"
      "           number of months following the current month.\n"
      " demote - Demote a supervisor to employee.  Will start them off as if\n"
      "          they were a new employee, but with their employment record\n"
      "          reflecting their history.\n"
      " fire - Terminate someone's employment with this shop.\n",
      "common", 100 );


    set_open_page( 8 );
    set_read_mess( "\n"
      "                            Hiring new employees                Page 8\n"
      "                        -=-=-=-=-=-=-=-=-=-=-=-=-=-\n\n"
      " This is a brief description of the process involved in hiring a\n"
      " new employee.\n\n"
      " 1) Prospective employees \"apply\" in the shop and a mail is sent\n"
      "    to each manager.  The application is saved and viewable from\n"
      "    within the managers' office.\n"
      " 2) Managers check the list in the office which will show applicants\n"
      "    waiting for employment, applicants yet to confirm their offer,\n"
      "    and new applicants yet to be voted upon (with votes so far).\n"
      " 3) Managers \"vote\" on each prospective employee.  Only one vote\n"
      "    per employee per manager is allowed, and the first vote counts.\n"
      " 4) As soon as the number of votes for employment equals 50% of the\n"
      "    current manager base, the candidate is accepted.  If votes against\n"
      "    exceeds 50%, the candidate is rejected.\n"
      " 5) If 50% hasn't been reached after 7 days, then the candidate is\n"
      "    hired/rejected on the basis of votes received so far.  (Continued...)\n",
      "common", 100 );

    set_open_page( 9 );
    set_read_mess( "\n"
      "                                                                Page 9\n\n"
      " 6) The approved candidate has 7 days from being accepted to confirm\n"
      "    their offer, otherwise they are removed from the list.\n"
      " 7) Once confirmed, the employee is kept advised of their current\n"
      "    position in the waiting list, and hired as soon as a position\n"
      "    becomes vacant in the shop.\n"
      " 8) The candidate can \"cancel\" their application at any time until\n"
      "    they are hired.\n\n"
      " Since the candidates are hired in order of being accepted, please make\n"
      " sure you vote for the oldest applications first.\n",
      "common", 100 );

    set_open_page( 10 );
    set_read_mess( "\n"
      "                           Disciplinary procedures              Page 10\n"
      "                         -=-=-=-=-=-=-=-=-=-=-=-=-=-\n\n"
      " This section is intended as a guide to disciplinary procedures.  It\n"
      " is ultimately down to managers to set their own policies within the\n"
      " shop.\n"
      " The first step in any action is to verbally warn an employee before\n"
      " taking any formal action.  This avoids any unpleasant comebacks on\n"
      " the manager involved.\n"
      " The next stage is either a warning, or suspending an employee's bonus.\n"
      " Whilst a warning reduces an employee's promotion points, bonuses can\n"
      " be suspended indefinitely.\n"
      " If the employee is a supervisor, the next stage is probably demotion.\n"
      " Following demotion, or if the employee is not a supervisor, dismissal\n"
      " may be the only course of action open to you.\n"
      " It is important to check the employee's history before taking any\n"
      " action as this will allow you to see what action has already been\n"
      " taken, and when.                                       (Continued...)\n",
      "common", 100 );

    set_open_page( 11 );
    set_read_mess( "\n"
      "                                                                Page 11\n\n"
      " Again, it is the responsibility of managers to develop a policy as\n"
      " to what merits disciplinary action.  A few guidelines are set out in\n"
      " the staff handbook, but more can be added.\n\n"
      " Finally, if there are any changes that need making to this, or indeed\n"
      " the staff handbook, please let me know.  I am open to comments and\n"
      " suggestions on content as well as shop policy.\n"
      " (c) "+ cap_name(CREATOR)+ " 2001",
      "common", 100 );

    set_open_page( 0 );
}
/* setup() */


void init () {
   set_open_page( 0 );
   if ( !_office || _office == "" ) {
      if ( !query_property( "office" ) ) {
         return;
      }
      _office = query_property( "office" );
      set_office( _office );
   }
   if ( !_office->query_manager( environment( this_object() )->query_name() ) &&
     !_office->query_retired( environment( this_object() )->query_name() ) &&
     !environment( this_object() )->query_creator() ) {
      return;
   }
   ::init();
}
/* init() */
// --- END [/mnt/home2/grok/lib/obj/misc/player_shop/mgr_book.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/player_shop/shop_badge.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/player_shop/shop_badge.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627969   Available: 13575323
Inodes: Total: 5242880    Free: 4960134
10978 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/player_shop/shop_badge.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627969   Available: 13575323
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
* Player-run shop employee badge.
* This object is the badge claimable by employees of player-run shops.
* It allows employees of a particular shop to chat to each other on a
* deidcated channel.  It also sets a player-title, and shows which employees
* are currently logged on.
* This object should not be inherited by anything, but should be created
* by the player_shop office.
* @author Ringo
* @started 1st August 1999
*/
#include <player_shop.h>

inherit "/obj/armour";

private int do_badge(string);
private int do_chat(string);
private int get_properties();
private string cap_name(string);

private string _office, 
_title,
_channel,
_owner;

private int _echo;

void setup()
{
    set_name("badge");
    set_short("employee badge");
    add_adjective("employee");
    add_adjective("tin");
    add_adjective("small");
    set_main_plural("employee badges");
    set_weight(1);
    set_value(0);
    set_type("badge");
    setup_armour(640);
    set_damage_chance(5);
    set_wear_remove_func(file_name(this_object()),
      "wear_remove_badge");
    add_property("no recycling", 1);
    add_extra_look(this_object());
    if (!query_property("office") || !query_property("owner"))
    {
        return;
    }
    _office = query_property("office");
    _owner = query_property("owner");
    _echo = query_property("echo");
    _title = _office->shop_very_short();
    _channel = _office->query_channel();
    set_long( "This is a small tin badge which marks " +
      cap_name(_owner) + " as an employee of "+
      _office->query_shop_name()+ ", "+ _office->query_place()+ ".\n");
    add_adjective(_channel);
}
/* setup() */


/** @ignore yes */
private string cap_name(string name) 
{
    if (test_player(name))
        return PLAYER_HANDLER->query_cap_name(name);
    else return capitalize(name);
}

/** @ignore yes */
void init()
{
    object tp;

    if (!_office || !_owner)
    {
        if (!get_properties()) return;
        set_long("This is a small tin badge which marks "+
          cap_name(_owner) + " as an employee of "+
          _office->query_shop_name()+ ", "+ _office->query_place()+ ".\n");
        add_adjective(_channel);
    }
    tp = this_player();
    if (!_office->query_employee(tp->query_name()) &&
      !_office->query_retired(tp->query_name()) &&
      !tp->query_creator())
    {
        return;
    }
    add_command("badge", ({ "help", "echo" }), (: do_badge($5) :));
    add_command("h"+ _channel, "", (: do_badge("hist") :));
    add_command(_channel+"?", "", (: do_badge("who") :));
    add_command(_channel, "<string'text'>", (: do_chat($4[0]) :));
    add_command(_channel+"@", "<string'text'>", (: do_chat("@"+$4[0]) :));
}
/* init() */


/** @ignore yes */
private int do_badge(string args)
{
    if (!_office || !_owner)
    {
        if (!get_properties()) return 1;
    }
    add_succeeded_mess("");
    if (args == "who")
    {
        tell_object(this_player(),
          "The following employees from "+ _office->query_shop_name()+
          " are logged on: \n" + _office->badge_list());
        return 1;
    }
    else if (args == "hist")
    {
        string result = "$P$"+ _channel+ " channel$P$\n";
        mixed *hist = HISTORY_HANDLER->query_chat_history(lower_case(_channel));

        tell_object(this_player(),
          "You ask the badge for the last few chats on the "+ _channel+ 
          " channel\n");
        if (!arrayp(hist) || !sizeof(hist))
        {
            tell_object(this_player(),
              "The badge mutters that nothing has been said on this channel, "
              "or it is not being remembered.\n");
            return 1;
        }
        result += implode(map(hist, (: "$I$5=$C$" + $1[0] + $1[1] + 
              "%^RESET%^" :)), "\n" ); 
        tell_object(this_player(), result);
    }
    else if (args == "echo")
    {
        if (_echo)
        {
            tell_object(this_player(), "Local echo now off.\n");
            _echo = 0;
        }
        else
        {
            tell_object(this_player(), "Local echo now on.\n");
            _echo = 1;
        }
        add_property("echo", _echo);
    }
    else
    {
        string result = sprintf("Commands for this badge:\n\n"
          "   %-13s - chat a message to the other employees\n"
          "   %-13s - emote a message to the other employees\n"
          "   %-13s - list employees logged on\n"
          "   h%-12s - show recent chat history\n"
          "   badge echo    - Turn local echo on/off\n\n"
          "You can also set your preferred chat colour using the \"colour "
          "shopchat <colour>\" command.\n", _channel, _channel + "@",
          _channel + "?", _channel, _channel);
        tell_object(this_player(), result);
    }
    return 1;
}
/* do_badge() */


/** @ignore yes */
private int do_chat(string wisp)
{
    string sender;
    object *things, tp;

    add_succeeded_mess("");
    if (!_office || !_owner)
    {
        if (!get_properties()) return 1;
    }
    tp = this_player();
    if (!tp->query_property(_channel+ "_on"))
    {
        return notify_fail("You are not wearing the " + _channel+
          " badge!\n");
    }
    if (tp->query_property("gagged"))
    {
        return notify_fail("You have been gagged!  You cannot chat until "
          "your gag is removed.  Perhaps you should talk to a creator about "
          "this.\n");
    }
    if (!tp->query_creator())
    {
        wisp = replace_string(wisp, "%^", "");
    }
    if (!wisp || ( wisp == "" ) || wisp == "@")
    {
        return notify_fail("Chat what?\n");
    }
    if (environment(this_object()) != tp)
    {
        return notify_fail("You're too far from the badge to whisper into "
          "it.\n");
    }
    tell_object(tp,  "You whisper into the badge.\n");
    sender = tp->query_cap_name();
    if (tp->query_name() == CREATOR && tp->query_invis())
    {
        sender = tp->query_short();
    }
    wisp = replace(wisp, sprintf("%c", 7), "!");
    things = children(BADGE);

    if (_echo)
    {
        things -= ({find_object(BADGE)});
    }
    else
    {
        things -= ({this_object(), find_object(BADGE)});
    }
    things->receive(_channel ,sender, wisp);
    if (wisp[0] == '@')
    {
        if (wisp[1] == ''')
      {
         HISTORY_HANDLER->add_chat_history(_channel, sender, wisp[1..1000]);
      }
      else
      {
         HISTORY_HANDLER->add_chat_history(_channel, sender+ " ", wisp[1..1000]);
      }
   }
   else
   {
      HISTORY_HANDLER->add_chat_history(_channel, sender +": ", wisp);
   }
   return 1;
}
/* do_chat() */


/** @ignore yes */
string extra_look(object thing)
{
   object tp;
   
   tp = this_player();
   if (!_office || !_owner)
   {
      if (!get_properties()) return "";
   }
   if (!_office->query_employee(tp->query_name()) &&
      !_office->query_retired(tp->query_name()) && !tp->query_creator())
   {
      return "";
   }
   return "You can get a list of commands by typing \"badge help\"\n";
}
/* extra_look() */


/** @ignore yes */
private int get_properties()
{
   if (!query_property("office") || !query_property("owner"))
   {
      tell_object(environment(), "This badge is broken.  "
         "Please claim another.\n");
      move("/room/rubbish");
      return 0;
   }
   _office = query_property("office");
   _owner = query_property("owner");
   _echo = query_property("echo");
   _title = _office->shop_very_short();
   _channel = _office->query_channel();
   return 1;
}
/* get_properties() */


/** @ignore yes */
string query_channel() { return copy(_channel); }


/** @ignore yes */
void receive(string channel, string sender, string text)
{
   object owner = environment();
   string *ignoring, prev_ob;
   
   if (!_office || !_owner)
   {
      if (!get_properties()) return;
   }
   prev_ob = base_name(previous_object());
   if (prev_ob != BADGE && prev_ob != _office->query_shop_front()
      /* Remove this condition once Tarnach's changed over */
      && prev_ob != "/d/am/square/emporium/TARNACH/consumables")
   {
      LOG_ERROR("shop_badge.c", "receive("+channel+","+sender+","+text+")");
      return;
   }
   if (!owner || (!living(owner)))
   {
      return;
   }
   if (!_office->query_employee(owner->query_name()) &&
      !_office->query_retired(owner->query_name()) &&
      !owner->query_creator())
   {
      return;
   }
   ignoring = owner->query_property("ignoring");
   if (ignoring && member_array(lower_case(sender), ignoring) != -1)
   {
      return;
   }
   if (channel != _channel || !owner->query_property(_channel+ "_on"))
   {
      return;
   }
   if (text[0] == '@')
   {
      if (text[1] == ''')
      {
         text = "["+ lower_case( _channel )+ "] "+ sender + text[1..1000];
      }
      else
      {
         text = "["+ lower_case( _channel )+ "] "+ sender +" "+ text[1..1000];
      }
   }
   else
   {
      text = "["+ lower_case( _channel )+ "] "+ sender +": "+ text;
   }
   
   tell_object(owner, owner->colour_event("shopchat", "%^CYAN%^") +
      "$I$5=$C$"+ text + "%^RESET%^\n");
   return;
}
/* receive() */


/** @ignore yes */
void set_props(string path, string owner)
{
   if (!path || path == "")
   {
      return;
   }
   if (previous_object() && previous_object() != find_object(path)) 
   {
      LOG_ERROR("shop_badge.c", "set_props("+path+","+owner+")");
      return;
   }
   set_long("This is a small tin badge which marks " +
      cap_name( owner ) + " as an employee of "+
      path->query_shop_name()+ ", "+ path->query_place()+ ".\n");
   add_property("office", path);
   add_property("owner", owner);
   _office = path;
   _owner = owner;
   _title = _office->shop_very_short();
   _channel = _office->query_channel();
   add_adjective( _channel );
}
/* set_props() */


/** @ignore yes */
void wear_remove_badge(object thing)
{   
   if (!_office || !_owner)
   {
      if (!get_properties()) return;
   }
   if (thing)
   {
      int level;
      string start;

      if (!living(thing))
      {
         return;
      }

if (thing->query_creator())
{
thing->add_property(_channel+ "_on", 1);
return;
}

      level = _office->query_employee(thing->query_name());
      
      /* Once Tarnach's transferred over replace following line with
       * if ( !level )
       */
      if (!level || level == -1)
      {
         if (_office->query_retired(thing->query_name()))
         {
            start = "Retired manager of ";
         }
         else return;
      }
      else if (level & MANAGER)
      {
         start = "Manager of ";
      }
      else if (level & SUPERVISOR)
      {
         start = "Supervisor of ";
      }
      else
      {
         start = "Employee of ";
      }
      thing->add_property(_channel+ "_on", 1);
      thing->set_title(_title, start + _office->query_shop_name());
      return;
   }
   thing = previous_object()->query_worn_by();
   if (thing)
   {
      thing->remove_property(_channel+ "_on");
      thing->remove_title(_title);
   }
}
/* wear_remove_badge() */
// --- END [/mnt/home2/grok/lib/obj/misc/player_shop/shop_badge.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/easel.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/easel.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627966   Available: 13575320
Inodes: Total: 5242880    Free: 4960134
7109 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/easel.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627966   Available: 13575320
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#define DIRS ([ \
      "north" : ({ ({ 0, -1 }), ({ "|" }) }), \
      "northeast" : ({ ({ 1, -1 }), ({ "/" }) }), \
      "east" : ({ ({ 1, 0 }), ({ "-" }) }), \
      "southeast" : ({ ({ 1, 1 }), ({ "\\" }) }), \
      "south" : ({ ({ 0, 1 }), ({ "|" }) }), \
      "southwest" : ({ ({ -1, 1 }), ({ "/" }) }), \
      "west" : ({ ({ -1, 0 }), ({ "-" }) }), \
      "northwest" : ({ ({ -1, -1 }), ({ "\\" }) }), \
   ])
#define PRIMES ({ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29 })

inherit "/std/object";

int *origin;
string *lines;

void setup() {
   set_name( "easel" );
   set_short( "small easel" );
   add_adjective( "small" );
   set_main_plural( "small easels" );
   set_value( 800 );
   origin = ({ 0, 0 });
   lines = ({ });
} /* setup() */

int *query_origin() { return origin; }

string *query_lines() { return lines; }

string long( string word, int dark ) {
   int i, max, min, width;
   string part;
   if ( !sizeof( lines ) )
      return "The easel is blank.\n";
   width = ( (int)this_player()->query_cols() - 2 ) / 2;
   min = origin[ 0 ] - width;
   max = origin[ 0 ] + width;
   if ( min < 0 ) {
      max -= min;
      min = 0;
   }
   if ( max >= strlen( lines[ 0 ] ) )
      max = strlen( lines[ 0 ] ) - 1;
   part = "";
   for ( i = 0; i < sizeof( lines ); i++ )
      part += " "+ lines[ i ][ min .. max ] +"\n";
   return part;
} /* long() */

int query_at( int *place ) {
   if ( !sizeof( lines ) )
      return 32;
   if ( ( origin[ 0 ] + place[ 0 ] ) < 0 )
      return 32;
   if ( ( origin[ 0 ] + place[ 0 ] ) >= strlen( lines[ 0 ] ) )
      return 32;
   if ( ( origin[ 1 ] + place[ 1 ] ) < 0 )
      return 32;
   if ( ( origin[ 1 ] + place[ 1 ] ) >= sizeof( lines ) )
      return 32;
   return lines[ origin[ 1 ] + place[ 1 ] ][ origin[ 0 ] + place[ 0 ] ];
} /* query_at() */

void add_shape( int *start, string *pieces ) {
   int i, number, max, width;
   string gap, front, back;
   for ( i = 0; i < sizeof( pieces ); i++ )
      if ( strlen( pieces[ i ] ) > max )
         max = strlen( pieces[ i ] );
   if ( sizeof( lines ) )
       width = strlen( lines[ 0 ] );
   else
      lines = ({ "" });
   if ( ( origin[ 0 ] + start[ 0 ] ) < 0 ) {
      gap = "";
      for ( i = origin[ 0 ] + start[ 0 ]; i < 0; i++ )
         gap += " ";
      for ( i = 0; i < sizeof( lines ); i++ )
         lines[ i ] = gap + lines[ i ];
      origin[ 0 ] = -start[ 0 ];
   }
   if ( ( origin[ 0 ] + start[ 0 ] + max ) > width ) {
      gap = "";
      for ( i = width; i < ( origin[ 0 ] + start[ 0 ] + max ); i++ )
         gap += " ";
      for ( i = 0; i < sizeof( lines ); i++ )
         lines[ i ] += gap;
   }
   max = sizeof( pieces );
   width = sizeof( lines );
   if ( ( origin[ 1 ] + start[ 1 ] ) < 0 ) {
      gap = "";
      for ( i = 0; i < strlen( lines[ 0 ] ); i++ )
         gap += " ";
      for ( i = origin[ 1 ] + start[ 1 ]; i < 0; i++ )
         lines = ({ gap }) + lines;
      origin[ 1 ] = -start[ 1 ];
   }
   if ( ( origin[ 1 ] + start[ 1 ] + max ) > width ) {
      gap = "";
      for ( i = 0; i < strlen( lines[ 0 ] ); i++ )
         gap += " ";
      for ( i = width; i < ( origin[ 1 ] + start[ 1 ] + max ); i++ )
         lines += ({ gap });
   }
   for ( i = origin[ 1 ] + start[ 1 ]; i < ( origin[ 1 ] + start[ 1 ] + max );
         i++ ) {
      number = origin[ 0 ] + start[ 0 ];
      if ( number > 0 )
         front = lines[ i ][ 0 .. number - 1 ];
      else
         front = "";
      number = origin[ 0 ] + start[ 0 ] +
            strlen( pieces[ i - origin[ 1 ] - start[ 1 ] ] );
      if ( number < strlen( lines[ i ] ) )
         back = lines[ i ][ number .. strlen( lines[ i ] ) - 1 ];
      else
         back = "";
      lines[ i ] = front + pieces[ i - origin[ 1 ] - start[ 1 ] ] + back;
   }
} /* add_shape() */

string *make_block( int size, int home ) {
   int i, j;
   string start, end, *blocks;
   if ( size == 1 )
      if ( home )
         return ({ "@" });
      else
         return ({ "#" });
   blocks = allocate( size );
   if ( home )
      blocks[ 0 ] = "@";
   else
      blocks[ 0 ] = "+";
   for ( i = 2; i < size; i++ )
      blocks[ 0 ] += "-";
   if ( home )
      blocks[ 0 ] += "@";
   else
      blocks[ 0 ] += "+";
   for ( i = 2; i < size; i++ ) {
      blocks[ i - 1 ] = "|";
      for ( j = 2; j < size; j++ )
         blocks[ i - 1 ] += ".";
      blocks[ i - 1 ] += "|";
   }
   if ( home )
      blocks[ size - 1 ] = "@";
   else
      blocks[ size - 1 ] = "+";
      for ( i = 2; i < size; i++ )
      blocks[ size - 1 ] += "-";
   if ( home )
      blocks[ size - 1 ] += "@";
   else
      blocks[ size - 1 ] += "+";
   return blocks;
} /* make_block() */

void make_map( mixed *locations, mapping connections ) {
   int i, j, k, x, y, *sizes;
   string *places;
   mapping centres;
   sizes = ({ });
   places = ({ });
   centres = ([ ]);
   for ( i = 0; i < sizeof( locations ); i+= 2 ) {
      sizes += ({ locations[ i + 1 ] });
      places += ({ locations[ i ] });
      reset_eval_cost();
   }
   for ( i = 0; i < sizeof( PRIMES ); i++ ) {
      x = 0;
      y = 0;
      for ( j = 0; j < sizeof( sizes ); j++ ) {
         if ( PRIMES[ i ] > sizes[ j ] ) {
            x = 1;
            break;
         }
         if ( sizes[ j ] % PRIMES[ i ] )
            y = 1;
      }
      if ( x )
         break;
      if ( !y ) {
         for ( j = 0; j < sizeof( sizes ); j++ )
            sizes[ j ] /= PRIMES[ i ];
         i--;
      }
   }
   reset_eval_cost();
   centres[ places[ 0 ] ] = ({ 0, 0 });
   for ( i = 0; i < sizeof( places ); i++ ) {
      tell_object( find_player( "deutha" ), "On "+ i +", "+ places[ i ] +
            ", at "+ centres[ places[ i ] ][ 0 ] +", "+
            centres[ places[ i ] ][ 1 ] +" for "+ sizes[ i ] +"\n" );
      add_shape( ({ centres[ places[ i ] ][ 0 ] - sizes[ i ],
            centres[ places[ i ] ][ 1 ] - sizes[ i ] }),
            make_block( 2 * sizes[ i ] - 1, !i ) );
      if ( undefinedp( connections[ places[ i ] ] ) )
            continue;
      for ( j = 0; j < sizeof( connections[ places[ i ] ] ); j += 2 ) {
         reset_eval_cost();
         add_shape( ({ centres[ places[ i ] ][ 0 ] -1 + sizes[ i ] *
               DIRS[ connections[ places[ i ] ][ j ] ][ 0 ][ 0 ],
               centres[ places[ i ] ][ 1 ] -1 + sizes[ i ] *
               DIRS[ connections[ places[ i ] ][ j ] ][ 0 ][ 1 ] }),
               DIRS[ connections[ places[ i ] ][ j ] ][ 1 ] );
         k = member_array( connections[ places[ i ] ][ j + 1 ], places );
         if ( k < 0 )
            continue;
         x = centres[ places[ i ] ][ 0 ] +
               DIRS[ connections[ places[ i ] ][ j ] ][ 0 ][ 0 ] *
               ( sizes[ i ] + sizes[ k ] );
         y = centres[ places[ i ] ][ 1 ] +
               DIRS[ connections[ places[ i ] ][ j ] ][ 0 ][ 1 ] *
               ( sizes[ i ] + sizes[ k ] );
         centres[ places[ k ] ] = ({ x, y });
         tell_object( find_player( "deutha" ), "Put "+
               connections[ places[ i ] ][ j + 1 ] +" at "+
               x +", "+ y +"\n" );
         reset_eval_cost();
      }
   }
} /* make_map() */
// --- END [/mnt/home2/grok/lib/obj/misc/easel.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/mortar_pestle.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/mortar_pestle.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627964   Available: 13575318
Inodes: Total: 5242880    Free: 4960134
819 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/mortar_pestle.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627964   Available: 13575318
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: mortar_pestle.c,v 1.2 2001/09/06 11:43:00 siel Exp $
 *
 *
 */

inherit "/obj/misc/grinder";

void setup() {
  set_name( "pestle" );
  set_short( "mortar and pestle" );
  set_long( "Roughly hewn from stone, the mortar's bowl has been "
      "smoothed from long use.  The stone pestle used for grinding "
      "herbs within the bowl is smooth as well and hangs from a "
      "leather thong tied through a ring in the side of the bowl.\n" );
  set_main_plural( "mortars and pestles" );
  add_adjective( ({ "mortar and", "rough", "stone", "smooth" }) );
  add_alias( ({ "mortar", "pestle", "bowl" }) );
  set_value( 800 );
  set_weight( 44 );
  set_max_grindable( 8 ); // eight stalks or ~ 1 lb. of stuff at once
  set_max_weight( 8 );    // It can hold what it can grind
}// --- END [/mnt/home2/grok/lib/obj/misc/mortar_pestle.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/keyring.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/keyring.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627964   Available: 13575318
Inodes: Total: 5242880    Free: 4960134
2336 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/keyring.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627964   Available: 13575318
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/container";

void create() {
   do_setup++;
   container::create();
   set_name( "keyring" );
   set_short( "keyring" );
   /* It's best to have this, just in case something happens because of a key. */
   add_property( "determinate", "a " );
   
   set_main_plural( "keyrings" );
   add_property("shop type", "jewellers");
   /* Feel free to override this and make it more interesting. */
   set_long( "This is a ring of metal that overlaps itself at one point, "
         "allowing keys to be strung onto it and be kept together.  It's "
         "amazing how useful a ring of metal can be.\n" );
   set_weight( 2 );
   set_value( 20 );
   set_max_weight( 1 );
   do_setup--;
   if (!do_setup)
      this_object()->setup();
} /* create() */

string long( string word, int dark ) {
   return ::long( word, dark ) +
         query_contents( "$C$"+ the_short() +" holds: " );
} /* long() */

mapping query_properties() {
   object thing;
   mixed arg, *args;
   mapping props, map;
   props = ::query_properties();
   args = copy( keys( props ) );
   foreach ( thing in find_inv_match( "", this_player() ) ) {
      map = (mapping)thing->query_properties();
      foreach ( arg in keys( map ) ) {
         if ( !stringp( arg ) ) {
            continue;
         }
         if ( member_array( arg, args ) != -1 ) {
            continue;
         }
         props[ arg ] = map[ arg ];
         args += ({ arg });
      }
   }
   return props;
} /* query_properties() */

mixed query_property( string word ) {
   object thing;
   mixed arg;

   arg = ::query_property( word );
   if ( arg ) {
      return arg;
   }
   foreach ( thing in find_inv_match( "", this_player() ) ) {
      arg = (mixed)thing->query_property( word );
      if ( arg ) {
         return arg;
      }
   }
   return 0;
} /* query_property() */

int test_add( object thing, int flag ) {
   if ( !thing->id( "key" ) && environment( thing ) ) {
      return 0;
   }
   return 1;
} /* test_add() */

int add_weight(int n) {
  int tmp, ret;
  
  if(sizeof(all_inventory(this_object())) >= 15)
    return 0;
  return ::add_weight(n);
} /* add_weight() */

mapping query_static_auto_load() {
   if ( explode( file_name(), "#" )[ 0 ] == "/obj/misc/keyring" ) {
      return int_query_static_auto_load();
   }
   return ([ ]);
} /* query_static_auto_load() */
// --- END [/mnt/home2/grok/lib/obj/misc/keyring.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/dead_book.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/dead_book.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627963   Available: 13575317
Inodes: Total: 5242880    Free: 4960134
1347 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/dead_book.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627963   Available: 13575317
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/book_dir";

#define DEAD_PAGES "/save/books/dead/dead_page"

void setup() {
  int i, max;

  seteuid(getuid());
  add_property("dead usable", 1);
  set_short("dark brown book");
  set_name("book");
  add_adjective( ({ "dark", "brown", "dead", "death", "dieing" }) );
  set_long("The book has some writing "
           "burnt into the dark brown leather cover.\n");
  add_read_mess("Introduction to death, or what to "
                "do when your blood runs out", 0, "general", 0 );
  set_book_language("general");
  set_book_dir(DEAD_PAGES);

  set_open_page(0);
} /* setup() */

void recovery_from_death() {
  call_out((: tell_object($1, the_short()+" crumbles and vanishes "
                              "mysteriously.\n") :), 1, previous_object());
  call_out("dest_me", 2);
} /* recovery_from_death() */

mixed query_static_auto_load() { return 0; }
mixed query_dynamic_auto_load() { return 0; }
mixed query_auto_load() { return 0; }

void check_location() {
  if (environment() &&
      !environment()->query_property("dead") &&
      !environment()->query_creator()) {
    say(the_short()+" vanishes suddenly and randomly.\n");
    call_out("dest_me", 1);
  }
} /* check_location() */

varargs int move(object dest, string mess1, string mess2) {
  ::move(dest, mess1, mess2);
  call_out("check_location", 1);
} /* move() */
// --- END [/mnt/home2/grok/lib/obj/misc/dead_book.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/cash_register.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/cash_register.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627962   Available: 13575316
Inodes: Total: 5242880    Free: 4960134
957 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/cash_register.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627962   Available: 13575316
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <money.h>

inherit "/std/container";

object shop;

object query_shop() { return shop; }

void set_shop( object thing ) { shop = thing; }

string long( string word, int dark ) {
   int i;
   string ret, *coins;
   object cash;
   ret = query_long();
   cash = present( MONEY_ALIAS, this_object() );
   if ( !cash )
      return ret +"There is no money in the register.\n";
   coins = (string *)cash->half_short( 1 );
   if ( !sizeof( coins ) )
      return ret +"There is no money in the register.\n";
   ret += "The register contains:\n";
   for ( i = 0; i < sizeof( coins ); i++ )
      ret += "      "+ coins[ i ] +"\n";
   return ret;
} /* long() */

int test_add( object thing, int flag ) {
   if ( !thing->id( MONEY_ALIAS ) )
      return 0;
   if ( shop )
      shop->save_register();
   return 1;
} /* test_add() */

int test_remove( object thing, int flag ) {
   if ( shop )
      shop->save_register();
   return 1;
} /* test_remove() */
// --- END [/mnt/home2/grok/lib/obj/misc/cash_register.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/dart_board.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/dart_board.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627962   Available: 13575316
Inodes: Total: 5242880    Free: 4960134
7823 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/dart_board.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627962   Available: 13575316
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*
** Dartboard, originally from LustyMUD, donated by Lusty, 
** patched to work under MudOS by Veronica, and changed 
** a bit by Shadowthief.
**
** 
** - I figured above credits were enough, and that they didn't
**   have to aslo coprise the entire long of the object.
** - Made it choose randomly from all creators instead of having 
**   a hard coded list of some.
** - Fixed the messages going to room and the players when a
**   game starts.
** - Commented out the add_command() that adds the syntax to
**   play for bets, as that feature isn't implemented anyway.
** - Cleaned up the code a bit.
**
** - Still needs improvement, though. -- May 2002, Tilly
*/

#include <player_handler.h>

inherit "/std/object";

string  *creators, name1, name2, target;
object  player1, player2;
int     score1, score2, in_use, thrown, bet;


/* Start of function prototypes */
void setup();
void init();
int abandon( string str );
string find_target();
int play( string str );
int throw_dart();
int score_it( int i );
void heart_beat();
void end_game();
/* End of function prototypes */

void setup() {
  set_name("dartboard");
    add_property( "there", "mounted on the wall" );
  add_adjective("party");
  set_main_plural("dartboards");
  set_short("party dartboard");
  set_long("This is a party dartboard.  It's round, with concentric "
    "circles in black and yellow painted on it.\n");
  set_weight(10000);
  set_value(0);
  reset_get();
  set_read_mess( 
    "This is a game of darts for two players. Before beginning "
    "their throws, the players must both type 'play'. Each player "
    "in turn can then throw three darts at the board (by typing "
    "'throw' three times). Note that your accuracy is affected "
    "by your DEX stat. The winner of the game is the player with the "
    "highest score after all darts have been thrown.\n" );
} /* setup() */


void init() {
  add_command("abandon", "", (:this_object()->abandon(""):));
  add_command("play", "", (:this_object()->play(0):));

  /* Commenting this one out since it obviously doesn't work anyway.
  add_command("play", "<word'bet'>", (:this_object()->play($4[0]):));
  */
  add_command("throw", "", (:this_object()->throw_dart():));
} /* init() */


int abandon( string str ) {
  if (this_player() == player1 || this_player() == player2) {
    write("You call off the game of darts.\n");
    say("The game of darts is called off by "
      + this_player()->query_short()+".\n");
    end_game();
    return 1;
  }
} /* abandon() */


string find_target() {
  string *creators, victim;

  creators = get_dir("/w/");
  victim = (creators[(random(sizeof(creators)))]);

  while (!PLAYER_HANDLER->test_user(victim) ) {
    victim = (creators[(random(sizeof(creators)))]);
}

  return capitalize(victim);
} /* find_target() */


int play( string str ) {
  int val;

  if (in_use) {
    write("The dartboard is in use right now.\n");
    return 1;
  }

  if (!str) str = "0";

  if (!sscanf(str, "%d", val) || val < 0) {
    write("Bets must be for zero or greater coins.\n");
    return 1;
  }

  if (this_player()->query_money() < val) {
    write("Betting is not yet supported... I'm working on it! "
   "Just type \"play\".\n");
    return 1;
  }

  if (player1) {
    if (this_player() == player1) {
      write("You can't play against yourself!\n");
      return 1;
    }

    if (val != bet) {
      write("Bet amounts must match. " + name1 + " bet " + bet + ".\n");
      return 1; 
    }

    player2 = this_player();
    name2 = player2->query_short();
    target = find_target();
    tell_room( environment(), name1 + " and " + name2 + 
      " have started a game of darts, throwing at " + target 
      + ".\n", ({ player1, player2 }) );
    tell_object( player2, "You accept " + name1 + "'s challenge, "
      "and you both prepare to throw darts at " + target + ".\n" );
    tell_object( player1, name2 + " accepts your challenge, and you "
      "both prepare to throw darts at " + target + ".\nThrow your darts.\n");

    in_use = 1;
    return 1;
  }
 
  bet = val;

  player1 = this_player();
  name1 = player1->query_short();

  write("You can 'abandon' the game if no one takes up your challenge.\n");
  say( name1 + " is looking for someone else to play darts with.\n");

  set_heart_beat(1);
  return 1;
} /* play() */


int throw_dart() {
  int hit;
  string start;

  if (!in_use)  {
     return notify_fail( "You are not currently playing.\n ");
  }
  if (this_player() != player1 && this_player() != player2)  {
     return notify_fail( "You are not currently playing.\n" );
  }

  if (in_use == 1 && this_player() == player1) {
    thrown += 1;

    write("You throw a dart.\n");
    say( name1 + " throws a dart.\n" );

    hit = score_it(random(21) + ((player1->query_dex() -13 ) / 2 ));

    if (hit == 500 && bet >= 50) {
      write("You feel a bit more experienced.\n");
      player1->ajdust_xp(10);
    }

    score1 += hit;

    if (thrown == 3) {
      write("That was your third dart. Your score is " + score1 + ".\n");
      say(name1 + " has a score of " + score1 + " after three darts.\n");
      if (player2) tell_object(player2, "Your turn to throw.\n");
      in_use = 2;
    }

    return 1;
  }

  if (in_use == 2 && this_player() == player2) {
    thrown += 1;

    write("You throw a dart.\n");
    say(name2+ " throws a dart.\n" );

    hit = score_it(random(21) + ((player2->query_dex() - 13 ) / 2 ));

    if (hit == 500 && bet >= 50) {
      write("You feel a bit more experienced.\n");
      player2->adjust_xp(10);
    }

    score2 += hit;

    if (thrown == 6) {
      write("That was your third dart.\n");

      if (score1 > score2) {
        start = " with a score of " + score1 + " to " +
          score2 + ".\n";
        write(name1 + " beats you" + start);
        tell_room( environment(), name1 + " beats " + name2 + start,
                ({ player1, player2 }));
        tell_object(player1, "You beat " + name2 + start);
      } else if (score2 > score1) {
        start = " with a score of " + score2 + " to " +
          score1 + ".\n";
        write("You beat " + name1 + start);
        tell_room( environment(), name2 + " beats " + name1 + start,
                    ({ player1, player2 }));
        tell_object(player1, name2 + " beats you" + start);
      } else {
        tell_room(environment(this_object()),
          "It's a tie with a score of " + score1 + "!\n");
      }

      end_game();
    }

    return 1;
  }

  write("It's not your turn to throw a dart!\n");
  return 1;
} /* throw_dart() */


int score_it( int i ) {
  string rest_mess;
  int ret;

  if (i < 2) {
    rest_mess = "the wall. No score.\n";
    ret = 0;
  } else if (i < 19) {
    rest_mess = "number "+i+", scoring "+(i*5)+".\n" ;
    ret = i * 5;
  } else if (i == 19) {
    rest_mess =  target+"'s face! Score of 250!\n";
    ret = 250;
  } else {
    rest_mess = target+"'s nose! Score of 500!\n";
    ret = 500;
  }

  write("You hit " + rest_mess);
  say( this_player()->query_short() + " hit " + rest_mess);

  return ret;
} /* score_it() */


void heart_beat() {
  if (!player1) player1 = find_player(lower_case(name1));
  if (name2 && !player2) player2 = find_player(lower_case(name2));

  if (!player1 || environment() != environment(player1))
    say(name1 + " is no longer here. The game of darts is called off.\n");
  else if (name2 && (!player2 || environment() != environment(player2)))
    say(name2 + " is no longer here. The game of darts is called off.\n");
  else
    return;

  end_game();
} /* heart_beat() */


void end_game() {
  set_heart_beat(0);
 
/*  if (player1) player1->add_money(bet);
  if (player2) player2->add_money(bet); */

  in_use  = 0; bet    = 0; thrown  = 0;
  player1 = 0; player2 = 0;
  name1  = 0; name2  = 0;
  score1  = 0; score2  = 0;
} /* end_game() */

// --- END [/mnt/home2/grok/lib/obj/misc/dart_board.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/traps/powder_trap.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/traps/powder_trap.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627960   Available: 13575314
Inodes: Total: 5242880    Free: 4960134
1039 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/traps/powder_trap.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627960   Available: 13575314
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/obj/misc/trap";

void setup() {
   set_name("trap");
   set_weight(1);
   set_short("anthrax trap");
   add_adjective("anthrax");
   set_long("This is a anthrax trap suitable for rigging inside "
            "the lock of a door. It uses a small envelope that "
            "will open in the face of anyone clumsily picking "
            "the lock.\n");
   make_trap(200, "pick",
             "Hidden inside the lock is a small envelope "
             "which, if touched by an clumsily wielded tool "
             "will open up and infect an unwary thief.\n",
             ({"A small envelope opens up and a puff of powder "
                "explodes into your face, which you inadvertantly "
                "inhale. The envelope has \"Congratulations! You've "
                "Been Infected With Anthrax!\" written in bold "
                "cheery letters.\n",
                 "A cloud of powder puffs out of the lock.\n" }),
             ({ "/std/effects/disease/common_cold", 6000 }));
   set_value(10000);
} /* setup() */
// --- END [/mnt/home2/grok/lib/obj/misc/traps/powder_trap.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/traps/fast_acting_needle_trap.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/traps/fast_acting_needle_trap.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627959   Available: 13575313
Inodes: Total: 5242880    Free: 4960134
901 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/traps/fast_acting_needle_trap.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627959   Available: 13575313
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/obj/misc/trap";

void setup() {
   set_name("trap");
   set_weight(1);
   set_short("fast-acting needle trap");
   add_adjective(({ "fast-acting", "fast", "acting", "needle" }));
   set_long("This is a needle trap suitable for rigging inside "
            "the lock of a door. It uses a small needle that "
            "will inject a fast acting poison into anyone "
            "clumsily picking "
            "the lock.\n");
   make_trap(250, "pick",
             "Hidden inside the lock is a small mechanism "
             "which, if touched by an clumsily wielded tool "
             "will cause a small needle to swing out and poison "
             "an unwary thief.\n",
             ({"A small needle swings out of the lock injecting "
                 "poison.\n",
                 "A small needle sings out of the lock.\n" }),
             500);
   set_value(80000);
} /* setup() */
// --- END [/mnt/home2/grok/lib/obj/misc/traps/fast_acting_needle_trap.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/traps/gas_trap.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/traps/gas_trap.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627959   Available: 13575313
Inodes: Total: 5242880    Free: 4960134
774 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/traps/gas_trap.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627959   Available: 13575313
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/obj/misc/trap";

void setup() {
   set_name("trap");
   set_weight(1);
   set_short("gas trap");
   add_adjective("gas");
   set_long("This is a gas trap suitable for rigging inside "
            "the lock of a door. It uses a small ampule of "
            "poison gas that is ejected by someone attempting "
            "to pick the lock.\n");
   make_trap(300, "pick",
             "Hidden inside the lock is a small ampule which, "
             "if touched by an unwary tool would trigger a "
             "puff of poisonous gas.",
             ({"A small cloud of gas puffs out of the lock.\n",
                 "A small cloud of gas puffs out of the lock.\n"}),
             ({"/std/effects/poisons/poison_gas", 600}));

   set_value(120000);
} /* setup() */
// --- END [/mnt/home2/grok/lib/obj/misc/traps/gas_trap.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/traps/leg_trap.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/traps/leg_trap.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627959   Available: 13575313
Inodes: Total: 5242880    Free: 4960134
1487 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/traps/leg_trap.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627959   Available: 13575313
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/obj/misc/trap";

// Note: This trap is not suitable to be sold for players to add to their
// doors since it requires a hold in the floor and so would have to be
// custom installed!
// Ceres (no, I did not write it!)

void setup() {
   set_name("trap");
   set_weight(1);
   set_short("leg trap");
   add_adjective("leg");
   set_long("This trap has a trigger suitable for rigging inside "
            "the lock of a door. It uses a small portion of the floor "
            "in front of the door to conceal a blunt leg trap that will "
            "shatter the femurs of any clumsy thief that attempt to "
            "pass through.\n");
   make_trap(350, "pick",
             "Hidden inside the lock is a trigger that leads down to a "
             "concealed panel on the floor. Carefully lifting the panel "
             "you see a vicious blunt man trap, designed to break any "
             "unskilled questionable entrant.\n",
             ({"A small click is heard, and the floor beneath your feet "
               "snaps away to reveal a leg trap which snaps together "
               "violently, shattering both your legs at once!\n",
               "A small click is heard and the jaws of a man trap burst out "
               "of the ground below " + this_player()->query_short() + "'s "
               "feet and shatters both of their legs!\n" }),
             ({ "/std/effects/disease/broken_leg", ({ "left", "right"}) }));
   set_value(1000000);
} /* setup() */
// --- END [/mnt/home2/grok/lib/obj/misc/traps/leg_trap.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/traps/needle_trap.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/traps/needle_trap.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627958   Available: 13575312
Inodes: Total: 5242880    Free: 4960134
863 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/traps/needle_trap.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627958   Available: 13575312
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/obj/misc/trap";

void setup() {
   set_name("trap");
   set_weight(1);
   set_short("needle trap");
   add_adjective("needle");
   set_long("This is a needle trap suitable for rigging inside "
            "the lock of a door. It uses a small needle that "
            "will inject poison into anyone clumsily picking "
            "the lock.\n");
   make_trap(200, "pick",
             "Hidden inside the lock is a small mechanism "
             "which, if touched by an clumsily wielded tool "
             "will cause a small needle to swing out and poison "
             "an unwary thief.\n",
             ({"A small needle swings out of the lock injecting "
                 "poison.\n",
                 "A small needle sings out of the lock.\n" }),
             ({ "/std/effects/poisons/spider_venom", 30 }));
   set_value(20000);
} /* setup() */
// --- END [/mnt/home2/grok/lib/obj/misc/traps/needle_trap.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/wearable_corpse.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/wearable_corpse.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627958   Available: 13575312
Inodes: Total: 5242880    Free: 4960134
1348 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/wearable_corpse.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627958   Available: 13575312
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * Wearable corpse for wearable pets!
 * 
 * To use this, you need to put a make_corpse function in your pet that
 * clones this object and sets it up as per a standard corpse.
 *
 * You should also call: set_type, set_max_cond and set_cond on it!
 *a
 * @author Terano
 * @started 24/11/02
 */

inherit "/obj/corpse";
inherit "/std/basic/wearable";

void create() {
  corpse::create();
  wearable::create();
}

string long( string word, int dark ) {
  return corpse::long( word, dark ) + wearable::long( word, dark );
}

void init_static_arg( mapping map ) {
   if ( map[ "corpse" ] )
      corpse::init_static_arg( map[ "corpse" ] );
   if ( map[ "wearable" ] )
      corpse::init_static_arg( map[ "wearable" ] );
}

void init_dynamic_arg( mapping map ) {
 if ( !undefinedp( map[ "corpse" ] ) ) 
      corpse::init_dynamic_arg( map[ "corpse" ] );

 if ( !undefinedp( map[ "wearable" ] ) ) 
      wearable::init_dynamic_arg( map[ "wearable" ] );
}

mapping query_static_auto_load() {
   return ([
      "corpse" : corpse::query_static_auto_load(),
      "wearable" : wearable::query_static_auto_load(),
   ]);
}

mapping query_dynamic_auto_load() {
   return ([
      "corpse" : corpse::query_dynamic_auto_load(),
      "wearable" : wearable::query_dynamic_auto_load()
   ]);
}

mixed *stats() {
	return corpse::stats() + wearable::stats();
}
// --- END [/mnt/home2/grok/lib/obj/misc/wearable_corpse.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/beeswax_candle.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/beeswax_candle.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627957   Available: 13575311
Inodes: Total: 5242880    Free: 4960134
874 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/beeswax_candle.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627957   Available: 13575311
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: beeswax_candle.c,v 1.2 2001/11/14 12:06:25 siel Exp $
 *
 *
 */

inherit "/std/lightable";

void setup() {
   set_name( "candle" );
   set_short( "beeswax candle" );
   add_adjective( "beeswax" );
   set_long( "This is a small candle, like you'd "
         "see on a birthday cake.  It is quite soft and "
         "squidgy.\n" );
   set_fuel_messages( ({
         "It is almost burnt to a stub.", 10,
         "It is more than halfway burnt.", 50,
         "It is not yet halfway burnt.", 85,
	 "It is almost new.", 99,
         "It is new.", 100
         }) );
   set_empty_mess( "is burnt to a stub." );
   set_max_fuel( 900 );
   set_fuel( 900 );
   set_brightness( 60 );
   set_value( 400 );
   set_hold_required( 1 );
   add_property( "no recycling", 1 );
   new_weapon( 10 );
   set_weight( 1 );
   set_hide_cond( 1 );
}
// --- END [/mnt/home2/grok/lib/obj/misc/beeswax_candle.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/pawn_receipt.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/pawn_receipt.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627957   Available: 13575311
Inodes: Total: 5242880    Free: 4960134
15096 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/pawn_receipt.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627957   Available: 13575311
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming

/*
 * This is a pawned item receipt.
 * It can be turned back into its item if reclaimed at a pawn shop.
 * Based heavily on /obj/misc/al_receipt.c
 *
 * Vashti 22nd September 2002
 */

#include <am_time.h>
#include <armoury.h>
#include <money.h>
#include <move_failures.h>
#include <player.h>
#include <virtual.h>

#define TO this_object()
#define TP this_player()

inherit "/obj/misc/paper" ;

private int    _expired ;
private int    _expired_sold ;
private int    _expiry_time ;
private int    _item_value, _obplural ;
private int    _timestamp;
private mixed  _static_save;
private string _obname, _obpath, _obshort ;
private string _shop_path, _virt_name ;

object do_kiss();


/** @ignore yes */
void setup() {
    set_name( "receipt" );
    set_short( "pawned item receipt" ) ;
    add_adjective( ({ "pawned", "item" }) );
    set_long( "This is a small slip of paper, with a black border.\n" );
    set_main_plural( "pawned item receipts" ) ;
    add_plural( "receipts" );
    add_adjective( "pawned" ) ;
    set_value( 0 ) ;
    set_weight( 1 );
  
    _obname = "unknown object";
    _obpath = "***";
    _timestamp = time();
} /* setup */


/** @ignore yes */
void init() {
    add_command( "reclaim", "<direct:object:me'receipt'>" ) ;
} /* init */


/** @ignore yes */
void reset() {
    object item ;
    
    if ( ( ! _expired ) && time() > _expiry_time ) {
        _expired = 1 ;
        set_short( "expired pawned item receipt" ) ;
        add_adjective( "expired" ) ;
        
        if ( ! _expired_sold ) {
            _expired_sold = 1 ;
            item = do_kiss() ;
            if ( item ) {
                item->move( _shop_path->query_store_room() ) ;
            }
        }
    }
} /* reset */


/**
 * This sets the short of the pawned object.
 */
void set_obshort( string s ) {
  _obshort = s;
} /* set_obshort */


/**
 * This returns the short of the pawned object.
 * @return [string] The short of the pawned object.
 */
string query_obshort() {
  return _obshort;
} /* query_obshort */


/**
 * This sets the time at which this receipt will die.
 * @param time The time in seconds when this receipt will be killed.
 */
void set_expiry_time( int time ) {
    _expiry_time = time ;
} /* set_expiry_time */


/**
 * This returns the Unix time in seconds at which this receipt will expire.
 * @return [int] The time of death in seconds.
 */
int query_expiry_time() {
    return _expiry_time ;
} /* query_expiry_time */


/**
 * This sets the value of the item this receipt is based on.
 * @param value The value of the original item.
 */
void set_item_value( int value ) {
    _item_value = value ;
} /* set_item_value */


/**
 * This returns the value of the item this receipt was based on.
 * @return [int] the value of the original item.
 */
int query_item_value() {
    return _item_value ;
} /* query_item_value */


/**
 * This allows us to set the path of the shop that spawned us, so that this
 * receipt can only be redeemed at that shop.
 * @param shop - either a shop object or a string path.
 */
void set_shop_path( mixed shop ) {
    if ( objectp( shop ) ) {
        _shop_path = base_name( shop ) ;
        return ;
    }
    
    _shop_path = shop ;
    return ;
} /* set_shop_path */


/**
 * This returns the path to the shop that this receipt was spawned by.
 * @return [string] the path to the cloning shop.
 */
string query_shop_path() {
    return _shop_path ;
} /* query_shop_path */


/**
 * Sets the name of the object.  This will be used so the item recipt
 * can be identified.
 * @param name the object name
 */
void set_obname( string name ) {
    _obname = name;
} /* set_obname */


/**
 * Sets the path to the object.  The path of the object for the recipt to
 * work with.
 * @param path the object path
 */
void set_object( string path ) {
    _obpath = path;
} /* set_object */


/**
 * This method sets the virtual object name of the item.
 * @param name the virtual object name
 */
void set_virtobname( string name ) {
    _virt_name = name;
} /* set_virtobname */


/**
 * This method returns the name of the object.
 * @return the name of the object
 */
string query_obname() {
    return _obname;
} /* query_obname */


/**
 * This method returns the path of the object.
 * @return the path of the object
 */
string query_obpath() {
    return _obpath;
} /* query_obpath */


/**
 * This method returns the timestamp of the reciept.  This is the time the
 * receipt was created.
 * @return the timestamp
 */
int query_timestamp() {
    return _timestamp;
} /* query_timestamp */


/**
 * This method returns the virtual object path name of the item.
 * @return the virtual object name
 */
string query_virt_obname() {
    return _virt_name;
} /* query_virt_obname */


/**
 * This method returns the save information for the object.  THis is not
 * just the static save information, it is an array of two elements.  The
 * first is the static save information and the second is the dynamic
 * save information.
 * @return the save information
 */
mixed query_static_save() {
  return _static_save;
} /* query_static_save */


/**
 * This allows us to check if the object is a pawned item receipt.
 * @return 1 if the object is a pawned item receipt.
 */
int query_pawned_item_receipt() {
    return 1 ;
} /* query_pawned_item_receipt */


/**
 * This method sets the save information for the file.  It actually sets
 * both the static and dynamic information.  This assumes it is passed
 * an array of two elements, the first is the static save information and
 * the second is the dynamic save information.
 * @param args the data as defined above
 */
void set_static_save( mixed args ) {
  mixed p;

  _static_save = args;
  if (_obname != "unknown object") {
    return;
  }

  // Try to find the short in here somewhere
  p = args[0];
  while (mapp(p)) {
    if (!undefinedp(p["short"])) {
      _obname = p["short"];
      return;
    }
    p = p["::"];
  }
}


/**
 * This sets whether or not our object is actually a collective,
 * and so more than one object.
 */
void set_object_plural( object ob ) {
  if ( ob->query_collective() && ob->query_amount() > 1 ) {
    _obplural = 1;
  } else {
    _obplural = 0;
  }
} /* set_plural */


/**
 * This lets us check whether or not our object is a plural object.
 */
int query_object_plural() {
  return _obplural;
} /* query_plural */


/**
 * This returns a short which is accurate for both ordinary and
 * collective objects.
 */
string query_correct_short( object ob ) {
    if ( ! ob ) {
      return 0;
    }

    set_object_plural( ob );
    if ( _obplural ) {
      return pluralize( ob->query_short() );
    }
  
    return ob->query_short();
} /* query_correct_short */


/**
 * This method sets up the receipt for the specified object.
 * @param ob the object to setup the reciept for
 */
void setup_receipt( object ob ) {
   mixed* bits;

   bits = AUTO_LOAD_OB->fragile_auto_str_ob(ob);
   set_obname(ob->query_name());
   set_obshort( query_correct_short( ob ) );
   set_object(bits[1]);
   set_static_save(bits[2]);
} /* setup_receipt() */


/**
 * This takes a sentence and pluralises it appropriately.
 * @parma text The sentence to pluralise.
 * @param plural Whether or not the sentence should be in plural form.
 */
string pluralize_sentence( string text, int plural ) {
  if ( plural ) {
    return replace( text, ({
      "$o", "them",
      "$r", "they",
      "$ve", "ve"
    }) );
  }
  
  return replace( text, ({
    "$o", "it",
    "$r", "it",
    "$ve", "s"
  }) );
} /* pluralize_sentence */


/** @ignore yes */
string query_details() {
    if ( _expired ) {
        return pluralize_sentence(
          "This is a receipt for your pawned " + query_obshort() + ".\n"
          "Sadly, you have left it too long to collect $o and $r ha$ve "
          "expired, so the shop will put $o up for sale.  Better hurry to "
          + _shop_path->the_short() + " sharpish and try to buy $o back!",
          _obplural );
    }
    
    return pluralize_sentence(
      "This is a receipt for your pawned " + query_obshort() + ".\n"
      "You must reclaim $o from " + _shop_path->the_short() + " before "
      + AM_TIME_HANDLER->query_am_time( _expiry_time ) + " or $r will "
      "be sold.", _obplural );
}

/**
 * This sets up a message for us to get when we read the receipt.
 * Because we're using a function pointer, add_read_mess doesn't work.
 * @param lang The language to produce the message in.
 */
mixed *query_read_mess() {
  string lang;
  
  if ( _shop_path ) {
    lang = _shop_path->query_language();
  } else {
    lang = "general";
  }
  
  return ::query_read_mess()
    + ({ ({ (: query_details() :), "neat printing", lang, 0 }) });
} /* query_read_mess */


/** @ignore yes */
mapping query_dynamic_auto_load()
{
   return ([
     "::"         : ::query_dynamic_auto_load(),
     "obname"     : _obname,
     "obpath"     : _obpath,
     "obvalue"    : value,
     "virt"       : _virt_name,
     "timestamp"  : _timestamp,
     "static"     : _static_save,
     "been sold"  : _expired_sold,
     "expired"    : _expired,
     "expires on" : _expiry_time,
     "item value" : _item_value,
     "item short" : _obshort,
     "item plural": _obplural,
     "shop path"  : _shop_path
  ]);
} /* query_dynamic_auto_load() */


/** @ignore yes */
void init_dynamic_arg(mapping arg, object) {
   _obname = arg["obname"];
   if ( stringp( _obname ) ) {
       add_adjective( explode( lower_case( _obname ), " " ) );
   }
   _obpath = arg["obpath"];
   set_value(arg["obvalue"]);
   _virt_name = arg["virt"];
   _timestamp = arg["timestamp"];
   _static_save = arg["static"];
   _expired = arg["expired"] ;
   _expired_sold = arg["been sold"] ;
   _expiry_time = arg["expires on"] ;
   _item_value = arg["item value"] ;
   _obshort = arg["item short"];
   _obplural = arg["item plural"];
   _shop_path = arg["shop path"] ;
   ::init_dynamic_arg(arg["::"]);

   if ( _expired ) {
       set_short( "expired pawned item receipt" ) ;
       add_adjective( "expired" ) ;
       set_main_plural( "expired pawned item receipts" ) ;
       add_plural( "pawned item receipts" ) ;
   }
}


/** @ignore yes */
mixed *stats() {
  mixed *stuff;

  stuff = ::stats() + ({
      ({ "obname", _obname }),
      ({ "obpath", _obpath }),
      ({ "timestamp", _timestamp + " (" + ctime(_timestamp) + ")" }),
      ({ "been sold", _expired_sold }),
      ({ "expired", _expired }),
      ({ "expires on", _expiry_time }),
      ({ "item short", _obshort }),
      ({ "item value", _item_value }),
      ({ "item plural", _obplural }),
      ({ "shop path", _shop_path })
   });
  if (_virt_name)
    stuff += ({ ({ "virtname", _virt_name }) });
    
  return stuff;
} /* stats */


/** @ignore yes */
object do_kiss() {
    object thing;

    if (sizeof(_static_save) < 2) {
        if (this_player()->query_creator()) {
            write("This receipt has no auto-load information, possibly "
                  "because the object was broken when the player logged "
                  "out.  It will have to be replaced by hand.\n");
        } else {
            write("Sorry, but this object is too broken to repair "
                  "with a kiss.  You'll have to contact a creator.\n");
        }
        return 0;
    }

    // If we have virtual names, try and fiddle with this.
    if (_virt_name) {
       _virt_name = CLONER->other_file( _virt_name );
       if (file_size(_virt_name) <= 0) {
          // try and rewrite through the armoury
          _virt_name = ARMOURY->remap_file_path(_virt_name);
       }
       if (file_size(_virt_name) <= 0) {
           write("The receipt whispers: Sorry, I'm still broken.  "
                 "Try again some other time, or contact a creator.\n");
           return 0;
       }
    }

    if ( !catch( thing = (object)CLONER->clone( _obpath ) ) ) {
        if ( thing ) {
            thing->init_static_arg(_static_save[0]);
            thing->init_dynamic_arg(_static_save[1]);
            thing->add_property(VIRTUAL_NAME_PROP, _virt_name);
            move("/room/rubbish");
            return thing;
        } else {
            write("The receipt whispers: I'm going to need some "
                  "creator help.\n");
            thing->dest_me();
        }
    } else {
         write("The receipt whispers: Sorry, I'm still broken.  "
               "Try again some other time, or contact a creator.\n");
    }

    return 0;
} /* do_kiss() */


/**
 * This handles all the reclaiming of objects that have been pawned.
 */
int do_reclaim() {
    int cost, i ;
    object change, item ;
    string change_str, place ;
    
    /* Make sure we're a pawned item receipt */
    if ( ! query_pawned_item_receipt() ) {
        add_failed_mess( "$D is not a pawned item receipt.\n" ) ;
        return 0 ;
    }
    
    /* Make sure we're in the right place */
    if ( base_name( environment( TP ) ) != _shop_path ) {
        add_failed_mess(
            "This is not the right place for you to reclaim $D.  "
            "Try a pawn shop.\n" ) ;
        return 0 ;
    }

    /* Make sure that place is open for business */
    if ( ! environment( TP )->is_open( TP, 0 ) ) {
        return 0;
    }
    
    /* Make sure the receipt hasn't expired */
    if ( _expired ) {
        add_failed_mess( "Oh dear, your receipt has expired.  With luck, your "
            + query_obshort() + " will be available for sale in the shop.\n" ) ;
        return 0 ;
    }
    
    /* Do the money transfer thing */
    place = query_property( "place" ) ;
    if ( ! place || ( place == "" ) ) {
        place = "default" ;
    }
    
    cost = ( ( 100 + _shop_path->query_pawn_markup() ) * _item_value ) / 100 ;
    debug_printf( "cost = %d, _item_value = %d, markup = %d",
        cost, _item_value, _shop_path->query_pawn_markup() ) ;

    if ( TP->query_value_in( place ) < cost ) {
        add_failed_mess( "You don't have enough money to reclaim $D.  "
            "It would cost you "
            + MONEY_HAND->money_value_string( cost, place ) + "\n" ) ;
        return 0 ;
    }

    change = MONEY_HAND->pay_amount_from( cost, TP, place ) ;
    if ( change ) {
        change->move( TP ) ;
        change_str = change->short() ;
    }

    /* Make the receipt back into what it should be */
    item = do_kiss();
    if ( ! item ) {
        add_failed_mess(
          "Oh dear, your item doesn't seem to be here any more.  "
          "Please contact a liaison.\n" );
        return 0;
    }
    
    i = item->move( TP );
    if ( i != MOVE_OK ) {
        tell_object( TP, "You're too heavily burdened to accept "
          + item->the_short() + ", so it is placed on the floor for you.\n" );
        item->move( environment(TP) );
    }
    
    add_succeeded_mess( ({
        "$N $V " + item->the_short() + " for "
          + MONEY_HAND->money_value_string( cost, place )
          + ( change_str ? " and receive " + change_str + " in change" : "" )
          + ".\n",
        "$N $V $D and receives " + item->the_short() + " in exchange.\n"
    }) ) ;

    return 1 ;
} /* do_reclaim */
// --- END [/mnt/home2/grok/lib/obj/misc/pawn_receipt.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/buckets/.bucket_small.ob_virtual_.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/buckets/.bucket_small.ob_virtual_.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627953   Available: 13575307
Inodes: Total: 5242880    Free: 4960134
1154 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/buckets/.bucket_small.ob_virtual_.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627953   Available: 13575307
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <virtual.h>

void dest_me() { destruct( this_object() ); }

void create()
{
  seteuid( (string)"/secure/master"->creator_file( file_name( this_object() ) ) );
} /* create() */

object create_virtual_ob() {
   object clone;

  clone = (object)SERVER->create_virtual_object( "/obj/vessel.c", 1 );
  clone->add_property( VIRTUAL_NAME_PROP, "/obj/misc/buckets/bucket_small.ob#1" );
  call_other( clone, "set_name",  "bucket"  );
  call_other( clone, "set_short",  "small bucket"  );
  call_other( clone, "set_long",  "This is a small metal bucket.  It is not very shiny.\n"  );
  call_other( clone, "set_main_plural",  "small buckets"  );
  call_other( clone, "add_adjective",  "small"  );
  call_other( clone, "add_plural",  "buckets"  );
  call_other( clone, "set_stuck",  1  );
  call_other( clone, "set_leak_rate",  0  );
  call_other( clone, "set_max_volume",  3000  );
  call_other( clone, "set_max_weight",  30  );
  call_other( clone, "set_full_weight",  30  );
  call_other( clone, "set_value",  85  );
  call_other( clone, "set_weight",  10  );
  call_other( clone, "set_material",  "metal" );
   return clone;
} /* create_virtual_ob() */
// --- END [/mnt/home2/grok/lib/obj/misc/buckets/.bucket_small.ob_virtual_.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/press_credentials.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/press_credentials.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627952   Available: 13575306
Inodes: Total: 5242880    Free: 4960134
2529 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/press_credentials.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627952   Available: 13575306
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: press_credentials.c,v 1.7 2001/08/17 08:39:25 pinkfish Exp $
 *
 *
 */

inherit "/obj/clothing";

private string _owner = "someone";
private string _paper;

void set_owner_stuff();
void update_stuff();

void setup() {
   add_property("press credentials",1);
   set_name( "badge" );
   set_short( "press credentials badge" );
   add_adjective( ({ "press", "credentials" }) );
   add_alias( "badge" );
   add_property( "nosteal", 1 );
   add_alias( "credentials" );
   set_type( "badge" );
   setup_clothing( 1000 );
   set_weight( 1 );
   reset_drop();
   set_wear_remove_func(base_name(this_object()), "wear_badge");
} /* setup() */

void init() {
   if( _owner == "someone" ) {
      update_stuff();
   }
   if( this_player()->query_name() == lower_case(_owner) ) {
      add_command( "show", "<direct:object:me'credentials'>");
   }
} /* init() */

void wear_badge(object ob, object player) {
   if (!ob) {
      if (player) {
         player->remove_title("newspaper");
      }
   } else if (_paper) {
      player->set_title("newspaper", "Reporter for " + _paper);
   }
} /* wear_badge() */

void set_owner_stuff() {
   set_long( "This is a small badge with a hand-drawn picture of " +
     _owner + " on it, underneath the logo of " + _paper + ".  "
     "Emblazoned along the bottom are the words \"Official Reporter\".\n");

   if (query_worn_by()) {
      query_worn_by()->set_title("newspaper", "Reporter for " + _paper);
   }
} /* set_owner_stuff() */

int do_show() {
   add_succeeded_mess( ({ "With a practiced flick of your wrist, you display "
     "your press credentials to the room.\n", "With a practiced flick of $p "
     "wrist, $N whips out $p press credentials for " + _paper +
     " and shows them to "
     "everybody.\n" }) );
   return 1;
} /* do_show() */

void set_paper_name(string paper) {
   _paper = paper;
} /* set_paper_name() */

string query_paper_name() {
   return _paper;
} /* query_paper_name() */

void update_stuff() {
   object ob;

   ob = environment();
   if( ob && living( ob ) ) {
      _owner = ob->query_cap_name();
   }
   set_owner_stuff();
} /* update_stuff() */

mapping query_dynamic_auto_load() {
   return ([
     "::" : ::query_dynamic_auto_load(),
     "cred owner" : _owner,
     "paper" : _paper
   ]);
} /* query_dynamic_auto_load() */

void init_dynamic_arg( mapping map ) {
   _paper = map["paper"];
   _owner = map["cred owner"];
   ::init_dynamic_arg( map[ "::" ] );
   set_owner_stuff();
} /* init_dynamic_arg() */
// --- END [/mnt/home2/grok/lib/obj/misc/press_credentials.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/dead_eel.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/dead_eel.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627951   Available: 13575305
Inodes: Total: 5242880    Free: 4960134
2943 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/dead_eel.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627951   Available: 13575305
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: dead_eel.c,v 1.2 2001/11/14 13:46:23 siel Exp $
 *
 *
 */


#include <move_failures.h>

#define EEL_SKIN "/obj/misc/eel_skin"

inherit "/obj/food";

void    setup();
void    init();
int     do_skin( object *indirect_obs, string indir_match, string dir_match, 
                 mixed *args, string pattern );
int     test_sharp( object weapon ); 
mixed   query_dynamic_auto_load();
void    init_dynamic_arg(mapping arg, object);

int skinned; /* 1 = the dead eel is already skinned */

void setup()
{
  set_name( "eel" );
  set_short( "dead eel" );
  add_alias( ({ "corpse", "eel corpse" }) );
  add_adjective( "dead" );
  set_main_plural( "dead eels" );
  set_long( function()
	    {
	      if( skinned ) 
		return
		  "This is the dead body of an unfortunate eel.  "
		  "As if being dead wasn't bad enough, it has also "
		  "been skinned.\n";
	      return
		  "This is the dead body of an unfortunate eel.  "
		  "Most people skin such a fish before eating it.\n";
	    } );
  set_weight( 60 ); /* Wrestling eels are big */
  set_value( 200 );
  set_weight_per_bite( 2 );
}

void init()
{
  ::init();
  this_player()->add_command( "skin", this_object(),
        "<direct:object:me-here> with <indirect:object:me>" );
}

int do_skin( object *indirect_obs, string indir_match, string dir_match, 
   mixed *args, string pattern )
{
  object skin;

  if ( skinned ) return notify_fail( "The eel is already skinned.\n" );
  if( !test_sharp( indirect_obs[0] ) )
    {
      tell_room( environment( this_player() ),
	     this_player()->one_short() + " unsuccessfully tries to "
             "skin an eel with " + indirect_obs[0]->one_short() + ".\n",
             this_player() );
      return notify_fail( indirect_obs[0]->the_short() +
            " only makes a shallow mark in the eel skin.  "
            "It would probably be easier to skin the eel "
            "with some kind of sharp implement.\n" );
    }
  skinned = 1;
  skin = clone_object( EEL_SKIN );
  if( MOVE_OK != skin->move( this_player() ) )
        skin->move( environment() );
  tell_room( environment( this_player() ),
        this_player()->one_short() + " skins an eel with "
        + indirect_obs[0]->one_short() + ".\n",
        this_player() );
  return notify_fail( "You skin the dead eel with " +
        indirect_obs[0]->the_short() + ".\n" );
}

int test_sharp( object weapon )
{
  int i;
  mixed *pongo;

  pongo = weapon->weapon_attacks();
  for( i = 1; i < sizeof( pongo ); i++ )
    {
      if( pongo[i] == "sharp" ) return 1; /* Ok, it's a sharp weapon */
    }
  return 0; /* Not a sharp weapon */

} /* test_sharp */

mixed query_dynamic_auto_load() {

  return ([ "::" : ::query_dynamic_auto_load(),
            "skinned" : skinned ]);
} /* query_dynamic_auto_load() */

void init_dynamic_arg(mapping arg, object) {

  ::init_dynamic_arg(arg["::"]);
  skinned = arg["skinned"];

} /* init_dynamic_arg() */
// --- END [/mnt/home2/grok/lib/obj/misc/dead_eel.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/terrain_shovel.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/terrain_shovel.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627950   Available: 13575304
Inodes: Total: 5242880    Free: 4960134
3996 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/terrain_shovel.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627950   Available: 13575304
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <dirs.h>
#include <terrain.h>

inherit "/std/object";

void setup() {
   set_name( "shovel" );
   set_short( "ceremonial shovel" );
   add_adjective( "ceremonial" );
   set_long( "This is a small ceremonial shovel, carried by those "+
         "responsible for the care, upkeep and expansion of "+
         "dungeons.\n" );
} /* setup() */

void init() {
   if ( this_player()->query_creator() ) {
      add_action( "do_add", "add" );
      add_action( "do_remove", "remove" );
      add_action( "do_visit", "visit" );
   }
} /* init() */

int do_add( string words ) {
   int i, distance, level, *new_co_ord, *old_co_ord, *vector;
   string direc, file, terrain, type;
   object room, *things;
   if ( !words )
      return notify_fail( "Add what?\n" );
   if ( sscanf( words, "%s %s %s", type, file, direc ) != 3 )
      return notify_fail( "Syntax: add fixed|floating <file> <direction>\n" );
   i = member_array( direc, STD_ORDERS );
   if ( i == -1 )
      return notify_fail( capitalize( direc ) +" is not a valid "+
            "direction.\n" );
   room = environment( this_player() );
   if ( room->query_exit( direc ) )
      return notify_fail( "There is already an exit to the "+
            direc +".\n" );
   vector = STD_ORDERS[ i + 1 ];
   if ( file_size( file +".c" ) < 0 )
      return notify_fail( capitalize( file ) +" does not exist.\n" );
   file->force_load();
   if ( !find_object( file ) )
      return notify_fail( capitalize( file ) +" will not load.\n" );
   distance = (int)file->query_room_size() +
         (int)room->query_room_size();
   old_co_ord = (int *)room->query_co_ord();
   if ( sizeof( old_co_ord ) != 3 )
      return notify_fail( "Environment does not have coordinates.\n" );
   new_co_ord = allocate( 3 );
   for ( i = 0; i < 3; i++ )
      new_co_ord[ i ] = old_co_ord[ i ] - distance * vector[ i ];
   terrain = (string)room->query_property( "terrain name" );
   if ( !terrain )
      return notify_fail( "Environment is not in the terrain "+
            "handling system.\n" );
   switch( type ) {
      case "fixed" :
         i = (int)TERRAIN_MAP->add_fixed_location( terrain,
               file, new_co_ord );
         break;
      case "floating" :
         i = (int)TERRAIN_MAP->add_floating_location( terrain,
               file, new_co_ord, level );
         break;
      default :
         return notify_fail( "Type must be fixed or floating.\n" );
   }
   if ( !i )
      return notify_fail( "Failed to add "+ file +" ("+ type +
            ") to "+ terrain +" at "+ new_co_ord[ 0 ] +", "+
            new_co_ord[ 1 ] +", "+ new_co_ord[ 2 ] +".\n" );
   write( "Added "+ file +" ("+ type +") to "+ terrain +" at "+
         new_co_ord[ 0 ] +", "+ new_co_ord[ 1 ] +", "+
         new_co_ord[ 2 ] +".\n" );
   if ( type == "fixed" )
      file->dest_me();
   TERRAIN_MAP->clear_connections( terrain );
   TERRAIN_MAP->delete_cloned_location( terrain, file_name( room ) );
   things = all_inventory( room );
   things->move( "/room/void" );
   room->dest_me();
   room = (object)TERRAIN_MAP->find_location( terrain, old_co_ord );
   things->move( room );
   return 1;
} /* do_add() */

int do_remove() {
   write( "This function has not been written yet.\n" );
   return 1;
} /* do_remove() */

int do_visit( string words ) {
   int x, y, z;
   string terrain;
   object room;
   if ( !words )
      return notify_fail( "Visit where?\n" );
   if ( sscanf( words, "%s %d %d %d", terrain, x, y, z ) != 4 )
      return notify_fail( "Syntax: visit <terrain> <x co-ord> "+
            "<y co-ord> <z co-ord>\n" );
   room = (object)TERRAIN_MAP->find_location( terrain, ({ x, y, z }) );
   if ( !objectp( room ) )
      return notify_fail( "There is no location at ("+ x +","+ y +","+ z +
            ") in \""+ terrain +"\".\n" );
   this_player()->move_with_look( room, "There is a strange smell, like "+
         "freshly broken earth, and $N appear$s.", "With a squelch, "+
         "$N vanish$s." );
   return 1;
} /* do_visit() */
// --- END [/mnt/home2/grok/lib/obj/misc/terrain_shovel.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/misc/s_badge.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/misc/s_badge.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627949   Available: 13575303
Inodes: Total: 5242880    Free: 4960134
7160 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/misc/s_badge.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627949   Available: 13575303
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <mail.h>

#define DOMAIN explode( theres[ i ], "/" )[ 1 ]
#define LORD capitalize( (string)( "/d/"+ DOMAIN +"/master" )->query_lord() )
#define MASTER "/secure/master"
#define HANDLER "/obj/handlers/playtesters"

#define PROTECTION_EFFECT "/d/playtesters/effects/pt_protection"

inherit "/obj/armour";

mapping routes;

int access_mail(string str);
int list_destinations();
int list_transits();
int do_goto(string destination);

void setup() {
   set_name( "badge" );
   set_short( "bejewelled gold badge" );
   add_adjective( "gold" );
   set_long( "This bejewelled gold badge is the mark of a Senior Playtester."
           "  It has a drawing of a womble on the front; it seems to be using"
           " a magnifying glass to examine something.  On the back is "
           "engraved a scroll with some words on it.\n" );
   setup_armour( 100 );
   set_damage_chance( 0 );
   set_type( "badge" );
   reset_drop();

   // Put this in a call_out to make sure the PTs get it.
   call_out( (: add_wear_effect :), 0, PROTECTION_EFFECT );
   
   /*
    * Please make sure that routes are placed correctly.
    * This is a _mapping_ !
    */
   routes = ([
     /* "/d/am/undercellar/upper_a" : ({
         "/d/am/short/short11",
      }), */ /* til I find out what the heck happened */
      "/d/klatch/djel/city/port/riverwalk09" : ({
         "/d/klatch/djel/city/port/pier1",
       }),
      "/d/klatch/djel/city/port/pier1" : ({
        "/d/klatch/djel/city/port/riverwalk09",
       }),
       "/d/am/isle_gods/siege/siege4" : ({
           "/d/am/isle_gods/buildings/parlour/parlor",
       }),
       "/d/am/ninth/ninth1" : ({
          "/d/am/blood/blood01",
       }),
       "/d/ram/ohulan/market/market_c" : ({
         "/d/ram/rambling_trail",
       }),
      "/d/klatch/djel/city/roads/widder35" : ({
         "/d/klatch/ephebe/desert/roads/road5",
       }),
      "/d/am/gates/hubwards" : ({
         "/d/sur/beta/topography/Sto_Plains/s_caravan/entrance",
      }),

    ]);
   set_read_mess( "This badge allows the bearer to move into certain areas "
         "to be playtested from certain entry locations (near to where the "
         "areas will be eventually connected).  To see the possible "
         "destinations from your current room, use the command "
         "\"destinations\", and to move into one of them, use the command "
         "\"goto <label>\" where <label> will be A, B, C, etc..  You can "
         "get a list of all transit points with \"transits\", although no "
         "guarantee is made that each item on this list will be "
         "recognisable.  Please report any problems with rooms not "
         "loading to the relevant domain Lord or Liaison(s)." );
} /* setup() */

void init() {
   string word;
   if ( !environment() )
      return;
   if ( !living( environment() ) )
      return;
   if ( !environment()->query_creator() ) {
      word = (string)environment()->query_name();
      if ( !HANDLER->query_playtester( word ) ) {
         tell_object( environment(), "You are not a playtester.  "
               "The playtester's badge disappears in a flurry of fluff.\n" );
         set_drop();
         move( "/room/rubbish" );
         return;
      }
      if ( HANDLER->query_senior_playtester( word ) ) {
         add_command( "mail", "", (: access_mail(0) :) );
         add_command( "mail", "<string>", (: access_mail($4[0]) :) );
      }
   }
   add_command("destinations", "", (: list_destinations() :) );
   add_command("transits", "", (: list_transits() :) );
   add_command("goto", "<string>", (: do_goto($4[0]) :) );
/* creator "goto" should take precidence */
} /* init() */

int access_mail( string words ) {
   return (int)MAIL_TRACK->mail( words );
} /* access_mail() */

int list_destinations() {
  int i;
  string here, *theres;
  object there;
  here = file_name( environment( this_player() ) );
  if ( !sizeof ( theres = routes[ here ] ) )
    return notify_fail( "You cannot use the badge to move from here.\n" );
  write( "From here you can use the badge to move to:\n" );
  for ( i = 0; i < sizeof( theres ); i++ ) {
    if ( !( there = find_object( theres[ i ] ) ) ) {
      if ( file_size( theres[ i ] +".c" ) < 0 ) {
/* might need to be check with MASTER using file_exists */
        write( sprintf( "%c: %s cannot be found; please contact %s.\n", 65 + i,
            theres[ i ], LORD ) );
        continue;
      }
      catch( theres[ i ]->force_load() );
      if ( !( there = find_object( theres[ i ] ) ) ) {
        write( sprintf( "%c: %s will not load, please contact %s.\n", 65 + i,
            theres[ i ], LORD ) );
        continue;
      }
    }
    write( sprintf( "%c: %s\n", 65 + i, (string)there->a_short() ) );
  }
  return 1;
} /* list_destinations() */

int list_transits() {
   int i;
   string *theres;
   object there;
   theres = keys( routes );
   if ( !sizeof( theres ) )
      return notify_fail( "There are no transit points at the moment.\n" );
   write( "You can use the badge to move from:\n" );
   for ( i = 0; i < sizeof( theres ); i++ ) {
    if ( !( there = find_object( theres[ i ] ) ) ) {
      if ( file_size( theres[ i ] +".c" ) < 0 ) {
/* might need to be check with MASTER using file_exists */
        write( sprintf( "%s cannot be found; please contact %s.\n",
            theres[ i ], LORD ) );
        continue;
      }
      catch( theres[ i ]->force_load() );
      if ( !( there = find_object( theres[ i ] ) ) ) {
        write( sprintf( "%s will not load, please contact %s.\n",
            theres[ i ], LORD ) );
        continue;
      }
    }
    write( sprintf( "   %s\n", (string)there->a_short() ) );
  }
  return 1;
} /* list_transits() */

int do_goto( string destination ) {
  int i;
  string here, *theres;
  object there;

  i = destination[ 0 ] - 65;
  if ( ( i < 0 ) || ( i > 25 ) ) {
    notify_fail( "The destination label needs to be a capital letter "+
        "between A and Z.\n" );
    return 0;
  }
  here = file_name( environment( this_player() ) );
  if ( !sizeof ( theres = routes[ here ] ) ) {
    notify_fail( "You cannot use the badge to move from here.\n" );
    return 0;
  }
   if ( i >= sizeof( theres ) )
      return notify_fail( "That is not a valid label from here.\n" );   
  if ( !( there = find_object( theres[ i ] ) ) ) {
    if ( file_size( theres[ i ] +".c" ) < 0 ) {
/* might need to be check with MASTER using file_exists */
      write( theres[ i ] +" cannot be found; please contact "+ LORD +".\n" );
      return 1;
    }
    catch( theres[ i ]->force_load() );
    if ( !( there = find_object( theres[ i ] ) ) ) {
      write( theres[ i ] +" will not load; please contact "+ LORD +".\n" );
      return 1;
    }
  }
  write( "Moving you to "+ (string)there->the_short() +"...\n" );
  this_player()->move_with_look( there, "$N appear$s in a flurry of fluff "
             "that only $N could muster.", "$N disappear$s in a flurry of fluff." );
  return 1;
} /* do_goto() */

// --- END [/mnt/home2/grok/lib/obj/misc/s_badge.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/peddler.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/peddler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627947   Available: 13575301
Inodes: Total: 5242880    Free: 4960134
17892 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/peddler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627947   Available: 13575301
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: peddler.c,v 1.33 2003/04/23 09:36:04 runtime Exp $
 *
 */
/**
 * This is the peddler object, it acts as a walking talking item
 * shop.
 * Added event_enter so to stop food from decaying when the peddler
 * sells it. Siel, October 2001
 *
 */
#include <armoury.h>
#include <money.h>
#include <move_failures.h>
#include <virtual.h>

#define MAX_PROP "max per reset"
#define TYPE "item shop type"
#define NUM_SOLD "number removed this reset"
#define DISPLAY "display in shop"

inherit "/obj/monster";
inherit "/std/shops/inherit/clone_on_demand";

private string _none_left_mess;
private string _out_of_item_mess;
private string _show_item_mess;
private string _missing_punter_mess;
private string _dont_sell_mess;
private string _all_out_mess;
private string _list_mess;
private string _list_item_mess;
private string _no_stock_mess;
private string _too_poor_mess;
private string _too_heavy_mess;
private string _in_combat_mess;
private string _busy_mess;
private int busy;

void create() {

    _none_left_mess      = "I'm afraid I don't have any of those.";
    _out_of_item_mess    = "We are right out of $item$.";
    _show_item_mess      = "$item$ is priced at $cost$.  Let me show it to "
        "you.";
    _missing_punter_mess = "Hey... Where'd the fellow go?  Anyway...";
    _dont_sell_mess      = "I'm afraid I don't have any $item$.";
    _all_out_mess        = "I'm afraid I have no $item$ left.";
    _list_mess           = "I have the following items for sale:";
    _list_item_mess      = "I have $num_left$ $display$ for $cost$.";
    _no_stock_mess       = "I am afraid I have nothing for sale.";
    _too_poor_mess       = "I'm afraid you can't afford to buy $item$.";
    _too_heavy_mess      = "Well, here's $item$, but you can't carry it at "
        "the moment.  I'll put it on the floor.";
    _in_combat_mess      = "Can't you see I'm a bit preoccupied right "
                           "now?";
    _busy_mess           = "Sorry, I can only handle one purchase at a "
                           "time!" ;
    monster::create();

} /* create() */


/** @ignore yes */
void init() {
    object cont = query_cont();

    ::init();
    if( cont ) {
        this_player()->add_command( "browse", this_object(),
                                "<indirect:object:" + file_name(cont) +
                                "> {from|of} <direct:living:here>" );
        this_player()->add_command( "buy", this_object(),
                                "<indirect:object:" + file_name(cont) +
                                "> from <direct:living:here>" );
        this_player()->add_command( "list", this_object(),
                                "goods {from|of} <direct:living:here>" );
    }

} /* init() */


/** @ignore yes */
void check_cont() {
    object cont;
    ::check_cont();
    cont = query_cont();
    cont->set_name( "peddler_store" );
} /* check_cont() */


/**
 * This method returns the cost of the specified item to the buyer.
 * @param thing the thing to cost
 * @param buyer who is buying it
 * @return the cost of the item
 */
int query_cost( object thing, object buyer ) {

   if( thing->query_property("cost here") ) {
        return (int)thing->query_property("cost here");
    }
    else {
       return (int)thing->query_value_at( this_object() );
    }

} /* query_cost() */


/**
 * This method returns the costs of the item as a string.
 * @param thing the thing to buy
 * @param place the money area it is being bought in
 * @param buyer the person who is buying the object
 * @return the string money value
 */
string cost_string( object thing, string place, object buyer ) {
    return (string)MONEY_HAND->money_value_string(
        query_cost( thing, buyer ), place );
} /* cost_string() */


/**
 * The main entrace to the browse for things command.
 * @return 1 on success, 0 on failure
 */
int do_browse( mixed indirect_obs, string dir_match, string indir_match,
    string *words ) {

    int num_left;
    int i;
    string place;
    object *things;
    string custom_string;

    if( this_object()->query_fighting() ) {
        queue_command( "sayto " + file_name(this_player()) + " " +
            _in_combat_mess, 2 );
        this_player()->add_succeeded_mess( this_object(), "$N ask$s $D "
            "about browsing an item.\n", ({ }) );
        return 1;
    }

    place = query_property( "place" );
    if ( !place || ( place == "" ) ) {
        place = "default";
    }
    check_cont();
    things = indirect_obs;
    if( !sizeof( things ) ) {
        queue_command( "sayto " + file_name(this_player()) + " " +
            _none_left_mess, 2 );
    }
    else {
        for ( i = 0; i < sizeof( things ); i++ ) {
            num_left = things[i]->query_property( MAX_PROP ) -
                things[i]->query_property( NUM_SOLD );
            if (num_left <= 0) {
                custom_string = replace( _out_of_item_mess, ({
                    "$item$", things[i]->one_short()
                }) );
                queue_command( "sayto " + file_name(this_player()) +
                    custom_string);
                continue;
            }

            custom_string = replace( _show_item_mess, ({
                "$item$", "$C$" +
                    strip_colours((string)things[i]->the_short()),
                "$cost$", cost_string( things[i], place,
                    this_player() )
            }) );
            queue_command( "sayto " + file_name(this_player()) + " " +
                custom_string, 4 * i + 2 );

            // Added in by Oaf 11/99 - peddler doesn't have item in
            // inventory, so just tell the player the long() of the item.
            queue_command( "whisper " +
                things[i]->one_short()+":\n"+things[i]->long() + " to " +
                file_name(this_player()) );

            /*
            init_command("show " + things[i]->query_name() + " to " +
                this_player()->query_name(), 4*i+3);
            */
            /*
            call_out("show_it", 4*i+3, evaluate(things[i]->the_short()),
                evaluate(things[ i ]->long()));
            */
        }
    }

    this_player()->add_succeeded_mess( this_object(), "$N ask$s $D "
        "about "+ query_multiple_short(things) +".\n", ({ }) );
    return 1;

} /* do_browse() */


/**
 * This method shows the object in question to the player.
 * @param short the short description
 * @param long the long description
void show_it(string short, string long){
    if(environment(this_player()) != environment(this_object())){
        queue_command("'" + _missing_punter_mess);
        return;
    }
    tell_room(environment(this_object()), capitalize(evaluate(the_short()))+
        " shows "+this_player()->the_short()+" "+short+ ".\n");
    tell_object(this_player(), long);

} * show_it() */

/**
 * The main entrace to the buy things command.
 * @return 1 on success, 0 on failure
 */
int do_buy( mixed indirect_obs, string dir_match, string indir_match,
      string *words ) {

    int i, num_left;
    object *things;
    string custom_string;

    if(busy) {
      do_command("'" + _busy_mess);
      this_player()->add_succeeded_mess( this_object(), "$N confuse$s "
                     "$D, who is busy making business.\n", ({ }));
      return 1;
    }
    busy = 1;

    check_cont();
    things = indirect_obs;

    if ( !sizeof( things ) ) {
        custom_string = replace( _dont_sell_mess, ({
            "$item$", indir_match
        }) );
        queue_command( "sayto " + file_name(this_player()) + " " +
            custom_string);
    }
    else {
        if( this_object()->query_fighting() ) {
           queue_command( "sayto " + file_name(this_player()) + " " +
                          _in_combat_mess, 2 );
           this_player()->add_succeeded_mess( this_object(), "$N ask$s $D "
               "about buying "+ query_multiple_short(things) +".\n", ({ }) );
           busy = 0;
           return 1;
        }

        for ( i = 0; i < sizeof( things ); ++i ) {
            num_left = (int)things[ i ]->query_property( MAX_PROP ) -
                (int)things[ i ]->query_property( NUM_SOLD );
            if ( num_left < 1 ) {
                custom_string = replace( _all_out_mess, ({
                    "$item$", strip_colours((string)things[i]->query_plural())
                }) );
                init_command( "sayto " + file_name(this_player()) + " " +
                    custom_string, 2 * i + 2 );
                busy = 0;
                continue;
            }

            call_out( "sell_thing", 2 * i, this_player(), things[ i ] );
        }
    }

    this_player()->add_succeeded_mess( this_object(), "$N ask$s $D "
        "about buying "+ query_multiple_short(things) +".\n", ({ }) );
    return 1;

} /* do_buy() */


/**
 * The main entrace to the list stuff command.
 * @return 1 on success, 0 on failure
 */
int do_list() {
    int num_left;
    string place;
    object thing;
    int first;
    object cont;
    string display;
    string custom_string;

    if( this_object()->query_fighting() ) {
        queue_command( "sayto " + file_name(this_player()) + " " +
            _in_combat_mess, 2 );
        this_player()->add_succeeded_mess( this_object(), "" );
        return 1;
    }

    place = query_property( "place" );

    if ( !place || ( place == "" ) ) {
        place = "default";
    }

    check_cont();
    cont = query_cont();

    thing = first_inventory( cont );
    first = 1;

    while ( thing ) {
        num_left = (int)thing->query_property( MAX_PROP ) -
            (int)thing->query_property( NUM_SOLD );
        if ( num_left < 1 ) {
            thing = next_inventory( thing );
            continue;
        }
        if (first) {
            queue_command( "sayto " + file_name(this_player()) + " " +
                _list_mess);
            first = 0;
        }

        /* Make it use the display property added with add_object, if it
            exists.  Else use the short.  Pluralize if neccessary */
        display = (string)thing->query_property( DISPLAY );


        if ( !stringp( display )  && thing->short()) {
            if( num_left > 1 ) {
                display = (string)thing->query_plural();
            }
            else {
                display = (string)thing->a_short();
            }
        }
        else {
            if( num_left > 1 ) {
                display = pluralize( display );
            }
        }

        custom_string = replace( _list_item_mess, ({
            "$num_left$", (num_left > 1 ? query_num (num_left) : ""),
//            "$num_left$", query_num (num_left),
            "$display$", display,
            "$cost$", cost_string( thing, place, this_player() ) +
                 (num_left > 1 ? " each" : "" )
        }) );

        queue_command( "sayto " + file_name( this_player() ) +
                    " " + custom_string );
        thing = next_inventory( thing );
    }

    if ( first ) {
        queue_command( "say " + _no_stock_mess);
    }

    this_player()->add_succeeded_mess( this_object(), "" );
    return 1;

} /* do_list() */


/**
 * The main entrace to the sell stuff command.
 * @return 1 on success, 0 on failure
 */
void sell_thing( object player, object thing ) {
    int value;
    string item_name, place;
    object copy;
    string custom_string;

    if ( !player ) {
        busy = 0;
        return;
    }
    if ( environment( player ) != environment( this_object() ) ) {
        busy = 0;
        return;
    }
    if ( !thing ) {
        busy = 0;
        return;
    }

    place = query_property( "place" );
    if ( !place || ( place == "" ) ) {
        place = "default";
    }

    value = (int)player->query_value_in( place );
    if ( place != "default" ) {
        value += (int)player->query_value_in( "default" );
    }

    // Make sure we are making a cost based on the non-cloned object.
    if ( (int)this_object()->query_cost( thing, player ) > value ) {
        custom_string = replace( _too_poor_mess, ({
            "$item$", (string)thing->a_short()
        }) );
        queue_command( "sayto " + file_name(player) + " " +
                       custom_string );
        busy = 0;
        return;
    }

    // So the copy is only made if the item is actually sold.
    copy = (object)this_object()->create_real_object( thing );
    if ( !copy ) {
        switch ( (string)thing->query_property( TYPE ) ) {
            case "armour" :
            case "weapon" :
            case "armoury item":
                copy = ARMOURY->request_item( item_name,
                    80 + random( 20 ) );
                break;
            case "object" :
                copy = clone_object( item_name );
                break;
        }
    }
    if ( !copy ) {
        copy = clone_object( explode( file_name( thing ), "#" )[ 0 ] );
    }
    if ( !copy ) {
        busy = 0;
        return;
    }

    thing->add_property( NUM_SOLD, (int)thing->query_property( NUM_SOLD ) +
        1 );
    player->pay_money( (mixed *)MONEY_HAND->create_money_array(
        (int)this_object()->query_cost( copy, player ), place ), place );
    tell_object( player, "You pay "+ the_short() +" "+
        cost_string( copy, place, player ) +".\n" );
    tell_room( environment(), (string)player->one_short() +
        " gives "+ the_short() +" some money.\n", player );

    if ( (int)copy->move( player ) != MOVE_OK ) {
        custom_string = replace( _too_heavy_mess, ({
            "$item$", (string)copy->the_short()
        }) );
        queue_command( "sayto " + file_name(player) + " " + custom_string );
        copy->move( environment() );
        queue_command( ":puts "+ (string)copy->a_short() +" on the ground." );
    }
    else {
        tell_room( environment(), the_short() +" gives "+
            (string)player->one_short() +" "+ (string)copy->a_short() +
            ".\n" );
    }
    busy = 0;

} /* sell_thing() */

void event_enter(object ob, string mess, object from) {
    if (ob->query_food_object()) { ob->set_decay_speed(0); }
} /* event_enter() */


void event_exit(object ob, string message, object to) {
    if (ob->query_food_object()) { ob->set_decay_speed(8000); }
} /* event_exit() */


void dest_me() {
  if(query_cont())
    log_file("PEDDLER", "Cont: %s\n", file_name(query_cont()));
    clone_on_demand::dest_me();
    monster::dest_me();
} /* dest_me() */


/* CHAT OVERRIDE FUNCTIONS, Dasquian 8/7/02 */


/**
 * Overrides the default reply to having none left
 * @param s the chat to replace the default with
 */
void set_none_left_mess(string s) {
    _none_left_mess = s;
} /* set_none_left_mess() */

/**
 * Overrides the default chat of being out of an item that is browsed
 * @param s the chat to replace the default with.  Must include $item$, which
 * will be replaced by the item short.
 */
void set_out_of_item_mess(string s) {
    _out_of_item_mess = s;
} /* set_out_of_item_mess() */

/**
 * Overrides the default chat of showing an item to a player
 * @param s the chat to replace the default with.  Must include $item$ and
 * $cost$, which will be replaced by the item short and the cost of the item
 * respectively.
 */
void set_show_item_mess(string s) {
    _show_item_mess = s;
} /* set_show_item_mess() */

/**
 * Overrides the default chat to the player having wandered off
 * @param s the chat to replace the default with
 */
void set_missing_punter_mess(string s) {
    _missing_punter_mess = s;
} /* set_missing_punter_mess() */

/**
 * Overrides the default chat of the peddler not selling an item
 * @param s the chat to replace the default with.  Must include $item$, which
 * will be replaced by the item short.
 */
void set_dont_sell_mess(string s) {
    _dont_sell_mess = s;
} /* set_dont_sell_mess() */

/**
 * Overrides the default chat of the item being out of stock when a player
 * tries to buy it
 * @param s the chat to replace the default with.  Must include $item$, which
 * will be replaced by the item short.
 */
void set_all_out_mess(string s) {
    _all_out_mess = s;
} /* set_all_out_mess() */

/**
 * Overrides the default chat to announcing the stock list
 * @param s the chat to replace the default with
 */
void set_list_mess(string s) {
    _list_mess = s;
} /* set_list_mess() */

/**
 * Overrides the default chat of listing a stock item's price and stock
 * @param s the chat to replace the default with.  Must include $num_left$,
 * $display$ and $cost$, which will be replaced by the appropriate
 * strings.
 */
void set_list_item_mess(string s) {
    _list_item_mess = s;
} /* set_list_item_mess() */

/**
 * Overrides the default reply to having no listable stock
 * @param s the chat to replace the default with
 */
void set_no_stock_mess(string s) {
    _no_stock_mess = s;
} /* set_no_stock_mess() */

/**
 * Overrides the default chat of the player being too poor to buy an item
 * @param s the chat to replace the default with.  Must include $item$, which
 * will be replaced by the item short.
 */
void set_too_poor_mess(string s) {
    _too_poor_mess = s;
} /* set_too_poor_mess() */

/**
 * Overrides the default chat of the player being too burdened to carry an
 * item
 * @param s the chat to replace the default with.  Must include $item$, which
 * will be replaced by the item short.
 */
void set_too_heavy_mess(string s) {
    _too_heavy_mess = s;
} /* set_too_heavy_mess() */

/**
 * Overrides the default chat of the peddler being in combat and hence unable
 * to sell his wares!
 * @param s the chat to replace the default with
 */
void set_in_combat_mess(string s) {
    _in_combat_mess = s;
} /* set_in_combat_mess() */

/**
 * Overrides the default chat of the peddler being busy selling
 * something already.
 * @param s the chat to replace the default with
 */
void set_busy_mess(string s) {
    _busy_mess = s;
} /* set_busy_mess() */
// --- END [/mnt/home2/grok/lib/obj/peddler.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/fungus.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/fungus.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627943   Available: 13575297
Inodes: Total: 5242880    Free: 4960134
7108 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/fungus.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627943   Available: 13575297
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: fungus.c,v 1.7 2001/09/24 21:56:19 danbala Exp $
 */
#include <move_failures.h>

inherit "/obj/food";

int delay, large_weight, stage;
string adjs, extra, type, *messages;
void next_stage();

void create() {
  do_setup++;
  ::create();
  do_setup--;
  set_name( "fungus" );
  add_plural( "fungi" );
  set_short( "fungus" );
  delay = 600;
  large_weight = 4;
  set_weight_per_bite( 1 );
  extra = "It looks edible.";
  type = "mushroom";
  messages = ({
    "A small $type$ pushes up through the soil.\n",
    "The $type$ seems to be a bit larger now.\n",
    "The $type$ looks nice and large now.\n",
    "The $type$ silently releases a grey dust into the air.\n",
    "The $type$ collapses in on itself and falls apart.\n"
  });
  if ( !do_setup )
    this_object()->setup();
   if ( clonep( this_object() ) )
      call_out( "next_stage", delay / 2 + random( delay ) );
} /* create() */

int query_growing() { return 1; }

int query_delay() { return delay; }

void set_delay( int number ) {
  if ( number < 60 )
    number = 60;
  delay = number;
  if ( remove_call_out( "next_stage" ) > -1 )
    call_out( "next_stage", delay / 2 + random( delay ) );
} /* set_delay() */

int query_large_weight() { return large_weight; }

int query_stage() { return stage; }

void set_stage( int number ) { 
  if(number > 0) {
    stage = number - 1;
  }
  this_object()->next_stage();
}

void set_large_weight( int number ) { large_weight = number; }

string query_adjs() { return adjs; }

void set_adjs( string words ) { adjs = words; }

string query_extra() { return extra; }

void set_extra( string words ) { extra = words; }

string query_type() { return type; }

void set_type( string word ) { type = word; }

string *query_messages() { return messages; }

void set_messages( string *words ) {
  if ( sizeof( words ) != 5 ) {
    write( "WARNING: there must be five messages.\n" );
    return;
  }
  messages = words;
} /* set_messages() */

void init() {
   ::init();
   if ( stage > 5 )
      this_player()->add_command( "pick", this_object() );
} /* init() */

int test_non_spore( object thing ) {
  return ( (int)thing->query_stage() > 5 );
} /* test_non_spore() */

void setup_spore() {
  set_name("pile");
  set_short("small, dusty pile of fungus spores");
  add_alias("dust");
  add_alias("spore");
  add_adjective("fungus");
  add_adjective("spore");
  set_main_plural("small, dusty piles of fungus spores");
  add_plural(({"piles","spores"}));
  add_plural_adjective("small, dusty piles of");
  add_plural_adjective("fungus");
  set_delay( delay );
  set_large_weight( large_weight );
  set_weight_per_bite( query_weight_per_bite() );
  set_adjs( adjs );
  set_extra( extra );
  set_long("This is a small pile of dust, mainly fungus "
           "spores, it seems.\n");
  set_type( type );
  set_messages( messages );
}

object make_spore( object place ) {
  object spore;
  spore = clone_object( explode( file_name( this_object() ), "#" )[0]);
  spore->setup_spore();
  spore->move( place );
  return spore;
} /* make_spore() */

void next_stage() {
  int i, number;
  string words;
  object *things;
  if ( !environment() )
    return;
  if ( adjs )
    words = adjs +" "+ type;
  else
    words = type;
  switch ( stage ) {
    case 0 .. 4 : /* dormant spore */
      this_object()->setup_spore();
      break;
    case 5 : /* small */
      things = match_objects_for_existence( pluralize(words),
                                            ({ environment() }) );
      things = filter_array( things, "test_non_spore", this_object() );
      if ( sizeof( things ) >=
          (int)environment()->query_property( words +" capacity" ) ) {
        move( "/room/rubbish" );
        return;
      }
      tell_room( environment(), replace( messages[ 0 ], "$type$", words ) );
      set_aliases( ({ type }) );
      set_plurals( ({ "fungi", pluralize( type ) }) );
      set_short( "small "+ words );
      if ( adjs )
        set_adjectives( ({ "small" }) + explode( adjs, " " ) );
      else
        set_adjectives( ({ "small" }) );
      set_main_plural( "small "+ pluralize( words ) );
      set_long( "This is a small "+ words +"."+ ( extra ? "  "+ extra : "" ) +
          "\n" );
      set_weight( large_weight / 4 );
      things = all_inventory( environment() );
      for ( i = 0; i < sizeof( things ); i++ )
        if ( living( things[ i ] ) )
          things[ i ]->add_command( "pick", this_object() );
      break;
    case 6 : /* medium */
      tell_room( environment(), replace( messages[ 1 ], "$type$", words ) );
      set_short( "medium "+ words );
      if ( adjs )
        set_adjectives( ({ "medium" }) + explode( adjs, " " ) );
      else
        set_adjectives( ({ "medium" }) );
      set_main_plural( "medium "+ pluralize( words ) );
      set_long( "This is a medium sized "+ words +"."+ ( extra ? "  "+
          extra : "" ) +"\n" );
      set_weight( large_weight / 2 );
      break;
    case 7 : /* large */
      tell_room( environment(), replace( messages[ 2 ], "$type$", words ) );
      set_short( "large "+ words );
      if ( adjs )
        set_adjectives( ({ "large" }) + explode( adjs, " " ) );
      else
        set_adjectives( ({ "large" }) );
      set_main_plural( "large "+ pluralize( words ) );
      set_long( "This is a large "+ words +"."+ ( extra ? "  "+ extra : "" ) +
          "\n" );
      set_weight( large_weight );
      break;
    case 8 .. 10 : /* spore production */
      break;
    case 11 : /* spore release */
      if(!environment() || base_name(environment()) == "/room/rubbish")
        break;
      
      tell_room( environment(), replace( messages[ 3 ], "$type$", words ) );
      number = 2 + random( 3 );
      for ( i = 0; i < number; i++ )
        make_spore( environment() );
      break;
    default : /* death */
      tell_room( environment(), replace( messages[ 4 ], "$type$", words ) );
      move( "/room/rubbish" );
      return;
  }
  stage++;
  call_out( "next_stage", delay / 2 + random( delay ) );
} /* next_stage() */

int do_get() {
  if ( stage != -1 ) {
    write( the_short() +" is currently growing.  You could \"pick\" "+
        "it, though.\n" );
    return 0;
  }
  if ( move( this_player() ) == MOVE_OK )
    return 1;
  return 0;
} /* do_get() */

int do_take() { return do_get(); }

int do_pick() {
  if ( stage < 6 )
    return 0;
  stage = -1;
  remove_call_out( "next_stage" );
  if ( move( this_player() ) != MOVE_OK )
    call_out( "too_heavy_mess", 0, this_player() );
  return 1;
} /* do_pick() */

void too_heavy_mess( object thing ) {
  if ( thing )
    tell_object( thing, "You are carrying too much to lift the "+ type +
        " as well, so you leave it on the ground.\n" );
} /* too_heavy_mess() */

string query_medium_short() {
  if ( adjs )
    return adjs +" "+ type;
  return type;
} /* query_medium_short() */

mapping query_static_auto_load() { return int_query_static_auto_load(); }

void init_dynamic_arg( mapping args, object) {
  ::init_dynamic_arg( args );
  stage = -1;
  remove_call_out( "next_stage" );
} /* init_dynamic_arg() */
// --- END [/mnt/home2/grok/lib/obj/fungus.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/shut.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/shut.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627941   Available: 13575295
Inodes: Total: 5242880    Free: 4960134
8269 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/shut.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627941   Available: 13575295
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: shut.c,v 1.8 2003/05/05 07:00:55 ceres Exp $
 * 
*/
/*
** Armageddon 3.0 is largely a rip off of the 2.4.5 version
** that most of us are familiar with. The original author
** left no credits, but the work is recognized.
** This version has a number of improvements, and hopefully,
** a neater finished product.
**
** To use, merely use the command:
**   call shut(##) /obj/shut
** where ## is the number of minutes till shutdown. Armageddon
** will then handle a nice shutdown.
**      Gordon
**  Bashed for our great mud by pinkfish.
**
**  Changed to use quit_alt on Fri Dec  6 10:35:04 WST 1996
**    -- Pinkfish.
*/

#include <network.h>

#define OFFLER_SHADOW "/std/shadows/misc/offler_shadow"

#undef CONVERTER
#undef AUTO_RESURRECT

inherit "/std/container";

int time_of_crash, time_of_last_shout;

void setup() {
/* This stops wizzes from cloning armageddon. He only needs to be loaded */
  if (file_name(this_object()) != "/obj/shut") {
    write("This object can't be cloned.\n");
    dest_me();
    return;
    }
  set_name("offler");
  set_living_name("offler");
  add_adjective( ({ "offler", "the", "crocodile" }));
  add_alias("god");
  enable_commands();
  set_short( "Offler" );
  add_property( "determinate", "" );
  set_long("The Crocodile God.  He looks big, green, and, well "+
           "like this really.\n");
  add_alias("shut");
  reset_get();
} /* setup() */

#define ishout(str) user_event("say", "%^BOLD%^%^RED%^Offler the Crocodile God shouts: "+str+"%^RESET%^\n", 0)

void heart_beat() {
   int time_to_crash;
   if (!time_of_crash) return;
   time_to_crash = time_of_crash - time();
   if (time_to_crash < 1) {
      call_out("end_it_all",0);
      set_heart_beat(0);
      return;
   }
   if (time_to_crash < 10)  {
      ishout( "Game weboot in "+ time_to_crash +" thecondth." );
      return;
   }
   if (time_to_crash < 60 && time_to_crash % 10 < 2) {
      ishout( "Game ith webooting in "+ time_to_crash +
            " thecondth.  Go away!" );
      return;
   }
   if (time_to_crash % 60 > 5)
      return;
   time_to_crash /= 60;
   if (time_to_crash == time_of_last_shout)
      return;
   time_of_last_shout = time_to_crash;
   if (time_to_crash > 30) {
      /* Give them at least 30 minutes warning... */
      return ;
   }
   if(time_to_crash == 1) {
      ishout( "Game ith webooting in one minute.  Quit now!" );
      return;
   }
   if (time_to_crash < 10 || !(time_to_crash % 10)) {
      ishout( "Game ith webooting in "+ time_to_crash +" minuteth." );
      return;
   }
} /* heart_beat() */

void shut(int minutes, string reason) {
   object *players;
   int i;
   string fname;
   if (!intp(minutes)) {
      write("Bad argument\n");
      return;
   }
   fname = file_name(previous_object());
   if (minutes <= 0) {
      write("No time given\n");
      return;
   }
#ifdef CONVERTER
   if (!CONVERTER->ok_to_shut()) {
      dest_me();
      return;
   }
#endif
   players = users();
   for (i=0;i<sizeof(players);i++) {
     if ( !players[ i ] )
       continue;
     if (players[i]->query_creator())
     tell_object(players[i], "%^BOLD%^%^RED%^Offler the Crocodile God wishes "
                 "you to know:  The mud is rebooting in "+
                 number_as_string( minutes ) + " minutes.%^RESET%^\n" );
   }
   set_long("He is firmly concentrating on counting.\n");
   if (time_of_crash)
     write( "There was already a reboot scheduled, set for "+
           (time_of_crash - time()) + " seconds.\n");

   move("/d/am/buildings/drum/mendeddrum",
      "Offler the Crocodile God appears in a puff of smoke.",
      "Offler the Crocodile God appears in a puff of smoke.");

   time_of_crash = time() + minutes*60;
   time_of_last_shout = minutes;
   set_heart_beat(1);
#ifdef AUTO_RESURRECT  
   call_out( "check_ghosts", 60 );
#endif
   
   if(file_name(previous_object()) == "/obj/handlers/garbage")
     log_file("REBOOT", "Shutdown requested automatically at "+ctime(time())+
              "\n");
   else if(this_player())
     log_file("REBOOT", "Shutdown at "+ctime(time())+" requested by " +
              this_player()->query_cap_name()+" for " + reason + "\n");
   else
     log_file("REBOOT", "Shutdown at "+ctime(time())+" requested by " +
              file_name(previous_object()) + " for " + reason + "\n");

} /* shut() */

string long(string str, int dark) {
  ::long(str, dark);
  if ( time_of_crash && this_player() && this_player()->query_creator() )
     return ::long(str,dark)+
            "Game reboot will be in " + ( time_of_crash - time() ) +
            " seconds.\n";
  return ::long(str,dark);
} /* long() */

void end_it_all() {
   int i;
   object *obs;
   
   ishout( "Thutdown now!" );
   obs = users();
   for (i=0;i<sizeof(obs);i++) {
      call_out("force_quit", i, obs[i]);
   }
   call_out("blue", 10);
} /* end_it_all() */

void force_quit( object ob ) {
   if ( !objectp( ob ) )
      return;
   ob->stop_all_fight();
   if(ob->query_login_ob()) {
     ob->dest_me();
     return;
   }
   if ( !environment( ob ) )
     ob->move( "/d/am/buildings/drum/mendeddrum" );
   /* Change it to use the quit_alt code. */
   if(environment(ob) &&
      file_name( environment( ob ) ) != "/room/departures" ) {
     ob->quit_alt();
   }
   /* If the quit_alt doesn't work.  Force a hard quit */
   if (environment(ob) && 
       file_name( environment( ob ) ) != "/room/departures" ) {
     ob->quit();
   }
} /* force_quit() */

/*
 * Check to see that everyone has been quit.  If we have taken
 * longer than 4 minutes to quit everyone, then we shutdown
 * anyway. -- Pinkfish
 */
void blue() {
  if (sizeof(users()) > 0 &&
      time() - time_of_crash < 240)
    call_out("blue", 10);
  else {
    SERVICES_D->eventShutdown(1);
    shutdown(0);
  }
} /* blue() */

int query_time_to_crash() {
   if ( !time_of_crash ) {
      call_out( "dest_me", 1 );
      return 9999;
   }
   set_heart_beat( 1 );
   return time_of_crash - time();
} /* query_time_to_crash() */

int query_unambushable() { return 1; }

void do_ambushed() {
   write( "Bad mistake...\n" );
   this_player()->run_away();
} /* do_ambushed() */

#ifdef AUTO_RESURRECT
void person_died( string word, int number ) {
   object thing;
   thing = find_player( word );
   if ( !thing )
      return;
   switch ( number ) {
      case 0 :
         break;
      case 1 :
         tell_object( thing, "$I$5=Offler tells you exclaiming: Well, "+
               "weally!  Thilly mortal, of all the timeth to die!\n" );
         break;
      case 2 :
         tell_object( thing, "$I$5=Offler tells you: Don't wowwy, I'll "+
               "welieve the chap with the thythe of you thith time.\n" );
         break;
      case 3 :
         thing->remove_ghost();
         clone_object( OFFLER_SHADOW )->setup_shadow( thing );
         break;
      default :
         tell_object( thing, "$I$5=Offler tells you exclaiming: And behave "+
               "yourthelf until I'm done, for goodneth' thake!\n" );
         return;
   }
   call_out( "person_died", 3, word, number + 1 );
} /* person_died() */

void person_dead( object thing, int number ) {
   if ( !thing )
      return;
   if ( thing->query_property( "noregen" ) ) {
      call_out( "person_dead", 3, thing, number );
      return;
   }
   switch ( number ) {
      case 0 :
         tell_object( thing, "$I$5=Offler tells you exclaiming: Well, "+
               "weally!  Can't have you wunning awound detheathed!\n" );
         break;
      case 1 :
         thing->remove_ghost();
         clone_object( OFFLER_SHADOW )->setup_shadow( thing );
         break;
      default :
         tell_object( thing, "$I$5=Offler tells you exclaiming: Now behave "+
               "yourthelf until I'm done, for goodneth' thake!\n" );
         return;
   }
   call_out( "person_dead", 3, thing, number + 1 );
} /* person_dead() */

void check_ghosts() {
   object thing;
   foreach( thing in users() ) {
      
      if ( !thing ) {
          continue;
      }
      if ( !thing->query_property( "dead" ) ) { 
         continue;
      }
      if ( (int)thing->query_deaths() > (int)thing->query_max_deaths() ) {
         continue;
      }
      call_out( "person_dead", 3, thing, 0 );
   }
} /* check_ghosts() */

#endif
// --- END [/mnt/home2/grok/lib/obj/shut.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/container.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/container.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627939   Available: 13575293
Inodes: Total: 5242880    Free: 4960134
54304 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/container.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627939   Available: 13575293
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker: trilogy $
 * $Id: container.c,v 1.13 2001/03/18 17:32:23 tannah Exp trilogy $
 * $Log: container.c,v $
 * Revision 1.13  2001/03/18 17:32:23  tannah
 * Changed all the %d/%d to <fraction>, the %p to <preposition>, the %I
 * to <indirect:object> and the %D to <direct:object>
 *
 * Revision 1.12  2000/07/14 22:08:51  pinkfish
 * Fix up to not use global variables from inherits
 *
 * Revision 1.11  2000/06/08 02:06:24  pinkfish
 * Remove the old fill code.
 *
 * Revision 1.10  1999/11/18 10:04:34  pinkfish
 * Add in stuff to control looking inside something else.
 *
 * Revision 1.9  1999/11/08 09:13:05  pinkfish
 * Fix it up so you can see what is in it.
 *
 * Revision 1.8  1999/11/04 00:59:22  pinkfish
 * Make it pay attenion to darkness levels.
 *
 * Revision 1.7  1999/07/20 07:53:48  wodan
 * set_unlock_trap has been renamed set_lock_trap for some reason.
 *
 * Revision 1.6  1999/05/27 23:46:11  pinkfish
 * Fix up to work propertly with the private variables in /std/basic/close_lock.c
 * These people that assume things about object internals.  Sheeze :)
 *
 * Revision 1.5  1998/10/30 08:34:49  pinkfish
 * Fix up the name references.
 *
 * Revision 1.4  1998/03/12 08:07:15  pinkfish
 * Added documentation.
 *
 * Revision 1.3  1998/03/05 06:03:35  pinkfish
 * Fixed up the problems wirth picking up immovable signs.
 *
 * Revision 1.2  1998/02/11 00:34:06  presto
 * Fixed placement of open/closed description
 *
 * Revision 1.1  1998/01/06 04:58:17  ceres
 * Initial revision
 * 
 */
/**
 * This is main container type object that players will use.  For
 * example, buckets and stuff would use this.  A backpack would be
 * a type of clothing and a potion bottle should be a vessel.
 * @author Who knows, Pinkfish, Ember, Jeremy
 * @see /obj/vessel.c
 * @see /obj/clothing.c
 */
#include "move_failures.h"
#include "parse_command.h"
#include "potion_attrs.h"
/* Modified by Piecemaker 18/5/93 to add octarine descriptions. */
/* Modified by Jeremy Feb 96 to skip breakage in stationary containers
 * and to add 'padded' property
 */

inherit "/std/container";
inherit "/std/basic/close_lock_container";

#define MAX_INVENT 40

nosave int full_weight, leak_rate, hb_count;

/* liquid/potion stuff */
mixed *misc_attrs;   /* purely physical attributes ... all the 'inactive' parts */
nosave mixed *all_attrs;    /* misc_attrs merged with active_attrs */
nosave mixed *active_attrs; /* this is the attrs due to the position in the potion space */

int volume, max_volume;  /* total volume, and max volume for this container */
int water;    /* the 'water' part of the volume ... the volume that is used in */
              /* potion space activities.  The volume that is not 'water' is */
              /* considered 'inactive' in any potion reactions */

int *ps_coord; /* coordinate in the potion_space */
int ps_quantity; /* magic number describing quantity of active junk in this potion */

nosave mixed *potion_id, *potion_adjective;
nosave int volume_to_womble;  /* kludge for the fraction stuff */

/** @ignore yes */
void set_volume_to_womble(int n) { volume_to_womble = n; }
/** @ignore yes */
int query_volume_to_womble() { return volume_to_womble; }

/**
 * This method sets the weight of the container when it is full.
 * @param i the new weight of the containe when full.
 * @see query_full_weight()
 * @see set_weight()
 */
void set_full_weight(int i) { full_weight = i; }
/**
 * This method sets the leak rate of the container.  The leak rate is how
 * fast stuff leaks out of the container.
 * @param i the new leak rate of the container
 * @see query_leak_rate()
 */
void set_leak_rate(int i) { leak_rate = i; }
/**
 * This method returns the full weight of the container.
 * @see set_full_weight()
 * @see query_weight()
 */
int query_full_weight() { return full_weight; }
/**
 * This method returns the leak rate of the container
 * @see set_leak_rate()
 */
int query_leak_rate() { return leak_rate; }

/**
 * This method returns the current amount of liquid in the container.
 * @return the current amount of liquid in the container
 */
int query_volume() { return volume; }
/**
 * This method sets the current amount of liquid in the container.  If
 * the container has a leak rate, it starts to leak.
 * @param i the new amount of liquid in the containe
 * @see query_volume()
 * @see set_leak_rate()
 */
void set_volume(int i) {
   volume = i;
   if (leak_rate) {
      set_heart_beat(1);
   }
} /* set_volume() */

/**
 * This method returns the current maxium volume associated with this
 * container.
 * @return the current maximum volume
 */
int query_max_volume() { return max_volume; }
/*
void set_max_volume(int i) { max_volume = i; }
 */

/**
 * This method returns the potion space co-ordinates of the liquid.
 * @return the potion space co-ordinates
 * @see query_ps_quantity()
 */
int *query_ps_coord() { return ps_coord; }
/**
 * This method returns the quantity of liquid at the potion space.
 * @return the quantity of liquid
 * @see query_ps_coord()
 * @see set_ps_quantity()
 */
int query_ps_quantity() { return ps_quantity; }

void set_ps_quantity(int n) { ps_quantity = n; }

int *query_all_attrs() { return all_attrs; }
int *query_misc_attrs() { return misc_attrs; }
int *query_active_attrs() { return active_attrs; }

/**
 * This method sets the volume of water in the container.
 * @param n the new volume of water
 */
void set_water_volume(int n) { water = n; if (leak_rate) set_heart_beat(1); }
/**
 * This method returns the volume of water in the container.
 * @see set_water_volume()
 */
int query_water_volume() { return water; }

/**
 * This method sets the maximum weight of the container.  This also sets
 * the maximum volume of the container to 10 times its maximum weight.
 * (If there is no current maximum volume).
 * @param i the maxium weight of the container
 * @see set_max_volume()
 * @see add_weight()
 */
void set_max_weight(int i) {
  if (!max_volume && i) {
    max_volume = i*10;
  }
  ::set_max_weight(i);
} /* set_max_weight() */

/**
 * This method sets the maximum volume of the container.  This also
 * sets the maximum weight of the container to one tenth of the
 * volume (if there is not current maximum weight).
 * @param i the new maximum volume
 * @see set_max_weight()
 * @see add_volume()
 */
void set_max_volume(int i) {
  if (!query_max_weight() && i) {
    ::set_max_weight(i/10);
  }
  max_volume = i;
} /* set_max_volume() */

/**
 * This method returns the amount of the liquid you can actually empty
 * from a container.
 * @return the amount of liquid that can be emptied
 */
int empty_formula() {
/* formula to work out how close to empty someone can get casually */
   int vol_lost;

   vol_lost = 2 + volume * 95 / 100;
   if (vol_lost > volume) vol_lost = volume;
   return vol_lost;
} /* empty_formula() */

/** @ignore yes */
int cull_neutral_obs( mixed ob ) {
   if ( ob->query_vect() ) {
     return 1;
   }
   return 0;
} /* cull_neutral_obs() */

/**
 * This method returns the vector of the contents of the container.
 * This is based on the vectors of all the liquid with a vector set
 * on them.
 */
int *contents_vect() {
   object *inv;
   int *v;
   int ang, str, tot, i;
 
   inv = all_inventory(this_object());
   inv = filter_array(inv, "cull_neutral_obs", this_object());
   
   if (sizeof(inv) == 0) return ({ 0, 0, 0 });
 
   tot = ang = str = 0;
 
   for (i = 0; i < sizeof(inv); i++) {
      v = inv[i]->query_vect(); 
      tot += v[0];
      ang += v[1] * v[0];
      str += v[2] * v[0];
   }
   
   return ({ ang / tot, str / tot, tot });
} /* contents_vect() */

/**
 * This method will destroy all the liquid contents of the object.
 * @return the number of object destroyed
 */ 
int dest_active_contents() {
   object *inv;
   int i;
 
   inv = all_inventory(this_object());
   inv = filter_array(inv, "cull_neutral_obs", this_object());
 
   for (i = 0; i < sizeof(inv); i++) {
      inv[i]->dest_me();
   }
   return sizeof(inv);
} /* dest_active_contents() */

/** @ignore yes */ 
int *squidge_vector(int *v, int meth_ang, int meth_mult) {
   int ca, cb;
   int da, cx, cy;
   object trig;
   
   "/obj/handlers/trig"->wibble_wobble();
   trig = find_object("/obj/handlers/trig");
   
   da = meth_ang - v[0];
   ca = v[1] * trig->cos(da);
   cb = v[1] * trig->sin(da);
   ca = ca * meth_mult;
   cb /= meth_mult;
   ca /= 1000000;
   cb /= 1000000;
   cx = ca * trig->cos(meth_ang) + cb * trig->sin(meth_ang);
   cy = ca * trig->sin(meth_ang) - cb * trig->cos(meth_ang);
   return ({ cx / 1000000, cy / 1000000 });
}

void set_ps_coord_quantity(int *coord, int quantity);

/**
 * This method adds a potion space vector with a particular
 * quantity to the object.
 * @param v the vector to add
 * @param quant the quantity to add
 */
void add_ps_vect(int *v, int quant) {
   object trig;
   int ca, cb;
   
   if (quant <= 0) return;
   trig = find_object("/obj/handlers/trig");
/*   ca = v[1] * trig->cos(v[0]) / 1000000;
   cb = v[1] * trig->sin(v[0]) / 1000000; */
   ca = v[0];  cb = v[1];
    ca = (int)trig->pow1_5(ps_coord[0] * 10 * ps_quantity /(ca * quant)) * ca / 1000000;
   cb = (int)trig->pow1_5(ps_coord[1] * 10 * ps_quantity /(cb * quant)) * cb / 1000000;
   
   set_ps_coord_quantity( ({ ps_coord[0] + ca, ps_coord[1] + cb }),
                          quant + ps_quantity);
   return;
}

/**
 * This method returns a string for how transparent the liquid is
 * based on the transparency value passed in.
 * @return the transparency string()
 * @param trans the transparency value
 */
string transparency_string(int trans)
/* return string describing transparency 'trans' */
{
   switch (trans) {
   case -10..9: return "opaque";
   case 10..24: return "milky";
   case 25..39: return "murky";
   case 40..59: return "cloudy";
   case 60..74: return "misty";
   case 75..89: return "slightly misty";
   case 90..110: return "clear";
/* if they've got the numbers stuffed up, they should _know_ about it :) */
   default: return "paisley";
   }
} /* transparency_string() */

/**
 * This method returns a string for how consistent the liquid is
 * based on the consistency value passed in.
 * @return the consistency string()
 * @param cons the consistency value
 */
string consistency_string(int cons)
/* return string describing consistency 'cons' */
{
   switch (cons) {
   case -10..9: return "watery liquid";
   case 10..24: return "slightly viscous watery liquid";
   case 25..39: return "runny syrup";
   case 40..59: return "syrup";
   case 60..74: return "jelly";  /* viscous liquid? */
   case 75..89: return "paste";
   case 90..110: return "solid";
/* see above comment in transparency */
   default: return "non-Newtonian fluid";
   }
} /* consistency_string() */

/**
 * This method updates the values used for the find_match() parseing
 * due to the liquids.
 * @see /secure/simul_efun->find_match()
 */
void update_potion_parse()
{
   int i;
   string *exploded;

   potion_adjective = query_adjectives() +
                  ({ transparency_string(all_attrs[POTION_TRANSPARENCY]) });
   potion_id = ({ query_name() }) + query_alias() + 
                  ({ consistency_string(all_attrs[POTION_CONSISTENCY]) });
   for (i = 0; i < sizeof(all_attrs[POTION_NAMES]); i++) {
      exploded = explode(all_attrs[POTION_NAMES][i][0], " ");
      potion_id += ({ exploded[sizeof(exploded) - 1] });
      if (sizeof(exploded) > 1) {
         potion_adjective += exploded[0..sizeof(exploded) - 2];
      }
   }
   
   for (i = 0; i < sizeof(all_attrs[POTION_COLOURS]); i++) 
      potion_adjective += explode(all_attrs[POTION_COLOURS][i][0], " ");
   /* plurals?  Lets forget them for now */
}

/**
 * This method zaps all the liquid stuff in the container.
 */
void void_liquid()
{
   volume = 0;
   water = 0;

   misc_attrs = allocate(POTION_ATTRS_SIZE);
   misc_attrs[POTION_CONSISTENCY] = 0;
   misc_attrs[POTION_TRANSPARENCY] = 100;
   misc_attrs[POTION_NAMES] = ({ });
   misc_attrs[POTION_COLOURS] = ({ });
   misc_attrs[POTION_SMELLS] = ({ });
   misc_attrs[POTION_FLAVOURS] = ({ });
   
   ps_coord = (int *)POTION_SPACE_HANDLER->neutral_coordinate();
   ps_quantity = 0;
   
/* Hmmm.  I wonder if having these all the same array will cause problems */
   active_attrs = all_attrs = misc_attrs;
   update_potion_parse();
}

/** @ignore yes */
void create() {
  do_setup++;
  container::create();
  close_lock_container::create();
  set_can_export_inventory();
  do_setup--;
  void_liquid();
  add_property("liquid", 1);
  add_property("watertight", 1);
  leak_rate = 1000;
  if ( !do_setup )
    this_object()->setup();
} /* create() */

/** @ignore yes */
void init() {
/*  liquid::init(); */
  (void)this_player()->add_command("drink", this_object());
  (void)this_player()->add_command("splash", this_object(), "<direct:object> <preposition> <indirect:object>");
  (void)this_player()->add_command("rub", this_object(), "<direct:object> <preposition> <indirect:object>");
  (void)this_player()->add_command("apply", this_object(), "<direct:object> <preposition> <indirect:object>");
  (void)this_player()->add_command("pour", this_object(), "<direct:object> <preposition> <indirect:object>");
  (void)this_player()->add_command("taste", this_object());
  (void)this_player()->add_command("smell", this_object());
  this_player()->add_command("fill", this_object(), "<indirect:object> <preposition> <direct:object>");
  this_player()->add_command("fill", this_object(), "<indirect:object> <fraction> up <preposition> <direct:object>");
  this_player()->add_command("fill", this_object(), "<indirect:object> <fraction> full <preposition> <direct:object>");
  (void)this_player()->add_command("empty", this_object());

  close_lock_container::init();
} /* init() */

/* This may be stuffing up other containers...
int query_weight() {
  if (!full_weight)
    return ::query_weight();
  return ::query_weight() + ((query_loc_weight()+(query_max_weight()*volume)/max_volume)
                             *full_weight)/query_max_weight();
} query_weight() */

/** @ignore yes */
int query_complete_weight() {
  return ::query_complete_weight() + ( query_max_weight() * volume ) /
      ( max_volume + 1 );
} /* query_complete_weight() */

/**
 * This method returns the current amount of weight left that can
 * be filled on the container.
 * @return the current amount of weight left
 */
int query_weight_left() {
  if (!max_volume)
    return query_max_weight() - query_loc_weight();
  return query_max_weight() - query_loc_weight() - (query_max_weight()*volume)/max_volume;
} /* query_weight_left() */

/**
 * This method returns the amount of volume left for liquids to be
 * added into.
 * @return the amount of volume left
 * @see add_volume()
 * @see transfer_liquid_to()
 */
int query_volume_left() {
  if (!query_max_weight())
    return max_volume - volume;
  return max_volume - volume - (max_volume*query_loc_weight())/query_max_weight();
} /* query_volume_left() */

/** @ignore yes */
int add_weight( int n ) {
  if ( query_weight_left() < n ) return 0;
  if ( !( ::add_weight( n ) ) ) return 0;
  if ( n >= 0 ) {
    remove_call_out( "check_breakages" );
    call_out( "check_breakages", 5 + random( 16 ) );
  }
  return 1;
#ifdef BREAK_NOW

  obs = all_inventory();
  for (i=0;i<sizeof(obs);i++) 
    if ((amt = obs[i]->query_property("fragile"))) {
      if (query_loc_weight() <= amt || ((query_loc_weight() - amt)*100)/amt <= random(100)) 
          obs[i] = 0;
    } else
      obs[i] = 0;

  obs = obs - ({ 0 });
  if (sizeof(obs)) {
    say(this_player()->one_short()+" breaks "+
          (sizeof(obs)>1?"some things":"one thing")+" in "+
          query_multiple_short(({ this_object() }))+".\n");
    write("You break "+query_multiple_short(obs)+" in "+
          query_multiple_short(({ this_object() }))+".\n");
    obs->dest_me();
  }
  return 1;
#endif
} /* add_weight() */

/**
 * This method checks to see if any of the things contained in the
 * container should be broken.
 * @see /std/container->add_weight()
 */
void check_breakages() {
/* check loc_weight against fragility of every object and break some
 *   if necessary.  If the container has the "padded" property, adjust
 *   the chance of breakage.
 */
  object *obs, carrier;
  int i, amt, wt;

  // See if it's being carried by a living object
  carrier = environment(this_object());
  while (carrier && (!living(carrier))) {
    carrier = environment(carrier);
  }
  if (!carrier)
    return;
  obs = all_inventory();
  wt = query_loc_weight() - (int)query_property("padded");
  for (i=0;i<sizeof(obs);i++) {
    if ((amt = obs[i]->query_property("fragile"))) {
      if (wt <= amt || ((wt - amt)*100)/amt <= random(100)) {
          obs[i] = 0;
      }
    } else {
      obs[i] = 0;
    }
  }

  obs = obs - ({ 0 });
  if (sizeof(obs) && environment(carrier)) {
    tell_room(environment(carrier), carrier->the_short()+" breaks "+
          (sizeof(obs)>1?"some things":"one thing")+" in "+
          query_multiple_short(({ this_object() }))+".\n", ({ carrier }));
    tell_object(carrier, "You break "+query_multiple_short(obs)+" in "+
          query_multiple_short(({ this_object() }))+".\n");
    obs->dest_me();
  }
} /* check_breakages() */

/** @ignore yes */
varargs string pretty_short( object thing ) {
   return short_status() + ::pretty_short( thing );
} /* pretty_short() */

/** @ignore yes */
varargs string pretty_plural( object thing ) {
   return short_status() + ::pretty_plural( thing );
} /* pretty_plural() */

/**
 * This method returns the name of the current liquid inside the container.
 * @return the name of the current liquid
 */
string liquid_name()
{
   string liq_name;
   mixed *names, *colours;
   string *med, *lo;   /* groups of strings with hi/med/lo intensities */
   int no_names, no_colours, i;
   
   names = all_attrs[POTION_NAMES];
   colours = all_attrs[POTION_COLOURS];
   
   no_names = (sizeof(names) < 1 || names[0][1] < VERY_SMALL_AMOUNT);
   no_colours = (sizeof(colours) < 1 || colours[0][1] < VERY_SMALL_AMOUNT);
   
   if (no_names && no_colours) {
      liq_name = "a colourless " + 
         transparency_string(all_attrs[POTION_TRANSPARENCY]) + " " +
         consistency_string(all_attrs[POTION_CONSISTENCY]);
   } else if (no_names) {
      if (colours[0][1] < SMALL_AMOUNT) {
         liq_name = "a faint " + colours[0][0];
      } else {
         liq_name = add_a(colours[0][0]);
      }
      liq_name += " " + transparency_string(all_attrs[POTION_TRANSPARENCY]) +
                     " " + consistency_string(all_attrs[POTION_CONSISTENCY]);
      med = ({ });
      i = 1;
      while (i < sizeof(colours) && colours[i][1] >= SMALL_AMOUNT)
         med += ({ colours[i++][0] });
      
      lo = ({ });
      while (i < sizeof(colours) && colours[i][1] >= VERY_SMALL_AMOUNT)
         lo += ({ colours[i++][0] });
      
      if (sizeof(med)) {
         liq_name += " with swirls of " + query_multiple_short(med);
      }
      
      if (sizeof(lo)) {
         if (sizeof(med)) liq_name += " and faint streaks of " + query_multiple_short(lo);
         else liq_name += " with faint streaks of " + query_multiple_short(lo);
      }
   } else if (no_colours) {
      i = 0;
      med = ({ });
      lo = ({ });
      while (i < sizeof(names) && names[i][1] >= SMALL_AMOUNT) 
         med += ({ names[i++][0] });
      while (i < sizeof(names) && names[i][1] >= VERY_SMALL_AMOUNT)
         lo += ({ names[i++][0] });
      
      if (sizeof(med) > 1) liq_name = "a mixture of " + query_multiple_short(med);
      else if (sizeof(med) == 1) liq_name = med[0];
      
      if (!sizeof(med) && sizeof(lo) > 1) 
         liq_name = "a diluted mixture of " + query_multiple_short(lo);
      else if (!sizeof(med) && sizeof(lo) == 1)
         liq_name = "diluted " + lo[0];
      else if (sizeof(med) && sizeof(lo))
         liq_name += "and small quantities of " + query_multiple_short(lo);
   } else {
      if (names[0][1] > colours[0][1] / 2) 
      /* arbitrary relationship ... names are 'twice' as visible as colours */
      /* if the primary name is more visible than the primary colour, */
      /* then we use this scenario: */
      /*   "chunky soup (a yellow cloudy syrup with swirls of green, orange */
      /*    and brown)" */
      /* else we use the colour scenario: */
      /*   "a yellow cloudy syrup containing chunky soup with swirls of green, */
      /*    orange and brown" */
      {
         /* this little fragment copied directly from 'no_colours' above */
         i = 0;
         med = ({ });
         lo = ({ });
         while (i < sizeof(names) && names[i][1] >= SMALL_AMOUNT) 
            med += ({ names[i++][0] });
         while (i < sizeof(names) && names[i][1] >= VERY_SMALL_AMOUNT)
            lo += ({ names[i++][0] });
      
         if (sizeof(med) > 1) liq_name = "a mixture of " + query_multiple_short(med);
         else if (sizeof(med) == 1) liq_name = med[0];
      
         if (!sizeof(med) && sizeof(lo) > 1) 
            liq_name = "a diluted mixture of " + query_multiple_short(lo);
         else if (!sizeof(med) && sizeof(lo) == 1)
            liq_name = "diluted " + lo[0];
         else if (sizeof(med) && sizeof(lo))
            liq_name += "and small quantities of " + query_multiple_short(lo);
         
         /* this little fragment copied directly from 'no_names' above */
         
         if (colours[0][1] < SMALL_AMOUNT) liq_name += " (a faint " + colours[0][0];
         else liq_name += " (" + add_a(colours[0][0]);
         liq_name += " " + transparency_string(all_attrs[POTION_TRANSPARENCY]) +
                        " " + consistency_string(all_attrs[POTION_CONSISTENCY]);
         med = ({ });
         i = 1;
         while (i < sizeof(colours) && colours[i][1] >= SMALL_AMOUNT)
            med += ({ colours[i++][0] });
         
         lo = ({ });
         while (i < sizeof(colours) && colours[i][1] >= VERY_SMALL_AMOUNT)
            lo += ({ colours[i++][0] });
         
         if (sizeof(med)) {
            liq_name += " with swirls of " + query_multiple_short(med);
         }
         
         if (sizeof(lo)) {
            if (sizeof(med)) liq_name += " and faint streaks of " + query_multiple_short(lo);
            else liq_name += " with faint streaks of " + query_multiple_short(lo);
         }
         liq_name += ")";
      } else {   /* phew, coloured liquid containing names now */
         /* this little fragment _almost_ directly copied from no_names above */
         if (colours[0][1] < SMALL_AMOUNT) liq_name = "a faint " + colours[0][0];
         else liq_name = add_a(colours[0][0]);
         liq_name += " " + transparency_string(all_attrs[POTION_TRANSPARENCY]) +
                        " " + consistency_string(all_attrs[POTION_CONSISTENCY]);
         
         med = ({ });
         i = 0;
         while (i < sizeof(names) && names[i][1] >= VERY_SMALL_AMOUNT)
            med += ({ names[i++][0] });
         
         liq_name += " containing " + query_multiple_short(med);
         
         med = ({ });
         i = 1;
         while (i < sizeof(colours) && colours[i][1] >= SMALL_AMOUNT)
            med += ({ colours[i++][0] });
         
         lo = ({ });
         while (i < sizeof(colours) && colours[i][1] >= VERY_SMALL_AMOUNT)
            lo += ({ colours[i++][0] });
         
         if (sizeof(med)) {
            liq_name += " with swirls of " + query_multiple_short(med);
         }
         
         if (sizeof(lo)) {
            if (sizeof(med)) liq_name += " and faint streaks of " + query_multiple_short(lo);
            else liq_name += " with faint streaks of " + query_multiple_short(lo);
         }
      } /* yayayayaya.  done! */
   }
   return liq_name;
}

/**
 * This method returns the short description of the liquid.
 * @return the short description of the liquid
 * @see query_liquid_name()
 */
string query_liquid_short()
{
   if (sizeof(all_attrs[POTION_NAMES]) && sizeof(all_attrs[POTION_COLOURS])) {
      if (all_attrs[POTION_NAMES][0][1] > all_attrs[POTION_COLOURS][0][1] / 2) {
         return all_attrs[POTION_NAMES][0][0];
      }
   }
   
   return (sizeof(all_attrs[POTION_COLOURS]) ? 
           all_attrs[POTION_COLOURS][0][0] : "colourless") + " " +
             transparency_string(all_attrs[POTION_TRANSPARENCY]) + " " +             
             consistency_string(all_attrs[POTION_CONSISTENCY]);
} /* query_liquid_short() */

/* ok modifyed back to using writes... */
/*        ^^^ lies!  all lies! */
/* Ok, Ok.  Sulk */
/* Please ignore the above comments.  They are wholely unjustified. */
/** @ignore yes */
string long(string str, int dark) {
  string ret;
  int bing;

  ret = ::long(str, dark);
  /*   ret += calc_extra_look(); */
  if (query_transparent() ||
      !query_closed()) {
    if ( ( dark == 2 ) || ( dark == -2 ) ) {
       if (query_contents() != "") {
          ret += "The "+ short( dark ) +" contains some items you cannot "
                 "make out.\n";
       }
    } else {
       ret += query_contents( "The "+ short( dark ) +" contains:\n" );
    }
  }

  /* what the hell is long_status, and why is it here? */
  ret += long_status();

  /* the long for the water inside of it */
  if ((query_transparent() || !query_closed()) && volume) {
    if ( ( dark == 2 ) || ( dark == -2 ) ) {
      ret += "It has some liquid of some sort in it.\n";
    } else {
      bing = (volume*8 + max_volume/16)/max_volume;
      if (bing <= 0) {
        ret += "It is slightly wet from "+liquid_name()+".\n";
      } else if (bing >= 8) {
        ret += "It is full to the brim with " + liquid_name()+".\n";
      } else {
        ret += "It is " + ({ "an eighth", "a quarter",
                "three eighths", "half", "five eighths", "three quarters",
                "seven eighths" })[bing-1]+" full of "+liquid_name()+".\n";
      }
    }
  }
  return ret;
} /* long() */

/**
 * This returns an adjective for how full the current object is with
 * liquid.  This is used in the parse command handling code.
 * @return the fullness adjective
 * @see query_max_volume()
 */
string *fullness_adjectives()
{
   if (!max_volume) {
      return ({ "totally", "empty" });
   }
   switch (100 * volume / max_volume) {
   case 0..4: return ({ "totally", "empty" });
   case 5..13: return ({ "empty" });
   case 65..94: return ({ "full" });
   case 95..100: return ({ "totally", "full" });
   default: return ({ });
   }
} /* fullness_adjectives() */

/* ok parse command stuff */
/** @@ignore yes */
string *parse_command_id_list() {
  return potion_id + ::parse_command_id_list();
} /* parse_command_id_list() */

/* string *parse_command_plural_id_list() { return plurals; } */
/** @@ignore yes */
string *parse_command_adjectiv_id_list() {
  return  fullness_adjectives() + potion_adjective + ::parse_command_adjectiv_id_list();
} /* parse_command_adjectiv_id_list() */

/** @@ignore yes */
int sort_func(int *x, int *y)
{
   if (x[1] < y[1]) return 1;
   else return 0;
}

/** @@ignore yes */
mixed *mix_liq(mixed *arr1, mixed *arr2, int vol1, int vol2, int tot_vol)
{
   int i, j;   /* general indexes into arrays */
   mixed *arr3;
   
   arr3 = allocate(sizeof(arr1));
 
   for (i = 0; i < sizeof(arr1); i++) {
      arr3[i] = ({ arr1[i][0], arr1[i][1] * vol1 / tot_vol });
      for (j = 0; j < sizeof(arr2); j++) {
         if (arr2[j][0] == arr1[i][0]) {
            arr3[i][1] += arr2[j][1] * vol2 / tot_vol;
            arr2[j][1] += 100000;         /* icky icky icky */
 /* have to be able to restore this because (due to the magic of
    arrays :( ) we are really working on the original */
            break;
         }
      }
   }
   
   for (i = 0; i < sizeof(arr2); i++) {
      if (arr2[i][1] >= 100000) {
         arr2[i][1] -= 100000;
      } else {
         arr3 += ({ ({ arr2[i][0], arr2[i][1] * vol2 / tot_vol }) });
      }
   }
   
   /* now lets sort it */
   arr3 = sort_array(arr3, "sort_func", this_object());
   /* now cull off 0's on the end */
   for (i = sizeof(arr3) - 1; i >= 0; i--) {
      if (arr3[i][1] > 0) break;
   }
   
   if (i < 0) arr3 = ({ });
   else arr3 = arr3[0..i];
   
   return arr3;
}
 
/** @@ignore yes */
mixed *merge_potions(mixed *potion1, mixed *potion2, int vol1, int vol2, int tot_vol)
{
   mixed *result;

   result = allocate(POTION_ATTRS_SIZE);
   result[POTION_CONSISTENCY] = 
      (potion1[POTION_CONSISTENCY] * vol1 +
       potion2[POTION_CONSISTENCY] * vol2) / tot_vol;
   result[POTION_TRANSPARENCY] = 
      (potion1[POTION_TRANSPARENCY] * vol1 +
       potion2[POTION_TRANSPARENCY] * vol2) / tot_vol;
   
   result[POTION_NAMES] = mix_liq(potion1[POTION_NAMES], potion2[POTION_NAMES],
                                  vol1, vol2, tot_vol);
   result[POTION_COLOURS] = mix_liq(potion1[POTION_COLOURS], potion2[POTION_COLOURS],
                                  vol1, vol2, tot_vol);
   result[POTION_FLAVOURS] = mix_liq(potion1[POTION_FLAVOURS], potion2[POTION_FLAVOURS],
                                  vol1, vol2, tot_vol);
   result[POTION_SMELLS] = mix_liq(potion1[POTION_SMELLS], potion2[POTION_SMELLS],
                                  vol1, vol2, tot_vol);
   return result;
}

void set_misc_attrs(mixed *new_misc_attrs, int misc_vol)
{
   misc_attrs = new_misc_attrs + ({ });
   volume = water + misc_vol;
   all_attrs = merge_potions(active_attrs, misc_attrs, water, volume - water, volume);
   update_potion_parse();
   if (leak_rate) set_heart_beat(1);
}

/**
 * This method changes the concentration of the liquid to be a new
 * and exciting concentration.
 * @param potion the potion to change the concentration of
 * @param new_conc the new concentration of the liquid
 */
mixed *change_concentration(mixed *potion, int new_conc)
{
   mixed *newpotion;
   int i;
   
   newpotion = potion + ({ });
   newpotion[POTION_CONSISTENCY] = newpotion[POTION_CONSISTENCY] * new_conc / 100;
   newpotion[POTION_TRANSPARENCY] = 
      (100 - (100 - newpotion[POTION_TRANSPARENCY]) * new_conc / 100);
   for (i = 0; i < sizeof(newpotion[POTION_NAMES]); i++) {
      newpotion[POTION_NAMES][i][1] = newpotion[POTION_NAMES][i][1] * new_conc / 100;
   }
   for (i = 0; i < sizeof(newpotion[POTION_COLOURS]); i++) {
      newpotion[POTION_COLOURS][i][1] = newpotion[POTION_COLOURS][i][1] * new_conc / 100;
   }
   for (i = 0; i < sizeof(newpotion[POTION_SMELLS]); i++) {
      newpotion[POTION_SMELLS][i][1] = newpotion[POTION_SMELLS][i][1] * new_conc / 100;
   }
   for (i = 0; i < sizeof(newpotion[POTION_FLAVOURS]); i++) {
      newpotion[POTION_FLAVOURS][i][1] = newpotion[POTION_FLAVOURS][i][1] * new_conc / 100;
   }
   return newpotion;
}

/**
 * This method sets the quantity of the position space co-ordinate
 * to be the new quantity.
 * @param new_coord the new co-ordinate of the liquid
 * @param new_quantity the new quantity of the liquid
 */
void set_ps_coord_quantity(int *new_coord, int new_quantity)
{
   mixed *ps_attrs;
   
   ps_attrs = (mixed *)POTION_SPACE_HANDLER->query_attrs_at(new_coord);
   active_attrs = change_concentration(ps_attrs, new_quantity * 100 / water);
   ps_quantity = new_quantity;
   ps_coord = new_coord;
   all_attrs = merge_potions(active_attrs, misc_attrs, water, volume - water, volume);
   update_potion_parse();
   (void)POTION_SPACE_HANDLER->potion_create(this_object(), new_coord, new_quantity);
}

void begin_config()
{
   potion_id = allocate(9);
   ps_coord = allocate(9);
}

void config(int vari, mixed cont)
{
   potion_id[vari] = cont;
   ps_coord[vari] = 1;
}

void end_config()
{
   mixed *ps_attrs;

   if (ps_coord[OC_VOL]) {
      volume = potion_id[OC_VOL];
      if (ps_coord[OC_MVOL]) water = volume - potion_id[OC_MVOL];
      else water = potion_id[OC_WVOL];
   } else {
      water = potion_id[OC_WVOL];
      volume = water + potion_id[OC_MVOL];
   }
   leak_rate = potion_id[OC_LEAKRATE];
   if (leak_rate && volume) set_heart_beat(1);
   if (ps_coord[OC_MAXVOL]) max_volume = potion_id[OC_MAXVOL];
   else max_volume = volume;
   ps_quantity = potion_id[OC_PSQUANT];
   if (ps_coord[OC_MISCATTRS]) misc_attrs = potion_id[OC_MISCATTRS];
   else misc_attrs = ({ 0, 100, ({ }), ({ }), ({ }), ({ }) });
   if (ps_coord[OC_PSCOORD]) ps_coord = potion_id[OC_PSCOORD];
   else ps_coord = ({ 0, 0 });
   
   ps_attrs = (mixed *)POTION_SPACE_HANDLER->query_attrs_at(ps_coord);
   active_attrs = change_concentration(ps_attrs, ps_quantity * 100 / water);
   all_attrs = merge_potions(active_attrs, misc_attrs, water, volume - water, volume);
   update_potion_parse();
   (void)POTION_SPACE_HANDLER->potion_create(this_object(), ps_coord, ps_quantity);
}

/** @@ignore yes */
mixed stats() {
  return container::stats() + close_lock_container::stats() + ({
    ({ "ps_quantity", query_ps_quantity() }),
   ({ "ps_coord", (pointerp(ps_coord) && sizeof(ps_coord) == 2) ?
      "({ " + ps_coord[0] + ", " + ps_coord[1] + " })" :
      sprintf("%O", ps_coord) }),
    ({ "volume", query_volume() + "" }),
    ({ "max volume", query_max_volume() }),
    ({ "water vol", query_water_volume() }),
    ({ "volume left", query_volume_left() }),
    ({ "weight left", query_weight_left() }),
    ({ "full_weight", query_full_weight(), }),
    ({ "leak_rate", query_leak_rate() + "" }),
  });
}

/** @@ignore yes */
object query_parse_id(mixed *arr) {
  volume_to_womble = 0;
  return ::query_parse_id(arr);
} /* query_parse_id() */

/** @@ignore yes */
object query_frac_parse_id(mixed *arr) {
  int i;

  volume_to_womble = 0;
  if (arr[P_THING] < 0) {
    arr[P_THING]++;
    if (arr[P_THING] != 0)
      return 0;
    volume_to_womble = volume*arr[P_TOP]/arr[P_BOT];
    call_out("set_volume_to_womble", 0, 0);
    arr[P_THING] = -1784628;
    return this_object();
  }
  if (arr[P_THING] == 0)
    if ((i=(arr[P_MAX_NUM]*arr[P_TOP])/arr[P_BOT]) > arr[P_CUR_NUM]++)
      return this_object();
    else
      if (i+1 == arr[P_CUR_NUM]) {
        volume_to_womble = volume*arr[P_TOP]/arr[P_BOT];
        call_out("set_volume_to_womble", 0, 0);
        return this_object();
      }
  else
    return 0;

  if ((i=(arr[P_THING]*arr[P_TOP])/arr[P_BOT]) > arr[P_CUR_NUM]++)
    return this_object();
  else
    if (i+1 == arr[P_CUR_NUM]) {
      volume_to_womble = volume*arr[P_TOP]/arr[P_BOT];
      call_out("set_volume_to_womble", 0, 0);
      return this_object();
    }
  return 0;
} /* query_frac_parse_id() */

/**
 * This method removes some volume of liquid from the container.
 * @see add_volume()
 * @see query_volume()
 */
int remove_volume(int vol_lost)
{
   int q_lost;
   
   if (!volume) {
      q_lost = ps_quantity;
      water = 0;
      ps_quantity = 0;
      return q_lost;
   }
   q_lost = ps_quantity * vol_lost / volume;
   water -= water * vol_lost / volume;
   volume -= vol_lost;
   ps_quantity -= q_lost;
   return q_lost;
}

/** @ignore yes */
void heart_beat() {
  int lost, off;

   if (leak_rate == 0 || volume <= 0) {
      set_heart_beat(0);
      return;
   }
  if (hb_count--) return ;
  hb_count = 10;
  lost = leak_rate;
  if (lost > volume)
    lost = volume;
  off = lost/100;
  if (off > 10)
    off = 10;
  tell_room(environment(),
            capitalize(query_liquid_short())+({ " drips slowly",
                               " drips",
                               " dribbles",
                               " trickles slowly",
                               " trickles",
                               " trickles rapidly",
                               " pours sluggishly",
                               " pours",
                               " streams",
                               " gushes",
                               " fountains", })[off]+" out of the "+
                                                          short(1)+".\n");
  (void)remove_volume(lost);
  if (!volume) {
    set_heart_beat(0);
/*    set_liquid_name(0); */
    void_liquid();
  }
} /* heart_beat() */

/**
 * This method does the actual liquid transfer, as needed by the
 * filling, emptying and pour operations.
 * @param dest where the liquid is to go
 * @param vol_misc the volume of non-water to move
 * @param misc the attributes for the non-water
 * @param vol_water the volume of water to move
 * @param coord the co-ordinate of the liquid
 * @param quantity the quantity of the potion space liquid
 */
void transfer_liquid_to(object dest, int vol_misc, mixed *misc, 
                                     int vol_water, int *coord, int quantity) 
{
   mixed *their_attrs;
   int their_vol, their_water, their_quantity, new_quantity, new_misc_vol;
   int *new_coord, *old_coord;

   their_attrs = (mixed *)dest->query_misc_attrs();
   their_vol = (int)dest->query_volume();
   their_water = (int)dest->query_water_volume();
   their_quantity = (int)dest->query_ps_quantity();
   new_quantity = quantity + their_quantity;

   if (!their_attrs)  /* can't be a potion ... give up */
      return ;
   
   new_misc_vol = vol_misc + their_vol - their_water;

   (void)dest->set_water_volume(their_water + vol_water);
   if (new_misc_vol) {
      their_attrs = merge_potions(misc_attrs, their_attrs, 
                               vol_misc, their_vol - their_water,
                               new_misc_vol);
      (void)dest->set_misc_attrs(their_attrs, new_misc_vol);
   } else   /* icck ... if we didn't do the set_misc_attrs, then their
                   volume is wrong, so we have to set it manually */
      (void)dest->set_volume(their_water + vol_water);
   
   
   old_coord = (int *)dest->query_ps_coord();
   new_coord = allocate(2);
/* simple averaging ... */
   if (pointerp(ps_coord) && new_quantity) {
      new_coord[0] = (ps_coord[0] * quantity + old_coord[0] * their_quantity) / 
                     new_quantity;
      new_coord[1] = (ps_coord[1] * quantity + old_coord[1] * their_quantity) / 
                     new_quantity;
      dest->set_ps_coord_quantity(new_coord, new_quantity);
   }

} /* transfer_liquid_to() */

/**
 * This method returns true if the object is open and prints a message
 * about the open status of the object.
 * @return 1 if it is open, 0 if not
 */
int ensure_open()
{
   if (query_locked()) {
      write("The " + short(1) + " is locked.\n");
      return 0;
   }
   if (query_closed()) /* has to be closed */
      if (do_open()) {
         write("You open the "+short(1)+".\n");
         return 1;
      } else {
         write("You can't open the " + short(1) + ".\n");
         return 0;
      }

   return 1;
} /* ensure_open() */

/** @ignore yes */
int do_pour(object *dest, string me, string him, string prep)
{
   int amount_poured, volume_transferred, old_water, old_volume;
   string liquid_desc;

   if (sizeof(dest) > 1) {
      write("Currently you can only pour into one object\n");
      return 0;
   }
   
   if (!ensure_open()) return 0;

   if (volume <= 0) {
      write("The " + short(0) + " you are trying to pour out of is empty.\n");
      return 0;
   }

   old_water = water;
   old_volume = volume;  /* so that when volume becomes 0 in this process */

   liquid_desc = query_liquid_short();

   if (volume_to_womble && volume_to_womble <= empty_formula()) 
      volume_transferred = volume_to_womble;
   else
      volume_transferred = empty_formula();

   amount_poured = remove_volume(volume_transferred);
   
   if (volume_transferred > dest[0]->query_volume_left()) {
      say(this_player()->short(0) + " attempts to pour from " + add_a(short(0))
         + " into " + add_a(dest[0]->short(0)) + " but ends up spilling "
         + liquid_desc + " all over the ground.\n");
      write(capitalize(liquid_desc) + " spills on the floor as you try to pour "
         + "from the " + short(0) + " into the " + dest[0]->short(0) + ".\n");

      amount_poured = (amount_poured * ((int)dest[0]->query_volume_left())) /
                         volume_transferred;
      volume_transferred = (int)dest[0]->query_volume_left();
   }
   
   transfer_liquid_to(dest[0], volume_transferred * (old_volume - old_water) / old_volume,
      misc_attrs, volume_transferred * old_water / old_volume, ps_coord, amount_poured);
   
   this_player()->add_succeeded(dest[0]);
   return 1;
}

/** @ignore yes */
int do_fill(object *to, mixed *args_b, mixed *args_a, mixed *args) {
   int m, n, i, run_out, volume_needed, their_volume, their_max,
       amount_poured, ok;

   if (intp(args[1]) && intp(args[2])) {
      m = args[0];
      n = args[1];
      if (m > n || m < 0 || n <= 0) {
         notify_fail("Interesting fraction you have there!\n");
         return 0;
      }
   } else {
      m = 1;
      n = 1;
   }

   if (query_locked()) {
      notify_fail("The " + short(0) + " is locked!\n");
      return 0;
   }
   
   if (query_closed()) {
      if (do_open()) {
         write("You open the " + short(0) + ".\n");
      } else {
         write("You cannot open the " + short(0) + ".\n");
         return 0;
      }
   }

   if (volume <= 0) {
      write("The " + short(0) + " is bone dry!\n");
      return 0;
   }
   
   run_out = 0;
   for (i = 0; i < sizeof(to) && !run_out; i++) {
      their_volume = (int)to[i]->query_volume();
      their_max = (int)to[i]->query_max_volume();

      if (their_max <= 0) {
         write("The " + to[i]->short(0) + 
               " doesn't look like it can be filled!\n");
         continue;
      }
   
      if (their_volume >= their_max) {
         write("The " + to[i]->short(0) + " is full to the brim already.\n");
         continue;
      }
   
      volume_needed = their_max * m / n;
      if (their_volume >= volume_needed) {
         write("The " + to[i]->short(0) + " is more than " + m + "/" + n +
           " full already.\n");
         continue;
      }
  
      ok++; 
      volume_needed -= their_volume;
   
      if (volume_needed > empty_formula()) {
         write("You drain the " + short(0) + " into the " + to[i]->short(0) + 
            " but it is not enough.\n");
         volume_needed = empty_formula();
         run_out = 1;
         this_player()->add_succeeded(to[i]);
      } else {
         this_player()->add_succeeded(to[i]);
/*
         write("You pour from the " + short(0) + " into the " + 
                to[i]->short(0) + ".\n");
 */
      }
  /* 
      say(this_player()->one_short() + " pours " + query_liquid_short() + 
         " from the " + short(0) + " into the " + to[i]->short(0) + ".\n");
   */ 
      amount_poured = volume_needed * ps_quantity / volume;
      transfer_liquid_to(to[i], volume_needed * (volume - water) / volume,
         misc_attrs, volume_needed * water / volume, ps_coord, amount_poured);
      amount_poured = remove_volume(volume_needed);
   }
   return ok;
} /* do_fill() */

/** @ignore yes */
int do_drink(object *dest, string me, string him, string prep)
{
   int amount_drunk, amount_can_be_drunk;

   if (sizeof(dest)) {
      write("Drinking is a very simple operation - please don't complicate matters.\n");
      return 0;
   }
   
   if (!ensure_open()) return 0;

   if (volume <= 0) {
      write("The " + short(0) + " is bone dry!\n");
      return 0;
   }
   
   amount_can_be_drunk = (2000 - (int)this_player()->query_volume(2)) * 
      (int)this_player()->query_con() / 12;
  /* should do some fudging to add +/- 5 mls or something */
  /* possibly skill/stat dependant */
   
   if (!volume_to_womble) volume_to_womble = empty_formula();
   if (volume_to_womble > empty_formula()) volume_to_womble = empty_formula();
   if (volume_to_womble > amount_can_be_drunk) {
      write("You drink some of the liquid, but simply cannot fit it all in.\n");
      volume_to_womble = amount_can_be_drunk;
   }
   amount_drunk = remove_volume(volume_to_womble);
  
   (void)POTION_SPACE_HANDLER->potion_drunk(this_player(), ps_coord, amount_drunk);
   this_player()->adjust_volume(2, volume_to_womble * 12 / 
      (int)this_player()->query_con());
   switch ((this_player()->query_volume(2) + 100) / 200) {
   case 5:
      write("You feel mildly full of liquid.\n");
      break;
   case 6:
      write("You feel very full of liquid.\n");
      break;
   case 7:
      write("You feel pissed.\n");
      break;
   case 8:
      write("You are awash with liquid.\n");
      break;
   case 9:
      write("You are full to the brim with liquid.\n");
      break;
   case 10:
      write("You feel you would burst if you drank any more.\n");
      break;
   }
   return 1;
}

/** @ignore yes */
int do_empty(object *dest, string me, string him, string prep)
{
   if (sizeof(dest)) {
      write("Passing on to pour ... bad move.\n");
      return do_pour(dest, me, him, prep);
   }
/* this completely fails to work :( ^^^ */
   
   if (!ensure_open()) { write("It aint open!\n"); return 0; }

   if (volume == 0) {
      write("The " + short(0) + " is already empty.\n");
      return 0;
   }

   if (volume_to_womble && volume_to_womble <= empty_formula())
      (void)remove_volume(volume_to_womble);
   else
      (void)remove_volume(empty_formula());
   
/* should check spillage */
   return 1;
}

/** @ignore yes */
int do_splash(object *dest, string me, string him, string prep) {
/* note that spashing needs to be changed to make the amount that 
   actually gets to the targe be related to some skill ... */
   int amount_splashed;

   if (sizeof(dest) > 1) {
      write("You can only splash one object at a time.\n");
      return 0;
   }

   if (!sizeof(dest))
     return 0;
   
   if (!ensure_open()) return 0;

   if (volume_to_womble && volume_to_womble <= empty_formula()) 
      amount_splashed = remove_volume(volume_to_womble);
   else
      amount_splashed = remove_volume(empty_formula());
   
   (void)POTION_SPACE_HANDLER->potion_touch(dest[0], ps_coord, amount_splashed);
   (void)this_player()->add_succeeded(dest[0]);
   return 1;
}

/** @ignore yes */
int do_rub(object *dest, string me, string him, string prep) {
   int amount_rubbed;

   if (sizeof(dest) > 1) {
      write("You can only "+query_verb()+" on to one object at a time.\n");
      return 0;
   }

   if (!sizeof(dest))
     return 0;

   if (environment(dest[0]) != this_player()) {
      write("You can only "+query_verb()+" on to an object in your inventory.\n");
      return 0;
   }

   if (!ensure_open()) return 0;

   if (volume_to_womble && volume_to_womble <= empty_formula())
      amount_rubbed = remove_volume(volume_to_womble);
   else
      amount_rubbed = remove_volume(empty_formula());

   (void)POTION_SPACE_HANDLER->potion_touch(dest[0], ps_coord, amount_rubbed);
   (void)this_player()->add_succeeded(dest[0]);
   return 1;
}

/** @ignore yes */
void do_apply(object *dest, string me, string him, string prep ) {
   do_rub( dest, me, him, prep );
}

#define TASTE_AMOUNT 5
/** @ignore yes */
int do_taste() {
   int amount_tasted;
   string desc;
   mixed *group;
   int i;
   /* be kind to tasters! */
 
   if (!ensure_open()) return 0;
 
   if (volume < TASTE_AMOUNT) {
      write("There is no liquid to taste.\n");
      return 0;
   }
   
   desc = "The " + query_liquid_short();
   if (!sizeof(all_attrs[POTION_FLAVOURS]) || 
     all_attrs[POTION_FLAVOURS][0][1] < VERY_SMALL_AMOUNT) 
      desc += " has no discernible flavour";
   else {
      group = ({ });
      for (i = 0; i < sizeof(all_attrs[POTION_FLAVOURS]) && 
           all_attrs[POTION_FLAVOURS][i][1] >= SMALL_AMOUNT; i++)
         group += all_attrs[POTION_FLAVOURS][i][0..0];
      
      if (sizeof(group)) {
         desc += " tastes of " + query_multiple_short(group);
         if (i < sizeof(all_attrs[POTION_FLAVOURS]) && 
             all_attrs[POTION_FLAVOURS][i][1] >= VERY_SMALL_AMOUNT)
            desc += " with a faint hint of ";
      } else desc += " tastes faintly of ";
      
      group = ({ });
      for (; i < sizeof(all_attrs[POTION_FLAVOURS]) && 
           all_attrs[POTION_FLAVOURS][i][1] >= VERY_SMALL_AMOUNT; i++)
         group += all_attrs[POTION_FLAVOURS][i][0..0];
      
      if (sizeof(group)) desc += query_multiple_short(group);
   }
   write(desc + ".\n");
   say(this_player()->one_short() + " takes a small sip from the " +
       short(0) + ".\n");
   
   amount_tasted = remove_volume(TASTE_AMOUNT);
   (void)POTION_SPACE_HANDLER->potion_drunk(this_player(), ps_coord, TASTE_AMOUNT);
   return 1;
}
 
/** @ignore yes */
int do_smell()
{
   string desc;
   string *group;
   int i;
   /* be kind to smellers! */
   
   if (!ensure_open()) return 0;
 
   if (volume < 1) {
      write("There is no liquid to smell.\n");
      return 0;
   }
   
   desc = "The " + query_liquid_short();
   if (!sizeof(all_attrs[POTION_SMELLS]) || 
     all_attrs[POTION_SMELLS][0][1] < VERY_SMALL_AMOUNT) 
      desc += " has no distinct aroma";
   else {
      group = ({ });
      for (i = 0; i < sizeof(all_attrs[POTION_SMELLS]) && 
           all_attrs[POTION_SMELLS][i][1] >= SMALL_AMOUNT; i++)
         group += all_attrs[POTION_SMELLS][i][0..0];
      
      if (sizeof(group)) {
         desc += " smells of " + query_multiple_short(group);
         if (i < sizeof(all_attrs[POTION_SMELLS]) && 
             all_attrs[POTION_SMELLS][i][1] >= VERY_SMALL_AMOUNT)
            desc += " with a faint hint of ";
      } else desc += " smells faintly of ";
      
      group = ({ });
      for (; i < sizeof(all_attrs[POTION_SMELLS]) && 
           all_attrs[POTION_SMELLS][i][1] >= VERY_SMALL_AMOUNT; i++)
         group += all_attrs[POTION_SMELLS][i][0..0];
      
      if (sizeof(group)) desc += query_multiple_short(group);
   }
   write(desc + ".\n");
   say(this_player()->one_short() + " takes a whiff of the " +
       short(0) + ".\n");
   
   (void)POTION_SPACE_HANDLER->potion_smell(this_player(), ps_coord, ps_quantity * 100 / volume);
   return 1;
}
 
/** @ignore yes */
mapping int_query_static_auto_load() {
  mapping tmp;

  tmp = ::int_query_static_auto_load();
  return ([ "::" : tmp,
            "leak rate" : leak_rate,
            "full weight" : full_weight,
            "trans" : query_transparent(),
            "difficulty" : query_difficulty(),
            "key" : query_key(),
            "trap open func" : query_open_trap_func(),
            "trap lock func" : query_lock_trap_func(),
            "trap open ob" : query_open_trap_ob(),
            "trap lock ob" : query_lock_trap_ob(),
            "max volume" : max_volume,
          ]);
} /* int_query_static_auto_load() */

/** @ignore yes */
mapping query_dynamic_auto_load() {
  if (!query_name() || query_name() == "object") {
    return 0;
  }
  return ([
           "::" : ::query_dynamic_auto_load(),
           "locked" : query_locked(),
           "stuck" : query_stuck(),
           "closed" : query_closed(),
           "volume" : volume,
           "water" : water,
           "misc attrs" : misc_attrs,
           "ps coord" : ps_coord,
           "ps quantity" : ps_quantity,
          ]);
} /* query_dynamic_auto_load() */

/** @ignore yes */
void init_dynamic_arg(mapping map) {
  mixed *ps_attrs;
  object money;

  if (map["::"])
    ::init_dynamic_arg(map["::"]);
  if (sizeof(map["money"])) {
     money = clone_object("/obj/money");
     money->set_money_array(map["money"]);
     money->move(this_object());
  }

  if (map["locked"]) {
     set_locked();
  } else {
     set_unlocked();
  }
  set_stuck(map["stuck"]);
  if (map["closed"]) {
     set_closed();
  } else {
     set_open();
  }

  volume = map["volume"];
  set_water_volume(map["water"]);
  if (volume == 0) {
    void_liquid();
    update_potion_parse();
    return;
  }
  misc_attrs = map["misc attrs"];
  ps_quantity = map["ps quantity"];
  ps_coord = map["ps coord"];
  ps_attrs = (mixed *)POTION_SPACE_HANDLER->query_attrs_at(ps_coord);
  if(!water) water = 1;
  active_attrs = change_concentration(ps_attrs, ps_quantity * 100 / water);
  all_attrs = merge_potions(active_attrs, misc_attrs, water, volume - water, volume);
  update_potion_parse();
} /* init_dynamic_arg() */

/** @ignore yes */
void init_static_arg(mapping args) {
  if (args["::"]) {
    ::init_static_arg(args["::"]);
  }
  if (!undefinedp(args["leak rate"])) {
    leak_rate = args["leak rate"];
  }
  if (!undefinedp(args["full weight"])) {
    full_weight = args["full weight"];
  }

  if (!undefinedp(args["trans"])) {
    if (args["trans"]) {
       set_transparent();
    } else {
       set_opaque();
    }
  }
  if (!undefinedp(args["difficulty"])) {
    set_difficulty(args["difficulty"]);
  }
  if (!undefinedp(args["key"])) {
    set_key(args["key"]);
  }
  if (!undefinedp(args["trap open func"])) {
    set_open_trap(args["trap open ob"], args["trap open func"]);
  }
  if (!undefinedp(args["trap lock func"])) {
    set_lock_trap(args["trap lock ob"], args["trap lock func"]);
  }

  if (!undefinedp(args["max volume"])) {
    max_volume = args["max volume"];
  }
} /* init_static_arg() */

/** @ignore yes
 * Do it all the time for containers...  They could have things in them.
 * too hard to andle rhe special cases you know...
 */
mixed query_static_auto_load() {
  if (!query_name() || query_name() == "object") return 0;
  if (file_name(this_object())[0..13] == "/obj/container")
    return int_query_static_auto_load();
  return ([ ]);
} /* query_static_auto_load() */

/**
 * This method stops the container being added when it is 
 * closed.  It also handles the same flags as the liing
 * object.  We assume this is not the same
 * as the default containers used
 * by things like item rooms and such.
 * @param ob the object being added
 * @param flag the addition flag
 * @see /std/basic/move.c
 */
int test_add(object ob, int flag) {
  return !query_closed() && !flag;
} /* test_addd() */

/** @ignore yes */
int can_find_match_recurse_into(object looker) {
   if (query_closed()) {
      return 0;
   }
   return ::can_find_match_recurse_into(looker);
} /* can_find_match_recurse_into() */

/** @ignore yes */
int test_remove(object ob, int flag) { return !query_closed(); }

/** @ignore yes */
varargs int move(mixed dest, string messin, string messout) {
   int result;
   object from;
   object to;

   from = environment();
   result = ::move(dest, messin, messout);
   if (result == MOVE_OK) {
      to = environment();
      we_moved(from, to);
   }
   return result;
} /* move() */

/** @ignore yes */
void dest_me() {
   close_lock_container::dest_me();
   container::dest_me();
} /* dest_me() */
// --- END [/mnt/home2/grok/lib/obj/container.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/package.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/package.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627925   Available: 13575279
Inodes: Total: 5242880    Free: 4960134
650 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/package.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627925   Available: 13575279
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:55.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: package.c,v 1.1 1999/07/28 19:03:35 ceres Exp $
 * 
*/
/**
 * Basic inheritable for a package. The main difference between this and
 * /obj/baggage is that the value of this is the sum of the values of the
 * items in the package.
 *
 * @author ceres
 */
inherit "/obj/baggage";

int query_value() {
  int value;
  object ob;

  value = ::query_value();

  foreach(ob in all_inventory())
    value += ob->query_value();

  return value;
}

/** @ignore yes */
mixed query_static_auto_load() {
  if ( base_name(this_object()) + ".c" == __FILE__ )
    return int_query_static_auto_load();
  return ([ ]);
}
// --- END [/mnt/home2/grok/lib/obj/package.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/monster/godmother/granny.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/monster/godmother/granny.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627925   Available: 13575279
Inodes: Total: 5242880    Free: 4960134
5811 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/monster/godmother/granny.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627925   Available: 13575279
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/obj/monster";
#include <panic.h>
#include <armoury.h>

void finish_up();

int state, start_time, prodded;
object lost;
string safeplace;

void setup() {
  start_time = time();
  set_name( "godmother" );
  set_short( "fairy godmother" );
  add_adjective( "fairy" );
  set_long( "This fairy godmother isn't quite what you expected.  She is "
    "tall and forbidding; not in the slightest bit cuddly or smiley.  She "
    "looks slightly uncomfortable and is currently glaring at her wand, "
    "which appears to be malfunctioning.  If you cross her, you might find "
    "yourself turned into a wombat or worse.\n" );

  set_race( "human" );
  set_guild( "witch" );
  set_level( 300 );
  set_gender( 2 );
  set_language("general");
  set_response_mon_understand_anything(1);
  add_property( "anchor", 1);

  ARMOURY->request_item("hobnailed boots", 100)->move( this_object() );
  ARMOURY->request_item("antique black dress", 100)->move( this_object() );
  ARMOURY->request_item("witchs pointy hat", 100)->move( this_object() );
  ARMOURY->request_item("black witches cloak", 100)->move( this_object() );
  init_equip();

  add_respond_to_with(({ "yes" }), "#yes_response");
  add_respond_to_with(({ "@nod" }), "#yes_response");
  add_respond_to_with(({ "no" }), "#no_response");
  add_respond_to_with(({ "@shake" }), "#no_response");
  add_respond_to_with(({ "@think", "somewhere", "safe" }), "#think_safe");
  add_respond_to_with(({ "@think", "safe" }), "#think_safe");
  add_respond_to_with(({ "@think", "safety" }), "#think_safe");
  add_respond_to_with(({ "@womble" }), "#think_mended_drum");
} /* setup() */


void do_panic(object pl) {

  string home;
  string nationality;

  nationality = pl->query_nationality();
   
  if ( !nationality ) { 
      queue_command( "say Oops.. you haven't got a nationality, I can't "
        "send you home!");
      finish_up();
      return;
  }

  home = nationality->query_default_start_location();
  safeplace = home->query_short();
 
  queue_command( "say I hope you're not foreign.  You know, where "
    "you gabble at me in heathen lingo and eat foreign muck and "
    "worship objects." );
  queue_command( "say So.  You want some help to get back to the "
    + safeplace + "?" );
  queue_command( "glare "+pl->query_name() );
  lost = pl;
  start_time = time();
} /* do_panic() */


int query_waiting() { return time()-start_time; }


void yes_response(object ob) {
  if (ob != lost)
    return ;
  queue_command( "say Right then.  Close your eyes and concentrate." );
  queue_command( "say Think of somewhere safe." );
  prodded = 0;
  call_out("check_think", 30);
} /* yes_response() */


void no_response(object ob) {
  if (ob != lost)
    return ;
  queue_command( "say So why did you call me up then?", 1 );
  queue_command( "roll eyes "+lost->query_name() );
  queue_command( "pinch "+lost->query_name()+" cheek" );
  PANIC_HANDLER->finish_panic(lost, PANIC_NOT_OK);
  lost = 0;
} /* no_response() */


void think_safe(object ob) {
  if (ob != lost)
    return ; 
  
  queue_command( "say Now the world will just rearrange itself "
    "to suit you." );
  PANIC_HANDLER->finish_panic(lost, PANIC_OK);
  lost = 0;
} /* think_safe() */


void check_think() {
  if(!lost)
    return;
  if (prodded < 3 ) {
    queue_command( "say Come on, I haven't got all day.  Just think of "
      "safety." );
    queue_command( "tap" );
    prodded ++ ;
    call_out("check_think", 60);
  } else {
    queue_command( "say Young people of today..." );
    queue_command( "mutter no manners" );
    PANIC_HANDLER->finish_panic(lost, PANIC_NOT_OK);
    lost = 0;
  }
} /* check_think() */


void event_exit(object ob, string message, object to) {
  if (ob == lost) {
    queue_command("hrmph");
    queue_command("tell "+lost->query_name()+" Thats right!  Just walk "
      "out on me.");
    queue_command("glare "+lost->query_name() );
    PANIC_HANDLER->finish_panic(lost, PANIC_NOT_OK);
    lost = 0;
  }
} /* event_exit() */


void event_fight_in_progress(object attacker, object attackee) {
  if (attackee == this_object()) {
/* Someone is attacking us! */
    attacker->adjust_tmp_str(-4);
    attacker->adjust_tmp_con(-4);
    attacker->adjust_tmp_dex(-4);
    attacker->adjust_tmp_int(-4);
    attacker->adjust_tmp_wis(-4);
    queue_command( "say What is this travesty!  Attacking your fairy "
               "godmother, Well I never." );
    queue_command( "say "+attacker->one_short()+" I here by curse you!" );
    queue_command( "say Don't expect me to help you again." );
    queue_command( "glare "+attacker->query_name() );
    attacker->add_property("attacked godmother", time());
    PANIC_HANDLER->finish_panic(lost, PANIC_NOT_OK);
    lost = 0;
  }
} /* event_fight_in_progress() */


void hurry_up() {
  if (!lost) {
    /* If the player has buggered off, we give up */
    queue_command( "blink" );
    queue_command( "say Where'd that bugger go?  Oh well.");
    PANIC_HANDLER->finish_panic(lost, PANIC_NOT_OK);
    lost = 0;
  }
  else  check_think();
} /* hurry_up() */


void finish_up() {
  if (lost) {
    queue_command( "say Well.  You took too long.  What a complete "
      "waste of time." );
    queue_command( "glare " + lost->query_name() );
    lost = 0;
  }
  else  {
    queue_command( "peer" );
    queue_command( "say Damn, they buggered off somewhere.  I hate "
      "it when they do that." );
    queue_command( "scowl" );
  }
  PANIC_HANDLER->finish_panic(lost, PANIC_NOT_OK);
} /* finish_up() */


void event_dest(object ob) {
  if (ob == lost) {
    PANIC_HANDLER->finish_panic(lost, PANIC_NOT_OK);
    lost = 0;
  }
} /* event_dest() */


void dest_me() {
  if (lost) {
    PANIC_HANDLER->finish_panic(lost, PANIC_NOT_OK);
    lost = 0;
  }
  ::dest_me();
} /* dest_me() */


int unambushable() {
  return 1;
}
// --- END [/mnt/home2/grok/lib/obj/monster/godmother/granny.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/monster/godmother/magrat.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/monster/godmother/magrat.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627923   Available: 13575277
Inodes: Total: 5242880    Free: 4960134
5787 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/monster/godmother/magrat.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627923   Available: 13575277
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/obj/monster";
#include <panic.h>
#include <armoury.h>

void finish_up();

int state, start_time, prodded;
object lost;
string safeplace;

void setup() {
  start_time = time();
  set_name("garlick");
  set_short("fairy godmother");
  add_alias("godmother");
  add_adjective("fairy");
  set_long( "In the realm of Fairy Godmothers, this one must certainly "
    "take honours in a Division Yet To Be Announced.  Grimly determined "
    "to do things properly, she has woven wild flowers in her "
    "windswept, golden locks, powdered her face to a fashionable pallor "
    "and has attired herself in numerous fluttering shawls, bangles, "
    "and a vivid green gown.  The overall effect is that of a maypole "
    "with a flower box emptied over its head that happens to jingle like "
    "a tinker's wagon with a broken wheel.  With one hand she clutches her "
    "regulation wand and with the other she dabs at her red and dripping "
    "nose with a damp scrap of lace.\n");

  set_race("human");
  set_guild("witch");
  set_level(200);
  set_gender(2);
  set_language("general");
  set_response_mon_understand_anything(1);
  add_property( "anchor", 1);

  ARMOURY->request_item("startling green dress", 100)->move( this_object() );
  ARMOURY->request_item("spiderweb shawl", 100)->move( this_object() );
  ARMOURY->request_item("pumps", 50)->move( this_object() );
  init_equip();

  add_respond_to_with(({ "yes" }), "#yes_response");
  add_respond_to_with(({ "@nod" }), "#yes_response");
  add_respond_to_with(({ "no" }), "#no_response");
  add_respond_to_with(({ "@shake" }), "#no_response");
} /* setup() */


void do_panic(object pl) {

  string home;
  string nationality;

  nationality = pl->query_nationality();
   
  if ( !nationality ) { 
      queue_command( "say Oops.. you haven't got a nationality, I can't "
        "send you home!");
      finish_up();
      return;
  }

  home = nationality->query_default_start_location();
  safeplace = home->query_short();
 
  queue_command( "say Umm.  Hi.  You are lost?  Would you like me to get "
             "you back to " + safeplace + "?" );
  queue_command( "emote waves her wand around a bit." );
  tell_room(environment(),
            "A puff of smoke drifts away from where something else used to "
            "be.  Now residing there is a pumpkin.\n");

  ARMOURY->request_item("pumpkin", 100)->move(environment());
  queue_command( "say Whoops." );
  lost = pl;
  start_time = time();
  prodded = 0;
  call_out("do_prod", 30);

} /* do_panic() */


int query_waiting() { return time()-start_time; }


void yes_response(object ob) {
  if (ob != lost)
    return ;
  queue_command( "say Oh, ahhh.  Good." );
  queue_command( "peer wor" );
  tell_object( lost, the_short() + " waves her wand in your direction.\n");
  tell_room( environment(), the_short() + " waves her wand in " +
    lost->the_short() + "'s direction.\n", lost );
  PANIC_HANDLER->finish_panic(lost, PANIC_OK);
  /* A couple of pumpkins for good luck. */
  ARMOURY->request_item("pumpkin", 100)->move(lost);
  ARMOURY->request_item("pumpkin", 100)->move(environment(lost));
  lost = 0;
} /* yes_response() */


void no_response(object ob) {
  if(ob != lost)
    return;
  queue_command( "say Oh, I must have got lost somewhere then." );
  queue_command( "wave" );
  queue_command( "say Oh dear." );
  ARMOURY->request_item("pumpkin", 100)->move(lost);
  ARMOURY->request_item("pumpkin", 100)->move(environment(lost));
  PANIC_HANDLER->finish_panic(lost, PANIC_NOT_OK);
  lost = 0;
} /* no_response() */


void do_prod() {
  if(!lost)
    return;
  if (prodded < 3 ) {
    queue_command( "say Umm....so....what do you think?  Do you want "
      "my help?" );
    queue_command( "expect "+lost->query_name() );
    prodded ++ ;
    call_out("do_prod", 60);
  } else {
    queue_command( "say Oh well.  I guess it wasn't me you wanted after all" );
    queue_command( "sigh" );
    PANIC_HANDLER->finish_panic(lost, PANIC_NOT_OK);
    lost = 0;
  }
} /* do_prod() */


void event_exit(object ob, string message, object to) {
    if (ob == lost) {
    queue_command( "say Bye..." );
    queue_command( "wave" );
    queue_command( "say Whoops." );
    queue_command( "tell "+lost->query_name()+" Sorry to have bothered you." );
    PANIC_HANDLER->finish_panic(lost, PANIC_NOT_OK);
    ARMOURY->request_item("pumpkin", 100)->move(environment(lost));
    lost = 0;
  }
} /* event_exit() */


void hurry_up() {
  if (!lost) {
    /* If the player has buggered off, we give up */
    queue_command( "blink twice" );
    queue_command( "say I guess my help wasn't wanted, then..." );
    PANIC_HANDLER->finish_panic(lost, PANIC_NOT_OK);
    lost = 0;
  }
  else do_prod();
} /* hurry_up() */


void event_fight_in_progress(object attacker, object attackee) {
  if (attackee == this_object()) {
    queue_command( "say Look, this is really not very nice." );
    queue_command( "frown" );
    queue_command( "say I know the art of self defence you know!" );
    set_hp(query_max_hp(), attacker);
    attackee->adjust_tmp_str(-2);
    attackee->adjust_tmp_dex(-2);
    attackee->adjust_tmp_wis(-2);
    attackee->adjust_tmp_int(-2);
    attackee->adjust_tmp_con(-2);
    attackee->add_property("attacked godmother", time());
    PANIC_HANDLER->finish_panic(lost, PANIC_NOT_OK);
    lost = 0;
  }
} /* event_fight_in_progress() */


void finish_up() {
  queue_command( "shuffle" );
  queue_command( "say Umm.  I have to go." );
  queue_command( "smile appol" );
  queue_command( "wave" );
  PANIC_HANDLER->finish_panic(lost, PANIC_NOT_OK);
  lost = 0;
} /* finish_up() */


void dest_me() {
  if (lost) {
    PANIC_HANDLER->finish_panic(lost, PANIC_NOT_OK);
    lost = 0;
  }
  ::dest_me();
} /* dest_me() */


int unambushable() {
    return 1;
}
// --- END [/mnt/home2/grok/lib/obj/monster/godmother/magrat.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/monster/commercial.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/monster/commercial.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627922   Available: 13575276
Inodes: Total: 5242880    Free: 4960134
12939 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/monster/commercial.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627922   Available: 13575276
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/obj/monster";
#include <money.h>

private object _sell_to;
private string* _furniture;
private string _commercial_type;

int do_list(int force);

void setup() {
   set_name("spulluf");
   set_gender(1 + random(2) );
   set_long("A nice happy person with a nice smile.\n");
   add_property("demon", 1);
   set_race( "human" );
   set_level( 1 );

   add_help_file("spulluf");

   add_respond_to_with(({ "@say", "browse" }), "#do_browse");
   add_respond_to_with(({ "@say", "buy" }), "#do_buy");
   _furniture = ({
        "/obj/furnitures/commercial/smithy",
        "/obj/furnitures/commercial/money_changer",
        "/obj/furnitures/commercial/blackjack",
        "/obj/furnitures/commercial/small_shop",
        "/obj/furnitures/commercial/pickler",
        "/obj/furnitures/commercial/blackboard",
        "/obj/furnitures/commercial/newspaper_box",
        "/obj/furnitures/commercial/newspaper_archive_box",
        "/obj/furnitures/commercial/bank_master",
        "/obj/furnitures/commercial/bank_franchise_small",
        "/obj/furnitures/commercial/postal",
        "/obj/furnitures/commercial/poll_data",
      });
} /* setup() */

string query_money_place() {
   return environment()->query_property("place");
} /* query_moneY_place() */

void set_commercial_type(string commercial_type) {
   _commercial_type = commercial_type;
} /* set_commercial_type() */

void do_start_speil(object sellto) {
   setup_nationality(sellto->query_nationality(), sellto->query_nationality_region());

   _sell_to = sellto;
   queue_command("sayto " + file_name(_sell_to) +
                 " Hello!  So you are looking at some commercial "
                 "furniture?");
   //do_list(1);
} /* do_list() */

int do_list(int force) {
   string furn;
   string place;
   int num;
   int size;
   object ob;

   if (!_sell_to) {
      call_out("leave_room", 5);
      return 0;
   }
   if (!force && this_player() != _sell_to) {
      queue_command("sayto " + file_name(this_player()) +
                 " I am dealing with " + _sell_to->the_short() +
                 " right now.");
      return 1;
   }

   queue_command("sayto " + file_name(_sell_to) +
                 " I have the following items available.");
   num = 0;
   place = query_money_place();
   foreach (furn in _furniture) {
      if (!_commercial_type ||
          furn->query_commercial_type() == _commercial_type) {
         queue_command("sayto " + file_name(_sell_to) +
                    sprintf(" %c) %s costs %s (%d square yards)",
                            num + 'A', furn->the_short(),
                            MONEY_HAND->money_value_string(furn->query_value(), place),
                            furn->query_commercial_size()));
         num++;
      }
   }

   foreach (ob in all_inventory(environment())) {
      size += ob->query_commercial_size();
   }
   queue_command("sayto " + file_name(_sell_to) +
                  " The size of your shop is " +
                  environment()->query_property_size() +
                  " square yards and you have " +
                  (environment()->query_property_size() - size) + 
                  " square yards of empty space.");
   return 1;
} /* do_list() */

string strip_spaces(string str) {
   while (strlen(str) && str[0] == ' ') {
      str = str[1..];
   }
   while (strlen(str) && str[<1] == ' ') {
      str = str[0..<2];
   }
   return str;
} /* strip_spaces() */

void leave_room() {
   move("/room/rubbish", "$N shuffles away.");
} /* leave_room() */

int do_browse(string str) {
   mapping options;
   mapping values;
   string option_name;
   string thing;
   string* bits;
   string place;
   int cost;
   int pos;
   string* furns;

   if (!_sell_to) {
      call_out("leave_room", 5);
      return 0;
   }
   place = query_money_place();
   if (this_player() != _sell_to) {
      queue_command("sayto " + file_name(this_player()) +
                 " I am dealing with " + _sell_to->the_short() +
                 " right now.");
      return 1;
   }

   str = lower_case(str);
   pos = str[0] - 'a';
   if (_commercial_type) {
      furns = filter(_furniture, (: $1->query_commercial_type() == _commercial_type :));
   } else {
      furns = _furniture;
   }
   if (strlen(str) > 1 || pos < 0 || pos >= sizeof(furns)) {
      queue_command("sayto " + file_name(_sell_to) +
                    " Sorry, I do not understand which thing "
                    "you want to browse.\n");
      return 1;
   }

   queue_command("sayto " + file_name(_sell_to) + " " +
                 furns[pos]->the_short() + " costs " +
                 MONEY_HAND->money_value_string(furns[pos]->query_value(), place) +
                 " and takes up " + furns[pos]->query_commercial_size() +
                 " square yards.");
   if (furns[pos]->query_weekly_upkeep_cost()) {
      queue_command("sayto " + file_name(_sell_to) +
                    " Costs " +
                    MONEY_HAND->money_value_string(furns[pos]->query_weekly_upkeep_cost(), place) +
                    " per week in upkeep.");
   }
 

   queue_command("sayto " + file_name(_sell_to) +
                 " " +
                 furns[pos]->long()[0..<2]);
   thing = furns[pos]->query_commercial_information();
   if (thing) {
      queue_command("sayto " + file_name(_sell_to) +
                    " " + thing);
   }
   options = furns[pos]->query_commercial_options();
   if (options) {
      queue_command("sayto " + file_name(_sell_to) +
                    " You have the following options for " +
                    furns[pos]->the_short());
      foreach (option_name, values in options) {
         bits = ({ });
         foreach (thing, cost in values) {
            bits += ({ "'" + thing + "' costs " +
                       MONEY_HAND->money_value_string(cost, place) });
         }
         queue_command("sayto " + file_name(_sell_to) +
                       " The options for '" + option_name  + "' are " +
                       query_multiple_short(bits));
     
      }
   }
   return 1;
} /* do_browse() */

int do_buy(string str, string options) {
   string place;
   string* bits;
   string name;
   string value;
   string thing;
   string option_name;
   string my_option;
   int pos;
   int size;
   int cost;
   int total_cost;
   int bad_option;
   int found;
   mapping option_types;
   object ob;
   string* furns;
   mapping values;
   mapping option_values;

   if (!_sell_to) {
      call_out("leave_room", 5);
      return 0;
   }
   place = query_money_place();
   if (this_player() != _sell_to) {
      queue_command("sayto " + file_name(this_player()) +
                 " I am dealing with " + _sell_to->the_short() +
                 " right now.");
      return 0;
   }

   str = lower_case(str);
   pos = str[0] - 'a';
   if (_commercial_type) {
      furns = filter(_furniture, (: $1->query_commercial_type() == _commercial_type :));
   } else {
      furns = _furniture;
   }
   if (strlen(str) > 1 || pos < 0 || pos >= sizeof(furns)) {
      queue_command("sayto " + file_name(_sell_to) +
                    " Sorry, I do not understand which thing "
                    "you want to buy.\n");
      return 1;
   }

   if (furns[pos]->disallow_sale_here(environment())) {
      queue_command("sayto " + file_name(_sell_to) +
                    " Sorry, this room disallows the purchase of that item.");
      return 0;
   }

   bits = explode(options, ",");
   option_types = ([ ]);
   foreach (thing in bits) {
      if (sscanf(thing, "%s=%s", name, value) == 2) {
         name = strip_spaces(name);
         value = strip_spaces(value);
         option_types[lower_case(name)] = lower_case(value);
      }
   }

   foreach (ob in all_inventory(environment())) {
      size += ob->query_commercial_size();
   }

   if (size + furns[pos]->query_commercial_size() >
       environment()->query_property_size()) {
      queue_command("sayto " + file_name(_sell_to) +
                    " The item " + furns[pos]->the_short() +
                    " is too big to fit into " + environment()->the_short());
      return 0;
   }

   //
   // Check to make sure all the options are set correctly.
   //
   option_values = furns[pos]->query_commercial_options();
   if (option_values) {
      foreach (option_name, values in option_values) {
         my_option = option_types[lower_case(option_name)];
         if (!my_option) {
            queue_command("sayto " + file_name(_sell_to) +
                    " The option '" + option_name + "' needs to be "
                    "specified.");
            bad_option = 1;
         } else {
            foreach (thing, cost in values) {
               if (lower_case(thing) == my_option) {
                  // Excelent.
                  total_cost += cost;
                  found = 1;
                  option_types[lower_case(option_name)] = thing;
               }
            }
            if (!found) {
               queue_command("sayto " + file_name(_sell_to) +
                       " The option " + option_name + " has options "
                       "of " + query_multiple_short(keys(values)) + ".");
               bad_option = 1;
            }
         }
      }
   }

   if (bad_option) {
      return 0;
   }

   total_cost += furns[pos]->query_value();
   if (this_player()->query_value_in(place) < total_cost) {
      queue_command("sayto " + file_name(_sell_to) +
              " You do not have the " +
              MONEY_HAND->money_value_string(total_cost, place) +
              " to buy " + furns[pos]->the_short() + ".");
      return 0;
   }

   this_player()->pay_money(MONEY_HAND->create_money_array(total_cost, place),
                            place);
   ob = clone_object(furns[pos]);
   foreach (name, thing in option_types) {
      ob->set_commercial_option(name, thing, environment());
   }
   ob->move(environment());
   return 1;
} /* do_buy() */

int do_dismiss() {
   if (_sell_to && this_player() != _sell_to) {
      queue_command("sayto " + file_name(this_player()) +
                 " I am dealing with " + _sell_to->the_short() +
                 " right now.");
      return 1;
   }

   queue_command("sayto " + file_name(this_player()) +
                 " Goodbye, see you next time.");
   call_out("leave_room", 5);

   return 1;
} /* do_dismiss() */

int do_trash(object* obs) {
   object* ok;
   object* bad;

   ok = filter(obs, (: $1->query_commercial_furniture() :));
   if (!sizeof(ok)) {
      queue_command("sayto " + file_name(_sell_to) +
                    " None of " + query_multiple_short(obs) + " are "
                    "commercial items, so I cannot remove them.");
      return 0;
   }

   //
   // Trash them.
   //
   bad = filter(ok, (: !$1->can_trash_furniture() :));
   if (sizeof(bad)) {
      this_player()->add_failed_mess(this_object(),
                      "The items $I are unable to be trashed.  Perhaps they "
                      "still have something in them?\n");
      return 0;
   }

   write("Are you sure you want to trash " + query_multiple_short(ok) +
         "; this will get rid of them completely? ");
   input_to("complete_trash", 0, ok);
   this_player()->add_succeeded_mess(this_object(), "", ({ }));
   return 1;
} /* do_trash() */

/** @ignore yes */
void complete_trash(string str, object* obs) {
   str = lower_case(str);
   if (!strlen(str) || str[0] != 'y') {
      write("Aborting trash.\n");
   }

   queue_command("sayto " + file_name(_sell_to) + " Trashing " +
                 query_multiple_short(obs) + " for you.\n");
   obs->move("/room/rubbish", "", the_short() + " points at $N and it rips "
             "apart then vanishes.");
} /* complete_trash() */

void init() {
   ::init();

   this_player()->add_command("trash", this_object(),
                              "<indirect:object> with <direct:object>",
                              (: do_trash :));
   this_player()->add_command("dismiss", this_object(),
                              "<direct:object>",
                              (: do_dismiss() :));
   this_player()->add_command("list", this_object(),
                              "<direct:object>",
                              (: do_list(0) :));
   this_player()->add_command("list", this_object(),
                              "{on|from} <direct:object>",
                              (: do_list(0) :));
   this_player()->add_command("browse", this_object(),
                              "<string'name'> on <direct:object>",
                              (: do_browse($4[0]) :));
   this_player()->add_command("buy", this_object(),
                              "<string'name'> {on|from} <direct:object>",
                              (: do_buy($4[0], "") :));
   this_player()->add_command("buy", this_object(),
                              "<string'name'> with <string'options'> {on|from} <direct:object>",
                              (: do_buy($4[0], $4[1]) :));
} /* init() */
// --- END [/mnt/home2/grok/lib/obj/monster/commercial.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/monster/cabbage.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/monster/cabbage.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627918   Available: 13575272
Inodes: Total: 5242880    Free: 4960134
6360 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/monster/cabbage.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627918   Available: 13575272
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/obj/monster";

#define SCATHE "/cmds/guild-race/magic/scathe"
#define LANCE "/obj/spells/mental_lance"

#include <config.h>
#ifndef __DISTRIBUTION_LIB__
#include <special_day.h>
#endif
#include <move_failures.h>
#include <armoury.h>

object query_owner();
void check_env();
void zap_cabbage();
string long_desc();

int eaten;
string owner_name, owner_short, language;
object owner;



void setup() {
  set_name( "cabbage" );
  set_short( "cabbage" );
  set_long( "A small cute looking cabbage.\n" );
  set_race( "cabbage" );
  set_level( 1 );

  add_respond_to_with( ({ ({ "@hug", "@snuggle", "@cuddle", "@nestle",
    "@snuffle", "@smooch", "@fondle", "@huggle", "@squeeze", "@wuffle"
    "@hop", "@lick", "@snog", "@fluff", "@nuzzle" }), "you" }), 
    "#respond_nice");
    
  add_respond_to_with( ({ ({ "@skick", "@spunch", "@sburn", "@jump", }),
    "you" }), "#respond_nasty");

#ifndef __DISTRIBUTION_LIB__
  if (SPECIAL_DAY_HANDLER->query_special_day() == CABBAGE_DAY) {
    add_property( "player", 1 ); // Can't be buried.
    set_get();
  }
#endif
} /* setup() */


void init() {
  ::init();
  this_player()->add_command("eat", this_object(), "<direct:object'cabbage'>" );    
  call_out( "check_env", 3 );
} /* init() */


void set_owner( object thing ) {
  if (!objectp( thing ) )
    return;
  set_long( (: long_desc :) );
  owner = thing;
  owner_name  = owner->query_name();
  owner_short = owner->query_short();
  language = owner->query_default_language();
  
  add_language( language );
  set_language( language );
  load_chat(30, ({
    1, "@roll up",
    1, "@purr",
    1, ":$V$0=ruffles its,ruffle their$V$ fronds.",
    1, ":$V$0=looks,look$V$ green.",
    3, "#soul_owner",
    1, "@roll over",
    1, "#check_env" }) );
    
  check_env();
} /* set_owner() */


string long_desc() {
  if ( owner && environment( owner ) == environment() ) {
    return "This small, cute-looking cabbage stares adoringly at " 
      + owner->the_short() + ".\n";
  }
  return "This small, cute-looking cabbage is looking off into the "
    "distance.  It is obviously hopelessly lost.\n";
} /* long_desc() */
        
        
void respond_nice( object souler ) {
  if ( !souler->query_visible(this_object()) )
    return;
  if ( owner && souler == owner) {
    do_command("nestle " + souler->query_name() );
  } else {
    do_command("peer curiously " + souler->query_name() );
  }
} /* respond_nice() */


void respond_nasty( object souler ) {
  if ( !souler->query_visible(this_object()) )
    return;
  if ( owner && souler == owner) {
    do_command("gasp");
    do_command("cry");
  } else {
    do_command( "sburn " + souler->query_name() + " dreams");
  }
} /* respond_nasty() */


int do_eat() {
  if ( this_player() != owner || eaten) {
    this_player()->add_failed_mess( this_object(), "You cannot eat this "
      "cabbage!\n" );
  return -1;
  }
  
  if( this_player()->query_property("dead") ) {
    this_player()->add_failed_mess( this_object(), "You are dead.  You "
      "cannot eat.\n" );
  }
    
#ifndef __DISTRIBUTION_LIB__
    if (SPECIAL_DAY_HANDLER->query_special_day() == CABBAGE_DAY) {
      this_player()->add_failed_mess(this_object(), "This is *my* day, "
      "how can you even think of eating me, your faithful cabbage!\n" );
      return -1;
    }
#endif
    
  this_player()->add_succeeded_mess( this_object(), 
    ({ "The cabbage lovingly and "
       "adoringly purrs quietly as you viciously rip off its fronds and "
       "eat it.  It dies looking wonderingly into your face.\n", 
       "$N $V $D.\n" }) );
    this_player()->add_effect("/std/effects/object/cabbage", 150);
    call_out("zap_cabbage", 2 );
    
    return 1;
} /* do_eat() */


void zap_cabbage() {        
  if ( environment() ) {
    all_inventory()->move( environment() );
  }
  if ( owner ) {
    do_command( "unfollow " + owner_name );
  }
  eaten = 1;
  owner = 0;
  owner_name = 0;
  owner_short = 0;
  move( "/room/rubbish" );
} /* zap_cabbage() */


int attack_by(object ob) {
  if( ( !query_owner() || ob == query_owner() ) && 
        base_name( previous_object() ) == LANCE )
    call_out( "coleslaw", 2 );
    
  ob->stop_fight(this_object());
  tell_object(ob, "The cabbage is a terrible pacifist.\n");
} /* attack_by() */

int attack_ob(object ob) {
  ob->stop_fight(this_object());
  tell_object(ob, "The cabbage is a terrible pacifist.\n");
} /* attack_by() */

int adjust_hp(int number, object attacker) {
  return 0;
} /* adjust_hp() */


void soul_owner() {
  string *souls = ({ "snuggle ", "nestle ", "stare dreamily ", "snuffle " });
  if(!owner)
    return;
  
  if ( environment() != environment( owner ) ) {
    do_command( "sniffle sadly" );
    return;
  } 
  if ( !owner->query_visible(this_object()) )
    return;
  
  do_command( souls[random(sizeof(souls))] + owner_name );
} /* soul_owner() */


void check_env() {
  object my_env, owner_env, *caterpillars;
  
  if ( !owner_name )
    return;

  my_env = environment();
    if ( !my_env ) {
        return;
    }
    
  if ( owner_name && !owner ) {
    do_command( "cry" );
    do_command( "'Woe is me! Where art thou, " + owner_short + "?" );
    call_out("zap_cabbage", 1);
    return;
  }
    
  owner_env = environment( owner );
  if ( !owner_env ) {
    return;
  }

  if ( file_name( my_env ) == "/room/rubbish" ) {
    return;
  }
    
  if ( this_object()->query_property( "dead" ) ) {
    return;
  }

  if (my_env == owner) {
    return ;
  }

  if (owner_env == my_env) {
    return ;
  }

  if (owner_env->query_mirror_room() == my_env) {
    return ;
  }
    
  caterpillars = match_objects_for_existence( "caterpillar", ({ owner_env }) );
    
  if ( my_env != owner_env && !sizeof(caterpillars)) {
    move( owner_env, "$N appear$s with a squelch.",
      "$N disappear$s with a squelch." );
    do_command( "follow " + owner_name );
  }

} /* check_env() */


object query_owner() { 
    return owner; 
} /* query_owner() */


/*
 * On Cabbage Day, we need to be moved out of a player's inventory.
 */
int query_theft_command() {
    return -1;
} /* query_theft_command() */


void coleslaw() {
  object ob;

  tell_room( environment(), the_short() + " explodes in a shower of "
      "fronds.\n" );
  ob = ARMOURY->request_object("coleslaw", 100);
  if (ob) {
     ob->move( environment() );
  }
  zap_cabbage();
} /* coleslaw() */
// --- END [/mnt/home2/grok/lib/obj/monster/cabbage.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/monster/cockroach.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/monster/cockroach.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627917   Available: 13575271
Inodes: Total: 5242880    Free: 4960134
923 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/monster/cockroach.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627917   Available: 13575271
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/obj/monster";

void setup() {
   set_name("cockroach");
   set_short("cockroach");
   set_race("cockroach");
   set_level( random( 1 + random( 3 ) ) );
   set_main_plural("cockroaches");
   add_alias( "roach" );
   add_plural( "roaches" );
   add_adjective("dirty");
   set_long("This is a huge dirty great big cockroach, the size of your "
            "hand at least.  It waves it feelers at you and looks "
            "horrible and black.  Not only can cockroaches survive "
            "a nuclear blast, they can survive in Ankh-Morpork!\n");
   load_chat( 5, ({
         10, ":scuttles around a bit.",
         10, ":cleans its feelers.",
         10, ":rushes around in circles.",
         1,  ":jerks off in a strange direction.",
      }) );
   set_wimpy( 30 );
   load_a_chat( 50, ({
         1, ":oozes horrible white stuff.",
         1, ":makes a sort of scraping noise."
      }) );
} /* setup() */

// --- END [/mnt/home2/grok/lib/obj/monster/cockroach.c] ---
// --- BEGIN [/mnt/home2/grok/lib/obj/monster/greco.c] ---
// Size:   File: "/mnt/home2/grok/lib/obj/monster/greco.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627916   Available: 13575270
Inodes: Total: 5242880    Free: 4960134
10518 bytes, Last Modified:   File: "/mnt/home2/grok/lib/obj/monster/greco.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627916   Available: 13575270
Inodes: Total: 5242880    Free: 4960134
2006-10-07 20:59:54.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* a different attempt by Ember to make an accountable auto_loading system */
/* uses old system, with a different front end */
/* 
 *  30-Oct-93    created by E
 *  24-Oct-96    Fiddled by Pinkfish to create the alter ego - Gumboot.
 *  05-Feb-97    Changed by Olorin to not trust find_call_out
 */

#define ITEM_TRACKER ("/obj/handlers/item_tracker")

inherit "/obj/monster";

object my_player;
mixed total_als;      /* generated total auto-load-string */
object *save_obs;
object *unhandled_obs;
object *done_obs;

int grecos_day_off;

void setup() {
  seteuid("Root");
  if (!grecos_day_off) {
    set_name("greco");
    set_short("Greco the Departure Gecko");
    set_long("A small mottled grey gecko whose job it is to record all of "
             "the baggage of players so they can be restocked when they "
             "come back.  Greco is currently scribbling in " 
             + query_possessive() + " notebook furiously.\n");
  } else {
    /* Gumboot.  Greco's happy replacement. */
    set_name("gumboot");
    set_short("Gumboot");             
    set_long("A big black lizard who looks rather confused about what "
             + query_pronoun() + " is supposed to be doing.  Nevertheless, "
             + query_pronoun() + " is trying to look busy, scrawling "
             "something into a huge log book.\n"); 
  }                      
              
  add_property("determinate", "");
  add_property("no_attack", 1);
  set_gender(1+random(2));  /* Greco (or Gumboot) the androgynous gecko */
  basic_setup("gnome", "warrior", 30);
  set_language("general");

} /* setup() */

void set_grecos_day_off(int day_off) {
  grecos_day_off = day_off;
  setup();
} /* set_grecos_day_off() */

int query_grecos_day_off() {
  return grecos_day_off;
} /* query_grecos_day_off() */

void get_rid_of(object player, int verbose) {
  int i;

  catch(set_grecos_day_off("/obj/monster/greco"->query_grecos_day_off()));
  if (verbose) {
    if (!grecos_day_off) {
      tell_object(player, "Greco the Departure Gecko starts inspecting "
                          "all your items and scribbling on a "
                          "notepad.\n");
    } else {
      tell_object(player, "This is Greco's day off.\nGumboot, Greco's "
                          "distant relative, is here to take your "
                          "information.  Gumboot looks very confused "
                          "and sticks the pencil in "+
                          query_possessive()+" ear.\n");
    }
  }
  my_player = player;
  unhandled_obs = save_obs = all_inventory(player);
  total_als = ({ });
  done_obs = ({ });
  for (i = 0; i < sizeof(save_obs); i++) 
    call_out("get_ob_al", 1, save_obs[i], verbose);
  call_out("finish_player", 2, verbose);
} /* get_rid_of() */

void get_ob_al(object ob, int verbose)
{
  mixed *als;

  /* this is call_outed for each object in the player's inventory */
  /* it should add to the autoload array and the done_obs array */
  unhandled_obs -= ({ ob }); 
  als = my_player->fragile_auto_str_ob(ob);
  done_obs += ({ ob });
  if (sizeof(als) == 0) return;
  total_als += als;
} /* get_ob_all() */

void handle_dead_ob(object ob) {
  int value;
  mixed *als;
  string obname;

  catch(ob->move("/room/broken"));
  value = 1000; /* random anonymous replacement value */
  catch(value = ob->query_value());
  obname = "unknown object";
  catch(obname = ob->short(1));
  catch("/obj/misc/al_receipt"->set_object(file_name(ob)));
  "/obj/misc/al_receipt"->set_obname(obname);
  "/obj/misc/al_receipt"->set_value(value);
  als = "/global/auto_load"->
    fragile_auto_str_ob(find_object("/obj/misc/al_receipt"));
  als[0] = 1;
  // This is a bit of a hack.  It could easily break if the receipt
  // inheritance changes.
  if (!undefinedp(als[2][1]["::"]["cloned by"])) {
    als[2][1]["::"]["cloned by"] = "greco";
  }
  log_file("GRECO", "%s: %s - Broken object at logout: %O\n",
           ctime(time()), my_player?my_player->query_name():"0", ob);
  total_als += als;
} /* handle_dead_ob() */

void finish_player(int verbose) {
  /* this is called after all of the auto_load call_outs are complete,
   * so it should check which objects failed to complete and write out
   * receipts for them ... */
  int i, one_more;
  object *missing_obs;

  if (find_call_out("get_ob_al") != -1) {
    call_out("finish_player", 2, verbose);
    return;
  }
  if ( sizeof( unhandled_obs ) ) {
     /* find_call_out isn't to be trusted:(
      */
    call_out("finish_player", 2, verbose);
    return;
  }
  missing_obs = save_obs - done_obs;
  if (sizeof(missing_obs)) {  
    one_more = sizeof(missing_obs);
    if (!grecos_day_off) {
      do_command("'"+(one_more==1?"One":"Some")+
                 " of your objects "+(one_more==1?"is":"are")+" broken and "
                 "will not save properly, so I will give you "+
                 (one_more==1?"a receipt for it.  This":
                              "receipts for them.  These")+
                 " can either be "
                 "sold for something vaguely like the replacement value of "
                 "the object or taken to a creator as proof of ownership "
                 "so you can ask very nicely to have it replaced.");
    } else {
      do_command("'Ummm.  I think some of these things of yours might "
                 "be broken.  Ummmm.....  Here, have some of these "
                 "receipt things.  Give them to a creator and they will "
                 "help you in trying to replace them.  Ummmm....  "
                 "Good luck.");
    }
    for (i = 0; i < sizeof(missing_obs); i++)
      handle_dead_ob(missing_obs[i]);
  }

  my_player->save_with_auto_load(total_als);
  if (verbose) {
    if (!grecos_day_off) {
      do_command( "smile brightly" );
      do_command( "'Well, everything seems to be in order.  Bye bye!" );
      do_command( "wave" );
      switch (random(3)) {
      case 0:
        tell_object(my_player, "You clamber aboard the giant spider.  It "
                    "opens the door, releases a thread of silk out into space "
                    "and, after a brief pause, climbs out after it possibly "
                    "never to be seen again ...\n");
        say(my_player->short(1) + " clambers aboard the giant spider.  It "
            "opens the door, releases a thread of silk out into space and, after "
            "a brief pause, climbs out after it.\n", my_player);
        break;
      case 1:
        tell_object(my_player, "The giant bird grabs you in its talons and leaps "
                    "out of the now open door to fly at great speed into the "
                    "black unknown ...\n");
        say(my_player->short(1) + " is grabbed by the talons of the giant bird "
            "and dragged out a door into the blackness of space.\n", my_player);
        break;
      case 2:
        tell_object(my_player, "You are thrown on to the back of the chimera.  "
                    "Clinging desperately to its mane you follow the beast out "
                    "into the inky depths.\n");
        say(my_player->short(1) + " is thrown onto the back of the chimera and "
            "dragged out into the inky depths.\n", my_player);
        break;
      }
    } else {
      do_command("smile strangely");
      do_command("'Well.  Uhhhh.  Thats it.");
      do_command("'I...  Umm.  Hope.");
      switch (random(3)) {
        case 0 :
          tell_object(my_player,
             "You clamber about a giant spider.  Gumboot starts to walk out "
             "the door and stands on one of it's feet.  You are flung from "
             "the back of the giant spider out through the door and "
             "floating meaninglessly through space.  You hope you will "
             "be seen again...\n");
          say(my_player->short(1)+" clambers aboard the giant spider.  It "
             "moves towards the door when something happens.  "+
             my_player->short(1)+" gets flung out through the door.\n");
          break;
        case 1 :
          tell_object(my_player,
             "The giant bird grabs you in it's talons and leaps out towards "
             "the now open door.\nGumboot exclaims: Wait!  I forgot to get your "
             "name!\nThe bird pauses confused and you thud into the side of "
             "the door and tumble backwards out into space, you try not "
             "notice the huge rents in your shoulder from where the talons "
             "ripped about your flesh.  Just a flesh wound.\n");
          say(my_player->short(1)+" is grabbed by the talons of the giant "
             "bird.  As they are heading for the door, Gumboot yells "
             "something at them, the bird gets disconcerted and rams "+
             my_player->short(1)+" into the door.  They tumble out into "
             "space a red line of blood showing their path.\n");
          break;
        case 2 :
          tell_object(my_player,
             "You are thrown towards the back of a chimera, you completely "
             "fail to get a hold on the mane and falls off it onto the "
             "floor.  The chimera steps backwards, convenient impaling you "
             "on a foot.  It then leaps through the door, you clutch your "
             "stomach hoping it is not permanent.\n");
          say(my_player->short(1)+" is thrown at a chimera, they don't catch "
             "hold of it, but they get impaled on it's foot when it steps "
             "back.  The chimera with a look of satisfaction dives through "
             "the door.\n");
          break;
      }
    }
  }
  tell_object(my_player, "Do come again!\n");

  // If we break here, then the player won't be destructed and then their
  // partially destructed inventory will overwrite their new inventory
  // when they idle out of the departure lounge!

  foreach( object saved_ob in done_obs ) { 
     reset_eval_cost(); 

     catch(saved_ob->set_tracked_item_status_reason("PLAYER_QUIT"));
     catch(saved_ob->dest_me());

     if ( saved_ob ) { 
         catch(saved_ob->dwep());
     }
  }
  
  // Should be the last one we need. 
  reset_eval_cost();

  catch( ITEM_TRACKER->save_all_item_states_delete_cache( my_player->query_name() ));
  catch(my_player->effects_quiting());
  catch(my_player->dest_me());
  if ( my_player ) {
    catch( my_player->dwep() );
  }
  if (my_player) {
    say(short(1) + " sighs deeply.\n");
  }
  move( "/room/rubbish", "$N appear$s.",
        "$N disappear$s in a puff of smoke." );
} /* finish_player() */
// --- END [/mnt/home2/grok/lib/obj/monster/greco.c] ---
